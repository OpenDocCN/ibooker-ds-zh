- en: 'Part 2\. Project basics: input and output with Johnny-Five'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分\. 项目基础：使用Johnny-Five进行输入和输出
- en: 'This part of the book is where things really get cooking: you’ll learn how
    to add sensors, outputs, and moving parts to projects, building a whole bunch
    of small experiments along the way with your Arduino Uno board and Johnny-Five.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的这一部分是真正开始烹饪的地方：你将学习如何将传感器、输出和运动部件添加到项目中，在Arduino Uno板和Johnny-Five的帮助下进行一系列小实验。
- en: In [chapter 4](kindle_split_012.html#ch04), you’ll get to know all about inputs
    (sensors), both analog and digital. You’ll try your hand at reading data from
    a simple temperature sensor and a photosensitive resistor, and you’ll learn to
    detect button presses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_012.html#ch04)中，你将了解所有关于输入（传感器）的内容，无论是模拟还是数字。你将尝试从简单的温度传感器和光敏电阻读取数据，并学习检测按钮按下。
- en: '[Chapter 5](kindle_split_013.html#ch05) concerns itself with outputs, building
    on your earlier experimentations with LEDs. You’ll move beyond blinking LEDs to
    animated LEDs and full-color RGB LEDs. You’ll display text on a parallel LCD module
    and build your own “weather ball” (a simplified weather conditions display).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](kindle_split_013.html#ch05)关注输出，基于你之前对LED的实验。你将超越闪烁LED，到动画LED和全彩RGB LED。你将在并行LCD模块上显示文本，并构建自己的“天气球”（简化的天气状况显示）。'
- en: 'If you’ve been waiting for the robots part, [chapter 6](kindle_split_014.html#ch06)
    is it! This chapter is all about motion: motors and servos. We’ll investigate
    how motors work and how to power and control them. At the end of [chapter 6](kindle_split_014.html#ch06),
    you’ll build a simple roving robot using an inexpensive robot chassis kit.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在等待机器人部分，[第6章](kindle_split_014.html#ch06)就是它！这一章全部关于运动：电机和伺服系统。我们将研究电机的工作原理以及如何供电和控制它们。在第6章[结束](kindle_split_014.html#ch06)时，你将使用一个经济实惠的机器人底盘套件构建一个简单的巡游机器人。
- en: By the end of this part of the book, you’ll have surveyed all of the major types
    of simple inputs and outputs for small embedded projects. You’ll be able to read
    environmental data from sensors and output light and sound. You’ll be ready to
    build more sophisticated, wires-free projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分结束时，你将已经调查了小型嵌入式项目中所有主要的简单输入和输出类型。你将能够从传感器读取环境数据，并输出光和声音。你将准备好构建更复杂、无线的项目。
- en: Chapter 4\. Sensors and input
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 传感器和输入
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The role sensors play in projects as *transducers*, converting physical phenomena
    to electrical signals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器在项目中作为*转换器*的作用，将物理现象转换为电信号
- en: How microcontrollers use analog-to-digital conversion (ADC) to interpret incoming
    analog signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微控制器如何使用模数转换（ADC）来解释传入的模拟信号
- en: Building voltage divider circuits to read *resistive sensors* like photoresistors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建分压器电路来读取*电阻传感器*如光敏电阻
- en: Using Johnny-Five’s generic `Sensor` class to read sensor data and listen for
    data and changes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Johnny-Five的通用`Sensor`类读取传感器数据并监听数据和变化
- en: Taking advantage of Johnny-Five’s component-specific `Thermometer` and `Button`
    classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Johnny-Five的特定组件`Thermometer`和`Button`类
- en: Managing default digital logic levels using pull-down resistors
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下拉电阻管理默认数字逻辑电平
- en: To build nifty gadgets, whether they’re temperature-controlled automatic fans
    or more interesting inventions, you’ve got to be able to gather information and
    input from the real, physical world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建巧妙的设备，无论是温度控制的自动风扇还是更有趣的发明，你必须能够从真实物理世界中收集信息和输入。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](tool.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于这一章，你需要以下物品：**'
- en: 1 Arduino Uno and USB cable
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno 和 USB 线
- en: 1 photoresistor
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 光敏电阻
- en: 1 4.7 kV resistor
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 4.7 kΩ 电阻
- en: 1 TMP36 analog temperature sensor
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 TMP36 模拟温度传感器
- en: 1 push button
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 按钮开关
- en: 1 10 kV resistor
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 10 kΩ 电阻
- en: Black, red, and green jumper wires
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑色、红色和绿色跳线
- en: 1 half-size breadboard
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: '![](0082fig01_alt.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](0082fig01_alt.jpg)'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Analog and digital sensors pay attention to a particular phenomenon in the physical
    environment—temperature, brightness, dampness, pressure, vibration—and they output
    information about changes in the intensity of that phenomenon as a signal. In
    the automatic fan example in [chapter 1](kindle_split_008.html#ch01), a temperature
    sensor translated temperature changes into an electrical signal that the microcontroller’s
    firmware could read and process ([figure 4.1](#ch04fig01)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和数字传感器关注物理环境中的特定现象——温度、亮度、湿度、压力、振动——并且输出关于该现象强度变化的信息作为信号。在 [第 1 章](kindle_split_008.html#ch01)
    中的自动风扇示例中，温度传感器将温度变化转换为微控制器固件可以读取和处理（[图 4.1](#ch04fig01)）的电气信号。
- en: Figure 4.1\. The temperature-controlled fan from [chapter 1](kindle_split_008.html#ch01)
    used an analog temperature sensor to gather information about changing temperatures
    in the surrounding environment.
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 来自 [第 1 章](kindle_split_008.html#ch01) 的温度控制风扇使用模拟温度传感器来收集关于周围环境温度变化的信息。
- en: '![](04fig01_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片 04fig01_alt.jpg](04fig01_alt.jpg)'
- en: That conversion from physical input to electrical output means that sensors
    are a type of *transducer*, which is any device that converts one form of energy
    into a signal (or vice versa).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从物理输入到电气输出的转换意味着传感器是一种 *转换器*，它可以将一种形式的能量转换为信号（或反之亦然）。
- en: 'Sensors and inputs are classified based on what kind of signal they produce:
    analog, a continuous, smooth set of values with no gaps, or digital, consisting
    of a discrete, finite set of values ([figure 4.2](#ch04fig02)).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器和输入根据它们产生的信号类型进行分类：模拟，一个连续、平滑的值集，没有间隙，或数字，由离散、有限的值集组成（[图 4.2](#ch04fig02)）。
- en: 'Figure 4.2\. An analog sensor like a temperature sensor (top) transduces changes
    in temperature into a smooth, analog signal. A digital input like a tilt switch
    (bottom) might have as few as two discrete output values: one when oriented normally
    (off, LOW, 0, or false) and one when inverted (on, HIGH, 1, true).'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 类似于温度传感器（顶部）的模拟传感器将温度变化转换为平滑的模拟信号。类似于倾斜开关（底部）的数字输入可能只有两个离散的输出值：一个在正常方向（关闭，LOW，0
    或 false）时，一个在反转（打开，HIGH，1，true）时。
- en: '![](04fig02_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片 04fig02_alt.jpg](04fig02_alt.jpg)'
- en: 4.1\. Working with analog sensors
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 与模拟传感器一起工作
- en: 'Our physical reality is analog: we live in a world of the infinite. There are
    an infinite number of temperatures between 0 and 20 degrees Celsius, an infinite
    number of colors, an infinite number of sound frequencies. Of course, as humans,
    we can’t discern 280.3984 Hz from 280.3985 Hz, but the two different values exist.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的物理现实是模拟的：我们生活在一个无限的世界中。0 到 20 摄氏度之间有无限多的温度，有无限多的颜色，有无限多的声音频率。当然，作为人类，我们无法区分
    280.3984 Hz 和 280.3985 Hz，但这两个不同的值确实存在。
- en: '*Analog sensors* are sensitive to these analog, real-world inputs. Their output
    is a smooth signal, usually of varying voltage that corresponds to the intensity
    of the thing they’re measuring ([figure 4.3](#ch04fig03)).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟传感器* 对这些模拟、现实世界的输入敏感。它们的输出是一个平滑的信号，通常是变化的电压，对应于它们所测量的强度（[图 4.3](#ch04fig03)）。'
- en: Figure 4.3\. The output signal from an analog temperature sensor varies in voltage
    over time as the temperature changes.
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 模拟温度传感器的输出信号随温度变化在电压上变化。
- en: '![](04fig03_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片 04fig03_alt.jpg](04fig03_alt.jpg)'
- en: 4.1.1\. Analog-to-digital conversion
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 模拟到数字转换
- en: Analog sensors like the temperature sensor in the fan provide an analog signal,
    but our programming world is digital. Analog input signals need to somehow be
    sampled and normalized—quantized—into discrete digital values so they can be processed
    with digital logic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于风扇中的温度传感器的模拟传感器提供模拟信号，但我们的编程世界是数字的。模拟输入信号需要以某种方式采样和归一化——量化——为离散的数字值，以便它们可以用数字逻辑进行处理。
- en: Doing this conversion of signal samples from analog to digital requires a bit
    of hardware and processing. The Arduino Uno’s microcontroller provides built-in
    *analog-to-digital conversion* (ADC) capability on six of its pins. Analog input
    pins—those with ADC support—are prefixed with “A” on the Uno ([figure 4.4](#ch04fig04)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号样本从模拟转换为数字的这种转换需要一些硬件和处理。Arduino Uno 的微控制器在其六个引脚上提供了内置的 *模拟到数字转换*（ADC）功能。具有
    ADC 支持的模拟输入引脚在 Uno 上以“A”为前缀（[图 4.4](#ch04fig04)）。
- en: Figure 4.4\. ADC is supported by the ATmega328P microcontroller on specific
    pins (made available as A0-A5 on the Uno). ADCs convert analog signals to discrete
    digital values.
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. ADC 由 ATmega328P 微控制器在特定引脚上支持（在 Uno 上作为 A0-A5 提供）。ADC 将模拟信号转换为离散的数字值。
- en: '![](04fig04_alt.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片 04fig04_alt.jpg](04fig04_alt.jpg)'
- en: The number of possible values that can be derived from an incoming analog signal
    depends on the *bandwidth* of the ADC hardware on the microcontroller. The ATmega328P
    on the Uno provides 10-bit ADC for each of its six enabled pins. That means it
    can resolve 1024 (2^(10)) possible interpreted digital values. An analog input
    of 0 V will be interpreted as 0, 5 V as 1023, and anything between scaled to the
    nearest (integer) step value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入的模拟信号中可以导出的可能值的数量取决于微控制器上ADC硬件的*带宽*。Arduino Uno上的ATmega328P为每个启用的引脚提供10位ADC。这意味着它可以解析1024（2^10）个可能的数字值。0
    V的模拟输入将被解释为0，5 V为1023，任何介于两者之间的值都按比例缩放到最接近的（整数）步进值。
- en: An analog sensor responds to a physical stimulus to which it is sensitive, transducing
    that physical energy into an output signal of varying voltage. That signal can
    be sampled by an analog input pin on a microcontroller and converted to digital
    values using the MCU’s analog-to-digital (ADC) capability. To see how this works
    in action, let’s experiment with a basic analog sensor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟传感器对它敏感的物理刺激做出反应，将这种物理能量转换为电压变化的输出信号。该信号可以通过微控制器的模拟输入引脚进行采样，并使用MCU的模数转换（ADC）功能转换为数字值。为了看到这是如何工作的，让我们通过一个基本的模拟传感器进行实验。
- en: 4.1.2\. Working with photoresistors
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 使用光敏电阻
- en: A *photoresistor*, also called a *photocell* or *light-dependent resistor* (LDR),
    is a simple sensor. Its name gives away that it’s actually a kind of resistor,
    but its conductivity changes depending on the brightness of incident light hitting
    it—it’s *photoconductive*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*光敏电阻*，也称为*光电池*或*光敏电阻器*（LDR），是一种简单的传感器。它的名字揭示了它实际上是一种电阻器，但其导电性取决于照射到它上的入射光的亮度——它是*光电导*的。'
- en: When things are dim, the photoresistor has higher resistance, topping out at
    about 10 kV when it’s totally dark. As the amount of light it’s exposed to increases,
    it becomes more conductive—its resistance decreases—down to about 1 kV when things
    are quite bright ([figure 4.5](#ch04fig05)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当光线较暗时，光敏电阻的电阻更高，在完全黑暗时达到约10 kΩ。随着它所暴露的光量增加，它变得更加导电——其电阻降低——在光线相当明亮时降低到约1 kΩ（[图4.5](#ch04fig05)）。
- en: Figure 4.5\. As light conditions change, the resistance of the photoresistor
    changes. It becomes more conductive—that is, less resistive—when more light hits
    it. When it’s darker, the resistance is higher.
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 随着光照条件的变化，光敏电阻的电阻会变化。当更多的光照射到它时，它变得更加导电——也就是说，电阻更小。当光线较暗时，电阻更高。
- en: '![](04fig05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05.jpg)'
- en: Voltages in a circuit
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 电路中的电压
- en: Let’s say we want to be able to use the Uno’s ADC-capable pin A0 to read a signal
    representing changing ambient light values. We need a circuit that contains the
    photoresistor and that’s connected to power, ground, and pin A0 on the Uno.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要能够使用Arduino Uno的具有ADC功能的引脚A0来读取表示环境光值变化的信号。我们需要一个包含光敏电阻并连接到电源、地以及Arduino
    Uno的引脚A0的电路。
- en: But the circuit shown in [figure 4.6](#ch04fig06) isn’t going to do the trick.
    Remember *Kirchoff’s voltage law* (KVL) from [chapter 3](kindle_split_010.html#ch03)?
    All of the voltage in a circuit has to get used up. The only component in the
    circuit in [figure 4.6](#ch04fig06) that “uses up” any voltage is the photoresistor
    itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但图4.6所示的电路并不能解决问题。还记得[第3章](kindle_split_010.html#ch03)中提到的*基尔霍夫电压定律*（KVL）吗？电路中的所有电压都必须被消耗。在图4.6所示的电路中，唯一“消耗”电压的组件就是光敏电阻本身。
- en: Figure 4.6\. With a circuit like this, there won’t be any meaningful voltage
    variance on pin A0.
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 在这样的电路中，引脚A0上不会出现任何有意义的电压变化。
- en: '![](04fig06_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig06_alt.jpg)'
- en: This means that no matter what the actual resistance value of the photoresistor
    is at any given moment, it’s going to use up all of the voltage in the circuit
    anyway—meaning that the voltage at A0 won’t change.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论光敏电阻在任何给定时刻的实际电阻值是多少，它仍然会消耗电路中的所有电压——这意味着A0的电压不会改变。
- en: In [chapter 3](kindle_split_010.html#ch03), you also saw how current is the
    same at every point in a series circuit. The circuit shown in [figure 4.7](#ch04fig07)
    assumes a 2 V forward voltage drop across the LED, leaving 3 V for the resistors
    to take care of. The total resistance in the circuit is 200 V (the two 100 V resistors
    add together), so
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_010.html#ch03)中，你也看到了在串联电路中电流在每个点都是相同的。图4.7所示的电路假设LED的正向电压降为2
    V，剩下3 V由电阻处理。电路中的总电阻为200 Ω（两个100 Ω电阻相加），所以
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Figure 4.7\. In a series circuit, current is the same at all points.
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7\. 在串联电路中，电流在所有点都是相同的。
- en: '![](04fig07_alt.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07_alt.jpg)'
- en: The current at all points in the circuit will measure 15 mA.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 电路中所有点的电流都将测量为15 mA。
- en: The key thing for figuring out our photoresistor problem here is that voltage
    gets divided up amongst the components in the circuit ([figure 4.8](#ch04fig08))
    and it’s not constant at every point.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们这里的光敏电阻问题的关键是电压在电路中的元件之间分配（[图4.8](#ch04fig08)），并且它不是在每个点都恒定的。
- en: Figure 4.8\. In a series circuit, voltage can differ at different points. Each
    component uses up, or *drops*, its own share of the circuit’s available voltage.
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8。在串联电路中，电压可以在不同的点有所不同。每个元件都会消耗，或者说*下降*电路可用电压的一部分。
- en: '![](04fig08_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08_alt.jpg)'
- en: Let’s tease the circuit in [figure 4.7](#ch04fig07) apart and analyze it to
    see where the voltage is going.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解图4.7中的电路并分析它，看看电压去哪里了。
- en: 2 V of the 5 V supply is getting chewed up by the LED because of its forward
    voltage drop. That leaves 3 V that needs to go...*somewhere*. It gets divided
    up amongst the remaining components in the circuit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 5 V电源中的2 V被LED的正向电压下降消耗。这留下了3 V需要去...*某个地方*。它被分配给电路中剩余的元件。
- en: The amount of voltage allotted to each remaining resistive component—the two
    resistors, R[1] and R[2]—is a ratio of the given component’s resistance to the
    total resistance in the circuit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给每个剩余的电阻元件（两个电阻，R[1]和R[2]）的电压是给定元件的电阻与电路总电阻的比率。
- en: 'Let’s calculate the voltage allotted to R[1]:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算分配给R[1]的电压：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because there are two resistors, and they’re of equal resistance, the remaining
    voltage will be distributed 50–50 between them. The results would be different
    if the resistors had differing values (for example, if R[1] were 300 V and R[2]
    were 100 V, their allotted voltages would be 1.125 V and .375 V respectively).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有两个电阻，并且它们的电阻相等，所以剩余的电压将平均分配给它们，即50-50。如果电阻的值不同（例如，如果R[1]是300 V而R[2]是100 V，它们分配的电压将分别是1.125
    V和0.375 V）。
- en: In the circuit depicted in [figure 4.9](#ch04fig09), the two resistors R[1]
    and R[2] have *equal* resistance—each provides half of the total resistance in
    the circuit. Thus the remaining voltage (3.0 V) in the circuit will get divided
    up equally (50–50) between them—1.5 V each.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.9所示的电路中，两个电阻R[1]和R[2]具有*相等*的电阻——每个电阻提供电路总电阻的一半。因此，电路中剩余的电压（3.0 V）将平均分配给它们，即50-50，每个电阻1.5
    V。
- en: Figure 4.9\. Kirchoff’s voltage law states that adding up all voltages in a
    circuit always produces 0\. That is, all voltage in the circuit needs to be accounted
    for (be used up).
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.9。基尔霍夫电压定律指出，电路中所有电压的总和总是产生0。也就是说，电路中的所有电压都需要被考虑（被消耗）。
- en: '![](04fig09_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig09_alt.jpg)'
- en: 'A more formal way of saying that “all voltage in a circuit needs to get used
    up” is that all voltages in a circuit must add up to 0\. Traveling around the
    circuit in [figure 4.9](#ch04fig09), we start at the power supply: +5 V. Then
    R[1] drops its share, 1.5 V; the LED drops 2.0 V; and R[2] drops 1.5 V. All of
    this adds up to 0:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更正式的说法是，“电路中的所有电压都需要被消耗”，即电路中的所有电压之和必须为0。在图4.9中绕电路走一圈，我们从电源开始：+5 V。然后R[1]下降其份额，1.5
    V；LED下降2.0 V；R[2]下降1.5 V。所有这些加起来等于0：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because we know how much voltage each component in the circuit is using up,
    we can derive the voltage at different points in the circuit ([figure 4.10](#ch04fig10)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道电路中每个元件消耗的电压量，我们可以推导出电路中不同点的电压（[图4.10](#ch04fig10)）。
- en: Figure 4.10\. Voltages at different points in a series circuit vary based on
    how much voltage has been dropped by components in the circuit.
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.10。串联电路中不同点的电压根据电路中元件下降的电压量而变化。
- en: '![](04fig10_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig10_alt.jpg)'
- en: So when there’s only one component in a circuit, it’s going to use up all the
    voltage. If you wired the photoresistor without any other components ([figure
    4.11](#ch04fig11)), it would provide 100% of the resistance in the circuit (technically,
    this isn’t quite true because of a resistor we’ll meet later that’s hidden inside
    the microcontroller, but it’s close enough).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当电路中只有一个元件时，它将消耗所有的电压。如果你将光敏电阻与其他元件一起连接（[图4.11](#ch04fig11)），它将提供电路中100%的电阻（技术上，这并不完全正确，因为我们在微控制器中会遇到一个隐藏的电阻，但足够接近了）。
- en: Figure 4.11\. With only the photoresistor in the circuit, there’s no point of
    reference at which to read measurable voltage changes.
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.11。在电路中只有光敏电阻的情况下，没有参考点可以读取可测量的电压变化。
- en: '![](04fig11_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig11_alt.jpg)'
- en: We need a way to create a circuit that has a point of reference, a point where
    voltage does vary in a predictable way and can be read.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来创建一个具有参考点的电路，一个电压在可预测的方式下变化并可读取的点。
- en: 4.1.3\. Voltage dividers
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3. 分压器
- en: Voltage dividers to the rescue! A voltage divider circuit makes it possible
    to read useful values from the photoresistor. To understand how, let’s first look
    at what a voltage divider is and how it works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分压器来拯救！分压器电路使得从光敏电阻中读取有用值成为可能。为了理解这一点，让我们首先看看什么是分压器以及它是如何工作的。
- en: A *voltage divider* is a circuit that uses a pair of resistors to convert a
    higher supply voltage into a lower output voltage. Although the voltage of the
    circuit as a *whole* is the supply voltage (5 V in our examples), voltage *between*
    the two resistors is a new output voltage ([figure 4.12](#ch04fig12)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*分压器*是一种电路，它使用一对电阻将较高的供电电压转换为较低的输出电压。尽管电路的整体电压是供电电压（在我们的例子中是5 V），但两个电阻之间的电压是一个新的输出电压([图4.12](#ch04fig12))。'
- en: Figure 4.12\. A voltage divider provides a new, lower voltage at V[out], available
    at points between two resistors, R[1] and R[2]. There are several ways to draw
    a voltage divider schematic; the two circuits depicted here are functionally identical.
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.12。分压器在V[out]处提供了一个新的、较低的电压，在两个电阻R[1]和R[2]之间可用。有几种方式可以绘制分压器的电路图；这里展示的两个电路在功能上是相同的。
- en: '![](04fig12_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig12_alt.jpg)'
- en: If the two resistors used in the voltage divider have equal resistance and are
    the only components in the circuit, it’s intuitive that the voltage available
    at V[out] in [figure 4.13](#ch04fig13) will be half of the original supply voltage—R[1]
    drops its proportional share of the supply voltage, 50%, as electricity flows
    across it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分压器中使用的两个电阻具有相同的电阻并且是电路中唯一的组件，那么直观地讲，[图4.13](#ch04fig13)中V[out]处的电压将是原始供电电压的一半——R[1]会降低其相应的供电电压份额，即50%，因为电流流过它。
- en: Figure 4.13\. When R[1] and R[2] are of equal resistance in a circuit, V[out]
    is half of V[in], as each resistor drops 50% of the supply voltage.
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.13。当电路中的R[1]和R[2]具有相同的电阻时，V[out]是V[in]的一半，因为每个电阻都会降低供电电压的50%。
- en: '![](04fig13.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig13.jpg)'
- en: Figure 4.14\. V[out] is 1/5 (20%) of the supply voltage because R[1] provides
    80% of the total resistance in the circuit.
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.14。V[out]是供电电压的1/5（20%），因为R[1]提供了电路总电阻的80%。
- en: '![](04fig14.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig14.jpg)'
- en: On the other hand, if R[2] remained at 100 V but R[1] changed resistance to
    400 V, 80% of the available voltage would be dropped by R[1] ([figure 4.14](#ch04fig14)),
    such that the output voltage at point V[out] is now 20% of the supply voltage.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果R[2]保持在100 V，但R[1]的电阻变为400 V，那么R[1]将降低80%的可用电压([图4.14](#ch04fig14))，这样V[out]处的输出电压现在仅为供电电压的20%。
- en: Voilà! Changes in the proportion of resistance R[1] provides to the circuit
    are reflected as voltage changes at V[out]. There’s the point of reference we
    need!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！电阻R[1]（光敏电阻）提供的电阻比例变化会反映在V[out]处的电压变化上。这就是我们需要的参考点！
- en: Voltage divider formula
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分压器公式
- en: 'The formula for voltage divider circuits—that is, the method for determining
    what voltage will be at V[out] between the two resistors—is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 分压器电路的公式——即确定两个电阻之间V[out]处电压的方法如下：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: V[out] is what’s “left over” of the supply voltage after R[1] has dropped its
    portion of the circuit’s voltage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: V[out]是R[1]降低电路电压份额后剩余的供电电压。
- en: We’ll be using a fixed 4.7 kV resistor as R[2] ([figure 4.15](#ch04fig15)).
    The photoresistor will play the part of R[1]. Its resistance ranges between 1
    kV and 10 kV depending on ambient brightness.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个固定的4.7 kΩ电阻作为R[2]([图4.15](#ch04fig15))。光敏电阻将扮演R[1]的角色。其电阻范围在1 kΩ到10 kΩ之间，具体取决于环境亮度。
- en: Figure 4.15\. The schematic for the photoresistor circuit
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.15。光敏电阻电路的电路图
- en: '![](04fig15.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig15.jpg)'
- en: As the resistance of R[1] (the photoresistor) changes proportionally to the
    circuit’s total resistance, the output voltage on A0 will also vary. We can measure
    that voltage with the Uno and see how the light levels are fluctuating.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 随着R[1]（光敏电阻）的电阻与电路总电阻成比例变化，A0上的输出电压也会变化。我们可以用Arduino Uno测量这个电压，并观察光强的波动。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Calculating the voltage range of V[out]**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算V[out]的电压范围**'
- en: You can calculate the range of possible voltages at V[out] by using the voltage
    divider formula.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用分压器公式来计算V[out]处可能电压的范围。
- en: 'At the photoresistor’s highest resistance, when it’s dark, R[1] will have a
    resistance of 10 kV (remember, R[2] is always 4.7 kV). This higher-resistance
    response to darkness will produce the lowest voltage in the range:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在光敏电阻的最高电阻，即黑暗中，R[1]的电阻为10 kΩ（记住，R[2]始终为4.7 kΩ）。这种对黑暗的高电阻响应将产生该范围内的最低电压：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When it’s bright, R[1]’s lowest possible resistance is 1 kV, resulting in the
    highest voltage in the range:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当明亮时，R[1]可能的最小电阻是1 kΩ，这将产生该范围内的最高电压：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using a voltage divider circuit with the photoresistor, you can create a
    readable output voltage signal for pin A0 that varies from 1.6 V to 4.125 V.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用光敏电阻的电压分压器电路，你可以为A0引脚创建一个可读的输出电压信号，该信号从1.6 V变化到4.125 V。
- en: 4.125 – 1.6 V = 2.525 V, or just slightly more than 50% of the total 0–5 V range.
    That means you’ll get a decent spread of values—ranging from (very roughly) about
    `328` (~1.6 V) to `845` (~4.125 V) of the possible 10-bit (0–1023) range.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 4.125 – 1.6 V = 2.525 V，或者说是总范围0–5 V的略多于50%。这意味着你将获得一个相当宽的值范围——从（非常粗略地）大约`328`
    (~1.6 V) 到`845` (~4.125 V) 的可能10位（0–1023）范围内。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.1.4\. Wiring and using a photoresistor
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 接线和使用光敏电阻
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要的东西
- en: '![](note.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Arduino Uno和USB线
- en: 1 photoresistor
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个光敏电阻
- en: 1 4.7 kV resistor (or 10 kV will also work)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个4.7 kΩ电阻（或10 kΩ也可以）
- en: Red (2), black (2), and green (1) jumper wires
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色（2根）、黑色（2根）和绿色（1根）的跳线
- en: 1 half-size breadboard
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个半尺寸面包板
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Like the other resistors you’ve been working with, photoresistors aren’t polarized,
    so you don’t need to worry about positive-negative orientation. Connect the photocell
    and 4.7 kV resistor to the breadboard as shown in [figure 4.16](#ch04fig16).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你一直在使用的其他电阻一样，光敏电阻不是极化的，因此你不需要担心正负极的朝向。按照[图4.16](#ch04fig16)所示，将光电电池和4.7 kΩ电阻连接到面包板上。
- en: Figure 4.16\. Wiring diagram for the photoresistor voltage divider circuit.
    The jumper wire connected to A0 needs to have its other end connected to V[out],
    between the photoresistor (R[1]) and the 4.7 kV resistor (R[2]).
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.16\. 光敏电阻电压分压器电路的接线图。连接到A0的跳线另一端需要连接到V[out]，在光敏电阻（R[1]）和4.7 kΩ电阻（R[2]）之间。
- en: '![](04fig16_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig16_alt.jpg)'
- en: The voltage divider output, V[out], is available in any terminal-row hole between
    the photocell and the resistor (recall that the five holes in each terminal row
    on the breadboard are electrically connected).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 电压分压器输出，V[out]，在光电电池和电阻之间的任何终端排孔中都可以获得（回想一下，面包板每个终端排的五个孔在电学上是连接的）。
- en: Plug one end of a green jumper wire into one of those holes and the other end
    into pin A0 on the Uno. Hook up power to the power rail from the Uno’s 5 V power
    and GND pins. Now you can put your breadboard aside for a moment and we’ll turn
    to the software side.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将绿色跳线的一端插入其中一个孔中，另一端插入到Uno的A0引脚上。从Uno的5 V电源和GND引脚连接到电源轨。现在你可以暂时把面包板放一边，我们将转向软件方面。
- en: Once the photoresistor circuit is powered (not yet! by the way), a signal of
    varying voltage will be present on pin A0\. So *how* can we read values from that
    signal using our handy Johnny-Five JavaScript framework?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦光敏电阻电路通电（顺便说一句，目前还没有！），A0引脚上将会出现一个变化的电压信号。那么我们如何使用我们手头的Johnny-Five JavaScript框架从这个信号中读取值呢？
- en: Processing analog sensor input with Johnny-Five
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Johnny-Five处理模拟传感器输入
- en: Johnny-Five’s API contains a collection of classes that can be used to interact
    with your development board and components. You’ve seen `Led`, for example. Many
    of the component classes, like `Led`, are for specific types of devices, such
    as `Accelerometer` and `Servo`. There are also a few more generic classes that
    have broader use, including one that can be used with analog sensors like the
    `Sensor` photoresistor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的API包含了一组可以用来与你的开发板和组件交互的类。例如，你已经看到了`Led`。许多组件类，如`Led`，是为特定类型的设备设计的，例如`Accelerometer`和`Servo`。还有一些更通用的类，用途更广泛，包括一个可以与模拟传感器如`Sensor`光敏电阻一起使用的类。
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Keeping up to date with the Johnny-Five API
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保持Johnny-Five API更新
- en: Johnny-Five, like much other open source software, is constantly evolving. New
    features and classes get added, and the API evolves as well. You can keep up to
    date with the current Johnny-Five API at [http://johnny-five.io/api](http://johnny-five.io/api).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five，像许多其他开源软件一样，一直在不断进化。新功能和类被添加，API也在不断演变。你可以在[http://johnny-five.io/api](http://johnny-five.io/api)上了解最新的Johnny-Five
    API。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using Johnny-Five’s Sensor class
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Johnny-Five的Sensor类
- en: The `Sensor` class can be used to read and process data from analog sensors.
    First, create a new `Sensor` object in a Johnny-Five Node.js script, as shown
    in the next listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sensor` 类可以用来读取和处理模拟传感器的数据。首先，在 Johnny-Five Node.js 脚本中创建一个新的 `Sensor` 对象，如下一列表所示。'
- en: Listing 4.1\. Instantiating a new `Sensor` object with Johnny-Five
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 使用 Johnny-Five 实例化一个新的 `Sensor` 对象
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* When instantiating a Sensor, “pin” is the only required property for
    the passed options object.**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当实例化 Sensor 时，“pin”是传递的选项对象中唯一的必需属性。**'
- en: The internals of `Sensor` take care of configuring the indicated `pin` as an
    analog input pin and then automatically and continuously reading ADC data from
    that pin.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sensor` 的内部机制负责将指定的 `pin` 配置为模拟输入引脚，然后自动且连续地从该引脚读取 ADC 数据。'
- en: So what can you do with a `Sensor` object? You could log out its value, as the
    following listing shows—`value` is one of several parameters available on `Sensor`
    objects, and it holds the most recently read value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可以用 `Sensor` 对象做什么呢？你可以像以下列表所示那样记录它的值——“value”是 `Sensor` 对象上可用的几个参数之一，它保存最近读取的值。
- en: Listing 4.2\. Logging a sensor’s value
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 记录传感器的值
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* This will only log once (ready event fires once).**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这只会记录一次（就绪事件只会触发一次）。**'
- en: But the code in [listing 4.2](#ch04ex02) will only log the value of the sensor
    once—that’s of limited use. It’s much more useful to look at sensor values over
    time. This is a job for event-driven JavaScript.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但 [列表 4.2](#ch04ex02) 中的代码只会记录传感器的值一次——这用途有限。查看传感器随时间变化的数据要更有用。这是事件驱动 JavaScript
    的用武之地。
- en: The Sensor data event in Johnny-Five
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Johnny-Five 中的传感器数据事件
- en: Different objects in Johnny-Five provide different events that your code can
    bind to. You can handle these events, when they occur, using a callback function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five 中的不同对象提供了不同的事件，你的代码可以绑定到这些事件上。你可以使用回调函数来处理这些事件，当它们发生时。
- en: The `Sensor` class, for example, has a `data` event that gets triggered every
    time the pin’s value is read successfully, as shown in the next listing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Sensor` 类有一个 `data` 事件，每当读取引脚的值成功时都会触发，如下一列表所示。
- en: Listing 4.3\. Logging values using the `data` event
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 使用 `data` 事件记录值
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* The data event is fired every time a value is successfully read from
    the pin.**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每当从引脚成功读取值时，都会触发数据事件。**'
- en: Trying out the photoresistor
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试使用光敏电阻
- en: Let’s put together our voltage-divider-enhanced photoresistor circuit with some
    Johnny-Five code to sense changes in surrounding light conditions. Create a new
    file, photoresistor.js, and populate it with the following code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些 Johnny-Five 代码来组合我们的电压分压器增强型光敏电阻电路，以检测周围光条件的变化。创建一个新文件，photoresistor.js，并填充以下代码。
- en: Listing 4.4\. Photoresistor.js
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. Photoresistor.js
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Plug in the Arduino’s USB cable to your computer—now the board and breadboard
    circuit have power. Execute the photoresistor script:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Arduino 的 USB 线缆插入您的计算机——现在板子和面包板电路都有电了。执行光敏电阻脚本：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the script is running, increase and decrease the amount of light reaching
    the photoresistor by placing your hand over it or dimming the lights. As you do
    this, you should see the values in the logged output change, which will look something
    like the following.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本开始运行，通过将手放在光敏电阻上或调暗灯光来增加和减少到达光敏电阻的光量。当你这样做的时候，你应该会看到记录输出的值发生变化，看起来如下所示。
- en: Listing 4.5\. Photoresistor data logging output
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 光敏电阻数据记录输出
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adjusting frequency, scale, and threshold
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调整频率、比例和阈值
- en: Photoresistor values are scrolling by awfully fast. By default, `Sensor` will
    read, calculate, and scale ADC data once every 25 ms. That’s why your photoresistor
    value logging is scrolling by so briskly. It’s possible to adjust the frequency
    of these reads with the `freq` parameter, as the following listing shows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 光敏电阻的值滚动得太快了。默认情况下，`Sensor` 将每 25 毫秒读取、计算和缩放 ADC 数据。这就是为什么你的光敏电阻值记录滚动得如此之快。你可以通过
    `freq` 参数调整这些读取的频率，如下一列表所示。
- en: Listing 4.6\. Sensor `freq` parameter
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 传感器 `freq` 参数
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Values are in milliseconds: this will read once per second.**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 值以毫秒为单位：这将每秒读取一次。**'
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Johnny-Five event binding and `this`**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Johnny-Five 事件绑定和 `this`**'
- en: '`Sensor` object events bind `this` to the `Sensor` object, meaning that you
    could write code like the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sensor` 对象的事件将 `this` 绑定到 `Sensor` 对象，这意味着你可以编写如下代码：'
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that because of the binding that happens with arrow functions used as
    anonymous callbacks, the following won’t work:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于使用了箭头函数作为匿名回调函数的绑定，以下代码将不起作用：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A more elegant approach is to bind to the `change` event instead of the `data`
    event. The `change` event is fired whenever the sensor’s most recent value differs
    by more than a threshold amount from the previously read value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更优雅的方法是绑定到`change`事件而不是`data`事件。每当传感器的最新值与之前读取的值差异超过阈值时，都会触发`change`事件。
- en: The `threshold` value defaults to `1`, which means that—because read sensor
    values are integers—any change in value will trigger the `change` event. `threshold`
    is an attribute on the `Sensor` object instance and can be changed at any point
    to alter the threshold for triggering `change` events. The following listing combines
    this into a script that logs out any time the sensor changes value by `5` or more
    (remember, possible values range from 0 to 1023).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`threshold`值默认为`1`，这意味着——因为读取的传感器值是整数——任何值的改变都会触发`change`事件。`threshold`是`Sensor`对象实例上的一个属性，可以在任何时刻更改以改变触发`change`事件的阈值。以下列表将此结合成一个脚本，该脚本会在传感器值变化`5`或更多时记录下来（记住，可能的值范围从0到1023）。'
- en: Listing 4.7\. Logging changing photoresistor values
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 记录变化的电阻值
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Logs out the sensor’s initial value**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录传感器的初始值**'
- en: '***2* You can adjust the threshold attribute; default is 1**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 可以调整阈值属性；默认为1**'
- en: '***3* change fires when value changes by >= threshold**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当值变化≥阈值时触发change**'
- en: Because the actual voltage at V[out] for the photoresistor circuit will vary
    depending on what resistor is used at R[2], the photoresistor’s changing values
    are more relative (it’s getting brighter, it’s getting darker) than absolute (in
    foot-candles or whatever light intensity is measured in). Other kinds of sensors
    provide a calibrated output voltage that can be directly converted into fixed
    units, like degrees Celsius in the case of analog temperature sensors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于光敏电阻电路在V[out]的实际电压将根据R[2]中使用的电阻而变化，因此光敏电阻的值变化更相对（它变得更亮，它变得更暗），而不是绝对（以英尺烛光或测量的光强度）。其他类型的传感器提供校准后的输出电压，可以直接转换为固定单位，例如模拟温度传感器的情况下的摄氏度。
- en: 4.1.5\. Using an analog temperature sensor
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5\. 使用模拟温度传感器
- en: 'The TMP36 is an analog temperature sensor manufactured by Analog Devices. It’s
    plentiful, cheap, and easy to work with. Like other analog sensors, it provides
    a signal of varying voltage. You don’t have to build a voltage divider to use
    it, though: it provides a varying output voltage on a third pin. All you have
    to do is connect the sensor to +5 V and ground, and then read the voltage on the
    third, output-voltage pin ([figure 4.17](#ch04fig17)).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TMP36是由Analog Devices制造的模拟温度传感器。它很丰富，价格便宜，易于使用。与其他模拟传感器一样，它提供变化的电压信号。不过，您不需要构建分压器来使用它：它在第三个引脚上提供变化的输出电压。您只需将传感器连接到+5
    V和地，然后读取第三个输出电压引脚上的电压（[图4.17](#ch04fig17)）。
- en: Figure 4.17\. The schematic for the TMP 36 circuit
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.17\. TMP 36电路的原理图
- en: '![](04fig17.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![04fig17.jpg](04fig17.jpg)'
- en: With the TMP36 and other similar analog temperature sensors, the output voltage
    can be used to calculate a “real” temperature value. The TMP36 sensor’s voltage
    increases linearly with temperature—given a voltage reading from the TMP36, the
    Celsius temperature can be obtained by multiplying the current voltage by 100
    and subtracting 50\. For example, if the output voltage from the sensor is 0.7
    V,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TMP36和其他类似模拟温度传感器，输出电压可以用来计算“真实”的温度值。TMP36传感器的电压随温度线性增加——给定TMP36的电压读取值，可以通过将当前电压乘以100并减去50来获得摄氏温度。例如，如果传感器的输出电压为0.7
    V，
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To perform this calculation, however, you’d need to convert the ADC 10-bit reading
    back into (approximate) voltage and also put the arithmetic into your code. To
    make this convenient for us, Johnny-Five offers the `Thermometer` class, which
    supports a number of different kinds of temperature sensors.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要执行此计算，您需要将ADC 10位读取值转换回（近似）电压，并将算术运算放入您的代码中。为了使我们更方便，Johnny-Five提供了`Thermometer`类，它支持多种不同类型的温度传感器。
- en: 'Building the circuit: TMP36 temperature sensor'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路：TMP36温度传感器
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![note.jpg](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno和USB线
- en: 1 TMP36 sensor
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 TMP36传感器
- en: 1 half-size breadboard
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: Red (2), black (2), and green (1) jumper wires
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色（2）、黑色（2）和绿色（1）的跳线
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The circuit for the TMP36 is shown in [figure 4.18](#ch04fig18). Connect the
    TMP36 to power using red and black jumper wires, and then connect its output (middle)
    pin to A0 with a green jumper wire.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: TMP36 的电路如图 4.18 所示。[图 4.18](#ch04fig18)。使用红色和黑色跳线将 TMP36 连接到电源，然后使用绿色跳线将其输出（中间）引脚连接到
    A0。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Don’t plug the TMP36 in backwards!
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不要将 TMP36 反向插入！
- en: TMP36 sensors don’t like to be plugged in backwards. Make sure you check the
    orientation of the flat side of the sensor when placing it into the circuit. After
    applying power to your circuit, touch the TMP36 sensor. If it feels unpleasantly
    hot to the touch—uh oh! Disconnect power immediately and check the sensor’s orientation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: TMP36 传感器不喜欢被反向插入。确保你在将其放入电路时检查传感器的平面侧。在给电路施加电源后，触摸 TMP36 传感器。如果它摸起来不舒服地热——哎呀！立即断开电源并检查传感器的方向。
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 4.18\. Wiring the TMP36 sensor
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.18\. 连接 TMP36 传感器
- en: '![](04fig18_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig18_alt.jpg)'
- en: Logging and inspecting TMP36 data
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录和检查 TMP36 数据
- en: Instantiating a `Thermometer` object is similar to using the `Sensor` class,
    but it needs information about what kind of temperature sensor (`controller`)
    is being used. A simple example of logging temperature is shown in the following
    listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个 `Thermometer` 对象类似于使用 `Sensor` 类，但它需要有关正在使用的温度传感器（控制器）的信息。以下列表展示了记录温度的简单示例。
- en: Listing 4.8\. temperature.js
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. temperature.js
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Thermometer requires a controller parameter—about 15 different temperature
    sensors are supported.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Thermometer 需要一个控制器参数——支持大约 15 种不同的温度传感器。**'
- en: '***2* Like Sensor, Thermometer needs to know which pin it’s on.**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 与 Sensor 类似，Thermometer 需要知道它所在的引脚。**'
- en: '***3* celsius, fahrenheit, and kelvin are all attributes on Thermometer instances.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* celsius、fahrenheit 和 kelvin 都是 Thermometer 实例的属性。**'
- en: Interacting with components using the Johnny-Five REPL
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Johnny-Five REPL 与组件交互
- en: When a Johnny-Five script is running, you can interact with it in your terminal
    window. Or, you *could*, if all that `console.log` stuff wasn’t scrolling by.
    Sometimes `console.log` is all you need, but for more convenient debugging or
    inspection without having to restart the script or change the code, you can take
    advantage of Johnny-Five’s REPL (read-evaluate-print loop).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Johnny-Five 脚本运行时，你可以在终端窗口中与之交互。或者，你 *可以*，如果所有那些 `console.log` 东西没有滚动过去的话。有时
    `console.log` 就是你所需要的，但为了更方便的调试或检查，而无需重新启动脚本或更改代码，你可以利用 Johnny-Five 的 REPL（读取-评估-打印循环）。
- en: If you removed the `console.log`-ing `data` event handler from temperature.js
    and executed the script, you’d see something like the following.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 temperature.js 中移除了 `console.log` 的 `data` 事件处理程序并执行了脚本，你会看到如下所示的内容。
- en: Listing 4.9\. Johnny-Five’s REPL
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. Johnny-Five 的 REPL
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can type JavaScript expressions at the double-arrow prompt and press Enter
    on your keyboard—it’s an interactive prompt. Maybe you want to see what the value
    of the `tmp36` temperature sensor is, in Fahrenheit, as shown in the next listing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在双箭头提示符处输入 JavaScript 表达式，然后按键盘上的 Enter 键——这是一个交互式提示符。也许你想查看 TMP36 温度传感器的华氏值，如下列表所示。
- en: Listing 4.10\. What if you want to get information from a Johnny-Five component...?
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 如果你想从 Johnny-Five 组件获取信息...？
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This isn’t game over; we just missed a step. “Injecting” something into the
    scope of Johnny-Five’s REPL requires us to be explicit about it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是游戏结束；我们只是错过了一步。“注入”某物到 Johnny-Five 的 REPL 范围内需要我们明确指出。
- en: Within your Johnny-Five script, you can selectively inject things into the REPL
    that you’d like to have available for inspection or manipulation when the script
    is running, as shown in the next listing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Johnny-Five 脚本中，你可以选择性地将你希望在脚本运行时可用于检查或操作的项目注入到 REPL 中，如下一列表所示。
- en: Listing 4.11\. Injecting into the REPL
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 注入到 REPL 中
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Things are injected into the REPL as key-value pairs.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 事物作为键值对注入到 REPL 中。**'
- en: '***2* This makes the tmp36 object reference available (as tmp36).**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这使得 tmp36 对象引用可用（作为 tmp36）。**'
- en: '***3* This makes the string ‘bar’ available as foo.**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这使得字符串 ''bar'' 可作为 foo 使用。**'
- en: Making the string `'bar'` available as `foo` is kind of silly, but the point
    is that you can make any kind of value you like available from within the REPL.
    You can then use the REPL as a console for interacting with these items, as the
    following listing shows.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串 `'bar'` 作为 `foo` 可用有点愚蠢，但重点是你可以从 REPL 内部使任何类型的值可用。然后你可以使用 REPL 作为与这些项目交互的控制台，如下列表所示。
- en: Listing 4.12\. Altering temperature.js to use REPL injection
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 修改 temperature.js 以使用 REPL 注入
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when you run `node temperature.js`, you won’t see data logging by, but
    you’ll get a REPL prompt once the board is initialized. Then you can interact
    with the `tmp36` object. Try typing this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 `node temperature.js` 时，你将不会看到通过 `tmp36` 对象的数据记录，但一旦板子初始化完成，你将得到一个 REPL
    提示符。然后你可以与 `tmp36` 对象交互。尝试输入以下内容：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样做：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This can come in handy, especially when debugging or exploring more complex
    components.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调试或探索更复杂的组件时非常有用。
- en: The photoresistor is a good fit for measuring relative changes to an environmental
    stimulus—it’s brighter, now it’s dimmer, now it’s brighter again. The TMP36 sensor
    is a good fit for measuring environmental stimulus as fixed units—degrees Celsius
    or Fahrenheit. Both produce voltage signals of infinite analog resolution (in
    theory, at least), and the range of values available for software processing is
    defined by the microcontroller’s ADC (10-bit, in the Uno’s case).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 光敏电阻非常适合测量环境刺激的相对变化——它现在更亮，现在更暗，现在又亮了。TMP36 传感器非常适合测量作为固定单位的环境刺激——摄氏度或华氏度。两者都产生无限模拟分辨率的电压信号（至少在理论上是这样），可用于软件处理的值范围由微控制器的
    ADC（在 Uno 的情况下为 10 位）定义。
- en: For some types of environmental sensing, though, you don’t need a continuous
    set of values as input. For these types of applications, you can use components
    that generate digital signals.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于某些类型的环境感应，你不需要连续的值作为输入。对于这些类型的应用，你可以使用生成数字信号的组件。
- en: 4.2\. Digital inputs
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 数字输入
- en: Pins 0 through 13 on the Uno are digital pins. Each can be configured as either
    an input pin or an output pin. When configured for input, a digital pin can evaluate,
    based on the voltage present, whether it’s in a HIGH or LOW logical state.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Uno 上，引脚 0 到 13 是数字引脚。每个引脚都可以配置为输入引脚或输出引脚。当配置为输入时，数字引脚可以根据存在的电压判断其处于高逻辑状态还是低逻辑状态。
- en: 'Buttons and some switches are good examples of components that provide simple
    digital signals because they are binary. A button is either pressed or it isn’t:
    it’s on or it’s off. This corresponds to digital input pins, whose states are
    also binary (LOW or HIGH).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮和一些开关是提供简单数字信号的组件的好例子，因为它们是二进制的。按钮要么被按下，要么没有被按下：它是开启还是关闭。这对应于数字输入引脚，其状态也是二进制的（低或高）。
- en: 4.2.1\. Using a button as a digital input
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 使用按钮作为数字输入
- en: Our challenge is to construct a circuit that correctly causes a digital pin
    to be in a HIGH state when a push button (a.k.a. *momentary switch*) is pressed,
    but in a LOW state otherwise. That way, our software can determine when a button
    is being pressed and do something with that information.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的挑战是构建一个电路，当按下按钮（也称为*瞬态开关*）时，正确地使数字引脚处于高状态，否则处于低状态。这样，我们的软件就可以确定何时按下按钮，并利用这些信息做些事情。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Push-button connection refresher**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**按钮连接复习**'
- en: Pins that share one side of a push button are only electrically connected when
    the button is pressed. But pins on opposite sides of the button are always electrically
    connected.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮按下时，共享按钮一侧的引脚才电连接。但按钮另一侧的引脚始终电连接。
- en: '![](0102fig01_alt.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![0102fig01_alt.jpg](0102fig01_alt.jpg)'
- en: The pin connections of a typical push button
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 典型按钮的引脚连接
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Understanding logic levels
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解逻辑电平
- en: The Arduino’s microcontroller determines whether a given digital input pin is
    HIGH or LOW based on the voltage present on the pin at the time that it’s read.
    As you might expect in the Uno’s case, 5 V present on an input pin will make it
    logically HIGH and 0 V makes it logically LOW. There’s some nuance here you need
    to know about, however, because it will affect the design of the button circuit.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 的微控制器根据读取时引脚上的电压确定给定的数字输入引脚是高还是低。正如你所预期的，在 Uno 的情况下，输入引脚上的 5 V 将使其逻辑上为高，而
    0 V 使其逻辑上为低。然而，这里有一些你需要知道的细微差别，因为它将影响按钮电路的设计。
- en: Let’s say you have a configured digital input pin on the Arduino but have nothing
    connected to it yet. What state would you expect the pin to have if you read its
    value? Turns out, it’s impossible to predict. Could be HIGH, could be LOW. If
    you read it over time, you’d see LOWs and HIGHs pretty much at random. This kind
    of disconnected behavior is called *floating*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在 Arduino 上有一个配置好的数字输入引脚，但还没有连接任何东西。如果你读取它的值，你期望引脚处于什么状态？结果，这是不可能预测的。可能是高，可能是低。如果你长时间读取，你会看到随机的高和低。这种未连接的行为被称为*浮动*。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Voltages and logic levels**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**电压和逻辑电平**'
- en: A digital pin doesn’t have to have exactly 5 V present to read HIGH. Similarly,
    low voltage of, say, 0.8 V, will result in a logical LOW. Each microcontroller
    has a set of voltage ranges that will result in a LOW state or a HIGH state, as
    well as a *noise margin* in the middle.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 数字引脚不需要精确的5 V电压来读取HIGH。同样，低电压，比如0.8 V，将导致逻辑LOW。每个微控制器都有一组电压范围，这些范围会导致LOW状态或HIGH状态，以及中间的*噪声边缘*。
- en: '![](0103fig01_alt.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](0103fig01_alt.jpg)'
- en: Voltage ranges for logical states on Arduino Uno pins. Any voltage below 1.5
    V is LOW; anything above 3 V, HIGH. Voltages between 1.5 V and 3 V fall in the
    noise margin and should be avoided.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Uno引脚上逻辑状态的电压范围。任何低于1.5 V的电压都是LOW；任何高于3 V的电压都是HIGH。介于1.5 V和3 V之间的电压处于噪声边缘，应避免使用。
- en: In the case of the Uno’s ATmega 328P, input voltages from about 0–1.5 V will
    result in a LOW state, whereas voltages greater than 3 V will read HIGH.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Arduino Uno的ATmega 328P，大约0–1.5 V的输入电压将导致LOW状态，而高于3 V的电压将读取HIGH。
- en: '|  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This comes about because of the pin’s *high impedance*, in which it takes just
    a teeny-tiny amount of current to move the pin between one logic level and the
    other. This is a useful and efficient thing—the pin can detect changes in connected
    components without needing to waste a lot of current to do so. Yet little blips
    commonly arising from electrical noise in the environment or interference from
    other pins on the same microcontroller are enough to make the pin swap around
    between LOW and HIGH basically at random.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为引脚的*高阻抗*，只需极小的电流就可以将引脚在逻辑电平之间移动。这是一件有用且高效的事情——引脚可以在不浪费大量电流的情况下检测连接组件的变化。然而，来自环境中的电气噪声或同一微控制器上其他引脚的干扰通常足以使引脚在LOW和HIGH之间随机切换。
- en: Wiring a button with a pull-down resistor
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用下拉电阻连接按钮
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Arduino Uno和USB线
- en: 1 push button
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个按钮
- en: 1 10 kV resistor
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个10 kΩ电阻
- en: 4 jumper wires
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4根跳线
- en: 1 half-size breadboard
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个半尺寸面包板
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What we need to do is build a safe circuit (one that doesn’t have a risk of
    a short circuit) that establishes a reliable “default” logic level when the button
    isn’t pressed—LOW or HIGH, but one that won’t flop around randomly. One way this
    can be done is by *pulling* the input pin to ground (0 V) with the aid of an additional
    resistor.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是构建一个安全的电路（一个没有短路风险的电路），当按钮未按下时，它能够建立一个可靠的“默认”逻辑电平——LOW或HIGH，但不会随机波动。实现这一点的其中一种方法是通过额外的电阻将输入引脚拉至地（0
    V）。
- en: When a *pull-down resistor* is present in the circuit, there’s always a connection
    between pin 2 and ground, even when the button isn’t pressed ([figure 4.19](#ch04fig19)).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当电路中存在*下拉电阻*时，引脚2和地之间始终存在连接，即使按钮未按下（[图4.19](#ch04fig19)）。
- en: Figure 4.19\. A pull-down resistor “pulls” the digital pin to logical LOW when
    the component (button) isn’t pushed (connected).
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.19\. 当组件（按钮）未被按下（连接）时，下拉电阻将数字引脚拉至逻辑LOW。
- en: '![](04fig19_alt.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig19_alt.jpg)'
- en: This takes care of the floating problem—if any stray current shows up uninvited
    when the button isn’t pressed, it’ll get wicked away to ground through the resistor
    (left side of [figure 4.19](#ch04fig19)). Pin 2 will continuously read LOW (0
    V) when the button isn’t pressed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了浮空问题——如果按钮未按下时出现任何意外的杂散电流，它将通过电阻（[图4.19](#ch04fig19)的左侧）流向地。当按钮未按下时，引脚2将连续读取LOW（0
    V）。
- en: 'When the button is pressed (right side of [figure 4.19](#ch04fig19)), current
    flows at 5 V through the button, and then into both pin 2 and ground—pin 2 will
    read HIGH. The pull-down resistor performs another role here: it prevents a short
    circuit when the button is pressed, limiting the current that flows.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时（[图4.19](#ch04fig19)的右侧），电流以5 V的电压通过按钮，然后流入引脚2和地——引脚2将读取HIGH。下拉电阻在这里还扮演另一个角色：它防止按钮按下时的短路，限制流过的电流。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A current divider in disguise**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪装成电流分压器**'
- en: When using a pull-down resistor in the circuit, you’ll actually be creating
    a current divider, even though it’s not immediately obvious. Remember from [chapter
    3](kindle_split_010.html#ch03) that current division is a feature of parallel
    circuits (the circuit in the figure is a parallel circuit because there’s more
    than one path an individual charge could take). When there’s more than one path
    to choose, current will split up proportionally based on the resistance in each
    path.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当在电路中使用下拉电阻时，你实际上是在创建一个电流分压器，尽管这并不立即明显。记得从[第3章](kindle_split_010.html#ch03)中，电流分压是并联电路（图中的电路是并联电路，因为有一个以上的路径供单个电荷通过）的特性。当有多个路径可供选择时，电流将根据每条路径的电阻成比例地分裂。
- en: '![](0105fig01_alt.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](0105fig01_alt.jpg)'
- en: Using a pull-down resistor in combination with an input pin actually creates
    a current divider.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下拉电阻与输入引脚结合实际上创建了一个电流分压器。
- en: Internally, microcontroller pin circuitry includes a resistor with high resistance
    (on the order of 100 kV to several megohms) when a pin is configured for input
    (high impedance state). This internal resistor will play the part of R[2]. For
    R[1], we have the 10 kV pull-down resistor—high resistance, but about an order
    of magnitude less resistant than the internal resistor (R[2]).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，当引脚配置为输入（高阻抗状态）时，微控制器引脚电路包括一个高电阻（大约100 kV到几个兆欧姆）的电阻。这个内部电阻将扮演R[2]的角色。对于R[1]，我们有10
    kV的下拉电阻——高电阻，但比内部电阻（R[2]）低一个数量级。
- en: When current flows through the circuit (the button is pressed), a whole lot
    more of it will go through the 10 kV (R[1]) resistor’s path than the path with
    the internal resistor (R[2]).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当电流通过电路（按钮被按下）时，大部分电流将通过10 kV（R[1]）电阻的路径，而不是内部电阻（R[2]）的路径。
- en: In a current divider, each path gets a different current allotment, but both
    get the same voltage. The bit of current that does reach pin 2 is at or near 5
    V, which will set the pin to HIGH.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在电流分压器中，每条路径得到不同的电流分配，但两者得到相同的电压。到达引脚2的那一小部分电流在或接近5 V，这将使引脚设置为HIGH。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The resulting wiring diagram ([figure 4.20](#ch04fig20)) isn’t too complex.
    Go ahead and wire the button on the breadboard as shown, making sure to connect
    a 10 kV resistor between pin 2 and ground.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的接线图（[图4.20](#ch04fig20)）并不复杂。请按照所示在面包板上连接按钮，确保在引脚2和地之间连接一个10 kV电阻。
- en: Figure 4.20\. The button circuit with a 10 kV pull-down resistor
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.20\. 带有10 kV下拉电阻的按钮电路
- en: '![](04fig20_alt.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig20_alt.jpg)'
- en: Johnny-Five’s Button class
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Johnny-Five的按钮类
- en: Johnny-Five’s `Button` class takes care of configuring a digital output pin
    and provides several features that you’d want in a button, including the ability
    to listen for button pushes, as shown in the next listing.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的`Button`类负责配置数字输出引脚，并提供你希望在按钮中拥有的几个功能，包括监听按钮按下的能力，如下一列表所示。
- en: Listing 4.13\. button.js
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.13\. button.js
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Try out the code in [listing 4.13](#ch04ex13). Connect your Arduino to USB
    power and run the script:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行[列表4.13](#ch04ex13)中的代码。将你的Arduino连接到USB电源并运行脚本：
- en: '[PRE25]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the board is initialized, every time you press the button down, you should
    see this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了板子，每次按下按钮，你应该看到这个：
- en: '[PRE26]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this chapter, you’ve seen a few flavors of basic inputs: two kinds of analog
    sensors and digital input with a push button. Inputs and sensors are vital for
    gathering information about the physical environment, but it gets considerably
    more fun when you actually do something with that information—when you create
    output. That’s what you’ll be doing next.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了几种基本输入的类型：两种类型的模拟传感器和带有按钮的数字输入。输入和传感器对于收集有关物理环境的信息至关重要，但当你实际上使用这些信息时，这会变得相当有趣——当你创建输出时。这就是你接下来将要做的。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Analog sensors generate signals of varying voltage with (theoretically) infinite
    resolution, and microcontrollers convert this signal to digital value equivalents
    using analog-to-digital (ADC) conversion.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟传感器生成具有（理论上）无限分辨率的电压信号，微控制器使用模数转换（ADC）将此信号转换为数字值等效。
- en: 'The Arduino Uno has six analog input pins, which provide 10-bit ADC (1024 values).
    Its 14 digital pins can be configured as either input or output and have binary
    logic levels: LOW or HIGH.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno有六个模拟输入引脚，提供10位ADC（1024个值）。它的14个数字引脚可以配置为输入或输出，并具有二进制逻辑电平：LOW或HIGH。
- en: Each component in a series circuit receives the same amount of current, but
    voltage is apportioned based on the component’s proportional resistance. A *voltage
    divider* uses this principle to convert a higher input voltage into a lower output
    voltage, using two resistors wired in series.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串联电路中的每个元件都会接收到相同数量的电流，但电压是根据元件的电阻比例分配的。*分压器*利用这一原理将较高的输入电压转换为较低的输出电压，通过串联两个电阻来实现。
- en: A voltage divider circuit creates a point of reference at which you can detect
    changes in resistance as changes in voltage. This approach can be used to read
    data from resistive sensors like a photoresistor.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分压器电路在参考点处创建一个可以检测电阻变化作为电压变化的点。这种方法可以用来读取光敏电阻等电阻传感器的数据。
- en: Classes like `Sensor`, `Thermometer`, and `Button` in Johnny-Five or equivalent
    higher-level JavaScript frameworks can add convenience by abstracting away pin
    configuration and tedious calculations and providing relevant events to bind to.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Johnny-Five 或等效的更高级 JavaScript 框架中的 `Sensor`、`Thermometer` 和 `Button` 类可以通过抽象掉引脚配置和繁琐的计算，并提供相关事件来绑定，从而增加便利性。
- en: Each branch in a parallel circuit receives the same amount of voltage, but current
    is apportioned based on the branch’s proportional resistance. A *current divider*
    uses this principle by using resistors wired in parallel.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并联电路中的每个分支都会接收到相同的电压，但电流是根据分支的电阻比例分配的。*电流分压器*通过使用并联电阻来应用这一原理。
- en: Using a pull-down resistor is one way to avoid a floating situation of indeterminate
    logic level when digital inputs are disconnected or inactive.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下拉电阻是避免在数字输入断开或未活动时出现不确定逻辑电平浮动状态的一种方法。
- en: 'Chapter 5\. Output: making things happen'
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章\. 输出：让事物发生
- en: '*This chapter covers*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Mastering more advanced LED-controlling techniques—animating LEDs and using
    full-color RGB LEDs
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握更高级的 LED 控制技术——动画 LED 和使用全色 RGB LED
- en: Using pulse-width modulation (PWM) support to make digital output signals behave
    more like analog output signals
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脉冲宽度调制（PWM）支持使数字输出信号表现得更像模拟输出信号
- en: The basics of bitshifting and binary operations in JavaScript
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中位运算和二进制操作的基础
- en: Integrating a third-party weather API to create a multi-colored LED “weather
    ball” gadget
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成第三方天气 API 以创建多色 LED “天气球”装置
- en: Wiring up and controlling a parallel LCD module with Johnny-Five and the Uno
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Johnny-Five 和 Uno 连接和控制并行 LCD 模块
- en: Combining multiple input and output components to build an advanced timer device
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合多个输入和输出组件构建高级计时器设备
- en: Making noises and playing tunes with piezo components and Johnny-Five
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用压电元件和 Johnny-Five 制作噪音和播放曲调
- en: Now it’s time to do something noisy. Or something bright. Or something blinky
    or expressive. You’ve tried out a few basic LED tricks, but now we’re going to
    take a more comprehensive look at some of the ways you can integrate *outputs*
    into projects.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候做一些嘈杂的、明亮的、闪烁的或富有表现力的东西了。你已经尝试了一些基本的 LED 技巧，但现在我们将更全面地探讨一些可以将*输出*集成到项目中的方法。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](tool.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![tool.jpg](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下物品：**'
- en: Arduino Uno and USB cable
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno 和 USB 线
- en: 2 standard LEDs, any color
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个标准 LED，任何颜色
- en: 1 photoresistor
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个光敏电阻
- en: 1 common-cathode RGB LED
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个共阴极 RGB LED
- en: 3 push buttons
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 个按钮
- en: 1 16x2 parallel LCD module
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 16x2 并行 LCD 模块
- en: 1 rotary potentiometer
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个旋转电位器
- en: 1 piezo
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个压电元件
- en: 3 10 kV resistors
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 个 10 kΩ 电阻
- en: 2 220 V resistors
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个 220 V 电阻
- en: 23 jumper wires in various colors
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 23 根不同颜色的跳线
- en: 1 half-size breadboard
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个半尺寸面包板
- en: '![](0108fig01_alt.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![0108fig01_alt.jpg](0108fig01_alt.jpg)'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1\. Lighting things up
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 点亮事物
- en: LEDs seem to do a lot more tricks than just turn on or off. If you look around
    at the electronics embedded in your own electronic gadgets, you’ll see them pulsing
    or fading out. You may even see them change color.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: LED 似乎能做很多不仅仅是开启或关闭的技巧。如果你看看你自己的电子设备中嵌入的电子元件，你会看到它们在闪烁或淡出。你可能甚至看到它们改变颜色。
- en: These common LED behaviors are, technically, illusions ([figure 5.1](#ch05fig01)).
    An LED can emit only one wavelength of light—it can only be one color. And yet,
    LEDs around us certainly *appear* to dim or take on different hues.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常见的 LED 行为在技术上实际上是错觉（[图 5.1](#ch05fig01)）。LED 只能发射一种波长的光——它只能是一种颜色。然而，我们周围的
    LED 确实*看起来*会变暗或呈现不同的色调。
- en: Figure 5.1\. LEDs emit a single color and are either on or off.
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. LED 发射单一颜色，要么开启要么关闭。
- en: '![](05fig01_alt.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![05fig01_alt.jpg](05fig01_alt.jpg)'
- en: Time to become an LED magician—there’s an electronic technique we can harness
    to make LEDs take on depth and intrigue.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候成为一个LED魔术师了——我们可以利用一种电子技术来使LED具有深度和吸引力。
- en: 5.1.1\. Fading LEDs with pulse-width modulation (PWM)
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 使用脉冲宽度调制（PWM）淡出LED
- en: OK, so an LED can only be on or off at any point in time. You’ve made one blink,
    which is really just a cycle of periodic ons and offs. We’re going to get fancier
    with the blinking, with the aim of tricking human eyes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以一个LED在任何时刻只能处于开启或关闭状态。你已经让它闪烁了一次，这实际上只是一个周期性的开启和关闭。我们将使闪烁更加复杂，目的是欺骗人的眼睛。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno和USB线
- en: 1 breadboard
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个面包板
- en: 2 standard LEDs, any color you like
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个标准LED，任何你喜欢的颜色
- en: 2 220 V resistors
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 220 V电阻
- en: Yellow (2) and black (1) jumper wires
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色（2）和黑色（1）跳线
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: First, construct the circuit shown in [figure 5.2](#ch05fig02). Next, create
    a file and add the code shown in the following listing.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建[图5.2](#ch05fig02)中所示的电路。接下来，创建一个文件并添加以下列表中的代码。
- en: Listing 5.1\. experiment-led.js
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. experiment-led.js
- en: '[PRE27]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Instantiates an Led object on pin 2**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在引脚2上实例化一个Led对象**'
- en: '***2* Instantiates an Led object on pin 3**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在引脚3上实例化一个Led对象**'
- en: '***3* Injects the Led object instances into the REPL**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将Led对象实例注入到REPL中**'
- en: Figure 5.2\. Wiring diagram for LED experimentation
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. LED实验的接线图
- en: '![](05fig02_alt.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig02_alt.jpg)'
- en: 'This code doesn’t really do much. It instantiates two `Led` objects and makes
    them available in Johnny-Five’s REPL as `led1` and `led2`. Run the script:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上并没有做什么。它创建了两个`Led`对象，并将它们作为`led1`和`led2`在Johnny-Five的REPL中可用。运行脚本：
- en: '[PRE28]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once it’s up and running, you’ll be able to type commands at the REPL prompt.
    First—and I know this is territory we’ve been through before—make one of the LEDs
    blink. Type the following at the REPL prompt and press Enter:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动并运行，你将能够在REPL提示符处输入命令。首先——我知道这是我们之前已经走过的领域——让其中一个LED闪烁。在REPL提示符处输入以下内容并按Enter键：
- en: '[PRE29]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first LED should be blinking now, in 100 ms periods (on for 100 ms, off
    for 100 ms)—this is the default phase length (speed of blink periods) for the
    `blink` method if you don’t tell it otherwise.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个LED现在应该以100毫秒的周期闪烁（亮100毫秒，灭100毫秒）——这是`blink`方法的默认相位长度（闪烁周期的速度），如果你不告诉它其他的话。
- en: Now I want you to carefully gather up the Arduino and the breadboard with the
    LEDs in one hand and wave it in front of your face. You’ll know you’re waving
    frantically enough when the LED appears not to blink anymore but is just a smeared
    line.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想让你用一只手小心地拿起Arduino和带有LED的面包板，在面前挥动。当你挥动得足够疯狂时，你会知道LED看起来不再闪烁，而是一条模糊的线条。
- en: You’re fooling your own eyes. When things move too quickly, your eyes and brain
    can’t quite keep up. Your brain, in effect, connects the dots for you and decides
    you’re seeing a continuous line of light. If you’re a photographer, you can think
    of it as sort of analogous to shutter speed—your own “shutter speed” isn’t fast
    enough, and you end up with motion blur. This is why films and movies can appear
    fluid at 24 individual frames per second or so.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你在欺骗自己的眼睛。当事物移动得太快时，你的眼睛和大脑无法跟上。实际上，你的大脑为你连接点，并决定你看到的是一串连续的光线。如果你是摄影师，你可以把它想象成类似于快门速度——你自己的“快门速度”不够快，结果就是运动模糊。这就是为什么电影和电影可以在每秒24帧左右看起来流畅。
- en: The same goes for the detection of individual blinks. If a light blinks fast
    enough, humans won’t be able to see the blinking at all ([figure 5.3](#ch05fig03)).
    Different humans have different thresholds of perception—this explains why I get
    maniacally grumpy around old fluorescents or CRTs with slow refresh frequencies
    while some of my colleagues aren’t bothered at all. But everyone reliably loses
    the ability to discern individual blinks at around 100 Hz (a hundred cycles per
    second).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个闪烁的检测也是如此。如果灯光闪烁得足够快，人类将完全看不到闪烁（[图5.3](#ch05fig03)）。不同的人有不同的感知阈值——这解释了为什么我在老式的荧光灯或慢刷新频率的CRT周围会变得疯狂地暴躁，而我的同事们却一点也不在意。但每个人在约100
    Hz（每秒一百个周期）时都会可靠地失去分辨单个闪烁的能力。
- en: Figure 5.3\. We lose the ability to discern individual blinks when an LED is
    moving quickly.
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 当LED快速移动时，我们失去了分辨单个闪烁的能力。
- en: '![](05fig03_alt.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig03_alt.jpg)'
- en: So, great, what’s the point of making an LED blink so fast that the blinks are
    invisible and it seems like it’s always on? Can’t we just *turn an LED on* steadily
    to get the same effect?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让LED如此快速闪烁以至于闪烁变得不可见，看起来它似乎总是亮着的意义何在？我们难道不能只是*稳定地打开LED*来达到同样的效果吗？
- en: It turns out that interesting things come to pass if you mess around with the
    proportion of time that the LED is on (versus off). If you’re blinking the LED
    really fast, humans won’t be able to perceive the blink—that we’ve covered. But
    if the LED is only on one-quarter of the time (off the other three-quarters),
    it will also appear considerably dimmer.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩弄LED开启（相对于关闭）的时间比例，会发生有趣的事情。如果你非常快地闪烁LED，人类将无法感知到闪烁——我们已经讨论过这一点。但如果LED只有四分之一的时间开启（其余的三分之三是关闭的），它也会显得相当暗。
- en: '|  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Make it stop!**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**让它停止！**'
- en: 'If the blinking LED is driving you nuts, you can always stop the blinking with
    the `Led.stop` instance method:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果闪烁的LED让你感到烦躁，你可以始终使用`Led.stop`实例方法来停止闪烁：
- en: '[PRE30]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Depending on when the command is issued, the result may be an LED that’s off
    or an LED that’s steadily on. If the LED is on and you want it off, use this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 根据命令发出的时间，结果可能是一个关闭的LED或一个稳定开启的LED。如果LED是开启的，而你想要它关闭，使用这个：
- en: '[PRE31]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’ll need to use both methods—you can’t just skip to the `off` method. The
    `stop` will clear the interval that causes the blinking to happen—`off` won’t.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用这两种方法——你不能跳过`off`方法。`stop`将清除导致闪烁发生的间隔——`off`不会。
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Let’s make this happen. Try (again in the REPL):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这一点。尝试（在REPL中再次尝试）：
- en: '[PRE32]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`brightness` is an instance method on Johnny-Five `Led` objects that takes
    an 8-bit value (0–255). A value of 64 is, then, one-quarter of the brightest possible
    value. The result of the call to `led2.brightness(64)` is that the LED spends
    75% of its time off and is lit 25% of the time. All of this turning on and off
    is happening at frequencies too fast for the eye to pick out. You’ll note that
    `led2` now appears less bright than `led1`—it’s dimmer.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`brightness`是Johnny-Five `Led`对象上的一个实例方法，它接受一个8位值（0–255）。因此，64的值是可能最亮值的四分之一。`led2.brightness(64)`调用结果就是LED有75%的时间是关闭的，25%的时间是点亮的。所有这些开启和关闭操作都在人眼无法察觉的频率下进行。你会注意到`led2`现在看起来比`led1`暗，它更暗。'
- en: The Uno’s microcontroller helps out here. It provides hardware support for a
    technique called *pulse-width modulation* (PWM), which does the juggling of ons
    and offs more quickly than software can easily provide. The percentage of time
    a PWM signal is HIGH (on) is called the *duty cycle*. An output that is HIGH a
    quarter of the time is said to have a 25% duty cycle ([figure 5.4](#ch05fig04)).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Uno的微控制器在这里提供帮助。它为一种称为*脉冲宽度调制*（PWM）的技术提供硬件支持，这种技术比软件能轻易提供的开关操作更快。PWM信号高电平（开启）的时间百分比称为*占空比*。一个四分之一时间高电平的输出被认为具有25%的占空比（[图5.4](#ch05fig04)）。
- en: Figure 5.4\. A 25% duty cycle
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. 25%占空比
- en: '![](05fig04_alt.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig04_alt.jpg)'
- en: PWM hardware support is common because it’s quite useful, but its support varies
    from board to board and it’s typically only available on certain pins. This is
    the case with the Arduino Uno. PWM is only available on pins 3, 5, 6, 9, 10, and
    11.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: PWM硬件支持很常见，因为它非常有用，但支持情况因板而异，通常仅在特定引脚上可用。Arduino Uno就是这样。PWM仅在引脚3、5、6、9、10和11上可用。
- en: Don’t worry, you don’t have to memorize that. If you look at your Arduino, you’ll
    see that those pin numbers are silkscreened with a tilde (`~`) next to them ([figure
    5.5](#ch05fig05)). That indicates that PWM is supported on that pin.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，你不必记住这一点。如果你看看你的Arduino，你会看到那些引脚编号旁边都印有波浪号（`~`）([图5.5](#ch05fig05))。这表示在该引脚上支持PWM。
- en: Figure 5.5\. Only some of the Arduino Uno’s digital pins support PWM. They’re
    marked with `~`.
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. 只有Arduino Uno的一些数字引脚支持PWM。它们被标记为`~`。
- en: '![](05fig05.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig05.jpg)'
- en: 'Now, back in the REPL, try this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到REPL中，尝试这个：
- en: '[PRE33]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This won’t work. You’ll get an exception that starts with something like
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不起作用。你会得到一个异常，开头可能是
- en: '[PRE34]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That’s Johnny-Five and `firmata`—the software includes mappings of which pins
    do what on which boards.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Johnny-Five和`firmata`——软件包括了哪些引脚在哪些板上做什么的映射。
- en: All right, we’ve looked at several things in our exploration here. People can’t
    discern blinks if they’re really fast. Changing the duty cycle of the signal into
    an LED makes its brightness appear to change. One last thing, and then we’ll do
    something with this knowledge.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在这次探索中已经看了很多东西。如果闪烁真的很快，人们无法分辨。将信号的占空比改变到LED中会使它的亮度看起来在变化。最后一件事，然后我们将用这个知识做点什么。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Be sure to use pins with PWM support for features that require it
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一定要使用支持PWM功能的引脚来处理需要PWM功能的特性
- en: Methods like `brightness` and several others you’ll need on `Led` instances
    require the component to be connected to a pin that supports PWM. Johnny-Five
    will throw an error if you try to invoke a PWM-requiring method on a pin that
    doesn’t support it. When designing your circuits, it’s good to keep in mind which
    pins support PWM to save time and headaches later.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`brightness`和其他你将在`Led`实例上需要的几个方法，需要组件连接到一个支持PWM的引脚。如果你尝试在一个不支持PWM的引脚上调用需要PWM的方法，Johnny-Five会抛出一个错误。在设计电路时，考虑到哪些引脚支持PWM是一个好主意，这样可以节省时间和避免头疼。
- en: '|  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this in the REPL:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中尝试以下操作：
- en: '[PRE35]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`128` is exactly in the middle of the brightness range, so you may expect that
    these two JavaScript expressions would result in the second LED shining at half
    brightness compared to the first, which is on full blast. But unless you squint
    really hard, both LEDs look about the same. You might be able to see a slight
    difference, but not much.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`128`正好位于亮度范围的中间，所以你可能预期这两个JavaScript表达式会导致第二个LED的亮度是第一个LED的一半，而第一个LED是全亮。但除非你眯着眼睛看，两个LED看起来几乎一样。你可能能够看到一点点的区别，但并不多。'
- en: That’s because brightness wins. `brightness(128)`does result in a duty cycle
    of 50%—the LED is only on half of the time—but the brain skews that toward brightness.
    Put another way, Johnny-Five’s 8-bit brightness scale 0–255 appears non-linear,
    entirely due to human perception.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为亮度更重要。`brightness(128)`确实会导致占空比为50%——LED只有一半时间处于开启状态——但大脑会偏向于亮度。换句话说，Johnny-Five的8位亮度范围0-255看起来是非线性的，这完全是由于人类感知的原因。
- en: 5.1.2\. Animating LEDs with PWM
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 使用PWM动画化LED
- en: Now you know how to turn an LED on or off, blink it, and, assuming it’s connected
    to a pin that supports PWM, set its brightness. To complement this small stable
    of tricks, you can also *animate* the brightness of an LED, making it appear to
    pulse or bounce or breathe or slowly fall asleep—your imagination is the limit
    here.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何打开或关闭LED，闪烁它，并且假设它连接到一个支持PWM的引脚，你可以设置其亮度。为了补充这些小技巧，你还可以*动画化*LED的亮度，使其看起来像脉冲、弹跳、呼吸或慢慢入睡——你的想象力是无限的。
- en: Johnny-Five includes an `Animation` class, which offers fine-grained control
    over animations of—at the time of writing—the brightness of LEDs and the motions
    of servos (we’ll meet servos in [chapter 6](kindle_split_014.html#ch06)).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five包含一个`Animation`类，它提供了对LED亮度动画和伺服电机运动的精细控制（我们将在第6章中介绍伺服电机[chapter
    6](kindle_split_014.html#ch06)）。
- en: Working with animations in Johnny-Five involves a few steps, shown in the next
    listing.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在Johnny-Five中处理动画涉及几个步骤，如下一个列表所示。
- en: Listing 5.2\. Steps for animating components in Johnny-Five
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. 在Johnny-Five中动画化组件的步骤
- en: '[PRE36]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Creates an options object containing animation details—more on this shortly**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个包含动画详细信息的选项对象——稍后将有更多介绍**'
- en: '***2* Instantiates an Animation object and passes it a target component—the
    target will be animated**'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实例化一个Animation对象，并传递一个目标组件——目标将被动画化**'
- en: '***3* Starts the animation with enqueue**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用enqueue开始动画**'
- en: Let’s take this for a spin by making an LED appear to *pulse*. Johnny-Five needs
    us first to define how we want the animation to behave.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过让LED看起来像*脉冲*来试一试。Johnny-Five需要我们首先定义动画应该如何表现。
- en: The pulsing LED should fade in and then fade out again in loops that use attractive
    easing. *Easing functions* are functions that vary the rate of an animation during
    its duration. For example, an animation that *eases out* starts out moving quickly
    but gets slower as it goes.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁的LED应该使用吸引式缓动循环淡入淡出。*缓动函数*是在动画持续期间改变动画速率的函数。例如，一个*缓动结束*的动画开始时移动得很快，但随着时间的推移会变慢。
- en: Easing functions are typically non-linear, integrating sine, cubic, exponential,
    and other curves into the equation. An in-out-sine easing creates an animation
    with a rhythm like that shown in [figure 5.6](#ch05fig06). Easing functions can
    make an animation more lifelike or give it different qualities of motion. Of course,
    LEDs don’t move, but changes in their brightness can definitely be animated.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 缓动函数通常是非线性函数，将正弦、立方、指数和其他曲线整合到方程中。in-out-sine 缓动创建的动画节奏类似于 [图 5.6](#ch05fig06)
    中所示。缓动函数可以使动画更加逼真或赋予它不同的运动特性。当然，LED 不动，但它们亮度的变化确实可以被动画化。
- en: Figure 5.6\. `inOutSine` is one of a couple of dozen easing function options
    available in Johnny-Five via its dependency on the `ease-component` npm package.
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6\. `inOutSine` 是 Johnny-Five 通过其对 `ease-component` npm 包的依赖而提供的几十个缓动函数选项之一。
- en: '![](05fig06.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![05fig06.jpg](05fig06.jpg)'
- en: The `inOutSine` easing is what we’ll use for pulsing, as the changes to brightness
    start out slow and then accelerate midway through the brightening of the LED.
    A pulse is a *metronomic* animation, meaning that once the animation runs forward,
    it should then run backward, moving between its start and end points in a back-and-forth
    *loop*.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`inOutSine` 缓动是我们用于脉冲的，因为亮度变化开始时较慢，然后在 LED 亮起中途加速。脉冲是一种 *节拍器* 动画，这意味着一旦动画向前运行，它应该然后反向运行，在其起点和终点之间来回
    *循环*。'
- en: 'We also need to tell the animation what it’s easing between by defining *keyframes*
    ([figure 5.7](#ch05fig07)). Keyframes define the specific states (like still frames)
    between which the animation should fill in intermediate frames using the easing
    function. The process of creating these intermediate frames or states between
    keyframes is known as *tweening*. For this simple pulse, the keyframes are simple:
    totally off (brightness 0) and totally on (brightness 255).'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过定义 *关键帧* ([图 5.7](#ch05fig07)) 来告诉动画它在什么之间进行缓动。关键帧定义了动画应在其中填充中间帧的特定状态（如静止帧）。在关键帧之间创建这些中间帧或状态的过程称为
    *插值*。对于这个简单的脉冲，关键帧很简单：完全关闭（亮度 0）和完全开启（亮度 255）。
- en: Figure 5.7\. The pulse animation will loop metronomically between two basic
    keyframes (brightness 0 and brightness 255) with `inOutSine` easing.
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.7\. 脉冲动画将以节拍器的方式在两个基本关键帧（亮度 0 和亮度 255）之间循环，使用 `inOutSine` 缓动。
- en: '![](05fig07_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![05fig07_alt.jpg](05fig07_alt.jpg)'
- en: Finally, we need to give the animation a *duration*, in milliseconds. Each segment
    of the animation—going from dark to bright or bright to dark—should take one second.
    Put together, the animation options look like the following code.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要给动画一个 *持续时间*，以毫秒为单位。动画的每个部分——从暗到亮或从亮到暗——应该持续一秒钟。组合起来，动画选项看起来像以下代码。
- en: Listing 5.3\. Animation options for pulsing
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 脉冲动画选项
- en: '[PRE37]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let’s see what this looks like, shall we? You can use the circuit from the last
    set of experiments for this part (you won’t be using the first LED). Create a
    new file called animate-LED.js. Paste the contents from experiment-LED.js into
    animate-LED.js as a starting point, and edit the code to create a single LED on
    pin 3\. Add the `options` object after the instantiation of the pulsing `Led`
    object as follows.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这会是什么样子，好吗？你可以使用上一组实验中的电路来完成这部分（你不会使用第一个 LED）。创建一个名为 animate-LED.js 的新文件。将
    experiment-LED.js 中的内容粘贴到 animate-LED.js 中作为起点，并编辑代码以在引脚 3 上创建一个单独的 LED。在脉冲 `Led`
    对象实例化之后添加 `options` 对象，如下所示。
- en: Listing 5.4\. animate-led.js
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. animate-led.js
- en: '[PRE38]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Steps 2 and 3 are next: creating an `Animation` object and making it go with
    `enqueue`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是步骤 2 和 3：创建一个 `Animation` 对象并使用 `enqueue` 使其运行。
- en: Listing 5.5\. Animation instantiation and enqueuing
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 动画实例化和入队
- en: '[PRE39]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Passes the target—the thing to animate. In this case, the LED (pulsingLED).**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 传递目标——要动画化的东西。在这种情况下，LED（pulsingLED）。**'
- en: '***2* Enqueues the animation and passes it the animation options.**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将动画入队并传递动画选项。**'
- en: 'Now run the script:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本：
- en: '[PRE40]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And there you have it. Well, sort of. I made you do it the hard way, because
    as it happens, the code in the following listing does the same thing.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了。嗯，差不多吧。我让你用困难的方式做了，因为实际上，以下列表中的代码做的是同样的事情。
- en: Listing 5.6\. Easier way to pulse an LED
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 更简单的方式来脉冲 LED
- en: '[PRE41]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Led.prototype.pulse takes a duration in ms (default 1000).**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `Led.prototype.pulse` 接受一个以毫秒为单位的持续时间（默认 1000）。**'
- en: Underneath, the implementation of `pulse` is similar to what we did earlier,
    but it’s such a common use that it’s been simplified into a method for Johnny-Five
    users.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，`pulse`的实现与我们之前所做的是相似的，但它如此常见，以至于它被简化为Johnny-Five用户的方法。
- en: Pulsing LEDs can be a nice way of grabbing attention without being too invasive.
    Using what we’ve covered, you can make a simple timer using just a few lines of
    code—it will start pulsing when the time’s up, as the following listing shows.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁LED可以是一种在不那么侵入性的情况下吸引注意力的好方法。使用我们所学的内容，你可以用几行代码制作一个简单的定时器——当时间到了，它就会开始闪烁，如下面的列表所示。
- en: Listing 5.7\. The world’s simplest timer
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. 世界上最简单的定时器
- en: '[PRE42]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Defines a timer length in milliseconds (here 10 seconds)**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义定时器长度（以毫秒为单位，这里为10秒）**'
- en: '***2* Sets a timeout to start pulsing the LED after 10 seconds**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置超时，在10秒后开始闪烁LED**'
- en: Of course, this timer is of limited use. You can’t change the timer’s length
    or when the timer starts, or start a new timer. Don’t worry; we’ll make it better
    in a bit.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个定时器用途有限。你不能改变定时器的长度或开始时间，也不能启动一个新的定时器。别担心；我们很快就会让它变得更好。
- en: 5.1.3\. Combining input with LED output
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. 结合输入和LED输出
- en: Of course, output is more interesting if it’s responding to some sort of meaningful
    input. The connections between input and output are what makes the internet of
    things tick.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果输出是对某种有意义输入的响应，那么输出更有趣。输入和输出之间的连接是使物联网运转的原因。
- en: One such coupling could be a photoresistor and an LED to create a brightness-aware
    nightlight. When the readings from the photoresistor are lower, the LED can be
    brighter—that is, the “nightlight” turns on at “night,” when it’s darker.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种耦合可以是光敏电阻和LED来创建亮度感知的夜灯。当光敏电阻的读数较低时，LED可以更亮——也就是说，“夜灯”在“夜晚”变暗时打开。
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno和USB线
- en: 1 standard LED, any color (you can reuse the pulsing LED from above)
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 标准LED，任何颜色（你可以重复使用上面的闪烁LED）
- en: 1 photoresistor
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 光敏电阻
- en: 1 10 kV resistor
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 10 kV电阻
- en: 1 220 V resistor
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 220 V电阻
- en: Yellow (1), red (2), green (1), and black (1) jumper wires
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色（1）、红色（2）、绿色（1）和黑色（1）跳线
- en: 1 half-size breadboard
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: '|  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Leave the LED connected to pin 3 on the breadboard (the pulsing LED from the
    last example), but remove the other LED and add a photoresistor and a 10 kV resistor
    as shown in [figure 5.8](#ch05fig08).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 将LED连接到面包板上的3号引脚（上一个例子中的闪烁LED），但移除另一个LED，并添加一个光敏电阻和一个10 kV电阻，如图5.8所示。
- en: Figure 5.8\. Wiring diagram for automatic nightlight
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8\. 自动夜灯的接线图
- en: '![](05fig08_alt.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig08_alt.jpg)'
- en: '[Listing 5.8](#ch05ex08) shows a first attempt at a light-sensitive nightlight
    using `Light`, a class in Johnny-Five that provides features for working with
    photoresistors (`ldr` stands for *light-dependent resistor*, another name for
    a photoresistor).'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.8](#ch05ex08) 展示了使用`Light`类（Johnny-Five中用于处理光敏电阻的功能）制作光敏感夜灯的第一次尝试，`ldr`代表*光敏电阻*，是光敏电阻的另一种称呼。'
- en: Listing 5.8\. A naive nightlight
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 一个简单的夜灯
- en: '[PRE43]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Checking light levels twice per second (every 500 ms, the value of freq)
    should more than suffice.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每秒检查两次光强度（每500毫秒，freq的值）应该绰绰有余。**'
- en: '***2* Sets LED brightness to “the opposite” of the photoresistor’s value**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将LED亮度设置为光敏电阻值的“相反”**'
- en: 'The following line may have made your eyes cross if you haven’t spent much
    time in the world of bitwise operators:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有花很多时间在位运算符的世界里，以下这一行可能会让你感到眼花缭乱：
- en: '[PRE44]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Recall that the Arduino Uno’s microcontroller provides ADC readings as 10-bit
    integers (0–1023). Meanwhile, the `brightness` method on the `Led` object expects
    an 8-bit number (0–255).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Arduino Uno的微控制器提供10位整数的ADC读数（0–1023）。同时，`Led`对象上的`brightness`方法期望一个8位数字（0–255）。
- en: The expression `photoresistor.value >> 2` shifts `photoresistor.value` to the
    right by two bits. That means two bits pop off the right side of the number and
    are never heard from again ([figure 5.9](#ch05fig09)). In the case of `photoresistor.value
    >> 2`, in goes a 10-bit number, its two least significant digits are booted out,
    and what’s returned is an 8-bit number.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`photoresistor.value >> 2`将`photoresistor.value`向右移动两位。这意味着两个位从数字的右侧弹出，并且再也没有被听到过（[图5.9](#ch05fig09)）。在`photoresistor.value
    >> 2`的情况下，进入的是一个10位数字，它的两个最低有效位被踢出去，返回的是一个8位数字。
- en: Figure 5.9\. Bitshifting a 10-bit number to the right by 2 results in an 8-bit
    number.
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9\. 将10位数字向右移动2位得到8位数字。
- en: '![](05fig09_alt.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig09_alt.jpg)'
- en: You can think of the 10-bit number as being too precise for an 8-bit input;
    the bitshifting right by 2 “rounds” it to a lower resolution that `brightness`
    can use.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将10位数字视为对于8位输入过于精确；右移2位“四舍五入”到`brightness`可以使用的一个较低分辨率。
- en: The `^ 255` part uses the bitwise `XOR` (exclusive OR) operator (`^`) to obtain
    what I’m going to loosely call “the opposite” 8-bit number from the left-hand
    argument. `XOR` performs a comparison on each pair of bits and returns `1` in
    the digit’s place only when the digits evaluated are different—when one is a `1`
    and one is a `0` ([figure 5.10](#ch05fig10)).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`^ 255`部分使用位运算的`XOR`（异或）运算符（`^`）来获取我所说的“相反”的8位数字，即左操作数的相反数。`XOR`在每一对位上进行比较，并且仅在评估的位不同时（一个为`1`，一个为`0`）在数字位返回`1`（[图5.10](#ch05fig10)）。'
- en: Figure 5.10\. The XOR operation compares each binary digit, producing a 1 if
    the binary digits are different.
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10\. XOR运算比较每个二进制位，如果二进制位不同则产生1。
- en: '![](05fig10_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig10_alt.jpg)'
- en: The expression `(photoresistor.value >> 2) ^ 255` means, then, *shift* `photoresistor.value`
    *2 bits to the right (making it an 8-bit number) and subsequently* `XOR` *the
    resulting value with 255*.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(photoresistor.value >> 2) ^ 255`的意思是，首先将`photoresistor.value`右移2位（使其成为8位数字），然后`XOR`操作与255的结果。
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Bitshifting all over the place
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 各处进行位移动
- en: Bitshifting and bitwise operations may feel foreign to software developers who
    usually work in higher-level code, but it comes up all over the place when working
    with hardware. The Mozilla Developer Network has a nice reference of JavaScript
    bitwise operators, which contains the key things you’ll want to know ([http://mng.bz/CLvy](http://mng.bz/CLvy)).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通常在高层次代码中工作的软件开发者来说，位移动和位运算可能感觉陌生，但在与硬件一起工作时却无处不在。Mozilla开发者网络有一个很好的JavaScript位运算符参考，其中包含了您想要了解的关键内容（[http://mng.bz/CLvy](http://mng.bz/CLvy)）。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The first version of the nightlight has some shortcomings, which you can see
    in action by running it:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 夜灯的第一版有一些不足之处，您可以通过运行它来看到：
- en: '[PRE45]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For one, the LED is always on at some brightness, even when readings for the
    photoresistor are near the brightest possible values. Wouldn’t we want the LED
    to come on only when it’s darker? We don’t need it on during broad daylight. The
    second version of the nightlight code addresses that by replacing what happens
    inside the `change` callback function, as shown in the following listing.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，LED灯总是以某种亮度亮着，即使光电电阻器的读数接近可能的最亮值。我们难道不希望LED只在变暗时才亮吗？在晴朗的日子里我们不需要它亮着。夜灯代码的第二版通过替换`change`回调函数内部的实现来解决这个问题，如下所示。
- en: Listing 5.9\. Slightly improved nightlight
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. 略微改进的夜灯
- en: '[PRE46]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Light instances have a level value, which is a percentage between 0.0
    and 1.0.**'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 灯实例有一个电平值，这是一个介于0.0和1.0之间的百分比。**'
- en: '***2* Changes the calculation of the LED brightness**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 改变了LED亮度的计算**'
- en: '***3* LED is off if level >= 0.5**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当电平 >= 0.5 时，LED关闭**'
- en: In this variant, the LED is switched off entirely if the photoresistor’s `level`
    is greater than or equal to `0.5` (`nightlight.off()`).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中，如果光电电阻器的`level`大于或等于`0.5`（`nightlight.off()`），LED将完全关闭。
- en: If the `photoresistor.level` is less than `0.5` (50%), we know that its 10-bit
    `value` also must be less than 512 (because 511 is the middle of the range of
    possible 10-bit values, 0–1023). That means `photoresistor.value` is an integer
    somewhere from 0 to 511, inclusive. All of the numbers in that range are 9-bit
    numbers (0–511). That means we only need to shift one bit to the right to convert
    the `value` to an 8-bit number (0–255).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`photoresistor.level`小于`0.5`（50%），我们知道它的10位`value`也必须小于512（因为511是可能的10位值范围0–1023的中点）。这意味着`photoresistor.value`是一个介于0到511之间的整数（包括0和511）。这意味着我们只需要右移一位就可以将`value`转换为8位数字（0–255）。
- en: The end result is that the LED will grow increasingly bright as photoresistor
    values decrease from 511 to 0.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，随着光电电阻器值从511减小到0，LED的亮度会逐渐增加。
- en: But we can still do better. As you saw in [chapter 4](kindle_split_012.html#ch04),
    even when choosing the best possible resistor value for the photoresistor circuit’s
    voltage divider, you won’t be able to get the full range of voltages from 0 to
    5 V. It would be better if the nightlight could calibrate itself based on the
    real range of conditions and readings it’s encountering, as shown in the next
    listing.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然可以做得更好。正如你在[第4章](kindle_split_012.html#ch04)中看到的，即使选择光电电阻电路电压分压器最佳可能的电阻值，你也不会得到从0到5
    V的完整电压范围。如果夜灯能够根据它实际遇到的条件和读数进行校准，那就更好了，如下一列表所示。
- en: Listing 5.10\. Self-calibrating nightlight
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10\. 自校准夜灯
- en: '[PRE47]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Keeps track of the dimmest and brightest readings it sees**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录它看到的最低和最高读数**'
- en: '***2* Updates dimmest and brightest if it encounters lower and higher values**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果遇到较低和较高的值，则更新最低和最高值**'
- en: '***3* Scales the current value to a 9-bit number between dimmest and brightest
    readings**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将当前值缩放到最低和最高读数之间的9位数字**'
- en: The nightlight code in [listing 5.10](#ch05ex10) makes two changes. One, it
    keeps track of the dimmest and brightest actual values seen during the nightlight’s
    script lifetime. Then it takes advantage of the `scale` utility method available
    on the `Fn` object on `Board` instances.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.10](#ch05ex10)中的夜灯代码进行了两项更改。一是它记录了夜灯脚本生命周期中看到的最低和最高实际值。然后它利用`Board`实例上的`Fn`对象可用的`scale`实用方法。'
- en: '`scale(value, fromLow, fromHigh, toLow, toHigh)` takes a `value` that currently
    exists in a range between `fromLow` and `fromHigh` (the `dimmest` and `brightest`
    values seen) and remaps it to a range between `toLow` and `toHigh` (`0` and `511`),
    proportionally.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale(value, fromLow, fromHigh, toLow, toHigh)`函数接受一个`value`，该值当前存在于`fromLow`和`fromHigh`（最暗和最亮的值）之间的范围内，并将其重新映射到`toLow`和`toHigh`（`0`和`511`）之间的范围，成比例地。'
- en: The resulting number will be a 9-bit number (between 0 and 511). Now we can
    proceed, knowing that values `<= 255` are in the lower half of the observed values.
    The nightlight will continue to adjust itself (calibrate low and high) as it runs
    over time.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 最终得到的数字将是一个9位数字（介于0和511之间）。现在我们可以继续进行，知道值`<= 255`位于观察到的值的下半部分。夜灯将在运行过程中继续调整自己（校准高低）。
- en: 5.1.4\. Going full-color with RGB LEDs
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4\. 使用RGB LED实现全彩
- en: All right, that’s some extensive coverage of dimming an LED, but what about
    LEDs that seem to change color? Sure, a single LED can only ever be one color—one
    wavelength—but if you group red, green, and blue LEDs in a single package and
    control the brightness (duty cycle) of each component LED, *voilà*! All the colors
    of the rainbow.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是对调暗LED的广泛覆盖，但那些似乎会改变颜色的LED呢？当然，单个LED只能始终是单一颜色——一个波长——但如果你在单个包装中将红色、绿色和蓝色LED组合在一起，并控制每个组件LED的亮度（占空比），*哇*！就能得到彩虹的所有颜色。
- en: RGB LEDs have four legs. There’s one leg for each LED (red, green, blue). The
    fourth leg is either a cathode or an anode. Common-cathode RGB LEDs—where all
    three color LEDs share a single cathode leg—are the kind we’ll be using ([figure
    5.11](#ch05fig11)). Common-anode RGB LEDS, which have a shared *anode* leg, are
    also available.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED有四条腿。每条腿对应一个LED（红色、绿色、蓝色）。第四条腿是阴极或阳极。常见的阴极RGB LED——其中三个颜色LED共享一个单独的阴极腿——是我们将要使用的类型（[图5.11](#ch05fig11)）。也有共享*阳极*腿的常见阳极RGB
    LED。
- en: Figure 5.11\. Common-cathode RGB LEDs have three component LEDs (red, green,
    blue) in one package. The longest leg is the shared cathode.
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11\. 常见的阴极RGB LED在一个包装中包含三个组件LED（红色、绿色、蓝色）。最长的腿是共享的阴极。
- en: '![](05fig11.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig11.jpg)'
- en: Like regular LEDs, RGB LEDs allow you to control brightness with PWM, but now
    there are three LEDs representing the primary colors of light. For common-cathode
    LEDs, a higher-percentage duty cycle on a component color LED will make that color
    brighter, whereas a lower duty cycle makes it dimmer.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通LED一样，RGB LED允许你使用PWM控制亮度，但现在有三个LED代表光的基本颜色。对于常见的阴极LED，组件颜色LED的较高占空比会使该颜色更亮，而较低的占空比会使它变暗。
- en: 5.1.5\. Build your own “weather ball”
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.5\. 制作你自己的“天气球”
- en: I grew up in Portland, Oregon, and when I was a kid, spotting the weather ball
    on top of the Standard Insurance Plaza was always a little thrill. The weather
    ball provided a very basic encoded visual representation of the weather forecast
    for the next 24 hours or so. The pole-mounted weather ball was large enough to
    be seen throughout the city, and it was covered with lights.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我在俄勒冈州的波特兰长大，当我还是个孩子的时候，看到标准保险公司大厦顶部的天气球总是有点兴奋。天气球提供了对未来24小时左右天气预报的基本编码视觉表示。这个安装在杆上的天气球足够大，可以在整个城市中看到，它被灯光覆盖。
- en: 'It only had six possible states. Predicted temperature trend was represented
    by color: red if it’s forecast to get warmer, white if it’s getting colder, green
    if it’s staying about the same. If precipitation was in the offing, it would blink.
    Simple, and yet, remarkably clear and useful. Let’s make one.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有六种可能的状态。预测的温度趋势由颜色表示：红色表示预计会变暖，白色表示变冷，绿色表示保持不变。如果预计会有降水，它会闪烁。简单，但非常清晰和有用。让我们做一个。
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 您需要准备的东西
- en: '![](note.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: Arduino Uno and USB cable
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno和USB线
- en: 1 common-cathode RGB LED
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个共阴极RGB LED
- en: 1 220 V resistor
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 220 V电阻
- en: Red (1), green (1), blue (1), and black (1) jumper wires
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色（1）、绿色（1）、蓝色（1）和黑色（1）跳线
- en: 1 breadboard
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个面包板
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Wire up an RGB LED circuit as shown in [figure 5.12](#ch05fig12).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图5.12所示连接RGB LED电路。
- en: Figure 5.12\. Wiring diagram for the weather ball
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.12\. 天气球的接线图
- en: '![](05fig12_alt.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig12_alt.jpg)'
- en: Now we need the weather forecast! The service Dark Sky provides a weather forecast
    API that, at the time of writing, provides free results for up to 1,000 queries
    a day. You do need to sign up for an API key, which you can do at [https://darksky.net/dev/register](https://darksky.net/dev/register).
    You may need to provide a credit card number to sign up for the service.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要天气预报！Dark Sky服务提供天气预报API，在撰写本文时，每天最多提供1,000次免费查询结果。您需要注册一个API密钥，您可以在[https://darksky.net/dev/register](https://darksky.net/dev/register)进行注册。您可能需要提供信用卡号码来注册服务。
- en: Once you have a developer API key, write it down and keep it somewhere reasonably
    safe. You’ll also need your latitude and longitude, which you can find on [http://mygeoposition.com/](http://mygeoposition.com/).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了开发者API密钥，请将其写下并保存在一个相对安全的地方。您还需要您的纬度和经度，您可以在[http://mygeoposition.com/](http://mygeoposition.com/)找到它们。
- en: Create a new file called weatherBall.js. First, let’s collect some settings
    for the weather ball, as shown in the following listing.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为weatherBall.js的新文件。首先，让我们收集一些天气球设置，如下所示。
- en: Listing 5.11\. Settings for the weather ball
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.11\. 天气球的设置
- en: '[PRE48]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* I’m in Vermont. Change the LAT and LONG values to your own location.**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我在佛蒙特州。将LAT和LONG值更改为您自己的位置。**'
- en: '***2* You shouldn’t need to change this URL.**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您不需要更改此URL。**'
- en: 'Time to take care of our dependencies:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候处理我们的依赖项了：
- en: '[PRE49]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We’ll use the `request` package to make API calls to Dark Sky. Add `requires`
    to the top of the file, and go ahead and instantiate a board with Johnny-Five.
    Notice in the next listing that Johnny-Five provides a special kind of `Led` component
    class for RGB LEDs: `Led.RGB`.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`request`包来调用Dark Sky的API。在文件顶部添加`requires`，然后使用Johnny-Five实例化一个板。注意，在下一个列表中，Johnny-Five为RGB
    LED提供了一个特殊的`Led`组件类：`Led.RGB`。
- en: Listing 5.12\. Instantiating a board
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.12\. 实例化一个板
- en: '[PRE50]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, we need to get some data about the forecast by requesting it from the
    Dark Sky API in the next listing.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过在下一个列表中请求Dark Sky API的数据来获取一些关于预报的信息。
- en: Listing 5.13\. Requesting data from the Dark Sky API
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.13\. 从Dark Sky API请求数据
- en: '[PRE51]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Puts together the request URL**'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组合请求URL**'
- en: '***2* If the response comes back OK...**'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果响应返回OK...**'
- en: '***3* Parses the response body as JSON**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将响应体解析为JSON**'
- en: '***4* Logs the forecast object to the REPL**'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将预报对象记录到REPL**'
- en: Assuming everything went OK, you’ll now have data to work with. Let’s make the
    weather ball go, as shown in the following listing.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，您现在将有一些数据可以处理。让我们按照以下列表让天气球动起来。
- en: Listing 5.14\. Make the weather ball go
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.14\. 让天气球动起来
- en: '[PRE52]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* daily.data is an Array with seven day-forecast elements.**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* daily.data是一个包含七个预报元素的数组。**'
- en: '***2* daily[1] is tomorrow. Is it likely to rain?**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* daily[1]是明天。有可能下雨吗？**'
- en: '***3* daily[0] is today. How much is the temperature changing?**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* daily[0]是今天。温度变化了多少？**'
- en: '***4* Sets the color of the RGB LED based on how much the temperature is changing**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 根据温度变化设置RGB LED的颜色**'
- en: '***5* strobe is the same as blink—blink is an alias to strobe.**'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 闪烁与闪烁相同——闪烁是闪烁的别名。**'
- en: '|  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Troubleshooting the circuit**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**电路故障排除**'
- en: 'For maximum flexibility, methods related to colors on Johnny-Five component
    object instances—most relevantly, `Led.prototype.color` in this case—accept several
    different color formats, such as these:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大灵活性，与 Johnny-Five 组件对象实例上的颜色相关的方法——在这种情况下，最重要的是 `Led.prototype.color`——接受几种不同的颜色格式，如下所示：
- en: '***Hex (string)*—** Familiar to web developers, RGB hex values like `"#00ff00"`
    (bright green) can be used. It works with or without the leading `#`.'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***十六进制（字符串）**—** 对于网络开发者来说很熟悉，RGB 十六进制值如 `"#00ff00"`（亮绿色）可以用来。它可以在或没有前导 `#`
    的情况下使用。'
- en: '***CSS color name (string)*—** “red” or “darksalmon” or “lemonchiffon” or any
    other valid CSS color name works.'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***CSS 颜色名称（字符串）**—** “red” 或 “darksalmon” 或 “lemonchiffon” 或任何其他有效的 CSS 颜色名称都适用。'
- en: '***Array of R, G, B values (array)*—** Each element of the array should be
    an 8-bit value, such as `[0x00, 0xff, 0x00]` or `[0, 255, 0]`.'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***R、G、B 值数组（数组）**—** 数组的每个元素都应是一个 8 位值，例如 `[0x00, 0xff, 0x00]` 或 `[0, 255,
    0]`。'
- en: '***Object of RGB values (object)*—** Again, 8-bit values should be used, such
    as `{ red: 0x00, green: 0xff, blue: 0x00}`'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***RGB 值对象（对象）**—** 再次，应使用 8 位值，例如 `{ red: 0x00, green: 0xff, blue: 0x00}`'
- en: Keep up to date with the latest at [http://johnny-five.io/api/led.rgb/](http://johnny-five.io/api/led.rgb/).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://johnny-five.io/api/led.rgb/](http://johnny-five.io/api/led.rgb/) 上了解最新信息。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now run your weather ball:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的天气球：
- en: '[PRE53]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The sensors and outputs we’ve used in examples so far have only required a few
    wires and have had simple hookups. In the next section, you’ll meet a component
    that has a bunch of wires, but it isn’t hard to work with as long as you’re paying
    attention.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面示例中使用的传感器和输出只需要几根线，并且连接简单。在下一节中，你将遇到一个有很多线的组件，但只要你注意，它并不难处理。
- en: 5.2\. Working with parallel LCD displays
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 使用并行 LCD 显示器
- en: 'LCDs (liquid crystal displays) can display characters and shapes, making them
    useful outputs for tons of projects. Their resolution is often defined in terms
    of how many *characters* they can display. The 16x2 LCD module we’ll use in the
    following experiments can display up to 32 characters total: 16 each on 2 lines.
    Each “character” slot is actually its own matrix of 5x7 dots; non-character shapes
    can also be represented.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: LCD（液晶显示器）可以显示字符和形状，这使得它们成为众多项目的有用输出。它们的分辨率通常以它们可以显示的 *字符* 数来定义。我们将在以下实验中使用的
    16x2 LCD 模块总共可以显示 32 个字符：每行 16 个。每个“字符”槽实际上是其自己的 5x7 点阵；非字符形状也可以表示。
- en: LCD modules are available with different interfaces, including several serial
    options (you’ll learn about serial communication in [chapter 7](kindle_split_016.html#ch07)).
    The module shown in [figure 5.13](#ch05fig13) has a *parallel* interface.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: LCD 模块提供不同的接口，包括几个串行选项（你将在第 7 章中学习串行通信）。图 5.13 中所示的模块具有 *并行* 接口。
- en: Figure 5.13\. 16x2 parallel LCD modules are available from many manufacturers.
    They have 16 pins and an LED backlight.
  id: totrans-562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.13\. 16x2 并行 LCD 模块由许多制造商提供。它们有 16 个引脚和一个 LED 背光。
- en: '![](05fig13_alt.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig13_alt.jpg)'
- en: Don’t panic when you see the wiring diagrams in this section. Wiring up parallel
    LCDs requires a fistful of jumper wires, but working with them isn’t complicated.
    Make sure you pay attention to which wires go where when you’re plugging things
    in and you’ll be fine. Improving the timer project from earlier in the chapter
    admittedly requires more jumper wires than you’ve yet seen in one place, but it’s
    a good exercise for piecing together more-complex circuits.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到本节中的接线图时，不要慌张。连接并行 LCD 需要一大把跳线，但与它们一起工作并不复杂。确保你在插拔东西时注意哪些线连接在哪里，你就能做得很好。诚然，改进本章前面提到的定时器项目需要比你在任何地方看到的更多的跳线，但这是一项很好的练习，可以组装更复杂的电路。
- en: 5.2.1\. Making a full-featured timer with LCD
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 使用 LCD 制作全功能定时器
- en: '|  |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 16x2 5 V parallel LCD module, such as any of SparkFun’s basic 16x2 5 V parallel
    LCD modules
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 16x2 5 V 并行 LCD 模块，例如 SparkFun 的任何基本 16x2 5 V 并行 LCD 模块
- en: 1 standard LED, any color
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个标准 LED，任何颜色
- en: 3 push buttons (momentary switches)
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 个按钮（瞬态开关）
- en: 1 rotary potentiometer
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个旋转电位器
- en: 1 220 V resistor
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 220 V 电阻
- en: 3 10 kV resistors
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 个 10 kV 电阻
- en: 1 piezo (optional)
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个压电片（可选）
- en: 23 jumper wires
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 23 根跳线
- en: 1 half-size breadboard
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个半尺寸面包板
- en: '|  |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This smarter timer will allow you to adjust the timer’s duration using buttons
    (even when the timer is running!) and will count down the remaining time on the
    LCD. You can pause and restart the timer, as well. When the time’s up, an LED
    will pulse to (gently) grab your attention.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更智能的计时器将允许你使用按钮调整计时器的持续时间（即使计时器正在运行！）并在 LCD 上显示剩余时间。你还可以暂停和重新启动计时器。时间到时，LED
    将闪烁以（温和地）吸引你的注意。
- en: Building the circuit
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路
- en: The fully constructed circuit will look like [figure 5.14](#ch05fig14). We’ll
    break it down into a few steps to make it less intimidating.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 完全构建的电路将看起来像 [图 5.14](#ch05fig14)。我们将将其分解为几个步骤以减少其威慑力。
- en: Figure 5.14\. The fully built LCD timer
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.14\. 完全组装好的 LCD 计时器
- en: '![](05fig14_alt.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig14_alt.jpg)'
- en: Connecting and testing buttons
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接和测试按钮
- en: Let’s start with some buttons that will allow a user to control the timer. From
    left to right, the buttons in [figure 5.15](#ch05fig15) are
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些允许用户控制计时器的按钮开始。从左到右，图 [图 5.15](#ch05fig15) 中的按钮是
- en: A Down button (represented by `downButton` in the following code), which will
    subtract one second from the current timer
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个向下按钮（在以下代码中用 `downButton` 表示），它将从当前计时器中减去一秒
- en: An Up button (`upButton`), which will add one second to the current timer
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个向上按钮 (`upButton`)，它将向当前计时器添加一秒
- en: A toggling Go button (`goButton`), which will start and pause the timer
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个切换启动按钮 (`goButton`)，它将启动和暂停计时器
- en: Make sure the buttons straddle the center notch and are oriented as shown in
    [figure 5.15](#ch05fig15). Each button is connected to ground through a 10 kV
    pull-down resistor, and to the +5 V power rail with a jumper wire.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 确保按钮跨越中心凹槽，并且方向如图 [图 5.15](#ch05fig15) 所示。每个按钮通过一个 10 kΩ 的下拉电阻连接到地，并通过跳线连接到
    +5 V 电源轨。
- en: Create a new file called timer-advanced.js and start by adding the following
    code to handle button presses.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 timer-advanced.js 的新文件，并首先添加以下代码以处理按钮按下。
- en: 'Figure 5.15\. Wiring diagram showing only the buttons: Down, Up, and Go'
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.15\. 仅显示按钮的布线图：向下、向上和启动
- en: '![](05fig15_alt.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig15_alt.jpg)'
- en: Listing 5.15\. Test the Buttons in timer-advanced.js
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. 在 timer-advanced.js 中测试按钮
- en: '[PRE54]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By beginning with some simple button handlers, you can validate that your buttons
    are wired correctly before moving on to other parts of the device. Run the script
    (`node timer-advanced.js`) and verify that pressing the different buttons logs
    the correct message to the console.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 通过开始一些简单的按钮处理程序，你可以在继续到设备的其他部分之前验证你的按钮是否正确布线。运行脚本 (`node timer-advanced.js`)
    并验证按下不同的按钮是否将正确的消息记录到控制台。
- en: '|  |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Troubleshooting the buttons
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 按钮故障排除
- en: If pressing the buttons isn’t giving you the results you expect, make sure the
    jumper wires from the button’s output are connected to the Arduino correctly—specifically,
    that the breadboard side of the connection is in a hole between the button’s output
    leg and the resistor.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下按钮没有给出你期望的结果，请确保按钮的输出端跳线正确连接到 Arduino——特别是，连接到面包板侧的连接应在按钮输出腿和电阻之间的孔中。
- en: Double-check that the button’s input leg is connected to power and that the
    10 kV pull-down resistors connect each button to ground. Also make sure your push
    button’s orientation is correct—most buttons fit more comfortably across the center
    notch in one orientation (the correct one) but there are lots of different kinds
    of buttons out there.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查按钮的输入腿是否连接到电源，以及 10 kΩ 的下拉电阻是否将每个按钮连接到地。还请确保你的按钮方向正确——大多数按钮在一个方向上更适合跨越中心凹槽（正确的方向），但市面上有很多不同类型的按钮。
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Connecting the LCD
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接 LCD
- en: With the buttons squared away, we can move on to connecting the LCD module to
    the breadboard, connecting to most of its 16 pins ([figure 5.16](#ch05fig16)).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完按钮后，我们可以将 LCD 模块连接到面包板，连接到其大多数 16 个引脚（[图 5.16](#ch05fig16)）。
- en: Figure 5.16\. A 16x2 parallel LCD module
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.16\. 16x2 并行 LCD 模块
- en: '![](05fig16.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig16.jpg)'
- en: Go ahead and connect the LCD to the breadboard as shown in the LCD positioning
    diagram ([figure 5.17](#ch05fig17)), making sure the leftmost pin of the LCD module
    is connected to the leftmost row of the breadboard, as in the wiring diagram.
    The LCD’s pins are numbered 1–16, starting from the left in this orientation.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 LCD 定位图（[图 5.17](#ch05fig17)）所示连接 LCD 到面包板，确保 LCD 模块的左侧引脚连接到面包板的左侧行，如图中布线图所示。LCD
    的引脚编号为 1-16，从左侧开始编号。
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: LCD module pin outs
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LCD 模块引脚排列
- en: Most common 16x2 parallel modules have the same pin orientation, with pin 1
    at the left and 16 at the right, when in the orientation shown in the LCD positioning
    diagram ([figure 5.17](#ch05fig17)). Double-check that your LCD module has the
    same pin orientation—you may need to flip your LCD around if not.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见的16x2并行模块具有相同的引脚方向，当处于LCD定位图（[图5.17](#ch05fig17)）所示的方位时，引脚1位于左侧，16位于右侧。请务必检查您的LCD模块具有相同的引脚方向——如果不行，您可能需要将LCD翻转过来。
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 5.17\. Wiring diagram of timer including potentiometer and LCD placement
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.17\. 包含电位器和LCD位置的布线图
- en: '![](05fig17_alt.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig17_alt.jpg)'
- en: Next, connect the potentiometer to the breadboard.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将电位器连接到面包板上。
- en: Wiring a contrast-control potentiometer
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 布线对比度控制电位器
- en: 'Like photoresistors, potentiometers are a kind of variable resistor ([figure
    5.18](#ch05fig18)). Potentiometers have three pins: two power pins and a third,
    middle pin. As the knob is turned on a rotary potentiometer (or slid on other
    kinds of potentiometers), the voltage on its middle pin changes. Potentiometers
    have internal voltage dividers, so their output voltages can be read directly—we
    don’t have to build a voltage divider like we do with photoresistors.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 与光敏电阻一样，电位器是一种可变电阻（[图5.18](#ch05fig18)）。电位器有三个引脚：两个电源引脚和一个中间引脚。当旋转旋转电位器的旋钮（或在其他类型的电位器上滑动）时，其中间引脚上的电压会改变。电位器具有内部电压分压器，因此可以直接读取其输出电压——我们不需要像光敏电阻那样构建电压分压器。
- en: Figure 5.18\. Potentiometers are variable resistors. They come in several shapes
    and sizes.
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.18\. 电位器是可变电阻。它们有多种形状和大小。
- en: '![](05fig18_alt.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig18_alt.jpg)'
- en: In this circuit, the potentiometer’s middle pin is connected directly to the
    LCD’s pin 3\. The LCD’s onboard electronics read the voltage on that pin to determine
    the contrast of the display. Rotating the potentiometer will, therefore, adjust
    the contrast.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个电路中，电位器的中间引脚直接连接到LCD的引脚3。LCD板载电子设备读取该引脚上的电压以确定显示屏的对比度。因此，旋转电位器将调整对比度。
- en: 'Your potentiometer might be a different size or shape than the one shown in
    the LCD positioning diagram ([figure 5.17](#ch05fig17)): that’s fine. Connect
    its outer pins to power and ground—you can’t get it backwards, as potentiometers
    aren’t polarized. Either orientation works. Next, connect the potentiometer’s
    middle leg to pin 3 of the LCD (remember, connections don’t continue across the
    center notch).'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电位器可能大小或形状与LCD定位图（[图5.17](#ch05fig17)）中所示的不同：这没关系。将其外引脚连接到电源和地——由于电位器不是极性的，所以您无法接反。任何方向都可以。接下来，将电位器的中间腿连接到LCD的引脚3（记住，连接不会穿过中心缺口）。
- en: Completing the LCD’s connections
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完成LCD的连接
- en: Onward! The LCD has several power connections ([figure 5.19](#ch05fig19)). Connect
    LCD pins 1, 5, and 16 to the ground power rail and pins 2 and 15 to the source
    power rail.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进！LCD有几个电源连接（[图5.19](#ch05fig19)）。将LCD引脚1、5和16连接到地电源轨，将引脚2和15连接到源电源轨。
- en: Figure 5.19\. Wiring diagram showing the breadboard power connections to the
    LCD
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.19\. 显示面包板电源连接到LCD的布线图
- en: '![](05fig19.jpg)'
  id: totrans-622
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig19.jpg)'
- en: The connections to LCD pins 1 and 2 power the LCD itself, and LCD pins 15 and
    16 power the display’s LED backlight.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到LCD引脚1和2的连接为LCD本身供电，而LCD引脚15和16为显示屏的LED背光供电。
- en: Pin 5 is a read/write (R/W) pin. When it’s pulled to ground, it puts the LCD
    in write mode, which is what one often wants when using an LCD—to write to it.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚5是一个读/写（R/W）引脚。当它被拉到地时，将LCD置于写入模式，这在使用LCD时通常是想要的——写入它。
- en: The rest of the pins we’ll use on the LCD will connect directly to the Arduino’s
    pins ([figure 5.20](#ch05fig20)).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在LCD上使用的其余引脚将直接连接到Arduino的引脚（[图5.20](#ch05fig20)）。
- en: Figure 5.20\. Wiring diagram showing all of the LCD connections
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.20\. 显示所有LCD连接的布线图
- en: '![](05fig20.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig20.jpg)'
- en: LCD pin 4 is the register select (RS) pin. At certain times, Johnny-Five’s underlying
    software needs to send instructions to the LCD to tell it how to behave. At other
    times, it needs to send the specific data for display. This pin allows it to switch
    between the two different memory *registers* for instructions and data. It should
    be connected to pin 7 on the Arduino.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: LCD引脚4是寄存器选择（RS）引脚。在特定时间，Johnny-Five的底层软件需要向LCD发送指令以告诉它如何行为。在其他时候，它需要发送用于显示的具体数据。此引脚允许它在指令和数据的不同内存*寄存器*之间切换。它应该连接到Arduino的引脚7。
- en: Pin 6 on the LCD is the enable (EN) pin. It should be connected to pin 8 on
    the Arduino. Writing a voltage to this pin prompts the LCD to read incoming data
    waiting for it on the data pins.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: LCD上的第6脚是使能（EN）引脚。它应该连接到Arduino的第8脚。向该引脚写入电压会提示LCD读取数据引脚上等待的数据。
- en: Data pins, eh? Those are the last remaining LCD connections. Pins 7 through
    14 on the LCD are parallel data pins (D0–D7), which represent the bit values of
    data written to the registers of the device. You only need to connect four of
    the eight—D4 through D7 (LCD pins 11, 12, 13, and 14, connected to pins 9, 10,
    11, and 12 on the Arduino respectively). Whew. There are a lot of wires!
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 数据引脚？那些是LCD上最后剩下的连接。LCD上的第7到14脚是并行数据引脚（D0–D7），它们代表写入设备寄存器的数据位值。你只需要连接八个中的四个——D4到D7（LCD引脚11、12、13和14，分别连接到Arduino的9、10、11和12脚）。哇。有很多电线！
- en: Controlling the LCD with Johnny-Five
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Johnny-Five 控制 LCD
- en: 'You can take your LCD for a spin by using the Johnny-Five `LCD` class. By default,
    Johnny-Five’s `LCD` object constructor will treat the LCD as a parallel LCD. It
    expects an array of six pin numbers for wires attached to different pins on the
    LCD: register select (RS), enable (EN), and four data connections (D4, D5, D6,
    and D7).'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用Johnny-Five的`LCD`类来测试你的LCD。默认情况下，Johnny-Five的`LCD`对象构造函数会将LCD视为并行LCD。它期望一个包含六个引脚编号的数组，这些引脚连接到LCD上的不同引脚：寄存器选择（RS）、使能（EN）和四个数据连接（D4、D5、D6和D7）。
- en: 'The details of interacting with parallel LCDs are fairly low-level, but Johnny-Five
    abstracts much of that away for you. Useful `LCD` methods in Johnny-Five include
    these:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 与并行LCD交互的细节相当底层，但Johnny-Five为你抽象了其中很多。Johnny-Five中有用的`LCD`方法包括以下这些：
- en: '`cursor(row, column)`—Positions the cursor before displaying text'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cursor(row, column)`—在显示文本之前定位光标'
- en: '`print(str)`—Displays text starting at the current cursor position'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(str)`—在当前光标位置显示文本'
- en: '`clear()`—Clears the LCD’s contents'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`—清除LCD的内容'
- en: Try it out by adding more code to your timer-advanced.js script, as shown in
    the following listing.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下列表添加更多代码到你的timer-advanced.js脚本中，以进行测试。
- en: Listing 5.16\. Test the LCD
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.16\. 测试LCD
- en: '[PRE55]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Instantiates a Johnny-Five LCD object**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化一个Johnny-Five LCD对象**'
- en: '***2* Positions the cursor on the 0th line, 0th position (top left) and prints
    “hello, world”**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将光标定位在第0行，第0个位置（左上角）并打印“hello, world”**'
- en: '***3* Writes “hello, again” to the LCD’s second line, 0th position**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将“hello, again”写入LCD的第二行，第0个位置**'
- en: Run the script (`node timer-advanced.js`) and, once it’s running, turn the potentiometer’s
    dial to adjust the contrast on the LCD.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本（`node timer-advanced.js`），一旦运行，将电位计的旋钮转动以调整LCD的对比度。
- en: The LCD should display “hello, world” on the first line and “hello, again” on
    the second line.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: LCD应在第一行显示“hello, world”，在第二行显示“hello, again”。
- en: '|  |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Troubleshooting the LCD
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LCD故障排除
- en: If your LCD doesn’t seem to work right, or at all, the first thing to do is
    double-check all of the wire connections and make sure they’re connected to the
    correct pins on the Arduino.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的LCD似乎无法正常工作，或者完全不工作，首先应该检查所有电线连接，并确保它们连接到Arduino的正确引脚上。
- en: If your LCD doesn’t light up, check the power connections on pins 15 and 16
    (backlight power).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的LCD没有点亮，请检查第15和16脚（背光电源）的电源连接。
- en: Make sure the LCD module is seated correctly and that the pins are aligned accurately.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 确保LCD模块安装正确，并且引脚对齐准确。
- en: '|  |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Programming the timer’s logic
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编程定时器的逻辑
- en: Our LCD circuitry is ready. It’s time to program the timer. We’ll break this
    down into chunks, but an overview of the timer’s eventual structure is shown here.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LCD电路已经准备好了。现在是时候编程定时器了。我们将将其分解成几个部分，但定时器最终结构的概述如下所示。
- en: Listing 5.17\. Overview of timer application structure
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.17\. 定时器应用程序结构概述
- en: '[PRE56]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Jumping in from the top, a section of variable initialization sets up some of
    the values we’ll need for operating the timer, as shown in the following listing.
    Add these to timer-advanced.js.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，一个变量初始化部分设置了一些我们操作定时器所需的值，如下所示。将这些添加到timer-advanced.js中。
- en: Listing 5.18\. Setting up some values
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.18\. 设置一些值
- en: '[PRE57]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* 60 seconds is the default timer length, in ms. You can change this if
    you like.**'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 60秒是默认定时器长度，以毫秒为单位。如果你喜欢，可以更改它。**'
- en: '***2* The upper limit of the timer is 99 minutes.**'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定时器的上限是99分钟。**'
- en: '***3* You can’t make the timer shorter than one second.**'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你不能将定时器设置得短于1秒。**'
- en: The 99-minute upper limit is based on the way the remaining time is formatted
    on the LCD (`mm:ss`). Longer durations wouldn’t fit.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 99分钟的.upper limit是基于在LCD上格式化剩余时间的方式（`mm:ss`）。更长的持续时间将无法适应。
- en: Speaking of display formatting, let’s get that going. It’s time to add a function
    to initialize a timer and to show the time remaining in the current timer on the
    LCD. The next bit of code to add defines the `init()` and `showRemaining()` functions.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 说到显示格式，让我们开始吧。现在是时候添加一个初始化计时器并在LCD上显示当前计时器的剩余时间的函数了。接下来要添加的代码定义了 `init()` 和
    `showRemaining()` 函数。
- en: Listing 5.19\. Initializing and displaying timer remaining time
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.19\. 初始化并显示剩余计时器时间
- en: '[PRE58]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Initializes a new timer and some variables**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化一个新的计时器和一些变量**'
- en: '***2* Formats and displays the remaining time in this timer**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 格式化并显示此计时器的剩余时间**'
- en: '***3* Only updates the LCD if the formatted string has changed**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 只有当格式化的字符串已更改时才更新LCD**'
- en: The `showRemaining` function will get invoked frequently when the timer is actually
    running. The check to make sure the time string has changed before updating the
    LCD (`timeString != lastTimeString`) will improve performance. The time remaining
    in the current timer will display at the top left (cursor position 0, 0) of the
    LCD.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 当计时器实际运行时，`showRemaining` 函数将被频繁调用。在更新LCD之前确保时间字符串已更改的检查（`timeString != lastTimeString`）将提高性能。当前计时器的剩余时间将显示在LCD的左上角（光标位置0,
    0）。
- en: Onward! `upButton` and `downButton` should adjust the timer’s duration when
    pressed, adding or removing a second, respectively. The `adjustTime()` function
    (in [listing 5.20](#ch05ex20)) takes a `delta` in milliseconds and adjusts the
    timer’s duration by that amount, making sure to keep the total duration within
    bounds.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 前进！当按下 `upButton` 和 `downButton` 时，应调整计时器的持续时间，分别增加或减少一秒。`adjustTime()` 函数（在[列表5.20](#ch05ex20)中）接受一个以毫秒为单位的
    `delta`，并通过该值调整计时器的持续时间，确保总持续时间在范围内。
- en: Button handlers need to be registered to invoke `adjustTime()`, and this is
    also a good spot to initialize the timer (`init()`).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮处理程序需要注册以调用 `adjustTime()`，这也是初始化计时器（`init()`）的好地方。
- en: Add `adjustTime()` and the button handlers as follows.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `adjustTime()` 和按钮处理程序，如下所示。
- en: Listing 5.20\. Add time-adjustment handler functions
  id: totrans-672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.20\. 添加时间调整处理函数
- en: '[PRE59]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* The timer’s duration has changed, so the LCD’s display needs updating.**'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计时器的持续时间已更改，因此LCD的显示需要更新。**'
- en: '***2* Don’t forget to initialize the timer.**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不要忘记初始化计时器。**'
- en: Now, let’s hook up the Go button. That button should toggle the timer (play/pause).
    That means we’ll also need logic for activating the timer—invoking the `tick()`
    function every 250 ms—and pausing it, as shown in the next listing.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接Go按钮。该按钮应切换计时器（播放/暂停）。这意味着我们还需要激活计时器的逻辑——每250毫秒调用一次 `tick()` 函数——以及暂停它，如下一列表所示。
- en: Listing 5.21\. Making the timer tick
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.21\. 使计时器滴答
- en: '[PRE60]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Clears anything currently displayed on the LCD**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 清除LCD上当前显示的内容**'
- en: '***2* Sets an interval to invoke tick four times per second or so**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置一个间隔，每秒大约调用四次tick**'
- en: '***3* Kicks off the timer with a tick**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 启动计时器并发出tick**'
- en: '***4* Clears the timer interval so the timer stops ticking**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 清除计时器间隔，使计时器停止滴答**'
- en: '***5* PAUSED will get erased when the timer is started again by lcd.clear().**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当再次通过 lcd.clear() 启动计时器时，"PAUSED" 将被擦除。**'
- en: '***6* Makes sure there isn’t already a timer running before starting**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在启动之前确保没有正在运行的计时器**'
- en: Now you can start and pause the timer, but what happens when the time runs out?
    We need something to alert the user that their time is up.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始和暂停计时器，但时间用完时会发生什么？我们需要某种东西来提醒用户他们的时间已到。
- en: 5.2.2\. Adding a visual LED “chime”
  id: totrans-686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 添加视觉LED“提示音”
- en: As the final part of this circuit construction, you can add an LED as shown
    in [figure 5.21](#ch05fig21). It should be connected through a 220 V resistor
    to ground, and its anode should be connected to the Arduino’s pin 7.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此电路构建的最后一部分，你可以添加一个LED，如图5.21所示。它应该通过一个220 V电阻连接到地，其阳极应连接到Arduino的7号引脚。
- en: Figure 5.21\. The completed wiring diagram, with LED
  id: totrans-688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.21\. 带LED的完成布线图
- en: '![](05fig21_alt.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig21_alt.jpg)'
- en: We’ll need to make a few adjustments to the `start` and `tick` functions, and
    we’ll add a new `chime` function, shown in the next listing.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对 `start` 和 `tick` 函数进行一些调整，并添加一个新的 `chime` 函数，如下一列表所示。
- en: Listing 5.22\. Add a visual chime
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.22\. 添加视觉提示音
- en: '[PRE61]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Instantiates an Led object on pin 6**'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在6号引脚上实例化一个Led对象**'
- en: '***2* Any time the timer is counting down, the chime-LED should be off.**'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当计时器正在倒计时的时候，蜂鸣-LED应该关闭。**'
- en: '***3* Some logic to determine if time’s up and if so to clear the interval,
    and so on**'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一些逻辑来判断时间是否结束，如果是，则清除间隔，等等**'
- en: '***4* chime()...**'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* chime()...**'
- en: '***5* Pulses the LED! Time’s up!**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 闪烁LED！时间到！**'
- en: '***6* Displays “DONE!” as well**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 也会显示“完成！”**'
- en: Because `init()` is called again when time runs out, the timer can be used over
    and over again without restarting the program ([figure 5.22](#ch05fig22)). Try
    it!
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当时间结束时，会再次调用`init()`，所以计时器可以重复使用而不需要重新启动程序（[图5.22](#ch05fig22)）。试试看！
- en: '[PRE62]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|  |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Code architecture for the timer
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计时器的代码架构
- en: The logic for the timer all happens within the `ready` callback for the Johnny-Five
    `board` object, and it’s starting to feel unwieldy. It would likely be more elegant
    to encapsulate the logic in an external module. You’ll see examples of that in
    later chapters.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器的逻辑全部发生在Johnny-Five `board`对象的`ready`回调中，而且开始感觉难以控制。可能将逻辑封装在外部模块中会更优雅。你将在后面的章节中看到这方面的例子。
- en: '|  |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 5.22\. The timer, timing away!
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Figure 5.22\. 计时器，正在计时！
- en: '![](05fig22_alt.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig22_alt.jpg)'
- en: 5.3\. Making noise with a piezo
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 使用蜂鸣器制造噪音
- en: First off, I’m not going to try to convince you that piezos ([figure 5.23](#ch05fig23))
    make lovely, dulcet noises. They can produce tones, based on simple frequencies,
    but they sound tinny and grating. Still, you *can* make one play a song, and they’re
    fun to noodle around with. If you’d like to add a piezo to your timer, you can
    swap out the LED for a piezo (as you’ll see in [figure 5.24](#ch05fig24)). Then
    you’ll be ready to have fun and annoy friends with your piezo!
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我不会试图说服你蜂鸣器（[图5.23](#ch05fig23)）能发出美妙、悦耳的声音。它们可以根据简单的频率产生音调，但听起来很刺耳。尽管如此，*你可以*让它们演奏一首歌，而且它们很有趣，可以随意摆弄。如果你想将蜂鸣器添加到计时器中，你可以将LED换成蜂鸣器（如图5.24所示）。然后你就可以尽情玩耍，用你的蜂鸣器来烦扰朋友了！
- en: 'Figure 5.23\. Some piezos have wire leads, and others have legs. Piezos have
    two pins: + and -.'
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Figure 5.23\. 一些蜂鸣器有电线引脚，而另一些有腿。蜂鸣器有两个引脚：+ 和 -。
- en: '![](05fig23.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig23.jpg)'
- en: When voltage is applied to a piezo, it causes physical changes to the shape
    of a surface inside the piezo. Piezos *transduce* the electrical energy into mechanical
    energy, and we, as humans, detect that mechanical energy as sound waves. Applying
    voltages at specific frequencies creates vibrations that correspond to different
    musical notes. This phenomenon is known as the *reverse piezoelectric effect*—electricity
    is converted to mechanical movement.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当电压施加到蜂鸣器上时，它会导致蜂鸣器内部表面的物理形状发生变化。蜂鸣器*转换*电能成机械能，而我们人类将这种机械能检测为声波。在特定频率下施加电压，会产生与不同音符相对应的振动。这种现象被称为*逆压电效应*——电能转换为机械运动。
- en: Piezos can also be used as sensors. Used as an input, piezos can detect knocks
    or other kinds of vibrations. This demonstrates the reverse of the reverse piezoelectric
    effect, that is, the *piezoelectric effect*.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 蜂鸣器也可以用作传感器。作为输入使用时，蜂鸣器可以检测敲击或其他类型的振动。这展示了逆压电效应的反面，即*压电效应*。
- en: '|  |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Piezos: timing and frequencies**'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**蜂鸣器：时序和频率**'
- en: To get a piezo to squawk out a note requires a combination of PWM and timing.
    To make a piezo make noise, you give it voltage at a 50% duty cycle—this creates
    square waves (on off on off). To make a piezo play a particular note, you adjust
    the frequency of these PWM cycles.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 要让蜂鸣器发出一个音符，需要PWM和时序的结合。要让蜂鸣器发声，你需要以50%的占空比给它施加电压——这会产生方波（开 关 开 关）。要让蜂鸣器演奏特定的音符，你需要调整这些PWM周期的频率。
- en: For example, the note A4, or A440 is a common reference tuning note. It’s called
    A440 because it vibrates at 440 Hz. Every 1/440th of a second, there’s a full
    wave period. In real life, these are smooth analog waves. With a piezo, they are
    square digital waves. By applying a 50% duty cycle voltage to a piezo 440 times
    a second, you can approximate A4.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，音符A4，或A440是一个常见的参考调音音符。它被称为A440，因为它以440 Hz振动。每1/440秒，有一个完整的波周期。在现实生活中，这些是平滑的模拟波。使用蜂鸣器，它们是方波数字波。通过每秒向蜂鸣器施加440次50%占空比的电压，你可以近似A4。
- en: '![](0142fig01_alt.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![](0142fig01_alt.jpg)'
- en: The octaves contained on a standard 88-key piano keyboard. A4 (a.k.a. A440)
    is the A above middle C (the A in the fourth octave).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的88键钢琴键盘上包含的八度。A4（即A440）是中音C以上的A（第四八度的A）。
- en: Musical frequencies double every octave, so that by the time you get to A7,
    you’re looking at 3520 Hz.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐频率每八度翻倍，所以当你到达A7时，你看到的是3520 Hz。
- en: '![](0143fig01_alt.jpg)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![](0143fig01_alt.jpg)'
- en: Frequency doubles every octave. A3 (220 Hz) is half the frequency of A4 (440
    Hz), whereas A5 (880 Hz) is double the frequency of A4\. A’s have nice round frequencies.
    The notes between also have predictable frequencies that double every octave,
    such as middle C (C4) at 261.626 Hz and C5 at 523.521 Hz.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 每个八度频率翻倍。A3（220 Hz）是A4（440 Hz）频率的一半，而A5（880 Hz）是A4的频率的两倍。A音符有很好的圆形频率。中间C（C4）的频率为261.626
    Hz，C5的频率为523.521 Hz，它们之间的音符也有可预测的频率，每个八度翻倍。
- en: In Johnny-Five, A4 (A440) is created by alternately writing HIGH and LOW to
    the piezo’s pin in equal intervals 880 times per second. Yep, 880—that’s twice
    the frequency, because one full “wave” (on-off) should happen 440 times per second.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在Johnny-Five中，A4（A440）是通过每秒交替写入HIGH和LOW到压电片的引脚上，以相等的间隔880次来创建的。是的，880次，因为一个完整的“波”（开-关）应该每秒发生440次。
- en: '![](0143fig02.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](0143fig02.jpg)'
- en: The note A4 has a frequency of 440 Hz. A complete wave period is 1/440th of
    a second. Unlike natural, analog sound waves, which have smooth curves, piezos
    emit square waves.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: A4音符的频率为440 Hz。一个完整的波周期是1/440秒。与自然、模拟声波不同，它们有平滑的曲线，压电片发出的是方波。
- en: The frequencies involved here far exceed the resolution of what you can do with
    built-in JavaScript timers (`setInterval`, `setTimeout`), so Johnny-Five depends
    on an npm package called `nanotimer`. This allows `setInterval`-like behavior
    but at much more precise, fine-grained precision.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及到的频率远远超过了您可以使用内置JavaScript计时器（`setInterval`，`setTimeout`）所能达到的分辨率，因此Johnny-Five依赖于一个名为`nanotimer`的npm包。这允许像`setInterval`一样的行为，但精度更高，粒度更细。
- en: '|  |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.3.1\. Adding an audible piezo chime to the timer
  id: totrans-727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 将可发声的压电片铃声添加到计时器
- en: Depending on which kind of piezo you have, either plug it directly into the
    breadboard or plug its wires into the breadboard ([figure 5.24](#ch05fig24)).
    Don’t forget to remove the 220 V resistor, as well.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您拥有的压电片类型，可以直接将其插入面包板，或者将它的电线插入面包板（[图5.24](#ch05fig24)）。别忘了也要移除220 V电阻。
- en: Figure 5.24\. Wiring diagram showing the replacement of the LED with a piezo
  id: totrans-729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.24\. 替换LED的压电片接线图
- en: '![](05fig24_alt.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig24_alt.jpg)'
- en: Playing tunes on the piezo
  id: totrans-731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在压电片上播放旋律
- en: The code changes for the timer are minor. Inside of timer-advanced.js, instantiate
    a `Piezo` instead of an `Led` and remove the reference to `alertLED` from the
    `start()` function, as shown in the following listing.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器的代码更改很小。在timer-advanced.js内部，实例化一个`Piezo`而不是`Led`，并从`start()`函数中移除对`alertLED`的引用，如下所示。
- en: Listing 5.23\. Instantiating a piezo
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.23\. 实例化一个压电片
- en: '[PRE63]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Johnny-Five’s `Piezo` class gives you some handy tools to make piezos play tunes,
    handling the complex timing and frequency conversions. Notes are exposed by their
    names (such as `'e5'`) so you don’t have to memorize frequencies. You can pass
    an object representing a “tune” to the `play` method, with properties such as
    `tempo` (BPM) and a `song` (array of notes and their durations).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的`Piezo`类提供了一些方便的工具来使压电片播放旋律，处理复杂的时序和频率转换。音符通过它们的名称（如`'e5'`）暴露出来，这样您就不需要记住频率。您可以将表示“旋律”的对象传递给`play`方法，其中包含如`tempo`（BPM）和`song`（音符及其持续时间的数组）等属性。
- en: Update the `chime()` function to play a song, as shown in the next listing.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`chime()`函数以播放歌曲，如下所示。
- en: Listing 5.24\. The new `chime()` function
  id: totrans-737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.24\. 新的`chime()`函数
- en: '[PRE64]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* tempo is an optional property.**'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 速度是一个可选属性。**'
- en: '***2* This will play the note e5 for 1 “beat”.**'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这将播放e5音符1个“拍”。**'
- en: You’ll have to try this out to find out what the time’s-up tune is!
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要亲自尝试以找出时间到调是什么！
- en: Summary
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: An LED can only emit one wavelength (color) and can only be off or on at any
    given time, but pulse-width modulation (PWM) can be used to fool the eye into
    thinking an LED is shining at different brightnesses.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个LED只能发出一种波长（颜色），在任何给定时间只能处于关闭或开启状态，但可以通过脉冲宽度调制（PWM）来欺骗眼睛，使其认为LED在不同的亮度下发光。
- en: PWM support is a hardware feature, and only some pins on development boards
    support PWM.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWM支持是硬件特性，并且只有开发板上的某些引脚支持PWM。
- en: The brightness of LEDs can be “animated” to create effects and communicate information.
    Using different easing functions and providing different animation options can
    generate different outcomes with Johnny-Five.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED的亮度可以被“动画化”，以创建效果和传达信息。使用不同的缓动函数和提供不同的动画选项，可以用Johnny-Five生成不同的结果。
- en: RGB LEDs combine three LEDs (red, green, blue) at different brightnesses—via
    PWM—to create different colors. Common cathode RBG LEDs have three component LEDs
    that share a single cathode leg.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB LED通过PWM将三个LED（红、绿、蓝）以不同的亮度组合在一起，以创建不同的颜色。常见的共阴极RGB LED有三个组件LED，它们共享一个共同的阴极引脚。
- en: Parallel LCDs have a lot of connections. Johnny-Five provides a simplified interface
    to LCDs via its `LCD` class.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并联LCD有很多连接。Johnny-Five通过其`LCD`类提供了一个简化的LCD接口。
- en: Potentiometers are another kind of variable resistor, like photoresistors. Unlike
    photoresistors, they have their own internal voltage dividers, so changing voltage
    can be read on the third pin.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动变阻器是另一种可变电阻，类似于光敏电阻。与光敏电阻不同，它们有自己的内部电压分压器，因此可以在第三个引脚上读取电压变化。
- en: Piezos take advantage of the reverse piezoelectric effect to transduce voltages
    at different frequencies into mechanical motion, and, as a result, sound waves.
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马达石利用逆压电效应将不同频率的电压转换为机械运动，从而产生声波。
- en: 'Chapter 6\. Output: making things move'
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章：输出：让事物移动
- en: '*This chapter covers*'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: How motors work and what makes them spin
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电机的工作原理以及是什么使它们旋转
- en: The inductive characteristics of motors and how to safely construct motor circuits
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电机感应特性以及如何安全构建电机电路
- en: Using diodes, capacitors, and transistors in circuits to control motors and
    protect components
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电路中使用二极管、电容器和晶体管来控制电机并保护组件
- en: How to position things, precisely, with servos
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用伺服电机精确定位事物
- en: How to control motors using an H-bridge circuit and motor drivers
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用H桥电路和电机驱动器控制电机
- en: How to build your first basic, roving robot
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建你的第一个基本、移动的机器人
- en: By now you’re likely tapping your feet impatiently and wondering, “When do we
    get to make *robots*?” Well, your ship has come in. It’s time to learn how to
    make things move.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经不耐烦地跺脚，想知道：“我们什么时候能做*机器人*？”好吧，你的船已经到了。是时候学习如何让事物移动了。
- en: The motors and servos you’re about to get to know provide the fundamental control
    of robots’ movements. There’s lots to learn, but by the end of this chapter you’ll
    have built a basic roving bot.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将了解的电机和伺服电机为机器人的基本运动控制提供基础。有很多东西要学习，但到本章结束时，你将构建一个基本的移动机器人。
- en: 'Making robots move involves choreographing electronically controlled movement.
    Motors spin, making wheels roll. Servos allow precise positioning of components:
    cameras, robotic arms, and so on. Let’s get moving.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 让机器人移动涉及编排电子控制动作。电机旋转，使轮子滚动。伺服电机允许精确定位组件：摄像头、机械臂等。让我们开始行动吧。
- en: '|  |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](tool.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下物品：**'
- en: Arduino Uno and USB cable
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno和USB线
- en: 1 9 V DC motor
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个9V直流电机
- en: 1 9 V battery and snaps
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个9V电池和夹子
- en: 1 1N4001 diode
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1N4001二极管
- en: 1 N-channel MOSFET, such as FQP30N06L
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个N沟道MOSFET，例如FQP30N06L
- en: 1 100 μF capacitor
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个100μF电容器
- en: 1 4.8 V micro servo
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个4.8V微型伺服电机
- en: 1 Texas Instruments SN754410 Quadruple Half-H Driver
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个德州仪器SN754410四倍半H驱动器
- en: Actobotics Peewee Runt Rover kit (or 2 gearmotors, 2 wheels, chassis)
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actobotics Peewee Runt Rover套件（或2个齿轮电机，2个轮子，底盘）
- en: Breakaway male header pins
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开式雄性引脚头
- en: Jumper wires
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 1 half-size breadboard
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个半尺寸面包板
- en: '![](0145fig01_alt.jpg)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![](0145fig01_alt.jpg)'
- en: '|  |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1\. Making motors spin
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1. 让电机旋转
- en: Motors convert electrical energy into mechanical energy ([figure 6.1](#ch06fig01)).
    Current goes in and motion comes out, typically in a rotary form, such as a spinning
    axle.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 电机将电能转化为机械能（[图6.1](#ch06fig01)）。电流进入，运动出来，通常是旋转形式，如旋转轴。
- en: Figure 6.1\. A typical hobby DC motor
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1：典型的业余DC电机
- en: '![](06fig01_alt.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: At the heart of a motor’s electricity-to-motion alchemy? Magnets!
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 电机将电能转化为动能的魔法核心？磁铁！
- en: '|  |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Actual current flow
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实际电流流动
- en: Recall how conventional current representations show electrical current as flowing
    from positive to negative, but in reality the opposite is closer to the truth?
    The actual direction of current flow is relevant to some of the topics covered
    in this chapter, and, as such, the conceptual diagrams show current flowing from
    negative toward positive.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，传统的电流表示法显示电流从正极流向负极，但在现实中，相反的情况更接近真相？电流的实际流动方向与本章涵盖的一些主题相关，因此概念图显示电流从负极流向正极。
- en: '|  |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1.1\. How motors work
  id: totrans-787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1. 电机的工作原理
- en: When an electrical current runs through a wire, a magnetic field is also created.
    The magnetic field is oriented at a right angle to the current’s direction ([figure
    6.2](#ch06fig02)).
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 当电流通过导线时，也会产生磁场。磁场与电流方向成直角（[图6.2](#ch06fig02)）。
- en: Figure 6.2\. Electrical current through a wire creates a magnetic field at a
    right angle to current flow.
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2。导线中的电流在电流流动的垂直方向上产生磁场。
- en: '![](06fig02_alt.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig02_alt.jpg)'
- en: 'The current-induced magnetic field near a single, straight wire is weak, relatively
    speaking. But it’s possible to concentrate the magnetic effect by winding a length
    of wire around (and around and around) a piece of metal. When current is applied
    to the *coil* of wire, the collective right-angle magnetic field has enough oomph
    to yank some of the previously disorganized atoms in the metal core into a north-south
    alignment. And, voila! You’ve created a magnet by using electricity: an *electromagnet*
    ([figure 6.3](#ch06fig03)).'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在一根单独的直导线附近，由电流引起的磁场相对较弱。但可以通过将一段导线绕在（以及绕在绕在绕在）金属块上，来集中磁效应。当电流施加到导线的线圈上时，集体直角磁场具有足够的能量，可以将金属芯中先前无序排列的一些原子拉入南北方向对齐。而且，看！你已经通过使用电创造了磁铁：一个*电磁铁*（[图6.3](#ch06fig03)）。
- en: Figure 6.3\. The current through the coil creates a magnetic field that magnetizes
    the iron core of the electromagnet.
  id: totrans-792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3。线圈中的电流产生磁场，磁化电磁铁的铁芯。
- en: '![](06fig03.jpg)'
  id: totrans-793
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig03.jpg)'
- en: If you reverse the direction of the current that’s running through the coiled
    wire, the electromagnet’s polarity will flip too—the north and south magnetic
    poles will swap places ([figure 6.4](#ch06fig04)). Cut off current from the wire,
    and the magnetic field will dissipate—you can turn your magnet off!
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你反转通过线圈导线的电流方向，电磁铁的极性也会翻转——南北磁极会互换位置（[图6.4](#ch06fig04)）。切断导线的电流，磁场就会消散——你可以关闭你的磁铁了！
- en: Figure 6.4\. Reversing current flow reverses the polarity of the electromagnet.
  id: totrans-795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4。反转电流流动反转了电磁铁的极性。
- en: '![](06fig04.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig04.jpg)'
- en: 'Let’s envision our imaginary electromagnet being put to theoretical use. In
    the left side of [figure 6.5](#ch06fig05), an unpowered electromagnet is mounted
    on an axle and suspended between two stationary magnets. As soon as current is
    applied to the electromagnet (the middle of [figure 6.5](#ch06fig05)), the electromagnet
    will want to align itself as magnetic forces dictate—its north pole toward the
    stationary magnet with the inward-facing south pole. What it will want to do is
    rotate half a turn to make this happen, like on the right in [figure 6.5](#ch06fig05).
    Of course, this hypothetical motor isn’t going to work: the battery is in the
    way and things are getting all tangled up.'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想我们的想象中的电磁铁被用于理论应用。在[图6.5](#ch06fig05)的左侧，一个未通电的电磁铁安装在一个轴上，并悬挂在两个固定磁铁之间。一旦电流施加到电磁铁上（[图6.5](#ch06fig05)的中间），电磁铁就会想要按照磁力指示的方式对齐——其北极指向具有朝内面对的南极的固定磁铁。它想要做的是旋转半圈来实现这一点，就像[图6.5](#ch06fig05)的右侧所示。当然，这个假设的电机不会工作：电池挡在中间，事情变得一团糟。
- en: Figure 6.5\. An electromagnet on an axle between two fixed magnets is going
    to want to orient itself—by rotating—as magnetic forces dictate.
  id: totrans-798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5。一个位于两个固定磁铁之间的轴上的电磁铁将想要通过旋转来对齐自己——按照磁力指示。
- en: '![](06fig05_alt.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig05_alt.jpg)'
- en: Without further intervention, things would stop here—the magnets are aligned
    in a happy way. But if we were able to swap the current direction through the
    electromagnet again at exactly this spot, the motion could be forced to continue,
    as the magnet seeks to align itself correctly once more. Reversing current polarity
    every half-turn could keep things going forever. Indeed, this concept is how motors
    work. A motor wired like the thing shown in [figure 6.5](#ch06fig05) would quickly
    become a tangle of batteries and wires, so a real motor involves some design enhancements.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 没有进一步的干预，事情就会在这里停止——磁铁以愉快的方式排列。但如果我们能够再次在这个确切的位置交换电磁铁中的电流方向，运动就可以被迫继续，因为磁铁试图再次正确对齐自己。每半转反转电流极性可以使事物永远继续。事实上，这正是电机工作的原理。像[图6.5](#ch06fig05)中显示的那样连接的电机将很快变成一团电池和导线的混乱，所以真正的电机涉及一些设计改进。
- en: '[Figure 6.6](#ch06fig06) shows a—still oversimplified—*brushed DC motor*. The
    wall of the motor contains fixed magnets. Positive and negative power connections
    from the power source are connected to two stationary *brushes*, which “brush
    on” power in a given polarity as the motor’s shaft turns and they come into contact
    with different parts of a split ring called a *commutator*. The current—and, thus,
    the magnetic field—changes polarity as the motor turns, keeping everything in
    motion. Brushed motors are very common, but non-brushed motors use the same general
    concepts—electricity and magnets—to accomplish the same thing.'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.6](#ch06fig06) 展示了一个——仍然过于简化的——*刷式直流电机*。电机的壁包含固定磁铁。电源的正负极连接到两个静止的 *刷子*，当电机的轴转动并接触分环的不同部分时，它们“刷”上给定极性的电源。随着电机的转动，电流——因此，磁场——极性改变，保持一切运动。刷式电机非常常见，但无刷电机使用相同的一般概念——电和磁——来完成相同的事情。'
- en: Figure 6.6\. A brushed motor’s electromagnets are connected to a split ring
    called a *commutator* (A). The commutator and electromagnets rotate as the motor
    spins. Fixed-position *brushes* (B) are attached to the power supply and “brush”
    alternating polarities onto the commutator as it rotates beneath them, changing
    the polarity of the electromagnets on the motor’s *armature* (C).
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6\. 刷式电机的电磁铁连接到一个称为 *换向器* 的分环（A）。当电机旋转时，换向器和电磁铁一起旋转。固定位置的 *刷子*（B）连接到电源，并在它们下方旋转时“刷”上交替的极性，改变电机
    *电枢*（C）上电磁铁的极性。
- en: '![](06fig06.jpg)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig06.jpg)'
- en: 6.1.2\. Controlling a motor with a push-button switch
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 使用按钮开关控制电机
- en: Let’s ease into motor control gently by building a basic circuit that powers
    a motor, controlled by a push button. In a bit, we’ll add the ability to control
    the motor with the Arduino Uno and Johnny-Five.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建一个基本的电路来逐步学习电机控制，该电路由按钮控制电机。稍后，我们将添加使用 Arduino Uno 和 Johnny-Five 控制电机的功能。
- en: '|  |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要的东西
- en: '![](note.jpg)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![图片](note.jpg)'
- en: 1 9 V battery
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 9 V 电池
- en: 1 9 V battery snap with leads
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个带引线的 9 V 电池夹
- en: 1 small DC motor, rated up to 9 V
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个额定电压高达 9 V 的小型直流电机
- en: 1 1N4001 diode
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 1N4001 二极管
- en: 1 jumper wire (black)
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 根跳线（黑色）
- en: 1 half-size breadboard
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个半尺寸面包板
- en: '|  |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Motors take electricity in, and put mechanical rotation out. But the inverse
    is also true: if the shaft of a motor is turned (mechanical energy is applied),
    the motor will *generate* electrical energy—it acts as a *generator*. This is
    how water can generate (hydroelectric) power, for example. Flowing water physically
    turns the shaft of a motor (generator), and electricity comes out. So motors also
    take mechanical energy in, and put electricity out ([figure 6.7](#ch06fig07)).
    This set of phenomena—the creation of voltage or motion via interactions with
    magnetic fields—is called *inductance*. A motor is an *inductive* component.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 电机接收电能，输出机械旋转。但反过来也是真的：如果电机的轴被转动（施加机械能），电机将 *产生* 电能——它充当 *发电机*。例如，水可以通过水力发电产生能量。流动的水物理地转动电机的轴（发电机），然后产生电能。所以电机也接收机械能，并输出电能（[图
    6.7](#ch06fig07)）。这一系列现象——通过磁场相互作用产生电压或运动——被称为 *电感*。电机是一个 *电感* 元件。
- en: Figure 6.7\. When a motor is turned by an external force, electrical current
    is generated.
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.7\. 当电机被外部力量驱动时，会产生电流。
- en: '![](06fig07_alt.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig07_alt.jpg)'
- en: The characteristics of inductive components have relevance to your circuitry.
    Say you apply current to a motor, and it’s spinning merrily along. Remove the
    current—shut off the power—and the motor will continue to spin on its own for
    a little while. During this brief time, it will be generating power, and an important
    thing to note is that a motor (or any inductor) will generate voltage in the *opposite
    direction* of the input voltage ([figure 6.8](#ch06fig08)).
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 诱导元件的特性与你的电路有关。比如说，你给电机施加电流，它愉快地旋转着。移除电流——关闭电源——电机将自行继续旋转一段时间。在这短暂的时间内，它将产生能量，值得注意的是，电机（或任何电感器）将在
    *相反方向* 上产生电压（[图 6.8](#ch06fig08)）。
- en: Figure 6.8\. When a motor is connected to a power supply, current flows from
    negative (low potential) toward positive (higher potential). The current flow
    causes the motor to spin. When current flow is removed from the motor, inertia
    causes the motor to continue spinning briefly. During this time, the motor acts
    as a generator, generating electricity with voltage opposite to the previous input
    voltage.
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. 当电机连接到电源时，电流从负极（低电位）流向正极（高电位）。电流流动使电机旋转。当从电机移除电流流动时，惯性会使电机短暂继续旋转。在这段时间内，电机充当发电机，产生与先前输入电压相反的电压。
- en: '![](06fig08_alt.jpg)'
  id: totrans-821
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig08_alt.jpg)'
- en: This means that the electricity flow can “move around backwards” in your circuit,
    and the negative voltage spike can be huge (albeit for a very short amount of
    time). Without intervention, this *back voltage* (also called *back electromotive
    force* or *back-EMF*) can do nasty things, like damage components or cause actual
    sparks to leap around!
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着电流可以在你的电路中“倒流”，并且负电压尖峰可能非常大（尽管时间非常短）。如果不进行干预，这种*反向电压*（也称为*反向电动势*或*反-EMF*）可能会做坏事，比如损坏元件或导致真正的火花跳跃！
- en: A circuit without protection from this back voltage works fine when the circuit
    is closed and current is flowing through the motor ([figure 6.9](#ch06fig09)),
    but it can be problematic when the current through the motor changes ([figure
    6.10](#ch06fig10)), which changes when the button is released (the switch is opened,
    breaking the circuit).
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 当电路闭合且电流通过电机([图6.9](#ch06fig09))时，没有保护这种反向电压的电路可以正常工作，但当电机中的电流发生变化([图6.10](#ch06fig10))时，这会在按钮释放（开关打开，断开电路）时发生变化，它可能会出现问题。
- en: Figure 6.9\. In the unprotected circuit pictured here, current flow is controlled
    with a push button (switch). When the switch is pressed and held, the current
    flows as expected, powering the motor. The motor consumes the voltage provided.
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9\. 在此处所示的未受保护的电路中，电流流动是通过一个按钮（开关）来控制的。当按下并保持开关时，电流按预期流动，为电机供电。电机消耗提供的电压。
- en: '![](06fig09.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig09.jpg)'
- en: The large negative voltage briefly generated in [figure 6.10](#ch06fig10) wants
    so very much to make a path to the +9 V voltage that it might do crazy things,
    like leap through the air or through other non-conductive materials to get there.
    We’ve got to protect our circuit against this kind of inductive voltage spike.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6.10](#ch06fig10)中短暂生成的较大负电压非常渴望找到通往+9 V电压的路径，它可能会做出疯狂的事情，比如飞跃空中或通过其他非导电材料到达那里。我们必须保护我们的电路免受这种感应电压尖峰的影响。
- en: Figure 6.10\. When the button is released (switch opened), the motor continues
    to spin for a little while. During this time it’s generating negative voltage.
    The lead formerly connected to the positive terminal of the battery (through the
    switch) can build up a very large negative potential—hundreds of volts, say—which
    is much, much lower than the +9 V of the battery.
  id: totrans-827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. 当按钮释放（开关打开）时，电机继续旋转一段时间。在这段时间内，它正在产生负电压。之前连接到电池正极（通过开关）的引线可能会积累一个非常大的负电位——比如数百伏，这比电池的+9
    V要低得多。
- en: '![](06fig10.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig10.jpg)'
- en: Managing back voltage with flyback diodes
  id: totrans-829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用反冲二极管管理反向电压
- en: We’ve got to manage this back voltage situation for the health and safety of
    our circuit. We need to make sure negative voltage isn’t allowed to go wandering
    around the circuit willy-nilly, hurting innocent components.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须管理这种反向电压情况，以确保电路的健康和安全。我们需要确保负电压不会被允许随意在电路中游荡，伤害无辜的元件。
- en: There’s a standard method for accomplishing this, using a diode ([figure 6.11](#ch06fig11)).
    You briefly met diodes in [chapter 2](kindle_split_009.html#ch02)—LEDs are a kind
    of diode. A diode is a semiconductor component that only allows current to flow
    through it in one direction.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种标准方法来完成这项任务，使用二极管([图6.11](#ch06fig11))。你曾在[第2章](kindle_split_009.html#ch02)中简要地遇到过二极管——LED就是二极管的一种。二极管是一种半导体元件，只允许电流单向通过它。
- en: Figure 6.11\. Diodes are semiconductor components that only permit current to
    flow in one direction.
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11\. 二极管是半导体元件，只允许电流单向流动。
- en: '![](06fig11_alt.jpg)'
  id: totrans-833
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig11_alt.jpg)'
- en: The diode placement in the circuit wiring diagram for the pushbutton-controlled
    motor we’re about to construct—with the diode’s cathode connected to the positive
    power rail—looks backwards, and it *is* ([figure 6.12](#ch06fig12)).
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将构建的按钮控制电机电路图中的二极管放置看起来是反的，并且它确实是([图6.12](#ch06fig12))。
- en: Figure 6.12\. Circuit diagram of a basic, push-button-controlled motor, including
    a protective diode
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12\. 基本按钮控制电机电路图，包括保护二极管
- en: '![](06fig12.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig12.jpg)'
- en: The way the diode is oriented (“backwards,” or, more technically, *reverse-biased*)
    in the circuit means that current will be blocked from flowing through it—usually.
    But when the back-voltage situation arises, and the flow through the circuit is
    topsy-turvy, the diode becomes temporarily *forward-biased*—it’s momentarily oriented
    so that current can flow across it. At these times, it can create a path to “wick
    away” dangerous negative voltage current and reroute it through the motor over
    and over again until the negative voltage dissipates naturally on its own (don’t
    worry, it will, and quickly).
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 二极管在电路中的方向（“反向”，或更技术性地，*反向偏置*）意味着电流将被阻止流过它——通常。但当出现反向电压情况，并且电路中的流动是颠倒的，二极管暂时变为*正向偏置*——它暂时调整为电流可以流过它的方向。在这些时候，它可以创建一个路径来“吸收”危险的负电压电流，并反复通过电机重新路由，直到负电压自然耗散（别担心，它会，而且很快）。
- en: A diode used this way is called a *flyback diode*, or a *snubber diode* ([figure
    6.13](#ch06fig13)).
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用的二极管被称为*反激二极管*，或*吸收二极管*([图6.13](#ch06fig13))。
- en: Figure 6.13\. If a flyback diode is used in a circuit with an inductor like
    a motor, it can provide a path for pent-up negative voltage that’s trying to go
    the wrong way. It can route it back through the motor in a loop until it dissipates.
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.13\. 如果在包含如电机这样的电感器的电路中使用反激二极管，它可以提供一个路径，让试图错误方向流动的积压负电压流过。它可以通过电机在回路中循环，直到它耗散。
- en: '![](06fig13.jpg)'
  id: totrans-840
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig13.jpg)'
- en: Powering motors in circuits
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 电路中电机的供电
- en: Inductive elements like motors are current-hungry, especially when they’re being
    turned on or off (by now you’ve probably recognized that inductors have some interesting
    characteristics when they’re starting up or shutting down). The maximum current
    draw possible from a single Arduino Uno pin is only 20 mA—this isn’t enough! Plus,
    many hobby motors are rated at 6 V or even 9 V—more than the Uno can provide,
    voltage-wise. We’ll use a stable, separate power source for our motor—a 9 V battery—to
    make sure our motor gets the juice it needs.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 电机这样的电感元件是电流消耗者，尤其是在它们被打开或关闭时（到现在你可能已经意识到，当电感器启动或关闭时，它们有一些有趣的特性）。单个Arduino Uno引脚可能的最大电流抽取仅为20
    mA——这还不够！此外，许多业余电机被评定为6 V或甚至9 V——电压上超过了Uno能提供的。我们将为我们的电机使用一个稳定、独立的电源——9 V电池，以确保我们的电机得到它需要的能量。
- en: Building the circuit
  id: totrans-843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路
- en: For the motor shown in [figure 6.12](#ch06fig12) to spin, you’ll need to create
    a closed path from the power source (positive battery terminal) to ground (negative
    battery terminal). Pressing the push button will connect this path—the motor will
    operate when the button is pressed.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使[图6.12](#ch06fig12)中所示的电机旋转，你需要从电源（正电池端子）到地（负电池端子）创建一个闭合回路。按下按钮将连接这个回路——当按钮被按下时，电机将运行。
- en: Build the circuit as shown in [figure 6.12](#ch06fig12), taking care to orient
    the flyback diode correctly. If you get it backwards, it’s going to get really
    hot (at a minimum) or possibly even blow up or damage the battery.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图6.12所示构建电路，注意正确放置反激二极管。如果你放反了，它可能会非常热（至少），甚至可能爆炸或损坏电池。
- en: Once you’ve constructed the circuit, you should be able to start the motor by
    holding down the push button. Those little hobby motors spin fast!
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了电路，你应该能够通过按下按钮来启动电机。那些小型的业余电机转速很快！
- en: '|  |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Spinning motors backwards
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反向旋转电机
- en: 'Your motor may have red and black wire leads, implying that there’s a “correct”
    or “polarized” way to plug the motor into a circuit. That’s a little misleading:
    motors are happy plugged in in either orientation—swapping the connections will
    simply reverse the direction that the motor spins. You’re welcome to try reorienting
    your motor’s leads in the circuit and see if you can get it to run “backwards.”
    Changing the direction of current through a motor to change the motor’s direction
    is a key part of robotic control, as you’ll see in a bit.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电机可能有红黑两根线引脚，这意味着有“正确”或“极化”的方式将电机插入电路。这有点误导：电机无论是哪种方向插入电路都很高兴——交换连接只会简单地反转电机旋转的方向。你可以尝试重新调整电机引脚在电路中的方向，看看是否能使其反向运行。通过改变电机中的电流方向来改变电机的方向是机器人控制的关键部分，你将在下面看到。
- en: '|  |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1.3\. Controlling a motor with Johnny-Five
  id: totrans-851
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 使用Johnny-Five控制电机
- en: 'Our first motor experiment has a few shortcomings: there’s no logic controlling
    the motor—just our own fingers—and the motor is either on (full speed!) or off—there’s
    nothing in between.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次的电机实验有几个缺点：没有逻辑控制电机——只有我们自己的手指——电机要么全速运行要么关闭——中间没有其他选择。
- en: Johnny-Five has a `Motor` component class that can give you more control over
    the motor’s speed. It gives you even more control if you use more sophisticated
    integrated circuits or motor controllers—but let’s start basic.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five有一个`Motor`组件类，可以让你对电机速度有更多的控制。如果你使用更复杂的集成电路或电机控制器，你将获得更多的控制——但让我们从基础开始。
- en: '|  |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备
- en: '![](note.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno和USB线
- en: 1 9 V battery
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 9V电池
- en: 1 9 V battery snap with leads
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 9V电池夹带引线
- en: 1 small 9 V DC motor
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 小型9V直流电机
- en: 1 1N4001 diode
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 1N4001二极管
- en: 1 N-channel MOSFET, such as the FQP30N06L
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 N沟道MOSFET，例如FQP30N06L
- en: 4 jumper wires
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 跳线
- en: 1 half-size breadboard
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: '|  |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In this experiment, we want to replace the human-powered push-button switch
    with a switching mechanism that can be controlled by the output from one of the
    Uno’s pins. You already know that the motor needs more than the Arduino’s on-board
    power can provide—both in terms of voltage and current—but any output signal from
    an Uno pin is going to be at 5 V. We’re going to end up with circuitry that combines
    two separate power sources: 9 V (battery) and 5 V (Arduino logic).'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们希望用可以由Arduino引脚输出控制的切换机制来替换人力推动的按钮开关。你已经知道电机需要的不仅仅是Arduino板载电源可以提供的——无论是电压还是电流——但任何来自Arduino引脚的输出信号都将为5V。我们将得到一个结合两个独立电源的电路：9V（电池）和5V（Arduino逻辑）。
- en: Using transistors as switches
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用晶体管作为开关
- en: 'MOSFETs are *metal-oxide-semiconductor field-effect transistors* (whew, no
    wonder people just say *MOSFET*). Transistors are semiconductor components that
    play one of two roles: amplifying or switching signals. There’s more to know about
    transistors, but in our immediate case, we’re going to use a MOSFET as a very
    fast, reliable switch.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: MOSFET是**金属氧化物半导体场效应晶体管**（whew，难怪人们只说*MOSFET*）。晶体管是半导体元件，扮演两种角色之一：放大或切换信号。关于晶体管还有很多要了解的，但就我们当前的情况而言，我们将使用MOSFET作为非常快速、可靠的开关。
- en: 'When a small voltage is applied to the MOSFET’s *gate* pin ([figure 6.14](#ch06fig14)),
    the other two pins (*source* and *drain*) are connected, and current can flow
    between them—the MOSFET is turned on. The Uno can reach out with a weaker, 5 V
    “finger” and “push” the gate pin, completing the 9 V circuit attached to *source*
    and *drain*. That is, you can use a signal with low voltage and power to control
    a signal with higher voltage and power. The resulting motor circuit has two input
    power sources: the 9 V battery and 5 V input coming from the Uno.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 当给MOSFET的**门**引脚（[图6.14](#ch06fig14)）施加小电压时，其他两个引脚（**源**和**漏**）相连，电流可以在它们之间流动——MOSFET被打开。Arduino可以用较弱的5V“手指”来“推动”门引脚，完成连接到**源**和**漏**的9V电路。也就是说，你可以使用低电压和低功率的信号来控制高电压和高功率的信号。结果，电机电路有两个输入电源：9V电池和来自Arduino的5V输入。
- en: Figure 6.14\. A MOSFET and its circuit symbol. A small voltage applied to the
    gate (G) pin will make a connection between the drain (D) and source (S) pins.
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.14\. 一个MOSFET及其电路符号。施加到门（G）引脚的小电压将在漏（D）和源（S）引脚之间建立连接。
- en: '![](06fig14.jpg)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig14.jpg)'
- en: '|  |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: MOSFET pinout
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MOSFET引脚排列
- en: Although most field-effect transistors (FETs) of this type (N-channel) use the
    pinout shown in [figure 6.14](#ch06fig14), make sure you double-check your component’s
    datasheet to confirm which pins are the gate, drain, and source.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数此类（N沟道）场效应晶体管（FETs）使用[图6.14](#ch06fig14)中显示的引脚排列，但请确保你查阅你的组件数据手册以确认哪些引脚是门、漏和源。
- en: '|  |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'One last thing: you need to connect the two power sources to a common ground.
    Although the input power sources are segregated—the positive power rail is only
    for 9-volt power—the ground for both is connected.'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：你需要将两个电源连接到公共地。尽管输入电源是分开的——正电源轨仅用于9伏电源——但它们的接地是相连的。
- en: Building the circuit
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'Make sure the MOSFET’s metal tab is oriented as shown in the wiring diagram
    for the MOSFET-switched motor ([figure 6.15](#ch06fig15))—the tab should be oriented
    toward the right. From the top, the first pin is the gate: this should be connected
    to the Uno’s pin 6\. Connect the bottommost pin—the source—to ground. The MOSFET’s
    drain pin (middle pin) should be connected to one of the motor’s leads and the
    flyback diode as shown (the diode is in parallel with the motor).'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 确保MOSFET的金属片朝向与MOSFET开关电机接线图（[图6.15](#ch06fig15)）所示方向一致——金属片应朝向右侧。从顶部看，第一个引脚是栅极：这应该连接到Arduino的6号引脚。将最底部的引脚（源极）连接到地。MOSFET的漏极引脚（中间引脚）应连接到电机的其中一个引脚和反向二极管，如图所示（二极管与电机并联）。
- en: Figure 6.15\. Circuit diagram for a transistor-switched motor control
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15\. 晶体管开关电机控制电路图
- en: '![](06fig15_alt.jpg)'
  id: totrans-880
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15](06fig15_alt.jpg)'
- en: When voltage is applied to the gate pin, current will be able to flow between
    the source and drain pins, allowing the motor to spin.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 当施加电压到栅极引脚时，电流将能够在源极和漏极引脚之间流动，从而使电机旋转。
- en: Taking the motor for a spin
  id: totrans-882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 带着电机去兜风
- en: Create a JavaScript file called motor-basic.js in your Johnny-Five working area
    with the following code. This script instantiates a `Motor` on pin 6 and makes
    it available to the REPL for your manual control.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在Johnny-Five工作区域中创建一个名为motor-basic.js的JavaScript文件，并包含以下代码。此脚本在引脚6上实例化一个`Motor`，并将其手动控制可用。
- en: Listing 6.1\. Motor test drive
  id: totrans-884
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 电机测试驾驶
- en: '[PRE65]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Pin 6 will control the motor’s speed with PWM.**'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 引脚6将使用PWM控制电机速度。**'
- en: '***2* You’ll have access to the motor from the REPL.**'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你将从REPL中访问电机。**'
- en: 'Johnny-Five’s `Motor` component class has more to it, but we’re starting with
    the most basic instantiation: identifying a single pin for controlling a motor’s
    speed in a single direction. This is called a *non-directional motor*.'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的`Motor`组件类还有更多功能，但我们从最基本的实例化开始：识别一个引脚来控制电机单方向的速度。这被称为*非方向性电机*。
- en: 'Run the script and interact with the `motor` in the REPL:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，并在REPL中与`motor`交互：
- en: '[PRE66]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the board and REPL are initialized, you can experiment with the available
    `motor` object reference by typing into the REPL. Here are some handy methods:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了板子和REPL，你就可以通过在REPL中输入来实验可用的`motor`对象引用。以下是一些实用的方法：
- en: '`speed(0-255)`—Make your motor spin at a given speed; for example, `motor.speed(100)`.'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed(0-255)`—使电机以给定速度旋转；例如，`motor.speed(100)`。'
- en: '`stop()`—Stop the motor; for example, `motor.stop()`.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`—停止电机；例如，`motor.stop()`。'
- en: '`start()`—Start the motor using the previously set speed; for example, `motor.start()`.'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`—使用之前设置的速度启动电机；例如，`motor.start()`。'
- en: Motor speed is controlled with pulse-width modulation (PWM), so it’s a good
    thing we have a fast switch (the MOSFET) that can open and close the circuit at
    high frequencies.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 电机速度通过脉冲宽度调制（PWM）控制，所以有一个快速的开关（MOSFET）可以在高频下打开和关闭电路是好事。
- en: '|  |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Take it further: make your own temperature-controlled fan**'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步探索：制作自己的温度控制风扇**'
- en: You now have all the tools you need in your growing builder’s kit to construct
    the temperature-controlled fan first mentioned in [chapter 1](kindle_split_008.html#ch01).
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在在你的不断增长的构建者工具包中拥有了所有必要的工具，可以构建在[第1章](kindle_split_008.html#ch01)中首次提到的温度控制风扇。
- en: 'Challenge: Instead of using the REPL to control a motor, add a TMP 36 sensor
    to your circuit and use changes in its value to turn the fan on or off, or to
    change its speed. You may have more fun if you cut a fan blade out of stiff paper
    or cardboard and attach it to your motor’s axle!'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战：不使用REPL来控制电机，而是将TMP 36传感器添加到电路中，并使用其值的变化来打开或关闭风扇，或改变其速度。如果你从硬纸板或卡纸上剪下一个风扇叶片并将其固定到电机的轴上，可能会更有趣！
- en: '|  |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.2\. Making servos go
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 让伺服机构动起来
- en: Servos are mechanisms for positioning things precisely, and they’re indispensable
    in robotics and other gadgets that require things to be moved accurately ([figure
    6.16](#ch06fig16)).
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服机构是用于精确定位物体的装置，在机器人和其他需要精确移动物体的设备中不可或缺（[图6.16](#ch06fig16)）。
- en: 'Figure 6.16\. A servo and its basic parts. Horns come in different shapes and
    sizes: discs, stars, single arms.'
  id: totrans-903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.16\. 伺服机构和其基本部件。鸣管有不同形状和大小：圆盘、星星、单臂。
- en: '![](06fig16_alt.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16](06fig16_alt.jpg)'
- en: A servo’s movement is powered by a DC motor, similar to the ones we’ve been
    experimenting with in this chapter. But a servo needs a few more parts to get
    its job done. A gear assembly translates the fast but weak rotation of the motor
    into a slower, but more accurate and strong (higher torque) rotation. Additional
    built-in circuitry monitors for input signals to tell the servo at what *angle*
    it should position itself, and it allows the servo to detect when it’s in the
    correct position.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服的运动由直流电机提供动力，类似于我们在本章实验中使用的电机。但伺服需要一些额外的部件来完成其工作。一个齿轮组将电机的快速但弱旋转转换为较慢、更准确和更强（更高扭矩）的旋转。额外的内置电路监控输入信号，以告诉伺服它应该在什么*角度*定位自己，并允许伺服检测它是否处于正确的位置。
- en: 'Most servos have about 180 degrees of rotation. They have a “neutral” position
    (90 degrees, or “up”) and can rotate about 90 degrees from that neutral position
    in either direction ([figure 6.17](#ch06fig17)). The 180 degrees of rotation is
    best-case: inexpensive low-power servos have as little as ~150 degrees of rotation.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数伺服大约有180度的旋转范围。它们有一个“中性”位置（90度，或“向上”），并且可以从该中性位置向任意方向旋转约90度（[图6.17](#ch06fig17)）。180度的旋转范围是最佳情况：价格低廉的低功耗伺服可能只有约150度的旋转范围。
- en: Figure 6.17\. A servo (with attached horn) positioned at a minimum angle, a
    neutral angle, and a maximum angle. Different servos have different real-life
    angle ranges.
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.17\. 伺服（带连接的螺旋桨）定位在最小角度、中性角度和最大角度。不同的伺服有不同的实际角度范围。
- en: '![](06fig17_alt.jpg)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig17_alt.jpg)'
- en: The circuitry within the servo package responds to coded signals on the servo’s
    signal wire. The signal used for controlling the position of a servo is a specific
    kind of PWM.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服套件内的电路对伺服信号线上的编码信号做出响应。用于控制伺服位置的是一种特定的PWM信号。
- en: '|  |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Servo-flavored PWM**'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '**伺服风味PWM**'
- en: A servo’s position, or *angle*, is controlled by sending PWM over its signal
    wire, but it’s a special “flavor” of PWM. A servo expects to receive a pulse every
    20 ms. The length of time that the pulse persists—the amount of time that the
    signal is HIGH—determines the position of the servo. The shorter the pulse duration,
    the further to the left the resulting position will be.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其信号线发送PWM信号来控制伺服的位置，但这是PWM的一种特殊“风味”。伺服期望每20毫秒接收一个脉冲。脉冲持续的时间——信号为高电平的时间——决定了伺服的位置。脉冲持续时间越短，结果位置越偏向左侧。
- en: Typically, a pulse of 1.5 ms will cause the servo to point in its *neutral*
    direction (90°). A pulse of 1 ms or so will peg the servo left (0°), whereas a
    2 ms pulse will position it all the way to the right (180°).
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，1.5毫秒的脉冲会使伺服指向其*中性*方向（90°）。大约1毫秒的脉冲会使伺服指向左侧（0°），而2毫秒的脉冲将使其完全指向右侧（180°）。
- en: '![](0157fig01_alt.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![](0157fig01_alt.jpg)'
- en: The duration of a PWM pulse determines the servo’s angle. A 1.5 ms pulse positions
    the servo at a neutral angle. Shorter pulses equate to more acute angles, and
    longer pulses to obtuse angles.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: PWM脉冲的持续时间决定了伺服的角度。1.5毫秒的脉冲将伺服定位在中性角度。较短的脉冲对应于更锐角，而较长的脉冲对应于钝角。
- en: '|  |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.2.1\. Controlling a servo with Johnny-Five
  id: totrans-917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 使用Johnny-Five控制伺服
- en: '|  |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备
- en: '![](note.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Arduino Uno和USB线
- en: 1 micro servo (4.8 V)
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个微型伺服（4.8 V）
- en: 1 100 μF (microfarads) capacitor
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个100 μF（微法拉）电容器
- en: 3 male header pins, if needed
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有需要，3个雄性排针
- en: 3 jumper wires (red, black, yellow)
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3根跳线（红色、黑色、黄色）
- en: 1 breadboard
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个面包板
- en: '|  |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Header pins for connecting your servo**'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**用于连接伺服的排针**'
- en: Most servos’ wires terminate in a female connector with three terminals.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数伺服的线以三个端子的雌性连接器结束。
- en: The easiest way to plug these into a breadboard is to obtain some *breakaway
    header pins*. These strips of pins come in rows of 16 to 40 pins, and you snap
    off the number of pins you need to connect a given component. Some are sturdier
    than others and may require pliers to snap apart.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些插入面包板的最简单方法是获得一些*断开排针*。这些排针条带以16到40排针的行列提供，你可以折断所需数量的排针以连接特定组件。有些比其他更坚固，可能需要钳子来折断。
- en: Look for male header pins at a 0.1″ pitch (the 0.1″ pitch makes them breadboard-compatible).
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.1英寸间距（0.1英寸间距使它们与面包板兼容）处寻找雄性排针。
- en: '![](0158fig01_alt.jpg)'
  id: totrans-933
  prefs: []
  type: TYPE_IMG
  zh: '![](0158fig01_alt.jpg)'
- en: Male breakaway header pins come in strips. You “break away” (snap off) the number
    of pins you need for a given component.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 雄性断开排针以条带形式提供。你需要“断开”（折断）所需数量的排针以适应特定组件。
- en: '|  |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Like motors, servos are power-hungry when they move and can cause voltage fluctuation
    in the circuit. However, it’s possible to power low-voltage micro servos—those
    rated for 4.8 V or below—directly from the Uno’s power supply if you take some
    precautions.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 就像电机一样，伺服器在移动时非常耗电，可能会在电路中引起电压波动。然而，如果你采取一些预防措施，可以直接从Arduino Uno的电源为低压微服（那些额定电压为4.8
    V或以下的）供电。
- en: Protecting circuits with decoupling capacitors
  id: totrans-937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用去耦电容器保护电路
- en: '*Capacitors* ([figure 6.18](#ch06fig18)) are passive electronic components
    that act kind of like batteries: they store a certain amount of charge, measured
    in units called *farads* (abbreviated as *F*). One farad is a lot; most capacitors
    for hobby electronics are measured in micro-, nano-, or even picofarads.'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '*电容器* ([图6.18](#ch06fig18)) 是一种类似于电池的被动电子元件：它们存储一定量的电荷，以称为 *法拉* 的单位来衡量（缩写为
    *F*）。一个法拉很大；大多数业余电子电容器都是以微法、纳法或甚至皮法来衡量的。'
- en: 'Figure 6.18\. Capacitors come in a number of different packages and sizes;
    electrolytic capacitors and ceramic capacitors are quite common. Take care: some,
    but not all, capacitors are polarized.'
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.18\. 电容器有多种不同的封装和尺寸；电解电容器和陶瓷电容器相当常见。请注意：并非所有电容器都有极性。
- en: '![](06fig18_alt.jpg)'
  id: totrans-940
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig18_alt.jpg)'
- en: A charged capacitor will get twitchy if there’s a voltage fluctuation between
    source power and ground. For example, if the voltage suddenly drops to 4.5 V,
    the capacitor will discharge some of its stored charge to “smooth out” the voltage.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电源和地之间有电压波动，充电电容器会变得不安。例如，如果电压突然下降到4.5 V，电容器会放电一部分储存的电荷以“平滑”电压。
- en: That means a capacitor can act as a tiny, boosting battery, squirting out extra
    charge as needed to keep the voltage steady. A capacitor used this way is called
    a *decoupling capacitor*, as it *decouples* the rest of the circuit from voltage
    noise caused by components.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着电容器可以充当一个小型的、提升的电池，根据需要喷出额外的电荷以保持电压稳定。以这种方式使用的电容器称为 *去耦电容器*，因为它可以 *去耦* 电路的其他部分，从而减少由组件引起的电压噪声。
- en: '|  |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Be careful with capacitors**'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '**小心使用电容器**'
- en: Watch out! Capacitors are sneaky little devils and can be downright *dangerous*
    in certain cases. They deserve extra respect and care.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 当心！电容器是狡猾的小恶魔，在某些情况下可能会非常 *危险*。它们应得到额外的尊重和照顾。
- en: An important thing to know is that capacitors can retain their charge for long
    periods of time, even if current isn’t running through them. They’re, again, like
    batteries in that regard. That means that if you accidentally complete a circuit
    across a capacitor—and, yeah, you can cause this situation with your fingers—it
    could discharge immediately and violently. If you ever find yourself deconstructing
    old televisions or electronic camera flashes, *be very careful*. If one of those
    powerful capacitors discharges at you unexpectedly, you could be looking at a
    trip to the hospital, or worse.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情是，电容器可以在长时间内保持它们的电荷，即使没有电流通过它们。在这方面，它们又像电池一样。这意味着如果你不小心在电容器上完成电路——是的，你可以用手指造成这种情况——它可能会立即且猛烈地放电。如果你发现自己正在拆卸旧电视或电子闪光灯，*一定要非常小心*。如果那些强大的电容器意外地向你放电，你可能会去医院，或者更糟。
- en: A more day-to-day thing to keep in mind is that electrolytic capacitors, like
    the one used in this experiment, are polarized. They won’t abide being plugged
    in backwards and they have a rather ornery habit of exploding when used in a reverse
    orientation. In our low-voltage, low-capacitance world, these are rather mild
    explosions, but they could still scare the bejeezus out of you, or melt components
    and boards you’d rather not melt.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个更日常的事情是，电解电容器，就像这个实验中使用的电容器一样，是有极性的。它们不会容忍被反向插入，而且当以反向方向使用时，它们有一种相当顽固的习惯，会爆炸。在我们的低压、低电容世界中，这些爆炸相当温和，但它们仍然可能会吓到你，或者熔化你不想熔化的组件和电路板。
- en: '|  |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Building the servo circuit
  id: totrans-949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建伺服电路
- en: Connect your servo’s power, ground, and control wires to the breadboard, using
    header pins if needed (see [figure 6.19](#ch06fig19)). Different servo manufacturers
    use different wire colors, but the positive power connection should be a red wire.
    Most servos use black for the negative lead wire, but some have a brown or maroon-ish
    wire. Finally, the signal wire could be white, yellow, orange, or even blue. In
    summary, the red wire is power, the darkest wire is ground, and what’s left over
    is the signal wire ([figure 6.20](#ch06fig20)).
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的伺服电机的电源、地线和控制线连接到面包板，如果需要可以使用引脚头（参见[图 6.19](#ch06fig19)）。不同的伺服电机制造商使用不同的电线颜色，但正极电源连接应该是红色电线。大多数伺服电机使用黑色作为负极引线，但有些使用棕色或类似颜色的电线。最后，信号线可能是白色、黄色、橙色甚至是蓝色。总之，红色电线是电源，最深的电线是地线，剩下的就是信号线（[图
    6.20](#ch06fig20)）。
- en: Figure 6.19\. Wiring diagram for a servo with a decoupling capacitor
  id: totrans-951
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.19\. 带有去耦电容器的伺服电机接线图
- en: '![](06fig19_alt.jpg)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig19_alt.jpg)'
- en: Figure 6.20\. Servo wires come in various colors and have differing connectors.
    There should be a red wire—this connects to Vcc (source power). The darkest wire—black
    or brown—is ground. The remaining wire is the signal wire—abbreviated here as
    *S*—for controlling the servo’s position.
  id: totrans-953
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.20\. 伺服电线的颜色各异，连接器也各不相同。应该有一条红色电线——这条电线连接到 Vcc（电源）。最深的电线——黑色或棕色的是地线。剩下的电线是信号线——在这里简写为
    *S*——用于控制伺服电机的位置。
- en: '![](06fig20_alt.jpg)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig20_alt.jpg)'
- en: Connect a 100 μF electrolytic capacitor in parallel with the servo’s power connections—that
    is, plug the capacitor’s anode into the same breadboard row as the servo’s power
    connection and its cathode into the same row as the servo’s ground connection.
    Connect the servo’s signal wire to pin 6 on the Uno. Finally, connect the servo’s
    power to the Uno’s 5 V power and the servo’s ground to the Uno’s GND pin.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 在伺服电机的电源连接处并联一个 100 μF 的电解电容器——也就是说，将电容器的阳极插入与伺服电机电源连接相同的面包板行，将电容器的阴极插入与伺服电机地连接相同的行。将伺服电机的信号线连接到
    Uno 的 6 号引脚。最后，将伺服电机的电源连接到 Uno 的 5 V 电源，将伺服电机的地连接到 Uno 的 GND 引脚。
- en: Taking the servo for a test drive
  id: totrans-956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对伺服电机进行测试驾驶
- en: You may by now have guessed already that Johnny-Five has a `Servo` class for
    controlling servos. It sure does!
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经猜到了，Johnny-Five 有一个用于控制伺服电机的 `Servo` 类。确实如此！
- en: 'Create a new file, servo-basic.js, and add the following JavaScript. This is
    similar to the motor test drive: it will make a reference to `servo` available
    to you in the REPL.'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，servo-basic.js，并添加以下 JavaScript。这与电机测试驾驶类似：它将在 REPL 中使 `servo` 可用。
- en: Listing 6.2\. Servo test drive
  id: totrans-959
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 伺服电机测试驾驶
- en: '[PRE67]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Servos require PWM control signals—make sure to use a PWM-enabled pin!**'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 伺服电机需要 PWM 控制信号——务必使用支持 PWM 的引脚！**'
- en: 'Run the script:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本：
- en: '[PRE68]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now you can avail yourself of the `Servo`’s methods:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `Servo` 的方法：
- en: '`to(deg)`—Move the servo to the `deg` value (between 0 and 180). For example,
    `servo.to(50)`'
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to(deg)`——将伺服电机移动到 `deg` 值（介于 0 和 180 之间）。例如，`servo.to(50)`'
- en: '`center()`—Move the servo to its center/neutral position, 90 degrees by default.
    For example, `servo.center()`'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center()`——将伺服电机移动到其中心/中性位置，默认为 90 度。例如，`servo.center()`'
- en: If you try to position your servo at the extreme ends of its range—0 or 180
    or near to those values—it will likely protest, making sad grinding sounds. That’s
    because the *effective* range of the servo is less than 180 degrees. Try experimenting
    to determine the lowest and highest angle values your servo can comfortably reach.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将伺服电机定位在其范围的极端位置——0 或 180 度或接近这些值——它可能会抗议，发出悲伤的磨擦声。这是因为伺服电机的 *有效* 范围小于
    180 度。尝试实验以确定伺服电机可以舒适达到的最小和最大角度值。
- en: This little test drive is but a brief introduction to servos. If the next section—building
    a robot!—appeals to you, and robotics is an area you want to dive into, you’ll
    have many more encounters with servos as you explore.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的测试驾驶只是对伺服电机的一个简要介绍。如果下一节——构建机器人！——对你有吸引力，并且你想要深入研究机器人领域，那么在探索过程中你将遇到更多关于伺服电机的情况。
- en: 6.3\. Building your first robot!
  id: totrans-969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 构建你的第一个机器人！
- en: 'It’s time to build a robot. To build a robot that can move around on wheels,
    you need some basic parts ([figure 6.21](#ch06fig21)):'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候构建一个机器人了。要构建一个可以在轮子上移动的机器人，你需要一些基本部件（[图 6.21](#ch06fig21)）：
- en: '***A chassis*—** Every robot needs a body. A chassis is a structure onto which
    you can attach motors, wheels, and other components.'
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***底盘*——** 每个机器人都需要一个身体。底盘是一个可以安装电机、轮子和其他组件的结构。'
- en: '***At least two geared motors*—** Motors for driving robots need to have some
    *gear reduction* to give them some torque. Otherwise they won’t be able to climb
    over even the most minimal obstacles. The drive axle of a gear motor is usually
    (but not always) at a right angle to the spin of the motor itself.'
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***至少两个齿轮电机*—** 机器人驱动电机需要一些*齿轮减速*以提供一些扭矩。否则，它们甚至无法越过最微小的障碍。齿轮电机的驱动轴通常（但不总是）与电机的旋转成直角。'
- en: '***Wheels or tracks*—** These translate the motion of the motors. Wheels fit
    onto the drive axles of gearmotors.'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***轮子或履带*—** 这些将电机的运动转换为机器的运动。轮子适合安装在齿轮电机的驱动轴上。'
- en: '***A brain*—** A microcontroller or processor to define the robot’s logic.'
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***大脑*—** 定义机器人逻辑的微控制器或处理器。'
- en: '***Motor circuitry*—** Your robot needs some components to translate its desired
    movement into motor motion.'
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***电机电路*—** 你的机器人需要一些组件来将其所需的运动转换为电机运动。'
- en: Figure 6.21\. A basic robot needs a chassis (body). Two or more geared motors
    connect to wheels or tracks to propel the bot. Of course, you’ll also need circuitry,
    a brain (microcontroller), and a power supply.
  id: totrans-976
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.21\. 一个基本的机器人需要一个底盘（身体）。两个或更多的齿轮电机连接到轮子或履带以推动机器人。当然，你还需要电路、大脑（微控制器）和电源。
- en: '![](06fig21_alt.jpg)'
  id: totrans-977
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig21_alt.jpg)'
- en: One of the things that can be off-putting about getting into basic robotics
    is the combined expense of various parts. Chassis can cost up to a few hundred
    dollars (!), and off-the-shelf shields, boards, or other circuitry for controlling
    the motors can cost a bit too.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 进入基础机器人领域可能会让人望而却步的一件事是各种部件的综合成本。底盘可能要花费几百美元(!)，而现成的用于控制电机的防护罩、电路板或其他电路可能也要花费不少。
- en: Our first roving bot will use quite inexpensive parts. You can find the suggested
    Actobotics Peewee Runt Rover chassis kit for about $16 online and in electronics-supply
    stores.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一辆巡游机器人将使用相当便宜的部件。你可以在网上和电子产品商店找到建议的Actobotics Peewee Runt Rover底盘套件，大约16美元。
- en: '|  |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要的东西
- en: '![](note.jpg)'
  id: totrans-982
  prefs: []
  type: TYPE_IMG
  zh: '![图片](note.jpg)'
- en: 1 Arduino Uno and USB cable^([[1](#ch06fn01)])
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno和USB线^([[1](#ch06fn01)])
- en: ¹
  id: totrans-984
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-985
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you happen to have a longer USB A to USB B cable than the one that came with
    your Arduino, this would be a good time to use it.
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你恰好有一根比随Arduino一起提供的USB A到USB B线更长的线，现在就是使用它的时候了。
- en: 1 Actobotics Peewee Runt Rover robot kit or similar^([[2](#ch06fn02)])
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Actobotics Peewee Runt Rover机器人套件或类似套件^([[2](#ch06fn02)])
- en: ²
  id: totrans-988
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contains chassis, 2 gearmotors, and 2 wheels.
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含底盘、2个齿轮电机和2个轮子。
- en: 9 V battery and snaps
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 V电池和夹子
- en: 1 Texas Instruments SN754410 Quadruple Half-H Driver
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个德州仪器SN754410四倍半-H驱动器
- en: 15 jumper wires
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15个跳线
- en: Double-sided tape, electrical tape, gaffer’s tape, or other adhesive (optional)
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双面胶带、电工胶带、电工胶带或其他粘合剂（可选）
- en: 1 half-size breadboard
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个半尺寸面包板
- en: '|  |'
  id: totrans-996
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-997
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Other options for building your first bot
  id: totrans-998
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 建造你的第一个机器人的其他选项
- en: The Actobotics Peewee Runt Rover kit is a handy option for a first robot because
    it’s inexpensive and includes a chassis, wheels, gearmotors, and mounts—the basic
    pieces you’ll need. But other two-wheeled chassis frames or kits are fine too.
    SparkFun’s Shadow chassis is another cheap option (though you’ll need to buy motors
    and wheels separately). Whatever you end up with, make sure you have a chassis,
    geared motors, and wheels. The instructions that follow for constructing a rover
    bot assume the Peewee kit, but construction shouldn’t differ too much for similar
    kits.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: Actobotics Peewee Runt Rover套件是第一台机器人的便捷选择，因为它价格低廉，包括底盘、轮子、齿轮电机和支架——你需要的基本部件。但其他两轮底盘框架或套件也很好。SparkFun的Shadow底盘是另一个经济实惠的选择（尽管你需要单独购买电机和轮子）。无论你最终得到什么，确保你有底盘、齿轮电机和轮子。以下关于构建巡游机器人的说明假设了Peewee套件，但构建不应与类似套件相差太多。
- en: '|  |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.3.1\. Robots and motors
  id: totrans-1001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 机器人和电机
- en: 'From our recent experiments, you’ve seen how a motor’s speed can be controlled
    with PWM, and how a motor’s direction can be reversed by swapping its power and
    ground connections. You’ve also seen how motor circuits are a little more complex
    than other circuits: you need diodes to protect your circuit’s other components,
    and you’ll likely need a more robust power supply for a motor than a development
    board can provide.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们最近的实验中，你已经看到了如何使用PWM控制电机的速度，以及如何通过交换其电源和地线连接来反转电机的方向。你还看到了电机电路比其他电路复杂一些：你需要二极管来保护电路的其他组件，并且你可能需要一个比开发板能提供的更强大的电源来为电机供电。
- en: It gets a bit more complicated. A roving robot needs at least two motors to
    be steerable, and you need to be able to run those motors in a forward and a reverse
    direction (without physically unplugging and swapping the leads, of course). Multiple
    motors on a single circuit should also be isolated with decoupling capacitors
    so that sudden spikes caused by one motor don’t affect the other motor or components.
    The details are starting to add up.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这会变得稍微复杂一些。一个移动的机器人至少需要两个电机才能转向，您需要能够以正向和反向方向运行这些电机（当然，不需要物理拔掉并交换引脚）。单个电路上的多个电机也应使用解耦电容器进行隔离，以防止一个电机引起的突然尖峰影响另一个电机或组件。细节开始累积。
- en: Controlling motors with H-bridge drivers
  id: totrans-1004
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用H桥驱动器控制电机
- en: An H-bridge is a circuit with four switches and a load in the middle—the load
    being a motor, in our case. In concept, it’s laid out roughly in the shape of
    the letter *H*, as shown in [figure 6.22](#ch06fig22).
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: H桥是一种包含四个开关和中间负载的电路——在我们的例子中，负载是电机。在概念上，它大致呈字母*H*的形状，如图[图6.22](#ch06fig22)所示。
- en: Figure 6.22\. An H-bridge circuit contains four switches, with the motor in
    the center. Different combinations of switch states can route current through
    the motor in different directions.
  id: totrans-1006
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.22\. H桥电路包含四个开关，电机位于中央。不同的开关状态组合可以使电流以不同的方向通过电机。
- en: '![](06fig22.jpg)'
  id: totrans-1007
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig22.jpg)'
- en: The arrangement of switches (that is, transistors) in an H-bridge allows the
    motor’s direction to be controlled without you having to physically change its
    wiring. Closing switches 1 and 4 ([figure 6.23](#ch06fig23), left) allows current
    to flow through the motor in one direction, whereas closing switches 2 and 3 ([figure
    6.23](#ch06fig23), right) allows the motor to spin in the opposite direction.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: H桥中开关（即晶体管）的排列允许您在不改变电机物理接线的情况下控制电机的方向。关闭1号和4号开关（[图6.23](#ch06fig23)，左侧）允许电流以一个方向流过电机，而关闭2号和3号开关（[图6.23](#ch06fig23)，右侧）允许电机以相反的方向旋转。
- en: Figure 6.23\. By activating different switches in an H-bridge, a motor can be
    made to spin in a forward or a reverse direction.
  id: totrans-1009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.23\. 通过激活H桥中的不同开关，可以使电机正向或反向旋转。
- en: '![](06fig23_alt.jpg)'
  id: totrans-1010
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig23_alt.jpg)'
- en: There are 16 possible states (switch combinations) an H-bridge circuit can be
    in, of which the two in [figure 6.23](#ch06fig23) are the most obviously useful.
    Several others are innocuous, allowing the motor to coast (when there’s no path
    through the circuit) or braking the motor (both leads of the motor connected to
    the same voltage).
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: H桥电路可以处于16种可能的状态（开关组合）中，其中[图6.23](#ch06fig23)中的两种是最显然有用的。其他几种是无害的，允许电机滑行（当电路中没有路径时）或制动电机（电机的两个引脚连接到相同的电压）。
- en: There are six switch combinations that are bad news, causing a situation called
    “shoot-through,” more simply described as a short circuit ([figure 6.24](#ch06fig24)).
    This is not good and will fry things.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 有六种开关组合是坏消息，会导致所谓的“直通”情况，更简单地描述为短路（[图6.24](#ch06fig24)）。这并不好，会损坏设备。
- en: Figure 6.24\. Closing both switches on either side of the H-bridge causes “shoot-through”—a
    short circuit!
  id: totrans-1013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.24\. 关闭H桥两侧的开关会导致“直通”——短路！
- en: '![](06fig24_alt.jpg)'
  id: totrans-1014
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig24_alt.jpg)'
- en: For our robot we’d need to build one H-bridge circuit per motor, not to mention
    adding in additional protective diodes and capacitors—that’s starting to sound
    like a lot of connections and complications. Fortunately, H-bridges are available
    inexpensively as integrated circuit (IC) chips ([figure 6.25](#ch06fig25)). Even
    better, many inexpensive ICs package together H-bridge circuitry along with internal
    diodes and other gadgetry to protect your motor circuit as well as preventing
    shoot-through states. These chips are called *motor drivers* or just *drivers*.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的机器人，我们需要为每个电机构建一个H桥电路，更不用说还要添加额外的保护二极管和电容器——这听起来像是要连接很多线路和复杂化。幸运的是，H桥作为集成电路（IC）芯片价格低廉（[图6.25](#ch06fig25)）。更好的是，许多低成本IC将H桥电路与内部二极管和其他设备一起封装，以保护您的电机电路，并防止直通状态。这些芯片被称为*电机驱动器*或简称*驱动器*。
- en: Figure 6.25\. Inexpensive motor drivers, like this Texas Instruments SN754410,
    give you logical control over internal H-bridge circuits. They also include other
    components, like diodes, making motor control simpler and less error-prone. The
    SN754410 is a dual H-bridge—it can control two motors.
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.25\. 像德州仪器SN754410这样的低成本电机驱动器，让您能够对内部H桥电路进行逻辑控制。它们还包含其他组件，如二极管，使电机控制更简单、更不易出错。SN754410是双H桥——它可以控制两个电机。
- en: '![](06fig25_alt.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig25_alt.jpg)'
- en: 'The Texas Instruments SN754410 Quadruple Half-H Driver costs just a few bucks
    and is available from various electronics supply resellers. Yeah, its name is
    a mouthful (bonus hint: a quadruple half-H-bridge is equivalent to two complete
    H-bridge circuits), but it does everything we need to drive both motors for our
    first roving robot.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 德州仪器SN754410四重半H桥驱动器只需花费几美元，可以从各种电子产品供应商处购买。是的，它的名字很长（提示：四重半H桥相当于两个完整的H桥电路），但它可以做我们为第一个巡游机器人驱动两个电机所需的一切。
- en: Before we dive into the details of the motor driver IC’s pins and related circuitry,
    let’s get started on the foundational pieces of our first robot.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨电机驱动IC引脚和相关电路的细节之前，让我们开始构建我们第一个机器人的基础部件。
- en: 6.3.2\. Building the robot’s chassis base
  id: totrans-1020
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2. 构建机器人底盘基础
- en: You’ll want to attach the side supports (this may take some oomph) and your
    breadboard to the bottom plate of the robot chassis ([figure 6.26](#ch06fig26)).
    If you have the Peewee kit, the side supports are the pieces of plastic with the
    larger, rectangular holes in the middle.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将侧支撑（这可能需要一些力气）和面包板固定到机器人底盘的底部板（[图6.26](#ch06fig26)）。如果你有Peewee套件，侧支撑是中间有较大、矩形孔的塑料件。
- en: Figure 6.26\. The bottom plate of the Peewee Runt Rover chassis, with attached
    side supports and breadboard. If you’re using a different chassis, it’ll look
    a little different, of course.
  id: totrans-1022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.26. Peewee Runt Rover底盘的底部板，带有连接的侧支撑和面包板。如果你使用的是不同的底盘，当然看起来会有些不同。
- en: '![](06fig26_alt.jpg)'
  id: totrans-1023
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig26_alt.jpg)'
- en: '|  |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Attaching the breadboard to the chassis
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将面包板固定到底盘上
- en: Most half-sized breadboards have adhesive that can be exposed by peeling off
    a piece of backing paper, and this can be useful for adhering the breadboard to
    the robot’s chassis to keep it from moving around. If you can’t permanently commit
    a breadboard to the robot—perhaps this is your only breadboard!—or if your breadboard
    doesn’t have adhesive, you can temporarily attach the breadboard to the robot
    chassis using double-sided tape, electrical tape, gaffer’s tape, or your choice
    of removable adhesive. You could also use wire ties.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数半尺寸面包板都有可以通过撕掉一块背纸来暴露的粘合剂，这可以用来将面包板粘附到机器人底盘上，以防止其移动。如果你不能永久地将面包板固定到机器人上——也许这是你唯一的面包板！——或者如果你的面包板没有粘合剂，你可以使用双面胶带、电工胶带、电工胶带或你选择的任何可移除粘合剂临时将面包板固定到机器人底盘上。你也可以使用线扣。
- en: '|  |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Go ahead and center the breadboard and attach it to the chassis. The hole in
    the center of the plate will leave some of the breadboard adhesive exposed (if
    you’re permanently attaching your breadboard). You can cut a piece of the backing
    paper in the shape of the hole and reattach it to cover up the exposed gummy surface,
    if you like. Don’t attach the top plate of the chassis yet.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 将面包板居中并固定到底盘上。板子中央的孔会露出一些面包板的粘合剂（如果你要永久性地固定面包板）。你可以剪下一块背纸，形状与孔相匹配，然后重新粘上去以覆盖暴露的粘性表面，如果你喜欢的话。暂时不要固定底盘的上板。
- en: Gearmotors made for robots have a geared output axle for driving wheels that’s
    (typically) at a right angle from the motor’s spin. Wheels attach to the output
    axle, facing outward from the robot, while the motor’s spinning shaft is oriented
    up (as in the Peewee kit, [figure 6.27](#ch06fig27)) or toward the back (as in
    the SparkFun Shadow Chassis). In all cases, you’ll want to have the motors’ wires
    on the inside.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 为机器人设计的齿轮电机有一个用于驱动轮子的齿轮输出轴，通常与电机的旋转轴成直角。轮子固定在输出轴上，朝向机器人外部，而电机的旋转轴向上（如在Peewee套件中，[图6.27](#ch06fig27)），或者朝向后方（如在SparkFun
    Shadow底盘中）。在所有情况下，你都会希望将电机的线缆放在内部。
- en: Figure 6.27\. The top plate of the Peewee Runt Rover chassis, shown with attached
    gear motors, wheels, dev-board support, and Arduino Uno. Make sure the motors’
    wires are oriented toward the inside of the chassis. The motor wires can be run
    underneath the Uno and through the center hole of the chassis plate.
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.27. Peewee Runt Rover底盘的上板，展示固定好的齿轮电机、轮子、开发板支撑和Arduino Uno。确保电机的线缆朝向底盘内部。电机线缆可以穿过Uno下方并通过底盘板的中心孔。
- en: '![](06fig27_alt.jpg)'
  id: totrans-1031
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig27_alt.jpg)'
- en: Take the Peewee chassis’ top plate and attach the gearmotors to it. The motors’
    leads can then be routed down through the circular hole in the middle of the top
    plate, for access to the breadboard below. The Peewee kit also comes with two
    development-board supports, in the shape of wide, shallow *U*s. These should be
    attached to the top plate now, and you can nestle the Arduino into them, with
    the USB connection toward what will be the rear of the robot (the plate is symmetrical
    front-to-back, so you get to decide now where the rear of your bot is).
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 取出Peewee底盘的上板，并将齿轮电机安装到上面。然后，可以将电机的引线通过上板中间的圆形孔引下来，以便访问下面的面包板。Peewee套件还附带两个开发板支架，形状为宽而浅的*U*形。现在应该将它们安装到上板上，并将Arduino放入其中，USB连接朝向将成为机器人后部的方向（板子前后对称，所以你现在可以决定你的机器人后部在哪里）。
- en: You can now slide the wheels onto the gearmotor axles. At this point, you should
    have a bottom plate with attached breadboard and side supports, and a top plate
    with attached Arduino, motors, and wheels.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将轮子滑到齿轮电机轴上。此时，你应该有一个带有面包板和侧支架的底板，以及一个带有Arduino、电机和轮子的上板。
- en: 6.3.3\. Controlling the robot’s motors
  id: totrans-1034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 控制机器人的电机
- en: If you orient the SN754410 motor driver with the semicircular dimple at the
    top, the pins are ordered from 1 to 16, as shown in [figure 6.28](#ch06fig28).
    Different pins have different purposes and provide connections to different things
    inside the chip. We’ll walk through these as we build the circuit.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将SN754410电机驱动器以顶部的半圆形凹槽朝上放置，引脚的顺序从1到16，如[图6.28](#ch06fig28)所示。不同的引脚有不同的用途，并为芯片内部的不同部分提供连接。我们将在构建电路时介绍这些引脚。
- en: Figure 6.28\. The pinout of the SN754410 motor driver
  id: totrans-1036
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.28\. SN754410电机驱动器的引脚排列
- en: '![](06fig28.jpg)'
  id: totrans-1037
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig28.jpg)'
- en: SN754410 power and enable connections
  id: totrans-1038
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SN754410电源和使能连接
- en: The first step for wiring up the SN754410 is connecting some of its pins to
    power and ground ([figure 6.29](#ch06fig29)).
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 连接SN754410的第一步是将一些引脚连接到电源和地（[图6.29](#ch06fig29)）。
- en: Figure 6.29\. The SN754410 needs to be connected to a motor power supply on
    VCC2 (physical pin 8) and the logic power supply on VCC1 (physical pin 16). The
    two enable pins should be connected directly to 5 V to set them HIGH. There are
    also four GND pins that, unsurprisingly, need to connect to ground.
  id: totrans-1040
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.29\. SN754410需要连接到VCC2（物理引脚8）上的电机电源和VCC1（物理引脚16）上的逻辑电源。两个使能引脚应直接连接到5V以将其设置为高电平。还有四个GND引脚，不出所料，需要连接到地。
- en: '![](06fig29_alt.jpg)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig29_alt.jpg)'
- en: The driver needs to be connected to two separate power sources. The 9 V battery
    will power the motors themselves (the *motor power source*), whereas the logic
    for controlling the motors will be 5 V from the Uno (the *logic power source*).
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器需要连接到两个独立的电源。9V电池将为电机本身供电（*电机电源*），而控制电机的逻辑将由来自Uno的5V供电（*逻辑电源*）。
- en: 'In addition, there are two *enable* pins on the chip: one for each motor’s
    driver. You need to “turn on” each driver by connecting each enable (EN) pin—physical
    pins 1 and 9—to 5 V (that is, logical HIGH).'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，芯片上还有两个*使能*引脚：一个用于每个电机的驱动器。您需要通过将每个使能（EN）引脚——物理引脚1和9——连接到5V（即逻辑高电平）来“打开”每个驱动器。
- en: 'Make connections to the power and enable pins as shown in the motor power wiring
    diagram ([figure 6.30](#ch06fig30)). Note that the ground rails are tied together
    (shared ground), but the power sources are isolated: the left rail for the motor
    power source (9 V), the right rail for the logic power source (5 V).'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 按照电机电源布线图（[图6.30](#ch06fig30)）所示连接到电源和使能引脚。请注意，地轨是连接在一起的（共享地），但电源是隔离的：左侧轨为电机电源（9V），右侧轨为逻辑电源（5V）。
- en: Figure 6.30\. Wiring the SN754410’s power connections on the robot’s breadboard
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.30\. 在机器人的面包板上布线SN754410的电源连接
- en: '![](06fig30.jpg)'
  id: totrans-1046
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig30.jpg)'
- en: SN754410 logic connections
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SN754410逻辑连接
- en: On the SN754410, each motor is controlled via two input pins. Two corresponding
    output pins are connected to the motor ([figure 6.31](#ch06fig31)).
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 在SN754410上，每个电机通过两个输入引脚进行控制。两个相应的输出引脚连接到电机（[图6.31](#ch06fig31)）。
- en: Figure 6.31\. Each of the two motor drivers has two input pins and two output
    pins.
  id: totrans-1049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.31\. 两个电机驱动器各有两个输入引脚和两个输出引脚。
- en: '![](06fig31_alt.jpg)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig31_alt.jpg)'
- en: Different logic-level combinations on a motor’s two input pins cause different
    things to happen with each motor, thanks to the internal H-bridge switches and
    circuitry. For each motor, one input pin can be used for controlling direction
    while the second input pin can be used to control the motor’s speed. Let’s take
    a look at how that can possibly be, examining how the first of the two motors
    is controlled (the second motor is controlled identically).
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电机两个输入引脚上的不同逻辑电平组合，加上内部H桥开关和电路，每个电机都会发生不同的事情。对于每个电机，一个输入引脚可以用来控制方向，而第二个输入引脚可以用来控制电机的速度。让我们看看这可能是什么样子，检查第一个电机是如何控制的（第二个电机以相同方式控制）。
- en: Controlling motor direction
  id: totrans-1052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制电机方向
- en: We’ll use pin 1A (physical pin 2 on the SN54410) to control the direction of
    the first motor ([figure 6.32](#ch06fig32)).
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用引脚1A（SN54410上的物理引脚2）来控制第一个电机的方向（[图6.32](#ch06fig32)）。
- en: 'Figure 6.32\. The first motor controller: two input pins and two output pins.
    We’ll use one of the input pins to control the motor’s direction and the other
    to control its speed.'
  id: totrans-1054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.32。第一个电机控制器：两个输入引脚和两个输出引脚。我们将使用一个输入引脚来控制电机的方向，另一个来控制其速度。
- en: '![](06fig32.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig32.jpg)'
- en: When pin 1A is set HIGH and pin 2A is LOW, 9 V current will be allowed to flow
    across the two output pins (1Y, 2Y) and the motor will spin in a forward direction
    ([figure 6.33](#ch06fig33)).
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 当引脚1A设置为HIGH，引脚2A设置为LOW时，9V电流将通过两个输出引脚（1Y，2Y）流动，电机将正向旋转（[图6.33](#ch06fig33)）。
- en: Figure 6.33\. When the first input is set HIGH and the second input is set LOW,
    the motor will turn in a forward direction.
  id: totrans-1057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.33。当第一个输入设置为HIGH，第二个输入设置为LOW时，电机将正向旋转。
- en: '![](06fig33_alt.jpg)'
  id: totrans-1058
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig33_alt.jpg)'
- en: Similarly, when the direction pin 1A is set LOW, the motor will spin in a reverse
    direction (9 V current flow is reversed) any time pin 2A is HIGH ([figure 6.34](#ch06fig34)).
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当方向引脚1A设置为LOW时，只要引脚2A为HIGH，电机就会以反向方向旋转（9V电流反向流动）（[图6.34](#ch06fig34)）。
- en: Figure 6.34\. When first input is LOW and second is HIGH, the motor rotates
    in the opposite (reverse) direction.
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.34。当第一个输入为LOW，第二个为HIGH时，电机以相反（反向）方向旋转。
- en: '![](06fig34_alt.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig34_alt.jpg)'
- en: Put another way, any time 1A and 2A have opposite logic levels, the motor will
    be powered to spin in the direction dictated by the logic level of pin 1A. But
    if both input pins have the same logic level, no current will flow through the
    motor (detailed in [table 6.1](#ch06table01)).
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何1A和2A具有相反逻辑电平的时候，电机都会根据引脚1A的逻辑电平来供电旋转。但如果两个输入引脚具有相同的逻辑电平，电机中就不会有电流流过（详细说明见[表6.1](#ch06table01)）。
- en: Table 6.1\. Motor driver direction control for motor 1
  id: totrans-1063
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1。电机驱动器方向控制表1
- en: '| 1A (direction pin) value | 2A (speed pin) value | Result |'
  id: totrans-1064
  prefs: []
  type: TYPE_TB
  zh: '| 1A（方向引脚）值 | 2A（速度引脚）值 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-1065
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| HIGH | LOW | Motor spins in direction 1 (forward) |'
  id: totrans-1066
  prefs: []
  type: TYPE_TB
  zh: '| HIGH | LOW | 电机以方向1（向前）旋转 |'
- en: '| HIGH | HIGH | No current through motor |'
  id: totrans-1067
  prefs: []
  type: TYPE_TB
  zh: '| 高 | 高 | 电机中没有电流通过 |'
- en: '| LOW | HIGH | Motor spins in direction 2 (backward) |'
  id: totrans-1068
  prefs: []
  type: TYPE_TB
  zh: '| LOW | HIGH | 电机以方向2（向后）旋转 |'
- en: '| LOW | LOW | No current through motor |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '| LOW | LOW | 电机中没有电流通过 |'
- en: Controlling motor speed
  id: totrans-1070
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制电机速度
- en: 'Pin 2A (SN54410 pin 7) will control the speed of the first motor, using PWM.
    Let’s say pin 1A, the direction pin, is set LOW, indicating a reverse direction
    for the motor’s spin, while PWM with a duty cycle of 25% is applied to pin 2A,
    the speed pin ([figure 6.35](#ch06fig35)). Seventy-five percent of the time, 1A
    and 2A will have the same logic levels (LOW/LOW), during which no current will
    flow through the motor. However, 25% of the time, the LOW/HIGH combination will
    allow current to flow, powering the motor. This results in what we want: the motor
    spinning in a reverse direction at a 25% speed setting.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚2A（SN54410引脚7）将控制第一个电机的速度，使用PWM。假设引脚1A，方向引脚，被设置为LOW，表示电机旋转方向为反向，同时将25%占空比的PWM应用于引脚2A，速度引脚（[图6.35](#ch06fig35)）。75%的时间内，1A和2A将具有相同的逻辑电平（LOW/LOW），在此期间电机中没有电流流过。然而，25%的时间内，LOW/HIGH的组合将允许电流流过，为电机供电。这导致了我们想要的结果：电机以25%的速度设置反向旋转。
- en: Figure 6.35\. With direction set to LOW (reverse) on pin 1A and a 25% duty cycle
    on pin 2A (speed), the motor will be powered 25% of the time in the reverse direction.
  id: totrans-1072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.35。在引脚1A上设置方向为LOW（反向）和引脚2A上设置25%占空比（速度）时，电机将以25%的时间在反向方向上供电。
- en: '![](06fig35_alt.jpg)'
  id: totrans-1073
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig35_alt.jpg)'
- en: The same goes for speed control in a forward direction, but there’s a wrinkle.
    Let’s say 1A (direction) is set HIGH—forward—and 2A (speed) is set to a 25% duty
    cycle PWM. What we intend is for the motor to spin forward at 25% speed, but what
    will actually end up happening is that it will spin forward at 75% speed ([figure
    6.36](#ch06fig36)).
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的，正向方向的速度控制也是如此，但有一个小问题。假设1A（方向）设置为HIGH（正向），2A（速度）设置为25%占空比的PWM。我们希望电机以25%的速度正向旋转，但实际上它将以75%的速度正向旋转（[图6.36](#ch06fig36)）。
- en: Figure 6.36\. With direction set to HIGH (forward) on pin 1A and a 25% duty
    cycle on pin 2A (speed), the motor will be powered 75% of the time in the forward
    direction.
  id: totrans-1075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.36\. 当1A引脚设置为HIGH（正向）且2A引脚（速度）设置为25%占空比时，电机将以75%的时间在正向方向上供电。
- en: '![](06fig36_alt.jpg)'
  id: totrans-1076
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig36_alt.jpg)'
- en: To account for this, the PWM signal needs to be *inverted* when the motor direction
    is forward. Some motor drivers handle this for you, automatically inverting PWM
    when the motor is set to spin forward. The SN54410, however, doesn’t, so we’ll
    have to account for it in our code.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，当电机方向为正向时，PWM信号需要被**反转**。一些电机驱动器会为你自动处理这个问题，当电机设置为正向旋转时，自动反转PWM。然而，SN54410并不这样做，因此我们将在代码中考虑这一点。
- en: Completing the motor circuit
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完成电机电路
- en: The rest of the circuit involves connections to the Arduino, 9 V motor power
    supply, and the two motors ([figure 6.37](#ch06fig37)). Connections to the Arduino
    and the motors should be routed through the center hole of the top chassis plate.
    As you finish making these connections, you can rest the top chassis plate on
    the bottom chassis plate and tuck the 9 V battery inside, but don’t snap the pieces
    together yet—you need to test the motors first.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 电路的其余部分涉及连接到Arduino、9V电机电源和两个电机（[图6.37](#ch06fig37)）。Arduino和电机的连接应通过顶壳板的中心孔进行。当你完成这些连接时，你可以将顶壳板放在底壳板上，并将9V电池放进去，但不要将部件完全组装在一起——你需要先测试电机。
- en: Figure 6.37\. Circuit diagram for the rover’s completed motor circuit
  id: totrans-1080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.37\. 探索者完成后的电机电路图
- en: '![](06fig37_alt.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig37_alt.jpg)'
- en: Testing the motors with Johnny-Five
  id: totrans-1082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Johnny-Five测试电机
- en: Before putting the robot together, you should test that the motor circuit is
    working as expected. Create a file called motor-test.js in your working directory,
    and put the following code into it.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装机器人之前，你应该测试电机电路是否按预期工作。在你的工作目录中创建一个名为motor-test.js的文件，并将以下代码放入其中。
- en: Listing 6.3\. Motor driver test drive
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 电机驱动器测试驱动
- en: '[PRE69]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Let’s zoom in on the instantiation of a Johnny-Five `Motors` object in the next
    listing. `Motors` is a Johnny-Five component collection class, akin to `Leds`.
    It can control multiple `Motor` components at once.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们聚焦于下一个列表中Johnny-Five `Motors`对象的实例化。`Motors`是Johnny-Five组件集合类，类似于`Leds`。它可以同时控制多个`Motor`组件。
- en: Listing 6.4\. Instantiating motors
  id: totrans-1087
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 实例化电机
- en: '[PRE70]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Options and pins for the first motor**'
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第一台电机的选项和引脚**'
- en: '***2* Options and pins for the second motor**'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第二台电机的选项和引脚**'
- en: 'To the `Motors` constructor, you pass along an array containing options for
    each `Motor`. Now that each motor is controlled by two pins, Johnny-Five needs
    to be told which pins do what: one for direction (`dir`) and one for speed (`pwm`).'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Motors`构造函数传递一个包含每个`Motor`选项的数组。现在每个电机由两个引脚控制，Johnny-Five需要知道哪个引脚做什么：一个用于方向（`dir`）和一个用于速度（`pwm`）。
- en: Remember that the PWM signal needs to be inverted when the motor runs forward.
    The hardware doesn’t do this automatically, but you can let Johnny-Five know that
    it needs to be done, and Johnny-Five will do it for you, by using the `invertPWM`
    option.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当电机正向运行时，PWM信号需要被反转。硬件不会自动这样做，但你可以通过使用`invertPWM`选项让Johnny-Five知道需要这样做，Johnny-Five会为你完成这个操作。
- en: '|  |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Don’t let your bot run away!
  id: totrans-1094
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不要让你的机器人跑掉！
- en: Before running the motors in the test script, lift your partially constructed
    robot off the ground so that the wheels are in the air. Otherwise it might run
    off!
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试脚本中运行电机之前，将你部分组装好的机器人从地面上抬起，使轮子悬在空中。否则它可能会跑掉！
- en: '|  |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Run the script:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本：
- en: '[PRE71]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When the board and REPL are initialized, enter the following command and press
    Enter:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 当板和REPL初始化后，输入以下命令并按Enter键：
- en: '[PRE72]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now look at your motors. Are they running forward, rather slowly? There’s a
    reasonable chance that one or both of them are spinning in the wrong direction.
    Not a problem. Kill the script, disconnect power, and swap the connection between
    the motor’s leads and the output pins on the motor driver for any motor that’s
    going the wrong way. Then try again.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看你的电机。它们是向前缓慢运行吗？有很大可能性其中一个或两个电机正在错误的方向上旋转。没问题。停止脚本，断开电源，并交换电机引线和电机驱动器输出引脚之间的连接，对于任何运行方向错误的电机。然后再次尝试。
- en: Finishing the chassis construction
  id: totrans-1102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完成底盘构建
- en: Attach the small plastic nubbins to the bottom of the bottom plate, at front
    and back. These are what the bot rests on when it’s not moving. Confident your
    motors are spinning as expected? Good. Now you can snap together the top and bottom
    chassis plates ([figure 6.38](#ch06fig38)).
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 将小塑料圆珠固定到底板底部，前后各一个。当机器人不移动时，它就靠这些圆珠支撑。你确信电机按预期旋转吗？很好。现在你可以将顶板和底板拼装在一起（[图 6.38](#ch06fig38)）。
- en: Figure 6.38\. The completed robot, viewed from the front
  id: totrans-1104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.38\. 从前面看完成的机器人
- en: '![](06fig38_alt.jpg)'
  id: totrans-1105
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig38_alt.jpg)'
- en: Writing the robot software
  id: totrans-1106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写机器人软件
- en: 'The rover’s software will allow you to use the arrow keys on your keyboard
    to steer the bot (and use the spacebar to stop it). The code is going to consist
    of a couple of scripts (modules) and an extra dependency (the npm `keypress` module).
    Let’s be a little more organized about the project’s working area:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 漫游车的软件将允许你使用键盘上的箭头键来控制机器人（并使用空格键停止它）。代码将包括几个脚本（模块）和一个额外的依赖项（npm `keypress` 模块）。让我们对项目的工
    作区域进行一点更合理的组织：
- en: Create a new directory called rover, and `cd` into that new directory.
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 rover 的新目录，并 `cd` 到该新目录。
- en: 'Run this command: `npm init --yes`. This will initialize a `package.json` file
    with some sane defaults.'
  id: totrans-1109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令：`npm init --yes`。这将使用一些合理的默认值初始化一个 `package.json` 文件。
- en: 'Run this command: `npm install --save johnny-five keypress`. This will install
    the two modules listed and save information about the dependencies to package.json.'
  id: totrans-1110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令：`npm install --save johnny-five keypress`。这将安装所列的两个模块并将依赖信息保存到 package.json
    中。
- en: Create a file called Rover.js ([listing 6.5](#ch06ex05)). This module will hold
    a JavaScript `class` that defines the rover’s basic movements. `Rover` doesn’t
    know about the specific pins or the configuration of the motors in the `Motors`
    object passed to its constructor; those details are abstracted away.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 Rover.js 的文件（[列表 6.5](#ch06ex05)）。此模块将包含一个定义漫游车基本运动的 JavaScript `class`。`Rover`
    不了解传递给其构造函数的 `Motors` 对象中的特定引脚或电机配置；这些细节被抽象掉了。
- en: Listing 6.5\. The `Rover` class
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. `Rover` 类
- en: '[PRE73]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Organizing behavior with class syntax can make code more readable.**'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用类语法组织行为可以使代码更易读。**'
- en: '***2* The constructor creates a reference to the motors (this.motors).**'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构造函数创建对电机的引用（this.motors）。**'
- en: '***3* Each Motor in a Motors object can be accessed with array notation.**'
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 Motors 对象中，每个电机都可以用数组表示法访问。**'
- en: '***4* Steering involves running one motor forward and one backward.**'
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 转向涉及一个电机向前运行，另一个电机向后运行。**'
- en: '***5* Exports the Rover class for outside consumption**'
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导出 Rover 类以供外部使用**'
- en: Now the robot needs an interface and a way to control it. Create another file
    called index.js, shown in the following listing.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在机器人需要一个接口和一种控制它的方法。创建另一个名为 index.js 的文件，如下所示。
- en: Listing 6.6\. Structure of index.js
  id: totrans-1120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. index.js 的结构
- en: '[PRE74]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Expanding on steps 1 and 2 in the preceding listing, let’s instantiate the `Motors`
    and then the `Rover` in the next listing.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个列表中的步骤 1 和 2 的基础上，让我们在下一个列表中实例化 `Motors` 和 `Rover`。
- en: 'Listing 6.7\. index.js: setting up the motors and the rover'
  id: totrans-1123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 6.7\. index.js: 设置电机和漫游车'
- en: '[PRE75]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Left motor details**'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 左电机细节**'
- en: '***2* Right motor details**'
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 右电机细节**'
- en: '***3* Passes Motors to the Rover constructor**'
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将电机传递给漫游车构造函数**'
- en: To control the robot, you need to listen for relevant keystrokes for steering
    input. The third task in index.js is to configure `keypress`.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制机器人，你需要监听相关的按键以获取转向输入。index.js 中的第三个任务是配置 `keypress`。
- en: 'Listing 6.8\. index.js: setting up `keypress`'
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 6.8\. index.js: 设置 `keypress`'
- en: '[PRE76]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Tell keypress to generate events for process.stdin (standard input, via
    your keyboard)**'
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 告诉 keypress 为 process.stdin（标准输入，通过你的键盘）生成事件**'
- en: '***2* Be explicit about character encoding.**'
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 明确字符编码。**'
- en: Finally, you need to listen for and handle keypresses.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要监听和处理按键。
- en: 'Listing 6.9\. index.js: handling keypresses'
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 6.9\. index.js: 处理按键'
- en: '[PRE77]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Listen for keypress events. You care about the key argument here.**'
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 监听按键事件。在这里你关心的是 key 参数。**'
- en: '***2* If there’s nothing useful in key, return (do nothing).**'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果 key 中没有有用的内容，则返回（不执行任何操作）。**'
- en: '***3* Pressing the q key will quit the robot. First, the motors are stopped.**'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 按下 q 键将退出机器人。首先，停止电机。**'
- en: '***4* process.exit() will terminate the robot’s process.**'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用 `process.exit()` 将终止机器人的进程。**'
- en: '***5* ‘up’ refers to the keyboard’s up arrow (and so on with ‘down’, ‘left’,
    and so on).**'
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* ‘up’ 指的是键盘的上箭头（以及‘down’、‘left’等）。**'
- en: '***6* The robot can be stopped with the spacebar.**'
  id: totrans-1141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 可以使用空格键停止机器人。**'
- en: '***7* The default case for the key switch statement is to do nothing.**'
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* key switch 语句的默认情况是不执行任何操作。**'
- en: Driving your robot
  id: totrans-1143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 驾驶你的机器人
- en: 'Place your robot where it has a bit of space to move around, and then run the
    script:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的机器人放置在一个有足够空间移动的地方，然后运行脚本：
- en: '[PRE78]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Once the board and REPL are initialized, you can use your arrow keys (up, down,
    left, right) to steer the robot around and the spacebar to make it stop.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了板子和 REPL，你可以使用箭头键（上、下、左、右）来控制机器人移动，并使用空格键使其停止。
- en: 'You may feel mingled feelings both of triumph (hooray! first robot!) and restriction
    (adventures are limited by the length of your USB cable). There’s good news: as
    we proceed, you’ll be able to untether your robots and make them more interesting.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感到复杂的情绪，既有胜利的喜悦（太好了！第一个机器人！）又有限制（冒险受限于 USB 电缆的长度）。好消息是：随着我们继续前进，你将能够摆脱机器人的束缚，使它们更有趣。
- en: Before we do that, however, you’ll round out the major topics of input and output
    by learning how to work with *serial* data.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，你将通过学习如何处理 *串行* 数据来完善输入和输出的主要主题。
- en: Summary
  id: totrans-1149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Electromagnets make motors spin. A motor provided with current will convert
    that electrical energy into mechanical energy—it will spin. Turning a motor’s
    shaft causes it to act as a generator, converting mechanical energy into electrical
    energy.
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电磁铁使电机旋转。给电机通电，它会将电能转换为机械能——开始旋转。转动电机的轴会使它充当发电机，将机械能转换为电能。
- en: Building circuits with motors involves additional care. Motor circuits often
    combine multiple voltages, and motor power supplies tend to be isolated from lower-voltage
    logic circuitry.
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电机构建电路需要额外的注意。电机电路通常结合多个电压，电机电源通常与低电压逻辑电路隔离。
- en: Motor direction can be reversed by reversing the direction of current flow through
    the motor, and motor speed can be controlled with PWM.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过反转电机中电流的方向可以反转电机方向，并且可以使用 PWM 控制电机速度。
- en: Transistors like MOSFETs can be used as high-speed switches, using low-voltage
    logic to switch higher-voltage circuitry.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 晶体管，如 MOSFET，可以用作高速开关，使用低电压逻辑来切换高电压电路。
- en: Diodes and capacitors are two components that can help build safer motor circuits.
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二极管和电容器是两种可以帮助构建更安全电机电路的组件。
- en: Diodes only allow current to flow through them in one direction. A diode, oriented
    to be reverse-biased in parallel with a motor, can protect the circuit, acting
    as a flyback diode.
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二极管只允许电流单向通过它们。一个与电机并联且反向偏置的二极管可以保护电路，充当反激二极管。
- en: Capacitors store electric charge and can be placed in parallel with components
    to isolate them from the circuit and smooth out voltage changes they cause. When
    used this way, they are called decoupling capacitors.
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电容器存储电荷，可以与组件并联放置，以隔离电路并平滑电压变化。以这种方式使用时，它们被称为去耦电容器。
- en: Servos allow for precise positioning, converting PWM signals into angle position.
    Most servos’ ranges are, ostensibly, 180 degrees, but the usable range is narrower
    on inexpensive servos.
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伺服电机允许进行精确定位，将 PWM 信号转换为角度位置。大多数伺服电机的范围理论上为 180 度，但在廉价伺服电机上可用范围更窄。
- en: H-bridge circuits provide the ability to direct current through a load (motor)
    in multiple directions, allowing you to reverse motor direction. H-bridges, combined
    with other features, are packaged in motor driver ICs.
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H-bridge 电路提供了在多个方向上通过负载（电机）导电流的能力，允许你反转电机方向。H-bridge 与其他功能结合，封装在电机驱动 IC 中。
- en: Basic roving robots combine a microcontroller with a motor driver, gearmotors,
    wheels, a source of power, and a chassis.
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本巡游机器人结合了微控制器、电机驱动器、齿轮电机、轮子、电源和底盘。
