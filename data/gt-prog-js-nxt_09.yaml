- en: Unit 7\. Working asynchronously
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元7\. 异步工作
- en: JavaScript has always been an asynchronous language. That makes it a perfect
    language for creating rich applications, because it can handle many concurrent
    tasks without locking the interface. But until recently, there hasn’t been much
    first-class support for its asynchronous nature other than being able to pass
    around functions that can be invoked at a later time. That has all changed. JavaScript
    now has first-class support for promises, asynchronous functions, and soon, for
    observables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 一直是一种异步语言。这使得它非常适合创建丰富的应用程序，因为它可以处理许多并发任务而不会锁定界面。但直到最近，除了能够传递可以在以后调用的函数之外，对它的异步性质的支持并没有多少是第一类的。但现在一切都变了。JavaScript
    现在有了对承诺、异步函数和即将对可观察对象的第一类支持。
- en: Promises are objects that represent *future* values. They are more convenient
    to pass around than callbacks because, unlike callbacks, they don’t rely on timing.
    A promise will give a value right away if the value has already been retrieved,
    or can wait until the value is retrieved. With callbacks, if you are too late
    and the value has already been retrieved, your callback may not get invoked.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是表示未来值的对象。与回调函数相比，它们更方便传递，因为承诺不依赖于时间。如果值已经被检索到，承诺会立即提供一个值，或者可以等待直到值被检索。使用回调时，如果你来得太晚，值已经被检索，你的回调可能不会被调用。
- en: Promises, as we’ll soon see, also provide tools to make complex asynchronous
    calls easier and remove the need for callback hell.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快就会看到的，承诺还提供了工具，使复杂的异步调用更容易，并消除了回调地狱的需要。
- en: It can be hard for people to wrap their heads around complex asynchronous interactions,
    which can lead to bugs. Blocking actions are much easier to think about, but are
    less efficient. Promises make complex asynchronous code easier to manage, but
    you still have to think asynchronously. But not with `async` functions. Async
    functions allow you to write your code as if it were a blocking operation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人们很难理解复杂的异步交互，这可能导致错误。阻塞操作更容易思考，但效率较低。承诺使复杂的异步代码更容易管理，但你仍然需要异步思考。但不是使用`async`函数。异步函数允许你像编写阻塞操作一样编写代码。
- en: A promise yields one value, and then it’s over. An observable is like a promise
    that continues to yield values. Observables allow you to turn anything into an
    event that you can subscribe to, and they allow you to treat events like objects
    that you can apply higher-order functions to such as `map` and `reduce`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺产生一个值，然后结束。一个可观察对象就像一个承诺，它继续产生值。可观察对象允许你将任何东西转换成你可以订阅的事件，并允许你将事件当作对象来处理，你可以对其应用高阶函数，如`map`和`reduce`。
- en: Lesson 30\. Promises
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第30课\. 承诺
- en: After reading [lesson 30](kindle_split_045_split_000.xhtml#ch30), you will be
    able to
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第30课](kindle_split_045_split_000.xhtml#ch30)之后，你将能够
- en: Use promise-based libraries to fetch asynchronous data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于承诺的库来获取异步数据
- en: Do basic error handling for promises
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对承诺进行基本错误处理
- en: Memoize asynchronous calls using `Promise.resolve`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Promise.resolve`来缓存异步调用
- en: Combine several promises into one
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个承诺合并为一个
- en: A *promise* is an object that represents an eventual value. You can access this
    eventual or future value by calling `.then()` on the promise and supplying a callback
    function. The promise will eventually invoke this callback with the value. If
    the promise is still waiting for the value (the promise is in a *pending* state),
    then the promise will wait until the value is ready or has loaded (at which point
    the promise enters the *resolved* state) before invoking the callback with the
    value. If the promise has already resolved, then the callback will be invoked
    right away.^([[1](kindle_split_045_split_000.xhtml#ch30fn01)])
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*承诺*是一个表示最终值的对象。你可以通过在承诺上调用`.then()`并提供一个回调函数来访问这个最终或未来的值。承诺最终会使用这个值调用这个回调。如果承诺仍在等待值（承诺处于*挂起*状态），那么承诺将等待直到值准备好或已加载（此时承诺进入*解决*状态），然后使用值调用回调。如果承诺已经解决，则回调将立即被调用.^([[1](kindle_split_045_split_000.xhtml#ch30fn01)])
- en: ¹
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not immediately. The callback will be added to the event loop, similar to a
    `setTimeout` with a delay of 0.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不是立即的。回调将被添加到事件循环中，类似于带有0延迟的`setTimeout`。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Asynchronous values in JavaScript were traditionally accessed by passing around
    callback functions that would get invoked once the data was ready. This is limiting
    because only the object that has a reference to the callback gets notified when
    the value is ready. What if instead of passing around a callback, you could pass
    around a value that represents what the asynchronous value will eventually become?
    How would this work?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，异步值传统上是通过传递回调函数来访问的，这些回调函数会在数据准备好时被调用。这很有限，因为只有拥有回调引用的对象会在值准备好时收到通知。如果除了传递回调之外，你还可以传递一个表示异步值最终将变成什么的价值，会怎么样？这将如何工作？
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.1\. Using promises
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.1\. 使用承诺
- en: 'Let’s assume you’re using a library called `axios` that makes an AJAX request
    and returns a promise. You want to use it to load data from the GitHub API and
    list a specific user’s organizations. You could make the request like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用一个名为 `axios` 的库，该库执行 AJAX 请求并返回一个承诺。你想使用它从 GitHub API 加载数据并列出特定用户的组织。你可以这样发出请求：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* The axios.get function makes an AJAX request and returns a promise.**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* axios.get 函数执行 AJAX 请求并返回一个承诺。**'
- en: '***2* You’re calling the then function on the promise with an arrow function.
    The arrow function will get invoked with the resp after the request completes.**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你在承诺上调用 then 函数时使用了箭头函数。箭头函数将在请求完成后使用 resp 被调用。**'
- en: Here you call `axios.get`, which returns a promise. When that promise resolves,
    you get the data from the response object. You can then do something with the
    results.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你调用 `axios.get`，它返回一个承诺。当该承诺解决时，你可以从响应对象中获取数据。然后你可以对结果进行一些操作。
- en: 'Let’s look at what this might look like if `axios` used callbacks instead of
    promises:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果 `axios` 使用回调而不是承诺会是什么样子：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this simple example, it seems like using promises just adds more steps than
    using a callback. However, as our examples become more complex, you’ll see how
    promises make for far more flexible and readable code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，使用承诺似乎比使用回调增加了更多步骤。然而，随着我们的示例变得更加复杂，你会看到承诺如何使代码更加灵活和可读。
- en: 'The function has my username hard-coded. Rewrite it to load a specified user’s
    organizations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中硬编码了我的用户名。将其重写为加载指定用户的组织：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here you made a function that takes a username and returns a promise. You then
    used that function to fetch the organizations for my user. Again let’s look at
    what this might look like using traditional callbacks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个接受用户名并返回承诺的函数。然后你使用该函数获取我的用户的组织。再次看看使用传统回调会是什么样子：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this fictitious function, the `getOrgs` function has gotten more complex
    because it needs to accept a callback function so it can pass it to the AJAX library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个虚构的函数中，`getOrgs` 函数变得更加复杂，因为它需要接受一个回调函数，以便将其传递给 AJAX 库。
- en: 'Now let’s imagine you have a class that represents a user view. In this user
    view, you don’t immediately show the user’s organizations, but, to make the application
    faster, you want to start loading them right away, in anticipation of showing
    them later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象你有一个表示用户视图的类。在这个用户视图中，你不会立即显示用户的组织，但为了使应用程序更快，你希望立即开始加载它们，以便稍后显示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Start loading the user orgs right away.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 立即开始加载用户组织。**'
- en: '***2* Show the orgs once loaded.**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 加载完成后显示组织。**'
- en: Here you created a class called `UserView` that starts loading the user’s organizations
    immediately. Later when the user view needs to show the user’s organizations,
    if they’re already loaded or if they’re still being loaded, it won’t matter. Either
    way, it will wait until they finish loading and then show them—or if they’ve already
    loaded, it will show them right away. This would be much harder to achieve using
    traditional callbacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个名为 `UserView` 的类，该类立即开始加载用户的组织。稍后当用户视图需要显示用户的组织时，无论它们是否已经加载或仍在加载中，都不会影响。无论如何，它将等待它们加载完成，然后显示它们——如果它们已经加载，它将立即显示它们。使用传统的回调来实现这一点会困难得多。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.1**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.1**'
- en: '**[Q1:](kindle_split_045_split_001.xhtml#ch30qa2q0a1)**'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_045_split_001.xhtml#ch30qa2q0a1)**'
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following example is using an AJAX function that takes a callback. Assuming
    the AJAX function returns a promise, rewrite it to use a promise instead:'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下示例使用了一个接受回调的 AJAX 函数。假设 AJAX 函数返回一个承诺，将其重写为使用承诺：
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.1 answer**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.1 答案**'
- en: '**[A1:](kindle_split_045_split_001.xhtml#ch30qa1q1)**'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_045_split_001.xhtml#ch30qa1q1)**'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.2\. Error handling
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.2\. 错误处理
- en: 'We don’t live in a perfect world. Sometimes the data that the promise is retrieving
    fails, either from a network error or from some other issue. The `then` method
    on a promise takes an optional second callback that gets invoked with the error
    if an error occurs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不生活在一个完美的世界里。有时承诺检索的数据会失败，无论是由于网络错误还是其他问题。承诺上的 `then` 方法接受一个可选的第二个回调，如果发生错误，则调用该回调：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If everything works as expected here, the `handleResp` function will get called
    with the response object from the request. If something goes wrong, the `handleError`
    function will get called with the error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这里一切如预期进行，`handleResp` 函数将接收到来自请求的响应对象。如果出现问题，`handleError` 函数将被调用以处理错误。
- en: Thesse are the basics of error handling with promises, but we’ll touch on some
    different techniques and gotchas about error handling with promises in [lesson
    31](kindle_split_046_split_000.xhtml#ch31) on advanced promises.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用承诺进行错误处理的基础，但我们将触及一些关于使用承诺进行错误处理的不同技术和注意事项，在关于高级承诺的[第 31 课](kindle_split_046_split_000.xhtml#ch31)中讨论。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.2**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.2**'
- en: '**[Q1:](kindle_split_045_split_002.xhtml#ch30qa4q0a1)**'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_045_split_002.xhtml#ch30qa4q0a1)**'
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following example uses a function called `getJSON` that takes a function
    that accepts two arguments. The first is a possible error object; the second is
    the JSON data that was loaded. Usually only one value will be present. Rewrite
    this to be promise-based instead of callback-based:'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下示例使用一个名为 `getJSON` 的函数，该函数接受一个接受两个参数的函数。第一个是一个可能的错误对象；第二个是加载的 JSON 数据。通常只有一个值会存在。将此重写为基于承诺而不是基于回调：
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.2 answer**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.2 答案**'
- en: '**[A1:](kindle_split_045_split_002.xhtml#ch30qa3q1)**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_045_split_002.xhtml#ch30qa3q1)**'
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.3\. Promise helpers
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.3. 承诺辅助函数
- en: 'The `Promise` object has four helper methods to make working with promises
    much easier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象有四个辅助方法，使处理承诺变得更加容易：'
- en: '`Promise.resolve()`'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Promise.resolve()`'
- en: '`Promise.reject()`'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Promise.reject()`'
- en: '`Promise.all()`'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Promise.all()`'
- en: '`Promise.race()`'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Promise.race()`'
- en: 'Let’s start with `Promise.resolve()`. This function returns a promise that
    has already resolved. Any argument given to `Promise.resolve` will be returned
    from the promise via a parameter passed to a function supplied to `.then`. This
    can be helpful for all sorts of reasons, and is typically used when something
    is expecting a promise but you already have a value available. Consider a scenario
    where you’re loading transactions for an accounting program. Whenever you load
    a transaction, you want to cache it so that next time it’s requested, you don’t
    have to load it again. You may end up with some code like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `Promise.resolve()` 开始。这个函数返回一个已经解析的承诺。传递给 `Promise.resolve` 的任何参数将通过传递给
    `.then` 方法中提供的函数的参数从承诺中返回。这可以出于各种原因而很有帮助，通常在期望承诺但已经有可用值的情况下使用。考虑一个场景，当你正在加载会计程序的交易时。每次加载交易时，你都想将其缓存起来，这样下次请求时就不需要再次加载。你可能会得到一些像这样的代码：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* If you already have the data, invoke the callback right away.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果你已经有了数据，立即调用回调。**'
- en: '***2* Assuming a fictitious load function that fetches data and returns it
    directly**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 假设一个虚构的加载函数，它获取数据并直接返回**'
- en: '***3* If you loaded the data, invoke the callback once you have it.**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果你已加载数据，一旦你有它就调用回调。**'
- en: 'Here you’re using an imaginary `load` function that fetches data from a URL
    and returns it directly via a promise. The `getTransaction` function effectively
    memoizes the network’s requests so that each transaction only needs to be loaded
    once. But you’ve had to resort back to callbacks, and lost many of the benefits
    of promises. For example, how would you add error handling to this? Rewrite `getTransaction`
    to always return a promise with the help of `Promise.resolve`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用一个假想的 `load` 函数，它从 URL 获取数据并通过承诺直接返回它。`getTransaction` 函数有效地缓存了网络的请求，这样每个交易只需要加载一次。但你不得不回到回调，并失去了承诺的许多好处。例如，你将如何添加错误处理？使用
    `Promise.resolve` 重写 `getTransaction` 以始终返回一个承诺：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* If you already have the data, use promise.resolve to return it.**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果你已经有了数据，使用 promise.resolve 返回它。**'
- en: '***2* Create a promise to load the transaction.**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个承诺来加载交易。**'
- en: '***3* Internally add the transaction to your cache when the promise resolves.**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当承诺解析时，将交易内部添加到你的缓存中。**'
- en: '***4* Return the promise.**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回承诺。**'
- en: '***5* You can now easily add error handling.**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 你现在可以轻松地添加错误处理。**'
- en: Your `getTransaction` function now always returns a promise. Because a promise
    is already being returned, you can easily add error handling outside of the `getTransaction`
    function without the `getTransaction` function having to concern itself with any
    error handling.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `getTransaction` 函数现在总是返回一个承诺。因为承诺已经被返回，你可以在 `getTransaction` 函数外部轻松添加错误处理，而无需
    `getTransaction` 函数担心任何错误处理。
- en: When invoking the `getTransaction` function, if the value is already in your
    cache, you return it using `Promise.resolve`, which creates an already resolved
    promise that gives the transaction. If you need to load the transaction, first
    create the promise loading the transaction. Internally you add the new transaction
    to your cache once loaded. You also return the promise. This shows another thing
    you can do with promises—did you catch it? You can call `.then` on a promise as
    many times as you like. Here you called `.then` on your `loading` promise internally
    to add the transaction to your cache. You also called `.then` on the same promise
    externally to actually do something with the transaction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `getTransaction` 函数时，如果值已经在你的缓存中，你将使用 `Promise.resolve` 返回它，这会创建一个已经解决的承诺，并给出交易。如果你需要加载交易，首先创建一个加载交易的承诺。一旦加载，你将内部将新交易添加到你的缓存中。你也会返回这个承诺。这显示了你可以用承诺做的另一件事——你注意到了吗？你可以对承诺多次调用
    `.then`。在这里，你内部在 `loading` 承诺上调用 `.then` 以将交易添加到你的缓存中。你也在外部对同一个承诺调用 `.then` 以实际对交易进行操作。
- en: '`Promise.reject()` works the same way as `Promise.resolve`, only the resulting
    promise is automatically in a *rejected* state instead of a *resolved* state.
    You can also pass a value to `Promise.reject` that will be given to the handler:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.reject()` 与 `Promise.resolve` 的工作方式相同，只是结果承诺自动处于 *拒绝* 状态而不是 *解决* 状态。你还可以向
    `Promise.reject` 传递一个值，该值将被传递给处理程序：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Rejected with: my value**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 拒绝原因：my value**'
- en: 'Sometimes you need to fetch data from several different locations and wait
    for all of it to load before doing anything. Let’s consider a new website that
    has profile pages for authors. The profile page shows an author’s information
    and lists the articles that they have written. You want to show a loading screen
    until both are loaded. You can do so using `Promise.all` like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要从几个不同的位置获取数据，并在做任何事情之前等待所有数据都加载完成。让我们考虑一个新网站，该网站有作者的简介页面。简介页面显示了作者的信息并列出他们所写的文章。你希望在两者都加载完成之前显示一个加载屏幕。你可以使用
    `Promise.all` 如此操作：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Promise.all takes an array of promises and returns a single promise.**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Promise.all 接受一个承诺数组并返回一个单独的承诺。**'
- en: '***2* The new promise gives an array of all the values from the previous promises.**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 新的承诺（promise）返回前一个承诺中所有值的数组。**'
- en: Here you create promises for loading both the author and the author’s articles.
    You give an array of these promises to `Promise.all`, which returns a single promise.
    The new promise will wait until all the promises have resolved and will give an
    array of all the values given from the previous promises. If any of the promises
    fail, the new promise will also fail with the error given from the first promise
    that failed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了加载作者及其文章的承诺。你将这些承诺的数组传递给 `Promise.all`，它返回一个单独的承诺。新的承诺将等待所有承诺都解决，并将从之前的承诺中给出的所有值作为一个数组给出。如果任何一个承诺失败，新的承诺也会因为第一个失败的承诺的错误而失败。
- en: '`Promise.race` works similarly to `Promise.all`: it takes an array of promises
    and returns a new promise. But this promise resolves as soon as the first promise
    it was given resolves, and gives its value.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.race` 与 `Promise.all` 的工作方式类似：它接受一个承诺数组并返回一个新的承诺。但是，这个新的承诺会在它所给的第一个承诺解决时立即解决，并给出其值。'
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 30.3**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.3**'
- en: '**[Q1:](kindle_split_045_split_003.xhtml#ch30qa6q0a1)**'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_045_split_003.xhtml#ch30qa6q0a1)**'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following example, what number will be logged?
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下示例中，将记录哪个数字？
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 30.3 answer**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.3 答案**'
- en: '**[A1:](kindle_split_045_split_003.xhtml#ch30qa5q1)**'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_045_split_003.xhtml#ch30qa5q1)**'
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '2'
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, you learned the basics of how to use promises.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何使用承诺（promises）的基础知识。
- en: A promise is an object that represents an eventual or future value.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺（promise）是一个表示最终或未来值的对象。
- en: The value is accessed by passing a callback to `.then` on the promise.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在承诺的 `.then` 上传递一个回调来访问这个值。
- en: An optional second callback can be given to `.then` to handle if the promise
    is rejected.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以向 `.then` 传递一个可选的第二个回调来处理承诺被拒绝的情况。
- en: '`.then` can be called on the promise any number of times.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在承诺上多次调用 `.then`。
- en: If the promise is pending, `.then` will wait until the promise resolves.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Promise处于挂起状态，`.then` 将等待直到Promise解决。
- en: If the promise is resolved, `.then` will still yield a value.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Promise已解决，`.then` 仍然会提供一个值。
- en: '`Promise.resolve` creates a pre-resolved promise.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.resolve` 创建一个已解决的Promise。'
- en: '`Promise.reject` create a pre-rejected promise.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.reject` 创建一个已拒绝的Promise。'
- en: '`Promise.all` takes an array of promises and returns a new promise that waits
    for all of them to resolve.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.all` 接受一个Promise数组，并返回一个新的Promise，该Promise等待所有这些Promise都解决。'
- en: '`Promise.race` takes an array of promises and returns a new promise that only
    waits for the first to resolve.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.race` 接受一个Promise数组，并返回一个新的Promise，该Promise只等待第一个解决。'
- en: 'Let’s see if you got this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这些：
- en: '**[Q30.1](kindle_split_050_split_021.xhtml#app01qa21q0a1)**'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q30.1](kindle_split_050_split_021.xhtml#app01qa21q0a1)**'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s say you have three endpoints:'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你有三个端点：
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: /user/4XJ/credit_availability
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /user/4XJ/credit_availability
- en: /transunion/credit_score?user=4XJ
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /transunion/credit_score?user=4XJ
- en: /equifax/credit_score?user=4XJ
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /equifax/credit_score?user=4XJ
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first endpoint checks the credit available on file for the user. The other
    two endpoints check the user’s latest credit score from TransUnion and EquiFax.
    To render the page, you need to wait for the credit availability and at least
    one credit score. Use any promise-based AJAX library and create a new promise
    that combines `Promise.all` and `Promise.race` to achieve this.
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个端点检查用户的信用可用性。其他两个端点检查用户从TransUnion和EquiFax的最新信用评分。为了渲染页面，你需要等待信用可用性和至少一个信用评分。使用任何基于Promise的AJAX库，并创建一个新的Promise，该Promise结合了`Promise.all`和`Promise.race`来实现这一点。
- en: Lesson 31\. Advanced promises
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第31课：高级Promise
- en: After reading [lesson 31](kindle_split_046_split_000.xhtml#ch31), you will be
    able to
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第31课](kindle_split_046_split_000.xhtml#ch31)后，你将能够
- en: Create your own promises
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的Promise
- en: Wrap callback-based methods with promises
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Promise包装基于回调的方法
- en: Use and understand how to properly write nested promises
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并理解如何正确编写嵌套的Promise
- en: Understand how error handling propagates in promise chains
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解错误处理如何在Promise链中传播
- en: In the previous lesson you learned the basics of promises. We’ll now take a
    more advanced look at creating new promises and converting asynchronous code to
    use promises. We’ll look at advanced error handling, using promises for multiple
    asynchronous calls, and other advanced usages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一课中，你学习了Promise的基础知识。现在我们将更深入地探讨创建新的Promise以及将异步代码转换为使用Promise的方法。我们将探讨高级错误处理、使用Promise进行多个异步调用以及其他高级用法。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Sometimes you need to make multiple asynchronous calls to get the data you need.
    A piece of data relies on another piece of data, which relies on yet another piece
    of data. Yet all of these pieces of data must be fetched from different locations.
    Traditionally you would have to treat these as three different operations with
    three different error catchers. What if you could turn it into one single operation
    with one error catcher?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要进行多次异步调用以获取所需的数据。一块数据依赖于另一块数据，而另一块数据又依赖于另一块数据。然而，所有这些数据都必须从不同的位置获取。传统上，你不得不将这些视为三个不同的操作，每个操作都有三个不同的错误处理程序。如果你能将其转换为一个单一的操作，并使用一个错误处理程序会怎样呢？
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 31.1\. Creating promises
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.1\. 创建Promise
- en: 'A promise is created by instantiating a new `Promise` object with a function
    argument, `new Promise(fn)`. The function given to the promise should take two
    arguments itself. The first one is a function to *resolve* the promise, and the
    second is a function to *reject* the promise:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个函数参数实例化一个新的`Promise`对象来创建Promise，`new Promise(fn)`。传递给Promise的函数本身应该接受两个参数。第一个参数是一个函数，用于*解决*Promise，第二个参数是一个函数，用于*拒绝*Promise：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* “alligator”**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “鳄鱼”**'
- en: 'Let’s say you’re loading an image via JavaScript. The classic way of doing
    this is to create an `Image` object and set a `src` property with callbacks assigned
    to `onload` and `onerror` like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用JavaScript加载一张图片。经典的方法是创建一个`Image`对象，并设置一个`src`属性，将`onload`和`onerror`回调分配给它，如下所示：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you wanted to turn the image loading into a promise, you could wrap it in
    a `Promise` and assign the `onload` and `onerror` to your resolve and reject functions
    respectively:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将图片加载转换为Promise，你可以在它周围包装一个`Promise`，并将`onload`和`onerror`分别分配给你的解决和拒绝函数：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We saw in the previous lesson that the `Promise` object has some helper methods
    like `Promise.resolve` and `Promise.reject`, but what if you wanted the promise
    to wait five seconds before resolving? This would be a handy promise-based version
    of `setTimeout`. You can actually wrap `setTimeout` with a promise to create such
    a tool:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一课中，我们看到了 `Promise` 对象有一些辅助方法，如 `Promise.resolve` 和 `Promise.reject`，但如果你想要承诺在解析前等待五秒，这将是一个方便的基于承诺的
    `setTimeout` 版本。实际上，你可以用承诺包裹 `setTimeout` 来创建这样的工具：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can turn any callback-based function into a promise using this technique.
    Let’s say, for example, you’re using the `navigator.geolocation.getCurrentPosition`
    function, which is callback-based. It takes a `success` callback and an `error`
    callback like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种技术将任何基于回调的函数转换为承诺。例如，假设你正在使用 `navigator.geolocation.getCurrentPosition`
    函数，这是一个基于回调的函数。它接受一个 `success` 回调和一个 `error` 回调，如下所示：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can wrap this in a promise like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样包裹它：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If it takes a callback, you can wrap it in a promise!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它需要一个回调，你可以将其包裹在一个承诺中！
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.1**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 31.1**'
- en: '**[Q1:](kindle_split_046_split_001.xhtml#ch31qa2q0a1)**'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_046_split_001.xhtml#ch31qa2q0a1)**'
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How could you wrap this `registerUser` function in a promise?
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何将这个 `registerUser` 函数包裹在一个承诺中？
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 31.1 answer**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.1 答案**'
- en: '**[A1:](kindle_split_046_split_001.xhtml#ch31qa1q1)**'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_046_split_001.xhtml#ch31qa1q1)**'
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 31.2\. Nested promises
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.2. 嵌套的承诺
- en: 'In the previous lesson about promises, we went over how to use an AJAX library
    that returns a promise. But you could, instead, use the new Web Hypertext Application
    Technology Working Group (WHATWG) standard method `fetch` for making AJAX requests.
    To do so you would need to use multiple promises:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于承诺的上一课中，我们介绍了如何使用返回承诺的 AJAX 库。但你可以使用新的 Web Hypertext Application Technology
    Working Group (WHATWG) 标准方法 `fetch` 来进行 AJAX 请求。为此，你需要使用多个承诺：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is starting to look like callback hell, but this isn’t actually how promises
    are meant to be used. Every time you call `then()` on a promise, it returns a
    new promise. This makes promises chainable:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始看起来像是回调地狱，但实际上承诺并不是这样使用的。每次你在承诺上调用 `then()`，它都会返回一个新的承诺。这使得承诺可以链式调用：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how your `then`s are no longer nested within each other, and are instead
    being chained together.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你的 `then`s 现在不再是嵌套的，而是被链式连接在一起。
- en: 'When you invoke `then()` on a promise, you pass a function as a parameter.
    Whatever that function returns will be the value for the next `then()` in the
    chain:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在承诺上调用 `then()` 时，你传递一个函数作为参数。该函数返回的任何内容都将作为链中下一个 `then()` 的值：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* 1 + 1 = 2**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 1 + 1 = 2**'
- en: '***2* 2 + 1 = 3**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 2 + 1 = 3**'
- en: '***3* 3 + 1 = 4**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 3 + 1 = 4**'
- en: '***4* 4**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 4**'
- en: 'There’s one exception to this: if the function given to a `then()` returns
    a promise, the promise returned by `then()` will wait until that promise resolves
    or rejects a value, and will do the same:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外：如果传递给 `then()` 的函数返回一个承诺，那么 `then()` 返回的承诺将等待该承诺解析或拒绝一个值，并执行相同的操作：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* “have elapsed.”**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “已过去。”**'
- en: '***2* “have elapsed.”**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “已过去。”**'
- en: '***3* “have elapsed.”**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* “已过去。”**'
- en: Here, the first promise specifies to wait 5 seconds. When it resolves, you log
    the elapsed time. You get 5.004, but that’s only because the `setTimeout` you’re
    using under the hood doesn’t guarantee exact timing. That function returns another
    promise set to wait another 5 seconds. So the next `then()` in the chain resolves
    after a total of ~10 seconds. You then return yet another promise that waits 2
    seconds, causing the final `then()` to resolve after a total of ~12 seconds.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个承诺指定等待 5 秒。当它解析时，你记录过去的时间。你得到 5.004，但这只是因为你在底层使用的 `setTimeout` 并不保证精确的时间。该函数返回另一个承诺，设置为再等待
    5 秒。因此，链中的下一个 `then()` 在总共约 10 秒后解析。然后你返回另一个等待 2 秒的承诺，导致最终的 `then()` 在总共约 12 秒后解析。
- en: 'It’s important to remember this only works if the function inside the `then`
    returns the promise. A promise inside the `then` that isn’t returned won’t work:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这只有在 `then` 内部的函数返回承诺时才有效。`then` 内部的未返回的承诺将不起作用：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* “have elapsed.”**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “已过去。”**'
- en: '***2* “have elapsed.”**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “已过去。”**'
- en: This time around, the second `wait` wasn’t returned, so the next `then()` in
    the chain didn’t wait for it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，第二个 `wait` 没有返回，所以链中的下一个 `then()` 没有等待它。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.2**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 31.2**'
- en: '**[Q1:](kindle_split_046_split_002.xhtml#ch31qa4q0a1)**'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_046_split_002.xhtml#ch31qa4q0a1)**'
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following made-up set of functions, each promise is nested. How could
    you rewrite this to use chaining instead?
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下虚构的一组函数中，每个承诺都是嵌套的。你如何重写它以使用链式连接？
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 31.2 answer**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.2 答案**'
- en: '**[A1:](kindle_split_046_split_002.xhtml#ch31qa3q1)**'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_046_split_002.xhtml#ch31qa3q1)**'
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 31.3\. Catching errors
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3\. 捕获错误
- en: 'In the previous section we saw that promises can be chained together using
    multiple `then()`s to create more complex promises. You also recently learned
    that `then()` takes a second callback to handle any errors. This raises the question:
    “If I chain multiple `then`s, do I need to have multiple error handlers?” The
    answer is, you can, but you don’t need to. Whenever a promise rejects, it will
    bubble up through any promises on it until it finds the first error handler:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了可以通过多个 `then()` 将承诺链式连接起来，以创建更复杂的承诺。你最近也了解到 `then()` 接受一个额外的回调来处理任何错误。这引发了一个问题：“如果我链式连接多个
    `then()`，我是否需要多个错误处理器？” 答案是，你可以，但不需要。每当承诺拒绝时，它将通过其上的任何承诺向上冒泡，直到找到第一个错误处理器：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous example will log the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子将记录以下内容：
- en: A
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A
- en: 'caught: X'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获：X
- en: C
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: Notice that it didn’t log `B`, which occurred after the rejection but before
    the error handler. But it did log `C`, which occurred after the error handler.
    This is because when a promise rejects, none of the promises after it will resolve
    until the rejection is caught. Once caught, any promise later in the chain will
    be able to resolve.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它没有记录 `B`，这是在拒绝之后但在错误处理器之前发生的。但它确实记录了 `C`，这是在错误处理器之后发生的。这是因为当承诺拒绝时，其后的任何承诺都不会解决，直到拒绝被捕获。一旦捕获，链中的任何后续承诺都将能够解决。
- en: 'Notice how you used `null` as the first argument because you only cared about
    catching the error at that step. There’s a convenience method `catch` for this
    very purpose. The previous example could have been written like so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何使用 `null` 作为第一个参数，因为你只关心在那个步骤捕获错误。有一个方便的方法 `catch` 正是为了这个目的。之前的例子可以写成这样：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You don’t have to use `Promise.reject` or explicitly call `reject()` inside
    of a promise to cause it to reject. Any JavaScript error will cause a rejection:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用 `Promise.reject` 或在承诺内部显式调用 `reject()` 来使承诺拒绝。任何 JavaScript 错误都会导致拒绝：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* caught: My Error**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 捕获：我的错误**'
- en: 'Let’s take a look at another example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* This won’t catch the error.**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这不会捕获错误。**'
- en: '***2* This will catch the error.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这将捕获错误。**'
- en: When you give two functions to a `.then()`, the first function runs in the event
    of the promise resolving, and the second function runs in the event of the promise
    rejecting. But if there’s an error in the first function, the second function
    won’t catch it. It will bubble up to the next promise that’s returned from the
    `.then()` and cause that promise to reject. So in order to catch the error, you
    must catch it from that promise. See [figure 31.1](kindle_split_046_split_003.xhtml#ch31fig01).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向 `.then()` 提供两个函数时，第一个函数在承诺解决时运行，第二个函数在承诺拒绝时运行。但如果第一个函数中存在错误，第二个函数将不会捕获它。它将冒泡到从
    `.then()` 返回的下一个承诺，并导致该承诺拒绝。因此，为了捕获错误，你必须从该承诺中捕获它。参见[图 31.1](kindle_split_046_split_003.xhtml#ch31fig01)。
- en: Figure 31.1\. Promise error handling
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 31.1\. 承诺错误处理
- en: '![](Images/31fig01_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/31fig01_alt.jpg)'
- en: Because every call to `.then` or `.catch` returns a new promise, it means there’s
    always a promise at the end that could potentially go uncaught. Initially, this
    was a cause for concern because if you didn’t catch an error from a promise, the
    promise *swallowed* the error and it went unreported. But most environments today
    raise an unhandled promise rejection error.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每次调用 `.then` 或 `.catch` 都会返回一个新的承诺，这意味着总有一个承诺在末尾，它可能会未被捕获。最初，这引起了一些担忧，因为如果你没有从承诺中捕获错误，承诺就会“吞下”错误，并且没有报告。但大多数环境今天都会引发未处理的承诺拒绝错误。
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.3**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 31.3**'
- en: '**[Q1:](kindle_split_046_split_003.xhtml#ch31qa6q0a1)**'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_046_split_003.xhtml#ch31qa6q0a1)**'
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following example, if `handlerOne` throws an error, which catcher will
    catch the error? What if `handlerTwo` throws the error?
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下示例中，如果 `handlerOne` 抛出错误，哪个捕获器将捕获错误？如果 `handlerTwo` 抛出错误呢？
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 31.3 answer**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.3 答案**'
- en: '**[A1:](kindle_split_046_split_003.xhtml#ch31qa5q1)**'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_046_split_003.xhtml#ch31qa5q1)**'
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`catcherTwo` will catch from `handlerOne`. `handlerTwo` would cause an unhandled
    promise rejection.'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`catcherTwo` 将从 `handlerOne` 捕获。`handlerTwo` 将导致未处理的承诺拒绝。'
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned about the most advanced usages of promises.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了 promise 的最先进用法。
- en: You can create a new promise with a callback that accepts `resolve` and `reject`
    functions.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个接受 `resolve` 和 `reject` 函数的回调来创建一个新的 promise。
- en: The `.catch(errCatcher)` function is shorthand for `.then(null, errCatcher)`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.catch(errCatcher)` 函数是 `.then(null, errCatcher)` 的简写。'
- en: Every call to `.then()` or `.catch()` returns a new promise creating a promise
    chain.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用 `.then()` 或 `.catch()` 都会返回一个新的 promise，从而创建一个 promise 链。
- en: Responses or rejections from previous promises bubble up through the promise
    chain.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个 promise 的响应或拒绝会冒泡到 promise 链中。
- en: 'Let’s see if you got this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个：
- en: '**[Q31.1](kindle_split_050_split_022.xhtml#app01qa22q0a1)**'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q31.1](kindle_split_050_split_022.xhtml#app01qa22q0a1)**'
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following function `getArticle` is callback-based. It also uses a function
    called `load`, which is also callback-based. Write a function that wraps the `load`
    function with a promise. Then rewrite the `getArticle` to be promise-based instead
    of callback-based:'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下函数 `getArticle` 是基于回调的。它还使用了一个名为 `load` 的函数，该函数也是基于回调的。编写一个函数，将 `load` 函数用
    promise 包装。然后重写 `getArticle` 以使其基于 promise 而不是基于回调：
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Lesson 32\. Async functions
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 32 课\. 异步函数
- en: After reading [lesson 32](kindle_split_047_split_000.xhtml#ch32), you will be
    able to
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读第 32 课 [lesson 32](kindle_split_047_split_000.xhtml#ch32) 之后，你将能够
- en: Write asynchronous code using a synchronous syntax
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同步语法编写异步代码
- en: Use generators to write asynchronous code
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器编写异步代码
- en: Use asynchronous functions to write asynchronous code
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步函数编写异步代码
- en: One of the reasons JavaScript can be hard to learn is because of its asynchronous
    nature. Asynchronous code is hard to think about, but it’s this asynchronous nature
    that makes JavaScript such a great language for the web. Web applications are
    full of asynchronous actions—from loading assets to handling user input. The purpose
    of asynchronous functions is to make it easy to write and think about asynchronous
    code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 难以学习的一个原因是它的异步特性。异步代码难以思考，但正是这种异步特性使得 JavaScript 成为一种非常适合网络的语言。Web
    应用程序充满了异步操作——从加载资源到处理用户输入。异步函数的目的是使编写和思考异步代码变得容易。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: So far in this unit we’ve been dealing with promises, which have proven to be
    much more useful than traditional asynchronous code using callbacks. But when
    using promises you still have to *think* asynchronously, which is much harder
    to do than thinking synchronously. Languages like PHP or Ruby are synchronous,
    so operations that take time to complete are easier to think about, but they’re
    *blocking*. This means they halt the execution of any code and block everything
    else from happening until they finish. What if you could get the best of both
    worlds and write code that looks as if it’s blocking—making it easier to think
    about—but still operates asynchronously?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本单元中，我们一直在处理 promise，这已经证明比使用回调的传统异步代码更有用。但是，在使用 promise 时，你仍然必须 *异步地思考*，这比同步思考要困难得多。像
    PHP 或 Ruby 这样的语言是同步的，所以需要时间完成的操作更容易思考，但它们是 *阻塞的*。这意味着它们会停止任何代码的执行，并阻塞其他所有事情的发生，直到它们完成。如果你能够得到两者的最佳之处，编写看起来像阻塞的代码——使其更容易思考——但仍然异步操作，那会怎么样呢？
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 32.1\. Asynchronous code with generators
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.1\. 使用生成器的异步代码
- en: When we discussed generator functions in [lesson 18](kindle_split_029_split_000.xhtml#ch18),
    you learned how you could create pause points by yielding a value. Whenever you
    `yield` a value from within a generator, it pauses at that point in the code until
    `.next()` is called on the generator again. As a reminder, when you call `next()`
    on the generator, you’re able to pass a value to the generator and get back a
    `value` and a `done` property indicating what the generator has completed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 18 课讨论生成器函数时，你学习了如何通过 `yield` 一个值来创建暂停点。每当你在生成器内部 `yield` 一个值时，它会在代码的该点暂停，直到再次在生成器上调用
    `.next()`。作为提醒，当你对生成器调用 `next()` 时，你能够向生成器传递一个值，并返回一个 `value` 和一个 `done` 属性，表示生成器已经完成了什么。
- en: What if the generator were to `yield` a promise? And what if the code that was
    running that generator waited for that promise to resolve and then invoked the
    `next()` function, passing the value resolved from the promise back to the generator?
    What if you did this in a loop, allowing the generator to yield several promises
    back to back?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成器要 `yield` 一个承诺怎么办？如果运行生成器的代码等待该承诺解决，然后调用 `next()` 函数，并将从承诺中解决的值传递回生成器怎么办？如果你在循环中这样做，允许生成器连续产生几个承诺怎么办？
- en: 'Write a function that takes a generator function and does this. Don’t dwell
    on understanding this `runner` function. What you do with it is more important
    than its inner workings:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，它接受一个生成器函数并执行此操作。不要过分关注理解这个 `runner` 函数。你如何使用它比它的内部工作更重要：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Take a generator function with an argument and return a new function.**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 取一个带有参数的生成器函数并返回一个新的函数。**'
- en: '***2* Invoke the generator function with the same arguments.**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用相同的参数调用生成器函数。**'
- en: '***3* Return a new promise.**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回一个新的承诺。**'
- en: '***4* Create a run function.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个 run 函数。**'
- en: '***5* Pass any previous value to the generator, while getting the next value
    from it.**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将任何前一个值传递给生成器，同时从中获取下一个值。**'
- en: '***6* If the generator is complete, resolve the promise with the final value.**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果生成器已完成，则使用最终值解决承诺。**'
- en: '***7* If the value is a promise, tell it to call run again when it resolves.**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 如果值是一个承诺，告诉它在解决时再次调用 run。**'
- en: '***8* Otherwise call run again immediately.**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 否则立即再次调用 run。**'
- en: '***9* Start the loop by invoking run.**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 通过调用 run 启动循环。**'
- en: Here you have a function that does exactly what we just discussed. You can give
    it a generator function and get back a new function that can `yield` promises,
    and get back their values once resolved. This `runner` function is pretty complex,
    so don’t worry if you find it hard to follow. The point is how you can use this
    `runner` function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个函数，它正好做了我们刚才讨论的事情。你可以给它一个生成器函数，然后得到一个新的函数，它可以 `yield` 承诺，并在解决后获取它们的值。这个
    `runner` 函数相当复杂，所以如果你发现它难以理解，不要担心。重点是你可以如何使用这个 `runner` 函数。
- en: 'Here’s an example that uses `fetch` to load an image which requires three promises:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 `fetch` 加载图像的例子，该图像需要三个承诺：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you were to use a generator with your `runner` function, you could have
    written it like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `runner` 函数与生成器一起使用，你可以这样编写它：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or if you wanted to make this function more universal, you could have done
    something more like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想使这个函数更通用，你可以这样做：
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By using the `runner` function to wrap your generator, every time you `yield`
    a promise, you get back the value from that promise. This allows you to write
    code that looks synchronous or blocking, but is actually still asynchronous.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `runner` 函数包装你的生成器，每次你 `yield` 一个承诺时，你都会从该承诺中获取值。这允许你编写看起来是同步或阻塞的代码，但实际上仍然是异步的。
- en: At the time of this writing, the `createImageBitmap` function that you’re using
    in these examples is only supported by the latest versions of Mozilla Firefox
    and Google Chrome.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你在这些例子中使用的 `createImageBitmap` 函数仅由最新版本的 Mozilla Firefox 和 Google Chrome
    支持。
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 32.1**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 32.1**'
- en: '**[Q1:](kindle_split_047_split_001.xhtml#ch32qa2q0a1)**'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_047_split_001.xhtml#ch32qa2q0a1)**'
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you convert the following code to make use of a generator and the
    `runner` function?
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会如何转换以下代码以使用生成器和 `runner` 函数？
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 32.1 answer**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 32.1 答案**'
- en: '**[A1:](kindle_split_047_split_001.xhtml#ch32qa1q1)**'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_047_split_001.xhtml#ch32qa1q1)**'
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 32.2\. Async functions
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2\. 异步函数
- en: The awesome thing about learning how to write asynchronous code using generators,
    promises, and a runner function is that you don’t have to learn anything new to
    make the jump to asynchronous functions. That’s because async functions are just
    syntactic sugar for the generators + promises approach. All you really need to
    learn are the new keywords. To indicate that a function is an async function,
    you prefix it with the `async` keyword. Then, instead of using the keyword `yield`,
    you use the keyword `await`. That’s all!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用生成器、承诺和 `runner` 函数编写异步代码的酷之处在于，你不必学习任何新东西就可以跳转到异步函数。这是因为异步函数只是生成器 + 承诺方法的语法糖。你真正需要学习的就是新关键字。为了表示一个函数是异步函数，你需要在它前面加上
    `async` 关键字。然后，你不再使用 `yield` 关键字，而是使用 `await` 关键字。就是这样！
- en: 'The previous fetch image function could be rewritten using an async function:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 fetch 图像函数可以用异步函数重写：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how little you changed. You aren’t using a generator anymore, and you
    don’t need the `runner` function anymore, either. You just need to indicate that
    your function is `async`, and then you can `await` promises instead of `yield`ing
    them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你做了多小的改变。你不再使用生成器，也不再需要 `runner` 函数。你只需要表明你的函数是 `async` 的，然后你可以 `await` promise
    而不是 `yield` 它们。
- en: 'An async function will always return a promise. If the async function itself
    returns a value, the promise returned will resolve to that value. If the async
    function returns a promise, the promise returned from the async function will
    resolve that promise’s value. This means you could have simplified your `fetchImage`
    function like so:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数总是会返回一个 promise。如果异步函数本身返回一个值，返回的 promise 将解析为该值。如果异步函数返回一个 promise，异步函数返回的
    promise 将解析那个 promise 的值。这意味着你可以这样简化你的 `fetchImage` 函数：
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Inside the async function, when you `await` a promise, it will wait for the
    promise to resolve then return the promise’s value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步函数中，当你 `await` 一个 promise 时，它将等待 promise 解析然后返回 promise 的值。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 32.2**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 32.2**'
- en: '**[Q1:](kindle_split_047_split_002.xhtml#ch32qa4q0a1)**'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_047_split_002.xhtml#ch32qa4q0a1)**'
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you convert the following code to make use of an async function?
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会如何转换以下代码以使用异步函数？
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 32.2 answer**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 32.2 答案**'
- en: '**[A1:](kindle_split_047_split_002.xhtml#ch32qa3q1)**'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_047_split_002.xhtml#ch32qa3q1)**'
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 32.3\. Error handling in async functions
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.3\. 异步函数中的错误处理
- en: 'If any of the promises that you `await` reject, you can handle the rejection
    from outside async function like so:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你 `await` 的任何一个 promise 被拒绝，你可以像这样从异步函数外部处理拒绝：
- en: '[PRE46]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* “I Failed.”**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “我失败了。”**'
- en: 'I’ve seen many people use try-catch statements inside async functions. This
    will work if an actual error is thrown. Remember, however, that an error will
    cause a promise to reject, but you can also manually reject a promise. In the
    latter case, a try-catch statement won’t catch the rejection:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到很多人在异步函数中使用 try-catch 语句。如果实际抛出了错误，这将有效。然而，记住，错误会导致 promise 拒绝，但你也可以手动拒绝一个
    promise。在后一种情况下，try-catch 语句不会捕获到拒绝：
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Uncaught (in promise) My Rejection Msg**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 未捕获（在 promise 中）我的拒绝信息**'
- en: In this example, the try-catch statement didn’t catch the `Promise.reject` and
    caused your `tryTest` function to throw an `uncaught in promise` error.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，try-catch 语句没有捕获到 `Promise.reject`，导致你的 `tryTest` 函数抛出了 `uncaught in
    promise` 错误。
- en: 'You could write your own promise wrapper to make error handling in async functions
    easier. You just need a function that takes a promise and returns a new promise
    that always resolves an array. If successful, the first value will be the result;
    if the promise is rejected, the second value will be the rejection:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写自己的 promise 包装器，使异步函数中的错误处理更容易。你只需要一个函数，它接受一个 promise 并返回一个新的 promise，该
    promise 总是解析为一个数组。如果成功，第一个值将是结果；如果 promise 被拒绝，第二个值将是拒绝：
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this little helper function you could now write your `tryTest` function
    like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个小小的辅助函数，你现在可以像这样编写你的 `tryTest` 函数：
- en: '[PRE49]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* response: caught: err err**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* response: caught: err err**'
- en: 'Let’s imagine you’re building a photo gallery and you want to fetch all the
    images using your `fetchImage` function. You need to wait until all of them have
    loaded before rendering the gallery. You could use `Promise.all` for this, but
    that would mean that if any of the images fail to load (highly possible), the
    whole thing would reject. Instead, you want any failed images to be skipped and
    to just get the result of all the images that loaded successfully. Use an async
    function to achieve this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你正在构建一个相册，并想使用你的 `fetchImage` 函数获取所有图片。你需要等待所有图片加载完成后再渲染相册。你可以使用 `Promise.all`
    来实现这一点，但这意味着如果任何图片加载失败（可能性很高），整个操作将会拒绝。相反，你希望跳过失败的图片，只获取所有成功加载的图片的结果。使用异步函数来实现这一点：
- en: '[PRE50]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* An array to hold all of the resolved values**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个用于存储所有解析值的数组**'
- en: '***2* When the promise resolves, add the response to the array.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当 promise 解析时，将响应添加到数组中。**'
- en: '***3* If the promise rejects, do nothing.**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果 promise 拒绝，则不执行任何操作。**'
- en: '***4* Wait for all the promises to resolve (or reject).**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 等待所有 promise 解析（或拒绝）。**'
- en: '***5* Return all the resolved values.**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回所有解析值。**'
- en: 'Here you used an async function to take an array of promises, get all of their
    responses, and skip all of their rejections. You could use it for your photo gallery
    like so:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用了一个异步函数来处理一个 promise 数组，获取所有响应并跳过所有拒绝。你可以像这样在你的相册中使用它：
- en: '[PRE51]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Anytime you’re working with multiple promises, consider whether using an async
    function could simplify things.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候您在处理多个承诺时，考虑是否使用异步函数可以简化事情。
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 32.3**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查32.3**'
- en: '**[Q1:](kindle_split_047_split_003.xhtml#ch32qa6q0a1)**'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_047_split_003.xhtml#ch32qa6q0a1)**'
- en: ''
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a promise that’s being `await`ed in an async function rejects, what happens?
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在异步函数中`await`的承诺拒绝，会发生什么？
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 32.3 answer**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 32.3 答案**'
- en: '**[A1:](kindle_split_047_split_003.xhtml#ch32qa5q1)**'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_047_split_003.xhtml#ch32qa5q1)**'
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If uncaught, the promise returned from the async function will reject.
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果未捕获，异步函数返回的承诺将拒绝。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, you learned how async functions work and how to use them.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了异步函数的工作原理以及如何使用它们。
- en: An async function is syntactic sugar for a generator and a runner function.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数是生成器和运行函数的语法糖。
- en: An async function is declared by the keyword `async` before the keyword `function`.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数是通过在`function`关键字之前使用`async`关键字声明的。
- en: Inside of an async function, you can `await` a promise to get the value it resolves
    to.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步函数内部，您可以使用`await`等待一个承诺以获取其解析的值。
- en: An async function always returns a promise.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数总是返回一个承诺。
- en: The value returned from the async function will be resolved from the promise
    that the async function returns.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数返回的值将解析为异步函数返回的承诺。
- en: If a promise inside the async function rejects, the promise the async function
    returns will reject.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果异步函数内部的承诺拒绝，异步函数返回的承诺将拒绝。
- en: 'Let’s see if you got this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否明白了：
- en: '**[Q32.1](kindle_split_050_split_023.xhtml#app01qa23q0a1)**'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q32.1](kindle_split_050_split_023.xhtml#app01qa23q0a1)**'
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s my solution to the previous lesson’s exercise. This could be greatly
    simplified by converting it to an async function. Make it happen:'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是之前课程练习的解决方案。通过将其转换为异步函数可以大大简化。让它发生：
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Lesson 33\. Observables
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第33课\. 可观察对象
- en: After reading [lesson 33](kindle_split_048_split_000.xhtml#ch33), you will be
    able to
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第33课](kindle_split_048_split_000.xhtml#ch33)之后，您将能够
- en: Create your own observables
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的可观察对象
- en: Subscribe to observables
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅可观察对象
- en: Compose new observables with higher-order combinator functions
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶组合函数来构建新的可观察对象
- en: Create your own combinator functions for composing observables
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的组合函数来构建可观察对象
- en: '*Observables* are objects in which you can subscribe to streams of data. Observables
    are like promises, but whereas a promise only resolves or rejects once, an observable
    can keep emitting new values indefinitely. If you were to think of promises as
    an asynchronous datum that you can wrap around `setTimeout`, observables would
    be the asynchronous data that you can wrap around `setInterval`.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*可观察对象*是您可以订阅数据流的对象。可观察对象类似于承诺，但承诺只解析或拒绝一次，而可观察对象可以无限期地持续发出新值。如果您将承诺视为可以围绕`setTimeout`包装的异步数据，那么可观察对象将是可以围绕`setInterval`包装的异步数据。'
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to use observables today, at the time of this writing, you need to
    use one of the open source implementations. Currently zen-observable is the closest
    implementation of the spec: [https://github.com/zenparsing/zen-observable](https://github.com/zenparsing/zen-observable).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在今天使用可观察对象，在撰写本文时，您需要使用开源实现之一。目前，zen-observable 是最接近规范实现的：[https://github.com/zenparsing/zen-observable](https://github.com/zenparsing/zen-observable)。
- en: '|  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Websockets allow the front end to subscribe to events from the back end. With
    WebSockets, the server can push new values to the client as they become available.
    Without them, you would need the client to pull new items from the back end by
    continuously polling the server, asking if new data is available yet. With WebSockets,
    you could say that the client is observing from the server. Wouldn’t it be nice
    to be able to use this same push mechanism of sending new data to any observer?
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 允许前端订阅后端的事件。使用 WebSockets，服务器可以在新值可用时将其推送到客户端。没有它们，您需要客户端通过不断轮询服务器，询问是否有新数据可用来从后端拉取新项目。使用
    WebSockets，您可以说客户端正在从服务器进行观察。不是很好吗，能够使用这种相同的推送机制将新数据发送给任何观察者？
- en: '|  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 33.1\. Creating observables
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1\. 创建可观察对象
- en: 'Creating an observable is similar to creating a promise, in the sense that
    you invoke the constructor function with a callback. The callback that you give
    to the observable takes an *observer* as an argument that you send data to:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可观察对象类似于创建一个承诺，从某种意义上说，您通过一个回调函数调用构造函数。您给可观察对象提供的回调函数接受一个*观察者*作为参数，您将数据发送给它：
- en: '[PRE53]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'An observer is just any object with the methods `start`, `next`, `error`, and
    `complete`, all of which are optional:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一个观察者只是任何具有 `start`、`next`、`error` 和 `complete` 方法的对象，所有这些方法都是可选的：
- en: '`start`—A one-time notification when the observer subscribes to the observable'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`——当观察者订阅可观察对象时的一次性通知'
- en: '`next`—The method that sends the data that the observable is dispatching to
    the observer'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`——发送可观察对象向观察者发送的数据的方法'
- en: '`error`—Like `next()` but used for sending errors to the observer'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`——与 `next()` 类似，但用于向观察者发送错误'
- en: '`complete`—A one-time notification when the observable has finished'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete`——当可观察对象完成时的一次性通知'
- en: 'Let’s say, for example, you’re going to make a clock widget that always shows
    the current time. You could make an observable that continuously emits the current
    time every second:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你将要制作一个始终显示当前时间的时钟小部件。你可以创建一个可观察对象，每秒持续发出当前时间：
- en: '[PRE54]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Notifies the observer of the current time at one second intervals**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 以一秒间隔通知观察者当前时间**'
- en: 'You could then *subscribe* to this observable like so:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以这样 *订阅* 此可观察对象：
- en: '[PRE55]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is great, but what if you get to a point in your application where you
    no longer want to show the current time? Maybe the user closed the clock widget
    or navigated to a new section in the app that doesn’t need it. Currently, there’s
    no way to stop the `setInterval` from running.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但如果你在应用程序中到达一个不再需要显示当前时间的点怎么办？也许用户关闭了时钟小部件或导航到了应用程序中的新部分，那里不需要它。目前，没有停止
    `setInterval` 运行的方法。
- en: The callback that you pass to the `Observable` constructor can return a cleanup
    function that gets executed when the observable is unsubscribed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给 `Observable` 构造函数的回调函数可以返回一个清理函数，该函数在可观察对象取消订阅时执行。
- en: '[PRE56]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* This cleanup function will run when the observable is unsubscribed from.**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当可观察对象从订阅中取消时，此清理函数将运行。**'
- en: 'You can now successfully unsubscribe from the `currentTime$` observable and
    tell it to no longer run the interval:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以成功取消对 `currentTime$` 可观察对象的订阅，并告诉它不再运行间隔：
- en: '[PRE57]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Notice how you named the observable you created with a trailing `$`. This isn’t
    required, but it’s a common convention to signify that the variable ending with
    a `$` is an observable. The pronunciation of such a variable would be plural:
    you would refer to `currentTime$` as either “current times” or “current time observable.”'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你创建的可观察对象名称后面有一个尾随的 `$`。这不是必需的，但这是一个常见的约定，用来表示以 `$` 结尾的变量是一个可观察对象。此类变量的发音应该是复数：你会将
    `currentTime$` 称为“当前时间”或“当前时间可观察对象”。
- en: 'The `Observable` object also has a couple of convenience methods for creating
    observables: `Observable.of()` and `Observable.from()`. The former takes any number
    of arguments and creates an observable of those values. The latter takes an iterable
    and creates an observable from it:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 对象还有一些方便的方法用于创建可观察对象：`Observable.of()` 和 `Observable.from()`。前者接受任意数量的参数，并创建一个包含这些值的可观察对象。后者接受一个可迭代对象，并从中创建一个可观察对象：'
- en: '[PRE58]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This subscription will log the following five strings:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此订阅将记录以下五个字符串：
- en: '--- started getting values ---'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '--- 开始获取值 ---'
- en: '![](Images/s.jpg) next value 1'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![](Images/s.jpg) 下一个值 1'
- en: '![](Images/s.jpg) next value 2'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![](Images/s.jpg) 下一个值 2'
- en: '![](Images/s.jpg) next value 3'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![](Images/s.jpg) 下一个值 3'
- en: '--- done getting values ---'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '--- 完成获取值 ---'
- en: As you can see, when you create an observable via `Observable.from(iterable)`,
    it’s the equivalent of `Observble.of(...iterable)`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当你通过 `Observable.from(iterable)` 创建可观察对象时，它与 `Observble.of(...iterable)`
    等效。
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 33.1**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 33.1**'
- en: '**[Q1:](kindle_split_048_split_001.xhtml#ch33qa2q0a1)**'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_048_split_001.xhtml#ch33qa2q0a1)**'
- en: ''
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many values will be emitted from the following observables before they complete?
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下可观察对象完成之前，将发出多少个值？
- en: ''
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 33.1 answer**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 33.1 答案**'
- en: '**[A1:](kindle_split_048_split_001.xhtml#ch33qa1q1)**'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_048_split_001.xhtml#ch33qa1q1)**'
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3 (‘A’, ‘B’, ‘C’)
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 （‘A’，‘B’，‘C’）
- en: 2 (‘ABC’, ‘XYZ’)
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 （‘ABC’，‘XYZ’）
- en: '|  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 33.2\. Composing observables
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.2\. 组合可观察对象
- en: One of the coolest aspects of observables is that you can compose them using
    higher-order combinators to create new unique observables. This means that you
    can treat the stream of values that the observable emits as a list that you can
    run methods on such as `map` and `filter`. Think of the power of lodash^([[1](kindle_split_048_split_002.xhtml#ch33fn01)])
    applied to events.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象最酷的方面之一是你可以使用高阶组合子来组合它们，从而创建新的独特可观察对象。这意味着你可以将可观察对象发出的值流视为一个列表，你可以对其运行诸如
    `map` 和 `filter` 等方法。想想lodash^([[1](kindle_split_048_split_002.xhtml#ch33fn01)])应用于事件时的强大功能。
- en: ¹
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://lodash.com](https://lodash.com)'
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://lodash.com](https://lodash.com)'
- en: 'You’re going to use some combinators on your `currentTime$` observable. Right
    now, it’s emitting a new date object every second:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要在你的 `currentTime$` 可观察对象上使用一些组合函数。目前，它每秒发出一个新的日期对象：
- en: '[PRE60]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can map this stream of dates to a stream of date strings formatted to your
    desire:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个日期流映射到格式化成你想要的日期字符串流：
- en: '[PRE61]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now you have a stream of time strings:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个时间字符串流：
- en: '[PRE62]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice how you’re getting duplicate values; we would, in fact, get 60 duplicates
    every minute. Your clock widget wouldn’t need to be notified of the next time
    string until it changed, so you could apply another combinator:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你得到了重复的值；实际上，我们每分钟会得到 60 个重复值。你的时钟小部件不需要在下一个时间字符串改变时通知，因此你可以应用另一个组合函数：
- en: '[PRE63]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now you have a stream of unique time strings:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个唯一的时字符串流：
- en: '[PRE64]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Every time you apply a combinator function to an observable, you get back a
    new observable. The original observable is never changed.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你对一个可观察对象应用一个组合函数，你都会得到一个新的可观察对象。原始的可观察对象永远不会改变。
- en: The `Observable` spec doesn’t actually include any combinator functions, but
    it’s intended to be composed by using them. Libraries such as zen-observable and
    RxJS, however, include several combinator functions.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 规范实际上并没有包含任何组合函数，但它旨在通过使用它们来组合。然而，像 zen-observable 和 RxJS 这样的库包含了多个组合函数。'
- en: '|  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 33.2**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 33.2**'
- en: '**[Q1:](kindle_split_048_split_002.xhtml#ch33qa4q0a1)**'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_048_split_002.xhtml#ch33qa4q0a1)**'
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you apply the `map` combinator to the `number$` observable, how is the
    `number$` observable modified?
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你对 `number$` 可观察对象应用 `map` 组合函数时，`number$` 可观察对象是如何被修改的？
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 33.2 answer**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 33.2 答案**'
- en: '**[A1:](kindle_split_048_split_002.xhtml#ch33qa3q1)**'
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_048_split_002.xhtml#ch33qa3q1)**'
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `number$` observable isn’t modified at all. A new observable is created.
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`number$` 可观察对象根本没有被修改。创建了一个新的可观察对象。'
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 33.3\. Creating observable combinators
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.3. 创建可观察对象组合器
- en: 'You can probably find an open source solution for any combinator you may desire,
    but understanding how to create your own combinators should demystify what’s actually
    happening when you start composing them. Create a combinator for filtering values
    from an observable:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以找到任何你想要的组合函数的开源解决方案，但理解如何创建自己的组合函数应该会消除当你开始组合它们时实际发生的事情的神秘感。创建一个从可观察对象中过滤值的组合函数：
- en: '[PRE66]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Accept an observable and a function to test if values should be filtered.**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接受一个可观察对象和一个用于测试值是否应该被过滤的函数。**'
- en: '***2* Return a new observable.**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回一个新的可观察对象。**'
- en: '***3* Proxy values from the previous observable to the next observer if they
    pass the filter test.**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果通过过滤测试，则从上一个可观察对象代理值到下一个观察者。**'
- en: 'Here you have a function that takes an existing observable and a function to
    test if the values should be filtered out or not. Then you return an observable
    that subscribes to the existing observable. The new observable proxies values
    from the existing observable, but only if they pass the filtering test. You could
    use this function like so:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个函数，它接受一个现有的可观察对象和一个函数，用于测试值是否应该被过滤掉。然后你返回一个订阅现有可观察对象的新可观察对象。新的可观察对象代理现有可观察对象的值，但只有当它们通过过滤测试时。你可以这样使用这个函数：
- en: '[PRE67]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here you use the `filter` function you created to filter an observable of numbers
    to a new observable of only odd numbers:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用你创建的 `filter` 函数来过滤数字可观察对象，得到一个只包含奇数的新的可观察对象：
- en: '[PRE68]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Of course a more complete combinator function would also proxy `error` and `complete`.
    I omitted that for brevity.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个更完整的组合函数也会代理 `error` 和 `complete`。为了简洁起见，我省略了这一点。
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 33.3**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 33.3**'
- en: '**[Q1:](kindle_split_048_split_003.xhtml#ch33qa6q0a1)**'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_048_split_003.xhtml#ch33qa6q0a1)**'
- en: ''
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What type of operation would the following combinator function compose observables
    with?
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下组合函数函数将组合哪些类型的操作？
- en: ''
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 33.3 answer**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 33.3 答案**'
- en: '**[A1:](kindle_split_048_split_003.xhtml#ch33qa5q1)**'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_048_split_003.xhtml#ch33qa5q1)**'
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It will perform a *map* operation.
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它将执行一个 *map* 操作。
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned about the basics of observables.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了关于可观察对象的基础知识。
- en: You create a new observable by passing the constructor a callback that takes
    an observer.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通过传递给构造函数一个接受观察者的回调来创建一个新的可观察对象。
- en: An observer is an object with `start`, `next`, `error`, and `complete` methods.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者是一个具有 `start`、`next`、`error` 和 `complete` 方法的对象。
- en: Observables can be composed to create more specific observables by applying
    higher-order combinators.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过应用高阶组合子来组合可观察对象，以创建更具体的可观察对象。
- en: A combinator is a just a function that subscribes to an existing observable
    and returns a new observable
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合子只是一个订阅现有可观察对象并返回新可观察对象的函数
- en: 'Let’s see if you got this:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个：
- en: '**[Q33.1](kindle_split_050_split_024.xhtml#app01qa24q0a1)**'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q33.1](kindle_split_050_split_024.xhtml#app01qa24q0a1)**'
- en: ''
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a combinator function called `collect` that keeps track of all values
    that have been emitted by another observable and emits an array of all the values
    so far. Then create another combinator called `sum` which takes an observable
    that emits arrays of values and sums them. Then combine these combinators to compose
    a new observable over `Observable.of(1, 2, 3, 4)`. The final observable should
    emit the values 1, 3, 6, and 10.
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个名为 `collect` 的组合子函数，它跟踪另一个可观察对象发出的所有值，并发出到目前为止所有值的数组。然后创建另一个名为 `sum` 的组合子，它接受发出值数组的可观察对象并求和。然后组合这些组合子，在
    `Observable.of(1, 2, 3, 4)` 上创建一个新的可观察对象。最终的可观察对象应该发出值 1, 3, 6 和 10。
- en: 'Lesson 34\. Capstone: Canvas image gallery'
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第34课：项目：Canvas图像画廊
- en: In this capstone you’re going to build a canvas-based image gallery.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将构建一个基于 canvas 的图像画廊。
- en: Your image gallery will load random images from Unsplash^([[1](kindle_split_049_split_000.xhtml#ch34fn01)])
    and render them to an HTML canvas element using a fading transition. You’ll use
    several promises to achieve this. You’ll use a promise and an async function to
    fetch images. You’ll also use promises to orchestrate the transitions and delay
    between the images, as well as other wiring that will need to be done.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你的图像画廊将从 Unsplash 加载随机图像（^[[1](kindle_split_049_split_000.xhtml#ch34fn01)]），并使用淡入淡出过渡渲染到
    HTML canvas 元素。你将使用多个承诺来实现这一点。你将使用承诺和异步函数来获取图像。你还将使用承诺来编排过渡和图像之间的延迟，以及需要完成的其他连接。
- en: ¹
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://unsplash.com/license](https://unsplash.com/license)'
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://unsplash.com/license](https://unsplash.com/license)'
- en: '|  |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll start your project using the start folder included in the code accompanying
    this book. If at any time you get stuck, you can also check out the final folder
    with the completed code. The start folder is a project already set up to use Babel
    and Browserify (see unit 0); you just need to run `npm install` to get set up.
    If you haven’t read unit 0, you should do so before proceeding with this capstone.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用本书代码中包含的起始文件夹开始你的项目。如果你在某个时候遇到困难，你还可以查看包含完成代码的最终文件夹。起始文件夹是一个已经设置好使用 Babel
    和 Browserify 的项目（见单元 0）；你只需运行 `npm install` 来设置。如果你还没有阅读单元 0，你应该在继续这个项目之前先阅读它。
- en: There’s also an included `index.html` file, which is where the app will run.
    It already includes all the HTML and CSS it needs, so you just need to open it
    in a browser once you bundle your JavaScript files. The `src` folder is where
    you’ll put all your JavaScript files. The `dest` folder is where the bundled JavaScript
    file will go after you run `npm run build`. You’ll need to remember to run `npm
    run build` to compile your code anytime you make a change.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 还包含一个名为 `index.html` 的文件，这是应用程序运行的地方。它已经包含了所需的全部 HTML 和 CSS，所以你只需在将 JavaScript
    文件打包后，在浏览器中打开它即可。`src` 文件夹是放置所有 JavaScript 文件的地方。`dest` 文件夹是运行 `npm run build`
    后打包的 JavaScript 文件将存放的地方。你需要记住，每次你修改代码时，都要运行 `npm run build` 来编译你的代码。
- en: '|  |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 34.1\. Fetching images
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.1\. 获取图像
- en: 'Since you’re going to be making an image gallery, start by writing a function
    that will fetch an image. You could use the age-old method of setting an `src`
    property on an `Image` object:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将制作一个图像画廊，首先编写一个获取图像的函数。你可以使用古老的在 `Image` 对象上设置 `src` 属性的方法：
- en: '[PRE70]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'But instead use an async function and the new `fetch` API to load and create
    an `ImageBitmap` that you can render onto a canvas:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用异步函数和新的 `fetch` API 来加载和创建可以渲染到 canvas 上的 `ImageBitmap`：
- en: '[PRE71]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Wait for a promise that makes a request to the given URL.**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 等待一个承诺，向给定的 URL 发起请求。**'
- en: '***2* Wait for another promise that creates a data blob from the requested
    file.**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待另一个承诺，从请求的文件创建数据块。**'
- en: '***3* Return a final promise that creates an ImageBitmap from a data blob.**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回一个最终承诺，从数据块创建 ImageBitmap。**'
- en: 'Now you should be able to load an image from a URL and eventually get an `ImageBitmap`
    object. You don’t need to worry about any callbacks for success or error states
    because you’re using promises. Write a function that will load a random image:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够从 URL 加载图像，并最终获取一个 `ImageBitmap` 对象。您不需要担心任何成功或错误状态的回调，因为您正在使用 promises。编写一个函数来加载一张随机图像：
- en: '[PRE72]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This function hard-codes the URL [https://source.unsplash.com/random](https://source.unsplash.com/random)
    as a parameter to your previously created `fetchImage` function. The URL will
    be redirected to a random image from the Unsplash community of free images. That
    means every time you invoke this function, you’ll get back a promise that will
    eventually yield an `ImageBitmap` for a random image.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将 URL [https://source.unsplash.com/random](https://source.unsplash.com/random)
    作为参数硬编码到您之前创建的 `fetchImage` 函数中。该 URL 将重定向到 Unsplash 社区中的随机免费图像。这意味着每次您调用此函数时，您都会得到一个最终会生成随机
    `ImageBitmap` 的 promise。
- en: 'You can test this function out now if you want to:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试这个函数，现在就可以：
- en: '[PRE73]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now that you can fetch random images, let’s turn our attention to rendering
    them to a canvas.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以获取随机图像，让我们将注意力转向将它们渲染到画布上。
- en: 34.2\. Painting the images on the canvas
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.2\. 在画布上绘制图像
- en: 'The first thing you want to do is grab a reference to the canvas object that’s
    provided in your HTML file:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先想要做的是获取您 HTML 文件中提供的 canvas 对象的引用：
- en: '[PRE74]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Get a reference to your canvas HTML element.**'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取您的 canvas HTML 元素的引用。**'
- en: '***2* Get a 2D context that you can use to start painting.**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取一个 2D 上下文，您可以使用它开始绘制。**'
- en: If you happen to have peeked into the game framework code provided in the previous
    capstone, this code should look familiar. Whenever you’re painting on an HTML
    canvas, you must first get either a 2D or a 3D context to paint on. Since images
    are two-dimensional objects, a 2D context will work just fine.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您偶然浏览了之前 capstone 中提供的游戏框架代码，这段代码应该看起来很熟悉。每当您在 HTML 画布上绘制时，您必须首先获取一个 2D 或
    3D 上下文来绘制。由于图像是二维对象，2D 上下文将完全适用。
- en: 'The 2D context happens to have a method called `drawImage` that takes an `ImageBitmap`
    and paints it to the canvas:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 2D 上下文恰好有一个名为 `drawImage` 的方法，它接受一个 `ImageBitmap` 并将其绘制到画布上：
- en: '[PRE75]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Accept an ImageBitmap as a parameter.**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接受一个 ImageBitmap 作为参数。**'
- en: '***2* Paint the ImageBitmap onto the canvas.**'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 ImageBitmap 绘制到画布上。**'
- en: 'Notice that the `drawImage` takes an additional eight parameters after the
    `ImageBitmap`. These parameters are as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`drawImage` 在 `ImageBitmap` 之后还接受另外八个参数。这些参数如下：
- en: Source x
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源 x
- en: Source y
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源 y
- en: Source width
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源宽度
- en: Source height
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源高度
- en: Destination x
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标 x
- en: Destination y
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标 y
- en: Destination width
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标宽度
- en: Destination height
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标高度
- en: You can use the source properties to define a section of the image to paint.
    And you can use the destination properties to specify a section of the canvas
    to paint to. You specified that you wanted to paint the entire image across the
    entirety of the canvas.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用源属性来定义要绘制的图像的一部分。您还可以使用目标属性来指定要绘制到画布上的部分。您指定了要绘制整个图像到画布的整个区域。
- en: 'There’s one more thing you need to add to this function before you’re done.
    You’re going to be transitioning or *fading* in new images. In order to achieve
    this effect, you’re going to need to first paint the image using transparency
    or *alpha*, then over time repaint the image using slightly more alpha to create
    a fading-in effect. Most of the logic for figuring out how much alpha to apply
    will happen in another function. Your draw function just needs to be able to take
    an `alpha` property and apply it to the image you’re painting:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此函数之前，您还需要添加一个功能。您将过渡或 *渐变* 新图像。为了实现这种效果，您需要首先使用透明度或 *alpha* 绘制图像，然后随着时间的推移，使用稍微更多的
    alpha 重新绘制图像以创建渐入效果。确定应用多少 alpha 的逻辑的大部分将发生在另一个函数中。您的绘制函数只需要能够接受一个 `alpha` 属性并将其应用于您正在绘制的图像：
- en: '[PRE76]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `globalAlpha` property on the canvas context will apply to anything that’s
    getting painted, so by setting this property before drawing the image, you can
    effectively apply an alpha channel to the image. Cool.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 画布上下文中的 `globalAlpha` 属性将应用于所有被绘制的元素，因此，在绘制图像之前设置此属性，您可以有效地将 alpha 通道应用于图像。很酷。
- en: 'Now write a function that takes an image and animates the image fading in.
    You’ll use your `draw` function to do the actual drawing. We just need to continue
    to draw a more opaque version of the image over time:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写一个函数，它接受一个图像并动画化图像的淡入。你将使用你的`draw`函数来进行实际的绘制。我们只需要随着时间的推移继续绘制图像的更不透明版本：
- en: '[PRE77]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* If the alpha is 99% or more opaque, you’re finished transitioning.**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果alpha达到99%或更多不透明度，你已完成过渡。**'
- en: '***2* Otherwise increase the alpha.**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 否则增加alpha。**'
- en: '***3* Then fadeIn the image with the new alpha on the next animation frame.**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 然后在下一个动画帧上使用新的alpha值淡入图像。**'
- en: 'This `fadeIn` function takes an image and an alpha and uses `requestAnimationFrame`
    to recursively increase the alpha and redraw the image. Once you’re at 99% or
    more alpha, you’re finished. But what should you do at that point? Traditionally
    this would be the place where you invoke a callback signifying that your animation
    has completed. But remember, anything that can use a callback can be made to use
    a promise. In fact, you can wrap this whole thing in a promise and resolve it
    when the animation is complete:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`fadeIn`函数接受一个图像和一个alpha值，并使用`requestAnimationFrame`递归地增加alpha并重新绘制图像。一旦alpha达到99%或更多，你就完成了。但在这个时候你应该做什么？传统上，这将是调用回调函数以表示动画已完成的地方。但请记住，任何可以使用回调的东西都可以被改造成使用承诺。实际上，你可以将整个操作包裹在一个承诺中，并在动画完成后解决它：
- en: '[PRE78]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* The fade function will return a promise that resolves when the fading
    transition has finished.**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 淡入函数将在淡入转换完成后解决承诺。**'
- en: '***2* Define a fadeIn function that captures both the image and resolve variables
    in a closure.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个fadeIn函数，该函数在闭包中捕获图像和解决变量。**'
- en: '***3* Draw the image at the given alpha.**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在给定的alpha值下绘制图像。**'
- en: '***4* If alpha is over .99, resolve the promise.**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果alpha超过.99，解决承诺。**'
- en: '***5* If alpha hasn’t reached .99, increase alpha slightly and schedule another
    fadeIn.**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果alpha没有达到.99，稍微增加alpha并安排另一个fadeIn。**'
- en: '***6* Start the fadeIn process with a low alpha.**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 以低alpha值开始fadeIn过程。**'
- en: Here you wrapped your `fadeIn` function into another function that returns a
    promise. Now the `fadeIn` function resolves the promise when the animation is
    complete. Because the image never changes, you no longer need to pass it to the
    `fadeIn` function, as it will maintain the reference in a closure. You also don’t
    need the outer `fade` function to take an `alpha` parameter, because you always
    want to start at .1 and always want to end at .99.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将`fadeIn`函数包裹在一个返回承诺的函数中。现在，`fadeIn`函数在动画完成后解决承诺。因为图像从未改变，所以你不再需要将图像传递给`fadeIn`函数，因为它将在闭包中保持引用。你也不再需要外部的`fade`函数接受一个`alpha`参数，因为你始终想从.1开始，并始终想以.99结束。
- en: 'You should now be able to fetch a random image and paint it to the canvas like
    this:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够像这样获取一个随机图像并将其绘制到画布上：
- en: '[PRE79]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This will fetch a random image then paint it to the canvas. The image will even
    fade in, not jarringly appear out of nowhere. Try it yourself!
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取一个随机图像并将其绘制到画布上。图像甚至可以淡入，而不是突然出现。试试看！
- en: 34.3\. Repeating the process
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.3. 重复过程
- en: 'Now you can fetch a random image and fade it in onto the canvas, so you just
    need a way to orchestrate doing this over and over on a continuous loop. But you
    don’t want to fade in an image immediately after the last; you want to wait a
    second to allow the user to view the image before transitioning to the next. Start
    by writing a function that resolves a promise after a given time period:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以获取一个随机图像并将其淡入画布，所以你只需要一种方法来连续不断地重复执行这个过程。但你不想在最后一个图像之后立即淡入图像；你想要等待一秒钟，以便用户在过渡到下一个图像之前查看图像。首先编写一个函数，在给定的时间段后解决一个承诺：
- en: '[PRE80]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This `wait` function takes a parameter that specifies how many milliseconds
    to wait, and returns a promise that resolves in that amount of time. Internally
    you tell `setTimeout` to resolve the promise at the specified millisecond count.
    Now create a function called `pause` that’s hard-coded to wait one and a half
    seconds:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`wait`函数接受一个参数，指定要等待的毫秒数，并返回一个在指定时间内解决的承诺。内部你告诉`setTimeout`在指定的毫秒数后解决承诺。现在创建一个名为`pause`的函数，硬编码为等待一秒半：
- en: '[PRE81]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now you can use this pause function like so:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以这样使用这个暂停函数：
- en: '[PRE82]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'More importantly, you can now create a continuous loop:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，你现在可以创建一个连续循环：
- en: '[PRE83]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: I love the eloquence here—the function reads exactly how it behaves. First you
    *get a random image*, then you *fade* that image in, then you *pause*, and then
    you move on to the *next image* and start the process over again.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这里的优雅——函数的读取方式正好反映了它的行为。首先你*获取一个随机图像*，然后*淡入*该图像，然后*暂停*，然后转到*下一个图像*并重新开始整个过程。
- en: 'At this point you can invoke the `nextImage` function and watch your marvelous
    gallery fade in random images every couple of seconds. But what happens if one
    of the images fails to load? In its current state, that would bring the entire
    thing to a halt. But you can easily fix that:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以调用`nextImage`函数，并观察你的奇妙画廊每隔几秒钟淡入随机图像。但如果其中一张图像加载失败怎么办？在其当前状态下，这会导致整个系统停止。但你可以轻松解决这个问题：
- en: '[PRE84]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Do you notice what you did here? Your `start` function kicks off the whole animation
    by invoking `nextImage`. As long as nothing goes wrong, the `nextImage` will continue
    to run, loading random images and fading them in. But if something does go wrong—for
    example an image fails to load—you’ll `catch` that and restart the whole thing
    by calling `start` again and kicking everything off. This, of course, will be
    seamless to the user, as the most recently loaded image will still be displayed
    until the next one loads. Isn’t that neat?
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到你在这里做了什么吗？你的`start`函数通过调用`nextImage`启动整个动画。只要没有出错，`nextImage`将继续运行，加载随机图像并淡入。但如果出了问题——例如图像加载失败——你会`catch`到它，并通过再次调用`start`并重新启动一切来重新开始整个过程。当然，这对用户来说将是无缝的，因为最新加载的图像仍然会显示，直到下一个加载。这不是很酷吗？
- en: 'Again, at this point you could simply invoke `start()` and be done. And for
    all intents and purposes, this would work just fine. Try it yourself. But you
    did create a small memory leak. Let’s take another look at that eloquent function
    that loops over random image animations:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在这个点上，你可以简单地调用`start()`并完成。从所有目的来看，这会工作得很好。试试看。但你确实创建了一个小的内存泄漏。让我们再次看看那个优雅的函数，它循环遍历随机图像动画：
- en: '[PRE85]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Every time this runs, it adds to the existing chain of promises. It has to in
    order to bubble back up the `catch` you defined in the `start` function. This
    means that your promise chain will grow longer and longer until eventually you
    run out of memory and crash. This would take a long time, because you’re only
    increasing the length of the promise chain at ~2 second intervals, but you need
    to fix this problem nevertheless.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行时，它都会添加到现有的承诺链中。它必须这样做，以便将`start`函数中定义的`catch`冒泡回上。这意味着您的承诺链会越来越长，直到最终耗尽内存并崩溃。这需要很长时间，因为您仅在约2秒的间隔内增加承诺链的长度，但您仍然需要解决这个问题。
- en: 'Instead of adding to the same promise chain over and over again, you can create
    a new promise chain every time. But how can this bubble back up to your `catch`?
    Simple: you’ll wrap the whole thing in another promise, and if any of your internal
    promise chains reject, reject the outer promise:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一次又一次地添加到同一个承诺链中，你可以在每次创建一个新的承诺链。但如何将这个冒泡回你的`catch`？简单：你将整个东西包裹在另一个承诺中，如果你的内部承诺链中的任何一个拒绝，拒绝外部承诺：
- en: '[PRE86]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Take an initial function that will be repeating.**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 选择一个将要重复的初始函数。**'
- en: '***2* Return a new promise.**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 返回一个新的承诺。**'
- en: '***3* Create a new function that will invoke your passed-in function.**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 创建一个新的函数，该函数将调用传入的函数。**'
- en: '***4* When the passed-in function resolves, invoke your go function again.**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4* 当传入的函数解决时，再次调用你的go函数。**'
- en: '***5* If your passed in function rejects, reject the outer promise that you
    returned.**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5* 如果传入的函数拒绝，拒绝你返回的外部承诺。**'
- en: '***6* Start the process.**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6* 开始过程。**'
- en: This `repeat` function is a proxy to another function. The function it proxies
    is expected to return a promise, and thus the `repeat` function also needs to
    return a promise. Internally, the `repeat` function will continuously re-invoke
    its proxied function every time it resolves. But it won’t add onto a single promise
    chain. Instead, if any of them reject, it will manually propagate the rejection
    up to the promise it returned. This means no more memory leak.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`repeat`函数是另一个函数的代理。它代理的函数预期返回一个承诺，因此`repeat`函数也需要返回一个承诺。内部，每次`repeat`函数解决时，它都会连续重新调用其代理函数。但它不会添加到单个承诺链中。相反，如果其中任何一个拒绝，它将手动将拒绝传播到它返回的承诺。这意味着不会有更多的内存泄漏。
- en: '[Figure 34.1](kindle_split_049_split_003.xhtml#ch34fig01) shows two visualizations.
    The first one shows how your `nextImage` function uses recursive promises. The
    chain will continue to get longer and longer, because each promise is kept in
    memory so that the errors or resolved values will be able to bubble all the way
    up to the root promise that was returned. Eventually this chain will consume too
    much memory and crash. The second visualization shows how you can have a wrapping
    promise that repeats (nonrecursively) the same promise chain, but instead of linking
    them together, they’re each linked to the outer promise (but only in the case
    of a failure). This means that once each inner promise resolves, there will be
    no need to keep them in memory because they’re only connected to the outer promise
    on a rejection. So they won’t continue to stack up and cause a memory leak.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[图34.1](kindle_split_049_split_003.xhtml#ch34fig01) 展示了两种可视化。第一个展示了你的`nextImage`函数如何使用递归承诺。链将不断变长，因为每个承诺都保留在内存中，以便错误或已解析的值能够一路冒泡到返回的根承诺。最终，这个链将消耗太多内存并崩溃。第二个可视化展示了你可以有一个包装承诺，它重复（非递归地）相同的承诺链，但它们不是相互链接，而是每个都链接到外部承诺（但仅在失败的情况下）。这意味着一旦每个内部承诺解析完成，就没有必要在内存中保留它们，因为它们仅在拒绝时与外部承诺连接。因此，它们不会继续堆叠并导致内存泄漏。'
- en: Figure 34.1\. Recursive versus repeating promises
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图34.1\. 递归与重复承诺的比较
- en: '![](Images/34fig01_alt.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/34fig01_alt.jpg)'
- en: 'Since the `repeat` function is now handling the repetition, you no longer need
    to make your `nextImage` function continuous. Modify it like this:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`repeat`函数现在负责重复操作，你不再需要让你的`nextImage`函数持续运行。修改它如下：
- en: '[PRE87]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now you just need to wrap it in a `repeat` in the `start` function:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要在`start`函数中将其包裹在`repeat`中：
- en: '[PRE88]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, you can call start without any caveats:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以无顾虑地调用`start`：
- en: '[PRE89]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You should now have an image gallery that paints random images with transitions,
    is self-healing, and will run forever without any memory leaks. And you achieved
    this without the help of any library, writing well under 100 lines of code!
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经拥有了一个图像库，它可以随机显示带有过渡效果的图像，具有自我修复功能，并且可以无限期运行而不会出现内存泄漏。而你实现这一切，无需任何库的帮助，代码行数不超过100行！
- en: Summary
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final capstone, you created an image gallery that loads random images
    and transitions them onto a canvas. You made use of several different promises
    and an async function to achieve this. By using small promises and wiring them
    together, you created an eloquent solution to a complex problem, using easy-to-maintain,
    self-documenting code.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的里程碑中，你创建了一个图像库，它可以加载随机图像并将它们过渡到画布上。你利用了几个不同的承诺和一个异步函数来实现这一点。通过使用小的承诺并将它们连接起来，你创造了一个优雅的解决方案，用于解决复杂问题，使用了易于维护、自我文档化的代码。
