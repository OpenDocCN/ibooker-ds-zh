- en: appendix B. Bootstrapping Microservices cheat sheet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 微服务引导速查表
- en: This appendix summarizes the most useful commands you learned throughout this
    book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录总结了您在本书中学到的最有用的命令。
- en: B.1 Node.js commands
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 Node.js 命令
- en: See chapter 2 to learn how to install and use Node.js to create microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第 2 章了解如何安装和使用 Node.js 创建微服务。
- en: Table B.1 Node.js commands *(continued)*
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.1 Node.js 命令（续）
- en: '| Command | Description |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `node --version` | Checks that Node.js is installed and prints the version
    number. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `node --version` | 检查 Node.js 是否已安装并打印版本号。|'
- en: '| `npm init -y` | Creates a default Node.js project. This creates a stub for
    our package .json, the file that tracks metadata and dependencies for our Node.js
    project. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `npm init -y` | 创建默认的 Node.js 项目。这会为我们的 package.json 创建一个占位符，该文件跟踪 Node.js
    项目的元数据和依赖项。|'
- en: '| `npm install --save`➥ `<package-name>` | Installs an npm package. There are
    many other packages available on npm. You can install any by inserting a specific
    package name. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `npm install --save`➥ `<package-name>` | 安装 npm 包。在 npm 上还有许多其他包可用。您可以通过插入特定的包名称来安装任何包。|'
- en: '| `npm install` | Installs all dependencies for a Node.js project. This includes
    all the packages that were previously recorded in package.json. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `npm install` | 安装 Node.js 项目的所有依赖项。这包括所有之前记录在 package.json 中的包。|'
- en: '| `node <script-file>` | Runs a Node.js script file. We just invoke the `node`
    command and give it the name of our script file as an argument. You can call your
    script main.js or server.js if you want, but it’s probably best to stick to the
    convention and just call it index.js. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `node <script-file>` | 运行 Node.js 脚本文件。我们只需调用 `node` 命令，并将脚本文件名作为参数传递。如果您想将其命名为
    main.js 或 server.js，也可以，但最好遵守约定，只将其命名为 index.js。|'
- en: '| `npm start` | The conventional npm script for starting a Node.js application,
    regardless of what name the main script file has or what command-line parameters
    it expects.Typically this just translates into node index.js in the package.json
    file, but it all depends on the author of the project and how they have set it
    up.The nice thing is that no matter how a particular project is structured, you
    only have to remember `npm start`. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `npm start` | 无论是主脚本文件叫什么名字，还是它期望的命令行参数是什么，`npm start` 都是启动 Node.js 应用的传统
    npm 脚本。通常这只是在 package.json 文件中转换为 node index.js，但它完全取决于项目的作者以及他们如何设置。好处是，无论特定项目结构如何，您只需记住
    `npm start`。|'
- en: '| `npm run start:dev` | My personal convention for starting a Node.js project
    in development. I add this to the scripts in package.json, and typically, it runs
    something like nodemon to enable live reload of your code as you work with it.
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `npm run start:dev` | 我启动开发中 Node.js 项目的个人约定。我将此添加到 package.json 中的脚本中，通常它运行类似
    nodemon 的东西，以便在您与代码一起工作时启用实时重载。|'
- en: B.2 Docker commands
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 Docker 命令
- en: See chapter 3 to learn how to package, publish, and run microservices using
    Docker.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第 3 章了解如何使用 Docker 打包、发布和运行微服务。
- en: Table B.2 Docker commands *(continued)*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.2 Docker 命令（续）
- en: '| Command | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `docker --version` | Checks that Docker is installed and prints the version
    number. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `docker --version` | 检查 Docker 是否已安装并打印版本号。|'
- en: '| `docker container list` | Lists running containers. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `docker container list` | 列出正在运行的容器。|'
- en: '| `docker ps` | Lists all containers (running and stopped). |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `docker ps` | 列出所有容器（正在运行和已停止的）。|'
- en: '| `docker image list` | Lists local images. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `docker image list` | 列出本地镜像。|'
- en: '| `docker build -t <tag> --file`➥ `<docker-file> .` | Builds an image from
    assets in the current directory according to the instructions in `docker-file`.
    The `-t` argument tags the image with a name you specify. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `docker build -t <tag> --file`➥ `<docker-file> .` | 根据当前目录中 `docker-file`
    中的说明从资产构建一个镜像。`-t` 参数使用您指定的名称标记镜像。|'
- en: '| `docker run -d -p`➥ `<host-port>:<container-port>`➥ `<tag>` | Instantiates
    a container from an image. If the image isn’t available locally, you can pull
    it from a remote registry (assuming the tag specifies the URL of the registry).The
    `-d` argument runs the container in detached mode; it won’t be bound to the terminal,
    and you won’t see the output. Omit this argument to see output directly, but note
    that this also locks up your terminal.The `-p` argument allows you to bind a port
    on the host to a port in the container. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `docker run -d -p`➥ `<host-port>:<container-port>`➥ `<tag>` | 从镜像实例化一个容器。如果镜像在本地不可用，您可以从远程仓库拉取它（假设标签指定了仓库的
    URL）。`-d` 参数以分离模式运行容器；它不会绑定到终端，您将看不到输出。省略此参数可以直接看到输出，但请注意，这也会锁定您的终端。`-p` 参数允许您将主机上的端口绑定到容器中的端口。
    |'
- en: '| `docker logs <container-id>` | Retrieves output from a particular container.
    You need to issue this command to see the output when running a container in detached
    mode. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `docker logs <container-id>` | 从特定容器检索输出。您需要发出此命令才能在分离模式下运行容器时看到输出。 |'
- en: '| `docker login <url>`➥ `--username <username>`➥ `--password <password>` |
    Authenticates with your private Docker registry so that you can run other commands
    against it. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `docker login <url>`➥ `--username <username>`➥ `--password <password>` |
    使用您的私有 Docker 仓库进行身份验证，以便您可以对其运行其他命令。 |'
- en: '| `docker tag <existing-tag>`➥ `<new-tag>` | Adds a new tag to an existing
    image. To push an image to your private container registry, you must first tag
    it with the URL of your registry. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `docker tag <existing-tag>`➥ `<new-tag>` | 为现有镜像添加新标签。要将镜像推送到您的私有容器仓库，您必须首先使用您仓库的
    URL 标记它。 |'
- en: '| `docker push <tag>` | Pushes an appropriately tagged image to your private
    Docker registry. The image should be tagged with the URL of your registry. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `docker push <tag>` | 将带有适当标签的镜像推送到您的私有 Docker 仓库。镜像应带有您仓库的 URL。 |'
- en: '| `docker kill <container-id>` | Stops a particular container locally. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `docker kill <container-id>` | 在本地停止特定容器。 |'
- en: '| `docker rm <container-id>` | Removes a particular container locally (it must
    be stopped first). |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `docker rm <container-id>` | 在本地删除特定容器（必须先停止）。 |'
- en: '| `docker rmi <image-id>`➥ `--force` | Removes a particular image locally (any
    containers must be removed first). The `--force` argument removes images even
    when these have been tagged multiple times. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `docker rmi <image-id>`➥ `--force` | 在本地删除特定镜像（必须先删除任何容器）。`--force` 参数即使在镜像被多次标记的情况下也会删除镜像。
    |'
- en: B.4 Docker Compose commands
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 Docker Compose 命令
- en: See chapters 4 and 5 to learn how to use Docker Compose to simulate a microservices
    application on your development workstation (or personal computer) for development
    and testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 参见第 4 章和第 5 章，了解如何使用 Docker Compose 在您的开发工作站（或个人电脑）上模拟微服务应用程序进行开发和测试。
- en: Table B.3 Docker Compose commands
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.3 Docker Compose 命令
- en: '| Command | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `docker-compose --version` | Checks that Docker Compose is installed and
    prints the version number. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose --version` | 检查 Docker Compose 是否已安装并打印版本号。 |'
- en: '| `docker-compose up --build` | Builds and instantiates an application composed
    of multiple containers as defined by the Docker Compose file (docker-compose .yaml)
    in the current working directory. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose up --build` | 根据当前工作目录中定义的 Docker Compose 文件（docker-compose
    .yaml）构建并实例化由多个容器组成的应用程序。 |'
- en: '| `docker-compose ps` | Lists running containers that are part of the application
    specified by the Docker Compose file. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose ps` | 列出由 Docker Compose 文件指定的应用程序中的运行容器。 |'
- en: '| `docker-compose stop` | Stops all containers in the application but persists
    the stopped containers for inspection. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose stop` | 停止应用程序中的所有容器，但保留已停止的容器以供检查。 |'
- en: '| `docker-compose down` | Stops and destroys the application, leaving the development
    workstation in a clean state. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose down` | 停止并销毁应用程序，使开发工作站处于干净状态。 |'
- en: Terraform commands
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 命令
- en: See chapters 6 and 7 to learn how to implement infrastructure as code via Terraform
    to create a Kubernetes cluster and deploy your microservices to it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参见第 6 章和第 7 章，了解如何通过 Terraform 实现基础设施即代码，以创建 Kubernetes 集群并将您的微服务部署到其中。
- en: Table B.4 Terraform commands
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.4 Terraform 命令
- en: '| Command | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `terraform init` | Initializes a Terraform project and downloads the provider
    plugins. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `terraform init` | 初始化 Terraform 项目并下载提供者插件。 |'
- en: '| `terraform apply`➥ `-auto-approve` | Executes Terraform code files in the
    working directory to incrementally apply changes to your infrastructure. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `terraform apply`➥ `-auto-approve` | 在工作目录中执行 Terraform 代码文件，以增量方式应用更改到您的基础设施。
    |'
- en: '| `terraform destroy` | Destroys all infrastructure that was created by the
    Terraform project. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `terraform destroy` | 销毁 Terraform 项目创建的所有基础设施。 |'
- en: B.5 Testing commands
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.5 测试命令
- en: See chapter 8 to learn about automated testing for microservices with Jest and
    Cypress.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅第 8 章了解使用 Jest 和 Cypress 对微服务进行自动化测试的内容。
- en: Table B.5 Testing commands
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.5 测试命令
- en: '| Command | Description |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `npx jest --init` | Initializes the Jest configuration file. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest --init` | 初始化 Jest 配置文件。 |'
- en: '| `npx jest` | Runs tests under Jest |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest` | 在 Jest 下运行测试 |'
- en: '| `npx jest --watch` | Runs tests with live reload enabled to rerun tests when
    code has changed. Jest uses Git to know which files have changed and should be
    considered. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest --watch` | 在启用实时重新加载的情况下运行测试，当代码更改时重新运行测试。Jest 使用 Git 来了解哪些文件已更改，应予以考虑。
    |'
- en: '| `npx jest --watchAll` | As previously, except it monitors all files for changes
    and not just those that are reported changed by Git. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest --watchAll` | 如前所述，但它监视所有文件以更改，而不仅仅是 Git 报告已更改的文件。 |'
- en: '| `npx cypress open` | Opens the Cypress UI so that you can run tests. Live
    reload works out of the box. You can update your code, and the tests rerun automatically.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `npx cypress open` | 打开 Cypress UI，以便您可以运行测试。实时重新加载默认启用。您可以更新您的代码，测试将自动重新运行。
    |'
- en: '| `npx cypress run` | Executes Cypress tests with Cypress running in headless
    mode. This lets you test with Cypress from the command line (or CD pipeline) without
    having to display the UI. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `npx cypress run` | 在无头模式下运行 Cypress 测试。这允许您从命令行（或 CD 管道）测试 Cypress，而无需显示
    UI。 |'
- en: '| `npm test` | The npm script convention for running tests. This can run Jest
    or Cypress (or even both) depending on how you configured your package.json file.This
    is the command you should run in your CD pipeline to execute your test suite.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `npm test` | 运行测试的 npm 脚本约定。这可以运行 Jest 或 Cypress（甚至两者都可以），具体取决于您如何配置您的 package.json
    文件。这是您应该在您的持续集成（CD）管道中运行的命令，以执行测试套件。 |'
- en: '| `npm run test:watch` | This is my personal convention for running tests in
    live reload mode. You need to configure this script in your package.json file
    to use it. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `npm run test:watch` | 这是我在实时重新加载模式下运行测试的个人约定。您需要配置此脚本在您的 package.json 文件中才能使用它。
    |'
