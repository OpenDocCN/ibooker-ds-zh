- en: 13 More with Gini coefficients and Lorenz curves
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 使用基尼系数和洛伦兹曲线的更多内容
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working (again) with Gini coefficients
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （再次）使用基尼系数
- en: Creating alternative Lorenz curves
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建替代洛伦兹曲线
- en: Running significance tests (t-tests and F-tests)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行显著性检验（t检验和F检验）
- en: Running other effect size tests (aside from Cohen’s d)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行其他效应量检验（除了Cohen’s d）
- en: Writing `for` loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`for`循环
- en: Writing user-defined functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写用户自定义函数
- en: 'It’s true that we’re going to again compute Gini coefficients, plot inequality
    by drawing Lorenz curves, perform more significance testing, and conduct additional
    effect size tests to complement our t-tests—but there’s a lot of new material
    packed into this chapter too:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们将再次计算基尼系数，通过绘制洛伦兹曲线来描绘不平等，进行更多的显著性检验，以及进行额外的效应量检验以补充我们的t检验——但本章也包含了大量新的内容：
- en: We’ll demonstrate how to intelligently plot multiple Lorenz curves with the
    least amount of code. You’ll learn how to plot two Lorenz curves in the same plot
    to compare two Gini coefficients in one object rather than two.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将演示如何用最少的代码智能地绘制多个洛伦兹曲线。你将学习如何在同一张图上绘制两条洛伦兹曲线，以比较一个对象中的两个基尼系数，而不是两个。
- en: Furthermore, we’ll demonstrate how to create a simple `for` loop as an alternative
    to writing repeatable lines of code and then demonstrate how to apply what we’ve
    learned by drawing four Lorenz curves with one short chunk of code.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们将演示如何创建一个简单的`for`循环，作为编写可重复代码行的替代方案，然后通过用一段简短的代码绘制四条洛伦兹曲线来展示我们所学的内容。
- en: Because we’re demonstrating how to create a `for` loop, we’ll show how you can
    create your own function just in case R doesn’t already have a function for what
    you need. We’ll first demonstrate how to create a pair of simple functions and
    then provide further instruction on creating a function that can estimate a Gini
    coefficient.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们将演示如何创建`for`循环，所以我们将展示如果你需要的R还没有相应的函数，你可以如何创建自己的函数。我们将首先演示如何创建一对简单的函数，然后提供创建可以估计基尼系数的函数的进一步指导。
- en: In previous chapters, including chapter 12, we’ve conducted Cohen’s d effect
    size tests to quantitatively and qualitatively measure the statistical relationship
    between two variables on a numeric scale. There are actually other effect size
    tests, above and beyond Cohen’s d, that do the same thing. We’ll demonstrate how
    to run those tests and then discuss which tests are best under which circumstances.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的章节中，包括第12章，我们已经进行了Cohen’s d效应量测试，以定量和定性测量两个变量在数值尺度上的统计关系。实际上，还有其他效应量测试，除了Cohen’s
    d之外，也能做同样的事情。我们将演示如何运行这些测试，然后讨论在什么情况下哪种测试最好。
- en: Finally, we’ll demonstrate how to run an F-test, which is yet another statistical
    test used to compare the variances between two or more groups. An F-test actually
    evaluates whether the ratio of two variances is statistically significant or just
    the result of chance. We’ll briefly discuss how and when an F-test best fits into
    your analysis.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将演示如何运行F检验，这是一种用于比较两个或更多组方差的另一种统计检验。F检验实际上评估的是两个方差比率的统计显著性，或者仅仅是偶然的结果。我们将简要讨论F检验何时以及如何最适合你的分析。
- en: Along the way, we’ll compute Gini coefficients on the distribution of win shares,
    the player-level advanced statistic that was at the heart of our analysis in chapters
    2 and 3\. While Gini coefficients have mostly been used to measure inequality
    in income or wealth, they can actually be used to measure any sort of inequality,
    as we demonstrated in the prior chapter. Our purpose in this chapter is to determine
    whether Gini coefficients on win share distributions are linked to winning or
    losing and if any variances are statistically significant. Our null hypothesis
    is that Gini coefficients, regardless of whether they are low or high or somewhere
    in between, have no effect on winning. However, if player salaries are truly aligned
    with productivity, we shouldn’t be surprised to see results similar to those from
    chapter 12, but let’s find out one way or the other. We’ll start by loading our
    required packages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将计算胜利份额分布的基尼系数，这是我们在第2章和第3章分析的核心球员级高级统计指标。虽然基尼系数主要用于衡量收入或财富的不平等，但实际上可以用来衡量任何类型的不平等，正如我们在上一章所展示的。在本章中，我们的目的是确定胜利份额分布的基尼系数是否与胜负有关，以及是否有任何方差具有统计学意义。我们的零假设是，无论基尼系数是低、高还是介于两者之间，都不会对胜负产生影响。然而，如果球员的薪水确实与生产力相匹配，我们不应该对看到与第12章类似的结果感到惊讶，但让我们找出一种或另一种方式。我们将首先加载我们所需的包。
- en: 13.1 Loading packages
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 加载包
- en: 'The same set of packages we loaded and used in the previous chapter—`tidyverse`,
    `sqldf`, `ineq`, `gglorenz`, `scales`, and `effsize`—is again required, along
    with two other packages, `effectsize` and `car`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中加载并使用的相同包集——`tidyverse`、`sqldf`、`ineq`、`gglorenz`、`scales`和`effsize`——再次是必需的，另外还需要两个包，`effectsize`和`car`：
- en: In prior chapters, including chapter 12, we performed one type of effect size
    test, Cohen’s d, by way of the `effsize` package. In this chapter, we’ll again
    compute Cohen’s d estimates through the `effsize` package, and then we’ll perform
    other effect size testing through the `effectsize` package.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的章节中，包括第12章，我们通过`effsize`包执行了一种类型的效果量测试，即Cohen's d。在本章中，我们再次将通过`effsize`包计算Cohen's
    d估计值，然后我们将通过`effectsize`包执行其他效果量测试。
- en: In chapter 5, we called the `vif()` function from the `car` package to check
    for multicollinearity in our multiple linear regressions; here, we’ll load the
    `car` package and then call its `recode()` function to recode, or rename, elements
    in a character vector.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第5章中，我们从`car`包中调用了`vif()`函数来检查我们的多元线性回归中的多重共线性；在这里，我们将加载`car`包，然后调用它的`recode()`函数来重新编码或重命名字符向量中的元素。
- en: 'Our eight packages are loaded by sequentially calling the base R `library()`
    function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过依次调用基础R的`library()`函数来加载八个包：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll next import our data set and then take a quick glance at what we’ll be
    working with going forward.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入我们的数据集，并快速浏览我们将要处理的内容。
- en: 13.2 Importing and viewing data
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 导入和查看数据
- en: 'Our data set is a .csv file downloaded from Kaggle and then stored in our default
    working directory; it contains player statistics, including win shares, from every
    NBA season between 1950 and 2017\. We therefore make a call to the `readr read_csv()`
    function to import our data and in the process establish an object called ws_gini:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集是一个从Kaggle下载的.csv文件，然后存储在我们的默认工作目录中；它包含了从1950年到2017年每个NBA赛季的球员统计数据，包括胜利份额。因此，我们调用`readr
    read_csv()`函数来导入我们的数据，并在过程中创建一个名为ws_gini的对象：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The base `R dim()` function returns the dimension, or row and column counts,
    of the ws_gini data set:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R的`dim()`函数返回ws_gini数据集的维度，即行和列的数量：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our data set is 24,624 observations long and 53 columns wide where each player/year/team
    combination occupies a unique record in the ws_gini data set. It’s *always a*
    best practice to reduce the dimension of your data by eliminating unnecessary
    or unwanted variables and records, if for no other reason than to allow your queries
    and other lines of code to run faster and for you to maintain focus where it’s
    needed most. Thus, we’ll start our data wrangling operations by reducing the width
    and then the length of our data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集有24,624个观测值和53列宽，其中每个球员/年份/球队组合在ws_gini数据集中都占据一个唯一的记录。始终是一个最佳实践，通过消除不必要的或不受欢迎的变量和记录来降低数据的维度，即使没有其他原因，也能让查询和其他代码行运行得更快，并让你在最需要的地方保持专注。因此，我们将从减少数据的宽度开始，然后是长度，来开始我们的数据整理操作。
- en: 13.3 Wrangling data
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 数据整理
- en: 'We begin by calling the `dplyr select()` function to subset ws_gini on just
    three variables: `Year` (e.g., 2012, which represents the 2011-12 season), `Tm`
    (e.g., CLE for Cleveland Cavaliers or DAL for Dallas Mavericks), and `WS` (short
    for win shares):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`dplyr select()`函数来筛选ws_gini中的三个变量：`Year`（例如，2012年，代表2011-12赛季），`Tm`（例如，CLE代表克利夫兰骑士队或DAL代表达拉斯小牛队），以及`WS`（代表赢球份额）：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we call the `dplyr filter()` function to subset ws_gini where the variable
    `Year` is equal to or greater than `1991`. Our data set will hereafter contain
    the 1991 through 2017 NBA seasons, which closely aligns with our data from chapter
    12:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`dplyr filter()`函数来筛选ws_gini中变量`Year`等于或大于`1991`的部分。从现在起，我们的数据集将包含1991年到2017年的NBA赛季，这与第12章中的数据紧密相关：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we call the `filter()` function again to further reduce the ws_gini data
    set by only including those records where the variable `Tm` doesn’t equal `TOT`;
    we therefore add the logical operator not equal to `(!=)` to exclude those records
    going forward. It turns out that players who played for more than one team in
    a single NBA season are represented multiple times in the data downloaded from
    Kaggle. For instance, Spencer Hawes, now retired, played for both the Charlotte
    Hornets and Milwaukee Bucks in 2017; there are thus three Spencer Hawes observations
    in ws_gini for 2017, one where the variable `Tm` equals `CHO` (for Charlotte),
    one where `Tm` equals `MIL` (for Milwaukee), and a third where `Tm` equals `TOT`,
    which is an aggregate of `CHO` and `MIL`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次调用`filter()`函数，通过只包括变量`Tm`不等于`TOT`的记录来进一步减少ws_gini数据集。因此，我们添加了逻辑运算符不等于`(!=)`来排除未来的这些记录。结果发现，在一个NBA赛季中为不止一支球队效力的球员在从Kaggle下载的数据中多次出现。例如，现在已经退役的斯宾塞·霍华德（Spencer
    Hawes）在2017年为夏洛特黄蜂队和密尔沃基雄鹿队效力；因此，ws_gini中2017年有斯宾塞·霍华德的三条记录，一条是变量`Tm`等于`CHO`（代表夏洛特），一条是变量`Tm`等于`MIL`（代表密尔沃基），还有一条是变量`Tm`等于`TOT`，这是`CHO`和`MIL`的汇总：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another call to the `dim()` function gets the reduced dimension of the ws_gini
    data set:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用`dim()`函数可以得到ws_gini数据集的降维维度：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is now just 13,356 rows long and, of course, three columns wide.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据集只有13,356行长，当然，三列宽。
- en: 'We then convert the variables `Year` and `Tm` to factor variables by twice
    calling the base R `as.factor()` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过两次调用基础R的`as.factor()`函数，将变量`Year`和`Tm`转换为因子变量：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Successive calls to the base R `head``()` and `tail()` functions return the
    first six and last six observations, respectively, in ws_gini—just so you can
    see what a few records actually look like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 连续调用基础R的`head()`和`tail()`函数分别返回ws_gini中的前六个和最后六个观测值——这样你可以看到一些记录的实际样子：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we call the `summary()` function from base R, which returns descriptive
    statistics for the three variables remaining in ws_gini. By adding the `maxsum`
    argument, we’re instructing R to return as many as, but no more than, 40 levels
    for factors. The variable `Year` contains 26 levels, and the variable `Tm` contains
    38 levels (our data includes different levels, or factors, for multiple iterations
    in team names even when the franchises remained the same).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用基础R的`summary()`函数，它返回ws_gini中剩余三个变量的描述性统计。通过添加`maxsum`参数，我们指示R返回最多40个水平（因子）但不超过40个。变量`Year`包含26个水平，变量`Tm`包含38个水平（我们的数据包括多个水平或因子，即使特许经营保持不变，球队名称的多个迭代也有不同的水平）。
- en: 'As a reminder, for variables that are numeric, such as `WS`, the `summary()`
    function returns the mean, median, minimum and maximum values, and the first and
    third quartiles. For variables that are factors, such as `Year` and `Tm`, `summary()`
    instead returns the observation counts for each group:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，对于像`WS`这样的数值变量，`summary()`函数返回均值、中位数、最小值、最大值以及第一和第三四分位数。对于像`Year`和`Tm`这样的因子变量，`summary()`函数则返回每个组的观测计数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The upcoming chunk of code should be familiar if you’ve already read chapter
    12\. The intent is to further reduce the length of our data set by subsetting
    ws_gini on a maximum of the top 14 win shares for each `Year` and `Tm` combination.
    The NBA includes many players who come and go on short-term contracts; by subsetting
    the ws_gini data set, we’re fairly and accurately excluding the NBA equivalent
    of temporary contract help and focusing exclusively on full-time and permanent
    employees:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了第12章，接下来的代码块应该很熟悉。我们的目的是通过在`Year`和`Tm`组合中筛选出每个组合的前14个最高赢球份额来进一步缩短数据集的长度。NBA中有许多球员因为短期合同而来来去去；通过筛选ws_gini数据集，我们可以公平准确地排除NBA的临时合同球员，并专注于全职和永久员工：
- en: We begin by passing our data to the `dplyr arrange()` function, which sorts
    ws_gini by each of the three ws_gini variables.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将数据传递给`dplyr arrange()`函数，该函数按ws_gini中的每个ws_gini变量对ws_gini进行排序。
- en: We then call the `dplyr group_by``()` and `mutate()` functions and the base
    R `rank()` function to create a new variable called `rank`, where the variable
    `WS` is sorted in descending order, 1 through *n*, by every `Year` and `Tm` combination
    in our data. The minus, or negative, sign inside the `rank()` function instructs
    R to sort, or rank, the variable `WS` in descending order. The `ties.method` argument
    specifies how ties should be handled; when equal to `first`, R assigns tied elements
    to consecutive, and thus different, ranks.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们调用`dplyr group_by()`和`mutate()`函数以及基本的R `rank()`函数来创建一个名为`rank`的新变量，其中变量`WS`按降序排序，从1到*n*，按我们数据中的每个`Year`和`Tm`组合排序。`rank()`函数内部的负号或负号指示R按降序排序或排名变量`WS`。`ties.method`参数指定如何处理平局；当等于`first`时，R将平局元素分配给连续的、因此不同的排名。
- en: Finally, we call the `dplyr filter()` function to include only those records
    where the variable `rank` is less than or equal to `14`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们调用`dplyr filter()`函数，只包括变量`rank`小于或等于`14`的记录。
- en: 'The results are thrown into a tibble called ws_gini2:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被放入一个名为ws_gini2的tibble中：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then call the base R `head()` function, this time to return the top 14 records
    in the ws_gini2 data set, to display the outcomes of these last few operations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用基本的R `head()`函数，这次是为了返回ws_gini2数据集中的前14条记录，以显示这些最后几个操作的输出：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are a couple of observations (note, by the way, that ATL is short for
    Atlanta Hawks):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些观察结果（顺便说一下，ATL是亚特兰大老鹰队的缩写）：
- en: The variable `WS` is clearly sorted in ascending order, and just as clearly,
    we see that the variable `rank` is sorted in descending order. This makes it possible
    to subset each `Year` and `Tm` combination on no more than the top 14 win shares.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`WS`显然是按升序排序的，同样明显的是，我们看到变量`rank`是按降序排序的。这使得我们可以对每个`Year`和`Tm`组合进行子集化，不超过前14个胜利贡献值。
- en: The Atlanta Hawks had two players who “earned” 0.0 win shares during the 1991
    season. By design, they are assigned different but contiguous ranks; otherwise,
    we would run the risk of subsetting at least some of our `Year` and `Tm` combinations
    on more than 14 records.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚特兰大老鹰队有两名球员在1991赛季“获得”了0.0胜利贡献值。按照设计，他们被分配了不同但连续的排名；否则，我们就有可能将我们的`Year`和`Tm`组合的子集扩展到超过14条记录的风险。
- en: 'While this looks perfect, let’s nevertheless perform a series of integrity
    checks similar to those we performed in the prior chapter. We start by twice calling
    the `sqldf()` function from the `sqldf` package to (1) to return every record
    from ws_gini where the variable `Year` equals `2012` and the variable `Tm` equals
    `GSW`, short for Golden State Warriors; and (2) return every record from ws_gini2
    where the variable `Year` also equals `2012` and the variable `Tm` also equals
    `GSW`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很完美，但我们仍然要执行一系列与上一章中执行的那些类似的完整性检查。我们首先两次调用`sqldf()`函数，来自`sqldf`包，以（1）返回变量`Year`等于`2012`且变量`Tm`等于`GSW`（即金州勇士队）的ws_gini中的每条记录；（2）返回变量`Year`也等于`2012`且变量`Tm`也等于`GSW`的ws_gini2中的每条记录：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our first `SELECT` statement returned 20 records, sorted in no particular order,
    and our second `SELECT` statement returned 14 records, where the variable `WS`
    is sorted in ascending order and the variable `rank` is sorted in descending order.
    This checks out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一条`SELECT`语句返回了20条记录，没有特定的排序顺序，而我们的第二条`SELECT`语句返回了14条记录，其中变量`WS`按升序排序，变量`rank`按降序排序。这是正确的。
- en: 'Next, we do the same by swapping out the Golden State Warriors in favor of
    the Boston Celtics (BOS) and by writing two short chunks of `dplyr` code rather
    than `sqldf` code. We pass the ws_gini and then the ws_gini2 data sets to the
    `filter()` function to subset the results where the variable `Year` equals `2017`
    and the variable `Tm` equals `BOS`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过用波士顿凯尔特人队（BOS）替换金州勇士队，并编写两个简短的`dplyr`代码块而不是`sqldf`代码来执行相同的操作。我们将ws_gini和ws_gini2数据集传递给`filter()`函数，以子集化变量`Year`等于`2017`且变量`Tm`等于`BOS`的结果：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our first chunk of `dplyr` code returned 15 unsorted records, and our second
    code chunk returned just 14 records by filtering out one of two players who earned
    0.1 win shares during the 2017 season. This checks out.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一段`dplyr`代码返回了15条未排序的记录，而我们的第二段代码通过过滤掉2017赛季获得0.1胜利贡献值的两名球员中的一名，只返回了14条记录。这是正确的。
- en: 'Finally, let’s run two more `SELECT` statements that compute the ws_gini2 row
    counts where the variable `Tm` equals `GSW` and then when `Tm` equals `BOS`. Row
    counts should equal a maximum of 378, which is the product of 27 seasons times
    a maximum of 14 players/win shares per season (some teams in some seasons had
    fewer than 14 players on their respective rosters):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行两个额外的`SELECT`语句，计算变量`Tm`等于`GSW`和`Tm`等于`BOS`时的ws_gini2行数。行数应等于最多378，这是27个赛季乘以每个赛季最多14名球员/赢分份额的乘积（有些赛季的某些球队在其阵容中少于14名球员）：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The row counts equal 377 and 378, respectively. This also checks out.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 行数分别等于377和378。这也检查无误。
- en: Now that we know our data is in a good spot, we can next begin our analysis
    by computing Gini coefficients.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道数据处于良好状态，我们可以通过计算基尼系数来开始我们的分析。
- en: 13.4 Gini coefficients
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 基尼系数
- en: Once more, the Gini coefficient is a frequently reported measure of inequality,
    usually income inequality across some population, where a coefficient equal to
    0 represents a state of perfect equality and a coefficient equal to 1 represents
    a state of perfect inequality. In chapter 12, we computed Gini coefficients to
    measure salary inequality; here, we’ll compute Gini coefficients to measure win
    share inequality.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，基尼系数是经常报道的不平等度量，通常是在某些人口中的收入不平等，其中系数等于0表示完全平等的状态，系数等于1表示完全不平等的状态。在第12章中，我们计算基尼系数来衡量薪酬不平等；在这里，我们将计算基尼系数来衡量赢分不平等。
- en: 'In the next chunk of code, we pass ws_gini2 to the `dplyr group_by``()` and
    `summarize()` functions to compute the league-wide Gini coefficient for win shares
    for each level in the variable `Year`. The `ineq()` function from the `ineq` package
    is otherwise doing our heavy lifting, returning the annual Gini coefficient, rounded
    to two digits right of the decimal point, through a new variable called `gc`.
    Our results are cast to a tibble called ws_gini_summary:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，我们将ws_gini2传递给`dplyr group_by()`和`summarize()`函数，以计算变量`Year`中每个级别的联赛基尼系数。`ineq`包中的`ineq`函数否则正在做我们的重活，通过一个名为`gc`的新变量返回年度基尼系数，四舍五入到小数点后两位。我们的结果被转换为一个名为ws_gini_summary的tibble。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our results are then plotted in a `gpplot2` line chart (see figure 13.1). We’ve
    switched up some of the aesthetics from previous line charts:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将结果绘制在`gpplot2`折线图中（见图13.1）。我们改变了一些之前折线图的美学设置：
- en: The `geom_line()` function draws a black line one-half the `ggplot2` default
    width.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_line()`函数绘制一条宽度为`ggplot2`默认宽度一半的黑色线。'
- en: The `geom_point()` function adds points along the line that are five times the
    default size. Our plot therefore assumes the look and feel of a connected scatterplot.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_point()`函数在沿线添加五倍于默认大小的点。因此，我们的图表假定看起来像一个连接的散点图。'
- en: The `geom_text()` function adds labels above the points that tie back to the
    ws_gini_summary variable `gc`. The `nudge_x` and `nudge_y` arguments are used
    to position the labels relative to the points—the smaller the number, the closer
    the labels. If negative, R places the numbers below the points rather than above.
    The `check_overlap` argument is an instruction to R to avoid, as much as possible,
    overlapping the labels.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_text()`函数在连接到ws_gini_summary变量`gc`的点上方添加标签。`nudge_x`和`nudge_y`参数用于将标签定位到点相对的位置——数字越小，标签越靠近。如果为负数，R将数字放置在点下方而不是上方。`check_overlap`参数是R避免尽可能重叠标签的指令。'
- en: The first and second calls to the `theme()` function center the title and subtitle,
    thereby overwriting the `ggplot2` default, which is to left-justify both. By setting
    the `hjust` argument, short for horizontal adjustment, equal to `0.5`, we’re shifting
    the title and subtitle halfway across the width of the plot. Alternatively, we
    could right-justify the title and subtitle by instead setting the `hjust` argument
    equal to `1`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme()`函数的第一和第二次调用将标题和副标题居中，从而覆盖了`ggplot2`的默认设置，即左对齐两者。通过将`hjust`参数（代表水平调整）设置为`0.5`，我们将标题和副标题移至图表宽度的中点。或者，我们可以通过将`hjust`参数设置为`1`来右对齐标题和副标题。'
- en: The third call to the `theme()` function orients the x-axis labels at 45 degrees
    and aligns them horizontally just beneath the plot.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme()`函数的第三次调用将x轴标签旋转45度，并将它们水平对齐在图表下方。'
- en: The `annotate()` function is called twice to add a pair of transparent rectangular
    shapes, where the `xmin`, `xmax`, `ymin`, and `ymax` arguments establish the horizontal
    and vertical boundaries. This is a nice touch that immediately suggests the plot
    has two different stories to tell.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`annotate()`函数被调用了两次，以添加一对透明的矩形形状，其中`xmin`、`xmax`、`ymin`和`ymax`参数确定了水平和垂直边界。这是一个很好的细节，立即暗示了图表有两个不同的故事要讲述。'
- en: '![CH13_F01_Sutton](../../OEBPS/Images/CH13_F01_Sutton.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F01_Sutton](../../OEBPS/Images/CH13_F01_Sutton.png)'
- en: Figure 13.1 The year-over-year, or season-over-season, Gini coefficient for
    win shares distribution across the NBA
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 NBA赢分分布的年度或赛季基尼系数
- en: 'Finally, here’s the chunk of code for our first plot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们的第一个图表的代码块：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our immediate takeaways are the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即得出的结论如下：
- en: 'These are high Gini coefficients: between 1991 and 2017, the Gini coefficient
    peaked twice at 0.56 and never dropped below 0.47\. Once more, a Gini coefficient
    equal to or greater than 0.40 indicates significant inequality, regardless of
    what’s being measured.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些是高基尼系数：在1991年至2017年之间，基尼系数两次达到峰值0.56，并且从未低于0.47。再次强调，基尼系数等于或大于0.40表明存在显著的不平等，无论测量的是什么。
- en: We added a pair of shaded rectangles to the plot to highlight a contrast in
    results. Between 1991 and 2009, the Gini coefficient was never below 0.52, but
    between 2010 and 2017, the Gini coefficient peaked at 0.51 once and was otherwise
    never above 0.50\. Again, this is a fairly simple-enough technique that readily
    makes it clear that we have two distinct sets of results.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在图表中添加了一对阴影矩形来突出结果之间的对比。在1991年至2009年之间，基尼系数从未低于0.52，但在2010年至2017年之间，基尼系数达到峰值0.51一次，并且在此之后从未高于0.50。再次强调，这是一个相当简单的技术，可以清楚地表明我们有两个不同的结果集。
- en: The league-wide Gini coefficient for win shares therefore trended *downward*
    between 1991 and 2017; by contrast, the Gini coefficient for salaries, which we
    explored in chapter 12, spiked *upward* in the mid-1990s and stabilized from there
    through 2018\. Consequently, the Gini coefficients between salaries and win shares
    were unaligned in the 1990s and then identical, or nearly identical, every year
    between 2010 and 2017; put differently, they gradually converged over time.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，从1991年到2017年，联赛的基尼系数在赢分方面呈下降趋势；相比之下，我们在第12章中探讨的工资基尼系数在1990年代中期急剧上升，并从那时起稳定到2018年。因此，在1990年代，工资和赢分之间的基尼系数不匹配，而在2010年至2017年之间，它们每年都是相同的，或者几乎是相同的；换句话说，它们随着时间的推移逐渐趋同。
- en: In the next sections, we’ll demonstrate different methods for visualizing the
    inequality of player productivity with Lorenz curves.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将展示不同的方法来可视化球员生产力的不平等，使用洛伦兹曲线。
- en: 13.5 Lorenz curves
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 洛伦兹曲线
- en: 'For starters, R will throw an error if we try to create a Lorenz curve from
    a vector that contains negative elements, so we need to query our data and then
    apply corrective action. We learned in chapters 2 and 3 that it’s possible for
    players to “accrue” negative win shares, even over the course of a career. In
    the following code, we make a call to the `sqldf()` function to return a record
    count from ws_gini2 where the variable `WS` is less than 0:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们尝试从一个包含负元素的向量创建洛伦兹曲线，R将抛出一个错误，因此我们需要查询我们的数据并采取纠正措施。我们在第2章和第3章中学到，球员在职业生涯中可能会“累积”负的赢分。在以下代码中，我们调用`sqldf()`函数来返回ws_gini2中变量`WS`小于0的记录数：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sure enough, we have 227 records where the variable `WS` equals some number
    less than 0\. There are at least two obvious fixes. One is to call the `filter()`
    function and remove these 227 records from our data set; the other is to adjust
    negative win shares to equal 0 instead. We’ll take the latter approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们有227条记录，其中变量`WS`等于某个小于0的数字。至少有两个明显的解决方案。一个是调用`filter()`函数并从我们的数据集中删除这227条记录；另一个是将负的赢分调整为等于0。我们将采取后一种方法。
- en: 'In the following line of code, we apply square brackets, also known as extraction
    operators, to index the `WS` vector in the ws_gini2 data set where the value is
    less than 0 and then modify those elements so that they equal 0 instead. Then,
    we call the base R `min()` function to return the minimum value in the variable
    `WS`; as expected, it now equals 0:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们应用了方括号，也称为提取运算符，来索引ws_gini2数据集中值小于0的`WS`向量，然后修改这些元素，使它们等于0。然后，我们调用基本的R
    `min()`函数来返回变量`WS`中的最小值；正如预期的那样，它现在等于0：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our first Lorenz curve is created with our next code chunk (see figure 13.2):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下一代码块创建了第一个洛伦兹曲线（见图 13.2）：
- en: We begin by calling the `filter()` function from the `dplyr` package to subset
    the ws_gini2 data set where the variable `Year` equals `1991`. The end result
    is a new data set called gini91.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从 `dplyr` 包中调用 `filter()` 函数，对 ws_gini2 数据集进行子集化，其中变量 `Year` 等于 `1991`。最终结果是名为
    gini91 的新数据集。
- en: Even though our Lorenz curve is essentially an extension of `ggplot2`, requiring
    not only the `ggplot()` function but also the `gglorenz` `stat_lorenz()` function,
    the syntax is otherwise entirely consistent with any other `ggplot2` object. Therefore,
    our plot is initialized by calling the `ggplot()` function, passing gini91 as
    our data source, and then passing the variable `WS` as the lone aesthetic mapping.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们的洛伦兹曲线本质上是对 `ggplot2` 的扩展，不仅需要 `ggplot()` 函数，还需要 `gglorenz` 的 `stat_lorenz()`
    函数，但其语法与其他任何 `ggplot2` 对象完全一致。因此，我们的图表是通过调用 `ggplot()` 函数初始化的，将 gini91 作为我们的数据源，然后将变量
    `WS` 作为唯一的美学映射传递。
- en: The `stat_lorenz()` function from the `gglorenz` package draws the Lorenz curve.
    When set to `TRUE`, the population is arranged in descending order; when set to
    `FALSE`, the population is instead arranged in ascending order. Because most Lorenz
    curves are created with the population arranged in ascending order, rather than
    vice versa, we set the `desc` argument, short for descending, equal to `FALSE`.
    Furthermore, we instruct R to draw the line a solid red and to make it twice the
    default width.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gglorenz` 包中的 `stat_lorenz()` 函数绘制洛伦兹曲线。当设置为 `TRUE` 时，人口按降序排列；当设置为 `FALSE`
    时，人口则按升序排列。由于大多数洛伦兹曲线都是按人口升序排列创建的，而不是相反，我们将 `desc` 参数（表示降序）设置为 `FALSE`。此外，我们指示
    R 用实线绘制线条，并将其宽度设置为默认宽度的两倍。'
- en: The `ggplot2 coord_fixed()` function fixes the ratios of the x- and y-axes so
    that their scales are equal.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot2 coord_fixed()` 函数固定 x 轴和 y 轴的比率，使它们的刻度相等。'
- en: The `geom_abline()` function draws a dashed diagonal line that represents a
    state of perfect equality.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_abline()` 函数绘制一条虚线对角线，代表完全相等的状态。'
- en: The `scale_x_continuous``()` and `scale_y_continuous()` functions, combined
    with the `scales` package, converts our x- and y-axis labels, respectively, from
    decimals to percentages.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_x_continuous()` 和 `scale_y_continuous()` 函数，结合 `scales` 包，分别将 x 轴和 y
    轴的标签从小数转换为百分比。'
- en: '![CH13_F02_Sutton](../../OEBPS/Images/CH13_F02_Sutton.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F02_Sutton](../../OEBPS/Images/CH13_F02_Sutton.png)'
- en: Figure 13.2 League-wide Lorenz curve for win share distribution for the 1990-91
    NBA season when the Gini coefficient equaled 0.56
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 1990-91 赛季 NBA 赛季的联赛范围内胜利份额分布的洛伦兹曲线，基尼系数等于 0.56
- en: 'Following is our `dplyr` and `ggplot2` code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的 `dplyr` 和 `ggplot2` 代码：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Approximately 25% of the win shares during the 1990-91 NBA season were generated
    by about 1% of the players; approximately 50% of all win shares were generated
    by about 12% of the players; and approximately 75% of the win shares were generated
    by about 37% of the players. This is exactly how we created our chapter 12 Lorenz
    curves. But let’s say we want to compare and visualize Gini coefficients between
    two seasons in a single graphical representation *and*, at the same time, create
    a plot that’s more aesthetically pleasing than our previous Lorenz curves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990-91 赛季的 NBA 赛季中，大约 25% 的胜利份额是由大约 1% 的球员产生的；大约 50% 的所有胜利份额是由大约 12% 的球员产生的；大约
    75% 的胜利份额是由大约 37% 的球员产生的。这正是我们创建第 12 章洛伦兹曲线的方式。但假设我们想要在单个图形表示中比较和可视化两个赛季之间的基尼系数，并且同时创建一个比我们之前的洛伦兹曲线更美观的图表。
- en: 'Our first step is to call the `dplyr filter()` function to subset the ws_gini2
    data set where the variable `Year` equals `1991` or `2017`, where the Gini coefficients
    equal 0.56 and 0.49, respectively. The pipe (`|`) is a logical operator meaning
    “or.” We cast the results to a new object called gini9117:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是调用 `dplyr filter()` 函数，对 ws_gini2 数据集进行子集化，其中变量 `Year` 等于 `1991` 或 `2017`，基尼系数分别为
    0.56 和 0.49。管道 (`|`) 是一个逻辑运算符，表示“或”。我们将结果转换到一个名为 gini9117 的新对象中：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then call the base R `head``()` and `tail()` functions to return the first
    three and last three records in gini9117:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用基础 R 的 `head()` 和 `tail()` 函数，以返回 gini9117 中的前三个和最后三个记录：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The factors in the variable `Tm` are arranged in alphabetical order. That being
    said, our data set begins with the 1991 Atlanta Hawks and ends with the 2017 Washington
    Wizards. So this checks out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `Tm` 中的因素按字母顺序排列。也就是说，我们的数据集从 1991 年的亚特兰大老鹰队开始，以 2017 年的华盛顿奇才队结束。所以这是正确的。
- en: 'Our next chunk of code draws a new and improved Lorenz curve (see figure 13.3).
    The syntax is the same as before, but with two exceptions—(1) we added an aesthetic
    parameter, `fill`, equal to the variable `Year`, and (2) we replaced the single
    Lorenz curve, or line, inside the `stat_lorenz()` function with an additional
    `geom` equal to `polygon`, which draws a pair of filled area curves:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的代码块绘制了一个新的、改进的洛伦兹曲线（见图13.3）。语法与之前相同，但有两大例外——（1）我们添加了一个美学参数`fill`，其值等于变量`Year`，（2）我们用额外的`geom`等于`polygon`替换了`stat_lorenz()`函数内的单个洛伦兹曲线或线条，这绘制了一对填充区域曲线：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![CH13_F03_Sutton](../../OEBPS/Images/CH13_F03_Sutton.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F03_Sutton](../../OEBPS/Images/CH13_F03_Sutton.png)'
- en: Figure 13.3 League-wide Lorenz curves for win share distributions in 1991 and
    2017 consolidated into a single graphical object
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 1991年和2017年联赛范围内的赢分分布洛伦兹曲线合并为一个单一图形对象
- en: The smaller curve represents the Gini coefficient in win share distribution
    for 2017, whereas the larger curve represents the Gini coefficient in win share
    distribution for 1991\. Don’t be fooled by the shades—we’re still measuring the
    distance between each of the Lorenz curves and the dashed diagonal line. This
    is both a more effective and more efficient way of visually comparing two Gini
    coefficients versus creating a pair of side-by-side plots.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的曲线代表2017年赢分分布的基尼系数，而较大的曲线代表1991年的基尼系数。不要被阴影所迷惑——我们仍在测量每条洛伦兹曲线与虚线对角线之间的距离。这是一种比创建成对的并排图表更有效、更高效的方式来直观比较两个基尼系数。
- en: We’ll demonstrate one more way to create a Lorenz curve—actually, a series of
    Lorenz curves—in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中展示创建洛伦兹曲线的另一种方法——实际上，是一系列洛伦兹曲线。
- en: 13.6 For loops
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 循环
- en: So far, we’ve demonstrated two methods for creating `ggplot2` Lorenz curves.
    But let’s say we want or need to create a separate Lorenz curve for each of the
    27 NBA seasons in our data set. One way to do that is to create one Lorenz curve,
    copy and paste the code 26 times, and then change maybe a couple of parameters
    on each iteration. This is tedious, yes, but not difficult. Another method is
    to write a `for` loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了两种创建`ggplot2`洛伦兹曲线的方法。但假设我们想要或需要为数据集中的27个NBA赛季中的每一个创建一个单独的洛伦兹曲线。一种方法是创建一个洛伦兹曲线，复制粘贴代码26次，然后在每次迭代中可能更改几个参数。是的，这很繁琐，但并不困难。另一种方法是编写一个`for`循环。
- en: 13.6.1 Simple demonstration
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6.1 简单演示
- en: A `for` loop is an efficient and common alternative when the same task must
    be repeated a finite number of times. There’s less code to write, which minimizes
    the potential for human error during the development phase and maximizes maintainability
    afterward because fixes and other changes then need to be applied just once, rather
    than, let’s say, 27 times.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一个任务必须重复有限次数时，`for`循环是一种高效且常见的选择。代码量更少，这最小化了开发阶段中人为错误的可能性，并在之后最大化了可维护性，因为修复和其他更改只需要应用一次，而不是，比如说，27次。
- en: 'Following is the simplest of `for` loops:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最简单的`for`循环：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s what just happened: An index, `i`, is iteratively replaced by each value
    in the vector 1:5\. Because the first value in our vector equals `1`, our `for`
    loop first replaces `i` with the number `1` and then executes the code between
    the curly brackets. Frequently, `for` loops are initialized with `i` as the counter,
    which is short for iteration, but `for` loops can be initialized just as well
    with any letter or character string. The `for` loop then iterates through the
    vector until it reaches the final value, at which point it stops and exits.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是刚刚发生的事情：索引`i`被迭代地替换为向量1:5中的每个值。因为我们的向量中的第一个值等于`1`，所以我们的`for`循环首先将`i`替换为数字`1`，然后执行花括号之间的代码。通常，`for`循环以`i`作为计数器初始化，这是迭代的简称，但`for`循环也可以用任何字母或字符字符串初始化。然后`for`循环遍历向量，直到达到最终值，此时它停止并退出。
- en: We returned five values with one small chunk of code where the alternative would
    have required us to sequentially multiply five numbers by two. If we should have
    multiplied those same five numbers by 3 instead of 2, we would have then been
    required to implement the change five times rather than just once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一小段代码返回了五个值，而如果用其他方法，我们需要依次将五个数字乘以二。如果我们应该将这五个相同的数字乘以三而不是二，那么我们就需要五次而不是一次地实施更改。
- en: 13.6.2 Applying what we’ve learned
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6.2 应用所学知识
- en: 'Now, for our Lorenz curves, we’re going to first wrangle our data to best demonstrate
    the use of `for` loops to create multiple plots. We start by calling the `dplyr
    ungroup()` function to decouple, or ungroup, the two variables, `Year` and `Tm`,
    that were previously combined by calling the `group_by()` function. We want to
    subset our data on the variables `Year` and `WS` only, but because `Year` and
    `Tm` are currently grouped, R will otherwise force us to also retain the variable
    `Tm`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的洛伦兹曲线，我们首先整理数据，以最好地展示使用`for`循环创建多个图的使用方法。我们首先调用`dplyr ungroup()`函数来解耦，或取消组合，之前通过调用`group_by()`函数组合的两个变量，`Year`和`Tm`。我们只想对变量`Year`和`WS`进行子集操作，但由于`Year`和`Tm`目前是组合的，否则R将强制我们保留变量`Tm`：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we call the `dplyr filter()` function to reduce the length of ws_gini2
    by only including those records where the variable `Year` equals `1991`, `1992`,
    `1993`, or `1994`. We can just as effectively demonstrate the worth of `for` loops
    with 4 years of data as we can with 27\. We then cast the results to a new tibble
    called ws9194\. The `head``()` and `tail()` functions return the first six and
    last six observations:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`dplyr filter()`函数来缩短ws_gini2的长度，只包括变量`Year`等于`1991`、`1992`、`1993`或`1994`的记录。我们可以用4年的数据同样有效地展示`for`循环的价值，就像我们用27年的数据一样。然后，我们将结果转换成一个新的tibble，称为ws9194。`head()`和`tail()`函数返回前六个和后六个观测值：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we transpose ws9194 from a long format to a wide format by calling the
    `pivot_ wider()` function from the `tidyr` package. By doing so, the variable
    `Year` is broken out into four columns, `1991` through `1994`, populated with
    elements from the variable `WS`. The `head()` function then returns the top six
    records:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`tidyr`包中的`pivot_wider()`函数将ws9194从长格式转换为宽格式。这样做后，变量`Year`被拆分为四个列，从`1991`到`1994`，用变量`WS`的元素填充。然后`head()`函数返回前六个记录：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We don’t need the variables `Tm` and `rank` to create our Lorenz curves, so
    we next call the `dplyr select()` function to subset ws9194 on every variable
    *but* `Tm` and `rank` (notice the minus sign that precedes our call to the `c()`
    function):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要变量`Tm`和`rank`来创建我们的洛伦兹曲线，所以我们接下来调用`dplyr select()`函数来对ws9194进行子集操作，除了`Tm`和`rank`之外的所有变量（注意`c()`函数调用之前的前导减号）：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, we convert ws9194 from a tibble to a data frame by calling the base R
    `as.data.frame()` function. Back when we created our first tibble, we mentioned
    that tibbles share many of the same properties as data frames, but there are at
    least three important differences as well. The first is that tibbles return only
    the first 10 rows and whatever number of columns fit on screen when the `print()`
    function is called (which we’ve seen). This is usually convenient when working
    with large data sets but sometimes frustrating otherwise. The second is that tibbles
    sometimes require “workarounds” when subsetting the data (which we’ve also seen).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用基础R的`as.data.frame()`函数将ws9194从tibble转换为数据框。当我们第一次创建tibble时，我们提到tibbles与数据框有许多相同的属性，但至少有三个重要的区别。第一个是，当调用`print()`函数时，tibbles只返回前10行和屏幕上能容纳的任意数量的列（我们之前已经看到过）。当处理大型数据集时这通常很方便，但有时也会令人沮丧。第二个是，当对数据进行子集操作时，tibbles有时需要“解决方案”（我们之前也看到过）。
- en: 'The third is much more significant—tibbles don’t always work with older code.
    It turns out that our forthcoming Lorenz curves, created in part with base R code,
    can’t read ws9194 as a tibble but can when ws9194 is a data frame instead. So
    we call the `as.data.frame()` function to convert ws9194 from a tibble to a data
    frame. Then, we call the base R `class()` function, which returns the class of
    ws9194 and confirms that it’s now a data frame:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个区别更为重要——tibbles并不总是与旧代码兼容。结果是，我们即将创建的洛伦兹曲线，部分使用基础R代码创建，不能将ws9194作为tibble读取，但当ws9194是数据框时可以。因此，我们调用`as.data.frame()`函数将ws9194从tibble转换为数据框。然后，我们调用基础R的`class()`函数，它返回ws9194的类，并确认它现在是一个数据框：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we call the `names()` function from base R to rename the four remaining
    columns in ws9194 to `a`, `b`, `c`, and `d`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从基础R中调用`names()`函数来重命名ws9194中剩余的四列，分别为`a`、`b`、`c`和`d`：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we can go about writing a `for` loop, and with that, creating four Lorenz
    curves, one for each of the four years in the ws9194 data set. First, we call
    the base R `par()` function to arrange our four Lorenz curves in a single 2 ×
    2 matrix. The `mfrow` argument tells R to arrange the plots with 1991 and 1992
    on the top and 1993 and 1994 along the bottom; if we had instead called the `mfcol`
    argument, R would arrange 1991 and 1992 on the left and 1993 and 1994 on the right.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写一个 `for` 循环，并使用它来创建四个洛伦兹曲线，每个曲线对应于 ws9194 数据集中的四个年份。首先，我们调用基础 R 的
    `par()` 函数来将我们的四个洛伦兹曲线排列在一个 2 × 2 矩阵中。`mfrow` 参数告诉 R 将图表排列为 1991 年和 1992 年在上部，1993
    年和 1994 年在底部；如果我们调用 `mfcol` 参数，R 将将 1991 年和 1992 年排列在左侧，1993 年和 1994 年排列在右侧。
- en: 'Within the remaining chunk of code, the following occurs:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的代码块中，发生以下情况：
- en: We first create a loop vector, called `loop.vector`, that will eventually iterate
    four times, or otherwise loop through each of the four columns, or vectors, in
    the ws9194 data set.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个循环向量，称为 `loop.vector`，它最终将迭代四次，或者在其他情况下循环遍历 ws9194 数据集中的每一列或向量。
- en: The loop object is then initialized as `i`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环对象随后被初始化为 `i`。
- en: The code inside the opening and closing brackets is then executed four times,
    once per column or vector that then generates four corresponding plots.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开括号和闭括号内的代码将被执行四次，每次对应于一列或向量，从而生成四个相应的图表。
- en: The data is stored as x and then used to source our Lorenz curves, created with
    the combination of the base R `plot()` function and the `Lc()` function from the
    `ineq` package (see figure 13.4).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据被存储为 x，然后用于生成我们的洛伦兹曲线，这些曲线是通过基础 R 的 `plot()` 函数和 `ineq` 包中的 `Lc()` 函数的组合来创建的（见图
    13.4）。
- en: The `paste0()` function is a built-in R function that concatenates elements
    without the need for separators. The title for each of our Lorenz curves is essentially
    a title on top and subtitle on the bottom, where the Lorenz curve is printed along
    the top and the applicable year is printed along the bottom; the `\n` in R acts
    like a carriage return when applied within a character string. The year is returned
    by appending, or concatenating, `199` and `i` (or `1`, `2`, `3`, `4` with each
    successive loop).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paste0()` 函数是一个内置的 R 函数，它可以将元素连接起来，而不需要分隔符。我们每个洛伦兹曲线的标题实际上是一个顶部标题和底部副标题，其中洛伦兹曲线打印在顶部，适用的年份打印在底部；在
    R 中，`\n` 在字符字符串中使用时类似于回车符。年份是通过附加或连接 `199` 和 `i`（或 `1`、`2`、`3`、`4`，每个循环依次进行）来返回的。'
- en: '![CH13_F04_Sutton](../../OEBPS/Images/CH13_F04_Sutton.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F04_Sutton](../../OEBPS/Images/CH13_F04_Sutton.png)'
- en: Figure 13.4 League-wide Lorenz curves for win share distributions between 1991
    and 1994 created from a `for` loop and base R
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 从 `for` 循环和基础 R 创建的 1991 年至 1994 年联赛洛伦兹曲线
- en: 'The result is four Lorenz curves consolidated into a single graphical object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是四个洛伦兹曲线合并成一个单一的图形对象：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we didn’t know otherwise, we would likely estimate the Gini coefficients
    to equal approximately 0.50\. (According to our time-series plot where we displayed
    the year-over-year league-wide Gini coefficients in win shares, the actual coefficients
    equal 0.56 in 1991 and 1992 and 0.54 in 1993 and 1994.) But more importantly,
    we’ve demonstrated how you can write a `for` loop and, in this case, create four
    plots with less than one-fourth the code that would otherwise be required.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道其他情况，我们可能会估计基尼系数大约等于 0.50。 (根据我们显示的年度联赛 Gini 系数的时间序列图，实际的系数在 1991 年和
    1992 年为 0.56，在 1993 年和 1994 年为 0.54。) 但更重要的是，我们已经展示了如何编写一个 `for` 循环，在这种情况下，用不到四分之一的代码就能创建四个图表。
- en: In the next section, we’ll imagine that R doesn’t contain any built-in or packaged
    function to compute Gini coefficients, so we’ll create one of our own.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将假设 R 中不包含任何内置或包装的函数来计算基尼系数，因此我们将创建一个自己的函数。
- en: 13.7 User-defined functions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 用户自定义函数
- en: 'R is essentially a *functional* programming language, which means almost everything
    in R is derived from a built-in or packaged function. In this chapter alone, we’ve
    already called nearly 40 unique functions. Every function contains the following
    components:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: R 实质上是一种 *函数式* 编程语言，这意味着 R 中的几乎所有内容都源自内置或包装的函数。仅在这一章中，我们就已经调用了近 40 个独特的函数。每个函数都包含以下组件：
- en: '*Function name*—The actual name of the function. Function names are usually
    unique but not necessarily so given the ongoing proliferation of new packages
    and functions. Very simply, the function name for the `pivot_wider()` function
    is `pivot_wider`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数名称*—函数的实际名称。函数名称通常是唯一的，但考虑到新包和函数的激增，这并不一定。非常简单，`pivot_wider()` 函数的函数名称是
    `pivot_wider`。'
- en: '*Arguments*—One or more arguments, or inputs, that functions require to run.
    When we call the `pivot_wider()` function, for instance, we then pass two arguments
    inside a pair of open and closed parentheses separated by a comma; those arguments
    tell R which variable from which data set to break out into new columns and from
    which other variable we should populate those new columns.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*—函数运行所需的一个或多个参数或输入。例如，当我们调用 `pivot_wider()` 函数时，我们随后在括号内传递两个参数，这些参数通过逗号分隔，告诉
    R 从哪个数据集的哪个变量中提取新列，以及从哪个其他变量中填充这些新列。'
- en: '*Function body*—More or less contains a collection of statements that define
    what the function is supposed to do. Unlike the function name and the function
    arguments, the function body is invisible to us; we know what a function is supposed
    to do from experience or from reading about it.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数体*—大致包含一组定义函数应该做什么的语句。与函数名称和函数参数不同，函数体对我们来说是不可见的；我们通过经验或阅读了解函数应该做什么。'
- en: '*Return value*—The output we expect when a function runs. When, for instance,
    we call the `mean()` function against a continuous variable, we expect R to return
    a numeric value that represents the average, or mean.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回值*—函数运行时预期的输出。例如，当我们对连续变量调用 `mean()` 函数时，我们期望 R 返回一个表示平均数或均值的数值。'
- en: When we say that R is a functional programming language, that’s also because
    we can write our own functions, which are frequently referred to as user-defined
    functions. They contain the same components as built-in or packaged functions
    and even take on the same syntax.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 R 是一种函数式编程语言时，这也是因为我们能够编写自己的函数，这些函数通常被称为用户定义函数。它们包含与内置或打包函数相同的组件，并且采用相同的语法。
- en: Let’s write a function that converts r, or the correlation coefficient between
    a pair of continuous variables, to r², which, if we were to regress one continuous
    variable against the other, represents the proportion of variance that can be
    explained in the target variable by the predictor variable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，将 r，即一对连续变量之间的相关系数，转换为 r²，如果我们对其中一个连续变量进行回归，它代表可以由预测变量解释的目标变量的方差比例。
- en: 'Our function name, on the left side of the assignment operator, is called `r_to_
    rsquared()`. Function names should be more intuitive than creative. Our function
    requires just one argument, or input, and that is `r`. The function body and the
    return value are situated inside a pair of opening and closing curly brackets.
    Our `r_to_ rsquared()` function converts r to r² by squaring it and then returning
    the result. Our first user-defined function follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的名称，位于赋值运算符的左侧，被称为 `r_to_ rsquared()`。函数名称应该比创意性更强，更直观。我们的函数只需要一个参数，或者输入，那就是
    `r`。函数体和返回值位于一对开括号和闭括号内。我们的 `r_to_ rsquared()` 函数通过平方 `r` 并返回结果，将 `r` 转换为 `r²`。我们的第一个用户定义函数如下：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we call the function and pass a value, `.42`, for `r`. Our function returns
    r², or 0.1764.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用该函数，并将 `.42` 作为 `r` 的值传递。我们的函数返回 r²，即 0.1764。
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s now write a second user-defined function, which converts r² to r:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写第二个用户定义函数，它将 `r²` 转换为 `r`：
- en: Our new function is called `rsquared_to_r()`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的新函数被称为 `rsquared_to_r()`。
- en: It requires one argument, a value for `r`², to run.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一个参数，即 `r²` 的值，才能运行。
- en: It then converts r² to r by computing the square root and returning the result.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它通过计算平方根并将结果返回，将 `r²` 转换为 `r`。
- en: 'Our second user-defined function “looks” just like our first one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个用户定义函数“看起来”和第一个完全一样：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then call the function and pass 0.1764 as an argument to get 0.42 returned:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用该函数，并将 0.1764 作为参数传递，以获得 0.42 的返回值：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we’ll create a function that *estimates* the Gini coefficient from a
    Lorenz curve:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数来*估计*洛伦兹曲线的基尼系数：
- en: Our function takes on the name `gini.est()`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的函数采用 `gini.est()` 的名称。
- en: 'It requires exactly three arguments to be passed:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要恰好传递三个参数：
- en: '`a`, which represents the estimated cumulative population percentage when the
    cumulative win share distribution equals 40%.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 代表当累积赢分分布等于 40% 时估计的累积人口百分比。'
- en: '`b`, which represents the estimated cumulative population percentage when the
    cumulative win share distribution equals 60%.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` 代表当累积赢分分布等于 60% 时估计的累积人口百分比。'
- en: '`c`, which represents the estimated cumulative population percentage when the
    cumulative win share distribution equals 80%. In other words, given three x-axis
    coordinates—40%, 60%, and 80%—we’re estimating the corresponding y-axis coordinates
    through which a Lorenz curve passes. We already know y when x equals 0% or 100%.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` 代表当累积赢分分布等于 80% 时估计的累积人口百分比。换句话说，给定三个 x 轴坐标——40%、60% 和 80%——我们通过洛伦兹曲线估计相应的
    y 轴坐标。当 x 等于 0% 或 100% 时，我们已知 y 的值。'
- en: The function body computes the estimated Gini coefficient, shortened to equal
    gini, and returns the result. The estimated Gini coefficient is computed first
    by splitting the area *underneath* the Lorenz curve into mutually exclusive triangles,
    estimating the area for each, and adding the estimates together; that sum is then
    multiplied by 2, and that product is then subtracted by 1\. With respect to the
    1991 through 1994 NBA seasons, we should get Gini coefficients equal to or slightly
    greater than 0.50.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体计算估计的基尼系数，简称为 gini，并返回结果。估计的基尼系数首先通过将洛伦兹曲线下方的面积分成互斥的三角形，估计每个三角形的面积，并将估计值相加；然后将这个总和乘以
    2，然后将这个乘积减去 1。关于 1991 年至 1994 年 NBA 赛季，我们应该得到等于或略大于 0.50 的基尼系数。
- en: 'The area underneath each Lorenz curve is divided into four triangles, where
    the estimated area equals the width (the distance between two points along the
    x-axis) times the height (the distance between two points along the y-axis, where
    estimates for `a`, `b`, and `c` must be supplied) times 0.5:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个洛伦兹曲线下方的面积被分成四个三角形，其中估计的面积等于宽度（x 轴上两点之间的距离）乘以高度（y 轴上两点之间的距离，其中必须提供 `a`、`b`
    和 `c` 的估计）乘以 0.5：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s now run the `gini.est()` function but pass only two of the required three
    parameters:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来运行 `gini.est()` 函数，但只传递所需的三个参数中的两个：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: R throws an error because we supplied `a` and `b`, but not `c`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: R 抛出错误，因为我们提供了 `a` 和 `b`，但没有提供 `c`。
- en: 'Let’s do it right this time. Based on the Lorenz curve we created for the 1991
    NBA season, we’re estimating that 40% of the win shares were accrued by 5% of
    the players in our data set who played that year, that 60% of the win shares were
    accrued by 18% of the players, and that 80% of the win shares were accrued by
    44% of the players:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这次做对。根据我们为 1991 年 NBA 赛季创建的洛伦兹曲线，我们估计 40% 的赢分由我们数据集中那一年 5% 的球员获得，60% 的赢分由
    18% 的球员获得，80% 的赢分由 44% 的球员获得：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our function returns an estimated Gini coefficient equal to 0.522; the actual
    Gini coefficient in 1991 was 0.56\. So while our function isn’t perfect, it nevertheless
    returned a reasonable enough estimate
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能返回一个估计的基尼系数等于 0.522；1991 年的实际基尼系数为 0.56。所以虽然我们的函数并不完美，但它仍然返回了一个足够合理的估计。
- en: 'Let’s now run the `gini.est()` function for the 1992, 1993, and 1994 NBA seasons:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为 1992 年、1993 年和 1994 年 NBA 赛季运行 `gini.est()` 函数：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’re consistently lowballing our estimates—the Gini coefficient equaled, of
    course, 0.56 in 1992 and 0.54 in 1993 and 1994\. Had we further decomposed the
    area underneath the curve and then performed additional geometric calculations,
    our function might have then proved more accurate. But more to the point, we’ve
    demonstrated how a user-defined function can be created in R. Let’s now see how
    real Gini coefficients relate to winning and losing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在低估我们的估计——基尼系数当然在 1992 年等于 0.56，在 1993 年和 1994 年等于 0.54。如果我们进一步分解曲线下方的面积并进行额外的几何计算，我们的函数可能会证明更准确。但更重要的是，我们已经展示了如何在
    R 中创建用户定义的函数。现在让我们看看实际的基尼系数如何与胜负相关。
- en: 13.8 Win share inequality and championships
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8 赢分不平等和冠军
- en: Our purpose here is to measure win share inequality grouped by championship-winning
    teams versus all other teams, perform a t-test to determine whether the variance
    in mean Gini coefficients between the groups is statistically significant, and
    then perform a pair of effect size tests around the same. In other words, we’ll
    perform a mix of “old” and “new” tests in the process. However, there are a series
    of data wrangling operations that must be performed first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的目的是通过按冠军球队与其他所有球队分组来衡量赢分不平等，进行 t 检验以确定两组之间平均基尼系数的方差在统计上是否显著，然后围绕同一组进行成对效应量测试。换句话说，我们将在过程中进行“旧”和“新”测试的混合。然而，必须首先执行一系列数据处理操作。
- en: 13.8.1 Wrangling data
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.8.1 数据整理
- en: 'Our next chunk of code reshapes ws_gini2, our working data set before we demonstrated
    `for` loops and user-defined functions, so that individual win shares (`WS`) at
    every year (`Year`) and team (`Tm`) combination become their own columns:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的代码块重新排列了`ws_gini2`，这是我们演示`for`循环和用户定义函数之前的工作数据集，以便每个年份（`Year`）和团队（`Tm`）组合的单独胜利份额（`WS`）成为它们自己的列：
- en: The variable `rank` doesn’t figure into our analysis; it was created only to
    help us subset the data we originally imported. Therefore, we call the `dplyr
    select()` function to subset ws_gini2 on every variable but `rank`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`rank`并不在我们的分析中起作用；它仅被创建来帮助我们子集最初导入的数据。因此，我们调用`dplyr select()`函数来子集`ws_gini2`中的所有变量，除了`rank`。
- en: Then, we pass the ws_gini2 data set to the `dplyr group_by``()`, `mutate``()`,
    and `row_number()` functions to create a new variable called `id`, which is merely
    a column of consecutive numbers with separate and independent sequences for every
    `Year` and `Tm` combination.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`ws_gini2`数据集传递给`dplyr group_by()`、`mutate()`和`row_number()`函数，以创建一个名为`id`的新变量，它仅是一个连续数字的列，每个`Year`和`Tm`组合都有独立的序列。
- en: We then call the `tidyr pivot_wider()` function to transpose the ws_gini2 data
    set from a long format to a wide format where the variable `id` is broken out
    into columns, and the values from the variable `WS` are then used to populate
    the cells in these new columns.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们调用`tidyr pivot_wider()`函数将`ws_gini2`数据集从长格式转换为宽格式，其中变量`id`被拆分为列，然后变量`WS`的值用于填充这些新列中的单元格。
- en: 'The result is a new tibble called ws_gini3\. A call to the base R `head()`
    function returns the first six observations so that you get an idea of what was
    just created. This is just the first step toward prepping our data to join with
    another data set:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个名为`ws_gini3`的新tibble。对基础R的`head()`函数的调用返回前六个观测值，以便你了解刚刚创建的内容。这是将我们的数据准备与另一个数据集合并的第一步：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The numbered columns don’t tie back at all to the variable `rank`; as a matter
    of fact, win shares are now sorted in ascending order from left to right. This
    is fine because the sort, or order, no longer matters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 编号列根本不与变量`rank`相关联；事实上，胜利份额现在是按升序从左到右排序的。这是可以的，因为排序或顺序不再重要。
- en: 'We then call the `names()` function from base R to rename all of the ws_gini3
    column names. That, of course, includes the variables `Year` and `Tm`, which will
    be renamed to `season_end` and `team`, respectively, to sync up with our chapter
    12 data. The `head()` function, of course, returns the first six observations:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从基础R中调用`names()`函数来重命名所有`ws_gini3`列名。当然，这包括变量`Year`和`Tm`，它们将被分别重命名为`season_end`和`team`，以与我们的第12章数据保持一致。`head()`函数当然返回前六个观测值：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, we call the `mutate()` function to create a new variable called `gini_index`,
    which equals the computed Gini coefficient, rounded to two digits right of the
    decimal point, for every `team` and `season_end` combination in the ws_gini3 data
    set. The Gini coefficient is computed by again calling the `ineq()` function from
    the `ineq` package, which takes the variables `ws1` through `ws14` as arguments.
    By setting the `na.rm` argument to `TRUE`, we’re instructing the `ineq()` function
    to skip Not Available (NA) values in our data; if we had instead set it to `FALSE`,
    the `ineq()` function would return `NA` for every `team` and `season_end` combination
    with fewer than 14 win shares.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`mutate()`函数来创建一个名为`gini_index`的新变量，它等于ws_gini3数据集中每个`team`和`season_end`组合计算的基尼系数，四舍五入到小数点后两位。基尼系数是通过再次调用`ineq()`函数从`ineq`包中计算的，该函数将变量`ws1`到`ws14`作为参数。通过将`na.rm`参数设置为`TRUE`，我们指示`ineq()`函数跳过数据中的不可用（NA）值；如果我们将其设置为`FALSE`，则`ineq()`函数将为每个具有少于14个胜利份额的`team`和`season_end`组合返回`NA`。
- en: 'The result is a new tibble called ws_gini4\. The `head()` function prints the
    first six records:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个名为`ws_gini4`的新tibble。`head()`函数打印出前六个记录：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We then make a second call to the `read_csv()` function to import the records.csv
    file stored in our default working directory; this is the same .csv file we imported
    in chapter 12\. We’ll again call it records:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用`read_csv()`函数来导入存储在我们默认工作目录中的`records.csv`文件；这是我们在第12章中导入的相同.csv文件。我们再次将其称为`records`：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The records data set includes regular season wins and losses, regular season
    winning percentage, and a binary variable equal to 0 or 1, where 0 indicates a
    team didn’t win a championship and 1 indicates otherwise. The data set contains
    these records for every NBA season between 1991 and 2018\. Because the data set
    we downloaded from Kaggle goes through 2017, we then call the `dplyr filter()`
    function to subset the records data set where the variable `season_end`, now numeric,
    is less than 2018:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: records 数据集包括常规赛的胜负记录、常规赛胜率以及一个等于 0 或 1 的二进制变量，其中 0 表示一支球队没有赢得冠军，而 1 表示相反。该数据集包含了
    1991 年至 2018 年间每个 NBA 赛季的这些记录。因为从 Kaggle 下载的数据集截止到 2017 年，所以我们调用 `dplyr filter()`
    函数来筛选出变量 `season_end`（现在为数值型）小于 2018 的 records 数据集子集：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we convert the variables `season_end`, `team`, and `champ` (this is the
    binary variable referenced previously) to factor variables by calling the base
    R `as.factor()` function three times. As a reminder, variables should be factors
    if and when they can take on just a finite set of values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过三次调用基础 R 的 `as.factor()` 函数将变量 `season_end`、`team` 和 `champ`（这是之前提到的二进制变量）转换为因子变量。提醒一下，如果变量只能取有限个值，它们应该被转换为因子：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We’re about to join ws_gini4 and records on the like variables `season_end`
    and `team`. However, the variable `team` in ws_gini4 is populated with every team’s
    three-letter abbreviation (e.g, ATL), whereas the variable `team` in records is
    populated with full team names (e.g., Atlanta Hawks). Two calls to the base R
    `levels()` function allow us to cross-check the two:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将在类似变量 `season_end` 和 `team` 上连接 ws_gini4 和 records。然而，ws_gini4 中的变量 `team`
    被填充了每个队伍的三字母缩写（例如，ATL），而 records 中的变量 `team` 被填充了完整的队伍名称（例如，亚特兰大老鹰）。两次调用基础 R 的
    `levels()` 函数允许我们交叉检查这两个变量：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then call the `recode()` function from the `car` package to rename every
    ws_gini4 instance of ATL to Atlanta Hawks, every instance of BOS to Boston Celtics,
    and so on, to align the variable `team` with the same variable in the records
    data set:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `car` 包中的 `recode()` 函数将 ws_gini4 中每个 ATL 实例重命名为亚特兰大老鹰，每个 BOS 实例重命名为波士顿凯尔特人，等等，以使变量
    `team` 与 records 数据集中的相同变量对齐：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that the variable `team` is aligned between ws_gini4 and records, we can
    combine the two objects into a single data set, ws_gini_records, by calling the
    `left_join()` function from the `dplyr` package:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，变量 `team` 在 ws_gini4 和 records 之间已经对齐，我们可以通过调用 `dplyr` 包中的 `left_join()`
    函数将这两个对象合并成一个单一的数据集，即 ws_gini_records：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we make a call to the `dplyr glimpse()` function to return a transposed
    view of the ws_gini_records data set:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `dplyr glimpse()` 函数以返回 ws_gini_records 数据集的转置视图：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The ws_gini_records data set contains 786 rows and 21 columns—786 rows because
    that’s the row count from ws_gini4 and records, and 21 columns because that’s
    the sum of variables between ws_gini4 and records minus the variables `season_end`
    and `team`. Yet we only need a subset of these variables. We therefore call the
    `dplyr select()` function to reduce the ws_gini_records data set to the variables
    `season_end`, `team`, `gini_index`, `wins`, `losses`, `pct`, and `champ`. The
    variables `gini_index` through `champ` occupy the last five positions in ws_gini_records:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ws_gini_records 数据集包含 786 行和 21 列——786 行是因为从 ws_gini4 和 records 中得到的行数，而 21
    列是因为 ws_gini4 和 records 之间变量的总和减去变量 `season_end` 和 `team`。然而，我们只需要这些变量的一部分。因此，我们调用
    `dplyr select()` 函数将 ws_gini_records 数据集缩减到 `season_end`、`team`、`gini_index`、`wins`、`losses`、`pct`
    和 `champ` 这些变量。变量 `gini_index` 到 `champ` 占据 ws_gini_records 的最后五个位置：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, we’ll measure the Gini coefficient for win share distribution grouped
    by the variable champ and then perform our first t-test.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据变量 champ 对赢分分布进行分组，并计算基尼系数，然后执行我们的第一次 t 检验。
- en: 13.8.2 T-test
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.8.2 t 检验
- en: Now that we have a single data set that contains the win shares Gini coefficient
    for every `team` and `season_end` combination between 1991 and 2017, as well as
    records for those same `team` and `season_end` combinations, we can begin our
    test and analysis efforts. It’s never enough to merely compute a pair of group
    means, record the results, and highlight any variance. The difference in means
    may or may not be meaningful; we therefore perform a statistical test to determine
    if the variance is likely due to chance or if it’s more significant than that.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含 1991 年至 2017 年间每个 `team` 和 `season_end` 组合的赢分基尼系数以及这些相同 `team` 和 `season_end`
    组合的记录的单个数据集，我们可以开始我们的测试和分析工作。仅仅计算一对组均值、记录结果并突出任何差异是不够的。平均值之间的差异可能或可能不具有意义；因此，我们进行统计检验以确定方差是否可能由偶然因素引起，或者是否比这更重要。
- en: 'We start with a chunk of `dplyr` code by which the ws_gini_records data set
    is passed to the `group_by``()` and `summarize()` functions. The `summarize()`
    function computes the `gini_index` mean, rounded to two digits right of the decimal
    point, for each level, or factor, in the binary variable `champ`. Our results
    are cast into a tibble called ws_gini_summary2:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一段 `dplyr` 代码，通过该代码将 ws_gini_records 数据集传递给 `group_by()` 和 `summarize()`
    函数。`summarize()` 函数计算二进制变量 `champ` 中每个级别或因子的 `gini_index` 均值，并四舍五入到小数点后两位。我们的结果被转换成一个名为
    ws_gini_summary2 的 tibble：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Championship-winning teams in our data set—one per season between 1991 and 2017,
    or 27 in total—had an average Gini coefficient for win share distribution equal
    to 0.51, while teams that didn’t win a league championship had an average Gini
    coefficient equal to 0.49\. In other words, championship-winning teams between
    1991 and 2017 had more unequal win share distributions than other teams.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中，冠军球队——1991 年至 2017 年每赛季一支，共 27 支——的平均基尼系数为 0.51，而未赢得联赛冠军的球队的基尼系数平均为
    0.49。换句话说，1991 年至 2017 年间，冠军球队的赢分分布比其他球队更不平等。
- en: We’ll conduct a t-test to determine whether this amounts to a statistically
    significant variance. Once more, a t-test is a statistical test that compares
    the means from two data series. It considers the difference in means and the group
    variances in conjunction with the record counts to determine if the variance is
    due to chance and therefore essentially equal to zero or, alternatively, if the
    variance is meaningful and therefore different from zero. If the former, we’ll
    fail to reject the null hypothesis and, in the case of the latter, we’ll reject
    the null hypothesis and instead accept the alternative hypothesis. Our null hypothesis
    here is that Gini coefficients have no effect on who wins or doesn’t win NBA championships.
    We’ll fail to reject the null hypothesis if we get a high p-value, greater than
    our predefined 5% threshold, from our t-test; otherwise, we’ll reject the null
    hypothesis, accept the alternative hypothesis, and conclude that higher Gini coefficients—that
    is, more unequal player productivity—contribute to NBA championships.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行 t 检验以确定这是否构成统计上显著的变化。再次强调，t 检验是一种统计检验，它比较两个数据系列的平均值。它考虑了平均值之间的差异以及组方差，并结合记录数来确定方差是否由偶然因素引起，因此基本上等于零，或者，方差是否有意义，因此与零不同。如果前者，我们将无法拒绝零假设；在后者的情况下，我们将拒绝零假设，并接受备择假设。在这里，我们的零假设是基尼系数对谁赢得或未赢得
    NBA 锦标赛没有影响。如果我们从 t 检验中获得一个高 p 值，大于我们预定义的 5% 阈值，我们将无法拒绝零假设；否则，我们将拒绝零假设，接受备择假设，并得出结论：更高的基尼系数——即更不平等球员生产力——有助于
    NBA 锦标赛。
- en: 'With that in mind, we establish two new data sets, ws_giniX, which is ws_gini_
    records filtered on the variable `champ` equaling `0`, and ws_giniY, which is
    ws_gini_records filtered on the variable `champ` instead equaling `1`. The t-test
    is performed against the ws_gini_records variable `gini_index`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们建立了两个新的数据集，ws_giniX，它是基于变量 `champ` 等于 `0` 的 ws_gini_records 过滤后的结果，以及
    ws_giniY，它是基于变量 `champ` 相反等于 `1` 的 ws_gini_records 过滤后的结果。t 检验是对 ws_gini_records
    变量的 `gini_index` 进行的：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The p-value of our t-test is equal to 0.02, and because it’s below our predefined
    and generally accepted 0.05 threshold for significance, we thus reject the null
    hypothesis that the means are statistically equal, which means the variance is
    statistically significant. In other words, the fact that championship-winning
    teams have more *unequal* win share distributions than all other teams, at least
    between 1991 and 2017, is meaningful. Quite frankly, this flies in the face of
    conventional thought; it’s always been assumed that the most “balanced” and “well-rounded”
    teams are also the most successful teams.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的t检验的p值等于0.02，因为它低于我们预定义的通常接受的显著性阈值0.05，所以我们拒绝均值在统计上相等的零假设，这意味着方差在统计上是显著的。换句话说，冠军队伍比所有其他队伍拥有更多的不平等赢分分布的事实，至少在1991年至2017年之间是有意义的。坦白说，这与传统观念相悖；人们一直认为最“平衡”和“全面”的队伍也是最成功的队伍。
- en: These results are best visualized with a pair of boxplots (see figure 13.5).
    But first, we call the base R `rbind()` function to join the ws_giniX and ws_giniY
    data sets by rows, thereby creating a new object called ws_giniXY in the process.
    Object ws_giniXY is then our data source. Our x-axis variable is the binary variable
    `champ`, and our y-axis variable is `gini_index`. The `scale_x_discrete()` function
    adds the x-axis labels `League Champions` and `All Other Teams` in lieu of `1`
    and `0`, respectively, from the variable `champ`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果最好用一对箱线图来可视化（见图13.5）。但首先，我们调用基础R的`rbind()`函数，通过行将ws_giniX和ws_giniY数据集连接起来，从而在过程中创建了一个名为ws_giniXY的新对象。ws_giniXY对象然后成为我们的数据源。我们的x轴变量是二元变量`champ`，我们的y轴变量是`gini_index`。`scale_x_discrete()`函数将x轴标签`League
    Champions`和`All Other Teams`添加到变量`champ`的`1`和`0`代替。
- en: '![CH13_F05_Sutton](../../OEBPS/Images/CH13_F05_Sutton.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F05_Sutton](../../OEBPS/Images/CH13_F05_Sutton.png)'
- en: Figure 13.5 Paired boxplots that visualize the means, medians, and Gini coefficient
    distributions between championship-winning teams and all other teams
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 对冠军队伍和所有其他队伍之间的均值、中位数和基尼系数分布进行可视化的成对箱线图
- en: The `ggplot()` function automatically draws horizontal lines to represent the
    medians; the `stat_summary()` function adds light dots to represent the means.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ggplot()`函数自动绘制水平线来表示中位数；`stat_summary()`函数添加轻点来表示均值。'
- en: 'Following is our data wrangling and data visualization code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们数据处理和数据处理代码：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There isn’t anything particularly remarkable about displaying the mean of one
    population versus the mean of a second population; however, our boxplots show
    the difference in population medians as well as the difference in distributions,
    where one is clearly less dispersed than the other.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示一个总体均值与另一个总体均值之间的差异方面，并没有什么特别值得注意的；然而，我们的箱线图显示了总体中位数以及分布之间的差异，其中一个的分散程度明显小于另一个。
- en: While t-tests tell us if the variance in two means is equal to zero or nonzero,
    and thus whether or not we should reject a null hypothesis, effect size tests
    tell us how large or not so large the standardized difference is between two distributions.
    We’ll pivot toward effect size testing next. Some of these tests haven’t been
    introduced until now.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当t检验告诉我们两个均值之间的方差是否等于零或非零，从而确定我们是否应该拒绝零假设时，效应大小测试告诉我们两个分布之间的标准化差异有多大或有多小。我们将在下一节转向效应大小测试。其中一些测试直到现在才被介绍。
- en: 13.8.3 Effect size testing
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.8.3 效应大小测试
- en: The most popular, or most common, effect size test is Cohen’s d, which computes
    the difference between two means and divides it by the average standard deviation
    between the same two populations. We’ve performed Cohen’s d tests in prior chapters
    where we’ve also run t-tests.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行或最常见的效应大小测试是Cohen的d，它计算两个均值之间的差异，并将其除以相同两个总体之间的平均标准差。我们在之前章节中已经执行了Cohen的d测试，其中我们也运行了t检验。
- en: 'We next make a call to the `cohen.d()` function from the `effsize` package,
    passing the same pair of arguments we first assigned to our t-test, and we get
    in return a d estimate that quantifies the number of standard deviations that
    one mean is either greater than or lesser than the other mean. The `cohen.d()`
    function takes that d estimate and translates it into a qualitative effect size
    rating equal to negligible, small, medium, or large:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`effsize`包中的`cohen.d()`函数，传递与最初分配给我们的t检验相同的参数对，并得到一个d估计值，该估计值量化了一个均值相对于另一个均值是大于还是小于多少个标准差。`cohen.d()`函数将这个d估计值转换为一个定性效应大小评级，等于可忽略、小、中或大：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: According to our Cohen’s d test, the effect size of the variable `gini_index`
    in ws_giniX versus in ws_giniY is equal to -0.32, which translates to a small
    effect size. The Cohen’s d estimate will be positive or negative depending on
    how we sequenced the arguments when we called the `cohen.d()` function. Here,
    it’s negative because the `gini_index` mean in ws_giniX is less than the `gini_index`
    mean in ws_giniY, and Cohen’s d subtracts the latter from the former.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的Cohen’s d检验，变量`gini_index`在ws_giniX与ws_giniY中的效应量等于-0.32，这表示效应量较小。Cohen’s
    d的估计值将根据我们调用`cohen.d()`函数时参数的顺序是正还是负。在这里，它是负的，因为ws_giniX中的`gini_index`平均值小于ws_giniY中的`gini_index`平均值，而Cohen’s
    d是从后者减去前者。
- en: Think of the numerator as the difference in means that is equal to the effect
    size, which, in turn, equals the signal, and think of the denominator as the average
    (pooled) standard deviation, which equals the noise. So in one sense, Cohen’s
    d returns a signal-to-noise ratio where the farther the coefficient, or d estimate,
    is from 0, the greater the effect size.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将分子视为等于效应量的均值差异，这反过来等于信号，将分母视为平均（合并）标准差，这等于噪声。从某种意义上说，Cohen’s d返回一个信号与噪声的比率，其中系数或d估计值越远离0，效应量就越大。
- en: 'Let’s next run a Cohen’s d test from the `effectsize` package as well as two
    other effect size tests from the same package, Hedges’ g and Glass’s delta, and
    compare and contrast the results. But first, here’s some additional background
    on effect size testing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从`effectsize`包中运行Cohen’s d测试，以及该包中的另外两个效应量测试，Hedges’ g和Glass’s delta，并比较和对比结果。但首先，这里有一些关于效应量测试的附加背景信息：
- en: Once more, Cohen’s d returns an effect size by computing the difference in two
    means and then dividing that by a pooled standard deviation between the two populations.
    Cohen’s d therefore doesn’t consider record counts, which is why we’ve previously
    stated that Cohen’s d is a proper statistical test to *complement* a t-test and
    is thus not a suitable *replacement* for the same. After all, results are more
    likely due to chance when we have, let’s say, just 50 records to evaluate, versus
    5,000 records; a Cohen’s d effect size test wouldn’t recognize that.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，Cohen’s d通过计算两个均值之间的差异，然后除以两个总体之间的合并标准差来返回效应量。因此，Cohen’s d不考虑记录数，这就是我们之前说Cohen’s
    d是补充t检验的适当统计检验，而不是相同检验的替代品的原因。毕竟，当我们只有50条记录来评估时，结果更有可能是由于偶然性，而当我们有5,000条记录时，Cohen’s
    d效应量测试是不会识别出这一点的。
- en: Another reason it’s worth mentioning that Cohen’s d ignores population sizes,
    or record counts, is that Cohen’s d may supply an inflated estimate of the standardized
    difference between two means to its denominator when the population sizes are
    small or if the two population sizes are different. To address this, Hedges’ g
    was introduced as an adjustment to Cohen’s d. Hedges’ g incorporates a correction
    factor to the denominator that accounts for the potential bias in small record
    counts, thereby providing a more accurate estimate of the effect size. It’s an
    appropriate alternative when there are fewer than 20 records. Otherwise, Hedges’
    g works just like Cohen’s d; for example, if Hedges’ g also returned an effect
    size equal to -0.32, we would evaluate that estimate as a small effect.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提及Cohen’s d忽略总体大小或记录数的另一个原因是，当总体大小较小或两个总体大小不同时，Cohen’s d可能向其分母提供一个膨胀的标准化均值差异估计。为了解决这个问题，Hedges’
    g被引入作为对Cohen’s d的调整。Hedges’ g通过在分母中包含一个校正因子来考虑小记录数的潜在偏差，从而提供对效应量的更准确估计。当记录数少于20条时，它是一个合适的替代品；否则，Hedges’
    g的工作方式与Cohen’s d相同；例如，如果Hedges’ g也返回一个效应量等于-0.32，我们将评估该估计为小效应。
- en: Glass’s delta divides the difference in means by the standard deviation of the
    *second* group passed to the `glass_delta()` function instead of a pooled, or
    average, standard deviation between both groups. This means we should expect different
    results if the two standard deviations are different. We still get an effect size
    equal to some number between -1 and +1, which would be evaluated similarly to
    Cohen’s d or Hedges’ g.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Glass’s delta将两组均值之差除以传递给`glass_delta()`函数的第二个组的标准差，而不是两组之间的合并或平均标准差。这意味着如果两个标准差不同，我们应该预期得到不同的结果。我们仍然会得到一个介于-1和+1之间的效应量，这将被类似于Cohen’s
    d或Hedges’ g的方式进行评估。
- en: It might go without saying, but neither Hedges’ g nor Glass’s delta should be
    run in lieu of a t-test; like Cohen’s d, both are only fitting complements to
    a t-test.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不用说，但Hedges的g和Glass的delta都不应该取代t-test；就像Cohen的d一样，它们都是t-test的补充。
- en: 'That all being said, we next make calls to the `cohens_d``()`, `hedges_g``()`,
    and `glass_ delta()` functions in succession:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们接下来依次调用`cohens_d``()`, `hedges_g``()`, 和 `glass_ delta()`函数：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our first, and maybe most obvious, takeaway is that the Cohen’s d test returns
    the same results as our first Cohen’s d test—as it should.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一点，也许是最明显的收获是，Cohen的d测试返回的结果与我们的第一个Cohen的d测试结果相同——正如它应该的那样。
- en: Our second takeaway is that the Hedges’ g results match the Cohen’s d results.
    This isn’t surprising because the Hedges’ g method for effect size is computed
    similarly to Cohen’s d, where the difference in population means is divided by
    the average, or pooled, standard deviation—except that Hedges’ g adds a “correction”
    by factoring counts in the denominator. As such, Hedges’ g is usually recommended
    over Cohen’s d when the population sizes are less than 20\. When both are greater
    than 20 (as shown here), Hedges’ g usually returns the same results as Cohen’s
    d.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个收获是，Hedges的g的结果与Cohen的d的结果相匹配。这并不令人惊讶，因为Hedges的g效应量计算方法与Cohen的d相似，即总体均值之差除以平均或合并的标准差——只不过Hedges的g通过在分母中考虑计数来添加一个“校正”。因此，当总体大小小于20时，通常推荐使用Hedges的g而不是Cohen的d。当两者都大于20（如这里所示）时，Hedges的g通常返回与Cohen的d相同的结果。
- en: Our third, perhaps most significant, takeaway is that the Glass’s delta method
    of effect size returns very different results from our Cohen’s d and Hedges’ g
    tests. Based on the Glass’s delta effect size estimate alone, we would instead
    conclude that the difference in the variable `gini_index` between ws_giniX and
    ws_giniY is medium, rather than small, and therefore more significant than either
    the Cohen’s d and Hedges’ g tests otherwise suggest.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个，也许是最重要的收获是，Glass的delta效应量方法返回的结果与我们的Cohen的d和Hedges的g测试非常不同。仅基于Glass的delta效应量估计，我们就会得出结论说变量`gini_index`在ws_giniX和ws_giniY之间的差异是中等，而不是小，因此比Cohen的d和Hedges的g测试所暗示的更为显著。
- en: 'We’re told to accept the Glass’s delta estimate over Cohen’s d and Hedges’
    g when the standard deviations between the two data series are significantly different.
    The base R `sd()` function returns the standard deviations; here, we front the
    `sd()` function with the `round()` function so that the returned standard deviations
    include two digits right of the decimal point rather than the default seven:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知，当两组数据之间的标准差显著不同时，应该接受Glass的delta估计而不是Cohen的d和Hedges的g。基础R的`sd()`函数返回标准差；在这里，我们在`sd()`函数前面加上`round()`函数，以便返回的标准差包括小数点后两位，而不是默认的七位：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The standard deviation is equal to the square root of the variance, so we could
    also compute the standard deviations by calling the base R `sqrt``()` and `var()`
    functions:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差等于方差的平方根，因此我们也可以通过调用基础R的`sqrt``()`和`var()`函数来计算标准差：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We then make a call to the `var.test()` function from base R to run what’s
    called an F-test. An F-test computes the F statistic, or the ratio of two variances,
    and returns a p-value. The p-value should be evaluated just the same as a p-value
    from other statistical tests:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着调用基础R中的`var.test()`函数来运行所谓的F-test。F-test计算F统计量，即两个方差的比率，并返回一个p值。p值应该像其他统计测试的p值一样进行评估：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because the p-value essentially equals zero, we should reject the null hypothesis
    and conclude that the variances, and therefore the standard deviations, are statistically
    different. So we should therefore accept the Glass’s delta effect size results
    over the Cohen’s d and Hedges’ g results and conclude that the effect size is
    medium instead of small.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因为p值本质上等于零，我们应该拒绝零假设，并得出结论说方差，因此标准差，在统计上是不同的。因此，我们应该接受Glass的delta效应量结果而不是Cohen的d和Hedges的g结果，并得出结论说效应量是中等而不是小。
- en: 'Or should we? Whereas Cohen’s d and Hedges’ g average, or pool, the standard
    deviations from both data series, Glass’s delta takes just the standard deviation
    from the *second* argument as a denominator. Let’s then rerun our effect size
    tests, this time reversing the sequence of the arguments:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们应该这样做吗？虽然Cohen的d和Hedges的g平均或合并了两组数据的标准差，但Glass的delta只将第二个参数的标准差作为分母。那么，我们重新运行我们的效应量测试，这次反转参数的顺序：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This time around, we essentially get the same results across all three effect
    size tests. Therefore, we can confidently settle on the idea that the effect size
    in the variable `gini_index` between the ws_giniX and ws_giniY data sets is small,
    which, of course, is more significant than negligible, but also less so than medium.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在所有三个效应量测试中都得到了相同的结果。因此，我们可以自信地得出结论，变量`gini_index`在ws_giniX和ws_giniY数据集之间的效应量是小的，这当然比可以忽略不计更为重要，但也不如中等重要。
- en: In the next section, we’ll repeat these same tests and compare the Gini coefficient
    on win shares between winning and losing teams.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重复这些相同的测试，并比较胜败球队的胜率之间的基尼系数。
- en: 13.9 Win share inequality and wins and losses
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9 胜率不平等以及胜负情况
- en: There’s no need for further data wrangling, so we’ll jump right in with another
    t-test. Here, we’ll be testing to determine whether or not Gini coefficients on
    win shares matter in regular season winning percentages.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要进行进一步的数据整理，所以我们将直接进行另一个t检验。在这里，我们将测试确定胜率基尼系数在常规赛胜率中是否重要。
- en: 13.9.1 T-test
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.1 t检验
- en: 'We begin by passing the ws_gini_records data set to the `dplyr group_by``()`
    and `summarize()` functions whereby `summarize()` computes the average Gini coefficient,
    rounded to two digits right of the decimal point, and `group_by``()` separates
    the results by winning percentage. Because we’ve included a logical operator inside
    the argument to the `group_by()` function, our results, when passed to a tibble
    called ws_gini_summary3, will therefore be split between `TRUE` and `FALSE`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将ws_gini_records数据集传递给`dplyr group_by()`和`summarize()`函数，其中`summarize()`计算平均基尼系数，四舍五入到小数点后两位，而`group_by()`根据胜率分离结果。因为我们已经在`group_by()`函数的参数中包含了一个逻辑运算符，所以当结果传递给一个名为ws_gini_summary3的tibble时，因此结果将在`TRUE`和`FALSE`之间分割：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Winning teams, on average, have higher Gini coefficients, and therefore more
    unequal win share distributions, than teams with losing records, at least between
    the 1991 and 2017 seasons. The difference is relatively small, but given the record
    counts, probably statistically significant. We’ll run a t-test to find out for
    sure.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利球队的平均基尼系数高于输球球队，因此胜率分布更不平等，至少在1991年至2017赛季之间是这样的。差异相对较小，但考虑到记录数量，可能具有统计学意义。我们将运行t检验以确定这一点。
- en: 'We therefore establish two more data sets: ws_giniA, which is ws_gini_records
    subset where the variable `pct` is equal to or greater than `0.50`, and ws_giniB,
    which is ws_gini_records subset where the variable `pct` is less than `0.50`.
    Our t-test compares the `gini_index` means between ws_giniA, subset on teams between
    1991 and 2017 that won at least half their regular season games, and ws_giniB,
    subset on teams that won fewer than half of their regular season games:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建立了另外两个数据集：ws_giniA，它是ws_gini_records子集，其中变量`pct`等于或大于`0.50`，以及ws_giniB，它是ws_gini_records子集，其中变量`pct`小于`0.50`。我们的t检验比较了ws_giniA（1991年至2017年间至少赢得一半常规赛比赛的球队子集）和ws_giniB（常规赛比赛中赢得少于一半比赛的球队子集）之间的`gini_index`平均值：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The p-value essentially equals 0, so once again, we should reject the null hypothesis
    and conclude that the variance in Gini coefficients is therefore statistically
    significant.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: p值基本上等于0，因此，我们再次应该拒绝零假设，并得出结论，基尼系数的方差因此具有统计学意义。
- en: 'We then produce a pair of `ggplot2` boxplots as a way of visualizing our results
    (see figure 13.6):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过一对`ggplot2`箱形图来可视化我们的结果（见图13.6）：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![CH13_F06_Sutton](../../OEBPS/Images/CH13_F06_Sutton.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F06_Sutton](../../OEBPS/Images/CH13_F06_Sutton.png)'
- en: Figure 13.6 Paired boxplots that visualize the means, medians, and Gini coefficient
    distributions between winning and losing teams
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 显示胜败球队之间均值、中位数和基尼系数分布的成对箱形图
- en: We’ll run a series of effect size tests next.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行一系列效应量测试。
- en: 13.9.2 Effect size testing
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.2 效应量测试
- en: 'In our next chunk of code, we call the `cohens_d``()`, `hedges_g``()`, and
    `glass_delta()` functions from the `effectsize` package:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的代码块中，我们调用来自`effectsize`包的`cohens_d()`、`hedges_g()`和`glass_delta()`函数：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The Cohen’s d and Hedges’ g estimates match one another, but the Glass’s delta
    estimate is marginally different. In any event, these results suggest that the
    effect size in this case is small.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Cohen的d和Hedges的g估计值彼此匹配，但Glass的delta估计值略有不同。无论如何，这些结果表明，在这种情况下，效应量是小的。
- en: Finally, we’ll create bands of winning percentages, as we did in chapter 12,
    and then plot the Gini coefficient for each band. Our point is to determine how
    regular season winning percentages might trend as inequality in player productivity
    increases.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建与第 12 章中相同的胜率区间，然后绘制每个区间的基尼系数。我们的目的是确定常规赛胜率如何随着球员生产力的不平等增加而变化趋势。
- en: 13.10 Gini coefficient bands versus winning percentage
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.10 基尼系数区间与胜率对比
- en: Our first action is to pass the ws_gini_records data set to the `dplyr mutate``()`
    and `case_when()` functions to create a categorical variable called `ws_gini_band`
    derived from the numeric variable `gini_index`. When the variable `gini_index`,
    for instance, is equal to or greater than `0.50`, the derived variable `ws_gini_band`
    will equal `>0.50`; when `gini_index` is greater than or equal to `0.45` and less
    than `0.50`, the derived variable `ws_gini_band` then equals `>0.45`, and so on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是将 ws_gini_records 数据集传递给 `dplyr mutate()` 和 `case_when()` 函数，以创建一个名为
    `ws_gini_band` 的分类变量，该变量是从数值变量 `gini_index` 派生出来的。例如，当变量 `gini_index` 等于或大于 `0.50`
    时，派生变量 `ws_gini_band` 将等于 `>0.50`；当 `gini_index` 大于或等于 `0.45` 且小于 `0.50` 时，派生变量
    `ws_gini_band` 则等于 `>0.45`，依此类推。
- en: We then call the `as.factor()` function to convert `ws_gini_band` to a factor
    variable. The `head()` function returns the first three observations.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用 `as.factor()` 函数将 `ws_gini_band` 转换为因子变量。`head()` 函数返回前三个观测值。
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we pass ws_gini_records to the `dplyr group_by``()` and `summarize()`
    functions, where the `summarize()` function computes the mean of the variable
    `pct`, rounded two digits to the right of the decimal point, and the `group_by()`
    function separates the results by each level, or factor, in the variable `ws_gini_band`.
    The results are cast to a tibble called gini_summary4:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 ws_gini_records 传递给 `dplyr group_by()` 和 `summarize()` 函数，其中 `summarize()`
    函数计算变量 `pct` 的平均值，保留小数点后两位，而 `group_by()` 函数则根据变量 `ws_gini_band` 的每个级别或因子来分隔结果。结果被转换为名为
    gini_summary4 的 tibble。
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that no results are returned where the derived variable `ws_gini_band`
    equals `<0.25`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当派生变量 `ws_gini_band` 等于 `<0.25` 时，没有返回任何结果。
- en: 'Here’s our `ggplot2` bar chart that takes gini_summary4 as a data source and
    plots the variable `ws_gini_band` along the x-axis and the variable `mean_pct`
    along the y-axis (see figure 13.7):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用 gini_summary4 作为数据源并绘制变量 `ws_gini_band` 沿 x 轴和变量 `mean_pct` 沿 y 轴的 `ggplot2`
    条形图（见图 13.7）：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![CH13_F07_Sutton](../../OEBPS/Images/CH13_F07_Sutton.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F07_Sutton](../../OEBPS/Images/CH13_F07_Sutton.png)'
- en: Figure 13.7 A bar chart shows that higher Gini coefficients—that is, more unequal
    win share distributions—are mostly aligned with higher regular season winning
    percentages.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 一条条形图显示，更高的基尼系数——即更不平等的赢分分布——主要与更高的常规赛胜率相一致。
- en: Our bar chart shows that NBA teams between 1991 and 2017 mainly had incremental
    to significant increases in regular season winning percentages with each successive
    bump in Gini coefficient bands—the bands representing the inequality in player
    productivity. We have one anomaly, where the Gini coefficient is greater than
    0.35 and less than 0.40, due to relatively low record counts.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的条形图显示，1991 年至 2017 年间的 NBA 球队，随着基尼系数区间的每个连续增加，常规赛胜率主要呈递增到显著增加的趋势——这些区间代表了球员生产力的不平等。我们有一个异常值，基尼系数大于
    0.35 且小于 0.40，这是由于相对较低的记录计数。
- en: So we’ve demonstrated that the most successful NBA teams, at least between 1991
    and 2017, weren’t the most “balanced” and “well-rounded” teams. Just the opposite,
    in fact. Put differently, we twice rejected our null hypothesis that Gini coefficients
    in win shares have no effect on outcomes, first with respect to league championships
    and then again with respect to regular season winning percentages. In other words,
    we’ve again challenged and contradicted the conventional wisdom. In chapter 14,
    we’ll challenge the idea that defense wins championships.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经证明，至少在 1991 年至 2017 年间，最成功的 NBA 球队并不是最“平衡”和“全面”的球队。事实上，恰恰相反。换句话说，我们两次拒绝了关于赢分中的基尼系数对结果没有影响的零假设，首先是在联赛冠军方面，然后是在常规赛胜率方面。换句话说，我们再次挑战并反驳了传统智慧。在第
    14 章中，我们将挑战“防守赢得冠军”的观点。
- en: In the meantime, hopefully we kept our promise that, despite working with Gini
    coefficients and Lorenz curves one more (and final) time, there was enough new
    statistical, data visualization, and programming material to keep your interest
    throughout. For instance, we learned that there are effect size tests, other than
    Cohen’s d, to complement t-tests; we demonstrated how to run those and even discussed
    under what circumstances which of these tests might best fit. We ran our first
    F-test and reviewed how and when you should pull such a test out of your toolkit
    of statistical tests. We also demonstrated how to create a `for` loop to avoid
    writing repeatable chunks of code and then how to write your own function if R
    doesn’t already have what you need. While not statistical, per se, you need to
    be comfortable with `for` loops and user-defined functions if you want to take
    your R skills to the highest levels.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们希望我们保持了承诺，尽管再次（也是最后一次）与基尼系数和洛伦兹曲线一起工作，但仍有足够的新的统计、数据可视化和编程材料来保持你的兴趣。例如，我们了解到除了Cohen的d值之外，还有其他效应量测试可以补充t检验；我们展示了如何运行这些测试，并讨论了在什么情况下这些测试可能最适合。我们进行了第一次F检验，并回顾了何时以及如何从你的统计测试工具箱中提取这样的测试。我们还展示了如何创建`for`循环以避免编写可重复的代码块，然后如何编写自己的函数，如果R已经有了你需要的功能，那么就不需要这样做。虽然这本身不是统计学的，但如果你想将R技能提升到最高水平，你需要熟悉`for`循环和用户定义的函数。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Statistical dispersion in general and Gini coefficients in particular are important
    concepts to understand in that they have many critical applications. Is there
    an association between city-level income inequality and school performance that
    should figure into funding and resource allocations? Is high income inequality
    correlated with exposure to contagious diseases, and, if so, should Gini coefficients
    drive prevention strategies? From a billing perspective, are there some medical
    procedures that have higher Gini coefficients than others, and if that’s the case,
    are additional regulations in order? Should Gini coefficients in securities returns
    trigger calculations of risk and reward and influence investment decisions?
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计分散性，尤其是基尼系数，是理解的重要概念，因为它们有众多关键应用。城市层面的收入不平等与学校表现之间是否存在关联，这应该纳入资金和资源配置的考量？高收入不平等是否与传染病的暴露相关，如果是这样，基尼系数是否应该驱动预防策略？从账单角度来看，是否存在某些医疗程序比其他程序具有更高的基尼系数，如果是这样，是否需要额外的法规？基尼系数在证券回报中是否应该触发风险和收益的计算并影响投资决策？
- en: In addition, we demonstrated `for` loops as just one way R lets us perform repeatable
    tasks without the repetition, thereby mitigating monotony from a development perspective
    and maintenance from a support perspective. There’s most definitely a huge return
    on investment here for any serious R programmer.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们展示了`for`循环只是R让我们以无重复的方式执行可重复任务的一种方式，从而从开发角度减轻单调性，从支持角度减轻维护性。对于任何严肃的R程序员来说，这里绝对有巨大的投资回报。
- en: We also demonstrated how to create a user-defined function. Even though it seems
    R has more than one function for almost any operation, we nevertheless have the
    ability in R to write our own functions if the need arises.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还展示了如何创建用户定义的函数。尽管R似乎为几乎所有操作都提供了多个函数，但我们仍然有能力在需要时在R中编写自己的函数。
- en: While effect size tests should only complement t-tests (or other like tests
    where we would reject or fail to reject a null hypothesis, such as a chi-square
    test for independence) and never replace them, their meaning and their results
    may actually resonate better with the laymen in your audience.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然效应量测试应该仅补充t检验（或我们可能会拒绝或未能拒绝零假设的其他类似测试，例如独立性卡方检验），但它们的意义和结果实际上可能更符合你听众中的外行人的理解。
- en: Of the effect size tests demonstrated in this chapter (disregarding the Cramer’s
    V tests from chapter 9), Cohen’s d is the most common and the most robust of the
    three. In most instances, Hedges’ g and Cohen’s d will return similar results;
    however, you might want to run a Hedges’ g test when you’re working with just
    a few records. A Glass’s delta test only makes sense if you want to control which
    of two standard deviations should be your effect size denominator, rather than
    it being an average of two standard deviations pooled from two groups.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中展示的效应量测试（不考虑第9章中的Cramer’s V测试），Cohen’s d是最常见且最稳健的。在大多数情况下，Hedges’ g和Cohen’s
    d会返回相似的结果；然而，当你只处理少量记录时，你可能想要运行一个Hedges’ g测试。Glass’s delta测试只有在你想控制两个标准差中的哪一个应该成为你的效应量分母，而不是两个组中两个标准差的平均值时才有意义。
- en: League-wide Gini coefficients around win share distributions are most recently
    down from where they were in the early 1990s.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在联赛中，关于胜利份额分布的Gini系数最近已经从20世纪90年代初的水平下降。
- en: Nevertheless, unequal win share distributions are mostly associated with championship-winning
    teams and teams that win more regular season games than they lose. Conversely,
    win share distributions that are less unequal (they aren’t really equal) are mostly
    associated with losing teams. These results are supported by our t-tests especially
    and our effect size tests. That these results are similar to our results from
    chapter 12 suggest that salaries and productivity are well aligned.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，不平等的胜利份额分布主要与夺冠球队和常规赛胜场数多于败场数的球队相关。相反，不那么不平等的胜利份额分布（它们并不真正相等）主要与输球球队相关。这些结果得到了我们的t检验特别是效应量测试的支持。这些结果与第12章中的结果相似，表明薪资和生产力是良好匹配的。
