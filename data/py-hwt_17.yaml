- en: 12 Logging and exception handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 日志记录和异常处理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Logging to files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志记录到文件
- en: Formatting logs properly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确格式化日志
- en: Handling exceptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Raising exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: When we move our application into production, we temporarily “lose” control
    of our product; we must rely on the product itself to behave. If we’ve been extremely
    careful during the development phase, we may be lucky enough to have a perfect
    product that has no bugs. This almost never happens, however. Thus, we should
    know that a variety of problems, such as an unusual amount of traffic to our web
    app, can occur. Should any problem arise, we don’t panic; we start the problem-solving
    process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将应用程序移入生产环境时，我们暂时“失去”了对产品的控制；我们必须依赖产品本身的行为。如果我们开发阶段非常小心，我们可能非常幸运地拥有一个完美的产品，没有任何错误。然而，这种情况几乎从未发生过。因此，我们应该知道，各种问题，如我们的
    Web 应用程序的不寻常流量，都可能发生。如果出现任何问题，我们不要惊慌；我们开始解决问题的过程。
- en: Sometimes, we don’t have the chance to talk to the users who report the problem,
    and even if we do, the information they provide can be rather limited, which can’t
    help us identify the underlying problems. Fortunately, because we expected that
    problems could arise with our product, our application logs the user’s activities
    and the related application events, which makes it possible for us to study where
    things might have gone wrong. These logging records play an essential role in
    making our product run smoothly by monitoring its performance continuously. Because
    logging is so useful, we should integrate it into our application during development.
    In the meantime, because of user input, we should expect specific exceptions to
    occur. It’s not uncommon, for example, for someone to try to get the result of
    one divided by zero, which causes the ZeroDivisionError exception; we should handle
    this exception properly so that the application will continue to run. In this
    chapter, we study logging and exception handling.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们没有机会与报告问题的用户交谈，即使我们有，他们提供的信息也可能相当有限，这并不能帮助我们识别潜在的问题。幸运的是，因为我们预计我们的产品可能会出现问题，我们的应用程序记录了用户的活动和相关应用程序事件，这使得我们能够研究事情可能出错的地方。这些日志记录在通过持续监控其性能使我们的产品平稳运行方面发挥着至关重要的作用。由于日志记录非常有用，我们应该在开发期间将其集成到我们的应用程序中。同时，由于用户输入，我们应该预料到会发生特定的异常。例如，有人试图获取一个除以零的结果，这会导致
    ZeroDivisionError 异常；我们应该正确处理这个异常，以便应用程序可以继续运行。在本章中，我们研究日志记录和异常处理。
- en: 12.1 How do I monitor my program with logging?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 我如何使用日志记录来监控我的程序？
- en: The most frustrating thing in software development could well be debugging a
    problem that you can’t reproduce. If you’re lucky enough, you may have various
    anecdotal descriptions from some less tech-savvy end users. These descriptions
    may be meaningless, however, as the same problem on the surface can have multiple
    root causes. Thus, it’s common sense that you should set up logging properly to
    monitor the performance of your application before turning it over to end users.
    When a user encounters any problem in a specific module of your application, you
    can pull out the pertinent logging information, and it should take much less time
    to solve the problem. This section introduces the essential features of logging
    in Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中最令人沮丧的事情可能是调试一个无法重现的问题。如果你足够幸运，你可能会有一些不太懂技术的最终用户的各种轶事描述。然而，这些描述可能没有意义，因为表面上相同的问题可能有多个根本原因。因此，常识告诉我们，在将应用程序交给最终用户之前，你应该正确设置日志记录来监控应用程序的性能。当用户在应用程序的特定模块中遇到任何问题时，你可以提取相关的日志信息，解决问题应该会花费更少的时间。本节介绍了
    Python 中日志记录的基本功能。
- en: 12.1.1 Creating the Logger object to log application events
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 创建 Logger 对象以记录应用程序事件
- en: Everything is an object in Python, so it’s not surprising that we use an object
    to log application events. Specifically, the Logger object does the logging for
    us. In this section, you’ll learn about best practices for creating a Logger object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，一切皆对象，因此我们使用对象来记录应用程序事件并不令人惊讶。具体来说，Logger 对象为我们执行日志记录。在本节中，你将了解创建
    Logger 对象的最佳实践。
- en: 'In the standard Python library, the logging module provides the logging functionalities.
    This module has the Logger class, and that class’s constructor takes a name to
    create an instance object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 Python 库中，logging 模块提供了日志记录功能。此模块包含 Logger 类，该类的构造函数接受一个名称来创建一个实例对象：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code snippet creates a Logger object. But are you wondering why I call
    this logger logger_not_good? Before I explain, take a look at the proper way to
    create a Logger object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段创建了一个 `Logger` 对象。但你可能想知道为什么我称这个日志记录器为 `logger_not_good`？在解释之前，先看看创建 `Logger`
    对象的正确方法：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we call the getLogger function by supplying the name of the logger. The
    reason we should use getLogger instead of calling the constructor is that we want
    a shared instance of the Logger class to handle logging. More specifically, in
    an application or in a module, we may want to retrieve the logger in multiple
    places. If we use the constructor, we end up with multiple distinct loggers, as
    in this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过提供日志记录器的名称来调用 `getLogger` 函数。我们应该使用 `getLogger` 而不是调用构造函数的原因是我们想要一个共享的
    `Logger` 类实例来处理日志记录。更具体地说，在一个应用程序或模块中，我们可能想在多个地方检索日志记录器。如果我们使用构造函数，最终会得到多个不同的日志记录器，就像这个例子中所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ You can combine these comparisons in a single comparison by using AND operations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你可以通过使用 AND 操作将这些比较组合成一个单独的比较。
- en: 'You must configure these loggers separately (I discuss configurations in section
    12.2), making sure that they have the same configurations so they’ll work properly.
    There is no reason why you should use multiple loggers for the same module, however;
    only one logger should do the job. As this example shows, using getLogger ensures
    that we always retrieve the same logger:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须分别配置这些日志记录器（我在第 12.2 节中讨论了配置），确保它们有相同的配置，以便它们可以正常工作。没有理由你应该为同一个模块使用多个日志记录器；只有一个日志记录器应该完成这项工作。正如这个例子所示，使用
    `getLogger` 确保我们总是检索到相同的日志记录器：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the is comparisons, you can tell that the logger is the same no matter
    how many times you called getLogger. When it’s the same logger, you can configure
    it once, and it’ll behave the same way throughout its lifecycle during your application’s
    execution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `is` 比较可以知道，无论你调用多少次 `getLogger`，日志记录器都是相同的。当它是同一个日志记录器时，你可以配置一次，在整个应用程序执行的生命周期中，它将以相同的方式表现。
- en: As a best practice, if you’re creating a module-level logger for each module
    in your application, I recommend that you create the logger by running logging.getLogger
    (__name__). __name__ is a special attribute for a module name. When you name the
    module taskier.py, for example, the module’s __name__ attribute is taskier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，如果你在应用程序中的每个模块创建模块级别的日志记录器，我建议你通过运行 `logging.getLogger (__name__)` 来创建日志记录器。`__name__`
    是一个用于模块名的特殊属性。例如，当你将模块命名为 `taskier.py` 时，该模块的 `__name__` 属性是 `taskier`。
- en: Maintainability Always use getLogger to retrieve the same logger for your module
    or application. For module-level loggers, it’s best to use getLogger (__name__)
    to get the logger.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 总是使用 `getLogger` 来获取你的模块或应用程序的相同日志记录器。对于模块级别的日志记录器，最好使用 `getLogger (__name__)`
    来获取日志记录器。
- en: 12.1.2 Using files to store application events
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 使用文件存储应用程序事件
- en: In all the previous chapters, I almost always used the print function to show
    the important messages during the execution of specific code snippets. Suppose
    that we want to make a log when a user creates a task in our task management application.
    The following listing shows a simplified version of the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的章节中，我几乎总是使用 `print` 函数来显示特定代码片段执行期间的重要消息。假设我们想在任务管理应用程序中创建一个用户创建任务的日志。下面的列表显示了代码的简化版本。
- en: Listing 12.1 Creating a log using print
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1 使用 `print` 创建日志
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can print a message after the task is removed successfully. But this approach
    can work only during the active coding phase because the printout message is showing
    up in the Python console. When you submit your application for production, it’s
    almost impossible for you to monitor the printout messages in a continuous manner.
    Thus, a sustainable approach is to store the application events using a permanent
    medium: files. In this section, I’ll show you how to send events to files.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任务成功移除后打印一条消息。但这种方法只能在活跃的编码阶段工作，因为打印的消息会显示在 Python 控制台中。当你提交应用程序进行生产时，几乎不可能以连续的方式监控打印消息。因此，一个可持续的方法是使用永久介质存储应用程序事件：文件。在本节中，我将向你展示如何将事件发送到文件。
- en: Note When you store events in a file, you can examine these events as many times
    as you want; thus, your approach is sustainable. By contrast, if you use the print
    function, the events are sent to the console, and when the console is closed,
    you lose the recorded information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 当你在文件中存储事件时，你可以多次检查这些事件；因此，你的方法是可以持续的。相比之下，如果你使用 `print` 函数，事件将被发送到控制台，当控制台关闭时，你会丢失记录的信息。
- en: We can think of the logger that oversees everything in terms of logging. Thus,
    to log events in a file, we must provide specific configuration to the logger,
    which we do by setting *handlers.* The logging module includes a class called
    FileHandler; we can use this class to specify a file to which the logger should
    save events, as the next listing shows.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将负责记录所有内容的记录器视为一个整体。因此，要记录文件中的事件，我们必须向记录器提供特定的配置，这通过设置 *处理器* 来实现。日志模块包含一个名为
    FileHandler 的类；我们可以使用这个类来指定记录器应保存事件的文件，如下一列表所示。
- en: Listing 12.2 Adding a file handler to the logger
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 向记录器添加文件处理器
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Specifies the file handler
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定文件处理器
- en: ❷ Adds the handler to the logger
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将处理器添加到记录器
- en: As shown in listing 12.2, we specify that we want all the records to go to the
    taskier.log file and associate the file with the logger by calling the addHandler
    method. Notably, after you run this code, you should see that your current directory
    has the taskier.log file. Now that the logger knows where to save the records,
    we’re ready to check out how logging works in the next listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 12.2 所示，我们指定所有记录都应发送到 taskier.log 文件，并通过调用 addHandler 方法将文件与记录器关联起来。值得注意的是，运行此代码后，您应该看到当前目录中存在
    taskier.log 文件。现在记录器知道记录的保存位置，我们准备检查下一列表中日志的工作方式。
- en: Listing 12.3 Writing a record to the log file
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 将记录写入日志文件
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code snippet, we’re writing a warning record by calling logger.warning.
    If we open the taskier.log file, we should be able to see the record.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们通过调用 logger.warning 来写入警告记录。如果我们打开 taskier.log 文件，我们应该能够看到这条记录。
- en: PEEK Each logging message is a log record, which is an instance of the LogRecord
    class. Section 12.2.3 discusses formatting log records.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PEEK 每条日志消息都是一个日志记录，它是 LogRecord 类的实例。第 12.2.3 节讨论了日志记录的格式化。
- en: 'If you prefer a programmatic way to see the record, run the following code.
    You know how to read a text file (section 11.1), right? Please note that I wrote
    a function to check the file content, because we’ll check the log file multiple
    times later, and it’s helpful to have a function for this purpose:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢程序化的方式来查看记录，请运行以下代码。您知道如何读取文本文件（第 11.1 节），对吧？请注意，我编写了一个函数来检查文件内容，因为我们将在以后多次检查日志文件，因此有一个这样的函数很有帮助：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reminder Use the with statement to open a file so that it can close the file
    automatically.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用 with 语句打开文件，以便它可以自动关闭文件。
- en: 'As you can see, we read the entire file, and the content matches what we expected:
    a single record about removing the task from the database.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们读取了整个文件，内容与我们预期相符：一条关于从数据库中删除任务的记录。
- en: 12.1.3 Adding multiple handlers to the logger
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 向记录器添加多个处理器
- en: In section 12.1.2, we saw how to add a file handler to a logger to send log
    records to a file. A logger can have multiple handlers, as we’ll discuss in this
    section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 12.1.2 节中，我们看到了如何向记录器添加文件处理器，以便将日志记录发送到文件。记录器可以有多个处理器，我们将在本节中讨论这一点。
- en: Besides file handlers, the logging module provides stream handlers, which can
    log the records in an interactive console. During the development of the software,
    we can use files to preserve the log records for later reference, but in the meantime,
    we can add a stream handler to the logger so that we can view the records in a
    console for real-time feedback, as in the following listing. This way, we don’t
    need to open or read the log to retrieve the records.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件处理器之外，日志模块还提供了流处理器，可以在交互式控制台中记录记录。在软件开发过程中，我们可以使用文件来保存日志记录以供以后参考，但在此同时，我们可以向记录器添加一个流处理器，以便我们可以在控制台中查看记录，从而实现实时反馈，如下所示。这样，我们就不需要打开或读取日志来检索记录。
- en: Listing 12.4 Using a stream handler with the logger
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 使用记录器与流处理器
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We call the StreamHandler constructor to create a stream handler and add it
    to the logger. When we send a warning log record to the logger, this message gets
    printed in the console. In the meantime, we can check that the same logger also
    records the message in the file handler that we added earlier:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 StreamHandler 构造函数来创建一个流处理器并将其添加到记录器中。当我们向记录器发送警告日志记录时，这条消息会在控制台中打印出来。同时，我们可以检查相同的记录器是否也记录了我们之前添加的文件处理器中的消息：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the log file records the same event as the stream handler. Please
    note that the log file has the record that we entered earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，日志文件记录了与流处理器相同的事件。请注意，日志文件中记录了我们之前输入的内容。
- en: For a logger, you can set more than a file handler and a stream handler. In
    fact, you can set multiple file handlers to the logger. Suppose that you want
    to have two duplicate log files for backup purposes. You can have two file handlers
    for each of the log files. Moreover, you can set different levels for the handlers
    (as discussed in section 12.2.2) and achieve finer control of the handlers in
    terms of what kinds of log records they capture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日志记录器，你可以设置多个文件处理器和流处理器。实际上，你可以为日志记录器设置多个文件处理器。假设你想要为备份目的创建两个重复的日志文件。你可以为每个日志文件设置两个文件处理器。此外，你可以为处理器设置不同的级别（如第
    12.2.2 节所述），从而更精细地控制处理器，以捕获哪些类型的日志记录。
- en: In most cases, we’ll need to use only stream and file handlers. But several
    other kinds of handlers can be handy in specific use cases. Although I’m not going
    to discuss them in detail because they’re not often used, it’s good to know about
    their existence (see [http://mng.bz/E0pD](http://mng.bz/E0pD)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们只需要使用流处理器和文件处理器。但在某些特定用例中，其他几种处理器可能很有用。尽管我不会详细讨论它们，因为它们不常使用，但了解它们的存在是好的（见
    [http://mng.bz/E0pD](http://mng.bz/E0pD)）。
- en: As shown in figure 12.1, we can attach different kinds of handlers to a logger.
    I’ve covered stream and file handlers. Some notable handlers include SMTP handlers,
    which can send log records as an email; HTTP handlers, which can send log records
    to a web server via an HTTP GET or POST request; and Queue handlers, which can
    send log records to a queue, such as one in a different thread.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 12.1 所示，我们可以将不同类型的处理器附加到日志记录器上。我已经介绍了流处理器和文件处理器。一些值得注意的处理器包括 SMTP 处理器，可以将日志记录作为电子邮件发送；HTTP
    处理器，可以通过 HTTP GET 或 POST 请求将日志记录发送到 Web 服务器；以及队列处理器，可以将日志记录发送到队列，例如在另一个线程中的队列。
- en: '![CH12_F01_Cui](../Images/CH12_F01_Cui.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F01_Cui](../Images/CH12_F01_Cui.png)'
- en: Figure 12.1 Common handlers can be attached to a logger. When we create a logger,
    we can instantiate a variety of handlers and attach them to the logger. These
    handlers have their respective intended uses.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 常见处理器可以附加到日志记录器上。当我们创建日志记录器时，我们可以实例化各种处理器并将它们附加到日志记录器上。这些处理器有其各自预定的用途。
- en: 12.1.4 Discussion
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 讨论
- en: We should use files to log important application events so that we can locate
    the necessary information to fix any problems that arise. During the development
    phase, it would be helpful to set a stream handler to the logger so that you can
    view the log records on the console in real time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用文件来记录重要的应用程序事件，这样我们就可以定位到解决任何出现问题的必要信息。在开发阶段，将流处理器设置到日志记录器中会有所帮助，这样你就可以实时在控制台上查看日志记录。
- en: 12.1.5 Challenge
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.5 挑战
- en: John recently started to integrate logging into his project. He knows that he
    can call logging.getLogger(__name__) to retrieve the logger used by the module.
    He runs the code in listing 12.2, which adds a file handler to the logger. If
    he runs the code multiple times, the logger has multiple file handlers, even though
    these file handlers are referring to the same file. When he logs any events, the
    file has duplicate records. How can he update the code in listing 12.2 so that
    it adds the file handler only once? If he does have multiple handlers set to the
    logger, how can he remove them?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰最近开始将日志记录集成到他的项目中。他知道他可以通过调用 logging.getLogger(__name__) 来检索模块使用的日志记录器。他运行了列表
    12.2 中的代码，为日志记录器添加了一个文件处理器。如果他多次运行代码，日志记录器会有多个文件处理器，尽管这些文件处理器都指向同一个文件。当他记录任何事件时，文件会有重复的记录。他应该如何更新列表
    12.2 中的代码，以便只添加一次文件处理器？如果他确实为日志记录器设置了多个处理器，他应该如何移除它们？
- en: Hint 1 A logger has a method called hasHandlers, which you can use to check
    whether a logger has handlers. You can add a handler if the logger doesn’t have
    any.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 1 日志记录器有一个名为 hasHandlers 的方法，你可以使用它来检查日志记录器是否有处理器。如果日志记录器没有任何处理器，你可以添加一个处理器。
- en: Hint 2 You can save a logger’s handlers as a list object, and you can empty
    the list so that the handlers will be removed from the logger.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 2 你可以将日志记录器的处理器保存为列表对象，并且你可以清空列表，这样处理器就会从日志记录器中移除。
- en: 12.2 How do I save log records properly?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 我应该如何正确保存日志记录？
- en: 'Depending on the size of your application, over an extended period of time,
    the log file can accumulate many records, on the magnitude of thousands or millions.
    Checking the records to find needed information can be a real pain. For demonstration
    purposes, I used simple messages for the log records in section 12.1\. For a task
    management application, however, you can expect to see some records like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的大小，在一段较长的时间内，日志文件可能会积累许多记录，数量可能达到数千或数百万。检查这些记录以找到所需信息可能真的非常痛苦。为了演示目的，我在12.1节中使用了简单的消息作为日志记录。然而，对于一个任务管理应用程序，你可能会看到一些这样的记录：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, with minimum formatting (two leading dashes) for the records,
    it’s hard to spot the potential records for a reported problem. Fortunately, we
    can categorize and format the log records to include more information, making
    our debugging experience less painful. In this section, I’ll show you how to save
    log records properly by focusing on using different levels for logging, and I’ll
    show you how to apply formatting to the log records for improved readability.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于记录的格式化（前导两个短横线）最少，很难找到报告问题的潜在记录。幸运的是，我们可以对日志记录进行分类和格式化，以包含更多信息，使我们的调试体验不那么痛苦。在本节中，我将向你展示如何通过关注使用不同的日志级别来正确保存日志记录，并展示如何对日志记录进行格式化以提高可读性。
- en: 12.2.1 Categorizing application events with levels
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 使用级别对应用程序事件进行分类
- en: Not all problems in software have the same level of priority. Some problems
    need to be fixed now, while others can wait. We can apply the same logic to our
    logging system. By using different logging levels, we can highlight the urgency/importance
    of the problems. In listing 12.3, we call logger.warning to write a record, which
    is at the warning level. As this section discusses, there are multiple levels
    higher than a warning, and you’ll learn how file handlers and logging work with
    levels.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中并非所有问题都具有相同的优先级。有些问题需要立即修复，而有些则可以稍后处理。我们可以将相同的逻辑应用到我们的日志系统中。通过使用不同的日志级别，我们可以突出显示问题的紧迫性/重要性。在12.3节中，我们调用logger.warning来写入一个警告级别的记录。正如本节所讨论的，警告级别之上还有多个级别，你将学习如何文件处理程序和日志与级别一起工作。
- en: In Python’s logging module, we have access to five levels (DEBUG, INFO, WARNING,
    ERROR, and CRITICAL) plus a base level (NOTSET), which has a numeric value of
    0 and isn’t typically used. Each level has a numeric value, and the higher the
    value, the more serious the problem. Figure 12.2 shows these levels and the general
    guidelines regarding what records should be captured at each level.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的日志模块中，我们有五个级别（DEBUG、INFO、WARNING、ERROR和CRITICAL）以及一个基本级别（NOTSET），其数值为0，通常不使用。每个级别都有一个数值，数值越高，问题越严重。图12.2显示了这些级别以及关于每个级别应捕获哪些记录的一般指南。
- en: '![CH12_F02_Cui](../Images/CH12_F02_Cui.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F02_Cui](../Images/CH12_F02_Cui.png)'
- en: Figure 12.2 The five levels of logging for different usages. There are five
    logging levels—DEBUG, INFO, WARNING, ERROR, and CRITICAL—with increasing severity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 不同用途的五个日志级别。有五个日志级别——DEBUG、INFO、WARNING、ERROR和CRITICAL，它们的严重性依次增加。
- en: These five levels are defined as integer constants in the logging module; they
    have numeric values from 10 to 50, in increments of 10\. As shown in figure 12.1,
    these levels are intended for different purposes, and you should respect the guidelines
    when you use these levels. But I haven’t talked about how to use these levels.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个级别在日志模块中被定义为整数常量；它们的数值从10到50，以10为增量。如图12.1所示，这些级别旨在用于不同的目的，当你使用这些级别时，应遵守这些指南。但我还没有讨论如何使用这些级别。
- en: 'The first use of the levels is to set the level of a logger. Besides the file
    handlers attribute, a logger has an important attribute called level. When we
    set a specific level, such as INFO, of a logger, all logging records at the level
    of INFO or more serious (meaning WARNING, ERROR, and CRITICAL) will be captured
    by the logger. Let’s see it in action:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些级别的第一个用途是设置记录器的级别。除了文件处理程序属性外，记录器还有一个重要的属性，称为级别。当我们设置记录器的特定级别，如INFO时，所有INFO级别或更严重（意味着WARNING、ERROR和CRITICAL）的日志记录都将被记录器捕获。让我们看看它是如何工作的：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Gets the name for the level
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取级别的名称
- en: In this code snippet, we set the logger with the level of WARNING, and when
    we check the logger’s level, it’s indeed WARNING. With the logger set at a level
    of WARNING, we expect that only warnings, errors, and critical messages will be
    captured by the logger. We can observe this effect in the following listing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们将记录器设置为 WARNING 级别，当我们检查记录器的级别时，它确实是 WARNING。当记录器设置为 WARNING 级别时，我们期望只有警告、错误和关键消息会被记录器捕获。我们可以在下面的列表中观察到这种效果。
- en: Listing 12.5 Logging records at different levels
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5 在不同级别记录记录
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in listing 12.5, we send five messages, each corresponding to the five
    levels. From the printout, you can see that the INFO and DEBUG messages aren’t
    recorded in the log file because the logger is set at the WARNING level.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 12.5 所示，我们发送了五条消息，每条消息对应五个级别。从打印输出中，你可以看到 INFO 和 DEBUG 消息没有被记录在日志文件中，因为记录器被设置为
    WARNING 级别。
- en: As you may have noticed, we use logger.critical to send a critical message,
    logger .error to send an error message, and so on. It’s important to know these
    methods, as we can create log records at different levels. The level settings
    directly determine how the logger will capture records. File handlers can also
    accept level settings, as discussed in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，我们使用 `logger.critical` 发送关键消息，`logger.error` 发送错误消息，等等。了解这些方法很重要，因为我们可以创建不同级别的记录。级别设置直接决定了记录器将如何捕获记录。文件处理器也可以接受级别设置，如下一节所述。
- en: 12.2.2 Setting a handler’s level
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 设置处理器级别
- en: The other use of levels is setting the level of a handler. When we set the level
    of the logger, the level applies at the logger level, which isn’t always desirable.
    A logger can have multiple handlers, and we might apply different levels to these
    handlers so that they can save logging records at their designated levels. This
    section discusses such usage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 级别的另一种用途是设置处理器的级别。当我们设置记录器的级别时，该级别适用于记录器级别，这并不总是期望的。记录器可以有多个处理器，我们可能需要将这些处理器应用于不同的级别，以便它们可以在指定的级别保存记录。本节讨论了这种用法。
- en: Let’s use file handlers as an example. Suppose that our task management application
    has two log files, with one recording WARNING-level records and above, and the
    other recording only CRITICAL records. The next listing shows a possible implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以文件处理器为例。假设我们的任务管理应用程序有两个日志文件，一个记录 WARNING 级别及以上的记录，另一个只记录 CRITICAL 记录。下一个列表显示了可能的实现。
- en: Listing 12.6 Setting levels to individual file handlers
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6 为单个文件处理器设置级别
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Sets the logger’s level to DEBUG
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将记录器的级别设置为 DEBUG
- en: ❷ Adds a handler at the WARNING level
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 WARNING 级别添加处理器
- en: ❸ Adds a handler at the CRITICAL level
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在 CRITICAL 级别添加处理器
- en: As shown in listing 12.6, we first set the logger’s level to DEBUG, which allows
    the logger to catch any message at the DEBUG level or above. To show how we can
    customize the levels at the handler level, I’m adding two file handlers to the
    logger, one at the WARNING level and the other at the CRITICAL level.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 12.6 所示，我们首先将记录器的级别设置为 DEBUG，这允许记录器捕获 DEBUG 级别或以上的任何消息。为了展示我们如何在处理器级别自定义级别，我在记录器中添加了两个文件处理器，一个在
    WARNING 级别，另一个在 CRITICAL 级别。
- en: After we log multiple messages at all levels, we see that each file captures
    the records at their designated levels. The taskier_critical.log file has only
    one CRITICAL record, and the taskier_warning.log file has WARNING, ERROR, and
    CRITICAL messages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们以所有级别记录多个消息之后，我们发现每个文件都捕获了其指定级别的记录。`taskier_critical.log` 文件只有一个 CRITICAL
    记录，而 `taskier_warning.log` 文件有 WARNING、ERROR 和 CRITICAL 消息。
- en: 12.2.3 Setting formats to the handler
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 为处理器设置格式
- en: In the preceding section, you learned about initializing a logger and configuring
    the logger with a file handler and the desired logging level. Another important
    configuration is formatting the log records. Without proper formatting, it’s hard
    to locate the problems. The goal of formatting log records is to highlight the
    key information in each log record, such as the time of the event and the level
    of the message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何初始化一个记录器，并使用文件处理器和所需的记录级别来配置记录器。另一个重要的配置是格式化记录。没有适当的格式化，很难定位问题。格式化记录记录的目标是突出每个记录中的关键信息，例如事件的时间和消息的级别。
- en: Although we could have continued to configure a file handler for formatting,
    we must read the log file to retrieve the log records, which is somewhat inconvenient
    for tutorial purposes. Thus, we’ll use a stream handler instead. The stream handler
    outputs the log records in an interactive console, making it easier to see the
    results (see the following listing).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们本可以继续配置一个文件处理器来进行格式化，但我们必须读取日志文件以检索日志记录，这对于教程目的来说有些不便。因此，我们将使用流处理器。流处理器将日志记录输出到交互式控制台，这使得查看结果更加容易（见以下列表）。
- en: Listing 12.7 Formatting log records for a stream handler
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7 为流处理器格式化日志记录
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Retrieves the logger and sets the level
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取记录器并设置级别
- en: ❷ Removes previously set handlers
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 移除之前设置的处理器
- en: ❸ Creates a formatter
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个格式化器
- en: ❹ Configures the handler with formatter
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用格式化器配置处理器
- en: As shown in listing 12.7, the logging module has the Formatter class, which
    we can use to create an instance for formatting. Please note that the formatter
    uses % style instead of f-strings (section 2.1), per the requirement of the class.
    In essence, the formatter should include the time when the event is recorded,
    the level of the record, and the message. It’s also useful to include the name
    of the module—in our case, the __main__ module, because we run it in an interactive
    console.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表12.7所示，logging模块有一个Formatter类，我们可以用它来创建一个用于格式化的实例。请注意，格式化器使用%样式而不是f-strings（第2.1节），这是根据类的要求。本质上，格式化器应包括事件记录的时间、记录的级别和消息。还包括模块的名称也很有用——在我们的例子中是__main__模块，因为我们是在交互式控制台中运行的。
- en: From the printout records, as you can tell, the readability of the log is much
    improved. It’s much easier for us to focus on records, such as ERROR and CRITICAL,
    because the records include the level. In the meantime, we have the timestamps
    of the events, which we can use to correlate the events with applicable events
    outside our application. If we see many errors at midnight, for example, is that
    because the server is under maintenance at that time?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从打印记录中可以看出，日志的可读性得到了显著提高。由于记录中包含了级别，我们更容易关注记录，例如ERROR和CRITICAL。同时，我们还有事件的日期和时间戳，我们可以使用它们将事件与我们的应用程序之外的相关事件相关联。例如，如果我们看到午夜有很多错误，那是因为服务器在那个时间正在维护吗？
- en: Readability Always format the log records to make it easier to locate pertinent
    problems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 总是格式化日志记录，以便更容易定位相关问题。
- en: 12.2.4 Discussion
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 讨论
- en: By now, you should have a good understanding of how logging works in Python.
    Figure 12.3 illustrates the general workflow of logging.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经很好地理解了Python中日志记录的工作方式。图12.3展示了日志记录的一般工作流程。
- en: '![CH12_F03_Cui](../Images/CH12_F03_Cui.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F03_Cui](../Images/CH12_F03_Cui.png)'
- en: Figure 12.3 The general process of logging. The first step is retrieving the
    logger by calling getLogger. Then (optionally) we can set a level of the logger.
    To log records in a file, we should add a file handler to the logger. We can call
    the corresponding method to record a message at a specific level.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 日志记录的一般过程。第一步是通过调用getLogger获取记录器。然后（可选）我们可以设置记录器的级别。要记录文件中的记录，我们应该向记录器添加一个文件处理器。我们可以调用相应的方法来记录特定级别的消息。
- en: We should be clear about what the five levels are and use them in an expected
    manner. If some functionalities are essential to the normal execution of the software,
    for example, you should log them as CRITICAL when they go wrong. Because a logger
    can log only messages at levels equal to or above the set level, if we want to
    have more-inclusive log records, it’s important to set the logger’s level to INFO
    or DEBUG so that more records can be captured.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该清楚五个级别的含义，并按预期的方式使用它们。例如，如果某些功能对于软件的正常执行至关重要，那么当它们出错时，你应该将它们记录为CRITICAL。因为记录器只能记录等于或高于设置级别的消息，如果我们想有更全面的日志记录，那么将记录器的级别设置为INFO或DEBUG非常重要，这样就可以捕获更多记录。
- en: 12.2.5 Challenge
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 挑战
- en: John is new to event logging in a project. He has realized that he can set levels
    to both the logger and the handler. Suppose that the logger has the level of WARNING,
    and the handler has the level of DEBUG. What happens if he calls logger.info("It's
    an info message.")? Will the handler capture this record?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰是一个新项目中的事件日志记录员。他已经意识到他可以同时设置记录器和处理器的级别。假设记录器的级别是WARNING，而处理器的级别是DEBUG。如果他调用logger.info("It's
    an info message.")会发生什么？处理器会捕获这个记录吗？
- en: Hint The message is checked against the logger’s level before the logger sends
    it to a handler.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 在记录器将消息发送到处理器之前，会检查消息是否与记录器的级别匹配。
- en: 12.3 How do I handle exceptions?
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 我该如何处理异常？
- en: 'When we discussed how to convert strings to obtain their underlying data in
    section 2.2, you learned that some strings represent numbers (such as "1" and
    "2") and that we can call the int constructor with these strings to obtain these
    integer values. Suppose that our task management app has a function that processes
    string data, which represents a row of data in a text file that stores tasks.
    For simplicity, suppose that a task has only title and urgency levels as its attributes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2.2 节中讨论如何将字符串转换为获取其底层数据时，你了解到一些字符串代表数字（例如 "1" 和 "2"），并且我们可以使用这些字符串调用 int
    构造函数来获取这些整数值。假设我们的任务管理应用有一个处理字符串数据的函数，它代表存储在文本文件中的任务的一行数据。为了简单起见，假设一个任务只有标题和紧急程度作为其属性：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Creates a named tuple class
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个命名元组类
- en: ❷ Unpacks the created list object
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解包创建的列表对象
- en: 'In this code snippet, we define the process_task_string0 to process the text
    data and create an instance of the Task class. Everything seems to be fine. But
    what can happen if the text is corrupted as Laundry,3#? Let’s try it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义了 process_task_string0 来处理文本数据并创建 Task 类的实例。一切看起来都很正常。但如果文本被损坏，比如
    Laundry,3#，会发生什么呢？让我们试试看：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can’t convert 3# to a valid integer by calling int("3#"), which leads to
    the ValueError exception.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能通过调用 int("3#") 将 3# 转换为有效的整数，这会导致 ValueError 异常。
- en: On many occasions, we can’t assume things will go as we expect, particularly
    when dealing with blocks of code that require specific input to work. The int
    constructor, for example, requires an integer or a string representing an integer
    value. In such a case, we should handle the potential ValueError exception during
    the development phase, preventing the error from stopping our application during
    its run time. This section discusses the key aspects of exception handling in
    Python.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们不能假设事情会像我们预期的那样进行，尤其是在处理需要特定输入才能工作的代码块时。例如，int 构造函数需要一个整数或表示整数值的字符串。在这种情况下，我们应该在开发阶段处理潜在的
    ValueError 异常，以防止错误在运行时停止我们的应用程序。本节讨论了 Python 中异常处理的关键方面。
- en: 12.3.1 Handling exceptions with try. . .except. . .
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 使用 try...except... 处理异常
- en: When exceptions such as ValueError happen, your application stops running (unless
    the exception handled as discussed in this section). This phenomenon—when software
    stops execution abruptly—is commonly known as a *crash.* Software can crash in
    different ways, some of which are outside the control of the software itself,
    such as when the computer runs out of memory. When we expect that running a block
    of code could result in specific exceptions, for example, we should account for
    this possibility by handling the exceptions properly to prevent the application
    from crashing. In this section, we’ll see the basic code blocks for exception
    handling.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生 ValueError 等异常时，你的应用程序会停止运行（除非本节讨论的异常被处理）。这种现象——当软件突然停止执行时——通常被称为 *崩溃*。软件可以通过不同的方式崩溃，其中一些是软件本身无法控制的，例如当计算机内存不足时。当我们预期运行一段代码可能会引发特定的异常时，例如，我们应该通过正确处理异常来考虑这种可能性，以防止应用程序崩溃。在本节中，我们将看到异常处理的基本代码块。
- en: '*Exceptions**,* or *errors,* are a general concept in all programming languages.
    The standard way to handle exceptions in Python is to use the try...except...
    block. Many other languages use try...catch... blocks. Figure 12.4 shows the general
    workflow of the try...except... statement.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常* 或 *错误* 是所有编程语言中的一个通用概念。在 Python 中处理异常的标准方式是使用 try...except... 块。许多其他语言使用
    try...catch... 块。图 12.4 显示了 try...except... 语句的一般工作流程。'
- en: '![CH12_F04_Cui](../Images/CH12_F04_Cui.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F04_Cui](../Images/CH12_F04_Cui.png)'
- en: Figure 12.4 The workflow of a try...except statement. We include the code that
    potentially raises an exception in the try clause. When such an exception is raised,
    the except clause gets executed, and execution moves to the code outside the statement.
    If no exception is raised when the code in the try clause is executed, Python
    skips the except clause.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 try...except 语句的工作流程。我们将可能引发异常的代码包含在 try 子句中。当引发此类异常时，except 子句将被执行，执行将移动到语句外的代码。如果执行
    try 子句中的代码时没有引发异常，Python 将跳过 except 子句。
- en: As shown in figure 12.4, Python tries to execute the code in the try clause.
    If everything works well, it skips the except clause and continues to run the
    code outside the try...except statement. If an exception does occur, the except
    clause gets executed, and any code in the try clause following the code that raises
    the exception is skipped too. The next listing shows an example of how try...except...
    works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如图12.4所示，Python试图执行try子句中的代码。如果一切顺利，它将跳过except子句并继续执行try...except语句之外的代码。如果发生异常，except子句将被执行，并且try子句中引发异常之后的任何代码也将被跳过。下一个列表显示了try...except...是如何工作的示例。
- en: Listing 12.8 Using try...except in a function
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 在函数中使用try...except
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Peek Don’t use a bare except statement. See section 12.3.2.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：不要使用裸except语句。参见12.3.2节。
- en: In listing 12.8, the process_task_string1 function includes the try...except...
    statement. Specifically, in the try clause, we include code that potentially raises
    an exception—in this case, the casting of the urgency_str to an integer. As an
    important note, we don’t want to fill the try clause with lots of code because
    it makes it hard to know which code can lead to an exception.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12.8中，process_task_string1函数包含了try...except...语句。具体来说，在try子句中，我们包含了可能引发异常的代码——在这种情况下，将urgency_str转换为整数。作为一个重要的注意事项，我们不希望try子句中包含大量代码，因为这会使我们难以知道哪些代码可能导致异常。
- en: Readability The try clause should include only the code that can raise an exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：try子句应仅包含可能引发异常的代码。
- en: 'For simplicity and demonstration purposes, the except clause includes calling
    the print function. It’s important to know that the except clause gets executed
    only if an exception is caught. We can observe this effect in the following code
    snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单和演示目的，except子句中包含了调用print函数。重要的是要知道，只有当捕获到异常时，except子句才会被执行。我们可以在以下代码片段中观察到这种效果：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We return None in the except clause, and we can verify it by comparing processed_
    task1 with None. If the execution of the try clause doesn’t raise any exception,
    the except clause is skipped, and the code outside the try...except... statement
    continues to execute:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在except子句中返回None，并且可以通过比较processed_task1与None来验证它。如果try子句的执行没有引发任何异常，except子句将被跳过，并且try...except...语句之外的代码将继续执行：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: QUESTION Do you think the comparison works with custom class objects instead
    of a named tuple class like Task in this example?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：你认为在这个例子中，使用自定义类对象而不是像Task这样的命名元组类进行比较是否可行？
- en: As you can see, when task_text0 contains the proper data to construct an instance
    of the Task class, everything works as it does in the process_task_string0 function,
    as though the try...except... statement doesn’t exist in process_task_string1!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当task_text0包含构建Task类实例所需的数据时，一切都会像process_task_string0函数中那样正常工作，就像try...except...语句在process_task_string1中不存在一样！
- en: 12.3.2 Specifying the exception in the except clause
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 在except子句中指定异常
- en: In listing 12.8, the except clause uses a bare except by the keyword itself.
    I don’t recommend this usage, however. Instead, the except clause allows us to
    specify what exception we’re handling in the clause. As covered in this section,
    we should be explicit about the exception to catch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12.8中，except子句通过关键字本身使用裸except。然而，我不推荐这种用法。相反，except子句允许我们指定在子句中处理的异常。正如本节所述，我们应该明确指出要捕获的异常。
- en: 'Specifying the exception is necessary; otherwise, the bare except clause will
    catch all the exceptions, even those that you don’t expect. Suppose that we have
    a pending task that is to be updated after casting the level of urgency:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 指定异常是必要的；否则，裸except子句将捕获所有异常，甚至是你不期望的异常。假设我们有一个待处理的任务，在将紧急程度转换为级别后需要更新：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note We typically minimize the code in the try clause. I included an extra line
    of code that results in an exception for teaching purposes only to illustrate
    the fact that we may have to handle multiple exceptions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们通常尽量减少try子句中的代码。我为了教学目的添加了一行会导致异常的额外代码，以说明我们可能需要处理多个异常。
- en: 'The preceding try clause has an extra line of code: pending_task.urgency =
    urgency. You may have realized that this code would result in a NameError exception
    because we never define a variable with this name, and it’s not available in any
    namespace. Observe this effect in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的try子句中有一行额外的代码：pending_task.urgency = urgency。你可能已经意识到，这段代码会导致NameError异常，因为我们从未定义过具有此名称的变量，它也不在任何命名空间中可用。在以下代码片段中观察这一效果：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thus, when we call process_task_string2, we could have both ValueError and
    NameError exceptions, and the bare except will handle both exceptions without
    any differentiation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们调用process_task_string2时，我们可能会有ValueError和NameError异常，裸except将无差别地处理这两个异常：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We should expect task_text0 to get processed without any problems, and we should
    get a casted urgency level of 3. But the printout message suggests that the number
    couldn’t be casted, suggesting that something is wrong with the casting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该预期task_text0能够无任何问题地被处理，并且我们应该得到一个转换后的urgency级别为3。但是打印信息表明数字无法转换，这表明转换过程中可能存在问题。
- en: To avoid ambiguity, never use a bare except; instead, be explicit about the
    exception. In this case, we already know that ValueError is possible; thus, we
    specify this exception following the except keyword. This clause gets executed
    if the ValueError exception is raised because the try clause ran, as the next
    listing shows.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免歧义，永远不要使用裸except；相反，要明确指定异常。在这种情况下，我们已经知道ValueError是可能的；因此，我们在except关键字后指定这个异常。如果try子句运行，并且引发了ValueError异常，这个子句将被执行，如下面的列表所示。
- en: Listing 12.9 Specifying the exception
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 指定异常
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the updated function, the code shows the printout message only if a ValueError
    exception is caught:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的函数，只有在捕获到ValueError异常时，代码才会显示打印信息：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because the int constructor can’t cast "3#" to an integer, the ValueError exception
    is handled as expected. Note that when we call this function with a string that
    is expected to produce a correct instance of Task, we should still see a NameError
    because we don’t have code to handle it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为int构造函数无法将"3#"转换为整数，所以ValueError异常被按预期处理。注意，当我们用预期产生正确的Task实例的字符串调用此函数时，我们仍然应该看到NameError，因为我们没有代码来处理它：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 12.3.3 Handling multiple exceptions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 处理多个异常
- en: We know that code executes linearly, and after the casting operation int(urgency_
    str), the execution continues to pending_task.urgency = urgency, which should
    raise a NameError exception. As of now, that exception is not handled. We can
    handle multiple exceptions in the try...except... statement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道代码是线性执行的，在执行int(urgency_str)类型转换操作后，执行继续到pending_task.urgency = urgency，这应该引发一个NameError异常。到目前为止，这个异常没有被处理。我们可以在try...except...语句中处理多个异常。
- en: We have two ways to handle multiple exceptions. When the exceptions are unrelated,
    we should use multiple except clauses, with each except handling a distinct kind
    of exception, as shown in the following listing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理多个异常的方法。当异常不相关时，我们应该使用多个except子句，每个except处理一种不同的异常，如下面的列表所示。
- en: Listing 12.10 Using multiple except clauses
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.10 使用多个except子句
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As shown in listing 12.10, we update the function by adding an extra except
    clause that handles the potential NameError exception.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表12.10所示，我们通过添加一个额外的except子句来更新函数，该子句处理潜在的NameError异常。
- en: Note Our code includes these seemingly “silly” mistakes for demonstration purposes.
    Some of the mistakes pertain to the quality of the code itself, and these mistakes
    should be fixed by changing the code instead of handling the exception.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们的代码包含这些看似“愚蠢”的错误是为了演示目的。其中一些错误与代码本身的质量有关，这些错误应该通过更改代码而不是处理异常来修复。
- en: 'With this update, we can verify that this exception is handled, as shown by
    the printout message:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次更新，我们可以验证这个异常是否被处理，如下面的打印信息所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Maintainability Use separate except clauses for exceptions that are unrelated.
    If the exceptions are semantically related, you can group them by using a single
    except clause. If you prefer, however, you can still handle these exceptions separately.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 维护性：对于不相关的异常，使用单独的except子句。如果异常在语义上是相关的，可以使用单个except子句将它们分组。然而，如果你愿意，仍然可以单独处理这些异常。
- en: Besides using multiple except clauses, you can specify multiple exceptions in
    a single except clause to handle multiple exceptions. The next listing shows an
    example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用多个except子句外，你还可以在单个except子句中指定多个异常来处理多个异常。下面的列表显示了示例。
- en: Listing 12.11 Multiple exceptions in an except clause
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11 except子句中的多个异常
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we list both exceptions as a tuple object in a single except
    clause. This way, if either exception is caught, the same except clause gets executed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将两个异常作为一个元组对象列在单个except子句中。这样，如果捕获到任一异常，相同的except子句将被执行：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Expect the NameError.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预期NameError异常。
- en: ❷ Expect the ValueError.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 预期ValueError异常。
- en: We tried two different strings, with "Laundry,3" raising the NameError exception
    and "Laundry,3#" raising the ValueError exception. Please note that when an exception
    is caught, the execution jumps to the except clause. In the latter case, when
    running int(urgency_str) raises the ValueError, we wouldn’t expect the NameError
    too.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了两种不同的字符串，使用 "Laundry,3" 会引发 NameError 异常，而使用 "Laundry,3#" 会引发 ValueError
    异常。请注意，当捕获到异常时，执行会跳转到 except 子句。在后一种情况下，当运行 int(urgency_str) 引发 ValueError 时，我们不会期望出现
    NameError。
- en: 12.3.4 Showing more information about an exception
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 显示异常的更多信息
- en: The except clause handles the specified exception when such an exception is
    caught. In the code examples that I’ve used so far, I’ve printed out messages
    as feedback on the exception. But these messages lack details about the exceptions,
    and I could show users more specific information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: except 子句在捕获到指定的异常时处理该异常。在我之前使用的代码示例中，我已经打印出消息作为异常的反馈。但是，这些消息缺乏有关异常的详细信息，我可以向用户提供更具体的信息。
- en: To obtain more information about an exception that is caught, we can assign
    the exception to a variable, using the except SpecificException as var_name syntax.
    We can update our function to take advantage of this feature as shown in the next
    listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取捕获到的异常的更多信息，我们可以使用 except SpecificException as var_name 语法将异常分配给一个变量。我们可以更新我们的函数以利用此功能，如下一列表所示。
- en: Listing 12.12 Creating a variable from the exception
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12 从异常创建变量
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As highlighted in listing 12.12, we assign the caught ValueError exception
    as ex so that we can use this variable in the clause. For simplicity, we’ll print
    out only the ValueError exception:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 12.12 所示，我们将捕获到的 ValueError 异常分配给 ex，以便我们可以在子句中使用这个变量。为了简单起见，我们将只打印出 ValueError
    异常：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the message, we know that the casting fails because "3#" can’t be converted
    to an integer number. Please note that I call the print function to show a detailed
    description of the exception for teaching purposes. For a frontend application,
    such as the task management app, we can display a WARNING message to notify users
    of this mistake, and they can correct it accordingly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从消息中，我们知道转换失败是因为 "3#" 不能转换为整数。请注意，我调用 print 函数是为了教学目的，显示异常的详细描述。对于前端应用程序，例如任务管理应用程序，我们可以显示一个
    WARNING 消息来通知用户这个错误，他们可以相应地纠正它。
- en: 12.3.5 Discussion
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.5 讨论
- en: Handling exceptions properly is key to improving the user’s experience with
    your applications. We can’t overlook the consequences of exceptions; they’ll crash
    your applications when they’re not handled properly. Thus, during the development
    phase of our applications, we should be cautious about code that can easily go
    wrong. Don’t be concerned about using try...except... statements in code. Although
    they may appear to lengthen the code, they make applications more robust; they
    can still run even when exceptions occur because they’re handled properly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理异常是提高用户应用体验的关键。我们不能忽视异常的后果；如果未正确处理，它们将使您的应用程序崩溃。因此，在应用程序的开发阶段，我们应该对可能出错代码保持谨慎。不要担心在代码中使用
    try...except... 语句。尽管它们可能看起来会延长代码，但它们使应用程序更加健壮；即使发生异常，它们仍然可以运行，因为它们得到了适当的处理。
- en: 12.3.6 Challenge
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.6 挑战
- en: Bob is an experienced programmer who uses best practices in his code. He understands
    that when he writes a try...except... statement, he should be explicit about the
    exact exceptions that he’s handling. Many kinds of exceptions exist. How can he
    find out which exception is appropriate for a specific use case during the development
    phase? In listing 12.9, for example, how can he know that he needs to handle a
    possible ValueError exception?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 是一位经验丰富的程序员，他在代码中遵循最佳实践。他明白，当他编写 try...except... 语句时，他应该明确他正在处理的精确异常。存在许多种类的异常。他在开发阶段如何找出适用于特定用例的适当异常呢？例如，在列表
    12.9 中，他如何知道需要处理可能的 ValueError 异常？
- en: Hint Besides looking up information about exceptions in the official Python
    documentation, you can run the potentially problematic code to see what exceptions
    you’re getting; then you can handle them accordingly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：除了在官方 Python 文档中查找有关异常的信息外，您还可以运行可能存在问题的代码以查看您正在获取哪些异常；然后您可以相应地处理它们。
- en: 12.4 How do I use else and finally clauses in exception handling?
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 如何在异常处理中使用 else 和 finally 子句？
- en: 'The most basic form of handling exceptions in Python is using the try...except...
    statement. This statement consists of one try clause and at least one except clause.
    The following example is part of listing 12.12:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中处理异常的最基本形式是使用 try...except... 语句。这个语句由一个 try 子句和至少一个 except 子句组成。以下示例是列表
    12.12 的一部分：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We know that the code task = Task(title, urgency) runs after the try...except...
    statement. Notably, the except clause includes a return statement (return None).
    If I didn’t include it, we would encounter the UnboundLocalError exception due
    to running task = Task(title, urgency) without defining urgency in the except
    clause. But we know that the code task = Task(title, urgency) is relevant only
    if the code in the try clause runs without raising exceptions. Is there a better
    way to make clear that we want some code to run only if there are no exceptions?
    This question leads to the topic of the next section: adding an else clause to
    the try...except... statement. Section 12.4.2 discusses the finally clause, another
    optional component in the full try...except... statement.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道代码 task = Task(title, urgency) 在 try...except... 语句之后运行。值得注意的是，except 子句包含一个返回语句（return
    None）。如果我没有包含它，由于在 except 子句中没有定义 urgency，运行 task = Task(title, urgency) 将会引发
    UnboundLocalError 异常。但我们知道，代码 task = Task(title, urgency) 仅在 try 子句中的代码没有引发异常时才相关。有没有更好的方法来明确我们只想在没有异常的情况下运行某些代码？这个问题引出了下一节的主题：向
    try...except... 语句添加 else 子句。12.4.2 节讨论了 finally 子句，这是完整 try...except... 语句中的另一个可选组件。
- en: 12.4.1 Using else to continue the logic of the code in the try clause
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 使用 else 继续在 try 子句中的代码逻辑
- en: In section 12.3, I mentioned that it’s critical to minimize the length of the
    try clause by including only the code that can raise exceptions. When the try
    clause completes its execution, Python runs the code after the try...except...
    statement. The code after the statement, however, makes sense only if executing
    the code in the try clause doesn’t raise any exceptions. To implement this feature,
    we should use the else clause on top of the try and except clauses.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 12.3 节中，我提到最小化 try 子句的长度是至关重要的，只包含可能引发异常的代码。当 try 子句完成执行后，Python 将运行 try...except...
    语句之后的代码。然而，语句之后的代码只有在 try 子句中的代码没有引发任何异常时才有意义。为了实现这个功能，我们应该在 try 和 except 子句之上使用
    else 子句。
- en: In the try...except... statement, the try keyword means that we’re going to
    try some code that may raise exceptions, and the except keyword means that we’re
    going to handle the exceptions we’re catching. How about the term else? This name
    may sound confusing. (What *else*?) To understand it, we must acknowledge that
    the entire try...except...else... statement aims to handle exceptions. More specifically,
    one objective is to catch such exceptions. Thus, it makes sense to say that if
    we can catch the exception, we’ll handle it; otherwise, we’ll continue execution.
    The else clause does the job for the “otherwise” portion. The next listing shows
    an example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 try...except... 语句中，try 关键字意味着我们将尝试执行可能引发异常的代码，而 except 关键字意味着我们将处理我们捕获到的异常。那么术语
    else 呢？这个名字可能听起来有些令人困惑。（还有什么 *else*？）为了理解它，我们必须承认整个 try...except...else... 语句的目的是处理异常。更具体地说，一个目标就是捕获这样的异常。因此，如果我们能够捕获异常，我们将处理它；否则，我们将继续执行。else
    子句负责“否则”部分的工作。下面的列表显示了示例。
- en: Listing 12.13 Adding the else clause to the try...except statement
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13 向 try...except 语句添加 else 子句
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ You can omit this optional return None statement.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你可以省略这个可选的返回 None 语句。
- en: 'As shown in listing 12.13, we include an else clause after the except clause.
    In the else clause, we create an instance object of the Task class (defined at
    the beginning of section 12.3) using title and urgency. We should expect to obtain
    an instance object if we don’t have the ValueError exception:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 12.13 所示，我们在 except 子句之后包含一个 else 子句。在 else 子句中，我们使用标题和紧急程度创建 Task 类（在 12.3
    节开头定义）的实例对象。如果我们没有 ValueError 异常，我们应该期望获得一个实例对象：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As shown in this code snippet, we obtain an instance class of the Task class,
    which suggests that the code in the else clause executes successfully. What happens
    when a ValueError exception is raised? Observe the result:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们获得了 Task 类的实例类，这表明 else 子句中的代码执行成功。当引发 ValueError 异常时会发生什么？观察结果：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first thing to note is that the except clause executes because of the caught
    ValueError exception. The other thing to note is that the return value of calling
    process_ task_string7 is None, which suggests that the code in the else clause
    doesn’t run when the except clause runs and returns None.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，异常处理子句执行是因为捕获到的`ValueError`异常。另一件要注意的事情是，调用`process_task_string7`函数的返回值是`None`，这表明当异常处理子句运行并返回`None`时，else子句中的代码并没有执行。
- en: 12.4.2 Cleaning up the exception handling with the finally clause
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 使用finally子句清理异常处理
- en: As you saw in section 12.4.1, only one of the except and else clauses runs.
    If the try clause raises exceptions, the except clause (handled exceptions) runs;
    if the try clause raises no exceptions, the else clause runs. Sometimes, however,
    we have some code that we’d like to run regardless of the exception status. In
    the function that processes the task string, for example, we may want to notify
    users that the processing has been done, whether or not it was successful. That
    task is exactly what the finally clause can do, as we’ll see in this section.
    Figure 12.5 provides a graphic overview of the four possible clauses in exception
    handling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在12.4.1节中看到的，except和else子句中只有一个会运行。如果try子句抛出异常，except子句（处理异常）会运行；如果try子句没有抛出异常，else子句会运行。然而，有时我们有一些无论异常状态如何都希望运行的代码。例如，在处理任务字符串的函数中，我们可能希望通知用户处理已完成，无论是否成功。这正是finally子句所能完成的任务，正如我们将在本节中看到的那样。图12.5提供了异常处理中四个可能子句的图形概述。
- en: '![CH12_F05_Cui](../Images/CH12_F05_Cui.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F05_Cui](../Images/CH12_F05_Cui.png)'
- en: Figure 12.5 The four clauses in a complete try...except...else...finally...
    statement. The try clause includes the code that could raise an exception. The
    except clause includes the code that handles the possible exception. The else
    clause runs only if no exceptions are raised. The finally clause runs after the
    except clause or the else clause.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 完整的try...except...else...finally...语句中的四个子句。try子句包括可能抛出异常的代码。except子句包括处理可能异常的代码。else子句仅在未抛出异常的情况下运行。finally子句在except子句或else子句之后运行。
- en: As indicated by its name, the finally clause should be placed at the end of
    the try...except... statement (figure 12.5). If you use an else clause, the finally
    clause should follow it; otherwise, it follows the except clause. The code in
    the finally clause runs no matter what the exception-raising status is. The next
    listing shows how finally works by continuing the example of processing a string
    that stores a task’s data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，finally子句应该放在try...except...语句的末尾（图12.5）。如果你使用else子句，finally子句应该跟在其后；否则，它跟在except子句后面。无论异常抛出的状态如何，finally子句中的代码都会执行。下面的列表展示了finally是如何通过继续处理存储任务数据的字符串的例子来工作的。
- en: Listing 12.14 Using the finally clause in the try...except statement
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.14 在try...except语句中使用finally子句
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In listing 12.14, we add the finally clause to the try...except... statement.
    For simplicity, we print out a message showing that the processing is done. This
    finally clause should run whether or not the ValueError exception is raised:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12.14中，我们将finally子句添加到try...except...语句中。为了简单起见，我们打印出一个消息，显示处理已完成。这个finally子句应该在是否抛出`ValueError`异常的情况下都运行：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In both invocations of the process_task_string8 function, we see that the finally
    clause executes by printing out the f-string message. You may wonder what the
    point of using the finally clause is. If it’s going to run regardless of exception
    status, why don’t we place it outside the try...except... statement? Because we
    know that code typically executes linearly, by placing it outside the statement,
    we guarantee that it will follow the except or else clause.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`process_task_string8`函数的两次调用中，我们可以看到finally子句通过打印f-string消息来执行。你可能想知道使用finally子句的目的是什么。如果它无论异常状态如何都会运行，为什么我们不将其放在try...except...语句之外？因为我们知道代码通常按线性方式执行，通过将其放在语句之外，我们保证它将跟随except或else子句。
- en: 'As you may notice, I used the word *typically* because an atypical rule applies
    to the finally clause. If the try clause reaches a break, continue, or return
    statement, the finally clause runs before executing the break, continue, or return
    statement. This rule is necessary to ensure that the code in the finally clause
    runs, because in a typical scenario, these statements end the current execution
    and skip the remaining code. We can observe this effect in the following example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我使用了“通常”这个词，因为finally子句有一个不典型的规则。如果try子句遇到break、continue或return语句，finally子句会在执行break、continue或return语句之前运行。这个规则是必要的，以确保finally子句中的代码执行，因为在典型场景中，这些语句会结束当前执行并跳过剩余的代码。我们可以在以下示例中观察到这种效果：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As highlighted in the code snippet, we include a return statement in the try
    clause. Unlike in other scenarios, the return statement ends a function’s execution
    immediately. Here, we see that the print function is called in the finally clause,
    supporting our earlier notion that the finally clause runs regardless of the exception
    status and even if the try or except clause contains a return statement. Because
    a finally clause executes whether or not an exception is raised, we often use
    a finally clause when we deal with shared resources, such as files and network
    connections. We want to release those resources (in the finally clause) whether
    or not the desired operation is done (in the try clause) or an exception is raised
    (in the except clause).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码片段所示，我们在try子句中包含了一个返回语句。与其它场景不同，返回语句会立即结束函数的执行。在这里，我们看到在finally子句中调用了print函数，这支持了我们之前的观点，即finally子句无论异常状态如何都会执行，即使try或except子句中包含返回语句。因为finally子句无论是否抛出异常都会执行，所以我们经常在处理共享资源，如文件和网络连接时使用finally子句。我们希望在try子句中完成所需操作（或抛出异常）的情况下，都能在finally子句中释放这些资源。
- en: 12.4.3 Discussion
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3 讨论
- en: Of the four clauses in the exception handling feature, you should always use
    try and except because they constitute the fundamentals of handling an exception.
    The try clause “tries” to run the code, as it may raise exceptions, and the except
    clause catches and handles the exceptions. Although the else and finally clauses
    are optional, they have their use cases, which you should know.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理功能的四个子句中，你应该始终使用try和except，因为它们构成了处理异常的基础。try子句“尝试”执行代码，因为它可能会抛出异常，而except子句则捕获并处理这些异常。尽管else和finally子句是可选的，但它们有自己的用例，你应该了解。
- en: 12.4.4 Challenge
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.4 挑战
- en: We know that in the presence of the finally clause, if the try clause includes
    a return statement, it still runs the code in the finally clause before running
    the return statement in the try clause. What’s the return value of calling the
    process_ task_challenge function in the following example?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在finally子句存在的情况下，如果try子句中包含返回语句，它仍然会在try子句中的返回语句之前运行finally子句中的代码。以下示例中调用process_
    task_challenge函数的返回值是什么？
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Hint Because the code in the finally clause runs before the return statement
    in the try clause, it ends the function immediately, as the finally clause includes
    a return statement itself. The return statement in the try clause is skipped.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：因为finally子句中的代码在try子句中的返回语句之前运行，所以它会立即结束函数，因为finally子句本身包含一个返回语句。try子句中的返回语句将被跳过。
- en: 12.5 How do I raise informative exceptions with custom exception classes?
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 如何使用自定义异常类抛出有信息的异常？
- en: 'When we learn to program in Python, we make various kinds of mistakes. Some
    errors are due to syntax errors, such as missing the colon in the if...else...
    statement. When we have a basic understanding of all the syntaxes, we may encounter
    other errors related mostly to the correct use of specific features from a semantic
    or logical perspective. As extensively used in sections 12.3 and 12.4, ValueError
    is such an error. As another example, when we try to divide a number by zero,
    we encounter the ZeroDivisionError:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习用Python编程时，会犯各种各样的错误。一些错误是由于语法错误造成的，比如在if...else...语句中缺少冒号。当我们对所有语法有了基本理解后，可能会遇到其他错误，这些错误主要与从语义或逻辑角度正确使用特定功能有关。正如在第12.3节和第12.4节中广泛使用的那样，ValueError就是这样的错误。作为另一个例子，当我们尝试将一个数除以零时，我们会遇到ZeroDivisionError：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In both cases, the error message not only tells us the specific exception name,
    but also supplies a description of the error, which helps us figure out what we
    did incorrectly. When we’re creating a library or package for other developers
    to use, it’s important to display a proper error message to users so that they
    know how to debug their code or handle the exception. In this section, you’ll
    learn how to raise informative exceptions with custom exception classes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，错误消息不仅告诉我们具体的异常名称，还提供了错误描述，这有助于我们找出我们做错了什么。当我们为其他开发者创建库或包时，向用户显示适当的错误消息非常重要，这样他们才知道如何调试代码或处理异常。在本节中，你将学习如何使用自定义异常类引发信息丰富的异常。
- en: 12.5.1 Raising exceptions with a custom message
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.1 使用自定义消息引发异常
- en: So far, we’ve seen the exceptions raised when Python evaluates our code. We
    haven’t learned how to raise exceptions ourselves, however. In this section, I’ll
    show how we can raise exceptions and how to provide custom messages for exceptions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 Python 评估我们的代码时引发的异常。然而，我们还没有学习如何自己引发异常。在本节中，我将展示我们如何引发异常以及如何为异常提供自定义消息。
- en: Concept When we “produce” an exception in the code to indicate some problems,
    we say that we *raise* an exception. Some other languages use *throw* for this
    purpose.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 当我们在代码中“产生”异常以指示某些问题时，我们说我们 *引发* 异常。一些其他语言使用 *throw* 来实现这个目的。
- en: 'I’ve been using *raise* to state that some code produces an exception. Not
    surprisingly, raise is a keyword in Python for raising exceptions. When we run
    the following code in the console, we should also see the traceback:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在使用 *raise* 来表示某些代码产生了异常。不出所料，raise 是 Python 中引发异常的关键字。当我们运行以下代码到控制台时，我们也应该看到
    traceback：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We raise an exception by using the format raise ExceptionClass. ValueError and
    ZeroDivisionError are two exception classes. Strictly speaking, when we raise
    an exception, we’re raising an instance object of the exception class; thus, the
    format of this example is syntactic sugar for raise ExceptionClass(), in which
    ExceptionClass() creates an instance object of the class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用格式 raise ExceptionClass 来引发异常。ValueError 和 ZeroDivisionError 是两个异常类。严格来说，当我们引发异常时，我们是在引发异常类的实例对象；因此，此示例的格式是
    raise ExceptionClass() 的语法糖，其中 ExceptionClass() 创建了一个类的实例对象。
- en: concept In programming, *syntactic sugar* refers to usages that are simple but
    perform the same operations as counterparts that are more complicated.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 在编程中，*语法糖* 指的是简单但执行与更复杂对应操作相同的用法。
- en: 'It’s also true that when we handle an exception, we’re dealing with an instance
    of an exception class. Observe the effect in this example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们处理异常时，我们正在处理异常类的实例。观察以下示例的效果：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As shown in this example, we know that 1 / 0 leads to raising the ZeroDivisionError
    exception, and we handle it in the except clause. From the printout message, we
    know that the raised exception is indeed an instance object of the ZeroDivisionError
    class.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们知道 1 / 0 会引发 ZeroDivisionError 异常，并在 except 子句中处理它。从打印的消息中，我们知道引发的异常确实是
    ZeroDivisionError 类的实例对象。
- en: 'Running raise ValueError doesn’t seem to be useful. If you recall, when we
    call int("3#"), the error message explicitly tells us the cause of this exception:
    ValueError: invalid literal for int() with base 10: '' 3#''. To supply a custom
    message to the exception, we use the format raise ExceptionClass("custom message").
    A few examples follow:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '运行 raise ValueError 似乎没有用。如果你还记得，当我们调用 int("3#") 时，错误消息明确告诉我们这个异常的原因：ValueError:
    invalid literal for int() with base 10: '' 3#''。要向异常提供自定义消息，我们使用格式 raise ExceptionClass("custom
    message")。以下是一些示例：'
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Uses the repr !r conversion to make a string within quotes
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 repr !r 转换来生成引号内的字符串
- en: When we supply a custom message to the exception class constructor, the raised
    exception is accompanied by the message, which informs users of the details of
    the exception. Please note that this message should be concise; we don’t want
    to overwhelm users with a chunky description that may only confuse them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向异常类构造函数提供自定义消息时，引发的异常会附带该消息，通知用户异常的详细信息。请注意，此消息应简短；我们不希望用一大段可能只会使他们困惑的描述来压倒用户。
- en: Readability When you supply custom messages to an exception class, be concise.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 当你向异常类提供自定义消息时，要简洁。
- en: 12.5.2 Preferring built-in exception classes
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.2 优先使用内置异常类
- en: When we discussed data models in the early chapters, you learned about the built-in
    data types, such as str (chapter 2), list, and tuple (chapter 3) before you learned
    about custom classes (chapters 8 and 9). The reason for this order is that built-in
    data types are the most basic form for representing data, and all Python programmers
    understand them well. We can apply the same philosophy to exceptions. When we
    need to raise exceptions, we prefer using built-in exception types.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论早期章节中的数据模型时，你在学习自定义类（第 8 章和第 9 章）之前，学习了内置数据类型，如 str（第 2 章）、list 和 tuple（第
    3 章）。这种顺序的原因是内置数据类型是表示数据的最基本形式，所有 Python 程序员都很好地理解它们。我们可以将同样的哲学应用到异常上。当我们需要抛出异常时，我们更喜欢使用内置异常类型。
- en: We know that exceptions are raised by creating instance objects from exception
    classes. Thus, to use built-in exception classes, we need to know the most common
    ones. Don’t be afraid of not knowing them; everyone who’s learning to code makes
    all kinds of mistakes that raise exceptions. You’ll gradually learn which exception
    is associated with what errors in your code. Figure 12.6 provides an overview
    of common exceptions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，异常是通过从异常类创建实例对象来引发的。因此，要使用内置异常类，我们需要了解最常见的那些。不要害怕不知道它们；每个学习编码的人都会犯各种错误，从而引发异常。你将逐渐学会你的代码中哪种异常与哪种错误相关联。图
    12.6 提供了常见异常的概述。
- en: '![CH12_F06_Cui](../Images/CH12_F06_Cui.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F06_Cui](../Images/CH12_F06_Cui.png)'
- en: Figure 12.6 The common built-in exception classes. The BaseException class is
    the superclass for all other exception classes. Most exception classes that we
    interact with are subclasses of the Exception class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 常见的内置异常类。BaseException 类是所有其他异常类的超类。我们与之交互的大多数异常类都是 Exception 类的子类。
- en: BaseException is the base class for all built-in exceptions, including system-exiting
    exceptions such as KeyboardInterrupt and SystemExit. As a rule, we should not
    inherit this class to define our own custom exception classes; instead, we should
    use the Exception class (see section 12.5.3) to avoid catching system-exiting
    exceptions. Common exception classes that we’ve encountered, such as ValueError
    and NameError, are direct or indirect subclasses of the Exception class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: BaseException 是所有内置异常的基类，包括如 KeyboardInterrupt 和 SystemExit 这样的系统退出异常。一般来说，我们不应该从这个类继承来定义我们自己的自定义异常类；相反，我们应该使用
    Exception 类（见 12.5.3 节）来避免捕获系统退出异常。我们遇到的一些常见异常类，如 ValueError 和 NameError，是 Exception
    类的直接或间接子类。
- en: 'Although it’s not difficult to define custom exception classes, when we think
    of raising an exception, we should first consider the built-in exception classes
    because they’re better known by ordinary developers. Consider a simple example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然定义自定义异常类并不困难，但当我们想到抛出异常时，我们应该首先考虑内置异常类，因为它们更被普通开发者所熟知。考虑一个简单的例子：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this code snippet, we define the Task class with a title attribute, which
    is a string. As of now, we don’t force users to use a str object to instantiate
    the Task class. If we do want to enforce this requirement, we can include type
    checking in our code and raise an exception when the supplied argument isn’t a
    str object, as shown in the next listing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义了一个具有标题属性的任务类，该属性是一个字符串。目前，我们没有强制用户使用字符串对象来实例化任务类。如果我们确实想强制这一要求，我们可以在代码中包含类型检查，并在提供的参数不是字符串对象时抛出异常，如下一个列表所示。
- en: Listing 12.15 Creating a class that raises an exception in its constructor
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15 在构造函数中抛出异常的类创建
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By using the built-in TypeError in listing 12.15, we make it easier for users
    to understand that they used a wrong type for the argument.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用列表 12.15 中的内置 TypeError，我们使用户更容易理解他们为参数使用了错误的数据类型。
- en: Readability Prefer using built-in exception classes when you raise exceptions,
    as they’re more familiar to users.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：在抛出异常时，优先使用内置异常类，因为它们对用户来说更熟悉。
- en: 12.5.3 Defining custom exception classes
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.3 定义自定义异常类
- en: When you create your own Python package, it’s common to define custom exception
    classes if the built-in ones can’t meet your needs. In this section, I’ll show
    you the best practices for defining custom exception classes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的 Python 包时，如果内置的异常类不能满足你的需求，定义自定义异常类是很常见的。在本节中，我将向你展示定义自定义异常类的最佳实践。
- en: As mentioned briefly in section 12.5.2, our custom exception classes should
    inherit from the Exception class. For a custom package, the best practice is to
    create a base exception class for your package and then create additional exception
    classes by inheriting your base exception class. Creating a base exception for
    your package allows users to handle all the exceptions of your package, should
    such a need arise.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第12.5.2节简要提到的，我们的自定义异常类应该继承自Exception类。对于自定义包，最佳实践是为您的包创建一个基本异常类，然后通过继承基本类创建额外的异常类。为您的包创建基本异常允许用户在需要时处理所有包的异常。
- en: 'Create a base exception class for your package if you need to define your own
    custom exception classes, which should inherit from the base class. Suppose that
    for the task management app, we’re making the app a package that other developers
    can use to build their own apps. They can use the Task class as the data model
    to build another app by using a different frontend library, for example. For this
    package, which might be named taskier, we can define a base exception class named
    TaskierError:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要定义自己的自定义异常类，请为您的包创建一个基本异常类，这些类应继承自基本类。假设对于任务管理应用，我们正在将其构建为一个其他开发者可以使用的包，以便他们可以使用Task类作为数据模型，通过使用不同的前端库来构建另一个应用。对于这个可能被命名为taskier的包，我们可以定义一个名为TaskierError的基本异常类：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this package-specific base exception class, we don’t need to have any implementation
    details. We can simply use a pass statement to fulfill the syntax requirement.
    (A class’s body can’t be empty.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定于包的基本异常类中，我们不需要有任何实现细节。我们可以简单地使用pass语句来满足语法要求。（类体不能为空。）
- en: For the taskier package, we can define more specific exception classes. We can
    allow the users to upload a CSV file from their computers to retrieve the data
    from multiple tasks, for example. The following listing defines an exception requiring
    the file to have the .csv extension.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务包，我们可以定义更具体的异常类。例如，我们可以允许用户从他们的电脑上传CSV文件以从多个任务中检索数据。以下列表定义了一个要求文件具有.csv扩展名的异常。
- en: Listing 12.16 Defining a custom exception class
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.16 定义自定义异常类
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice two significant things in listing 12.16:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表12.16中的两个重要事项：
- en: '*The custom exception class can take additional arguments for instantiation.*
    Here, we include the file_path argument (note that the message for creating an
    exception is optional) because we want to show readers that the file at the specified
    path isn’t in the correct form.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义异常类可以接受额外的实例化参数。* 这里，我们包括file_path参数（注意创建异常的消息是可选的），因为我们想向读者展示指定路径上的文件不是正确的格式。'
- en: '*We override the* __str__ *method.* As you may recall from section 8.4, this
    method is called when we print an instance object.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们重写了* __str__ *方法。* 如您从第8.4节回忆起来，这个方法在我们打印实例对象时被调用。'
- en: In another part of our package, we use this exception class. As shown in the
    preceding code, the upload_file function checks the file’s extension (section
    11.5) and raises the exception when the extension is incorrect.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们包的另一个部分，我们使用这个异常类。如前述代码所示，upload_file函数检查文件的扩展名（第11.5节）并在扩展名不正确时引发异常。
- en: 'When another developer uses our package, they may build a control widget, allowing
    users to upload a file. They may have the following functionality in their app:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他开发者使用我们的包时，他们可能会构建一个控件小部件，允许用户上传文件。他们的应用可能具有以下功能：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this example, we call the custom function with two different types of files:
    CSV files and Microsoft Word document files. As you can see, when we don’t use
    the correct file, the except clause catches the FileExtensionError and prints
    the message that we implement in the __str__ class.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用两种不同类型的文件调用自定义函数：CSV文件和Microsoft Word文档文件。如您所见，当我们不使用正确的文件时，except子句会捕获FileExtensionError并打印我们在__str__类中实现的错误消息。
- en: We can define additional custom exception classes in our package if necessary.
    We can define an exception class called FileFormatError to use when the file doesn’t
    contain the desired data, for example. As another example, we can define an exception
    class called InputArgumentError to use when developers use wrong arguments for
    critical functions. Both classes should inherit the TaskierError. Figure 12.7
    shows the hierarchy of exception classes in a custom package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以在我们的包中定义额外的自定义异常类。例如，我们可以定义一个名为FileFormatError的异常类，用于文件不包含所需数据时使用。作为另一个例子，我们可以定义一个名为InputArgumentError的异常类，用于开发者在关键函数中使用错误的参数时使用。这两个类都应该继承自TaskierError。图12.7显示了自定义包中异常类的层次结构。
- en: '![CH12_F07_Cui](../Images/CH12_F07_Cui.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F07_Cui](../Images/CH12_F07_Cui.png)'
- en: Figure 12.7 The hierarchy of custom exception classes in a custom package. We
    create a package-specific base exception class by inheriting the Exception class.
    From this base class, we can define multiple exception classes that raise specific
    exceptions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 自定义包中自定义异常类的层次结构。我们通过继承Exception类创建一个特定于包的基本异常类。从这个基类出发，我们可以定义多个异常类，以引发特定的异常。
- en: 12.5.4 Discussion
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.4 讨论
- en: Although you can define custom exception classes to raise informative exceptions,
    you should prefer using the built-in exception classes whenever possible. If you’re
    creating a custom package or library, however, you may find that it makes more
    sense to create your own custom exception classes to produce more specific error
    messages, thus helping the users of the package (developers) debug the problems.
    Notably, you should define a package-specific base exception class first. These
    custom exception classes behave like regular custom classes, and you can override
    special methods such as __str__ if necessary.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以定义自定义异常类来引发信息丰富的异常，但尽可能使用内置异常类。然而，如果你正在创建自定义包或库，你可能发现创建自己的自定义异常类来生成更具体的错误消息更有意义，从而帮助包的用户（开发者）调试问题。值得注意的是，你应该首先定义一个特定于包的基本异常类。这些自定义异常类的行为类似于常规的自定义类，如果需要，你可以覆盖特殊方法，如__str__。
- en: 12.5.5 Challenge
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.5 挑战
- en: In listing 12.15, the Task class can raise the TypeError exception in its constructor.
    Can you write some code that handles this exception by using the try...except...
    else...finally... statement?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12.15中，Task类可以在其构造函数中引发TypeError异常。你能编写一些代码，通过使用try...except...else...finally...语句来处理这个异常吗？
- en: Hint You should call the constructor in the try clause and handle the possible
    TypeError exception.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你应该在try子句中调用构造函数，并处理可能出现的TypeError异常。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: It’s best practice to call getLogger to retrieve the logger for your module,
    which guarantees that you obtain the same logger instead of creating multiple
    ones.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践是调用getLogger来检索你模块的记录器，这保证了你获得的是同一个记录器而不是创建多个。
- en: For long-term storage purposes, it’s common to attach a file handler to a logger
    so that log records can be saved to files.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了长期存储目的，通常会将文件处理器附加到记录器上，以便将日志记录保存到文件中。
- en: During the development phase, it’s helpful to show the logs in a console. You
    can also add a stream handler to the logger.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发阶段，显示日志在控制台中有助于调试。你还可以将流处理器添加到记录器中。
- en: 'To better track the severity of log records, you should categorize those records
    with different levels: DEBUG, INFO, WARNING, ERROR, and CRITICAL.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更好地跟踪日志记录的严重性，你应该将这些记录按不同级别进行分类：DEBUG、INFO、WARNING、ERROR 和 CRITICAL。
- en: You can set the logger and the handlers with a proper logging level so that
    they track records at the desired level.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过设置适当的日志级别来设置记录器和处理器，以便它们跟踪所需级别的记录。
- en: For readability, it’s always a good idea to format the log records. Key information
    includes the timestamp, the level of severity, the applicable module, and the
    message.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高可读性，格式化日志记录始终是一个好主意。关键信息包括时间戳、严重级别、适用模块和消息。
- en: The try...except... statement is the basic format for handling exceptions in
    Python. The try clause should include only the code that can raise exceptions.
    You should be explicit about the exceptions that you’re handling in the except
    clause.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: try...except...语句是Python中处理异常的基本格式。try子句应仅包含可能引发异常的代码。你应该在except子句中明确指出你正在处理的异常。
- en: Although you can bundle multiple exceptions as a tuple object in a single except
    clause, I recommend that you use multiple except clauses instead of one except
    clause—unless the exceptions are indeed closely related.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然您可以在单个 except 子句中将多个异常作为一个元组对象捆绑起来，但我建议您使用多个 except 子句而不是一个 except 子句——除非这些异常确实非常相关。
- en: The else clause runs when the try clause doesn’t raise exceptions. The finally
    clause can be used to clean up exception handling; it runs no matter whether an
    exception is raised in the try clause.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 try 子句没有引发异常时，else 子句会执行。finally 子句可以用来清理异常处理；无论 try 子句中是否引发了异常，它都会执行。
- en: You can raise exceptions by using the built-in exception classes and supply
    custom messages to these exceptions to be more informative.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用内置的异常类来引发异常，并向这些异常提供自定义消息以使其更具信息性。
- en: When you define custom exception classes, remember that you should inherit the
    Exception class but not the BaseException class.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您定义自定义异常类时，请记住您应该继承自 Exception 类，而不是 BaseException 类。
- en: If your package includes custom exception classes, it’s best practice to define
    a package-specific base exception class from which you define additional custom
    exception subclasses.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的包中包含自定义异常类，最佳实践是从其中定义额外的自定义异常子类的包特定基异常类。
