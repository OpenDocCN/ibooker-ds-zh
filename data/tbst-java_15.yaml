- en: 12 Investigating apps’ behaviors in large systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 调查大型系统中的应用程序行为
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Investigating app communication issues
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查应用程序通信问题
- en: Using log-monitoring tools in your system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的系统中使用日志监控工具
- en: Taking advantage of deployment tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用部署工具
- en: In this chapter, we go beyond the border of a single app and discuss how to
    investigate situations caused by apps working together in systems. Today, many
    systems are composed of multiple apps that communicate with one another. Large
    business systems leverage various apps, and they are often implemented with different
    technologies and on different platforms. In many cases, the maturity of these
    apps also varies from new services to old and messy scripts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将超越单个应用程序的边界，讨论如何调查由系统中的应用程序协同工作引起的情况。如今，许多系统由多个相互通信的应用程序组成。大型商业系统利用各种应用程序，并且它们通常使用不同的技术和平台实现。在许多情况下，这些应用程序的成熟度也各不相同，从新服务到旧的和混乱的脚本。
- en: Debugging, profiling, and logs aren’t always enough. Sometimes you need to find
    bigger clues. An app can work well independently but not correctly integrate with
    other apps or the environment it’s deployed into.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 调试、性能分析和日志记录并不总是足够。有时您需要找到更大的线索。一个应用程序可以独立工作得很好，但不能正确地与其他应用程序或其部署的环境集成。
- en: We’ll start in section 12.1 with ways to investigate communication between the
    services of a system. In section 12.2, we’ll focus our attention on the relevance
    of implementing monitoring for apps in a system and how to use the information
    a monitoring tool provides. We’ll end this chapter’s discussion in section 12.3,
    where we’ll discuss how to take advantage of deployment tools.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从12.1节开始，介绍调查系统服务之间通信的方法。在12.2节中，我们将关注在系统中实施应用程序监控的相关性以及如何使用监控工具提供的信息。我们将在12.3节结束本章的讨论，我们将讨论如何利用部署工具。
- en: 12.1 Investigating communication between services
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 调查服务之间的通信
- en: In this section, we discuss investigating communication between apps. In a system,
    apps “talk” to one another to fulfill their responsibilities. Thus far, we have
    focused on investigating the interior workings of an app and the communication
    between an app and a database management system. But what about apps that talk
    to one another? Is there a way to monitor the events throughout an entire system
    composed of many apps (figure 12.1)?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论调查应用程序之间的通信。在一个系统中，应用程序“交谈”以履行其职责。到目前为止，我们一直专注于调查应用程序的内部工作原理以及应用程序与数据库管理系统之间的通信。但对于相互交谈的应用程序呢？是否有方法来监控由许多应用程序组成的整个系统中的事件（图12.1）？
- en: '![](../../OEBPS/Images/CH12_F01_Spilca3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1](../../OEBPS/Images/CH12_F01_Spilca3.png)'
- en: Figure 12.1 In many cases, an investigation stays within the boundaries of an
    app. But you may need to go beyond what happens inside a given process. Issues
    or strange behavior can be caused by apps that have problems communicating with
    each other, and implementing a monitoring tool will make investigating these types
    of issues easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 在许多情况下，调查停留在应用程序的边界内。但您可能需要超越给定进程内部发生的事情。问题或异常行为可能是由存在通信问题的问题应用程序引起的，实现监控工具将使调查这类问题更容易。
- en: Let’s discuss how to use a profiling tool to investigate issues regarding how
    apps “talk” to each other. We’ll use JProfiler to observe communication for a
    simple app (project da-ch12-ex1) to expose an endpoint you can call (`/demo` endpoint).
    When you send an HTTP request to this endpoint, the app sends a request to an
    endpoint exposed by [httpbin.org](http://httpbin.org/), which delays the response
    for 5 seconds and then responds with a 200 OK HTTP status.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何使用性能分析工具来调查应用程序之间“交流”的问题。我们将使用JProfiler来观察一个简单应用程序（项目da-ch12-ex1）的通信，以暴露一个您可以调用的端点（`/demo`端点）。当您向此端点发送HTTP请求时，应用程序会向由[httpbin.org](http://httpbin.org/)提供的端点发送请求，该端点延迟5秒后以200
    OK HTTP状态响应。
- en: As you’ll learn in this section, JProfiler offers a set of tools you can use
    to observe both the requests an app receives and the requests an app sends. Moreover,
    you can investigate low-level communication events on sockets. Such approaches
    can help you to identify the root cause of communication problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本节中将学到的，JProfiler提供了一套您可以用来观察应用程序接收到的请求和发送的请求的工具。此外，您还可以调查套接字上的低级通信事件。这些方法可以帮助您确定通信问题的根本原因。
- en: In section 12.1.1, we’ll use JProfiler to observe the requests an app receives.
    In section 12.1.2, we’ll investigate details about the requests an app sends,
    and in section 12.1.3, we’ll focus on investigating low-level communication events
    on sockets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在12.1.1节中，我们将使用JProfiler观察应用程序接收到的请求。在12.1.2节中，我们将调查应用程序发送的请求的详细信息，而在12.1.3节中，我们将专注于调查套接字上的低级通信事件。
- en: Microservices
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务
- en: 'Let’s talk frankly about microservices. Many systems you’ll work on claim they
    are microservices. Most often this is not true; they are simply service-oriented
    architectures. Microservices have become (for some reason I can’t say I fully
    understand) a brand that sells quite well:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坦率地谈谈微服务。你将要工作的许多系统声称它们是微服务。大多数情况下这并不真实；它们只是面向服务的架构。微服务已经（出于某种原因，我无法完全理解）成为了一个卖得相当好的品牌：
- en: Do you want to employ someone faster? Tell them they’re going to work with microservices.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要更快地雇佣某人吗？告诉他们他们将使用微服务工作。
- en: Do you want to impress a customer during a presales meeting? Tell them you do
    microservices.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在销售前会议中给客户留下深刻印象吗？告诉他们你做微服务。
- en: 'Do you want more people to attend your presentation? You guessed it: just add
    microservices in the title.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要更多的人参加你的演示吗？没错：只需在标题中添加微服务。
- en: 'But microservices are more difficult than what I feel the majority of developers
    understand. You’ll find plenty of literature out there if you want to better understand
    what microservices are. You can start with *Microservices Patterns* by Chris Richardson
    (Manning, 2018) and then read *Monolith to Microservices* by Sam Newman (O’Reilly
    Media, 2018) or *Building Microservices: Designing Fine-Grained Systems*, second
    edition (O’Relly Media, 2021), also by Sam Newman.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '但微服务比我认为的大多数开发者理解的要复杂。如果你想要更好地理解微服务是什么，你会在那里找到大量的文献。你可以从Chris Richardson的《Microservices
    Patterns》（Manning, 2018）开始，然后阅读Sam Newman的《Monolith to Microservices》（O’Reilly
    Media, 2018）或《Building Microservices: Designing Fine-Grained Systems》，第二版（O’Relly
    Media, 2021），也是Sam Newman的作品。'
- en: Whether they are real microservices systems or not, you still need to know how
    to investigate problems and how to quickly understand what the system does in
    given scenarios. In this chapter, we will discuss investigation techniques that
    apply to microservices, but not just to microservices. I prefer to use the simple
    term *service* instead of *microservice*. Sometimes I’ll just use *app* or *application*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论它们是否是真正的微服务系统，你仍然需要知道如何调查问题和如何快速理解在给定场景下系统做了什么。在本章中，我们将讨论适用于微服务的调查技术，但不仅限于微服务。我更喜欢使用简单的术语*服务*而不是*微服务*。有时我会直接使用*应用程序*或*应用*。
- en: 12.1.1 Using HTTP server probes to observe HTTP requests
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 使用HTTP服务器探针观察HTTP请求
- en: When two apps communicate, the data flows in two directions. An app either sends
    or receives a request. When an app sends a request, we say it acts as a *client*;
    when it receives a request, we say it’s the *server*. In this section, we focus
    on the HTTP requests an app receives (as a server). We’ll use a simple app provided
    with the book (project da-ch12-ex1) to understand how to monitor such events with
    JProfiler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个应用程序进行通信时，数据流向两个方向。一个应用程序要么发送请求，要么接收请求。当一个应用程序发送请求时，我们称其为*客户端*；当它接收请求时，我们称其为*服务器*。在本节中，我们专注于应用程序作为服务器接收的HTTP请求。我们将使用书中提供的简单应用程序（项目da-ch12-ex1）来了解如何使用JProfiler监控此类事件。
- en: Open project da-ch12-ex1 in your IDE and start the application. Using JProfiler,
    connect to the app and start recording the received HTTP requests going to HTTP
    Server > Events, and then press the star icon to record single events. Figure
    12.2 shows you how to start recording the events. We want to learn what HTTP requests
    the app receives and what information these requests can provide.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中打开项目da-ch12-ex1并启动应用程序。使用JProfiler连接到应用程序，并开始记录发送到HTTP服务器>事件的接收到的HTTP请求，然后按星形图标记录单个事件。图12.2显示了如何开始记录事件。我们想要了解应用程序接收到的HTTP请求以及这些请求可以提供的信息。
- en: '![](../../OEBPS/Images/CH12_F02_Spilca3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F02_Spilca3.png)'
- en: Figure 12.2 To start recording received HTTP requests with JProfiler, go to
    HTTP Server > Events, and then press the star icon to record single events. Now,
    whenever the profiled app receives HTTP requests, JProfiler will display the details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 要使用JProfiler开始记录接收到的HTTP请求，请转到HTTP服务器>事件，然后按星形图标记录单个事件。现在，每当被分析的应用程序接收HTTP请求时，JProfiler将显示详细信息。
- en: 'Let’s call the only endpoint this demo app exposes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个演示应用程序暴露的唯一端点称为：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As presented in figure 12.3, JProfiler shows the request the server received.
    First, you can easily determine when the event ends: the displayed status will
    be “completed.” If the operation never ends, meaning for some reason either the
    request wasn’t fully processed or the response wasn’t sent back to the client,
    the status will be “in progress.” This way, you can determine whether the request
    takes too long or if it has been delayed or interrupted by something.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如图12.3所示，JProfiler显示了服务器接收到的请求。首先，你可以轻松地确定事件何时结束：显示的状态将是“完成”。如果操作永远不会结束，这意味着由于某种原因请求没有完全处理，或者响应没有发送回客户端，状态将是“进行中”。这样，你可以确定请求是否耗时过长，或者是否由于某些原因而延迟或中断。
- en: The HTTP server events table also displays the event duration. If the event
    is completed but takes a long time, you need to determine what caused the delay.
    It may be faulty communication, which you will observe using socket events, discussed
    in section 12.1.3, or you may need to sample and profile the execution, as discussed
    in chapters 7 to 9.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器事件表还显示了事件持续时间。如果事件已完成但耗时较长，你需要确定导致延迟的原因。可能是由于通信故障，你将使用第12.1.3节中讨论的套接字事件来观察，或者你可能需要像第7章到第9章中讨论的那样采样和性能分析。
- en: It’s also important to see how many events the app gets. In some cases, one
    request won’t cause trouble, but I remember a situation in which an app was affected
    by one of the clients *polling* (repeatedly sending requests over a short time)
    one of the endpoints. If a client sends a high number of requests in a short interval
    and there’s nothing preventing them from reaching the app, the app may have trouble
    responding to all the requests and even crash.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是要看到应用接收了多少事件。在某些情况下，一个请求不会引起麻烦，但我记得有一个情况是一个应用受到了其中一个客户端*轮询*（在短时间内重复发送请求）其中一个端点的影响。如果客户端在短时间内发送大量请求，并且没有任何阻止它们到达应用的因素，应用可能难以响应所有请求，甚至崩溃。
- en: '![](../../OEBPS/Images/CH12_F03_Spilca3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F03_Spilca3.png)'
- en: Figure 12.3 After starting to record the HTTP server events (HTTP requests the
    app receives), the profiling tool shows details of all the received events on
    the page. You can easily see if an event ended and the time it took to complete.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 开始记录HTTP服务器事件（应用接收到的HTTP请求）后，性能分析工具会在页面上显示所有接收事件的详细信息。你可以轻松地看到事件是否结束以及完成所需的时间。
- en: 12.1.2 Using HTTP client probes to observe HTTP requests the app sends
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 使用HTTP客户端探针观察应用发送的HTTP请求
- en: Similar to HTTP server events (HTTP requests the app receives), you can profile
    the HTTP client events (HTTP requests the app sends). In this section, we’ll discuss
    profiling HTTP requests the app sends to identify potential issues they can cause.
    To do this, we’ll continue using the app provided with project da-ch12-ex1, the
    same one we used in section 12.1.1\. This app sends a request to an endpoint of
    [httpbin.org](http://httpbin.org/) when you call the `/demo` endpoint it exposes.
    Let’s start the app, call the `/demo` endpoint, and find out if we can observe
    the HTTP requests this app sends.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP服务器事件（应用接收到的HTTP请求）类似，你可以对HTTP客户端事件（应用发送的HTTP请求）进行性能分析。在本节中，我们将讨论分析应用发送的HTTP请求以识别它们可能引起的问题。为此，我们将继续使用项目da-ch12-ex1中提供的应用，与我们在12.1.1节中使用的是同一个应用。当你调用它公开的`/demo`端点时，该应用会向httpbin.org的端点发送请求。让我们启动应用，调用`/demo`端点，并找出我们是否可以观察到这个应用发送的HTTP请求。
- en: 'After starting the app, begin recording the HTTP client events in JProfiler
    (figure 12.4), and call the `/demo` endpoint:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用后，开始在JProfiler中记录HTTP客户端事件（图12.4），并调用`/demo`端点：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../../OEBPS/Images/CH12_F04_Spilca3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F04_Spilca3.png)'
- en: Figure 12.4 You can record all the HTTP requests the app sends regardless of
    the way they’re sent (what technology your app uses) in JProfiler, which displays
    details such as the duration, the status code, the HTTP method and URI called,
    and whether an exception has been encountered—which is all useful information
    when investigating specific scenarios that involve HTTP requests an app sends.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 在JProfiler中，你可以记录应用发送的所有HTTP请求，无论它们是如何发送的（应用使用的技术），它显示了诸如持续时间、状态码、调用的HTTP方法和URI以及是否遇到异常等详细信息——这些都是调查涉及应用发送的HTTP请求的具体场景时的有用信息。
- en: Look at the information this tool provides (figure 12.4). You’re first interested
    in the description and method columns since they help you to identify what endpoint
    the app calls. Once you know this, the details that give the most insight are
    the call duration, the response status code, and whether an exception has been
    encountered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此工具提供的信息（图12.4）。您首先感兴趣的可能是描述和方法列，因为它们有助于您识别应用程序调用的端点。一旦您知道了这一点，提供最多洞察力的细节是调用持续时间、响应状态码以及是否遇到了异常。
- en: If you find that a call takes a long time to execute (more than you expect),
    you’ll want to figure out why. First, try to determine whether the problem is
    caused by the data exchange (over the network) or something inside the app (e.g.,
    deserializing the response or processing it).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现某个调用执行时间过长（超过您的预期），您可能需要找出原因。首先，尝试确定问题是由数据交换（通过网络）还是应用程序内部（例如，反序列化响应或处理它）引起的。
- en: As you’ll see in section 12.1.3, investigating low-level events on sockets can
    tell you whether the problem is the communication itself or whether you should
    look at something your app does. If you discover that the data exchange is not
    causing the problem, you can apply the profiling techniques we discussed in chapters
    7 to 9 to discover what affects the app’s execution performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在第12.1.3节中看到的那样，调查套接字上的底层事件可以告诉您问题是否是通信本身，或者您是否应该查看应用程序的某些操作。如果您发现数据交换不是问题的原因，您可以将我们在第7章到第9章中讨论的配置文件技术应用于发现影响应用程序执行性能的因素。
- en: Just as with the HTTP requests an app gets (as discussed in section 12.1.1),
    it is important to consider the event count (how many lines appear in the events
    table) of HTTP requests an app sends. Does your app send too many requests, causing
    the other service to be slower to respond? In an app I implemented some time ago,
    I found that the app was sending frequent requests because of a faulty retry mechanism.
    The problem was difficult to spot up front since the requests were made to retrieve
    some data and were not changing anything or resulting in a wrong output. In this
    case, the supplementary requests only affected the app’s performance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第12.1.1节中讨论的HTTP请求一样，考虑应用程序发送的HTTP请求的事件计数（事件表中出现多少行）非常重要。您的应用程序是否发送了过多的请求，导致其他服务响应较慢？在我之前实施的一个应用程序中，我发现应用程序由于一个错误的重试机制而频繁发送请求。由于请求是为了检索一些数据，并没有改变任何东西或导致错误输出，因此问题一开始很难被发现。在这种情况下，补充请求只会影响应用程序的性能。
- en: 12.1.3 Investigating low-level events on sockets
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 调查套接字上的底层事件
- en: 'In this section, we discuss investigating low-level communication events on
    sockets to see whether a communication problem is caused by the communication
    channel (e.g., the network) or by something faulty inside the app. To observe
    these low-level events, you can use JProfiler: go to the Sockets > Events section.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论调查套接字上的底层通信事件，以查看通信问题是由通信通道（例如，网络）引起的，还是由应用程序内部的故障引起的。要观察这些底层事件，您可以使用JProfiler：转到“套接字
    > 事件”部分。
- en: 'Start the application, begin registering the events in JProfiler, and then
    send a request to the `/demo` endpoint:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，开始在JProfiler中注册事件，然后向`/demo`端点发送请求：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JProfiler intercepts all the events on sockets and displays them in a table,
    as presented in figure 12.5.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JProfiler拦截套接字上的所有事件，并将它们以表格形式显示，如图12.5所示。
- en: '![](../../OEBPS/Images/CH12_F05_Spilca3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F05_Spilca3.png)'
- en: Figure 12.5 Any message an app exchanges through the network level uses sockets
    behind the scenes. You can use a profiling tool such as JProfiler to observe all
    the low-level events at the sockets level. To monitor these events, use the Sockets
    > Events section. These events can help you to understand whether the app faces
    networking issues or if it simply doesn’t correctly manage the communication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 任何应用程序通过网络层交换的消息都使用底层的套接字。您可以使用JProfiler之类的分析工具来观察套接字级别的所有底层事件。要监控这些事件，请使用“套接字
    > 事件”部分。这些事件可以帮助您了解应用程序是否面临网络问题，或者它是否只是没有正确管理通信。
- en: 'A socket is a gateway to another process your app communicates with. When establishing
    communication, your app will execute the following socket events (figure 12.6):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是应用程序与其通信的另一个进程的网关。在建立通信时，应用程序将执行以下套接字事件（图12.6）：
- en: Open a socket to establish the communication (handshake with the app it needs
    to talk to).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开套接字以建立通信（与需要与之通信的应用程序进行握手）。
- en: Read from the socket (receive data) or write through it (send data).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从套接字读取（接收数据）或通过它写入（发送数据）。
- en: Close the socket.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭套接字。
- en: '![](../../OEBPS/Images/CH12_F06_Spilca3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F06_Spilca3.png)'
- en: Figure 12.6 When an app starts a data exchange, it first opens a socket. To
    exchange the data, the app can execute multiple data exchange events (read or
    write data events). When the data exchange ends, the app closes the socket.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 当应用程序开始数据交换时，它首先打开一个套接字。为了交换数据，应用程序可以执行多个数据交换事件（读取或写入数据事件）。当数据交换结束时，应用程序关闭套接字。
- en: Let’s discuss these kinds of events in more detail and understand what can they
    tell you about your app’s behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这些事件，并了解它们能告诉你关于应用程序行为的什么信息。
- en: Opening a socket to establish communication
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开套接字以建立通信
- en: One thing that should draw your attention is a long execution time for the open
    socket event. Opening a socket shouldn’t take a long time. If it does, this indicates
    a problem with the communication channel. For example, the system or virtual machine
    on which the app runs may not be properly configured, or the network could have
    issues. When the open socket event takes a long time, it is usually not caused
    by a problem with your code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应该引起你注意的是打开套接字事件的长时间执行。打开套接字不应该花费很长时间。如果它确实花费了很长时间，这表明通信通道存在问题。例如，应用程序运行的系统或虚拟机可能配置不当，或者网络可能存在问题。当打开套接字事件花费很长时间时，通常不是由你的代码问题引起的。
- en: Writing data through the socket or reading data from it
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过套接字写入数据或从它读取数据
- en: Reading or writing data through the socket is the actual process of communication.
    The two apps are connected to each other, and they exchange data. If this operation
    is slow, it can be because either a large amount of data is transferred or the
    communication channel is slow or faulty.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过套接字读取或写入数据是实际通信过程。两个应用程序相互连接，并交换数据。如果这个操作很慢，可能是因为大量数据传输，或者通信通道缓慢或故障。
- en: You can find the amount of data being sent through the socket using JProfiler
    (see the Throughput column in figure 12.5) so you can decide if the slowness is
    caused by the amount of data or something else. In our example, you can see that
    the app received a very small amount of data (only 535 bytes), but it had to wait
    over 5 seconds. In such a case, we can conclude that the problem is not with the
    current app, but with either the communication channel or the process that our
    app talks to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用JProfiler找到通过套接字发送的数据量（参见图12.5中的吞吐量列），这样你可以决定缓慢是由数据量还是其他原因引起的。在我们的示例中，你可以看到应用程序接收了非常少量的数据（只有535字节），但它必须等待超过5秒。在这种情况下，我们可以得出结论，问题不是当前应用程序的问题，而是通信通道或我们的应用程序与之通信的进程的问题。
- en: 'The app we use for our example calls an endpoint in [httpbin.org](http://httpbin.org/)
    that causes a 5 second delay. So, our conclusion is indeed right: the other communication
    endpoint causes the slowness.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中使用的应用程序调用[httpbin.org](http://httpbin.org/)上的一个端点，该端点会导致5秒的延迟。因此，我们的结论确实是正确的：其他通信端点导致了缓慢。
- en: Closing the socket
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭套接字
- en: Closing a socket doesn’t cause slowness. It allows the app to free resources
    allocated to the socket. So, when the communication ends, the app needs to close
    the socket.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭套接字不会导致缓慢。它允许应用程序释放分配给套接字的所有资源。因此，当通信结束时，应用程序需要关闭套接字。
- en: 12.2 The relevance of integrated log monitoring
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 集成日志监控的相关性
- en: Today, many systems adopt a service-oriented approach and increase the number
    of apps they offer over time. These apps communicate with one another and exchange,
    store, and process data, executing business functions users need. With the increase
    in the number of applications and the applications’ sizes, the systems have become
    more and more difficult to monitor. Noticing where something goes wrong has become
    considerably more challenging. To identify the system parts that cause issues,
    you can use the capabilities a log-monitoring tool offers (figure 12.7).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多系统采用面向服务的架构，并且随着时间的推移增加他们提供的应用程序数量。这些应用程序相互通信，交换、存储和处理数据，执行用户需要的业务功能。随着应用程序数量和应用程序规模的增加，系统变得越来越难以监控。注意到哪里出了问题已经变得相当具有挑战性。为了确定导致问题的系统部分，你可以使用日志监控工具提供的功能（图12.7）。
- en: '![](../../OEBPS/Images/CH12_F07_Spilca3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F07_Spilca3.png)'
- en: Figure 12.7 A log-monitoring tool helps you to easily collect and visualize
    events throughout the whole system. You can use these details to investigate issues
    and specific app behavior.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 日志监控工具帮助你轻松收集和可视化整个系统中的事件。你可以使用这些详细信息来调查问题和特定应用的行为。
- en: DEFINITION A log-monitoring tool is software you can integrate with apps to
    see exceptions happening throughout the whole system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：日志监控工具是一种你可以集成到应用中以查看整个系统中发生的异常的软件。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_girl2.png)'
- en: The tool observes the executions of all apps and collects data whenever an app
    throws a run-time exception. It then displays this information in a user-friendly
    way to help you to more quickly identify the problem’s cause.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 工具会观察所有应用的执行情况，并在应用抛出运行时异常时收集数据。然后，它会以用户友好的方式显示这些信息，帮助你更快地识别问题的原因。
- en: We’ll use a simple tool you can configure with your system to collect the exception
    events and present them in an easy-to-read way. Sentry ([https://sentry.io](https://sentry.io))
    is a log-monitoring tool that I’ve used in many of the systems I’ve worked with,
    and it has proved to be extremely useful throughout both the production and development
    of apps. Sentry has a free plan you can use for learning purposes (like the examples
    in this chapter).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的工具，你可以配置它以收集异常事件并以易于阅读的方式呈现。Sentry([https://sentry.io](https://sentry.io))是我使用过许多系统中的一种日志监控工具，它在应用的开发和生产过程中都证明极为有用。Sentry有一个免费计划，你可以用于学习目的（如本章中的示例）。
- en: Let’s create an app that throws an exception on purpose and integrate it with
    Sentry. This app is in project da-ch12-ex2.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个故意抛出异常的应用，并将其与Sentry集成。此应用位于项目da-ch12-ex2中。
- en: The next code snippet shows you the simple implementation of this app. We want
    to use Sentry to observe the exceptions caused by this app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了此应用的简单实现。我们希望使用Sentry来观察此应用引发的异常。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Defines an endpoint you call using HTTP GET
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个使用HTTP GET调用的端点
- en: ❷ Throw an exception when you send a request to the endpoint
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当你向端点发送请求时抛出异常
- en: Integrating an app with Sentry is straightforward. Sentry provides APIs that
    allow you to integrate apps developed in a large variety of platforms with just
    a few lines of code. The official documentation provides examples and detailed
    steps on how to integrate your app according to the technologies it uses.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用与Sentry集成非常简单。Sentry提供API，允许你仅用几行代码就将各种平台开发的应用集成。官方文档提供了根据所使用的技术如何集成你的应用的示例和详细步骤。
- en: 'The steps you need to follow are simple:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要遵循的步骤很简单：
- en: Create an account in Sentry.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Sentry中创建一个账户。
- en: Add a new project (that represents the app you want to monitor).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的项目（代表你想要监控的应用）。
- en: Collect the project data source name (DSN) address Sentry provides.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集Sentry提供的项目数据源名称（DSN）地址。
- en: Configure the DSN address in your project.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中配置DSN地址。
- en: Once you create an account (step 1), you can add projects (step 2). For these
    two steps, you just follow the instructions on [sentry.io](https://sentry.io);
    the process is as simple as creating an account on any website. Each project you
    add will appear in your dashboard, as presented in figure 12.8.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个账户（步骤1），你就可以添加项目（步骤2）。对于这两个步骤，你只需遵循[sentry.io](https://sentry.io)上的说明；这个过程就像在任何网站上创建账户一样简单。你添加的每个项目都会出现在你的仪表板上，如图12.8所示。
- en: '![](../../OEBPS/Images/CH12_F08_Spilca3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH12_F08_Spilca3.png)'
- en: Figure 12.8 Sentry independently monitors the logs of each service in your system
    and displays a short overview of the events for each service in the initial dashboard.
    Services (named projects) are allocated to teams, and Sentry can be configured
    to send email notifications for events to the team members.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 Sentry独立监控系统中每个服务的日志，并在初始仪表板上为每个服务显示事件的简要概述。服务（称为项目）分配给团队，Sentry可以配置为向团队成员发送事件通知的电子邮件。
- en: I created my-demo-project. One or multiple projects can be added to a team.
    In this case, Sentry created my-team by default when I added the first project.
    You can rename it if you like and add others if needed. When you have more apps,
    you can allocate them to teams. Each user can be part of one or multiple teams
    and can monitor the events of the apps allocated to their teams. Teams in Sentry
    are a simple way to organize who takes care of what and make developers accountable
    for monitoring certain services.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了my-demo-project。一个或多个项目可以被添加到一个团队中。在这种情况下，当我添加第一个项目时，Sentry默认创建了我的团队。如果您喜欢，可以重命名它，并在需要时添加其他人。当您有更多应用时，您可以将其分配到团队中。每个用户可以成为一个或多个团队的成员，并可以监控分配给他们的团队的应用事件。Sentry中的团队是一种简单的方式来组织谁负责什么，并使开发者对监控某些服务负责。
- en: Since your app didn’t send any events yet to Sentry, your project won’t show
    a bar on the bar chart (as presented in figure 12.8). You first need to tell your
    app where to send the events. To do this, you need to configure the DSN address
    that Sentry provides, as shown in figure 12.9\. You find the DSN address in the
    project settings, in the Client Keys section (step 3).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用尚未向Sentry发送任何事件，您的项目在柱状图中不会显示条形（如图12.8所示）。您首先需要告诉您的应用将事件发送到何处。为此，您需要配置Sentry提供的DSN地址，如图12.9所示。您可以在项目设置中的“客户端密钥”部分（步骤3）找到DSN地址。
- en: '![](../../OEBPS/Images/CH12_F09_Spilca3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F09_Spilca3.png)'
- en: Figure 12.9 In the project settings, in the Client Keys section, you find the
    DSN value, which is a URL. The application uses this URL to send the events to
    Sentry.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 在项目设置中，在“客户端密钥”部分，您会找到DSN值，这是一个URL。应用使用此URL将事件发送到Sentry。
- en: 'Depending on the app type, Sentry offers different ways to set up the configuration
    (step 4). You can find detailed steps on the official page for each platform:
    [https://docs.sentry.io/platforms/](https://docs.sentry.io/platforms/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用类型，Sentry提供不同的配置设置方法（步骤4）。您可以在每个平台的官方页面上找到详细步骤：[https://docs.sentry.io/platforms/](https://docs.sentry.io/platforms/)。
- en: 'Because our project uses Spring Boot as a platform, we can just add the DSN
    value to the property `sentry.dsn` in the application.properties file. You find
    this configuration in the next snippet. Although optional in Sentry, I always
    recommend specifying the name of the environment in which the app runs. This allows
    you to filter the events later so that you get only the ones you’re interested
    in:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目使用Spring Boot作为平台，我们只需将DSN值添加到application.properties文件中的属性`sentry.dsn`即可。您可以在下一节中找到此配置。尽管在Sentry中是可选的，但我总是建议指定应用运行的环境名称。这允许您稍后筛选事件，以便只获取您感兴趣的事件：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Figure 12.10 shows you how to get details about exception events in your app.
    Select the Issues menu on the left to access a board where you can browse all
    the events that Sentry caught from the apps it integrates with. You can filter
    which apps you want to see events for, which environment, and the period of time
    in which you’re interested.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10展示了如何在您的应用中获取异常事件的详细信息。选择左侧的“问题”菜单以访问一个板，您可以在其中浏览Sentry从其集成的应用中捕获的所有事件。您可以筛选您想要查看事件的应用、环境和您感兴趣的时间段。
- en: '![](../../OEBPS/Images/CH12_F10_Spilca3.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F10_Spilca3.png)'
- en: Figure 12.10 Sentry collects all the exceptions caused by the monitored services.
    In the Issues menu, you can browse a list of these issues. You can filter them
    based on the time the events happened, the environment, and specific services
    that cause the events, which helps you to more easily identify an issue.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 Sentry收集了由监控服务引起的所有异常。在“问题”菜单中，您可以浏览这些问题的列表。您可以根据事件发生的时间、环境和导致事件的特定服务来筛选它们，这有助于您更容易地识别问题。
- en: This board is the key starting point for an investigation. If you use Sentry
    and need to analyze something happening with a service in the system, first check
    the events in the issues board. Using Sentry to find exception events is much
    faster than searching these events in logs, as we discussed in chapter 5.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个板是调查的关键起点。如果您使用Sentry并需要分析系统中某个服务的异常，首先检查问题板中的事件。使用Sentry查找异常事件比我们在第5章中讨论的搜索日志中的这些事件要快得多。
- en: The first thing you find on the board is a list with short details for each
    audited event. The exception type, its message, and the number of occurrences
    are the most important details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您在板上首先看到的是每个审计事件的简要详情列表。异常类型、其消息和发生次数是最重要的细节。
- en: Another essential detail you find about each event is the last time the event
    was encountered and the first time it appeared. You can use this information to
    figure out if the problem is a recurrent one, if it happens frequently, or if
    it’s an isolated case. If the event is isolated, you may find that it’s caused
    by a sporadic problem in the environment, but bugs generated by the app logic
    are recurrent and more frequent. As presented in figure 12.10, all these details
    are in the main issues board.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个事件中，你发现的一个基本细节是事件最后一次遇到的时间和第一次出现的时间。你可以使用这些信息来判断问题是否是反复出现的，是否经常发生，或者是否是一个孤立案例。如果事件是孤立的，你可能会发现它是由于环境中偶然的问题引起的，但由应用逻辑产生的错误是反复出现的，并且更频繁。如图12.10所示，所有这些细节都在主要问题板上。
- en: 'If you are interested in more information on a specific event, select the event
    you need to investigate in the main issues board. Sentry collects the following
    useful details (figure 12.11):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对特定事件的信息感兴趣，请在主要问题板上选择你需要调查的事件。Sentry收集以下有用的细节（图12.11）：
- en: The exception stack trace
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常堆栈跟踪
- en: Environment details such as the operating system, runtime JVM, and server name
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境细节，例如操作系统、运行时JVM和服务器名称
- en: Client details, in case the exception was caused during an HTTP request
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端详细信息，如果异常是在HTTP请求过程中引起的
- en: Information sent on the request, in case the exception happened during an HTTP
    request
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTTP请求过程中发生异常时发送的信息
- en: '![](../../OEBPS/Images/CH12_F11_Spilca3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F11_Spilca3.png)'
- en: Figure 12.11 Each of the events Sentry collects—the event stack trace, details
    about the server and client environments, and even details about the request (headers,
    HTTP method, etc.)—provides information that can help you to identify the problem’s
    root cause.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 Sentry收集的每个事件——事件的堆栈跟踪、关于服务器和客户端环境的详细信息，甚至关于请求的详细信息（头信息、HTTP方法等）——提供了可以帮助你识别问题根本原因的信息。
- en: Using Sentry in team management
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队管理中使用Sentry
- en: Even though Sentry is a tool mainly used in auditing, monitoring, and investigating
    issues with apps, there is an alternative use for it that I consider quite helpful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Sentry是一个主要用于审计、监控和调查应用问题的工具，但我觉得它还有另一种用途，我认为这个用途非常有帮助。
- en: 'As a development lead, I am both the team lead and the technical lead. Before
    the COVID-19 pandemic, when we all used to work in the office, close to each other,
    knowing when someone was struggling with something was much easier for me, and
    vice versa: it was much easier to throw a ball of paper toward me to get my attention
    when they needed me. But things changed with remote, online work. One of the things
    that added delays to the team was simply the difficulty in communication between
    team members.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发团队领导，我既是团队领导也是技术领导。在COVID-19大流行之前，当我们都在办公室工作时，彼此靠近，我知道有人遇到困难要容易得多，反之亦然：当他们需要我时，更容易把一团纸扔向我以引起我的注意。但随着远程在线工作的出现，情况发生了变化。给团队增加延迟的一个因素仅仅是团队成员之间沟通的困难。
- en: Sentry can be configured to send emails for the events it encounters, so I configured
    it to get emails, even for events coming from local environments, to see what
    difficulties team members encountered. And since I know my team well, I knew if
    someone was stuck with a specific problem. In some cases, two or more team members
    experienced the same problem, but because communication was flawed, they both
    spent time investigating it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Sentry可以配置为发送它遇到的事件的电子邮件，因此我配置了它接收电子邮件，即使是来自本地环境的事件，以了解团队成员遇到了什么困难。由于我对我的团队很了解，我知道如果有人遇到了特定的问题。在某些情况下，两个或更多团队成员遇到了相同的问题，但由于沟通存在缺陷，他们都花费了时间来调查它。
- en: Using Sentry, I was able to act right away and help someone before they spent
    too much time trying to investigate an error and was able to plan team tasks more
    efficiently. I could also stop them from working when I saw they ran over schedule
    or worked at the same time. Pretty cool, isn’t it?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sentry，我能够立即采取行动并帮助某人，在他们花费太多时间尝试调查错误之前。我还能在他们超时或同时工作时阻止他们工作。这很酷，不是吗？
- en: One of the things I find particularly useful is that Sentry automatically collects
    details on the HTTP request in case the exception happened on a thread serving
    such a request. You can use this information to replicate the problem in a development
    environment or try to determine whether any of the data sent through the HTTP
    request could have caused the exception event. While Sentry doesn’t indicate the
    cause of a problem, it does provide more pieces of the puzzle, helping you to
    more quickly understand its root cause.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现特别有用的一点是，Sentry会自动收集在为请求服务的线程上发生异常时HTTP请求的详细信息。你可以使用这些信息在开发环境中重现问题，或者尝试确定通过HTTP请求发送的任何数据是否可能导致了异常事件。虽然Sentry不会指出问题的原因，但它确实提供了更多的线索，帮助你更快地理解其根本原因。
- en: NOTE In many cases today, apps talk to each other over HTTP, and it’s very likely
    that exception events happen as a consequence. Sentry takes the details of the
    HTTP request and associates them with the event.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在许多情况下，今天的应用程序通过HTTP相互通信，并且异常事件很可能因此发生。Sentry会记录HTTP请求的详细信息，并将其与事件关联。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: 12.3 Using deployment tools in investigations
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 使用部署工具进行调查
- en: 'One of the things I learned with time and by working on many projects is that
    environments that host apps are different and evolve. An important lesson I learned
    is that properly understanding the environment my apps run in can be tremendously
    helpful when investigating why an app behaves in a specific way. Let’s discuss
    one of the latest ways of deploying service-oriented architectures and how this
    can be helpful when investigating issues your apps might encounter: *service meshes*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移和参与许多项目的工作，我学到了一些东西，那就是托管应用程序的环境是不同的，并且会演变。我学到的其中一个重要教训是，正确理解应用程序运行的环境在调查为什么应用程序以特定方式行为时非常有帮助。让我们讨论一种最新的部署面向服务的架构的方法，以及这种方法在调查应用程序可能遇到的问题时如何有所帮助：*服务网格*。
- en: A service mesh is a way to control how different apps in a system communicate
    with one another, and they can be extremely helpful from many points of view,
    including making your apps easier to monitor and to investigate when they have
    issues. The service mesh tool I use and like the most is Istio ([https://istio.io](https://istio.io));
    for more details, I recommend you read *Istio in Action* by Christian E. Posta
    and Rinor Maloku (Manning, 2022).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格是一种控制系统中不同应用程序之间如何相互通信的方法，并且从许多角度来看，它们可以非常有帮助，包括使你的应用程序在出现问题时更容易监控和调查。我最喜欢并使用的服务网格工具是Istio
    ([https://istio.io](https://istio.io))；有关更多详情，我建议你阅读Christian E. Posta和Rinor Maloku合著的《Istio
    in Action》（Manning，2022年）。
- en: 'I’ll provide an overview of how a service mesh works, and then we’ll discuss
    a couple of ways they are helpful when investigating app executions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将概述服务网格的工作原理，然后我们将讨论它们在调查应用程序执行时的一些有用方式：
- en: '*Fault injection*—A way you can force the app communication to fail to create
    a specific scenario you need to investigate'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*故障注入*——一种你可以强制应用程序通信失败以创建你需要调查的特定场景的方法'
- en: '*Mirroring*—A way to replicate events from a production application to investigate
    them in a testing environment'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*镜像*——一种将生产应用程序的事件复制到测试环境中进行调查的方法'
- en: '![](../../OEBPS/Images/CH12_F12_Spilca3.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F12_Spilca3.png)'
- en: Figure 12.12 In a service mesh deployment, communication from and to each app
    is intercepted by a side cart app (a separate application). Since the side cart
    app intercepts the data exchanged, you can configure it to log details you need
    and even alter the communication to force the system into scenarios you want to
    investigate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 在服务网格部署中，每个应用的通信都被一个侧边栏应用（一个独立的应用）拦截。由于侧边栏应用拦截了交换的数据，你可以配置它来记录你需要的信息，甚至修改通信以强制系统进入你想要调查的场景。
- en: Figure 12.12 visually shows you three services deployed in a service mesh. Each
    service is accompanied by an app that intercepts the data that app exchanges with
    other apps.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12直观地展示了在服务网格中部署的三个服务。每个服务都伴随着一个拦截该服务与其他应用交换数据的应用的程序。
- en: Because the side cart app intercepts the communication between the service it’s
    linked to as well as other apps, you can configure it to manage that data in a
    way that is completely transparent to the service. We’ll discuss this further
    in sections 12.3.1 and 12.3.2.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于侧边栏应用拦截了它所链接的服务以及其他应用之间的通信，你可以配置它以完全透明于服务的方式管理这些数据。我们将在12.3.1和12.3.2节中进一步讨论这一点。
- en: 12.3.1 Using fault injection to mimic hard-to-replicate issues
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 使用故障注入来模拟难以复现的问题
- en: 'Some of the most challenging scenarios to investigate are the ones that are
    hard to replicate in your local environment or in an environment where you have
    more access to debugging or profiling. In my experience, the environment can create
    some of the most difficult-to-replicate scenarios. Events such as the following
    can give you terrible headaches and make investigating an app’s behavior quite
    challenging:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最具挑战性的调查场景之一是那些难以在本地环境或在你有更多调试或分析访问权限的环境中复现的场景。根据我的经验，环境可以创建一些最难以复现的场景。以下事件可能会给你带来极大的麻烦，并使调查应用程序的行为变得相当困难：
- en: Some faulty device causes network failures.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些故障设备导致网络故障。
- en: Some additional software running where your app is installed makes the whole
    environment faulty or unstable.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序安装的地方运行的一些额外软件使整个环境变得故障或不稳定。
- en: 'However, there’s something important to remember about such issues: your app
    should expect them to happen. The network is never 100% reliable, and you can’t
    trust the environment completely. If your app fails because of a network spike,
    your app isn’t reliable enough; don’t try to sweep the problem under someone else’s
    rug—solve it!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于这类问题，有一些重要的事情需要记住：你的应用程序应该预期它们会发生。网络永远不可能100%可靠，你不能完全信任环境。如果你的应用程序因为网络峰值而失败，那么你的应用程序还不够可靠；不要试图把问题推给其他人——解决它！
- en: You need to design apps to be robust and expect them to know how to act upon
    an external event that doesn’t allow them to execute a normal flow. But designing
    a system in such a way is no easy job. As a developer, you should anticipate that,
    but even if you made great efforts to cover all the bases, problems can still
    occur. You need to be ready to investigate where these problems come from and
    implement solutions to solve them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要设计应用程序使其具有鲁棒性，并预期它们知道如何对不允许它们执行正常流程的外部事件做出反应。但以这种方式设计系统并不容易。作为一名开发者，你应该预料到这一点，即使你做出了巨大的努力来覆盖所有基础，问题仍然可能发生。你需要准备好调查这些问题的来源，并实施解决方案来解决它们。
- en: 'I''ve made this point multiple times throughout the book, but it bears repeating
    here: the best way to investigate a problem is to find a way to replicate it.
    Although some issues caused by the environment can be difficult to replicate,
    some scenarios can easily be re-created when you use a service mesh with your
    deployment.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书中多次提到这一点，但在这里重复一遍：调查问题的最佳方式是找到一种方法来复现它。尽管一些由环境引起的问题难以复现，但当你使用服务网格进行部署时，一些场景可以很容易地重新创建。
- en: NOTE The best way to investigate a scenario is to replicate the app’s or system’s
    behavior in a test environment first.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：调查场景的最佳方式是首先在测试环境中复现应用程序或系统的行为。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: One of the easiest and most useful things to do is simulate a faulty communication
    scenario. In a service-oriented or microservices system, the whole system relies
    on the way the apps communicate, one with another. For this reason, it is extremely
    important to be able to test what happens when a certain service in the system
    can’t be accessed. You need to simulate faulty behavior for testing or for investigation
    purposes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 做起来最容易且最有用的事情之一是模拟一个故障通信场景。在一个面向服务的或微服务系统中，整个系统依赖于应用程序之间的通信方式。因此，能够测试当系统中的某个服务无法访问时会发生什么，这一点极为重要。你需要模拟故障行为以进行测试或调查。
- en: Since with a service mesh the communication to and from an app is managed by
    the side cart app, you can configure the side cart app to act abnormally, on purpose,
    to simulate faulty communication (figure 12.13). This way, you can investigate
    how the system behaves in such a case.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务网格管理应用程序的通信是由侧边栏应用程序处理的，因此你可以配置侧边栏应用程序故意异常行为，以模拟故障通信（图12.13）。这样，你可以调查系统在这种情况下的行为。
- en: '![](../../OEBPS/Images/CH12_F13_Spilca3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F13_Spilca3.png)'
- en: Figure 12.13 You can use the side cart app of a service mesh to force the system
    into scenarios you want to investigate. Say you want to replicate a production
    case in which the communication is often disrupted between two services. You can
    easily configure a service mesh side cart app to force the execution into such
    a scenario to allow you to investigate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 你可以使用服务网格的侧边栏应用程序来强制系统进入你想要调查的场景。比如说，你想要复现一个生产案例，其中两个服务之间的通信经常中断。你可以轻松地配置一个服务网格侧边栏应用程序来强制执行进入这样的场景，以便你可以进行调查。
- en: Fault injection means breaking your system on purpose, in a test environment,
    to replicate specific behavior that is otherwise difficult to replicate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入意味着在测试环境中故意破坏您的系统，以复制其他情况下难以复制的特定行为。
- en: '![](../../OEBPS/Images/icon_guy4.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3.2](../../OEBPS/Images/icon_guy4.png)'
- en: 12.3.2 Using mirroring to facilitate testing and error detection
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 使用镜像促进测试和错误检测
- en: When using service meshes, one technique you can use to replicate a problem
    in a different environment is mirroring. *Mirroring* is configuring the side cart
    app to send a copy of the same requests the service sends to a replica of the
    app it communicates with. This replica may run in a different environment that
    you use for testing (figure 12.14), which allows you to use the app running in
    the test environment to debug or profile the communication between services.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用服务网格时，您可以使用的一种在另一个环境中复制问题的技术是镜像。*镜像*是指配置侧边栏应用程序，将服务发送到与其通信的应用程序副本的相同请求的副本。这个副本可能运行在您用于测试的不同环境中（如图12.14所示），这允许您使用在测试环境中运行的应用程序来调试或分析服务之间的通信。
- en: '![](../../OEBPS/Images/CH12_F14_Spilca3.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14](../../OEBPS/Images/CH12_F14_Spilca3.png)'
- en: Figure 12.14 You can configure the side cart app to mirror the events from a
    production app to a service deployed in development. This way, you can investigate
    a problem that is hard to replicate in development without interfering with the
    production environment.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 您可以将侧边栏应用程序配置为将生产应用程序的事件镜像到开发中部署的服务。这样，您可以在不影响生产环境的情况下，调查在开发环境中难以复制的难题。
- en: Mirroring is a really useful investigation tool, but remember that even if your
    system uses a service mesh for deployment, it’s possible you won’t be able to
    use mirroring. In many systems, the data used in the production environment is
    private and can’t simply be copied to a test environment. If your system doesn’t
    allow copying data from production to test, then mirroring will be prohibited
    as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是非常有用的调查工具，但请记住，即使您的系统使用服务网格进行部署，您也可能无法使用镜像。在许多系统中，生产环境中使用的数据是私有的，不能简单地复制到测试环境中。如果您的系统不允许从生产环境复制数据到测试环境，那么镜像也将被禁止。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Systems today are often composed of many services communicating with one another.
    Faulty communication between services can cause issues such as bad performance
    or even wrong output. It’s essential to know how to investigate communication
    between services using tools such as profiling or service meshes.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天的系统通常由许多相互通信的服务组成。服务之间的错误通信可能导致性能问题或甚至错误的输出。了解如何使用配置文件或服务网格等工具调查服务之间的通信至关重要。
- en: You can use JProfiler to intercept the HTTP requests a server app receives and
    the event duration. You can then use this information to observe whether a given
    endpoint is called too many times or takes too long to execute, causing stress
    on the app instance.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用JProfiler截获服务器应用程序接收的HTTP请求和事件持续时间。然后，您可以使用这些信息来观察是否某个端点被调用次数过多或执行时间过长，从而对应用程序实例造成压力。
- en: You can use JProfiler to observe the behavior of an app as an HTTP client. You
    can intercept all the requests an app sends, as well as details such as duration,
    HTTP response status code, and encountered exceptions. This information can help
    you to figure out if something is wrong with how the app integrates with other
    services.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用JProfiler观察应用程序作为HTTP客户端的行为。您可以截获应用程序发送的所有请求，以及持续时间、HTTP响应状态码和遇到的异常等详细信息。这些信息可以帮助您确定应用程序与其他服务集成的方式是否存在问题。
- en: JProfiler gives you excellent tools to observe low-level communication established
    by an app by directly investigating the socket events, which allows you to isolate
    the problem and determine whether the issues are related to either the communication
    channel or some part of your application.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JProfiler为您提供优秀的工具，可以直接调查应用程序建立的底层通信，通过直接调查套接字事件，这允许您隔离问题并确定问题是否与通信通道或应用程序的某个部分有关。
- en: With large, service-oriented systems, using a log-monitoring tool is an excellent
    way to observe issues and put puzzle pieces together faster to find a problem’s
    root cause. A log-monitoring tool is software that collects exceptional events
    in each app in the system and displays the information you need to understand
    the problem and where it comes from. Sentry is an excellent tool you can use for
    system log monitoring.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型面向服务的系统中，使用日志监控工具是观察问题和更快地将拼图碎片拼凑起来以找到问题根本原因的绝佳方式。日志监控工具是一种软件，它收集系统中每个应用中的异常事件，并显示你需要了解问题及其来源的信息。Sentry
    是一个你可以用于系统日志监控的绝佳工具。
- en: In some cases, you can take advantage of tools used to deploy apps. For example,
    if your service deployments rely on a service mesh, you can use service mesh capabilities
    to reproduce scenarios you want to investigate. You can configure
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以利用用于部署应用的工具。例如，如果你的服务部署依赖于服务网格，你可以使用服务网格功能来重现你想要调查的场景。你可以配置
- en: Fault injection to simulate a service that doesn’t work properly and investigate
    how other services are affected in this case.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障注入以模拟一个工作不正常的服务，并调查在这种情况下其他服务受到的影响。
- en: Mirroring to get a copy of all the requests an app sends to a replica of the
    receiver service. This replica is installed in a test environment, where you can
    investigate a scenario using debugging and profiling techniques without affecting
    the production system.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过镜像来获取应用发送给接收服务副本的所有请求的副本。这个副本安装在测试环境中，你可以使用调试和性能分析技术来调查场景，而不会影响生产系统。
