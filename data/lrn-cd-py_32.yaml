- en: Lesson 26\. Advanced operations with lists
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 26 课\. 列表的进阶操作
- en: After reading [lesson 26](#ch26), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 26 课](#ch26) 之后，你将能够
- en: Build lists whose elements are lists
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建元素为列表的列表
- en: Sort and reverse list elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和反转列表元素
- en: Convert a string into a list by splitting on a character
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在字符上分割将字符串转换为列表
- en: A list is typically used to represent a collection of items, frequently but
    not necessarily of the same type. You’ll see that it may be useful for the list
    elements to be lists themselves. For example, suppose you want to keep a list
    of all the items in your house. Because you have many items, it’ll be more organized
    to have sublists, where each sublist represents a room, and a sublist’s elements
    are all the items in that room.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 列表通常用于表示一组项目，通常是相同类型的，但并不一定是。你会发现列表元素本身也是列表可能很有用。例如，假设你想要保存你家中所有项目的列表。因为你有很多项目，所以有子列表会更组织，每个子列表代表一个房间，子列表的元素是该房间中的所有项目。
- en: At this point, it’s important to take a step back and understand what has been
    going on with this new mutable object, a list. Lists are directly modified by
    any actions you do on them. Because the list is directly modified, you don’t reassign
    the list to a new variable after an operation; the list itself now contains the
    changed values. To see the value of the modified list, you can print it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，退一步理解这个新的可变对象——列表——所发生的事情是很重要的。列表会直接被你对它们所做的任何操作修改。因为列表是直接修改的，所以在操作后你不需要将列表重新赋值给一个新的变量；列表本身现在包含已更改的值。要查看修改后的列表的值，你可以打印它。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Your friend can recite the number pi up to 100 digits. You add each digit into
    a list as he tells it to you. You want to figure out how many zeros are in the
    first 100 digits. How can you quickly do this?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友能背诵到 100 位的圆周率。你将每个数字添加到列表中，当他告诉你时。你想要找出前 100 位中有多少个零。你如何快速做到这一点？
- en: 'Answer:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: If you sort the list, you can count the zeros at the beginning of the list.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你排序了列表，你可以计算列表开头有多少个零。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 26.1\. Sorting and reversing lists
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1\. 排序和反转列表
- en: 'After you have a list of elements, you can perform operations that rearrange
    elements in the whole list. For example, if you have a list of students in your
    class, you don’t need to keep two lists of the same students: one sorted and one
    unsorted. You can start out with an unsorted list and then sort it directly when
    needed. When you care only about the contents of the list, storing it in a sorted
    manner may be preferred. But note that after it’s sorted, you can’t go back to
    the unsorted version of the list unless you re-create it from scratch.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有一个元素列表之后，你可以执行重新排列整个列表中元素的运算。例如，如果你有一个班级中学生的列表，你不需要保留两个相同学生的列表：一个排序，一个未排序。你可以从一个未排序的列表开始，然后在需要时直接对其进行排序。当你只关心列表的内容时，以排序的方式存储它可能更受欢迎。但请注意，一旦排序，除非你从头开始重新创建它，否则你不能回到列表的未排序版本。
- en: Because lists are mutable, you can sort a list, using the operation `sort()`,
    so that the list elements of the original list are now in sorted order. The command
    `L.sort()` will sort the list `L` in ascending order (for numbers) and lexicographically
    (for letters or strings). In contrast, if you wanted to sort items in an immutable
    tuple object, you’d be creating many intermediary objects as you’re concatenating
    the items from end to beginning (take the last item and put it at index 0, take
    the second-to-last item and put it at index 1, and so on).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表是可变的，所以你可以使用操作 `sort()` 对列表进行排序，这样原始列表的元素现在就是有序的。命令 `L.sort()` 将按升序（对于数字）和字典序（对于字母或字符串）对列表
    `L` 进行排序。相比之下，如果你想要对一个不可变的元组对象中的项目进行排序，那么在从末尾开始连接项目时，你会创建许多中间对象（取最后一个项目并将其放在索引
    0，取倒数第二个项目并将其放在索引 1，依此类推）。
- en: Reversing a list may also be useful. For example, if you have a list of the
    names of your students and you sorted them alphabetically, you can reverse the
    list and have them sorted in reverse alphabetical order. The command `L.reverse()`
    reverses the list `L` so that the element at the front is now at the end, and
    so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反转列表也可能很有用。例如，如果你有一个学生姓名的列表并且按字母顺序排序了它们，你可以反转列表，使它们按逆字母顺序排序。命令 `L.reverse()`
    反转列表 `L`，使得原来的第一个元素现在在末尾，依此类推。
- en: Listing 26.1\. Sorting and reversing a list
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.1\. 排序和反转列表
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Reverses original list**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 反转原始列表**'
- en: '***2* Prints [1, 1.5, 1.4, 2, 1.5, 1.3, 1.4] because the preceding line reverses
    the original list by moving the first element to the last position, the second
    element to the second-to-last position, and so on**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 [1, 1.5, 1.4, 2, 1.5, 1.3, 1.4]，因为上一行通过将第一个元素移动到最后位置，第二个元素移动到倒数第二个位置，依此类推来反转原始列表**'
- en: '***3* Sorts list in ascending order**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 按升序排序列表**'
- en: '***4* Prints [1, 1.3, 1.4, 1.4, 1.5, 1.5, 2] because the preceding line sorted
    the list in ascending order**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印 [1, 1.3, 1.4, 1.4, 1.5, 1.5, 2]，因为上一行按升序排序了列表**'
- en: '***5* Reverses sorted list**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 反转排序后的列表**'
- en: '***6* Prints [2, 1.5, 1.5, 1.4, 1.4, 1.3, 1] because the preceding line reversed
    the list sorted in ascending order**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 打印 [2, 1.5, 1.5, 1.4, 1.4, 1.3, 1]，因为上一行反转了按升序排序的列表**'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.1**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.1**'
- en: '**[Q1:](kindle_split_056.html#app01qa103q0a1)**'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa103q0a1)**'
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the value of list `L` after each operation?
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每次操作后列表 L 的值是多少？
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve seen lists whose elements are floats, integers, or strings. But a list
    can contain elements of any type, including other lists!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过包含浮点数、整数或字符串的列表。但列表可以包含任何类型的元素，包括其他列表！
- en: 26.2\. Lists of lists
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2\. 列表列表
- en: If you want to program a game, especially a game that relies on the user being
    in a certain position, you’ll often want to think about the position on a board
    represented in a two-dimensional coordinate plane. Lists can be used to help you
    represent the two-dimensional coordinate plane by using one list whose elements
    are also lists. The following listing creates a list `L` whose three elements
    are empty lists, and then populates the list with elements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编写一个游戏，特别是依赖于用户在特定位置的游戏，你通常会想要考虑在二维坐标系中表示的棋盘位置。列表可以帮助你通过使用一个其元素也是列表的列表来表示二维坐标系。以下列表创建了一个列表
    `L`，其三个元素都是空列表，然后填充了这个列表。
- en: Listing 26.2\. Creating and populating a list of lists
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.2\. 创建和填充列表列表
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Empty list of lists**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 空的列表列表**'
- en: '***2* L has the value [[1,2,3], [], []] because you set the element at index
    0 to be the list [1,2,3].**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* L 的值为 [[1,2,3], [], []]，因为你将索引 0 的元素设置为列表 [1,2,3]。**'
- en: '***3* L has the value [[1,2,3], [‘t’], []] because you appended the string
    ‘t’ to the middle empty list.**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* L 的值为 [[1,2,3], [''t''], []]，因为你将字符串 ''t'' 添加到了中间的空列表中。**'
- en: '***4* L has the value [[1,2,3], [‘t’, ‘o’], []] because you appended the string
    ‘o’ to the already mutated middle list.**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* L 的值为 [[1,2,3], [''t'', ''o''], []]，因为你将字符串 ''o'' 添加到了已经修改过的中间列表中。**'
- en: '***5* L has the value [[1,2,3], [‘d’, ‘o’], []] because you accessed the element
    at index 1 (a list) and then accessed that object’s element at index 0 (letter
    t) to change it (to the letter d).**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* L 的值为 [[1,2,3], [''d'', ''o''], []]，因为你访问了索引 1（一个列表）的对象，然后访问该对象的索引 0（字母
    t）的元素来更改它（改为字母 d）。**'
- en: Working with lists of lists adds another layer of indirection when indexing
    into the list to work with its elements. The first time you index a list of lists
    (or even a list of lists of lists of lists), you access the object at that position.
    If the object at that position is a list, you can index into that list as well,
    and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表列表进行工作时，在索引列表以处理其元素时增加了另一层间接性。第一次索引列表列表（甚至列表列表列表列表），你访问该位置的对象。如果该位置的对象是一个列表，你可以进一步索引该列表，依此类推。
- en: You can represent a tic-tac-toe board with a list of lists. [Listing 26.3](#ch26ex03)
    shows the code for setting up the board with lists. Because lists are one-dimensional,
    you can consider each element of the outer list to be a row in the board. Each
    sublist will contain all the elements for each column in that row.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表列表来表示井字棋盘。[列表 26.3](#ch26ex03) 显示了使用列表设置棋盘的代码。因为列表是一维的，你可以认为外部列表的每个元素是棋盘中的一行。每个子列表将包含该行中每列的所有元素。
- en: Listing 26.3\. Tic-tac-toe board with lists of lists
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.3\. 使用列表表示的井字棋盘
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Variable x**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 变量 x**'
- en: '***2* Variable o**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 变量 o**'
- en: '***3* Empty space**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 空间**'
- en: '***4* Replaces every variable with its value. Variable board has three rows
    (one for each sublist) and three columns (each sublist has three elements).**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 用其值替换每个变量。变量 board 有三行（每个子列表一行）和三列（每个子列表有三个元素）。**'
- en: 'This tic-tac-toe board represented in code looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 用代码表示的井字棋盘看起来像这样：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using lists inside lists, you can represent any size tic-tac-toe board by adjusting
    the number of sublists you have and the number of elements each sublist contains.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用列表中的列表，您可以调整子列表的数量以及每个子列表包含的元素数量来表示任何大小的井字棋板。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.2**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.2**'
- en: 'Using the variables set up in [listing 26.3](#ch26ex03), write the line of
    code to set up a board that looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在 [列表 26.3](#ch26ex03) 中设置的变量，编写一行代码来设置一个看起来像这样的板：
- en: '**[1](kindle_split_056.html#app01qa104q0a1)**'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa104q0a1)**'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A 3 × 3 board
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 3 × 3 的板
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _ _ _
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _ _ _
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x x x
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x x x
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: o o o
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: o o o
- en: '**[2](kindle_split_056.html#app01qa104q0a2)**'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa104q0a2)**'
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A 3 × 4 board
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 3 × 4 的板
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x o x o
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x o x o
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: o o x x
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: o o x x
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: o _ x x
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: o _ x x
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.3\. Converting a string to a list
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.3. 将字符串转换为列表
- en: 'Suppose you’re given a string that contains email data separated by commas.
    You’d like to separate out each email address and keep each address in a list.
    The following sample string shows how the input data might look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您得到一个包含以逗号分隔的电子邮件数据的字符串。您希望将每个电子邮件地址分离出来，并将每个地址保存在一个列表中。以下示例字符串显示了输入数据可能的样子：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You could solve this problem by using string manipulations, but in a somewhat
    tedious way. First, you find the index of the first comma. Then you save the email
    as the substring from the beginning of the string `emails` until that index. Then
    you save the rest of the string from that index until the end of `emails` in another
    variable. And finally, you repeat the process until you don’t have any more commas
    left to find. This solution uses a loop and forces you to create unnecessary variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用字符串操作来解决这个问题，但这种方式可能有些繁琐。首先，您需要找到第一个逗号的位置。然后，将电子邮件保存为从字符串 `emails` 开始到该索引的子字符串。接着，将字符串从该索引到
    `emails` 结束的部分保存到另一个变量中。最后，重复这个过程，直到没有更多的逗号可以找到。这个解决方案使用了循环，并迫使您创建不必要的变量。
- en: 'Using lists provides a simple, one-line solution to this problem. With the
    preceding `emails` string, you can do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表为这个问题提供了一个简单的一行解决方案。使用前面的 `emails` 字符串，您可以这样做：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This line uses the operation `split()` on the string named `emails`. In the
    parentheses to `split()`, you can put the element on which you’d like to split
    the string. In this case, you want to split on the comma. The result from running
    that command is that `emails_list` is a list of strings that contains every substring
    between the commas, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了名为 `emails` 的字符串上的 `split()` 操作。在 `split()` 的括号中，您可以放置您想要分割字符串的元素。在这种情况下，您想要在逗号上分割。运行该命令的结果是
    `emails_list` 是一个包含每个逗号之间子字符串的字符串列表，如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that each email is now a separate element in the list `emails_list`,
    making it easy to work with.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在每个电子邮件都是列表 `emails_list` 中的一个单独元素，这使得处理起来变得容易。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.3**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.3**'
- en: 'Write a line of code to achieve the following tasks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一行代码以实现以下任务：
- en: '**[1](kindle_split_056.html#app01qa105q0a1)**'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa105q0a1)**'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Split the string `" abcdefghijklmnopqrstuvwxyz"` by the space character.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过空格字符分割字符串 `" abcdefghijklmnopqrstuvwxyz"`。
- en: '**[2](kindle_split_056.html#app01qa105q0a2)**'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa105q0a2)**'
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Split the string `"spaces and more spaces"` by words.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过单词分割字符串 `"spaces and more spaces"`。
- en: '**[3](kindle_split_056.html#app01qa105q0a3)**'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa105q0a3)**'
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Split the string `"the secret of life is 42"` on the letter `s`.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过字母 `s` 分割字符串 `"the secret of life is 42"`。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With the operations you saw on lists in [lesson 25](kindle_split_040.html#ch25)
    (sorting and reversing a list), you’re now able to simulate real-life phenomena:
    stacks and queues of items.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 [第 25 课](kindle_split_040.html#ch25) 中看到的列表操作（排序和反转列表），您现在能够模拟现实生活中的现象：物品的栈和队列。
- en: 26.4\. Applications of lists
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.4. 列表的应用
- en: Why would you need to simulate a stack or a queue by using a list? This is a
    somewhat philosophical question, and it hints at what you’ll see in the next unit.
    A more basic question is why do I need a list object when I can just create a
    bunch of integer/float/ string objects and remember the order I want them in?
    The idea is that you use simpler objects to create more complex objects that have
    more specific behaviors. In the same way that a list is made up of an ordered
    group of objects, a stack or a queue is made up of a list. You can make up your
    own stack or queue object so that their construction is the same (you use a list)
    but their behavior is different.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么需要通过使用列表来模拟一个栈或队列呢？这是一个有点哲学性的问题，它暗示了你将在下一单元中看到的内容。一个更基本的问题是，当我可以创建一堆整数/浮点/字符串对象并记住它们的顺序时，我为什么还需要一个列表对象呢？这个想法是，你使用更简单的对象来创建具有更多特定行为的更复杂对象。就像列表是由一组有序对象组成的一样，栈或队列也是由列表组成的。你可以自己创建一个栈或队列对象，使得它们的构造相同（你使用列表），但行为不同。
- en: 26.4.1\. Stacks
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.4.1\. 栈
- en: Think of a stack of pancakes. As they’re being made, new pancakes are added
    to the top of the stack. When a pancake is eaten, it’s taken from the top of the
    stack. You can mimic this behavior with a list. The top of the stack is the end
    of the list. Every time you have a new element, you add it to the end of the list
    with `append()`. Every time you want to take an element out, you remove it from
    the end of the list with `pop()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下煎饼堆。当它们被制作时，新的煎饼被添加到堆的顶部。当煎饼被吃掉时，它从堆的顶部取出。你可以用列表来模拟这种行为。栈的顶部是列表的末尾。每次你有新元素时，你使用
    `append()` 方法将其添加到列表的末尾。每次你想取出一个元素时，你使用 `pop()` 方法从列表的末尾移除它。
- en: '[Listing 26.4](#ch26ex04) shows an implementation of a pancake stack in Python.
    Suppose you have blueberry and chocolate pancakes. A blueberry pancake is represented
    by the element `''b''` (letter *b* as a string) and a chocolate pancake as `''c''`
    (letter *c* as a string). Your pancake stack is originally an empty list (no pancakes
    made yet). One cook makes batches of pancakes; the cook is also a list with pancake
    elements. As soon as a batch is made by the cook, the batch is added to the stack
    by using `extend()`. Someone eating a pancake can be represented by using the
    `pop()` operation on the stack.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 26.4](#ch26ex04) 展示了 Python 中煎饼栈的实现。假设你有蓝莓和巧克力煎饼。蓝莓煎饼由元素 `''b''`（字母 *b*
    作为字符串）表示，巧克力煎饼由 `''c''`（字母 *c* 作为字符串）表示。你的煎饼栈最初是一个空列表（还没有制作煎饼）。一位厨师制作一批煎饼；厨师也是一个包含煎饼元素的列表。一旦厨师制作了一批煎饼，就会使用
    `extend()` 方法将这批煎饼添加到栈中。吃煎饼的人可以用栈上的 `pop()` 操作来表示。'
- en: Listing 26.4\. A stack of pancakes represented with a list
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.4\. 使用列表表示的煎饼栈
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Empty list**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 空列表**'
- en: '***2* List of three pancakes made**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 制作了三个煎饼的列表**'
- en: '***3* Adds cook’s pancakes to stack**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将厨师制作的煎饼添加到栈中**'
- en: '***4* Removes last element in list**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 移除列表中的最后一个元素**'
- en: '***5* New batch of pancakes**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 新一批煎饼**'
- en: '***6* Adds cook’s batch to stack at the end**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将厨师的一批煎饼添加到栈的末尾**'
- en: '***7* Adds cook’s batch to stack at the end**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将厨师的一批煎饼添加到栈的末尾**'
- en: '***8* Removes last element in list**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 移除列表中的最后一个元素**'
- en: Stacks are a *first-in-last-out* structure because the first item added to the
    stack is the last one taken out. Queues, on the other hand, are *first-in-first-out*
    because the first item added to a queue is the first one taken out.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种 *先进后出* 结构，因为最先添加到栈中的项目是最后被取出的。另一方面，队列是 *先进先出*，因为最先添加到队列中的项目是第一个被取出的。
- en: 26.4.2\. Queues
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.4.2\. 队列
- en: Think of a grocery store queue. When a new person arrives, they stand at the
    end of the line. As people are being helped, the ones that have been in the queue
    the longest (at the front of the line) are going to be helped next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下杂货店的队列。当新来的人到达时，他们站在队伍的末尾。当人们被帮助时，那些在队列中等待时间最长的人（队伍的前面）将被下一个帮助。
- en: You can simulate a queue by using a list. As you get new elements, you add to
    the end of the list. When you want to take out an element, you remove the one
    at the beginning of the list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表来模拟队列。当你得到新元素时，你将它们添加到列表的末尾。当你想要取出一个元素时，你从列表的起始位置移除它。
- en: '[Listing 26.5](#ch26ex05) shows an example of a simulated queue in code. Your
    grocery store has one line, represented by a list. As customers come in, you use
    `append()` to add them to the end of the list. As customers are helped, you use
    `pop(0)` to remove them from the front of the line.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码列表 26.5](#ch26ex05) 展示了代码中模拟队列的一个示例。你的杂货店有一条队伍，用列表表示。当顾客进来时，你使用 `append()`
    将他们添加到列表的末尾。当顾客得到帮助时，你使用 `pop(0)` 从队伍的前端移除他们。'
- en: Listing 26.5\. A queue of people represented by a list
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.5。用列表表示的人队列
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Empty list**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 空列表**'
- en: '***2* List of one person now in queue**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在队列中一个人的名单**'
- en: '***3* List of two people now in queue**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 现在队列中的两个人名单**'
- en: '***4* First person removed from the queue**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从队列中移除的第一个人**'
- en: '***5* New people added to the end of list**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 新人添加到列表的末尾**'
- en: '***6* People removed from beginning of list**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从列表开头移除的人**'
- en: Using more complex object types, such as lists, you can simulate real-life actions.
    In this case, you can use specific sequences of operations to simulate stacks
    and queues of objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更复杂的数据类型，如列表，你可以模拟现实生活中的动作。在这种情况下，你可以使用特定的操作序列来模拟对象栈和队列。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.4**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.4**'
- en: Are the following situations best representative of a queue, a stack, or neither?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情况最符合队列、栈还是都不是？
- en: '**[1](kindle_split_056.html#app01qa106q0a1)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa106q0a1)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Undo mechanism in your text editor
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的文本编辑器的撤销机制
- en: '**[2](kindle_split_056.html#app01qa106q0a2)**'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa106q0a2)**'
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Putting tennis balls in a container and then taking them out
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将网球放入容器中然后取出来
- en: '**[3](kindle_split_056.html#app01qa106q0a3)**'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa106q0a3)**'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cars in a line waiting for inspection
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 排队等待检查的汽车
- en: '**[4](kindle_split_056.html#app01qa106q0a4)**'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa106q0a4)**'
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Airport luggage entering the carousel and being picked up by its owner
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 机场行李进入传送带并被其主人取走
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you more operations that you can
    do with lists. You sorted a list, reversed a list, created lists that contained
    other lists as elements, and converted a string into a list by splitting it on
    a character. Here are the major takeaways:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你更多关于列表的操作。你排序了一个列表，反转了一个列表，创建了包含其他列表作为元素的列表，并通过在字符上分割将字符串转换为列表。以下是主要收获：
- en: Lists can contain elements that are other lists.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以包含其他列表作为元素。
- en: You can sort or reverse a list’s elements.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对列表的元素进行排序或反转。
- en: Behaviors of stacks and queues can be implemented using lists.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列的行为可以使用列表实现。
- en: Let’s see if you got this...
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: '**[Q26.1](kindle_split_056.html#app01qa107q0a1)**'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q26.1](kindle_split_056.html#app01qa107q0a1)**'
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a program that takes in a string containing city names separated by commas,
    and then prints a list of the city names in sorted order. You can start with this:'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序接受一个包含以逗号分隔的城市名称的字符串，然后按顺序打印城市名称列表。你可以从以下内容开始：
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**[Q26.2](kindle_split_056.html#app01qa107q0a2)**'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q26.2](kindle_split_056.html#app01qa107q0a2)**'
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function named `is_permutation`. It takes in two lists, `L1` and `L2`.
    The function returns `True` if `L1` and `L2` are permutations of each other. It
    returns `False` otherwise. Every element in `L1` is in `L2`, and vice versa, only
    arranged in a different order. For example,
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为 `is_permutation` 的函数。它接受两个列表，`L1` 和 `L2`。如果 `L1` 和 `L2` 是彼此的排列，则函数返回
    `True`。否则返回 `False`。`L1` 中的每个元素都在 `L2` 中，反之亦然，只是顺序不同。例如，
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`is_permutation([1,2,3], [3,1,2])` returns `True`.'
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_permutation([1,2,3], [3,1,2])` 返回 `True`.'
- en: '`is_permutation([1,1,1,2], [1,2,1,1])` returns `True`.'
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_permutation([1,1,1,2], [1,2,1,1])` 返回 `True`.'
- en: '`is_permutation([1,2,3,1], [1,2,3])` returns `False`.'
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_permutation([1,2,3,1], [1,2,3])` 返回 `False`.'
