- en: Chapter 21\. Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 21 章 数据库
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'A huge amount of data lives in databases, so it’s essential that you know how
    to access it. Sometimes you can ask someone to download a snapshot into a `.csv`
    file for you, but this gets painful quickly: every time you need to make a change,
    you’ll have to communicate with another human. You want to be able to reach into
    the database directly to get the data you need, when you need it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大量数据存储在数据库中，因此你了解如何访问它是至关重要的。有时你可以请求某人为你下载一个 `.csv` 文件的快照，但这很快就变得痛苦：每次需要进行更改时，你都必须与另一个人沟通。你希望能够直接进入数据库，按需获取你所需的数据。
- en: 'In this chapter, you’ll first learn the basics of the DBI package: how to use
    it to connect to a database and then retrieve data with a SQL^([1](ch21.xhtml#idm44771280827536))
    query. *SQL*, short for Structured Query Language, is the lingua franca of databases
    and is an important language for all data scientists to learn. That said, we’re
    not going to start with SQL, but instead we’ll teach you dbplyr, which can translate
    your dplyr code to SQL. We’ll use that as a way to teach you some of the most
    important features of SQL. You won’t become a SQL master by the end of the chapter,
    but you will be able to identify the most important components and understand
    what they do.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先学习 DBI 包的基础知识：如何使用它连接数据库，然后通过 SQL^([1](ch21.xhtml#idm44771280827536))
    查询检索数据。*SQL*，即结构化查询语言，是数据库的通用语言，对所有数据科学家来说都是一种重要的语言。话虽如此，我们不会从 SQL 入手，而是教你 dbplyr，它可以将你的
    dplyr 代码转换为 SQL。我们将以此方式教授你一些 SQL 最重要的特性。虽然在本章结束时你不会成为 SQL 大师，但你将能够识别最重要的组件并理解它们的作用。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: In this chapter, we’ll introduce DBI and dbplyr. DBI is a low-level interface
    that connects to databases and executes SQL; dbplyr is a high-level interface
    that translates your dplyr code to SQL queries and then executes them with DBI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 DBI 和 dbplyr。DBI 是一个低级接口，用于连接数据库并执行 SQL；dbplyr 是一个高级接口，将你的 dplyr
    代码转换为 SQL 查询，然后使用 DBI 执行这些查询。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Database Basics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库基础知识
- en: 'At the simplest level, you can think about a database as a collection of data
    frames, called *tables* in database terminology. Like a `data.frame`, a database
    table is a collection of named columns, where every value in the column is the
    same type. There are three high-level differences between data frames and database
    tables:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的层面上，你可以把数据库看作是一个数据框的集合，在数据库术语中称为*表*。就像 `data.frame` 一样，数据库表是一组具有命名列的集合，其中每个列中的值都是相同类型的。数据框与数据库表之间有三个高级别的区别：
- en: Database tables are stored on disk and can be arbitrarily large. Data frames
    are stored in memory and are fundamentally limited (although that limit is still
    plenty large for many problems).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库表存储在磁盘上，可以任意大。数据框存储在内存中，并且基本上是有限的（尽管这个限制对于许多问题来说仍然很大）。
- en: Database tables almost always have indexes. Much like the index of a book, a
    database index makes it possible to quickly find rows of interest without having
    to look at every single row. Data frames and tibbles don’t have indexes, but data
    tables do, which is one of the reasons that they’re so fast.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库表几乎总是有索引的。就像书的索引一样，数据库索引使得能够快速找到感兴趣的行，而无需查看每一行。数据框和 tibble 没有索引，但数据表有，这也是它们如此快速的原因之一。
- en: Most classical databases are optimized for rapidly collecting data, not analyzing
    existing data. These databases are called *row-oriented* because the data is stored
    row by row, rather than column by column like R. More recently, there’s been much
    development of *column-oriented* databases that make analyzing the existing data
    much faster.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数经典数据库优化于快速收集数据，而不是分析现有数据。这些数据库被称为*面向行*，因为数据是按行存储的，而不像 R 那样按列存储。近年来，出现了许多*面向列*数据库的发展，这使得分析现有数据变得更加快速。
- en: 'Databases are run by database management systems (*DBMS* for short), which
    come in three basic forms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库由数据库管理系统（*DBMS* 简称）管理，基本上有三种形式：
- en: '*Client-server* DBMS run on a powerful central server, which you connect from
    your computer (the client). They are great for sharing data with multiple people
    in an organization. Popular client-server DBMS include PostgreSQL, MariaDB, SQL
    Server, and Oracle.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端-服务器* 数据库管理系统运行在强大的中央服务器上，你可以从你的计算机（客户端）连接到它们。它们非常适合在组织中与多人共享数据。流行的客户端-服务器
    DBMS 包括 PostgreSQL、MariaDB、SQL Server 和 Oracle。'
- en: '*Cloud* DBMS, like Snowflake, Amazon’s RedShift, and Google’s BigQuery, are
    similar to client-server DBMS, but they run in the cloud. This means they can
    easily handle extremely large datasets and can automatically provide more compute
    resources as needed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云* DBMS，如Snowflake、Amazon的RedShift和Google的BigQuery，类似于客户端-服务器DBMS，但运行在云端。这意味着它们可以轻松处理极大的数据集，并根据需要自动提供更多的计算资源。'
- en: '*In-process* DBMS, like SQLite or duckdb, run entirely on your computer. They’re
    great for working with large datasets where you’re the primary user.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程内* DBMS，如SQLite或duckdb，在你的计算机上完全运行。它们非常适合处理大数据集，你是主要用户。'
- en: Connecting to a Database
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'To connect to the database from R, you’ll use a pair of packages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要从R连接到数据库，你将使用一对包：
- en: You’ll always use DBI (*d*ata*b*ase *i*nterface) because it provides a set of
    generic functions that connect to the database, upload data, run SQL queries,
    etc.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你总是会使用DBI（数据库接口），因为它提供了一组通用函数，用于连接到数据库、上传数据、运行SQL查询等等。
- en: You’ll also use a package tailored for the DBMS you’re connecting to. This package
    translates the generic DBI commands into the specifics needed for a given DBMS.
    There’s usually one package for each DBMS, e.g., RPostgres for PostgreSQL and
    RMariaDB for MySQL.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还会使用专门为你连接的DBMS定制的包。这个包将通用的DBI命令转换为特定于给定DBMS所需的命令。通常每个DBMS都有一个包，例如，RPostgres用于PostgreSQL，RMariaDB用于MySQL。
- en: If you can’t find a specific package for your DBMS, you can usually use the
    odbc package instead. This uses the ODBC protocol supported by many DBMS. odbc
    requires a little more setup because you’ll also need to install an ODBC driver
    and tell the odbc package where to find it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到特定DBMS的包，通常可以使用odbc包代替。这使用许多DBMS支持的ODBC协议。odbc需要更多的设置，因为你还需要安装ODBC驱动程序并告诉odbc包在哪里找到它。
- en: 'Concretely, you create a database connection using [`DBI::dbConnect()`](https://dbi.r-dbi.org/reference/dbConnect.xhtml).
    The first argument selects the DBMS,^([2](ch21.xhtml#idm44771280761328)) and then
    the second and subsequent arguments describe how to connect to it (i.e., where
    it lives and the credentials that you need to access it). The following code shows
    a couple of typical examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你可以使用[`DBI::dbConnect()`](https://dbi.r-dbi.org/reference/dbConnect.xhtml)来创建数据库连接。第一个参数选择DBMS，^([2](ch21.xhtml#idm44771280761328))
    然后第二个及后续参数描述如何连接到它（即它的位置和需要访问它所需的凭据）。以下代码展示了几个典型的例子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The precise details of the connection vary a lot from DBMS to DBMS, so unfortunately
    we can’t cover all the details here. This means you’ll need to do a little research
    on your own. Typically you can ask the other data scientists in your team or talk
    to your DBA (*d*ata*b*ase *a*dministrator). The initial setup will often take
    a little fiddling (and maybe some googling) to get it right, but you’ll generally
    need to do it only once.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从DBMS到DBMS连接的详细信息会有很大的不同，所以遗憾的是我们无法在这里涵盖所有的细节。这意味着你需要自己做一些研究。通常你可以向团队中的其他数据科学家询问，或者与你的数据库管理员（DBA）交流。最初的设置通常需要一点调试（也许需要一些搜索），但通常只需做一次。
- en: In This Book
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本书中
- en: 'Setting up a client-server or cloud DBMS would be a pain for this book, so
    we’ll instead use an in-process DBMS that lives entirely in an R package: duckdb.
    Thanks to the magic of DBI, the only difference between using duckdb and any other
    DBMS is how you’ll connect to the database. This makes it great to teach with
    because you can easily run this code as well as easily take what you learn and
    apply it elsewhere.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书而设立客户端-服务器或云DBMS可能会很麻烦，因此我们将使用一个完全驻留在R包中的进程内DBMS：duckdb。多亏了DBI的魔力，使用duckdb和任何其他DBMS之间唯一的区别在于如何连接到数据库。这使得它非常适合教学，因为你可以轻松运行这段代码，同时也可以轻松地将所学内容应用到其他地方。
- en: 'Connecting to duckdb is particularly simple because the defaults create a temporary
    database that is deleted when you quit R. That’s great for learning because it
    guarantees that you’ll start from a clean slate every time you restart R:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到duckdb特别简单，因为默认情况下创建一个临时数据库，退出R时会删除。这对学习来说非常好，因为它保证每次重新启动R时都从一个干净的状态开始：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'duckdb is a high-performance database that’s designed very much for the needs
    of a data scientist. We use it here because it’s easy to get started with, but
    it’s also capable of handling gigabytes of data with great speed. If you want
    to use duckdb for a real data analysis project, you’ll also need to supply the
    `dbdir` argument to make a persistent database and tell duckdb where to save it.
    Assuming you’re using a project ([Chapter 6](ch06.xhtml#chp-workflow-scripts)),
    it’s reasonable to store it in the `duckdb` directory of the current project:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: duckdb 是专为数据科学家需求设计的高性能数据库。我们在这里使用它是因为它很容易入门，但它也能以极快的速度处理千兆字节的数据。如果你想在真实的数据分析项目中使用
    duckdb，你还需要提供 `dbdir` 参数来创建一个持久的数据库，并告诉 duckdb 在哪里保存它。假设你正在使用一个项目（[第6章](ch06.xhtml#chp-workflow-scripts)），把它存储在当前项目的
    `duckdb` 目录中是合理的：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Load Some Data
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载一些数据
- en: 'Since this is a new database, we need to start by adding some data. Here we’ll
    add the `mpg` and `diamonds` datasets from ggplot2 using [`DBI::dbWriteTable()`](https://dbi.r-dbi.org/reference/dbWriteTable.xhtml).
    The simplest usage of [`dbWriteTable()`](https://dbi.r-dbi.org/reference/dbWriteTable.xhtml)
    needs three arguments: a database connection, the name of the table to create
    in the database, and a data frame of data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个新的数据库，我们需要首先添加一些数据。在这里，我们将使用 [`DBI::dbWriteTable()`](https://dbi.r-dbi.org/reference/dbWriteTable.xhtml)
    添加 ggplot2 的 `mpg` 和 `diamonds` 数据集。[`dbWriteTable()`](https://dbi.r-dbi.org/reference/dbWriteTable.xhtml)
    的最简单用法需要三个参数：一个数据库连接，要在数据库中创建的表的名称，以及一个数据框。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you’re using duckdb in a real project, we highly recommend learning about
    `duckdb_read_csv()` and `duckdb_register_arrow()`. These give you powerful and
    performant ways to quickly load data directly into duckdb, without having to first
    load it into R. We’ll also show off a useful technique for loading multiple files
    into a database in [“Writing to a Database”](ch26.xhtml#sec-save-database).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个真实的项目中使用 duckdb，我们强烈推荐学习 `duckdb_read_csv()` 和 `duckdb_register_arrow()`。它们为你提供了强大和高效的方式，直接将数据快速加载到
    duckdb 中，而无需先加载到 R 中。我们还将展示一种有用的技术，用于将多个文件写入数据库，详见 [“Writing to a Database”](ch26.xhtml#sec-save-database)。
- en: DBI Basics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBI 基础
- en: 'You can check that the data is loaded correctly by using a couple of other
    DBI functions: `dbListTable()` lists all tables in the database,^([3](ch21.xhtml#idm44771280576144))
    and [`dbReadTable()`](https://dbi.r-dbi.org/reference/dbReadTable.xhtml) retrieves
    the contents of a table.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用几个其他的 DBI 函数来检查数据是否加载正确：`dbListTable()` 列出数据库中的所有表，^([3](ch21.xhtml#idm44771280576144))
    和 [`dbReadTable()`](https://dbi.r-dbi.org/reference/dbReadTable.xhtml) 检索表的内容。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[`dbReadTable()`](https://dbi.r-dbi.org/reference/dbReadTable.xhtml) returns
    a `data.frame`, so we use [`as_tibble()`](https://tibble.tidyverse.org/reference/as_tibble.xhtml)
    to convert it into a tibble so that it prints nicely.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[`dbReadTable()`](https://dbi.r-dbi.org/reference/dbReadTable.xhtml) 返回一个 `data.frame`，所以我们使用
    [`as_tibble()`](https://tibble.tidyverse.org/reference/as_tibble.xhtml) 将其转换为
    tibble，以便它可以漂亮地打印出来。'
- en: 'If you already know SQL, you can use [`dbGetQuery()`](https://dbi.r-dbi.org/reference/dbGetQuery.xhtml)
    to get the results of running a query on the database:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经了解 SQL，你可以使用 [`dbGetQuery()`](https://dbi.r-dbi.org/reference/dbGetQuery.xhtml)
    来获取在数据库上运行查询的结果：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’ve never seen SQL before, don’t worry! You’ll learn more about it shortly.
    But if you read it carefully, you might guess that it selects five columns of
    the `diamonds` dataset and all the rows where `price` is greater than 15,000.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没见过 SQL，别担心！你很快就会了解更多。但是如果你仔细阅读，你可能会猜到它选择了 `diamonds` 数据集的五列，并选择了所有 `price`
    大于 15,000 的行。
- en: dbplyr Basics
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dbplyr 基础
- en: Now that we’ve connected to a database and loaded up some data, we can start
    to learn about dbplyr. dbplyr is a dplyr *backend*, which means you keep writing
    dplyr code but the backend executes it differently. In this, dbplyr translates
    to SQL; other backends include [dtplyr](https://oreil.ly/9Dq5p), which translates
    to [data.table](https://oreil.ly/k3EaP), and [multidplyr](https://oreil.ly/gmDpk),
    which executes your code on multiple cores.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接到数据库并加载了一些数据，我们可以开始学习 dbplyr。dbplyr 是 dplyr 的一个 *后端*，这意味着你可以继续编写 dplyr
    代码，但后端会以不同的方式执行它。在这里，dbplyr 转换为 SQL；其他后端包括 [dtplyr](https://oreil.ly/9Dq5p)，它转换为
    [data.table](https://oreil.ly/k3EaP)，以及 [multidplyr](https://oreil.ly/gmDpk)，它可以在多个核心上执行你的代码。
- en: 'To use dbplyr, you must first use [`tbl()`](https://dplyr.tidyverse.org/reference/tbl.xhtml)
    to create an object that represents a database table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 dbplyr，你必须先使用 [`tbl()`](https://dplyr.tidyverse.org/reference/tbl.xhtml)
    来创建一个表示数据库表的对象：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two other common ways to interact with a database. First, many corporate
    databases are very large so you need some hierarchy to keep all the tables organized.
    In that case you might need to supply a schema, or a catalog and a schema, to
    pick the table you’re interested in:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库互动的另外两种常见方法。首先，许多企业数据库非常庞大，因此您需要一些层次结构来组织所有的表。在这种情况下，您可能需要提供一个模式或者一个目录和模式，以选择您感兴趣的表：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Other times you might want to use your own SQL query as a starting point:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望使用自己的 SQL 查询作为起点：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This object is *lazy*; when you use dplyr verbs on it, dplyr doesn’t do any
    work: it just records the sequence of operations that you want to perform and
    performs them only when needed. For example, take the following pipeline:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象是*惰性*的；当你在其上使用 dplyr 动词时，dplyr 不会进行任何操作：它只记录你希望执行的操作序列，并在需要时执行它们。例如，考虑以下管道：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can tell this object represents a database query because it prints the DBMS
    name at the top, and while it tells you the number of columns, it typically doesn’t
    know the number of rows. This is because finding the total number of rows usually
    requires executing the complete query, something we’re trying to avoid.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打印顶部的 DBMS 名称来确定这个对象表示一个数据库查询，尽管它告诉您列的数量，但通常不知道行的数量。这是因为找到总行数通常需要执行完整的查询，我们正试图避免这样做。
- en: You can see the SQL code generated by dplyr with the [`show_query()`](https://dplyr.tidyverse.org/reference/explain.xhtml)
    function. If you know dplyr, this is a great way to learn SQL! Write some dplyr
    code, get dbplyr to translate it to SQL and then try to figure out how the two
    languages match up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 [`show_query()`](https://dplyr.tidyverse.org/reference/explain.xhtml)
    函数查看 dplyr 生成的 SQL 代码。如果你了解 dplyr，这是学习 SQL 的好方法！编写一些 dplyr 代码，让 dbplyr 将其转换为 SQL，然后尝试弄清这两种语言如何匹配。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To get all the data back into R, you call [`collect()`](https://dplyr.tidyverse.org/reference/compute.xhtml).
    Behind the scenes, this generates the SQL, calls [`dbGetQuery()`](https://dbi.r-dbi.org/reference/dbGetQuery.xhtml)
    to get the data, and then turns the result into a tibble:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有数据带回 R，您可以调用[`collect()`](https://dplyr.tidyverse.org/reference/compute.xhtml)。在幕后，这会生成
    SQL 代码，调用 [`dbGetQuery()`](https://dbi.r-dbi.org/reference/dbGetQuery.xhtml) 获取数据，然后将结果转换为
    tibble：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Typically, you’ll use dbplyr to select the data you want from the database,
    performing basic filtering and aggregation using the translations described next.
    Then, once you’re ready to analyze the data with functions that are unique to
    R, you’ll collect the data using [`collect()`](https://dplyr.tidyverse.org/reference/compute.xhtml)
    to get an in-memory tibble and continue your work with pure R code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您将使用 dbplyr 从数据库中选择所需的数据，使用下面描述的翻译执行基本的过滤和聚合。然后，一旦准备用 R 特有的函数分析数据，您可以使用
    [`collect()`](https://dplyr.tidyverse.org/reference/compute.xhtml) 收集数据到内存中的 tibble，并继续您的工作与纯
    R 代码。
- en: SQL
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL
- en: The rest of the chapter will teach you a little SQL through the lens of dbplyr.
    It’s a rather nontraditional introduction to SQL, but we hope it will get you
    quickly up to speed with the basics. Luckily, if you understand dplyr, you’re
    in a great place to quickly pick up SQL because so many of the concepts are the
    same.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将通过 dbplyr 的视角向你介绍一点 SQL。这是一个非常非传统的 SQL 入门，但我们希望它能让你迅速掌握基础知识。幸运的是，如果你了解
    dplyr，那你很容易掌握 SQL，因为许多概念是相同的。
- en: 'We’ll explore the relationship between dplyr and SQL using a couple of old
    friends from the nycflights13 package: `flights` and `planes`. These datasets
    are easy to get into our learning database because dbplyr comes with a function
    that copies the tables from nycflights13 to our database:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 nycflights13 包中的两个老朋友 `flights` 和 `planes` 来探索 dplyr 和 SQL 之间的关系。这些数据集很容易导入我们的学习数据库，因为
    dbplyr 自带一个将 nycflights13 中的表复制到我们数据库中的函数：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: SQL Basics
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 基础知识
- en: The top-level components of SQL are called *statements*. Common statements include
    `CREATE` for defining new tables, `INSERT` for adding data, and `SELECT` for retrieving
    data. We will on focus on `SELECT` statements, also called *queries*, because
    they are almost exclusively what you’ll use as a data scientist.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 的顶层组件被称为*语句*。常见的语句包括用于定义新表的`CREATE`，用于添加数据的`INSERT`，以及用于检索数据的`SELECT`。我们将重点关注`SELECT`语句，也称为*查询*，因为这几乎是数据科学家经常使用的。
- en: 'A query is made up of *clauses*. There are five important clauses: `SELECT`,
    `FROM`, `WHERE`, `ORDER BY`, and `GROUP BY`. Every query must have the `SELECT`^([4](ch21.xhtml#idm44771280084352))
    and `FROM`^([5](ch21.xhtml#idm44771280052864)) clauses, and the simplest query
    is `SELECT * FROM table`, which selects all columns from the specified table.
    This is what dbplyr generates for an unadulterated table:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查询由 *子句* 组成。有五个重要的子句：`SELECT`、`FROM`、`WHERE`、`ORDER BY` 和 `GROUP BY`。每个查询必须包含
    `SELECT`^([4](ch21.xhtml#idm44771280084352)) 和 `FROM`^([5](ch21.xhtml#idm44771280052864))
    子句，最简单的查询是 `SELECT * FROM table`，它从指定的表中选择所有列。这是未经修改的表时 `dbplyr` 生成的内容：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`WHERE` and `ORDER BY` control which rows are included and how they are ordered:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 和 `ORDER BY` 控制包含哪些行以及如何排序：'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`GROUP BY` converts the query to a summary, causing aggregation to happen:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUP BY` 将查询转换为摘要，导致聚合操作发生：'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are two important differences between dplyr verbs and `SELECT` clauses:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dplyr` 动词和 `SELECT` 子句之间存在两个重要的区别：
- en: 'In SQL, case doesn’t matter: you can write `select`, `SELECT`, or even `SeLeCt`.
    In this book we’ll stick with the common convention of writing SQL keywords in
    uppercase to distinguish them from table or variables names.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQL 中，大小写不重要：可以写成 `select`、`SELECT`，甚至 `SeLeCt`。本书中我们将坚持使用大写字母来写 SQL 关键字，以区分它们与表或变量名。
- en: 'In SQL, order matters: you must always write the clauses in the order `SELECT`,
    `FROM`, `WHERE`, `GROUP BY`, and `ORDER BY`. Confusingly, this order doesn’t match
    how the clauses are actually evaluated, which is first `FROM` and then `WHERE`,
    `GROUP BY`, `SELECT`, and `ORDER BY`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQL 中，顺序很重要：必须按照 `SELECT`、`FROM`、`WHERE`、`GROUP BY` 和 `ORDER BY` 的顺序书写子句。令人困惑的是，这个顺序并不匹配子句实际执行的顺序，实际上是先执行
    `FROM`，然后是 `WHERE`、`GROUP BY`、`SELECT` 和 `ORDER BY`。
- en: The following sections explore each clause in more detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分详细探讨了每个子句。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that while SQL is a standard, it is extremely complex, and no database
    follows the standard exactly. While the main components that we’ll focus on in
    this book are similar between DBMSs, there are many minor variations. Fortunately,
    dbplyr is designed to handle this problem and generates different translations
    for different databases. It’s not perfect, but it’s continually improving, and
    if you hit a problem, you can file an issue [on GitHub](https://oreil.ly/xgmg8)
    to help us do better.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 SQL 是一个标准，但它非常复杂，没有数据库完全遵循该标准。尽管我们在本书中将关注的主要组件在不同 DBMS 之间相似，但存在许多细小的变化。幸运的是，`dbplyr`
    被设计来处理这个问题，并为不同的数据库生成不同的翻译。它并非完美，但在不断改进，如果遇到问题，您可以在 [GitHub](https://oreil.ly/xgmg8)
    上提出问题以帮助我们做得更好。
- en: SELECT
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELECT
- en: The `SELECT` clause is the workhorse of queries and performs the same job as
    [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml), [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml),
    [`rename()`](https://dplyr.tidyverse.org/reference/rename.xhtml), [`relocate()`](https://dplyr.tidyverse.org/reference/relocate.xhtml),
    and, as you’ll learn in the next section, [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 子句是查询的核心，执行与 [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)，[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)，[`rename()`](https://dplyr.tidyverse.org/reference/rename.xhtml)，[`relocate()`](https://dplyr.tidyverse.org/reference/relocate.xhtml)
    和你将在下一节中学到的 [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    相同的工作。'
- en: '[`select()`](https://dplyr.tidyverse.org/reference/select.xhtml), [`rename()`](https://dplyr.tidyverse.org/reference/rename.xhtml),
    and [`relocate()`](https://dplyr.tidyverse.org/reference/relocate.xhtml) have
    very direct translations to `SELECT` as they just affect where a column appears
    (if at all) along with its name:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)，[`rename()`](https://dplyr.tidyverse.org/reference/rename.xhtml)，和
    [`relocate()`](https://dplyr.tidyverse.org/reference/relocate.xhtml) 都有非常直接的对应
    `SELECT` 的翻译，因为它们只影响列出现的位置（如果有的话）以及列的名称：'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example also shows you how SQL does renaming. In SQL terminology, renaming
    is called *aliasing* and is done with `AS`. Note that unlike [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml),
    the old name is on the left, and the new name is on the right.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例还展示了 SQL 如何进行重命名。在 SQL 术语中，重命名称为 *别名*，并使用 `AS` 进行操作。请注意，与 [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    不同的是，旧名称在左侧，新名称在右侧。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous examples, note that `"year"` and `"type"` are wrapped in double
    quotes. That’s because these are *reserved words* in duckdb, so dbplyr quotes
    them to avoid any potential confusion between column/table names and SQL operators.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，请注意`"year"`和`"type"`被包裹在双引号中。这是因为它们在duckdb中是*保留词*，所以dbplyr将它们用引号括起来，以避免在列/表名和SQL操作符之间产生任何潜在混淆。
- en: 'When working with other databases, you’re likely to see every variable name
    quoted because only a handful of client packages, like duckdb, know what all the
    reserved words are, so they quote everything to be safe:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他数据库一起工作时，你可能会看到每个变量名都被引用，因为只有少数客户端包（如duckdb）知道所有的保留词，所以它们为了安全起见将所有内容都加了引号：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Some other database systems use backticks instead of quotes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些数据库系统使用反引号而不是引号：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The translations for [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    are similarly straightforward: each variable becomes a new expression in `SELECT`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)的翻译同样很简单：每个变量在`SELECT`中成为一个新的表达式：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ll come back to the translation of individual components (like `/`) in [“Function
    Translations”](#sec-sql-expressions).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[“函数翻译”](#sec-sql-expressions)中回顾个别组件（如`/`）的翻译。
- en: FROM
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FROM
- en: The `FROM` clause defines the data source. It’s going to be rather uninteresting
    for a little while, because we’re just using single tables. You’ll see more complex
    examples once we hit the join functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`子句定义了数据源。一开始它可能不是很有趣，因为我们只是使用单表。一旦涉及到连接函数，你会看到更复杂的例子。'
- en: GROUP BY
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP BY
- en: '[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml) is translated
    to the `GROUP BY`^([6](ch21.xhtml#idm44771279537344)) clause, and [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    is translated to the `SELECT` clause:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)被翻译为`GROUP
    BY`^([6](ch21.xhtml#idm44771279537344))子句，而[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)则被翻译为`SELECT`子句：'
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ll come back to what’s happening with translating [`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)
    and [`mean()`](https://rdrr.io/r/base/mean.xhtml) in [“Function Translations”](#sec-sql-expressions).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[“函数翻译”](#sec-sql-expressions)中回顾[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)和[`mean()`](https://rdrr.io/r/base/mean.xhtml)的翻译过程。
- en: WHERE
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WHERE
- en: '[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml) is translated
    to the `WHERE` clause:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)被翻译为`WHERE`子句：'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are a few important details to note here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意几个重要的细节：
- en: '`|` becomes `OR`, and `&` becomes `AND`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`变成`OR`，`&`变成`AND`。'
- en: SQL uses `=` for comparison, not `==`. SQL doesn’t have assignment, so there’s
    no potential for confusion there.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL使用`=`进行比较，而不是`==`。SQL中没有赋值操作，所以在这方面没有混淆的可能性。
- en: SQL uses only `''` for strings, not `""`. In SQL, `""` is used to identify variables,
    like R’s [PRE23].
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL中只使用`''`表示字符串，而不是`""`。在SQL中，`""`用于标识变量，就像R的[PRE23]一样。
- en: 'Another useful SQL operator is `IN`, which is close to R’s `%in%`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的SQL操作符是`IN`，它与R的`%in%`相似：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'SQL uses `NULL` instead of `NA`. `NULL`s behave similarly to `NA`s. The main
    difference is that while they’re “infectious” in comparisons and arithmetic, they
    are silently dropped when summarizing. dbplyr will remind you about this behavior
    the first time you hit it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SQL使用`NULL`而不是`NA`。`NULL`在比较和算术运算中的行为类似于`NA`。主要的区别在于，当进行汇总时，它们会被静默地丢弃。当你第一次遇到时，dbplyr会提醒你这种行为：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you want to learn more about how `NULL`s work, you might enjoy [“The Three-Valued
    Logic of SQL”](https://oreil.ly/PTwQz) by Markus Winand.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`NULL`如何工作的信息，你可能会喜欢Markus Winand的[“SQL的三值逻辑”](https://oreil.ly/PTwQz)。
- en: 'In general, you can work with `NULL`s using the functions you’d use for `NA`s
    in R:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，你可以使用在R中处理`NA`时使用的函数来处理`NULL`：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This SQL query illustrates one of the drawbacks of dbplyr: while the SQL is
    correct, it isn’t as simple as you might write by hand. In this case, you could
    drop the parentheses and use a special operator that’s easier to read:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQL查询展示了dbplyr的一个缺点：虽然SQL是正确的，但并不像你手写的那样简单。在这种情况下，你可以去掉括号，并使用一个更容易阅读的特殊操作符：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that if you [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)
    a variable that you created using a summarize, dbplyr will generate a `HAVING`
    clause, rather than a `WHERE` clause. This is a one of the idiosyncrasies of SQL:
    `WHERE` is evaluated before `SELECT` and `GROUP BY`, so SQL needs another clause
    that’s evaluated afterward.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你用`summarize`创建的变量进行[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)，`dbplyr`会生成`HAVING`子句，而不是`WHERE`子句。这是SQL的一个特殊之处：`WHERE`在`SELECT`和`GROUP
    BY`之前评估，所以SQL需要另一个在其后评估的子句。
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ORDER BY
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORDER BY
- en: 'Ordering rows involves a straightforward translation from [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)
    to the `ORDER BY` clause:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对行进行排序涉及从[`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)到`ORDER
    BY`子句的直接翻译：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice how [`desc()`](https://dplyr.tidyverse.org/reference/desc.xhtml) is
    translated to `DESC`: this is one of the many dplyr functions whose name was directly
    inspired by SQL.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[`desc()`](https://dplyr.tidyverse.org/reference/desc.xhtml)如何翻译成`DESC`：这是许多`dplyr`函数之一，其命名直接受到SQL启发。
- en: Subqueries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子查询
- en: Sometimes it’s not possible to translate a dplyr pipeline into a single `SELECT`
    statement and you need to use a subquery. A *subquery* is just a query used as
    a data source in the `FROM` clause, instead of the usual table.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候无法将一个`dplyr`管道翻译成单个`SELECT`语句，需要使用子查询。*子查询*就是作为`FROM`子句中数据源的查询，而不是通常的表格。
- en: 'dbplyr typically uses subqueries to work around the limitations of SQL. For
    example, expressions in the `SELECT` clause can’t refer to columns that were just
    created. That means that the following (silly) dplyr pipeline needs to happen
    in two steps: the first (inner) query computes `year1`, and then the second (outer)
    query can compute `year2`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbplyr`通常使用子查询来解决SQL的限制。例如，`SELECT`子句中的表达式不能引用刚刚创建的列。这意味着以下（愚蠢的）`dplyr`管道需要分两步进行：第一个（内部）查询计算`year1`，然后第二个（外部）查询可以计算`year2`：'
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You’ll also see this if you attempted to [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)
    a variable that you just created. Remember, even though `WHERE` is written after
    `SELECT`, it’s evaluated before it, so we need a subquery in this (silly) example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试对刚创建的变量进行[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)，也会看到这种情况。记住，尽管`WHERE`在`SELECT`之后编写，但它在之前评估，因此在这个（愚蠢的）例子中我们需要一个子查询：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sometimes dbplyr will create a subquery where it’s not needed because it doesn’t
    yet know how to optimize that translation. As dbplyr improves over time, these
    cases will get rarer but will probably never go away.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候`dbplyr`会创建不必要的子查询，因为它尚不知道如何优化这种转换。随着时间推移，`dbplyr`的改进会使这类情况变得更少，但可能永远不会消失。
- en: Joins
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: 'If you’re familiar with dplyr’s joins, SQL joins are similar. Here’s a simple
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉`dplyr`的连接操作，SQL的连接操作也是类似的。这里有一个简单的例子：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The main thing to notice here is the syntax: SQL joins use subclauses of the
    `FROM` clause to bring in additional tables, using `ON` to define how the tables
    are related.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的主要是语法：SQL连接使用`FROM`子句的子子句引入额外的表格，并使用`ON`来定义表格之间的关系。
- en: 'dplyr’s names for these functions are so closely connected to SQL that you
    can easily guess the equivalent SQL for [`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml),
    [`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml), and
    [`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`中这些函数的命名与SQL密切相关，因此你可以轻松推测[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)、[`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)和[`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)的等效SQL语句：'
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You’re likely to need many joins when working with data from a database. That’s
    because database tables are often stored in a highly normalized form, where each
    “fact” is stored in a single place, and to keep a complete dataset for analysis,
    you need to navigate a complex network of tables connected by primary and foreign
    keys. If you hit this scenario, the [dm package](https://oreil.ly/tVS8h), by Tobias
    Schieferdecker, Kirill Müller, and Darko Bergant, is a lifesaver. It can automatically
    determine the connections between tables using the constraints that DBAs often
    supply, visualize the connections so you can see what’s going on, and generate
    the joins you need to connect one table to another.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当从数据库中处理数据时，你可能需要许多连接。这是因为数据库表通常以高度规范化的形式存储，每个“事实”都存储在一个地方，为了保持完整的数据集进行分析，你需要浏览通过主键和外键连接的复杂网络表。如果遇到这种情况，Tobias
    Schieferdecker、Kirill Müller和Darko Bergant的[dm包](https://oreil.ly/tVS8h)会帮上大忙。它可以自动确定表之间的连接，使用DBA通常提供的约束条件可视化连接情况，生成你需要连接一个表到另一个表的连接。
- en: Other Verbs
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他动词
- en: dbplyr also translates other verbs such as [`distinct()`](https://dplyr.tidyverse.org/reference/distinct.xhtml),
    `slice_*()`, and [`intersect()`](https://generics.r-lib.org/reference/setops.xhtml),
    as well as a growing selection of tidyr functions such as [`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)
    and [`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.xhtml).
    The easiest way to see the full set of what’s currently available is to visit
    the [dbplyr website](https://oreil.ly/A8OGW).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: dbplyr还翻译其他动词，如[`distinct()`](https://dplyr.tidyverse.org/reference/distinct.xhtml)，`slice_*()`，以及[`intersect()`](https://generics.r-lib.org/reference/setops.xhtml)，还有越来越多的tidyr函数，如[`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)和[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.xhtml)。查看目前提供的完整集合最简单的方法是访问[dbplyr网站](https://oreil.ly/A8OGW)。
- en: Exercises
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: What is [`distinct()`](https://dplyr.tidyverse.org/reference/distinct.xhtml)
    translated to? How about [`head()`](https://rdrr.io/r/utils/head.xhtml)?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`distinct()`](https://dplyr.tidyverse.org/reference/distinct.xhtml)被翻译成什么？[`head()`](https://rdrr.io/r/utils/head.xhtml)呢？'
- en: 'Explain what each of the following SQL queries do and try to re-create them
    using dbplyr:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释下面每个SQL查询的作用，并尝试使用dbplyr重新创建它们：
- en: '[PRE34]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Function Translations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数翻译
- en: So far we’ve focused on the big picture of how dplyr verbs are translated to
    the clauses of a query. Now we’re going to zoom in a little and talk about the
    translation of the R functions that work with individual columns; e.g., what happens
    when you use `mean(x)` in [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经集中讨论了dplyr动词如何翻译成查询语句的主要内容。现在我们将稍微深入一点，讨论与单个列一起工作的R函数的翻译；例如，在[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)中使用`mean(x)`时会发生什么？
- en: To help see what’s going on, we’ll use a couple of little helper functions that
    run a [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml) or
    [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) and show the
    generated SQL. That will make it a little easier to explore a few variations and
    see how summaries and transformations can differ.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解正在发生的事情，我们将使用几个小助手函数来运行[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)或[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)，并显示生成的SQL。这将使探索几种变化，以及摘要和转换如何不同，变得更加容易。
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s dive in with some summaries! Looking at the following code, you’ll notice
    that some summary functions, such as [`mean()`](https://rdrr.io/r/base/mean.xhtml),
    have a relatively simple translation, while others like [`median()`](https://rdrr.io/r/stats/median.xhtml)
    are much more complex. The complexity is typically higher for operations that
    are common in statistics but less common in databases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些摘要来深入研究！看看以下代码，你会注意到一些摘要函数，比如[`mean()`](https://rdrr.io/r/base/mean.xhtml)，其翻译相对简单，而像[`median()`](https://rdrr.io/r/stats/median.xhtml)这样的函数则复杂得多。这种复杂性通常更高，适用于统计学中常见但在数据库中不太常见的操作。
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The translation of summary functions becomes more complicated when you use
    them inside a [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    because they have to turn into so-called *window* functions. In SQL, you turn
    an ordinary aggregation function into a window function by adding `OVER` after
    it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)中使用它们时，摘要函数的翻译会变得更加复杂，因为它们必须转变为所谓的*窗口*函数。在SQL中，你可以通过在普通聚合函数后添加`OVER`来将普通聚合函数转变为窗口函数：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In SQL, the `GROUP BY` clause is used exclusively for summaries, so here you
    can see that the grouping has moved from the `PARTITION BY` argument to `OVER`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，`GROUP BY`子句专门用于汇总，因此您可以看到分组已从`PARTITION BY`参数移至`OVER`。
- en: 'Window functions include all functions that look forward or backward, such
    as [`lead()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml) and [`lag()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml),
    which look at the “previous” or “next” value, respectively:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数包括所有向前或向后查找的函数，例如[`lead()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml)和[`lag()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml)，它们分别查看“前一个”或“后一个”值：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here it’s important to [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)
    the data, because SQL tables have no intrinsic order. In fact, if you don’t use
    [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml), you might
    get the rows back in a different order every time! Notice for window functions,
    the ordering information is repeated: the `ORDER BY` clause of the main query
    doesn’t automatically apply to window functions.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重要的是对数据进行[`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)，因为SQL表没有固有的顺序。实际上，如果不使用[`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)，每次都可能以不同的顺序返回行！请注意，对于窗口函数，排序信息是重复的：主查询的`ORDER
    BY`子句不会自动应用于窗口函数。
- en: 'Another important SQL function is `CASE WHEN`. It’s used as the translation
    of [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml) and [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml),
    the dplyr function that it directly inspired. Here are a couple of simple examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的SQL函数是`CASE WHEN`。它被用作[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)和[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)的翻译，这两个是直接受其启发的dplyr函数。这里有几个简单的示例：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`CASE WHEN` is also used for some other functions that don’t have a direct
    translation from R to SQL. A good example of this is [`cut()`](https://rdrr.io/r/base/cut.xhtml):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`CASE WHEN`也用于一些从R到SQL没有直接翻译的其他函数。其中一个很好的例子是[`cut()`](https://rdrr.io/r/base/cut.xhtml)。'
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: dbplyr also translates common string and date-time manipulation functions, which
    you can learn about in [`vignette("translation-function", package = "dbplyr")`](https://dbplyr.tidyverse.org/articles/translation-function.xhtml).
    dbplyr’s translations are certainly not perfect, and there are many R functions
    that aren’t translated yet, but dbplyr does a surprisingly good job covering the
    functions that you’ll use most of the time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: dbplyr还可以翻译常见的字符串和日期时间操作函数，您可以在[`vignette("translation-function", package =
    "dbplyr")`](https://dbplyr.tidyverse.org/articles/translation-function.xhtml)中了解这些。dbplyr的翻译虽然不完美，但对于您大部分时间使用的函数来说，效果出奇的好。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter you learned how to access data from databases. We focused on
    dbplyr, a dplyr “backend” that allows you to write the dplyr code you’re familiar
    with and have it be automatically translated to SQL. We used that translation
    to teach you a little SQL; it’s important to learn some SQL because it’s *the*
    most commonly used language for working with data and knowing some will make it
    easier for you to communicate with other data folks who don’t use R. If you’ve
    finished this chapter and would like to learn more about SQL, we have two recommendations:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何从数据库访问数据。我们专注于dbplyr，这是一个dplyr的“后端”，允许您编写熟悉的dplyr代码，并自动将其转换为SQL。我们利用这种转换教您了一些SQL；学习一些SQL很重要，因为它是处理数据最常用的语言，掌握一些SQL会使您更容易与其他不使用R的数据专业人员交流。如果您完成了本章并希望了解更多关于SQL的知识，我们有两个推荐：
- en: '[*SQL for Data Scientists*](https://oreil.ly/QfAat) by Renée M. P. Teate is
    an introduction to SQL designed specifically for the needs of data scientists
    and includes examples of the sort of highly interconnected data you’re likely
    to encounter in real organizations.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*数据科学家的 SQL*](https://oreil.ly/QfAat)由Renée M. P. Teate编写，专为数据科学家的需求设计的SQL介绍，并包括您在真实组织中可能遇到的高度互联数据的示例。'
- en: '[*Practical SQL*](https://oreil.ly/-0Usp) by Anthony DeBarros is written from
    the perspective of a data journalist (a data scientist specialized in telling
    compelling stories) and goes into more detail about getting your data into a database
    and running your own DBMS.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*实用 SQL*](https://oreil.ly/-0Usp)由安东尼·德巴罗斯（Anthony DeBarros）从数据记者的视角（一位专门讲述引人入胜故事的数据科学家）撰写，详细介绍了如何将数据导入数据库并运行自己的数据库管理系统（DBMS）。'
- en: 'In the next chapter, we’ll learn about another dplyr backend for working with
    large data: arrow. The arrow package is designed for working with large files
    on disk and is a natural complement to databases.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个用于处理大数据的 dplyr 后端：arrow。arrow 包设计用于处理磁盘上的大文件，是数据库的自然补充。
- en: ^([1](ch21.xhtml#idm44771280827536-marker)) SQL is either pronounced “s”-“q”-“l”
    or “sequel.”
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch21.xhtml#idm44771280827536-marker)) SQL 可以发音为 “s”-“q”-“l” 或 “sequel”。
- en: ^([2](ch21.xhtml#idm44771280761328-marker)) Typically, this is the only function
    you’ll use from the client package, so we recommend using `::` to pull out that
    one function, rather than loading the complete package with [`library()`](https://rdrr.io/r/base/library.xhtml).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch21.xhtml#idm44771280761328-marker)) 通常，这是你从客户端包中使用的唯一函数，因此我们建议使用 `::`
    来提取那个函数，而不是用 [`library()`](https://rdrr.io/r/base/library.xhtml) 加载整个包。
- en: ^([3](ch21.xhtml#idm44771280576144-marker)) At least, all the tables that you
    have permission to see.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch21.xhtml#idm44771280576144-marker)) 至少是你有权限查看的所有表。
- en: ^([4](ch21.xhtml#idm44771280084352-marker)) Confusingly, depending on the context,
    `SELECT` is either a statement or a clause. To avoid this confusion, we’ll generally
    use `SELECT` query instead of `SELECT` statement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch21.xhtml#idm44771280084352-marker)) 令人困惑的是，根据上下文，`SELECT` 可能是语句，也可能是子句。为避免混淆，我们通常使用
    `SELECT` 查询而不是 `SELECT` 语句。
- en: ^([5](ch21.xhtml#idm44771280052864-marker)) Technically, only the `SELECT` is
    required, since you can write queries like `SELECT 1+1` to perform basic calculations.
    But if you want to work with data (as you always do!), you’ll also need a `FROM`
    clause.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch21.xhtml#idm44771280052864-marker)) 严格来说，只需要 `SELECT`，因为你可以编写像 `SELECT
    1+1` 这样的查询来进行基本计算。但如果你想处理数据（正如你总是需要的！），你还需要 `FROM` 子句。
- en: '^([6](ch21.xhtml#idm44771279537344-marker)) This is no coincidence: the dplyr
    function name was inspired by the SQL clause.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch21.xhtml#idm44771279537344-marker)) 这并非巧合：dplyr 函数名受到了 SQL 语句的启发。
