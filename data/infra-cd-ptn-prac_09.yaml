- en: 7 Continuous delivery and branching models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 持续交付和分支模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Designing delivery pipelines to avoid pushing failures to production systems
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计交付管道以避免将失败推送到生产系统
- en: Choosing a branching model for infrastructure configuration for team collaboration
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为团队协作选择基础设施配置的分支模型
- en: Reviewing and managing changes to infrastructure resources within your team
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查和管理团队内部基础设施资源的变更
- en: In the previous chapters, you learned how to write patterns for modules and
    dependencies. You also applied some general practices for writing infrastructure
    as code and sharing modules. The patterns, practices, and workflows had a lot
    of steps.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何编写模块和依赖项的模式。你还应用了一些编写基础设施代码和共享模块的一般实践。这些模式、实践和工作流程有很多步骤。
- en: Furthermore, many of the workflows require careful coordination of changes.
    One day, you might try to make a change only to find out that your teammate’s
    updates might overwrite yours! How do you make sure you manage conflicts during
    the development process?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多工作流程需要仔细协调变更。有一天，你可能会尝试进行一个变更，却发现你的队友的更新可能会覆盖你的变更！你如何确保你在开发过程中管理好冲突？
- en: One solution involves submitting change requests to a ticketing system. For
    example, if you want to change a server, you’d need to fill out a change request
    in your ticketing system. This change request then gets reviewed by your peers
    (usually your team) and the change advisory board (on behalf of the company).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是向票务系统提交变更请求。例如，如果你想更改服务器，你需要在票务系统中填写变更请求。然后，这个变更请求将由你的同行（通常是你的团队）和变更咨询委员会（代表公司）进行审查。
- en: Most companies use this process, called *change management*, to figure out which
    changes conflict. Infrastructure change management involves submitting a change
    request detailing rollout and rollback steps for peer reviewers’ approval.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公司使用这个被称为*变更管理*的过程来确定哪些变更存在冲突。基础设施变更管理涉及提交一个变更请求，详细说明部署和回滚步骤，供同行审查批准。
- en: Definition *Change management* for infrastructure is a process that facilitates
    a change to a system. It often involves detailing and reviewing the change across
    a company before approving it for production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*变更管理*对于基础设施来说是一个促进系统变更的过程。它通常涉及在批准投入生产之前，在整个公司中详细审查和审查变更。
- en: Change management depends on peer review to prevent changes from overwriting
    each other. The peer review and change advisory board in the example serve as
    quality gates. *Quality gates* verify that the change request does not compromise
    a system’s security or availability. Once your change passes the gates, you can
    schedule it and update the server accordingly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 变更管理依赖于同行审查，以防止变更相互覆盖。示例中的同行审查和变更咨询委员会充当质量门。*质量门*验证变更请求不会损害系统的安全或可用性。一旦你的变更通过了这些门，你就可以安排它并相应地更新服务器。
- en: Definition *Quality gates* for IaC enforce a system’s security, availability,
    and resiliency through review or tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*IaC*的*质量门*通过审查或测试来强制执行系统的安全性、可用性和弹性。
- en: How do change management and quality gates help solve conflicts between changes?
    Imagine you applied the change management process to your and your teammate’s
    conflicting changes. In figure 7.1, you and your teammate submit change requests
    to the ticketing system. Peers across the organization manually review each change
    and determine that your teammate’s change has a minimal impact on users. They
    reschedule your change for another day to avoid conflict with your teammate’s
    change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 变更管理和质量门如何帮助解决变更之间的冲突？想象一下，你将变更管理流程应用于你和你的队友的冲突变更。在图7.1中，你和你的队友向票务系统提交变更请求。组织内的同行手动审查每个变更，并确定你的队友的变更对用户的影响最小。他们重新安排你的变更，以避免与你的队友的变更冲突。
- en: '![](../../OEBPS/Images/CH07_F01_Wang.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F01_Wang.png)'
- en: Figure 7.1 Collaboration on IaC involves streamlining the process of peer and
    organizational review of changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 IaC的协作涉及简化同行和组织审查变更的过程。
- en: Change management can take weeks to complete. Manual review doesn’t catch every
    problem or prevent every infrastructure change conflict. You still need to understand
    how to revert changes. You’ll learn about fixing change failures in chapter 11.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 变更管理可能需要几周才能完成。人工审查无法发现每个问题或防止每个基础设施变更冲突。你仍然需要了解如何撤销变更。你将在第11章学习如何修复变更失败。
- en: Rather than rely on change management, you can use IaC to *communicate* changes
    through code and *automate* change management. This chapter focuses on streamlining
    change management by scaling and automating IaC development processes across your
    team and company. You’ll face the challenge of people working on the same or dependent
    resources while trying not to break a production system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是依赖变更管理，你可以使用基础设施即代码（IaC）通过代码来*沟通*变更并*自动化*变更管理。本章重点介绍通过扩展和自动化团队和公司内的IaC开发流程来简化变更管理。你将面临在尝试不破坏生产系统的情况下，同时处理同一或依赖资源上工作的挑战。
- en: Image building and configuration management
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和配置管理
- en: Throughout this book, I focus on the use case of provisioning infrastructure.
    Use cases for image building and configuration management should follow the general
    pattern for delivery pipelines in this chapter. The patterns and practices to
    assess infrastructure changes and incorporate automated testing remain consistent
    for all use cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我专注于基础设施供应的使用案例。构建和配置管理的使用案例应遵循本章中交付管道的一般模式。评估基础设施更改和纳入自动化测试的模式和实践对所有使用案例都是一致的。
- en: 7.1 Delivering changes to production
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 将更改交付到生产环境
- en: How do you control IaC changes to a production environment? You apply software
    development practices like continuous integration, delivery, or deployment (CI/CD)
    to organize code changes from various collaborators and prepare to release IaC
    to a production environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何控制IaC对生产环境的更改？你应用软件开发实践，如持续集成、交付或部署（CI/CD），来组织来自各种协作者的代码更改，并准备将IaC发布到生产环境。
- en: CI/CD requires automated testing to automate the release and management of changes.
    I’ll explain how you can automate infrastructure changes and make the most of
    its benefits. It uses the testing practices you learned from the preceding chapter
    with the delivery pipeline patterns in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD需要自动化测试来自动化更改的发布和管理。我将解释你如何自动化基础设施更改并充分利用其优势。它使用你在上一章中学到的测试实践以及本章中的交付管道模式。
- en: 7.1.1 Continuous integration
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 持续集成
- en: Recall the IaC conflict you ran into with your teammate. You did not know your
    teammate’s change would affect yours, and vice versa. How do you automatically
    identify the conflicts before your peers review your change?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你与队友遇到的IaC冲突。你不知道你的队友的更改会影响你的，反之亦然。你如何在同行审查你的更改之前自动识别冲突？
- en: One solution in figure 7.2 involves asking your team to regularly merge its
    changes into the main IaC. If your team continuously *integrates* its changes
    into the main configuration, you and your teammate can identify the conflicts
    earlier, before they overwrite your updates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2中的一个解决方案是要求你的团队定期将其更改合并到主IaC中。如果你的团队持续地将更改*集成*到主配置中，你和你的队友可以更早地识别冲突，在它们覆盖你的更新之前。
- en: You can apply the practice of *continuous integration* (*CI*) to merge your
    changes into the main configuration multiple times a day and check whether they
    conflict with collaborators.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将*持续集成*（CI）的实践应用到合并更改到主配置中，每天多次，并检查它们是否与协作者冲突。
- en: Definition *Continuous integration* (*CI*) for IaC is a practice of regularly
    and frequently merging changes into your repository after verifying the change
    in a testing environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IaC，*持续集成*（CI）的定义是在测试环境中验证更改后，定期和频繁地将更改合并到你的存储库中。
- en: '![](../../OEBPS/Images/CH07_F02_Wang.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F02_Wang.png)'
- en: Figure 7.2 Continuous integration involves merging changes to the main configuration
    often, allowing earlier identification of conflicts in changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 持续集成涉及频繁地将更改合并到主配置中，从而允许更早地识别更改中的冲突。
- en: How often should you merge? Knowing when to merge requires a bit of experience
    and depends on the type of change you want to make. As a general rule, I merge
    when I accumulate a few lines of configuration change that (likely) will not break
    the system. Sometimes, this means I merge several times a day. Other times, for
    a difficult change, I might merge once or twice a day. The rest of the team also
    continues to work on and merge their changes a few times a day.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该多久合并一次？知道何时合并需要一些经验，并取决于你想要进行的更改类型。作为一个一般规则，当我积累了几行配置更改（可能）不会破坏系统时，我会合并。有时，这意味着我一天内可能合并几次。有时，对于困难的更改，我可能一天只合并一次或两次。其余的团队也会继续每天几次地工作并合并他们的更改。
- en: Each time a team member merges their changes, a build tool (such as a CI framework)
    should start a workflow to test the changes and deploy them. Figure 7.3 shows
    an example workflow that a build tool might run. The workflow checks IaC for merge
    conflicts, runs unit tests to verify formatting, and pauses for peer review. Once
    it passes peer review, the build tool deploys the changes to production.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每当团队成员合并他们的更改时，构建工具（如CI框架）应该启动一个工作流程来测试更改并将它们部署。图7.3显示了构建工具可能运行的一个示例工作流程。该工作流程检查IaC的合并冲突，运行单元测试以验证格式，并暂停进行同行评审。一旦通过同行评审，构建工具将更改部署到生产环境。
- en: '![](../../OEBPS/Images/CH07_F03_Wang.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F03_Wang.png)'
- en: Figure 7.3 CI in a delivery pipeline includes automated unit tests before waiting
    for manual approval to production.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3在交付管道中的CI包括在等待手动批准到生产之前自动化的单元测试。
- en: You can express this workflow as part of a *delivery pipeline*. A pipeline organizes
    and automates a set of stages to build, test, deploy, and release your IaC.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个工作流程表达为*交付管道*的一部分。管道组织并自动化一系列阶段，用于构建、测试、部署和发布你的基础设施即代码（IaC）。
- en: Definition A *delivery pipeline* for IaC expresses and automates a workflow
    to build, test, deploy, and release a change to infrastructure.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义IaC的*交付管道*表达并自动化一个工作流程，用于构建、测试、部署和发布对基础设施的更改。
- en: An infrastructure delivery pipeline starts by checking configuration conflicts
    or syntax problems. Unit testing in a CI pipeline offers you some confidence that
    you don’t have change conflicts. You can then submit the change to your team or
    company for review. The pipeline automatically releases (or applies) it to production.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施交付管道首先检查配置冲突或语法问题。CI管道中的单元测试让你有信心没有更改冲突。然后你可以将更改提交给团队或公司进行审查。管道会自动将其发布（或应用）到生产环境中。
- en: Why should you design a delivery pipeline and add it to your build tool? You
    might not remember all the steps you need to release a change to production. A
    delivery pipeline codifies the process so you don’t have to remember it. Agreeing
    on a delivery pipeline for infrastructure helps you scale infrastructure changes
    consistently and reproducibly, no matter the infrastructure resource.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该设计一个交付管道并将其添加到构建工具中？你可能不会记得发布更改到生产所需的全部步骤。交付管道将过程编码化，这样你就不需要记住它。同意基础设施的交付管道可以帮助你一致且可重复地扩展基础设施更改，无论基础设施资源如何。
- en: 7.1.2 Continuous delivery
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 持续交付
- en: You used CI to merge changes and check for conflicts, but how do you know if
    the system functions as you expect? CI validates formatting and standards, but
    you don’t know if the configuration works until release. You have some confidence
    in your unit test, but you need more tests to feel comfortable with the updates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了持续集成（CI）来合并更改并检查冲突，但你如何知道系统是否按预期运行？CI验证格式和标准，但你不知道配置是否在发布前工作。你对单元测试有信心，但你需要更多的测试来对更新感到舒适。
- en: Figure 7.4 reimagines the CI workflow you started for IaC. You update your delivery
    pipeline with extra stages after unit tests. Before you submit the change for
    peer review, you deploy the configuration to a testing environment and test it
    with integration and end-to-end tests. After peer review, you *deliver* the changes
    to production and rerun the end-to-end tests to verify production functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4重新构想了你为IaC开始的CI工作流程。你在单元测试之后更新你的交付管道，添加额外的阶段。在提交更改进行同行评审之前，你将配置部署到测试环境，并使用集成和端到端测试进行测试。同行评审后，你*交付*更改到生产，并重新运行端到端测试以验证生产功能。
- en: '![](../../OEBPS/Images/CH07_F04_Wang.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F04_Wang.png)'
- en: Figure 7.4 Continuous delivery automatically deploys and runs infrastructure
    changes in a testing environment and waits for manual approval for production.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4持续交付自动在测试环境中部署和运行基础设施更改，并等待手动批准到生产。
- en: You expanded your delivery pipeline with the practice of *continuous delivery*
    (*CD*). CD adds a step to your delivery pipeline that deploys your infrastructure
    configuration to a testing environment for integration or end-to-end testing after
    passing unit tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过实践*持续交付*（*CD*）扩展了你的交付管道。CD在通过单元测试后，将你的基础设施配置部署到测试环境进行集成或端到端测试的步骤添加到你的交付管道中。
- en: Definition *Continuous delivery* (*CD*) for IaC deploys your infrastructure
    change to a testing environment for integration or end-to-end testing after merging
    your changes to a repository. It can involve a manual quality gate before releasing
    the changes to production.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *持续交付* (*CD*) 对于基础设施即代码 (IaC)，在将您的更改合并到存储库后，将基础设施更改部署到测试环境进行集成或端到端测试。在将更改发布到生产环境之前，它可能涉及一个手动质量关卡。
- en: Whenever someone pushes a change to source control, it starts the pipeline’s
    workflow to verify the changes in a testing environment. Once the integration
    and end-to-end tests pass, the pipeline can wait for manual approval before deploying
    the changes to production.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有人将更改推送到源代码控制时，它就会启动管道的工作流程，以在测试环境中验证这些更改。一旦集成和端到端测试通过，管道可以等待人工审批，然后再将更改部署到生产环境。
- en: Why use CD over CI? CD incorporates all of the automated tests you worked hard
    to write in chapter 6\. Furthermore, its delivery pipeline includes *tests as
    quality gates*. A teammate reviewing your change might feel more confident about
    whether the tests verify the change implementation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 CD 而不是 CI？CD 包含了您在第六章中努力编写的所有自动化测试。此外，其交付管道包括 *作为质量关卡* 的测试。审查您更改的队友可能会对测试是否验证更改实现更有信心。
- en: Note Continuous delivery requires an entire book! I’ve applied it directly to
    infrastructure and tried to cover it in one section. If you want to review a more
    practical example, I created an example pipeline at [http://mng.bz/mOy8](http://mng.bz/mOy8).
    The pipeline uses GitHub Actions to deploy the hello-world service to Google Cloud
    Run. Its stages include unit tests, testing environment deployment, and integration
    tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 持续交付需要整本书来介绍！我已经直接将其应用于基础设施，并试图在单节中涵盖它。如果您想查看一个更实际的例子，我创建了一个示例管道，[http://mng.bz/mOy8](http://mng.bz/mOy8)。该管道使用
    GitHub Actions 将 hello-world 服务部署到 Google Cloud Run。其阶段包括单元测试、测试环境部署和集成测试。
- en: CD should involve small and frequent changes to code. You push these changes
    automatically to a testing environment and wait for manual approval before pushing
    them to production. However, changes waiting for manual approval accumulate like
    a traffic jam. A few cars that slow down can cascade to many cars, ultimately
    affecting your expected arrival time!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CD 应该涉及对代码的小幅度和频繁更改。您将这些更改自动推送到测试环境，并在将其推送到生产环境之前等待人工审批。然而，等待人工审批的更改会像交通堵塞一样积累。几辆减速的汽车可能会连锁反应到许多汽车，最终影响您的预期到达时间！
- en: A manual approval step builds a batch of changes, which introduces some problems.
    When you push a large batch of changes into production in figure 7.5, you wait
    for the system to process and deploy the changes. Unfortunately, you also introduce
    an unintended failure because some changes conflict. Your team spends days tracking
    down which combination of changes caused the failure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 人工审批步骤会构建一批更改，这会引入一些问题。当您在图 7.5 中推送大量更改到生产环境时，您需要等待系统处理和部署这些更改。不幸的是，您也可能引入了意外的失败，因为一些更改存在冲突。您的团队可能需要花费数天时间追踪导致失败的更改组合。
- en: When you use CD, approve changes as quickly as possible. Implement a shorter
    feedback cycle for manual approval. You can also limit how many changes you approve
    at once. Both solutions mitigate some of the risk introduced by manual approval.
    I’ll cover another solution in the next section that entirely omits the manual
    approval process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 CD 时，尽可能快速地审批更改。为人工审批实施更短的反馈周期。您还可以限制一次审批的更改数量。这两种解决方案都减轻了人工审批引入的一些风险。我将在下一节中介绍另一种解决方案，该方案完全省略了人工审批过程。
- en: 7.1.3 Continuous deployment
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 持续部署
- en: Can you prevent large batches of changes by eliminating manual stages in your
    delivery pipeline? You can! However, you must practice CI/CD before removing manual
    approval.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您能否通过在交付管道中消除人工阶段来防止大量更改？您可以！然而，在移除人工审批之前，您必须练习 CI/CD。
- en: '![](../../OEBPS/Images/CH07_F05_Wang.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F05_Wang.png)'
- en: Figure 7.5 Avoid pushing large batches of changes to production whenever you
    introduce a manual approval to prevent complex troubleshooting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 避免在引入人工审批时推送大量更改到生产环境，以防止复杂的故障排除。
- en: Removing manual approval from your pipeline means you must have confidence in
    your *testing*. The pipeline in figure 7.6 adds more integration and end-to-end
    tests to verify the system and automatically pushes the changes to production.
    You feel confident that your tests sufficiently check system functionality *and*
    you can easily revert changes. You remove the manual approval and promote changes
    immediately to a production environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的管道中移除手动批准意味着您必须对您的*测试*有信心。图7.6中的管道增加了更多的集成和端到端测试来验证系统，并自动将更改推送到生产环境。您有信心认为您的测试充分检查了系统功能，并且您可以轻松地撤销更改。您移除了手动批准，并立即将更改提升到生产环境。
- en: '![](../../OEBPS/Images/CH07_F06_Wang.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F06_Wang.png)'
- en: Figure 7.6 Continuous deployment fully automates the testing and applying of
    changes to production.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 持续部署完全自动化了测试和将更改应用到生产的过程。
- en: '*Continuous deployment* removes the manual approval step and promotes changes
    directly from a testing environment into production.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续部署*消除了手动批准步骤，并直接从测试环境将更改提升到生产。'
- en: Definition *Continuous deployment* for IaC deploys and tests your infrastructure
    change to a testing environment and automatically promotes the change to production
    when the tests pass.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*IaC的持续部署*：将基础设施更改部署和测试到测试环境，并在测试通过时自动将更改提升到生产。
- en: Automatic deployment prevents a traffic jam of changes. Pushing infrastructure
    changes often takes hours and affects unknown dependencies. You can use continuous
    deployment for infrastructure if you have a thorough testing strategy and familiarity
    in fixing failures.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自动部署防止了更改的拥堵。推送基础设施更改通常需要数小时，并影响未知依赖项。如果您有全面的测试策略和修复故障的熟悉度，您可以使用持续部署进行基础设施。
- en: Using the techniques in chapter 11 to fix failures can help you practice continuous
    deployment. However, most organizations do not fully embrace continuous deployment
    for their infrastructure because they do not feel confident in testing or reverting
    changes. Investing time and practice in these patterns can help you move closer
    to a continuous deployment model.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第11章中的技术来修复故障可以帮助您练习持续部署。然而，大多数组织并没有完全接受持续部署用于他们的基础设施，因为他们对测试或撤销更改没有信心。在这些模式上投入时间和实践可以帮助您更接近持续部署模型。
- en: 7.1.4 Choosing a delivery approach
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 选择交付方法
- en: Continuous delivery and deployment create a workflow to test and deliver IaC
    to a production environment. However, you cannot expect your organization to feel
    comfortable automating all changes directly to production! I recommend applying
    a combination of continuous delivery and deployment to infrastructure change management.
    First, you must categorize the type of changes you implement before choosing a
    delivery approach.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付和部署创建了一个工作流程，用于测试和将IaC交付到生产环境。然而，您不能期望您的组织对直接自动化所有更改到生产感到舒适！我建议将持续交付和部署应用于基础设施变更管理。首先，您必须在选择交付方法之前对您实施的更改类型进行分类。
- en: Types of infrastructure change
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施更改的类型
- en: The type of change affects how you deliver it to production. You need to work
    with your organization’s change review board to classify the type of change and
    automate the testing and review for each one. Otherwise, you may find yourself
    noncompliant with an audit requirement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 变更类型影响您将其交付到生产的方式。您需要与您组织的变更审查委员会合作，对变更类型进行分类，并为每个变更自动化测试和审查。否则，您可能会发现自己不符合审计要求。
- en: Imagine you make a routine change every week to a server. You update the server’s
    IaC with a new tag. The automation never changes and does not fail often. When
    it does fail, you know exactly how to fix it. The server’s routine change becomes
    a good candidate for continuous deployment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您每周都会对服务器进行常规更改。您使用新的标签更新服务器的IaC。自动化从未改变，并且很少失败。当它确实失败时，您知道如何修复它。服务器的常规更改成为持续部署的良好候选。
- en: In figure 7.7, you continuously deploy the server change directly to production
    without manual approval. The pipeline replaces a manual approval step after the
    testing environment with a test to check for a prefix in the commit message. Your
    server change has the commit message of a `standard` change, so the pipeline bypasses
    manual approval.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.7中，您将服务器更改直接连续部署到生产环境，无需手动批准。管道在测试环境之后替换了手动批准步骤，用测试来检查提交信息中的前缀。您的服务器更改具有`标准`更改的提交信息，因此管道绕过了手动批准。
- en: You routinely make *standard changes* to your infrastructure. Examples of standard
    changes include upgrading container images in an orchestrator, deploying a new
    queue, or adding a new alert into your monitoring system. If the change fails,
    you can reference a runbook to roll back the change without impacting anything.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会定期对你的基础设施进行*标准变更*。标准变更的例子包括在编排器中升级容器镜像、部署新的队列或向你的监控系统添加新的警报。如果变更失败，你可以参考运行手册来回滚变更，而不会影响任何东西。
- en: Definition A *standard change* to infrastructure is a commonly implemented change
    with well-defined behavior and a rollback plan.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 基础设施的*标准变更*是一个常见实施、具有定义良好的行为和回滚计划的变更。
- en: '![](../../OEBPS/Images/CH07_F07_Wang.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F07_Wang.png)'
- en: Figure 7.7 A standard or emergency change can have an initial peer review before
    your delivery pipeline automatically pushes it to production.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 在你的交付管道自动将变更推送到生产之前，标准或紧急变更可以有一个初始的同行评审。
- en: Why should you consider continuous deployment for standard changes? A standard
    change often involves a commonly automated, well-defined fix. You don’t want your
    team members pausing to review and approve a repetitive change. The standard change
    distracts them from more important changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该考虑为标准变更使用持续部署？标准变更通常涉及一个常见的自动化、定义良好的修复。你不想让你的团队成员暂停来审查和批准重复的变更。标准变更会分散他们的注意力，使他们无法关注更重要的事。
- en: Other types of changes benefit from continuous deployment. Imagine you discover
    that an application on a server stopped running. You need the application up and
    running again quickly. Rather than run a standard change, you implement the fix
    in IaC and update its commit message with `emergency`. After pushing the change,
    your build system bypasses the manual approval stage because the commit message
    identifies the change as an emergency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的变更也受益于持续部署。想象一下，你发现服务器上的一个应用程序停止运行。你需要快速让应用程序重新运行。与其运行标准变更，不如在IaC中实施修复，并使用`emergency`更新其提交信息。在推送变更后，你的构建系统会绕过手动批准阶段，因为提交信息将变更标识为紧急。
- en: Besides continuously delivering standard changes, you can opt to continuously
    deliver *emergency changes* for emergency scenarios to fix production. When possible,
    push fixes by using IaC and the commit message to identify the emergency change.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了持续交付标准变更外，你还可以选择为紧急情况持续交付*紧急变更*以修复生产。当可能时，使用IaC和提交信息来标识紧急变更，通过使用IaC推送修复。
- en: Definition An *emergency change* to infrastructure is a change that you must
    quickly implement in production to fix system functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 基础设施的*紧急变更*是指你必须快速在生产中实施以修复系统功能的变更。
- en: Emergency changes go directly to production without manual approval because
    you often need to fix the system quickly. A manual approval may hinder the resolution
    of a problem. As a result, adding a bypass for emergency changes helps you quickly
    resolve the problem and record your resolution history.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 紧急变更直接进入生产，无需手动批准，因为你通常需要快速修复系统。手动批准可能会阻碍问题的解决。因此，为紧急变更添加绕过有助于你快速解决问题并记录你的解决历史。
- en: To continuously deploy standard and emergency changes, you *must* have automated
    testing in your pipeline before adding the ability to bypass the manual approval
    step. Furthermore, you need to standardize the bypass commit message structure.
    A bypass allows engineers to deploy fixes without a backlog of changes. It also
    allows compliance and security teams to audit the sequence of changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要持续部署标准和紧急变更，你*必须*在添加绕过手动批准步骤的能力之前在你的管道中进行自动化测试。此外，你需要标准化绕过提交信息的结构。绕过允许工程师在没有变更积压的情况下部署修复。它还允许合规性和安全团队审计变更序列。
- en: Can’t I just run an emergency change manually?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我就不能手动运行一个紧急变更吗？
- en: I highly recommend you use IaC and your delivery pipeline to make emergency
    changes. The commits record a history of your resolution steps, and your pipeline
    tests your changes before you run automation that makes the system worse.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你使用IaC和你的交付管道来制作紧急变更。提交记录了解决步骤的历史，你的管道在运行自动化之前会测试你的变更，以防止系统变得更糟。
- en: However, you might find the deployment pipeline can take too long to run when
    you’re trying to push out a fix quickly. You may consider making a manual change,
    recognizing that you may not benefit from the automated tests and checks addressed
    by the pipeline.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你试图快速推出修复时，你可能发现部署管道运行时间过长。你可能考虑进行手动变更，认识到你可能无法从管道中解决的自动化测试和检查中受益。
- en: After you make a manual change, reconcile the actual infrastructure state with
    the expected IaC. The practice of reconciliation involves manually updating the
    configuration to match the infrastructure resource (review this technique in chapter
    2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '在进行手动变更后，将实际基础设施状态与预期的IaC进行核对。核对的做法涉及手动更新配置以匹配基础设施资源（请参阅第2章中介绍的技术）。 '
- en: Other changes should not use continuous deployment. Imagine you’ve been assigned
    a new project. You need to enable IPv6 on all networks. By making this networking
    change, you could affect every application and system in the network!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他变更不应使用持续交付。想象一下，你被分配了一个新的项目。你需要启用所有网络上的IPv6。通过进行这个网络变更，你可能会影响网络中的每个应用和系统！
- en: For this new and major change, you *do not* want to skip manual approval. You
    want skilled network engineers reviewing your IaC. In figure 7.8, you update your
    networks’ IaC with IPv6 and wait for manual approval before production. The manual
    approval step communicates to the other application and engineering teams that
    your changes may have a large blast radius if they fail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个新的和重大变更，你*不*想跳过手动批准。你希望有经验的网络工程师审查你的基础设施即代码（IaC）。在图7.8中，你更新网络的IaC以IPv6，并在生产前等待手动批准。手动批准步骤会通知其他应用和工程团队，如果变更失败，它们可能具有很大的影响范围。
- en: '![](../../OEBPS/Images/CH07_F08_Wang.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F08_Wang.png)'
- en: Figure 7.8 New or major changes should have manual peer approval before applying
    to production.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 新或重大变更在生产应用前应进行手动同行批准。
- en: '*New or major changes* can affect a system’s architecture, security, or availability.
    These changes should require filing an issue or ticket with some justification
    and discussion. They also involve a manual change review from your peers in the
    team or company.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*新或重大变更*可能影响系统的架构、安全或可用性。这些变更应要求提交问题或工单，并提供一些理由和讨论。它们还涉及团队或公司内部同行对手动变更的审查。'
- en: Definition A *new or major change* to infrastructure potentially affects a system’s
    architecture, security, or availability. These changes do not have well-defined
    implementation or rollback plans.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个对基础设施的*新或重大变更*可能影响系统的架构、安全或可用性。这些变更没有明确定义的实现或回滚计划。
- en: Major changes have the potential for significant impact or a high risk of failure.
    Similarly, new or unknown changes can cause unpredictable results and complex
    rollback steps. Asking for manual approval signals that you may need some help
    if the changes fail. Other examples of new or major changes often include updates
    to network CIDR blocks (if they affect other allocations), DNS, certificate changes,
    upgrades to workload orchestrators, or platform refactoring (such as adding a
    secrets manager to applications).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重大变更可能产生重大影响或存在高风险失败的可能性。同样，新的或未知变更可能导致不可预测的结果和复杂的回滚步骤。请求手动批准表明，如果变更失败，你可能需要一些帮助。其他新的或重大变更的例子通常包括更新网络CIDR块（如果它们影响其他分配）、DNS、证书变更、升级工作负载编排器或平台重构（例如，向应用程序添加密钥管理器）。
- en: Delivery approach based on change type
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 基于变更类型的交付方法
- en: After categorizing the changes you make and their types, you can decide on your
    delivery approach. For the most part, standard and emergency changes use continuous
    deployment, while new and major changes use CD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在对所做的变更及其类型进行分类后，你可以决定你的交付方法。就大多数情况而言，标准和紧急变更使用持续交付，而新的和重大变更使用CD。
- en: Table 7.1 outlines some of the types of changes, their delivery approach, and
    an example. However, these general practices have exceptions. Some standard changes
    may require CD because they impact other resources. By contrast, changes related
    to greenfield (new) environments could implement a continuous deployment approach
    because it does not impact other systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1概述了一些变更类型、它们的交付方法和一个示例。然而，这些一般实践有例外。一些标准变更可能需要持续交付，因为它们会影响其他资源。相比之下，与绿色（新）环境相关的变更可以实施持续交付方法，因为它不会影响其他系统。
- en: Table 7.1 Types of changes and delivery approach
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 变更类型和交付方法
- en: '| Type of change | Delivery approach | Manual approval before production? |
    Example |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 变更类型 | 交付方法 | 生产前是否需要手动批准 | 示例 |'
- en: '| Standard | Continuous deployment | No | Adding servers to a scaling group
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | 持续交付 | 否 | 向扩展组添加服务器 |'
- en: '| Emergency | Continuous deployment or manual change | No | Rolling back an
    operating system image to a previous version |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 紧急 | 持续交付或手动变更 | 否 | 将操作系统镜像回滚到先前的版本 |'
- en: '| Major | Continuous delivery | Yes | Enabling SSL for all services and infrastructure
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 主要 | 持续交付 | 是 | 为所有服务和基础设施启用 SSL |'
- en: '| New | Continuous delivery | Yes | Deploying a new type of infrastructure
    component |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 新增 | 持续交付 | 是 | 部署新的基础设施组件 |'
- en: Continuous integration, delivery, and deployment also apply to the software
    development life cycle. However, applying the concepts to the infrastructure life
    cycle pushes the limits of your organization’s change and review processes. Regularly
    categorizing your changes and evaluating your change and review process can help
    balance productivity and governance, something I mentioned as part of module-sharing
    practices.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成、交付和部署也适用于软件开发生命周期。然而，将这些概念应用于基础设施生命周期将推动您组织变更和审查流程的极限。定期对您的变更进行分类并评估您的变更和审查流程可以帮助平衡生产力和治理，这是我作为模块共享实践的一部分提到的。
- en: Configuration management
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理
- en: Configuration management tools should follow a similar approach for assessing
    change types and applying continuous delivery or deployment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具应采用类似的方法来评估变更类型并应用持续交付或部署。
- en: As a general rule, make sure to quickly review and approve changes and *push
    them into production as soon as possible*. A larger batch of changes has a larger
    blast radius. If you push every change in one batch and affect a business-critical
    application, you must troubleshoot each change in the batch. The complexity of
    troubleshooting grows when you need to identify which change affected the system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，确保快速审查和批准变更，并*尽快将它们推入生产*。大量变更的爆炸半径更大。如果您将每个变更作为一个批次推送并影响业务关键应用程序，您必须对批次中的每个变更进行故障排除。当您需要确定哪个变更影响了系统时，故障排除的复杂性会增加。
- en: Exercise 7.1
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.1
- en: Choose a standard infrastructure change in your organization. What do you need
    in order to confidently continuously deliver the change to production? What about
    continuous deployment? Outline or diagram stages in your delivery pipelines for
    both.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的组织中选择一个标准的基础设施变更。您需要什么才能自信地将变更持续交付到生产环境中？持续部署呢？概述或绘制您的交付管道中的阶段。
- en: See appendix B for answers to exercises.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录 B 以获取练习的答案。
- en: 7.1.5 Modules
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5 模块
- en: What about delivery pipelines for modules? You learned about sharing, releasing,
    and managing versions of infrastructure modules in chapter 5 and testing their
    functionality in chapter 6\. I alluded to the idea of automating the process of
    testing and releasing modules but did not fully explain their delivery pipelines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的交付管道呢？您在第五章中学习了关于共享、发布和管理基础设施模块版本的内容，并在第六章中测试了它们的功能。我提到了自动化测试和发布模块过程的想法，但没有完全解释它们的交付管道。
- en: Delivery pipelines for infrastructure modules differ slightly from the examples
    I outlined for production configuration. You alter the delivery pipeline in figure
    7.9 to release a module after testing instead of delivering to production. You
    keep a manual approval step for your team to review the module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施模块的交付管道与我为生产配置概述的示例略有不同。您将图 7.9 中的交付管道更改，以便在测试后发布模块而不是交付到生产。您保留一个手动批准步骤，以便团队审查模块。
- en: '![](../../OEBPS/Images/CH07_F09_Wang.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F09_Wang.png)'
- en: Figure 7.9 After testing the module, wait for the team to review the change
    and test results before updating and releasing the new module version.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 在测试模块后，等待团队审查变更和测试结果，然后再更新和发布新模块版本。
- en: You can categorize module changes with the same types of changes as configurations,
    including standard, emergency, major, and new changes. Table 7.2 outlines the
    types of changes, their delivery approach, and an example. For the most part,
    they match the approach recommended for configurations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与配置相同的变更类型来对模块变更进行分类，包括标准、紧急、主要和新增变更。表 7.2 概述了变更类型、它们的交付方法和一个示例。大部分它们与为配置推荐的方法相匹配。
- en: Table 7.2 Types of module changes and delivery approach
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 模块变更类型和交付方法
- en: '| Type of change | Delivery approach | Manual approval before production? |
    Example |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 变更类型 | 交付方法 | 生产前手动批准？ | 示例 |'
- en: '| Standard | Continuous deployment | No | Enabling an override for an existing
    default parameter |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | 持续部署 | 否 | 启用对现有默认参数的覆盖 |'
- en: '| Emergency | Continuous deployment or branch | No | Rolling back an operating
    system image to a previous version |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 紧急 | 持续部署或分支 | 否 | 将操作系统镜像回滚到先前版本 |'
- en: '| Major | Continuous delivery | Yes | Updating a database or infrastructure
    by using data |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 主要 | 持续交付 | 是 | 通过使用数据更新数据库或基础设施 |'
- en: '| New | Continuous delivery | Yes | Deploying a new server module |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 新建 | 持续交付 | 是 | 部署新的服务器模块 |'
- en: Some module changes benefit from review or pair programming with a subject-matter
    expert, such as database configurations or other specialized infrastructure involving
    data. However, emergency changes on modules may have a different delivery approach.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块更改可以从与主题专家（如数据库配置或其他涉及数据的专用基础设施）的审查或结对编程中受益。然而，模块上的紧急更改可能采用不同的交付方法。
- en: Emergency changes on modules mean isolating a quick fix to a different version
    of the module. You can achieve isolation in one of two ways. You could implement
    the fix and continuously deploy and release a new version of the module with the
    changes. Alternatively, you could create a *branch* of a module repository and
    update your infrastructure configuration to reference the branch.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 模块上的紧急更改意味着将快速修复隔离到模块的不同版本。你可以通过两种方式实现隔离。你可以实施修复并持续部署和发布带有更改的新模块版本。或者，你可以创建模块存储库的
    *分支* 并更新你的基础设施配置以引用该分支。
- en: Definition A *branch* in version control is a pointer to a snapshot of code.
    It allows you to separately implement changes based on that snapshot.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 版本控制中的 *分支* 是指向代码快照的指针。它允许你基于该快照单独实施更改。
- en: After validating the branch, you can update the main branch of the module with
    a standard change. Branching the module helps you quickly implement the emergency
    module change and reconcile the module changes later.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 验证分支后，你可以使用标准更改更新模块的主分支。分支模块可以帮助你快速实施紧急模块更改，并在以后协调模块更改。
- en: If I know other teams pin their versions, I prefer to continuously deploy a
    new version of the module with the fix. While a branch can isolate the emergency
    change, I have to remember to merge it back into the main release of the module.
    In the next section, you’ll learn about branching models and how to apply them
    to IaC changes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我知道其他团队锁定他们的版本，我更喜欢持续部署带有修复的新模块版本。虽然分支可以隔离紧急更改，但我必须记得将其合并回模块的主发布版本。在下一节中，你将了解分支模型以及如何将它们应用于IaC更改。
- en: Image building and configuration management
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图像构建和配置管理
- en: Delivery pipelines for image building and configuration management modules follow
    a similar approach to modules for provisioning tools. Make sure to version and
    test changes to images before deploying them to production.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图像构建和配置管理模块的交付管道遵循与提供工具模块类似的方法。在将它们部署到生产之前，确保对图像进行版本控制和测试更改。
- en: 7.2 Branching models
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 分支模型
- en: Besides implementing continuous delivery or deployment, you need to standardize
    the way changes merge to your main configuration. The main branch in version control
    serves as a source of truth for configuration. Updating the configuration requires
    additional coordination and collaboration within your team.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实施持续交付或部署之外，你还需要标准化更改合并到主配置的方式。版本控制中的主分支是配置的真相来源。更新配置需要团队内部额外的协调和协作。
- en: Imagine you want to reduce access for a firewall while your teammate refreshes
    its license. Your team has a CD pipeline to test and manually approve changes
    to the production firewall. However, you and your teammate’s changes present two
    problems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在队友刷新其许可证的同时减少防火墙的访问权限。你的团队有一个CD管道来测试和手动批准对生产防火墙的更改。然而，你和队友的更改提出了两个问题。
- en: First, how can both of you work on and test your changes in isolation? Second,
    how do you control which change should go first? Figure 7.10 outlines your and
    your teammate’s dilemma of who should deploy their changes first. You want to
    avoid pushing both changes at the same time. If the firewall causes network access
    failure, you won’t know which change caused the problem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你们两个人如何独立地工作和测试你们的更改？其次，你们如何控制哪个更改应该先进行？图7.10概述了你们和你们的队友在谁应该先部署他们的更改方面的困境。你们想要避免同时推送两个更改。如果防火墙导致网络访问失败，你们将不知道是哪个更改导致了问题。
- en: '![](../../OEBPS/Images/CH07_F10_Wang.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F10_Wang.png)'
- en: Figure 7.10 Even if you have a CD pipeline to deliver changes to the firewall,
    you need additional development coordination to identify which change must apply
    first.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 即使你有CD管道将更改部署到防火墙，你仍需要额外的开发协调来识别哪些更改必须首先应用。
- en: 'A *branching model* coordinates how your team uses version control to enable
    parallel work while minimizing disruption and troubleshooting complexity. You
    can choose from two types of branching models: feature-based or trunk-based development.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*分支模型* 协调你的团队如何使用版本控制来启用并行工作，同时最小化中断和故障排除复杂性。你可以选择两种类型的分支模型：基于特征的或基于主干线的开发。'
- en: Definition A *branching model* defines how your team uses version control to
    enable parallel work and resolve conflicts in their efforts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *分支模型* 定义了你的团队如何使用版本控制来启用并行工作并解决他们努力中的冲突。
- en: Each branching model comes with its complexities in implementation, especially
    in IaC. I’ll describe how you can apply both development models to coordinate
    the firewall rule and license changes between you and your teammate. Then, I’ll
    discuss some limitations to each approach and how your teams can choose.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每种分支模型在实施过程中都伴随着其复杂性，尤其是在基础设施即代码（IaC）中。我将描述如何将这两种开发模型应用于协调你和你的队友之间的防火墙规则和许可证变更。然后，我将讨论每种方法的局限性以及你的团队如何进行选择。
- en: 7.2.1 Feature-based development
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 基于特征的开发
- en: What if you and your teammate could work on your changes in isolation before
    combining them? If your teammate creates a *branch* with their license change
    and you create a branch with your firewall changes, you isolate your changes from
    each other. When you both finish, you merge your changes to the main branch and
    resolve conflicts with each other.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和你的队友在合并之前能够在隔离状态下对变更进行工作会怎样？如果你的队友创建了一个包含许可证变更的 *分支*，而你创建了一个包含防火墙变更的分支，你将你的变更彼此隔离。当你们都完成时，你们将变更合并到主分支，并解决彼此之间的冲突。
- en: Figure 7.11 demonstrates how you and your teammate choreograph your changes
    on different branches. You name your branch `TICKET-002` for the firewall rule,
    and your teammate names their branch `TICKET-005` for the license update. Your
    firewall rule changes get approved first, so you put them into the main branch
    and deploy them to production. Your teammate continues working on the license
    update. They retrieve your firewall rule updates into their branch for further
    testing before merging their changes back to the main branch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11展示了你和你队友如何在不同的分支上编排你们的变更。你将你的分支命名为 `TICKET-002` 以表示防火墙规则，而你的队友将他们的分支命名为
    `TICKET-005` 以表示许可证更新。你的防火墙规则变更首先获得批准，因此你将它们放入主分支并部署到生产环境中。你的队友继续进行许可证更新工作。他们在合并变更回主分支之前，将你的防火墙规则更新检索到他们的分支中进行进一步测试。
- en: '![](../../OEBPS/Images/CH07_F11_Wang.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F11_Wang.png)'
- en: Figure 7.11 When you use feature-based development, you isolate your changes
    to your branch and reconcile conflicts with the main configuration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 当你使用基于特征的开发时，你将你的变更隔离到你的分支中，并与主配置进行冲突协调。
- en: '*Feature-based development* allows you to evolve your changes independent of
    your teammates by isolating those changes to a branch.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于特征的开发* 允许你通过将变更隔离到分支中来独立于你的队友进行变更的演进。'
- en: Definition *Feature-based development* (also known as *feature branching*, or
    *Git Flow*) is a branching pattern that separates different changes into individual
    branches. You merge the changes on a specific branch to the main configuration
    after testing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *基于特征的开发*（也称为 *功能分支* 或 *Git Flow*）是一种将不同的变更分离到单独分支的分支模式。在测试后，你将特定分支上的变更合并到主配置中。
- en: The flow of feature-based development helps you focus on the composability of
    your change independent of others. However, you need to constantly fetch changes
    from the main branch and reconcile them with your branch. Feature-based development
    works best when each team member diligently updates and tests their branches.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基于特征的开发流程有助于你专注于你的变更的可组合性，而无需考虑其他人的变更。然而，你需要不断地从主分支获取变更，并将它们与你自己的分支进行协调。当每个团队成员勤奋地更新和测试他们的分支时，基于特征的开发效果最佳。
- en: 'Let’s examine feature-based development in action. Imagine you start your feature-based
    development workflow for the firewall by cloning a local copy of the configuration
    from version control:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于特征的开发在实际中的应用。想象一下，你通过从版本控制中克隆配置的本地副本来开始基于特征的防火墙开发工作流程：
- en: '[PRE0]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You create a branch, which creates a pointer for your updates. I recommend
    naming the branch after the ticket number (such as `TICKET-002`) associated with
    the change, although you can also use a descriptive dash-delimited name:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个分支，这将为你的更新创建一个指针。我建议将分支命名为与变更相关的票号（例如 `TICKET-002`），尽管你也可以使用描述性的破折号分隔的名称：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You make your changes to the firewall rules on the branch. Then you use your
    command line to commit your changes to your local branch:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你在分支上对防火墙规则进行更改。然后你使用命令行将你的更改提交到你的本地分支：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have your changes locally, but you want others to review your change. You
    push the changes to a remote branch:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本地有你的更改，但你想让别人审查你的更改。你将更改推送到远程分支：
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Meanwhile, your teammate works on `TICKET-005`, which updates the license.
    They create a new branch called `TICKET-005` with changes that *do not* include
    your firewall rule updates. Notice that your branch does not include their updated
    license, and their branch does not include your updated firewall rules. You can
    review the difference between the two branches:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你的队友在`TICKET-005`上工作，更新许可证。他们创建了一个名为`TICKET-005`的新分支，其中包含的更改*不包括*你的防火墙规则更新。注意，你的分支不包括他们的更新许可证，他们的分支不包括你的更新防火墙规则。你可以审查两个分支之间的差异：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You open a *pull request*, notifying your team that you finished your changes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你打开一个*拉取请求*，通知你的团队你已经完成了你的更改。
- en: Definition A *pull request* notifies the maintainers of a repository that you
    have external changes you would like to merge into the main configuration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *拉取请求*通知存储库的维护者，你有一些外部更改希望合并到主配置中。
- en: You add members of the change advisory board to review your pull request. They
    approve the changes, and you merge your changes back to the main branch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你将更改顾问委员会的成员添加到审查你的拉取请求中。他们批准更改，然后你将你的更改合并回主分支。
- en: 'Your teammate has not received approval to update the license yet. To ensure
    that they don’t affect the production configuration, they need to retrieve all
    changes from the main branch, including yours in `TICKET-002`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你的队友尚未获得更新许可证的批准。为了确保他们不会影响生产配置，他们需要从主分支检索所有更改，包括你在`TICKET-002`中的更改：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then they return to their branch named `TICKET-005` and merge changes from
    the main branch into the `TICKET-005` branch:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们回到他们名为`TICKET-005`的分支，并将主分支的更改合并到`TICKET-005`分支：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When your teammate reviews the firewall configuration, they’ll find your changes
    from `TICKET-002`. They can update their branch with the changes from the main
    one:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的队友审查防火墙配置时，他们会找到来自`TICKET-002`的你的更改。他们可以将主分支的更改更新到他们的分支：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once your teammate’s changes receive approval, your teammate can merge the new
    firewall license to the main branch.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的队友的更改获得批准，你的队友可以将新的防火墙许可证合并到主分支。
- en: Feature-based development requires numerous steps for each team member. You
    can simplify the workflow by automating the testing and merging process. Use a
    delivery pipeline to organize the changes across branches.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基于特性的开发需要每个团队成员进行多个步骤。你可以通过自动化测试和合并过程来简化工作流程。使用交付管道来组织跨分支的更改。
- en: Figure 7.12 organizes the feature-based development workflow of the delivery
    pipeline for you and your teammate. You and your teammate each get a branch pipeline
    with its own testing environment. For example, you have a branch named `TICKET-002`
    and a new firewall environment that isolates your changes. You run unit tests,
    deploy the change, and run integration and end-to-end tests in the `TICKET-002`
    firewall environment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12为你和你的队友组织了基于特性的交付管道开发工作流程。你和你的队友各自获得一个带有自己测试环境的分支管道。例如，你有一个名为`TICKET-002`的分支和一个隔离你更改的新防火墙环境。你在`TICKET-002`防火墙环境中运行单元测试，部署更改，并运行集成和端到端测试。
- en: '![](../../OEBPS/Images/CH07_F12_Wang.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12](../../OEBPS/Images/CH07_F12_Wang.png)'
- en: Figure 7.12 You can use feature-based development to isolate testing of your
    changes on the branch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 你可以使用基于特性的开发来隔离分支上你的更改的测试。
- en: Once your branch tests pass, you merge the changes to the main branch. While
    you worked on your change, your teammate separately created their own branch and
    firewall environment named `TICKET-005`. Your teammate realizes that you recently
    made updates to the firewall configuration.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的分支测试通过，你将更改合并到主分支。在你工作于你的更改的同时，你的队友分别创建了他们自己的名为`TICKET-005`的分支和防火墙环境。你的队友意识到你最近更新了防火墙配置。
- en: In figure 7.12, your teammate retrieves changes from the main branch and makes
    sure those changes still work with their branch and environment. Once your teammate
    runs the same unit, integration, and end-to-end tests on their branch, they merge
    `TICKET-005` changes to the main branch for production deployment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.12中，你的队友从主分支检索更改，并确保这些更改仍然与他们的分支和环境兼容。一旦你的队友在他们分支上运行相同的单元、集成和端到端测试，他们将合并`TICKET-005`更改到主分支以进行生产部署。
- en: Why create a testing environment for each branch? A testing environment per
    branch isolates your changes and tests them relative to the main branch. As a
    temporary environment, the branch’s testing environment can minimize the need
    for a persistent testing environment and reduce the overall cost of infrastructure.
    However, a testing environment may take some time to create.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么为每个分支创建一个测试环境？每个分支的测试环境可以隔离您的更改，并相对于主分支进行测试。作为临时环境，分支的测试环境可以最小化对持久测试环境的需求，并降低整体基础设施成本。然而，创建测试环境可能需要一些时间。
- en: 'Your team gets a few benefits from feature-based development, including the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队从基于功能的开发中获得一些好处，包括以下内容：
- en: Ability to isolate changes to a branch.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够隔离分支上的更改。
- en: Ability to test changes within the branch.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分支内测试更改的能力。
- en: Implicit step for peer review. You can merge your changes to production only
    if someone approves the change.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐含的同行评审步骤。只有当有人批准更改时，您才能将更改合并到生产环境中。
- en: Separation of emergency changes on a branch. After validating the emergency
    change, you can merge it to the main branch.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分支上分离紧急更改。在验证紧急更改后，您可以将它合并到主分支。
- en: Fortunately, repository hosting services (e.g., GitHub or GitLab) have functionality
    that can help you automate a feature-based development model. Such functionality
    includes labels for tracking specific features, status checks with integration
    tests before merging your branch, and automated deletion of old branches. You
    can also define a list of reviewers and automatically add them to pull requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，代码库托管服务（例如，GitHub 或 GitLab）具有可以帮助您自动化基于功能的开发模型的功能。这些功能包括用于跟踪特定功能的标签、在合并分支之前进行集成测试的状态检查，以及自动删除旧分支。您还可以定义一个审阅者列表，并自动将他们添加到拉取请求中。
- en: 7.2.2 Trunk-based development
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 主干开发
- en: Imagine your organization does not want to create a testing environment per
    branch, and many of the engineers do not feel comfortable with a feature-based
    development workflow. Instead of creating a branch, you and your teammate work
    together on the main branch.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的组织不想为每个分支创建测试环境，并且许多工程师对基于功能的开发工作流程感到不舒服。相反，您和您的队友可以在主分支上一起工作。
- en: Figure 7.13 shows how you and your teammate can collaborate on the main branch.
    You update the firewall rule and push the changes first. Then your teammate updates
    their local repository to include your changes and pushes their changes to the
    main branch.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 展示了您和您的队友如何在主分支上进行协作。您首先更新防火墙规则并推送更改。然后您的队友更新他们的本地仓库以包含您的更改，并将他们的更改推送到主分支。
- en: '![](../../OEBPS/Images/CH07_F13_Wang.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F13_Wang.png)'
- en: Figure 7.13 When you use trunk development, you maintain one main branch and
    update the production configuration directly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 当您使用主干开发时，您维护一个主分支并直接更新生产配置。
- en: The workflow seems more streamlined since you both push to one branch. *Trunk-based
    development* means that you push changes directly to the main branch without isolating
    your changes in version control.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您俩都推送到一个分支，工作流程看起来更加流畅。*主干开发* 意味着您直接将更改推送到主分支，而不在版本控制中隔离您的更改。
- en: Definition *Trunk-based development* (also known as *pushing to main*) is a
    branching pattern that pushes all changes directly to the main branch. It favors
    making small changes and using testing environments to verify that changes succeed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *主干开发*（也称为 *推送到主分支*）是一种将所有更改直接推送到主分支的分支模式。它倾向于进行小改动，并使用测试环境来验证更改是否成功。
- en: Trunk-based development does not allow you to evolve your changes independently
    of your teammates. However, this limitation becomes a benefit. Trunk-based development
    forces you to implement changes in a *specific order*. You can quickly identify
    which commit causes the change and resolve it. The pattern offers an opinionated
    way to orchestrate and apply IaC changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 主干开发不允许您独立于队友进行更改的演变。然而，这种限制变成了一个优势。主干开发迫使您以 *特定顺序* 实施更改。您可以快速识别导致更改的提交并解决它。该模式提供了一种有见地的方法来编排和应用基础设施即代码（IaC）更改。
- en: 'Let’s apply trunk-based development to your firewall rule and your teammate’s
    firewall license updates. You start by cloning a local copy of the firewall configuration
    from version control. When you clone the configuration, you can check the main
    branch:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将主干开发应用于您的防火墙规则和您的队友的防火墙许可证更新。您首先从版本控制中克隆防火墙配置的本地副本。当您克隆配置时，您可以检查主分支：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You make the firewall rule changes to the main branch. Commit your changes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你将防火墙规则更改提交到主分支。提交你的更改：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Update your local copy to make sure you retrieve new changes from main. Use
    `git pull` `--rebase` to fetch the changes from the remote repository, merge them
    into your local copy, and rebase the local history with the remote one:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的本地副本以确保从主分支检索新更改。使用 `git pull` `--rebase` 从远程仓库获取更改，将它们合并到你的本地副本中，并与远程历史记录进行变基：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, you can push the changes to the main branch. Your push should start the
    delivery pipeline in figure 7.14\. Your pipeline runs unit and integration tests
    against a testing environment. After all testing stages pass, the pipeline waits
    for manual approval from your team. Your teammate can review your changes and
    approve them. Once they approve your change, the pipeline deploys your firewall
    rule change to production.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将更改推送到主分支。你的推送应该启动图7.14所示的交付流水线。你的流水线会对测试环境执行单元和集成测试。在所有测试阶段通过后，流水线等待你的团队手动批准。你的队友可以审查你的更改并批准它们。一旦他们批准了你的更改，流水线就会将你的防火墙规则更改部署到生产环境中。
- en: '![](../../OEBPS/Images/CH07_F14_Wang.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F14_Wang.png)'
- en: Figure 7.14 Trunk-based development requires a pipeline to deliver it to production
    continuously.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 基于主干线的开发需要一条流水线来持续将其交付到生产环境中。
- en: If your firewall rule change fails, it stops the delivery pipeline before it
    goes to production. You’ll notice the failure in the testing environment stage
    and revert the change. Everyone else can proceed with their changes to production
    while you implement a fix.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的防火墙规则更改失败，它会在进入生产之前停止交付流水线。你会在测试环境阶段注意到失败并撤销更改。其他人可以继续将他们的更改推送到生产环境，而你则需要实施修复。
- en: Trunk-based development heavily depends on delivery pipelines to test and deploy
    changes. The delivery pipeline should include a persistent testing environment
    to evaluate conflicts between changes. While a persistent testing environment
    incurs a cost, the environment more accurately reflects the change’s behavior
    in production.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干线的开发高度依赖于交付流水线来测试和部署更改。交付流水线应包括一个持久测试环境来评估更改之间的冲突。虽然持久测试环境会产生成本，但该环境更准确地反映了更改在生产中的行为。
- en: The workflow for trunk-based development has very few steps. Most infrastructure
    teams find this workflow helpful in making changes because it sequences the changes
    in a particular order. Trunk-based development creates a continuous feedback loop
    of how different changes affect each other. It also promotes a practice of making
    minor changes, resolving updates from the main configuration, and pushing the
    changes to production. When your team’s changes conflict, you can quickly identify
    which dependencies affected the testing environment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干线的开发的工作流程步骤非常少。大多数基础设施团队发现这个工作流程在做出更改时很有帮助，因为它按照特定的顺序排列更改。基于主干线的开发创建了一个持续反馈循环，展示了不同的更改如何相互影响。它还促进了一种实践，即进行小幅度更改，解决主配置的更新，并将更改推送到生产环境。当你的团队更改发生冲突时，你可以快速识别哪些依赖项影响了测试环境。
- en: However, trunk-based development does require practice to resolve changes and
    discipline to reconcile changes. You do not isolate your changes, and working
    on one branch can make it challenging to collaborate. Once you work through the
    initial collaboration conflicts, you might find that trunk-based development provides
    better visibility into IaC changes across your team.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于主干线的开发确实需要练习来解决更改并保持纪律以协调更改。你不会隔离你的更改，在一个分支上工作可能会使协作变得具有挑战性。一旦你解决了最初的协作冲突，你可能会发现基于主干线的开发为你团队中的IaC更改提供了更好的可见性。
- en: 7.2.3 Choosing a branching model
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 选择分支模型
- en: I’ve spent hours with software and infrastructure teams debating the merits
    of feature-based or trunk-based development. At the conclusion of those meetings,
    I always came to the realization that the branching model choice depended on the
    team’s comfort level, size, and environment setup. This section covers some limitations
    and concerns when applying both branching models to infrastructure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我与软件和基础设施团队花费了数小时讨论基于功能或基于主干线的开发的优点。在这些会议结束时，我总是意识到分支模型的选择取决于团队的舒适度、规模和环境设置。本节涵盖了将这两种分支模型应用于基础设施时的某些局限性和担忧。
- en: Challenges of feature-based development
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 基于功能的开发挑战
- en: Many open source projects for applications and infrastructure successfully use
    feature-based development. Feature-based development provides the framework to
    test and assess critical changes independent of one another. It separates changes
    across many collaborators and enforces a manual review stage before merging to
    the main branch. Source control or CI frameworks offer native integrations to
    support feature-based development.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序和基础设施的开源项目成功使用了基于特性的开发。基于特性的开发提供了一个框架，可以独立测试和评估关键更改。它将更改分散到许多协作者之间，并在合并到主分支之前强制执行手动审查阶段。源代码控制或CI框架提供了原生集成以支持基于特性的开发。
- en: IaC gets the same benefit from feature-based development. Teams enjoy isolating
    infrastructure changes to a branch before pushing it to production. Figure 7.15
    tests your firewall rule changes in the `TICKET-002` environment from your teammate’s
    license changes in the `TICKET-005` environment. You can apply changes on top
    of your branch without conflicting with someone else.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: IaC从基于特性的开发中获得了相同的益处。团队在将基础设施更改推送到生产之前，可以将其隔离到分支中。图7.15测试了您在`TICKET-002`环境中对防火墙规则更改的验证，来自您的队友在`TICKET-005`环境中的许可更改。您可以在您的分支上应用更改，而不会与其他人冲突。
- en: '![](../../OEBPS/Images/CH07_F15_Wang.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F15_Wang.png)'
- en: Figure 7.15 You can create a new testing environment for each feature branch
    to verify individual changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 您可以为每个特性分支创建一个新的测试环境，以验证单个更改。
- en: However, feature-based development has a few challenges. First, new environments
    can cost time and money to create (refer to chapter 12 for cost management). Your
    pipeline might struggle to spin up new environments when multiple team members
    work on the configuration with many branches.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于特性的开发有几个挑战。首先，创建新环境可能需要时间和金钱（有关成本管理，请参阅第12章）。当多个团队成员在许多分支上配置时，您的管道可能难以启动新环境。
- en: To speed up the creation of testing environments, you could invest in runners
    for your pipeline framework to run tests in parallel. Alternatively, you could
    also create one persistent testing environment for all branches to use. However,
    feature-based development might cause conflicts in a persistent testing environment
    because each branch applies changes asynchronously.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快测试环境的创建，您可以为您的管道框架投资运行器以并行运行测试。或者，您也可以为所有分支创建一个持久测试环境。然而，基于特性的开发可能会在持久测试环境中引起冲突，因为每个分支都是异步应用更改的。
- en: '![](../../OEBPS/Images/CH07_F16_Wang.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F16_Wang.png)'
- en: Figure 7.16 You can omit your branches’ integration and end-to-end tests to
    mitigate the cost of multiple environments and pipeline concurrency.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 您可以省略分支的集成和端到端测试，以减轻多个环境和管道并发成本。
- en: Rather than create a persistent testing environment, you could also omit the
    integration and end-to-end tests from every branch except the main one to optimize
    costs. For example, your firewall change might require only static analysis, unit
    tests, and team review before merging to production, as shown in figure 7.16\.
    You do not need to create a unique testing environment for the branch and merge
    the branch to production after manual review.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个持久的测试环境，您还可以省略除了主分支之外的所有分支的集成和端到端测试，以优化成本。例如，您的防火墙更改可能只需要静态分析、单元测试和团队审查，然后才能合并到生产中，如图7.16所示。您不需要为分支创建唯一的测试环境，在人工审查后，将分支合并到生产中。
- en: Another challenge you face with feature-based development involves the discipline
    and familiarity with version control. If you haven’t used version control, you
    need to get used to the feature-branching workflow. The workflow adds the challenge
    of reverse engineering merged changes and troubleshooting conflicts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您在基于特性的开发中面临的另一个挑战涉及版本控制的纪律和熟悉度。如果您还没有使用版本控制，您需要习惯特性分支的工作流程。该工作流程增加了逆向工程合并更改和解决冲突的挑战。
- en: For example, someone could make a branch to fix the firewall rule over the week-end.
    They forget to merge the hotfix, and you did not know they changed the firewall.
    You overwrite their configuration by accident when updating the firewall rules!
    Over time, you accumulate a lot of branches and must troubleshoot which ones you’ve
    applied.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有人可能在本周末创建一个分支来修复防火墙规则。他们忘记合并热修复，而您不知道他们更改了防火墙。在更新防火墙规则时，您意外地覆盖了他们的配置！随着时间的推移，您积累了大量的分支，必须解决哪些分支已经应用。
- en: You’ll also encounter the challenge of long-lived branches. Imagine your teammate
    has been working on updating the license for a month. They create a new branch
    named `TICKET-005`. Every few days, they need to check for updates in the main
    branch and add them to their fix.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会遇到长期分支的挑战。想象一下，你的队友已经花了一个月的时间更新许可证。他们创建了一个名为 `TICKET-005` 的新分支。每隔几天，他们需要检查主分支的更新并将它们添加到他们的修复中。
- en: One day, you need to make a change that depends on your teammate’s license update.
    You start working on your changes on a branch named `TICKET-002`, as shown in
    figure 7.17 You finish but realize that your teammate still has work to do on
    `TICKET-005`! You wait two more months for your teammate to finish their firewall
    license update. Once they finish, you spend hours updating your `TICKET-002` branch
    so you can finally deploy your changes to production.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，你需要进行一个依赖于你的队友许可证更新的变更。你开始在名为 `TICKET-002` 的分支上工作你的变更，如图 7.17 所示。你完成了工作，但意识到你的队友在
    `TICKET-005` 上还有工作要做！你等待了另外两个月，直到你的队友完成他们的防火墙许可证更新。一旦他们完成，你花费数小时更新你的 `TICKET-002`
    分支，以便最终将你的变更部署到生产环境中。
- en: '![](../../OEBPS/Images/CH07_F17_Wang.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F17_Wang.png)'
- en: Figure 7.17 Branches with long lifetimes can prevent other changes from deploying
    to production and introduce complexity during the branching process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 长寿命的分支可能会阻止其他变更部署到生产环境，并在分支过程中引入复杂性。
- en: Feature-based development encourages you to keep branches for a long time. You
    have to vigilantly update long-lived branches to keep up with the main one. Otherwise,
    you’ll encounter conflicts you cannot easily resolve. On occasion, your only solution
    involves deleting your abandoned branch and restarting your changes on a new,
    updated branch.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 基于功能的开发鼓励你长时间保留分支。你必须警惕地更新长期分支，以跟上主分支。否则，你将遇到难以轻易解决的冲突。有时，你唯一的解决方案是删除你废弃的分支，并在新的、更新的分支上重新开始你的变更。
- en: Challenges of trunk-based development
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干开发的挑战
- en: Trunk-based development works well with infrastructure changes and the need
    to mitigate configuration drift between environments and states. You omit the
    complexities of merging and managing feature branches, especially if you need
    to build confidence in Git skills.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发与基础设施变更和缓解环境之间配置漂移的需求相得益彰。你省略了合并和管理功能分支的复杂性，特别是如果你需要建立 Git 技能的信心。
- en: Trunk-based development favors small changes instead of large, significant ones.
    You implement changes progressively instead of testing them in one batch. In chapter
    10, I cover the use of feature toggling to gradually implement a set of changes
    and mitigate risk to infrastructure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干开发倾向于小变更而不是大而重要的变更。你逐步实施变更，而不是一次性测试它们。在第 10 章中，我将介绍使用功能切换来逐步实施一组变更并降低对基础设施的风险。
- en: Trunk-based development has a few disadvantages. It requires a dedicated testing
    environment before pushing changes to production. Figure 7.18 outlines the ideal
    workflow for trunk-based development. After you run unit tests, you deploy the
    change to a long-lived testing environment for integration and end-to-end tests.
    If the change passes tests in the testing environment, it can undergo review from
    your teammates. Once they approve the change, it goes to the production environment
    for integration and end-to-end testing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干开发有几个缺点。在将变更推送到生产之前，它需要一个专门的测试环境。图 7.18 概述了基于主干开发的理想工作流程。在你运行单元测试后，你将变更部署到一个长期测试环境中进行集成和端到端测试。如果变更在测试环境中通过测试，它可以接受队友的审查。一旦他们批准变更，它将进入生产环境进行集成和端到端测试。
- en: '![](../../OEBPS/Images/CH07_F18_Wang.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F18_Wang.png)'
- en: Figure 7.18 Trunk-based development requires a dedicated testing environment
    to mimic the changes to production and help build confidence for peer review.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 基于主干的开发需要一个专门的测试环境来模拟生产中的变更，并帮助建立同行审查的信心。
- en: You need thorough unit tests to format and lint for your team’s standards, and
    integration tests to verify functionality. A persistent testing environment increases
    the overall cost of trunk-based development. Smaller, more modular infrastructure
    configurations can reduce the conflicts within a resource or module and lower
    the overall cost of required infrastructure for tests.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要彻底的单元测试来格式化和检查团队的标准，以及集成测试来验证功能。一个持久的测试环境会增加基于主干开发的总体成本。更小、更模块化的基础设施配置可以减少资源或模块内的冲突，并降低测试所需基础设施的总体成本。
- en: You may find that trunk-based development conflicts with manual change approval.
    Manual change approval can happen only after someone pushes the changes to the
    main branch. Your reviewer needs to know if your change worked before they can
    verify its formatting and configuration. If you push a broken configuration to
    the testing environment, you identify and revert quickly before someone else reviews
    it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，基于主干的发展与手动变更审批相冲突。手动变更审批只能在有人将更改推送到主分支之后进行。你的审阅者需要知道你的变更是否成功，他们才能验证其格式和配置。如果你将一个损坏的配置推送到测试环境，你需要迅速识别并回滚，以免其他人审阅。
- en: Table 7.3 summarizes the benefits and limitations of feature-based and trunk-based
    development. The choice depends on the type of infrastructure your team configures
    and its familiarity with version control.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3总结了基于特征和基于主干发展的优点和局限性。选择取决于你的团队配置的基础设施类型及其对版本控制的熟悉程度。
- en: Table 7.3 Comparison of feature-based and trunk-based development
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3 基于特征和基于主干的发展比较
- en: '| Development model | Benefits | Limitations |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 开发模型 | 优点 | 局限性 |'
- en: '| Feature-based development | Isolates changes using branchesIsolates tests
    using branchesOrganizes manual review of codeScales across multiple teams and
    collaborators | Requires diligence and familiarity with updating branchesEncourages
    long-lived branchesIncreases cost in money and time |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 基于特征的发展 | 使用分支隔离变更，使用分支隔离测试，组织代码的手动审查，跨多个团队和协作者扩展 | 需要勤奋和熟悉更新分支，鼓励长期分支，增加金钱和时间成本
    |'
- en: '| Trunk-based development | Provides better representation of change behaviorUses
    one version control workflow for all changesEncourages incremental infrastructure
    changes to reduce blast radius | Requires long-lived testing environmentDoes not
    include a stage for manual reviewRequires discipline and organization to scale
    across multiple teams and collaborators |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 基于主干的发展 | 提供更好的变更行为表示，使用一个版本控制工作流程处理所有变更，鼓励增量基础设施变更以减少影响范围 | 需要长期测试环境，不包括手动审查阶段，需要纪律和组织才能跨多个团队和协作者扩展
    |'
- en: You must establish and agree on a development model within your team. Agreement
    on a development model helps promote reproducibility of changes and the overall
    availability of the system. Beware of the limitations with each approach, and
    always keep your changes as small as possible. No matter which model your team
    adopts, apply changes to production as frequently as possible to reduce the blast
    radius of changes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在团队内部建立并达成一致的开发模型。对开发模型的达成一致有助于促进变更的可重复性和系统的整体可用性。注意每种方法的局限性，并始终尽量保持你的变更尽可能小。无论你的团队采用哪种模型，尽可能频繁地将变更应用到生产环境中，以减少变更的影响范围。
- en: 7.3 Peer review
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 同行评审
- en: Throughout this chapter and chapter 5, I emphasized the importance of including
    a review step in delivery pipelines and module changes. Why should you take the
    time to review your teammate’s IaC? What should you look for as you review it?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和第5章中，我强调了在交付管道和模块变更中包含审查步骤的重要性。为什么你应该花时间审查你的队友的IaC？在审查时你应该寻找什么？
- en: '*Peer review* allows your teammates to examine your infrastructure configuration
    for recommendations, standards, and formatting.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*同行评审*允许你的队友检查你的基础设施配置以获得建议、标准和格式。'
- en: Definition *Peer review* is a practice that allows your teammates or other teams
    to examine your infrastructure configuration for recommendations, standards, and
    formatting.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *同行评审* 是一种允许你的队友或其他团队检查你的基础设施配置以获得建议、标准和格式的实践。
- en: As a reviewer, I focus on whether a configuration will scale across teams, remain
    secure, or affect higher-level infrastructure dependencies. This perspective on
    review sometimes blocks the merging of the change to production. However, the
    peer review process serves as a team education opportunity for standardized practices
    and new patterns. You and your team may need to spend time debating the merits
    or drawbacks of a design or implementation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为审阅者，我关注的是配置是否能够在团队间扩展，保持安全，或者影响高级基础设施依赖。这种审阅视角有时会阻止变更合并到生产环境中。然而，同行评审过程为团队提供了标准化实践和新模式的教育机会。你和你的团队可能需要花时间讨论设计或实现的优点或缺点。
- en: To understand the importance and drawbacks of peer review, imagine a new inventory
    team needs read access to a GCP project. In listing 7.1, you update the code for
    access management rules to read a list of users from a JSON object. The new code
    passes all the tests, and you wait for a few days for your teammate to review
    the change.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解同行评审的重要性和缺点，想象一个新的库存团队需要读取GCP项目的访问权限。在列表7.1中，您更新了访问管理规则的代码，从JSON对象中读取用户列表。新代码通过了所有测试，您等待了几天，等待您的队友审查更改。
- en: Listing 7.1 First implementation to add a new team to a GCP project
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 向GCP项目添加新团队的首次实现
- en: '[PRE11]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Defines a list of users and groups to add to the GCP project
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义要添加到GCP项目的用户和组列表
- en: ❷ Adds the inventory team as a read-only group to the project
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将库存团队作为只读组添加到项目中
- en: ❸ Creates a module for the GCP project users, which uses the factory pattern
    to attach users to roles
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为GCP项目用户创建一个模块，该模块使用工厂模式将用户附加到角色
- en: ❹ Uses the module to create the JSON configuration for the list of users to
    append to GCP roles
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用该模块为要附加到GCP角色的用户列表创建JSON配置
- en: ❺ For each group in the list, creates a Google project IAM member with the user
    attached to their assigned role. This resource appends the user to the roles in
    GCP.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于列表中的每个组，创建一个Google项目IAM成员，并将用户附加到其分配的角色。此资源将用户添加到GCP的角色中。
- en: ❻ Writes the Python dictionary out to a JSON file to be executed by Terraform
    later
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将Python字典写入由Terraform稍后执行的JSON文件
- en: ❼ When you write out the JSON file to be executed by Terraform, use an indentation
    of two spaces.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 当您将JSON文件写入由Terraform执行的文件时，使用两个空格缩进。
- en: AWS and Azure equivalents
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure等效
- en: To convert the code listing to AWS, you would map references to the GCP project
    to an AWS account. GCP project users align with an AWS IAM user. Similarly, you
    would create an Azure subscription and add a user account to Azure Active Directory.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代码列表转换为AWS，您需要将GCP项目的引用映射到AWS账户。GCP项目用户与AWS IAM用户相对应。同样，您会创建一个Azure订阅并将用户账户添加到Azure
    Active Directory。
- en: 'You wait three days before your teammate returns with the following feedback:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您等待三天后，您的队友返回并提供了以下反馈：
- en: You must indent your JSON infrastructure configuration with four spaces.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须使用四个空格缩进您的JSON基础设施配置。
- en: You must rename the group to `team-inventory@example.com`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须将组重命名为`team-inventory@example.com`。
- en: You must add the inventory team to the list of users for the `viewer` role instead
    of defining the role for the group.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须将库存团队添加到`viewer`角色的用户列表中，而不是为该组定义角色。
- en: Your teammate explains that the first two conform to team standards. The last
    requirement conforms to a security standard for authoritative bindings for access
    control (it defines a list of users for the role instead of adding a role to the
    user). You already delayed your change by three days waiting for peer review!
    Now, you need to fix it and wait another few days to get approval.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您的队友解释说，前两个符合团队标准。最后一个要求符合访问控制权威绑定安全标准（它定义了角色的用户列表而不是将角色添加到用户）。您已经因为等待同行评审而延迟了三天！现在，您需要修复它并等待另外几天以获得批准。
- en: Remember from chapter 6 that you want to capture the unknown knowns of siloed
    knowledge into tests. Your teammate had some knowledge that you did not know.
    You decide to add some unit tests to help you remember the team standards.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第6章中您想要将孤岛知识的未知已知捕获到测试中。您的队友有一些您不知道的知识。您决定添加一些单元测试来帮助您记住团队标准。
- en: The new code in listing 7.2 includes new unit tests (linting rules) to validate
    your team’s configuration and security standards. One test checks for the correct
    indentation of four spaces in the JSON. Another checks that all groups conform
    to a naming standard. The last test checks that you use the correct resource to
    bind users to roles.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2中的新代码包括新的单元测试（linting规则），以验证您的团队配置和安全标准。一个测试检查JSON中是否有四个空格的正确缩进。另一个测试检查所有组是否符合命名标准。最后一个测试检查您是否使用了正确的资源将用户绑定到角色。
- en: Listing 7.2 Adding unit tests to lint for team development standards
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 向团队开发标准添加单元测试以进行lint
- en: '[PRE12]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Imports the list of GCP users and roles
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入GCP用户和角色的列表
- en: ❷ Uses Python to read in the Terraform JSON configuration file. The test uses
    this fixture to verify that the JSON has an indentation of four spaces.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Python读取Terraform JSON配置文件。测试使用此固定值来验证JSON具有四个空格的缩进。
- en: ❸ Imports the list of GCP users and roles, including the inventory team, as
    a fixture to the test. The test checks that each user has a prefix of “team-”
    to identify it as a group.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将GCP用户和角色的列表（包括库存团队）作为固定值导入测试。测试检查每个用户都有一个“team-”前缀来识别它作为一个组。
- en: ❹ Uses a fixture to create a sample GCP project user using the factory module
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用工厂模块创建一个示例GCP项目用户
- en: ❺ Uses Python to read in the Terraform JSON configuration file. The test uses
    this fixture to verify that the JSON has an indentation of four spaces.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用Python读取Terraform JSON配置文件。测试使用此固定值来验证JSON有四个空格的缩进。
- en: ❻ Checks that the factory module uses the correct Terraform resource of Google
    project IAM binding and not members. This uses an authoritative binding to add
    team members to a specific role
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查工厂模块是否使用了正确的Google项目IAM绑定Terraform资源而不是成员。这使用权威绑定将团队成员添加到特定角色
- en: AWS and Azure equivalents
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure的等效资源
- en: A GCP project IAM binding is similar to an `aws_iam_policy_attachment` Terraform
    resource ([http://mng.bz/5QW7](http://mng.bz/5QW7)). The binding or attachment
    authoritatively revokes any users not defined as part of the Terraform resource.
    At the time of publication, Azure’s access control model uses an additive policy
    approach and does not have an explicit way to define authoritative role attachments
    or binding definitions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: GCP项目IAM绑定类似于`aws_iam_policy_attachment` Terraform资源([http://mng.bz/5QW7](http://mng.bz/5QW7))。绑定或附件会权威性地撤销任何未定义为Terraform资源一部分的用户。在发布时，Azure的访问控制模型使用的是累加策略方法，并且没有明确的方式来定义权威的角色附加或绑定定义。
- en: You correct your mistakes before peer review and shorten the feedback loop,
    thanks to automated linting and unit tests. Your teammate doesn’t have to nitpick
    for formatting and standards. However, you and your teammate still debate whether
    you should add the user to the role or the role to the user. You decide to raise
    this architectural decision to the broader team for consideration.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自动代码审查和单元测试，你可以在同行评审之前纠正错误并缩短反馈循环。你的队友不需要对格式和标准吹毛求疵。然而，你和你的队友仍在争论是否应该将用户添加到角色中，或者将角色添加到用户中。你决定将这个架构决策提交给更广泛的团队进行考虑。
- en: Figure 7.19 demonstrates that effective peer review follows the example’s workflow
    of combining automated testing with broader architectural discussions. Between
    automated tests, peer review, and collaborating together, you maintain secure,
    resilient, and scalable IaC.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19演示了有效的同行评审遵循示例的工作流程，将自动化测试与更广泛的架构讨论相结合。在自动化测试、同行评审和协作之间，你维护了安全、弹性和可扩展的IaC。
- en: '![](../../OEBPS/Images/CH07_F19_Wang.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F19_Wang.png)'
- en: Figure 7.19 Automating some of the checks and maintaining awareness of any manual
    review processes will help expedite peer review.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 自动化一些检查并保持对任何手动审查过程的意识将有助于加快同行评审。
- en: However, test automation and reviewers do not catch everything. Peer review
    later in your development process can get frustrating as well. To address any
    gaps and raise architectural concerns earlier in the IaC writing process, you
    can program with a teammate. This technique, called *pair programming*, uses two
    engineers to mitigate the friction of peer review.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试自动化和审阅者并不能捕捉到所有内容。在开发过程的后期进行同行评审可能会令人沮丧。为了在IaC编写过程中尽早解决差距和提出架构问题，你可以与队友一起编程。这种技术称为*结对编程*，使用两位工程师来减轻同行评审的摩擦。
- en: Definition *Pair programming* is the practice of two programmers working together
    at one workstation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*结对编程*是两位程序员在一台工作站上共同工作的实践。
- en: One engineer may catch something the other does not realize, and vice versa.
    Pair programming has many challenges, including resource constraints and personality
    conflicts. Most companies don’t adopt it because it initially slows the delivery
    pace and affects team capacity. Some individuals dislike it because their pairing
    partner may work at a different pace. Pair programming takes self-awareness and
    discipline.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一位工程师可能会捕捉到另一位没有意识到的东西，反之亦然。结对编程有许多挑战，包括资源限制和个性冲突。大多数公司不采用它，因为它最初会减慢交付速度并影响团队容量。有些人不喜欢它，因为他们的配对伙伴可能工作速度不同。结对编程需要自我意识和纪律。
- en: Try to pair program IaC when you can. Infrastructure often includes particular
    terminology and institutional knowledge. For instance, current and future team
    members must understand *why* someone used an authoritative binding for project
    access control. Pair programming facilitates knowledge sharing and bakes in change
    review during development. Over time, your team becomes more proficient at delivering
    infrastructure changes quickly without the friction of manual change review.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地进行IaC的结对编程。基础设施通常包括特定的术语和制度知识。例如，当前和未来的团队成员必须理解为什么有人为项目访问控制使用了权威绑定。结对编程促进了知识共享，并在开发过程中内置了变更审查。随着时间的推移，你的团队在快速交付基础设施变更方面变得更加熟练，而无需手动变更审查的摩擦。
- en: Note Peer (or code) review and pair programming should promote a safe space
    for everyone on the team to learn how to code with best practices in mind. Specific
    details about these processes are beyond the scope of this book. For more information
    on code review, I recommend examining Google’s Engineering practices at [http://mng.bz/6XNR](http://mng.bz/6XNR).
    For more on pair programming, see [http://mng.bz/o2GD](http://mng.bz/o2GD). You
    can use various techniques to balance the pairing relationship, such as switching
    the keyboard every 30 minutes or assigning a driver and navigator.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意同行（或代码）评审和结对编程应该为团队中的每个人提供一个安全的空间，以便学习如何考虑最佳实践来编写代码。关于这些过程的特定细节超出了本书的范围。有关代码评审的更多信息，我建议查看谷歌的工程实践[http://mng.bz/6XNR](http://mng.bz/6XNR)。有关结对编程的更多信息，请参阅[http://mng.bz/o2GD](http://mng.bz/o2GD)。你可以使用各种技术来平衡配对关系，例如每30分钟切换键盘或指定驾驶员和导航员。
- en: A change to infrastructure can affect the availability of business-critical
    systems. Batching many changes can exacerbate the failure by making it challenging
    to troubleshoot to one root cause. If you can shorten the peer-review process
    with a combination of pair programming and test automation, you can focus on reviewing
    the architecture and impact of infrastructure changes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施的改变可能会影响关键业务系统的可用性。批量进行许多改变可能会加剧故障，因为难以追踪到一个根本原因。如果你能通过组合结对编程和测试自动化来缩短同行评审过程，你就可以专注于审查基础设施变更的架构和影响。
- en: 7.4 GitOps
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 GitOps
- en: What happens when you combine continuous deployment, declarative configuration,
    drift detection, and version control? All of these patterns seem fairly disparate,
    but using them together offers an opinionated approach to managing infrastructure.
    You declare the configuration you want for your infrastructure, add it to version
    control, and deploy it to production.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你结合持续部署、声明性配置、漂移检测和版本控制时会发生什么？所有这些模式似乎相当不同，但将它们一起使用为管理基础设施提供了一种有见地的方法。你声明你希望为基础设施设置的配置，将其添加到版本控制中，并将其部署到生产环境中。
- en: Imagine you want to update a payment service from version 3.0 to 3.2\. The payment
    service runs on a workload orchestrator (e.g., Kubernetes). The orchestrator offers
    a declarative configuration interface using a DSL. You can pass YAML files to
    configure resources in the orchestrator.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想将支付服务从版本3.0更新到3.2。支付服务运行在工作负载编排器（例如，Kubernetes）上。编排器提供了一个使用DSL的声明性配置接口。你可以传递YAML文件来配置编排器中的资源。
- en: Figure 7.20 implements a workflow that responds to changes by combining continuous
    deployment, the declarative configuration, and version control. You update the
    declarative configuration with version 3.2\. A controller detects drift between
    the current configuration and the one in version control. It starts a delivery
    pipeline to deploy the new version and run tests to check its functionality.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20实现了一个通过结合持续部署、声明性配置和版本控制来响应变更的工作流程。你使用版本3.2更新声明性配置。一个控制器检测当前配置与版本控制中的配置之间的偏差。它启动一个交付管道来部署新版本并运行测试以检查其功能。
- en: '![](../../OEBPS/Images/CH07_F20_Wang.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20](../../OEBPS/Images/CH07_F20_Wang.png)'
- en: Figure 7.20 An implementation of GitOps can use feature-based development to
    open a pull request, test changes on a branch, add reviewers, and merge the changes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 GitOps的一个实现可以使用基于特性的开发来打开一个拉取请求，在分支上测试变更，添加审阅者，并合并变更。
- en: Why do you have a controller detect and apply changes continuously? The controller
    reduces the drift between the expected configuration and actual state. This ensures
    that your system stays updated.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你要让控制器持续检测和应用变更？控制器减少了预期配置与实际状态之间的偏差。这确保了你的系统保持更新。
- en: You might get a sense of déjà vu from this workflow. After all, it combines
    all the practices on writing IaC, testing, and delivery. This book takes a very
    opinionated stance on IaC, aligning with a concept called GitOps. *GitOps* defines
    an approach that allows teams to manage infrastructure changes in version control,
    make declarative changes via IaC, and continuously deploy updates to infrastructure.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会从这个工作流程中感受到似曾相识的感觉。毕竟，它结合了所有关于编写基础设施即代码（IaC）、测试和交付的实践。本书对IaC持有非常坚定的立场，与称为GitOps的概念相一致。*GitOps*定义了一种方法，允许团队通过版本控制管理基础设施变更，通过IaC进行声明性更改，并持续部署更新到基础设施。
- en: Definition *GitOps* is an approach that uses declarative IaC to manage infrastructure
    changes through version control and continuously deploy them to production.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*GitOps*是一种使用声明性IaC通过版本控制管理基础设施变更并将其持续部署到生产的方法。
- en: You’ll associate GitOps most frequently with the Kubernetes ecosystem. However,
    GitOps offers an opinionated paradigm for scaling IaC practices across an organization.
    You no longer implement changes by filling tickets with the relevant details.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您最常将GitOps与Kubernetes生态系统联系起来。然而，GitOps为在整个组织中扩展IaC实践提供了一个有见地的范例。您不再通过填写包含相关详细信息的工单来实施更改。
- en: Instead, anyone in the organization can branch IaC and commit changes. Continuous
    deployment reduces drift, keeps infrastructure updated, and always runs the tests.
    You can track who requested and made the change through the pull request and commit
    history.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，组织中的任何人都可分支IaC并提交更改。持续部署减少漂移，保持基础设施更新，并始终运行测试。您可以通过拉取请求和提交历史记录跟踪谁请求并进行了更改。
- en: Note To learn more about GitOps and Kubernetes, check out *GitOps and Kubernetes*
    by Billy Yuen et al. (Manning, 2021). You can find general practices about GitOps
    on [https://opengitops.dev](https://opengitops.dev).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：想了解更多关于GitOps和Kubernetes的信息，请参阅Billy Yuen等人所著的*GitOps and Kubernetes*（Manning，2021）。您可以在[https://opengitops.dev](https://opengitops.dev)找到关于GitOps的一般实践。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Delivering infrastructure changes to production usually involves a change review
    process, which manually verifies the architecture and impact of the change.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基础设施更改交付到生产通常涉及一个变更审查流程，该流程手动验证更改的架构和影响。
- en: Continuous integration involves frequently merging changes to the main branch
    of infrastructure configuration.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成涉及频繁地将更改合并到基础设施配置的主分支。
- en: Continuous delivery deploys changes to a testing environment for automated testing
    and waits for manual approval before pushing them to production.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付将更改部署到测试环境进行自动测试，并在将其推送到生产之前等待手动审批。
- en: Continuous deployment directly deploys changes to production without a manual
    approval stage.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署直接将更改部署到生产环境，无需手动审批阶段。
- en: You can use continuous integration, delivery, or deployment to push IaC changes
    with automated tests, depending on the type of change and its frequency.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以根据更改的类型和频率，使用持续集成、交付或部署来推送IaC更改，并带有自动测试。
- en: Your team can collaborate on IaC by using feature-based development or trunk-based
    development.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的团队可以通过使用基于特性的开发或主干开发来协作进行IaC。
- en: Feature-based development creates a branch for each change, enabling isolated
    testing but requiring familiarity with version control practices.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于特性的开发为每个更改创建一个分支，允许隔离测试，但需要熟悉版本控制实践。
- en: Trunk-based development applies all changes to the main branch, which identifies
    conflicts between changes but requires a testing environment before production.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于主干的开发将所有更改应用于主分支，这会识别更改之间的冲突，但在生产之前需要测试环境。
- en: You can automate checks for formatting and standards and manually review the
    configuration for architecture and dependencies.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以自动化检查格式和标准，并手动审查配置架构和依赖关系。
- en: Pair programming can help identify conflicts and problems with a change earlier
    in the development process.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对编程可以帮助在开发早期阶段识别更改中的冲突和问题。
- en: GitOps incorporates version control, declarative infrastructure configuration,
    and continuous deployment to empower anyone to automate infrastructure changes
    through code commits.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps结合了版本控制、声明性基础设施配置和持续部署，使任何人都能通过代码提交自动化基础设施变更。
