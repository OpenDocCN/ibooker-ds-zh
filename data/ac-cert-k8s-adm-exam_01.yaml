- en: 1 First steps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 第一步
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the Certified Kubernetes Administrator Exam
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍认证Kubernetes管理员考试
- en: Defining a Kubernetes administrator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Kubernetes管理员
- en: Meeting Kubernetes and the problems it solves
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识Kubernetes及其解决的问题
- en: Introducing the Kubernetes API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes API
- en: Kubernetes components and Services, and Linux backend services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes组件和服务，以及Linux后端服务
- en: Declarative and imperative commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性和命令性命令
- en: Welcome to *Acing the Certified Kubernetes Administrator Exam*. If you’ve purchased
    this book, chances are you’ve already researched the exam, know what it’s about,
    and perhaps even have it scheduled. If not, don’t worry; we’ll talk about what
    the exam is and how to get signed up as soon as possible. For those of you who
    want to get right down to it, go ahead and skip this section, as it will most
    likely be review for you. You can skip to section 2, where we get into the meat
    and potatoes of the exam curriculum.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎加入 *通过认证Kubernetes管理员考试*。如果你已经购买了这本书，那么你很可能已经研究了考试，知道它是什么，甚至可能已经安排了考试。如果没有，不要担心；我们将讨论考试是什么以及如何尽快报名。对于那些想直接进入正题的人，请继续阅读本节，因为它对你来说很可能是复习。你可以跳到第2节，那里我们将深入探讨考试课程的核心内容。
- en: 'For those who are still being introduced to the CKA exam, let’s go over what
    the exam is and what it entails. First, let me start by stating that I’m glad
    you’ve decided to come along with us on this journey to get certified in Kubernetes.
    Achieving the Certified Kubernetes Administrator (CKA) certification is quite
    an accomplishment and will help advance your career in a very big way. Also, you’ll
    be part of a large group of individuals who hold this certification, including
    over 32,000 people worldwide. You might be asking yourself if it’s worth it, and
    to that, I would say yes, and here’s why:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些刚开始接触CKA考试的人来说，让我们先了解一下考试是什么以及它包含的内容。首先，让我先说，我很高兴你决定加入我们，一起踏上获得Kubernetes认证的旅程。获得认证Kubernetes管理员（CKA）认证是一项相当大的成就，并将极大地推动你的职业生涯。此外，你将成为一个大型群体中的一员，这个群体包括全球超过32,000人。你可能想知道这是否值得，对此，我会说值得，原因如下：
- en: Kubernetes and distributed systems are going to be around for a long time.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes和分布式系统将会长期存在。
- en: Kubernetes skills are in high demand.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes技能需求量大。
- en: Getting certified will help solidify your understanding and show that you are
    well rounded and versed in Kubernetes.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过认证将有助于巩固你对Kubernetes的理解，并表明你在Kubernetes方面知识全面、熟练。
- en: 1.1 Introducing the CKA exam
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 介绍CKA考试
- en: Now, let’s get into what the exam is all about. The CKA exam is a competency
    test like no other. Instead of multiple-choice or fill-in-the-blank questions,
    this exam is entirely executed from within a Linux terminal (Ubuntu XFCE) in a
    remote desktop environment provided by PSI Services (the exam provider). Yes,
    that’s right; they’ll give you a set of tasks to complete, and you’ll execute
    the solutions by typing the commands inside the terminal within the provided remote
    desktop environment. This is the entire exam experience, and you will have two
    hours to complete 15–20 tasks of this nature. Once complete, you are graded on
    the outcome of your tasks, no matter which path you took to achieve the outcome.
    This means that there may be more than one way to solve a given task. Throughout
    this book, you will learn different ways of obtaining the same results, giving
    you more tools in your tool belt, to achieve a passing grade on this exam, which
    is 66% or higher. You can also receive partial credit on any task, so that will
    help your success rate as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解考试的内容。CKA考试是一种独特的胜任力测试。与其他考试不同，它不是选择题或填空题，而是在PSI服务（考试提供者）提供的远程桌面环境中，完全在Linux终端（Ubuntu
    XFCE）内执行。是的，没错；他们会给你一组任务来完成，你将通过在提供的远程桌面环境中的终端内输入命令来执行解决方案。这就是整个考试体验，你将有两个小时的时间完成15-20个这样的任务。一旦完成，你将根据任务的成果进行评分，无论你采取了哪种途径来实现成果。这意味着可能存在多种解决给定任务的方法。在这本书的整个过程中，你将学习不同的方法来获得相同的结果，这将为你提供更多的工具，帮助你在这场考试中取得及格的分数，及格分数是66%或更高。你也可以在任何一个任务中获得部分分数，这将有助于提高你的成功率。
- en: Throughout this book, we’ll address tips and tricks available for each topic
    within each chapter. This will tie in nicely with applying your lessons and give
    you the necessary skills to approach the exam with confidence. These exam tips,
    in combination with your determination and repeated practice, will lead to success
    in passing the CKA exam. I can’t emphasize enough how much muscle memory and putting
    in the practice will help your brain retain and access the appropriate Kubernetes
    commands when the time comes for the exam. Acing the CKA is truly an exercise,
    so if you’re determined to pass the exam, you shouldn’t take long breaks between
    study sessions, especially if you aren’t working with Kubernetes daily. Don’t
    let this deter you, though; we’re going to do this Kubernetes workout together!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将针对每一章中每个主题可用的技巧和窍门进行讨论。这将很好地与运用你的课程内容相结合，并为你提供必要的技能，以自信地应对考试。这些考试技巧，结合你的决心和反复练习，将有助于你在通过
    CKA 考试中取得成功。我无法强调肌肉记忆和投入练习对于在考试时间来临时帮助你的大脑保留和访问适当的 Kubernetes 命令有多么重要。真正掌握 CKA
    确实是一项锻炼，所以如果你决心通过考试，你不应该在学习期间长时间休息，尤其是如果你不是每天与 Kubernetes 一起工作。尽管如此，不要因此气馁；我们将一起完成这个
    Kubernetes 锻炼！
- en: 'The CKA exam is provided by the Linux Foundation, and Kubernetes is maintained
    by the Cloud Native Computing Foundation (CNCF). The exam costs US$375 as of the
    writing of this book, but check the updated pricing sheet for current prices and
    prices in other currencies by visiting the Linux Foundation website at [https://training.linuxfoundation.org](https://training.linuxfoundation.org).
    This price may be a bit higher than similar certifications of its class, but they
    do allow one free retake, as well as one additional browser tab, opened to the
    following sites and their subdomains during the exam:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CKA 考试由 Linux 基金会提供，Kubernetes 由云原生计算基金会（CNCF）维护。截至本书编写时，考试费用为 375 美元，但请访问 Linux
    基金会网站 [https://training.linuxfoundation.org](https://training.linuxfoundation.org)
    查看最新的价格和不同货币的价格。这个价格可能比同类认证略高，但它们确实允许免费重考一次，以及在考试期间打开一个额外的浏览器标签页，访问以下网站及其子域名：
- en: '[https://helm.sh/docs/](https://helm.sh/docs/)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://helm.sh/docs/](https://helm.sh/docs/)'
- en: '[https://kubernetes.io/docs/](https://kubernetes.io/docs/)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/](https://kubernetes.io/docs/)'
- en: '[https://github.com/kubernetes/](https://github.com/kubernetes/)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/](https://github.com/kubernetes/)'
- en: '[https://kubernetes.io/blog/](https://kubernetes.io/blog/)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/blog/](https://kubernetes.io/blog/)'
- en: To take the exam, you will need a computer running Windows 8.1, Windows 10,
    Windows 11, macOS 10.15, macOS 11, macOS 12, Ubuntu 18.04, or Ubuntu 20.04 that
    has the Chrome web browser installed (all browsers are supported, but PSI highly
    recommends Chrome). When you begin the exam, you’ll be instructed to download
    and install a new PSI-secured browser, which will automatically grant you access
    to the PSI proctoring platform, called *PSI Bridge*, which is the remote desktop
    environment. The remote desktop environment will include links to open the terminal
    as well as the provided Firefox browser (you must use Firefox) so you can browse
    to the authorized sites listed earlier. You will also need a webcam that has at
    least 640 × 480 pixel resolution, as they will require a 360 view of the room
    (external camera required for desktops) and will be monitoring you for the duration
    of the exam. Your computer screen must be 1368 x 769 pixel resolution or higher
    (dual monitors are not supported), you must have a functional microphone, and
    your internet bandwidth speed must be at least 300 Kbps to download and upload.
    The room where you take the exam must be quiet and well lit. Public spaces such
    as coffee shops or stores are not allowed. Your desk must be cleared of all papers
    and other electronics, and you must be seen clearly in the center frame of your
    webcam.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参加考试，你需要一台运行Windows 8.1、Windows 10、Windows 11、macOS 10.15、macOS 11、macOS 12、Ubuntu
    18.04或Ubuntu 20.04的电脑，并且已经安装了Chrome网络浏览器（所有浏览器都受支持，但PSI强烈推荐使用Chrome）。当你开始考试时，你会被告知下载并安装一个新的PSI安全浏览器，这将自动为你提供访问PSI监考平台，称为*PSI
    Bridge*，这是一个远程桌面环境。远程桌面环境将包括打开终端以及提供的Firefox浏览器的链接（你必须使用Firefox）以便你可以浏览到之前列出的授权网站。你还需要一个至少具有640
    × 480像素分辨率的摄像头，因为它们将需要房间的一个360度视图（台式机需要外部摄像头）并在整个考试过程中监视你。你的电脑屏幕分辨率必须为1368 x 769像素或更高（不支持双显示器），你必须有一个功能正常的麦克风，并且你的互联网带宽速度必须至少为300
    Kbps以进行下载和上传。你参加考试的地方必须安静且光线充足。不允许在公共空间，如咖啡馆或商店进行考试。你的桌子必须清理干净，不得放置任何纸张和其他电子产品，并且你必须清晰地出现在你的摄像头的中心框架中。
- en: On exam day, you’ll sit down at your desk with your computer, make sure it’s
    plugged in, then go to the Linux Foundation portal to start your exam. Before
    you click the Begin Exam button, make sure that all browser tabs are closed and
    no other applications are running in the background (the proctor will check this
    as well). Once you click on the button to begin the exam, you’ll immediately be
    introduced to an exam proctor. This exam proctor will check your environment to
    make sure that your desk is cleared and there aren’t any papers or unauthorized
    electronics around. So, using your camera, you’ll pan around the room to get a
    full 360 view, and you’ll wait for their approval. They’ll also periodically check
    your hands and wrists. The proctor will first check your hands and wrists before
    you start the exam, then they’ll also stop you at frequent intervals in the middle
    of your exam and ask you to show both sides of your hands and wrists. Before they
    release the exam to you, they will also ask you for your government-issued ID,
    which you must hold up to the camera. Once the proctor is done verifying your
    identity and checking your workspace, they will release the exam, which means
    they will allow you to enter the exam and view the first question. You’ll notice
    that each question has a similar format, including the context you must use and
    the task(s) that you must execute via the command line to solve the problem. If
    you come to a question that you can’t answer, my advice is to skip it; you can
    flag it and come back to it at any time during the exam. It will be clear how
    to flag a question for review, as they show you in a brief automated walk-through
    at the beginning of the exam. For each task, you will also see the percentage
    of points that the task is worth. If you’re stumped on something, look at how
    much it’s worth. If it’s worth, let’s say, 5%, then go ahead and skip it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试当天，你将坐在电脑前，确保电脑已连接电源，然后访问 Linux 基金会门户开始考试。在点击“开始考试”按钮之前，请确保所有浏览器标签页都已关闭，且后台没有运行其他应用程序（监考官也会检查这一点）。一旦你点击开始考试的按钮，你将立即遇到一位考试监考官。这位监考官会检查你的环境，确保你的桌子是清理过的，周围没有纸张或未经授权的电子产品。因此，使用你的摄像头，你将环顾四周以获得完整的
    360 度视角，并等待他们的批准。他们还会定期检查你的双手和手腕。在考试开始之前，监考官首先会检查你的双手和手腕，然后在考试过程中，他们还会在频繁的间隔中让你停下来，要求你展示双手和手腕的两侧。在他们将考试释放给你之前，他们还会要求你出示政府颁发的身份证件，你必须将其举到摄像头前。一旦监考官完成身份验证和检查工作空间，他们将会释放考试，这意味着他们允许你进入考试并查看第一题。你会发现每道题都有类似的格式，包括你必须使用的上下文以及你必须通过命令行执行的任务来解决该问题。如果你遇到无法回答的问题，我的建议是跳过它；你可以在考试期间随时标记它并返回。在考试开始时，他们会通过简短的自动化演示向你展示如何标记问题以供审查。对于每个任务，你也会看到该任务占的百分比。如果你对某事感到困惑，看看它值多少分。如果它值，比如说，5%，那么就继续跳过它。
- en: EXAM TIP If you are copying and pasting text back and forth from the Firefox
    browser and the terminal, use the keyboard shortcut CTRL-SHIFT-C to copy and CTRL-SHIFT-V
    to paste.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：如果你需要在 Firefox 浏览器和终端之间复制粘贴文本，请使用快捷键 CTRL-SHIFT-C 来复制，CTRL-SHIFT-V 来粘贴。
- en: The core competencies on which you will be tested are cluster architecture,
    installation and configuration; workloads and scheduling; Services and networking;
    storage; and troubleshooting. We’ll cover all these areas in this book. Within
    the cluster architecture competency, which will comprise 25% of the questions
    on the exam, you will be tested on role-based access control, using kubeadm to
    add features and update a Kubernetes cluster, and backing up and restoring the
    etcd datastore. In the workloads and scheduling competency, which will comprise
    15% of the questions on the exam, expect to be tested on performing rolling updates
    and rollbacks, as well as scaling applications and using ConfigMaps and Secrets.
    In the Services and networking competency, which comprises 20% of the questions
    on the exam, you’ll be tested on creating and updating various Services in Kubernetes,
    using Ingress, DNS, and the container network interface in Kubernetes. In the
    storage competency, which comprises 10% of the questions on the exam, you’ll need
    to understand storage classes, persistent volumes, and volume modes in Kubernetes.
    Then, in the troubleshooting competency, which is 30% of the questions on the
    exam, you will be expected to know how to get the logs from a Kubernetes cluster,
    as well as monitor and repair core cluster components. Table 1.1 outlines these
    domains and their competencies.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被测试的核心能力包括集群架构、安装和配置；工作负载和调度；服务和网络；存储；以及故障排除。本书将涵盖所有这些领域。在集群架构能力方面，这将占考试问题的25%，你将接受基于角色的访问控制、使用
    kubeadm 添加功能和更新 Kubernetes 集群、以及备份和恢复 etcd 数据存储的测试。在工作负载和调度能力方面，这将占考试问题的15%，你将接受执行滚动更新和回滚、以及扩展应用程序和使用
    ConfigMaps 和 Secrets 的测试。在服务和网络能力方面，这将占考试问题的20%，你将接受在 Kubernetes 中创建和更新各种服务、使用
    Ingress、DNS 和 Kubernetes 的容器网络接口的测试。在存储能力方面，这将占考试问题的10%，你需要了解 Kubernetes 中的存储类、持久卷和卷模式。然后，在故障排除能力方面，这是考试问题的30%，你将需要知道如何从
    Kubernetes 集群中获取日志，以及监控和修复核心集群组件。表 1.1 概述了这些领域及其能力百分比。
- en: Table 1.1 Exam competencies and their percentages of the exam
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 考试能力和其占考试百分比
- en: '| Cluster architecture, installation, and configuration—25% |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 集群架构、安装和配置—25% |'
- en: '|'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Manage role-based access control (RBAC).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理基于角色的访问控制（RBAC）。
- en: Use kubeadm to install a basic cluster.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kubeadm 安装基本集群。
- en: Manage a highly available Kubernetes cluster.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理高可用性 Kubernetes 集群。
- en: Perform a version upgrade on a Kubernetes cluster using kubeadm..
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kubeadm 在 Kubernetes 集群上执行版本升级。
- en: Implement etcd backup and restore.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施 etcd 备份和恢复。
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Workloads and scheduling—15% |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 工作负载和调度—15% |'
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand Deployments and how to perform rolling updates and rollbacks.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Deployments 以及如何执行滚动更新和回滚。
- en: Use ConfigMaps and Secrets to configure applications.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ConfigMaps 和 Secrets 配置应用程序。
- en: Know how to scale applications.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何扩展应用程序。
- en: Understand the primitives used to create robust, self-healing application Deployments.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解用于创建健壮、自我修复的应用程序部署的原语。
- en: Understand how resource limits can affect Pod scheduling.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解资源限制如何影响 Pod 调度。
- en: Awareness of manifest management and common templating tools.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解清单管理和常用模板工具。
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Services and networking—20% |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 服务和网络—20% |'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand host networking configuration on the cluster nodes.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集群节点上理解主机网络配置。
- en: Understand connectivity between Pods.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Pod 之间的连接性。
- en: Understand ClusterIP, NodePort, and LoadBalancer Service types and Endpoints.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ClusterIP、NodePort 和 LoadBalancer 服务类型和端点。
- en: Know how to use Ingress controllers and Ingress resources.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 Ingress 控制器和 Ingress 资源。
- en: Know how to configure and use CoreDNS.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何配置和使用 CoreDNS。
- en: Choose an appropriate container network interface plugin.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的容器网络接口插件。
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Storage—10% |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 存储—10% |'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand storage classes and persistent volumes.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解存储类和持久卷。
- en: Understand volume and access modes and reclaim policies for volumes.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解卷和访问模式以及卷的回收策略。
- en: Understand persistent volume claims primitive.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解持久卷声明原语。
- en: Know how to configure applications with persistent storage.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何配置具有持久存储的应用程序。
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Troubleshooting—30% |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 故障排除—30% |'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Evaluate cluster and node logging.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估集群和节点日志。
- en: Understand how to monitor applications.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何监控应用程序。
- en: Manage container stdout and stderr logs.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器标准输出和标准错误日志。
- en: Troubleshoot application failure.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除应用程序故障。
- en: Troubleshoot cluster component failure.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除集群组件故障。
- en: Troubleshoot networking.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除网络问题。
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You will have six clusters available during the exam that you will be required
    to switch between depending on the question. Usually, each question will ask you
    to perform the task on a different cluster than the previous question. They will
    provide instructions for how to switch between clusters, so don’t worry too much
    about memorizing the cluster names and commands to switch between clusters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试期间，你将拥有六个集群可供使用，你将需要根据问题在这些集群之间进行切换。通常，每个问题都会要求你在与上一个问题不同的集群上执行任务。他们将提供如何在集群之间切换的说明，所以不必过于担心记住集群名称和切换集群的命令。
- en: The exam will also have the alias for `kubectl` set to `k`. An *alias* is a
    command you run that pertains to another command. For example, a common alias
    that exists for most Linux operating systems is `l='ls -lah'`, which means when
    you type the command `l`, it’s the same thing as typing `ls -lah`. Similarly for
    the CKA exam, when you type the command `k`, it’s the same as the command `kubectl`.
    From the command line on your computer, you can type `alias` to list all the existing
    aliases on your computer. All six clusters will have only one control plane node,
    and two clusters will have only one worker node, with one out of those two missing
    a worker node. They will all have a container network interface (CNI) installed
    and are named `k8s`, `hk8s`, `bk8s`, `wk8s`, `ek8s`, and `ik8s`, as shown in figure
    1.1.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考试还将为 `kubectl` 设置别名 `k`。别名是你运行的一个与另一个命令相关的命令。例如，大多数 Linux 操作系统都存在一个常见的别名 `l='ls
    -lah'`，这意味着当你输入命令 `l` 时，它与输入 `ls -lah` 是相同的。同样，对于 CKA 考试，当你输入命令 `k` 时，它与命令 `kubectl`
    相同。从你电脑的命令行中，你可以输入 `alias` 来列出你电脑上所有现有的别名。所有六个集群都只有一个控制平面节点，其中两个集群只有一个工作节点，这两个节点中有一个缺少工作节点。它们都将安装容器网络接口（CNI），并命名为
    `k8s`、`hk8s`、`bk8s`、`wk8s`、`ek8s` 和 `ik8s`，如图 1.1 所示。
- en: '![](../../OEBPS/Images/01-01.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-01.png)'
- en: Figure 1.1 Cluster configuration for all six clusters in the exam environment
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 考试环境中所有六个集群的集群配置
- en: So many people have registered for the CKA exam that it has become one of the
    most popular Linux Foundation certifications to date. This partially speaks to
    the demand for the certification but also to the credibility of the certification
    once received. The certificate is valid for three years, and the process to recertify
    is the same process that you went through the first time you took the exam.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多人注册了 CKA 考试，以至于它已经成为迄今为止最受欢迎的 Linux 基金会认证之一。这部分反映了认证的需求，但也反映了获得认证后的可信度。证书有效期为三年，重新认证的过程与你第一次参加考试时相同。
- en: I suggest scheduling your exam now, so you have an end goal and a deadline for
    completing it. This will keep you motivated to finish this book and will provide
    the necessary timeline to keep your knowledge top of mind and appropriately prepared
    to sit for the exam. If you are currently working with Kubernetes at your job,
    and you are typing `kubectl` commands daily, then schedule your exam for one month
    from today.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你现在就安排考试，这样你就有了一个完成考试的目标和截止日期。这将让你保持动力完成这本书，并提供必要的时间表，以保持你的知识在心中，并适当准备参加考试。如果你目前在工作中使用
    Kubernetes，并且你每天都在输入 `kubectl` 命令，那么请安排你在今天起一个月后参加考试。
- en: 'If you are just approaching the topic of Kubernetes, having never heard of
    it before, go ahead and schedule your exam for the furthest date the exam scheduler
    will allow (usually this is three months, but it may be less.) You can always
    reschedule, but the point is to give yourself two things: (1) a deadline so that
    you can take this exam seriously and achieve your intended result and (2) daily
    practice to incorporate into your prefrontal cortex (where memories are stored).
    This is exactly what you’ll need to stay fresh and ready for the exam.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚刚接触 Kubernetes 主题，之前从未听说过它，那么请安排你在考试调度器允许的最晚日期参加考试（通常这是三个月，但可能更短。）你总是可以重新安排，但关键是要给自己两样东西：（1）一个截止日期，这样你就可以认真对待这次考试并实现你的预期结果；（2）日常练习，将其融入你的前额叶皮层（记忆存储的地方）。这正是你保持新鲜和为考试做好准备所需要的东西。
- en: 1.2 What’s in store
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 有哪些内容
- en: Throughout this book, I’ll be inserting exercises and exam-like scenarios for
    you to practice `kubectl` commands and prepare you for the exam. To make practice
    as easy as possible, I’ve included instructions for creating your local cluster.
    In appendix A, I’ll walk you through the steps to create a Kubernetes cluster
    using kind. Kind Kubernetes ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
    is a free, lightweight, and easy-to-use tool for creating a cluster right on your
    existing laptop or desktop computer. The only requirement is Docker, and with
    one command, you’ll have a cluster up and running in seconds. This eliminates
    the barrier to entry for practicing for the CKA. I advise you to utilize this
    method, as you can waste a lot of time trying to build a cluster manually; and
    because the exam will have clusters already prepared for you, I believe this is
    the best way to study and follow along with this book. There are other methods
    to create a local cluster that you are welcome to use, such as minikube or MicroK8s.
    The idea is similar, but those tools might not align directly with the scenarios
    in this book. For example, in chapter 5, we’ll prepare a cluster with a missing
    node. The steps to stage the environment are unique to kind, so reproducing the
    environment in minikube will be different.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将插入练习和类似考试的情景，让您练习`kubectl`命令，并为考试做准备。为了使练习尽可能容易，我包括了创建您本地集群的说明。在附录A中，我将向您介绍使用kind创建Kubernetes集群的步骤。Kind
    Kubernetes ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)) 是一个免费、轻量级且易于使用的工具，可以在您现有的笔记本电脑或台式机上创建集群。唯一的要求是Docker，只需一条命令，您就能在几秒钟内拥有一个集群并运行起来。这消除了练习CKA的入门障碍。我建议您使用这种方法，因为您可能会浪费大量时间手动构建集群；而且由于考试将为您准备好的集群，我认为这是学习和跟随这本书的最佳方式。还有其他创建本地集群的方法，您也可以使用，例如minikube或MicroK8s。想法是相似的，但那些工具可能不会直接与本书中的场景相匹配。例如，在第5章中，我们将准备一个缺少节点的集群。设置环境的步骤是kind特有的，因此在minikube中重现环境将有所不同。
- en: Within each chapter of this book, there will be a scenario that resembles the
    real exam, which we’ll work through together, followed by additional practice
    exercises that you can complete on your own. In appendix D, you can review hints
    for solving these practice exercises. You can use these to both test your knowledge
    of the book’s content and to gauge your readiness for the CKA exam.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的每一章中，将会有一个类似于真实考试的情景，我们将一起解决，然后是您可以独立完成的额外练习。在附录D中，您可以回顾解决这些练习的提示。您可以使用这些提示来测试您对本书内容的了解，并评估您对CKA考试的准备情况。
- en: Before we begin, I’d like to clarify some points and let you know what this
    book is and what it isn’t. This book is not an introduction to Kubernetes, so
    I expect that you have a background in containers and an understanding of what
    problem Kubernetes solves, as these will not be covered in this book. The CKA
    exam is not introductory; therefore, it will require quite a bit of experience
    with using and navigating the Linux operating system. People who understand cgroups
    and namespaces, which provide containers in Linux, will have an easier time following
    this book and subsequently passing the exam. Also, most who sit for this exam
    are already working with the technology in their job today, by either being introduced
    to it via a new project or by already using cluster administration as a primary
    function within their role. I’m not saying that people who are not working with
    Kubernetes won’t pass the exam, but getting direct exposure to real-world scenarios,
    using your knowledge in a daily, hands-on fashion is more likely to lead to success.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想澄清一些要点，并让您了解这本书是什么以及它不是什么。这本书不是Kubernetes的入门介绍，所以我期望您对容器有背景知识，并理解Kubernetes解决的问题，因为这些内容本书不会涉及。CKA考试不是入门级考试；因此，它将需要相当多的使用和导航Linux操作系统的经验。那些理解cgroups和namespaces（在Linux中提供容器）的人，将更容易跟随这本书，并随后通过考试。此外，大多数参加这次考试的人已经在他们的工作中使用这项技术，无论是通过一个新的项目接触它，还是已经将集群管理作为他们角色中的主要功能。我并不是说没有与Kubernetes合作的人不能通过考试，但直接接触现实场景，以日常、实际的方式运用您的知识，更有可能带来成功。
- en: 1.2.1 What is a Kubernetes administrator?
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 Kubernetes管理员是什么？
- en: 'The role of a Kubernetes administrator is twofold. A Kubernetes administrator
    knows the inner workings of Kubernetes and how to translate that into value for
    the end users. Here’s what a job posting for a Kubernetes administrator might
    look like: “The responsibility of a Kubernetes administrator is to ensure that
    the company’s services meet the needs of the customers within the desired levels
    of reliability, performance, and availability by developing continuous improvements,
    tools, and automation. You must know how to install, configure, deploy, update,
    and patch each of the components of the Kubernetes infrastructure to ensure that
    services and underlying systems are properly monitored and have adequate observability.
    This includes identifying and monitoring proper KPIs (key performance indicators)
    to ensure service health, minimizing MTTA (mean time to acknowledge) and MTTR
    (mean time to repair).”'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 管理员的职责有两方面。Kubernetes 管理员了解 Kubernetes 的内部工作原理以及如何将其转化为对最终用户的价值。以下是一份
    Kubernetes 管理员职位发布的内容：“Kubernetes 管理员的职责是通过开发持续改进、工具和自动化，确保公司的服务在期望的可靠性、性能和可用性水平上满足客户需求。你必须知道如何安装、配置、部署、更新和修补
    Kubernetes 基础设施中的每个组件，以确保服务和底层系统得到适当的监控并具有足够的可观察性。这包括识别和监控适当的 KPI（关键绩效指标）以确保服务健康，最小化
    MTTA（平均确认时间）和 MTTR（平均修复时间）。”
- en: Let’s not sugarcoat it; the difficulty level of the exam remains high, hence
    the need for this book. But you will start to realize the complexities of Kubernetes
    after reading this book—not only how to envision the complexities and how they
    relate to what you already know about engineering and technology, but also how
    to dig through the complexities to troubleshoot and determine the root cause for
    the actions within a Kubernetes cluster.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不妨实话实说；考试的难度仍然很高，因此需要这本书。但你在阅读这本书后，将开始意识到 Kubernetes 的复杂性——不仅在于如何构想这些复杂性以及它们如何与你已知的工程和技术知识相关联，还在于如何深入复杂性以进行故障排除并确定
    Kubernetes 集群内操作的根本原因。
- en: 1.3 Meeting Kubernetes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 了解 Kubernetes
- en: That brings me to the next point—the Kubernetes cluster. What is it? The Kubernetes
    cluster is called a *cluster* because it is a RESTful API of machines working
    together, in conjunction, as in figure 1.2\. Just like a server farm, the machines
    are interconnected and housed within the same facility or network. But the key
    difference in Kubernetes is that the connected servers not only distribute load
    appropriately but also easily exchange data to eliminate a single point of failure.
    If one of the nodes fails, it doesn’t bring down the entire cluster. Throughout
    this book, we’ll call servers *nodes*. *Node* is a term that’s specific to clusters,
    which tend to indicate that the server is a part of a larger system. We’ll talk
    more about the anatomy of a cluster in chapter 2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了下一个要点——Kubernetes 集群。它是什么？Kubernetes 集群被称为“集群”，因为它是由协同工作的机器组成的 RESTful API，就像图
    1.2 所示。就像一个服务器农场一样，机器相互连接并位于同一设施或网络内。但在 Kubernetes 中的关键区别是，连接的服务器不仅能够适当地分配负载，而且可以轻松交换数据以消除单点故障。如果一个节点失败，它不会使整个集群崩溃。在这本书的整个过程中，我们将把服务器称为“节点”。“节点”是一个特定于集群的术语，通常表示服务器是更大系统的一部分。我们将在第
    2 章中更多地讨论集群的解剖结构。
- en: '![](../../OEBPS/Images/01-02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-02.png)'
- en: Figure 1.2 Servers (called nodes) working together in a cluster. When one fails,
    it takes itself out of the cluster to be repaired.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 集群中协同工作的服务器（称为节点）。当其中一个失败时，它会将自己从集群中移除以进行修复。
- en: NOTE Kubernetes is often referred to as K8s for short (pronounced kates), where
    the 8 between the K and the S represents the number of characters between those
    letters (“ubernete” = 8 characters).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Kubernetes 通常简称为 K8s（发音为 kates），其中 K 和 S 之间的 8 代表这两个字母之间的字符数（“ubernete” =
    8 个字符）。
- en: Kubernetes is nothing more than a piece of software that you interact with via
    a REST API. A RESTful API is a well-defined, highly scalable, loosely coupled
    application architecture that favors communication over a network—and, more importantly,
    the act of transferring the state of a resource over a network. I can’t stress
    enough how important it is to remember that Kubernetes is behind an API (a RESTful
    one, which is a collection of resources that can be manipulated through that API).
    *Resources* is the keyword here. Resources are how we address objects in Kubernetes.
    Sometimes in the Kubernetes community, we use the words *resources* and *objects*
    interchangeably, but there is a fundamental difference. Objects can have more
    than one resource address; for example, Deployments can have multiple URIs (uniform
    resource identifiers) based on the API version or based on the Deployment name,
    as you can see in figure 1.3\. *Deployments* in Kubernetes are objects that offer
    more automated control over Pods and ReplicaSets that comprise your application
    running on Kubernetes. ReplicaSets are another type of object in Kubernetes that
    provides a control loop running a specified number of Pods (i.e., Pod replicas).
    You can list all available API resources with the command `kubectl api-resources`
    from any Kubernetes cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes不过是一块软件，您通过REST API与之交互。RESTful API是一个定义良好、高度可扩展、松耦合的应用架构，它优先考虑通过网络进行通信——更重要的是，通过网络传输资源的状态。我无法强调记住这一点的重要性，即Kubernetes背后有一个API（一个RESTful
    API，它是一组可以通过该API进行操作的资源）。*资源*是这里的关键词。资源是我们如何在Kubernetes中定位对象的方式。有时在Kubernetes社区中，我们使用*资源*和*对象*这两个词可以互换使用，但它们之间有一个根本的区别。对象可以有多个资源地址；例如，Deployments可以根据API版本或根据Deployment名称拥有多个URI（统一资源标识符），如图1.3所示。*Deployments*在Kubernetes中是对象，它们为您在Kubernetes上运行的应用程序中的Pods和ReplicaSets提供更自动化的控制。ReplicaSets是Kubernetes中的另一种对象类型，它提供了一个运行指定数量Pods（即Pod副本）的控制循环。您可以使用`kubectl
    api-resources`命令从任何Kubernetes集群列出所有可用的API资源。
- en: '![](../../OEBPS/Images/01-03.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-03.png)'
- en: Figure 1.3 Kubernetes addresses objects by their resource URI, where multiple
    URIs can point to a single object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 Kubernetes通过资源URI来定位对象，其中多个URI可以指向单个对象。
- en: We commonly interact with the Kubernetes API, and the objects within, by using
    a command-line tool called `kubectl`. We will solely be using `kubectl` throughout
    this book, as this is the command-line tool used on the exam to interface with
    the Kubernetes API. Having the `kubectl` command-line tool, in addition to a certificate,
    is needed to create, read, update, and delete Kubernetes resources. Depicted in
    figure 1.4 is a certificate that provides us with the role-based access that we
    need to perform certain operations in the Kubernetes cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过一个名为`kubectl`的命令行工具与Kubernetes API及其中的对象进行交互。在这本书中，我们将仅使用`kubectl`，因为这是在考试中用于与Kubernetes
    API接口的命令行工具。除了证书外，还需要`kubectl`命令行工具来创建、读取、更新和删除Kubernetes资源。图1.4展示了为我们提供执行Kubernetes集群中某些操作所需基于角色的访问权限的证书。
- en: '![](../../OEBPS/Images/01-04.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-04.png)'
- en: Figure 1.4 `kubectl` is the tool used to access Kubernetes objects, given a
    valid certificate inside the kubeconfig.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 `kubectl`是用于访问Kubernetes对象的工具，在kubeconfig内部提供有效的证书。
- en: 1.3.1 Cluster architecture, installation, and configuration
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 集群架构、安装和配置
- en: As previously mentioned, the architecture of a cluster is comprised of nodes,
    and on those nodes are running Pods. A Pod is the smallest deployable unit in
    Kubernetes and contains one or more containers. In an abstraction of the API,
    resources like Deployments are created that are comprised of *ReplicaSets*, which
    in turn are running one or more Pods across multiple nodes. In Kubernetes, there
    are two types of nodes—the *control plane node* and the *worker node*. The control
    plane node runs the API server, DNS, the controller manager, the scheduler, kube-proxy,
    and etcd datastore. All these parts and their relationships are shown in figure
    1.5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，集群的架构由节点组成，在这些节点上运行着Pod。Pod是Kubernetes中最小的可部署单元，包含一个或多个容器。在API的抽象中，创建了由*ReplicaSets*组成的资源，这些ReplicaSets又运行在多个节点上的一个或多个Pod。在Kubernetes中，有两种类型的节点——*控制平面节点*和*工作节点*。控制平面节点运行API服务器、DNS、控制器管理器、调度器、kube-proxy和etcd数据存储。所有这些部分及其关系都在图1.5中展示。
- en: '![](../../OEBPS/Images/01-05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-05.png)'
- en: Figure 1.5 Kubernetes architecture showing nodes, Pods, Deployments, and ReplicaSets
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 显示了 Kubernetes 架构，其中包括节点、Pod、部署和副本集。
- en: Communication to the control plane happens through the API, on the control plane
    node. The worker nodes, by way of the kubelet, get instructions from the control
    plane to fulfill their duty to not only run the containers themselves but to report
    on the health, providing a constant status to the control plane. The workers carry
    the brunt of the load, which makes their role very important for running applications
    in Kubernetes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与控制平面通信通过 API 在控制平面节点上进行。工作节点通过 kubelet 获取来自控制平面的指令，以履行其职责，不仅运行容器，还要报告健康状况，向控制平面提供持续的状态。工作节点承担着大部分负载，这使得它们在
    Kubernetes 中运行应用程序时扮演着非常重要的角色。
- en: 1.3.2 Workloads and scheduling
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 工作负载和调度
- en: Resources like ReplicaSets (`rs`) and Deployments (`deploy`) are essential to
    developing stateless application workloads running on Kubernetes. Without them,
    we wouldn’t be able to automatically scale Pods, which provides load balancing,
    making our applications more readily available when running on Kubernetes. We
    call the process of deploying these applications to Kubernetes *scheduling*. The
    term *scheduling* comes from the *scheduler*, which is a component of the control
    plane. We’ll talk more about the control plane components later in this chapter.
    Historically, if you had to create an application that runs on hardware, it had
    to be maintained and updated from time to time. This can cause outages and/or
    limitations to what that hardware can do (it gets old). Kubernetes (the application)
    abstracts this hardware away and creates a common interface (an API) between it
    and everything else (hardware alike). This allows you to switch out hardware on
    the fly, as well as incorporate hardware from different vendors and mix and match.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像副本集（`rs`）和部署（`deploy`）这样的资源对于在 Kubernetes 上运行无状态应用程序工作负载至关重要。没有它们，我们就无法自动扩展
    Pod，这提供了负载均衡，使得我们的应用程序在 Kubernetes 上运行时更加易于访问。我们将将这些应用程序部署到 Kubernetes 的过程称为*调度*。术语*调度*来自*调度器*，它是控制平面的一部分。我们将在本章后面更详细地讨论控制平面组件。历史上，如果你必须创建一个在硬件上运行的应用程序，它必须定期维护和更新。这可能会导致中断和/或限制该硬件的功能（它会过时）。Kubernetes（应用程序）抽象化了这种硬件，并在它和所有其他东西（包括硬件）之间创建了一个通用接口（一个
    API）。这允许你在运行时更换硬件，以及整合来自不同供应商的硬件并进行混合匹配。
- en: 'My favorite way of driving home this point is to look at an example to get
    a solid understanding of resources inside of an API. Let’s look at an API that’s
    been rendered through the browser at [https://swapi.dev](https://swapi.dev). If
    you go to SWAPI (*Star Wars* API), you’ll see how to request different facts about
    *Star Wars* movies. You make this request via a `GET` request to the API. Because
    the API is built on top of the HTTP protocol, we can perform HTTP methods to take
    action on the API Endpoints. Those actions can be create, read, update, or delete,
    usually designated by an acronym: *CRUD*. In this case, though, the purpose of
    the SWAPI is to make a request to the API and “GET” back some data. So, in the
    request field, type `people/1/`, and down below you should see the results, shown
    in figure 1.6.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的阐述这个观点的方法是查看一个例子，以获得对 API 内部资源的深入了解。让我们看看一个通过浏览器在 [https://swapi.dev](https://swapi.dev)
    渲染的 API。如果你访问 SWAPI（*星球大战* API），你会看到如何请求有关 *星球大战* 电影的不同事实。你通过向 API 发送 `GET` 请求来执行此请求。因为
    API 是建立在 HTTP 协议之上的，我们可以执行 HTTP 方法来对 API 端点采取行动。这些操作可以是创建、读取、更新或删除，通常用缩写 *CRUD*
    表示。然而，SWAPI 的目的是向 API 发送请求并“GET”回一些数据。因此，在请求字段中，输入 `people/1/`，下面你应该能看到结果，如图 1.6
    所示。
- en: '![](../../OEBPS/Images/01-06.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-06.png)'
- en: Figure 1.6 The SWAPI website allows you to access objects the same way that
    Kubernetes does.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 SWAPI 网站允许你以与 Kubernetes 相同的方式访问对象。
- en: The result is `"Luke Skywalker"`, but the result doesn’t really matter; the
    point is that you just received data (in JSON format) from the API. The data that
    you received is the resource URI we’ve been talking about. The object located
    at that URI was `"Luke Skywalker"`, and that object contains data such as height,
    hair color, eye color, etc. Relating this to Kubernetes, the `people` object in
    SWAPI is much like the Deployment object in Kubernetes. And you can similarly
    access the Kubernetes API. The Kubernetes Dashboard even offers the API rendered
    through a browser, just like SWAPI. Figure 1.7 shows some Kubernetes resource
    URIs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `"Luke Skywalker"`，但结果本身并不重要；重要的是你刚刚从 API 接收到了数据（以 JSON 格式）。你接收到的数据是我们一直在谈论的资源
    URI。位于该 URI 的对象是 `"Luke Skywalker"`，该对象包含诸如身高、发色、眼色等数据。将此与 Kubernetes 相关联，SWAPI
    中的 `people` 对象与 Kubernetes 中的 Deployment 对象非常相似。你可以类似地访问 Kubernetes API。Kubernetes
    Dashboard 甚至通过浏览器提供 API 的渲染，就像 SWAPI 一样。图 1.7 显示了一些 Kubernetes 资源 URI。
- en: '![](../../OEBPS/Images/01-07.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-07.png)'
- en: Figure 1.7 Objects in Kubernetes accessed according to their resource URI. Nodes,
    for example, are located in `/apis/apps/v1/nodes`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 根据资源 URI 访问 Kubernetes 中的对象。例如，节点位于 `/apis/apps/v1/nodes`。
- en: There are different API calls (called *HTTP* *methods*) that perform certain
    actions against the API (given you have already authenticated to the API). They
    are `GET`, `POST`, `PATCH`, `PUT`, and `DELETE`. A `GET` HTTP method is exactly
    what we’ve been doing with the SWAPI, which is to retrieve or view information
    about the resources in our API. A `POST` HTTP method is used to create a new resource
    in the API. A `PATCH` HTTP method is used to update existing resources, and a
    `PUT` HTTP method is used to replace existing resources in the API. Finally, a
    `DELETE` HTTP method is used to delete a resource from the API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的 API 调用（称为 *HTTP* *方法*）对 API 执行某些操作（假设你已经对 API 进行了认证）。它们是 `GET`、`POST`、`PATCH`、`PUT`
    和 `DELETE`。`GET` HTTP 方法正是我们一直在 SWAPI 中所做的那样，即检索或查看我们 API 中资源的有关信息。`POST` HTTP
    方法用于在 API 中创建新的资源。`PATCH` HTTP 方法用于更新现有资源，而 `PUT` HTTP 方法用于替换 API 中的现有资源。最后，`DELETE`
    HTTP 方法用于从 API 中删除资源。
- en: 1.3.3 Services and networking
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 服务和网络
- en: To have the end user interact with your application running on Kubernetes, we
    create an object called a *Service*. These Services provide a load-balancing feature
    to the Pods they serve. They also provide a single IP address and DNS name, which
    we’ll review in later chapters. Speaking of DNS, there’s a component in Kubernetes
    called CoreDNS that provides names for IP translations. This means that resources
    in Kubernetes can talk to each other using common names as opposed to IP addresses.
    The three types of Services are ClusterIP, NodePort, and LoadBalancer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要让最终用户与运行在 Kubernetes 上的应用程序交互，我们创建了一个名为 *Service* 的对象。这些服务为它们所服务的 Pods 提供负载均衡功能。它们还提供了一个单一的
    IP 地址和 DNS 名称，我们将在后面的章节中回顾。说到 DNS，Kubernetes 中有一个名为 CoreDNS 的组件，它提供 IP 地址的名称。这意味着
    Kubernetes 中的资源可以使用通用名称而不是 IP 地址相互通信。三种类型的服务是 ClusterIP、NodePort 和 LoadBalancer。
- en: An Ingress resource is another Kubernetes object that provides path-based routing
    to a Service in Kubernetes. For example, you would create an Ingress resource
    to offer a layer-7 (application layer) route to a Service based on a URL path.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 资源是 Kubernetes 中的另一个对象，它提供了基于路径的路由到 Kubernetes 中的服务。例如，你会创建一个 Ingress
    资源，根据 URL 路径提供一个基于 7 层（应用层）的路由到服务。
- en: 1.3.4 Storage
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4 存储
- en: While managing ephemeral objects such as Pods in Kubernetes, you can’t rely
    on storage to be tied to a single Pod. Storage is the data that an application
    uses to store and organize files in a filesystem such as NTFS, XFS, or ext4\.
    A filesystem is the act of the organization of storage that takes place in an
    operating system such as Linux. In Kubernetes, there’s a concept of persistent
    volumes that aren’t tied to an individual Pod but instead to an NFS, EFS, or iSCSI
    volume. Having the storage decoupled from the ephemeral applications creates that
    persistence of data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理 Kubernetes 中的短暂对象，如 Pods 时，你不能依赖于存储与单个 Pod 相关联。存储是应用程序用于在文件系统（如 NTFS、XFS
    或 ext4）中存储和组织文件的数据。文件系统是在操作系统（如 Linux）中发生的存储组织行为。在 Kubernetes 中，有一个持久卷的概念，它不与单个
    Pod 相关联，而是与 NFS、EFS 或 iSCSI 卷相关联。将存储与短暂的应用程序解耦，可以创建数据的持久性。
- en: In addition, from a developer’s perspective, you no longer have to manage the
    underlying storage. To Kubernetes, it seems like just one large storage layer.
    The developer can utilize an object called a *persistent volume claim* to reserve
    a persistent volume, so it cannot be used for other applications running in Kubernetes.
    This still requires the persistent volume to exist, so in the case that it doesn’t,
    the developer may access storage dynamically using an object called *storage class*.
    Storage class pertains to the different classes that volumes come in—for example,
    slow versus fast.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从开发者的角度来看，你不再需要管理底层存储。对Kubernetes来说，它似乎只是一个大型的存储层。开发者可以使用一个名为*persistent
    volume claim*的对象来预留持久卷，这样它就不能被Kubernetes中运行的其他应用程序使用。但这仍然需要持久卷存在，所以如果它不存在，开发者可以使用名为*storage
    class*的对象动态访问存储。存储类与卷的不同类别有关——例如，慢速与快速。
- en: Volumes can also be used by multiple Pods at the same time as well as reused,
    specifying certain access modes and certain reclaim policies, respectively. The
    access modes allow the read and write capability of a volume to one or many Pods.
    The reclaim policy will allow or deny access from other Pods in a Kubernetes cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 卷也可以由多个Pod同时使用，并且可以重用，分别指定某些访问模式和某些回收策略。访问模式允许一个或多个Pod读取和写入卷的能力。回收策略将允许或拒绝来自Kubernetes集群中其他Pod的访问。
- en: 1.3.5 Troubleshooting
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.5 故障排除
- en: Kubernetes clusters aren’t perfect; they can become quite complex the more resources
    and objects are created in them. Troubleshooting when problems arise is essential
    to limit the downtime of running applications and also to detect problems to optimize
    and have Kubernetes performing at its best. Being able to decipher logs from a
    running container, analyze failures, and propose a solution to that failure is
    key to becoming a great Kubernetes administrator. Logs are time-based behavioral
    data sent via text to a directory on the filesystem to give you verbose information
    about a problem that’s occurring. All the redundancy in the world will not fix
    a cluster that has been poorly constructed and not well maintained.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群并不完美；随着在集群中创建的资源和对象越来越多，它们可能会变得相当复杂。当出现问题时进行故障排除对于限制运行应用程序的停机时间以及检测问题以优化和使Kubernetes表现最佳至关重要。能够解析运行容器的日志、分析故障并提出解决方案是成为一名优秀的Kubernetes管理员的关键。日志是基于时间的基于文本的行为数据，发送到文件系统上的一个目录，以提供有关正在发生的问题的详细信息。世界上所有的冗余都无法修复一个构建不良且维护不善的集群。
- en: Applications running on Kubernetes also have an added maintenance responsibility.
    They contain logs from stdout and stderr that are important for detecting when
    communication problems arise or application failure is imminent.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行的应用程序也增加了维护责任。它们包含来自stdout和stderr的日志，这对于检测通信问题何时出现或应用程序即将失败至关重要。
- en: 1.4 Control plane node
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 控制平面节点
- en: 'The Services and components on the control plane that make it the control plane
    are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使其成为控制平面的服务和组件如下：
- en: Controller manager
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: API server
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器
- en: Scheduler
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: etcd datastore
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd数据存储
- en: The controller manager is a control loop, responsible for matching the current
    state to the desired state. For example, the controller manager will automatically
    scale a Deployment if the Pods do not match the desired number of replicas. The
    controller manager also creates the default accounts and API access tokens for
    new namespaces. That’s why you’ll see when we create a Kubernetes cluster in the
    next chapter that there’s a default namespace, Service Account, and secret already
    created for you to start deploying your resources (applications) into. This makes
    it easy to start running containerized applications on Kubernetes right away.
    When referring to a namespace, think of it as a dedicated virtual environment
    for your Kubernetes resources. The default namespace will be isolated within the
    scope of that namespace and can have its own grouping of Kubernetes resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器是一个控制循环，负责将当前状态与期望状态相匹配。例如，如果Pods的数量不匹配期望的副本数，控制器管理器将自动扩展Deployment。控制器管理器还会为新命名空间创建默认账户和API访问令牌。这就是为什么在下一章中创建Kubernetes集群时，你会看到已经为你创建了一个默认命名空间、服务账户和密钥，以便你可以开始部署你的资源（应用程序）。这使得立即在Kubernetes上运行容器化应用程序变得容易。当提到命名空间时，可以将其视为一个专门为你的Kubernetes资源设置的虚拟环境。默认命名空间将在这个命名空间的范围内进行隔离，并且可以有自己的Kubernetes资源分组。
- en: 'The API server is exactly what it sounds like: it’s the component that exposes
    the Kubernetes API (the RESTful API that we talked about earlier). It’s the entry
    point for the cluster, so all communication to the cluster passes through it to
    access the cluster components. Think of it like a gate that will open only if
    opened with the right key using authentication, as in figure 1.8\. We’ll talk
    more about authentication in chapter 3.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器正如其名：它是暴露Kubernetes API（我们之前提到的RESTful API）的组件。它是集群的入口点，因此所有通往集群的通信都通过它来访问集群组件。想象一下，它就像一个只有用正确的密钥通过认证才能打开的大门，就像图1.8中所示。我们将在第3章中更多地讨论认证。
- en: '![](../../OEBPS/Images/01-08.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8](../../OEBPS/Images/01-08.png)'
- en: Figure 1.8 To access the Kubernetes API, you use a key to authenticate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 要访问Kubernetes API，你需要使用密钥进行认证。
- en: The scheduler is the component that selects the nodes on which the Pods run.
    You will probably hear the word *scheduling* a lot throughout this book, so from
    here on when I say “scheduling,” it just means that the Pods are being placed
    (scheduled) on the nodes for running them. If multiple nodes already have Pods
    running on them, then the scheduler is going to place the Pods on a different
    node, taking into consideration the available resources and other rules/specifications
    that have been placed on that node.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器是选择Pod运行节点的组件。你可能会在这本书中多次听到“调度”这个词，所以从现在开始，当我提到“调度”时，它仅仅意味着Pod正在被放置（调度）到节点上以运行。如果多个节点已经运行了Pod，那么调度器将会将Pod放置到不同的节点上，同时考虑可用的资源以及已经放置在该节点上的其他规则/规范。
- en: 'There are certain Services (called *daemons*) that run on the control plane
    and are critical for the Kubernetes cluster to operate. They are so critical,
    in fact, that in a production scenario, they are replicated for high availability.
    Replicating the control plane components is beyond the scope of this book and
    the exam because the Kubernetes clusters on the exam are not going to have more
    than one control plane node. In general, replicating the control plane works by
    performing two functions. First, replication ensures that the control plane components
    have only one instance-receiving request at a time. This is achieved by electing
    a leader. The leader will act as the primary control plane and relay its status
    to the other followers. Second, because the control plane relies on etcd for storing
    all the Kubernetes configuration data (the state of resources and how they are
    running in Kubernetes), you’ll create multiple redundant copies of etcd. If you
    want to learn more about replicating the control plane for high availability in
    Kubernetes, you can read more here: [http://mng.bz/5wz7](http://mng.bz/5wz7).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些服务（称为*守护进程*）运行在控制平面，对于Kubernetes集群的运行至关重要。实际上，它们是如此关键，以至于在生产场景中，它们会被复制以实现高可用性。复制控制平面组件超出了本书和考试的范畴，因为考试中的Kubernetes集群不会超过一个控制平面节点。一般来说，复制控制平面是通过执行两个功能来实现的。首先，复制确保控制平面组件一次只有一个实例接收请求。这是通过选举一个领导者来实现的。领导者将充当主控制平面，并将其状态传递给其他追随者。其次，因为控制平面依赖于etcd来存储所有的Kubernetes配置数据（资源的状态以及它们在Kubernetes中的运行方式），所以你会创建多个冗余的etcd副本。如果你想了解更多关于在Kubernetes中实现高可用性的控制平面复制，你可以在这里阅读更多：[http://mng.bz/5wz7](http://mng.bz/5wz7)。
- en: The etcd datastore is one of those critical control plane components we addressed
    earlier. Etcd stores all the Kubernetes configuration data (the state of Kubernetes).
    Etcd is a consistent, distributed key-value store designed to hold small amounts
    of data that can fit entirely in memory. This is important because data can be
    retrieved more quickly than other traditional databases (see figure 1.9). The
    most important thing to remember about the etcd datastore is that losing it (etcd
    failure) is catastrophic, as it contains all the configuration information for
    resources running inside a Kubernetes cluster, so making sure it’s backed up is
    extremely important. You may come across questions on the exam about backing up
    etcd, so we’ll cover how to do this in the next chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: etcd数据存储是我们之前提到的那些关键控制平面组件之一。Etcd存储了所有的Kubernetes配置数据（Kubernetes的状态）。Etcd是一个一致性的、分布式的键值存储，旨在存储可以完全放入内存中的少量数据。这很重要，因为数据可以比其他传统数据库更快地检索（见图1.9）。关于etcd数据存储，最重要的是记住，丢失它（etcd故障）是灾难性的，因为它包含了运行在Kubernetes集群内部的所有资源的配置信息，所以确保它被备份是极其重要的。你可能会在考试中遇到有关备份etcd的问题，所以我们将在下一章中介绍如何进行备份。
- en: '![](../../OEBPS/Images/01-09.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9](../../OEBPS/Images/01-09.png)'
- en: Figure 1.9 The etcd datastore resides in a Kubernetes Pod on the control plane
    node.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 etcd数据存储位于控制平面节点上的Kubernetes Pod中。
- en: 1.5 Worker nodes
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 工作节点
- en: 'Now that we’ve talked about the control plane components in great detail, let’s
    review the components that reside on a worker node, as shown in figure 1.10\.
    The components that run on a worker node are different from the components on
    the control plane because the worker nodes play a different role in the Kubernetes
    landscape. You will most certainly have more than one node inside of a Kubernetes
    cluster, and each one of the following components is installed on each node:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经详细讨论了控制平面组件，现在让我们回顾一下位于工作节点上的组件，如图1.10所示。运行在工作节点上的组件与控制平面上的组件不同，因为工作节点在Kubernetes环境中扮演着不同的角色。您在Kubernetes集群中肯定会有不止一个节点，以下每个组件都会安装在每个节点上：
- en: The kubelet
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubelet
- en: kube-proxy
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-proxy
- en: The container runtime
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: '![](../../OEBPS/Images/01-10.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-10.png)'
- en: Figure 1.10 The role of the worker node is to run the application workloads.
    It also contains kubelet, kube-proxy, and the container runtime (e.g., containerd).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 工作节点的角色是运行应用程序工作负载。它还包含kubelet、kube-proxy和容器运行时（例如，containerd）。
- en: 'The kubelet service that runs on each worker node makes sure that containers
    are running in a Pod. However, although it’s not aware of containers that aren’t
    managed by the scheduler, kubelet can detect when a container (within a Pod) is
    failing and take corrective action to ensure that the container restarts in the
    way that is specified in the YAML manifest, the set of instructions for configuring
    a Pod in YAML (YAML isn’t markup language) format. It’s like a set of declarative
    instructions (with the end state in mind) for the kubelet to follow to maintain
    high availability for the application running on Kubernetes. If the kubelet can’t
    make the container run, it will report the status of the Pod and container to
    the Kubernetes API server, and you can see it in the Pod events by performing
    the command `kubectl describe po nginx` (nginx is the name of the Pod). A similar
    output is shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在每个工作节点上的kubelet服务确保容器在Pod中运行。然而，尽管它不知道由调度器未管理的容器，kubelet可以检测到容器（在Pod内）失败的情况，并采取纠正措施以确保容器以YAML清单中指定的方式重启，YAML清单是一组用于配置Pod的YAML（YAML不是标记语言）格式的指令。它就像是一组声明性指令（考虑到最终状态），供kubelet遵循以保持运行在Kubernetes上的应用程序的高可用性。如果kubelet无法使容器运行，它将向Kubernetes
    API服务器报告Pod和容器的状态，您可以通过执行命令`kubectl describe po nginx`（nginx是Pod的名称）在Pod事件中看到它。这里显示了类似的输出：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you look at the events after describing the Pod, you see that there are
    different states of a container (shown as the status), including waiting, running,
    and terminated. You will also see the state of the container by running the command
    `kubectl get po`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您描述Pod后查看事件时，您会看到容器（显示为状态）的不同状态，包括等待、运行和终止。您还可以通过运行命令`kubectl get po`来查看容器的状态。
- en: 'The kube-proxy Service running on each worker node is the communication mechanism
    of a Kubernetes Service. A Service is another resource type in Kubernetes and
    is responsible for allocating traffic to the various Pods within that Service.
    We’ll review Services in depth in chapter 6\. These are basic network rules for
    the node to follow if traffic needs to get to the Pods in Kubernetes. There’s
    a fascinating video that describes this in greater detail called “Life of a Packet.”
    I highly encourage you to watch it here: [https://youtu.be/0Omvgd7Hg1I](https://youtu.be/0Omvgd7Hg1I).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在每个工作节点上的kube-proxy服务是Kubernetes服务的通信机制。服务是Kubernetes中的另一种资源类型，负责将流量分配给该服务内的各个Pod。我们将在第6章中深入探讨服务。这些是节点在需要将流量发送到Kubernetes中的Pod时需要遵循的基本网络规则。有一个非常有趣的视频详细描述了这一点，名为“数据包的一生”。我强烈建议您在这里观看：[https://youtu.be/0Omvgd7Hg1I](https://youtu.be/0Omvgd7Hg1I)。
- en: Finally, running on each node in the Kubernetes cluster is the container runtime.
    This is a necessary component for Kubernetes to work, as it is the engine that
    runs the containers themselves. Interestingly, though, it is an external dependency,
    meaning that it’s one of the only components necessary to a Kubernetes cluster
    that Kubernetes doesn’t apply or install itself. This means that you have choices
    when it comes to container engines that you have to install. Kubernetes supports
    any container runtime time that follows the CRI requirements ([http://mng.bz/6D0R](http://mng.bz/6D0R)).
    The common options are either Docker ([https://docs.docker.com/engine/](https://docs.docker.com/engine/)),
    containerd ([https://containerd.io/docs/](https://containerd.io/docs/)), or CRI-O
    ([https://cri-o.io/#what-is-cri-o](https://cri-o.io/#what-is-cri-o)). Chances
    are you’ve heard of Docker, but did you know that Docker uses containerd as the
    container runtime under the hood while using a feature called dockershim to get
    to containerd? Docker is also not CRI compliant ([http://mng.bz/o1nD](http://mng.bz/o1nD)).
    So, containerd, implied by the last sentence, is the stripped-down (so it’s lightweight
    and portable) container runtime that is also CRI compliant. CRI-O is another lightweight
    container runtime that supports the open container initiative (OCI). So, it’s
    a community-driven, open source project that supports multiple image formats,
    including Docker images.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每个 Kubernetes 节点上运行的是容器运行时。这是 Kubernetes 运作所必需的组件，因为它是运行容器的引擎。有趣的是，它是一个外部依赖项，这意味着它是
    Kubernetes 集群中唯一需要 Kubernetes 本身不应用或安装的组件之一。这意味着在安装容器引擎时，你有选择权。Kubernetes 支持任何符合
    CRI 要求的容器运行时 ([http://mng.bz/6D0R](http://mng.bz/6D0R))。常见的选项包括 Docker ([https://docs.docker.com/engine/](https://docs.docker.com/engine/))、containerd
    ([https://containerd.io/docs/](https://containerd.io/docs/)) 或 CRI-O ([https://cri-o.io/#what-is-cri-o](https://cri-o.io/#what-is-cri-o))。你可能听说过
    Docker，但你是否知道 Docker 在底层使用 containerd 作为容器运行时，同时使用名为 dockershim 的功能来访问 containerd？Docker
    也不符合 CRI 标准 ([http://mng.bz/o1nD](http://mng.bz/o1nD))。因此，最后一句中隐含的 containerd
    是一个精简版（因此它轻量级且便携）的容器运行时，同时也符合 CRI 标准。CRI-O 是另一个轻量级容器运行时，支持开放容器倡议 (OCI)。因此，它是一个由社区驱动的开源项目，支持多种镜像格式，包括
    Docker 镜像。
- en: 1.6 API model and PKI
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 API 模型和 PKI
- en: We’ll talk more about RBAC and identity management in Kubernetes in chapter
    3, but for now, let’s just talk about the public key infrastructure that comprises
    the client-to-server relationship in Kubernetes. As we have seen, to manipulate
    objects in Kubernetes, we need two things. The first is the command-line tool
    `kubectl`. The second is a client certificate, as you can see in figure 1.11.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 3 章中更详细地讨论 Kubernetes 中的 RBAC 和身份管理，但到目前为止，让我们先谈谈构成 Kubernetes 中客户端到服务器关系的公共密钥基础设施。正如我们所见，要操作
    Kubernetes 中的对象，我们需要两样东西。第一样是命令行工具 `kubectl`。第二样是客户端证书，如图 1.11 所示。
- en: '![](../../OEBPS/Images/01-11.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11](../../OEBPS/Images/01-11.png)'
- en: Figure 1.11 To manipulate Kubernetes objects, we must authenticate with a client
    certificate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 要操作 Kubernetes 对象，我们必须使用客户端证书进行身份验证。
- en: Public key infrastructure (PKI) is a very common client–server communication
    pattern, and it is the usual way our computers securely communicate with websites
    via web servers. At a high level, PKI enables secure communication over the web
    by ensuring that the website you’re visiting is the website that you intended
    to visit (via cryptographic signature). This ensures that you’re visiting the
    right website (not an imposter’s website), but also ensures that nobody is snooping
    or intercepting the traffic back and forth. If you think about accessing your
    bank over the web, this PKI infrastructure is critical to ensuring that bank accounts
    are safe, that the people accessing them are indeed the owners of the accounts,
    and that the bank you are accessing is indeed the correct bank.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 公共密钥基础设施 (PKI) 是一种非常常见的客户端-服务器通信模式，并且是我们计算机通过 Web 服务器安全地与网站通信的通常方式。从高层次来看，PKI
    通过确保你访问的网站是你打算访问的网站（通过加密签名）来启用 Web 上的安全通信。这确保了你访问的是正确的网站（而不是冒名顶替者的网站），同时也确保没有人正在窃听或拦截往返的流量。如果你考虑通过
    Web 访问你的银行，这个 PKI 基础设施对于确保银行账户安全、访问它们的人确实是账户的所有者以及你访问的是正确的银行至关重要。
- en: The fundamental pieces of the PKI include three elements, which are shown in
    figure 1.12\. First and foremost is the certificate authority (CA). The CA is
    the source of truth and signs the server certificate (in the case of one used
    with the API), and subsequently, the client can determine if the server is valid.
    On the web, for example, the common certificate authorities are DigiCert, Symantec,
    and Thawte and are already trusted by the browser (the client) as a way for your
    browser to quickly verify a website’s identity (e.g., whether google.com is actually
    Google). The second and third pieces of the PKI puzzle are the server and client,
    both relying on the CA—the client trying to verify the identity of the server,
    and the server trying to authenticate and prove to the CA that they are who they
    say they are. Just like the PKI for the web, the same PKI model is applied to
    Kubernetes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PKI的基本组成部分包括三个元素，如图1.12所示。首先是证书颁发机构（CA）。CA是真相来源，并签署服务器证书（在用于API的情况下），随后客户端可以确定服务器是否有效。例如，在互联网上，常见的证书颁发机构有DigiCert、Symantec和Thawte，并且浏览器（客户端）已经信任它们作为浏览器快速验证网站身份的方式（例如，是否google.com确实是谷歌）。PKI拼图的第二和第三部分是服务器和客户端，它们都依赖于CA——客户端试图验证服务器的身份，服务器则试图向CA进行身份验证并证明它们就是他们所说的那样。就像互联网的PKI一样，相同的PKI模型也应用于Kubernetes。
- en: '![](../../OEBPS/Images/01-12.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12](../../OEBPS/Images/01-12.png)'
- en: Figure 1.12 The control plane node serves as the certificate authority (CA),
    which signs the certificate and provides authentication to client and server communication.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 控制平面节点作为证书颁发机构（CA），它签署证书并为客户端和服务器之间的通信提供身份验证。
- en: Taking the same three pieces of the PKI puzzle and applying them to Kubernetes,
    Kubernetes is its own CA and will be the source of truth for the other components
    within a Kubernetes cluster. The clients in Kubernetes (the ones checking whether
    the servers are who they say they are) are the kubelet, the scheduler, the controller
    manager, and the etcd datastore. The same Kubernetes component can be a client
    and a server at the same time. The servers in Kubernetes (the ones trying to prove
    their identity to the CA) are the kubelet, the Kubernetes API, and the etcd datastore
    (see figure 1.13).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将PKI拼图的三块相同的拼图应用到Kubernetes中，Kubernetes是其自己的CA，并将成为Kubernetes集群内其他组件的真相来源。Kubernetes中的客户端（检查服务器是否为它们所声称的身份的客户端）包括kubelet、调度器、控制器管理器和etcd数据存储。同一个Kubernetes组件可以同时作为客户端和服务器。Kubernetes中的服务器（试图向CA证明其身份的客户端）包括kubelet、Kubernetes
    API和etcd数据存储（见图1.13）。
- en: '![](../../OEBPS/Images/01-13.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13](../../OEBPS/Images/01-13.png)'
- en: Figure 1.13 The Kubernetes API has multiple responsibilities in the PKI infrastructure
    of both client and server. The CA is generating certificates, and servers are
    proving their identity ([http://mng.bz/mV68](http://mng.bz/mV68)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 Kubernetes API在PKI基础设施中既作为客户端又作为服务器承担多个职责。CA生成证书，服务器则试图证明其身份（[http://mng.bz/mV68](http://mng.bz/mV68)）。
- en: Luckily, you don’t have to worry about creating a CA, client, or server certificate.
    Kubeadm will do all of this for you. Kubeadm is another command-line tool like
    `kubectl`, but its purpose is for creating the necessary components that make
    up our Kubernetes cluster (including the CA and other certificates); sometimes
    we call this *bootstrapping the cluster*. We’ll talk more about kubeadm and the
    location of all of these certificates in chapter 3.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必担心创建CA、客户端或服务器证书。Kubeadm会为你完成所有这些工作。Kubeadm是一个类似于`kubectl`的命令行工具，但其目的是创建构成我们Kubernetes集群所需的所有组件（包括CA和其他证书）；有时我们称之为*引导集群*。我们将在第3章中更多地讨论kubeadm以及所有这些证书的位置。
- en: 1.7 Linux system services
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 Linux系统服务
- en: With all this talk about Services and components to both the control plane and
    the worker nodes, I thought it pertinent to mention Linux system services. Linux
    system services are a grouping of files on the Linux operating system that provides
    a software program that constantly runs in the background. If you remember, I
    referred to certain services that run on the control plane as daemons. Daemons
    have been used in the Linux world for ages, not to be confused with a DaemonSet
    in Kubernetes, which makes sure the daemon is running on each node as a Pod in
    the Kubernetes cluster at all times, as shown in figure 1.14\. If you are more
    familiar with Windows computers, this same concept is called a *service*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于服务和控制平面以及工作节点组件的讨论中，我认为提及Linux系统服务是恰当的。Linux系统服务是在Linux操作系统上的一组文件，它提供了一个在后台持续运行的软件程序。如果你还记得，我提到过在控制平面运行的一些服务被称为守护进程。在Linux世界中，守护进程已经使用了很长时间，不要与Kubernetes中的DaemonSet混淆，它确保守护进程作为Kubernetes集群中的Pod在所有时间运行，如图1.14所示。如果你更熟悉Windows计算机，这个相同的概念被称为*服务*。
- en: '![](../../OEBPS/Images/01-14.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14](../../OEBPS/Images/01-14.png)'
- en: Figure 1.14 DaemonSets ensure that a single Pod is running on each node in the
    cluster. kube-proxy and CNI both run as DaemonSets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14. DaemonSets确保集群中的每个节点上运行一个Pod。kube-proxy和CNI都作为DaemonSets运行。
- en: For that matter, the control plane components that we spoke about earlier are
    a good example of that. You can have a DaemonSet running on each node that provides
    the kube-proxy component, for example. See for yourself by running the command
    `kubectl get ds -A`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，我们之前提到的控制平面组件是一个很好的例子。你可以在每个节点上运行一个DaemonSet，提供kube-proxy组件，例如。通过运行命令`kubectl
    get ds -A`来亲自看看。
- en: '[PRE1]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is one service, however, that you don’t want Kubernetes to manage (as
    a DaemonSet), and that is kubelet. kubelet is one of the only services in the
    context of Kubernetes that will be located on the Linux system itself (as a Linux
    system service). You must know this for the exam. Why? Because the Linux service
    may be down, presenting a scenario on the exam for you to repair it. Knowledge
    about where this service is and how to repair it will come in handy. To see a
    list of all services on your Linux system, type the command `sudo systemctl list-unit-files
    --type service --all | grep kubelet -a6`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个服务你不想让Kubernetes管理（作为一个DaemonSet），那就是kubelet。kubelet是在Kubernetes环境中唯一位于Linux系统本身（作为一个Linux系统服务）的服务之一。你必须知道这一点，因为考试可能会让你修复它。了解这个服务的位置以及如何修复它将非常有用。要查看Linux系统上所有服务的列表，请输入命令`sudo
    systemctl list-unit-files --type service --all | grep kubelet -a6`。
- en: '[PRE2]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see a list of services that will show the unit file (the service name)
    and the state of the service (enabled/disabled/masked/static). In this list, you
    will see `kubelet.service` as one of these. Once you’ve identified that the kubelet
    service is running on your system, you can do one of three things. If it has stopped,
    you can start it by typing `systemctl start kubelet`. If you notice that the service
    does not start when the node is rebooted, then you can enable it with the command
    `systemctl enable kubelet` so that it automatically starts up when the node starts
    up (or restarts). Finally, if you simply want to check the status of the service
    to see if it’s active or inactive, you can run the command `systemctl status kubelet`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个显示单元文件（服务名称）和服务状态（启用/禁用/掩码/静态）的服务列表。在这个列表中，你会看到`kubelet.service`作为其中之一。一旦你确定kubelet服务在你的系统上正在运行，你可以做三件事情之一。如果它已经停止，你可以通过输入`systemctl
    start kubelet`来启动它。如果你注意到当节点重启时服务没有启动，那么你可以使用命令`systemctl enable kubelet`来启用它，这样当节点启动（或重启）时它会自动启动。最后，如果你只是想检查服务状态以查看它是活动状态还是非活动状态，你可以运行命令`systemctl
    status kubelet`。
- en: 'Within the list of services, you may have noticed the `systemd.journald` service.
    If you didn’t, go ahead and run the following command to show it: `sudo systemctl
    list-unit-files --type service --all | grep journald.service`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务列表中，你可能已经注意到了`systemd.journald`服务。如果没有注意到，可以运行以下命令来显示它：`sudo systemctl list-unit-files
    --type service --all | grep journald.service`。
- en: '[PRE3]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Journald (another Linux system service) is used to collect logs about the kubelet
    service on each node. Journalctl is a command-line utility for viewing logs on
    a Linux system collected by systemd, which is the primary daemon in Linux that
    controls all processes. This logging mechanism can prove very useful during the
    exam. You may find yourself digging through the logs to find out why the kubelet
    service is failing, for example. Use the commands `sudo journalctl -u kubelet`
    and `sudo journalctl -u containerd` as a reference.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Journald（另一个Linux系统服务）用于收集每个节点上kubelet服务的日志。Journalctl是一个命令行工具，用于查看由systemd收集的Linux系统日志，systemd是Linux中控制所有进程的主要守护进程。这种日志机制在考试期间可能非常有用。例如，你可能会发现自己正在挖掘日志以找出kubelet服务失败的原因。可以使用命令`sudo
    journalctl -u kubelet`和`sudo journalctl -u containerd`作为参考。
- en: You can check the `/var/log/pods` directory for Pod logs; however, you can also
    retrieve these in the exact same fashion with the `kubectl logs` command (e.g.,
    `kubectl logs kube-controller-manager-server1 -n kube-system`). More on troubleshooting
    and collecting these logs in chapter 8\. For now, just know that these Linux system
    services are important for collecting valuable information about Kubernetes and
    that some services exist on the Linux system (the node) and some Services exist
    within the confines of Kubernetes (in a Pod).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`/var/log/pods`目录中检查Pod日志；然而，你也可以使用`kubectl logs`命令以完全相同的方式检索这些日志（例如，`kubectl
    logs kube-controller-manager-server1 -n kube-system`）。关于故障排除和收集这些日志的更多内容，请参阅第8章。现在，只需知道这些Linux系统服务对于收集有关Kubernetes的有价值信息非常重要，并且一些服务存在于Linux系统（节点）上，而一些服务存在于Kubernetes（Pod）的范围内。
- en: 1.8 Declarative syntax
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 声明式语法
- en: Now that you have a good idea of the composition of a Kubernetes cluster and
    its underlying Services, I would be remiss not to mention the primary purpose
    of Kubernetes, which is to run applications. Yes, once you have the foundation
    (which we’ve talked about thus far in this chapter) of your control plane components,
    worker node components, and Linux system services, and the cluster is functioning
    as a loosely coupled unit (remember the API model?), it’s time to run your applications.
    After all, this is the primary function and the reason why we’re using Kubernetes
    in the first place. As far as running these applications on Kubernetes, you can
    run a Java application on Kubernetes, just the same as a .NET application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地了解了Kubernetes集群及其底层服务的组成，我不得不提一下Kubernetes的主要目的，那就是运行应用程序。是的，一旦你有了控制平面组件（我们在此章中已经讨论过）、工作节点组件和Linux系统服务的基石，并且集群作为一个松散耦合的单元运行（记得API模型吗？），那么就是时候运行你的应用程序了。毕竟，这是主要功能，也是我们最初使用Kubernetes的原因。至于在Kubernetes上运行这些应用程序，你可以在Kubernetes上运行Java应用程序，就像.NET应用程序一样。
- en: '![](../../OEBPS/Images/01-15.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-15.png)'
- en: Figure 1.15 In a true microservices architecture, each microservice is decoupled
    from other services; therefore, it can be built in the language that suits the
    service best.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 在真正的微服务架构中，每个微服务都与其他服务解耦；因此，它可以以最适合该服务的语言构建。
- en: Kubernetes doesn’t care at all about the language or about how the application
    runs, as depicted in figure 1.15\. It will run your containers the same way in
    every instance and does so by keeping that same foundational benefit to containers,
    which inherently run the same way on every machine because the application binaries
    and libraries are packaged up along with the container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes根本不在乎语言或应用程序的运行方式，如图1.15所示。它将以相同的方式在每次实例中运行你的容器，并且通过保持相同的容器基础优势来实现这一点，因为应用程序的二进制文件和库与容器一起打包，并且因为应用程序在每台机器上以相同的方式运行。
- en: 'So, if Kubernetes doesn’t care about the language or the framework of the application,
    how are applications deployed on Kubernetes? This brings us to a very important
    word in DevOps and cloud native—*declarative*. You will find that building applications
    on Kubernetes in a declarative way is far better than imperative. Why? Imperative
    is nothing more than running a series of commands in a specific sequence. This
    makes it hard to track these commands and detect if a command failed during the
    execution of those imperative commands in sequential order. Declarative is more
    descriptive and succinct and has the following major benefits:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 Kubernetes 不关心应用程序的语言或框架，那么应用程序是如何在 Kubernetes 上部署的呢？这引出了 DevOps 和云原生中的一个非常重要的词——*声明式*。你会发现，以声明式方式在
    Kubernetes 上构建应用程序要比命令式方式好得多。为什么？命令式方式不过是按照特定顺序运行一系列命令。这使得跟踪这些命令和在执行这些命令的顺序中检测命令失败变得很困难。声明式方式更加描述性和简洁，具有以下主要优势：
- en: Describing your configuration via YAML file, which can be checked into version
    control
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 YAML 文件描述你的配置，该文件可以提交到版本控制
- en: Building with the end state in mind, without considering order or specific commands
    to run
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以最终状态为目标构建，不考虑顺序或特定的运行命令
- en: Having the efficiency and speed to get up and running through parallel actions
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过并行操作获得高效和快速启动的能力
- en: 'YAML is a human-readable language, also rendered for machines, so creating
    this configuration file is fairly simple. Most resources follow the same pattern
    and structure for YAML and how it’s made. Here’s an example of a file named `my-pod-manifest.yaml`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是一种人类可读的语言，同时也适用于机器，因此创建这种配置文件相对简单。大多数资源都遵循 YAML 的相同模式和结构。以下是一个名为 `my-pod-manifest.yaml`
    的文件示例：
- en: '[PRE4]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These YAML files (called *manifests*) can be referred to years later, which
    is a good form of documenting how the application was built. Checking it into
    version control will allow you to track changes and work in teams to develop and
    enhance the configuration over time. You have the freedom to build applications
    running on Kubernetes with the end in mind. This is called *goal seeking*. You
    don’t have to be concerned about the path to reach that end state; you simply
    submit the YAML file to the Kubernetes API, and the API chooses the best path
    to complete your build.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 YAML 文件（称为 *manifests*）可以在多年后引用，这是记录应用程序构建过程的一种良好形式。将其提交到版本控制将允许你跟踪更改，并在团队中共同开发并随着时间的推移改进配置。你可以自由地构建以
    Kubernetes 运行的应用程序，并着眼于最终目标。这被称为 *目标寻求*。你不必担心达到最终状态的道路；你只需将 YAML 文件提交给 Kubernetes
    API，API 就会选择最佳路径来完成构建。
- en: 'Interestingly enough, submitting your file to the API is the same as performing
    a `POST` request to the API. Because everything running in your cluster is visible
    to the API, actions can be processed in parallel and will reach your end state
    faster. Here’s an example of running an imperative command (using `kubectl`) to
    create a Pod via the YAML file declaratively:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，将你的文件提交给 API 与执行一个 `POST` 请求到 API 是相同的。因为你的集群中运行的所有内容都对 API 可见，动作可以并行处理，并且会更快地达到最终状态。以下是一个使用
    `kubectl` 通过 YAML 文件声明式创建 Pod 的命令式命令示例：
- en: '[PRE5]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are three different ways you can submit this file to the Kubernetes API
    using `kubectl`—by using the command `kubectl create -f my-pod-manifest.yaml`,
    the command `kubectl apply -f my-pod-manifest.yaml`, or the command `kubectl replace
    -f manifest.yaml`. The `create` command expects that no resource has been created
    yet, and if otherwise, it will throw an error. The `apply` command, on the other
    hand, can be used to either create or update an existing resource. The `replace`
    command will delete the resource if it’s there and create an entirely new one
    as if you deleted the resource manually and then created a new one. Using the
    replace command on a Deployment, for example, will trigger a new rollout, where
    the Pods within that Deployment will be gracefully terminated and new Pod replicas
    will be spun up. We’ll talk about Deployments in more detail in chapter 4 and
    rollouts in chapter 5.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三种不同的方式将此文件提交给 Kubernetes API 使用 `kubectl`——通过使用命令 `kubectl create -f my-pod-manifest.yaml`，命令
    `kubectl apply -f my-pod-manifest.yaml`，或者命令 `kubectl replace -f manifest.yaml`。`create`
    命令期望还没有创建任何资源，如果否则，它将抛出一个错误。另一方面，`apply` 命令可以用来创建或更新现有资源。`replace` 命令如果存在将删除资源，并创建一个全新的资源，就像你手动删除资源然后创建一个新的一样。例如，在
    Deployment 上使用 `replace` 命令将触发一个新的部署，其中该 Deployment 内的 Pod 将被优雅地终止，并启动新的 Pod 副本。我们将在第
    4 章中更详细地讨论 Deployment，在第 5 章中讨论滚动更新。
- en: '*Idempotent* is another important word to remember. The benefit of working
    with the Kubernetes API is that the state of the resources within will remain
    unchanged, no matter how many times the same call is made to the API. This creates
    consistency in your environment, and you know what to expect as your infrastructure
    and applications get increasingly complex over time.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*幂等* 是另一个需要记住的重要词汇。与 Kubernetes API 一起工作的好处是，无论对 API 进行多少次相同的调用，资源的状态都将保持不变。这为您的工作环境带来了一致性，并且随着时间的推移，您的基础设施和应用变得越来越复杂，您也知道可以期待什么。'
- en: Now that we’ve talked about Kubernetes to exhaustion and discussed the complexities
    and complications that we may or may not run into, let’s dive into the next chapter
    and get more hands-on with our approach to learning Kubernetes. After all, you’ll
    have your hands on the keyboard for the exam, so why not dive into practicing
    and simulating the exam experience? Roll up your sleeves!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对 Kubernetes 讨论得淋漓尽致，并讨论了我们可能遇到或可能没有遇到的复杂性和复杂性，那么让我们深入下一章，并更深入地了解我们学习
    Kubernetes 的方法。毕竟，您将在考试中动手操作键盘，为什么不深入实践和模拟考试体验呢？卷起袖子吧！
- en: 1.9 Exam exercises
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 考试练习
- en: Perform the command to list all API resources in your Kubernetes cluster. Save
    the output to a file named `resources.csv`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行列出 Kubernetes 集群中所有 API 资源的命令。将输出保存到名为 `resources.csv` 的文件中。
- en: List the services on your Linux operating system that are associated with Kubernetes.
    Save the output to a file named `services.csv`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出与 Kubernetes 相关的 Linux 操作系统上的服务。将输出保存到名为 `services.csv` 的文件中。
- en: List the status of the kubelet service running on the Kubernetes node, output
    the result to a file named `kubelet-status.txt,` and save the file in the `/tmp`
    directory.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出在 Kubernetes 节点上运行的 kubelet 服务的状态，将结果输出到名为 `kubelet-status.txt` 的文件中，并将文件保存在
    `/tmp` 目录中。
- en: Use the declarative syntax to create a Pod from a YAML file in Kubernetes. Save
    the YAML file as `chap1-pod.yaml`. Use the `kubectl create` command to create
    the Pod.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用声明性语法从 YAML 文件创建 Kubernetes 中的 Pod。将 YAML 文件保存为 `chap1-pod.yaml`。使用 `kubectl
    create` 命令创建 Pod。
- en: Using the `kubectl` CLI tool, list all the Services created in your Kubernetes
    cluster across all namespaces. Save the output of the command to a file named
    `all-k8s-services.txt`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` CLI 工具列出您在 Kubernetes 集群中所有命名空间中创建的所有服务。将命令的输出保存到名为 `all-k8s-services.txt`
    的文件中。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you’ve met Kubernetes. You now know what Kubernetes looks
    like inside and out and what it’s commonly used for. You should also know the
    following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经认识了 Kubernetes。现在您不仅知道 Kubernetes 的内部和外部结构，还知道它通常被用于什么。您还应该了解以下内容：
- en: Kubernetes is an application that runs other applications and is built much
    like other RESTful web apps. The API is the central hub for authentication, authorization,
    and communication in the Kubernetes cluster.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 是一个运行其他应用程序的应用程序，其构建方式与其它 RESTful 网络应用程序类似。API 是 Kubernetes 集群中身份验证、授权和通信的中心枢纽。
- en: 'A cluster has many different components, including two main parts: a control
    plane, which is handled by the control plane nodes, and the worker nodes, which
    are responsible for running the workloads (i.e., the containerized applications
    running on top of Kubernetes).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群有许多不同的组件，包括两个主要部分：控制平面，由控制平面节点处理，以及工作节点，它们负责运行工作负载（即运行在 Kubernetes 之上的容器化应用程序）。
- en: Linux system services are important in Kubernetes because they are responsible
    for keeping Kubernetes running on the host itself.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Linux 系统服务很重要，因为它们负责在主机本身上保持 Kubernetes 的运行。
- en: You can access the cluster in two ways, programmatically or using a tool called
    `kubectl`, which both require a certificate to authenticate. This certificate
    is common in a PKI (public key infrastructure) system that checks in with the
    CA (certificate authority) to ensure that the certificate is valid and that communication
    can happen between components in the Kubernetes cluster.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过两种方式访问集群，编程方式或使用名为 `kubectl` 的工具，这两种方式都需要证书进行身份验证。这种证书在 PKI（公钥基础设施）系统中很常见，该系统会与
    CA（证书颁发机构）进行交互，以确保证书有效，并且可以在 Kubernetes 集群中的组件之间进行通信。
- en: Kubernetes was built with microservices in mind, meaning that large microservice
    applications can run more efficiently in Kubernetes, being that each service is
    decoupled from the overall application.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 是考虑到微服务而构建的，这意味着大型微服务应用程序可以在 Kubernetes 中运行得更有效率，因为每个服务都与整体应用程序解耦。
- en: Running Services on Kubernetes is more efficient via a declarative approach.
    This way, we can describe what we want the end state to be, as opposed to running
    a set of imperative commands to achieve the same result.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行服务通过声明式方法更为高效。这种方式，我们可以描述我们希望最终状态是什么，而不是运行一系列命令式指令来达到相同的结果。
