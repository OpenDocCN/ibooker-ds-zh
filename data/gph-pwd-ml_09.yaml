- en: 7 Context-aware and hybrid recommendations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 上下文感知和混合推荐
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing a recommendation engine that takes into account the user’s context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现考虑用户上下文的推荐引擎
- en: Designing graph models for context-aware recommendation engines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为上下文感知推荐引擎设计图模型
- en: Importing existing datasets into the graph models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有数据集导入图模型
- en: Combining multiple recommendation approaches
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合多种推荐方法
- en: 'This chapter introduces into the recommendation scenario another variable that
    the previous approaches ignored: *context*. The specific conditions in which the
    user expresses a desire, preference, or need have a strong influence on their
    behavior and expectations. Different techniques exist to consider the user’s context
    during the recommendation process. We’ll cover the main ones in this chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '本章介绍了推荐场景中另一个先前方法忽略的变量：*上下文*。用户表达欲望、偏好或需求的具体条件对其行为和期望有强烈的影响。在推荐过程中考虑用户上下文存在不同的技术。我们将在本章中介绍主要的技术。 '
- en: Furthermore, to complete our overview of recommendation engine models and algorithms,
    we’ll see how it’s possible to use a hybrid approach that combines the different
    types of systems presented so far. Such an approach will enable us to create a
    unique and powerful recommendation ecosystem capable of overcoming all the issues,
    limitations, and drawbacks of each individual recommendation method.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了完成我们对推荐引擎模型和算法的概述，我们将看到如何使用一种混合方法，该方法结合了迄今为止所展示的不同类型系统。这种方法将使我们能够创建一个独特且强大的推荐生态系统，能够克服每种单独推荐方法的所有问题、局限性和缺点。
- en: 7.1 The context-based approach
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 基于上下文的方法
- en: Suppose that you would like to implement a mobile application that provides
    recommendations about movies to watch at the cinema; we’ll call it Reco4.me. By
    using context-aware techniques, you’ll be able to take into account environmental
    information during the recommendation process, suggesting, for example, movies
    playing at cinemas close to the user’s current location.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想实现一个提供影院观影推荐的电影移动应用；我们将称之为Reco4.me。通过使用上下文感知技术，你将能够在推荐过程中考虑环境信息，例如，建议用户当前位置附近的影院正在上映的电影。
- en: Let’s further refine the scenario with a concrete example. Suppose that you’re
    in London, and you would like to find a movie to watch at a nearby cinema. You
    take out your phone, open the Reco4.me app, and hope for some good recommendations.
    What kinds of recommendations do you expect? You want to know about movies that
    are currently playing in cinemas close to where you are. Ideally, you would also
    like to have recommendations that suit your preferences. I don’t know about you,
    but for me, the context changes my preferences. When I’m alone at home, I love
    to watch action or fantasy movies. When I’m with my kids, I prefer to watch cartoons
    or family movies. When I’m with my wife, “we” prefer to watch chick flicks or
    romcoms. The app should take into account this environmental information and provide
    accurate recommendations that suit the user’s current context.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子进一步细化场景。假设你在伦敦，你想要在附近的影院找一部电影来看。你拿出手机，打开Reco4.me应用，希望得到一些好的推荐。你期望什么样的推荐？你希望了解你附近影院正在上映的电影。理想情况下，你希望得到适合你偏好的推荐。我不知道你，但对我来说，上下文会改变我的偏好。当我独自在家时，我喜欢看动作或奇幻电影。当我和孩子在一起时，我更喜欢看卡通或家庭电影。当我和我妻子在一起时，“我们”更喜欢看浪漫喜剧或爱情喜剧。应用应该考虑这种环境信息，并提供适合用户当前上下文的准确推荐。
- en: This example shows how essential it can be to consider context in a recommender
    system, because it may have a subtle but powerful influence on user behaviors
    and needs. Considering the context, therefore, can dramatically affect the quality
    of the recommendations, converting what might be a good tip in some circumstances
    to a useless suggestion in others. This situation is true not only in scenarios
    like the one described here, but also in many others. Think about how you use
    an e-commerce site such as Amazon, for example. You might use it to buy a book
    for yourself, a gift for your fiancé, or a toy for your kids. You have a single
    account, but your behavior and your preferences are driven by the specific needs
    you have while you are navigating the site. So although it could be useful to
    see recommendations of books that might be of interest to you while you are looking
    for a skateboard for your son, it would be more effective to get suggestions that
    suit your current needs, based on previous gifts you’ve bought for your kids.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在推荐系统中考虑环境信息是多么重要，因为它可能对用户行为和需求产生微妙但强大的影响。因此，考虑环境信息可以显著影响推荐的质量，将可能在某些情况下有用的建议转化为在其他情况下无用的建议。这种情况不仅适用于这里描述的场景，也适用于许多其他场景。例如，想想你如何使用像亚马逊这样的电子商务网站。你可能用它为自己买一本书，为你的未婚夫买一份礼物，或者为你的孩子买一个玩具。你有一个单独的账户，但你的行为和偏好是由你在浏览网站时特定的需求所驱动的。所以，尽管在寻找为你儿子买滑板的推荐时看到可能对你感兴趣的书是有用的，但得到基于你之前为孩子购买的礼物的当前需求的建议会更有效。
- en: Traditional recommender systems, such as those based on the content-based and
    collaborative filtering approaches discussed in chapters 4 and 5, tend to use
    fairly simple user models. User-based collaborative filtering models users simply
    as vectors of item ratings, for example. As additional observations are made about
    users’ preferences, the user models are extended, and the full collection of user
    preferences is used to generate recommendations or make predictions. This approach,
    therefore, ignores the notion of “situated actions” [Suchman, 1987]—the fact that
    users interact with the system within a particular context or specific scope,
    and that preferences for items within one context may be different from those
    in another context. In many application domains, a context-independent representation
    may lose predictive power because potentially useful information from multiple
    contexts is aggregated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的推荐系统，如第4章和第5章中讨论的基于内容和协同过滤方法的系统，往往使用相当简单的用户模型。例如，基于用户的协同过滤模型将用户简单地视为项目评分的向量。随着对用户偏好的观察越来越多，用户模型得到扩展，并使用用户偏好的完整集合来生成推荐或做出预测。因此，这种方法忽略了“情境行为”的概念[Suchman,
    1987]——即用户在特定情境或特定范围内与系统交互的事实，以及同一情境中项目偏好可能与另一情境不同。在许多应用领域，一个与环境无关的表示可能会失去预测能力，因为来自多个情境的有用信息被汇总。
- en: More formally, interactions between users and items exhibit a multifaceted nature.
    User preferences typically are not fixed and may change with respect to a specific
    situation. Going back to the example of the Reco4.me app, a simplified schema
    of the possible contextual information is depicted in figure 7.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，用户与项目之间的交互表现出多方面的性质。用户偏好通常不是固定的，并且可能随着特定情况而变化。回到Reco4.me应用的例子，可能的上下文信息的简化模式在图7.1中展示。
- en: '![CH07_F01_Negro](../Images/CH07_F01_Negro.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Negro](../Images/CH07_F01_Negro.png)'
- en: Figure 7.1 Contextual information for the app Reco4.me
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 Reco4.me应用的环境信息
- en: This example is a small subset of the types of contextual information that could
    be considered. Context might include the season of the year or day of the week,
    the type of electronic device the user is using, the user’s mood—almost anything
    [Bazire and Brézillon, 2005; Doerfel et al., 2016]. It’s worth mentioning too
    that the contextual information is defined by what the system knows or can guess
    about the specific conditions in which an action or interaction occurs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是可能考虑的环境信息类型的一个小子集。环境可能包括一年中的季节或星期几，用户正在使用的电子设备类型，用户的心情——几乎任何东西[Bazire和Brézillon,
    2005; Doerfel等，2016]。也值得提到的是，环境信息是由系统对特定条件下发生动作或交互的具体情况所知道或可以推测的内容来定义的。
- en: 'In content-based and collaborative filtering approaches, the recommendation
    problem is defined as a prediction problem in which, given a user profile (defined
    in different ways) and a target item, the recommender system’s task is to predict
    that user’s rating of or interest in that item, reflecting the degree of user
    preference for the item. Specifically, a recommender system tries to estimate
    a rating function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于内容和协同过滤方法中，推荐问题被定义为预测问题，其中，给定一个用户配置文件（以不同的方式定义）和一个目标项目，推荐系统的任务是预测用户对该项目的评分或兴趣，反映用户对项目的偏好程度。具体来说，推荐系统试图估计一个评分函数：
- en: '*f*: User × Item → ratings'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*: 用户 × 项目 → 评分'
- en: Such a function maps user-item pairs to an ordered set of score values. Note
    that f can be viewed as a general-purpose utility (or preference) measure for
    user-item pairs. The ratings for all user-item pairs are not known and therefore
    must be inferred, which is why we talk about *prediction*. When an initial set
    of ratings has been collected, implicitly or explicitly, a recommender system
    tries to estimate the rating values for items that have not yet been rated by
    the users. From now on, we’ll refer to these traditional recommender systems as
    *two-dimensional* (2D) because they consider only the Users and Items dimensions
    as input in the recommendation process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数将用户-项目对映射到一个有序的分数值集合。请注意，f 可以被视为用户-项目对的一般用途（或偏好）度量。所有用户-项目对的评分都是未知的，因此必须推断出来，这就是我们为什么谈论*预测*的原因。当收集到一组初始评分（隐式或显式地）后，推荐系统试图估计尚未被用户评分的项目评分值。从现在起，我们将这些传统的推荐系统称为*二维*（2D），因为它们在推荐过程中只考虑用户和项目维度作为输入。
- en: 'By contrast, *context-aware* recommender systems try to incorporate or use
    additional environmental evidence (beyond information about users and items) to
    estimate user preferences for unseen items. When such contextual evidence can
    be incorporated as part of the input to the recommender system, the rating function
    can be viewed as multidimensional. In this formula, Context represents a set of
    factors that further delineate the conditions under which the user-item pair is
    assigned a particular rating:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，*上下文感知*推荐系统试图结合或使用额外的环境证据（超出用户和项目信息）来估计用户对未见项目的偏好。当此类上下文证据可以作为推荐系统输入的一部分时，评分函数可以被视为多维的。在这个公式中，上下文代表一组进一步界定用户-项目对被分配特定评分条件的因素：
- en: '*f*: User × Item × *Contex*[1] × *Contex*[2] × … × *Contex*[n] → ratings'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*: 用户 × 项目 × *上下文*[1] × *上下文*[2] × … × *上下文*[n] → 评分'
- en: The underlying assumption of this extended model is that user preferences for
    items are a function not only of the items themselves, but also of the context
    in which the items are being considered.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展模型的潜在假设是，用户对项目的偏好不仅取决于项目本身，还取决于考虑项目时的上下文。
- en: 'Context information represents a set of explicit variables that model contextual
    factors in the underlying domain (time, location, surroundings, device, occasion,
    and so on). Regardless of how the context is represented, context-aware recommenders
    must be able to obtain contextual information that corresponds to the user’s activity
    (such as making a purchase or rating an item). Such information, in a context-aware
    recommender system, has a twofold purpose:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文信息代表一组显式变量，它们在底层领域（时间、位置、环境、设备、场合等）中建模上下文因素。无论上下文如何表示，上下文感知推荐者必须能够获取与用户活动（如购买或评分项目）相对应的上下文信息。在这种上下文感知推荐系统中，此类信息有两个方面的目的：
- en: It is part of the learning and modeling process (used, for example, for discovering
    rules, segmenting users, or building regression models).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是学习和建模过程的一部分（例如，用于发现规则、细分用户或构建回归模型）。
- en: For a given target user and target item, the system must be able to identify
    the values of specific contextual variables as part of the user’s ongoing interaction
    with the system. This information is used to ensure that the right recommendation
    is delivered, considering the context.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的目标用户和目标项目，系统必须能够识别特定上下文变量的值，作为用户与系统持续互动的一部分。这些信息用于确保在考虑上下文的情况下提供正确的推荐。
- en: 'Contextual information can be obtained in many ways, either explicitly or implicitly.
    Explicit contextual information may be obtained from users themselves or from
    sensors designed to measure specific physical or environmental information [Frolov
    and Oseledets, 2016]. In some cases, however, contextual information must be derived
    or inferred from other observed data. Here some examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文信息可以通过多种方式获得，无论是显式还是隐式。显式上下文信息可能来自用户本身或来自设计用于测量特定物理或环境信息的传感器 [Frolov and
    Oseledets, 2016]。然而，在某些情况下，上下文信息必须从其他观察数据中推导或推断出来。以下是一些例子：
- en: '*Explicit*—The application may ask a person who’s looking for a restaurant
    recommendation to specify whether they’re going on a date or going out with co-workers
    for a business dinner.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显式*—应用程序可能要求寻找餐厅推荐的人指定他们是否在约会或与同事一起参加商务晚餐。'
- en: '*Explicit/implicit*—If the restaurant recommender is a mobile app, additional
    contextual information can be obtained through the device’s GPS and other sensors
    about the location, time, and weather conditions.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显式/隐式*—如果餐厅推荐器是一个移动应用，可以通过设备的GPS和其他传感器获得关于位置、时间和天气条件等额外上下文信息。'
- en: '*Implicit*—An e-commerce system may attempt, using previously learned models
    of user behavior, to distinguish (for example) whether the user is likely to be
    purchasing a gift for their spouse or a work-related book.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隐式*—一个电子商务系统可能尝试使用之前学习到的用户行为模型来区分（例如）用户是否可能为其配偶购买礼物或与工作相关的书籍。'
- en: Approaches to implicitly infer contextual information typically require building
    predictive models from historical data [Palmisano et al., 2008].
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式推断上下文信息的方法通常需要从历史数据中构建预测模型 [Palmisano et al., 2008]。
- en: Figure 7.2 shows the mental model of a context-aware recommendation engine.
    The user’s events—input of the system—are contextualized and converted to a graph;
    then the process of building a model and providing recommendations can start.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2展示了上下文感知推荐引擎的心理模型。用户的动作——系统的输入——被上下文化并转换为图；然后可以开始构建模型和提供推荐的过程。
- en: '![CH07_F02_Negro](../Images/CH07_F02_Negro.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Negro](../Images/CH07_F02_Negro.png)'
- en: Figure 7.2 A graph-powered context-aware recommender system
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 由图驱动的上下文感知推荐系统
- en: 7.1.1 Representing contextual information
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 表示上下文信息
- en: In content-based and collaborative filtering approaches, the user-item interactions—buy,
    click, view, rate, watch, and so on—are represented as a 2D matrix, which we’ve
    defined as the User x Item (U x I) dataset. Such a matrix can easily be represented
    as a bipartite graph, in which one set of vertices represents the users and the
    other set represents the items. The interaction is modeled via a relationship
    between the user (the subject of the event) and the item (the object of the event).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于内容和协同过滤的方法中，用户-项目交互（购买、点击、查看、评分、观看等）被表示为一个二维矩阵，我们将其定义为用户 x 项目（U x I）数据集。这样的矩阵可以很容易地表示为一个二分图，其中一个顶点集代表用户，另一个顶点集代表项目。交互通过事件的用户（事件的主题）和项目（事件的客体）之间的关系来建模。
- en: In context-aware recommendation systems, each interaction event brings more
    information with it. It is described not only by the user and the item, but also
    by all the environmental information that contextualizes the situated action.
    If a user is watching a movie at home with their kids in the evening, the contextual
    information is composed of
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文感知推荐系统中，每个交互事件都带来了更多的信息。它不仅由用户和项目描述，还包括所有环境信息，这些信息上下文化了特定行为。如果一个用户在晚上与孩子们在家看电影，上下文信息包括
- en: '*Time*—Evening, weekday'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间*—晚上，工作日'
- en: '*Company*—Kids'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公司*—儿童'
- en: '*Location*—Home'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*位置*—家'
- en: This example is only a subset of the relevant information that can describe
    the event “watch.” Other information could include the device being used, the
    mood of the users, the ages of the viewers, or the occasion (date night, party,
    or kids’ bedtime movie). Some variables may be discrete (contextual information
    with defined sets of values, such as device and location), and others are continuous
    (numerical values such as age). In the latter case, it’s generally preferable
    to discretize the variables somehow. In the case of age, you might have buckets—such
    as 0-5, 6-14, 15-21, 22-50, and over 50—depending on the specific requirements
    of the recommendation engine.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子仅是描述“观看”这一事件的有关信息的子集。其他信息可能包括使用的设备、用户的情绪、观看者的年龄或场合（约会之夜、派对或孩子的睡前电影）。一些变量可能是离散的（具有定义好的值集的上下文信息，如设备和位置），而其他变量是连续的（如年龄这样的数值）。在后一种情况下，通常最好以某种方式对变量进行离散化。在年龄的情况下，你可能会有不同的年龄段——例如0-5岁、6-14岁、15-21岁、22-50岁以及50岁以上——这取决于推荐引擎的具体要求。
- en: 'The resulting dataset, which represents the input for the recommendation process,
    can no longer be represented as a simple 2D matrix. It requires an N-dimensional
    matrix, in which two dimensions are the users and the items, and the others represent
    contexts. In the example considered here, the dataset will be a five-dimensional
    matrix:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代表推荐过程输入的结果数据集不能再表示为一个简单的二维矩阵。它需要一个N维矩阵，其中两个维度是用户和项目，其余维度代表上下文。在考虑的例子中，数据集将是一个五维矩阵：
- en: dataset = User × Item × Location × Company × Time
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: dataset = 用户 × 项目 × 位置 × 公司 × 时间
- en: Each interaction or event cannot be described simply by two elements and the
    relationship between them. In the best case, when all the contextual information
    is available, three other elements are required, so we cannot use a simple relationship
    in a bipartite graph to represent an event. To represent relationships among five
    vertices, we would need a hypergraph. In mathematics, a *hypergraph* is a generalization
    of the graph in which one edge can connect any number of vertices. In most graph
    databases (including Neo4j), however, it is not possible to represent an n-vertex
    relationship.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交互或事件不能仅通过两个元素及其关系来简单描述。在最佳情况下，当所有上下文信息都可用时，还需要另外三个元素，因此我们不能使用简单的二元关系在二分图中表示一个事件。要表示五个顶点之间的关系，我们需要一个超图。在数学中，*超图*是图的推广，其中一条边可以连接任意数量的顶点。然而，在大多数图数据库（包括Neo4j）中，无法表示n顶点的关系。
- en: The solution is to materialize events as nodes and connect each event node with
    all the elements, or dimensions, that describe the event. The result will look
    like figure 7.3.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将事件实体化为节点，并将每个事件节点与描述该事件的全部元素或维度相连接。结果将类似于图7.3。
- en: '![CH07_F03_Negro](../Images/CH07_F03_Negro.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Negro](../Images/CH07_F03_Negro.png)'
- en: Figure 7.3 An n-partite graph representing contextual information about events
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 表示事件上下信息的n分图
- en: The new graph representation is a 6-partite graph because we have users, items,
    location information, time information, and company information plus the events.
    This graph represents the input for the next steps in the recommendation process
    depicted in figure 7.2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们拥有用户、项目、位置信息、时间信息和公司信息以及事件，新的图表示是一个6分图。此图表示了推荐过程中下一步的输入，如图7.2所示。
- en: Passing from a 2D representation to an n-dimensional representation (n = 5 in
    our case) makes data sparsity an even bigger concern. It will be hard to find
    a lot of events that happen for multiple users under exactly the same circumstances.
    This problem is exacerbated when we have detailed contextual information (higher
    values of n), but it can be mitigated by introducing hierarchies in the contextual
    information. Figure 7.4 shows some examples of possible hierarchies—represented
    in the form of a graph—considering some of the contextual information for our
    specific scenario. These hierarchies are defined as taxonomies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从二维表示过渡到n维表示（在我们的例子中n=5）使得数据稀疏性成为一个更大的问题。很难找到在完全相同情况下发生的大量事件。当我们拥有详细上下文信息（n的值更高）时，这个问题会加剧，但可以通过在上下文信息中引入层次结构来缓解。图7.4展示了考虑我们特定场景的一些上下文信息的可能层次结构示例——以图的形式表示。这些层次结构被定义为分类法。
- en: '![CH07_F04_Negro](../Images/CH07_F04_Negro.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Negro](../Images/CH07_F04_Negro.png)'
- en: Figure 7.4 Taxonomies of users, items, and times
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 用户、项目和时间的分类法
- en: These taxonomies will be used during the recommendation phase to solve the sparsity
    problem and enable us to provide recommendations even when we don’t have much
    information about the current user’s specific context.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分类法将在推荐阶段使用，以解决稀疏性问题，并使我们能够在没有太多关于当前用户特定上下文信息的情况下提供推荐。
- en: In this section, we will use the DePaulMovie dataset[¹](#pgfId-1006338) [Zheng
    et al., 2015], which contains data collected from surveys conducted with students.
    It contains data from 97 users about 79 movies, rated in different contexts (time,
    location, and companion). Such a dataset matches our needs perfectly, and it’s
    often used to perform comparisons of context-aware recommender systems [Ilarri
    et al., 2018].
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 DePaulMovie 数据集[¹](#pgfId-1006338) [Zheng et al., 2015]，该数据集包含从学生调查中收集的数据。它包含关于
    97 个用户和 79 部电影的评分数据，这些评分在不同的上下文中进行（时间、地点和同伴）。这样的数据集完美符合我们的需求，并且经常用于进行上下文感知推荐系统的比较
    [Ilarri et al., 2018]。
- en: To begin, let’s import the data from the DePaulMovie dataset selected for this
    example. Please run the code using a fresh database; you can clean it up[²](#pgfId-1006353)
    or decide to use a different one and keep the one you created in previous chapters
    for further experimentation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入为这个示例选择的数据集 DePaulMovie 的数据。请使用一个全新的数据库运行代码；你可以清理它[²](#pgfId-1006353)
    或者决定使用不同的数据库，并保留你在前几章中创建的数据库以进行进一步实验。
- en: Listing 7.1 Importing data from the DePaulMovie dataset
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 从 DePaulMovie 数据集导入数据
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Entry point for importing the data from the CSV file
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 CSV 文件导入数据的入口点
- en: ❷ Queries that create the constraints in the database to prevent duplicates
    and speed access
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建数据库中的约束以防止重复并加快访问速度的查询
- en: ❸ Query which in one shot creates the events and connects them to the related
    dimensions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一次性创建事件并将它们与相关维度连接的查询
- en: In the complete version in the code repository, you’ll notice that I’ve also
    imported some information about the movies. This information will be useful for
    getting a sense of the results and also for the following exercises.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码仓库的完整版本中，你会注意到我还导入了一些关于电影的信息。这些信息将有助于了解结果，也适用于以下练习。
- en: Exercises
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'After you’ve imported the data, play with the graph database. Here are some
    things to try:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入数据后，尝试操作图数据库。以下是一些可以尝试的事情：
- en: Look for the most frequent contextual information—the most frequent time for
    watching a movie, for example.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最频繁的上下文信息——例如，观看电影的最频繁时间。
- en: Look for the most active users, and check the variability of their contextual
    information.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最活跃的用户，并检查他们上下文信息的变异性。
- en: Try adding some taxonomies to see whether the results of the preceding queries
    change.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试添加一些分类法，看看先前查询的结果是否会有所改变。
- en: Search for movies or genres that are commonly watched during the week and those
    that are more often watched on the weekend.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索在周内普遍观看的电影或类型，以及周末更常观看的电影。
- en: 7.1.2 Providing recommendations
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 提供推荐
- en: Classical recommender systems provide recommendations by using limited knowledge
    of user preferences (that is, user preferences for some subset of the items),
    and the input data for these systems is typically based on records of the form
    <user, item, rating>. As described in previous chapters, the recommendation processes
    generally use the U x I matrix to create a model and provide recommendations based
    only on user interaction and preferences.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 经典推荐系统通过使用对用户偏好的有限了解（即用户对某些项目子集的偏好）来提供推荐，这些系统的输入数据通常是基于形式为 <用户，项目，评分> 的记录。如前几章所述，推荐过程通常使用
    U x I 矩阵来创建模型，并仅基于用户交互和偏好提供推荐。
- en: 'By contrast, context-aware recommender systems typically deal with data records
    of the form <user, item, context1, context2, ..., rating>, in which each record
    includes not only how much a given user liked a specific item, but also contextual
    information about the conditions in which the user interacted with the item (context1
    = Saturday, context2 = wife, and so on). This “rich” information is used to create
    the model. Furthermore, information about the user’s current context can be used
    in various stages of the recommendation process, leading to several approaches
    to context-aware recommender systems. From an algorithmic perspective, the vast
    majority of the context-aware recommendation approaches do the following things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，上下文感知推荐系统通常处理形式为 <用户, 项目, 上下文1, 上下文2, ..., 评分> 的数据记录，其中每个记录不仅包括特定用户对某个项目的喜好程度，还包括用户与项目交互时所处的条件上下文信息（context1
    = 星期六，context2 = 妻子，等等）。这种“丰富”的信息被用于构建模型。此外，用户当前上下文的信息可以在推荐过程的各个阶段被使用，从而产生几种上下文感知推荐系统的方法。从算法的角度来看，绝大多数上下文感知推荐方法都执行以下操作：
- en: Take as input the contextualized (extended) User × Item dataset in the form
    U × I × C[1] × C[2] × ... × C[n], where C[i] is an additional contextual dimension.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以形式 U × I × C[1] × C[2] × ... × C[n] 的上下文化（扩展）用户 × 项目数据集作为输入，其中 C[i] 是一个额外的上下文维度。
- en: Produce a list of contextual recommendations i[1], i[2], i[3], ... for each
    user u, based on the current context of the user.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个用户 u 根据用户的当前上下文生成一个上下文推荐列表 i[1]，i[2]，i[3]，...
- en: Based on how the contextual information, the current user, and the current item
    are used during the recommendation process, context-aware recommendation systems
    can take one of the three forms shown in figure 7.5.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文信息、当前用户和当前项目在推荐过程中的使用情况，上下文感知推荐系统可以采取图 7.5 中所示的三种形式之一。
- en: '![CH07_F05_Negro](../Images/CH07_F05_Negro.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F05_Negro](../Images/CH07_F05_Negro.png)'
- en: Figure 7.5 The three forms of a context-aware recommender system
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 上下文感知推荐系统的三种形式
- en: The three types of context-aware recommendation system are [Ilarri et al., 2018]
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 三种类型的上下文感知推荐系统是 [Ilarri et al., 2018]
- en: '*Contextual prefiltering (or contextualization of recommendation input)*—In
    this paradigm, information about the current context c is used only for selecting
    the relevant set of data, and ratings are predicted by using any traditional 2D
    recommender system on the selected data. For efficiency, several models must be
    precomputed, considering the most probable combinations of contexts.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上下文预过滤（或推荐输入的上下文化）*—在这个范例中，当前上下文 c 的信息仅用于选择相关数据集，并且通过在所选数据上使用任何传统的二维推荐系统来预测评分。为了提高效率，必须预先计算几个模型，考虑到上下文最可能的组合。'
- en: '*Contextual postfiltering (or contextualization of recommendation output)*—In
    this paradigm, contextual information is initially ignored, and the ratings are
    predicted by using any traditional 2D recommender system on the entire dataset.
    Then the resulting set of recommendations is adjusted (contextualized) for each
    user, using the contextual information. Only one model is built, so it’s easier
    to manage, and the contextual information is used only during the recommendation
    phase.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上下文后过滤（或推荐输出的上下文化）*—在这个范例中，上下文信息最初被忽略，并且使用任何传统的二维推荐系统在整个数据集上预测评分。然后，使用上下文信息调整（上下文化）生成的推荐集，针对每个用户。只构建了一个模型，因此更容易管理，并且上下文信息仅在推荐阶段被使用。'
- en: '*Contextual modeling (or contextualization of the recommendation function)*—In
    this paradigm, contextual information is used directly in the modeling technique
    as part of model building.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上下文建模（或推荐函数的上下文化）*—在这个范例中，上下文信息直接作为模型构建的一部分被用于建模技术。'
- en: The following sections describe the three paradigms in more detail, highlighting
    the role of the graph approach for each (especially the first two).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将更详细地描述这三种范例，并突出每种范例中图方法的作用（尤其是前两种）。
- en: Contextual prefiltering
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文预过滤
- en: As shown in figure 7.6, the contextual prefiltering approach uses contextual
    information to select the most relevant User × Item matrices and create models
    from them; then it generates recommendations through the inferred models.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 7.6 所示，上下文预过滤方法使用上下文信息来选择最相关的用户 × 项目矩阵，并从这些矩阵中创建模型；然后通过推断的模型生成推荐。
- en: '![CH07_F06_Negro](../Images/CH07_F06_Negro.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F06_Negro](../Images/CH07_F06_Negro.png)'
- en: Figure 7.6 Contextual prefiltering
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 上下文预过滤
- en: When the User × Item datasets are extracted, any of the numerous traditional
    recommendation techniques proposed in the literature (such as the approaches discussed
    in chapters 4 and 5) can be used to build the model and provide recommendations.
    This technique represents one of the biggest advantages of the first approach
    to context-aware recommendation engines.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当提取用户 × 项目数据集时，可以使用文献中提出的任何众多传统推荐技术（如第 4 章和第 5 章中讨论的方法）来构建模型并提供推荐。这种技术代表了上下文感知推荐引擎第一种方法的最大优势之一。
- en: Note that the prefiltering approach is related to the task of building multiple
    local models in machine learning and data mining based on the most relevant combination
    of contextual information. Rather than building the global rating estimation model
    using all the available ratings, the prefiltering approach builds (prebuilds in
    the real scenario) a local rating estimation model that uses only the ratings
    pertaining to the user-specified criteria for the recommendation (such as Saturday
    or weekday).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预过滤方法与在机器学习和数据挖掘中基于最相关上下文信息组合构建多个局部模型的任务相关。而不是使用所有可用的评级来构建全局评级估计模型，预过滤方法（在实际场景中是预先构建的）构建了一个局部评级估计模型，该模型仅使用与用户指定的推荐标准（如周六或工作日）相关的评级。
- en: 'In this approach, the context c essentially serves as a filter for selecting
    relevant rating data. Here’s an example of a contextual data filter for a movie
    recommender system: if a person wants to see a movie on Saturday, only the Saturday
    rating data is used to recommend movies. Extracting the relevant dataset, building
    the model, and providing the recommendations require time, of course, especially
    if the dataset is big. For this reason, multiple versions are precomputed, using
    the most relevant combinations of contextual information.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，上下文 c 实际上充当了一个过滤器，用于选择相关的评级数据。以下是一个电影推荐系统上下文数据过滤器的示例：如果某人想在周六看电影，则只使用周六的评级数据来推荐电影。提取相关数据集、构建模型和提供推荐当然需要时间，尤其是如果数据集很大。因此，预先计算了多个版本，使用最相关的上下文信息组合。
- en: In the graph approach, considering the model depicted in figure 7.3, performing
    such prefiltering consists in selecting the relevant events by running a query
    like the following.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在图方法中，考虑图 7.3 中所示模型，执行此类预过滤包括通过运行如下查询来选择相关事件。
- en: Listing 7.2 Filtering events based on relevant contextual information
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 基于相关上下文信息过滤事件
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this query, we are considering only the events that happen during a weekday
    alone at home. The output is a slice of our multidimensional matrix. If we instead
    want to get a User × Item matrix for the context <Weekend, Cinema, Partner>, the
    query would look like the following.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们只考虑在家庭中仅在工作日发生的事件。输出是我们多维矩阵的一个切片。如果我们想获取 <周末，电影院，伙伴> 的用户 × 项目矩阵，查询将如下所示。
- en: Listing 7.3 Filtering events based on different contextual information
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 基于不同上下文信息过滤事件
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The resulting matrices will be different.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结果矩阵将不同。
- en: It is not necessary to specify all the contextual information, of course. Some
    of the dimensions can be ignored. We could have a context <Cinema, Partner> in
    which the time dimension would be irrelevant, for example. The query in this case
    would look like the following.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有必要指定所有上下文信息。某些维度可以被忽略。例如，我们可能有一个包含 <电影院，伙伴> 的上下文，其中时间维度可能是不相关的。在这种情况下，查询看起来如下。
- en: Listing 7.4 Filtering events by considering only two items of contextual information
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 仅考虑两个上下文信息项过滤事件
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The graph model is highly flexible. As mentioned previously, after the data
    is filtered, any classic method can be applied to build the model and provide
    recommendations. Suppose that we would like to use the collaborative approach—specifically,
    the nearest neighbor approach. We have to compute similarities among items, users,
    or both. The resulting similarities can be stored as simple relationships between
    items and/or users, but the information about the prefiltering condition would
    be lost. A property can be added to the relationships to keep track of the sources
    used for computing them, but it’s difficult to query; also, most important, this
    approach doesn’t use the graph capabilities to speed navigation through nodes
    and relationships.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图模型非常灵活。如前所述，数据过滤后，任何经典方法都可以应用于构建模型并提供推荐。假设我们想使用协同方法——具体来说，是最近邻方法。我们必须计算项目、用户或两者的相似度。结果相似度可以存储为项目与/或用户之间简单的关系，但预过滤条件的信息将会丢失。可以在关系中添加一个属性来跟踪用于计算它们的信息来源，但这很难查询；更重要的是，这种方法没有使用图的能力来加速通过节点和关系的导航。
- en: 'The best modeling choice in this case is to materialize the similarities by
    using nodes and connect them to the relevant contextual information used for computing
    them: the prefiltering conditions. The resulting graph model would look like figure
    7.7.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最佳建模选择是使用节点来具体化相似度，并将它们连接到用于计算它们的相应上下文信息：预过滤条件。结果图模型将类似于图7.7。
- en: '![CH07_F07_Negro](../Images/CH07_F07_Negro.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F07_Negro](../Images/CH07_F07_Negro.png)'
- en: Figure 7.7 Graph model with the similarity nodes after the computation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 计算后相似节点图模型
- en: This model is easy to navigate during the recommendation process. We can assign
    an ID to each set of contextual information to make querying easier; this ID isn’t
    mandatory, but it’s helpful because it allows faster and simpler access. We can
    get the k-NN for a specific context by using a query like the following.[³](#pgfId-1006375)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐过程中，此模型易于导航。我们可以为每一组上下文信息分配一个ID，以便查询更简单；这个ID不是强制的，但它很有帮助，因为它允许更快、更简单的访问。我们可以通过以下查询获取特定上下文的k-NN。[³](#pgfId-1006375)
- en: Listing 7.5 Query to get the k-NN given specific contextual information
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 获取特定上下文信息的k-NN的查询
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Assigning IDs to specific sets of contextual information allows us to query
    by context ID.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将ID分配给特定的上下文信息集合，使我们能够通过上下文ID进行查询。
- en: The following listing allows you to create such a graph model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表允许您创建这样的图模型。
- en: Listing 7.6 Code for computing and storing similarities in the prefiltering
    approach
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 预过滤方法中计算和存储相似度的代码
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Entry point for computing similarities in prefiltering. The context parameter
    specifies the contextual information. This function has to be run multiple times
    for multiple combinations of contextual information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预过滤中计算相似度的入口点。上下文参数指定上下文信息。此函数必须多次运行，以处理多个上下文信息的组合。
- en: ❷ Computes the similarities. The cosine function is the same one used many times
    in chapters 4, 5, and 6.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算相似度。余弦函数与第4、5、6章多次使用的是同一个。
- en: ❸ Prefilters the dataset, considering the relevant contextual information, and
    returns the usual item list with related sparse vectors
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 根据相关上下文信息预过滤数据集，并返回带有相关稀疏向量的常规项目列表
- en: ❹ if statements that change the query according to the contextual information
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据上下文信息更改查询的if语句
- en: ❺ Query that cleans up the previous stored model
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 清理先前存储模型的查询
- en: ❻ Query that creates the new similarity nodes and connects them to the related
    items and contextual information
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 创建新的相似度节点并将它们连接到相关项目和上下文的查询
- en: ❼ if statements that modify the query according to the filter conditions
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 根据过滤条件修改查询的if语句
- en: As mentioned previously, the exact context can be too narrow. Consider, for
    example, the context of watching a movie with your partner in a cinema on Saturday—or,
    more formally, c = <Partner, Cinema, Saturday>. Using this exact context as a
    data-filtering query may be problematic, because there may not be enough data
    available for accurate rating prediction. To address this issue, Adomavicius and
    Tuzhilin [2005] suggest generalizing the filtering conditions by aggregating narrower
    context details, which may not be significant. These generalizations are the taxonomies
    we discussed earlier, some examples of which were shown in figure 7.4\. So, for
    example, Saturday can become Weekend, whereas Monday to Friday are considered
    to be Weekdays. It’s easy not only to represent such hierarchies or aggregations
    in a graph, but also to query them. Using broader concepts while filtering data
    can deliver better results.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，确切上下文可能过于狭窄。例如，考虑周六与伴侣在电影院看电影的情况——或者更正式地，c = <Partner, Cinema, Saturday>。使用这个确切上下文作为数据过滤查询可能有问题，因为可能没有足够的数据来进行准确的评分预测。为了解决这个问题，Adomavicius和Tuzhilin
    [2005]建议通过聚合较窄的上下文细节来泛化过滤条件，这些细节可能并不重要。这些泛化是我们之前讨论的分类法，其中一些例子在图7.4中展示过。例如，周六可以成为周末，而周一到周五被认为是工作日。不仅容易在图中表示这样的层次结构或聚合，而且还可以查询它们。在过滤数据时使用更广泛的概念可以提供更好的结果。
- en: 'When considering the prefiltering approach, it’s important to determine whether
    the local (specific to some contextual information) model it generates outperforms
    the global model of the traditional 2D technique, which ignores all the information
    associated with the contextual dimensions. It may be better to use contextual
    prefiltering to recommend movies to watch in a movie theater on the weekend but
    use the traditional 2D technique (ignoring the contextual information) to recommend
    movies to watch at home on demand. The trade-off during the calculation of an
    unknown rating in this case is between the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑预滤波方法时，重要的是确定它生成的局部（特定于某些上下文信息）模型是否优于传统的2D技术的全局模型，该模型忽略了与上下文维度相关的所有信息。在这种情况下，可能最好使用上下文预滤波来推荐周末在电影院观看的电影，而使用传统的2D技术（忽略上下文信息）来推荐按需在家观看的电影。在这种情况下计算未知评分时的权衡是在以下方面：
- en: Using more specific (in the sense of narrower contextual information) but relevant
    data (the prefiltering)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更具体（在上下文信息较窄的意义上）但相关的数据（预滤波）
- en: Using all the data available (the traditional 2D recommendation)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有可用的数据（传统的2D推荐）
- en: No simple rule helps us choose between these two calculations; which approach
    will be more successful depends on many factors, such as the type of contextual
    information, the application domain, the user behaviors, and the amount and sparsity
    of data available. For that reason, the prefiltering recommendation method may
    outperform traditional 2D recommendation techniques in some contexts but not in
    others. Based on this observation, Adomavicius and Tuzhilin [2005] propose combining
    contextual prefilters with the traditional 2D technique when no filtering is done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的规则可以帮助我们在这两种计算之间做出选择；哪种方法更成功取决于许多因素，例如上下文信息类型、应用领域、用户行为以及可用数据的数量和稀疏性。因此，预滤波推荐方法在某些上下文中可能优于传统的2D推荐技术，但在其他上下文中则不然。基于这一观察，Adomavicius和Tuzhilin
    [2005]提出，在没有进行过滤的情况下，将上下文预滤波与传统的2D技术相结合。
- en: Contextual postfiltering
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文后滤波
- en: As shown in figure 7.8, the contextual postfiltering approach ignores contextual
    information during model generation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.8所示，上下文后滤波方法在模型生成过程中忽略了上下文信息。
- en: '![CH07_F08_Negro](../Images/CH07_F08_Negro.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F08_Negro](../Images/CH07_F08_Negro.png)'
- en: Figure 7.8 Contextual postfiltering
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8上下文后滤波
- en: 'Furthermore, the ranked list of all candidate items is computed regardless
    of the context. The postfiltering approach uses contextual information in a later
    phase to adjust the obtained recommendation list for each user. The adjustment
    to the top N items can be performed in two ways:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论上下文如何，都会计算所有候选项目的排序列表。后滤波方法在后续阶段使用上下文信息来调整每个用户的推荐列表。对前N个项目的调整可以有两种方式：
- en: Filtering out recommendations that are irrelevant in a given context
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤掉给定上下文中不相关的推荐
- en: Adjusting the ranking of recommendations in the list
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整列表中推荐的排序
- en: In our movie recommendation application Reco4.me, if the user watches only comedies
    on the weekend, the recommendation system could filter out all noncomedies in
    the recommendation list for weekend viewing or penalize them by reducing their
    ratings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电影推荐应用Reco4.me中，如果用户在周末只看喜剧，推荐系统可能会过滤掉周末观看推荐列表中的所有非喜剧，或者通过降低它们的评分来惩罚它们。
- en: Which method is preferable will depend on the application. Panniello et al.
    [2009] performed an experimental comparison of the exact (that is, nongeneralized)
    prefiltering method with postfiltering methods they called Weight and Filter,
    using several real-world e-commerce datasets. Their results showed that the Weight
    postfiltering method outperformed the exact prefiltering approach, which in turn
    outperformed the Filter method. Depending on your application, however, your results
    may vary.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更可取将取决于应用。Panniello等人[2009]对精确（即非泛化）预过滤方法与他们称为Weight和Filter的后过滤方法进行了实验比较，使用了几个现实世界的电子商务数据集。他们的结果显示，Weight后过滤方法优于精确预过滤方法，而后者又优于Filter方法。然而，根据您的应用，结果可能会有所不同。
- en: The methods for filtering or adjusting rankings can be classified as heuristic-based
    or model-based. Heuristic postfiltering approaches focus on finding common item
    characteristics (attributes) for a given user in a given context (such as preferred
    actors to watch on Saturday in a cinema) and then uses these attributes to adjust
    the recommendations. This method requires storing metadata about each item and
    searching for common patterns in user preferences.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤或调整排名的方法可以分为基于启发式或基于模型。启发式后过滤方法侧重于在给定上下文中（例如，在电影院观看周六电影时喜欢的演员）为给定用户找到共同的项目特征（属性），然后使用这些属性来调整推荐。这种方法需要存储每个项目的元数据并搜索用户偏好的共同模式。
- en: In the graph model, representing item metadata is straightforward, and multiple
    modeling techniques have been presented in previous chapters (specifically for
    the content-based approach). Mixing such models with the User × Item × Contexts
    graph representation is a simple exercise; figure 7.9 presents a possible result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在图模型中，表示项目元数据是直接的，前几章（特别是对于基于内容的策略）已经介绍了多种建模技术。将这些模型与用户×项目×上下文图表示混合是一个简单的练习；图7.9展示了可能的结果。
- en: '![CH07_F09_Negro](../Images/CH07_F09_Negro.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F09_Negro](../Images/CH07_F09_Negro.png)'
- en: Figure 7.9 An n-partite graph representing contextual information of events
    plus the item attributes
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 表示事件上下文信息以及项目属性的n分图
- en: The DePaulMovie dataset contains references to IMDb IDs for each movie, so we
    can reuse the code we implemented in chapter 4 to get and add information from
    IMDb. The code is presented in the file import_depaulmovie.py in the repository
    for this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: DePaulMovie数据集包含每部电影的IMDb ID引用，因此我们可以重用第4章中实现的代码来从IMDb获取和添加信息。该代码在本书的仓库中的文件import_depaulmovie.py中展示。
- en: 'After the import, queries like the following can be used to compute commonalities
    based on contextual information for users. Note that the queries shown here focus
    on a specific user to prove the concept. The queries consider only two contexts
    of all the possible combinations: <Cinema, Partner> and <Home, Alone>. We’ll start
    with the <Cinema, Partner> context (listing 7.7).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，可以使用以下查询来根据上下文信息计算用户的共同点。请注意，这里显示的查询专注于特定用户以证明概念。查询仅考虑所有可能组合中的两个上下文：<Cinema,
    Partner>和<Home, Alone>。我们将从<Cinema, Partner>上下文（列表7.7）开始。
- en: Listing 7.7 Query for getting user profile for the context <Cinema, Partner>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 查询获取上下文<Cinema, Partner>的用户资料
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The results of listing 7.7 are shown in figure 7.10.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7的结果显示在图7.10中。
- en: '![CH07_F10_Negro](../Images/CH07_F10_Negro.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F10_Negro](../Images/CH07_F10_Negro.png)'
- en: Figure 7.10 Results of listing 7.7
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 列表7.7的结果
- en: From the results, it is clear that when this user is watching a movie at the
    cinema with their partner, the user prefers comedies, romances, dramas, and action
    movies. The preferred actors/directors follow the same logic. Now let’s take a
    look at the <Home, Alone> context (listing 7.8).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果来看，当这位用户与伴侣在电影院看电影时，用户更喜欢喜剧、浪漫、戏剧和动作电影。喜欢的演员/导演遵循相同的逻辑。现在让我们看看<Home, Alone>上下文（列表7.8）。
- en: Listing 7.8 Query for getting user preferences/profile for the context <Home,
    Alone>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 查询获取上下文<Home, Alone>的用户偏好/资料
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The results of this query are shown in figure 7.11.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本查询的结果显示在图7.11中。
- en: '![CH07_F11_Negro](../Images/CH07_F11_Negro.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F11_Negro](../Images/CH07_F11_Negro.png)'
- en: Figure 7.11 Results of listing 7.8
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 列表7.8的结果
- en: Is this user the same one as before? The results here are different, showing
    the extent to which the context plays a role in the user’s preferences. Results
    obtained in this way can be used to postfilter or fine-tune the results of a traditional
    collaborative filtering approach. Preferences based on context can be precomputed
    and stored back in our graph model. The result will look like figure 7.12.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户和之前的是同一个吗？这里的结果不同，显示了上下文在用户偏好中扮演的角色。以这种方式获得的结果可以用于后过滤或微调传统协同过滤方法的结果。基于上下文的偏好可以预先计算并存储回我们的图模型中。结果将类似于图7.12。
- en: '![CH07_F12_Negro](../Images/CH07_F12_Negro.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F12_Negro](../Images/CH07_F12_Negro.png)'
- en: Figure 7.12 Graph model for the contextualized user preferences
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 上下文化用户偏好的图模型
- en: The types of nodes and relationships presented in the model in figure 7.12 can
    be created by running queries like the following.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12中模型中展示的节点和关系类型可以通过运行以下查询来创建。
- en: Listing 7.9 Query for creating user preferences
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 创建用户偏好的查询
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It worth noting that this query uses properties to represent the contextual
    information of the user preferences. This example is a slight deviation from the
    model design shown in figure 7.12, but it’s a valid option. In the following exercises,
    you are invited to create an equivalent query that matches the model perfectly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，此查询使用属性来表示用户偏好的上下文信息。这个例子与图7.12中所示的模型设计略有不同，但它是一个有效的选项。在接下来的练习中，你将被邀请创建一个与模型完全匹配的等效查询。
- en: Exercises
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Using listing 7.9 as the basis, create the following queries:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以列表7.9为基础，创建以下查询：
- en: The same query for a different context
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同上下文下的相同查询
- en: An equivalent query that uses relationships to contextual information instead
    of using properties for specifying the context
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关系代替属性来指定上下文的等效查询
- en: A query for actors only
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅针对演员的查询
- en: A query for directors only
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅针对导演的查询
- en: A query for writers only
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅针对编剧的查询
- en: A query for genres only
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅针对类型的查询
- en: During the recommendation process, we can use this information about user preferences
    to determine how to adjust the results obtained in the first approach. The query
    to get this information is simple, as you can see in listing 7.10.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐过程中，我们可以使用有关用户偏好的信息来确定如何调整第一个方法获得的结果。获取此信息的查询很简单，如列表7.10所示。
- en: Listing 7.10 Query for getting the boosting factors for the features
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10 获取特征提升因素的查询
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This query returns values we can use as boosting factors after the first generic
    recommendation list has been obtained in one of the classic approaches. The alternative
    to the heuristic approach to postfiltering is the model-based approach. Here,
    we build predictive models that calculate the probability that the user will choose
    a certain type of item in a given context (the likelihood of choosing movies of
    a certain genre when alone and at home, for example) and then use this probability
    to adjust the recommendations. The algorithms for computing probability are beyond
    the scope of this chapter, but when they are computed, they can be stored in the
    graph model exactly as shown in figure 7.12.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回的值可以用作在经典方法中获取第一个通用推荐列表之后作为提升因素的值。与后过滤的启发式方法相比，基于模型的方法是另一种选择。在这里，我们构建预测模型，这些模型计算用户在特定情境下选择某种类型项目的概率（例如，独自在家时选择特定类型的电影的可能性），然后使用这个概率来调整推荐。计算概率的算法超出了本章的范围，但一旦计算出来，它们可以像图7.12中所示的那样存储在图模型中。
- en: It is important to note that, as was the case with contextual prefiltering,
    the greatest advantage of the contextual postfiltering approach is that it allows
    the use of any traditional recommendation technique.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，与上下文预过滤的情况一样，上下文后过滤方法的最大优势是它允许使用任何传统的推荐技术。
- en: Contextual modeling
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文建模
- en: The third type of context-aware recommendation system is based on contextual
    modeling. This approach, illustrated in figure 7.13, uses contextual information
    directly during model creation, giving rise to truly multidimensional recommendation
    functions that represent either predictive models (such as decision trees and
    regressions) or heuristic calculations that incorporate contextual information
    in addition to the user and item data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种上下文感知推荐系统是基于上下文建模的。这种方法如图7.13所示，在模型创建过程中直接使用上下文信息，从而产生了真正多维的推荐函数，这些函数代表预测模型（如决策树和回归）或结合上下文信息（除用户和项目数据外）的启发式计算。
- en: '![CH07_F13_Negro](../Images/CH07_F13_Negro.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F13_Negro](../Images/CH07_F13_Negro.png)'
- en: Figure 7.13 Contextual modeling
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13上下文建模
- en: In the past few years, a large number of recommendation algorithms based on
    a variety of heuristics as well as predictive modeling techniques have been developed.
    Some of these techniques can be considered to be extensions of the 2D to the multidimensional
    recommendation settings. Frolov and Oseledets [2016] show how to represent the
    User × Item × Contexts dataset as a multidimensional matrix, or tensor.[⁴](#pgfId-1006395)
    Such a tensor can be represented as shown in figure 7.14, with each event representing
    an element, and the contexts, users, and items representing the dimensions. In
    such a representation, some operations on tensors, such as slicing, are easy to
    do with simple queries.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，基于各种启发式方法和预测建模技术的推荐算法大量开发。其中一些技术可以被认为是将二维扩展到多维推荐设置中的扩展。Frolov和Oseledets[2016]展示了如何将用户
    × 项目 × 上下文数据集表示为多维矩阵或张量。[⁴](#pgfId-1006395)这样一个张量可以如图7.14所示表示，其中每个事件代表一个元素，上下文、用户和项目代表维度。在这种表示中，对张量的某些操作，如切片，可以通过简单的查询轻松完成。
- en: '![CH07_F14_Negro](../Images/CH07_F14_Negro.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F14_Negro](../Images/CH07_F14_Negro.png)'
- en: Figure 7.14 Tensor representation in a graph model (as a multipartite graph)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14图模型中的张量表示（作为一个多部分图）
- en: Other researchers have addressed the task of contextual modeling with a purely
    graph-based approach, considering context-aware recommendation as a searching
    problem to find interesting items for a user given a so-called context graph [Wu
    et al., 2015]. The previously suggested method for creating the graph would not
    work in this case because the model design is different. Instead, the graph is
    created as follows. Given a context graph G = {V, E}, the vertices and the edges
    are defined so that
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其他研究人员已经使用纯图方法来解决上下文建模的任务，将上下文感知推荐视为一个搜索问题，即在所谓的上下文图中找到对用户感兴趣的项目[Wu等人，2015]。之前提出的创建图的方法在这种情况下将不起作用，因为模型设计不同。相反，图是按照以下方式创建的。给定上下文图G
    = {V, E}，顶点和边被定义为如下：
- en: The vertex set V is divided into several distinct sets, such as a set of users
    U, a set of items I, a set of attributes A, and a set of contexts C. C represents
    the combination of contextual information in a node. <Home, Alone, Weekday> is
    a node, for example. Nodes A represent the static features or attributes of users
    or items—information that does not change for different ratings, unlike the contextual
    information.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点集V被划分为几个不同的集合，例如用户集U、项目集I、属性集A和上下文集C。C代表节点中上下文信息的组合。《家庭，独自，工作日》是一个节点，例如。节点A代表用户或项目的静态特征或属性——与上下文信息不同，这些信息不会因不同的评分而改变。
- en: 'The edge set E consists of the existing connections of the Cartesian product:
    V × V. Edges with diverse types have distinct semantics. U × A connects users
    and their attributes (user interests), U × I connects users with the items they
    have interacted with (the old User × Item dataset), and U × C connects users and
    contexts. The submatrix U × U, which stores social network information, may exist
    or not.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边集E由笛卡尔积的现有连接组成：V × V。具有不同类型的边具有不同的语义。U × A将用户及其属性（用户兴趣）连接起来，U × I将用户与其交互过的项目连接起来（旧的User
    × Item数据集），U × C将用户与上下文连接起来。存储社交网络信息的子矩阵U × U可能存在也可能不存在。
- en: The context graph G can be represented as an adjacent matrix in which all submatrices
    are configured as symmetric (UI^T is the transport matrix of UI, for example),
    as shown in table 7.1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图G可以表示为一个邻接矩阵，其中所有子矩阵都配置为对称的（例如，UI^T是UI的转换矩阵），如表7.1所示。
- en: Table 7.1 An adjacent matrix representation of contextual user-item interactions
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 用户-项目交互的邻接矩阵表示
- en: '|  | Users | Items | Contexts | Attributes |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  | 用户 | 项目 | 上下文 | 属性 |'
- en: '| Users | UU | UI | UC | UA |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | UU | UI | UC | UA |'
- en: '| Items | UIT | 0 | IC | IA |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | UIT | 0 | IC | IA |'
- en: '| Contexts | UCT | ICT | 0 | 0 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 上下文 | UCT | ICT | 0 | 0 |'
- en: '| Attributes | UAT | IAT | 0 | 0 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | UAT | IAT | 0 | 0 |'
- en: The resulting graph is shown in figure 7.15.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图显示在图7.15中。
- en: '![CH07_F15_Negro](../Images/CH07_F15_Negro.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F15_Negro](../Images/CH07_F15_Negro.png)'
- en: Figure 7.15 Representation of a context graph
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15上下文图的表示
- en: Avoiding too many details, a random walk approach (specifically, the Personalized
    PageRank or PageRank with restart algorithm) is used to compute the relevance
    of the nodes in the graph. The recommendation process uses these relevance scores
    to estimate the likelihood that an unseen item i will be accessed by a user u.
    For a detailed description, see Wu et al. [2015].
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过多的细节，使用随机游走方法（特别是个性化PageRank或带重启的PageRank算法）来计算图中节点的相关性。推荐过程使用这些相关性分数来估计未看到的项i被用户u访问的可能性。有关详细描述，请参阅Wu等人[2015]。
- en: Pros and cons
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 优缺点
- en: 'Each of the three techniques discussed for context-based recommendation has
    advantages and disadvantages:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所讨论的基于上下文的推荐的三种技术，每种都有其优势和劣势：
- en: Prefiltering
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预过滤
- en: '*Pros*—This method is not only easy to implement, but also allows you to use
    any of the traditional recommendation techniques. It can deliver quite accurate
    results if relevant data for the user’s current context is available.'
  id: totrans-189
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优点*—这种方法不仅易于实现，还允许你使用任何传统的推荐技术。如果用户当前上下文的相关数据可用，它可以提供相当准确的结果。'
- en: '*Cons*—The data-sparsity problem is common here because it’s highly probable
    that for some contexts, there won’t be enough data available for accurate recommendations.
    Moreover, to be performant, this approach requires you to prebuild a high number
    of models and keep them all updated.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺点*—数据稀疏性问题在这里很常见，因为对于某些上下文，可能没有足够的数据来进行准确的推荐。此外，为了性能，这种方法要求你预先构建大量模型并保持它们全部更新。'
- en: Postfiltering
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后过滤
- en: '*Pros*—This method is even easier to implement: you use a traditional technique
    (such as collaborative filtering) to generate the recommendations and then apply
    the filter to the result.'
  id: totrans-192
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优点*—这种方法甚至更容易实现：你使用传统的技术（如协同过滤）来生成推荐，然后对结果应用过滤器。'
- en: '*Cons*—The postfiltering filters out or reduces the ratings for elements that
    are not relevant to the user’s current context. Prediction accuracy is almost
    independent from context and mostly aligned with the traditional methods. Data
    sparsity is a problem here too, as it is for the traditional methods; it may be
    that all the resulting elements are irrelevant to the current context.'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺点*—后过滤会过滤掉或减少与用户当前上下文不相关的元素的评分。预测准确性几乎与上下文无关，并且主要与传统方法一致。数据稀疏性在这里也是一个问题，正如传统方法中那样；可能所有生成的元素都与当前上下文无关。'
- en: Contextual modeling
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文建模
- en: '*Pros*—The methods in this category are the most recent and tend to be the
    most accurate. The main disadvantage of the previous approach is that context
    is not integrated tightly into the recommendation algorithm, preventing you from
    taking full advantage of the relationships among the various user-item combinations
    and contextual values. Contextual modeling takes context into account from the
    beginning, enabling the creation of precise models that can be queried by using
    user, item, and contextual information.'
  id: totrans-195
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优点*—这一类的方法是最新的，往往也是最准确的。先前方法的主要缺点是上下文没有紧密集成到推荐算法中，这阻止了你充分利用各种用户-项目组合和上下文值之间的关系。上下文建模从一开始就考虑上下文，使得可以创建精确的模型，并使用用户、项目和上下文信息进行查询。'
- en: '*Cons*—Most of the methods available for contextual modeling are complex to
    implement, and a lot of computational power is required to create and update the
    model.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺点*—大多数可用的上下文建模方法实现起来都很复杂，创建和更新模型需要大量的计算能力。'
- en: The choice of technique depends on weighing these pros and cons. More specifically,
    the choice depends on the type and quantity of data available, the frequency of
    new data, and how closely the model should be aligned with the current data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 技术的选择取决于权衡这些优缺点。更具体地说，选择取决于可用数据的类型和数量、新数据的频率以及模型应与当前数据多么紧密地一致。
- en: 7.1.3 Advantages of the graph approach
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 图方法的优势
- en: 'In this section, we’ve discussed different approaches to creating a context-aware
    recommendation engine: prefiltering, postfiltering, and contextual modeling. All
    the methods and algorithms presented here can use the graph representation of
    the User × Item × Contexts dataset, which simplifies accessing and navigating
    this complex data. Specifically, the main aspects and advantages of the graph-based
    approach to context-aware recommendation systems are'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了创建上下文感知推荐引擎的不同方法：预过滤、后过滤和上下文建模。这里介绍的所有方法和算法都可以使用User × Item × Contexts数据集的图表示，这简化了访问和导航这些复杂数据。具体来说，基于图的方法在上下文感知推荐系统中的主要方面和优势包括
- en: The User × Item × Contexts multidimensional matrix, which represents the input
    of any such system, can be represented by a graph materializing the interaction
    event. This data model speeds the filtering phase and prevents the data-sparsity
    problem, which can be problematic in this scenario.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示任何此类系统输入的User × Item × Contexts多维矩阵可以通过一个实体化交互事件的图来表示。这种数据模型加速了过滤阶段，并防止了数据稀疏性问题，这在当前场景中可能是个问题。
- en: A proper graph model can store the multimodel results of contextual prefiltering.
    Specifically, in the case of the nearest neighbor approach to prefiltering, which
    results in different sets of similarities among the items or users, graphs can
    store the results of multiple models by materializing the similarity nodes.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合适的图模型可以存储上下文预过滤的多模型结果。具体来说，在预过滤的最近邻方法中，这会导致项目或用户之间不同的相似性集合，图可以通过实体化相似性节点来存储多个模型的结果。
- en: During the recommendation phase, graph access patterns simplify the selection
    of relevant data based on the current user and the current context.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在推荐阶段，图访问模式简化了基于当前用户和当前上下文选择相关数据的过程。
- en: In the contextual modeling approach, graphs provide a suitable method for storing
    tensors, simplifying some operations. Additionally, some specific approaches not
    only use a graph representation of the data (the context graph described earlier),
    but also use graph algorithms such as random walk and PageRank for building models
    and then providing recommendations.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上下文建模方法中，图提供了一种适合存储张量、简化某些操作的方法。此外，一些特定的方法不仅使用数据（如前所述的上下文图）的图表示，还使用图算法，如随机游走和PageRank来构建模型并提供推荐。
- en: 7.2 Hybrid recommendation engines
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 混合推荐引擎
- en: The recommendation approaches discussed in this book exploit different sources
    of information and follow different paradigms to make recommendations. Although
    they produce results that are considered to be personalized based on the assumed
    interests of their recipients, they perform with varying degrees of success in
    different application domains. Collaborative filtering exploits a specific type
    of information (item ratings) from a user model to derive recommendations, whereas
    content-based approaches rely on product features and textual descriptions as
    well as on user profiles. Session-based approaches use the clickstreams of anonymous
    users, whereas context-aware methods use contextual information together with
    item ratings to fine-tune the recommendations according to the current needs of
    the user.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论的推荐方法利用不同的信息来源和遵循不同的范式来做出推荐。尽管它们基于接收者的假设兴趣产生个性化的结果，但在不同的应用领域中，它们的成功程度各不相同。协同过滤利用用户模型中的一种特定类型的信息（项目评分）来推导推荐，而基于内容的推荐方法则依赖于产品特征和文本描述以及用户配置文件。基于会话的方法使用匿名用户的点击流，而上下文感知方法则使用上下文信息以及项目评分来根据用户的当前需求微调推荐。
- en: Each of these approaches has its pros and cons (highlighted in detail in this
    chapter and previous chapters), including the ability to handle the data-sparsity
    and cold-start problems, and the amount of effort required for content or context
    acquisition and processing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法各有优缺点（在本章和前几章中详细说明），包括处理数据稀疏性和冷启动问题的能力，以及获取和处理内容或上下文所需的工作量。
- en: Figure 7.16 sketches a recommendation system as a black box that transforms
    input data into a ranked list of items as output. Potential inputs, based on the
    approaches discussed here, include user models and contextual information as well
    as session data and item data; other inputs, required by other recommendation
    models, could be included as well. None of the basic approaches is able to fully
    exploit all these inputs, however. Consequently, building hybrid systems that
    combine the strengths of different algorithms and models to overcome some of the
    aforementioned shortcomings and problems has become the target of recent research.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16概述了一个推荐系统作为黑盒，它将输入数据转换为输出项的排序列表。潜在的输入，基于这里讨论的方法，包括用户模型和上下文信息，以及会话数据和项目数据；其他输入，由其他推荐模型所需，也可以包括在内。然而，没有任何基本方法能够充分利用所有这些输入。因此，构建结合不同算法和模型优势的混合系统，以克服上述一些缺点和问题，已成为最近研究的目标。
- en: '![CH07_F16_Negro](../Images/CH07_F16_Negro.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F16_Negro](../Images/CH07_F16_Negro.png)'
- en: Figure 7.16 Hybrid recommendation system as a black box
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 混合推荐系统作为黑盒
- en: 'Hybrid recommender systems are technical implementations that combine multiple
    algorithms or recommendation components. Burke’s [2002] taxonomy distinguishes
    among seven hybridization strategies. From a more general perspective, the seven
    variants can be abstracted into three base designs:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 混合推荐系统是结合多个算法或推荐组件的技术实现。Burke的[2002]分类法区分了七种混合策略。从更一般的角度来看，这七个变体可以抽象为三种基本设计：
- en: '*Monolithic*—This hybridization design incorporates aspects of several recommendation
    strategies in one algorithm implementation. Several recommenders contribute virtually
    because the hybrid uses additional input data that is specific to another recommendation
    algorithm, or the input data is augmented by one technique and factually exploited
    by another. Feature combination and feature augmentation strategies can be assigned
    to this category. *Feature combination* uses a diverse range of input data. It
    can combine collaborative features, such as a user’s likes and dislikes, with
    content features of catalog items. *Feature augmentation* applies complex transformation
    steps. The output of a contributing recommender system augments the feature space
    of the actual recommender by preprocessing its knowledge sources. See figure 7.17
    a.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单体*—这种混合化设计在一个算法实现中结合了多种推荐策略的方面。几个推荐者几乎贡献了虚拟的，因为混合使用了针对另一个推荐算法的特定输入数据，或者输入数据通过一种技术增强，实际上被另一种技术利用。特征组合和特征增强策略可以归为此类。*特征组合*使用多种多样的输入数据。它可以结合协作特征，如用户的喜好和不喜欢，与目录项目的特征内容。*特征增强*应用复杂的转换步骤。贡献的推荐系统通过预处理其知识源来增强实际推荐系统的特征空间。见图7.17
    a。'
- en: '*Parallelized*—This approach requires at least two separate recommender implementations,
    which are subsequently combined (see figure 7.17 b). Parallelized hybrid recommender
    systems operate independently of one another and produce separate recommendation
    lists. In a subsequent hybridization step, their output is combined into a final
    set of recommendations. Following Burke’s taxonomy, the weighted, mixed, and switching
    strategies require recommendation components to work in parallel.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行化*—这种方法需要至少两个独立的推荐系统实现，随后将它们组合在一起（见图7.17 b）。并行化混合推荐系统相互独立运行，并产生单独的推荐列表。在随后的混合化步骤中，它们的输出被组合成最终的推荐集。根据Burke的分类法，加权、混合和切换策略要求推荐组件并行工作。'
- en: '*Pipelined*—In this case, several recommender systems are joined in a pipeline
    architecture (see figure 7.17 c). The output of one recommender becomes part of
    the input of the subsequent one. Optionally, the subsequent recommender components
    may use parts of the original input data, too. The cascade and meta-level hybrids,
    as defined by Burke, are examples of such architectures.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*流水线*—在这种情况下，多个推荐系统以流水线架构（见图7.17 c）连接在一起。一个推荐系统的输出成为后续一个推荐系统的输入。可选地，后续的推荐系统组件也可能使用原始输入数据的一部分。Burke定义的级联和元级混合架构就是此类架构的例子。'
- en: '![CH07_F17_Negro](../Images/CH07_F17_Negro.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F17_Negro](../Images/CH07_F17_Negro.png)'
- en: Figure 7.17 Hybridization design techniques
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 混合设计技术
- en: In this chapter, we will focus on the parallelized hybridization technique,
    which allows multiple recommender systems to operate in parallel, each using its
    own input and producing its own output model. The resulting models have to be
    stored somewhere so that they can be accessed and mixed or merged easily during
    the recommendation phase. In this context, graphs provide
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注并行化混合技术，它允许多个推荐系统并行运行，每个系统使用自己的输入并产生自己的输出模型。结果模型必须存储在某个地方，以便在推荐阶段可以轻松访问和混合或合并。在这种情况下，图提供了
- en: A suitable representation for storing in a single, homogeneous, and connected
    data source all the different sets of information required by each recommender
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种适合存储在单一、同质和连通的数据源中，以满足每个推荐系统所需的所有不同信息集的表示
- en: A model for storing the results of the training process so that they can be
    queried easily in parallel and then merged according to the hybridization strategy
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于存储训练过程结果的模型，以便可以并行查询，然后根据混合策略合并
- en: 7.2.1 Multiple models, single graph
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 多模型，单图
- en: 'Let’s take a closer look at the parallelized hybrid approach (figure 7.18).
    Suppose that you have two types of recommender systems to be hybridized: one content-based,
    like the ones described in chapter 4, and one collaborative, like those described
    in chapter 5\. This scenario is a common one: it’s often useful to merge these
    types of recommender systems because each can solve the issues of the other. The
    content-based approach mitigates the cold-start problem that occurs when data
    is missing, such as in the case of a new user, item, or new platform, whereas
    the collaborative filtering approach provides more accurate results and also works
    without information or metadata about users and items.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看并行化混合方法（图7.18）。假设你有两种类型的推荐系统需要混合：一种是基于内容的，如第4章中描述的，另一种是基于协作的，如第5章中描述的。这种情况很常见：通常很有用将这两种类型的推荐系统合并，因为每种都可以解决另一种的问题。基于内容的方案可以缓解数据缺失时出现的冷启动问题，例如在新的用户、项目或新平台的情况下，而基于协作过滤的方法则提供更准确的结果，并且在没有用户和项目信息或元数据的情况下也能工作。
- en: '![CH07_F18_Negro](../Images/CH07_F18_Negro.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F18_Negro](../Images/CH07_F18_Negro.png)'
- en: Figure 7.18 Parallelized approach
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 并行化方法
- en: The graph used as input for the parallelized hybrid recommendation system that
    uses these two types of recommenders as input looks like figure 7.19.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为并行化混合推荐系统输入的图，该系统使用这两种类型的推荐器作为输入，看起来像图7.19。
- en: '![CH07_F19_Negro](../Images/CH07_F19_Negro.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F19_Negro](../Images/CH07_F19_Negro.png)'
- en: Figure 7.19 Example graph model that combines collaborative filtering and content-based
    approaches
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 示例图模型，结合了协作过滤和基于内容的方案
- en: In this case, it is important to note how the rated connection is used by both
    recommender systems in different ways. In the collaborative-filtering approach,
    it is used for creating the User-Item dataset; in the content-based approach,
    it is used for accessing the features of interest for the user. When the models
    are computed, they can be stored back in the graph, as depicted in figure 7.20.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重要的是要注意两个推荐系统如何以不同的方式使用评分连接。在协作过滤方法中，它用于创建用户-项目数据集；在基于内容的方法中，它用于访问用户感兴趣的特征。当模型被计算后，它们可以存储回图中，如图7.20所示。
- en: '![CH07_F20_Negro](../Images/CH07_F20_Negro.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F20_Negro](../Images/CH07_F20_Negro.png)'
- en: Figure 7.20 Mixing multiple recommendation models in the same graph
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 在同一图中混合多个推荐模型
- en: 7.2.2 Providing recommendations
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 提供推荐
- en: 'Now that we’ve built the models and stored them in the graph, we can combine
    their outputs to obtain a unique list (or sometimes multiple lists) of items to
    recommend to the user. As described earlier, parallelized hybridization designs
    employ several recommenders side by side and use a specific hybridization mechanism
    to aggregate their outputs. The hybridization mechanism defines the strategy to
    provide recommendations to the user. According to Burke’s [2002] classification,
    three main strategies can be applied: mixed, weighted, and switching. Additional
    combination strategies for multiple recommendation lists, such as majority voting
    schemes, may also be applicable.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了模型并将它们存储在图中，我们可以结合它们的输出以获得一个独特的推荐项目列表（有时是多个列表）以推荐给用户。如前所述，并行化混合设计并排使用多个推荐器，并使用特定的混合机制来聚合它们的输出。混合机制定义了向用户提供推荐的战略。根据Burke的[2002]分类，可以应用三种主要策略：混合、加权以及切换。对于多个推荐列表，如多数投票方案等附加组合策略也可能适用。
- en: Mixed
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 混合
- en: The *mixed* hybridization strategy combines the results of different recommender
    systems at the level of the user interface. Results from different techniques
    are presented together; therefore, the recommendation result for user u is a set
    of lists of items.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*混合*混合策略在用户界面级别结合不同推荐系统的结果。不同技术的结果一起呈现；因此，用户u的推荐结果是一系列项目列表。'
- en: The top-scoring items for each recommender are displayed to the user next to
    one another, generally specifying to the user the criteria for each item. Sometimes
    in the mixed approach, some type of conflict resolution is necessary to prevent
    too many overlaps in the multiple lists.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个推荐器的得分最高的项目并排显示给用户，通常指定每个项目的标准。有时在混合方法中，需要某种类型的冲突解决来防止多个列表中重叠过多。
- en: Weighted
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 加权
- en: A *weighted* hybridization strategy combines the recommendations of two or more
    recommender systems by computing weighted sums of their scores. Figure 7.21 is
    a graphical model showing how it works.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一种*加权*混合策略通过计算两个或多个推荐系统得分的加权总和来结合它们的推荐。图7.21是一个图形模型，展示了其工作原理。
- en: '![CH07_F21_Negro](../Images/CH07_F21_Negro.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F21_Negro](../Images/CH07_F21_Negro.png)'
- en: Figure 7.21 Weighted method explained with graphical model
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 使用图形模型解释加权方法
- en: Thus, given n different recommendation functions score[k](u, i) with associated
    relative weights β[k], the final score will be computed according to the formula
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定n个不同的推荐函数score[k](u, i)及其相关的相对权重β[k]，最终得分将根据以下公式计算
- en: '![CH07_F22_EQ01_Negro](../Images/CH07_F22_EQ01_Negro.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F22_EQ01_Negro](../Images/CH07_F22_EQ01_Negro.png)'
- en: where n is the number of recommenders whose outputs have to be mixed. Furthermore,
    the item scores need to be restricted to the same range for all recommenders,
    and the sum of all β[k] must be 1\. This technique is straightforward and thus
    is a popular strategy for combining the predictive power of different recommendation
    techniques in a weighted manner.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 其中n是需要混合的推荐器输出的数量。此外，项目得分需要限制在所有推荐器中相同的范围内，并且所有β[k]的总和必须为1。这种方法简单直接，因此是结合不同推荐技术预测能力的加权方式的一种流行策略。
- en: It is worth noting that the value of β[k] can be dynamic, changing over the
    life of the recommendation system, privileging (for example) the content-based
    approach over collaborative filtering in the early stages when not enough information
    is available for the latter to be effective and then gradually giving it more
    weight when more data has been gathered. Moreover, the values can be dynamic per
    user, assigning a higher value of β[k] to the content-based recommendations until
    the system has acquired enough data for the collaborative filtering approach to
    be effective. Different techniques can be applied to evaluate how to set and then
    evolve the values of the weights.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，β[k]的值可以是动态的，在推荐系统的一生中发生变化，例如在早期由于缺乏足够的信息而无法有效应用协同过滤时，优先考虑基于内容的推荐方法，然后在收集到更多数据后逐渐增加其权重。此外，这些值可以针对每个用户动态变化，将较高的β[k]值分配给基于内容的推荐，直到系统收集到足够的数据，使得协同过滤方法变得有效。可以应用不同的技术来评估如何设置并演变权重的值。
- en: Switching
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 切换
- en: '*Switching* hybrids require an oracle that decides which recommender should
    be used in a specific situation, depending on the user profile and/or the quality
    of recommendation results. Figure 7.22 is a graphical model describing how it
    works.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*切换* 混合推荐系统需要一个预言机来决定在特定情况下应使用哪个推荐器，这取决于用户配置文件和/或推荐结果的质量。图 7.22 是一个描述其工作原理的图形模型。'
- en: '![CH07_F22_Negro](../Images/CH07_F22_Negro.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F22_Negro](../Images/CH07_F22_Negro.png)'
- en: Figure 7.22 Switching method explained by a graphical model
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 通过图形模型解释的切换方法
- en: Such an evaluation could be carried out as follows,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的评估可以按照以下方式进行，
- en: '![CH07_F22_Negro_EQ02](../Images/CH07_F22_Negro_EQ02.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F22_Negro_EQ02](../Images/CH07_F22_Negro_EQ02.png)'
- en: where k is determined by the switching condition. To overcome the cold-start
    problem, a content-based and collaborative switching hybrid could initially make
    content-based recommendations until enough rating data is available. When the
    collaborative filtering component can deliver recommendations with sufficient
    confidence, the recom-mendation strategy could be switched. In an extreme case,
    dynamic weight adjustment could be implemented as a switching hybrid. The weights
    of all but one dynamically selected recommender are set to 0, and the output of
    the single remaining recommender is assigned a weight of 1.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 k 由切换条件确定。为了克服冷启动问题，基于内容和协作的切换混合推荐系统可以最初基于内容进行推荐，直到有足够的评分数据可用。当协同过滤组件可以提供具有足够置信度的推荐时，推荐策略可以切换。在极端情况下，可以实施动态权重调整作为切换混合。除了动态选择的单个推荐器外，所有其他推荐器的权重都设置为
    0，而单个剩余推荐器的输出被分配一个权重为 1。
- en: 7.2.3 Advantages of the graph approach
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 图方法的优势
- en: 'In this section, we’ve discussed how to create a hybrid recommendation engine,
    focusing on parallelized hybridization approaches: mixed, weighted, and switching.
    All the methods presented here can take advantage of a graph representation of
    the data, both for training and in the resulting models. The main aspects and
    advantages of the graph-based approach to hybrid methods are'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何创建一个混合推荐引擎，重点关注并行化混合方法：混合、加权以及切换。这里提出的所有方法都可以利用数据图表示，无论是训练还是生成的模型。基于图混合方法的主要方面和优势是
- en: Various sets of information can coexist in the same data structure, making it
    easier to meet the data management needs of a hybrid recommender.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种信息集可以在相同的数据结构中共存，这使得更容易满足混合推荐系统的数据管理需求。
- en: The independent models resulting from each recommender can be stored together
    and then accessed easily during the recommendation phase.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个推荐器产生的独立模型可以一起存储，并在推荐阶段轻松访问。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented the latest advanced techniques for implementing recommendation
    engines using contextual information and showed how to combine different approaches
    for greater effect. The various data models illustrate the usefulness and flexibility
    of graphs for satisfying different requirements in terms of training data and
    model storage. In this chapter, you learned
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用上下文信息实现推荐引擎的最新高级技术，并展示了如何结合不同的方法以产生更大的效果。各种数据模型说明了图在满足不同训练数据和模型存储需求方面的有用性和灵活性。在本章中，你学习了
- en: How to improve the quality of the recommendations by embedding contextual information
    in the model and the related graph model
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过在模型和相关图模型中嵌入上下文信息来提高推荐质量
- en: 'How to use the graph to feed the context-aware design approaches: pre-/ postfiltering
    and contextual modeling'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用图来为上下文感知设计方法提供数据：预/后过滤和上下文建模
- en: How to combine multiple algorithms in a single recommendation engine
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在一个推荐引擎中结合多个算法
- en: How to mix different training datasets and models in a single big graph
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在一个大图中混合不同的训练数据集和模型
- en: References
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[Adomavicius and Tuzhilin, 2005] Adomavicius, Gediminus, and Alexander Tuzhilin.
    “Toward the Next Generation of Recommender Systems: A Survey of the State-of-the-Art
    and Possible Extensions.” *IEEE Transactions on Knowledge and Data Engineering*
    17(6): 734-749.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[Adomavicius and Tuzhilin, 2005] Adomavicius, Gediminus, 和 Alexander Tuzhilin.
    “迈向下一代推荐系统：对现有技术和可能扩展的综述。” *IEEE 知识和数据工程杂志* 17(6): 734-749.'
- en: '[Bazire and Brézillon, 2005] Bazire, Mary, and Patrick Brézillon. “Understanding
    Context Before Using It.” *Proceedings of the 5th International and Interdisciplinary
    Conference on Modeling and Using Contex*t (2005): 29-40.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[巴齐尔和布雷松，2005] 巴齐尔，玛丽，帕特里克·布雷松。 “在使用上下文之前理解上下文。” *第5届国际和跨学科建模与使用上下文会议论文集* (2005):
    29-40。'
- en: '[Burke, 2002] Burke, Robin. “Hybrid Recommender Systems: Survey and Experiments.”
    *User Modeling and User-Adapted Interaction* 12:4 (2002): 331-370.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[伯克，2002] 伯克，罗宾。 “混合推荐系统：调查和实验。” *用户建模与用户自适应交互* 12:4 (2002): 331-370。'
- en: '[Doerfel et al., 2016] Doerfel, Stephan, Robert Jäschke, and Gerd Stumme. “The
    Role of Cores in Recommender Benchmarking for Social Bookmarking Systems.” *ACM
    Transactions on Intelligent Systems and Technology* 7:3 (2016): Article 40.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[多费尔等，2016] 多费尔，斯蒂芬，罗伯特·雅施克，格德·斯特姆。 “在社交书签系统中推荐基准测试中核心的作用。” *ACM智能系统与技术研究*
    7:3 (2016): 文章40。'
- en: '[Frolov and Oseledets, 2016] Frolov, Evgeny, and Ivan Oseledets. “Tensor Methods
    and Recommender Systems.” arXiv preprint arXiv:1603.06038 (2016).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[弗罗洛夫和奥谢列茨，2016] 弗罗洛夫，叶夫根尼，伊万·奥谢列茨。 “张量方法和推荐系统。” arXiv预印本 arXiv:1603.06038
    (2016)。'
- en: '[Ilarri et al., 2018] Ilarri, Sergio, Raquel Trillo-Lado, and Ramon Hermoso.
    “Datasets for Context-Aware Recommender Systems: Current Context and Possible
    Directions.” *Proceedings of the IEEE 34th International Conference on Data Engineering
    Workshops* (2018).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[伊拉里等，2018] 伊拉里，塞戈里奥，拉奎尔·特里略-拉多，拉蒙·赫尔莫索。 “面向上下文感知推荐系统的数据集：当前上下文和可能的方向。” *IEEE第34届国际数据工程研讨会论文集*
    (2018)。'
- en: '[Palmisano et al., 2008] Palmisano, Cosimo, Alexander Tuzhilin, and Michele
    Gorgoglione. “Using Context to Improve Predictive Modeling of Customers in Personalization
    Applications.” *IEEE Transactions on Knowledge and Data Engineering* 20:11 (2008):
    1535-1549.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[帕尔米萨诺等，2008] 帕尔米萨诺，科西莫，亚历山大·图齐林，米歇尔·戈戈利奥内。 “在个性化应用中使用上下文来改进客户预测建模。” *知识数据工程杂志*
    20:11 (2008): 1535-1549。'
- en: '[Panniello et al., 2009] Panniello, Umberto, Alexander Tuzhilin, Michele Gorgoglione,
    Cosimo Palmisano, and Anto Pedone. “Experimental Comparison of Pre- vs. Post-Filtering
    Approaches in Context-Aware Recommender Systems.” *Proceedings of the 3rd ACM
    Conference on Recommender Systems* (2009): 265-268.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[帕尼内洛等，2009] 帕尼内洛，翁贝托，亚历山大·图齐林，米歇尔·戈戈利奥内，科西莫·帕尔米萨诺，安托·佩多内。 “在上下文感知推荐系统中，预先过滤和后过滤方法的实验比较。”
    *第3届ACM推荐系统会议论文集* (2009): 265-268。'
- en: '[Suchman, 1987] Suchman, Lucy. *Plans and Situated Actions*. Cambridge, UK:
    Cambridge University Press, 1987.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[萨奇曼，1987] 萨奇曼，露西。 *计划和情境行动*。 英国剑桥：剑桥大学出版社，1987。'
- en: '[Wu et al., 2015] Wu, Hao, Kun Yue, Xiaoxin Liu, Yijian Pei, and Bo Li. “Context-Aware
    Recommendation via Graph-Based Contextual Modeling and Postfiltering.” *International
    Journal of Distributed Sensor Networks* - Special Issue on Big Data and Knowledge
    Extraction for Cyber-Physical Systems (2015): Article 16.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[吴等，2015] 吴，浩，岳坤，刘晓欣，裴一建，李波。 “基于图上下文建模和后过滤的上下文感知推荐。” *国际分布式传感器网络杂志* - 关于大数据和知识提取的网络安全物理系统特刊
    (2015): 文章16。'
- en: '[Zheng et al., 2015] Zheng, Yong, Bamshad Mobasher, and Robin Burke, “CARSKit:
    A Java-Based Context-Aware Recommendation Engine.” *Proceedings of the 15th IEEE
    International Conference on Data Mining (ICDM) Workshops* (2015): 1668-1671.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[郑等，2015] 郑勇，班沙德·莫巴舍，罗宾·伯克。 “CARSKit：一个基于Java的上下文感知推荐引擎。” *第15届IEEE国际数据挖掘会议（ICDM）研讨会论文集*
    (2015): 1668-1671。'
- en: '* * *'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)[http://mng.bz/D1jE](https://shortener.manning.com/D1jE).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.)[http://mng.bz/D1jE](https://shortener.manning.com/D1jE).
- en: ^(2.)To clean the existing database, you could run MATCH (n) DETACH DELETE n,
    but it could take longer. Another option is to stop the database and purge the
    data directory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^(2.)为了清理现有的数据库，你可以运行MATCH (n) DETACH DELETE n，但这可能需要更长的时间。另一个选择是停止数据库并清除数据目录。
- en: ^(3.)The query can be run after the code finishes creating the k-NN. Here, the
    purpose is to show how to query the model.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^(3.)在代码完成创建k-NN之后可以运行查询。在这里，目的是展示如何查询模型。
- en: '^(4.)A *matrix* is a 2D grid of numbers. A *tensor* is a generalization of
    the concept of matrix that can have any number of dimensions: 0 (a single number),
    1 (a vector), 2 (a traditional matrix), 3 (a cube of numbers), or more. These
    higher-dimensional structures are difficult to visualize. The dimension of a tensor
    is known as its *rank* (aka *order* or *degree*).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^(4.)一个 *矩阵* 是一个二维数字网格。一个 *张量* 是矩阵概念的推广，可以具有任意数量的维度：0（一个单独的数字）、1（一个向量）、2（一个传统矩阵）、3（一个数字立方体）或更多。这些高维结构难以可视化。张量的维度被称为其
    *秩*（也称为 *阶* 或 *度*）。
