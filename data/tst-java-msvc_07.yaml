- en: Chapter 8\. Docker and testing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章\. Docker与测试
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Handling difficulties with high-level tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理高级测试的困难
- en: Understanding how Docker can help you with testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Docker如何帮助你进行测试
- en: Creating reproducible testing environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重复的测试环境
- en: Working with Arquillian Cube
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Arquillian Cube一起工作
- en: A recurring message delivered by this book, and a message most developers would
    agree with, is that a high-level test implies a slower test—and that a huge amount
    of effort is usually required to prepare the test environment in which to run
    it. You encountered this in [chapter 5](kindle_split_014_split_000.xhtml#ch05),
    where you learned that to write an integration test against a database, you need
    an environment with the database you’re going to use in production. The same thing
    happened in [chapter 7](kindle_split_016_split_000.xhtml#ch07), where you saw
    that you might need one or more microservices deployed along with their databases.
    And in the case of a web frontend, you might also need specific browsers installed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书传达的一个反复出现的消息，也是大多数开发者会同意的一个消息，就是高级测试意味着测试速度较慢——并且通常需要大量的努力来准备运行测试的环境。你在[第5章](kindle_split_014_split_000.xhtml#ch05)中遇到了这种情况，你学习了要编写针对数据库的集成测试，你需要一个包含你将在生产中使用的数据库的环境。同样的事情发生在[第7章](kindle_split_016_split_000.xhtml#ch07)中，你看到了你可能需要部署一个或多个微服务及其数据库。对于Web前端，你可能还需要安装特定的浏览器。
- en: 'When you want to test the application’s big picture, you need more pieces in
    your environment to make it run. Here are a few:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想测试应用程序的整体情况时，你需要在你的环境中添加更多组件来使其运行。以下是一些：
- en: Databases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Other microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他微服务
- en: Multiple browsers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个浏览器
- en: Distributed caches
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: The problem is that first, you need to define your test environment; and second,
    you must provide a runtime under which to run this configuration. This probably
    won’t be your development machine, a disadvantage for a developer because you’ll
    lose the possibility of reproducing or debugging any given problem locally. Remote
    debugging, although not impossible, is much more complex.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于首先，你需要定义你的测试环境；其次，你必须提供一个运行时来运行此配置。这很可能不是你的开发机器，这对开发者来说是一个缺点，因为你将失去在本地重现或调试任何给定问题的可能性。远程调试，尽管不是不可能，但更加复杂。
- en: Using Docker can mitigate some of these issues. Docker lets developers run test
    environments on their local machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker可以缓解这些问题。Docker允许开发者在其本地机器上运行测试环境。
- en: 8.1\. Tools in the Docker ecosystem
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. Docker生态系统中的工具
- en: The Docker ecosystem includes several tools such as Docker Compose, Docker Machine,
    and libraries that integrate with the ecosystem, such as Arquillian Cube. This
    section presents an overview of some of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统包括几个工具，如Docker Compose、Docker Machine以及与生态系统集成的库，如Arquillian Cube。本节介绍了其中的一些概述。
- en: 8.1.1\. Docker
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. Docker
- en: Docker is an open source platform that simplifies the creation, deployment,
    and running of applications in *containers*. Imagine a container as being like
    a box where you deploy an application along with all the dependencies it needs,
    neatly packaged. In packaging the application this way, you can ensure that the
    application will run in a well-defined environment (one provided by the container),
    regardless of the underlying operating system. This enables you to move containers
    from one machine to another—for example, from a developer machine to a production
    machine—without worrying about the external configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker是一个开源平台，它简化了在*容器*中创建、部署和运行应用程序的过程。想象一下，容器就像一个盒子，你可以在其中部署一个应用程序以及它需要的所有依赖项，整洁地打包。以这种方式打包应用程序，你可以确保应用程序将在一个定义良好的环境中运行（由容器提供），而不管底层操作系统是什么。这使得你可以将容器从一个机器移动到另一个机器——例如，从开发机器到生产机器——而不用担心外部配置。 '
- en: You can think of Docker as a virtual machine, but without the need to install
    and set up the entire OS yourself. Docker reuses the same Linux kernel regardless
    of where the container is actually running. This approach gives your startup time
    a significant performance boost and reduces the size of the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Docker想象成一个虚拟机，但不需要你自己安装和设置整个操作系统。Docker无论容器实际在哪里运行，都重新使用相同的Linux内核。这种方法给你的启动时间带来了显著的性能提升，并减少了应用程序的大小。
- en: '[Figure 8.1](kindle_split_017_split_001.xhtml#ch08fig01) shows a comparison
    between a VM and a Docker container. The primary difference is that instead of
    having a guest OS for each application, a container runs atop a machine OS.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.1](kindle_split_017_split_001.xhtml#ch08fig01)显示了虚拟机与Docker容器的比较。主要区别在于，每个应用程序不需要一个客户操作系统，容器是在机器操作系统之上运行的。'
- en: Figure 8.1\. Virtual machine vs. container
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 虚拟机与容器的比较
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: 'To run Docker containers, you need at least three components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Docker容器，您至少需要三个组件：
- en: '*Docker client*—A command-line interface (CLI) program that sends commands
    from the user to a host where the Docker daemon is installed/running.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker client*—一个命令行界面（CLI）程序，将用户的命令发送到安装/运行Docker守护进程的主机。'
- en: '*Docker daemon*—A program that runs on the host OS and performs all major operations
    such as building, shipping, and running Docker containers. During the development
    and testing phases, the Docker daemon and the Docker client are probably running
    in the same machine.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker daemon*—一个在主机操作系统上运行的程序，执行所有主要操作，如构建、运输和运行Docker容器。在开发和测试阶段，Docker守护进程和Docker客户端可能运行在同一台机器上。'
- en: '*Docker registry*—An artifact repository for sharing Docker images. There’s
    a public Docker registry at [http://hub.docker.com](http://hub.docker.com).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker registry*—一个用于共享Docker镜像的工件存储库。在[http://hub.docker.com](http://hub.docker.com)有一个公共Docker注册库。'
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The difference between an image and a container is that an *image* is all the
    bits and bobs, such as the application and configuration parameters. It doesn’t
    have state and never changes. On the other hand, a *container* is a running instance
    of an image on the Docker daemon.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像和容器的区别在于，*镜像*包含了所有组件，如应用程序和配置参数。它没有状态且永远不会改变。另一方面，*容器*是Docker守护进程上运行的镜像的运行实例。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 8.2](kindle_split_017_split_001.xhtml#ch08fig02) shows the schema of
    the Docker architecture. The Docker client communicates with the Docker daemon/host
    to execute commands. If a required Docker image isn’t present on the host, it’s
    downloaded from the Docker registry. Finally, the Docker host instantiates a new
    container from a given image.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.2](kindle_split_017_split_001.xhtml#ch08fig02)显示了Docker架构的方案。Docker客户端与Docker守护进程/主机通信以执行命令。如果主机上没有所需的Docker镜像，它将从Docker注册库下载。最后，Docker主机从给定的镜像实例化一个新的容器。'
- en: Figure 8.2\. Docker architectural schema
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. Docker架构方案
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig02_alt.jpg)'
- en: 'Using the Docker client to retrieve an image from the Docker registry and running
    it on the Docker host might look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker客户端从Docker注册库检索镜像并在Docker主机上运行可能如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Pulls (downloads) the image from the Docker registry to the Docker host**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从Docker注册库将镜像拉取（下载）到Docker主机**'
- en: '***2* Starts the JBoss/WildFly container on the Docker host**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在Docker主机上启动JBoss/WildFly容器**'
- en: After executing the preceding commands, you can navigate in your browser to
    http://<dockerHostIp>;:8080, where you should see the WildFly server Welcome page
    shown in [figure 8.3](kindle_split_017_split_001.xhtml#ch08fig03).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，您可以在浏览器中导航到http://<dockerHostIp>:8080，在那里您应该看到[图8.3](kindle_split_017_split_001.xhtml#ch08fig03)中显示的WildFly服务器欢迎页面。
- en: Figure 8.3\. Welcome to WildFly
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 欢迎使用WildFly
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03_alt.jpg)'
- en: Now that you understand the Docker essentials, let’s look at a Docker tool called
    *Docker Machine*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Docker的基本知识，让我们看看一个名为*Docker Machine*的Docker工具。
- en: 8.1.2\. Docker Machine
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. Docker Machine
- en: '*Docker Machine* helps you to create Docker hosts on virtualization platforms
    like VirtualBox and VMware. It also supports most popular infrastructure as a
    service (IaaS) platforms, such as Amazon Web Services (AWS), Azure, DigitalOcean,
    OpenStack, and Google Compute Engine. In addition to installing Docker on given
    hosts, it also configures a Docker client to communicate with them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Machine*帮助您在VirtualBox和VMware等虚拟化平台上创建Docker主机。它还支持大多数流行的基础设施即服务（IaaS）平台，如亚马逊网络服务（AWS）、Azure、DigitalOcean、OpenStack和谷歌计算引擎。除了在指定主机上安装Docker外，它还配置Docker客户端以与它们通信。'
- en: Usually, the virtualization approach with VirtualBox is the best way to go on
    development machines. Note that in this case you need to have VirtualBox installed,
    because Docker Machine doesn’t perform this installation step.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在开发机器上使用VirtualBox的虚拟化方法是最佳选择。请注意，在这种情况下，您需要安装VirtualBox，因为Docker Machine不会执行此安装步骤。
- en: 'To create a VirtualBox image with Docker installed, run the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建安装了 Docker 的 VirtualBox 镜像，请运行以下命令：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After some time, everything will be installed and ready to be used on your
    local machine. The final steps are to begin creating the VirtualBox image and
    configure the client to point to the instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，所有内容都将安装并准备好在本地机器上使用。最后的步骤是开始创建 VirtualBox 镜像，并配置客户端指向该实例：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Starts the host named dev**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 启动名为 dev 的主机**'
- en: '***2* Configures the Docker client environment variables**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置 Docker 客户端环境变量**'
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Docker on a local machine**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地机器上的 Docker**'
- en: If you want to use Docker Machine on a local machine, the best way to get started
    is to use Docker Toolbox. It’s available for both Windows and macOS.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在本地机器上使用 Docker Machine，最佳入门方式是使用 Docker Toolbox。它适用于 Windows 和 macOS 系统。
- en: 'Docker Machine has an installer that installs the following tools:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine 有一个安装程序，它安装以下工具：
- en: Docker client
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 客户端
- en: Docker Machine
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Machine
- en: Docker Compose
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Oracle VirtualBox
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle VirtualBox
- en: Kitematic (Docker GUI) and a preconfigured shell
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kitematic (Docker GUI) 和预配置的 shell
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1.3\. Docker Compose
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. Docker Compose
- en: '*Docker Compose* is a multi-container-management tool composed of two elements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Compose* 是一个由两个元素组成的容器多管理工具：'
- en: A format in YAML describing one or more containers that work together to form
    the application. It also specifies how containers interact with each other, as
    well as some other information such as networks, volumes, and ports.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 YAML 格式，描述了一个或多个容器，它们协同工作以形成应用程序。它还指定了容器如何相互交互，以及一些其他信息，如网络、卷和端口。
- en: A CLI tool to read a Docker Compose file and create the application defined
    by the file.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 CLI 工具，用于读取 Docker Compose 文件并创建由文件定义的应用程序。
- en: By default, any Docker Compose file is appropriately named docker-compose.yml.
    A simple docker-compose.yml file might look like the following.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何 Docker Compose 文件都应命名为 docker-compose.yml。一个简单的 docker-compose.yml
    文件可能看起来像以下这样。
- en: Listing 8.1\. docker-compose.yml
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. docker-compose.yml
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Defines a container name**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义了一个容器名称**'
- en: '***2* Sets the image to be used**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置要使用的镜像**'
- en: '***3* Defines a binding/exposed ports pair**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义了一对绑定/暴露端口**'
- en: '***4* Defines a link between containers of the form [service-name:alias]**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定义了容器之间的链接，形式为 [service-name:alias]**'
- en: 'When you run `docker-compose up` from the terminal on the file in [listing
    8.1](kindle_split_017_split_001.xhtml#ch08ex01), two containers are started: *tomcat*
    and *pingpong*. They’re connected with a `link` named *pingpong*. And port 8081
    for the Tomcat service is exposed to clients of the Docker host, forwarding all
    traffic to the internal container port 8080\. The containers are reachable at
    a hostname identical to the alias or service name, if no alias is specified.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [列表 8.1](kindle_split_017_split_001.xhtml#ch08ex01) 中的文件上从终端运行 `docker-compose
    up` 时，将启动两个容器：*tomcat* 和 *pingpong*。它们通过名为 *pingpong* 的 `link` 连接在一起。Tomcat 服务的端口
    8081 对 Docker 主机的客户端暴露，将所有流量转发到内部容器端口 8080。如果未指定别名，容器可以通过与别名或服务名称相同的主机名访问。
- en: One of the best testing-related aspects of Docker Compose is the extension feature.
    It enables you to share common configuration snippets between different files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 最好的测试相关特性之一是扩展功能。它允许你在不同的文件之间共享常见的配置片段。
- en: Let’s look at an example of a Docker Compose file using the `extend` keyword.
    You should first define the common or abstract container definition that other
    containers may extend in a Docker Compose file, which, by default, should *not*
    be named docker-compose.yml. You should strive to follow the naming convention
    that the file called docker-compose.yml is the *only* file that will be used by
    the running system, so to that end let’s name this file common.yml.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `extend` 关键字的 Docker Compose 文件的一个示例。你应该首先在 Docker Compose 文件中定义一个常见的或抽象的容器定义，其他容器可以扩展它，默认情况下，该文件不应命名为
    docker-compose.yml。你应该努力遵循命名约定，即名为 docker-compose.yml 的文件是运行系统将使用的 *唯一* 文件，因此让我们将此文件命名为
    common.yml。
- en: Listing 8.2\. common.yml
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. common.yml
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There’s nothing new here beyond the previous definition, other than defining
    a new service called `webapp`. Now, let’s define the docker-compose.yml file to
    use common.yml, and set new parameters for the service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有比之前定义的新内容，只是定义了一个名为 `webapp` 的新服务。现在，让我们定义 docker-compose.yml 文件以使用 common.yml，并为该服务设置新的参数。
- en: Listing 8.3\. docker-compose.yml
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. docker-compose.yml
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Starts an extension section**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 开始一个扩展部分**'
- en: '***2* Sets the location of the extendible file**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置可扩展文件的存储位置**'
- en: '***3* Sets the element to extend**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置要扩展的元素**'
- en: '***4* Sets/Overrides a property**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置/覆盖属性**'
- en: 'You can run `docker-compose` in a terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端中运行 `docker-compose`：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, using Docker and Docker Compose, you can readily define testing
    environments that can be used on any machine where tests need to run. The two
    main advantages of using these tools together are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Docker 和 Docker Compose，你可以轻松定义可以在任何需要运行测试的机器上使用的测试环境。使用这些工具结合的两个主要优势如下：
- en: 'Every environment that runs tests contains exactly the same versions of the
    required libraries, dependencies, and/or servers. It doesn’t matter which physical
    machines are run: it could be the development, testing, or preproduction machine.
    All of them contain the same running bits and bobs.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个运行测试的环境都包含所需库、依赖项和/或服务器的确切版本。无论运行在哪些物理机器上：可能是开发、测试或预生产机器。它们都包含相同的运行组件。
- en: You don’t need to install anything on testing machines other than Docker. Everything
    else is resolved at runtime.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 Docker 之外，你不需要在测试机器上安装任何东西。其他所有内容都在运行时解决。
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter provides a very basic introduction to Docker Compose, and we encourage
    you to learn more at [https://docs.docker.com/compose](https://docs.docker.com/compose).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一个关于 Docker Compose 的非常基本的介绍，我们鼓励你到 [https://docs.docker.com/compose](https://docs.docker.com/compose)
    学习更多。
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.2\. Arquillian Cube
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. Arquillian Cube
- en: So far, you’ve read that Docker and Docker Compose make a perfect pair for testing.
    They should help you define reliable and reproducible testing environments, so
    that each time you execute tests, you know the same environment is set up correctly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解到 Docker 和 Docker Compose 是测试的理想搭档。它们应该帮助你定义可靠且可重复的测试环境，这样每次执行测试时，你都知道环境已经正确设置。
- en: The problem is that you need to manually run `docker-compose up` or add a step
    to the build tool in order to fire it up before executing the tests. You also
    need to deal with the Docker host IP address, which may be `localhost`—but not
    necessarily, because it may be a Docker machine or a remote Docker host.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你需要手动运行 `docker-compose up` 或在构建工具中添加一个步骤来启动它，然后再执行测试。你还需要处理 Docker 主机 IP
    地址，它可能是 `localhost`——但并不一定是，因为它可能是一个 Docker 机器或远程 Docker 主机。
- en: 'Although starting Docker Compose manually could be a good approach, our opinion
    is that tests should be self-executing as much as possible and not require manual
    intervention or complicated runtimes. You’ve guessed it: there’s a cool Arquillian
    extension that will help you achieve your goals. *Arquillian Cube* is an extension
    that can be used to manage Docker containers from within an Arquillian test. It
    uses an approach similar to what Arquillian Core does for application servers,
    but modified for Docker containers. Arquillian Cube can be used in the following
    scenarios:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动启动 Docker Compose 可能是一个好的方法，但我们的观点是测试应该尽可能地自我执行，而不需要人工干预或复杂的运行时。你已经猜到了：有一个酷炫的
    Arquillian 扩展可以帮助你实现目标。*Arquillian Cube* 是一个扩展，可以在 Arquillian 测试中管理 Docker 容器。它使用的方法类似于
    Arquillian Core 用于应用服务器的方法，但进行了修改以适应 Docker 容器。Arquillian Cube 可以用于以下场景：
- en: Preparing testing environments for high-level tests
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备高级测试的测试环境
- en: Testing Dockerfile compositions
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Dockerfile 组合
- en: Validating Docker Compose compositions
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 Docker Compose 组合
- en: White box and black box testing
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白盒和黑盒测试
- en: As you can see in [figure 8.4](kindle_split_017_split_002.xhtml#ch08fig04),
    before executing tests, Arquillian Cube reads a Docker Compose file and starts
    all the containers in the correct order. Arquillian then waits until all the services
    are up and running so they’re able to receive incoming connections. After that,
    tests are executed with the test environment running. Following execution, all
    running containers are stopped and removed from the Docker host.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 8.4](kindle_split_017_split_002.xhtml#ch08fig04) 所示，在执行测试之前，Arquillian
    Cube 读取 Docker Compose 文件并按正确顺序启动所有容器。然后 Arquillian 等待直到所有服务都启动并运行，以便它们能够接收传入的连接。之后，在测试环境中执行测试。执行完成后，所有正在运行的容器都会停止并被从
    Docker 主机中移除。
- en: Figure 8.4\. Arquillian Cube lifecycle
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. Arquillian Cube 生命周期
- en: '![](Images/08fig04_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04_alt.jpg)'
- en: With Arquillian Cube, your Docker-based tests are fully automated. You can define
    your testing environment in the Docker Compose format, and the Arquillian runner
    takes care of everything for you. This again leaves you, the developer, free to
    write the actual tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Arquillian Cube，您的基于 Docker 的测试将完全自动化。您可以使用 Docker Compose 格式定义您的测试环境，Arquillian
    运行器将为您处理所有事情。这再次让您，作为开发者，有更多时间编写实际的测试。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It isn’t necessary to use Docker for production. You can also just take advantage
    of Docker to prepare a valid testing environment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 并非必须使用 Docker 进行生产。您也可以仅利用 Docker 准备一个有效的测试环境。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When using Docker in production, you can use Arquillian Cube to write tests
    that validate that your container image is created correctly or, for example,
    that the container is bootable and is accessible from outside of the Docker host.
    Obviously, in production, you can use a Docker Compose file that’s almost, if
    not the same as, the one used to create the testing environment, and validate
    that all containers defined can communicate between each other and that environment
    variables are correctly set.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当在生产环境中使用 Docker 时，您可以使用 Arquillian Cube 编写测试来验证您的容器镜像是否正确创建，或者例如，容器是否可启动并且可以从
    Docker 主机外部访问。显然，在生产环境中，您可以使用几乎与创建测试环境相同的 Docker Compose 文件，并验证所有定义的容器是否可以相互通信以及环境变量是否设置正确。
- en: The potential use is unbounded, as there are an endless number of ways to use
    Arquillian Cube and Docker together for testing. We’ll cover the most common use
    cases in the following sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其潜在用途是无限的，因为使用 Arquillian Cube 和 Docker 进行测试的方法有无数种。我们将在以下章节中介绍最常见的使用案例。
- en: 8.2.1\. Setting up Arquillian Cube
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 设置 Arquillian Cube
- en: Arquillian Cube requires that you set up several parameters. It uses some default
    parameters that *may* work in most situations and others that are intelligently
    deduced from the environment. Sometimes you may need to modify these automatically
    defined parameters. [Table 8.1](kindle_split_017_split_002.xhtml#ch08table01)
    describes the most important configuration attributes that can be set in an arquillian.xml
    file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube 需要您设置几个参数。它使用一些默认参数，这些参数*可能*在大多数情况下都适用，还有一些参数是智能地从环境中推断出来的。有时您可能需要修改这些自动定义的参数。[表
    8.1](kindle_split_017_split_002.xhtml#ch08table01) 描述了可以在 arquillian.xml 文件中设置的最重要的配置属性。
- en: Table 8.1\. Arquillian Cube parameters
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1\. Arquillian Cube 参数
- en: '| Attribute | Description | Default behavior |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 默认行为 |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| serverUri | URI of the Docker host where containers will be instantiated.
    | Gets the value from the environment variable DOCKER_HOST if set; otherwise,
    for Linux it’s set to unix:///var/run/docker.sock, and on Windows and macOS it’s
    set to https://<docker_host_ip>;:2376. docker_host_ip is resolved automatically
    by Arquillian Cube by obtaining the boot2docker or docker machine IP. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| serverUri | 容器将要实例化的 Docker 主机的 URI。 | 如果设置了环境变量 DOCKER_HOST，则获取其值；否则，对于
    Linux，它设置为 unix:///var/run/docker.sock，而在 Windows 和 macOS 上设置为 https://<docker_host_ip>;:2376。docker_host_ip
    由 Arquillian Cube 自动解析，通过获取 boot2docker 或 docker machine IP。 |'
- en: '| dockerRegistry | Sets the location of the Docker registry from which to download
    images. | By default, this is the public Docker registry at [https://registry.hub.docker.com](https://registry.hub.docker.com).
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| dockerRegistry | 设置从其中下载镜像的 Docker 仓库的位置。 | 默认情况下，这是公共 Docker 仓库 [https://registry.hub.docker.com](https://registry.hub.docker.com)。
    |'
- en: '| username | Sets the username to connect to the Docker registry. (You’ll need
    an account.) |   |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | 设置连接到 Docker 仓库的用户名。（您需要一个账户。） |   |'
- en: '| password | Sets the password to connect to the Docker registry. (You’ll need
    an account.) |   |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 密码 | 设置连接到 Docker 仓库的密码。（您需要一个账户。） |   |'
- en: '| dockerContainers | Embeds the Docker Compose content as an Arquillian property,
    instead of as a Docker Compose file. |   |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| dockerContainers | 将 Docker Compose 内容作为 Arquillian 属性嵌入，而不是作为 Docker Compose
    文件。 |   |'
- en: '| dockerContainersFile | Sets the location of the Docker Compose file. The
    location is relative to the root of the project; but it can also be a URI that’s
    converted to a URL, so you can effectively have Docker Compose definitions on
    remote sites. |   |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| dockerContainersFile | 设置 Docker Compose 文件的位置。位置相对于项目根目录；但也可以是一个 URI，它将被转换为
    URL，因此您可以在远程站点上有效地拥有 Docker Compose 定义。 |   |'
- en: '| dockerContainersFiles | Sets a comma-separated list of Docker Compose file
    locations. Internally, all of these locations are appended into one. |   |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| dockerContainersFiles | 设置逗号分隔的 Docker Compose 文件位置列表。内部，所有这些位置都被追加到一个文件中。
    |   |'
- en: '| tlsVerify | Boolean to set if Arquillian Cube should connect to the Docker
    server with Transport Layer Security (TLS). | Gets the value from the TLS_VERIFY
    environment variable if set; otherwise, it’s automatically sets to false if the
    serverUri scheme is http or true if it’s https. You can force a value by setting
    this property. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| tlsVerify | 设置 Arquillian Cube 是否应使用传输层安全性 (TLS) 连接到 Docker 服务器的一个布尔值。 |
    如果设置了 TLS_VERIFY 环境变量，则获取该值；否则，如果服务器 Uri 方案是 http，则自动设置为 false；如果是 https，则设置为
    true。您可以通过设置此属性来强制设置一个值。 |'
- en: '| certPath | Path where certificates are stored if you’re using HTTPS. | Gets
    the value from the DOCKER_CERT_PATH environment variable if set; otherwise, the
    location is resolved from boot2docker or docker-machine. You can force a value
    by setting this property. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| certPath | 如果您使用 HTTPS，则证书存储的路径。 | 如果设置了 DOCKER_CERT_PATH 环境变量，则获取该值；否则，从
    boot2docker 或 docker-machine 解析位置。您可以通过设置此属性来强制设置一个值。 |'
- en: '| machineName | Sets the machine name if you’re using Docker Machine to manage
    your Docker host. | Gets the value from the DOCKER_MACHINE_NAME environment variable
    if set; otherwise, the machine name is resolved automatically if in the current
    Docker machine instance only one machine is running. You can force a value by
    setting this property. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| machineName | 如果您使用 Docker Machine 来管理您的 Docker 主机，则设置机器名称。 | 如果设置了 DOCKER_MACHINE_NAME
    环境变量，则获取该值；否则，如果当前 Docker 机器实例中只有一个机器正在运行，则自动解析机器名称。您可以通过设置此属性来强制设置一个值。 |'
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that the arquillian.xml configuration attributes can be configured
    using system properties or environment variables by using `${system_property}`
    placeholders or `${env.environment_variable}` placeholders.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，可以使用 `${system_property}` 占位符或 `${env.environment_variable}` 占位符通过系统属性或环境变量来配置
    arquillian.xml 配置属性。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Arquillian Cube connection modes**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arquillian Cube 连接模式**'
- en: The test environment is started and stopped for each test suite. This means
    that, depending on the elements’ boot-up time, testing time may be affected, especially
    with small test suites.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境会为每个测试套件启动和停止。这意味着，根据元素的启动时间，测试时间可能会受到影响，尤其是在小型测试套件中。
- en: With Arquillian Cube, you have the option to bypass the creation/start of Docker
    containers that are already running on a Docker host with the same container name.
    This allows you to prestart the containers (for example, in the continuous integration
    [CI] build script, or before starting work) and connect to them to avoid the extra
    cost during test execution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Arquillian Cube，您可以选择绕过在具有相同容器名称的 Docker 主机上已运行的 Docker 容器的创建/启动。这允许您预先启动容器（例如，在持续集成
    [CI] 构建脚本中或在工作开始之前），并连接到它们以避免测试执行期间的额外开销。
- en: 'Here’s an example of how to configure the `connectionMode` property:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何配置 `connectionMode` 属性的示例：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can set the following modes for this property:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为该属性设置以下模式：
- en: '`STARTANDSTOP`—The default, if not specified. Creates and stops all Docker
    containers.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTANDSTOP`—默认模式，如果没有指定。创建并停止所有 Docker 容器。'
- en: '`STARTORCONNECT`—Bypasses the creation/start steps if a container with the
    same container name is already running and this named container isn’t to be terminated
    after the tests complete. If the container configured for Cube is not already
    running, then Arquillian will start it *and stop it* at the end of the execution,
    behaving much like the `STARTANDSTOP` mode.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTORCONNECT`—如果已运行具有相同容器名称的容器且该容器在测试完成后不会被终止，则绕过创建/启动步骤。如果为 Cube 配置的容器尚未运行，则
    Arquillian 将在执行结束时启动它*并停止它*，其行为类似于 `STARTANDSTOP` 模式。'
- en: '`STARTORCONNECTANDLEAVE`—Exactly the same as `STARTORCONNECT` mode; but if
    a container is started by Arquillian Cube, then it *won’t be stopped* at the end
    of the execution, so it can be reused in the next cycle.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTORCONNECTANDLEAVE`—与 `STARTORCONNECT` 模式完全相同；但如果容器是由 Arquillian Cube
    启动的，则在执行结束时它*不会停止*，因此可以在下一个周期中重用。'
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you’re familiar with the common configuration parameters in Arquillian
    Cube, let’s explore how to write tests using it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经熟悉了 Arquillian Cube 中的常见配置参数，让我们来探索如何使用它编写测试。
- en: 8.2.2\. Writing container tests
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 编写容器测试
- en: 'The first use case we’ll cover for Arquillian Cube is validating that the Dockerfile
    defined in the service to containerize the application is correct. Although you
    can perform several checks, the most common ones are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Arquillian Cube 覆盖的第一个用例是验证服务中定义的 Dockerfile 是否正确用于将应用程序容器化。尽管您可以执行多个检查，但最常见的是以下内容：
- en: Docker is able to build the image without any errors.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker能够无错误地构建镜像。
- en: The service exposes the correct ports.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务暴露了正确的端口。
- en: The service is started correctly and can correctly serve incoming requests.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务已正确启动并且可以正确地服务传入的请求。
- en: Let’s start by configuring Docker in arquillian.xml, and then create a minimal
    script to build and run the image under test.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在arquillian.xml中配置Docker，然后创建一个最小化的脚本，用于构建和运行测试中的镜像。
- en: Listing 8.4\. Configuring Docker
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 配置Docker
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* This line is required only if you’re using Docker Machine.**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只有在使用Docker Machine时才需要这一行。**'
- en: '***2* Defines in Docker Compose format how to build and run the image**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在Docker Compose格式中定义如何构建和运行镜像**'
- en: 'When you’re using Docker Machine with more than one machine running, the machine
    named `dev` is used for building and running the Docker container under test.
    Then, with the `dockerContainers` property, you embed a Docker Compose container
    definition to build an image from an expected Dockerfile located in the docker
    directory and exposing port 8080\. As mentioned earlier, Dockerfile is the default
    filename for a Docker definition. The Dockerfile may look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Docker Machine并且有多个机器运行时，名为`dev`的机器用于构建和运行测试中的Docker容器。然后，使用`dockerContainers`属性，你嵌入一个Docker
    Compose容器定义，从位于docker目录中的预期Dockerfile构建镜像，并暴露端口8080。如前所述，Dockerfile是Docker定义的默认文件名。Dockerfile可能看起来像以下这样：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The image defined here is based on the Apache TomEE `tomee:8-jdk-7.0.1-webprofile`
    Docker image. The `ADD` command adds your project-deployment WAR file to the specified
    image path—the TomEE hot deployment path in this image is /usr/local/tomee/webapps/,
    so adding a WAR file here will automatically deploy the application. Finally,
    the `EXPOSE` command exposes the TomEE HTTP port 8080 to the outside world.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的镜像基于Apache TomEE `tomee:8-jdk-7.0.1-webprofile` Docker镜像。`ADD`命令将你的项目部署WAR文件添加到指定的镜像路径——在这个镜像中，TomEE热部署路径是/usr/local/tomee/webapps/，因此在这里添加WAR文件将自动部署应用程序。最后，`EXPOSE`命令将TomEE
    HTTP端口8080暴露给外部世界。
- en: Using this information, you can write a test to validate that the image is correctly
    built, exposes the correct port, and runs correctly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，你可以编写一个测试来验证镜像是否正确构建，是否暴露了正确的端口，并且运行正确。
- en: Listing 8.5\. Validating the image
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 验证镜像
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Arquillian runner**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Arquillian运行器**'
- en: '***2* The test is enriched with a Docker client to access the Docker host.**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 测试中增加了Docker客户端以访问Docker主机。**'
- en: '***3* The test is enriched with the Docker host IP.**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 测试中增加了Docker主机IP。**'
- en: '***4* Gets the binding port for exposed port 8080 of the container myservice**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取容器myservice暴露的端口8080的绑定端口**'
- en: '***5* Asserts that the built image is exposing port 8080**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 断言构建的镜像正在暴露端口8080**'
- en: '***6* Asserts that the container is running**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 断言容器正在运行**'
- en: '***7* Asserts that the healthCheck endpoint returns that the service is up
    and running**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 断言健康检查端点返回服务正在运行和运行中**'
- en: 'There are several things to note about this test. First, you apply the Arquillian
    runner, but without a `@Deployment` method. This is because these tests don’t
    need to deploy anything in an application server: the container image receives
    the deployment file required to run the test, and the server is already running.
    You’re effectively using all the elements provided by Arquillian but without deploying
    anything.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个测试有几个需要注意的点。首先，你应用了Arquillian运行器，但没有`@Deployment`方法。这是因为这些测试不需要在应用服务器中部署任何内容：容器镜像接收运行测试所需的部署文件，服务器已经启动。你实际上是在使用Arquillian提供的所有元素，但没有部署任何内容。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Any test without a `@Deployment` annotated method must be used with either the
    `arquillian-junit-standalone` or `arquillian-testng-standalone` dependency, instead
    of the `container` dependency. All tests are run in the as-client mode, because
    they can’t be deployed into an application server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 任何没有使用`@Deployment`注解方法的测试都必须使用`arquillian-junit-standalone`或`arquillian-testng-standalone`依赖项，而不是`container`依赖项。所有测试都在as-client模式下运行，因为它们不能部署到应用服务器。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The second thing to note is that Arquillian Cube offers some enrichers for tests.
    In this test, the `DockerClient` object is injected. This object offers you some
    powerful operations to communicate with the Docker host and get information about
    running containers. Moreover, the test is enriched with the Docker host IP or
    hostname in the `dockerHost` variable. The binding port for the container’s exposed
    port 8080 is also injected as the `myservicePort` variable. These variables provide
    information that allows the test to communicate with the TomEE server and the
    hosted application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要注意的是，Arquillian Cube 为测试提供了一些增强器。在这个测试中，注入了 `DockerClient` 对象。这个对象为你提供了一些强大的操作，用于与
    Docker 主机通信并获取正在运行的容器的信息。此外，测试通过 `dockerHost` 变量增强了 Docker 主机 IP 或主机名。容器暴露的端口
    8080 的绑定端口也作为 `myservicePort` 变量注入。这些变量提供了允许测试与 TomEE 服务器和托管应用程序通信的信息。
- en: Last but not least are the test methods to verify that the Dockerfile is correctly
    configured, the build is correct, and the service it’s exposing is correctly deployed.
    Arquillian Cube provides custom AssertJ assertions. So, for example, you can write
    assertions to assert that a specific Docker image is instantiated in the Docker
    host, or a port is exposed, or a specific process is running as expected.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，测试方法用于验证 Dockerfile 是否正确配置，构建是否正确，以及它所暴露的服务是否正确部署。Arquillian Cube
    提供了自定义 AssertJ 断言。例如，你可以编写断言来断言在 Docker 主机中实例化了特定的 Docker 镜像，或者端口已暴露，或者特定进程按预期运行。
- en: If the construction defined by the Dockerfile fails, Arquillian Cube throws
    an exception, causing the test to fail. A health check of the endpoint for the
    deployed service is used to verify that the microservice deployed in the Docker
    container is operating correctly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由 Dockerfile 定义的构建失败，Arquillian Cube 会抛出异常，导致测试失败。使用部署服务的端点健康检查来验证在 Docker
    容器中部署的微服务是否正常运行。
- en: After test execution, Arquillian Cube removes the built image from the Docker
    host. This ensures that disk space doesn’t increase every time you run a test,
    and also makes sure each test is run in isolation from the next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行后，Arquillian Cube 会从 Docker 主机中删除构建的镜像。这确保了每次运行测试时磁盘空间不会增加，并且确保每个测试都是独立于下一个测试运行的。
- en: Next, let’s examine how you can use Arquillian Cube to test more-complex scenarios
    like integration tests.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 Arquillian Cube 来测试更复杂的场景，如集成测试。
- en: 8.2.3\. Writing integration tests
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3. 编写集成测试
- en: You learned in [chapter 5](kindle_split_014_split_000.xhtml#ch05) that it’s
    possible to validate the connection between two systems, such as the communication
    between a microservice and a database (such as SQL or NoSQL), or between two microservices.
    In such cases, it’s normal to test your gateway code against any real system that
    you’re going to use in production. This is a big difference when compared to *component
    tests*, where stubs or fakes are usually used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 5 章](kindle_split_014_split_000.xhtml#ch05)中了解到，验证两个系统之间的连接是可能的，例如微服务与数据库（如
    SQL 或 NoSQL）之间的通信，或者两个微服务之间的通信。在这种情况下，测试你的网关代码针对任何你将在生产中使用的真实系统是很正常的。与通常使用存根或模拟的
    *组件测试* 相比，这是一个很大的不同。
- en: The single biggest challenge for integration tests is how to consistently set
    up the environment to run these tests. For example, you’ll probably need the same
    databases you’re using in production on both the developer and CI machines. You
    may also need a way to deploy all dependent microservices for the actual microservice
    under test. In addition, ensuring that versions are maintained across all environments
    and machines isn’t a trivial task. Prior to Docker, this kind of setup wasn’t
    easy to realize without having everything in place on all machines.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的最大挑战是如何一致地设置环境来运行这些测试。例如，你可能需要在开发人员和 CI 机器上使用与生产中相同的数据库。你可能还需要一种方法来部署实际测试的微服务的所有依赖微服务。此外，确保所有环境中机器的版本保持一致并不是一个简单任务。在
    Docker 之前，这种设置没有所有机器上的所有内容就很难实现。
- en: You’ve seen that Docker and Docker Compose can help you prepare a consistent
    environment for testing, and how Arquillian Cube can help automate the process.
    In this section, we’ll look at an example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 Docker 和 Docker Compose 可以帮助你为测试准备一个一致的环境，以及 Arquillian Cube 如何帮助自动化这个过程。在本节中，我们将查看一个示例。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Arquillian deployment and Docker**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arquillian 部署和 Docker**'
- en: 'As we said in [chapter 4](kindle_split_013_split_000.xhtml#ch04), Arquillian
    has three ways to manage an application server:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 4 章](kindle_split_013_split_000.xhtml#ch04)中所述，Arquillian 有三种方式来管理应用服务器：
- en: '*Embedded*—The application server shares the same JVM and classpath with the
    test runtime (IDE, build tool, and so on).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入式*—应用服务器与测试运行时（IDE、构建工具等）共享相同的 JVM 和类路径。'
- en: '*Managed*—The application server is booted up independently of the test runtime.
    It effectively creates a new JVM, independent of the actual test JVM.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理*—应用服务器独立于测试运行时启动。它实际上创建了一个新的 JVM，与实际的测试 JVM 无关。'
- en: '*Remote*—Arquillian doesn’t manage the lifecycle of the application server.
    It expects to reuse an instance that’s already up and running.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远程*—Arquillian 不管理应用服务器的生命周期。它期望重用已经启动并运行的实例。'
- en: With this in mind, you can use Arquillian to deploy your (micro)deployment file
    in an application server that it’s running in a Docker container. From an Arquillian
    point of view, this application server instance is a remote instance where the
    lifecycle is managed by another party (in this case, Docker).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，你可以使用 Arquillian 将你的（微）部署文件部署到运行在 Docker 容器中的应用服务器中。从 Arquillian 的角度来看，这个应用服务器实例是一个远程实例，其生命周期由第三方（在这种情况下，Docker）管理。
- en: Think back to the fact that the runtime adapter in the classpath is how Arquillian
    knows how to manage the application-server lifecycle. For example, in the case
    of Apache Tomcat, for remote mode you need to define the `org.jboss.arquillian.container:arquillian-tomcat-remote-7:1.0.0.CR7`
    dependency.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，类路径中的运行时适配器是 Arquillian 知道如何管理应用服务器生命周期的方式。例如，在 Apache Tomcat 的情况下，对于远程模式，您需要定义
    `org.jboss.arquillian.container:arquillian-tomcat-remote-7:1.0.0.CR7` 依赖项。
- en: As you can see, it’s possible to take advantage of (micro)deployment and use
    Docker to set up (part of) the environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可以利用（微）部署并使用 Docker 来设置（部分）环境。
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s create an integration test using Arquillian Cube, to test the integration
    between a service and its database. You’ll use a microdeployment approach to package
    the classes related to the persistence layer. In order to add to the previous
    Docker Compose file format, make sure to use Docker compose format version 2 rather
    than version 1.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Arquillian Cube 创建一个集成测试，以测试服务与其数据库之间的集成。你将使用微部署方法来打包与持久层相关的类。为了添加到之前的
    Docker Compose 文件格式，请确保使用 Docker Compose 格式版本 2 而不是版本 1。
- en: The following listing shows what a test looks like.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了测试的外观。
- en: Listing 8.6\. Integration test
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 集成测试
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Creates a microdeployment using only the required persistence-layer classes
    and files**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅使用所需的持久层类和文件创建微部署**'
- en: This is no different than running any other Arquillian test, so the test won’t
    be aware of whether it’s running against a local or a remote instance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这与运行任何其他 Arquillian 测试没有不同，因此测试不会知道它是在本地还是远程实例上运行。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can also benefit from using the Arquillian Persistence Extension in these
    tests if you need to.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您还可以在这些测试中受益于使用 Arquillian Persistence 扩展。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next step is defining a docker-compose.yml file that starts the server and
    the database.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个 docker-compose.yml 文件，该文件启动服务器和数据库。
- en: Listing 8.7\. Starting the server and database
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 启动服务器和数据库
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Sets environment variables from a file named envs**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从名为 envs 的文件中设置环境变量**'
- en: '***2* The Tomcat image is built from a Dockerfile.**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Tomcat 镜像是通过 Dockerfile 构建的**。'
- en: '***3* Uses the H2 server Docker image**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 H2 服务器 Docker 镜像**'
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Always pay close attention to the indentation in YAML files. It’s vital!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 总是注意 YAML 文件中的缩进。这是至关重要的！
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this file, a default network is created and shared between both containers.
    The container name is the hostname alias used by each container to look up other
    instances. For example, a `tomcat` container configuration for reaching `db` might
    be `jdbc:h2:tcp://`**`db`**`:1521/opt/h2-data/test`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，创建了一个默认网络，并在两个容器之间共享。容器名称是每个容器用来查找其他实例的主机名别名。例如，一个用于到达 `db` 的 `tomcat`
    容器配置可能是 `jdbc:h2:tcp://`**`db`**`:1521/opt/h2-data/test`。
- en: 'The Dockerfile should add a tomcat-users.xml file, ready with a user that has
    the roles to be able to deploy remotely. You need to define environment variables
    in order to configure Tomcat to accept deploying external applications on the
    fly, as well as set the password:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 应该添加一个 tomcat-users.xml 文件，其中包含一个具有部署远程应用所需角色的用户。您需要定义环境变量来配置 Tomcat
    以动态接受部署外部应用，并设置密码：
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Trick to change how entropy is calculated so that Tomcat starts up quickly**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 改变熵计算方式的小技巧，以便Tomcat快速启动**'
- en: '***2* The dockerServerIp parameter is replaced automatically at runtime by
    the Docker host IP.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* dockerServerIp参数在运行时自动替换为Docker主机IP。**'
- en: '***3* The JMX console is configured to accept remote communication.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* JMX控制台被配置为接受远程通信。**'
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Entropy**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**熵**'
- en: 'The entropy trick in the Tomcat configuration snippet is used only on Linux
    platforms, but it can also improve startup on Windows machines. The default `SecureRandom`
    implementation is very slow, because it must wait for the OS to build up entropy—and
    this can take minutes. Specifying `urandom` is slightly less secure for extreme
    cryptography algorithms. On some systems, you may need to use the alternative
    syntax if you still notice significant startup times (note the extra slashes):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tomcat配置片段中的熵技巧仅在Linux平台上使用，但它也可以提高Windows机器的启动速度。默认的`SecureRandom`实现非常慢，因为它必须等待操作系统建立熵——这可能会花费几分钟。指定`urandom`对于极端加密算法来说稍微不安全一些。在某些系统上，如果你仍然注意到显著的启动时间，你可能需要使用替代语法（注意额外的斜杠）：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Other options are available, such as defining a physical file of random numbers.
    Search the internet for java.security.egd to learn more about this subject.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项还包括定义一个随机数的物理文件。在网上搜索java.security.egd以了解更多关于这个主题的信息。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Last but not least, you need to configure the Arquillian Cube Extension to load
    the provided Docker Compose file. You also need to configure the remote adapter
    to set the user declared in the tomcat-users.xml file to connect to the Tomcat
    server and deploy the application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你需要配置Arquillian Cube扩展以加载提供的Docker Compose文件。你还需要配置远程适配器，将tomcat-users.xml文件中声明的用户设置为连接到Tomcat服务器并部署应用程序。
- en: Listing 8.8\. Configuring the Arquillian Cube Extension and the remote adapter
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. 配置Arquillian Cube扩展和远程适配器
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Sets the location of the Docker Compose file. In this case, it’s located
    in the project’s root directory.**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置Docker Compose文件的定位。在本例中，它位于项目的根目录中。**'
- en: '***2* Configures the Tomcat adapter with admin and mypass as authentication
    parameters to deploy**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置Tomcat适配器，使用admin和mypass作为认证参数以部署**'
- en: This is all you need to configure. Arquillian Cube automatically takes care
    of where Tomcat is running and deploying the test application to the correct (remote)
    Docker host IP. It’s important to note that most of these steps are specific to
    Tomcat, and that using another container might require different steps and touch
    different files.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要配置的所有内容。Arquillian Cube会自动处理Tomcat的运行位置，并将测试应用程序部署到正确的（远程）Docker主机IP。需要注意的是，这些步骤大多数是针对Tomcat的，使用其他容器可能需要不同的步骤并触及不同的文件。
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: The `qualifier` value in arquillian.xml must be the same container name as that
    defined in the docker-compose.yml file. In the previous example, the container
    name is `tomcat` and the qualifier is also `tomcat`, which makes sense.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在arquillian.xml中的`qualifier`值必须与docker-compose.yml文件中定义的容器名称相同。在之前的例子中，容器名称是`tomcat`，而qualifier也是`tomcat`，这很有意义。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When you run this test, the following steps are executed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个测试时，以下步骤将被执行：
- en: '**1**.  Arquillian Cube reads the Docker Compose file and then builds and instantiates
    the specified images to the Docker host.'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  Arquillian Cube读取Docker Compose文件，然后在Docker主机上构建和实例化指定的镜像。'
- en: '**2**.  Arquillian Core deploys the microdeployment file that contains the
    persistence-layer classes into the Tomcat container instance running in Docker
    Host.'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  Arquillian Core将包含持久层类的微部署文件部署到在Docker主机中运行的Tomcat容器实例中。'
- en: '**3**.  The test is executed when the entire test environment is set up and
    booted.'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  测试是在整个测试环境设置并启动时执行的。'
- en: '**4**.  After all tests are executed, the microdeployment file is undeployed.'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  在所有测试执行完毕后，微部署文件将被卸载。'
- en: '**5**.  The Docker container instances are terminated and removed from the
    Docker host.'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  Docker容器实例将被终止并从Docker主机中移除。'
- en: Note that this test now runs in its own provided testing environment that hosts
    the required database used in production. You don’t need to install any software
    dependencies on your actual development environment or CI environment for each
    project. Docker and Arquillian Cube take care of providing the dependencies for
    the test automatically.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个测试现在运行在自己的测试环境中，该环境托管了生产中使用的所需数据库。你不需要在每个项目的实际开发环境或 CI 环境中安装任何软件依赖项。Docker
    和 Arquillian Cube 会自动提供测试所需的依赖项。
- en: Now that you’ve seen how to write an integration test using Arquillian Cube,
    let’s move on to how you can use it for end-to-end testing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何使用 Arquillian Cube 编写集成测试，接下来让我们看看如何使用它进行端到端测试。
- en: 8.2.4\. Writing end-to-end tests
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4\. 编写端到端测试
- en: '[Chapter 7](kindle_split_016_split_000.xhtml#ch07) explained that you can validate
    your application from start to finish by, in theory, simulating a real-world user
    of your application, or at least performing the actions of a real user. In practice,
    these tests are usually the most difficult to write because they cover a lot of
    interactions—in most cases (but not always) interactions with the UI. They also
    require that you set up a full test environment with all possible elements the
    application might interact with, such as'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 7 章](kindle_split_016_split_000.xhtml#ch07) 解释了，理论上你可以通过模拟你的应用程序的真实世界用户，或者至少执行真实用户的操作来从始至终验证你的应用程序。在实践中，这些测试通常是最难编写的，因为它们覆盖了大量的交互——在大多数情况下（但并非总是）是与
    UI 的交互。它们还要求你设置一个完整的测试环境，包含应用程序可能与之交互的所有可能元素，例如'
- en: Server
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器
- en: Databases
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Distributed caches
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: Browsers
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: You now know that Docker, Docker Compose, and Arquillian Cube can help you prepare
    the environment for tests. Note that in end-to-end tests, you probably won’t need
    to create a deployment file in your tests; you’ll reuse an existing, versioned
    Docker image of the core of the application. For this reason, and as you saw in
    [chapter 4](kindle_split_013_split_000.xhtml#ch04), where no deployment method
    is provided, you’ll need to use the `standalone` dependency of Arquillian Core.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道 Docker、Docker Compose 和 Arquillian Cube 可以帮助你准备测试环境。请注意，在端到端测试中，你可能不需要在测试中创建部署文件；你将重用现有、已版本化的应用程序核心的
    Docker 镜像。因此，正如你在[第 4 章](kindle_split_013_split_000.xhtml#ch04)中看到的，那里没有提供部署方法，你需要使用
    Arquillian Core 的 `standalone` 依赖项。
- en: Let’s see what a docker-compose.yml file might look like for the same application
    you tested in [section 8.2.3](kindle_split_017_split_002.xhtml#ch08lev2sec6).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为你在[第 8.2.3 节](kindle_split_017_split_002.xhtml#ch08lev2sec6)测试的相同应用程序的
    docker-compose.yml 文件可能是什么样子。
- en: Listing 8.9\. Docker Compose file for an end-to-end test
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 用于端到端测试的 Docker Compose 文件
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* The image version is set using a system property or environment variable.
    If it isn’t set, the default value “latest” is used, denoted by the :- symbols.**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用系统属性或环境变量设置镜像版本。如果没有设置，则使用默认值“latest”，由冒号和短横线符号表示。**'
- en: In this file, you aren’t building a new Docker container, but rather are reusing
    the one built during the process of building the microservice. Each time you run
    end-to-end tests, the Docker image bundling the microservice may be a different
    version; for this reason, the final image name containing the microservice is
    generated dynamically at testing time by setting the version using a system property
    or environment variable named `version`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，你并不是构建一个新的 Docker 容器，而是在构建微服务的过程中重用已经构建的容器。每次运行端到端测试时，包含微服务的 Docker 镜像可能都是不同版本；因此，包含微服务的最终镜像名称在测试时通过设置名为
    `version` 的系统属性或环境变量来动态生成。
- en: The configuration file (arquillian.xml) doesn’t change from the previous use
    case.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件（arquillian.xml）与之前的使用案例没有变化。
- en: Listing 8.10\. Configuration file for an end-to-end test
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 端到端测试的配置文件
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Sets the docker-compose.yml file location**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置 docker-compose.yml 文件位置**'
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using multiple Docker Compose file definitions**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用多个 Docker Compose 文件定义**'
- en: In simple cases where a microservice isn’t a consumer of another microservice,
    using a single Docker Compose file may do the trick. But if a microservice under
    test is itself a consumer of one or more microservices, you may also need to start
    all of these services prior to testing. This is also valid when you want to write
    an end-to-end test, not for a given microservice and all of its dependencies (which
    can be other microservices), but for the entire system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，如果一个微服务不是另一个微服务的消费者，使用单个Docker Compose文件可能就足够了。但如果要测试的微服务本身是其他一个或多个微服务的消费者，您可能还需要在测试之前启动所有这些服务。这同样适用于您想要编写端到端测试的情况，不仅是为了给定的微服务及其所有依赖项（这些依赖项可以是其他微服务），而且是针对整个系统。
- en: In such cases, you can still rely on creating a single Docker Compose file containing
    all microservices and dependencies required for testing. But this may not be a
    good idea in terms of readiness, maintainability, and reflecting changes to the
    microservices environment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您仍然可以依赖创建一个包含所有测试所需微服务和依赖项的单个Docker Compose文件。但从准备就绪、可维护性和反映微服务环境变化的角度来看，这可能不是一个好主意。
- en: Our opinion is that each microservice should define its own Docker Compose file
    to set up the testing/production environment it needs in order to run. This makes
    end-to-end tests easy, because you can merge all the definitions with the useful
    Arquillian Cube `dockerContainersFiles` property.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点是，每个微服务都应该定义自己的Docker Compose文件，以设置其运行所需的测试/生产环境。这使得端到端测试变得容易，因为您可以使用有用的Arquillian
    Cube `dockerContainersFiles`属性合并所有定义。
- en: 'In the following snippet, Arquillian Cube downloads all the remote Docker Compose
    files and merges them into a single composition. Arquillian Cube then starts all
    defined containers, after which the test is executed:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，Arquillian Cube下载所有远程Docker Compose文件并将它们合并成一个单一组合。然后Arquillian Cube启动所有定义的容器，之后执行测试：
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* A list of locations where Docker Compose files are stored**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 存储Docker Compose文件的列表**'
- en: As you can see, it isn’t necessary to define the testing environment in a single
    location. Each microservice can define its own testing environment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有必要在单一位置定义测试环境。每个微服务都可以定义自己的测试环境。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Finally, you can write the end-to-end tests as you learned in [chapter 7](kindle_split_016_split_000.xhtml#ch07),
    using any of the frameworks exposed there. You can enrich each test with different
    Docker/container environment values such as the Docker host IP, and resolve port
    binding values for given exposed ports:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用在第7章（[chapter 7](kindle_split_016_split_000.xhtml#ch07)）中学到的知识编写端到端测试，使用那里公开的任何框架。您可以为每个测试添加不同的Docker/容器环境值，例如Docker主机IP，并解决给定公开端口的端口绑定值：
- en: '[PRE19]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Injects the Docker host IP**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入Docker主机的IP**'
- en: '***2* Resolves the binding port for exposed port 8080 of the tomcat container**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 解析tomcat容器公开端口8080的绑定端口**'
- en: '***3* Injects the IP of the tomcat container**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入tomcat容器的IP**'
- en: 'After injecting the Docker host IP and container binding port, you can configure
    any test framework used for endpoint testing against the Docker container. For
    example, you could configure REST Assured ([http://rest-assured.io](http://rest-assured.io))
    to test a microservice that’s running in the Docker host by doing something like
    this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入Docker主机IP和容器绑定端口后，您可以为端点测试配置任何测试框架，针对运行在Docker主机上的微服务进行配置。例如，您可以通过以下方式配置REST
    Assured ([http://rest-assured.io](http://rest-assured.io))来测试一个运行在Docker主机上的微服务：
- en: '[PRE20]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is one way to configure any testing framework by constructing the URL required.
    But Arquillian Cube offers tight integration with REST Assured and Arquillian
    Drone/Graphene, so you don’t need to deal with this in every test.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种通过构建所需URL来配置任何测试框架的方法。但Arquillian Cube提供了与REST Assured和Arquillian Drone/Graphene的紧密集成，因此您不需要在每次测试中都处理这个问题。
- en: 8.3\. Rest API
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. Rest API
- en: 'Because Arquillian Cube provides integration with REST Assured, you don’t need
    to repeat the same configuration code in all the tests where REST Assured is used
    with Docker. Having this integration means you can inject an instance of `io.restassured.builder.RequestSpecBuilder`
    that’s preconfigured with the current Docker host IP and port. (The sidebar “[About
    port resolution](kindle_split_017_split_003.xhtml#ch08sb06)” explains how the
    port resolution works.) The following test uses REST Assured integration:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Arquillian Cube提供了与REST Assured的集成，所以你不需要在所有使用Docker与REST Assured一起使用的测试中重复相同的配置代码。这种集成意味着你可以注入一个预配置了当前Docker主机IP和端口的`io.restassured.builder.RequestSpecBuilder`实例。（侧边栏“[关于端口解析](kindle_split_017_split_003.xhtml#ch08sb06)”解释了端口解析是如何工作的。）以下测试使用了REST
    Assured集成：
- en: '[PRE21]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* RequestSpecBuilder with Docker parameters predefined**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用预定义的Docker参数的RequestSpecBuilder**'
- en: '***2* REST Assured is configured with a request specification.**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* REST Assured配置了请求规范。**'
- en: As you can see, this test is similar to any test using REST Assured. The only
    difference is that now you’re setting the request-specification object configured
    with Docker values.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个测试与使用REST Assured的任何测试类似。唯一的区别是现在你正在设置配置了Docker值的请求规范对象。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About port resolution**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于端口解析**'
- en: Arquillian Cube REST Assured integration tries to automatically resolve which
    port is the binding port of the public microservice. By default, Arquillian Cube
    scans all Docker containers defined in Docker Compose files, and if there’s only
    one binding port, it’s the one that’s used.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube REST Assured集成尝试自动解析哪个端口是公共微服务的绑定端口。默认情况下，Arquillian Cube扫描Docker
    Compose文件中定义的所有Docker容器，如果只有一个绑定端口，则使用该端口。
- en: If there are several binding ports, then the `port` configuration property must
    be defined for the exposed port that Arquillian Cube should use to communicate
    with the microservice. For example, if you’re using the binding configuration
    8080:80, where the exposed port is 80 and the binding port is 8080, then when
    you set the `port` property to `80`, the extension will resolve to 8080.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个绑定端口，那么必须为Arquillian Cube用于与微服务通信的暴露端口定义`port`配置属性。例如，如果你使用绑定配置8080:80，其中暴露端口是80，绑定端口是8080，那么当你将`port`属性设置为`80`时，扩展将解析为8080。
- en: 'To set the `port` property, you need to add it to arquillian.xml:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`port`属性，你需要将其添加到`arquillian.xml`中：
- en: '[PRE22]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Sets the REST Assured configuration section**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置REST Assured配置部分**'
- en: '***2* Exposes port to resolve**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 暴露端口以解析**'
- en: If there’s no exposed port with the given number, then the port specified in
    the configuration property is also used as the binding port.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有暴露指定编号的端口，那么配置属性中指定的端口也被用作绑定端口。
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.4\. Arquillian Drone and Graphene
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. Arquillian Drone和Graphene
- en: When you’re running end-to-end tests that involve a browser as a frontend UI,
    one of the problems you may encounter is setting up the testing environment. You’ll
    need to install all requirements on every machine where tests are run, including
    the required browsers (with specific versions).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在运行涉及浏览器作为前端UI的端到端测试时，你可能会遇到的一个问题是设置测试环境。你需要在运行测试的每台机器上安装所有必需的要求，包括所需的浏览器（以及特定的版本）。
- en: As you learned in [chapter 7](kindle_split_016_split_000.xhtml#ch07), the de
    facto tool for web-browser tests is Selenium WebDriver. The Arquillian ecosystem
    offers Arquillian Drone and Graphene as the integration extension that uses WebDriver.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第7章](kindle_split_016_split_000.xhtml#ch07)中学到的，事实上的工具用于Web浏览器测试是Selenium
    WebDriver。Arquillian生态系统提供了Arquillian Drone和Graphene作为使用WebDriver的集成扩展。
- en: The Selenium project offers Docker images for the Selenium standalone server
    with Chrome and/or Firefox preinstalled. So, you effectively don’t need to install
    a browser in the testing environment, because the browser is treated like any
    other test dependency managed by Docker, such as databases, distributed caches,
    and other services.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium项目为Selenium独立服务器提供了预装Chrome和/或Firefox的Docker镜像。因此，你实际上不需要在测试环境中安装浏览器，因为浏览器被当作任何其他由Docker管理的测试依赖项，例如数据库、分布式缓存和其他服务。
- en: 8.4.1\. Integrating Arquillian Cube and Arquillian Drone
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 集成Arquillian Cube和Arquillian Drone
- en: 'Arquillian Cube integrates with Arquillian Drone by automatically executing
    several cumbersome tasks:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube通过自动执行几个繁琐的任务与Arquillian Drone集成：
- en: Starting the Docker container with the correct `browser` property for the `webdriver`
    extension set to `Firefox`, if not already set. The Selenium version of the image
    is the same as that defined in the test classpath.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未设置，则启动具有正确`browser`属性的Docker容器，`webdriver`扩展设置为`Firefox`。Selenium镜像的版本与在测试类路径中定义的版本相同。
- en: Providing a `WebDriver` that can connect to the container.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个可以连接到容器的`WebDriver`。
- en: Creating a virtual network computing (VNC) Docker container that records all
    test executions that occur for each test in a browser container and stores them
    on the local machine in MP4 format.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个虚拟网络计算（VNC）Docker容器，记录每个浏览器容器中发生的所有测试执行，并将它们以MP4格式存储在本地机器上。
- en: These interactions are summarized in [figure 8.5](kindle_split_017_split_004.xhtml#ch08fig05).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交互总结在[图8.5](kindle_split_017_split_004.xhtml#ch08fig05)中。
- en: Figure 8.5\. Arquillian integrations
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5\. Arquillian集成
- en: '![](Images/08fig05_alt.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig05_alt.jpg)'
- en: '[Table 8.2](kindle_split_017_split_004.xhtml#ch08table02) describes the most
    important configuration attributes that you can define in arquillian.xml.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8.2](kindle_split_017_split_004.xhtml#ch08table02)描述了您可以在arquillian.xml中定义的最重要配置属性。'
- en: Table 8.2\. Arquillian Cube Graphene configuration parameters
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.2\. Arquillian Cube Graphene配置参数
- en: '| Attribute | Description | Default behavior |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 默认行为 |'
- en: '| --- | --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| recordingMode | Recording mode to be used. The valid values are ALL, ONLY_FAILING,
    and NONE. | ALL |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| recordingMode | 要使用的录制模式。有效值是ALL、ONLY_FAILING和NONE。 | ALL |'
- en: '| videoOutput | Directory where videos are stored. | Creates target/reports/videos
    or, if target doesn’t exist, build/reports/videos. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| videoOutput | 存储视频的目录。 | 创建target/reports/videos或，如果target不存在，则创建build/reports/videos。
    |'
- en: '| browserImage | Docker image to be used as a custom browser image instead
    of the default image. |   |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| browserImage | 要用作自定义浏览器镜像的Docker镜像，而不是默认镜像。 |   |'
- en: '| browserDockerfileLocation | Dockerfile location to be used to build a custom
    Docker image instead of the default Dockerfile. This property has preference over
    browserImage. |   |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| browserDockerfileLocation | 用于构建自定义Docker镜像的Dockerfile位置，而不是默认的Dockerfile。此属性优先于browserImage。
    |   |'
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Custom images must expose port 4444 so the `WebDriver` instance can reach the
    browser. If VNC is used, port 5900 must also be exposed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义镜像必须暴露端口4444，以便`WebDriver`实例可以访问浏览器。如果使用VNC，则必须也暴露端口5900。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here’s an example of a typical configuration:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型配置的示例：
- en: '[PRE23]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Typical Arquillian Cube configuration**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 典型的Arquillian Cube配置**'
- en: '***2* Configures the browser property from either a system property or an environment
    variable, using “chrome” as the default**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从系统属性或环境变量中配置浏览器属性，默认使用“chrome”**'
- en: '***3* Disables recording capabilities**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 禁用录制功能**'
- en: Here, Arquillian Cube is configured to start all containers defined in the docker-compose.yml
    file. Notice that this file doesn’t contain any information regarding browsers,
    because this is autoresolved by the Arquillian Cube Drone integration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Arquillian Cube被配置为启动docker-compose.yml文件中定义的所有容器。请注意，此文件不包含任何关于浏览器的信息，因为这由Arquillian
    Cube Drone集成自动解决。
- en: The browser is specified by setting the `browser` system property or environment
    variable to `firefox` or `chrome`. If it isn’t defined, `chrome` is used as the
    default. Finally, the recording feature is disabled.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`browser`系统属性或环境变量设置为`firefox`或`chrome`来指定浏览器。如果没有定义，则默认使用`chrome`。最后，禁用录制功能。
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: At time of writing, the Selenium project offers images only for Firefox and
    Chrome. Creating Internet Explorer images is still a task left to the user.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Selenium项目仅提供Firefox和Chrome的镜像。创建Internet Explorer镜像仍然是留给用户的一项任务。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The actual test shown in [listing 8.11](kindle_split_017_split_004.xhtml#ch08ex11)
    (HelloWorldTest.java) looks similar to any Drone and Arquillian Cube test, with
    one slight difference. All browser commands (hence, `WebDriver`) are executed
    *inside* the Docker host, meaning you’re governed by Docker host rules. Thus,
    in this test, instead of using `HostIp` to get the Docker host IP, you use `CubeIp`,
    which returns the *internal IP address* of the given container. This is required
    because the browser is running inside the Docker host, and to connect to another
    container in the same Docker host, you need either the host name or the internal
    IP address.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.11](kindle_split_017_split_004.xhtml#ch08ex11)（HelloWorldTest.java）中展示的实际测试看起来与任何
    Drone 和 Arquillian Cube 测试类似，只有一个细微的区别。所有浏览器命令（因此，`WebDriver`）都是在 Docker 主机内部执行的，这意味着您受到
    Docker 主机规则的约束。因此，在这个测试中，您不是使用 `HostIp` 来获取 Docker 主机的 IP 地址，而是使用 `CubeIp`，它返回给定容器的
    *内部 IP 地址*。这是必需的，因为浏览器是在 Docker 主机内部运行的，并且要连接到同一 Docker 主机中的另一个容器，您需要主机名或内部 IP
    地址。
- en: Listing 8.11\. HelloWorldTest.java
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. HelloWorldTest.java
- en: '[PRE24]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Uses the Drone annotation to inject the WebDriver instance**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 Drone 注解注入 WebDriver 实例**'
- en: '***2* Injects the internal IP of the helloworld container**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 helloworld 容器的内部 IP**'
- en: '***3* URL to connect the browser to the microservice**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 连接浏览器到微服务的 URL**'
- en: Next, let’s look at how Arquillian Cube and Arquillian Graphene are integrated.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Arquillian Cube 和 Arquillian Graphene 是如何集成的。
- en: 8.4.2\. Integrating Arquillian Cube and Arquillian Graphene
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 集成 Arquillian Cube 和 Arquillian Graphene
- en: Arquillian Graphene is a set of extensions for the WebDriver API, focused on
    rapid development and usability in a Java environment. It strives for reusable
    tests by simplifying the use of web page abstractions (page objects and page fragments).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Graphene 是 WebDriver API 的一组扩展，专注于在 Java 环境中的快速开发和可用性。它通过简化网页抽象（页面对象和页面片段）的使用来追求可重用测试。
- en: Arquillian Graphene depends on Arquillian Drone to provide an instance of `WebDriver`,
    so everything that’s valid in integration between Arquillian Cube Docker (such
    as recording capabilities) is also valid for Arquillian Cube Graphene.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Graphene 依赖于 Arquillian Drone 来提供 `WebDriver` 的实例，因此 Arquillian Cube
    Docker（例如记录功能）之间的集成中有效的一切也适用于 Arquillian Cube Graphene。
- en: One of the primary things that differentiates a test written in Arquillian Drone
    from a test written in Arquillian Graphene is that the latter test automatically
    resolves the host and the context of the application. In Arquillian Drone, you
    need to explicitly set them by calling the `webdriver.get(...)` method.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 区分在 Arquillian Drone 中编写的测试和在 Arquillian Graphene 中编写的测试的主要因素之一是后者测试会自动解析应用程序的主机和上下文。在
    Arquillian Drone 中，您需要通过调用 `webdriver.get(...)` 方法显式设置它们。
- en: 'This autoresolution feature provided by Arquillian Graphene works only when
    you’re running tests in container mode. (Arquillian manages the deployment file
    for classes that have a `@Deployment` method.) When you’re using standalone mode
    (no `@Deployment` declaration), which may be the case in end-to-end tests, you
    need to configure Arquillian Graphene in arquillian.xml with the URL where the
    application is deployed:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Graphene 提供的此自动解析功能仅在您以容器模式运行测试时才有效。（Arquillian 管理具有 `@Deployment`
    方法的类的部署文件。）当您使用独立模式（没有 `@Deployment` 声明）时，这可能在端到端测试中是情况，您需要使用 `arquillian.xml`
    配置 Arquillian Graphene，并指定应用程序部署的 URL：
- en: '[PRE25]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Sets the URL to be used by Graphene tests**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置 Graphene 测试使用的 URL**'
- en: The problem is that when you’re using Arquillian Cube, you may not know the
    Docker host IP address at configuration time—only during the runtime phase. So
    you can’t reliably set it yet!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当您使用 Arquillian Cube 时，您可能在配置时间不知道 Docker 主机 IP 地址——只有在运行时阶段才知道。因此，您还不能可靠地设置它！
- en: Arquillian Cube integrates with Arquillian Graphene by providing a special keyword,
    `dockerHost`, that can be defined in the `url` property and is replaced at runtime
    by the current Docker host IP when the test environment fires up. Additionally,
    if the *host* part of `url` isn’t `dockerHost` or a valid IP, then this host is
    considered to be the Docker container name and is replaced by its container internal
    IP.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube 通过提供可以在 `url` 属性中定义的特殊关键字 `dockerHost` 与 Arquillian Graphene
    集成，该关键字在测试环境启动时由当前的 Docker 主机 IP 地址替换。此外，如果 `url` 的 *主机* 部分不是 `dockerHost` 或有效的
    IP 地址，则该主机被认为是 Docker 容器名称，并将其替换为其容器内部 IP。
- en: 'Knowing this, the previous example can be rewritten so it’s Arquillian Cube
    Graphene aware:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，前面的示例可以重写为 Arquillian Cube Graphene 兼容的形式：
- en: '[PRE26]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Sets the URL to be used by Graphene**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置 Graphene 使用的 URL**'
- en: 'Based on this information, you now know the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，您现在知道以下内容：
- en: The `helloworld` part of the URL will be replaced by the container’s internal
    IP.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL 中的 `helloworld` 部分将被容器的内部 IP 地址替换。
- en: The port used should be the exposed port for the `helloworld` container.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应使用的端口是 `helloworld` 容器公开的端口。
- en: 'You can now define a page object, as in any other Arquillian Graphene test:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以定义一个页面对象，就像在其他 Arquillian Graphene 测试中一样：
- en: '[PRE27]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Path of the page represented by this page object**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 表示此页面对象的页面路径**'
- en: Note that in this case, you aren’t setting any information about the actual
    hostname, you’re just setting the relative context location of this page.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，您没有设置任何有关实际主机名的信息，您只是设置了此页面的相对上下文位置。
- en: 'Finally, the test has no changes versus a normal test. Everything is managed
    underneath by Arquillian Cube:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与正常测试相比，测试没有变化。所有内容都由 Arquillian Cube 在底层管理：
- en: '[PRE28]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the host information isn’t present in any test. It’s resolved
    and provided to the environment via the arquillian.xml file. This makes the tests
    reusable in any environment, because you can change the base URL dynamically before
    executing the tests.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主机信息没有出现在任何测试中。它通过 `arquillian.xml` 文件解析并提供给环境。这使得测试可以在任何环境中重用，因为您可以在执行测试之前动态更改基本
    URL。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Arquillian Cube Graphene autoresolution is required only if you’re using Arquillian
    in standalone mode (using the standalone dependency). If you’re using container
    mode, the URL is resolved by the deployment method, and you don’t need to specify
    anything. In our opinion, an end-to-end test with Docker (or in general) should
    be written using Arquillian standalone mode; this simulates a real production
    environment much more closely, which is ultimately what you’re trying to achieve.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当您使用独立模式（使用独立依赖项）的 Arquillian 时，才需要 Arquillian Cube 的 Graphene 自动解析。如果您使用容器模式，URL
    由部署方法解析，您不需要指定任何内容。在我们看来，使用 Docker（或更一般地）编写的端到端测试应该使用 Arquillian 独立模式；这更接近于模拟真实的生产环境，这正是您试图实现的目标。
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.5\. Parallelizing tests
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5. 并行化测试
- en: 'One of the problems you may encounter when running tests against a single Docker
    host is that each container running in the host must have a unique name. In general,
    this may not be an issue, but in some situations it can lead to a conflict:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当您针对单个 Docker 主机运行测试时，可能会遇到的一个问题是，在主机中运行的每个容器都必须有一个唯一名称。通常，这可能不是问题，但在某些情况下，它可能导致冲突：
- en: If you run tests defined in the same project in parallel, then, assuming they’re
    reusing the same Docker Compose file, the same Docker host is used. This will
    cause a conflict because you’re using the same container name for each test.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您并行运行同一项目中定义的测试，那么，假设它们正在重用相同的 Docker Compose 文件，将使用相同的 Docker 主机。这将导致冲突，因为您为每个测试使用了相同的容器名称。
- en: Different projects are running tests in your CI environment and reusing the
    same Docker host. For example, two microservices have defined a Docker container
    named `db`, and they’re building at the same time.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的项目在您的 CI 环境中运行测试并重用相同的 Docker 主机。例如，两个微服务定义了一个名为 `db` 的 Docker 容器，并且它们正在同时构建。
- en: 'Workarounds are available to mitigate these problems:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些解决方案可以减轻这些问题：
- en: The first problem can be resolved by setting the `arq.extension.docker.serverUri`
    property in each parallel execution to use a different Docker host.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题可以通过在每个并行执行中设置 `arq.extension.docker.serverUri` 属性来解决，以使用不同的 Docker 主机。
- en: The second problem can be resolved by using one agent/slave for each project,
    each of which has its own Docker host.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个问题可以通过为每个项目使用一个代理/从机来解决，每个代理/从机都有自己的 Docker 主机。
- en: In conjunction with these workarounds, Arquillian Cube offers a helpful tool
    called the *star operator* (`*`).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些解决方案一起，Arquillian Cube 提供了一个名为 *星号操作符*（`*`）的有用工具。
- en: 'The star operator lets you indicate to Arquillian Cube that you want to generate
    part of the Docker container name randomly. All generated information is automatically
    adapted to use the random element. The only thing you need to do is add an asterisk
    character (`*`) at the end of the container name in the Docker Compose file. Here’s
    an example:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 星号操作符允许您向 Arquillian Cube 指示您想要随机生成 Docker 容器名称的一部分。所有生成的信息都会自动适应使用随机元素。您需要做的只是将一个星号字符（`*`）添加到
    Docker Compose 文件中容器名称的末尾。以下是一个示例：
- en: '[PRE29]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Sets a link to a partially random container name**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置部分随机容器名称的链接**'
- en: '***2* Sets the container name as partially random**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将容器名称设置为部分随机**'
- en: Given this Docker Compose file, Arquillian Cube will substitute the `*` character
    for a UUID generated for each execution at runtime. Binding ports are changed
    to a random port (in the range 49152–65535). And a new environment variable with
    a link to the random container setting at the new host location is provided to
    containers; the form of this environment variable is `<containerName>;_HOSTNAME`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个Docker Compose文件，Arquillian Cube将在运行时用UUID替换`*`字符，为每次执行生成。绑定端口被更改为随机端口（范围在49152–65535）。同时，为容器提供了一个新的环境变量，该变量包含指向新主机位置的随机容器设置的链接；这个环境变量的形式是`<containerName>;_HOSTNAME`。
- en: 'The resulting docker-compose.yml file after Arquillian Cube has applied the
    changes might look like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube应用更改后的docker-compose.yml文件可能看起来像这样：
- en: '[PRE30]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Link updated to a random container name**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将链接更新为随机容器名称**'
- en: '***2* Environment variable with the hostname of the new container**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含新容器主机名的环境变量**'
- en: '***3* Container defined with a random name**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用随机名称定义容器**'
- en: '***4* Binding port updated to a random port**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 绑定端口更新为随机端口**'
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Using the star operator will make your Docker Compose file incompatible with
    the `docker-compose` CLI. Also note that the `hostname` entry in DNS defined by
    the `links` section is also randomly generated, because the container name has
    been changed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用星号运算符将使你的Docker Compose文件与`docker-compose` CLI不兼容。此外，请注意，由`links`部分定义的DNS中的`hostname`条目也是随机生成的，因为容器名称已被更改。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The star operator isn’t an all-or-nothing solution—you can use it together with
    other approaches. The ideal scenario has one Docker host for each parallel execution
    or slave/agent.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 星号运算符不是一个全有或全无的解决方案——你可以将它与其他方法一起使用。理想的情况是每个并行执行或奴隶/代理有一个Docker主机。
- en: 8.6\. Arquillian Cube and Algeron
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6\. Arquillian Cube和Algeron
- en: 'In [chapter 6](kindle_split_015_split_000.xhtml#ch06), you learned about consumer-driven
    contracts and how they’re run using the Arquillian Algeron Extension. You execute
    them in two steps: the first step is on the consumer side, where you start a stub
    HTTP server and send requests to it; and the second step is to replay and verify
    all interactions that occurred against a real provider. These interactions are
    summarized in [figure 8.6](kindle_split_017_split_006.xhtml#ch08fig06).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_015_split_000.xhtml#ch06)中，你学习了关于消费者驱动的合约以及它们是如何使用Arquillian
    Algeron扩展运行的。你通过两个步骤执行它们：第一步是在消费者端，你启动一个stub HTTP服务器并向它发送请求；第二步是回放并验证所有针对真实提供者的交互。这些交互在[图8.6](kindle_split_017_split_006.xhtml#ch08fig06)中进行了总结。
- en: Figure 8.6\. Pact lifecycle
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6\. Pact生命周期
- en: '![](Images/08fig06.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig06.jpg)'
- en: To run provider contract tests, you need to deploy the provider service and
    then replay and verify all interactions. This is where Docker and Arquillian Cube
    can help you, by simplifying the deployment phase of the provider service.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行提供者合约测试，你需要部署提供者服务，然后回放并验证所有交互。这正是Docker和Arquillian Cube可以帮助你的地方，通过简化提供者服务的部署阶段。
- en: 'So far, there isn’t much difference between using Arquillian Algeron with Arquillian
    Cube. But let’s look at a quick example where a new Arquillian Cube enrichment
    method is introduced:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用Arquillian Algeron与Arquillian Cube之间没有太大的区别。但让我们看看一个快速示例，其中引入了一个新的Arquillian
    Cube丰富方法：
- en: '[PRE31]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Arquillian Cube and Arquillian Algeron annotations**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Arquillian Cube和Arquillian Algeron注解**'
- en: '***2* Enriches the URL with valid Docker values**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用有效的Docker值丰富URL**'
- en: '***3* Enriches the Arquillian Algeron Target**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 丰富Arquillian Algeron目标**'
- en: '***4* Replays verification against the Docker container**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 对Docker容器进行回放验证**'
- en: This test is basically the same as any other Arquillian Cube and Arquillian
    Algeron Pact provider, but in this case the test is enriched with a URL to access
    the provider. This URL is created by resolving `dockerHost` as the host part.
    The port part is appended by obtaining the exposed port set in the annotation
    for the specific container (`"helloworld"`, in this case). The annotation-defined
    context is then appended. For example, the resulting URL might have the value
    `http://192.168.99.100:8081/hello`. The rest of the test is pretty much the same
    as any other.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试基本上与任何其他Arquillian Cube和Arquillian Algeron Pact提供者相同，但在这个情况下，测试被添加了一个访问提供者的URL。这个URL是通过解析`dockerHost`作为主机部分创建的。端口号是通过获取特定容器（在这种情况下是`"helloworld"`）的注解中设置的公开端口来附加的。然后附加由注解定义的上下文。例如，生成的URL可能具有`http://192.168.99.100:8081/hello`的值。测试的其余部分与其他测试基本相同。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `@DockerUrl` annotation in any Arquillian Cube standalone test,
    not just when using Arquillian Algeron. But note that the enrichment test is in
    *standalone* mode (there’s no `@Deployment` method). The `@DockerUrl` enrichment
    works only when you’re running Arquillian in standalone mode.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何Arquillian Cube独立测试中使用`@DockerUrl`注解，而不仅仅是当使用Arquillian Algeron时。但请注意，增强测试是在*独立*模式下进行的（没有`@Deployment`方法）。`@DockerUrl`增强仅在独立模式下运行Arquillian时才有效。
- en: '|  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Of course, you still need to define a Docker Compose file and configure Arquillian
    Cube. But for the sake of simplicity, and because you’ve seen that in previous
    sections, we skipped these steps.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你仍然需要定义一个Docker Compose文件并配置Arquillian Cube。但为了简化，并且因为你已经在前面的章节中看到了这些步骤，所以我们跳过了这些步骤。
- en: 8.7\. Using the container-objects pattern
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7\. 使用容器对象模式
- en: So far, you’ve seen how to “orchestrate” Docker containers using the Docker
    Compose file. Arquillian Cube also offers another way to define Docker containers
    using a Java object.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何使用Docker Compose文件“编排”Docker容器。Arquillian Cube还提供了一种使用Java对象定义Docker容器的方法。
- en: Using Java objects to define the container configuration enables you to add
    some dynamism to the Docker container definition, such as modifying a Dockerfile’s
    content programmatically or modelling container attributes such as IP address,
    username, and password. Also, because you’re creating Java objects, you can use
    any of the resources the language provides, such as extending definitions, injecting
    values from tests, or packaging values as delivery artifacts.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java对象定义容器配置使你能够为Docker容器定义添加一些动态性，例如以编程方式修改Dockerfile的内容或模拟容器属性，如IP地址、用户名和密码。此外，因为你正在创建Java对象，你可以使用语言提供的任何资源，例如扩展定义、从测试中注入值或打包值为交付工件。
- en: You can think of *container objects* as a way to model containers in a reusable,
    maintainable way. Because they’re Java objects, nothing prevents you from reusing
    them across multiple projects. This reduces the amount of duplicated code, and
    any fixes only need to be applied in one place instead of in multiple projects.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将*容器对象*视为以可重用、可维护的方式对容器进行建模。因为它们是Java对象，所以没有任何东西阻止你在多个项目中重用它们。这减少了代码重复的数量，并且任何修复只需要在一个地方应用，而不是在多个项目中。
- en: Before we show you how to implement container objects, let’s look at an example
    where they’re useful. Suppose your microservice (or project) needs to send a file
    to an FTP server. You need to write an integration test validating that your business
    code can execute this operation correctly.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向您展示如何实现容器对象之前，让我们看看一个它们有用的例子。假设你的微服务（或项目）需要向FTP服务器发送一个文件。你需要编写一个集成测试来验证你的业务代码能否正确执行此操作。
- en: 'Your test must be able to execute the following operations:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试必须能够执行以下操作：
- en: Find the hostname/IP and port where the FTP server is running.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到FTP服务器运行的hostname/IP和端口。
- en: Define the username and password required to access the FTP server and store
    files.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义访问FTP服务器和存储文件所需的用户名和密码。
- en: Assert the existence of a file on the FTP server to verify that the file is
    correctly sent.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言FTP服务器上文件的存在，以验证文件是否正确发送。
- en: 'One way to write this test would be to use the Docker Compose approach:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此测试的一种方法就是使用Docker Compose方法：
- en: '[PRE32]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This approach has several problems:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个问题：
- en: You need to copy this docker-compose.yml file to all projects where you want
    to write an integration test using the FTP server.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要将此docker-compose.yml文件复制到所有你想使用FTP服务器编写集成测试的项目中。
- en: Tests need to know internal details of the Docker container, such as username
    and password.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试需要了解Docker容器的内部细节，例如用户名和密码。
- en: Tests contain logic specific to the Docker container, such as how to validate
    that a file has been copied.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试包含特定于Docker容器的逻辑，例如如何验证文件是否已复制。
- en: Any changes need to be propagated to all use cases.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何更改都需要传播到所有用例。
- en: You obviously have a good contender here for writing a container-object pattern
    that encapsulates all logic related to the FTP server. The following listing shows
    what this container object might look like (FtpContainer.java).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这里有一个很好的候选者来编写一个封装所有与FTP服务器相关的逻辑的容器对象模式。以下列表显示了此容器对象可能的样子（FtpContainer.java）。
- en: Listing 8.12\. Container-object pattern
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.12\. 容器对象模式
- en: '[PRE33]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Defines the Cube name and binding ports**'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义Cube名称和绑定端口**'
- en: '***2* Configures environment variables to be set in the container**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置要在容器中设置的环境变量**'
- en: '***3* Sets the Docker image**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置Docker镜像**'
- en: '***4* Enables enrichments in container objects**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在容器对象中启用增强功能**'
- en: '***5* Encapsulates operations related to the container**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 封装与容器相关的操作**'
- en: As you can see in this class, a container object is a plain old Java object
    (POJO). This object is annotated with configuration parameters required for starting
    the container, such as `name` and `bind`/`expose` ports using the `@Cube` annotation,
    and which Docker image is mapped using the `@Image` annotation. Any Arquillian
    test enrichment that you’ve learned so far can be applied to a container object,
    such as `host_ip`, `host_port`, and `docker client`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这个类中看到的，容器对象是一个普通的Java对象（POJO）。此对象使用`@Cube`注解标注了启动容器所需的配置参数，例如`name`和`bind`/`expose`端口，以及使用`@Image`注解映射的Docker镜像。您可以将迄今为止学到的任何Arquillian测试增强功能应用于容器对象，例如`host_ip`、`host_port`和`docker
    client`。
- en: Now you’ve seen how to define a container object, here’s how to use it in a
    test (FtpClientTest.java).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何定义容器对象，以下是如何在测试（FtpClientTest.java）中使用它的方法。
- en: Listing 8.13\. Using a container object in a test
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.13\. 在测试中使用容器对象
- en: '[PRE34]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* The container object is annotated with @Cube.**'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 容器对象使用@Cube注解。**'
- en: '***2* Retrieves FTP properties from the injected object**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从注入的对象检索FTP属性**'
- en: '***3* Encapsulates operations related to the container**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 封装与容器相关的操作**'
- en: Using a container object in an Arquillian Cube test is as simple as declaring
    it as such and annotating it with `@Cube`. At execution time, Arquillian Cube
    inspects all test classes for fields annotated with `Cube`, reads all metainformation,
    and starts the defined containers. After the test is executed, the container is
    stopped.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arquillian Cube测试中使用容器对象就像声明它并使用`@Cube`注解它一样简单。在执行时间，Arquillian Cube检查所有带有`Cube`注解的字段，读取所有元信息，并启动定义的容器。测试执行后，容器将被停止。
- en: As you can see, the lifecycle of a container object isn’t much different from
    defining it in a Docker Compose file. Note that in this case, there’s no need
    for a Docker Compose file, although you could use both approaches together if
    you wanted to.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，容器对象的生存周期与在Docker Compose文件中定义它并没有太大的不同。请注意，在这种情况下，不需要Docker Compose文件，尽管如果您愿意，您可以使用这两种方法一起使用。
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Updating default values**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新默认值**'
- en: 'When you’re working with a POJO, you can override any part of it using normal
    Java language conventions. In the following example, the test overrides the name
    of the container, as well as the port binding configuration:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与POJO一起工作时，您可以使用常规Java语言约定覆盖它的任何部分。在以下示例中，测试覆盖了容器的名称，以及端口绑定配置：
- en: '[PRE35]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Updates default values provided by the container object**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新容器对象提供的默认值**'
- en: '|  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Another feature offered by the container-objects pattern in Arquillian Cube
    is the possibility of not depending on a specific image. You can build your own
    image from a Dockerfile using the `CubeDockerFile` annotation:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube中容器对象模式提供的另一个功能是无需依赖于特定镜像。您可以使用`CubeDockerFile`注解从Dockerfile构建自己的镜像：
- en: '[PRE36]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Builds image from a configured Dockerfile**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从配置的Dockerfile构建镜像**'
- en: The `CubeDockerFile` annotation sets the location where the Dockerfile can be
    found, but it doesn’t limit the contents of the Dockerfile. This location must
    be accessible by the runtime `ClassLoader`, so it must be present on the classpath.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`CubeDockerFile`注解设置了Dockerfile可以找到的位置，但它并不限制Dockerfile的内容。此位置必须可通过运行时`ClassLoader`访问，因此它必须存在于类路径上。'
- en: 'You can also create the Dockerfile programmatically using the ShrinkWrap Descriptors
    domain-specific language (DSL). The following example shows how a Dockerfile can
    be defined using the DSL in a container object:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用ShrinkWrap Descriptors领域特定语言（DSL）编程方式创建Dockerfile。以下示例展示了如何使用容器对象中的DSL定义Dockerfile：
- en: '[PRE37]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Static method for defining a Dockerfile**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义Dockerfile的静态方法**'
- en: '***2* Creates Dockerfile content using the ShrinkWrap Descriptors DSL**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用ShrinkWrap Descriptors DSL创建Dockerfile内容**'
- en: '***3* Builds an archive with all required content**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用所有必需内容构建存档**'
- en: The method that builds the Dockerfile must be annotated with `CubeDockerFile`,
    and it must be public and static with no arguments. In addition, the method needs
    to return a ShrinkWrap `Archive` instance. The Dockerfile isn’t returned directly,
    because in certain circumstances you might need to add extra files required for
    building the Docker container. This is especially true when you need to add files
    during container creation.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Dockerfile的方法必须使用`CubeDockerFile`注解，并且它必须是公共的、静态的，且没有参数。此外，该方法需要返回一个ShrinkWrap
    `Archive`实例。Dockerfile不是直接返回的，因为在某些情况下，你可能需要添加构建Docker容器所需的额外文件。这在你需要在容器创建期间添加文件时尤其如此。
- en: The last feature offered by the container-objects pattern is the aggregation
    of containers. Aggregation allows you to define container objects in other container
    objects. Each aggregated object contains a link to its parent, so each of the
    involved parties can communicate with each other.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 容器对象模式提供的最后一个功能是容器的聚合。聚合允许你在其他容器对象中定义容器对象。每个聚合对象都包含对其父对象的链接，因此所有参与方都可以相互通信。
- en: 'Here’s how to define an inner container object:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何定义内部容器对象的方法：
- en: '[PRE38]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In addition to starting both containers, Arquillian Cube creates a link between
    them by setting the hostname for `LinkContainerObject` to `inner`. The link can
    be further configured by using a `@Link` annotation:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启动两个容器之外，Arquillian Cube通过将`LinkContainerObject`的主机名设置为`inner`来在它们之间创建一个链接。可以通过使用`@Link`注解进一步配置链接：
- en: '[PRE39]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 8.7.1\. Using a flexible container-object DSL
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.1\. 使用灵活的容器对象DSL
- en: Arquillian Cube also provides a generic `Container` object to generate Cube
    instances. Writing definitions is more efficient when you use this approach, but
    it’s a little more difficult to reuse the code or to provide the custom operations
    with the custom container-object approach.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube还提供了一个通用的`Container`对象来生成Cube实例。使用这种方法编写定义更高效，但使用自定义容器对象方法重用代码或提供自定义操作会更困难一些。
- en: 'Let’s look at a simple example of how to declare and start a Docker container
    using the `Container` DSL:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Container` DSL声明和启动Docker容器的一个简单示例：
- en: '[PRE40]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* The field is annotated with @DockerContainer.**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 字段被注解为@DockerContainer。**'
- en: '***2* The DSL starts with the withContainerName method.**'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* DSL从`withContainerName`方法开始。**'
- en: '***3* Gets container information to connect**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取容器信息以连接**'
- en: To create a generic container object, you only need to create a field of type
    `org.arquillian.cube.docker.impl.client.containerobject.dsl.Container` and annotate
    it with `@DockerContainer`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个通用的容器对象，你只需要创建一个类型为`org.arquillian.cube.docker.impl.client.containerobject.dsl.Container`的字段，并使用`@DockerContainer`注解它。
- en: 'You can also create a Docker network using the DSL approach:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用DSL方法创建Docker网络：
- en: '[PRE41]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* The field is annotated with @DockerNetwork.**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 字段被注解为@DockerNetwork。**'
- en: '***2* The DSL starts with the withDefaultDriver method.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* DSL从`withDefaultDriver`方法开始。**'
- en: To create a network using the DSL approach, you create a field of type `org.arquillian.cube.docker.impl.client.containerobject.dsl.Network`
    and annotate it with `@DockerNetwork`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用DSL方法创建网络，你需要创建一个类型为`org.arquillian.cube.docker.impl.client.containerobject.dsl.Network`的字段，并使用`@DockerNetwork`注解它。
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Container objects and DSL JUnit rules**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器对象和DSL JUnit规则**'
- en: 'You can define generic containers using a *JUnit rule*. This way, you can use
    any JUnit runner such as `SpringJUnit4ClassRunner` side by side with the container
    object DSL. Here’s how to define a Redis container:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*JUnit规则*定义通用容器。这样，你可以使用任何JUnit运行器，如`SpringJUnit4ClassRunner`，与容器对象DSL并排使用。以下是如何定义Redis容器的方法：
- en: '[PRE42]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Spring Data and Spring Boot**'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Data和Spring Boot**'
- en: 'With Spring Data, you configure the database location using environment variables.
    To set them in the test, you need to use a custom `ApplicationContextInitializer`.
    Here’s an example:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Data，你通过环境变量配置数据库位置。要在测试中设置它们，你需要使用自定义的`ApplicationContextInitializer`。以下是一个示例：
- en: '[PRE43]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Spring JUnit test runner with Boot configuration**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 带有Boot配置的Spring JUnit测试运行器**'
- en: '***2* Setup initializer to configure environment variables**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置初始化器以配置环境变量**'
- en: '***3* Defines a Redis container**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义Redis容器**'
- en: '***4* Initializer implementation with container configuration**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 带有容器配置的初始化器实现**'
- en: Note that you must add the `org.arquillian.cube:arquillian-cube-docker-junit-rule`
    dependency. You don’t need to add any other Arquillian dependency.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须添加`org.arquillian.cube:arquillian-cube-docker-junit-rule`依赖。你不需要添加任何其他的Arquillian依赖。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So far, you’ve learned how to use Docker and Arquillian Cube to set up a complex
    testing environment. In the next section, we’ll look at how to use and deploy
    Docker images in Kubernetes.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何使用Docker和Arquillian Cube来设置复杂的测试环境。在下一节中，我们将探讨如何在Kubernetes中使用和部署Docker镜像。
- en: 8.8\. Deployment tests and Kubernetes
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8\. 部署测试和Kubernetes
- en: In this chapter, you’ve seen how you can use Docker for testing purposes, but
    perhaps you’re also using Docker at the production level. Docker containers on
    their own can be difficult to manage and maintain. Complex applications typically
    require booting up multiple containers on multiple machines (note that the Docker
    host runs on a single host). You also need a way to orchestrate all these containers
    and offer other features such as fault tolerance, horizontal autoscaling, distribution
    of secrets, naming and discovery of services across all machines, rolling updates,
    and load balancing. One standout tool that offers these features is Kubernetes.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何使用Docker进行测试，但也许你也在生产级别使用Docker。Docker容器本身可能难以管理和维护。复杂的应用程序通常需要在多台机器上启动多个容器（注意Docker主机运行在单个主机上）。你还需要一种方法来编排所有这些容器，并提供其他功能，如容错性、水平自动扩展、秘密的分布、跨所有机器的服务命名和发现、滚动更新和负载均衡。提供这些功能的一个突出工具是Kubernetes。
- en: 'Kubernetes is an open source system for managing clusters of Docker containers.
    It was created by Google; several other companies have contributed to it, including
    Red Hat and Microsoft. Kubernetes provides tools for deploying and scaling applications,
    as well as managing changes to existing applications, such as updating to a new
    version or rolling back in the case of failure or health checks. Moreover, Kubernetes
    was created with two important features in mind: extensibility and fault tolerance.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个用于管理Docker容器集群的开源系统。它由Google创建；包括Red Hat和Microsoft在内的其他公司对其做出了贡献。Kubernetes提供了部署和扩展应用程序的工具，以及管理现有应用程序更改的工具，例如更新到新版本或在失败或健康检查的情况下回滚。此外，Kubernetes的创建考虑了两个重要特性：可扩展性和容错性。
- en: 'Following are the primary Kubernetes concepts you need to understand ([figure
    8.7](kindle_split_017_split_008.xhtml#ch08fig07) summarizes these concepts):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要理解的主要Kubernetes概念（[图8.7](kindle_split_017_split_008.xhtml#ch08fig07)总结了这些概念）：
- en: '*Pod*—The minimal unit of organization in Kubernetes. A pod is composed of
    one or more containers that are run on the same host machine and can share resources.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*—Kubernetes中的最小组织单元。Pod由一个或多个在同一主机机器上运行的容器组成，并且可以共享资源。'
- en: '*Service*—A set of pods and the policy by which to access them. Kubernetes
    provides a stable IP address and DNS name to the service, which abstracts from
    the pods’ location. Because pods are ephemeral, their IP address can change. Services
    react to this change by always forwarding to the location of the required pod.
    Services act as a load balancer among all pod instances.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Service*—一组Pod及其访问策略。Kubernetes为服务提供稳定的IP地址和DNS名称，从而抽象出Pod的位置。因为Pod是短暂的，它们的IP地址可能会改变。服务通过始终转发到所需Pod的位置来响应这种变化。服务在所有Pod实例之间充当负载均衡器。'
- en: '*Replication controller (RC)*—Maintains the desired state of the cluster. For
    example, if you need three instances of a pod, the RC will manage the given pod
    and always have three instances of it running on the cluster.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Replication controller (RC)*—维护集群的期望状态。例如，如果你需要一个Pod的三个实例，RC将管理给定的Pod，并始终在集群上运行三个实例。'
- en: '*Namespace*—A way to create a virtual cluster backed by a physical cluster.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Namespace*—一种创建由物理集群支持虚拟集群的方法。'
- en: Figure 8.7\. An example Kubernetes deployment
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7\. Kubernetes部署示例
- en: '![](Images/08fig07_alt.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig07_alt.jpg)'
- en: 'Usually, in Kubernetes, you define elements in a JSON or YAML file. For example,
    to define a pod, you could create the following pod-redis.json file:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Kubernetes中，你会在JSON或YAML文件中定义元素。例如，为了定义一个Pod，你可以创建以下pod-redis.json文件：
- en: '[PRE44]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This snippet defines a simple pod, using the `redis` container named `key-value-store`,
    exposing port number 6379 on the pod’s IP address.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段定义了一个简单的Pod，使用名为`key-value-store`的`redis`容器，在Pod的IP地址上暴露端口号6379。
- en: In Kubernetes, deploying an application/service isn’t done manually but rather
    is programmable and automatic. This implies that you need to test that what’s
    configured is what you expect to be deployed.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，部署应用程序/服务不是通过手动完成，而是通过可编程和自动完成。这意味着你需要测试配置的是你期望部署的内容。
- en: Arquillian Cube provides support for writing tests for Kubernetes. The idea
    behind the integration of Arquillian Cube and Kubernetes is to consume and test
    the provided services as well as validate that the environment is in the expected
    state. The integration lifecycle of Arquillian Cube and Kubernetes is summarized
    in [figure 8.8](kindle_split_017_split_008.xhtml#ch08fig08).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube 为 Kubernetes 测试提供支持。Arquillian Cube 和 Kubernetes 集成的理念是消费和测试提供的服务，以及验证环境是否处于预期的状态。Arquillian
    Cube 和 Kubernetes 的集成生命周期总结在[图 8.8](kindle_split_017_split_008.xhtml#ch08fig08)中。
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Only Arquillian standalone mode is supported in the integration of Arquillian
    Cube and Kubernetes.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 Arquillian 独立模式在 Arquillian Cube 和 Kubernetes 集成中受支持。
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 8.8\. Lifecycle of Arquillian Cube and Kubernetes integration
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8\. Arquillian Cube 和 Kubernetes 集成的生命周期
- en: '![](Images/08fig08_alt.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig08_alt.jpg)'
- en: Arquillian Cube Kubernetes creates a temporary namespace to deploy all Kubernetes
    resources in an isolated environment. Then it searches in the classpath for a
    file called kubernetes.json or kubernetes.yaml, and applies all Kubernetes resources
    required on that temporary namespace. Once everything is ready, it runs your tests
    (using a black box approach). And when testing is finished, it cleans up.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube Kubernetes 创建一个临时命名空间，在隔离环境中部署所有 Kubernetes 资源。然后它在类路径中搜索名为
    kubernetes.json 或 kubernetes.yaml 的文件，并在该临时命名空间上应用所需的全部 Kubernetes 资源。一切准备就绪后，它运行您的测试（使用黑盒方法）。测试完成后，它进行清理。
- en: '|  |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Arquillian Cube Kubernetes needs to authenticate into Kubernetes. To do so,
    Arquillian Cube reads user information (token and password) from ~/.kube/config.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube Kubernetes 需要认证到 Kubernetes。为此，Arquillian Cube 从 ~/.kube/config
    中读取用户信息（令牌和密码）。
- en: '|  |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can configure Arquillian Cube Kubernetes parameters in arquillian.xml. [Table
    8.3](kindle_split_017_split_008.xhtml#ch08table03) lists some of the most useful
    parameters.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 arquillian.xml 中配置 Arquillian Cube Kubernetes 参数。[表 8.3](kindle_split_017_split_008.xhtml#ch08table03)
    列出了一些最有用的参数。
- en: '|  |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Arquillian Cube Kubernetes can read properties from environment variables.
    The equivalent environment properties are property names in all caps, with the
    dot (`.`) symbol converted to `_`: for example, `KUBERNETES_MASTER`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube Kubernetes 可以从环境变量中读取属性。等效的环境属性是全部大写的属性名，点（`.`）符号转换为下划线（`_`）：例如，`KUBERNETES_MASTER`。
- en: '|  |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Table 8.3\. Arquillian Cube Kubernetes parameters
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.3\. Arquillian Cube Kubernetes 参数
- en: '| Attribute | Description | Default behavior |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 默认行为 |'
- en: '| --- | --- | --- |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| kubernetes.master | URL for the Kubernetes master |   |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.master | Kubernetes 主机的 URL |  |'
- en: '| env.config.url | URL for the Kubernetes JSON/YAML file | Defaults to a classpath
    resource kubernates.json |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| env.config.url | Kubernetes JSON/YAML 文件的 URL | 默认为类路径资源 kubernates.json
    |'
- en: '| env.dependencies | Whitespace-separated list of URLs pointing to more than
    one Kubernetes definition file |   |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| env.dependencies | 以空格分隔的 URL 列表，指向多个 Kubernetes 定义文件 |  |'
- en: '| env.config.resource.name | Option to select a different classpath resource
    |   |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| env.config.resource.name | 选项用于选择不同的类路径资源 |  |'
- en: '| namespace.use.existing | Flag that specifies not to generate a new temporary
    namespace, but to reuse the one that’s set |   |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| namespace.use.existing | 标志指定不生成新的临时命名空间，而是重用已设置的命名空间 |  |'
- en: '| env.init.enabled | Flag to initialize the environment with defined Kubernetes
    resources (goes hand to hand with namespace.use.existing) | By default, creates
    Kubernetes resources |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| env.init.enabled | 标志用于使用定义的 Kubernetes 资源初始化环境（与 namespace.use.existing
    一起使用） | 默认情况下，创建 Kubernetes 资源 |'
- en: '| namespace.cleanup.enabled | Instructs the extension to destroy the namespace
    after the end of the test suite | By default, destroys namespace to keep the cluster
    clean |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| namespace.cleanup.enabled | 指示扩展在测试套件结束后销毁命名空间 | 默认情况下，销毁命名空间以保持集群清洁 |'
- en: 'You can configure `kubernetes.master` (if the `KUBERNETES_MASTER` environment
    variable isn’t set), by setting it in arquillian.xml:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 arquillian.xml 中设置它来配置 `kubernetes.master`（如果未设置 `KUBERNETES_MASTER`
    环境变量）：
- en: '[PRE45]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Any Arquillian Cube Kubernetes test can be enriched with the following elements:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Arquillian Cube Kubernetes 测试都可以通过以下元素进行丰富：
- en: A Kubernetes client
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 客户端
- en: A session object containing test-session information such as the name of the
    temporarily created namespace
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含测试会话信息（如临时创建的命名空间名称）的会话对象
- en: A pod (by its ID) or a list of all pods started by the test
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 pod（通过其 ID）或测试启动的所有 pod 的列表
- en: An RC (by its ID) or a list of all RCs started by the test
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个RC（通过其ID）或由测试启动的所有RC的列表
- en: A service (by its ID) or a list of all services started by the test
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务（通过其ID）或由测试启动的所有服务的列表
- en: The URL of a service
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的URL
- en: 'The following test is enriched with some of these elements:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试通过以下元素进行了增强：
- en: '[PRE46]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Enriches the test with a service named my-service**'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在测试中增强名为my-service的服务**'
- en: '***2* Enriches the test with all pods defined in the test**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在测试中增强所有定义的Pod**'
- en: In this test, all information of a Kubernetes service called `my-service` can
    be queried. You can also access all pods defined in the current test. In a similar
    way, you can get the list of services by using `ServiceList`, or a concrete pod
    by using `@Named` and the `Pod` object. The same goes for RC objects.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，可以查询名为`my-service`的Kubernetes服务的所有信息。您还可以访问当前测试中定义的所有Pod。以类似的方式，您可以使用`ServiceList`获取服务列表，或使用`@Named`和`Pod`对象获取具体的Pod。对于RC对象也是如此。
- en: 'To inject a service URL, you do this:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要注入服务URL，您这样做：
- en: '[PRE47]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Service name**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 服务名称**'
- en: 'Moreover, as Arquillian Cube Docker does, Kubernetes integration provides tight
    integration with AssertJ, to provide a readable way of writing assertions about
    the environment. Here’s a simple example of how to use this integration:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如Arquillian Cube Docker所做的那样，Kubernetes集成提供了与AssertJ的紧密集成，以提供一种可读的方式来编写关于环境的断言。以下是一个如何使用此集成的一个简单示例：
- en: '[PRE48]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Kubernetes client enrichment**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Kubernetes客户端增强**'
- en: '***2* AssertJ Kubernetes integration’s assertThat method**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* AssertJ Kubernetes集成的assertThat方法**'
- en: This test asserts that the current `Deployment` creates at least one pod, which
    becomes available within a time period (by default, 30 seconds), and that it stays
    in the `Ready` state for a time period (by default, 1 second). This test is simple,
    but in our experience it catches most errors that may occur during deployment
    time on Kubernetes. Of course, this is just a start; you can add as many assertions
    as you need to validate that the application is deployed as required. Moreover,
    AssertJ Kubernetes provides custom assertions not only for `KubernetesClient`
    but also for pods, services, and RCs.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试断言当前`Deployment`至少创建一个Pod，该Pod在一段时间内（默认为30秒）变为可用，并且在该时间段内（默认为1秒）保持`Ready`状态。这个测试很简单，但根据我们的经验，它捕获了在Kubernetes部署期间可能发生的多数错误。当然，这只是开始；您可以根据需要添加尽可能多的断言来验证应用程序是否按要求部署。此外，AssertJ
    Kubernetes不仅为`KubernetesClient`提供自定义断言，还为Pod、服务和RC提供。
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Arquillian Cube Kubernetes and OpenShift**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arquillian Cube Kubernetes和OpenShift**'
- en: 'Arquillian Cube Kubernetes implements some extra features to help with testing
    through OpenShift:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Cube Kubernetes实现了一些额外的功能，以帮助通过OpenShift进行测试：
- en: Automatic setup of connecting to non-exported routes.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动设置连接到非导出路由。
- en: Triggering the build job/pipeline directly from the test. This pushes the `@Deployment`
    artifact to a local repository and triggers an OS build for deployment.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从测试触发构建作业/管道。这会将`@Deployment`工件推送到本地存储库并触发一个OS构建以进行部署。
- en: Because OpenShift version 3 is a Kubernetes system, everything that’s valid
    in Arquillian Cube Kubernetes is valid in OpenShift.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 因为OpenShift 3是一个Kubernetes系统，所以Arquillian Cube Kubernetes中所有有效的内容在OpenShift中也有效。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: After this introduction to using Docker for testing purposes and which tools
    you can use to automate tests using Docker, let’s see what you need to do to begin
    using them.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍如何使用Docker进行测试目的以及您可以使用哪些工具来自动化使用Docker的测试之后，让我们看看您需要做什么才能开始使用它们。
- en: 8.9\. Build-script modifications
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.9\. 构建脚本修改
- en: You’ve seen that Arquillian Cube has integrations with different technologies
    such as Docker, Kubernetes, and OpenShift. Each has its own dependencies, and
    the following sections cover how to add those dependencies to your tests.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到Arquillian Cube与不同的技术（如Docker、Kubernetes和OpenShift）有集成。每个都有自己的依赖项，以下部分将介绍如何将这些依赖项添加到您的测试中。
- en: 8.9.1\. Arquillian Cube Docker
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.9.1\. Arquillian Cube Docker
- en: 'To use Cube Docker integration, you need to add the following dependency:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Cube Docker集成，您需要添加以下依赖项：
- en: '[PRE49]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To use Drone/Graphene integration, you also need to add this:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Drone/Graphene集成，您还需要添加以下内容：
- en: '[PRE50]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that in this case, you need to add Selenium, Arquillian Drone, or Arquillian
    Graphene dependencies, as you did in [chapter 7](kindle_split_016_split_000.xhtml#ch07).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，您需要添加Selenium、Arquillian Drone或Arquillian Graphene依赖项，就像在[第7章](kindle_split_016_split_000.xhtml#ch07)中所做的那样。
- en: 'To use REST Assured integration, you also need to add the REST Assured dependency:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用REST Assured集成，您还需要添加REST Assured依赖项：
- en: '[PRE51]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, to use AssertJ integration, add the AssertJ dependency:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用 AssertJ 集成，添加 AssertJ 依赖项：
- en: '[PRE52]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 8.9.2\. Arquillian Cube Docker JUnit rule
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.9.2\. Arquillian Cube Docker JUnit 规则
- en: 'To use container DSL with JUnit rule support, add the following dependency:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用具有 JUnit 规则支持的容器 DSL，添加以下依赖项：
- en: '[PRE53]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 8.9.3\. Arquillian Cube Kubernetes
  id: totrans-566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.9.3\. Arquillian Cube Kubernetes
- en: 'To use Arquillian Cube with Kubernetes support, add this dependency:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用具有 Kubernetes 支持的 Arquillian Cube，添加以下依赖项：
- en: '[PRE54]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To use AssertJ integration, you also need to add this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 AssertJ 集成，你还需要添加以下内容：
- en: '[PRE55]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 8.9.4\. Arquillian Cube OpenShift
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.9.4\. Arquillian Cube OpenShift
- en: 'To use Arquillian Cube with specific features of OpenShift (not the Kubernetes
    part), add the following dependency:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Arquillian Cube 与 OpenShift 的特定功能（不是 Kubernetes 部分），添加以下依赖项：
- en: '[PRE56]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 8.10\. Testing the Dockerfile for the video service
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.10\. 测试视频服务的 Dockerfile
- en: The video service is packaged into a Docker image. To create this image, use
    the following Dockerfile (code/video/Dockerfile).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 视频服务被打包成一个 Docker 镜像。要创建此镜像，请使用以下 Dockerfile（code/video/Dockerfile）。
- en: Listing 8.14\. Video-service Dockerfile
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. 视频服务 Dockerfile
- en: '[PRE57]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, nothing special happens here. The output of the Spring Boot
    artifact is copied inside the image, and when the image is instantiated, the service
    is also started.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里没有发生任何特别的事情。Spring Boot 项目的输出被复制到镜像内部，当镜像被实例化时，服务也被启动。
- en: Next, you create a Docker Compose file to automate the building of the image
    (code/video/c-tests/src/test/resources/arquillian.xml).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个 Docker Compose 文件来自动化镜像的构建（code/video/c-tests/src/test/resources/arquillian.xml）。
- en: Listing 8.15\. Docker Compose file
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. Docker Compose 文件
- en: '[PRE58]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Builds and defines dependencies of the service**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 构建并定义服务的依赖项**'
- en: Finally, you can write the test to validate that the image can be built and
    the container instantiated (code/video/c-tests/src/test/java/book/video/VideoServiceContainerTest.java).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以编写测试来验证镜像可以构建并且容器可以实例化（code/video/c-tests/src/test/java/book/video/VideoServiceContainerTest.java）。
- en: Listing 8.16\. Validating the image and the container
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. 验证图像和容器
- en: '[PRE59]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Validates the Docker container properties**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 验证 Docker 容器属性**'
- en: This test uses Docker AssertJ integration. Although it isn’t mandatory, we recommend
    using it to maintain your test’s readability.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试使用 Docker AssertJ 集成。尽管这不是强制性的，但我们建议使用它以保持测试的可读性。
- en: When executing this test, Arquillian Cube instructs the Docker host to build
    and run the given image. If the image can be built, the test verifies that ports
    that should be exposed are still exposed (nobody has changed them in the Dockerfile)
    and finally verifies that the container is running.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此测试时，Arquillian Cube 指示 Docker 主机构建和运行给定的镜像。如果镜像可以构建，测试将验证应该公开的端口仍然公开（没有人更改
    Dockerfile 中的它们），并最终验证容器正在运行。
- en: '|  |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don’t need to build the image every time. Instead, you can create the image
    once in the CD build and then reuse it for each kind of test.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要每次都构建镜像。相反，你可以在 CD 构建中创建一次镜像，然后为每种测试重用它。
- en: '|  |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exercise
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: You should now be able to use Docker to set up a testing environment to run
    your tests. Using the video-service example, write a simple end-to-end test using
    REST Assured.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够使用 Docker 设置测试环境来运行你的测试。使用视频服务示例，编写一个简单的端到端测试，使用 REST Assured。
- en: Summary
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use Docker for testing purposes by using it to set up test environments.
    You can also use it to test applications that use Docker in production.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Docker 来设置测试环境，用于测试目的。你还可以用它来测试在生产中使用 Docker 的应用程序。
- en: You can write tests for the UI using Docker and Selenium/Arquillian Graphene
    so that everything, including the browser, is containerized.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Docker 和 Selenium/Arquillian Graphene 编写 UI 测试，以便将包括浏览器在内的所有内容容器化。
- en: The container-object pattern lets you create containers programmatically.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器对象模式允许你以编程方式创建容器。
- en: Docker doesn’t force you to use any specific language or framework. This means
    you can use Arquillian Cube to test any application written with any language,
    as long as it’s Dockerized. This is a perfect match for a microservices architecture,
    where each microservice may be coded in a different language.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 不强制你使用任何特定的语言或框架。这意味着你可以使用 Arquillian Cube 来测试任何用任何语言编写的应用程序，只要它是 Docker
    化的。这对于微服务架构来说是一个完美的匹配，因为每个微服务可能用不同的语言编写。
- en: If a microservice depends on an external service, you shouldn’t set up the testing
    environment using the real external service (doing so could make your tests flaky);
    you can use service virtualization to simulate external services. Because WireMock
    is an HTTP server, you can containerize it and use it in Docker. This way, you
    can use Docker to test microservice(s) and cut dependencies at the level you need,
    and simulate the responses with a WireMock/Hoverfly container.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务依赖于外部服务，你不应该使用真实的外部服务来设置测试环境（这样做可能会使你的测试变得不可靠）；你可以使用服务虚拟化来模拟外部服务。因为WireMock是一个HTTP服务器，你可以将其容器化并在Docker中使用。这样，你可以使用Docker来测试微服务（们），并在所需的级别上减少依赖，并通过WireMock/Hoverfly容器模拟响应。
