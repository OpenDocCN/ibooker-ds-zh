- en: 2 A basic API implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 基本的API实现
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reading and understanding the requirements of an API specification
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和理解API规范的要求
- en: Structuring our application into a data layer, an application layer, and an
    interface layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序结构化为数据层、应用层和接口层
- en: Implementing API endpoints using FastAPI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FastAPI实现API端点
- en: Implementing data validation models (schemas) using pydantic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pydantic实现数据验证模型（模式）
- en: Testing the API using a Swagger UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swagger UI测试API
- en: In this chapter, we implement the API for the orders service, which is one of
    the microservices of the CoffeeMesh website, the project we introduced in section
    1.5\. CoffeeMesh is an application that makes and delivers coffee on demand at
    any time, wherever you are. The orders service allows customers to place orders
    with CoffeeMesh. As we implement the orders API, you will get an early look into
    the concepts and processes that we dissect in more detail throughout this book.
    The code for this chapter is available under the ch02 folder of the GitHub repository
    provided with this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了订单服务的API，这是我们在1.5节中介绍的CoffeeMesh网站的一个微服务。CoffeeMesh是一个可以在任何时间、任何地点按需制作和配送咖啡的应用程序。订单服务允许客户通过CoffeeMesh下订单。在我们实现订单API的过程中，您将提前了解我们在本书中更详细地剖析的概念和流程。本章的代码可在本书提供的GitHub仓库的ch02文件夹中找到。
- en: 2.1 Introducing the orders API specification
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 订单API规范的介绍
- en: 'Let’s begin by analyzing the requirements of the orders API. Using the orders
    API, we can place orders, update them, retrieve their details, or cancel them.
    The orders API specification is available in a file named ch02/oas.yaml in the
    GitHub repository for this book. OAS stands for *OpenAPI specification*, which
    is a standard format for documenting REST APIs. In chapter 5, you’ll learn to
    document your APIs using OpenAPI. As you can see in figure 2.1, the API specification
    describes a REST API with four main URL paths:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从分析订单API的要求开始。使用订单API，我们可以下订单、更新订单、检索它们的详细信息或取消订单。订单API规范可在本书GitHub仓库的ch02/oas.yaml文件中找到。OAS代表*OpenAPI规范*，这是一种用于记录REST
    API的标准格式。如图2.1所示，API规范描述了一个具有四个主要URL路径的REST API。 '
- en: '`/orders`—Allows us to retrieve lists of orders (GET) and create orders (POST).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders`—允许我们检索订单列表（GET）和创建订单（POST）。'
- en: '`/orders/{order_id}`—Allows us to retrieve the details of a specific order
    (GET), to update an order (PUT), and to delete an order (DELETE).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}`—允许我们检索特定订单的详细信息（GET），更新订单（PUT），以及删除订单（DELETE）。'
- en: '`/orders/{order_id}/cancel`—Allows us to cancel an order (POST).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}/cancel`—允许我们取消订单（POST）。'
- en: '`/orders/{order_id}/pay`—Allows us to pay for an order (POST).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}/pay`—允许我们为订单付款（POST）。'
- en: '![](../Images/02-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-01.png)'
- en: Figure 2.1 The orders API exposes seven endpoints structured around four URL
    paths. Each endpoint implements different capabilities, such as placing and cancelling
    an order.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 订单API公开了围绕四个URL路径结构的七个端点。每个端点实现不同的功能，例如下订单和取消订单。
- en: In addition to documenting the API endpoints, the specification also includes
    data models that tell us what the data exchanged over those endpoints looks like.
    In OpenAPI, we call those models *schemas*, and you can find them within the components
    section of the orders API specification. Schemas tell us what properties must
    be included in a payload and what their types are.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了记录API端点外，规范还包括数据模型，告诉我们通过这些端点交换的数据看起来像什么。在OpenAPI中，我们称这些模型为*模式*，您可以在订单API规范的组件部分找到它们。模式告诉我们必须包含哪些属性以及它们的类型。
- en: For example, the `OrderItemSchema` schema specifies that the `product` and the
    `size` properties are required, but the `quantity` property is optional. When
    the `quantity` property is missing from the payload, the default value is `1`.
    Our API implementation must therefore enforce the presence of the `product` and
    the `size` properties in the payload before we try to create the order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`OrderItemSchema`模式指定`product`和`size`属性是必需的，但`quantity`属性是可选的。当`quantity`属性从有效负载中缺失时，默认值是`1`。因此，我们的API实现必须在尝试创建订单之前强制执行有效负载中`product`和`size`属性的存在。
- en: Listing 2.1 Specification for `OrderItemSchema`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 `OrderItemSchema`规范
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we understand the requirements for building the orders API, let’s look
    at the architectural layout we will use for the implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了构建订单API的要求，让我们看看我们将用于实施的架构布局。
- en: 2.2 High-level architecture of the orders application
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 订单应用的高级架构
- en: This section offers a high-level overview of the orders API’s architectural
    layout. Our goal is to identify the layers of the application and to enforce clear
    boundaries and separation of concerns between all layers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了订单API架构布局的高级概述。我们的目标是确定应用程序的层，并在所有层之间强制执行清晰的边界和关注点的分离。
- en: 'As you can see in figure 2.2, we organize into three layers: the API layer,
    the business layer, and the data layer.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如图2.2所示，我们将组织成三层：API层、业务层和数据层。
- en: '![](../Images/02-02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-02.png)'
- en: 'Figure 2.2 To enforce separation of concerns among the different components
    of our service, we structure our code around three layers: the data layer knows
    how to interface with the source of data; the business layer implements the service’s
    capabilities; and the interface layer implements the service’s API.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 为了在我们的服务不同组件之间强制执行关注点的分离，我们围绕三个层次结构化我们的代码：数据层知道如何与数据源接口；业务层实现服务的功能；接口层实现服务的API。
- en: This way of structuring the application is an adaptation of the three-tier architecture
    pattern, which structures applications into a data layer, a business layer, and
    a presentation layer. As you can see in figure 2.3, the data layer is the part
    of the application that knows how to persist data so that we can retrieve it later.
    The data layer implements the data models required for interfacing with our source
    of data. For example, if our persistent storage is an SQL database, the models
    in the data layer will represent the tables in the database, often with the help
    of an object relational mapper (ORM) framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建应用程序的方式是对三层架构模式的改编，它将应用程序结构化为数据层、业务层和表示层。如图2.3所示，数据层是应用程序中知道如何持久化数据以便我们以后可以检索的部分。数据层实现了与我们的数据源接口所需的数据模型。例如，如果我们的持久化存储是SQL数据库，数据层中的模型将代表数据库中的表，通常需要使用对象关系映射（ORM）框架。
- en: '![](../Images/02-03.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-03.png)'
- en: Figure 2.3 When a user request reaches the orders service, it’s first validated
    by the interface layer. Then the interface layer interfaces with the business
    layer to process the request. After processing, the data layer persists the data
    contained in the request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 当用户请求到达订单服务时，它首先由接口层进行验证。然后接口层与业务层接口以处理请求。处理完毕后，数据层将请求中包含的数据持久化。
- en: The business layer implements our service’s capabilities. It controls the interactions
    between the API layer and the data layer. For the orders service, it’s the part
    that knows what to do to place, cancel, or pay for an order.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层实现我们服务的功能。它控制API层和数据层之间的交互。对于订单服务来说，它是知道如何处理订单放置、取消或支付的部分。
- en: The API layer of a service is different from the business layer. The business
    layer implements the capabilities of a service, while the API layer is an adapter
    on top of the application logic that exposes the service’s capabilities to its
    consumers. Figure 2.2 illustrates this relationship among the layers of a service,
    while figure 2.3 illustrates how a user request is processed by each layer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的API层与业务层不同。业务层实现服务的功能，而API层是应用逻辑之上的适配器，它将服务的功能暴露给消费者。图2.2说明了服务层之间的关系，而图2.3说明了用户请求是如何被每一层处理的。
- en: The API layer is an adapter on top of the business layer. Its most important
    job is validating incoming requests and returning the expected responses. The
    API layer communicates with the business layer, passing the data sent by the user,
    so that resources can be processed and persisted in the server. The API layer
    is equivalent to the presentation layer in three-tier architecture. Now that we
    know how we are going to structure our application, let’s jump straight into the
    code!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: API层是业务层之上的适配器。其最重要的任务是验证传入的请求并返回预期的响应。API层与业务层通信，传递用户发送的数据，以便资源可以在服务器上被处理和持久化。API层相当于三层架构中的表示层。既然我们已经知道了我们将如何构建我们的应用程序，那么我们就直接进入代码吧！
- en: 2.3 Implementing the API endpoints
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 实现API端点
- en: In this section, you will learn to implement the API layer of the orders service.
    I’ll show you how to break down the implementation of the API into progressive
    steps. In the first step, we produce a minimal implementation of the endpoints
    with mock responses. In the following sections of this chapter, we enhance the
    implementation by adding data validation and dynamic responses. You’ll also learn
    about the FastAPI library and how you can use it to build a web API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何实现订单服务的API层。我会向你展示如何将API的实现分解成逐步的步骤。在第一步中，我们将使用模拟响应生成端点的最小实现。在本章的后续部分，我们将通过添加数据验证和动态响应来增强实现。你还将了解FastAPI库以及如何使用它来构建Web
    API。
- en: What is FastAPI?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是FastAPI？
- en: FastAPI ([https://github.com/tiangolo/fastapi](https://github.com/tiangolo/fastapi))
    is a web API framework built on top of Starlette ([https://github.com/encode/starlette](https://github.com/encode/starlette)).
    Starlette is a high-performance, lightweight, asynchronous server gateway interface
    (ASGI) web framework, which means that we can implement our services as a collection
    of asynchronous tasks to gain performance in our applications. In addition, FastAPI
    uses pydantic ([https://github.com/samuelcolvin/pydantic/](https://github.com/samuelcolvin/pydantic/))
    for data validation. The following figure illustrates how all these different
    technologies fit together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI ([https://github.com/tiangolo/fastapi](https://github.com/tiangolo/fastapi))是一个建立在Starlette
    ([https://github.com/encode/starlette](https://github.com/encode/starlette))之上的Web
    API框架。Starlette是一个高性能、轻量级、异步的服务器网关接口（ASGI）Web框架，这意味着我们可以将我们的服务实现为一系列异步任务，以在我们的应用程序中获得性能提升。此外，FastAPI使用pydantic
    ([https://github.com/samuelcolvin/pydantic/](https://github.com/samuelcolvin/pydantic/))进行数据验证。以下图示说明了所有这些不同技术是如何结合在一起的。
- en: '![](../Images/02-03_UN01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-03_UN01.png)'
- en: Uvicorn ([https://github.com/encode/uvicorn](https://github.com/encode/uvicorn))
    is an asynchronous web server commonly used to run Starlette applications. Uvicorn
    handles HTTP requests and passes them on to Starlette, which functions within
    your application to call when a request arrives in the server. FastAPI is built
    on top of Starlette, and it enhances Starlette’s routes with data validation and
    API documentation functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Uvicorn ([https://github.com/encode/uvicorn](https://github.com/encode/uvicorn))是一个异步Web服务器，通常用于运行Starlette应用程序。Uvicorn处理HTTP请求并将它们传递给Starlette，Starlette在你的应用程序中工作，当服务器收到请求时调用。FastAPI建立在Starlette之上，并通过数据验证和API文档功能增强了Starlette的路由。
- en: Before we start implementing the API, we need to set up our environment for
    this project. Create a folder named ch02 and move into it using the `cd` command
    in your terminal. We’ll use Pipenv to install and manage our dependencies.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现API之前，我们需要为这个项目设置我们的环境。创建一个名为ch02的文件夹，并使用终端中的`cd`命令进入该文件夹。我们将使用Pipenv来安装和管理我们的依赖项。
- en: About dependencies
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于依赖项
- en: If you want to make sure you use the same dependencies that I used when writing
    this book, you can fetch the ch02/Pipfile and ch02/Pipfile.lock files from the
    GitHub repository for this book and run `pipenv` `install`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保你使用的是我在编写这本书时使用的相同依赖项，你可以从这本书的GitHub仓库中获取ch02/Pipfile和ch02/Pipfile.lock文件，并运行`pipenv
    install`。
- en: '`Pipfile` describes the environment that we wish to create with Pipenv. Among
    other things, `Pipfile` contains the version of Python that must be used to create
    the environment and the URLs of the PyPi repositories that must be used to pull
    the dependencies. Pipenv also makes it easier to keep production dependencies
    separate from development dependencies by providing specific installation flags
    for each set. For example, to install `pytest` we run `pipenv` `install` `pytest`
    `--dev`. Pipenv also exposes commands that allow us to easily manage our virtual
    environments, such as `pipenv` `shell` to activate the virtual environment or
    `pipenv` `--rm` to delete the virtual environment.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipfile`描述了我们希望使用Pipenv创建的环境。其中包含了许多内容，例如必须用于创建环境的Python版本和必须用于拉取依赖项的PyPi仓库的URL。Pipenv还通过为每个集合提供特定的安装标志，使得将生产依赖项与开发依赖项分开变得更容易。例如，要安装`pytest`，我们运行`pipenv
    install pytest --dev`。Pipenv还公开了允许我们轻松管理我们的虚拟环境的命令，例如使用`pipenv shell`激活虚拟环境或使用`pipenv
    --rm`删除虚拟环境。'
- en: Pipenv is a dependency management tool for Python that guarantees that the same
    versions of our dependencies are installed in different environments. In other
    words, Pipenv makes it possible to create environments in a deterministic way.
    To accomplish that, Pipenv uses a file called Pipfile.lock, which contains a description
    of the exact package versions that were installed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pipenv是Python的一个依赖项管理工具，它确保在不同的环境中安装了相同版本的依赖项。换句话说，Pipenv使得以确定性的方式创建环境成为可能。为了实现这一点，Pipenv使用一个名为Pipfile.lock的文件，其中包含已安装的确切包版本描述。
- en: Listing 2.2 Creating a virtual environment and installing dependencies with
    `pipenv`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 使用`pipenv`创建虚拟环境并安装依赖项
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Create a virtual environment using pipenv and setting the runtime to Python
    3.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用pipenv创建虚拟环境并设置运行时为Python 3。
- en: ② Install FastAPI and Uvicorn.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ② 安装FastAPI和Uvicorn。
- en: ③ Activate the virtual environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 激活虚拟环境。
- en: 'Now that our dependencies are installed, let’s build the API. First, copy the
    API specification under ch02/oas.yaml in the GitHub repository for this book in
    the ch02 folder we created earlier. Then create a subfolder named orders, which
    will contain our API implementation. Within the orders folder, create a file called
    app.py. Create another subfolder called orders/api, and within that folder create
    a file called orders/api/ api.py. At this point, the project structure should
    look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了依赖项，让我们构建API。首先，复制GitHub仓库中ch02/oas.yaml下的API规范到我们之前创建的ch02文件夹中。然后创建一个名为orders的子文件夹，它将包含我们的API实现。在orders文件夹内，创建一个名为app.py的文件。再创建一个名为orders/api的子文件夹，并在该文件夹内创建一个名为orders/api/api.py的文件。此时，项目结构应该看起来像这样：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 2.3 shows how to create an instance of the FastAPI application in file
    orders/ app.py. The instance of the `FastAPI` class from FastAPI is an object
    that represents the API we are implementing. It provides *decorators* (functions
    that add additional functionality to a function or class) that allow us to register
    our view functions.[¹](#pgfId-1073824)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3展示了如何在文件orders/app.py中创建FastAPI应用程序的实例。从FastAPI来的`FastAPI`类实例代表我们正在实现的API。它提供了*装饰器*（向函数或类添加额外功能的函数），允许我们注册我们的视图函数。[¹](#pgfId-1073824)
- en: Listing 2.3 Creating an instance of the FastAPI application
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 创建FastAPI应用程序实例
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① We create an instance of the FastAPI class. This object represents our API
    application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建FastAPI类的实例。这个对象代表我们的API应用程序。
- en: ② We import the api module so that our view functions can be registered at load
    time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们导入api模块，以便我们的视图函数可以在加载时注册。
- en: Listing 2.4 shows a minimal implementation of our API endpoints. The code goes
    within the orders/api/api.py file. We declare a static `order` object, and we
    return the same data in all the endpoints except the DELETE `/orders/{order_id}`
    endpoint, which returns an empty response. Later, we’ll change the implementation
    to use a dynamic list of orders. FastAPI decorators transform the data we return
    in every function into an HTTP response; they also map our functions to a specific
    URL in our server. By default, FastAPI includes 200 (OK) status codes in our responses,
    but we can override this behavior by using the `status_code` parameter in the
    routes decorators, like we do in the POST `/orders` and in the DELETE `/orders/{order_id}`
    endpoints.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4展示了我们API端点的最小实现。代码位于orders/api/api.py文件中。我们声明了一个静态`order`对象，并在所有端点中返回相同的数据，除了DELETE
    `/orders/{order_id}`端点，它返回一个空响应。稍后，我们将更改实现以使用动态订单列表。FastAPI装饰器将每个函数返回的数据转换为HTTP响应；它们还将我们的函数映射到服务器中的特定URL。默认情况下，FastAPI在我们的响应中包含200（OK）状态码，但我们可以通过在路由装饰器中使用`status_code`参数来覆盖此行为，就像我们在POST
    `/orders`和DELETE `/orders/{order_id}`端点中所做的那样。
- en: Listing 2.4 Minimal implementation of the orders API
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 订单API的最小实现
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① We define an order object to return in our responses.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义一个订单对象以返回我们的响应。
- en: ② We register a GET endpoint for the /orders URL path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们为/orders URL路径注册了一个GET端点。
- en: ③ We specify that the response’s status code is 201 (Created).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们指定响应的状态码为201（已创建）。
- en: ④ We define URL parameters, such as order_id, within curly brackets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们在花括号内定义URL参数，例如order_id。
- en: ⑤ We capture the URL parameter as a function argument.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们捕获URL参数作为函数参数。
- en: ⑥ We use HTTPStatus.NO_CONTENT.value to return an empty response.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们使用 HTTPStatus.NO_CONTENT.value 来返回一个空响应。
- en: FastAPI exposes decorators named after HTTP methods, such as `get()` and `post()`.
    We use these decorators to register our API endpoints. FastAPI’s decorators take
    at least one argument, which is the URL path we want to register.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI公开了以HTTP方法命名的装饰器，例如`get()`和`post()`。我们使用这些装饰器来注册我们的API端点。FastAPI的装饰器至少接受一个参数，即我们想要注册的URL路径。
- en: Our view functions can take any number of parameters. If the name of the parameter
    matches the name of a URL path parameter, FastAPI passes the path parameter from
    the URL to our view function on invocation. For example, as you can see in figure
    2.4, the URL `/orders/{order_id}` defines a path parameter named `order_id`, and
    accordingly our view functions registered for that URL path take an argument named
    `order_id`. If a user navigates to the URL /orders/53e80ed2-b9d6-4c3b-b549-258aaaef9533,
    our view functions will be called with the `order_id` parameter set to `53e80ed2-b9d6-4c3b-b549-258aaaef9533`.
    FastAPI allows us to specify the type and format of the URL path parameter by
    using type hints. In listing 2.4, we specify that `order_id`’s type is a *universally
    unique identifier* (UUID). FastAPI will invalidate any calls in which `order_id`
    doesn’t follow that format.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点函数可以接受任意数量的参数。如果参数的名称与URL路径参数的名称匹配，FastAPI在调用时会将路径参数从URL传递到我们的视图函数中。例如，如图2.4所示，URL
    `/orders/{order_id}` 定义了一个名为 `order_id` 的路径参数，相应地，我们为该URL路径注册的视图函数接受一个名为 `order_id`
    的参数。如果用户导航到URL /orders/53e80ed2-b9d6-4c3b-b549-258aaaef9533，我们的视图函数将被调用，并将 `order_id`
    参数设置为 `53e80ed2-b9d6-4c3b-b549-258aaaef9533`。FastAPI允许我们通过使用类型提示来指定URL路径参数的类型和格式。在列表2.4中，我们指定
    `order_id` 的类型是一个*通用唯一标识符*（UUID）。FastAPI将使任何不符合该格式的 `order_id` 调用无效。
- en: '![](../Images/02-04.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-04.png)'
- en: Figure 2.4 FastAPI knows how to map a request to the right function, and it
    passes any relevant parameters from the request to the function. In this illustration,
    a GET request on the `/orders/{order_id}` endpoint with `order_id` set to `ff0f1355-e821-4178-9567-550dec27a373`
    is passed to the `get_order()` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 FastAPI知道如何将请求映射到正确的函数，并将任何相关的参数从请求传递到函数中。在这个示例中，一个对`/orders/{order_id}`端点的GET请求，其中`order_id`设置为`ff0f1355-e821-4178-9567-550dec27a373`，被传递到`get_order()`函数。
- en: FastAPI responses include a 200 (OK) status code by default, but we can change
    this behavior by setting the `status_code` parameter in the endpoints’ decorators.
    In listing 2.4, we set `status_code` to 201 (Created) in the POST `/orders` endpoint,
    and to 204 (No Content) in the DELETE `/orders/{order_id}` endpoint. For a detailed
    explanation of status codes, see section 4.6 in chapter 4.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI的响应默认包含一个200（OK）状态码，但我们可以通过在端点装饰器中设置`status_code`参数来改变这种行为。在列表2.4中，我们在POST
    `/orders`端点中将`status_code`设置为201（已创建），在DELETE `/orders/{order_id}`端点中设置为204（无内容）。有关状态码的详细解释，请参阅第4章第4.6节。
- en: 'You can now run the app to get a feeling of what the API looks like by executing
    the following command from the top-level orders directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从顶级`orders`目录执行以下命令来运行应用程序，以了解API的外观：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command loads the server with hot reloading enabled. *Hot reloading* restarts
    your server whenever you make changes to your files. Visit the http://127.0.0.1:8000/docs
    URL in a browser and you will see an interactive display of the API documentation
    generated by FastAPI from our code (see figure 2.5 for an illustration). This
    visualization is called Swagger UI, and it’s one of the most popular ways of visualizing
    REST APIs. Another popular visualization is Redoc, which is also supported by
    FastAPI under the http://127.0.0.1:8000/redoc URL.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令加载服务器并启用热重载。*热重载*会在您更改文件时重启您的服务器。在浏览器中访问http://127.0.0.1:8000/docs URL，您将看到由FastAPI从我们的代码生成的API文档的交互式显示（见图2.5）。这种可视化称为Swagger
    UI，它是可视化REST API中最受欢迎的方式之一。另一种流行的可视化是Redoc，它也由FastAPI支持，可通过http://127.0.0.1:8000/redoc
    URL访问。
- en: '![](../Images/02-05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-05.png)'
- en: Figure 2.5 View of the Swagger UI dynamically generated by FastAPI from our
    code. We can use this view to test the implementation of our endpoints.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 由FastAPI从我们的代码动态生成的Swagger UI视图。我们可以使用这个视图来测试端点的实现。
- en: If you click on any of the endpoints represented in the Swagger UI, you will
    see additional documentation about the endpoint. You will also see a Try it Out
    button, which gives you the opportunity to test the endpoint directly from this
    UI. Click that button, then click Execute, and you will get the hardcoded response
    we included in our endpoints (see figure 2.6 for an illustration).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 Swagger UI 中表示的任何端点，你将看到有关端点的附加文档。你还将看到一个“尝试一下”按钮，它给你直接从该 UI 测试端点的机会。点击该按钮，然后点击“执行”，你将得到我们包含在端点中的硬编码响应（参见图
    2.6 以获得说明）。
- en: '![](../Images/02-06.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-06.png)'
- en: Figure 2.6 To test an endpoint, click it to expand it. You’ll see a Try it Out
    button on the top-right corner of the endpoint’s description. Click that button,
    and then click the Execute button. This triggers a request to the server, and
    you’ll be able to see the response.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 要测试一个端点，点击它以展开。你将在端点描述的右上角看到一个“尝试一下”按钮。点击该按钮，然后点击“执行”按钮。这将触发对服务器的请求，你将能够看到响应。
- en: Now that we have the basic skeleton of our API, we’ll move on to implementing
    validators for our incoming payloads and our outgoing responses. The next section
    walks you through the steps needed to accomplish that.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们 API 的基本框架，接下来我们将转向实现我们传入的有效载荷和输出的响应的验证器。下一节将指导你完成这一步骤。
- en: 2.4 Implementing data validation models with pydantic
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用 pydantic 实现数据验证模型
- en: Now that we have implemented the main layout for the URL paths of our API, we
    need to add validation for incoming payloads and how we marshal our outgoing responses.
    Data validation and marshalling are crucial operations in an API, and to deliver
    a successful API integration, we need to get them right. In the following sections,
    you’ll learn to add robust data validation and marshalling capabilities to your
    APIs. FastAPI uses pydantic for data validation, so we’ll start by learning to
    create pydantic models in this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了我们 API 的 URL 路径的主要布局，我们需要添加对传入的有效载荷和我们的输出响应的验证。数据验证和序列化是 API 中的关键操作，为了成功实现
    API 集成，我们需要正确处理它们。在接下来的章节中，你将学习如何为你的 API 添加强大的数据验证和序列化功能。FastAPI 使用 pydantic 进行数据验证，因此我们将从本节开始学习如何创建
    pydantic 模型。
- en: DEFINITION *Marshalling* is the process of transforming an in-memory data structure
    into a format suitable for storage or transmission over a network. In the context
    of web APIs, marshalling refers to the process of transforming an object into
    a data structure that can be serialized into a content type of choice, like XML
    or JSON, with explicit mappings for the object attributes (see figure 2.7 for
    an illustration).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *序列化* 是将内存中的数据结构转换为适合存储或通过网络传输的格式的过程。在 Web API 的上下文中，序列化指的是将对象转换为可以序列化为所选内容类型（如
    XML 或 JSON）的数据结构的过程，并具有对对象属性的显式映射（参见图 2.7 以获得说明）。
- en: '![](../Images/02-07.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-07.png)'
- en: Figure 2.7 To build a response payload from a Python object, we first marshal
    the object into a serializable data structure, with explicit mapping of attributes
    between the object and the new structure. Deserializing the payload gives us back
    an object identical to the one we serialized.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 要从 Python 对象构建响应有效载荷，我们首先将对象序列化为可序列化的数据结构，并在对象和新的结构之间显式映射属性。反序列化有效载荷将给我们回一个与序列化时相同的对象。
- en: 'The orders API specification contains three schemas: `CreateOrderSchema`, `GetOrderSchema`,
    and `OrderItemSchema`. Let’s analyze these schemas to make sure we understand
    how we need to implement our validation models.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 订单 API 规范包含三个模式：`CreateOrderSchema`、`GetOrderSchema` 和 `OrderItemSchema`。让我们分析这些模式，以确保我们理解我们需要如何实现我们的验证模型。
- en: Listing 2.5 Specification for the orders API schemas
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 订单 API 模式的规范
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Every schema has a type, which in this case is an object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ① 每个模式都有一个类型，在这个例子中是一个对象。
- en: ② We list compulsory properties under the required keyword.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们在 required 关键字下列出强制属性。
- en: ③ We list object properties under the properties keyword.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们在 properties 关键字下列出对象属性。
- en: ④ We constrain the values of a property using an enumeration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们使用枚举来约束属性的值。
- en: ⑤ Attributes can have a default value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 属性可以有一个默认值。
- en: ⑥ We can also specify a minimum value for a property.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们还可以指定属性的最低值。
- en: ⑦ We specify the type of the items in the array using the items keyword.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们使用 items 关键字指定数组中项的类型。
- en: ⑧ We use a JSON pointer to reference another schema within the same document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们使用 JSON 指针来引用同一文档内的另一个模式。
- en: 'We use `GetOrderSchema` when we return the details of an order from the server
    and `CreateOrderSchema` to validate an order placed by a customer. Figure 2.8
    illustrates how the data validation flow works for `CreateOrderSchema`. As you
    can see, `CreateOrderSchema` only requires the presence of one property in the
    payload: the `order` property, which is an array of objects whose specification
    is defined by `OrderItemSchema`. `OrderItemSchema` has two required properties,
    `product` and `size`, and one optional property, `quantity`, which has a default
    value of `1`. This means that, when processing a request payload, we must check
    that the `product` and `size` properties are present in the payload and that they
    have the right type. Figure 2.8 shows what happens when the `quantity` property
    is missing from the payload. In that case, we set the property to its default
    value of `1` in the server.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从服务器返回订单详情时使用`GetOrderSchema`，而当验证客户放置的订单时使用`CreateOrderSchema`。图2.8说明了`CreateOrderSchema`的数据验证流程。如图所示，`CreateOrderSchema`只要求有效载荷中存在一个属性：`order`属性，它是一个对象数组，其规范由`OrderItemSchema`定义。`OrderItemSchema`有两个必需属性，`product`和`size`，以及一个可选属性`quantity`，其默认值为`1`。这意味着在处理请求有效载荷时，我们必须检查有效载荷中是否存在`product`和`size`属性，并且它们具有正确的类型。图2.8显示了当有效载荷中缺少`quantity`属性时会发生什么。在这种情况下，我们在服务器中将该属性设置为默认值`1`。
- en: '![](../Images/02-08.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-08.png)'
- en: Figure 2.8 Data validation flow for request payloads against the `CreateOrderSchema`
    model. The diagram shows how each property of the request payload is validated
    against the properties defined in the schema and how we build an object from the
    resulting validation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 `CreateOrderSchema`模型对请求有效载荷的数据验证流程。该图显示了请求有效载荷的每个属性是如何与模式中定义的属性进行验证的，以及我们是如何从验证结果构建对象的。
- en: Now that we understand our API schemas, it’s time to implement them. Create
    a new file called orders/api/schemas.py. This file will contain our pydantic models.
    Listing 2.6 shows how we implement `CreateOrderSchema`, `GetOrderSchema`, and
    `OrderItemSchema` using pydantic. The code in listing 2.6 goes in the orders/api/schemas.py
    module. We define every schema as a class that inherits from pydantic’s `BaseModel`
    class, and we specify the type of every attribute using Python type hints. For
    attributes that can only take on a limited selection of values, we define an enumeration
    class. In this case, we define enumerations for the `size` and `status` properties.
    We set the type of `OrderItemSchema`’s `quantity` property to pydantic’s `conint`
    type, which enforces integer values. We also specify that `quantity` is an optional
    property and that its values should be equal or greater than 1, and we give it
    a default value of 1\. Finally, we use pydantic’s `conlist` type to define `CreateOrderSchema`’s
    `order` property as a list with at least one element.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了我们的API模式，是时候实现它们了。创建一个名为`orders/api/schemas.py`的新文件。该文件将包含我们的pydantic模型。列表2.6显示了如何使用pydantic实现`CreateOrderSchema`、`GetOrderSchema`和`OrderItemSchema`。列表2.6中的代码位于`orders/api/schemas.py`模块中。我们定义每个模式为一个继承自pydantic的`BaseModel`类的类，并使用Python类型提示指定每个属性的类型。对于只能取有限值集合的属性，我们定义一个枚举类。在这种情况下，我们为`size`和`status`属性定义了枚举。我们将`OrderItemSchema`的`quantity`属性的类型设置为pydantic的`conint`类型，该类型强制执行整数值。我们还指定`quantity`是一个可选属性，其值应等于或大于1，并为其提供一个默认值1。最后，我们使用pydantic的`conlist`类型将`CreateOrderSchema`的`order`属性定义为至少包含一个元素的列表。
- en: Listing 2.6 Implementation of the validation models using pydantic
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 使用pydantic实现验证模型
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① We declare an enumeration schema.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明一个枚举模式。
- en: ② Every pydantic model inherits from pydantic’s BaseModel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ② 每个pydantic模型都继承自pydantic的BaseModel。
- en: ③ We use Python-type hints to specify the type of an attribute.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用Python类型提示来指定属性的类型。
- en: ④ We constrain the values of a property by setting its type to an enumeration.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们通过将属性的类型设置为枚举来约束属性的值。
- en: ⑤ We specify quantity’s minimum value, and we give it a default.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们指定数量的最小值，并为其提供一个默认值。
- en: ⑥ We use pydantic’s conlist type to define a list with at least one element.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们使用pydantic的conlist类型来定义至少包含一个元素的列表。
- en: Now that our validation models are implemented, in the following sections we’ll
    link them with the API to validate and marshal payloads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了验证模型，在接下来的部分中，我们将它们与API链接起来以验证和打包有效载荷。
- en: 2.5 Validating request payloads with pydantic
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 使用pydantic验证请求有效载荷
- en: In this section, we use the models we implemented in section 2.4 to validate
    request payloads. How do we access request payloads within our view functions?
    We intercept request payloads by declaring them as a parameter of the view function,
    and to validate them we set their type to the relevant pydantic model.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用在第2.4节中实现的模型来验证请求负载。我们如何在视图函数中访问请求负载？我们通过将它们声明为视图函数的参数来拦截请求负载，并通过将它们的类型设置为相关的pydantic模型来验证它们。
- en: Listing 2.7 Hooking validation models up with the API endpoints
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 将验证模型与API端点连接
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① We import the pydantic models so that we can use them for validation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入pydantic模型，以便可以使用它们进行验证。
- en: ② We intercept a payload by declaring it as a parameter in our function, and
    we use type hints to validate it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们通过在函数中声明它作为参数来拦截负载，并使用类型提示来验证它。
- en: 'If you kept the application running, the changes are loaded automatically by
    the server, so you just need to refresh the browser to update the UI. If you click
    the POST endpoint of the /orders URL path, you’ll see that the UI now gives you
    an example of the payload expected by the server. Now, if you try editing the
    payload to remove any of the required fields, for example, the `product` field,
    and you send it to the server, you’ll get the following error message:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保持应用程序运行，更改将自动由服务器加载，因此你只需刷新浏览器即可更新UI。如果你点击/orders URL路径的POST端点，你会看到UI现在为你提供了一个服务器期望的负载示例。现在，如果你尝试编辑负载以删除任何必需的字段，例如`product`字段，并将其发送到服务器，你将收到以下错误信息：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'FastAPI generates an error message that points to where in the payload the
    error is found. The error message uses a JSON pointer to indicate where the problem
    is. A JSON pointer is a syntax that allows you to represent the path to a specific
    value within a JSON document. If this is the first time you’ve encountered JSON
    pointers, think of them as a different way of representing dictionary syntax and
    index notation in Python. For example, the error message `"loc:` `/body/order/0/product"`
    is roughly equivalent to the following notation in Python: `loc[''body''][''order''][0][''product'']`.
    Figure 2.9 shows you how to interpret the JSON pointer from the error message
    to identify the source of the problem in the payload.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI生成了一个错误信息，该信息指向了负载中错误发生的位置。错误信息使用JSON指针来指示问题所在。JSON指针是一种语法，允许你在JSON文档中表示特定值的路径。如果你第一次遇到JSON指针，可以将它们视为在Python中表示字典语法和索引记法的一种不同方式。例如，错误信息`"loc:`
    `/body/order/0/product"`大致等同于Python中的以下表示：`loc['body']['order'][0]['product']`。图2.9展示了如何从错误信息中解释JSON指针，以确定负载中问题的来源。
- en: '![](../Images/02-09.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9](../Images/02-09.png)'
- en: Figure 2.9 When a request fails due a malformed payload, we get a response with
    an error message. The error message uses a JSON pointer to tell us where the error
    is. In this case, the error message says that the property `/body/order/0/product`
    is missing from the payload.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 当请求因负载格式错误而失败时，我们收到一个包含错误信息的响应。错误信息使用JSON指针告诉我们错误的位置。在这种情况下，错误信息指出，属性`/body/order/0/product`在负载中缺失。
- en: 'You can also change the payload so that, instead of missing a required property,
    it contains an illegal value for the `size` property:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以更改负载，使其不缺少必需的属性，而是包含`size`属性的非法值：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, you’ll also get an informative error with the following message:
    `"value` `is` `not` `a` `valid` `enumeration` `member;` `permitted:` `''small'',`
    `''medium'',` `''big''"`. What happens if we make a typo in the payload? For example,
    imagine a client sent the following payload to the server:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你也会收到以下信息的错误信息：`"value` `is` `not` `a` `valid` `enumeration` `member;`
    `permitted:` `'small',` `'medium',` `'big'"`。如果我们对负载中的内容输入错误会发生什么？例如，想象一个客户端向服务器发送以下负载：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, FastAPI assumes that the `quantity` property is missing and that
    the client wishes to set its value to `1`. This result could lead to confusion
    between the client and the server, and in such cases invalidating payloads with
    illegal properties helps us make the API integration more reliable. In chapter
    6, you’ll learn to handle those situations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，FastAPI假设`quantity`属性缺失，并且客户端希望将其值设置为`1`。这种结果可能会导致客户端和服务器之间的混淆，在这种情况下，通过验证非法属性来使API集成更加可靠。在第6章中，你将学习如何处理这些情况。
- en: 'One edge case with optional properties, such as `OrderItemSchema`’s `quantity`,
    is that pydantic assumes they’re nullable and therefore will accept payloads with
    `quantity` set to `null`. For example, if we send the following payload to the
    POST `/orders` endpoint, our server will accept it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 带有可选属性的边缘情况，例如`OrderItemSchema`的`quantity`，是pydantic假设它们是可空的，因此会接受将`quantity`设置为`null`的有效负载。例如，如果我们向POST
    `/orders`端点发送以下有效负载，我们的服务器将接受它：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In terms of API integrations, optional isn’t quite the same as nullable: a
    property can be optional because it has a default value, but that doesn’t mean
    it can be `null`. To enforce the right behavior in pydantic, we need to include
    an additional validation rule that prevents users from setting the value of `quantity`
    to `null`. We use pydantic’s `validator()` decorator to define additional validation
    rules for our models.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在API集成方面，可选的并不完全等同于可空的：一个属性可以是可选的，因为它有一个默认值，但这并不意味着它可以设置为`null`。为了在pydantic中强制正确的行为，我们需要包含一个额外的验证规则，防止用户将`quantity`的值设置为`null`。我们使用pydantic的`validator()`装饰器为我们的模型定义额外的验证规则。
- en: Listing 2.8 Including additional validation rules for pydantic models
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 为pydantic模型包含额外的验证规则
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we know how to test our API implementation using a Swagger UI, let’s
    see how we use pydantic to validate and serialize our API responses.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用Swagger UI测试我们的API实现，让我们看看我们如何使用pydantic来验证和序列化我们的API响应。
- en: 2.6 Marshalling and validating response payloads with pydantic
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 使用pydantic序列化和验证响应有效负载
- en: In this section, we’ll use the pydantic models implemented in section 2.4 to
    marshal and validate the response payloads of our API. Malformed payloads are
    one of the most common causes of API integration failures, so this step is crucial
    to deliver a robust API. For example, the schema for the response payload of the
    POST `/orders` endpoint is `GetOrderSchema`, which requires the presence of the
    `id`, `created`, `status`, and `order` fields. API clients will expect the presence
    of all these fields in the response payload and will raise errors if any of the
    fields is missing or comes in the wrong type or format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用第2.4节中实现的pydantic模型来序列化和验证我们的API的响应有效负载。格式错误的有效负载是API集成失败的最常见原因之一，因此这一步对于提供健壮的API至关重要。例如，POST
    `/orders`端点响应有效负载的模式是`GetOrderSchema`，它要求存在`id`、`created`、`status`和`order`字段。API客户端将期望响应有效负载中存在所有这些字段，如果任何字段缺失或类型或格式不正确，将引发错误。
- en: NOTE Malformed response payloads are a common source of API integration failures.
    You can avoid this problem by validating your response payloads before they leave
    the server. In FastAPI, this is easily done by setting the `response_model` parameter
    of a route decorator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：格式错误的有效负载是API集成失败的一个常见原因。你可以在它们离开服务器之前验证你的响应有效负载来避免这个问题。在FastAPI中，这可以通过设置路由装饰器的`response_model`参数轻松完成。
- en: Listing 2.9 shows how we use pydantic models to validate the responses from
    the GET `/orders` and the POST `/orders` endpoints. As you can see, we set the
    `response_model` parameter to a pydantic model in FastAPI’s route decorators.
    We follow the same approach to validate responses from all the other endpoints
    except the DELETE `/orders/{order_id}` endpoint, which returns an empty response.
    Feel free to check out the code in the GitHub repository for this book for the
    full implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9展示了我们如何使用pydantic模型来验证GET `/orders`和POST `/orders`端点的响应。正如你所见，我们在FastAPI的路由装饰器中将`response_model`参数设置为一个pydantic模型。我们遵循相同的方法来验证所有其他端点的响应，除了返回空响应的DELETE
    `/orders/{order_id}`端点。你可以自由地查看GitHub仓库中这本书的完整实现。
- en: Listing 2.9 Hooking validation models for responses in the API endpoints
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 在API端点中挂钩验证模型以响应
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have response models, FastAPI will raise an error if a required
    property is missing from a response payload. It will also remove any properties
    that are not part of the schema, and it will try to cast each property into the
    right type. Let’s see this behavior at work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了响应模型，如果响应有效负载中缺少必需的属性，FastAPI将引发错误。它还会删除不属于模式的任何属性，并尝试将每个属性转换为正确的类型。让我们看看这个行为是如何工作的。
- en: 'In a browser, visit the http://127.0.0.1:8000/docs URL to load the Swagger
    UI for our API. Then head over to the GET `/orders` `endpoint` and send a request.
    You’ll get the order that we hardcoded at the top of the orders/api/api.py file.
    Let’s make some modifications to that payload to see how FastAPI handles them.
    To begin, let’s add an additional property called `updated`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，访问 http://127.0.0.1:8000/docs URL 以加载我们的 API 的 Swagger UI。然后转到 GET `/orders`
    `端点` 并发送请求。你会得到位于 orders/api/api.py 文件顶部的硬编码订单。让我们对那个有效载荷进行一些修改，以查看 FastAPI 如何处理它们。首先，让我们添加一个额外的属性
    `updated`：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we call the GET `/orders` endpoint again, we’ll get the same response we
    obtained before, without the `updated` property since it isn’t part of the `GetOrderSchema`
    model:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次调用 GET `/orders` 端点，我们将获得之前获得相同的响应，但没有 `updated` 属性，因为它不是 `GetOrderSchema`
    模型的一部分：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s now remove the `created` property from the order payload and call the
    GET `/orders` endpoint again:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从订单有效载荷中删除 `created` 属性，并再次调用 GET `/orders` 端点：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This time, FastAPI raises a server error telling us that the required `created`
    property is missing from the payload:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，FastAPI 抛出一个服务器错误，告诉我们必需的 `created` 属性在有效载荷中缺失：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s now change the value of the `created` property to a random string and
    run another request against the GET `/orders` endpoint:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 `created` 属性的值更改为一个随机字符串，并再次对 GET `/orders` 端点发起请求：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, FastAPI raises a helpful error:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，FastAPI 会抛出一个有用的错误：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our responses are being correctly validated and marshalled. Let’s now add a
    simple state management mechanism for the application so that we can place orders
    and change their state through the API.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的反应正在被正确验证和打包。现在让我们为应用程序添加一个简单的状态管理机制，这样我们就可以通过 API 放置订单并更改它们的状态。
- en: 2.7 Adding an in-memory list of orders to the API
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 向 API 添加内存订单列表
- en: So far, our API implementation has returned the same response object. Let’s
    change that by adding a simple in-memory collection of orders to manage the state
    of the application. To keep the implementation simple, we’ll represent the collection
    of orders as a Python list. We’ll manage the list within the view functions of
    the API layer. In chapter 7, you’ll learn useful patterns to add a robust controller
    and data persistence layers to the application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 API 实现已经返回了相同的响应对象。让我们通过添加一个简单的内存订单集合来改变这一点，以管理应用程序的状态。为了简化实现，我们将订单集合表示为
    Python 列表。我们将在 API 层的视图函数中管理该列表。在第 7 章中，你将学习到向应用程序添加健壮的控制器和数据持久化层的实用模式。
- en: Listing 2.10 shows the changes required for the view functions under api.py
    to manage the in-memory list of orders in our view functions. The changes in listing
    2.9 go into the orders/api/api.py file. We represent the collection of orders
    as a Python list, and we assign it to the variable `ORDERS`. To keep it simple,
    we store the details of every order as a dictionary, and we update them by changing
    their properties in the dictionary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 展示了在 api.py 中管理视图函数中内存订单列表所需的更改。列表 2.9 中的更改涉及 orders/api/api.py 文件。我们将订单集合表示为
    Python 列表，并将其分配给变量 `ORDERS`。为了简化，我们将每个订单的详细信息存储为字典，并通过更改字典中的属性来更新它们。
- en: Listing 2.10 Managing the application’s state with an in-memory list
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 使用内存列表管理应用程序的状态
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We represent our in-memory list of orders as a Python list.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将内存中的订单列表表示为 Python 列表。
- en: ② To return the list of orders, we simply return the ORDERS list.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为了返回订单列表，我们只需返回 `ORDERS` 列表。
- en: ③ We transform every order into a dictionary.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将每个订单转换为字典。
- en: ④ We enrich the order object with server-side attributes, such as the ID.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们通过服务器端属性（如 ID）丰富订单对象。
- en: ⑤ To create the order, we add it to the list.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 为了创建订单，我们将它添加到列表中。
- en: ⑥ After appending the order to the list, we return it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 在将订单追加到列表后，我们返回它。
- en: ⑦ To find an order by ID, we iterate the ORDERS list and check their IDs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 为了通过 ID 查找订单，我们遍历 ORDERS 列表并检查它们的 ID。
- en: ⑧ If an order isn’t found, we raise an HTTPException with status_code set to
    404 to return a 404 response.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果找不到订单，我们将抛出一个 `HTTPException`，将 `status_code` 设置为 404，以返回 404 响应。
- en: ⑨ We order from the list using the list.pop() method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 我们使用 `list.pop()` 方法从列表中删除订单。
- en: If you play around with the POST `/orders` endpoint, you’ll be able to create
    new orders, and using their IDs you’ll be able to update them by hitting the PUT
    `/orders/{order_id}` endpoint. In every endpoint under the `/orders/{order_id}`
    URL path, we check whether the order requested by the API client exists, and if
    it doesn’t we return a 404 (Not Found) response with a helpful message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试操作 `/orders` 端点，你将能够创建新的订单，并且使用它们的ID，你可以通过访问 `/orders/{order_id}` 端点来更新它们。在
    `/orders/{order_id}` URL 路径下的每个端点，我们都会检查API客户端请求的订单是否存在，如果不存在，我们将返回一个包含有用信息的404（未找到）响应。
- en: We are now able to use the orders API to create orders, update them, pay for
    them, cancel them, and get their details. You have implemented a fully working
    web API for a microservice application! You’ve become familiar with a bunch of
    new libraries to build web APIs, and you’ve seen how to add robust data validation
    to your APIs. You’ve also learned to put it all together and run it with success.
    Hopefully, this chapter has sparked your interest and excitement about designing
    and building microservices exposing web APIs. In the coming chapters, we’ll delve
    deeper into these topics, and you’ll learn to build and deliver robust and secure
    microservice API integrations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够使用订单API来创建订单、更新它们、支付它们、取消它们以及获取它们的详细信息。你已经为微服务应用程序实现了一个完全工作的Web API！你已经熟悉了构建Web
    API的一堆新库，并且看到了如何为你的API添加健壮的数据验证。你还学会了如何将它们全部组合起来并成功运行。希望这一章能够激发你对设计和构建暴露Web API的微服务的兴趣和热情。在接下来的章节中，我们将更深入地探讨这些主题，你将学习如何构建和交付健壮且安全的微服务API集成。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'To structure microservices into modular layers, we use an adaptation of the
    three-tier architecture pattern:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将微服务结构化为模块化层，我们使用了一种三层架构模式的变体：
- en: A data layer that knows how to interface with the source of data
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个知道如何与数据源接口的数据层
- en: A business layer that implements the capabilities of the service
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现服务功能的业务层
- en: An interface or presentation layer that exposes the capabilities of the service
    through an API
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口或表示层，通过API公开服务的功能
- en: FastAPI is a popular framework for building web APIs. It’s highly performant,
    and it has a rich ecosystem of libraries that make it easier to build APIs.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 是一个流行的用于构建Web API的框架。它性能卓越，并且拥有丰富的库生态系统，这使得构建API更加容易。
- en: FastAPI uses pydantic, a popular data validation library for Python. Pydantic
    uses type hints to create validation rules, which results in clean and easy-to-understand
    models.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 使用 pydantic，这是一个流行的Python数据验证库。Pydantic使用类型提示来创建验证规则，这导致模型干净且易于理解。
- en: FastAPI generates a Swagger UI dynamically from our code. A Swagger UI is a
    popular interactive visualization UI for APIs. Using the Swagger UI, we can easily
    test if our implementation is correct.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI会从我们的代码中动态生成Swagger UI。Swagger UI是一个流行的API交互式可视化UI。使用Swagger UI，我们可以轻松地测试我们的实现是否正确。
- en: '* * *'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ For a classic explanation of the decorator pattern, see Erich Gamma et al.,
    *Design Patterns* (Addison-Wesley, 1995), pp. 175–184\. For a more Pythonic introduction
    to decorators, see Luciano Ramalho, *Fluent Python* (O’Reilly, 2015), pp. 189–222.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 对于装饰器模式的经典解释，请参阅Erich Gamma等人所著的《设计模式》（Addison-Wesley，1995年），第175-184页。对于装饰器的更Pythonic介绍，请参阅Luciano
    Ramalho所著的《Fluent Python》（O’Reilly，2015年），第189-222页。
