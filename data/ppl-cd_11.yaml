- en: 8 Running automated tests with Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 使用Jenkins运行自动化测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing CI pipelines for Python, Go, Node.js, and Angular-based services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于Python、Go、Node.js和Angular的服务实现CI管道
- en: Running pre-integration tests and automated UI testing with Headless Chrome
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无头Chrome运行预集成测试和自动化UI测试
- en: Executing SonarQube static code analysis within Jenkins pipelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins管道中执行SonarQube静态代码分析
- en: Running unit tests inside a Docker container and publishing code coverage reports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器内运行单元测试并发布代码覆盖率报告
- en: Integrating dependency checks in a Jenkins pipeline and injecting security in
    DevOps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins管道中集成依赖性检查并在DevOps中注入安全性
- en: In the previous chapter, you learned how to set up multibranch pipeline jobs
    for containerized microservices and for continuously triggering Jenkins upon push
    events with webhooks. In this chapter, we will run automated tests within the
    CI pipeline. Figure 8.1 summarizes the current CI workflow stages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何为容器化微服务设置多分支管道作业，以及如何使用webhooks在推送事件上持续触发Jenkins。在本章中，我们将在CI管道中运行自动化测试。图8.1总结了当前的CI工作流程阶段。
- en: '![](Images/CH08_F01_Labouardy.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F01_Labouardy.png)'
- en: Figure 8.1 The test stages covered in this chapter
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 本章涵盖的测试阶段
- en: Test automation is widely considered a cornerstone of Agile development. If
    you want to release fast—even daily—with reasonable quality, you have to move
    to automated testing. On the other hand, giving less importance to testing can
    result in customer dissatisfaction and a delayed product. However, automating
    the testing process is a bit more difficult than automating the build, release,
    and deployment processes. Automating nearly all the test cases used in an application
    usually takes a lot of effort. It is an activity that matures over time. It is
    not always possible to automate all the testing. But the idea is to automate whatever
    testing is possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化通常被认为是敏捷开发的基础。如果你想快速发布——甚至每天——并且保持合理的质量，你必须转向自动化测试。另一方面，对测试的重视不足可能导致客户不满和产品延迟。然而，自动化测试过程比自动化构建、发布和部署过程要困难一些。通常需要大量努力来自动化应用程序中使用的几乎所有测试用例。这是一个随着时间的推移而成熟的活动。并不是所有的测试都可以自动化。但想法是自动化尽可能多的测试。
- en: By the end of this chapter, we will implement the test stage in the target CI
    pipeline shown in figure 8.2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将实现如图8.2所示的CI管道中的测试阶段。
- en: '![](Images/CH08_F02_Labouardy.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F02_Labouardy.png)'
- en: Figure 8.2 Target CI pipeline
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 目标CI管道
- en: 'Before resuming the CI pipeline implementation, a quick reminder regarding
    the web distributed application we’re integrating with Jenkins: it’s based on
    a microservices architecture and split into components/services written in different
    programming languages and frameworks. Figure 8.3 illustrates this architecture.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续CI管道实现之前，关于我们与Jenkins集成的Web分布式应用程序的快速提醒：它基于微服务架构，并分为用不同编程语言和框架编写的组件/服务。图8.3说明了这种架构。
- en: '![](Images/CH08_F03_Labouardy.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F03_Labouardy.png)'
- en: Figure 8.3 Watchlist microservices architecture
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 观察列表微服务架构
- en: In the following sections, you will learn how to integrate various types of
    tests in our CI workflow. We will start with unit testing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何将各种类型的测试集成到我们的CI工作流程中。我们将从单元测试开始。
- en: 8.1 Running unit tests inside Docker containers
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 在Docker容器内运行单元测试
- en: '*Unit* *testing* is the frontline effort to identify issues as early as possible.
    The test needs to be small and quick to execute to be efficient.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元*测试是尽早识别问题的前沿工作。测试需要小而快速执行，以便高效。'
- en: The movies-loader service is written in Python. To define unit tests, we’re
    going to use the unittest framework (it comes bundled with the installation of
    Python). To use it, we import the unittest module, which offers a rich set of
    methods to construct and run tests. The following listing, test_main.py, demonstrates
    a short unit test to test the JSON loading and parsing mechanism.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: movies-loader服务是用Python编写的。为了定义单元测试，我们将使用unittest框架（它随Python的安装一起提供）。要使用它，我们需要导入unittest模块，它提供了一套丰富的用于构建和运行测试的方法。以下列表，test_main.py，演示了一个简短的单元测试，用于测试JSON加载和解析机制。
- en: Listing 8.1 Unit testing in Python
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 Python中的单元测试
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `setUpClass()` method allows us to load the movies.json file before the
    execution of each test method. The three individual tests are defined with methods
    whose names start with the prefix `test`. This naming convention informs the test
    runner about which methods represent tests. The crux of each test is a call to
    `assertEqual``()` to check for an expected result. For instance, we check whether
    the first movie’s title attribute parsed from the JSON file is `The` `Shawshank`
    `Redemption`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUpClass()` 方法允许我们在每个测试方法执行之前加载 movies.json 文件。三个单独的测试是通过以 `test` 前缀开头的方法定义的。这种命名约定通知测试运行器哪些方法代表测试。每个测试的核心是一个调用
    `assertEqual()` 的操作，以检查预期的结果。例如，我们检查从 JSON 文件解析出的第一部电影标题属性是否为 `The` `Shawshank`
    `Redemption`。'
- en: To run the test, we can execute the `python` `test_main.py` command on Jenkins.
    However, it requires Python 3 to be installed. To avoid installing the runtime
    environment for each service we are building, we will run the tests inside a Docker
    container. That way, we will be using Docker as an execution environment across
    all Jenkins workers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们可以在 Jenkins 上执行 `python test_main.py` 命令。但是，它需要安装 Python 3。为了避免为构建的每个服务安装运行时环境，我们将在
    Docker 容器中运行测试。这样，我们将在所有 Jenkins 工作节点上使用 Docker 作为执行环境。
- en: On the movies-loader repository, create a Dockerfile.test file by using your
    favorite text editor or IDE with the following content.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 movies-loader 仓库中，使用您喜欢的文本编辑器或 IDE 创建一个名为 Dockerfile.test 的文件，内容如下。
- en: Listing 8.2 Movie loader’s Dockerfile.test
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 Movie loader 的 Dockerfile.test
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Dockerfile is built from a Python 3.7.3 official image. It sets a working
    directory called app, and copies the test files to the working directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是从 Python 3.7.3 官方镜像构建的。它设置了一个名为 app 的工作目录，并将测试文件复制到工作目录中。
- en: Note The name convention *Dockerfile.test* is used to avoid name conflict with
    *Dockerfile*, which is used to build the main application’s Docker image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 *Dockerfile.test* 的命名约定是为了避免与用于构建主应用程序 Docker 镜像的 *Dockerfile* 发生名称冲突。
- en: Now, update the Jenkinsfile given in listing 7.1 and add a new `Unit` `Test`
    stage, as shown in the following listing. The stage will create a Docker image
    based on Dockerfile .test and then spin up a Docker container from the created
    image to run the `python` `test_main.py` command to launch unit tests. The `Unit`
    `Test` stage uses a DSL-like syntax to define the shell instructions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新列表 7.1 中给出的 Jenkinsfile，并添加一个新的 `Unit` `Test` 阶段，如下所示。该阶段将基于 Dockerfile
    .test 创建 Docker 镜像，然后从创建的镜像启动 Docker 容器以运行 `python` `test_main.py` 命令以启动单元测试。`Unit`
    `Test` 阶段使用类似 DSL 的语法来定义 shell 指令。
- en: Listing 8.3 Movie loader’s Jenkinsfile
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 Movie loader 的 Jenkinsfile
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `docker` `build` and `docker` `run` commands are used to create an image
    and build a container from the image, respectively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker build` 和 `docker run` 命令分别创建镜像和从镜像构建容器。
- en: Note The `--rm` flag in the `docker` `run` command is used to automatically
    clean up the container and remove the filesystem when the container exits.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`docker run` 命令中的 `--rm` 标志用于在容器退出时自动清理容器并删除文件系统。
- en: You can use the `powershell` step in your pipeline on a Windows worker. This
    step has the same options as the `sh` instruction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Windows 工作节点上的管道中使用 `powershell` 步骤。此步骤具有与 `sh` 指令相同的选项。
- en: 'Commit the changes to the develop branch with the following commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将更改提交到 develop 分支：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In a few seconds, a new build should be triggered on the movies-loader job for
    the develop branch. From the movies-loader Multibranch Pipeline job, click the
    respective develop branch. On the resultant page, you will see the Stage view
    for the develop branch pipeline, as shown in figure 8.4.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在几秒钟内，应该会在 develop 分支的 movies-loader 作业上触发一个新的构建。从 movies-loader 多分支流水线作业中，点击相应的
    develop 分支。在结果页面上，您将看到 develop 分支流水线的阶段视图，如图 8.4 所示。
- en: '![](Images/CH08_F04_Labouardy.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F04_Labouardy.png)'
- en: Figure 8.4 Unit test stage execution
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 单元测试阶段执行
- en: Click the Console Output option to view the test results. All three test cases
    ran, and the status shows as `SUCCESS` in the logs, as you can see in figure 8.5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 点击控制台输出选项以查看测试结果。所有三个测试用例都已运行，日志中的状态显示为 `SUCCESS`，如图 8.5 所示。
- en: '![](Images/CH08_F05_Labouardy.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F05_Labouardy.png)'
- en: Figure 8.5 Unit test successful execution logs
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 单元测试成功执行日志
- en: 'The shell commands can be replaced with Docker DSL instructions. I advise using
    them where appropriate instead of running Docker commands via the shell, because
    they provide high-level encapsulation and ease of use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用Docker DSL指令替换shell命令。我建议在适当的地方使用它们，而不是通过shell运行Docker命令，因为它们提供了高级封装和易于使用：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `docker.build()` method is similar to running the `docker build` command.
    The returned value of the method can be used for a subsequent call to create a
    Docker container and run the unit tests. Figure 8.6 shows a successful run of
    the pipeline.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker.build()`方法类似于运行`docker build`命令。该方法返回的值可以用于后续调用以创建Docker容器并运行单元测试。图8.6显示了管道成功运行的示例。'
- en: '![](Images/CH08_F06_Labouardy.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F06_Labouardy.png)'
- en: Figure 8.6 Using the Docker DSL to run tests
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 使用Docker DSL运行测试
- en: To show results in a graphical, visual way, we can use the JUnit report integration
    plugin on Jenkins to consume an XML file generated by Python unit tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以图形化、可视化的方式显示结果，我们可以在Jenkins上使用JUnit报告集成插件来消费由Python单元测试生成的XML文件。
- en: Note The JUnit report integration plugin ([https://plugins.jenkins.io/junit/](https://plugins.jenkins.io/junit/))
    is installed by default in the baked Jenkins master machine image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：JUnit报告集成插件([https://plugins.jenkins.io/junit/](https://plugins.jenkins.io/junit/))默认安装在预制的Jenkins主机机器镜像中。
- en: 'Update the test_main.py file to use the xmlrunner library, and pass it to the
    unittest .main method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更新test_main.py文件以使用xmlrunner库，并将其传递给unittest.main方法：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate test reports in the reports directory. However, we need
    to address a problem: the test container will store the result of the tests that
    it executes within itself. We can resolve this by mapping a volume to the reports
    directory. Update the Jenkinsfile to tell Jenkins where to find the JUnit test
    report:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在“reports”目录中生成测试报告。然而，我们需要解决一个问题：测试容器将存储它自身执行的测试结果。我们可以通过将一个卷映射到“reports”目录来解决这个问题。更新Jenkinsfile以告诉Jenkins在哪里找到JUnit测试报告：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note You can also get the report results by using the `docker cp` command to
    copy the report files into the current workspace. Then, set the workspace as an
    argument for the JUnit command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您也可以通过使用`docker cp`命令将报告文件复制到当前工作区来获取报告结果。然后，将工作区作为JUnit命令的参数设置。
- en: Let’s go ahead and execute this. This will add a chart to the project page in
    Jenkins after the changes are pushed to the develop branch and CI execution is
    completed; see figure 8.7.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续执行这个操作。这将添加一个图表到Jenkins的项目页面，在更改推送到develop分支并且CI执行完成后；参见图8.7。
- en: '![](Images/CH08_F07_Labouardy.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F07_Labouardy.png)'
- en: Figure 8.7 JUnit test chart analyzer
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 JUnit测试图表分析器
- en: The historic graph shows several metrics (including failure, total, and duration)
    related to the test execution over a period of time. You can also click the chart
    to get more details about individual tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 历史图表显示了在一段时间内与测试执行相关的几个指标（包括失败、总数和持续时间）。您还可以点击图表以获取有关单个测试的更多详细信息。
- en: 8.2 Automating code linter integration with Jenkins
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用Jenkins自动化代码检查器集成
- en: Another example of tests to implement within CI pipelines is *code linting*.
    Linters can be used to check the source code and find typos, syntax errors, undeclared
    variables, and calls to undefined or deprecated functions. They can help you write
    better code and anticipate potential bugs. Let’s see how to integrate code linters
    with Jenkins.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CI管道中要实现的测试示例之一是*代码检查*。检查器可以用来检查源代码，查找拼写错误、语法错误、未声明的变量以及对未定义或已弃用的函数的调用。它们可以帮助您编写更好的代码并预测潜在的bug。让我们看看如何将代码检查器与Jenkins集成。
- en: The movies-parser service is written in Go, so we can use a Go linter to make
    sure that the code respects the code style. A linter may sound like an optional
    tool, but for larger projects, it helps to keep a consistent style over your project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: movies-parser服务是用Go编写的，因此我们可以使用Go检查器来确保代码遵循代码风格。检查器可能听起来像是一个可选的工具，但对于大型项目来说，它有助于在整个项目中保持一致的样式。
- en: Dockerfile.test uses golang:1.13.4 as a base image, and installs the `golint`
    tool and service dependencies, as shown in the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile.test使用golang:1.13.4作为基础镜像，并安装了`golint`工具和服务依赖项，如下所示。
- en: Listing 8.4 Movie parser’s Dockerfile.test
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 Movie解析器的Dockerfile.test
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the `Quality Tests` stage to the Jenkinsfile to build a Docker image based
    on Dockerfile.test with the `docker.build()` command, and then use the `inside()`
    instruction on the built image to start a Docker container in daemonized mode
    to execute the `golint` command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Quality Tests`阶段添加到Jenkinsfile中，使用`docker.build()`命令基于Dockerfile.test构建Docker镜像，然后使用`inside()`指令在构建的镜像上以守护模式启动Docker容器来执行`golint`命令：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note If an `ENTRYPOINT` instruction is defined in Dockerfile.test, the `inside()`
    instruction will pass the commands defined in its scope as an argument to the
    `ENTRYPOINT` instruction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果Dockerfile.test中定义了`ENTRYPOINT`指令，`inside()`指令将把其作用域内定义的命令作为参数传递给`ENTRYPOINT`指令。
- en: The `golint` execution will result in the logs shown in figure 8.8.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`golint`执行将产生如图8.8所示的日志。'
- en: '![](Images/CH08_F08_Labouardy.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F08_Labouardy.png)'
- en: Figure 8.8 The `golint` command output identifies the missing comment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 `golint`命令输出标识了缺失的注释。
- en: By default, `golint` prints only the style issues, and returns (with a 0 exit
    code), so the CI never considers that something went wrong. If you specify `-set_exit_status`,
    the pipeline will fail if an issue is reported by `golint`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`golint`仅打印样式问题，并返回（带有0退出代码），因此CI永远不会考虑出了问题。如果您指定`-set_exit_status`，如果`golint`报告问题，则流水线将失败。
- en: We can also implement a unit test for the movies-parser service. Go has a built-in
    testing command called `go` `test` and the package *testing*, which combine to
    give a minimal but complete unit-testing experience.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为movies-parser服务实现一个单元测试。Go有一个内置的测试命令`go test`和包*testing*，它们结合提供了一个最小但完整的单元测试体验。
- en: Similarly to the movies-loader service, we will write a Dockerfile.test file
    to execute the `go` `test` command that will execute tests written in the main_test.go
    file. The code in the following listing has been cropped for brevity and to highlight
    the main parts. You can browse the full code in chapter7/microservices/movies-parser/main_test.go.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于movies-loader服务，我们将编写一个Dockerfile.test文件来执行在main_test.go文件中编写的测试。以下列表中的代码为了简洁和突出主要部分而进行了裁剪。您可以在第7章的`chapter7/microservices/movies-parser/main_test.go`中浏览完整代码。
- en: Listing 8.5 Movie parser’s unit test
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 电影解析器的单元测试
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code shows the basic structure of a unit test in Go. The built-in testing
    package is provided by Go’s standard library. A unit test is a function that accepts
    the argument of type `*testing.T` and calls the `t.Error()` method to indicate
    a failure. This function must start with a `Test` keyword, and the latter name
    should start with an uppercase letter. In our use case, the function tests the
    `ParseMovie()` method, which takes as a parameter `HTML` and returns a `Movie`’s
    structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了Go中单元测试的基本结构。内置的测试包由Go的标准库提供。单元测试是一个接受类型为`*testing.T`的参数并调用`t.Error()`方法来指示失败的函数。此函数必须以`Test`关键字开头，并且后缀名应以大写字母开头。在我们的用例中，该函数测试`ParseMovie()`方法，该方法接受`HTML`参数并返回`Movie`结构。
- en: 8.3 Generating code coverage reports
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 生成代码覆盖率报告
- en: 'The `Unit Tests` stage is straightforward: it will execute `go` `test` inside
    the Docker container created from the Docker test image. Instead of building the
    test image on each stage, we move the `docker.build()` instruction outside the
    stage to speed up the pipeline execution time, as you can see in the following
    listing.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit Tests`阶段很简单：它将在从Docker测试镜像创建的Docker容器内执行`go test`。我们不是在每个阶段构建测试镜像，而是将`docker.build()`指令移出阶段以加快流水线执行时间，如下所示。'
- en: Listing 8.6 Movie parser’s Jenkinsfile
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 电影解析器的Jenkinsfile
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Push the changes to the develop branch, and the pipeline should be triggered
    to execute the three stages defined on the Jenkinsfile, as shown in figure 8.9.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到develop分支，并触发Jenkinsfile中定义的三个阶段执行，如图8.9所示。
- en: '![](Images/CH08_F09_Labouardy.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F09_Labouardy.png)'
- en: Figure 8.9 Go CI pipeline
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 Go CI流水线
- en: The `go` `test` command output is shown in figure 8.10.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test`命令的输出如图8.10所示。'
- en: '![](Images/CH08_F10_Labouardy.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F10_Labouardy.png)'
- en: Figure 8.10 `go` `test` command output
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 `go test`命令输出
- en: Note Go provides the `-cover` flag to the `go` `test` command as a built-in
    functionality to check your code coverage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Go提供了`-cover`标志作为`go test`命令的内置功能，用于检查代码覆盖率。
- en: 'If we want to get the coverage report in HTML format, you need to add the following
    command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以HTML格式获取覆盖率报告，需要添加以下命令：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](Images/CH08_F11_Labouardy.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F11_Labouardy.png)'
- en: Figure 8.11 The coverage.html content can be served from the Jenkins dashboard
    at the end of the test stage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 覆盖率.html内容可以在测试阶段结束时从Jenkins仪表板提供。
- en: The commands render an HTML page, shown in figure 8.11, that visualizes line-by-line
    coverage of each affected line in the main.go file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命令会渲染一个HTML页面，如图8.11所示，该页面可视化地显示了main.go文件中每个受影响行的逐行覆盖率。
- en: You can include the previous command in the CI workflow to generate coverage
    reports in HTML format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面的命令包含在CI工作流程中，以生成HTML格式的覆盖率报告。
- en: 8.4 Injecting security in the CI pipeline
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 在CI管道中注入安全
- en: It’s important to make sure that no vulnerabilities are published to production—at
    least no critical or major ones. Scanning project dependencies within a CI pipeline
    can ensure this additional level of security. Several dependency scanning solutions
    exist, commercial and open source. In this part, we’ll go with Nancy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不会将任何漏洞发布到生产环境中非常重要——至少不要发布关键或重大的漏洞。在CI管道中扫描项目依赖项可以确保这一额外的安全级别。存在几种依赖项扫描解决方案，包括商业和开源。在本部分，我们将使用Nancy。
- en: Nancy ([https://github.com/sonatype-nexus-community/nancy](https://github.com/sonatype-nexus-community/nancy))
    is an open source tool that checks for vulnerabilities in your Go dependencies.
    It uses Sonatype’s OSS Index ([https://ossindex.sonatype.org/](https://ossindex.sonatype.org/)),
    a mirror of the Common Vulnerabilities and Exposures (CVE) database, to check
    your dependencies for publicly filed vulnerabilities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Nancy ([https://github.com/sonatype-nexus-community/nancy](https://github.com/sonatype-nexus-community/nancy))
    是一个开源工具，用于检查你的Go依赖项中的漏洞。它使用Sonatype的OSS Index ([https://ossindex.sonatype.org/](https://ossindex.sonatype.org/))，这是公共漏洞和暴露（CVE）数据库的镜像，来检查你的依赖项是否存在公开报告的漏洞。
- en: Note Chapter 9 covers how to use the OWASP Dependency-Check plugin on Jenkins
    to detect references to dependencies that have been assigned CVE entries.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第9章介绍了如何在Jenkins上使用OWASP Dependency-Check插件来检测对已分配CVE条目的依赖项的引用。
- en: Step one in the process is to install a Nancy binary from the official release
    page. Update Dockerfile.test for the movies-parser project to install Nancy version
    1.0.22 (at the time of writing this book) and configure the executable on the
    `PATH` variable, as shown in the following listing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的第一个步骤是从官方发布页面安装Nancy二进制文件。更新movies-parser项目的Dockerfile.test，以安装Nancy版本1.0.22（本书编写时），并在`PATH`变量上配置可执行文件，如下所示。
- en: Listing 8.7 Movie parser’s Dockerfile.test
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 Movie parser的Dockerfile.test
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To start using the tool, add a `Security Tests` stage on the Jenkinsfile to
    run Nancy with the Gopkg.lock file as parameter, which contains a list of used
    Go dependencies in the movies-parser service:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用此工具，请在Jenkinsfile中添加一个`Security Tests`阶段，以使用Gopkg.lock文件作为参数运行Nancy，该文件包含movies-parser服务中使用的Go依赖项列表：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Push the changes to the remote repository. A new pipeline will be started. At
    the `Security` `Tests` stage, Nancy will be executed, and no dependency security
    vulnerability will be reported, as shown in figure 8.12.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到远程仓库。将启动一个新的管道。在`Security` `Tests`阶段，将执行Nancy，并且不会报告任何依赖项安全漏洞，如图8.12所示。
- en: '![](Images/CH08_F12_Labouardy.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F12_Labouardy.png)'
- en: Figure 8.12 Dependencies scanning for known vulnerabilities
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 已知漏洞的依赖项扫描
- en: If Nancy finds a vulnerability in one of your dependencies, it will exit with
    a nonzero code, allowing you to use Nancy as a tool in your CI/CD process, and
    fail builds.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Nancy在您的依赖项中找到一个漏洞，它将以非零代码退出，这样您就可以将Nancy作为CI/CD流程中的工具使用，并使构建失败。
- en: While you should aim to resolve all security vulnerabilities, some security
    scan results may contain false positives. For example, if you see a theoretical
    denial-of-service attack under obscure conditions that don’t apply to your project,
    it may be safe to schedule a fix a week or two into the future. On the other hand,
    a more serious vulnerability that may grant unauthorized access to customer credit
    card data should be fixed immediately. Whatever the case, arm yourself with knowledge
    of the vulnerability so you and your team can determine the proper course of action
    to mitigate the security threat.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你应该努力解决所有安全漏洞，但某些安全扫描结果可能包含误报。例如，如果你在不太可能适用于你项目的隐蔽条件下看到一个理论上的拒绝服务攻击，那么可能安全地安排在未来一周或两周内修复。另一方面，一个更严重的漏洞可能会允许未经授权访问客户信用卡数据，应该立即修复。无论情况如何，都要掌握漏洞知识，这样你和你的团队就可以确定适当的行动方案来减轻安全威胁。
- en: Adding the dependency scanning to your pipeline (figure 8.13) is a simple first
    step to reduce your attack surface. This is easy to implement, as it requires
    no server reconfigurations or additional servers to work. In its most basic form,
    simply install the Nancy binary and roll it out.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项扫描添加到你的管道（图 8.13）是减少你的攻击面的简单第一步。这很容易实现，因为它不需要服务器重新配置或额外的服务器来工作。在其最基本的形式中，只需安装
    Nancy 二进制文件并将其部署。
- en: '![](Images/CH08_F13_Labouardy.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F13_Labouardy.png)'
- en: Figure 8.13 Security injection in CI pipeline
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 CI 管道中的安全注入
- en: 8.5 Running parallel tests with Jenkins
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 使用 Jenkins 运行并行测试
- en: So far, pre-integration tests are running sequentially. One problem we always
    encounter is how to run all the tests needed to ensure high-quality changes while
    still keeping pipeline times reasonable and changes flowing smoothly. More tests
    mean greater confidence, but also longer wait times.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，预集成测试是顺序运行的。我们总是遇到的一个问题是如何在保持管道时间合理和更改流畅的同时运行所有确保高质量更改所需的测试。更多的测试意味着更大的信心，但也意味着更长的等待时间。
- en: Note In chapter 9, we will cover how to use the Parallel Test Execution plugin
    to run tests in parallel across multiple Jenkins workers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第 9 章中，我们将介绍如何使用并行测试执行插件在多个 Jenkins 工作者之间并行运行测试。
- en: One of the features of Jenkins pipelines that you see advertised quite frequently
    is its ability to run parts of your build in parallel by using the `parallel`
    DSL step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常看到的 Jenkins 管道的一个特性是它能够通过使用 `parallel` DSL 步骤并行运行构建的部分。
- en: Update the Jenkinsfile to use the `parallel` keyword, as shown in the following
    listing. The `parallel` section contains a list of nested test stages to be run
    in parallel. Also, you can force your parallel stages to all be aborted when any
    one of them fails, by adding a `failFast` `true` instruction.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Jenkinsfile 以使用 `parallel` 关键字，如下所示列表。`parallel` 部分包含一个要并行运行的嵌套测试阶段列表。此外，你可以通过添加
    `failFast true` 指令来强制所有并行阶段在任何一个失败时全部中止。
- en: Listing 8.8 Running tests in parallel
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 并行运行测试
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you push those changes to the remote repository, a new build will be invoked
    (figure 8.14). However, one disadvantage of the standard pipeline view is that
    you can’t easily see how the parallel steps progress, because the pipeline is
    linear, like a pipeline. This issue has been addressed by Jenkins by providing
    an alternate view: Blue Ocean.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些更改推送到远程仓库，将触发一个新的构建（图 8.14）。然而，标准管道视图的一个缺点是你无法轻易地看到并行步骤的进度，因为管道是线性的，就像管道一样。Jenkins
    通过提供另一种视图：Blue Ocean 来解决这个问题。
- en: '![](Images/CH08_F14_Labouardy.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F14_Labouardy.png)'
- en: Figure 8.14 Pre-integration tests’ parallel execution
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 预集成测试的并行执行
- en: Figure 8.15 shows the results for the same pipeline, with parallel test execution
    in Blue Ocean mode.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 显示了相同管道的结果，其中在 Blue Ocean 模式下执行并行测试。
- en: '![](Images/CH08_F15_Labouardy.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F15_Labouardy.png)'
- en: Figure 8.15 Parallel stages in Blue Ocean
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 Blue Ocean 中的并行阶段
- en: This looks nice and provides great visualization for parallel pipeline stages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很棒，为并行管道阶段提供了很好的可视化。
- en: 8.6 Improving quality with code analysis
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 通过代码分析提高质量
- en: Apart from continuously integrating code, CI pipelines nowadays also include
    tasks that perform continuous inspection—inspecting code for its quality in a
    continuous approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了持续集成代码之外，现在的 CI 管道还包括执行持续检查的任务——以持续的方式检查代码的质量。
- en: The movies-store application is written with TypeScript. We will use Dockerfile.test
    to build the Docker image to run automated tests, as shown in the following listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 电影商店应用程序是用 TypeScript 编写的。我们将使用 Dockerfile.test 来构建 Docker 镜像以运行自动化测试，如下所示列表。
- en: Listing 8.9 Movie store’s Dockerfile.test
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 电影商店的 Dockerfile.test
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first category of tests will be linting the source code. As you saw earlier
    in this chapter, linting is the process of checking the source code for programmatic,
    syntactic, stylistic errors. Linting puts the whole service in a uniform format.
    The code linting can be achieved by writing some rules. Many linters are available,
    including JSLint, JSHint, and ESLint.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类测试将是源代码的代码检查。正如你在这章前面看到的，代码检查是检查源代码中程序性、语法和风格错误的流程。代码检查使整个服务保持统一格式。代码检查可以通过编写一些规则来实现。有许多代码检查工具可用，包括
    JSLint、JSHint 和 ESLint。
- en: When it comes to linting TypeScript code, ESLint ([https://eslint.org/](https://eslint.org/))
    has a higher-performing architecture than others. For that reason, I’m using ESLint
    for linting the Node.js project, as shown in the following listing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到TypeScript代码的代码检查时，ESLint ([https://eslint.org/](https://eslint.org/)) 比其他工具具有更高的性能架构。因此，我正在使用ESLint对Node.js项目进行代码检查，如下所示列表。
- en: Listing 8.10 Movie store’s Jenkinsfile
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 电影存储的Jenkinsfile
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Copy this content to the movies-store Jenkinsfile and push the changes to the
    develop branch. A new build should be triggered. At the `Quality` `Tests` stage,
    we’ll see the errors regarding undefined keywords (figure 8.16) such as `describe`
    and `before`, which are part of the Mocha ([https://mochajs.org/](https://mochajs.org/))
    and Chai ([www.chaijs.com](http://www.chaijs.com)) JavaScript frameworks. These
    frameworks are used to describe unit tests (located under the test folder) efficiently
    and handily.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容复制到movies-store Jenkinsfile，并将更改推送到develop分支。应该触发一个新的构建。在`质量` `测试`阶段，我们将看到有关未定义关键字（如图8.16所示）的错误，例如`describe`和`before`，它们是Mocha
    ([https://mochajs.org/](https://mochajs.org/)) 和Chai ([www.chaijs.com](http://www.chaijs.com))
    JavaScript框架的一部分。这些框架用于高效且方便地描述单元测试（位于test文件夹下）。
- en: '![](Images/CH08_F16_Labouardy.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F16_Labouardy.png)'
- en: Figure 8.16 ESLint problem detection
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 ESLint问题检测
- en: 'ESLint will return an exit 1 code error, which will break the pipeline. To
    fix the spotted errors, extend ESLint rules by enabling the Mocha environment
    for ESLint. We use the `key` attribute in eslintrc.json to specify the environments
    we want to enable by setting `mocha` to `true`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint将返回退出码1的错误，这将中断管道。为了修复发现的问题，通过启用Mocha环境来扩展ESLint规则。我们使用eslintrc.json中的`key`属性来指定我们想要启用的环境，将`mocha`设置为`true`：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you push the changes, this time the static code analysis results will be
    successful, as you can see in figure 8.17.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这次推送更改，静态代码分析的结果将会成功，如图8.17所示。
- en: '![](Images/CH08_F17_Labouardy.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F17_Labouardy.png)'
- en: Figure 8.17 CI pipeline execution after fixing ESLint errors
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 修复ESLint错误后的CI管道执行
- en: 8.7 Running mocked database tests
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 运行模拟数据库测试
- en: While many developers focus on 100% coverage with unit tests, the code you write
    must not be tested just in isolation. Integration and end-to-end tests give you
    that extra confidence by testing parts of your application together. These parts
    may be working just fine on their own, but in a large system, units of code rarely
    work separately.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多开发者专注于单元测试的100%覆盖率时，你编写的代码不能仅仅在隔离状态下进行测试。集成和端到端测试通过一起测试应用程序的各个部分，为你提供了额外的信心。这些部分可能各自运行良好，但在一个大型系统中，代码单元很少单独工作。
- en: Typically, for integration or end-to-end tests, your scripts will need to connect
    to a real, dedicated database for testing purposes. This involves writing code
    that runs at the beginning and end of every test case/suite to ensure that the
    database is in a clean, predictable state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于集成或端到端测试，你的脚本将需要连接到用于测试目的的真实、专用数据库。这涉及到编写在每次测试用例/套件开始和结束时运行的代码，以确保数据库处于干净、可预测的状态。
- en: 'Using a real database for testing does have some challenges: database operations
    can be relatively slow, the testing environment can be complex, and operational
    overhead may increase. Java projects widely use DbUnit with an in-memory database
    for this purpose (for example, H2, [www.h2database.com/html/main.html](http://www.h2database.com/html/main.html)).
    Reusing a good solution from another platform and applying it to the Node.js world
    can be the way to go here.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用真实数据库进行测试确实存在一些挑战：数据库操作可能相对较慢，测试环境可能很复杂，运营开销可能会增加。Java项目广泛使用DbUnit与内存数据库（例如，H2，[www.h2database.com/html/main.html](http://www.h2database.com/html/main.html)）进行此目的。从另一个平台重用良好的解决方案并将其应用于Node.js世界可能是这里的方法。
- en: Mongo-unit ([www.npmjs.com/package/mongo-unit](http://www.npmjs.com/package/mongo-unit))
    is a Node.js package that can be installed by using Node Package Manager (npm)
    or Yarn. It runs MongoDB in memory. It makes integration tests easy by integrating
    well with the Mocha framework and providing a simple API to manage the database
    state.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo-unit ([www.npmjs.com/package/mongo-unit](http://www.npmjs.com/package/mongo-unit))
    是一个Node.js包，可以通过使用Node包管理器（npm）或Yarn进行安装。它可以在内存中运行MongoDB。通过与Mocha框架的良好集成并提供一个简单的API来管理数据库状态，它使得集成测试变得容易。
- en: Note In chapter 9 and 10, we will run sidecar containers in Jenkins pipelines,
    such as a MongoDB database, to run end-to-end tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第9章和第10章中，我们将在Jenkins管道中运行侧车容器，例如MongoDB数据库，以运行端到端测试。
- en: The following listing is a simple test (/chapter7/microservices/movies-store/test/dao.spec.js),
    written with Mocha and Chai, that uses the mongo-unit package to simulate MongoDB
    by running an in-memory database.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表是一个简单的测试 (/chapter7/microservices/movies-store/test/dao.spec.js)，使用 Mocha
    和 Chai 编写，并使用 mongo-unit 包通过运行内存数据库来模拟 MongoDB。
- en: Listing 8.11 Mocha and Chai unit tests
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 Mocha 和 Chai 单元测试
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we update the Jenkinsfile to add a new stage that executes the `npm run
    test` command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新 Jenkinsfile 以添加一个新的阶段，该阶段执行 `npm run test` 命令：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `npm run test` command is an alias; it runs the Mocha command line against
    test cases in the test folder (figure 8.18). The command is defined in package.json,
    provided in the following listing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run test` 命令是一个别名；它运行 Mocha 命令行对测试文件夹中的测试用例进行操作（图 8.18）。该命令在 package.json
    中定义，如下所示。'
- en: Listing 8.12 Movie store’s package.json
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 电影商店的 package.json
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](Images/CH08_F18_Labouardy.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F18_Labouardy.png)'
- en: Figure 8.18 Unit testing using the Mocha framework
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 使用 Mocha 框架进行单元测试
- en: Note If your tests depend on other services, Docker Compose can be used to simplify
    the startup and connection of all the services that the application depends on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 如果您的测试依赖于其他服务，可以使用 Docker Compose 来简化所有依赖服务的启动和连接。
- en: 8.8 Generating HTML coverage reports
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 生成 HTML 覆盖率报告
- en: 'We create a new stage to run the coverage tool with a text output format:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的阶段来运行覆盖率工具，并使用文本输出格式：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will output the text report to the console output, as shown in figure 8.19.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出文本报告到控制台输出，如图 8.19 所示。
- en: Note Istanbul is a JavaScript code coverage tool. For more information, refer
    to the official guide at [https://istanbul.js.org](https://istanbul.js.org).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Istanbul 是一个 JavaScript 代码覆盖率工具。更多信息，请参阅官方指南 [https://istanbul.js.org](https://istanbul.js.org)。
- en: '![](Images/CH08_F19_Labouardy.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F19_Labouardy.png)'
- en: Figure 8.19 Istanbul coverage reports in text format
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 Istanbul 文本格式覆盖率报告
- en: The metrics that you might see in your coverage reports could be defined as
    in table 8.1.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您在覆盖率报告中可能看到的指标可以定义为表 8.1 所示。
- en: Table 8.1 Coverage report metrics
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 覆盖率报告指标
- en: '| Metric | Description |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 描述 |'
- en: '| Statements | The number of statements in the program that are truly called,
    out of the total number |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 程序中实际调用的语句数量，占总语句数量的比例 |'
- en: '| Branches | The number of branches of the control structures executed |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 分支 | 执行的控制结构分支数量 |'
- en: '| Functions | The number of functions called, out of the total number of functions
    defined |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 调用的函数数量，占总定义函数数量的比例 |'
- en: '| Lines | The number of lines of source code that are being tested, out of
    the total number of lines present inside the code |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 行数 | 被测试的源代码行数，占总代码行数的比例 |'
- en: By default, Istanbul uses a text reporter, but various other reporters are available.
    You can view the full list at [http://mng.bz/DKoE](http://mng.bz/DKoE).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Istanbul 使用文本报告器，但还有各种其他报告器可用。您可以在 [http://mng.bz/DKoE](http://mng.bz/DKoE)
    查看完整列表。
- en: To generate the HTML format, we will map a volume to /app/coverage, which is
    the folder in which Istanbul will generate the reports. Then, we’ll use the Jenkins
    HTML Publisher plugin to display the generated code coverage reports, as shown
    in the following listing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 HTML 格式，我们将一个卷映射到 /app/coverage，这是 Istanbul 生成报告的文件夹。然后，我们将使用 Jenkins HTML
    发布插件来显示生成的代码覆盖率报告，如下所示。
- en: Listing 8.13 Publishing code coverage HTML reports
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 发布代码覆盖率 HTML 报告
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `publishHTML` command takes the `target` block as the main parameter. Within
    that, we have several subparameters. The `allowMissing` parameter is set to `false`,
    so if something goes wrong while generating the coverage report and the report
    is missing, the `publishHTML` instruction will throw an error.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`publishHTML` 命令将 `target` 块作为主要参数。在此参数内，我们有几个子参数。`allowMissing` 参数设置为 `false`，因此如果在生成覆盖率报告时出现问题且报告缺失，`publishHTML`
    指令将引发错误。'
- en: At the end of the CI pipeline, an HTML file will be generated and consumed by
    the HTML Publisher plugin, as shown in figure 8.20.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI 管道结束时，将生成一个 HTML 文件，并由 HTML 发布插件使用，如图 8.20 所示。
- en: '![](Images/CH08_F20_Labouardy.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F20_Labouardy.png)'
- en: Figure 8.20 HTML report generation with Istanbul
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 使用 Istanbul 生成 HTML 报告
- en: The HTML report will then be accessible from Jenkins, by clicking the Coverage
    Report item from the left panel; see figure 8.21.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击左侧面板的覆盖率报告项，可以从 Jenkins 访问 HTML 报告；见图 8.21。
- en: '![](Images/CH08_F21_Labouardy.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F21_Labouardy.png)'
- en: Figure 8.21 The coverage report can be accessible from the Jenkins panel.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 覆盖率报告可以从Jenkins面板访问。
- en: Note The Cobertura plugin ([https://plugins.jenkins.io/cobertura/](https://plugins.jenkins.io/cobertura/))
    can also be used to publish HTML reports. Both plugins show the same results.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Cobertura插件（[https://plugins.jenkins.io/cobertura/](https://plugins.jenkins.io/cobertura/））也可以用来发布HTML报告。这两个插件显示相同的结果。
- en: We can drill down to identify the uncovered lines and functions, as shown in
    figure 8.22.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以深入挖掘以识别未覆盖的行和函数，如图8.22所示。
- en: '![](Images/CH08_F22_Labouardy.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F22_Labouardy.png)'
- en: Figure 8.22 Deep dive inside the coverage report
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 深入覆盖率报告
- en: Note Several tools exist to create coverage reports, depending on the language
    you use (for example, SimpleCov for Ruby, Coverage.py for Python, and JaCoCo for
    Java).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：根据你使用的语言，存在多种创建覆盖率报告的工具（例如，SimpleCov用于Ruby，Coverage.py用于Python，JaCoCo用于Java）。
- en: You can take this further and run stages in parallel to reduce the waiting time
    of running tests, as shown in the following listing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一过程进一步扩展，并行运行阶段以减少测试运行的等待时间，如下面的列表所示。
- en: Listing 8.14 Running pre-integration tests in parallel
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 并行运行预集成测试
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Figure 8.23 shows the end result of running this job in the Blue Ocean view.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23显示了在Blue Ocean视图中运行此作业的最终结果。
- en: '![](Images/CH08_F23_Labouardy.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F23_Labouardy.png)'
- en: Figure 8.23 Running tests in parallel
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 并行运行测试
- en: 8.9 Automating UI testing with Headless Chrome
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9 使用无头Chrome自动化UI测试
- en: For the Angular application, we will create a Dockerfile.test file that installs
    the Angular CLI ([https://angular.io/cli](https://angular.io/cli)) and the needed
    dependencies to run automated tests; see the following listing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Angular应用程序，我们将创建一个Dockerfile.test文件，该文件安装Angular CLI（[https://angular.io/cli](https://angular.io/cli)）和运行自动化测试所需的依赖项；请参见以下列表。
- en: Listing 8.15 Movie marketplace’s Dockerfile.test
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 电影市场Dockerfile.test文件
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The linting state is similar to the previous part; we will use the TSLint linter,
    which comes installed by default for Angular projects. Hence, we will run the
    `npm` `run` `lint` alias command defined in package.json, as shown in the following
    listing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查状态与上一部分类似；我们将使用默认安装的TSLint代码检查器。因此，我们将运行package.json中定义的`npm run lint`别名命令，如下面的列表所示。
- en: Listing 8.16 Movie marketplace’s package.json
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.16 电影市场package.json
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We update the Jenkinsfile with the following content.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下内容更新Jenkinsfile。
- en: Listing 8.17 Movie marketplace’s Jenkinsfile
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.17 电影市场Jenkinsfile
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s save this config and run a build. The pipeline should fail and turn red
    because of the forced rules on TSLint, as shown in figure 8.24.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存这个配置并运行构建。由于TSLint上的强制规则，管道应该失败并变成红色，如图8.24所示。
- en: '![](Images/CH08_F24_Labouardy.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F24_Labouardy.png)'
- en: Figure 8.24 CI pipeline failur.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 CI管道失败。
- en: If you click the Quality Tests stage logs, the logs should display errors regarding
    missing semicolons and trailing whitespace, as shown in figure 8.25.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击质量测试阶段的日志，日志应该显示有关缺少分号和尾随空白的错误，如图8.25所示。
- en: '![](Images/CH08_F25_Labouardy.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F25_Labouardy.png)'
- en: Figure 8.25 Angular linting output log.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 Angular代码检查输出日志。
- en: If you wish to let TSLint pass within your code (figure 8.26), you need to update
    tslint.json to disable forced rules or add the `/*` `tslint:disable` `*/` instruction
    at the beginning of each file for TSLint to skip the linting process on those
    files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望让TSLint在你的代码中通过（图8.26），你需要更新tslint.json以禁用强制规则或在每个文件的开始处添加`/* tslint:disable
    */`指令，以便TSLint跳过这些文件的代码检查过程。
- en: '![](Images/CH08_F26_Labouardy.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F26_Labouardy.png)'
- en: Figure 8.26 Angular linting output log.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 Angular代码检查输出日志。
- en: For Angular unit testing, we will use the Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/))
    and Karma ([https://karma-runner.github.io/latest/index.html](https://karma-runner.github.io/latest/index.html))
    frameworks. Both testing frameworks support the BDD practice, which describes
    tests in a human-readable format for nontechnical people. The sample unit test
    (chapter7/microservices/ movies-marketplace/src/app/app.component.spec.ts) in
    the following listing is self-explanatory. It tests whether the app component
    has a property `text` with the value `Watchlist` that is rendered in the HTML
    inside a `span` element tag.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Angular 单元测试，我们将使用 Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/))
    和 Karma ([https://karma-runner.github.io/latest/index.html](https://karma-runner.github.io/latest/index.html))
    框架。这两个测试框架都支持 BDD 实践，它以人类可读的格式描述测试，便于非技术人员理解。以下列表中的示例单元测试（chapter7/microservices/movies-marketplace/src/app/app.component.spec.ts）是自我解释的。它测试了应用组件是否有一个值为
    `Watchlist` 的 `text` 属性，该属性在 `span` 元素标签内的 HTML 中渲染。
- en: Listing 8.18 Movie marketplace’s Karma tests
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 电影市场 Karma 测试
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note When creating Angular projects with the Angular CLI, it defaults to creating
    and running unit tests by using Jasmine and Karma.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当使用 Angular CLI 创建 Angular 项目时，默认使用 Jasmine 和 Karma 创建和运行单元测试。
- en: Running unit tests for frontend web applications requires them to be tested
    in a web browser. While it’s not an issue on a workstation or host machine, it
    can become tedious when running in a restricted environment such as a Docker container.
    In fact, these execution environments are generally lightweight and do not contain
    any graphical environment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前端 Web 应用的单元测试需要它们在 Web 浏览器中进行测试。虽然在工作站或主机机器上这不是问题，但在受限环境中（如 Docker 容器）运行时可能会变得繁琐。实际上，这些执行环境通常是轻量级的，并且不包含任何图形环境。
- en: 'Fortunately, Karma tests can be run with a UI-less browser, and two main options
    can be used: Chrome Headless or PhantomJS. The example in the following listing
    uses Chrome Headless with Puppeteer, which can be configured on a simple flag
    in the Karma config (chapter7/microservices/movies-marketplace/karma.conf.js).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Karma 测试可以使用无界面浏览器运行，主要有两种选项：Chrome Headless 或 PhantomJS。以下列表中的示例使用 Chrome
    Headless 和 Puppeteer，这可以在 Karma 配置中的简单标志上进行配置（chapter7/microservices/movies-marketplace/karma.conf.js）。
- en: Listing 8.19 Karma runner configuration
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 Karma 运行器配置
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Headless Chrome needs sudo privileges to be run unless the `--no-sandbox` flag
    is used. Next, we need to update Dockerfile.test to install Chromium:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Headless Chrome 需要sudo权限才能运行，除非使用 `--no-sandbox` 标志。接下来，我们需要更新 Dockerfile.test
    以安装 Chromium：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note Chromium/Google Chrome has shipped with the headless mode since version
    59.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Chromium/Google Chrome 自 59 版本起已包含无头模式。
- en: Then, we update the Jenkinsfile to run unit tests with the `npm` `run` `test`
    command. The command will fire up Headless Chrome and execute Karma.js tests.
    Next, we generate a coverage report in HTML format that will be consumed by the
    HTML Publisher plugin, as shown in the following listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新 Jenkinsfile 以使用 `npm run test` 命令运行单元测试。该命令将启动 Headless Chrome 并执行 Karma.js
    测试。接下来，我们将生成一个 HTML 格式的覆盖率报告，该报告将由 HTML 发布器插件使用，如下所示。
- en: Listing 8.20 Mapping the workspace folder with the Docker container volum.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 将工作区文件夹映射到 Docker 容器卷。
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once changes are pushed to the GitHub repository, a new build will be triggered
    and unit tests will be executed, as shown in figure 8.27.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将更改推送到 GitHub 仓库，将触发新的构建，并执行单元测试，如图 8.27 所示。
- en: '![](Images/CH08_F27_Labouardy.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F27_Labouardy.png)'
- en: Figure 8.27 Running headless Chrome inside a Docker container
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 在 Docker 容器内运行无头 Chrome
- en: The Karma launcher will run the tests on the Headless Chrome browser and display
    the code coverage statistics, as shown in figure 8.28.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 启动器将在 Headless Chrome 浏览器上运行测试，并显示代码覆盖率统计信息，如图 8.28 所示。
- en: '![](Images/CH08_F28_Labouardy.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F28_Labouardy.png)'
- en: Figure 8.28 Successful execution of the Karma unit tests
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 Karma 单元测试成功执行
- en: Also, a generated HTML report will be available in the Artifacts section in
    the Blue Ocean view, shown in figure 8.29.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成的 HTML 报告将在 Blue Ocean 视图中的“工件”部分可用，如图 8.29 所示。
- en: '![](Images/CH08_F29_Labouardy.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F29_Labouardy.png)'
- en: Figure 8.29 Coverage report alongside other artifacts
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 覆盖率报告与其他工件并列
- en: If you click the coverage report link, it should display the statements and
    functions coverage by Angular components and services, as shown in figure 8.30.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击覆盖率报告链接，它应显示 Angular 组件和服务通过语句和函数的覆盖率，如图 8.30 所示。
- en: '![](Images/CH08_F30_Labouardy.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F30_Labouardy.png)'
- en: Figure 8.30 Coverage statistics by filename
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.30 按文件名统计的覆盖率统计
- en: With this done, it is now possible to run the unit tests with Chromium inside
    a Docker container.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，现在可以在 Docker 容器内使用 Chromium 运行单元测试。
- en: 8.10 Integrating SonarQube Scanner with Jenkins
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.10 将 SonarQube Scanner 与 Jenkins 集成
- en: While code linters can give you a high-level overview of the quality of your
    code, they’re still limited if you want to perform deep static code analysis and
    inspection to detect potential bugs and vulnerabilities. That’s where SonarQube
    comes into play. it will give you a 360-degree vision of the quality of the codebase
    by integrating external libraries like PMD, Checkstyle, and FindBugs. Every time
    code gets committed, code analysis is performed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码检查器可以给你一个关于代码质量的总体概述，但如果你想要执行深入的静态代码分析和检查以检测潜在的错误和漏洞，它们仍然有限。这就是 SonarQube
    发挥作用的地方。它将通过集成外部库如 PMD、Checkstyle 和 FindBugs，为你提供一个代码库质量的 360 度视角。每次代码提交时，都会执行代码分析。
- en: Note SonarQube can be used to inspect code in more than 20 programming languages,
    including Java, PHP, Go, and Python.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：SonarQube 可以用于检查超过 20 种编程语言的代码，包括 Java、PHP、Go 和 Python。
- en: To deploy SonarQube, we will bake a new AMI with Packer. Similarly to previous
    chapters, we create a template.json file with the content in the following listing
    (chapter8/sonarqube/packer/template.json).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 SonarQube，我们将使用 Packer 烘焙一个新的 AMI。类似于前面的章节，我们创建一个 template.json 文件，其内容如下（chapter8/sonarqube/packer/template.json）。
- en: Listing 8.21 Jenkins worker’s Packer templat.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 Jenkins 工作节点的 Packer 模板。
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The temporary EC2 instance will be based on Amazon Linux AMI and uses a shell
    script to provision the instance to install SonarQube and configure the needed
    dependencies.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时性 EC2 实例将基于 Amazon Linux AMI，并使用 shell 脚本来配置实例以安装 SonarQube 和配置所需的依赖项。
- en: The setup.sh script will install SonarQube from the official release page. For
    this example, SonarQube 8.2.0 will be installed. SonarQube supports PostgreSQL,
    MySQL, Microsoft SQL Server (MSSQL), and Oracle as a backend. I opted to go with
    PostgreSQL to store configurations and report results. Then, the script creates
    a directory named sonar, sets permissions, and configures SonarQube to start automatically;
    see the following listing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: setup.sh 脚本将从官方发布页面安装 SonarQube。在此示例中，将安装 SonarQube 8.2.0。SonarQube 支持 PostgreSQL、MySQL、Microsoft
    SQL Server (MSSQL) 和 Oracle 作为后端。我选择使用 PostgreSQL 来存储配置和报告结果。然后，脚本创建一个名为 sonar
    的目录，设置权限，并配置 SonarQube 以自动启动；请参见以下列表。
- en: Listing 8.22 Installing SonarQube LT.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22 安装 SonarQube LT。
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note The full shell script is available on the GitHub repository along with
    a step-by-step guide. Also, make sure you have at least 4 GB of memory to run
    the 64-bit version of SonarQube.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：完整的 shell 脚本可在 GitHub 仓库中找到，附带逐步指南。同时，请确保您至少有 4 GB 的内存来运行 SonarQube 的 64
    位版本。
- en: Once you define the needed Packer variables, issue a packer build command to
    start the provisioning process. Once the AMI is baked, it should be available
    on the EC2 dashboard in the Images section, as shown in figure 8.31.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了所需的 Packer 变量，执行 packer build 命令以启动配置过程。一旦 AMI 被烘焙，它应该可以在图 8.31 所示的 EC2
    仪表板中的镜像部分找到。
- en: '![](Images/CH08_F31_Labouardy.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F31_Labouardy.png)'
- en: Figure 8.31 SonarQube machine image
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.31 SonarQube 机器镜像
- en: From there, use Terraform to deploy a private EC2 instance based on the SonarQube
    AMI, as shown in the following listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，使用 Terraform 部署基于 SonarQube AMI 的私有 EC2 实例，如下所示。
- en: Listing 8.23 SonarQube EC2 instance resource with Terraform
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.23 使用 Terraform 的 SonarQube EC2 实例资源
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then, define a public load balancer to forward incoming HTTP and HTTPS (optional)
    traffic to the instance on port 9000 (the port to which the SonarQube dashboard
    is exposed). Also, create an A record in Route 53 pointing to the load balancer
    FQDN.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义一个公共负载均衡器，将传入的 HTTP 和 HTTPS（可选）流量转发到端口 9000（SonarQube 仪表板暴露的端口）上的实例。同时，在
    Route 53 中创建一个指向负载均衡器 FQDN 的 A 记录。
- en: Issue the `terraform apply` command to provision the instance and other resources.
    The instance should be deployed in a few seconds, as shown in figure 8.32.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `terraform apply` 命令以配置实例和其他资源。实例应在几秒钟内部署完成，如图 8.32 所示。
- en: '![](Images/CH08_F32_Labouardy.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F32_Labouardy.png)'
- en: Figure 8.32 SonarQube private EC2 instance
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.32 SonarQube 私有 EC2 实例
- en: On the terminal, you should have the URL of the public load balancer in the
    Outputs section, as shown in figure 8.33.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上，你应该在输出部分看到公共负载均衡器的 URL，如图 8.33 所示。
- en: '![](Images/CH08_F33_Labouardy.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F33_Labouardy.png)'
- en: Figure 8.33 SonarQube DNS URL
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.33 SonarQube DNS URL
- en: Head over to the URL and log in with the default credentials (figure 8.34).
    Right now, no user accounts are configured in SonarQube. However, by default,
    an admin account exists with the username `admin` and the password `admin`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 转到URL并使用默认凭证（图8.34）登录。目前，SonarQube中没有配置用户帐户。然而，默认情况下，存在一个名为`admin`的管理员帐户，密码为`admin`。
- en: '![](Images/CH08_F34_Labouardy.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F34_Labouardy.png)'
- en: Figure 8.34 SonarQube web dashboard
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34 SonarQube网络仪表板
- en: Next, make sure the TypeScript analyzer is enabled from the SonarQube Plugins
    section, as shown in figure 8.35.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保从SonarQube插件部分启用TypeScript分析器，如图8.35所示。
- en: '![](Images/CH08_F35_Labouardy.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F35_Labouardy.png)'
- en: Figure 8.35 SonarQube TypeScript analyzer plugin
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35 SonarQube TypeScript分析插件
- en: Then, generate a new token for Jenkins to avoid using SonarQube admin credentials
    for security purposes. Go to Administration and navigate to Security. On the same
    page under the Tokens section is an option to generate a token; click the Generate
    button, shown in figure 8.36.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为Jenkins生成一个新的令牌，以避免出于安全目的使用SonarQube管理员凭证。转到管理界面并导航到安全。在同一个页面下的令牌部分有一个生成令牌的选项；点击图8.36所示的生成按钮。
- en: '![](Images/CH08_F36_Labouardy.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F36_Labouardy.png)'
- en: Figure 8.36 SonarQube Jenkins dedicated token
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36 SonarQube Jenkins专用令牌
- en: The server authentication token should be created as a `Secret text` credential
    from Jenkins, as shown in figure 8.37.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器身份验证令牌应从Jenkins创建为`Secret text`凭证，如图8.37所示。
- en: '![](Images/CH08_F37_Labouardy.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F37_Labouardy.png)'
- en: Figure 8.37 SonarQube secret text credentials
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37 SonarQube秘密文本凭证
- en: To trigger the scanning from the CI pipeline, we need to install SonarQube Scanner.
    You can choose to either install it automatically or provide the installation
    path for this tool on Jenkins workers. It can be installed by choosing Manage
    Jenkins > Global Tool Configuration. Or you can bake a new Jenkins worker image
    with SonarQube Scanner with the commands shown in the following listing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要从CI管道触发扫描，我们需要安装SonarQube Scanner。您可以选择自动安装或为Jenkins工作节点提供此工具的安装路径。可以通过选择管理Jenkins
    > 全局工具配置来安装它。或者，您可以使用以下列表中的命令创建一个新的Jenkins工作节点镜像，其中包含SonarQube Scanner。
- en: Listing 8.24 SonarQube Scanner installation
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.24 SonarQube Scanner安装
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note The launch configuration of the Jenkins workers is immutable. You will
    need to clone the launch configuration, update it with newly built AMI, and attach
    it to the Jenkins workers’ Auto Scaling group to create new workers with the Sonar
    Scanner tool.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins工作节点的启动配置是不可变的。您需要克隆启动配置，使用新构建的AMI更新它，并将其附加到Jenkins工作节点的自动扩展组，以创建带有Sonar
    Scanner工具的新工作节点。
- en: Lastly, make Jenkins aware of the SonarQube server installation from the Configure
    menu in Manage Jenkins, as shown in figure 8.38.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从Manage Jenkins中的配置菜单使Jenkins了解SonarQube服务器的安装情况，如图8.38所示。
- en: '![](Images/CH08_F38_Labouardy.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F38_Labouardy.png)'
- en: Figure 8.38 SonarQube server settings
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38 SonarQube服务器设置
- en: Then, create a sonar-project.properties file in the movies-marketplace root
    folder to publish the coverage report to the SonarQube server. This file contains
    certain sonar properties, such as which folder to scan and exclude, and the name
    of the project; see the following listing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在movies-marketplace根目录下创建一个sonar-project.properties文件，以便将覆盖率报告发布到SonarQube服务器。此文件包含某些sonar属性，例如要扫描和排除的文件夹以及项目的名称；请参阅以下列表。
- en: Listing 8.25 SonarQube project configuration
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.25 SonarQube项目配置
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, update the Jenkinsfile to create a new `Static` `Code` `Analysis` stage.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新Jenkinsfile以创建一个新的`静态` `代码` `分析`阶段。
- en: Then inject a SonarQube global configuration (secret token and SonarQube server
    URL values) with the `withSonarQubeEnv` block and invoke the `sonar-scanner` command
    to start the analysis process, as shown in the following listing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`withSonarQubeEnv`块注入SonarQube全局配置（秘密令牌和SonarQube服务器URL值），并调用`sonar-scanner`命令以启动分析过程，如以下列表所示。
- en: Listing 8.26 Triggering SonarQube analysis
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.26 触发SonarQube分析
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can override property values by using the `-D` flag:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `-D` 标志来覆盖属性值：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This option allows us to attach the Jenkins build number with every analysis
    that we perform and publish to SonarQube.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许我们将Jenkins构建号附加到我们执行的每个分析和发布的SonarQube。
- en: 'After a successful build, the logs will show you the files and folders SonarQube
    has scanned. After scanning, the analysis report is posted to the SonarQube server
    we have integrated. This analysis is based on rules defined by SonarQube. If the
    code passes the error threshold, it’s allowed to move to the next step in its
    life cycle. But if it crosses the error threshold, it’s dropped:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建成功后，日志将显示SonarQube已扫描的文件和文件夹。扫描后，分析报告将发布到我们已集成的SonarQube服务器。此分析基于SonarQube定义的规则。如果代码通过错误阈值，则允许其生命周期中的下一步。但如果它超过错误阈值，则会被丢弃：
- en: '![](Images/CH08_F38_UN01_Labouardy.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F38_UN01_Labouardy.png)'
- en: You can define your custom thresholds by creating Quality Profiles, which are
    a set of rules that will make the pipeline fail if an issue is raised in your
    codebase.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建质量配置文件来定义自己的自定义阈值，这些配置文件是一组规则，如果代码库中提出问题，则会导致管道失败。
- en: 'Note Refer to this official documentation for a step-by-step guide on how to
    create SonarQube custom rules with Quality Profiles: [http://mng.bz/l9vy](http://mng.bz/l9vy).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请参考此官方文档以获取创建带有质量配置文件的SonarQube自定义规则的逐步指南：[http://mng.bz/l9vy](http://mng.bz/l9vy)。
- en: Finally, on visiting the SonarQube server, the project details should be visible
    with all the metrics captured from the code coverage report, as you can see in
    figure 8.39.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在访问SonarQube服务器时，项目详情应显示所有从代码覆盖率报告中捕获的指标，如图8.39所示。
- en: '![](Images/CH08_F39_Labouardy.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F39_Labouardy.png)'
- en: Figure 8.39 SonarQube project metrics
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39 SonarQube项目指标
- en: Now you can go inside the movies-marketplace project and discover issues, bugs,
    code smells, coverage, or duplication. The dashboard (figure 8.40) shows where
    you stand in terms of quality in the glimpse of an eye.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以进入movies-marketplace项目并发现问题、错误、代码异味、覆盖率或重复。仪表板（图8.40）让您一眼就能看到质量状况。
- en: '![](Images/CH08_F40_Labouardy.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F40_Labouardy.png)'
- en: Figure 8.40 SonarQube project deep-dive metrics and issues
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.40 SonarQube项目深度指标和问题
- en: Also, when the job is completed, the SonarQube Scanner plugin will detect that
    a SonarQube analysis was made during the build. The plugin will then display a
    badge and a widget on the Jenkins job page with a link to the SonarQube dashboard
    as well as quality gate status, as shown in figure 8.41.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当作业完成时，SonarQube Scanner插件将检测到在构建过程中进行了SonarQube分析。然后，插件将在Jenkins作业页面上显示一个徽章和一个小部件，其中包含到SonarQube仪表板的链接以及质量门状态，如图8.41所示。
- en: '![](Images/CH08_F41_Labouardy.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F41_Labouardy.png)'
- en: Figure 8.41 SonarQube integration with Jenkins
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.41 SonarQube与Jenkins集成
- en: The SonarQube analysis was quick, but for larger projects, the analysis might
    take a few minutes to complete.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube分析速度快，但对于较大的项目，分析可能需要几分钟才能完成。
- en: To wait for the analysis to be completed, we will pause the pipeline with the
    `withForQualityGate` step, which waits for SonarQube analysis to be done. To notify
    the CI pipeline about the analysis completion, we need to create a webhook on
    SonarQube to notify Jenkins when project analysis is done, as shown in figure
    8.42.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待分析完成，我们将使用`withForQualityGate`步骤暂停管道，该步骤等待SonarQube分析完成。为了通知CI管道关于分析完成的情况，我们需要在SonarQube上创建一个webhook，以便在项目分析完成后通知Jenkins，如图8.42所示。
- en: '![](Images/CH08_F42_Labouardy.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F42_Labouardy.png)'
- en: Figure 8.42 SonarQube webhook creation
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.42 SonarQube webhook创建
- en: Next, in the following listing, we update the Jenkinsfile to integrate the `waitForQualityGate`
    step that pauses the pipeline until SonarQube analysis is completed and returns
    the quality gate status.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在下面的列表中，我们更新Jenkinsfile以集成`waitForQualityGate`步骤，该步骤暂停管道直到SonarQube分析完成并返回质量门状态。
- en: Listing 8.27 Adding a quality gate to the Jenkinsfile
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.27 在Jenkinsfile中添加质量门
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note The quality gate can be moved outside the `node{}` block to avoid occupying
    a Jenkins worker waiting for SonarQube notification.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：质量门可以移出`node{}`块之外，以避免占用等待SonarQube通知的Jenkins工作节点。
- en: Commit the changes and push them to the remote repository. A new build will
    be triggered, and SonarQube analysis will be kicked off automatically. Once the
    analysis is completed, a notification will be sent to the CI pipeline to resume
    the pipeline stages, as shown in figure 8.43.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改并将它们推送到远程仓库。将触发新的构建，并自动启动SonarQube分析。一旦分析完成，就会向CI管道发送通知以恢复管道阶段，如图8.43所示。
- en: Note We can set up Post-build actions in Jenkins to notify the user about the
    test results.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可以在Jenkins中设置Post-build操作来通知用户关于测试结果。
- en: '![](Images/CH08_F43_Labouardy.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F43_Labouardy.png)'
- en: Figure 8.43 SonarQube project analysis status
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.43 SonarQube项目分析状态
- en: As a result, as soon as a developer commits the code to GitHub, Jenkins will
    fetch/pull the code from the GitHub repository, perform static code analysis with
    the help of Sonar Scanner, and send analysis reports to the SonarQube server.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦开发者在GitHub上提交代码，Jenkins就会从GitHub仓库中获取/拉取代码，在Sonar Scanner的帮助下执行静态代码分析，并将分析报告发送到SonarQube服务器。
- en: In this chapter, you learned how to run various automated tests and how to integrate
    external tools like Nancy and SonarQube to inspect code quality, detect bugs,
    and avoid potential security vulnerabilities while continuously building microservices
    within Jenkins CI pipelines. In the next chapter, we will build the Docker image
    after a successful run of tests and push the image to a private remote repository.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何运行各种自动化测试，以及如何集成外部工具如Nancy和SonarQube来检查代码质量、检测错误，并在Jenkins CI管道中持续构建微服务的同时避免潜在的安全漏洞。在下一章中，我们将在测试成功运行后构建Docker镜像，并将镜像推送到私有远程仓库。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Docker containers are used to run tests to avoid installing multiple runtime
    environments for each service we’re integrating and keep a consistent execution
    environment across all Jenkins workers.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器来运行测试，以避免为每个我们要集成的服务安装多个运行时环境，并保持所有Jenkins工作节点之间的一致执行环境。
- en: Promoting traditional security practices into CI/CD workflows like external
    dependencies scanning can enable an additional security layer to avoid security
    breaches and vulnerabilities.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传统安全实践（如外部依赖项扫描）推广到CI/CD工作流程中，可以增加一个安全层，以避免安全漏洞和漏洞。
- en: Headless Chrome is a way to run UI tests in a headless environment without the
    full browser UI.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头Chrome是一种在无头环境中运行UI测试的方法，而不需要完整的浏览器UI。
- en: The parallel DSL step gives the ability to easily run pipeline stages in parallel.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行DSL步骤提供了轻松并行运行管道阶段的能力。
- en: SonarQube is a code-quality management tool that allows teams to manage, track,
    and improve the quality of their source code.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube是一个代码质量管理工具，允许团队管理、跟踪和改进其源代码的质量。
