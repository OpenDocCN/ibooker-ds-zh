- en: 5  Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 路由
- en: As we’ve seen, routing is one of Express's big features, allowing you to map
    different requests to different request handlers. In this chapter, we'll go far
    more in depth. We'll look at routing in detail, how to use Express with HTTPS,
    Express 4's new routers feature, and more. We'll also build a couple of routing-centric
    applications, one of which will be a running example throughout the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，路由是Express的主要功能之一，允许您将不同的请求映射到不同的请求处理器。在本章中，我们将更深入地探讨。我们将详细研究路由，如何使用Express与HTTPS，Express
    4的新路由器功能，以及更多。我们还将构建几个以路由为中心的应用程序，其中之一将是贯穿本书的运行示例。
- en: In this chapter, I'll tell you everything there is to know about routing in
    Express!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将告诉你关于Express路由的所有知识！
- en: 5.1     What is routing?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 什么是路由？
- en: Let's imagine we're building the homepage for Olivia Example. She's a great
    lady and we're honored to build her website.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在为Olivia Example构建主页。她是一位了不起的女性，我们很荣幸为她建立网站。
- en: 'If we''re a browser visiting `example.com/olivia`, here''s what the "raw" HTTP
    request might look like:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是一个访问`example.com/olivia`的浏览器，这里的“原始”HTTP请求可能看起来是这样的：
- en: Listing 5.1 The first line of an HTTP request
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 HTTP请求的第一行
- en: '`GET /olivia http/1.1`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET /olivia http/1.1`'
- en: That HTTP request has a verb (`GET`), a URI (the `/olivia` part), and the HTTP
    version (1.1). When we're routing, we take the pair of the verb and the URI and
    map it to a request handler. We basically say, "Hey, Express! When you see a`GET` request
    to `/about_me`, run this code. And when you see a POST request to `/new_user`,
    run this other code."
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTTP请求有一个动词（`GET`），一个URI（`/olivia`部分），以及HTTP版本（1.1）。当我们进行路由时，我们将动词和URI的配对映射到请求处理器。我们基本上说：“嘿，Express！当你看到对`/about_me`的`GET`请求时，运行这段代码。当你看到对`/new_user`的POST请求时，运行这段其他代码。”
- en: That's pretty much it—routing maps verbs and URIs to specific code. Let's take
    a look at a simple example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是全部内容——路由将动词和URI映射到特定的代码。让我们看看一个简单的例子。
- en: 5.1.1  A simple example
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 简单示例
- en: 'Let''s say we want to write a simple Express application that responds to the
    HTTP request above (an HTTP GET to `/olivia`). We''ll call some methods on our
    Express app, like so:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个简单的Express应用程序来响应上述HTTP请求（对`/olivia`的HTTP GET请求）。我们将在我们的Express应用程序上调用一些方法，如下所示：
- en: Listing 5.2 A simple Express app that shows Olivia's homepage
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 一个简单的Express应用程序，显示Olivia的主页
- en: '`var express = require("express");` `var app = express();`   `app.get("/olivia",
    function(request, response) {  #B` `  response.send("Welcome to Olivia''s homepage!");`
    `});`   `app.use(function(request, response) {  #C` `  response.status(404).send("Page
    not found!");` `}); `  `app.listen(3000); #D`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `app.get("/olivia",
    function(request, response) {  #B` `response.send("欢迎来到Olivia的主页！");` `});` `app.use(function(request,
    response) {  #C` `response.status(404).send("页面未找到！");` `});` `app.listen(3000);
    #D`'
- en: '#B  This is the magical part; this routes GET requests to /olivia to the request
    handler we specify.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这是神奇的部分；它将GET请求映射到我们指定的请求处理器。'
- en: '#C  If you load /olivia, that''s all good. But if you load something else (like
    /olivia_example), we want to serve a 404 error.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 如果您加载/olivia，那就没问题。但如果您加载其他内容（如/olivia_example），我们希望返回404错误。'
- en: '#D Finally, we start the server on port 3000!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 最后，我们在3000端口启动服务器！'
- en: 'The real meat of this example is on the third line: when we get HTTP GET requests
    to `/olivia`, we run the specified request handler. To hammer this home: we''ll
    ignore this if we see a GET request to some other URI, and we''ll also ignore
    this if we see a non-GET request to `/olivia`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的真正内容在第三行：当我们收到对`/olivia`的HTTP GET请求时，我们运行指定的请求处理器。为了强调这一点：如果我们看到对其他URI的GET请求，我们将忽略它，如果我们看到对`/olivia`的非GET请求，我们也会忽略它。
- en: This is a pretty simple example (hence the title of this section). Let's take
    a look at some more complex routing features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的例子（因此本节的标题）。让我们看看一些更复杂的路由功能。
- en: 5.2     The features of routing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 路由功能
- en: 'So we''ve just looked at a simple example of routing. Conceptually, it''s not
    too crazy: it maps an HTTP verb + URI combo to a request handler. This lets you
    map things like GET `/about` or POST `/user/log_in` to a specific bit of code.
    This is great!'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚查看了一个简单的路由示例。从概念上讲，它并不疯狂：它将HTTP动词+ URI组合映射到请求处理器。这允许您将诸如GET `/about`
    或 POST `/user/log_in` 等内容映射到特定的代码块。这太棒了！
- en: But we're greedy. If Express were a vat of ice cream, we wouldn't be satisfied
    with one scoop. We want more scoops. We want sprinkles. We want chocolate sauce.
    We want more routing features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们是贪婪的。如果Express是一桶冰淇淋，我们不会满足于一勺。我们想要更多的勺子。我们想要糖霜。我们想要巧克力酱。我们想要更多的路由功能。
- en: NOTE Some other frameworks (Ruby on Rails, for example) have a centralized routing
    file where all routes are defined in one place. Express is not this way—they can
    be defined in a lot of places.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些其他框架（例如Ruby on Rails）有一个集中式的路由文件，其中所有路由都在一个地方定义。Express不是这样——它们可以在很多地方定义。
- en: 5.2.1  Grabbing parameters to routes
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 从路由中获取参数
- en: The routes we've seen above could really be expressed in code with a strict
    equality operator (`===`); is the user visiting `/olivia`? That's very useful,
    but it doesn't give us all the expressive power we might want.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的路由实际上可以用严格的相等运算符（`===`）在代码中表达；用户是否访问了`/olivia`？这非常有用，但它并不提供我们可能想要的全部表达力。
- en: 'Imagine you''ve been tasked to make a website that has user profiles, and imagine
    that every user has a numeric ID. You want the URL for user #1 to be `/users/1`.
    User #2 should be found at `/users/2` (and so on). Rather than define, in code,
    a new route for every single new user (which would be crazy), you can define one
    route for everything that starts with `/users/` and then has an ID.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被分配了一个任务，要制作一个包含用户资料的网站，并且假设每个用户都有一个数字ID。你希望用户#1的URL是`/users/1`。用户#2应该在`/users/2`（以此类推）找到。与其为每个新用户在代码中定义一个新的路由（这会非常疯狂），你不如定义一个以`/users/`开头的路由，然后跟上一个ID。
- en: THE SIMPLEST WAY
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法
- en: The absolutely simplest way to grab a parameter is by simply putting it in your
    route with a colon in front of it. To grab the value, you'll look inside the params
    property of the request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 获取参数的最简单方法就是简单地在路由中将其放入，并在其前面加上一个冒号。要获取值，你将查看请求的params属性。
- en: Listing 5.3 The simplest parameter
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 最简单的参数
- en: '`app.get("/users/:userid", function(req, res) {       #A` `   var userId =
    parseInt(req.params.userid, 10);     #B` `   // …``});`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/users/:userid", function(req, res) {       #A` `   var userId =
    parseInt(req.params.userid, 10);     #B` `   // …``});`'
- en: '#A This will match requests coming into /users/123 and /users/horse_ebooks
    too.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这将匹配进入`/users/123`和`/users/horse_ebooks`的请求。'
- en: '#B The userid property is always a string in this case, so we have to convert
    it to an integer. If we visit /users/olivia, though, this will return NaN, which
    we''ll need to handle.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 在这种情况下，userid属性始终是一个字符串，因此我们必须将其转换为整数。如果我们访问`/users/olivia`，这将返回NaN，我们需要处理这种情况。'
- en: In the above example, we see how to grab parameters from a more dynamic route.
    The code above will match what we want; things like `/users/123` and `/users/8`.
    But while it won't match a parameter-less `/users/` or`/users/123/posts`, it probably
    still matches more than what we want. For example, it'll also match `/users/cake` and `/users/horse_ebooks`.
    If we want to be more specific, we have a few options.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们看到如何从一个更动态的路由中获取参数。上面的代码将匹配我们想要的内容；例如`/users/123`和`/users/8`。但是，它不会匹配没有参数的`/users/`或`/users/123/posts`，但它可能仍然匹配比我们想要的更多。例如，它还会匹配`/users/cake`和`/users/horse_ebooks`。如果我们想更加具体，我们有一些选择。
- en: NOTE While it's often that you'll want to be more specific with your parameter
    definitions, it might very well be that this is fine for your purposes! You might
    want to allow /users/123 and /users/count_dracula. Even if you only want to allow
    numeric parameters, you might prefer to have validation logic right in the route.
    As we'll see, there are other ways to do it, but that might be just fine for you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然你通常希望你的参数定义更加具体，但这也完全可能适合你的需求！你可能希望允许`/users/123`和`/users/count_dracula`。即使你只想允许数字参数，你也可能更喜欢在路由中直接添加验证逻辑。正如我们将看到的，还有其他方法可以做到这一点，但这可能对你来说已经足够好了。
- en: 5.2.2  Using regular expressions to match routes
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 使用正则表达式匹配路由
- en: Express allows you to specify your routes as strings, but it also allows you
    to specify them as regular expressions. This gives you more control over the routes
    you specify. You can also use regular expressions to match parameters, as we'll
    see.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Express 允许你以字符串的形式指定你的路由，但它也允许你以正则表达式的方式指定它们。这让你对指定的路由有更多的控制。你还可以使用正则表达式来匹配参数，正如我们将看到的。
- en: NOTE Regular expressions can get a little hairy. They scared me when I first
    started working with them, but I found that fear greatly reduced by the entry
    on the Mozilla Developer Network. If you need help, I strongly recommend checking
    it out at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正则表达式可能会变得有些复杂。当我第一次开始使用它们时，它们让我感到害怕，但我发现通过Mozilla开发者网络上的条目，这种恐惧大大减少了。如果你需要帮助，我强烈建议你查看https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions。
- en: Let's imagine that we want to match things like `/users/123` or `/users/456`,
    but not `/users/olivia`. We can code this into a regular expression and grab the
    number to boot.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要匹配像`/users/123`或`/users/456`这样的东西，但不匹配`/users/olivia`。我们可以将这个逻辑编码到正则表达式中，并捕获数字。
- en: Listing 5.5 Using regular expressions for numeric routes
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 使用正则表达式进行数字路由
- en: '`app.get(/^\/users\/(\d+)$/, function(req, res) { #A` `  var userId = parseInt(req.params[0],
    10); #B` `  // ...``});`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get(/^\/users\/(\d+)$/, function(req, res) { #A` `  var userId = parseInt(req.params[0],
    10); #B` `  // ...``});`'
- en: '#A This both defines the route (starts with /users/ and ends with one or more
    digits)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这既定义了路由（以/users/开头，以一个或多个数字结尾）'
- en: and captures the digits, which is used on the next line. If this regular expression
    looks daunting, that's because all regular expressions look daunting.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并捕获数字，这在下一行使用。如果这个正则表达式看起来令人畏惧，那是因为所有正则表达式看起来都令人畏惧。
- en: '#B The parameters aren''t named this time, so we access them by their ordinality.
    If we captured a second value, we''d look inside req.params[1], and so on. Note
    that we still capture them as strings and have to convert them manually.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这次参数没有命名，所以我们通过它们的序号来访问它们。如果我们捕获了第二个值，我们会查看req.params[1]，依此类推。请注意，我们仍然将它们作为字符串捕获，并必须手动进行转换。'
- en: This is one way to enforce the "the user ID must be an integer" constraint.
    Like the above, it's passed in as a string, so we have to convert it to a number
    (and probably to a user object further down the line).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是强制执行“用户ID必须是整数”约束的一种方法。和上面一样，它作为字符串传入，所以我们必须将其转换为数字（并且可能还要进一步转换为用户对象）。
- en: 'Regular expressions can be a little difficult to read, but you can use them
    to define much more complex routes than these. For example, you might want to
    define a route that looks for ranges. That is, if you visit `/users/100-500`,
    you can see a list of users from IDs 100 to 500\. Regular expressions make this
    relatively easy to express (no pun intended):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可能有点难以阅读，但你可以使用它们来定义比这些更复杂的路由。例如，你可能想要定义一个查找范围的路由。也就是说，如果你访问`/users/100-500`，你可以看到从ID
    100到500的用户列表。正则表达式使这相对容易表达（无意中开玩笑）：
- en: Listing 5.6 Using regular expressions for complex routes
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 使用正则表达式进行复杂路由
- en: '`app.get(/^\/users\/(\d+)-(\d+)$/, function(req, res) { #A` `  var startId
    = parseInt(req.params[0], 10);  #B` `  var endId = parseInt(req.params[1], 10); 
    #C` `  // …``});`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get(/^\/users\/(\d+)-(\d+)$/, function(req, res) { #A` `  var startId
    = parseInt(req.params[0], 10);  #B` `  var endId = parseInt(req.params[1], 10); 
    #C` `  // …``});`'
- en: '#A Like the above, this defines a route with a regular expression. This time,
    we capture two sets of digits on either side of a hyphen character.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 和上面一样，这次我们定义了一个使用正则表达式的路由。这次，我们在连字符两侧捕获两组数字。'
- en: '#B Like before, we grab the first captured parameter as a string and have to
    do some conversion.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 和之前一样，我们获取第一个捕获的参数作为字符串，并需要进行一些转换。'
- en: '#C This is very similar to the previous line, but we''re converting the second
    parameter, not the first.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 这与上一行非常相似，但我们转换的是第二个参数，而不是第一个。'
- en: You can daydream about the crazy number of possibilities this opens up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以梦想这为可能性的数量打开了无数的可能性。
- en: 'For example, I once had to define a route that matched UUIDs (version 3 and
    4). If you''re not familiar, a UUID is a long string of hex digits that looks
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我曾经不得不定义一个匹配UUID（版本3和4）的路由。如果你不熟悉，UUID是一个看起来像这样的长字符串的十六进制数字：
- en: '`xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`'
- en: '...where x is any hex digit and y is 8, 9, A, or B. Let''s say you want to
    write a route that matches any UUID. It might look something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '...其中x是任何十六进制数字，y是8、9、A或B。假设你想编写一个匹配任何UUID的路由。它可能看起来像这样：'
- en: Listing 5.7 UUID-matching routes with a regexp
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 使用正则表达式匹配UUID的路由
- en: '`var horribleRegexp = /^([0-9a-f]{8}-[0-9a-f]{4}-` `[CA]4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})$/i;`
      `app.get(horribleRegexp, function(req, res) {` `  var uuid = req.params[0];`
    `  // ...``});`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`var horribleRegexp = /^([0-9a-f]{8}-[0-9a-f]{4}-` `[CA]4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})$/i;`
    `app.get(horribleRegexp, function(req, res) {` `  var uuid = req.params[0];` ` 
    // ...``});`'
- en: 'I could fill hundreds of pages with more examples, but I won''t. The key takeaway
    here: you can use regular expressions to define your routes.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用数百页的例子来填充，但我不这么做。这里的关键要点：你可以使用正则表达式来定义你的路由。
- en: 5.2.3  Grabbing query arguments
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3  抓取查询参数
- en: Another common way to dynamically pass information in URLs is to use something
    called "query strings". You've probably seen query strings every time you've done
    a search on the Internet. For example, if you searched for "javascript-themed
    burrito" on Google, you'd see a URL like this: `https://www.google.com/search?q=javascript-themed%20burrito`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中动态传递信息的另一种常见方式是使用所谓的“查询字符串”。你可能每次在互联网上搜索时都见过查询字符串。例如，如果你在 Google 上搜索“javascript-themed
    burrito”，你会看到一个像这样的 URL：`https://www.google.com/search?q=javascript-themed%20burrito`
- en: 'This is passing a query. If Google were written in Express (it''s not), it
    might handle a query like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在传递一个查询。如果 Google 是用 Express 编写的（实际上不是），它可能会处理这样的查询：
- en: Listing 5.8 Handling a search query string
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 处理搜索查询字符串
- en: '`app.get("/search", function(req, res) {` `  // req.query.q == "javascript-themed
    burrito"` `  // ...``});`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/search", function(req, res) {` `  // req.query.q == "javascript-themed
    burrito"` `  // ...``});`'
- en: This is pretty similar to how you handle parameters, but it allows you to grab
    this style of query.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这与处理参数的方式非常相似，但它允许你获取这种查询风格。
- en: NOTE There's a common security bug with query parameters, unfortunately. If
    you visit ?arg=something, then req.query.arg will be a string. But if you visit
    ?arg=something&arg=somethingelse, then req.query.arg will be an array. We'll discuss
    coping with these types of issues in detail in Chapter 8, if you thirst for more.
    In general, though, you'll want to make sure that you don't blindly assume something
    is a string or an array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：不幸的是，查询参数有一个常见的安全漏洞。如果你访问 ?arg=something，那么 req.query.arg 将是一个字符串。但是如果你访问
    ?arg=something&arg=somethingelse，那么 req.query.arg 将是一个数组。如果你渴望了解更多，我们将在第 8 章详细讨论如何应对这类问题。不过，总的来说，你想要确保不要盲目地假设某物是一个字符串或一个数组。
- en: 5.3     Using routers to split up your app
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 使用路由器拆分你的应用程序
- en: It's likely that as your application grows, so will your number of routes. Your
    collaborative cat-photo montage site might start with routes for static files
    and for images, but you might later add user accounts, chat, forums, and the like.
    Your number of routes can get unwieldy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能随着你的应用程序的增长，你的路由数量也会增加。你的协作猫照片拼贴网站可能最初只有静态文件和图像的路由，但后来你可能还会添加用户账户、聊天、论坛等。你的路由数量可能会变得难以管理。
- en: 'Express 4 added a feature to help ease these growing pains; it added routers.
    To quote the Express documentation (don''t worry if you don''t perfectly understand
    all of this):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Express 4 增加了一个功能来帮助缓解这些成长的痛苦；它增加了路由器。引用 Express 文档（如果你不完全理解这些内容，请不要担心）：
- en: A router is an isolated instance of middleware and routes. Routers can be thought
    of as "mini" applications only capable of performing middleware and routing. Every
    express application has a built-in app router.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器是中间件和路由的独立实例，可以被视为“迷你”应用程序，只能执行中间件和路由。每个 Express 应用程序都有一个内置的应用程序路由器。
- en: Routers behave like middleware themselves and can be "`.use()`'d" by the app
    o in other routers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器本身就像中间件一样，可以被应用或其它路由器“`.use()`”。
- en: In other words, routers allow you to chunk your big app into many mini apps
    that you can later put together. For small apps, this might be overkill, but as
    soon as you think to yourself, "this `app.js` file is getting big", it's time
    to think about breaking your app down with routers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，路由器允许你将你的大应用程序拆分成许多小应用程序，你可以在以后将它们组合起来。对于小型应用程序，这可能有点过度，但当你想到，“这个 `app.js`
    文件变得很大”，就是时候考虑使用路由器来拆分你的应用程序了。
- en: NOTE Routers really shine when you're building a bigger application. I don't
    want to build a huge application in this section, so this example will have some
    spots that you should fill in with your imagination
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：路由器在构建更大的应用程序时表现得尤为出色。我不想在本节中构建一个巨大的应用程序，所以这个例子中会有一些你应该用想象力填补的地方。
- en: 'Listing 5.9 Routers in action: the main app'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 路由器在行动：主应用程序
- en: '`var express = require("express");` `var path = require("path");` `var apiRouter
    = require("./routes/api_router");  #A`   `var app = express();`   `var staticPath
    = path.resolve(__dirname, "static"); app.use(express.static(staticPath));`   `app.use("/api",
    apiRouter);  #A`  `app.listen(3000);`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var apiRouter
    = require("./routes/api_router");  #A` `var app = express();` `var staticPath
    = path.resolve(__dirname, "static"); app.use(express.static(staticPath));` `app.use("/api",
    apiRouter);  #A` `app.listen(3000);`'
- en: '#A We require our API router (which is defined below) and then we use it in
    our main app, just like we use middleware.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们需要我们的 API 路由器（定义在下面），然后我们就像使用中间件一样使用它在我们的主应用中。'
- en: As you can see, we use our API router just like middleware. Routers are basically
    just middleware! In this case, any URL that starts with `/api` will be sent straight
    to our router. That means that `/api/users` and `/api/message` will use your router
    code, but something like `/about/celinedion` will not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们就像使用中间件一样使用我们的 API 路由。路由基本上就是中间件！在这种情况下，任何以 `/api` 开头的 URL 都会直接发送到我们的路由器。这意味着
    `/api/users` 和 `/api/message` 将使用你的路由代码，但像 `/about/celinedion` 这样的 URL 则不会。
- en: 'Now, let''s go ahead and define our router. Think of it as a sub-application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续定义我们的路由。把它想象成一个子应用：
- en: Listing 5.10 A sample router definition (at routes/api_router.js)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 路由定义示例（在 routes/api_router.js 中）
- en: '`var express = require("express");`   `var ALLOWED_IPS = [` `  "127.0.0.1",`
    `  "123.456.7.89"` `];`   `var api = express.Router();`   `api.use(function(req,
    res, next) {` `  var userIsAllowed = ALLOWED_IPS.indexOf(req.ip) !== -1;` `  if
    (!userIsAllowed) {` `    res.status(401).send("Not authorized!");` `  } else {`
    `    next();` `  }` `});`   `api.get("/users", function(req, res) { /* ... */
    });` `api.post("/user", function(req, res) { /* ... */ });` `api.get("/messages",
    function(req, res) { /* ... */ }); api.post("/message", function(req, res) { /*
    ... */ });`  `module.exports = api;`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var ALLOWED_IPS = [` `  "127.0.0.1",`
    `  "123.456.7.89"` `];` `var api = express.Router();` `api.use(function(req, res,
    next) {` `  var userIsAllowed = ALLOWED_IPS.indexOf(req.ip) !== -1;` `  if (!userIsAllowed)
    {` `    res.status(401).send("未授权！");` `  } else {` `    next();` `  }` `});`
    `api.get("/users", function(req, res) { /* ... */ });` `api.post("/user", function(req,
    res) { /* ... */ });` `api.get("/messages", function(req, res) { /* ... */ });`
    `api.post("/message", function(req, res) { /* ... */ });` `module.exports = api;`'
- en: This looks a lot like a mini-application; it supports middleware and routes.
    The main difference is that it can't stand alone; it has to be plugged into a
    "grown-up" app. Routers can do the same routing that "big" apps can do and they
    can use middleware.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像一个迷你应用；它支持中间件和路由。主要区别在于它不能独立存在；它必须连接到一个“成熟”的应用。路由器可以执行与“大型”应用相同的路由，并且可以使用中间件。
- en: You could imagine making a router with many sub-routers. Maybe you want to make
    an API router that further defers to a "users router" and a "messages router",
    or perhaps something else!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象创建一个具有许多子路由的路由器。也许你想要创建一个 API 路由器，它进一步委托给“用户路由器”和“消息路由器”，或者可能是其他什么！
- en: 5.4     Serving static files
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4      服务静态文件
- en: Unless you're building a web server that's 100% API (and I mean one hundred
    percent), you're probably going to send a static file or two. Maybe you have some
    CSS to send, maybe you have a single-page app that needs some static files sent,
    and maybe you're a donut enthusiast and have gigabytes of donut photos to serve
    your hungry viewers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在构建一个 100% API 的 Web 服务器（我的意思是百分之一百），否则你可能需要发送一个或两个静态文件。也许你需要发送一些 CSS，也许你需要发送一些静态文件给单页应用，也许你是一个喜欢甜甜圈的爱好者，并且有数吉字节甜甜圈照片要提供给饥饿的观众。
- en: We've seen how to send static files before, but let's explore it in more depth.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到过如何发送静态文件，但现在让我们更深入地探讨一下。
- en: 5.4.1  Static files with middleware
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 使用中间件发送静态文件
- en: We've sent static files with middleware before, but don't roll your eyes yet—we're
    going to dive just a little deeper.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用中间件发送过静态文件了，但别皱眉——我们将会深入探讨一下。
- en: 'We went over this in Chapter 2, so I won''t preach the benefits of this stuff.
    I''ll just review the code example we used before:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章中已经讨论过这个问题，所以我就不再宣扬这些好处了。我只会回顾我们之前使用的代码示例：
- en: Listing 5.11 A simple example of express.static
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 express.static 的一个简单示例
- en: '`var express = require("express");` `var path = require("path");` `var http
    = require("http");` `var app = express();`   `var publicPath = path.resolve(__dirname,
    "public");  #A` `app.use(express.static(publicPath)); #B`   `app.use(function(request,
    response) {` `  response.writeHead(200, { "Content-Type": "text/plain" });` ` 
    response.end("Looks like you didn''t find a static file.");` `});`  `http.createServer(app).listen(3000);`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var http
    = require("http");` `var app = express();` `var publicPath = path.resolve(__dirname,
    "public");  #A` `app.use(express.static(publicPath)); #B` `app.use(function(request,
    response) {` `  response.writeHead(200, { "Content-Type": "text/plain" });` ` 
    response.end("看起来你没有找到静态文件。");` `});` `http.createServer(app).listen(3000);`'
- en: '#A Set up the path where our static files will sit, using Node''s path module.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 使用 Node 的 path 模块设置我们的静态文件存放路径。'
- en: '#B Send static files from the publicPath directory.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 从 publicPath 目录发送静态文件。'
- en: Recall that path.resolve helps keep our path resolution cross-platform (things
    are different on Windows and Mac and Linux). Also recall that this is much better
    than doing it all yourself! If any of this is unclear, go back and take a look
    at Chapter 2.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，path.resolve有助于保持我们的路径解析跨平台（Windows、Mac和Linux上的事情是不同的）。也请记住，这比你自己做要好得多！如果任何内容不清楚，请返回并查看第2章。
- en: Now let's go deeper.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更深入地探讨。
- en: CHANGING THE PATHS FOR CLIENTS
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端路径变更
- en: It's common that you'll want to serve files at the root of your site. For example,
    if your URL is http://jokes.edu and you're serving `jokes.txt`, the path will
    be http://jokes.edu/jokes.txt.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在网站的根目录下提供文件。例如，如果你的URL是http://jokes.edu，并且你正在提供`jokes.txt`，则路径将是http://jokes.edu/jokes.txt。
- en: But you might also want to mount some static files at a different URL for clients.
    For example, you might want a folder full of offensive-but-hilarious photos to
    look like it's in a folder called "offensive", so a user might visit http://jokes.edu/offensive/photo123.jpg.
    How might we do this?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能还希望将一些静态文件挂载到不同的URL上供客户端使用。例如，你可能希望一个充满攻击性但非常有趣的图片文件夹看起来像在名为“offensive”的文件夹中，因此用户可能访问http://jokes.edu/offensive/photo123.jpg。我们该如何实现这一点？
- en: 'Express to the rescue: middleware can be "mounted" at a given prefix. In other
    words, you can make a middleware only respond if it starts with `/offensive`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Express来拯救：中间件可以在给定前缀上“挂载”。换句话说，你可以使一个中间件仅在以`/offensive`开头时响应。
- en: 'Here''s how that''s done:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现的：
- en: Listing 5.12 Mounting static file middleware
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.12 挂载静态文件中间件
- en: '`// …` `var photoPath = path.resolve(__dirname, "offensive-photos-folder");
    app.use("/offensive", express.static(photoPath));``// …`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `var photoPath = path.resolve(__dirname, "offensive-photos-folder");
    app.use("/offensive", express.static(photoPath));``// …`'
- en: 'Now web browsers and other clients can visit your offensive photos at a path
    other than the root. Note that this can be done for any middleware, not just the
    static file middleware. Perhaps the biggest example is the one we saw above: mounting
    Express''s routers at a prefix.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网络浏览器和其他客户端可以访问除根路径之外的其他路径上的攻击性照片。请注意，这可以应用于任何中间件，而不仅仅是静态文件中间件。最大的例子可能是我们上面看到的：在指定前缀上挂载Express的路由器。
- en: ROUTING WITH MULTIPLE STATIC FILE DIRECTORIES
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 多个静态文件目录的路由
- en: I frequently find myself with static files in multiple directories. For example,
    I sometimes have static files in a folder called "public" and another in a folder
    called "user_uploads". How can we do this with Express?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现自己有多个目录中的静态文件。例如，我有时在名为“public”的文件夹中有静态文件，在名为“user_uploads”的另一个文件夹中也有。我们如何使用Express来实现这一点？
- en: Express already solves this problem with the built-in middleware feature, and
    because express.static is middleware, we can just apply it multiple times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Express已经通过内置的中间件功能解决了这个问题，并且因为express.static是中间件，所以我们可以多次应用它。
- en: 'Here''s how we might do that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们可能如何实现它的示例：
- en: Listing 5.13 Serving static files from multiple directories
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13 从多个目录提供静态文件
- en: '`// …`   `var publicPath = path.resolve(__dirname, "public");  #A` `var userUploadsPath
    = path.resolve(__dirname, "user_uploads");`   `app.use(express.static(publicPath));
    app.use(express.static(userUploadsPath));`  `// …`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `var publicPath = path.resolve(__dirname, "public");  #A` `var userUploadsPath
    = path.resolve(__dirname, "user_uploads");` `app.use(express.static(publicPath));
    app.use(express.static(userUploadsPath));` `// …`'
- en: '#A Note that this depends on the "path" module, so make sure you require it
    before you use it!'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '# 注意，这依赖于“path”模块，所以在使用它之前请确保你已经引入了它！'
- en: 'Now, let''s quickly imagine four scenarios, and see how the above code deals
    with them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速想象四种场景，并看看上面的代码是如何处理它们的：
- en: 1.  The user requests a resource that isn't in the public folder or the user
    uploads folder. In that case, both static middleware functions will continue onto
    the next routes and middleware.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 当用户请求的资源不在公共文件夹或用户上传文件夹中时，在这种情况下，静态中间件函数将继续执行到下一个路由和中间件。
- en: 2.  The user requests a resource that's in the public folder. In that case,
    the first middleware will send the file and no following routes or middleware
    functions will be called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 当用户请求的资源在公共文件夹中时，在这种情况下，第一个中间件将发送文件，并且不会调用后续的路由或中间件函数。
- en: 3.  The user requests a resource that's in the user uploads folder, but not
    the public folder. The first middleware will continue on (it's not in "public"),
    so the second middleware will pick it up. After that, no other middleware or route
    will be called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 当用户请求的资源在用户上传文件夹中，但不在公共文件夹中时，第一个中间件将继续执行（它不在“public”中），因此第二个中间件将接手。之后，不会调用其他中间件或路由。
- en: 4.  The user requests a resource that's in both the public folder and the uploads
    folder. In this case, because the public-serving middleware is first, you'll get
    the file in "public" and you'll never be able to reach the matching file in the
    user uploads folder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 用户请求的资源同时位于公共文件夹和上传文件夹中。在这种情况下，因为公共服务中间件优先，您将获得“公共”文件夹中的文件，并且永远无法访问用户上传文件夹中匹配的文件。
- en: 'As always, you can mount middleware at different paths to avoid the issue presented
    in #4\. Here''s how you might do that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，您可以在不同的路径上安装中间件以避免第4点中提出的问题。以下是您可以这样做的方式：
- en: Listing 5.14 Serving static files from multiple directories without conflict
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.14 从多个目录中无冲突地提供静态文件
- en: '`// …`   `app.use("/public", express.static(publicPath));` `app.use("/uploads",
    express.static(userUploadsPath));`  `// …`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `app.use("/public", express.static(publicPath));` `app.use("/uploads",
    express.static(userUploadsPath));` `// …`'
- en: Now, if "image.jpg" is in both folders, you'll be able to grab it from the public
    folder at `/public/image.jpg` and from the uploads folder in `/uploads/image.jpg`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果“image.jpg”在两个文件夹中，您将能够从`/public/image.jpg`的公共文件夹中获取它，并从`/uploads/image.jpg`的上传文件夹中获取它。
- en: 5.4.2  Routing to static files
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 路由到静态文件
- en: It's possible that you'll want to send static files with a route. For example,
    you might want to send a user's profile picture if they visit `/users/123/profile_photo`.
    The static middleware has no way of knowing about this, but Express has a nice
    way of doing this, which uses a lot of the same internal mechanisms as the static
    middleware.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能您会想要通过路由发送静态文件。例如，如果您访问`/users/123/profile_photo`，您可能想发送一个用户的个人照片。静态中间件无法知道这一点，但Express有很好的方法来做这件事，它使用了与静态中间件相同的大量内部机制。
- en: 'Let''s say we want to send profile pictures when someone visits `/users/:userid/profile_photo`.
    Let''s also say that we''ve got a magic function called `getProfilePhotoPath` that
    takes a user ID and returns the path to their profile picture. Here''s how we
    might do that:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在有人访问`/users/:userid/profile_photo`时发送个人照片。假设我们有一个名为`getProfilePhotoPath`的神奇函数，它接受一个用户ID并返回其个人照片的路径。以下是我们可以这样做的方式：
- en: Listing 5.15 Sending profile pictures
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.15 发送个人照片
- en: '`app.get("/users/:userid/profile_photo", function(req, res) {` `  res.sendFile(getProfilePhotoPath(req.params.userid));``});`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/users/:userid/profile_photo", function(req, res) {` `  res.sendFile(getProfilePhotoPath(req.params.userid));``});`'
- en: In Chapter 2, we saw that this would be a big headache without Express. We'd
    have to open the file, figure out its content-type (HTML, plain text, image...),
    its file size, et cetera. Express's `sendFile` does all of this for us and lets
    you send files easily.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们看到了没有Express这将是一个大麻烦。我们不得不打开文件，找出其内容类型（HTML，纯文本，图像...），其文件大小，等等。Express的`sendFile`为我们做了所有这些，并让您轻松发送文件。
- en: You can use this to send any file you want!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它发送您想要的任何文件！
- en: 5.5     Using Express with HTTPS
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 使用Express与HTTPS
- en: As we discussed earlier in the chapter, HTTPS is HTTP's more secure sister.
    It adds a secure layer to HTTP, adding more security (although nothing is invincible).
    This secure layer is called TLS or SSL. The names are used interchangeably, but
    TLS is technically the successor to SSL.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所讨论的，HTTPS是HTTP更安全的姐妹。它为HTTP添加了一个安全层，增加了更多的安全性（尽管没有什么是不败的）。这个安全层被称为TLS或SSL。这两个名字可以互换使用，但技术上TLS是SSL的后继者。
- en: 'I won''t go into the crazy math involved, but TLS uses what''s called public-key
    cryptography. Public-key crypto works like this: every peer has a public key that
    they share with everybody and a private key that they share with nobody. If I
    want to send something to you, I encrypt the message with my private key (probably
    somewhere on my computer) and your public key (publicly available to anyone).
    I can then send you messages that look like garbage to any eavesdroppers, and
    you decrypt it with your private key and my public key. Through crazy cool math,
    we can have a secure conversation even if everyone is listening to us, and we
    never had to agree on some kind of secret code beforehand.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入涉及其中的疯狂数学，但TLS使用的是称为公钥加密的加密方式。公钥加密的工作原理是这样的：每个对等方都有一个公钥，他们与每个人分享，以及一个私钥，他们与没有人分享。如果我想给你发东西，我会用我的私钥（可能在我的电脑上某个地方）和你的公钥（对任何人公开）加密信息。然后我可以给你发送看起来像垃圾的消息，任何窃听者都无法理解，而你用你的私钥和我的公钥解密它。通过疯狂的酷数学，即使每个人都正在监听我们，我们也可以有一个安全的对话，而且我们事先根本不需要同意某种秘密代码。
- en: If this is a bit confusing, just remember that both peers have a private key
    and a public key.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这有点令人困惑，只需记住，双方都有私钥和公钥。
- en: 'In TLS, the public key also has a special property: it''s also something called
    a certificate. If I''m talking to you, you''ll present me with your certificate
    (AKA your public key), and I''ll make sure it''s actually you by making sure a
    certificate authority says "yeah, that''s you." Your browser has a list of certificate
    authorities that it trusts; companies like VeriSign and Google run these certificate
    authorities.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TLS 中，公钥还有一个特殊属性：它也是被称为证书的东西。如果我正在和你交谈，你会向我展示你的证书（即你的公钥），我会确保它是你，通过确保证书颁发机构说“是的，那是你。”你的浏览器有一个它信任的证书颁发机构列表；像
    VeriSign 和 Google 这样的公司运营这些证书颁发机构。
- en: I imagine certificate authorities as a bodyguard. When I'm talking to somebody,
    I look up at my bodyguard and say "hey, is this person who they say they are?".
    My bodyguard looks down at me and gives a small nod, or maybe a shake of the head.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我把证书颁发机构想象成一个保镖。当我与某人交谈时，我会抬头看我的保镖，说“嘿，这个人真的是他们说的那个人吗？”我的保镖低头看着我，微微点头，或者可能摇摇头。
- en: NOTE Some hosting providers like Heroku will do all the HTTPS for you so that
    you don't have to worry about it. This section is only useful if you have to do
    HTTPS yourself!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些托管提供商（如 Heroku）会为你处理所有的 HTTPS，这样你就不必担心它了。本节仅在你必须自己处理 HTTPS 时才有用！
- en: First, you'll need to generate your public and private keys. We'll use OpenSSL
    for this. If you're on Windows, grab a binary from [https://www.openssl.org/related/binaries.html](https://www.openssl.org/related/binaries.html).
    It should come preinstalled on Mac OS X. If you're on a Linux machine with a package
    manager (like Arch, Gentoo, Ubuntu, or Debian) and it's not already installed,
    install it with your OS's package manager. You can check if OpenSSL is installed
    by typing `openssl version` at your command prompt.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要生成你的公钥和私钥。我们将使用 OpenSSL 来完成这个任务。如果你使用的是 Windows 系统，可以从 [https://www.openssl.org/related/binaries.html](https://www.openssl.org/related/binaries.html)
    下载一个二进制文件。它应该预安装在 Mac OS X 上。如果你使用的是带有包管理器的 Linux 机器（如 Arch、Gentoo、Ubuntu 或 Debian），并且它尚未安装，你可以使用操作系统的包管理器来安装它。你可以在命令提示符中输入
    `openssl version` 来检查 OpenSSL 是否已安装。
- en: 'From there, we''ll run the following two commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们将运行以下两个命令：
- en: Listing 5.16 Using OpenSSL to create your private key and signing request
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 使用 OpenSSL 创建你的私钥和签名请求
- en: '`openssl genrsa -out privatekey.pem 1024   #A` `openssl req -new -key privatekey.pem
    -out request.pem  #B`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl genrsa -out privatekey.pem 1024   #A` `openssl req -new -key privatekey.pem
    -out request.pem  #B`'
- en: '#A This generates your private key into privatekey.pem.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这将生成你的私钥到 `privatekey.pem`。'
- en: '#B This generates a certificate signing request into request.pem. You''ll have
    to fill out a bunch of information.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这将生成一个签名请求到 `request.pem`。你将不得不填写一些信息。'
- en: The first command simply generates your private key; anyone can do this. The
    next command generates a certificate signing request. It'll ask you a bunch of
    information, and then spit out a file into `request.pem`. From here, you have
    to request a certificate from a certificate authority. Several groups on the Internet
    are working on Let's Encrypt, a free and automated certificate authority. You
    can check out the service at [https://letsencrypt.org/](https://letsencrypt.org/).
    If you'd prefer a different certificate authority, you can shop around online.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令简单地生成你的私钥；任何人都可以这样做。下一个命令生成一个证书签名请求。它会询问你一些信息，然后输出一个文件到 `request.pem`。从这里开始，你必须从证书颁发机构请求一个证书。互联网上有几个团体正在致力于
    Let's Encrypt，这是一个免费且自动化的证书颁发机构。你可以在 [https://letsencrypt.org/](https://letsencrypt.org/)
    查看该服务。如果你更喜欢其他证书颁发机构，你可以在网上寻找。
- en: Once they've given you a certificate, you can use Node's built-in HTTPS module
    with Express. It's very similar to the HTTP module, but you'll have to supply
    your certificate and private key.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们给你一个证书，你就可以使用 Node 内置的 HTTPS 模块与 Express 一起使用了。它与 HTTP 模块非常相似，但你必须提供你的证书和私钥。
- en: Listing 5.17 Using HTTPS with an Express app
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 使用 Express 应用程序配置 HTTPS
- en: '`var express = require("express");  #A` `var https = require("https");   #A`
    `var fs = require("fs");   #A`   `var app = express();` `// ... define your app
    ...`   `var httpsOptions = {` `   key: fs.readFileSync("path/to/private/key.pem"),  
    #B` `   cert: fs.readFileSync("path/to/certificate.pem")   #B` `};``https.createServer(httpsOptions,
    app).listen(3000);   #C`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");  #A` `var https = require("https");   #A`
    `var fs = require("fs");   #A` `var app = express();` `// ... 定义你的应用程序 ...` `var
    httpsOptions = {` `   key: fs.readFileSync("path/to/private/key.pem"),   #B` `  
    cert: fs.readFileSync("path/to/certificate.pem")   #B` `};` `https.createServer(httpsOptions,
    app).listen(3000);   #C`'
- en: '#A First, we require the modules we need.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 首先，我们引入所需的模块。'
- en: '#B After defining our application, we define an object that contains our private
    key and our certificate.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 在定义我们的应用程序之后，我们定义一个包含我们的私钥和证书的对象。'
- en: '#C Now we pass that object into https.createServer, which is otherwise just
    like the http.createServer that we''ve seen before.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 现在我们将这个对象传递给https.createServer，它与其他我们所见的http.createServer非常相似。'
- en: Other than the fact that we have to pass the private key and certificate as
    arguments, this is otherwise very similar to the http.createServer we've seen
    before.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们必须将私钥和证书作为参数传递之外，这与其他我们所见的http.createServer非常相似。
- en: If you want to run both an HTTP server and an HTTPS server, just start both!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想同时运行一个HTTP服务器和一个HTTPS服务器，只需启动它们即可！
- en: Listing 5.18 Using HTTP and HTTPS with Express
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.18 使用Express进行HTTP和HTTPS
- en: '`var express = require("express");` `var http = require("http");` `var https
    = require("https");` `var fs = require("fs");`   `var app = express();`   `//
    ... define your app ...`   `var httpsOptions = {` `  key: fs.readFileSync("path/to/private/key.pem"),`
    `  cert: fs.readFileSync("path/to/certificate.pem")` `};` `http.createServer(app).listen(80);``https.createServer(httpsOptions,
    app).listen(443)`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var http = require("http");` `var https
    = require("https");` `var fs = require("fs");` `var app = express();` `// ...
    定义你的应用程序 ...` `var httpsOptions = {` `  key: fs.readFileSync("path/to/private/key.pem"),`
    `  cert: fs.readFileSync("path/to/certificate.pem")` `};` `http.createServer(app).listen(80);`
    `https.createServer(httpsOptions, app).listen(443)`'
- en: All we have to do is run both servers on different ports, and we're done! That's
    HTTPS.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在不同的端口上运行两个服务器，然后就可以完成了！这就是HTTPS。
- en: '5.6     Putting it all together: a simple routing demo'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6     整合所有内容：一个简单的路由演示
- en: Let's take what we've learned and build a simple web application that returns
    the temperature by your United States ZIP code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用所学知识构建一个简单的Web应用程序，该应用程序可以根据您的美国ZIP代码返回温度。
- en: NOTE I'm an American, so this example will use the US-style postal code, called
    a ZIP code. ZIP codes are five digits long and can give you a pretty good ballpark
    location. There are 42,522 of them, so if the US is 3.7 million square miles,
    each ZIP code covers about 87 square miles on average. Because we're going to
    use ZIP codes, this example will only work in the United States. It shouldn't
    be too much of a stretch to make a similar application that works elsewhere (if
    you're inspired, you could try using the HTML5 Geolocation API!).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 我是一个美国人，所以这个例子将使用美国风格的邮政编码，称为ZIP代码。ZIP代码是五位数字，可以给出相当好的大致位置。共有42,522个，所以如果美国是370万平方英里，每个ZIP代码平均覆盖约87平方英里。因为我们将使用ZIP代码，所以这个例子将仅适用于美国。制作一个在其他地方也能工作的类似应用程序（如果你有灵感，可以尝试使用HTML5地理位置API！）。
- en: 'Our application will basically have two parts:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将基本分为两部分：
- en: 1.  A static homepage that asks the user for their ZIP code. After the user
    types it in, it will load the weather via an asynchronous JavaScript request (also
    known as an AJAX request).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  一个静态主页，要求用户输入他们的ZIP代码。用户输入后，将通过异步JavaScript请求（也称为AJAX请求）加载天气。
- en: 2.  Because we're using JavaScript, we'll send the temperature as JSON. We'll
    define a route for `/12345` which will return the weather at ZIP code 12345.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  因为我们使用JavaScript，所以我们将以JSON格式发送温度。我们将为`/12345`定义一个路由，该路由将返回ZIP代码12345的天气。
- en: Let's get started.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 5.6.1  Getting set up
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.1  准备工作
- en: 'For this application, we''ll use four Node packages: Express (obviously), ForecastIO
    (for grabbing weather data from the free API called Forecast.io), Zippity-do-dah
    (for turning ZIP codes into latitude/longitude pairs), and EJS (for rendering
    HTML views). (These are some pretty good names, right? Especially "zippity-do-dah".)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将使用四个Node包：Express（显然）、ForecastIO（用于从名为Forecast.io的免费API获取天气数据）、Zippity-do-dah（用于将ZIP代码转换为经纬度对），以及EJS（用于渲染HTML视图）。（这些名字相当不错，对吧？特别是“zippity-do-dah”。）
- en: 'Make a new Express application. You''ll want to make sure the `package.json` looks
    something like this when it''s time to start:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Express应用程序。你想要确保在启动时`package.json`看起来像这样：
- en: Listing 5.19 package.json for this application
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.19 此应用程序的package.json
- en: '`{` `  "name": "temperature-by-zip",` `  "private": true,` `  "scripts": {`
    `    "start": "node app.js"` `  },` `  "dependencies": {` `    "ejs": "^2.3.1",`
    `    "express": "^4.12.4",` `    "forecastio": "^0.2.0",` `    "zippity-do-dah":
    "0.0.x"` `  }``}`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "temperature-by-zip",` `  "private": true,` `  "scripts": {`
    `    "start": "node app.js"` `  },` `  "dependencies": {` `    "ejs": "^2.3.1",`
    `  "express": "^4.12.4",` `  "forecastio": "^0.2.0",` `  "zippity-do-dah": "0.0.x"`
    `  }``}`'
- en: Make sure you have all of these dependencies installed by running `npm install` in
    your application's directory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经通过在应用程序目录中运行 `npm install` 安装了所有这些依赖项。
- en: On the client, we'll depend on jQuery and a minimal CSS framework called Pure
    (more information at [http://purecss.io/](http://purecss.io/)). It's likely that
    you already know about jQuery, but Pure is a bit more obscure (though most everything
    is more obscure than jQuery). Pure gives us a little bit of styling for text and
    forms, similar to Twitter's Bootstrap. The difference with Pure is that it's far
    lighter-weight, which better suits this kind of application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们将依赖于 jQuery 和一个名为 Pure 的最小化 CSS 框架（更多信息请访问 [http://purecss.io/](http://purecss.io/)）。你很可能已经了解
    jQuery，但 Pure 稍微有点神秘（尽管几乎所有东西都比 jQuery 神秘）。Pure 为文本和表单提供了一些样式，类似于 Twitter 的 Bootstrap。与
    Pure 的区别在于它更轻量级，更适合这种类型的应用。
- en: 'Make two directories: one called `public` and one called `views`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个目录：一个名为 `public`，另一个名为 `views`。
- en: Next, we'll need to get an API key from Forecast.io. Visit their developers
    URL at [https://developers.forecast.io](https://developers.forecast.io)). Register
    for an account. At bottom of the dashboard page is your API key, which is a string
    of 32 characters. You'll need to copy this API key into your code in just a moment,
    so make sure you have it ready.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从 Forecast.io 获取一个 API 密钥。访问他们的开发者网址 [https://developers.forecast.io](https://developers.forecast.io)。注册一个账户。在仪表板页面的底部是你的
    API 密钥，它是一个由 32 个字符组成的字符串。你很快就需要将这个 API 密钥复制到你的代码中，所以请确保你已经准备好了。
- en: We're ready to get started!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始工作了！
- en: 5.6.2  The main app code
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.2 主要应用程序代码
- en: Now that we're all set up, it's time to code! Let's start with the main application
    JavaScript. If you followed the example at the end of Chapter 2, this business
    should be pretty familiar.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，是时候开始编码了！让我们从主应用程序 JavaScript 开始。如果你遵循了第 2 章末尾的示例，这个业务应该很熟悉。
- en: 'Create `app.js` and put this inside:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app.js` 并将以下内容放入其中：
- en: Listing 5.20 app.js
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.20 app.js
- en: '`var path = require("path");  #A` `var express = require("express");  #A` `var
    zipdb = require("zippity-do-dah");  #A` `var ForecastIo = require("forecastio"); 
    #A`   `var app = express();  #B` `var weather = new ForecastIo("YOUR FORECAST.IO
    API KEY HERE");  #C`   `app.use(express.static(path.resolve(__dirname, "public"))); 
    #D`   `app.set("views", path.resolve(__dirname, "views"));  #E` `app.set("view
    engine", "ejs");  #E`   `app.get("/", function(req, res) { #F` `  res.render("index"); `
    `}); `   `app.get(/^\/(\d{5})$/, function(req, res, next) { ` `  var zipcode =
    req.params[0];  #G` `  var location = zipdb.zipcode(zipcode); #H` `  if (!location.zipcode)
    {#I` `    next(); #I` `    return;` `  }`   `  var latitude = location.latitude;`
    `  var longitude = location.longitude;`   `  weather.forecast(latitude, longitude,
    function(err, data) {` `    if (err) {` `      next();` `      return;` `    }`
      `    res.json({ #J` `      zipcode: zipcode,` `      temperature: data.currently.temperature`
    `    });` `  });` `});`   `app.use(function(req, res) { #K` `  res.status(404).render("404");`
    `});``app.listen(3000);  #L`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`var path = require("path");  #A` `var express = require("express");  #A` `var
    zipdb = require("zippity-do-dah");  #A` `var ForecastIo = require("forecastio"); 
    #A` `var app = express();  #B` `var weather = new ForecastIo("YOUR FORECAST.IO
    API KEY HERE");  #C` `app.use(express.static(path.resolve(__dirname, "public"))); 
    #D` `app.set("views", path.resolve(__dirname, "views"));  #E` `app.set("view engine",
    "ejs");  #E` `app.get("/", function(req, res) { #F ` res.render("index"); ` });
    ` `}); ` `app.get(/^\/(\d{5})$/, function(req, res, next) { ` ` var zipcode =
    req.params[0];  #G ` var location = zipdb.zipcode(zipcode); #H ` if (!location.zipcode)
    {#I ` next(); #I ` return; ` } ` var latitude = location.latitude; ` var longitude
    = location.longitude; ` weather.forecast(latitude, longitude, function(err, data)
    { ` if (err) { ` next(); ` return; ` } ` res.json({ #J ` zipcode: zipcode, ` temperature:
    data.currently.temperature ` }); ` }); ` }); ` `app.use(function(req, res) { #K
    ` res.status(404).render("404"); ` }); ` `app.listen(3000);  #L`'
- en: '#A  We start by including Node''s built-in path module, Express, zippity-do-dah,
    and ForecastIO. Nothing too different than what we''ve seen before!'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们首先引入 Node 的内置路径模块、Express、zippity-do-dah 和 ForecastIO。与之前看到的不同之处不多！'
- en: '#B Create a new Express application.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 创建一个新的 Express 应用程序。'
- en: '#C Create a new ForecastIO object with your API key. Make sure to fill this
    in!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 使用你的 API 密钥创建一个新的 ForecastIO 对象。确保填写完整！'
- en: '#D Serve static files out of "public" with Express''s built-in static file
    middleware.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 使用 Express 内置的静态文件中间件，从 "public" 目录中提供静态文件。'
- en: '#E Use EJS as our view engine, and serve the views out of a folder called "views".'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 使用 EJS 作为我们的视图引擎，并将视图从名为 "views" 的文件夹中提供。'
- en: '#F Render the "index" view if we hit the homepage.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#F 如果我们访问主页，则渲染 "index" 视图。'
- en: '#G This is an example of Express''s regular expression routing feature. Regular
    expressions are always nasty to read, but this one basically says "give me five
    numbers". The parenthesis "capture" the specified ZIP code and pass it as req.params[0].'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#G 这是一个 Express 的正则表达式路由功能的例子。正则表达式总是很难阅读，但这个基本上是说“给我五个数字”。括号“捕获”指定的 ZIP 码并将其作为
    req.params[0] 传递。'
- en: '#H Use zippity-do-dah to grab location data with the ZIP code.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#H 使用 zippity-do-dah 通过 ZIP 码获取位置数据。'
- en: '#I zippity-do-dah just returns an empty object ({}) when no results are found.
    This probes the object for a zipcode property, and if we''re missing it, then
    this won''t work, and we should continue on.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#I zippity-do-dah 在没有找到结果时仅返回一个空对象 ({})。这会检查对象中的 zipcode 属性，如果我们缺少它，那么这不会工作，我们应该继续。'
- en: '#J We''ll send this JSON object with Express''s convenient json method.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#J 我们将使用 Express 的便捷 json 方法发送此 JSON 对象。'
- en: '#K If we miss the static files middleware, miss the handler for the root URL
    (/), and miss the weather URL, then show a 404 error.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#K 如果我们遗漏了静态文件中间件、根 URL (/) 的处理器以及天气 URL，那么将显示 404 错误。'
- en: '#L Start the app on port 3000!'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#L 在端口 3000 上启动应用程序！'
- en: Now we need to fill in the client. This means making some views with EJS, and
    as we'll see, we'll add a splash of CSS and a bit of client-side JavaScript.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要填写客户端。这意味着制作一些带有 EJS 的视图，正如我们将看到的，我们将添加一些 CSS 和一些客户端 JavaScript。
- en: 5.6.3  The two views
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.3 两个视图
- en: There are two views in this application; the 404 page and the homepage. We want
    our site to look consistent across pages, so let's make a template. We'll need
    to make a header and a footer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序中有两个视图；404 页面和主页。我们希望网站在各个页面之间看起来保持一致，所以让我们创建一个模板。我们需要创建一个页眉和一个页脚。
- en: 'Let''s start with the header. Save the following into a file called header.ejs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从页眉开始。将以下内容保存到名为 header.ejs 的文件中：
- en: Listing 5.21 views/header.ejs
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.21 视图/header.ejs
- en: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `  <title>Temperature
    by ZIP code</title>` `  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">`
    `  <link rel="stylesheet" href="/main.css">` `</head>``<body>`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `  <title>ZIP
    码温度</title>` `  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">`
    `  <link rel="stylesheet" href="/main.css">` `</head>``<body>`'
- en: 'Next, let''s close off the page in footer.ejs:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 footer.ejs 中关闭页面：
- en: Listing 5.22 views/footer.ejs
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.22 视图/footer.ejs
- en: '`</body>` `</html>`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`</body>` `</html>`'
- en: 'Now that we have our template, let''s fill in the simple 404 page (as 404.ejs):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模板，让我们填写简单的 404 页面（作为 404.ejs）：
- en: Listing 5.23 views/404.ejs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 视图/404.ejs
- en: '`<% include header %>` `  <h1>404 error! File not found.</h1>``<% include footer
    %>`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include header %>` `  <h1>404 错误！文件未找到。</h1>``<% include footer %>`'
- en: The index homepage isn't too complex, either. Save this sucker as index.ejs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 索引主页也不太复杂。将这个家伙保存为 index.ejs。
- en: Listing 5.24 views/index.ejs
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.24 视图/index.ejs
- en: '`<% include header %>`   `<h1>What''s your ZIP code?</h1>`   `<form class="pure-form">`
    `  <fieldset>` `    <input type="number" name="zip" placeholder="12345"[CA]` `   
    autofocus required>` `    <input type="submit" class="pure-button[CA]` `    pure-button-primary"
    value="Go">` `  </fieldset>` `</form>`   `<script src="//ajax.googleapis.com/ajax/libs/[CA/]`
    `jquery/2.1.1/jquery.min.js"></script>` `<script src="/main.js"></script>`  `<%
    include footer %>`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include header %>`   `<h1>你的 ZIP 码是多少？</h1>`   `<form class="pure-form">`
    `  <fieldset>` `    <input type="number" name="zip" placeholder="12345"[CA]` `   
    autofocus required>` `    <input type="submit" class="pure-button[CA]` `    pure-button-primary"
    value="去">` `  </fieldset>` `</form>`   `<script src="//ajax.googleapis.com/ajax/libs/[CA/]`
    `jquery/2.1.1/jquery.min.js"></script>` `<script src="/main.js"></script>`  `<%
    include footer %>`'
- en: There are a couple of references to the Pure CSS framework in the index code;
    all they do is apply some styling so our page looks a little better.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 index 代码中有一两个对 Pure CSS 框架的引用；它们所做的只是应用一些样式，使我们的页面看起来更好一些。
- en: 'Speaking of styling, we''ll need to fill in main.css that we specified in the
    layout. Save the following into `public/main.css`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到样式，我们需要填写我们在布局中指定的 main.css。以下内容保存到 `public/main.css`：
- en: Listing 5.25 public/main.css
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.25 public/main.css
- en: '`html {` `  display: table;` `  width: 100%;` `  height: 100%;` `}` `body {`
    `  display: table-cell;` `  vertical-align: middle;` `  text-align: center;``}`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`html {` `  display: table;` `  width: 100%;` `  height: 100%;` `}` `body {`
    `  display: table-cell;` `  vertical-align: middle;` `  text-align: center;``}`'
- en: This CSS effectively centers all the page's content, both horizontally and vertically.
    This isn't a CSS book, so don't worry if you don't understand exactly what's going
    on in the above.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 CSS 有效地使页面的所有内容在水平和垂直方向上居中。这不是一本 CSS 书，所以如果你不明白上面发生的事情，请不要担心。
- en: Now we have everything other than our client-side JavaScript! You can try to `npm
    start` this app right now. You should be able to see the homepage at `http://localhost:3000`,
    the      404 page at`http://localhost:3000/some/garbage/url`, and the weather
    should load 12345's temperature as JSON at `http://localhost:3000/12345`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了除了客户端JavaScript之外的一切！您现在就可以尝试使用`npm start`启动此应用程序。您应该能够在`http://localhost:3000`看到主页，在`http://localhost:3000/some/garbage/url`看到404页面，并且天气应该会在`http://localhost:3000/12345`以JSON格式加载12345的温度。
- en: Let's finish it off with our client-side JavaScript.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用客户端JavaScript来完成它。
- en: 'Save this stuff in `public/main.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容保存到`public/main.js`：
- en: Listing 5.26 public/main.js
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.26 public/main.js
- en: '`$(function() {`   `  var $h1 = $("h1");` `  var $zip = $("input[name=''zip'']");`
      `  $("form").on("submit", function(event) {`   `    event.preventDefault(); 
    #A`   `    var zipCode = $.trim($zip.val());` `    $h1.text("Loading...");`  
    `    var request = $.ajax({   #B` `      url: "/" + zipCode,` `      dataType:
    "json"` `    });` `    request.done(function(data) {     #C` `      var temperature
    = data.temperature;` `      $h1.text("It is " + temperature + "&#176; in " + zipCode
    + "."); #D` `    });` `    request.fail(function() {    #E` `      $h1.text("Error!");`
    `    });`   `  });`  `});`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(function() {`   `  var $h1 = $("h1");` `  var $zip = $("input[name=''zip'']");`
      `  $("form").on("submit", function(event) {`   `    event.preventDefault(); 
    #A`   `    var zipCode = $.trim($zip.val());` `    $h1.text("Loading...");`  
    `    var request = $.ajax({   #B` `      url: "/" + zipCode,` `      dataType:
    "json"` `    });` `    request.done(function(data) {     #C` `      var temperature
    = data.temperature;` `      $h1.text("It is " + temperature + "&#176; in " + zipCode
    + "."); #D` `    });` `    request.fail(function() {    #E` `      $h1.text("Error!");`
    `    });`   `  });`  `});`'
- en: '#A  We don''t want the form doing what HTML would normally make it do -- we
    want to drive!'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们不希望表单执行HTML通常会执行的操作——我们想要控制！'
- en: '#B  We spin off an AJAX request. If we''ve typed "12345" into the ZIP code
    field, we''ll be visiting /12345 to do this request.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 我们发起一个AJAX请求。如果我们已经在ZIP代码字段中输入了"12345"，我们将访问/12345来执行此请求。'
- en: '#C When the request succeeds, we''ll update the header with the current temperature.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 当请求成功时，我们将更新标题为当前温度。'
- en: '#D &#176; is the HTML character code for the ° degree symbol.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#D °是HTML字符代码，用于表示°符号。'
- en: '#E If there''s an error (either on the client or the server), make sure that
    an error is shown.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 如果发生错误（无论是客户端还是服务器），请确保显示错误。'
- en: 5.6.4  The application in action
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.4 应用程序的实际应用
- en: With that, you can start the application with `npm start`. Visit `http://localhost:3000`,
    type in a ZIP code, and watch the temperature appear!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您可以使用`npm start`启动应用程序。访问`http://localhost:3000`，输入一个ZIP代码，并观察温度的出现！
- en: '![](../Images/05_01.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_01.png)'
- en: Figure 5.1 Temperature by ZIP code in action
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 ZIP代码的温度实际应用
- en: That's our simple application! It takes advantage of Express's helpful routing
    features, serves HTML views, JSON, and static files.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的简单应用程序！它利用了Express的有用路由功能，提供HTML视图、JSON和静态文件。
- en: If you'd like, you can extend this application to work with more than just United
    States ZIP codes, or show more than just the temperature, or add API documentation,
    or add better error handling, or maybe more!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以扩展此应用程序以支持不仅仅是美国ZIP代码，或者显示不仅仅是温度，或者添加API文档，或者添加更好的错误处理，或者也许更多！
- en: 5.7     Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7     总结
- en: 'In this chapter, you saw:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了：
- en: '·  What routing is at a conceptual level: a mapping of a URL to a piece of
    code'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ·  在概念层面上，路由是什么：将URL映射到一段代码
- en: ·  Simple routing, pattern-matching routing, and more
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ·  简单路由、模式匹配路由以及更多
- en: ·  Grabbing parameters from routes
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ·  从路由中获取参数
- en: ·  Using Express 4's new routers feature
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用Express 4的新路由器功能
- en: ·  Using middleware with routing
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用具有路由功能的中间件
- en: ·  Serving static files with `express.static`, Express's built-in static file
    middleware
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用`express.static`服务静态文件，这是Express内置的静态文件中间件
- en: ·  How to use Express with Node's built-in HTTPS module
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用Express与Node的内置HTTPS模块
