- en: 3 Basic data management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 基本数据管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Manipulating dates and missing values
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作日期和缺失值
- en: Understanding data type conversions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据类型转换
- en: Creating and recoding variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和重新编码变量
- en: Sorting, merging, and subsetting datasets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序、合并和子集数据集
- en: Selecting and dropping variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择和删除变量
- en: In chapter 2, we covered various methods for importing data into R. Unfortunately,
    getting your data in the rectangular arrangement of a matrix or data frame is
    only the first step in preparing it for analysis. To paraphrase Captain Kirk in
    the *Star Trek* episode “A Taste of Armageddon” (and proving my geekiness once
    and for all), “Data is a messy business—a very, very messy business.” In my own
    work, as much as 60% of any data analysis project is spent cleaning and organizing
    the data. I’ll go out on a limb and say that the same is probably true for most
    real-world data analysts. Let’s take a look at an example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们介绍了将数据导入R的各种方法。不幸的是，将数据以矩阵或数据框的矩形排列形式准备好，只是分析准备的第一步。为了引用《星际迷航》中“末日审判的滋味”一集中队长柯克的台词（并最终证明我的极客身份），“数据是一团糟——非常非常糟糕的一团糟。”在我的工作中，任何数据分析项目60%的时间都花在清理和组织数据上。我敢打赌，大多数现实世界的数据分析师也是如此。让我们来看一个例子。
- en: 3.1 A working example
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 一个工作示例
- en: One of the topics that I study in my current job is how men and women differ
    in the ways they lead their organizations. Typical questions might be
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前在工作中研究的一个主题是男性和女性在领导组织的方式上存在哪些差异。典型的问题可能包括
- en: Do men and women in management positions differ in the degree to which they
    defer to superiors?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理职位上的男性和女性在向上级让步的程度上是否存在差异？
- en: Does this vary from country to country, or are these gender differences universal?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是否因国家而异，还是这些性别差异是普遍存在的？
- en: One way to address these questions is to have bosses in multiple countries rate
    their managers on deferential behavior, using questions like the following.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法之一是让多个国家的上司使用以下问题对他们的经理的顺从行为进行评分。
- en: '| This manager asks my opinion before making personnel decisions. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 这位经理在做出人事决策之前会征求我的意见。|'
- en: '| 1 | 2 | 3 | 4 | 5 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 3 | 4 | 5 |'
- en: '| strongly disagree | disagree | neither agree nor disagree | agree | strongly
    agree |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 强烈不同意 | 不同意 | 既不同意也不反对 | 同意 | 强烈同意 |'
- en: The resulting data might resemble that in table 3.1\. Each row represents the
    ratings given to a manager by their boss.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据可能类似于表3.1中的数据。每一行代表上司对经理给出的评分。
- en: Table 3.1 Gender differences in leadership behavior
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 领导行为中的性别差异
- en: '| Manager | Date | Country | Gender | Age | q1 | q2 | q3 | q4 | q5 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 经理 | 日期 | 国家 | 性别 | 年龄 | q1 | q2 | q3 | q4 | q5 |'
- en: '| 1 | 10/24/14 | US | M | 32 | 5 | 4 | 5 | 5 | 5 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 10/24/14 | US | M | 32 | 5 | 4 | 5 | 5 | 5 |'
- en: '| 2 | 10/28/14 | US | F | 45 | 3 | 5 | 2 | 5 | 5 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 10/28/14 | US | F | 45 | 3 | 5 | 2 | 5 | 5 |'
- en: '| 3 | 10/01/14 | US | F | 25 | 3 | 5 | 5 | 5 | 2 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 10/01/14 | US | F | 25 | 3 | 5 | 5 | 5 | 2 |'
- en: '| 4 | 10/12/14 | US | M | 39 | 3 | 3 | 4 |  |  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10/12/14 | US | M | 39 | 3 | 3 | 4 |  |  |'
- en: '| 5 | 05/01/14 | US | F | 99 | 2 | 2 | 1 | 2 | 1 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 05/01/14 | US | F | 99 | 2 | 2 | 1 | 2 | 1 |'
- en: Here, each manager is rated by their boss on five statements (q1 to q5) related
    to deference to authority. For example, manager 1 is a 32-year-old male working
    in the US and is rated as deferential by his boss, whereas manager 5 is a female
    of unknown age (99 probably indicates that the information is missing) working
    in the UK and is rated low on deferential behavior. The Date column captures when
    the ratings were made.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每位经理根据与其相关的五个陈述（q1至q5）对其权威的顺从程度进行评分。例如，经理1是一位32岁的男性，在美国工作，并被其上司评价为顺从，而经理5是一位年龄不详的女性（99可能表示信息缺失），在英国工作，并在顺从行为上得分较低。日期列捕捉了评分的时间。
- en: Although a dataset might have dozens of variables and thousands of observations,
    I’ve included only 10 columns and 5 rows to simplify the examples. Additionally,
    I’ve limited the number of items pertaining to the managers’ deferential behavior
    to 5\. In a real-world study, you’d probably use 10 to 20 such items to improve
    the reliability and validity of the results. You can create a data frame containing
    the data in table 3.1 using the following code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据集可能有数十个变量和数千个观测值，但我只包括了10列和5行来简化示例。此外，我还将涉及经理顺从行为的条目限制为5个。在现实世界的研究中，你可能会使用10到20个这样的条目来提高结果的可靠性和有效性。你可以使用以下代码创建包含表3.1中数据的数据框。
- en: Listing 3.1 Creating the leadership data frame
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 创建领导数据框
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To address the questions of interest, you must first deal with several data
    management issues. Here’s a partial list:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决感兴趣的问题，你必须首先处理几个数据管理问题。以下是一个部分列表：
- en: The five ratings (q1 to q5) need to be combined, yielding a single mean deferential
    score from each manager.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五个评分（q1到q5）需要合并，从而从每个经理那里得到一个单一的均值差异分数。
- en: In surveys, respondents often skip questions. For example, the boss rating manager
    4 skipped questions 4 and 5\. You need a method of handling incomplete data. You
    also need to recode values like 99 for age to *missing*.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调查中，受访者经常跳过问题。例如，老板对经理的4分评价跳过了问题4和5。你需要一种处理不完整数据的方法。你还需要将像99这样的年龄值重新编码为*缺失*。
- en: There may be hundreds of variables in a dataset, but you may only be interested
    in a few. To simplify matters, you’ll want to create a new dataset with only the
    variables of interest.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集中可能有数百个变量，但你可能只对其中几个感兴趣。为了简化问题，你将想要创建一个只包含感兴趣变量的新数据集。
- en: Past research suggests that leadership behavior may change as a function of
    the manager’s age. To examine this, you may want to recode the current values
    of age into a new categorical age grouping (for example, young, middle-aged, elderly).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去的研究表明，领导行为可能会随着管理者年龄的变化而变化。为了检验这一点，你可能想将当前年龄值重新编码到一个新的年龄分类中（例如，年轻、中年、老年）。
- en: Leadership behavior may change over time. You might want to focus on deferential
    behavior during the recent global financial crisis. To do so, you may want to
    limit the study to data gathered during a specific period of time (say, January
    1, 2009, to December 31, 2009).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领导行为可能会随时间而改变。你可能想专注于最近全球金融危机期间的差异行为。为此，你可能想将研究限制在特定时间段收集的数据（例如，2009年1月1日至2009年12月31日）。
- en: We’ll work through each of these issues in this chapter, as well as other basic
    data management tasks such as combining and sorting datasets. Then, in chapter
    5, we’ll look at some advanced topics.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中逐一解决这些问题，以及其他基本的数据管理任务，例如合并和排序数据集。然后，在第5章中，我们将探讨一些高级主题。
- en: 3.2 Creating new variables
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 创建新变量
- en: 'In a typical research project, you’ll need to create new variables and transform
    existing ones. This is accomplished with statements of the form:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的研究项目中，你需要创建新变量和转换现有变量。这是通过以下形式的语句完成的：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A wide array of operators and functions can be included in the `expression`
    portion of the statement. Table 3.2 lists R’s arithmetic operators.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在语句的`expression`部分包含各种运算符和函数。表3.2列出了R的算术运算符。
- en: Table 3.2 Arithmetic operators
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 算术运算符
- en: '| Operator | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| `+` | Addition |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 |'
- en: '| `-` | Subtraction |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法 |'
- en: '| `*` | Multiplication |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 |'
- en: '| `/` | Division |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 |'
- en: '| `^` or `**` | Exponentiation |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `^`或`**` | 幂运算 |'
- en: '| `x%%y` | Modulus (x mod y): for example, `5%%2` is `1` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `x%%y` | 模数（x mod y）：例如，`5%%2`是`1` |'
- en: '| `x%/%y` | Integer division: for example, `5%/%2` is `2` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `x%/%y` | 整数除法：例如，`5%/%2`是`2` |'
- en: Given the data frame `leadership`, say you want to create a new variable `total_
    score` that adds the variables q1 to q5 and a new variable called `mean_score`
    that averages these variables. If you use the code
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给定数据框`leadership`，假设你想创建一个新变量`total_score`，它将变量q1到q5相加，并创建一个名为`mean_score`的新变量，该变量平均这些变量。如果你使用以下代码
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: you’ll get an error, because R doesn’t know that `q1`, `q2`, `q3`, `q4,` and
    `q5` are from the data frame `leadership`. If you use this code instead
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个错误，因为R不知道`q1`、`q2`、`q3`、`q4`和`q5`是从数据框`leadership`中来的。如果你使用下面的代码代替
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: the statements will succeed, but you’ll end up with a data frame (`leadership`)
    and two separate vectors (`total_score` and `mean_score`). This probably isn’t
    the result you want. Ultimately, you want to incorporate new variables into the
    original data frame. The following listing provides two separate ways to accomplish
    this goal. The one you choose is up to you; the results will be the same.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句将成功，但你最终会得到一个数据框（`leadership`）和两个单独的向量（`total_score`和`mean_score`）。这可能不是你想要的结果。最终，你想要将新变量纳入原始数据框中。以下列表提供了两种实现这一目标的方法。你可以选择其中一种；结果将是相同的。
- en: Listing 3.2 Creating new variables
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 创建新变量
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Personally, I prefer the second method, exemplified by the use of the `transform()`
    function. It simplifies the inclusion of as many new variables as you want and
    saves the results to the data frame.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢第二种方法，即使用`transform()`函数的例子。它简化了包含尽可能多的新变量，并将结果保存到数据框中。
- en: 3.3 Recoding variables
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 重新编码变量
- en: '`Recoding` involves creating new values of a variable conditional on the existing
    values of the same and/or other variables. For example, you may want to'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`重新编码`涉及根据同一变量和/或其他变量的现有值创建变量的新值。例如，你可能想要'
- en: Change a continuous variable into a set of categories
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连续变量转换为一系列类别
- en: Replace miscoded values with correct values
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误编码的值替换为正确值
- en: Create a pass/fail variable based on a set of cutoff scores
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据一组截止分数创建通过/失败变量
- en: To recode data, you can use one or more of R’s logical operators (see table
    3.3). Logical operators are expressions that return `TRUE` or `FALSE`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新编码数据，你可以使用一个或多个 R 的逻辑运算符（见表 3.3）。逻辑运算符是返回 `TRUE` 或 `FALSE` 的表达式。
- en: Table 3.3 Logical operators
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3 逻辑运算符
- en: '| Operator | Description |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| `<` | Less than |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `<=` | Less than or equal to |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: '| `>` | Greater than |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `>=` | Greater than or equal to |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: '| `==` | Exactly equal to |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 精确等于 |'
- en: '| `!=` | Not equal to |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `!x` | Not `x` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `!x` | 非 `x` |'
- en: '| `x &#124; y` | `x` or `y` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `x | y` | `x` 或 `y` |'
- en: '| `x & y` | `x` and `y` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `x & y` | `x` 和 `y` |'
- en: '| `isTRUE(x)` | Tests whether `x` is `TRUE` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `isTRUE(x)` | 测试 `x` 是否为 `TRUE` |'
- en: Let’s say you want to recode the ages of the managers in the leadership dataset
    from the continuous variable `age` to the categorical variable `agecat` (`Young`,
    `Middle Aged`, `Elder`). First, you must recode the value `99` for `age` to indicate
    that the value is missing using code such as
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将领导数据集中管理员的年龄从连续变量 `age` 重新编码为分类变量 `agecat`（`Young`，`Middle Aged`，`Elder`）。首先，你必须将
    `age` 的值 `99` 重新编码，以表示该值缺失，可以使用如下代码
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The statement `variable[condition]` `<-` `expression` will only make the assignment
    when `condition` is `TRUE`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 `variable[condition] <- expression` 只有在 `condition` 为 `TRUE` 时才会进行赋值。
- en: 'Once missing values for `age` have been specified, you can then use the following
    code to create the `agecat` variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了 `age` 的缺失值，然后你可以使用以下代码创建 `agecat` 变量：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You include the data frame names in `leadership$agecat` to ensure that the new
    variable is saved back to the data frame. (I defined middle-aged as 55 to 75 so
    I won’t feel so old.) Note that if you hadn’t recoded 99 as *missing* for `age`
    first, manager 5 would’ve erroneously been given the value “Elder” for `agecat`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `leadership$agecat` 中包含数据框名称，以确保新变量被保存回数据框。 （我将中年定义为 55 至 75，这样我就不会觉得那么老了。）请注意，如果你没有首先将
    99 重新编码为 `age` 的 *缺失*，经理 5 就会被错误地赋予 `agecat` 的值“Elder”。
- en: This code can be written more compactly as
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以更紧凑地写成
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `within()` function is similar to the `with()` function (section 2.2.4),
    but it allows you to modify the data frame. First, the variable `agecat` is created
    and set to missing for each row of the data frame. Then, the remaining statements
    within the braces are executed in order. Remember that `agecat` is a character
    variable; you’re likely to want to turn it into an ordered factor, as explained
    in section 2.2.5.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`within()` 函数与 `with()` 函数（第 2.2.4 节）类似，但它允许你修改数据框。首先，创建变量 `agecat` 并将其设置为数据框每一行的缺失值。然后，执行花括号内的剩余语句。记住，`agecat`
    是一个字符变量；你很可能想要将其转换为有序因子，如第 2.2.5 节所述。'
- en: Several packages offer useful recoding functions; in particular, the `car` package’s
    `recode()` function recodes numeric and character vectors and factors very simply.
    The package `doBy` offers `recodeVar()`, another popular function. Finally, R
    ships with `cut()`, which allows you to divide the range of a numeric variable
    into intervals, returning a factor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 几个包提供了有用的重新编码函数；特别是，`car` 包的 `recode()` 函数可以非常简单地重新编码数值和字符向量以及因子。`doBy` 包提供了
    `recodeVar()`，另一个流行的函数。最后，R 内置了 `cut()` 函数，它允许你将数值变量的范围划分为区间，并返回一个因子。
- en: 3.4 Renaming variables
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 重命名变量
- en: 'If you’re not happy with your variable names, you can change them interactively
    or programmatically. Let’s say you want to change the variable `manager` to `managerID`
    and `date` to `testDate`. You can use the following statement to invoke an interactive
    editor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己的变量名不满意，你可以交互式地或以编程方式更改它们。假设你想要将变量 `manager` 改为 `managerID`，将 `date` 改为
    `testDate`。你可以使用以下语句调用交互式编辑器：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then you click the variable names and rename them in the dialogs that are presented
    (see figure 3.1).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你点击变量名，并在显示的对话框中重命名它们（见图 3.1）。
- en: '![](Images/CH03_F01_Kabacoff3.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F01_Kabacoff3.png)'
- en: Figure 3.1 Renaming variables interactively using the `fix()` function
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 使用 `fix()` 函数交互式重命名变量
- en: Programmatically, you can rename variables via the `names()` function. For example,
    the statement
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程方式，您可以通过 `names()` 函数重命名变量。例如，以下语句
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'renames `date` to `testDate` as demonstrated in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，将 `date` 重命名为 `testDate`：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In a similar fashion, the statement
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，以下语句
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: renames q1 through q5 to item1 through item5.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将 q1 到 q5 重命名为 item1 到 item5。
- en: 3.5 Missing values
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 缺失值
- en: In a project of any size, data is likely to be incomplete because of missed
    questions, faulty equipment, or improperly coded data. In R, missing values are
    represented by the symbol `NA` (not available). Unlike programs such as SAS, R
    uses the same missing-value symbol for character and numeric data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何规模的项目中，由于漏题、设备故障或数据编码不当，数据很可能会不完整。在 R 中，缺失值用符号 `NA`（不可用）表示。与 SAS 等程序不同，R
    使用相同的缺失值符号来表示字符和数值数据。
- en: 'R provides a number of functions for identifying observations that contain
    missing values. The function `is.na()` allows you to test for the presence of
    missing values. Assume that you have this vector:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了多个函数用于识别包含缺失值的观测值。函数 `is.na()` 允许您测试是否存在缺失值。假设您有如下向量：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then the following function returns `c(FALSE, FALSE, FALSE, TRUE):`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以下函数返回 `c(FALSE, FALSE, FALSE, TRUE)`：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the `is.na()` function works on an object. It returns an object of
    the same size, with the entries replaced by `TRUE` if the element is a missing
    value or `FALSE` if the element isn’t a missing value. The following listing applies
    this to the leadership example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `is.na()` 函数在对象上的工作方式。它返回一个大小相同的对象，如果元素是缺失值，则条目被替换为 `TRUE`，如果元素不是缺失值，则条目被替换为
    `FALSE`。以下列表将此应用于领导力示例。
- en: Listing 3.3 Applying the `is.na()` function
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 应用 `is.na()` 函数
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `leadership[,6:10]` limits the data frame to columns 6 to 10, and `is.na()`
    identifies which values are missing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`leadership[,6:10]` 限制了数据框到第 6 到 10 列，而 `is.na()` 识别了哪些值是缺失的。
- en: You need to keep two important things in mind when you’re working with missing
    values in R. First, missing values are considered noncomparable, even to themselves.
    This means you can’t use comparison operators to test for the presence of missing
    values. For example, the logical test `myvar` `==` `NA` is never `TRUE`. Instead,
    you have to use missing-value functions like `is.na()` to identify the missing
    values in R data objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 R 中处理缺失值时，需要记住两个重要的事情。首先，缺失值被认为是不可比较的，即使是与自身比较。这意味着您不能使用比较运算符来测试缺失值的存在。例如，逻辑测试
    `myvar` `==` `NA` 永远不会返回 `TRUE`。相反，您必须使用缺失值函数（如 `is.na()`）来识别 R 数据对象中的缺失值。
- en: Second, R doesn’t represent infinite or impossible values as missing values.
    Again, this is different than the way other programs like SAS handle such data.
    Positive and negative infinity are represented by the symbols `Inf` and `–Inf`,
    respectively. Thus, `5/0` returns `Inf`. Impossible values (for example, `sin(Inf)`)
    are represented by the symbol `NaN` (not a number). To identify these values,
    you need to use `is .infinite()` or `is.nan()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，R 不将无限或不可能的值表示为缺失值。这与其他程序（如 SAS）处理此类数据的方式不同。正无穷和负无穷分别用符号 `Inf` 和 `–Inf` 表示。因此，`5/0`
    返回 `Inf`。不可能的值（例如，`sin(Inf)`）用符号 `NaN`（非数字）表示。要识别这些值，您需要使用 `is .infinite()` 或
    `is.nan()`。
- en: 3.5.1 Recoding values to missing
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 将值重新编码为缺失
- en: 'As we saw in section 3.3, you can use assignments to recode values to *missing*.
    In the leadership example, missing `age` values are coded as 99\. Before analyzing
    this dataset, you must let R know that the value `99` means *missing* in this
    case—otherwise, the mean age for this sample of bosses will be way off. You can
    accomplish this by recoding the variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 3.3 节中看到的，您可以使用赋值来将值重新编码为 *缺失*。在领导力示例中，缺失的 `age` 值被编码为 99。在分析此数据集之前，您必须让
    R 知道在这种情况下值 `99` 代表 *缺失*——否则，这个老板样本的平均年龄将会偏差很大。您可以通过重新编码变量来完成此操作：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Any value of age that’s equal to `99` is changed to `NA`. Be sure that any missing
    data is properly coded as missing before you analyze the data, or the results
    will be meaningless.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 任何等于 `99` 的年龄值都更改为 `NA`。在分析数据之前，请确保任何缺失数据都正确编码为缺失值，否则结果将没有意义。
- en: 3.5.2 Excluding missing values from analyses
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 从分析中排除缺失值
- en: 'Once you’ve identified missing values, you need to eliminate them in some way
    before analyzing your data further. The reason is that arithmetic expressions
    and functions that contain missing values yield missing values. For example, consider
    this code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了缺失值，在进一步分析数据之前，你需要以某种方式消除它们。原因是包含缺失值的算术表达式和函数会产生缺失值。例如，考虑以下代码：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both `y` and `z` will be `NA` (missing) because the third element of `x` is
    missing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`x`的第三个元素缺失，`y`和`z`都将为`NA`（缺失）。
- en: 'Luckily, most numeric functions have an `na.rm=TRUE` option that removes missing
    values prior to calculations and applies the function to the remaining values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数数值函数都有一个`na.rm=TRUE`选项，该选项在计算之前删除缺失值，并将函数应用于剩余的值：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `y` is equal to 6.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`y`等于6。
- en: When using a function with incomplete data, be sure to check how that function
    handles missing data by looking at its online help (for example, `help(sum)`).
    The `sum()` function is only one of many functions we’ll consider in chapter 5\.
    Functions allow you to transform data with flexibility and ease.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用包含不完整数据的函数时，务必通过查看其在线帮助（例如，`help(sum)`）来检查该函数如何处理缺失数据。`sum()`函数是我们将在第5章考虑的许多函数之一。函数允许你以灵活和简便的方式转换数据。
- en: You can remove any observation with missing data by using the `na.omit()` function,
    which deletes any rows with missing data. Let’s apply this to the leadership dataset
    in the following listing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`na.omit()`函数删除任何包含缺失数据的观测值，该函数会删除任何包含缺失数据的行。让我们在下面的列表中将此应用于领导力数据集。
- en: Listing 3.4 Using `na.omit()` to delete incomplete observations
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 使用`na.omit()`删除不完整观测值
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Data frame with missing data
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含缺失数据的数据框
- en: ❷ Data frame with complete cases only
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅包含完整案例的数据框
- en: Any rows containing missing data are deleted from leadership before the results
    are saved to `newdata`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在将结果保存到`newdata`之前，任何包含缺失数据的行都会从领导力数据集中删除。
- en: Deleting all observations with missing data (called *listwise deletion*) is
    one of several methods of handling incomplete datasets. If only a few values are
    missing or they’re concentrated in a small number of observations, listwise deletion
    can provide a good solution to the missing-values problem. But if missing values
    are spread throughout the data or a great deal of data are missing in a small
    number of variables, listwise deletion can exclude a substantial percentage of
    your data. We’ll explore several more sophisticated methods of dealing with missing
    values in chapter 18\. Next, let’s look at dates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 删除所有包含缺失数据的观测值（称为*列表删除*）是处理不完整数据集的几种方法之一。如果只有少数值缺失，或者它们集中在少数观测值中，列表删除可以提供解决缺失值问题的良好解决方案。但如果缺失值分布在整个数据中，或者少数变量中有大量数据缺失，列表删除可能会排除大量数据。我们将在第18章中探讨处理缺失值的几种更复杂的方法。接下来，让我们看看日期。
- en: 3.6 Date values
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 日期值
- en: Dates are typically entered into R as character strings and then translated
    into date variables that are stored numerically. The function `as.Date()` is used
    to make this translation. The syntax is a`s.Date(x,` `"input_format")`, where
    `x` is the character data and `input_format` gives the appropriate format for
    reading the date (see table 3.4).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 日期通常以字符字符串的形式输入到R中，然后转换为存储为数值的日期变量。`as.Date()`函数用于进行这种转换。语法是`as.Date(x, "input_format")`，其中`x`是字符数据，`input_format`给出了读取日期的适当格式（见表3.4）。
- en: Table 3.4 Date formats
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4 日期格式
- en: '| Symbol | Meaning | Example |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 示例 |'
- en: '| `%d` | Day as a number (0–31) | 01–31 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 日期作为数字（0–31） | 01–31 |'
- en: '| `%a``%A` | Abbreviated weekdayUnabbreviated weekday | MonMonday |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `%a` `%A` | 简写星期非简写星期 | MonMonday |'
- en: '| `%m` | Month (01–12) | 01–12 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `%m` | 月份（01–12） | 01–12 |'
- en: '| `%b``%B` | Abbreviated monthUnabbreviated month | JanJanuary |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `%b` `%B` | 简写月份非简写月份 | JanJanuary |'
- en: '| `%y``%Y` | Two-digit yearFour-digit year | 072007 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `%y` `%Y` | 两位数年份四位数字年份 | 072007 |'
- en: The default format for inputting dates is yyyy-mm-dd. The statement
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输入日期的默认格式是yyyy-mm-dd。以下语句
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: converts the character data to dates using this default format. In contrast,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此默认格式将字符数据转换为日期。相比之下，
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: reads the data using a mm/dd/yyyy format.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mm/dd/yyyy格式读取数据。
- en: In the leadership dataset, date is coded as a character variable in mm/dd/yy
    format. Therefore
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在领导力数据集中，日期以mm/dd/yy格式编码为字符变量。因此
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: uses the specified format to read the character variable and replace it in the
    data frame as a date variable. Once the variable is in date format, you can analyze
    and plot the dates using the wide range of analytic techniques covered in later
    chapters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指定的格式读取字符变量并将其替换为数据帧中的日期变量。一旦变量以日期格式存在，你就可以使用后面章节中涵盖的广泛分析技术来分析和绘制日期。
- en: Two functions are especially useful for time-stamping data. `Sys.Date()` returns
    today’s date, and `date()` returns the current date and time. As I write this,
    it’s July 7, 2021, at 6:43 p.m. Executing those functions produces
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数特别适用于时间戳数据。`Sys.Date()`返回今天的日期，而`date()`返回当前的日期和时间。在我写这篇文章的时候，是2021年7月7日晚上6:43。执行这些函数会产生
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can use the `format(x, format="output_format")` function to output dates
    in a specified format and to extract portions of dates:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`format(x, format="output_format")`函数以指定格式输出日期并提取日期的部分：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `format()` function takes an argument (a date, in this case) and applies
    an output format (in this case, assembled from the symbols in table 3.4). The
    important result here is that there are only two more days until the weekend!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`函数接受一个参数（在这种情况下是一个日期）并应用一个输出格式（在这种情况下，由表3.4中的符号组成）。这里的重要结果是，距离周末只剩两天了！'
- en: When R stores dates internally, they’re represented as the number of days since
    January 1, 1970, with negative values for earlier dates. That means you can perform
    arithmetic operations on them. For example,
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当R内部存储日期时，它们被表示为自1970年1月1日起的天数，较早的日期使用负值。这意味着你可以对它们进行算术运算。例如，
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: displays the number of days between February 13, 2020, and January 22, 2021.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了2020年2月13日和2021年1月22日之间的天数。
- en: 'Finally, you can also use the function `difftime()` to calculate a time interval
    and express it as seconds, minutes, hours, days, or weeks. Let’s assume that I
    was born on October 12, 1956\. How old am I?:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以使用`difftime()`函数来计算时间间隔，并以秒、分钟、小时、天或周的形式表示。假设我是在1956年10月12日出生的。我多大了？：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Apparently, I am 3,380 weeks old. Who knew? Extra credit: On which day of the
    week was I born?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我已经3,380周大了。谁知道呢？额外加分：我是在星期几出生的？
- en: 3.6.1 Converting dates to character variables
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 将日期转换为字符变量
- en: 'You can also convert date variables to character variables. Date values can
    be converted to character values using the `as.character()` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将日期变量转换为字符变量。可以使用`as.character()`函数将日期值转换为字符值：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The conversion allows you to apply a range of character functions to the data
    values (subsetting, replacement, concatenation, and so on). We’ll cover character
    functions in detail in section 5.2.4.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换允许你将一系列字符函数应用于数据值（子集、替换、连接等）。我们将在第5.2.4节中详细讨论字符函数。
- en: 3.6.2 Going further
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 进一步学习
- en: To learn more about converting character data to dates, look at `help(as.Date)`
    and `help(strftime)`. To learn more about formatting dates and times, see `help(ISOdatetime)`.
    The `lubridate` package contains a number of functions that simplify working with
    dates, including functions to identify and parse date-time data, extract date-time
    components (for example, years, months, days, hours, and minutes), and perform
    arithmetic calculations on date-times. If you need to do complex calculations
    with dates, the `timeDate` package can also help. It provides a myriad of functions
    for dealing with dates, can handle multiple time zones at once, and provides sophisticated
    calendar manipulations that recognize business days, weekends, and holidays.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于将字符数据转换为日期的信息，请查看`help(as.Date)`和`help(strftime)`。要了解更多关于日期和时间的格式化信息，请参阅`help(ISOdatetime)`。`lubridate`包包含许多简化日期处理的函数，包括用于识别和解析日期时间数据、提取日期时间组件（例如，年、月、日、小时和分钟）以及在对日期时间进行算术计算。如果你需要使用日期进行复杂计算，`timeDate`包也可以提供帮助。它提供了一系列处理日期的函数，可以同时处理多个时区，并提供复杂的日历操作，识别工作日、周末和假日。
- en: 3.7 Type conversions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 类型转换
- en: We just discussed how to convert character data to date values and vice versa.
    R provides a set of functions to identify an object’s data type and convert it
    to a different data type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了如何将字符数据转换为日期值以及相反的操作。R提供了一套函数来识别对象的数据类型并将其转换为不同的数据类型。
- en: Type conversions in R work similarly to those in other statistical programming
    languages. For example, adding a character string to a numeric vector converts
    all the elements in the vector to character values. You can use the functions
    listed in table 3.5 to test for a data type and convert it to a given type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的类型转换与其他统计编程语言中的转换类似。例如，将字符字符串添加到数值向量会将向量中的所有元素转换为字符值。你可以使用表 3.5 中列出的函数来测试数据类型并将其转换为给定类型。
- en: Table 3.5 Type-conversion functions
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.5 类型转换函数
- en: '| Test | Convert |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 转换 |'
- en: '| `is.numeric()` | `as.numeric``()` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `is.numeric()` | `as.numeric()` |'
- en: '| `is.character()` | `as.character``()` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `is.character()` | `as.character()` |'
- en: '| `is.vector()` | `as.vector``()` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `is.vector()` | `as.vector()` |'
- en: '| `is.matrix()` | `as.matrix``()` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `is.matrix()` | `as.matrix()` |'
- en: '| `is.data.frame()` | `as.data.frame``()` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `is.data.frame()` | `as.data.frame()` |'
- en: '| `is.factor()` | `as.factor``()` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `is.factor()` | `as.factor()` |'
- en: '| `is.logical()` | `as.logical``()` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `is.logical()` | `as.logical()` |'
- en: Functions of the form `is.datatype()` return `TRUE` or `FALSE`, whereas `as.datatype()`
    converts the argument to that type. The following listing provides an example.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 `is.datatype()` 的函数返回 `TRUE` 或 `FALSE`，而 `as.datatype()` 将参数转换为该类型。以下列表提供了一个示例。
- en: Listing 3.5 Converting from one data type to another
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 从一种数据类型转换为另一种数据类型
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When combined with the flow controls (such as `if-then`) that we’ll discuss
    in chapter 5, the `is.datatype()` function can be a powerful tool, allowing you
    to handle data in different ways depending on its type. Additionally, some R functions
    require data of a specific type (character or numeric, matrix or data frame),
    and `as.datatype()` lets you transform your data into the format required prior
    to analyses.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当与第 5 章中将要讨论的流程控制（如 `if-then`）结合使用时，`is.datatype()` 函数可以成为一个强大的工具，允许你根据数据类型以不同的方式处理数据。此外，一些
    R 函数需要特定类型的数据（字符或数值、矩阵或数据框），而 `as.datatype()` 允许你在分析之前将数据转换为所需的格式。
- en: 3.8 Sorting data
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 排序数据
- en: Sometimes, viewing a dataset in a sorted order can tell you quite a bit about
    the data. For example, which managers are most deferential? To sort a data frame
    in R, you use the `order()` function. By default, the sorting order is ascending.
    Prepend the sorting variable with a minus sign to indicate descending order. The
    following examples illustrate sorting with the leadership data frame.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，以排序顺序查看数据集可以告诉你很多关于数据的信息。例如，哪些经理最谦逊？在 R 中，你使用 `order()` 函数对数据框进行排序。默认情况下，排序顺序是升序。在排序变量前加一个负号以表示降序。以下示例说明了使用领导数据框进行排序。
- en: The statement
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 语句
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: creates a new dataset containing rows sorted from youngest manager to oldest
    manager. The statement
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的数据集，其中包含按经理年龄从年轻到老排序的行。语句
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: sorts the rows into female followed by male and youngest to oldest within each
    gender.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将行按女性排序，然后在每个性别内按年龄从年轻到老排序。
- en: Finally,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: sorts the rows by gender, and then from oldest to youngest manager within each
    gender.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按性别排序行，然后在每个性别内按年龄从老到少排序经理。
- en: 3.9 Merging datasets
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 合并数据集
- en: If your data exists in multiple locations, you’ll need to combine it before
    moving forward. This section shows you how to add columns (variables) and rows
    (observations) to a data frame.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据存在于多个位置，在继续之前你需要将其合并。本节将向你展示如何向数据框添加列（变量）和行（观测值）。
- en: 3.9.1 Adding columns to a data frame
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.1 向数据框添加列
- en: To merge two data frames (datasets) horizontally, you use the `merge()` function.
    In most cases, two data frames are joined by one or more common key variables
    (that is, an inner join). For example,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要水平合并两个数据框（数据集），你使用 `merge()` 函数。在大多数情况下，两个数据框通过一个或多个公共键变量（即内部连接）连接。例如，
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: merges `dataframeA` and `dataframeB` by ID. Similarly,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 ID 合并 `dataframeA` 和 `dataframeB`。同样，
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: merges the two data frames by `ID` and `Country`. Horizontal joins like this
    are typically used to add variables to a data frame.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `ID` 和 `Country` 合并两个数据框。这种类型的水平连接通常用于向数据框添加变量。
- en: Horizontal concatenation with cbind()
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cbind() 进行水平连接
- en: 'If you’re joining two matrices or data frames horizontally and don’t need to
    specify a common key, you can use the `cbind()` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你水平连接两个矩阵或数据框，并且不需要指定公共键，你可以使用 `cbind()` 函数：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function horizontally concatenates objects `A` and `B`. For the function
    to work properly, each object must have the same number of rows and must be sorted
    in the same order.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数水平连接对象 `A` 和 `B`。为了使函数正常工作，每个对象必须具有相同数量的行，并且必须按相同的顺序排序。
- en: 3.9.2 Adding rows to a data frame
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.2 向数据框添加行
- en: 'To join two data frames (datasets) vertically, use the `rbind()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要垂直连接两个数据框（数据集），请使用`rbind()`函数：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The two data frames must have the same variables, but they don’t have to be
    in the same order. If `dataframeA` has variables that `dataframeB` doesn’t, then
    before joining them, do one of the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数据框必须具有相同的变量，但它们不必按相同的顺序排列。如果`dataframeA`有`dataframeB`没有的变量，那么在连接它们之前，你可以执行以下操作之一：
- en: Delete the extra variables in `dataframeA`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`dataframeA`中的额外变量。
- en: Create the additional variables in `dataframeB` and set them to `NA` (missing).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`dataframeB`中创建额外的变量并将它们设置为`NA`（缺失）。
- en: Vertical concatenation is typically used to add observations to a data frame.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直连接通常用于向数据框中添加观测值。
- en: 3.10 Subsetting datasets
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 子集数据集
- en: R has powerful indexing features for accessing the elements of an object. These
    features can be used to select and exclude variables, observations, or both. The
    following sections demonstrate several methods for keeping or deleting variables
    and observations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: R具有强大的索引功能，用于访问对象的元素。这些功能可以用来选择和排除变量、观测值或两者。以下几节将演示几种保留或删除变量和观测值的方法。
- en: 3.10.1 Selecting variables
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.1 选择变量
- en: It’s common to create a new dataset from a limited number of variables chosen
    from a larger dataset. Chapter 2 showed that the elements of a data frame are
    accessed using the notation `dataframe[row` `indices,` `column` `indices]`. You
    can use this to select variables. For example,
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从较大的数据集中选择有限数量的变量来创建新的数据集是很常见的。第二章展示了数据框的元素是通过使用表示法`dataframe[row indices, column
    indices]`来访问的。你可以使用这个表示法来选择变量。例如，
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: selects variables `q1`, `q2`, `q3`, `q4`, and q5 from the leadership data frame
    and saves them to the data frame `newdata`. Leaving the row indices blank `(,)`
    selects all the rows by default.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从领导数据框中选择变量`q1`、`q2`、`q3`、`q4`和`q5`，并将它们保存到数据框`newdata`中。留空行索引（`()`）默认选择所有行。
- en: The statements
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: accomplish the same variable selection. Here, variable names (in quotes) are
    entered as column indices, thereby selecting the same columns.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同的变量选择。在这里，变量名（用引号括起来）作为列索引输入，从而选择相同的列。
- en: If only one set of indices is provided for a data frame, R assumes that you
    are subsetting the columns. In the following statement, the comma is assumed
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为数据框提供了一个索引集，R假定你正在子集化列。在以下语句中，逗号被假定为
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: and subsets the same set of variables.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 并对相同的变量集进行子集化。
- en: Finally, you could use
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This example uses the `paste()` function to create the same character vector
    as in the previous example. The `paste()` function will be covered in chapter
    5.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`paste()`函数创建与上一个示例相同的字符向量。`paste()`函数将在第五章中介绍。
- en: 3.10.2 Dropping variables
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.2 删除变量
- en: There are many reasons to exclude variables. For example, if a variable has
    many missing values, you may want to drop it prior to further analyses. Let’s
    look at some methods of excluding variables.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因需要排除变量。例如，如果一个变量有很多缺失值，你可能在进一步分析之前想要删除它。让我们看看一些排除变量的方法。
- en: 'You can exclude variables `q3` and `q4` with these statements:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语句排除变量`q3`和`q4`：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To understand why this works, you need to break it down:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这样做有效，你需要将其分解：
- en: '`names(leadership)` produces a character vector containing the variable names:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`names(leadership)`生成一个包含变量名的字符向量：'
- en: '[PRE40]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`names(leadership)%in%` `c("q3",` `"q4")` returns a logical vector with `TRUE`
    for each element in `names(leadership)` that matches `q3` or `q4` and `FALSE`
    otherwise:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`names(leadership)%in%c("q3", "q4")`返回一个逻辑向量，对于`names(leadership)`中与`q3`或`q4`匹配的每个元素返回`TRUE`，否则返回`FALSE`：'
- en: '[PRE41]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The not (`!`) operator reverses the logical values:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非（`!`）运算符反转逻辑值：
- en: '[PRE42]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`leadership[c(TRUE,` `TRUE,` `TRUE,` `TRUE,` `TRUE,` `TRUE,` `TRUE,` `FALSE,
    FALSE,` `TRUE)]` selects columns with `TRUE` logical values, so `q3` and `q4`
    are excluded.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`leadership[c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)]`选择具有`TRUE`逻辑值的列，因此排除了`q3`和`q4`。'
- en: 'Knowing that `q3` and `q4` are the eighth and ninth variables, you can exclude
    them with the following statement:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 知道`q3`和`q4`是第八和第九个变量，你可以使用以下语句来排除它们：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This works because prepending a column index with a minus sign (-) excludes
    that column.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为在列索引前加上负号（-）可以排除该列。
- en: Finally, the same deletion can be accomplished via
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，同样的删除操作可以通过以下方式完成：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here you set columns `q3` and `q4` to undefined (`NULL`). Note that `NULL` isn’t
    the same as `NA` (missing).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将列`q3`和`q4`设置为未定义的（`NULL`）。请注意，`NULL`与`NA`（缺失）不同。
- en: Dropping variables is the converse of keeping variables. The choice depends
    on which is easier to code. If there are many variables to drop, it may be easier
    to keep the ones that remain, or vice versa.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 删除变量是保留变量的逆过程。选择哪种方式取决于哪种方式更容易编码。如果有许多变量需要删除，可能更容易保留剩下的变量，反之亦然。
- en: 3.10.3 Selecting observations
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.3 选择观测值
- en: Selecting or excluding observations (rows) is typically a key aspect of successful
    data preparation and analysis. Several examples are given in the following listing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 选择或排除观测值（行）通常是成功数据准备和分析的关键方面。以下列表中给出了几个示例。
- en: Listing 3.6 Selecting observations
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 选择观测值
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Asks for rows 1 through 3 (the first three observations)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 询问第 1 至 3 行（前三个观测值）
- en: ❸ Selects all men over 30
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择所有 30 岁以上的男性
- en: 'Each of these examples provides the row indices and leaves the column indices
    blank (therefore choosing all columns). Let’s break down the line of code at ❷
    to understand it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的每一个都提供了行索引，并留出列索引空白（因此选择所有列）。让我们分析 ❷ 中的代码行来理解它：
- en: The logical comparison `leadership$gender=="M"` produces the vector `c(TRUE,`
    `FALSE,` `FALSE,` `TRUE,` `FALSE)`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑比较 `leadership$gender=="M"` 产生向量 `c(TRUE, FALSE, FALSE, TRUE, FALSE)`。
- en: The logical comparison `leadership$age > 30` produces the vector `c(TRUE, TRUE,`
    `FALSE,` `TRUE,` `TRUE)`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑比较 `leadership$age > 30` 产生向量 `c(TRUE, TRUE, FALSE, TRUE, TRUE)`。
- en: The logical comparison `c(TRUE,` `FALSE,` `FALSE,` `TRUE,` `FALSE)` `&` `c(TRUE,
    TRUE,` `FALSE,` `TRUE,` `TRUE)` produces the vector `c(TRUE,` `FALSE,` `FALSE,
    TRUE,` `FALSE)`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑比较 `c(TRUE, FALSE, FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE, TRUE, TRUE)`
    产生向量 `c(TRUE, FALSE, FALSE, TRUE, FALSE)`。
- en: '`leadership[c(TRUE,` `FALSE,` `FALSE,` `TRUE,` `FALSE),]` selects the first
    and fourth observations from the data frame (when the row index is `TRUE`, the
    row is included; when it’s `FALSE`, the row is excluded). This meets the selection
    criteria (men over 30).'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`leadership[c(TRUE, FALSE, FALSE, TRUE, FALSE),]` 从数据框中选择第一个和第四个观测值（当行索引为 `TRUE`
    时，行被包含；当它是 `FALSE` 时，行被排除）。这符合选择标准（30岁以上的男性）。'
- en: 'At the beginning of this chapter, I suggested that you might want to limit
    your analyses to observations collected between January 1, 2009, and December
    31, 2009\. How can you do this? Here’s one solution:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我建议您可能希望将您的分析限制在 2009 年 1 月 1 日至 2009 年 12 月 31 日期间收集的观测值。您如何做到这一点？这里有一个解决方案：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Converts the date values read in originally as character values to date values
    using the format mm/dd/yy
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将最初以字符值读入的日期值转换为日期值，格式为 mm/dd/yy
- en: ❷ Creates starting date
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建起始日期
- en: ❸ Creates ending date
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建结束日期
- en: ❹ Selects cases meeting your desired criteria, as in the previous example
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 选择符合您所需标准的情况，如前一个示例所示
- en: Note that the default for the `as.Date()` function is yyyy-mm-dd, so you don’t
    have to supply it here.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`as.Date()` 函数的默认格式是 yyyy-mm-dd，因此您在这里不需要提供它。
- en: 3.10.4 The subset() function
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.4 subset() 函数
- en: The examples in the previous two sections are important because they help describe
    the ways in which logical vectors and comparison operators are interpreted in
    R. Understanding how these examples work will help you interpret R code in general.
    Now that you’ve done things the hard way, let’s look at a shortcut.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例中的例子很重要，因为它们有助于描述在 R 中逻辑向量和比较运算符是如何被解释的。理解这些例子的工作方式将有助于您一般地解释 R 代码。既然您已经用困难的方式完成了这些事情，让我们看看一种捷径。
- en: 'The `subset()` function is probably the easiest way to select variables and
    observations. Here are two examples:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: subset() 函数可能是选择变量和观测值的最简单方法。以下有两个示例：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Selects all rows that have a value of age greater than or equal to 35 or less
    than 23\. Keeps variables q1 through q4.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 选择所有年龄大于或等于 35 或小于 23 的行。保留变量 q1 至 q4。
- en: ❷ Selects all men over the age of 25, and keeps variables gender through q4
    (gender, q4, and all columns between them).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 选择所有 25 岁以上的男性，并保留变量 gender 通过 q4（gender、q4 以及它们之间的所有列）。
- en: You saw the colon operator used to generate a sequence of numbers in chapter
    2\. In the subset function, `from:to` returns all variables in a data frame between
    the `from` variable and the `to` variable, inclusive.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您在第二章中看到了冒号运算符用于生成数字序列。在 subset 函数中，`from:to` 返回数据框中 `from` 变量和 `to` 变量之间的所有变量，包括这两个变量。
- en: 3.10.5 Random samples
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.5 随机样本
- en: Sampling from larger datasets is common in data mining and machine learning.
    For example, you may want to select two random samples, creating a predictive
    model from one and validating its effectiveness on the other. The `sample()` function
    enables you to take a random sample (with or without replacement) of size `n`
    from a dataset.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据挖掘和机器学习中，从更大的数据集中进行抽样是很常见的。例如，你可能想要选择两个随机样本，从一个样本中创建预测模型，并在另一个样本上验证其有效性。`sample()`
    函数允许你从一个数据集中随机抽取大小为 `n` 的样本（带或不带替换）。
- en: 'You could take a random sample of size 3 from the leadership dataset using
    the following statement:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语句从领导数据集中随机抽取大小为 3 的样本：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first argument to `sample()` is a vector of elements to choose from. Here,
    the vector is 1 to the number of observations in the data frame. The second argument
    is the number of elements to be selected, and the third argument indicates sampling
    without replacement. `sample()` returns the randomly sampled elements, which are
    then used to select rows from the data frame.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()` 的第一个参数是从中选择元素的向量。在这里，向量是从 1 到数据框中观测值的数量。第二个参数是要选择的元素数量，第三个参数表示不进行替换的抽样。`sample()`
    返回随机抽取的元素，然后用于从数据框中选择行。'
- en: R has extensive facilities for sampling, including drawing and calibrating survey
    samples (see the `sampling` package) and analyzing complex survey data (see the
    `survey` package). Other methods that rely on sampling, including bootstrapping
    and resampling statistics, are described in chapter 12.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了广泛的抽样功能，包括绘制和校准调查样本（参见 `sampling` 包）以及分析复杂的调查数据（参见 `survey` 包）。第 12 章描述了依赖于抽样的其他方法，包括自助法和重抽样统计。
- en: 3.11 Using dplyr to manipulate data frames
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.11 使用 dplyr 操作数据框
- en: So far, we’ve manipulated R data frames using base R functions. The `dplyr`
    package provides a series of shortcuts that allow you to complete the same data
    management tasks in a streamlined fashion. It is rapidly becoming one of the most
    popular R packages for data management.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用基础 R 函数操作了 R 数据框。`dplyr` 包提供了一系列快捷方式，允许你以简化的方式完成相同的数据管理任务。它正迅速成为最受欢迎的
    R 数据管理包之一。
- en: 3.11.1 Basic dplyr functions
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11.1 基本dplyr函数
- en: The `dplyr` package provides a set of functions that can be used to select variables
    and observations, transform variables, rename variables, and sort rows. Table
    3.6 lists the relevant functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 包提供了一组函数，可用于选择变量和观测值、转换变量、重命名变量以及排序行。表 3.6 列出了相关函数。'
- en: Table 3.6 `dplyr` functions for manipulating data frames
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.6 `dplyr` 用于操作数据框的函数
- en: '| Function | Use |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 用途 |'
- en: '| `select()` | Select variables/columns |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `select()` | 选择变量/列 |'
- en: '| `filter()` | Select observations/rows |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `filter()` | 选择观测值/行 |'
- en: '| `mutate()` | Transform or recode variables |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `mutate()` | 转换或重新编码变量 |'
- en: '| `rename()` | Rename variables/columns |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `rename()` | 重命名变量/列 |'
- en: '| `recode()` | Recode variable values |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `recode()` | 重新编码变量值 |'
- en: '| `arrange()` | Order rows by variable values |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `arrange()` | 按变量值排序行 |'
- en: Let’s return to the data frame created in table 3.1 and reproduced in table
    3.7 for convenience.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到表 3.1 中创建的数据框，并在表 3.7 中重现以方便起见。
- en: Table 3.7 Gender differences in leadership behavior
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.7 领导行为中的性别差异
- en: '| Manager | Date | Country | Gender | Age | q1 | q2 | q3 | q4 | q5 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 经理 | 日期 | 国家 | 性别 | 年龄 | q1 | q2 | q3 | q4 | q5 |'
- en: '| 1 | 10/24/14 | US | M | 32 | 5 | 4 | 5 | 5 | 5 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 10/24/14 | 美国 | M | 32 | 5 | 4 | 5 | 5 | 5 |'
- en: '| 2 | 10/28/14 | US | F | 45 | 3 | 5 | 2 | 5 | 5 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 10/28/14 | 美国 | F | 45 | 3 | 5 | 2 | 5 | 5 |'
- en: '| 3 | 10/01/14 | UK | F | 25 | 3 | 5 | 5 | 5 | 2 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 10/01/14 | 英国 | F | 25 | 3 | 5 | 5 | 5 | 2 |'
- en: '| 4 | 10/12/14 | UK | M | 39 | 3 | 3 | 4 |  |  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10/12/14 | 英国 | M | 39 | 3 | 3 | 4 |  |  |'
- en: '| 5 | 05/01/14 | UK | F | 99 | 2 | 2 | 1 | 2 | 1 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 05/01/14 | 英国 | F | 99 | 2 | 2 | 1 | 2 | 1 |'
- en: This time, we’ll use `dplyr` functions to manipulate the dataset. The code is
    provided in listing 3.7\. Since `dplyr` is not part of base R, install it (`install.packages("dplyr")`)
    first.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用 `dplyr` 函数来操作数据集。代码在列表 3.7 中提供。由于 `dplyr` 不是 R 基础包的一部分，首先需要安装它（`install.packages("dplyr")`）。
- en: Listing 3.7 Manipulating data with `dplyr`
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 使用 `dplyr` 操作数据
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Load the dplyr package.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载 dplyr 包。
- en: ❷ Create two summary variables.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建两个汇总变量。
- en: ❸ Recode M and F to male and female.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 M 和 F 重新编码为男性和女性。
- en: ❹ Rename the manager and gender variables.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 重命名经理和性别变量。
- en: ❺ Sort the data by sex and then total score within sex.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 按性别排序数据，然后在性别内按总分排序。
- en: ❻ Create a new data frame containing the rating variables.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 创建包含评分变量的新数据框。
- en: ❼ Create a new data frame containing males with total scores above 10.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 创建一个新的数据框，包含总分超过 10 的男性。
- en: First, the `dplyr` package is loaded. Then `mutate()` function is used to create
    a total score and mean score. The format is
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，加载 `dplyr` 包。然后使用 `mutate()` 函数创建总分和平均分。格式是
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The new variables are added to the data frame.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 新变量被添加到数据框中。
- en: Next, the `recode()` function is used to modify the values of the `gender` variable.
    The format is
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `recode()` 函数修改 `gender` 变量的值。格式是
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Vector values that are not given new values are left unchanged. For example,
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 没有给定新值的向量值保持不变。例如，
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For numeric values, use backticks to quote the original values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值，使用反引号来引用原始值：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, use the `rename()` function to change the variable names. The format is
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `rename()` 函数更改变量名。格式是
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The data are then sorted using the `arrange()` function. First, the rows are
    sorted in ascending order by `sex` (females followed by males). Next, the rows
    are sorted in ascending order by `total_score` (low scores to high scores) separately
    within each sex group. The `desc()` function is used to reverse the order of the
    sorting. For example,
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `arrange()` 函数对数据进行排序。首先，按 `sex` 升序排序行（女性随后是男性）。接下来，在每组性别内按 `total_score`
    升序排序行（低分到高分）。使用 `desc()` 函数来反转排序顺序。例如，
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: would sort the data in ascending order by `sex` and in descending order (high
    to low `total_scores`) within each sex.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将按 `sex` 升序排序数据，并在每个性别内按降序（高分到低分 `total_scores`）排序。
- en: The `select` statement is used to select or exclude variables. In this case,
    the variables `ID` and `mean_score` are selected.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 语句用于选择或排除变量。在这种情况下，选择了变量 `ID` 和 `mean_score`。'
- en: The format for the `select()` function is
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 函数的格式是'
- en: '[PRE56]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Variable lists are typically variable names without quotes. The colon operator
    (:) can be used to select a range of variables. Additionally, functions can be
    used to select variables containing specific text strings. For example, the statement
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 变量列表通常是变量名，不带引号。可以使用冒号运算符（:）来选择变量范围。此外，可以使用函数来选择包含特定文本字符串的变量。例如，以下语句
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: would select the variables `ID`, `country`, `sex`, `age`, `q1`, `q2`, `q3`,
    `q4` and `q5`. See `help(select_helpers)` for a list of functions that can be
    used to aid in the selection of variables.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将选择变量 `ID`、`country`、`sex`、`age`、`q1`、`q2`、`q3`、`q4` 和 `q5`。有关可用于辅助变量选择的函数列表，请参阅
    `help(select_helpers)`。
- en: A minus sign (`-`) is used to exclude variables. The statement
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用负号（`-`）来排除变量。该语句
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: would include all variables *except* `sex` and `age`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 会包括所有变量，**除了** `sex` 和 `age`。
- en: Finally, the `filter()` function is used to select the observations or rows
    in a data frame meeting a given set of criteria. Here, men with total scores greater
    than 10 are retained. The format is
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `filter()` 函数选择满足给定一组标准的数据框中的观测值或行。在这里，保留总分大于 10 的男性。格式是
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: and rows are retained if the expression is `TRUE`. Any of the logical operators
    in table 3.3 can be used, and parentheses can be used to clarify the precedence
    of these operators. For example,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式为 `TRUE`，则保留行。可以使用表 3.3 中的任何逻辑运算符，并且可以使用括号来澄清这些运算符的优先级。例如，
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: would create a data frame containing all male managers with mean scores below
    2 or above 4.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个包含所有平均分低于 2 或高于 4 的男性经理的数据框。
- en: 3.11.2 Using pipe operators to chain statements
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11.2 使用管道运算符链式调用语句
- en: 'The `dplyr` package allows you to write code in a compact format using the
    pipe operator (`%>%`) provided by the `magrittr` package. Consider the following
    three statements:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 包允许您使用 `magrittr` 包提供的管道运算符（`%>%`）以紧凑的格式编写代码。考虑以下三个语句：'
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'These statements can be rewritten as a single statement using the pipe operator:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句可以使用管道运算符重写为单个语句：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `%>%` operator (pronounced THEN) passes the result on the left-hand side
    to the first parameter of the function on the right-hand side. A statement rewritten
    this way is often easier to read.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`%>%` 运算符（发音为 THEN）将左侧的结果传递到右侧函数的第一个参数。以这种方式重写的语句通常更容易阅读。'
- en: Although we have covered basic `dplyr` functions, the package also contains
    functions for summarizing, combining, and restructuring data. These additional
    functions will be discussed in chapter 5.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经介绍了基本的 `dplyr` 函数，但该包还包含用于汇总、组合和重构数据的函数。这些附加函数将在第 5 章中讨论。
- en: 3.12 Using SQL statements to manipulate data frames
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.12 使用 SQL 语句操作数据框
- en: Until now, you’ve been using R statements and functions to manipulate data.
    But many data analysts come to R well versed in Structured Query Language (SQL).
    It would be a shame to lose all that accumulated knowledge. Therefore, before
    we end, let me briefly mention the `sqldf` package. (If you’re unfamiliar with
    SQL, please feel free to skip this section.)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在使用 R 语句和函数来操作数据。但许多数据分析师在熟悉结构化查询语言（SQL）的情况下来到 R。失去所有这些积累的知识将是一件遗憾的事情。因此，在我们结束之前，让我简要地提及
    `sqldf` 软件包。（如果您不熟悉 SQL，请随意跳过本节。）
- en: After downloading and installing the package (`install.packages("sqldf")`),
    you can use the `sqldf()` function to apply SQL `SELECT` statements to data frames.
    Two examples are given in the following listing.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装该软件包（`install.packages("sqldf")`）后，您可以使用 `sqldf()` 函数将 SQL `SELECT` 语句应用于数据框。以下列出两个示例。
- en: Listing 3.8 Using SQL statements to manipulate data frames
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 使用 SQL 语句操作数据框
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ Selects all variables (columns) from data frame mtcars, keeps only automobiles
    (rows) with one carburetor (carb), sorts in ascending order by mpg, and saves
    the results as the data frame newdf. The option row.names=TRUE carries the row
    names from the original data frame over to the new one.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数据框 mtcars 中选择所有变量（列），仅保留有一个化油器（carb）的汽车（行），按 mpg 升序排序，并将结果保存为数据框 newdf。选项
    row.names=TRUE 将原始数据框的行名传递到新数据框中。
- en: ❷ Prints the mean mpg and disp within each level of gear for automobiles with
    four or six cylinders (cyl)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印具有四个或六个气缸（cyl）的汽车在每个变速器级别（gear）内的平均 mpg 和 disp。
- en: Experienced SQL users will find the `sqldf` package a useful adjunct to data
    management in R. See the project home page ([https://github.com/ggrothendieck/sqldf](https://github.com/ggrothendieck/sqldf))
    for more details.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的 SQL 用户会发现 `sqldf` 软件包是 R 中数据管理的有用补充。更多详情请参阅项目主页 ([https://github.com/ggrothendieck/sqldf](https://github.com/ggrothendieck/sqldf))。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Creating new variables and recoding existing variables are important parts of
    data management.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新变量和重新编码现有变量是数据管理的重要部分。
- en: Functions allow you to store and manipulate missing and date values.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数允许您存储和操作缺失值和日期值。
- en: Variables can be converted from one type (e.g., numeric) to another (e.g., character).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量可以从一种类型（例如，数值）转换为另一种类型（例如，字符）。
- en: Based on a set of criteria, you can retain (or delete) observations and variables.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据一组标准，您可以保留（或删除）观测值和变量。
- en: It is possible to merge datasets horizontally (adding variables) or vertically
    (adding observations).
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以水平合并数据集（添加变量）或垂直合并数据集（添加观测值）。
