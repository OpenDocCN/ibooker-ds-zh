- en: 4 Transforming vectors and graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 向量和图形的变换
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Transforming and drawing 3D objects by applying mathematical functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用数学函数变换和绘制3D对象
- en: Creating computer animations using transformations to vector graphics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换创建计算机动画，用于矢量图形
- en: Identifying linear transformations, which preserve lines and polygons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别保持直线和多边形不变的线性变换
- en: Computing the effects of linear transformations on vectors and 3D models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算线性变换对向量和3D模型的影响
- en: With the techniques from the last two chapters and a little creativity, you
    can render any 2D or 3D figure you can think of. Whole objects, characters, and
    worlds can be built from line segments and polygons defined by vectors. But, there’s
    still one thing standing in between you and your first feature-length, computer-animated
    film or life-like action video game−you need to be able to draw objects that *change*
    over time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前两章的技术和一点创意，你可以渲染你所能想到的任何2D或3D图形。整个物体、角色和世界都可以由向量定义的线段和多边形构建。但是，仍然有一件事介于你和你的第一部特长篇计算机动画电影或逼真的动作视频游戏之间−你需要能够绘制随时间变化的物体。
- en: 'Animation works the same way for computer graphics as it does for film: you
    render static images and then display dozens of them every second. When we see
    that many snapshots of a moving object, it looks like the image is continuously
    changing. In chapters 2 and 3, we looked at a few mathematical operations that
    take in existing vectors and transform them geometrically to output new ones.
    By chaining together sequences of small transformations, we can create the illusion
    of continuous motion.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 动画在计算机图形学和电影中工作方式相同：你渲染静态图像，然后每秒显示数十个。当我们看到这么多移动对象的快照时，它看起来就像图像在持续变化。在第2章和第3章中，我们研究了几个数学运算，它们接受现有的向量并将它们几何变换成新的向量。通过将一系列小变换链接起来，我们可以创造出连续运动的错觉。
- en: As a mental model for this, you can keep in mind our examples of rotating 2D
    vectors. You saw that you could write a Python function, `rotate`, that took in
    a 2D vector and rotated it by, say, 45° in the counterclockwise direction. As
    figure 4.1 shows, you can think of the `rotate` function as a machine that takes
    in a vector and outputs an appropriately transformed vector.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个模型的心理模型，你可以记住我们旋转二维向量的例子。你看到你可以写一个Python函数，`rotate`，它接受一个二维向量并将其逆时针旋转45°。如图4.1所示，你可以把`rotate`函数想象成一个机器，它接受一个向量并输出相应变换后的向量。
- en: '![](../Images/CH04_F01_Orland.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F01_Orland.png)'
- en: Figure 4.1 Picturing a vector function as a machine with an input slot and output
    slot
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 将向量函数想象成一个具有输入槽和输出槽的机器
- en: If we apply a 3D analogy of this function to every vector of every polygon defining
    a 3D shape, we can see the whole shape rotate. This 3D shape could be the octahedron
    from the previous chapter or a more interesting one like a teapot. In figure 4.2,
    this rotation machine takes a teapot as input and returns a rotated copy as its
    output.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个函数的3D类比应用于定义3D形状的每个多边形的每个向量，我们就可以看到整个形状旋转。这个3D形状可以是前一章中的八面体，或者是一个更有趣的形状，比如茶壶。在图4.2中，这个旋转机器接受茶壶作为输入，并返回旋转后的副本作为输出。
- en: '![](../Images/CH04_F02_Orland.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Orland.png)'
- en: Figure 4.2 A transformation can be applied to every vector making up a 3D model,
    thereby transforming the whole model in the same geometric way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 可以将变换应用于构成3D模型的每个向量，从而以相同的方式变换整个模型。
- en: If instead of rotating by 45° once, we rotated by one degree 45 times, we could
    generate frames of a movie showing a rotating teapot (figure 4.3).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是一次旋转45°，而是旋转45次，每次旋转1度，我们就可以生成显示旋转茶壶的电影帧（图4.3）。
- en: Rotations turn out to be great examples to work with because when we rotate
    every point on a line segment by the same angle about the origin, we still have
    a line segment of the same length. As a result, when you rotate all the vectors
    outlining a 2D or 3D object, you can still recognize the object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是很好的例子，因为当我们围绕原点以相同角度旋转线段上的每个点时，我们仍然有一个相同长度的线段。因此，当你旋转构成二维或三维对象的向量时，你仍然可以识别出该对象。
- en: '![](../Images/CH04_F03_Orland.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_Orland.png)'
- en: Figure 4.3 Rotating the teapot by 1° at a time, 45 times in a row, beginning
    with the upper left-hand corner
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 每次旋转茶壶1°，连续旋转45次，从左上角开始
- en: I’ll introduce you to a broad class of vector transformations called *linear
    transformations* that, like rotations, send vectors lying on a straight line to
    new vectors that also lie on a straight line. Linear transformations have numerous
    applications in math, physics, and data analysis. It’s helpful to know how to
    picture them geometrically when you meet them again in these contexts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您介绍一类称为**线性变换**的广泛向量变换，它们与旋转类似，将位于直线上的向量映射到新的位于直线上的向量。线性变换在数学、物理和数据分析中有着广泛的应用。当您在这些背景下再次遇到它们时，了解如何从几何角度想象它们是有帮助的。
- en: To visualize rotations, linear transformations, and other vector transformations
    in this chapter, we’ll upgrade to more powerful drawing tools. We’ll swap out
    Matplotlib for OpenGL, which is an industry standard library for high-performance
    graphics. Most OpenGL programming is done in C or C++, but we’ll use a friendly
    Python wrapper called PyOpenGL. We’ll also use a video game development library
    in Python called PyGame. Specifically, we’ll use the features in PyGame that make
    it easy to render successive images into an animation. The set up for all of these
    new tools is covered in appendix C, so we can jump right in and focus on the math
    of transforming vectors. If you want to follow along with the code for this chapter
    (which I strongly recommend!), then you should skip to appendix C and return here
    once you get the code working.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化本章中的旋转、线性变换和其他向量变换，我们将升级到更强大的绘图工具。我们将用OpenGL替换Matplotlib，OpenGL是一个用于高性能图形的行业标准库。大多数OpenGL编程是用C或C++完成的，但我们将使用一个友好的Python包装器PyOpenGL。我们还将使用一个名为PyGame的Python视频游戏开发库。具体来说，我们将使用PyGame中的功能，这些功能使得将连续图像渲染成动画变得容易。所有这些新工具的设置都在附录C中介绍，因此我们可以直接进入并专注于向量的数学变换。如果您想跟随本章的代码（我强烈推荐！），那么您应该跳转到附录C，一旦代码运行正常，再返回这里。
- en: 4.1 Transforming 3D objects
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 变换3D对象
- en: 'Our main goal in this chapter is taking a 3D object (like the teapot) and changing
    it to create a new 3D object that is visually different. In chapter 2, we already
    saw that we could translate or scale each vector in a 2D dinosaur and the whole
    dinosaur shape would move or change in size accordingly. We take the same approach
    here. Every transformation we look at takes a vector as input and returns a vector
    as output, something like this pseudocode:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是取一个3D对象（如茶壶）并改变它以创建一个新的3D对象，该对象在视觉上不同。在第2章中，我们已经看到我们可以平移或缩放二维恐龙中的每个向量，整个恐龙形状会相应地移动或改变大小。我们在这里采取相同的方法。我们研究的每个变换都接受一个向量作为输入并返回一个向量作为输出，类似于以下伪代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s start by adapting the familiar examples of translation and scaling from
    2D to 3D.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将熟悉的二维平移和缩放示例适应到三维空间开始。
- en: 4.1.1 Drawing a transformed object
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 绘制变换后的对象
- en: If you’ve installed the dependencies described in appendix C, you should be
    able to run the file draw_teapot.py in the source code for chapter 4 (see appendix
    A for instructions to run a Python script from the command line). If it runs successfully,
    you should see a PyGame window that shows the image in figure 4.4.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装附录C中描述的依赖项，您应该能够在第4章的源代码中运行draw_teapot.py文件（有关从命令行运行Python脚本的说明，请参阅附录A）。如果它运行成功，您应该看到一个显示图4.4中图像的PyGame窗口。
- en: '![](../Images/CH04_F04_Orland.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH04_F04_Orland.png)'
- en: Figure 4.4 The result of running draw_teapot.py
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 运行draw_teapot.py的结果
- en: 'In the next few examples, we modify the vectors defining the teapot and then
    re-render it so that we can see the geometric effect. As a first example, we can
    scale all of the vectors by the same factor. The following function, `scale2`,
    multiplies an input vector by the scalar 2.0 and returns the result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，我们将修改定义茶壶的向量，然后重新渲染它，以便我们可以看到几何效果。作为一个例子，我们可以将所有向量按相同的因子缩放。以下函数`scale2`将输入向量乘以标量2.0并返回结果：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `scale2(*v*)` function has the same form as the `transform(*v*)` function
    given at the top of this section; when passed a 3D vector as input, `scale2` returns
    a new 3D vector as output. To execute this transformation on the teapot, we need
    to transform each of its vertices. We can do this triangle by triangle. For each
    triangle that we use to build the teapot, we create a new triangle with the result
    of applying `scale2` to the original vertices:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`scale2(*v*)`函数与本章开头给出的`transform(*v*)`函数具有相同的形式；当输入一个3D向量时，`scale2`返回一个新的3D向量作为输出。为了在茶壶上执行这种变换，我们需要变换它的每个顶点。我们可以一个三角形一个三角形地做这件事。对于构建茶壶的每个三角形，我们创建一个新的三角形，其顶点是应用`scale2`变换后的原始顶点：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Loads the triangles using the code from appendix C
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用附录 C 中的代码加载三角形
- en: ❷ Applies scale2 to each vertex in a given triangle to get new vertices
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 `scale2` 应用到给定三角形中的每个顶点上以获得新顶点
- en: ❸ Does this for each triangle in the list of original triangles
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对原始三角形列表中的每个三角形都这样做
- en: Now that we’ve got a new set of triangles, we can draw them by calling `draw_model(scaled_triangles)`.
    Figure 4.5 shows the teapot after this call, and you can reproduce this by running
    the file scale_teapot.py in the source code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一组新的三角形，我们可以通过调用 `draw_model(scaled_triangles)` 来绘制它们。图 4.5 显示了调用此函数后的茶壶，你可以通过在源代码中运行文件
    scale_teapot.py 来重现这个结果。
- en: '![](../Images/CH04_F05_Orland.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F05_Orland.png)'
- en: Figure 4.5 Applying `scale2` to each vertex of each triangle gives us a teapot
    that is twice as big.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 将 `scale2` 应用到每个三角形的每个顶点上，我们得到了一个两倍大的茶壶。
- en: 'This teapot looks bigger than the original, and in fact, it is twice as big
    because we multiplied each vector by 2\. Let’s apply another transformation to
    each vector: translation by the vector (−1, 0, 0).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个茶壶看起来比原来的大，实际上，它大了两倍，因为我们把每个向量乘以 2。现在让我们对每个向量应用另一个变换：通过向量 (−1, 0, 0) 进行平移。
- en: 'Recall that “translating by a vector” is another way of saying “adding the
    vector,” so what I’m really talking about is adding (−1, 0, 0) to every vertex
    of the teapot. This should move the whole teapot one unit in the negative *x*
    direction, which is to the left from our perspective. This function accomplishes
    the translation for a single vertex:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，“通过向量转换”是“加向量”的另一种说法，所以我真正要讨论的是将向量 (−1, 0, 0) 加到茶壶的每个顶点上。这应该将整个茶壶向负 *x*
    方向移动一个单位，即从我们的视角来看是向左移动。这个函数为单个顶点完成了转换：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Starting with the original triangles, we now want to scale each of their vertices
    as before and then apply the translation. Figure 4.6 shows the result. You can
    reproduce it with the source file scale_translate_teapot.py:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始三角形开始，我们现在想要像以前一样缩放每个顶点，然后应用平移。图 4.6 显示了结果。你可以使用源文件 scale_translate_teapot.py
    来重现它：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/CH04_F06_Orland.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F06_Orland.png)'
- en: Figure 4.6 The teapot is bigger and moved to the left as we hoped!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 茶壶变大了，并且像我们希望的那样向左移动了！
- en: Different scalar multiples change the size of the teapot by different factors,
    and different translation vectors move the teapot to different positions in space.
    In the exercises that follow, you’ll have a chance to try different scalar multiples
    and translations, but for now, let’s focus on combining and applying more transformations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的标量倍数以不同的因素改变茶壶的大小，不同的平移向量将茶壶移动到空间中的不同位置。在接下来的练习中，你将有机会尝试不同的标量倍数和平移，但到目前为止，让我们专注于组合和应用更多的变换。
- en: 4.1.2 Composing vector transformations
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 组合向量变换
- en: 'Applying any number of transformations sequentially defines a new transformation.
    In the previous section, for instance, we transformed the teapot by scaling it
    and then translating it. We can package this new transformation as its own Python
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 依次应用任意数量的变换定义了一个新的变换。例如，在上一节中，我们通过缩放然后平移来变换茶壶。我们可以将这个新变换打包成它自己的 Python 函数：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is an important principle! Because vector transformations take vectors
    as inputs and return vectors as outputs, we can combine as many of them as we
    want by *composition of functions* . If you haven’t heard this term before, it
    means defining new functions by applying two or more existing ones in a specified
    order. If we picture the functions `scale2` and `translate1left` as machines that
    take in 3D models and output new ones (figure 4.7), we can combine them by passing
    the outputs of the first machine as inputs to the second.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的原则！因为向量变换以向量作为输入并返回向量作为输出，我们可以通过函数的**组合**来组合尽可能多的它们。如果你之前没有听说过这个术语，它意味着通过以指定顺序应用两个或多个现有函数来定义新函数。如果我们把
    `scale2` 和 `translate1left` 函数想象成接受 3D 模型并输出新模型的机器（图 4.7），我们可以通过将第一个机器的输出作为第二个机器的输入来组合它们。
- en: '![](../Images/CH04_F07_Orland.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F07_Orland.png)'
- en: Figure 4.7 Calling `scale2` and then `translate1left` on a teapot to output
    a transformed version
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 在茶壶上调用 `scale2` 和 `translate1left` 以输出转换后的版本
- en: We can imagine hiding the intermediate step by welding the output slot of the
    first machine to the input slot of the second machine (figure 4.8).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象通过将第一个机器的输出槽焊接到第二个机器的输入槽来隐藏中间步骤（图 4.8）。
- en: '![](../Images/CH04_F08_Orland.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F08_Orland.png)'
- en: Figure 4.8 Welding the two function machines together to get a new one, which
    performs both transformations in one step
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 将两个函数机器焊接在一起以得到一个新的机器，该机器一步完成两种转换
- en: 'We can think of the result as a new machine that does the work of both the
    original functions in one step. This “welding” of functions can be done in code
    as well. We can write a general-purpose `compose` function that takes two Python
    functions (for vector transformations, for instance) and returns a new function,
    which is their composition:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把结果想象成一个新机器，它一步完成原始函数的工作。这种函数的“焊接”也可以在代码中实现。我们可以编写一个通用的`compose`函数，它接受两个Python函数（例如，用于向量变换的函数）并返回一个新的函数，这是它们的组合：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of defining `scale2_then_translate1left` as its own function, we could
    write
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必为`scale2_then_translate1left`定义一个单独的函数，我们可以这样写
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might have heard of the idea that Python treats functions as “first-class
    objects.” What is usually meant by this slogan is that Python functions can be
    assigned to variables, passed as inputs to other functions, or created on-the-fly
    and returned as output values. These are *functional programming* techniques,
    meaning that they help us build complex programs by combining existing functions
    to make new ones.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过Python将函数视为“一等对象”的想法。这个口号通常意味着Python函数可以被分配给变量，作为其他函数的输入传递，或者即时创建并作为输出值返回。这些都是*函数式编程*技术，意味着它们通过组合现有函数来构建新的函数，帮助我们构建复杂的程序。
- en: There is some debate about whether functional programming is kosher in Python
    (or as a Python fan would say, whether or not functional programming is “Pythonic”).
    I won’t opine about coding style, but I use functional programming because functions,
    namely vector transformations, are our central objects of study. With the `compose`
    function covered, I’ll show you a few more functional “recipes” that justify this
    digression. Each of these is added in a new helper file called transforms.py in
    the source code for this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数式编程在Python中是否合适（或者说，作为一个Python粉丝可能会说，函数式编程是否“Pythonic”），有一些争议。我不会对编码风格发表意见，但我使用函数式编程，因为函数，特别是向量变换，是我们研究的核心对象。在介绍了`compose`函数之后，我将向你展示一些更多的函数式“食谱”，以证明这种偏离是有道理的。这些都是在本书源代码中的新辅助文件`transforms.py`中添加的。
- en: 'Something we’ll be doing repeatedly is taking a vector transformation and applying
    it to every vertex in every triangle defining a 3D model. We can write a reusable
    function for this rather than writing a new list comprehension each time. The
    following `polygon_map` function takes a vector transformation and a list of polygons
    (usually triangles) and applies the transformation to each vertex of each polygon,
    yielding a new list of new polygons:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将反复进行的一项操作是将向量变换应用于定义3D模型的每个三角形的每个顶点。我们可以为这个操作编写一个可重用的函数，而不是每次都编写一个新的列表推导式。以下`polygon_map`函数接受一个向量变换和一个多边形列表（通常是三角形），并将变换应用于每个多边形的每个顶点，生成一个新的多边形列表：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this helper function, we can apply `scale2` to the original teapot in
    one line:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个辅助函数，我们可以一行代码就将`scale2`应用于原始的茶壶：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `compose` and `polygon_map` functions both take vector transformations
    as arguments, but it’s also useful to have functions that return vector transformations.
    For instance, it might have bothered you that we named a function `scale2` and
    hard-coded the number two into its definition. A replacement for this could be
    a `scale_by` function that returns a scaling transformation for a specified scalar:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose`和`polygon_map`函数都接受向量变换作为参数，但拥有返回向量变换的函数也很有用。例如，我们可能觉得将一个函数命名为`scale2`并将数字二硬编码到其定义中有些麻烦。这种做法的一个替代方案是`scale_by`函数，它返回一个指定标量的缩放变换：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this function, we can write `scale_by(2)` and the return value would be
    a new function that behaves identically to `scale2`. While we’re picturing functions
    as machines with input and output slots, you can picture `scale_by` as a machine
    that takes numbers in its input slot and outputs new function machines from its
    output slot as shown in figure 4.9.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以写`scale_by(2)`，返回值将是一个新的函数，其行为与`scale2`完全相同。当我们把函数想象成具有输入和输出槽位的机器时，你可以把`scale_by`想象成一个机器，它在其输入槽位中接受数字，并从其输出槽位输出新的函数机器，如图4.9所示。
- en: '![](../Images/CH04_F09_Orland.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F09_Orland.png)'
- en: Figure 4.9 A function machine that takes numbers as inputs and produces new
    function machines as outputs
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 一个函数机器，它接受数字作为输入并产生新的函数机器作为输出
- en: As an exercise, you can write a similar `translate_by` function that takes a
    translation vector as input and returns a translation function as output. In the
    terminology of functional programming, this process is called *currying* *.* Currying
    takes a function that accepts multiple inputs and refactors it to a function that
    returns another function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以编写一个类似的 `translate_by` 函数，它接受一个平移向量作为输入，并返回一个平移函数作为输出。在函数式编程的术语中，这个过程称为
    *currying* *.* Currying 将接受多个输入的函数重构为返回另一个函数的函数。
- en: 'The result is a programmatic machine that behaves identically but is invoked
    differently; for instance, `scale_by(s)(*v*)` gives the same result as `scale(s,v)`
    for any inputs *s* and *v*. The advantage is that `scale(...)` and `add(...)`
    accept different kinds of arguments, so the resulting functions, `scale_by(s)`
    and `translate _by(*w*)`, are interchangeable. Next, we’ll think similarly about
    rotations: for any given angle, we can produce a vector transformation that rotates
    our model by that angle.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个程序化的机器，其行为相同，但调用方式不同；例如，`scale_by(s)(*v*)` 对于任何输入 *s* 和 *v* 都会产生与 `scale(s,v)`
    相同的结果。优点是 `scale(...)` 和 `add(...)` 可以接受不同类型的参数，因此生成的函数 `scale_by(s)` 和 `translate_by(*w*)`
    可以互换使用。接下来，我们将类似地考虑旋转：对于任何给定的角度，我们可以生成一个向量变换，使我们的模型绕该角度旋转。
- en: 4.1.3 Rotating an object about an axis
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 绕轴旋转对象
- en: 'You already saw how to do rotations in 2D in chapter 2: you convert the Cartesian
    coordinates to polar coordinates, increase or decrease the angle by the rotation
    factor, and then convert back. Even though this is a 2D trick, it is helpful in
    3D because all 3D'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在第二章中看到了如何在二维中进行旋转：你将笛卡尔坐标转换为极坐标，通过旋转因子增加或减少角度，然后转换回来。尽管这是一个二维技巧，但在三维中也很有用，因为所有三维
- en: vector rotations are, in a sense, isolated in planes. Picture, for instance,
    a single point in 3D being rotated about the *z* -axis. Its *x* − and *y*-coordinates
    change, but its *z*-coordinate remains the same. If a given point is rotated around
    the *z* -axis, it stays in a circle with a constant *z*-coordinate, regardless
    of the rotation angle (figure 4.10).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向量旋转在某种意义上是孤立在平面上的。例如，想象一个点在三维空间中绕 *z* 轴旋转。它的 *x* 和 *y* 坐标会改变，但它的 *z* 坐标保持不变。如果给定点绕
    *z* 轴旋转，它将保持在具有恒定 *z* 坐标的圆上，无论旋转角度如何（图4.10）。
- en: '![](../Images/CH04_F10_Orland.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F10_Orland.png)'
- en: Figure 4.10 Rotating a point around the z-axis
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 绕z轴旋转点
- en: 'What this means is that we can rotate a 3D point around the *z* -axis by holding
    the *z*-coordinate constant and applying our 2D rotation function only to the
    *x* − and *y*-coordinates. We’ll work through the code here, and you can also
    find it in rotate_teapot.py in the source code. First, we write a 2D rotation
    function adapted from the strategy we used in chapter 2:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过保持 *z* 坐标不变，并将我们的二维旋转函数仅应用于 *x* 和 *y* 坐标来绕 *z* 轴旋转一个三维点。我们将在代码中实现这一点，你还可以在源代码中的
    rotate_teapot.py 文件中找到它。首先，我们编写一个二维旋转函数，该函数是从我们在第二章中使用的方法改编而来的：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function takes an angle and a 2D vector and returns a rotated 2D vector.
    Now, let’s create a function, `rotate_z`, that applies this function only to the
    *x* and *y* components of a 3D vector:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个角度和一个二维向量，并返回一个旋转后的二维向量。现在，让我们创建一个函数 `rotate_z`，它只应用于三维向量的 *x* 和 *y*
    分量：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Continuing to think in the functional programming paradigm, we can curry this
    function. Given any angle, the curried version produces a vector transformation
    that does the corresponding rotation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在函数式编程范式下思考，我们可以对函数进行currying。给定任何角度，curried版本会产生一个向量变换，执行相应的旋转：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s see it in action. The following line yields the teapot in figure 4.11,
    which is rotated by *π*/4 or 45°:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实际效果。以下行生成了图4.11中的茶壶，它绕 *π*/4 或 45° 旋转：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/CH04_F11_Orland.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F11_Orland.png)'
- en: Figure 4.11 The teapot is rotated 45° counterclockwise about the z-axis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 茶壶绕z轴逆时针旋转45°。
- en: 'We can write a similar function to rotate the teapot about the x-axis, meaning
    the rotation affects only the *y* and *z* components of the vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个类似的函数来绕x轴旋转茶壶，这意味着旋转只影响向量的 *y* 和 *z* 分量：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the function `rotate_x_by`, a rotation about the x-axis is achieved by fixing
    the *x* coordinate and executing a 2D rotation in the *y*,*z* plane. The following
    code draws a 90° or *π*/2 radian rotation (counterclockwise) about the x-axis,
    resulting in the upright teapot shown in figure 4.12:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rotate_x_by` 函数中，通过固定 *x* 坐标并在 *y*、*z* 平面上执行 2D 旋转来实现绕 x 轴的旋转。以下代码绘制了 90°
    或 *π*/2 弧度（逆时针）的旋转，结果如图 4.12 所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](../Images/CH04_F12_Orland.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F12_Orland.png)'
- en: Figure 4.12 The teapot rotated by *π*/2 about the x-axis.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 茶壶绕 x 轴旋转 *π*/2。
- en: You can reproduce figure 4.12 with the source file rotate_teapot_x.py. The shading
    is consistent among these rotated teapots; their brightest polygons are toward
    the top-right of the figures, which is expected because the light source remains
    at (1, 2, 3). This is a good sign that we are successfully moving the teapot and
    not just changing our OpenGL perspective as before.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用源文件 rotate_teapot_x.py 重新生成图 4.12。这些旋转茶壶的阴影是一致的；它们最亮的多边形位于图象的右上角，这是预期的，因为光源仍然位于
    (1, 2, 3)。这是一个好迹象，表明我们正在成功移动茶壶，而不是像以前那样仅仅改变我们的 OpenGL 视角。
- en: It turns out that it’s possible to get *any* rotation we want by composing rotations
    in the *x* and *z* directions. In the exercises at the end of the section, you
    can try your hand at some more rotations, but for now, we’ll move on to other
    kinds of vector transformations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，通过在 *x* 和 *z* 方向上组合旋转，我们可以得到我们想要的任何旋转。在章节末尾的练习中，你可以尝试一些更多的旋转，但到目前为止，我们将继续探讨其他类型的向量变换。
- en: 4.1.4 Inventing your own geometric transformations
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 发明你自己的几何变换
- en: So far, I’ve focused on the vector transformations we already saw in some way
    in the preceding chapters. Now, let’s throw caution to the wind and see what other
    interesting transformations we can come up with. Remember, the only requirement
    for a 3D vector transformation is that it accepts a single 3D vector as input
    and returns a new 3D vector as its output. Let’s look at a few transformations
    that don’t quite fall in any of the categories we’ve seen so far.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我主要关注我们在前几章中以一种方式看到过的向量变换。现在，让我们大胆尝试，看看我们还能想出哪些有趣的变换。记住，3D 向量变换的唯一要求是它接受一个单一的
    3D 向量作为输入，并返回一个新的 3D 向量作为输出。让我们看看一些不太符合我们之前看到过的类别的变换。
- en: 'For our teapot, let’s modify one coordinate at a time. This function stretches
    vectors by a (hard-coded) factor of four, but only in the *x* direction:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的茶壶，让我们一次修改一个坐标。这个函数通过（硬编码的）四倍因子拉伸向量，但只在 *x* 方向上：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result is a long, skinny teapot along the x-axis or in the handle-to-spout
    direction (figure 4.13). This is fully implemented in stretch_teapot.py.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是沿着 x 轴或把手到壶嘴的方向出现一个细长的茶壶（图 4.13）。这在 stretch_teapot.py 中完全实现。
- en: '![](../Images/CH04_F13_Orland.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F13_Orland.png)'
- en: Figure 4.13 A teapot stretched along the x-axis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 沿 x 轴拉伸的茶壶。
- en: A similar `stretch_y` function elongates the teapot from top-to-bottom. You
    can implement `stretch_y` and apply it to a teapot yourself, and you should get
    the image in figure 4.14\. Otherwise, you can look at the implementation in stretch_teapot_y.py
    in the source code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的 `stretch_y` 函数可以使茶壶从上到下变长。你可以自己实现 `stretch_y` 并将其应用于茶壶，你应该得到图 4.14 中的图像。否则，你可以查看源代码中
    stretch_teapot_y.py 中的实现。
- en: 'We can get even more creative, stretching the teapot by cubing the *y*-coordinate
    rather than just multiplying it by a number. This transformation gives the teapot
    a disproportionately elongated lid as implemented in cube_teapot.py and shown
    in figure 4.15:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更有创意，通过将 *y* 坐标立方而不是简单地乘以一个数字来拉伸茶壶。这种变换在 cube_teapot.py 中实现，并在图 4.15 中展示：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/CH04_F14_Orland.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F14_Orland.png)'
- en: Figure 4.14 Stretching the teapot in the y direction instead
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 在 y 方向上拉伸茶壶而不是其他方向
- en: '![](../Images/CH04_F15_Orland.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F15_Orland.png)'
- en: Figure 4.15 Cubing the vertical dimension of the teapot
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 茶壶的垂直维度立方
- en: 'If we selectively add two of the three coordinates in the formula for the transformation,
    for instance the *x* and *y* coordinates, we can cause the teapot to slant. This
    is implemented in slant_teapot.py and shown in figure 4.16:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择性地在变换的公式中添加三个坐标中的两个，例如 *x* 和 *y* 坐标，我们可以使茶壶倾斜。这已在 slant_teapot.py 中实现，并在图
    4.16 中展示：
- en: '![](../Images/CH04_F16_Orland.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F16_Orland.png)'
- en: Figure 4.16 Adding the y-coordinate to the existing x-coordinate causes the
    teapot to slant in the *x* direction.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 将y坐标添加到现有的x坐标会使茶壶在*x*方向上倾斜。
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The point is not that any one of these transformations is important or useful,
    but that any mathematical transformation of the vectors constituting a 3D model
    have *some* geometric consequence on the appearance of the model. It is possible
    to go too crazy with the transformation, at which point the model can become too
    distorted to recognize or even to draw successfully. Indeed, some transfor-mations
    are better-behaved in general, and we’ll classify them in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点不是这些变换中的任何一个都很重要或有用，而是构成3D模型的向量的任何数学变换都会对模型的外观产生某种几何影响。过度使用变换可能会导致模型过度扭曲，以至于无法识别或成功绘制。实际上，一些变换在一般情况下表现得更好，我们将在下一节中对其进行分类。
- en: 4.1.5 Exercises
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 练习
- en: '| **Exercise 4.1**: Implement a `translate_by` function (referred to in section
    4.1.2), taking a translation vector as input and returning a translation function
    as output.**Solution**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习4.1**：实现一个`translate_by`函数（在4.1.2节中提到），它接受一个平移向量作为输入，并返回一个平移函数作为输出。**解答**：'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 4.2**: Render the teapot translated by 20 units in the negative
    *z* direction. What does the resulting image look like?**Solution**: We can accomplish
    this by applying `translate_by((0,0,−20))` to every vector of every polygon with
    `polgyon_map` :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习4.2**：渲染沿负*z*方向平移20单位的茶壶。结果图像看起来像什么？**解答**：我们可以通过将`translate_by((0,0,−20))`应用于每个多边形的每个向量，使用`polgyon_map`来完成这项工作：'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember, we are looking at the teapot from five units up the z-axis. This transformation
    brings the teapot 20 units further from us, so it looks much smaller than the
    original. You can find the complete implementation in translate_teapot_down_z.py
    in the source code.![](../Images/CH04_F16_Orland_UN01.png)The teapot translated
    20 units down the z-axis. It appears smaller because it is further from the viewpoint.
    |
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们是从z轴上方五单位处观察茶壶的。这个变换将茶壶带到我们前方20单位处，所以它看起来比原始的茶壶小得多。你可以在源代码中的translate_teapot_down_z.py中找到完整的实现。![图片](../Images/CH04_F16_Orland_UN01.png)茶壶沿z轴向下平移了20单位。它看起来更小，因为它离观察者更远。|
- en: '| **Exercise 4.3-Mini Project**: What happens to the teapot when you scale
    every vector by a scalar between 0 and 1? What happens when you scale it by a
    factor of −1?**Solution**: We can apply `scale_by(0.5)` and `scale_by(−1)` to
    see the results:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习4.3-迷你项目**：当你将每个向量按0到1之间的标量缩放时，茶壶会发生什么变化？当你将其按-1的因子缩放时会发生什么？**解答**：我们可以通过应用`scale_by(0.5)`和`scale_by(−1)`来查看结果：'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/CH04_F16_Orland_UN02.png)Left-to-right, the original teapot,
    the teapot scaled by 0.5, and the teapot scaled by −1.As you can see, `scale_by(0.5)`
    shrinks the teapot to half its original size. The action of `scale_by(−1)` seems
    to rotate the teapot by 180°, but the situation is a bit more complicated. It’s
    actually turned inside-out as well! Each triangle has been reflected, so each
    normal vector now points into the teapot rather than outward from its surface.![](../Images/CH04_F16_Orland_UN03.png)Reflection
    changes the orientation of a triangle. The indexed vertices are in counterclockwise
    order on the left and clockwise order in the reflection on the right. The normal
    vectors to these triangles point in opposite directions.Rotating the teapot, you
    can see that it is not quite rendering correctly as a result. We should be careful
    with reflections of our graphics for this reason!![](../Images/CH04_F16_Orland_UN04.png)The
    rotated, reflected teapot does not look quite right. Some features appear but
    should be concealed. For instance, we can see both the lid and the hollow bottom
    in the bottom right frame. |'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH04_F16_Orland_UN02.png)从左到右，原始的茶壶、放大0.5倍的茶壶和放大-1倍的茶壶。如图所示，`scale_by(0.5)`将茶壶缩小到原来的一半大小。`scale_by(−1)`的动作看起来像是将茶壶旋转了180°，但实际上情况要复杂一些。它实际上被翻转了！每个三角形都被反射了，所以每个法向量现在指向茶壶内部而不是从其表面向外！![图片](../Images/CH04_F16_Orland_UN03.png)反射改变了三角形的方向。左边的索引顶点按逆时针顺序排列，右边的反射按顺时针顺序排列。这些三角形的法向量指向相反的方向。旋转茶壶，你可以看到它渲染得并不完全正确，这是由于这个原因！我们应该小心处理我们的图形的反射！！![图片](../Images/CH04_F16_Orland_UN04.png)旋转并反射的茶壶看起来并不完全正确。一些特征出现了，但应该被隐藏。例如，在右下角的框架中，我们可以看到盖子和空心底部。|'
- en: '| **Exercise 4.4**: First apply `translate1left` to the teapot and then apply
    `scale2`. How is the result different from the opposite order of composition?
    Why?**Solution**: We can compose these two functions in the specified order and
    then apply them with `polygon_map:`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 4.4**: 首先对茶壶应用 `translate1left`，然后应用 `scale2`。与逆序组合的效果有何不同？为什么？**解答**：我们可以按指定顺序组合这两个函数，然后使用
    `polygon_map:` 应用它们。|'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result is that the teapot is still twice as large as the original, but this
    one is translated further to the left. This is because when a scaling factor of
    2 is applied after a translation, the distance of the translation doubles as well.
    You can convince yourself by running the source files scale_translate _teapot.py
    and translate_scale_teapot .py and comparing the results.![](../Images/CH04_F16_Orland_UN05.png)Scaling
    and then translating the teapot (left) vs. translating and then scaling (right)
    |
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是茶壶仍然是原始大小的两倍，但这个茶壶向左平移得更远。这是因为当缩放因子 2 在平移之后应用时，平移的距离也会加倍。你可以通过运行源文件 `scale_translate_teapot.py`
    和 `translate_scale_teapot.py` 并比较结果来证实这一点！![图片](../Images/CH04_F16_Orland_UN05.png)先缩放后平移茶壶（左）与先平移后缩放（右）|
- en: '| **Exercise 4.5**: What is the effect of the transformation `compose(scale_by
    (0.4), scale_by(1.5))` ?**Solution**: Applying this to a vector scales it by 1.5
    and then by 0.4 for a net scaling factor of 0.6\. The resulting figure will be
    60% of the size of the original. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.5**: 变换 `compose(scale_by (0.4), scale_by(1.5))` 的效果是什么？**解答**：应用此变换到向量上，首先将其缩放为
    1.5 倍，然后缩放为 0.4 倍，最终缩放因子为 0.6。生成的图形将是原始大小的 60%。|'
- en: '| **Exercise 4.6**: Modify the `compose(f,g)` function to `compose(*args)`,
    which takes several functions as arguments and returns a new function that is
    their composition.**Solution**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 4.6**: 将 `compose(f,g)` 函数修改为 `compose(*args)`，它接受多个函数作为参数，并返回一个新的函数，该函数是它们的组合。**解答**：'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Starts defining the function that compose returns❷ Sets the current state
    equal to the input❸ Iterates over the input functions in reverse order because
    the inner functions of a composition are applied first. For example, compose(f,g,h)(*x*)
    should equal *f*(g(h(*x*))), so the first function to apply is h.❹ At each step,
    updates the state by applying the next function. The final state has all the |
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 开始定义 compose 返回的函数❷ 将当前状态设置为输入❸ 以相反的顺序遍历输入函数，因为组合的内函数先应用。例如，`compose(f,g,h)(*x*)`
    应等于 `f(g(h(*x*)))`，所以第一个要应用的函数是 h。❹ 在每一步中，通过应用下一个函数来更新状态。最终状态包含所有 |
- en: '| To check our work, we can build some functions and compose them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| 为了验证我们的工作，我们可以构建一些函数并将它们组合起来：'
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then running `*f*(“hon”)` returns the string `“Python”`. In general, the constructed
    function `f` appends the string `“Pyt”` to whatever string it is given. |
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 `*f*(“hon”)` 返回字符串 `“Python”`。一般来说，构造的函数 `f` 将字符串 `“Pyt”` 追加到它所接受的任何字符串上。|
- en: '| **Exercise 4.7**: Write a `curry2(f)` function that takes a Python function
    `f(x,y)` with two arguments and returns a curried version. For instance, once
    you write `g = curry2(f)`, the two expressions `f(x,y)` and `*g*(*x*)(*y*)` should
    return the same result.**Solution**: The return value should be a new function
    that, in turn, produces a new function when called:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 4.7**: 编写一个 `curry2(f)` 函数，该函数接受一个具有两个参数的 Python 函数 `f(x,y)` 并返回一个柯里化版本。例如，一旦你编写了
    `g = curry2(f)`，两个表达式 `f(x,y)` 和 `*g*(*x*)(*y*)` 应该返回相同的结果。**解答**：返回值应该是一个新函数，当它被调用时，会再次产生一个新的函数：'
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As an example, we could have built the `scale_by` function like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们可以这样构建 `scale_by` 函数：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 4.8**: Without running it, what is the result of applying the
    transformation `compose(rotate_z_by(pi/2),rotate_x_by(pi/2))` ? What if you switch
    the order of the composition?**Solution**: This composition is equivalent to a
    clockwise rotation by *π*/2 about the y-axis. Reversing the order gives a counterclockwise
    rotation by *π*/2 about the y-axis. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.8**: 不运行它，应用变换 `compose(rotate_z_by(pi/2),rotate_x_by(pi/2))` 的结果是什么？如果你交换组合的顺序呢？**解答**：这个组合等价于绕
    y 轴顺时针旋转 *π*/2。逆序则给出绕 y 轴逆时针旋转 *π*/2。|'
- en: '| **Exercise 4.9**: Write a function `stretch_x(scalar,vector)` that scales
    the target vector by the given factor but only in the *x* direction. Also write
    a curried version `stretch_x_by` so that `stretch_x_by(scalar)(vector)` returns
    the same result.**Solution**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 4.9**: 编写一个函数 `stretch_x(scalar,vector)`，该函数通过给定的因子缩放目标向量，但仅在 *x* 方向上缩放。同时编写一个柯里化版本
    `stretch_x_by`，使得 `stretch_x_by(scalar)(vector)` 返回相同的结果。**解答**：'
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 4.2 Linear transformations
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 线性变换
- en: The well-behaved vector transformations we’re going to focus on are called *linear
    transformations*. Along with vectors, linear transformations are the other main
    objects of study in linear algebra. Linear transformations are special transformations
    where vector arithmetic looks the same before and after the transformation. Let’s
    draw some diagrams to show exactly what that means.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要关注的良好行为的向量变换被称为 *线性变换*。与向量一样，线性变换是线性代数中研究的其他主要对象。线性变换是一种特殊的变换，其中向量算术在变换前后看起来相同。让我们绘制一些图表来展示这究竟意味着什么。
- en: 4.2.1 Preserving vector arithmetic
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 保持向量算术
- en: The two most important arithmetic operations on vectors are addition and scalar
    multiplication. Let’s return to our 2D pictures of these operations and see how
    they look before and after a transformation is applied.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向量上的两个最重要的算术运算分别是加法和标量乘法。让我们回到这些操作的 2D 图像，看看在应用变换前后它们看起来如何。
- en: We can picture the sum of two vectors as the new vector we arrive at when we
    place them tip-to-tail, or as the vector to the tip of the parallelogram they
    define. For instance, figure 4.17 represents the vector sum ***u*** + ***v***
    = ***w***.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将两个向量的和想象成我们将它们尾对尾放置时到达的新向量，或者想象成定义的平行四边形的顶点向量。例如，图 4.17 表示向量和 ***u*** +
    ***v*** = ***w***。
- en: '![](../Images/CH04_F17_Orland.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F17_Orland.png)'
- en: Figure 4.17 Geometric demonstration of the vector sum *z* + *v* = w
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 向量和 *z* + *v* = w 的几何演示
- en: The question we want to ask is, if we apply the same vector transformation to
    all three of the vectors in this diagram, will it still look like a vector sum?
    Let’s try a vector transformation, which is a counterclockwise rotation about
    the origin, and call this transformation *R*. Figure 4.18 shows ***u***, ***v***,
    and ***w*** rotated by the same angle by the transformation *R*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要问的问题是，如果我们将相同的向量变换应用到这个图中的三个向量上，它是否仍然看起来像向量和？让我们尝试一个向量变换，这是一个关于原点的逆时针旋转，我们称这个变换为
    *R*。图 4.18 显示了 ***u***，***v*** 和 ***w*** 通过变换 *R* 以相同的角度旋转。
- en: '![](../Images/CH04_F18_Orland.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F18_Orland.png)'
- en: Figure 4.18 After rotating *u*, *v*, and *w* by the same rotation R, the sum
    still holds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 在将 *u*，*v* 和 *w* 通过相同的旋转 R 旋转后，和仍然成立。
- en: The rotated diagram is exactly the diagram representing the vector sum *R*(*u*)
    + *R*(*v*) = *R*(*w*). You can draw the picture for any three vectors ***u***,
    ***v***, and ***w***, and as long as ***u*** + ***v*** = ***w*** and if you apply
    the same rotation transformation *R* to each of the vectors, you find that *R*(*u*)
    + *R*(*v*) = *R*(*w*) as well. To describe this property, we say that rotations
    *preserve* vector sums.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转后的图表正好是表示向量和 *R*(*u*) + *R*(*v*) = *R*(*w*) 的图表。你可以为任何三个向量 ***u***，***v***
    和 ***w*** 绘制图像，只要 ***u*** + ***v*** = ***w***，并且如果你将相同的旋转变换 *R* 应用到每个向量上，你会发现
    *R*(*u*) + *R*(*v*) = *R*(*w*)。为了描述这个属性，我们说旋转 *保持* 向量和。
- en: Similarly, rotations preserve scalar multiples. If ***v*** is a vector and s***v***
    is a multiple of ***v*** by a scalar *s*, then s***v*** points in the same direction
    but is scaled by a factor of *s*. If we rotate ***v*** and s***v*** by the same
    rotation *R*, we’ll see that *R*(*s* ***v***) is a scalar multiple of *R*(***v***)
    by the same factor *s*(figure 4.19).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，旋转保持标量乘法。如果 ***v*** 是一个向量，而 s***v*** 是通过标量 *s* 乘以 ***v*** 得到的，那么 s***v***
    指向相同的方向，但按 *s* 的因子缩放。如果我们用相同的旋转 *R* 旋转 ***v*** 和 s***v***，我们会看到 *R*(*s* ***v***)
    是 *R*(*v**) 的一个标量倍数，倍数为相同的 *s*（图 4.19）。
- en: '![](../Images/CH04_F19_Orland.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F19_Orland.png)'
- en: Figure 4.19 Scalar multiplication is preserved by rotation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 旋转保持了标量乘法。
- en: Again, this is only a visual example and not a proof, but you’ll find that for
    any vector ***v***, scalar *s*, and rotation *R*, the same picture holds. Rotations
    or any other vector transformations that preserve vector sums and scalar multiples
    are called *linear transformations.*
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是一个视觉示例，而不是一个证明，但你会发现对于任何向量 ***v***，标量 *s* 和旋转 *R*，同样的图像是成立的。保持向量加法和标量乘法的旋转或其他向量变换被称为
    *线性变换*。
- en: '| Linear transformationA *linear transformation* is a vector transformation
    *T* that preserves vector addition and scalar multiplication. That is, for any
    input vectors ***u*** and ***v***, we have*T*(*u*) + *T*(*v*) = *T*(*u* + v)and
    for any pair of a scalar *s* and a vector ***v***, we have*T*(*sv*) = *sT*(*v*)
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 线性变换 | *线性变换* 是一个保持向量加法和标量乘法的向量变换 *T*。也就是说，对于任何输入向量 ***u*** 和 ***v***，我们有
    *T*(*u*) + *T*(*v*) = *T*(*u* + v*)，并且对于任何一对标量 *s* 和向量 ***v***，我们有 *T*(*sv*) =
    *sT*(*v*) |'
- en: Make sure you pause to digest this definition; linear transformations are so
    important that the whole subject of linear algebra is named after them. To help
    you recognize linear transformations when you see them, we’ll look at a few more
    examples.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你暂停一下，消化这个定义；线性变换如此重要，以至于整个线性代数主题都是以它们的名称命名的。为了帮助你识别当你看到它们时的线性变换，我们将再看看几个例子。
- en: 4.2.2 Picturing linear transformations
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 图形化线性变换
- en: 'First, let’s look at a counterexample: a vector transformation that’s *not*
    linear. Such an example is a transformation *S*(*v*) that takes a vector ***v***
    = (*x*, *y*) and outputs a vector with both coordinates squared: *S*(*v*) = (*x*²,
    *y*²). As an example, let’s look at the sum of ***u*** = (2, 3) and ***v*** =
    (1, −1). The sum is (2, 3) + (1, −1) = (3, 2). This is shown with vector addition
    in figure 4.20.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一个反例：一个非线性的向量变换。这样的例子是一个变换 *S*(*v*)，它将向量 ***v*** = (*x*, *y*) 转换为坐标都平方的向量：*S*(*v*)
    = (*x*², *y*²)。作为一个例子，让我们来看 ***u*** = (2, 3) 和 ***v*** = (1, −1) 的和。和是 (2, 3)
    + (1, −1) = (3, 2)。这如图 4.20 中的向量加法所示。
- en: '![](../Images/CH04_F20_Orland.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F20_Orland.png)'
- en: Figure 4.20 Picturing the vector sum of *z* = (2, 3) and *v* = (1, −1), *z*
    + *v* = (3, 2)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 描绘了向量 *z* = (2, 3) 和 *v* = (1, −1) 的和，*z* + *v* = (3, 2)
- en: 'Now let’s apply *S* to each of these: *S*(***u***) = (4, 9), *S*(***v***) =
    (1, 1), and *S*(***u*** + ***v***) = (9, 4). Figure 4.21 clearly shows that *S*(***u***)
    + *S*(***v***) does *not* agree with *S*(***u*** + ***v***).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 *S* 应用到这些向量上：*S*(***u***) = (4, 9)，*S*(***v***) = (1, 1)，以及 *S*(***u***
    + ***v***) = (9, 4)。图 4.21 清楚地显示 *S*(***u***) + *S*(***v***) 与 *S*(***u*** + ***v***)
    不一致。
- en: '![](../Images/CH04_F21_Orland.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F21_Orland.png)'
- en: Figure 4.21 S does not respect sums! S(*u*) + S(*v*) is far from S(*u + v*).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 S 不尊重和！S(*u*) + S(*v*) 与 S(*u + v*) 相去甚远。
- en: 'As an exercise, you can try to find a counterexample demonstrating that *S*
    does not preserve scalar multiples either. For now, let’s examine another transformation.
    Let *D*(***v***) be the vector transformation that scales the input vector by
    a factor of 2\. In other words, *D*(***v***) = 2***v***. This *does* preserve
    vector sums: if ***u*** + ***v*** = ***w***, then 2***u*** + 2***v*** = 2***w***
    as well. Figure 4.22 provides a visual example.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试找到一个反例来证明 *S* 也不保留标量乘法。现在，让我们检查另一个变换。设 *D*(***v***) 是将输入向量按因子 2 放大的向量变换。换句话说，*D*(***v***)
    = 2***v***。这确实保留了向量和：如果 ***u*** + ***v*** = ***w***，那么 2***u*** + 2***v*** 也等于
    2***w***。图 4.22 提供了一个视觉示例。
- en: '![](../Images/CH04_F22_Orland.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F22_Orland.png)'
- en: 'Figure 4.22 Doubling the lengths of vectors preserves their sums: if *z* +
    *v* = *w*, then *D*(*u*) + *D*(*v*) = *D*(*w*)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 向量的长度加倍保留了它们的和：如果 *z* + *v* = *w*，那么 *D*(*u*) + *D*(*v*) = *D*(*w*).
- en: Likewise, *D*(***v***) preserves scalar multiplication. This is a bit harder
    to draw, but you can see it algebraically. For any scalar *s*, *D*(*sv*) = 2(*sv*)
    = *s*(2*v*) = *sD*(*v*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，*D*(***v***) 保留了标量乘法。这有点难以绘制，但你可以从代数上看到这一点。对于任何标量 *s*，*D*(*sv*) = 2(*sv*)
    = *s*(2*v*) = *sD*(*v*).
- en: How about translation? Suppose *B*(***v***) translates any input vector ***v***
    by (7, 0). Surprisingly, this is *not* a linear transformation. Figure 4.23 provides
    a visual counterexample where ***u*** + ***v*** = ***w***, but *B*(***v***) +
    *B*(***w***) is not the same as *B*(***v*** + ***w***).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译呢？假设 *B*(***v***) 将任何输入向量 ***v*** 平移到 (7, 0)。令人惊讶的是，这 *不是* 一个线性变换。图 4.23 提供了一个视觉反例，其中
    ***u*** + ***v*** = ***w***，但 *B*(***v***) + *B*(***w***) 并不等于 *B*(***v*** + ***w***).
- en: '![](../Images/CH04_F23_Orland.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F23_Orland.png)'
- en: Figure 4.23 The translation transformation B does not preserve a vector sum
    because *B*(*u*) + *B*(*v*) is not equal to *B*(*u + v*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 平移变换 B 不保留向量和，因为 *B*(*u*) + *B*(*v*) 不等于 *B*(*u + v*).
- en: It turns out that for a transformation to be linear, it must not move the origin
    (see why as an exercise later). Translation by any non-zero vector transforms
    the origin, which ends up at a different point, so it cannot be linear.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，为了使一个变换成为线性变换，它必须不移动原点（为什么稍后作为练习说明）。任何非零向量的平移都会将原点移动到不同的点，因此它不能是线性的。
- en: Other examples of linear transformations include reflection, projection, shearing,
    and any 3D analogy of the preceding linear transformations. These are defined
    in the exercises section and you should convince yourself with several examples
    that each of these transformations preserves vector addition and scalar multiplication.
    With practice, you can recognize which transformations are linear and which are
    not. Next, we’ll look at why the special properties of linear transformations
    are useful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换的其他例子包括反射、投影、剪切以及前面线性变换的任何 3D 类比。这些在练习部分定义，你应该通过几个例子来确信每个这些变换都保持向量加法和标量乘法。通过练习，你可以识别出哪些变换是线性的，哪些不是。接下来，我们将探讨线性变换的特殊性质为什么有用。
- en: 4.2.3 Why linear transformations?
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 为什么是线性变换？
- en: Because linear transformations preserve vector sums and scalar multiples, they
    also preserve a broader class of vector arithmetic operations. The most general
    operation is called a *linear combination* . A linear combination of a collection
    of vectors is a sum of scalar multiples of them. For instance, one linear combination
    of two vectors ***u*** and ***v*** would be 3***u*** − 2***v***. Given three vectors
    ***u***, ***v***, and ***w*** *,* the expression 0.5*u* − *v* + 6 *w is a linear
    combination of* ***u*** *,* ***v*** *, and* ***w***. Because linear transformations
    preserve vector sums and scalar multiples, these preserve linear combinations
    as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于线性变换保持向量之和和标量乘积，它们也保持更广泛的向量算术运算类。最一般的运算称为 *线性组合*。向量集合的线性组合是它们的标量倍数之和。例如，两个向量
    ***u*** 和 ***v*** 的一个线性组合可以是 3***u*** − 2***v***。给定三个向量 ***u***、***v*** 和 ***w***，表达式
    0.5*u* − *v* + 6 *w 是 ***u***、***v*** 和 ***w*** 的线性组合。因为线性变换保持向量之和和标量乘积，所以它们也保持线性组合。
- en: 'We can restate this fact algebraically. If you have a collection of *n* vectors,
    ***v***[1], ***v***[2], ..., ***v*** *n*, as well as any choice of *n* scalars,
    *s*[1], *s*[2], *s*[3], ..., *s[n]*, a linear transformation *T* preserves the
    linear combination:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用代数方式重述这个事实。如果你有一组 *n* 个向量 ***v***[1]、***v***[2]、...、***v*** *n*，以及任何选择的
    *n* 个标量 *s*[1]、*s*[2]、*s*[3]、...、*s[n]*，线性变换 *T* 保持线性组合：
- en: '*T*(*s*[1] *v*[1] + *s*[2] *v*[2] + *s*[3] *v*[3] + ... + *s[n]v[n]*) = *s*[1]
    *T*(*v*[1]) + *s*[2] *T*(*v*[2]) + *s*[3] *T*(*v*[3]) + ... + *s[n]T*(*v[n]*)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(*s*[1] *v*[1] + *s*[2] *v*[2] + *s*[3] *v*[3] + ... + *s[n]v[n]*) = *s*[1]
    *T*(*v*[1]) + *s*[2] *T*(*v*[2]) + *s*[3] *T*(*v*[3]) + ... + *s[n]T*(*v[n]*)'
- en: One easy-to-picture linear combination we’ve seen before is ½ ***u*** + ½ ***v***
    *for vectors* ***u*** *and* ***v***, which is equivalent to ½ (***u*** + ***v***).
    Figure 4.24 shows that this linear combination of two vectors gives us the midpoint
    of the line segment connecting them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的一个容易理解的线性组合是向量 ***u*** 和 ***v*** 的 ½ ***u*** + ½ ***v***，这相当于 ½ (***u***
    + ***v***)。图 4.24 显示，这两个向量的这种线性组合给出了它们之间线段的中点。
- en: '![](../Images/CH04_F24_Orland.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F24_Orland.png)'
- en: Figure 4.24 The midpoint between the tips of two vectors *z* and *v* can be
    found as the linear combination ½ *z* + ½ *v* = ½ (*u + v*).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 两个向量 *z* 和 *v* 之间的中点可以表示为线性组合 ½ *z* + ½ *v* = ½ (*u + v*)。
- en: 'This means linear transformations send midpoints to other midpoints: for example,
    *T*(½ ***u*** + ½ ***v***) = ½ *T*(***u***) + ½ *T*(***v***), which is the midpoint
    of the segment connecting *T*(***u***) and *T*(***v***) as figure 4.25 shows.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着线性变换将中点映射到其他中点：例如，*T*(½ ***u*** + ½ ***v***) = ½ *T*(***u***) + ½ *T*(***v***)，如图
    4.25 所示，这是连接 *T*(***u***) 和 *T*(***v***) 的线段的中点。
- en: '![](../Images/CH04_F25_Orland.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F25_Orland.png)'
- en: Figure 4.25 Because the midpoint between two vectors is a linear combination
    of the vectors, the linear transformation T sets the midpoint between *z* and
    *v* to the midpoint between T(*u*) and T(*v*).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 因为两个向量之间的中点是向量的线性组合，线性变换 T 将 *z* 和 *v* 之间的中点设置为 T(*u*) 和 T(*v*) 之间的中点。
- en: It’s less obvious, but a linear combination like 0.25*u* + 0.75*v* also lies
    on the line segment between ***u*** and ***v*** (figure 4.26). Specifically, this
    is the point 75% of the way from ***u*** to ***v***. Likewise, 0.6*u* + 0.4*v*
    is 40% of the way from ***u*** to ***v***, and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点可能不太明显，但像 0.25*u* + 0.75*v* 这样的线性组合也位于 ***u*** 和 ***v*** 之间的线段上（图 4.26）。具体来说，这是从
    ***u*** 到 ***v*** 的 75% 处的点。同样，0.6*u* + 0.4*v* 是从 ***u*** 到 ***v*** 的 40% 处，以此类推。
- en: '![](../Images/CH04_F26_Orland.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F26_Orland.png)'
- en: Figure 4.26 The point 0.25*u* + 0.75*v* lies on the line segment connecting
    *z* and *v*, 75% of the way from *z* to *v*. You can see this concretely with
    *u* = (−2, 2) and *v* = (6, 6).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 点0.25*u* + 0.75*v*位于连接*z*和*v*的线段上，从*z*到*v*的75%。你可以通过*u* = (−2, 2)和*v*
    = (6, 6)具体地看到这一点。
- en: In fact, *every* point on the line segment between two vectors is a “weighted
    average” like this, having the form *su* + (1 − *s*)*v* for some number *s* between
    0 and 1\. To convince you, figure 4.27 shows the vectors *su* + (1 − *s*)*v* for
    ***u*** = (−1, 1) and ***v*** = (3, 4) for 10 values of *s* between 0 and 1 and
    then for 100 values of *s* between 0 and 1.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，两个向量之间的线段上的*每一个*点都是这样的“加权平均”，具有以下形式：*su* + (1 − *s*)*v*，其中*s*是介于0和1之间的某个数。为了让你信服，图4.27显示了***u***
    = (−1, 1)和***v*** = (3, 4)在0和1之间10个值和100个值的*s*的向量*su* + (1 − *s*)*v*。
- en: '![](../Images/CH04_F27a_Orland.png)![](../Images/CH04_F27b_Orland.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F27a_Orland.png)![图片](../Images/CH04_F27b_Orland.png)'
- en: Figure 4.27 Plotting various weighted averages of (−1, 1) and (3, 4) with 10
    values of s between 0 and 1 (left) and 100 values of s between 0 and 1 (right)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 以0到1之间10个值和100个值的*s*绘制(−1, 1)和(3, 4)的各种加权平均（左侧）和右侧）。
- en: The key idea here is that every point on a line segment connecting two vectors
    ***u*** and ***v*** is a weighted average and, therefore, a linear combination
    of points *u* and ***v***. With this in mind, we can think about what a linear
    transformation does to a whole line segment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键思想是，连接两个向量***u***和***v***的线段上的每一个点都是一个加权平均，因此是点*u*和***v***的线性组合。考虑到这一点，我们可以思考线性变换对整个线段的影响。
- en: Any point on the line segment connecting ***u*** and ***v*** is a weighted average
    of ***u*** and ***v***, so it has the form *s* · ***u*** + (1 − *s*) · ***v***
    for some value *s*. A linear transformation, *T*, transforms ***u*** and ***v***
    to some new vectors **T**(***u***) and **T**(***v***). The point on the line segment
    is transformed to some new point *T*(*s* · ***u*** + (1 − *s*) · ***v***) or *s*
    · *T*(***u***) + (1 − *s*) · *T*(***v***). This is, in turn, a weighted average
    of **T**(***u***) and **T**(***v***), so it is a point that lies on the segment
    connecting **T**(***u***) and **T**(***v***) as shown in figure 4.28.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 连接***u***和***v***的线段上的任意点都是***u***和***v***的加权平均，因此它具有以下形式：*s* · ***u*** + (1
    − *s*) · ***v***，其中*s*是某个值。线性变换*T*将***u***和***v***变换为一些新的向量**T**(***u***)和**T**(***v***)。线段上的点被变换为新的点*T*(*s*
    · ***u*** + (1 − *s*) · ***v***)或*s* · *T*(***u***) + (1 − *s*) · *T*(***v***)。这反过来又是一个**T**(***u***)和**T**(***v***)的加权平均，因此它是一个位于**T**(***u***)和**T**(***v***)连接线段上的点，如图4.28所示。
- en: '![](../Images/CH04_F28_Orland.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F28_Orland.png)'
- en: Figure 4.28 A linear transformation T transforms a weighted average of *z* and
    *v* to a weighted average of T(*u*) and T(*v*). The original weighted average
    lies on the segment connecting *z* and *v*, and the transformed one lies on the
    segment connecting T(*u*) and T(*v*).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 线性变换T将*z*和*v*的加权平均转换为T(*u*)和T(*v*)的加权平均。原始的加权平均位于连接*z*和*v*的线段上，变换后的加权平均位于连接T(*u*)和T(*v*)的线段上。
- en: 'Because of this, a linear transformation *T* takes every point on the line
    segment connecting ***u*** and ***v*** to a point on the line segment connecting
    **T**(***u***) and **T**(***v***). This is a key property of linear transformations:
    they send every existing line segment to a new line segment. Because our 3D models
    are made up of polygons and polygons are outlined by line segments, linear transformations
    can be expected to preserve the structure of our 3D models to some extent (figure
    4.29).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，线性变换*T*将连接***u***和***v***的线段上的每一个点变换为连接**T**(***u***)和**T**(***v***)的线段上的一个点。这是线性变换的一个关键特性：它们将每一个现有的线段映射到新的线段。因为我们的3D模型由多边形组成，而多边形由线段勾勒出来，所以线性变换可以在一定程度上保留我们的3D模型的结构（如图4.29所示）。
- en: '![](../Images/CH04_F29_Orland.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F29_Orland.png)'
- en: Figure 4.29 Applying a linear transformation (rotation by 60°) to points making
    up a triangle. The result is a rotated triangle (on the left).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 将组成三角形的点应用线性变换（旋转60°）。结果是旋转后的三角形（在左侧）。
- en: By contrast, if we use the non-linear transformation *S*(***v***) sending ***v***
    = (*x*, *y*) to (*x*², *y*²), we can see that line segments are distorted. This
    means that a triangle defined by vectors ***u***, ***v***, and ***w*** is not
    really sent to another triangle defined by *S*(***u***), *S*(***v***), and *S*(***w***)
    as shown in figure 4.30.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们使用非线性变换 *S*(***v***)，将 ***v*** = (*x*, *y*) 映射到 (*x*², *y*²)，我们可以看到线段被扭曲。这意味着由向量
    ***u***，***v*** 和 ***w*** 定义的三角形实际上并没有被映射到由 *S*(***u***)，*S*(***v***)，和 *S*(***w***)
    定义的另一个三角形，如图 4.30 所示。
- en: '![](../Images/CH04_F30_Orland.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F30_Orland.png)'
- en: Figure 4.30 Applying the non-linear transformation S does not preserve the straightness
    of edges of the triangle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH04_F30_Orland.png)'
- en: In summary, linear transformations respect the algebraic properties of vectors,
    preserving sums, scalar multiples, and linear combinations. They also respect
    the geometric properties of collections of vectors, sending line segments and
    polygons defined by vectors to new ones defined by the transformed vectors. Next,
    we’ll see that linear transformations are not only special from a geometric perspective;
    they’re also easy to compute.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，线性变换尊重向量的代数性质，保持和、标量乘积和线性组合。它们也尊重向量集合的几何性质，将向量定义的线段和多边形映射到由变换向量定义的新线段和多边形。接下来，我们将看到线性变换不仅在几何上特殊；它们也易于计算。
- en: 4.2.4 Computing linear transformations
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 计算线性变换
- en: 'In chapters 2 and 3, you saw how to break 2D and 3D vectors into components.
    For instance, the vector (4, 3, 5) can be decomposed as a sum (4, 0, 0) + (0,
    3, 0) + (0, 0, 5). This makes it easy to picture how far the vector extends in
    each of the three dimensions of the space that we’re in. We can decompose this
    even further into a linear combination (figure 4.31):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章和第 3 章中，你看到了如何将 2D 和 3D 向量分解成分量。例如，向量 (4, 3, 5) 可以分解为和 (4, 0, 0) + (0,
    3, 0) + (0, 0, 5)。这使得我们可以想象向量在我们所在空间的三个维度中延伸有多远。我们可以进一步将其分解为线性组合（图 4.31）：
- en: (4, 3, 5) = 4 · (1, 0, 0) + 3 · (0, 1, 0) + 5 · (0, 0, 1)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (4, 3, 5) = 4 · (1, 0, 0) + 3 · (0, 1, 0) + 5 · (0, 0, 1)
- en: '![](../Images/CH04_F31_Orland.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F31_Orland.png)'
- en: Figure 4.31 The 3D vector (4, 3, 5) as a linear combination of (1, 0, 0), (0,
    1, 0), and (0, 0, 1)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 3D 向量 (4, 3, 5) 是 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1) 的线性组合
- en: 'This might seem like a boring fact, but it’s one of the profound insights from
    linear algebra: any 3D vector can be decomposed into a linear combination of three
    vectors (1, 0, 0), (0, 1, 0), and (0, 0, 1). The scalars appearing in this decomposition
    for a vector ***v*** are exactly the coordinates of ***v***.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实可能看起来很无聊，但它是从线性代数中得出的深刻见解之一：任何 3D 向量都可以分解为三个向量 (1, 0, 0)，(0, 1, 0) 和 (0,
    0, 1) 的线性组合。在这个分解中出现的标量正好是向量 ***v*** 的坐标。
- en: The three vectors (1, 0, 0), (0, 1, 0), and (0, 0, 1) are called the *standard
    basis* for three-dimensional space. These are denoted ***e***[1], ***e***[2],
    and ***e***[3], so we could write the previous linear combination as (3, 4, 5)
    = 3 ***e***[1] + 4 ***e***[2] + 5 ***e***[3]. When we’re working in 2D space,
    we call ***e***[1] = (1, 0) and ***e***[2] = (0, 1); so, for example, (7, −4)
    = 7 ***e***[1] − 4 ***e***[2](figure 4.32). (When we say ***e***[1], we could
    mean (1, 0) or (1, 0, 0), but usually it’s clear which one we mean once we’ve
    established whether we’re working in two or three dimensions.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 三个向量 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1) 被称为三维空间的标准基。这些表示为 ***e***[1]，***e***[2]
    和 ***e***[3]，因此我们可以将之前的线性组合写成 (3, 4, 5) = 3 ***e***[1] + 4 ***e***[2] + 5 ***e***[3]。当我们工作在
    2D 空间时，我们称 ***e***[1] = (1, 0) 和 ***e***[2] = (0, 1)；例如，(7, −4) = 7 ***e***[1]
    − 4 ***e***[2](图 4.32)。(当我们说 ***e***[1] 时，我们可能指的是 (1, 0) 或 (1, 0, 0)，但一旦我们确定了我们在二维还是三维空间中工作，通常就可以清楚地知道我们指的是哪一个。)
- en: '![](../Images/CH04_F32_Orland.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F32_Orland.png)'
- en: Figure 4.32 The 2D vector (7, −4) as a linear combination of the standard basis
    vectors e1 and e2
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 2D 向量 (7, −4) 是标准基向量 e1 和 e2 的线性组合
- en: We’ve only written the same vectors in a slightly different way, but it turns
    out this change in perspective makes it easy to compute linear transformations.
    Because linear transformations respect linear combinations, all we need to know
    to compute a linear transformation is how it affects standard basis vectors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是以稍微不同的方式写下了相同的向量，但结果证明这种视角的改变使得计算线性变换变得容易。因为线性变换尊重线性组合，所以我们只需要知道线性变换如何影响标准基向量。
- en: Let’s look at a visual example (figure 4.33). Say we know nothing about a 2D
    vector transformation *T* except that it is linear and we know what *T*(***e***[1])
    and *T*(***e***[2]) are.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个视觉示例（图4.33）。假设我们对二维向量变换 *T* 一无所知，除了它具有线性性质，并且我们知道 *T*(***e***[1]) 和 *T*(***e***[2])
    是什么。
- en: '![](../Images/CH04_F33_Orland.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F33_Orland.png)'
- en: Figure 4.33 When a linear transformation acts on the two standard basis vectors
    in 2D, we get two new vectors as a result.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33 当线性变换作用于二维中的两个标准基向量时，我们得到两个新的向量作为结果。
- en: 'For any other vector ***v***, we automatically know where *T*(***v***) ends
    up. Say ***v*** = (3, 2), then we can assert:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何其他向量 ***v***，我们自动知道 *T*(***v***) 最终会落在何处。假设 ***v*** = (3, 2)，那么我们可以断言：
- en: '*T*(***v***) = *T*(3e[1] + 2e[2]) = 3*T*(e[1]) + 2*T*(e[2])'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(***v***) = *T*(3e[1] + 2e[2]) = 3*T*(e[1]) + 2*T*(e[2])'
- en: Because we already know where *T*(***e***[1]) and *T*(***e***[2]) are, we can
    locate *T*(***v***) as shown in figure 4.34.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经知道 *T*(***e***[1]) 和 *T*(***e***[2]) 的位置，我们可以根据图4.34定位 *T*(***v***)。
- en: '![](../Images/CH04_F34_Orland.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F34_Orland.png)'
- en: Figure 4.34 We can compute T(*v*) for any vector *v* as a linear combination
    of T(e1) and T(e2).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34 我们可以计算 T(*v*) 为 T(e1) 和 T(e2) 的线性组合。
- en: 'To make this more concrete, let’s do a complete example in 3D. Say *a* is a
    linear transformation, and all we know about *a* is that *a*(***e***[1]) = (1,
    1, 1), *a*(***e***[2]) = (1, 0, −1), and *a*(***e***[3]) = (0, 1, 1). If ***v***
    = (−1, 2, 2), what is *a*(***v***)? Well, first we can expand ***v*** as a linear
    combination of the three standard basis vectors. Because ***v*** = (−1, 2, 2)
    = ***−e***[1] + 2***e***[2] + 2***e***[3], we can make the substitution:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个问题更具体，让我们在三维空间中做一个完整的例子。假设 *a* 是一个线性变换，我们只知道 *a*(***e***[1]) = (1, 1, 1)，*a*(***e***[2])
    = (1, 0, −1)，和 *a*(***e***[3]) = (0, 1, 1)。如果 ***v*** = (−1, 2, 2)，那么 *a*(***v***)
    是什么？首先，我们可以将 ***v*** 展开为三个标准基向量的线性组合。因为 ***v*** = (−1, 2, 2) = ***−e***[1] + 2***e***[2]
    + 2***e***[3]，我们可以进行替换：
- en: '*a*(*v*) = *a*(−e[1] + 2e[2] + 2e[3])'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*(*v*) = *a*(−e[1] + 2e[2] + 2e[3])'
- en: 'Next, we can use the fact that *a* is linear and preserves linear combinations:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以利用 *a* 是线性且保持线性组合的事实：
- en: = − *a*(e[1]) + 2*a*(e[2]) + 2*a*(e[3])
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: = − *a*(e[1]) + 2*a*(e[2]) + 2*a*(e[3])
- en: 'Finally, we can substitute in the known values of *a*(***e***[1]), *a*(***e***[2]),
    and *a*(***e***[3]), and simplify:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以代入已知的 *a*(***e***[1])、*a*(***e***[2]) 和 *a*(***e***[3]) 的值，并进行简化：
- en: = − (1, 1, 1) + 2 · (1, 0, −1) + 2 · (0, 1, 1)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: = − (1, 1, 1) + 2 · (1, 0, −1) + 2 · (0, 1, 1)
- en: = (1, 1, −1)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: = (1, 1, −1)
- en: 'As proof we really know how *a* works, we can apply it to the teapot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们确实知道 *a* 如何工作，我们可以将其应用于茶壶：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ The known results of applying A to the standard basis vectors
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用 A 到标准基向量的已知结果
- en: ❷ Builds a function apply_A(*v*) that returns the result of A on the input vector
    v
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建一个函数 apply_A(*v*)，它返回 A 对输入向量 v 的作用结果
- en: ❸ The result should be a linear combination of these vectors, where the scalars
    are taken to be the coordinates of the target vector v.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 结果应该是这些向量的线性组合，其中标量是目标向量 v 的坐标。
- en: ❹ Uses polygon_map to apply A to every vector of every triangle in the teapot
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 polygon_map 将 A 应用到茶壶中每个三角形的每个向量上
- en: Figure 4.35 shows the result of this transformation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35显示了这次变换的结果。
- en: '![](../Images/CH04_F35_Orland.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F35_Orland.png)'
- en: Figure 4.35 In this rotated, skewed configuration, we see that the teapot does
    not have a bottom!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35 在这个旋转、倾斜的配置中，我们看到茶壶没有底部！
- en: The takeaway here is that a 2D linear transformation *T* is defined completely
    by the values of *T*(***e***[1]) and *T*(***e***[2]); that’s two vectors or four
    numbers in total. Likewise, a 3D linear transformation *T* is defined completely
    by the values of *T*(***e***[1]), *T*(***e***[2]), and *T*(***e***[3]), which
    are three vectors or nine numbers in total. In any number of dimensions, the behavior
    of a linear transformation is specified by a list of vectors or an array-of-arrays
    of numbers. Such an array-of-arrays is called a *matrix*, and we’ll see how to
    use matrices in the next chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，二维线性变换 *T* 完全由 *T*(***e***[1]) 和 *T*(***e***[2]) 的值定义；总共是两个向量或四个数字。同样，三维线性变换
    *T* 完全由 *T*(***e***[1])、*T*(***e***[2]) 和 *T*(***e***[3]) 的值定义，总共是三个向量或九个数字。在任何数量的维度中，线性变换的行为由向量列表或数字的数组-数组指定。这种数组-数组称为
    *矩阵*，我们将在下一章中看到如何使用矩阵。
- en: 4.2.5 Exercises
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 练习
- en: '| **Exercise 4.10**: Considering *S* again, the vector transformation that
    squares all coordinates, show algebraically that *S*(*s**v***) = *sS*(*v*) does
    not hold for all choices of scalars *s* and 2D vectors ***v***.**Solution**: Let
    ***v*** = (*x*, *y*). Then *s* *v* = (*sx*, *sy*) and *S*(*s**v***) = (*s*² *x*²,
    *s*² *y*²) = *s*² · (*x*², *y*²) = *s*² · *S*(***v***). For most values of *s*
    and most vectors ***v***, *S*(*s**v***) = *s*² · *S*(*v*) won’t equal *s* · *S*(***v***).
    A specific counterexample is *s* = 2 and ***v*** = (1, 1, 1), where *S*(*s**v***)
    = (4, 4, 4) while *s* · *S*(***v***) = (2, 2, 2). This counterexample shows that
    *S* is not linear. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.10**: 再次考虑 *S*，即平方所有坐标的向量变换，通过代数证明对于所有选择的标量 *s* 和 2D 向量 ***v***，*S*(*s**v***)
    = *sS*(*v*) 不成立。***解答***：设 ***v*** = (*x*, *y*)。那么 *s* *v* = (*sx*, *sy*)，且 *S*(*s**v***)
    = (*s*² *x*², *s*² *y*²) = *s*² · (*x*², *y*²) = *s*² · *S*(***v***)。对于大多数 *s*
    值和大多数向量 ***v***，*S*(*s**v***) = *s*² · *S*(*v*) 不会等于 *s* · *S*(***v***)。一个具体的反例是
    *s* = 2 和 ***v*** = (1, 1, 1)，其中 *S*(*s**v***) = (4, 4, 4) 而 *s* · *S*(***v***)
    = (2, 2, 2)。这个反例表明 *S* 不是线性的。|'
- en: '| **Exercise 4.11**: Suppose *T* is a vector transformation and *T*(**0**)
    ≠ 0, where **0** represents the vector with all coordinates equal to zero. Why
    is *T* not linear according to the definition?**Solution**: For any vector ***v***,
    ***v*** + **0** = ***v***. For *T* to preserve vector addition, it should be that
    *T*(*v* + **0**) = *T*(*v*) + *T*(0). Because *T*(*v* + **0**) = *T*(*v*), this
    requires that *T*(*v*) = *T*(*v*) + *T*(**0**) or **0** = *T*(**0**). Given that
    this is not the case, *T* cannot be linear. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.11**: 假设 *T* 是一个向量变换，且 *T*(**0**) ≠ 0，其中 **0** 代表所有坐标都等于零的向量。为什么根据定义，*T*
    不是线性的？***解答***：对于任何向量 ***v***，***v*** + **0** = ***v***。为了保持向量加法，*T* 应该满足 *T*(*v*
    + **0**) = *T*(*v*) + *T*(0)。因为 *T*(*v* + **0**) = *T*(*v*)，这要求 *T*(*v*) = *T*(*v*)
    + *T*(**0**) 或 **0** = *T*(**0**)。鉴于这种情况并不成立，*T* 不能是线性的。|'
- en: '| **Exercise 4.12**: The *identity transformation* is the vector transformation
    that returns the same vector it is passed. It is denoted with a capital *I*, so
    we could write its definition as *I*(***v***) = ***v*** for all vectors ***v***.
    Explain why *I* is a linear transformation.**Solution**: For any vectors ***v***
    and ***w***, *I*(v + w) = *v* + *w* = *I*(*v*) + *I*(*w*), and for any scalar
    *s*, *I*(*s**v***) = *s* *v* = *s* · *I*(*v*). These equalities show that the
    identity transformation preserves vector sums and scalar multiples. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.12**: **恒等变换**是返回相同向量的向量变换。它用大写 *I* 表示，因此我们可以将其定义写为 *I*(***v***) =
    ***v*** 对于所有向量 ***v***。解释为什么 *I* 是一个线性变换。***解答***：对于任何向量 ***v*** 和 ***w***，*I*(v
    + w) = *v* + *w* = *I*(*v*) + *I*(*w*)，对于任何标量 *s*，*I*(*s**v***) = *s* *v* = *s*
    · *I*(*v*)。这些等式表明恒等变换保持了向量加法和标量乘法。|'
- en: '| **Exercise 4.13**: What is the midpoint between (5, 3) and (−2, 1)? Plot
    all three of these points to see that you are correct.**Solution**: The midpoint
    is ½ (5, 3) + ½ (−2, 1) or (5/2, 3/2) + (−1, ½), which equals (3/2, 2). This is
    seen to be correct when drawn to scale in the diagram that follows:![](../Images/CH04_F35_Orland_UN06.png)The
    midpoint of the segment connecting (5, 3) and (−2, 1) is (3/2, 2). |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.13**: (5, 3) 和 (−2, 1) 之间的中点是什么？绘制这三个点以验证你的答案。***解答***：中点是 ½ (5, 3)
    + ½ (−2, 1) 或 (5/2, 3/2) + (−1, ½)，等于 (3/2, 2)。这在以下按比例绘制的图中可以验证：![](../Images/CH04_F35_Orland_UN06.png)连接
    (5, 3) 和 (−2, 1) 的线段的中点是 (3/2, 2)。|'
- en: '| **Exercise 4.14**: Consider again the non-linear transformation *S*(***v***)
    sending ***v*** = (*x*, *y*) to (*x², y²). Plot all 36 vectors **v** with integer
    coordinates 0 to 5 as points using the drawing code from chapter 2 and then plot
    S(**v**) for each of them. What happens geometrically to vectors under the action
    of S ?***Solution**: The space between points is uniform to begin with, but in
    the transformed picture, the spacing increases in the horizontal and vertical
    directions as the *x* − and *y*-coordinates increase, respectively.![](../Images/CH04_F35_Orland_UN07a.png) ![](../Images/CH04_F35_Orland_UN07b.png)
    The grid of points is initially uniformly spaced, but after applying the transformation
    S, the spacing varies between points, even on the same lines. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.14**: 再次考虑非线性变换 *S*(***v***)，它将 ***v*** = (*x*, *y*) 映射到 (*x², y²)。使用第
    2 章中的绘图代码，将所有坐标为 0 到 5 的 36 个向量 **v** 作为点绘制出来，然后为每个点绘制 S(**v**)。在 S 的作用下，向量在几何上会发生什么变化？***解答***：最初点之间的空间是均匀的，但在变换后的图像中，随着
    *x* 和 *y* 坐标的增加，水平方向和垂直方向上的间距分别增加。![](../Images/CH04_F35_Orland_UN07a.png) ![](../Images/CH04_F35_Orland_UN07b.png)
    点的网格最初是均匀分布的，但在应用变换 S 之后，点之间的间距发生变化，甚至在同一直线上也是如此。|'
- en: '| **Exercise 4.15-Mini Project**: *Property-based testing* is a type of unit
    testing that involves inventing arbitrary input data for a program and then checking
    that the outputs satisfy desired conditions. There are popular Python libraries
    like Hypothesis (available through pip) that make it easy to set this up. Using
    your library of choice, implement property-based tests that check if a vector
    transformation is linear.Specifically, given a vector transformation *T* implemented
    as a Python function, generate a large number of pairs of random vectors and assert
    for all of those that their sum is preserved by *T*. Then, do the same thing for
    pairs of a scalar and a vector, and ensure that *T* preserves scalar multiples.
    You should find that linear transformations like `rotate_x_by(pi/2)` pass the
    test, but non-linear transformations like the coordinate-squaring transformation
    do not pass. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.15-迷你项目**: *基于属性的测试*是一种单元测试，它涉及为程序发明任意输入数据，然后检查输出是否满足期望条件。有像 Hypothesis（通过
    pip 可用）这样的流行 Python 库，可以轻松设置此功能。使用您选择的库，实现基于属性的测试，检查向量变换是否线性。具体来说，给定一个作为 Python
    函数实现的向量变换 *T*，生成大量随机向量的成对，并断言所有这些向量在 *T* 下都保持其和。然后，对标量和向量的成对做同样的事情，并确保 *T* 保持标量倍数。你应该会发现像
    `rotate_x_by(pi/2)` 这样的线性变换可以通过测试，但像坐标平方变换这样的非线性变换则不能通过。|'
- en: '| **Exercise 4.16**: One 2D vector transformation is *reflection* across the
    *x* -axis. This transformation takes a vector and returns another one, which is
    the mirror image with respect to the x-axis. Its *x*-coordinate should be unchanged,
    and its *y*-coordinate should change its sign. Denoting this transformation *S[x]*,
    here is an image of a vector ***v*** = (3, 2) and the transformed vector *S[x]*(*v*).![](../Images/CH04_F35_Orland_UN08.png)A
    vector *v* = (3, 2) and its reflection over the x-axis (3, −2)Draw two vectors
    and their sum, as well as the reflection of these three vectors to demonstrate
    that this transformation preserves vector addition. Draw another diagram to show
    similarly that scalar multiplication is preserved, thereby demonstrating both
    criteria for linearity. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **练习 4.16**: 一个 2D 向量变换是沿 *x* 轴的 *反射*。这种变换将一个向量转换成另一个向量，它是相对于 x 轴的镜像。它的 *x*
    坐标应该保持不变，而它的 *y* 坐标应该改变其符号。表示这个变换为 *S[x]*，下面是一个向量 ***v*** = (3, 2) 和变换后的向量 *S[x]*(*v*)
    的图像。![](../Images/CH04_F35_Orland_UN08.png)向量 *v* = (3, 2) 和它在 x 轴上的反射 (3, −2)画两个向量及其和，以及这三个向量的反射，以证明这个变换保持向量加法。再画一个图，以类似的方式展示标量乘法也得到保持，从而证明线性性的两个标准。|'
- en: '| **Solution**: Here’s an example of reflection over the x-axis that preserves
    a vector sum:![](../Images/CH04_F35_Orland_UN09.png)For *z* + *v* = *w* as shown,
    reflection over the x-axis preserves the sum; that is, *S[x]*(*u*) + *S[x]*(*v*)
    = *S[x]*(*w*).Here’s an example showing reflection preserving a scalar multiple:
    *S[x]*(*s**v***) lies where *sS[x]*(*v*) is expected to be.To *prove* that *S[x]*
    is linear, you would need to show that you can draw analogous pictures for every
    vector sum and every scalar multiple. There are infinitely many of these, so it’s
    better to use an algebraic proof. (Can you figure out how to show these two facts
    algebraically?)![](../Images/CH04_F35_Orland_UN10.png)Reflection across the x-axis
    preserves this scalar multiple. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **解答**: 下面是一个关于 x 轴反射保持向量和的例子！[](../Images/CH04_F35_Orland_UN09.png)对于 *z*
    + *v* = *w* 如所示，x 轴反射保持和；也就是说，*S[x]*(*u*) + *S[x]*(*v*) = *S[x]*(*w*)。下面是一个显示反射保持标量倍的例子：*S[x]*(*s**v***)位于预期
    *sS[x]*(*v*) 应该出现的位置。为了 *证明* *S[x]* 是线性的，你需要展示你可以为每个向量之和和每个标量倍数绘制类似的图像。这些有无限多个，所以最好使用代数证明。（你能想出如何代数地展示这两个事实吗？）！[](../Images/CH04_F35_Orland_UN10.png)x
    轴反射保持这个标量倍数。|'
- en: '| **Exercise 4.17-Mini Project**: Suppose *S* and *T* are both linear transformations.
    Explain why the composition of *S* and *T* is also linear.**Solution**: The composition
    *S*(*T*(*v*)) is linear if for any vector sum ***u*** + ***v*** = ***w***, we
    have *S*(*T*(*u*)) + *S*(*T*(*v*)) = *S*(*T*(*w*)), and for any scalar multiple
    *s* *v*, we have *S*(*T*(*s**v***)) = *s* · *S*(*T*(*v*)). This is only a statement
    of the definition that must be satisfied.Now let’s see why it’s true. Suppose
    first that ***u*** + ***v*** = ***w*** for any given input vectors ***u*** and
    ***v***. Then by the linearity of *T*, we also know that *T*(*u*) + *T*(*v*) =
    *T*(*w*). Because this sum holds, the linearity of *S* tells us that the sum is
    preserved under *S* : *S*(*T*(*u*)) + *S*(*T*(*v*)) = *S*(*T*(*w*)). That means
    that *S*(*T*(*v*)) preserves vector sums.Similarly, for any scalar multiple *s*
    *v*, the linearity of *T* tells us that *s* · *T*(*v*) = *T*(*s**v***). By linearity
    of *S*, *s* · *S*(*T*(*v*)) = *S*(*T*(*s**v***)) as well. This means *S*(*T*(*v*))
    preserves scalar multiplication and, therefore, that *S*(*T*(*v*)) satisfies the
    full definition of linearity as previously stated. We can conclude that the composition
    of two linear transformations is linear. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **练习4.17-迷你项目**：假设*S*和*T*都是线性变换。解释为什么*S*和*T*的复合也是线性的。**解答**：如果对于任何向量之和***u***
    + ***v*** = ***w***，我们有*S*(*T*(*u*)) + *S*(*T*(*v*)) = *S*(*T*(*w*))，并且对于任何标量乘积*s*
    *v*，我们有*S*(*T*(*s**v***)) = *s* · *S*(*T*(*v*))，那么复合*S*(*T*(*v*))是线性的。这是一个必须满足的定义的陈述。现在让我们看看为什么它是正确的。首先假设对于任何给定的输入向量***u***和***v***，***u***
    + ***v*** = ***w***。那么根据*T*的线性，我们也知道*T*(*u*) + *T*(*v*) = *T*(*w*)。因为这个和成立，*S*的线性告诉我们这个和在*S*下得到保留：*S*(*T*(*u*))
    + *S*(*T*(*v*)) = *S*(*T*(*w*))。这意味着*S*(*T*(*v*))保留了向量之和。同样，对于任何标量乘积*s* *v*，*T*的线性告诉我们*s*
    · *T*(*v*) = *T*(*s**v***)。根据*S*的线性，*s* · *S*(*T*(*v*)) = *S*(*T*(*s**v***))同样成立。这意味着*S*(*T*(*v*))保留了标量乘法，因此*S*(*T*(*v*))满足之前所述的线性定义的完整定义。我们可以得出结论，两个线性变换的复合是线性的。
    |'
- en: '| **Exercise 4.18**: Let *T* be the linear transformation done by the Python
    function `rotate_x_by(pi/2)`, what are *T*(***e***[1]), *T*(***e***[2]), and *T*(***e***[3])?**Solution**:
    Any rotation about an axis leaves points on the axis unaffected, so because *T*(***e***[1])
    is on the x-axis, *T*(***e***[1]) = ***e***[1] = (1, 0, 0). A counterclockwise
    rotation of ***e***[2] = (0, 1, 0) in the *y*,*z* plane takes this vector from
    the point one unit in thepositive *y* direction to the point one unit in the positive
    *z* direction, so *T*(***e***[2]) = ***e***[3] = (0, 0, 1). Likewise, ***e***[3]
    is rotated counterclockwise from the positive *z* direction to the negative *y*
    direction. *T*(***e***[3]) still has length one in this direction, so it is -***e***[2]
    or (0, −1, 0).![](../Images/CH04_F35_Orland_UN11.png)A quarter-turn counterclockwise
    in the y,z plane sends *e*[2] to *e*[3] and *e*[3] to − *e*[2]. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **练习4.18**：设*T*是由Python函数`rotate_x_by(pi/2)`执行的线性变换，*T*(***e***[1])，*T*(***e***[2])和*T*(***e***[3])是什么？**解答**：任何绕轴的旋转都不会影响轴上的点，因此因为*T*(***e***[1])位于x轴上，所以*T*(***e***[1])
    = ***e***[1] = (1, 0, 0)。在*y*，*z*平面内逆时针旋转***e***[2] = (0, 1, 0)将这个向量从正*y*方向的一个单位点旋转到正*z*方向的一个单位点，所以*T*(***e***[2])
    = ***e***[3] = (0, 0, 1)。同样，***e***[3]从正*z*方向逆时针旋转到负*y*方向。*T*(***e***[3])在这个方向上的长度仍然为1，所以它是-***e***[2]或(0,
    −1, 0)。![](../Images/CH04_F35_Orland_UN11.png)在y,z平面内逆时针旋转90度将*e*[2]发送到*e*[3]，将*e*[3]发送到-
    *e*[2]。 |'
- en: '| **Exercise 4.19**: Write a `linear_combination(scalars,` `*vectors)` that
    takes a list of scalars and the same number of vectors, and returns a single vector.
    For example, `linear_combination([1,2,3],` `(1,0,0),` `(0,1,0),` `(0,0, 1))` should
    return 1 · (1, 0, 0) + 2 · (0, 1, 0) + 3 · (0, 0, 1) or (1, 2, 3).**Solution**:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习4.19**：编写一个`linear_combination(scalars, *vectors)`函数，它接受一个标量列表和相同数量的向量，并返回一个单个向量。例如，`linear_combination([1,2,3],
    (1,0,0), (0,1,0), (0,0, 1))`应该返回1 · (1, 0, 0) + 2 · (0, 1, 0) + 3 · (0, 0, 1)或(1,
    2, 3)。**解答**：'
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can confirm this gives the expected result as previously described:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认这给出了之前描述的预期结果：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 4.20**: Write a function `transform_standard_basis(transform)`
    that takes a 3D vector transformation as an input and outputs the effect it has
    on the standard basis. It should output a tuple of 3 vectors that are the results
    of `transform` acting on ***e***[1], ***e***[2], and ***e***[3], respectively.**Solution**:
    As suggested, we just need to apply `transform` to each standard basis vector:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习4.20**：编写一个函数`transform_standard_basis(transform)`，它接受一个3D向量变换作为输入，并输出它对标准基的影响。它应该输出一个包含3个向量的元组，这些向量分别是`transform`作用于***e***[1]，***e***[2]和***e***[3]的结果。**解答**：正如建议的那样，我们只需要将`transform`应用于每个标准基向量：'
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It confirms (within the floating-point error) our solution to a previous exercise,
    where we sought this output for `rotate_x_by(pi/2)` :'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它在浮点误差范围内确认了我们之前练习中的解决方案，其中我们寻求`rotate_x_by(pi/2)`的输出：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These vectors are approximately (1, 0, 0), (0, 0, 1), and (0, −1, 0). |
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些向量大约是（1, 0, 0），（0, 0, 1），和（0, −1, 0）。|
- en: '| **Exercise 4.21**: Suppose *B* is a linear transformation, with *B*(***e***[1])
    = (0, 0, 1), *B*(***e***[2]) = (2, 1, 0), *B*(***e***[3]) = (−1, 0, −1), and ***v***
    = (−1, 1, 2). What is *B*(***v***)?**Solution**: Because ***v*** = (−1, 1, 2)
    = -***e***[1] + ***e***[2] + 2***e***[3], *B*(***v***) = *B*(−***e***[1] + ***e***[2]
    + 2***e***[3]). Because *B* is linear, it preserves this linear combination: *B*(***v***)
    = − *B*(***e***[1]) + *B*(***e***[2]) + 2 · *B*(***e***[3]). Now we have all the
    information we need: *B*(***v***) = −(0, 0, 1) + (2, 1, 0) + 2 · (−1, 0, −1) =
    (0, 1, −3). |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **练习4.21**：假设 *B* 是一个线性变换，其中 *B*(***e***[1]) = (0, 0, 1)，*B*(***e***[2])
    = (2, 1, 0)，*B*(***e***[3]) = (−1, 0, −1)，并且 ***v*** = (−1, 1, 2)。*B*(***v***)是什么？**解答**：因为
    ***v*** = (−1, 1, 2) = -***e***[1] + ***e***[2] + 2***e***[3]，所以 *B*(***v***)
    = *B*(−***e***[1] + ***e***[2] + 2***e***[3])。因为 *B* 是线性的，它保持这种线性组合：*B*(***v***)
    = − *B*(***e***[1]) + *B*(***e***[2]) + 2 · *B*(***e***[3])。现在我们有了所有需要的信息：*B*(***v***)
    = −(0, 0, 1) + (2, 1, 0) + 2 · (−1, 0, −1) = (0, 1, −3)。|'
- en: '| **Exercise 4.22**: Suppose *a* and *B* are both linear transformations with
    *a*(***e***[1]) = (1, 1, 1), *a*(***e***[2]) = (1, 0, −1), and *a*(***e***[3])
    = (0, 1, 1), and *B*(***e***[1]) = (0, 0, 1), *B*(***e***[2]) = (2, 1, 0), and
    *B*(***e***[3]) = (−1, 0, −1). What is *a*(*B*(***e***[1])), *a*(*B*(***e***[2])),
    and *a*(*B*(***e***[3]))?**Solution**: *a*(*B*(***e***[1])) is *a* applied to
    *B*(***e***[1]) = (0, 0, 1) = ***e***[3]. We already know *a*(***e***[3]) = (0,
    1, 1), so *B*(*a*(***e***[1])) = (0, 1, 1).*a*(*B*(***e***[2])) is *a* applied
    to *B*(***e***[2]) = (2, 1, 0). This is a linear combination of *a*(***e***[1]),
    *a*(***e***[2]), and *a*(***e***[3]) with scalars (2, 1, 0): 2 · (1, 1, 1) + 1
    · (1, 0, −1) + 0 · (0, 1, 1) = (3, 2, 1).Finally, *a*(*B*(***e***[3])) is *a*
    applied to *B*(***e***[3]) = (−1, 0, −1). This is the linear combination −1 ·
    (1, 1, 1) + 0 · (1, 0, −1) + −1 · (0, 1, 1) = (−1, −2, −2).Note that now we know
    the result of the composition of *a* and *B* for all of the standard basis vectors,
    so we can calculate *a*(*B*(***v***)) for any vector ***v***. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **练习4.22**：假设 *a* 和 *B* 都是线性变换，其中 *a*(***e***[1]) = (1, 1, 1)，*a*(***e***[2])
    = (1, 0, −1)，*a*(***e***[3]) = (0, 1, 1)，和 *B*(***e***[1]) = (0, 0, 1)，*B*(***e***[2])
    = (2, 1, 0)，*B*(***e***[3]) = (−1, 0, −1)。*a*(*B*(***e***[1])), *a*(*B*(***e***[2])),
    和 *a*(*B*(***e***[3]))是什么？**解答**：*a*(*B*(***e***[1]))是*a*应用于*B*(***e***[1]) =
    (0, 0, 1) = ***e***[3]。我们已知*a*(***e***[3]) = (0, 1, 1)，所以*B*(*a*(***e***[1]))
    = (0, 1, 1)。*a*(*B*(***e***[2]))是*a*应用于*B*(***e***[2]) = (2, 1, 0)。这是*a*(***e***[1]),
    *a*(***e***[2]), 和 *a*(***e***[3])的线性组合，标量是(2, 1, 0)：2 · (1, 1, 1) + 1 · (1, 0,
    −1) + 0 · (0, 1, 1) = (3, 2, 1)。最后，*a*(*B*(***e***[3]))是*a*应用于*B*(***e***[3])
    = (−1, 0, −1)。这是线性组合−1 · (1, 1, 1) + 0 · (1, 0, −1) + −1 · (0, 1, 1) = (−1, −2,
    −2)。注意，现在我们知道了*a*和*B*对所有标准基向量的组合结果，因此我们可以计算*a*(*B*(***v***))对于任何向量***v***。|'
- en: Linear transformations are both well-behaved and easy-to-compute because these
    can be specified with so little data. We explore this more in the next chapter
    when we compute linear transformations with *matrix* notation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换因为所需数据很少，所以既表现良好又易于计算。我们将在下一章中更深入地探讨这一点，届时我们将使用**矩阵**符号来计算线性变换。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Vector transformations are functions that take vectors as inputs and return
    vectors as outputs. Vector transformations can operate on 2D or 3D vectors.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量变换是接受向量作为输入并返回向量作为输出的函数。向量变换可以作用于2D或3D向量。
- en: To effect a geometric transformation of the model, apply a vector transformation
    to every vertex of every polygon of a 3D model.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对模型进行几何变换，将向量变换应用于3D模型中每个多边形的每个顶点。
- en: You can combine existing vector transformations by composition of functions
    to create new transformations, which are equivalent to applying the existing vector
    transformations sequentially.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过函数的组合来组合现有的向量变换，以创建新的变换，这些变换相当于依次应用现有的向量变换。
- en: Functional programming is a programming paradigm that emphasizes composing and,
    otherwise, manipulating functions.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程是一种强调函数组合和操作的编程范式。
- en: The functional operation of currying turns a function that takes multiple arguments
    into a function that takes one argument and returns a new function. Currying lets
    you turn existing Python functions (like `scale` and `add`) into vector transformations.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化（currying）的功能操作将接受多个参数的函数转换为一个接受一个参数并返回一个新函数的函数。柯里化允许你将现有的Python函数（如`scale`和`add`）转换为向量变换。
- en: Linear transformations are vector transformations that preserve vector sums
    and scalar multiples. In particular, points lying on a line segment still lie
    on a line segment after a linear transformation is applied.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性变换是向量变换，它们保持向量之和和标量乘积。特别是，在应用线性变换后，位于线段上的点仍然位于线段上。
- en: A linear combination is the most general combination of scalar multiplication
    and vector addition. Every 3D vector is a linear combination of the 3D standard
    basis vectors, which are denoted ***e***[1] = (1, 0, 0), ***e***[2] = (0, 1, 0),
    and ***e***[3] = (0, 0, 1). Likewise, every 2D vector is a linear combination
    of the 2D standard basis vectors, which are ***e***[1] = (1, 0) and ***e***[2]
    = (0, 1).
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性组合是标量乘法和向量加法最一般的组合。每一个三维向量都是三维标准基向量的线性组合，这些标准基向量表示为***e***[1] = (1, 0, 0)，***e***[2]
    = (0, 1, 0)，和***e***[3] = (0, 0, 1)。同样，每一个二维向量都是二维标准基向量的线性组合，这些标准基向量表示为***e***[1]
    = (1, 0)和***e***[2] = (0, 1)。
- en: Once you know how a given linear transformation acts on the standard basis vectors,
    you can determine how it acts on any vector by writing the vector as a linear
    combination of the standard basis and using the fact that linear combinations
    are preserved.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你知道一个给定的线性变换如何作用于标准基向量，你就可以通过将向量表示为标准基的线性组合，并利用线性组合的性质来决定它对任何向量如何作用。
- en: In 3D, three vectors or nine total numbers specify a linear transformation.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在三维空间中，三个向量或九个总数可以指定一个线性变换。
- en: In 2D, two vectors or four total numbers do the same.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在二维空间中，两个向量或四个总数执行相同的操作。
- en: 'This last point is critical: linear transformations are both well-behaved and
    easy-to-compute with because they can be specified with so little data.'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后这一点至关重要：线性变换因为只需要很少的数据就能被指定，所以它们既表现良好又易于计算。
