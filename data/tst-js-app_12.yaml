- en: 10 UI-based end-to-end testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 基于UI的端到端测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: UI and end-to-end tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI和端到端测试
- en: When to write each type of test
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时编写每种类型的测试
- en: The business impact of end-to-end tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试的商业影响
- en: An overview of multiple UI-based end-to-end testing tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种基于UI的端到端测试工具概述
- en: Sublime pieces of sugary treats can take a bakery a long way. Excellent customer
    service, beautifully decorated tables, and breathtaking views take it even further.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 优质的甜点可以给面包店带来长足的发展。卓越的客户服务、精美的装饰桌子和令人叹为观止的景色可以更进一步。
- en: For customers to be enchanted, their experience must be flawless from the moment
    they step in to the moment they decide to leave, hopefully, wanting to come back.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让顾客着迷，他们的体验必须从他们踏入的那一刻起，到他们决定离开的那一刻，希望他们愿意再次回来，都是无懈可击的。
- en: No matter how good a pastry chef’s desserts are, if their bakery looks dirty,
    no one will come in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论糕点师制作的甜点有多好，如果他们的面包店看起来很脏，没有人会进来。
- en: Building delightful software involves a similar amount of care and attention
    to detail. Elegantly designed APIs are worthless if the buttons in the client’s
    user interface don’t work or if the information it displays is unreadable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 打造令人愉悦的软件需要投入与关注细节的相似程度。如果客户端用户界面中的按钮不起作用，或者它显示的信息难以阅读，那么优雅设计的API就毫无价值。
- en: In this chapter, you’ll learn about UI-based end-to-end tests, the conceptual
    differences between them and other kinds of tests, how they impact your business,
    and the different tools available for writing them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解基于UI的端到端测试，它们与其他测试类型之间的概念性差异，它们如何影响你的业务，以及编写它们的不同工具。
- en: I’ll begin the chapter by explaining UI-based end-to-end tests and how they
    differ from other kinds of tests. In this first section, I’ll emphasize where
    these tests fit in the testing pyramid, explain how much they cost, and the benefits
    they yield so that you can decide whether you should adopt them, and understand
    how to incorporate them into your development process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先解释基于UI的端到端测试以及它们与其他测试类型的不同之处。在本节中，我将强调这些测试在测试金字塔中的位置，解释它们的成本以及它们带来的好处，以便你可以决定是否应该采用它们，并了解如何将它们融入你的开发过程中。
- en: Once I’ve explained the differences and similarities of these types of tests,
    I’ll teach you how to decide when to write each one of them. I’ll go through the
    pros and cons of each one and give you examples of how each type of test delivers
    value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我解释了这些测试类型之间的差异和相似之处，我将教你如何决定何时编写每种测试。我会逐一分析每种测试的优缺点，并给出每种测试类型如何带来价值的例子。
- en: The third and final section contains an overview of end-to-end testing tools.
    In it, I will present and compare tools like Selenium, Puppeteer, and Cypress,
    which is the tool I’ll use throughout the next chapter. Through the use of diagrams,
    I’ll show you how these tools are architected and how they work. Additionally,
    I’ll explain the pros and cons of each so that you can pick the adequate technology
    for your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和最后一节将概述端到端测试工具。其中，我将介绍并比较Selenium、Puppeteer和Cypress等工具，这些工具将是下一章中我会使用的工具。通过使用图表，我将向你展示这些工具的架构和工作原理。此外，我将解释每种工具的优缺点，以便你可以为你的项目选择适当的技术。
- en: 10.1 What are UI-based end-to-end tests?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 什么是基于UI的端到端测试？
- en: Baking sublime desserts is different from establishing a successful bakery.
    No matter how delightful your cheesecakes taste, you won’t sell any in a scruffy
    bakery. Likewise, not even the best-looking bakery in town survives sour desserts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 制作上乘的甜点与建立成功的面包店不同。无论你的芝士蛋糕味道有多美妙，如果你在一个杂乱无章的面包店中卖，你也不会卖出任何东西。同样，即使城镇里最漂亮的面包店也无法承受酸味十足的甜点。
- en: To succeed, bakery owners have to make sure that the presentation of each product
    is flawless, that they taste delectable, and that both the customer service and
    the bakery’s decoration is held up to the highest standards.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功，面包店老板必须确保每个产品的展示完美无瑕，它们味道美味，客户服务和面包店的装饰都达到最高标准。
- en: Similarly, for software products to succeed, they must fulfill their user’s
    needs, behave correctly, and have responsive and understandable interfaces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了软件产品的成功，它们必须满足用户的需求，行为正确，并且具有响应性和易于理解的界面。
- en: In this section, I’ll explain the difference between end-to-end tests, UI tests,
    and UI-based end-to-end tests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释端到端测试、UI测试和基于UI的端到端测试之间的区别。
- en: End-to-end tests help you ensure that the ***entire*** application works as
    it should. As I’ve explained in chapter 2, the scope of these tests is large,
    and the reliability guarantees they generate are strong. These tests are at the
    very top of the testing pyramid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试有助于你确保**整个**应用程序按预期工作。正如我在第2章中解释的，这些测试的范围很大，它们产生的可靠性保证很强。这些测试是测试金字塔的顶端。
- en: To attach an “end-to-end” label to a test, it’s useful to look at what the software
    under test is.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个测试贴上“端到端”的标签，查看正在测试的软件是有用的。
- en: As an example, think about the tests for the application used in chapters 4
    and 5\. When you consider the software under test to be the inventory management
    backend, the tests that validate this backend by sending HTTP requests are end-to-end
    tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑第4章和第5章中使用的应用程序的测试。当你将正在测试的软件视为库存管理后端时，通过发送HTTP请求验证此后端的测试是端到端测试。
- en: On the other hand, if you consider the software under test to be the web client
    the bakery’s operators use, its end-to-end tests are the ones that click buttons,
    fill inputs, submit forms, and read the page’s contents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你认为正在测试的软件是面包店操作员使用的网络客户端，那么其端到端测试就是点击按钮、填写输入、提交表单和读取页面内容的测试。
- en: Now, if you consider the software under test to be the *entire* inventory management
    application, including both its backend *and* frontend, the tests I’ve previously
    mentioned are *not* exactly “end-to-end” tests because they do *not* cover the
    entire software under test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你认为正在测试的软件是包括其后端**以及**前端的整个库存管理应用程序，那么我之前提到的测试**并不**是“端到端”测试，因为它们**没有**覆盖整个正在测试的软件。
- en: End-to-end tests for this entire application would use a browser to interact
    with the application through its web client, allow the HTTP requests to reach
    the backend, and expect the page to display the right contents once the server
    answers. Testing the inventory management application in this way covers all of
    the software involved in running it, as shown in figure 10.1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个应用程序进行的端到端测试将使用浏览器通过其网络客户端与应用程序交互，允许HTTP请求到达后端，并期望在服务器响应后页面显示正确的内容。以这种方式测试库存管理应用程序涵盖了运行它所涉及的软件的所有部分，如图10.1所示。
- en: '![](../Images/CH10_F01_DaCosta.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F01_DaCosta.png)'
- en: Figure 10.1 An end-to-end test for the entire application covers all parts of
    its stack by interacting with it through a browser.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 整个应用程序的端到端测试通过与其通过浏览器交互来覆盖其堆栈的所有部分。
- en: User-interface tests are different from end-to-end tests in the sense that they
    cover an application’s UI, not ***necessarily*** its entire range of features
    or its complete software stack.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面测试与端到端测试的不同之处在于，它们覆盖的是应用程序的UI，**不一定**是其所有功能范围或完整的软件栈。
- en: A user-interface test for the frontend application from chapter 6, for example,
    could involve using a browser only to check if it displays the correct content.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对第6章中前端应用程序的用户界面测试可能仅涉及使用浏览器来检查它是否显示正确的内容。
- en: Even the end-to-end test I’ve previously mentioned—the one that interacts with
    the entire application through its UI—is a UI test. I’d consider that test a UI
    test because it uses the client’s user interface as the entry point for its actions
    and as an assertion target.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是我之前提到的端到端测试——通过UI与整个应用程序交互的测试——也是UI测试。我会将这个测试视为UI测试，因为它使用客户端的用户界面作为其操作的入口点，并将其作为断言目标。
- en: Alternatively, a user-interface test could use a stub to replace the backend
    entirely and focus solely on the application’s interface elements. A test like
    this would then be *exclusively* a UI test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用户界面测试可以使用存根完全替换后端，并仅关注应用程序的界面元素。这样的测试将**仅**是UI测试。
- en: Important User-interface tests and end-to-end tests are not mutually exclusive
    classifications. A test can be both a UI test *and* an end-to-end test, or only
    one of them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 用户界面测试和端到端测试不是相互排斥的分类。一个测试可以是UI测试**并且**是端到端测试，或者只是其中之一。
- en: I call UI-based end-to-end tests the *tests that cover an entire application’s
    software stack by interacting with the application through its UI*. You can see
    in figure 10.2 how these types of tests overlap.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我将基于UI的端到端测试称为**通过与应用程序通过其UI交互来覆盖整个应用程序软件栈的测试**。你可以在图10.2中看到这些测试类型是如何重叠的。
- en: '![](../Images/CH10_F02_DaCosta.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F02_DaCosta.png)'
- en: Figure 10.2 End-to-end tests validate all of the application’s layers. UI tests
    validate an application through its UI. UI-based end-to-end tests are at the intersection
    of both kinds of tests because they validate all of the appli-cation’s layers
    by interacting with it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 端到端测试验证应用程序的所有层。UI测试通过UI验证应用程序。基于UI的端到端测试位于这两种测试的交叉点，因为它们通过与应用程序交互来验证应用程序的所有层。
- en: 10.2 When to write each type of test
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 何时编写每种类型的测试
- en: When deciding whether and when to write pure end-to-end tests, pure UI tests,
    or UI-based end-to-end tests, I recommend readers follow the testing pyramid’s
    principles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否以及何时编写纯端到端测试、纯UI测试或基于UI的端到端测试时，我建议读者遵循测试金字塔的原则。
- en: To follow those principles, you must be able to determine where each of these
    kinds of tests fit, which is what I’ll teach you in this subsection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这些原则，你必须能够确定每种这类测试适合的位置，这正是我在本小节中要教你的。
- en: 10.2.1 UI-based end-to-end tests
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 基于UI的端到端测试
- en: A UI-based end-to-end test involves the entire stack of software upon which
    your application depends. It goes at the very top of the testing pyramid because
    it has the broadest possible scope and generates the most reliable guarantees.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于UI的端到端测试涉及你的应用程序所依赖的整个软件栈。它位于测试金字塔的最顶层，因为它具有最广泛的范围，并产生最可靠的保证。
- en: Even within the “end-to-end” test category, UI tests that cover your entire
    system go above end-to-end tests for RESTful APIs, for example, as shown in figure
    10.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在“端到端”测试类别中，覆盖整个系统的UI测试也高于RESTful API的端到端测试，如图10.3所示。
- en: '![](../Images/CH10_F03_DaCosta.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 DaCosta](../Images/CH10_F03_DaCosta.png)'
- en: Figure 10.3 Within the end-to-end tests section of the testing pyramid, UI-based
    end-to-end tests go at the very top.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 在测试金字塔的端到端测试部分，基于UI的端到端测试位于最顶层。
- en: 'It interacts with your application *exactly* like users would: by interacting
    with your page’s elements through a real browser. Because these interactions depend
    on the client to send the adequate requests and the server to provide adequate
    responses, it covers both your frontend *and* backend.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它与你的应用程序*完全一样*地交互：通过在真实浏览器中与你的页面元素交互。因为这些交互依赖于客户端发送适当的请求和服务器提供适当的响应，它涵盖了你的前端*和*后端。
- en: For example, consider a UI-based end-to-end test for the inventory management
    application from chapter 6.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑第6章中库存管理应用程序的基于UI的端到端测试。
- en: By filling the application’s inputs, submitting the form, and checking the item
    list, this test validates whether the frontend form sends the expected request,
    whether the server responds correctly, and whether the client adequately updates
    the stock once it receives the server’s response.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填充应用程序的输入，提交表单，并检查项目列表，此测试验证前端表单是否发送了预期的请求，服务器是否正确响应，以及客户端在收到服务器的响应后是否充分更新了库存。
- en: With a single test, you were able to cover a large part of your application
    reliably. Therefore, you need fewer UI-based end-to-end tests than other kinds
    of tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单个测试，你能够可靠地覆盖应用程序的大部分内容。因此，你需要比其他类型的测试更少的基于UI的端到端测试。
- en: Because these tests tend to be more time-consuming to write and to execute,
    it’s wise to avoid having to update them multiple times as you develop new features.
    Therefore, I’d recommend readers to write these kinds of tests *after* implementing
    **complete** pieces of functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试编写和执行通常需要更多时间，因此明智的做法是在开发新功能时避免多次更新它们。因此，我建议读者在实现**完整**的功能块之后编写这些类型的测试。
- en: NOTE In the next chapter, I’ll go into detail about why these tests can be time-consuming
    to write and maintain in the sections “Best practices for end-to-end tests” and
    “Dealing with flakiness.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在下一章中，我将在“端到端测试的最佳实践”和“处理不可靠性”部分详细说明为什么这些测试编写和维护可能很耗时。
- en: To decide in which circumstances you should write UI-based end-to-end tests,
    you must carefully consider how critical the feature under test is, how labor-intensive
    it is to validate it manually, and how much it will cost to automate its tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要决定在什么情况下你应该编写基于UI的端到端测试，你必须仔细考虑正在测试的功能有多关键，手动验证它有多费时，以及自动化测试它将花费多少成本。
- en: How critical the feature under test is
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在测试的功能有多关键
- en: How labor-intensive it is to validate the feature manually
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动验证该功能需要多少工作量
- en: How much it will cost to write an automated test
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自动化测试将花费多少成本
- en: The more critical a feature is, and the more time you need to test it manually,
    the more crucial it is to write UI-based end-to-end tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能越关键，你需要手动测试它的时间越多，编写基于UI的端到端测试就越重要。
- en: If, for example, you had to test how the “undo” button behaves when users add
    items simultaneously, you’d have to have at least two clients open, insert items
    on both, and then try clicking the “undo” button in these different clients, in
    different orders. This kind of test is time-consuming, and, because it has many
    steps, it’s also error-prone.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要测试当用户同时添加项目时“撤销”按钮的行为，你至少需要打开两个客户端，在两个客户端上插入项目，然后尝试在这些不同的客户端中按不同的顺序点击“撤销”按钮。这种测试耗时且因为步骤繁多，也容易出错。
- en: Additionally, because the consequences can be incredibly dire if this button
    misbehaves, it’s essential to validate this functionality rigorously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于如果这个按钮表现不佳，后果可能极其严重，因此，严格验证这个功能是至关重要的。
- en: In this case, given how critical this feature is, you’d have to test it frequently,
    and, therefore, you’d invest a lot of time performing manual labor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，鉴于这个功能的重要性，你不得不频繁对其进行测试，因此，你将不得不投入大量时间进行手动劳动。
- en: If you had UI-based end-to-end test instead, you could delegate the testing
    to a machine, which would do it much more quickly and would never forget any steps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个基于UI的端到端测试，你可以将测试委托给机器，它会更快地完成，并且永远不会忘记任何步骤。
- en: On the other hand, if you have a small, inessential feature, such as a reset
    button that clears the form’s content, you don’t necessarily need to invest time
    in writing a UI-based end-to-end test.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有一个小而无关紧要的功能，例如清除表单内容的重置按钮，你不必一定投入时间编写基于UI的端到端测试。
- en: For these kinds of features, a test written using `react-testing-library` would
    offer guarantees that are almost as reliable and take much less time to implement
    and to execute.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类功能，使用 `react-testing-library` 编写的测试可以提供几乎同样可靠的保证，并且实施和执行所需的时间要少得多。
- en: Both developers and QA engineers can write UI-based end-to-end tests. In leaner
    teams, which take a more agile approach to software development, software engineers
    will write these tests themselves and factor into their estimations the time it
    takes to write those tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员和QA工程师都可以编写基于UI的端到端测试。在更精简的团队中，这些团队采用更敏捷的软件开发方法，软件工程师将自行编写这些测试，并将编写这些测试所需的时间纳入他们的估算中。
- en: When a QA team is available, QA engineers can write UI-based end-to-end tests
    that run against an environment other than production. By automating repetitive
    tests, they can perform more proactive work and have more time for improving their
    own processes and performing exploratory testing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当QA团队可用时，QA工程师可以编写针对除生产环境以外的环境的基于UI的端到端测试。通过自动化重复性测试，他们可以执行更多主动工作，并有更多时间改进自己的流程和进行探索性测试。
- en: 10.2.2 Pure end-to-end tests
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 纯端到端测试
- en: In the testing pyramid, pure end-to-end tests go a bit below UI-based end-to-end
    tests, as you can see in figure 10.4\. They do not test your software precisely
    as users would, but they can be almost as reliable and are much quicker to write.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔中，纯端到端测试位于基于UI的端到端测试之下，如图10.4所示。它们并不完全像用户那样测试你的软件，但它们可以几乎同样可靠，并且编写起来要快得多。
- en: '![](../Images/CH10_F04_DaCosta.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_DaCosta.png)'
- en: Figure 10.4 Pure end-to-end tests go below UI-based end-to-end tests in the
    testing pyramid.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 纯端到端测试位于基于UI的端到端测试之下。
- en: Unlike UI-based end-to-end tests, pure end-to-end tests can be bundled into
    your development process and significantly shorten your feedback loop as you write
    code. These tests provide reliable quality guarantees and cover a large part of
    your code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于UI的端到端测试不同，纯端到端测试可以集成到你的开发过程中，并在你编写代码时显著缩短你的反馈循环。这些测试提供了可靠的质量保证，并覆盖了你代码的大部分内容。
- en: Additionally, when testing software with no graphical user interface, such as
    RESTful APIs or distributable software packages, it’s not possible to write UI
    tests. Therefore end-to-end tests offer the strongest reliability guarantees you
    can have.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当测试没有图形用户界面的软件，如RESTful API或可分发软件包时，无法编写UI测试。因此，端到端测试提供了你可以拥有的最强可靠性保证。
- en: You should write end-to-end tests as you develop code. These tests should validate
    your code from a consumer’s perspective. When you tested your backend in chapter
    4, for example, your end tests validated your routes by sending them HTTP requests
    and checking the server’s response and the database’s content.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在编写代码的同时编写端到端测试。这些测试应该从消费者的角度验证你的代码。例如，当你测试第4章中的后端时，你的端到端测试通过发送HTTP请求并检查服务器的响应和数据库的内容来验证你的路由。
- en: When writing end-to-end tests, developers should pay attention to how much their
    tests overlap and carefully adapt their test suite to reduce the burden of maintenance
    as their software grows, maintaining a balanced testing pyramid.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写端到端测试时，开发者应该注意测试之间的重叠程度，并仔细调整测试套件，以减少随着软件的增长而带来的维护负担，保持测试金字塔的平衡。
- en: Because writing this kind of test requires direct access to the code, they must
    be written by developers, not QA engineers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编写这类测试需要直接访问代码，所以它们必须由开发者编写，而不是质量保证工程师。
- en: 10.2.3 Pure UI tests
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 纯UI测试
- en: 'UI tests can come in two flavors: they can validate a UI either through a real
    browser or through a testing framework, such as Jest.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试可以分为两种类型：它们可以通过真实浏览器或测试框架（如Jest）来验证UI。
- en: If you take the term “UI test” to the letter, you can consider the tests you’ve
    written using `react-testing-library` as UI tests. Thanks to JSDOM, they can interact
    with your components by dispatching browserlike events and validate your application
    by finding elements in the DOM.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你字面理解“UI测试”这个术语，那么你可以将使用`react-testing-library`编写的测试视为UI测试。多亏了JSDOM，它们可以通过派发类似浏览器的事件与你的组件交互，并通过在DOM中查找元素来验证你的应用程序。
- en: Nonetheless, because those tests use JSDOM instead of a real browser run-time
    environment, they don’t *exactly* replicate what happens when your application
    runs within a browser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，由于这些测试使用JSDOM而不是真实浏览器运行时环境，它们并不*完全*复制应用程序在浏览器中运行时发生的情况。
- en: In the testing pyramid, UI tests that run in a browser go above UI tests that
    run within testing frameworks. Tests that run within a real browser can replicate
    user interactions more accurately and involve fewer test doubles. However, they
    take more time to run and are more complex to write.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔中，运行在浏览器中的UI测试位于运行在测试框架内的UI测试之上。在真实浏览器中运行的测试可以更准确地复制用户交互，并涉及更少的测试替身。然而，它们运行所需的时间更长，编写起来也更复杂。
- en: Considering that UI tests that run within testing frameworks are way quicker
    to write and that the guarantees they generate are almost as reliable, I’d recommend
    you choose them most of the time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在测试框架中运行的UI测试编写速度快，并且它们产生的保证几乎同样可靠，我建议你大多数时候选择它们。
- en: For example, think about what you’d have to do to run in a browser the tests
    you wrote in chapter 6\. Instead of having a lightweight replica of a browser
    environment in which you could easily dispatch events, you’d have to interface
    with a real browser and deal with all of its complexities, like waiting for pages
    to load and interacting with its native APIs. Besides making the test much more
    complicated, it would take way more time to finish.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想想你需要在浏览器中运行第6章中编写的测试需要做什么。你将不得不与真实浏览器接口，并处理所有其复杂性，比如等待页面加载和与其原生API交互。除了使测试变得更加复杂外，完成测试所需的时间也会大大增加。
- en: Because UI tests that run within test frameworks are quick to write and offer
    reliable guarantees, you can write them as you develop features. Given how small
    these tests tend to be, it’s also straightforward to include them in a test-driven
    workflow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在测试框架中运行的UI测试编写速度快，且提供可靠的保证，你可以在开发功能的同时编写它们。鉴于这些测试通常很小，将它们包含在测试驱动的工作流程中也很简单。
- en: I’d recommend writing pure UI tests that run in a browser only when it’s critical
    to use browser-specific features that you can’t accurately simulate with JSDOM
    or when performing visual regression testing—a topic we’ll cover later in this
    chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议仅在需要使用JSDOM无法准确模拟的浏览器特定功能或进行视觉回归测试（我们将在本章后面讨论）时，才编写仅在浏览器中运行的纯UI测试。
- en: Most of the time, UI tests must be written by developers, not QA engineers,
    because they depend on having access to the code either to interface with the
    unit under test directly or to write test doubles for the applications with which
    your client interacts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，UI测试必须由开发者编写，而不是质量保证工程师，因为它们依赖于直接访问被测试单元的接口或为与你的客户交互的应用程序编写测试替身。
- en: When interactions with other pieces of software are irrelevant to the test,
    QA engineers can then assume this responsibility if they find it suitable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他软件组件的交互对测试无关时，如果QA工程师认为合适，他们可以承担这项责任。
- en: 10.2.4 A note on acceptance testing and this chapter’s name
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 关于验收测试和本章标题的说明
- en: In the software industry, people often use terms like *end-to-end tests*, *UI
    tests*, and *UI-based end-to-end tests* imprecisely.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业，人们经常不精确地使用诸如*端到端测试*、*UI测试*和*基于UI的端到端测试*等术语。
- en: I’ve frequently seen, for example, people calling “end-to-end tests” any tests
    that interact with an application through a browser.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我经常看到人们将任何通过浏览器与应用程序交互的测试称为“端到端测试”。
- en: Even though that definition is correct, given that these tests’ scope is the
    entire application under test, I believe that we could adopt more precise terminology,
    like what I’ve used throughout this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使那个定义是正确的，因为这些测试的范围是整个被测试的应用程序，我相信我们可以采用更精确的术语，就像我在本章中使用的术语一样。
- en: Because of this inaccuracy, I had a difficult time picking a name for this chapter.
    Initially, I thought I’d name it “UI tests,” but that would mean its name would
    be reductive, given that the chapter isn’t *exclusively* about testing user interfaces.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种不准确，我很难为这一章挑选一个名字。最初，我认为我会将其命名为“UI测试”，但那样的话，其名称就会过于简化，因为本章并不*仅限于*测试用户界面。
- en: I then pondered naming it “acceptance tests.” I considered this name because
    I was dealing with validating requisites *mostly* from a customer’s perspective
    and checking whether the application fulfils its customers’ needs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我当时考虑将其命名为“验收测试”。我之所以考虑这个名字，是因为我主要从客户的角度验证需求，并检查应用程序是否满足客户的需求。
- en: The problem with naming it “acceptance tests” is that it may mislead readers
    into thinking that I’d ignore checking technical requirements at all. This name,
    too, could end up being reductive.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将其命名为“验收测试”的问题在于，它可能会误导读者认为我会完全忽略检查技术要求。这个名字也可能最终变得过于简化。
- en: Naming this chapter “UI-based end-to-end tests” informs the reader that I will
    cover a broader scope of technologies and techniques within this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章命名为“基于UI的端到端测试”告知读者，我将在本章中涵盖更广泛的技术和技巧。
- en: I believe this name is ideal because this chapter covers tests that interact
    with an entire application, from end to end, through its graphical user interface,
    most of which are acceptance tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个名字很理想，因为本章涵盖了与整个应用程序交互的测试，从端到端，通过其图形用户界面，其中大部分是验收测试。
- en: The difference between this chapter and the previous ones that covered end-to-end
    tests is that this chapter focuses on testing your *entire* software stack, not
    just a single piece of software.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与之前涵盖端到端测试的章节之间的区别在于，本章侧重于测试你的整个软件栈，而不仅仅是单个软件组件。
- en: Because these tests are at the highest possible level of integration, when considering
    the testing pyramid, even *within* the “end-to-end” layer, they are at the very
    top.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试处于可能的最大集成级别，在考虑测试金字塔时，即使在“端到端”层内，它们也处于最顶层。
- en: 10.3 An overview of end-to-end testing tools
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 端到端测试工具概述
- en: As Louis’s business expands, the more challenging it becomes for him to oversee
    the bakery’s decor and supervise customer service while still baking delightful
    desserts. Because he is fully aware that his gifts are best used in the kitchen
    rather than in an office, Louis decided to hire a manager to oversee the whole
    business.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着路易斯生意的扩张，他越来越难以同时监督面包店的装饰、监督客户服务并烘焙令人愉悦的甜点。因为他深知自己的天赋最好用在厨房而不是办公室，路易斯决定雇佣一位经理来监督整个业务。
- en: Even though the bakery’s new manager can’t bake a cheesecake that’s nearly as
    good as Louis’s, she is multidisciplinary enough to recognize an excellent dessert
    *and* guarantee that the business is running smoothly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使面包店的新的经理无法做出像路易斯那样好的芝士蛋糕，但她足够多才多艺，能够识别出优秀的甜点，并保证业务运营顺利。
- en: In this section, I will present tools that are to your software what Louis’s
    new manager is to the bakery.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍对软件来说就像路易斯的新经理对面包店一样重要的工具。
- en: Instead of specializing in interfacing with your code directly, the tools I’ll
    present in this section interact with your software through its user interface.
    They test your software as a whole and are capable of asserting on much broader
    aspects of how it works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这个部分中展示的工具不是直接与你的代码接口专业化，而是通过用户界面与你的软件交互。它们测试你的软件作为一个整体，并且能够对它如何工作的更广泛方面进行断言。
- en: For example, instead of invoking a function and expecting its output to match
    a particular value, these tools can help you fill inputs, submit a form, and check
    whether the browser displays the correct result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些工具可以帮助你填写输入，提交表单，并检查浏览器是否显示了正确的结果，而不是调用一个函数并期望其输出与特定值匹配。
- en: In this case, even though the tool you used doesn’t necessarily need to know
    about your server, it requires the server to provide the correct response for
    the client to update adequately. Even though this loosely coupled test knows less
    about each specific part of your software stack, it can evaluate all of them,
    just like Louis’s new manager.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使你使用的工具不一定需要了解你的服务器，它也要求服务器提供正确的响应，以便客户端能够适当地更新。即使这种松散耦合的测试对你的软件堆栈的每个具体部分了解不多，但它可以评估所有这些部分，就像路易斯的新经理一样。
- en: I’ll start this section by talking about Selenium, one of the oldest and most
    widely known end-to-end testing tools available. I will talk about what Selenium
    is, how it works, how you can benefit from it, and its most critical and most
    frequent problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从这个部分开始，先谈谈Selenium，这是目前最古老且最广为人知的端到端测试工具之一。我将介绍Selenium是什么，它是如何工作的，你如何从中受益，以及它最关键和最常见的问题。
- en: By exposing Selenium’s problems, it will be easier for you to understand how
    other testing tools try to solve them and what trade-offs they have to make.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过揭示Selenium的问题，你将更容易理解其他测试工具如何尝试解决这些问题以及它们必须做出的权衡。
- en: After talking about Selenium, I’ll present Puppeteer and Cypress, which are
    two of the most popular tools in this niche at the moment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论Selenium之后，我将介绍Puppeteer和Cypress，它们是目前这个领域中最受欢迎的两个工具。
- en: As I teach about those tools, besides covering their strengths and weaknesses,
    I’ll explore the contrast between Selenium and them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我介绍这些工具时，除了介绍它们的优缺点外，我还会探讨Selenium与它们的对比。
- en: For reasons I will explain throughout this chapter and the next, Cypress is
    my personal favorite and, therefore, the tool I’ve chosen to use to write almost
    all of the upcoming examples and the tool on which I’ll focus in this section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在本章和下一章中将要解释的原因，Cypress是我个人的首选工具，因此我选择使用它来编写几乎所有即将到来的示例，并且在这个部分中我将重点关注这个工具。
- en: 10.3.1 Selenium
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 Selenium
- en: Selenium is a browser automation framework frequently used for testing web applications
    through a real browser. It can open websites, click elements, and read a page’s
    contents so that you can interact with applications and execute assertions. Selenium
    is the precursor of the browser-based end-to-end testing tools you will see in
    this section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个常用于通过真实浏览器测试Web应用程序的浏览器自动化框架。它可以打开网站，点击元素，并读取页面内容，以便你可以与应用程序交互并执行断言。Selenium是本节中你将看到的基于浏览器的端到端测试工具的先驱。
- en: NOTE You can find the complete documentation for Selenium at [https://www.selenium.dev/documentation](https://www.selenium.dev/documentation).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在[https://www.selenium.dev/documentation](https://www.selenium.dev/documentation)找到Selenium的完整文档。
- en: To understand why Selenium is useful, compare it to the tests you’ve written
    for the web application in chapter 6.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么Selenium有用，可以将它与第6章中为Web应用程序编写的测试进行比较。
- en: In those tests, you mounted your application to an alternative DOM implementation,
    JSDOM. Then, you used JSDOM’s pure JavaScript implementation of native APIs to
    dispatch events and inspect elements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些测试中，你将你的应用程序挂载到替代DOM实现JSDOM上。然后，你使用JSDOM对原生API的纯JavaScript实现来派发事件和检查元素。
- en: JSDOM is ideal for writing tests during your development process. Because it
    allows you to get rid of the need for a real browser instance, JSDOM simplifies
    setting up a testing environment and makes your tests quicker and lighter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JSDOM非常适合在开发过程中编写测试。因为它允许你摆脱对真实浏览器实例的需求，JSDOM简化了测试环境的设置，并使你的测试更快、更轻量。
- en: The problem with using JSDOM is that it may not always accurately reflect what
    real browsers do. JSDOM is an *attempt* to implement browser APIs as per specification.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSDOM的问题在于它可能并不总是准确地反映真实浏览器的行为。JSDOM是按照规范实现浏览器API的*尝试*。
- en: Even though JSDOM does an excellent job in almost every case, it’s still an
    imperfect replica of a browser’s environment. Additionally, even browsers themselves
    do not always follow the API’s specifications adequately. Therefore, even if JSDOM
    implements those APIs correctly, browsers may not.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JSDOM在几乎所有情况下都做得很好，但它仍然是一个不完美的浏览器环境的复制品。此外，即使是浏览器本身也不总是充分遵循API规范。因此，即使JSDOM正确实现了这些API，浏览器也可能不会。
- en: For example, imagine that you implemented a feature that relies on an API that
    behaves one way in Chrome and another in Firefox. In that case, if JSDOM’s implementation
    is correct, your tests would pass. Nonetheless, if neither Chrome nor Firefox
    implemented the specification correctly, your feature wouldn’t work on either
    browser.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你实现了一个依赖于API的功能，该API在Chrome和Firefox中的行为不同。在这种情况下，如果JSDOM的实现是正确的，你的测试将会通过。然而，如果Chrome和Firefox都没有正确实现该规范，你的功能在任一浏览器上都不会工作。
- en: Because Selenium runs its tests through a real browser instance, it’s the tool
    that more closely resembles how your users interact with your software. Therefore,
    it’s the tool that gives you the most reliable guarantees.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Selenium通过真实的浏览器实例运行其测试，它是更接近用户如何与你的软件交互的工具。因此，它是提供最可靠保证的工具。
- en: If the browser that Selenium is using to run your tests doesn’t implement a
    particular API or doesn’t adequately follow its specification, your tests *will*
    fail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Selenium用于运行你的测试的浏览器没有实现特定的API或没有充分遵循其规范，你的测试*将会*失败。
- en: Besides being the most accurate way to replicate your user’s actions, Selenium
    provides you with the full range of a browser’s capabilities.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是最准确复制用户行为的方式之外，Selenium还为你提供了浏览器功能的全面范围。
- en: Instead of merely attaching nodes to a “document,” when using Selenium, you
    can freely navigate between pages, throttle the network’s speed, record videos,
    and take screenshots.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Selenium时，你不仅可以将节点附加到“文档”上，还可以自由地在页面之间导航，限制网络速度，录制视频和截图。
- en: For example, if you have a test that guarantees that the images for all products
    are visible after one second, even on a patchy internet connection, you need to
    use a real browser. This technique will cause your tests to resemble your users’
    environments as closely as possible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个测试保证所有产品的图片在1秒后可见，即使在网络连接不稳定的情况下，你需要使用一个真实的浏览器。这种技术将使你的测试尽可能接近用户的测试环境。
- en: How Selenium works
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium的工作原理
- en: Selenium interacts with a browser through programs called *Webdrivers*. These
    Webdrivers are responsible for receiving Selenium’s commands and performing the
    necessary actions within a real browser.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium通过称为*Webdrivers*的程序与浏览器交互。这些Webdrivers负责接收Selenium的命令并在真实的浏览器内执行必要的操作。
- en: For example, when you tell Selenium to click an element, it will send a “click”
    command to the Webdriver you’ve chosen. Because this Webdriver is capable of controlling
    a real browser, it will make the browser click the selected element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你告诉Selenium点击一个元素时，它将向你所选择的Webdriver发送一个“click”命令。因为这个Webdriver能够控制一个真实的浏览器，它将使浏览器点击选定的元素。
- en: To communicate with the Webdriver, Selenium uses a protocol called *JSON Wire*.
    This protocol specifies a set of HTTP routes for handling different actions to
    be performed within a browser. When running the Webdriver, it will manage a server
    that implements such routes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Webdriver通信，Selenium使用一种称为*JSON Wire*的协议。该协议指定了一组HTTP路由，用于处理在浏览器内执行的不同操作。当运行Webdriver时，它将管理一个实现这些路由的服务器。
- en: If, for example, you tell Selenium to click on an element, it will send a `POST`
    request to the Webdriver’s `/session/:sessionId/element/:id/click` route. To obtain
    an element’s text, it will send a `GET` request to `/session/:sessionId/element/:id/text`.
    This communication is illustrated in figure 10.5.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你告诉Selenium点击一个元素，它将向Webdriver的`/session/:sessionId/element/:id/click`路由发送一个`POST`请求。为了获取一个元素的文本，它将向`/session/:sessionId/element/:id/text`发送一个`GET`请求。这种通信在图10.5中得到了说明。
- en: '![](../Images/CH10_F05_DaCosta.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F05_DaCosta.png)'
- en: Figure 10.5 Selenium sends HTTP requests to the Webdrivers that control browsers.
    These requests adopt the JSON Wire protocol.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 Selenium向控制浏览器的Webdrivers发送HTTP请求。这些请求采用JSON Wire协议。
- en: To communicate with the browser, each Webdriver uses the target browser’s remote-control
    APIs. Because different browsers have distinct remote-control APIs, each browser
    demands a specific driver. To drive Chrome, you will use the `ChromeDriver`. To
    drive Firefox, you’ll need the `Geckodriver`, as shown in figure 10.6.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与浏览器通信，每个 Webdriver 都使用目标浏览器的远程控制 API。由于不同的浏览器有不同的远程控制 API，每个浏览器都需要特定的驱动程序。要驱动
    Chrome，你将使用 `ChromeDriver`。要驱动 Firefox，你需要 `Geckodriver`，如图 10.6 所示。
- en: '![](../Images/CH10_F06_DaCosta.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F06_DaCosta.png)'
- en: Figure 10.6 Different web drivers control different browsers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 不同的 Web 驱动控制不同的浏览器。
- en: When you use Selenium’s JavaScript library, all it does is implement methods
    that will send to the Webdriver of your choice requests that follow the JSON Wire
    protocol.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Selenium 的 JavaScript 库时，它所做的只是实现将发送到你所选择的 Webdriver 的请求，这些请求遵循 JSON Wire
    协议。
- en: Using a Webdriver’s interfaces without Selenium
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 Selenium 使用 Webdriver 的接口
- en: As I’ve previously mentioned, **even though Selenium is mostly used to test
    web applications, it is actually a browser automation library**. Therefore, its
    JavaScript library, available on NPM under the name `selenium-webdriver`, does
    *not* include a test runner or an assertion library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，**尽管 Selenium 主要用于测试 Web 应用程序，但实际上它是一个浏览器自动化库**。因此，它在 NPM 上以 `selenium-webdriver`
    命名的 JavaScript 库并不包含测试运行器或断言库。
- en: NOTE You can find the documentation for the `selenium-webdriver` package at
    [https://www.selenium.dev/selenium/docs/api/javascript](https://www.selenium.dev/selenium/docs/api/javascript).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在 [https://www.selenium.dev/selenium/docs/api/javascript](https://www.selenium.dev/selenium/docs/api/javascript)
    找到 `selenium-webdriver` 包的文档。
- en: For you to write tests using Selenium, you will need to use separate testing
    frameworks, such as Jest, as figure 10.7 illustrates. Alternatively, you can use
    Mocha, which is *exclusively* a test runner, or Chai, which is *exclusively* an
    assertion library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Selenium 编写测试，你需要使用像 Jest 这样的单独的测试框架，如图 10.7 所示。或者，你也可以使用 Mocha，它是一个**专用的**测试运行器，或者
    Chai，它是一个**专用的**断言库。
- en: '![](../Images/CH10_F07_DaCosta.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F07_DaCosta.png)'
- en: Figure 10.7 If you want to use Selenium for testing, you must pair it with a
    testing framework, such as Jest.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 如果你想要使用 Selenium 进行测试，你必须与一个测试框架，如 Jest，配合使用。
- en: Because Selenium doesn’t ship with any testing tools, it can be cumbersome to
    set up the necessary environment to start using it to test your applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Selenium 不附带任何测试工具，因此设置必要的环境以开始使用它来测试应用程序可能会很麻烦。
- en: To avoid going through this setup process yourself, you can use libraries like
    Nightwatch.js, whose documentation is available at [https://nightwatchjs.org](https://nightwatchjs.org),
    or WebdriverIO, about which you can find more at [https://webdriver.io](https://webdriver.io).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免自己进行此设置过程，你可以使用像 Nightwatch.js 这样的库，其文档可在 [https://nightwatchjs.org](https://nightwatchjs.org)
    找到，或者关于 WebdriverIO 的更多信息可在 [https://webdriver.io](https://webdriver.io) 找到。
- en: These tools, just like Selenium, can interface with multiple Webdrivers and,
    therefore, are capable of controlling real browsers. The main difference between
    these libraries and Selenium is that they ship with testing utilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具，就像 Selenium 一样，可以与多个 Webdriver 接口，因此能够控制真实浏览器。这些库与 Selenium 的主要区别在于它们附带测试工具。
- en: Besides bundling testing utilities, these other libraries are also concerned
    with extensibility and offer different APIs that cater to a test-focused audience
    (figure 10.8).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了捆绑测试工具之外，这些其他库还关注可扩展性，并提供不同的 API，以满足以测试为重点的受众（图 10.8）。
- en: '![](../Images/CH10_F08_DaCosta.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F08_DaCosta.png)'
- en: Figure 10.8 Instead of having to set up your own testing infrastructure, you
    can use libraries like Nightwatch.js or WebdriverIO, which ship with all the tools
    necessary for writing tests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 不需要自己搭建测试基础设施，你可以使用 Nightwatch.js 或 WebdriverIO 等库，它们包含了编写测试所需的所有工具。
- en: When to choose Selenium
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Selenium 的时候
- en: The most notable advantage of tools like Selenium, Nightwatch.js, and WebdriverIO
    over other browser-testing frameworks and automation tools is its capability of
    controlling multiple kinds of browsers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他浏览器测试框架和自动化工具相比，Selenium、Nightwatch.js 和 WebdriverIO 等工具最显著的优势在于其控制多种浏览器的能力。
- en: Due to its highly decoupled architecture, which supports interfacing with different
    kinds of drivers to control numerous distinct browsers, it supports all the major
    browsers available.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其高度解耦的架构，它支持与不同类型的驱动程序接口以控制众多不同的浏览器，因此支持所有可用的主流浏览器。
- en: If your userbase’s browser choice is diverse, it will be highly beneficial for
    you to use Selenium or other libraries that take advantage of the Webdriver interfaces.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用户群体的浏览器选择多样化，使用Selenium或其他利用Webdriver接口的库将非常有益。
- en: In general, I’d avoid Selenium itself if I’m using it *exclusively* to write
    tests. In that case, I’d generally go for Nightwatch.js or WebdriverIO. On the
    other hand, if you need to perform other browser-automation tasks, Selenium can
    be an excellent choice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果我仅仅用它来编写测试，我会避免使用Selenium本身。在这种情况下，我通常会选择Nightwatch.js或WebdriverIO。另一方面，如果你需要执行其他浏览器自动化任务，Selenium可以是一个极佳的选择。
- en: The most significant problem with these kinds of tools is that they make it
    too easy for you to write flaky tests, and, therefore, you’ll need to create robust
    testing mechanisms to have deterministic validations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具最显著的问题在于，它们使你编写易变的测试变得过于容易，因此你需要创建健壮的测试机制来进行确定性的验证。
- en: NOTE Flaky tests are nondeterministic tests. Given the same application under
    test, they may fail sometimes and succeed in others. In this chapter’s section
    called “Dealing with flakiness,” you’ll learn more about these tests and why you
    should try to eliminate them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：易变的测试是非确定性的测试。在相同的测试应用下，它们有时会失败，有时会成功。在本章的“处理易变性”部分，你将了解更多关于这些测试以及为什么你应该尝试消除它们的信息。
- en: Additionally, because these kinds of tools control real browsers through HTTP
    requests, they tend to be slower than alternatives like Cypress, which run entirely
    *within* the browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这些工具通过HTTP请求控制真实浏览器，它们通常比完全在浏览器内运行的Cypress等替代方案要慢。
- en: Besides their possible slowness, configuring and debugging tests written with
    these tools can often be challenging. Without built-in tools to outline different
    test cases, run assertions, and monitor your test’s executions, they can take
    significantly more time to write.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可能的速度较慢之外，配置和调试使用这些工具编写的测试通常具有挑战性。没有内置的工具来概述不同的测试用例、运行断言和监控测试执行，它们可能需要更多的时间来编写。
- en: 10.3.2 Puppeteer
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 Puppeteer
- en: Like Selenium, Puppeteer is *not* exclusively a testing framework. Instead,
    it’s a browser-automation tool.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与Selenium一样，Puppeteer也不是一个专门的测试框架。相反，它是一个浏览器自动化工具。
- en: NOTE You can find Puppeteer’s documentation at [https://pptr.dev](https://pptr.dev).
    Within this website, you’ll also find links to Puppeteer’s complete API documentation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在[https://pptr.dev](https://pptr.dev)找到Puppeteer的文档。在这个网站上，你还可以找到Puppeteer的完整API文档链接。
- en: Unlike Selenium, Puppeteer, shown in figure 10.9, can control *only* Chrome
    and Chromium. To do so, it uses the Chrome DevTools protocol, which allows other
    programs to interact with the browser’s capabilities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与Selenium不同，如图10.9所示的Puppeteer只能控制Chrome和Chromium。为了做到这一点，它使用Chrome DevTools协议，该协议允许其他程序与浏览器的功能进行交互。
- en: NOTE At the time of this writing, support for Firefox is still in an experimental
    stage.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本文时，Firefox的支持仍处于实验阶段。
- en: Because Puppeteer involves fewer pieces of software than Selenium and other
    Webdriver-based tools, it is leaner. When compared to those tools, Puppeteer is
    easier to set up and debug.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Puppeteer涉及的软件组件比Selenium和其他基于Webdriver的工具要少，因此它更加精简。与这些工具相比，Puppeteer更容易设置和调试。
- en: Nonetheless, because it still is *exclusively* a browser-automation tool, it
    doesn’t ship with testing frameworks or libraries to create test suites and perform
    assertions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，因为它仍然是一个专门的浏览器自动化工具，所以它没有附带测试框架或库来创建测试套件和执行断言。
- en: '![](../Images/CH10_F09_DaCosta.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F09_DaCosta.png)'
- en: Figure 10.9 Puppeteer directly controls Chrome and Chromium through their DevTools
    Protocol.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 Puppeteer通过其DevTools协议直接控制Chrome和Chromium。
- en: If you want to use Puppeteer to run tests, you must use separate testing libraries,
    like Jest or Jest Puppeteer. The latter ships with all the necessary support for
    running tests using Puppeteer itself, including extra assertions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用Puppeteer来运行测试，你必须使用单独的测试库，如Jest或Jest Puppeteer。后者自带了使用Puppeteer本身运行测试所需的所有支持，包括额外的断言。
- en: A further advantage of Puppeteer over Selenium is its event-driven architecture,
    which eliminates the need for fixed-time delays or writing your own retry mechanisms.
    By default, tests written using Puppeteer tend to be much more robust.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer相较于Selenium的另一个优势是其事件驱动架构，这消除了固定时间延迟或编写自己的重试机制的需求。默认情况下，使用Puppeteer编写的测试往往更加健壮。
- en: Additionally, its debuggability is much better than Selenium’s. With Puppeteer,
    you can easily use Chrome’s developer tools to solve bugs and its “slow-motion”
    mode to replay the test’s steps in such a way that you can understand precisely
    what the browser is doing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它的可调试性比 Selenium 的要好得多。使用 Puppeteer，你可以轻松地使用 Chrome 的开发者工具来解决错误，并使用其“慢动作”模式以这种方式回放测试步骤，这样你可以精确地了解浏览器正在做什么。
- en: When to choose Puppeteer
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 何时选择 Puppeteer
- en: Given it’s much easier to write robust tests with Puppeteer, they take less
    time to write and, therefore, cost less. You also spend less time debugging them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 Puppeteer 编写健壮的测试要容易得多，因此它们所需的时间更少，因此成本也更低。你调试它们的时间也更少。
- en: If you need to support only Chrome and Chromium, Puppeteer is a much better
    alternative than Selenium and other Webdriver-based tools due to its simplicity
    and debuggability.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要支持 Chrome 和 Chromium，由于 Puppeteer 的简单性和可调试性，它比 Selenium 和其他基于 Webdriver
    的工具是一个更好的替代品。
- en: Besides these advantages, because Puppeteer doesn’t focus on supporting numerous
    browsers, it can provide you with access to more features and offer more elaborate
    APIs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些优势之外，由于 Puppeteer 不专注于支持众多浏览器，它可以为你提供更多功能和更详细的 API。
- en: The disadvantage of it focusing only on Chrome and Chromium is that you shouldn’t
    even consider it if you *must* support other browsers. Unless you can use different
    tools to automate the tests that will run in different browsers, Selenium or other
    Webdriver-based tools are a much better choice.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它只关注 Chrome 和 Chromium 的缺点是，如果你*必须*支持其他浏览器，甚至都不应该考虑它。除非你可以使用不同的工具来自动化将在不同浏览器中运行的测试，否则
    Selenium 或其他基于 Webdriver 的工具是一个更好的选择。
- en: NOTE I’ll cover supporting multiple browsers in-depth in the penultimate section
    of this chapter, “Running tests on multiple browsers.”
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我将在本章倒数第二节“在多个浏览器上运行测试”中深入探讨支持多个浏览器的问题。
- en: Considering that Puppeteer doesn’t ship with testing-specific tools, if you’re
    not willing to set up a testing environment on your own or use packages like `jest-puppeteer`,
    it may also not be the best choice for your project.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Puppeteer 不附带特定的测试工具，如果你不愿意自己设置测试环境或使用像 `jest-puppeteer` 这样的包，它可能也不是你项目的最佳选择。
- en: 10.3.3 Cypress
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 Cypress
- en: Cypress, shown in figure 10.10, is a testing tool that directly interfaces with
    a browser’s remote-control APIs to find elements and carry out actions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10.10 所示，Cypress 是一个测试工具，它直接与浏览器的远程控制 API 交互，以查找元素并执行操作。
- en: NOTE Cypress’s full documentation is available at [https://docs.cypress.io](https://docs.cypress.io).
    It is exceptionally well written and includes many examples and long-form articles.
    If you’re thinking about adopting Cypress, or already did so, I’d highly recommend
    you to read their documentation thoroughly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Cypress 的完整文档可在 [https://docs.cypress.io](https://docs.cypress.io) 找到。它写得非常好，包含许多示例和长篇文章。如果你正在考虑采用
    Cypress，或者已经这样做了，我强烈建议你仔细阅读他们的文档。
- en: This direct communication makes tests quicker and reduces the complexity of
    setting up a testing environment because it reduces the amount of software needed
    to start writing tests.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种直接通信使测试更快，并减少了设置测试环境的复杂性，因为它减少了启动编写测试所需的软件数量。
- en: '![](../Images/CH10_F10_DaCosta.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F10_DaCosta.png)'
- en: Figure 10.10 Cypress spawns a Node.js process that communicates with the tests
    that run *within* browsers themselves.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 Cypress 在浏览器自身运行的测试中启动一个 Node.js 进程，并与这些测试进行通信。
- en: Besides making it easier and quicker to write tests, this architecture allows
    you to leverage the Node.js process behind Cypress to perform tasks like managing
    files, sending requests, and accessing a database.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使编写测试更容易、更快之外，这种架构还允许你利用 Cypress 背后的 Node.js 进程来执行诸如管理文件、发送请求和访问数据库等任务。
- en: Furthermore, because **Cypress is a tool created specifically for testing**,
    it offers numerous advantages over tools like Selenium and Puppeteer, which focus
    *only* on browser automation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 **Cypress 是一个专门为测试而创建的工具**，它比只关注浏览器自动化的工具如 Selenium 和 Puppeteer 提供了众多优势。
- en: One of these advantages is that Cypress includes many testing utilities right
    out of the box. Unlike Selenium and Puppeteer, you don’t have to set up an entire
    test environment yourself when using it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势之一是 Cypress 默认就包含了大量的测试实用工具。与 Selenium 和 Puppeteer 不同，当你使用它时，你不需要自己设置整个测试环境。
- en: When using Cypress, you don’t need to pick multiple packages for organizing
    your tests, running assertions, or creating test doubles. Instead, these tools
    are bundled *into* Cypress. **Installing Cypress is all you need to do to start
    writing tests**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Cypress 时，你不需要挑选多个包来组织你的测试、运行断言或创建测试替身。相反，这些工具都打包在 Cypress 中。**安装 Cypress
    是你开始编写测试所需做的全部事情**。
- en: Even Cypress’s APIs are designed with testing in mind. Typical situations you’d
    encounter when writing tests are already built into Cypress’s methods. These APIs
    make tests simpler, concise, and more readable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 的 API 设计时也考虑了测试。你在编写测试时可能会遇到的情况已经内置到 Cypress 的方法中。这些 API 使测试更简单、更简洁、更易读。
- en: Imagine, for example, that you’d like to click a button that appears only a
    few seconds after accessing your application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，你想要点击一个在你访问应用程序后仅几秒钟出现的按钮。
- en: In that case, browser-automation tools would require you write a line of code
    that explicitly tells your test to wait for the button to be visible before trying
    to click it. When using these kinds of tools, your tests will immediately fail
    if they don’t find the element on which they must click.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，浏览器自动化工具将需要你编写一行代码，明确告诉你的测试在尝试点击之前等待按钮可见。当使用这些类型的工具时，如果你的测试没有找到必须点击的元素，它们将立即失败。
- en: Cypress, in contrast, doesn’t require you to write explicit code to wait for
    the button to appear. It will, by default, keep trying to find the button on which
    it wants to click until it reaches a timeout. Cypress will try to perform the
    click only once it finds the button.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，Cypress 不需要你编写显式代码来等待按钮出现。它将默认尝试找到它想要点击的按钮，直到达到超时。Cypress 只在找到按钮后才会尝试执行点击操作。
- en: Among Cypress’s marvelous testing features, another helpful one is the ability
    to “time-travel.” As Cypress runs tests, it takes snapshots of your application
    as it carries them out. After executing tests, you can revisit each of their steps
    and verify how your application looked at any point in time.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cypress 的众多出色测试特性中，另一个有用的特性是“时间旅行”。当 Cypress 运行测试时，它会记录执行过程中的应用程序快照。在执行测试后，你可以回顾每个步骤，并验证你的应用程序在任何时间点的样子。
- en: Being able to see how your application reacts to a test’s actions allows you
    to debug it more quickly and ensure that the test is doing what you intended it
    to do.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 能够看到你的应用程序如何对测试的动作做出反应，让你能够更快地调试它，并确保测试正在执行你想要它执行的操作。
- en: For example, if you have a test that fills out a form, submits it, and expects
    the page to update, you can use the test’s action log to see how your application
    looked at each of these steps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个填写表单、提交并期望页面更新的测试，你可以使用测试的动作日志来查看你的应用程序在每个这些步骤中的样子。
- en: By hovering over each action, you will be able to visualize your application’s
    state before the test fills any fields, after it enters data into each one of
    them, and after submitting the form.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过悬停在每个动作上，你将能够可视化测试填充任何字段之前、进入每个字段数据之后以及提交表单之后的你的应用程序状态。
- en: Because you can run Cypress tests within real browsers, as you go through your
    application’s states, you can examine them in detail using your browser’s developer
    tools.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以在真实浏览器中运行 Cypress 测试，随着你遍历应用程序的状态，你可以使用浏览器开发者工具详细检查它们。
- en: If your test couldn’t find an input to fill, for example, you can travel back
    in time to check whether it existed on the page and whether you’ve used the correct
    selector to find it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试找不到要填充的输入，例如，你可以回到过去检查它是否存在于页面上，以及你是否使用了正确的选择器来找到它。
- en: In addition to inspecting elements, you can use the browser’s debugger to step
    through your application’s code and understand how it responds to the test’s actions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查元素外，你还可以使用浏览器的调试器逐步执行你的应用程序代码，了解它如何响应测试的动作。
- en: When tests detect a bug in your application, you can add break points to your
    application’s code and step through its lines until you understand the bug’s root
    cause.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试检测到你的应用程序中的错误时，你可以在应用程序的代码中添加断点，逐步执行其行，直到你理解错误的根本原因。
- en: 10.3.4 When to choose Cypress
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 何时选择 Cypress
- en: Cypress’s main advantages over other tools stem from being it being a *testing*
    tool rather than a more general browser-automation software. If you’re looking
    for a tool *exclusively* to write tests, I’d almost always recommend Cypress.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 相比其他工具的主要优势在于它是一个 *测试* 工具，而不是更通用的浏览器自动化软件。如果你在寻找一个 *专门* 用于编写测试的工具，我几乎总是推荐
    Cypress。
- en: Choosing Cypress will save you the time of setting up a testing environment.
    When using it, you won’t need to install and configure other packages for organizing
    tests, running assertions, and creating test doubles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Cypress 可以节省设置测试环境的时间。使用它时，你不需要安装和配置其他包来组织测试、运行断言和创建测试替身。
- en: Because Cypress bundles all the essential tools for testing, you can start writing
    tests and getting value from them sooner. Unlike with Selenium and Puppeteer,
    you won’t have to set up multiple pieces of software or create your own testing
    infrastructure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Cypress 包含了所有必要的测试工具，你可以更快地开始编写测试并从中获得价值。与 Selenium 和 Puppeteer 不同，你不需要设置多个软件或创建自己的测试基础设施。
- en: Besides being able to start writing tests earlier, you’ll also be able to write
    them more quickly, thanks to Cypress’s debugging features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够更早开始编写测试之外，Cypress 的调试功能还使你能够更快地编写测试。
- en: Particularly the ability to time-travel and inspect your application’s state
    at any point in time will make it much easier to detect what’s causing a test
    to fail.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是能够穿越时间并检查应用在任何时间点的状态，这将使检测导致测试失败的原因变得更加容易。
- en: Quickly detecting a failure’s root cause enables developers to implement a fix
    in less time and, thus, diminishes the costs of writing tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检测失败的根本原因使开发者能够在更短的时间内实施修复，从而减少了编写测试的成本。
- en: In addition to these debugging features, another factor that makes it quicker
    to write tests using Cypress are its simple and robust APIs, which have retriability
    built into them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些调试功能之外，Cypress 的简单且健壮的 API 也是使其能够更快编写测试的另一个因素，这些 API 内置了可重试性。
- en: Instead of having to explicitly configure tests to wait for a particular element
    to appear or retry failing assertions, as you’d have to do with Puppeteer and
    Selenium, your tests will do that *automatically* and, therefore, will be much
    more robust, intelligible, and concise.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Puppeteer 和 Selenium 不同，你不需要明确配置测试以等待特定元素出现或重试失败的断言，你的测试将*自动*执行这些操作，因此将更加健壮、易于理解且简洁。
- en: Finally, the other two characteristics to consider when choosing Cypress as
    your testing tool are its excellent documentation and comprehensible UI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在选择 Cypress 作为测试工具时，需要考虑的两个其他特点是其出色的文档和易于理解的 UI。
- en: These characteristics improve developers’ experience, causing them to want to
    write better tests more often and, therefore, create more reliable guarantees.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性改善了开发者的体验，使他们更愿意更频繁地编写更好的测试，从而创建更可靠的保证。
- en: The only scenarios in which I’d advocate *against* choosing Cypress is when
    you have to perform tasks other than exclusively running tests, or when you *must*
    support browsers other than Edge, Chrome, and Firefox—the only three web browsers
    Cypress supports.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我唯一会建议不选择 Cypress 的场景是当你必须执行除了专门运行测试之外的任务时，或者当你*必须*支持除了 Edge、Chrome 和 Firefox
    之外的浏览器——这是 Cypress 支持的唯一三个网络浏览器。
- en: I consider Cypress to be the most cost efficient of all the tools presented
    in this chapter, and I believe it will be suitable for the majority of the projects
    you will tackle. Therefore, it is the tool I’ve chosen to use for the examples
    in the next chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 Cypress 是本章中所有工具中最具成本效益的，我相信它将适合你将要处理的多数项目。因此，它是我在下一章示例中选择的工具。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: UI-based end-to-end tests use your application’s interface as the entry point
    for their actions and cover your entire application’s software stack.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 UI 的端到端测试将应用界面作为其操作的入口点，并覆盖整个应用的软件栈。
- en: The more critical and challenging it is to test a feature, the more helpful
    it becomes to have UI-based end-to-end tests for it. When you have critical features
    that are difficult to test, UI-based end-to-end tests can accelerate the process
    of validating your application and make it much more reliable. These tests won’t
    forget any steps and will execute them much faster than a human could.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试一个功能越关键和具有挑战性，拥有基于 UI 的端到端测试就越有帮助。当你有难以测试的关键功能时，基于 UI 的端到端测试可以加速验证应用的过程，并使其更加可靠。这些测试不会忘记任何步骤，并且执行速度比人类快得多。
- en: When UI-based end-to-end tests are too time-consuming to write, and the unit
    under test is not so critical, you should consider writing other kinds of tests
    that can deliver similarly reliable guarantees. If you’re testing a web server,
    for example, you can write end-to-end tests exclusively for its routes. If you’re
    testing a frontend application, you can use `dom-testing-library` or `react-testing`
    library, if you have a React application.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当基于UI的端到端测试编写过于耗时，且被测试的单元不是那么关键时，你应该考虑编写其他类型的测试，这些测试可以提供类似的可靠保证。例如，如果你正在测试一个Web服务器，你可以专门为其路由编写端到端测试。如果你正在测试一个前端应用程序，如果你有一个React应用程序，你可以使用`dom-testing-library`或`react-testing`库。
- en: To write UI-based end-to-end tests, you can integrate browser-automation tools
    like Selenium or Puppeteer with your favorite testing libraries. Alternatively,
    you can opt for a solution like Cypress, Nightwatch.js, or WebdriverIO, which
    bundle testing utilities so that you don’t have to set up a testing infrastructure
    yourself.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编写基于UI的端到端测试，你可以将浏览器自动化工具如Selenium或Puppeteer与你的首选测试库集成。或者，你也可以选择像Cypress、Nightwatch.js或WebdriverIO这样的解决方案，这些解决方案捆绑了测试实用工具，这样你就不需要自己设置测试基础设施。
- en: Selenium interacts with browsers by communicating with a browser’s driver through
    a protocol called JSON Wire, which specifies a set of HTTP requests to send for
    the different actions the browser must execute.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium通过一个名为JSON Wire的协议与浏览器交互，该协议指定了一系列HTTP请求，用于执行浏览器必须执行的不同操作。
- en: Cypress and Puppeteer, unlike Selenium, can directly control a browser instance.
    This capability makes these tools more flexible in terms of testing and makes
    tests quicker to write, but it reduces the number of browsers with which these
    testing tools can interact.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Selenium不同，Cypress和Puppeteer可以直接控制浏览器实例。这种能力使得这些工具在测试方面更加灵活，使得测试编写更快，但减少了这些测试工具可以与之交互的浏览器数量。
- en: The tool on which I’ll focus in this book is Cypress. I’ve chosen it because
    of its flexibility, how easy it is to set up, and its excellent debugging features,
    which include the ability to time travel, see your tests as they run, and record
    them. Most of the time, it is the tool I’d recommend if you don’t plan to support
    browsers such as Internet Explorer.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这本书中，我将重点关注Cypress工具。我选择它是因为它的灵活性、设置简单以及出色的调试功能，包括时间旅行、查看运行中的测试以及记录它们的能力。大多数时候，如果你不打算支持像Internet
    Explorer这样的浏览器，我会推荐这个工具。
