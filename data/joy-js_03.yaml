- en: 2 Inheritance-based object modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 基于继承的对象建模
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Prototypal inheritance, constructor functions, and classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承、构造函数和类
- en: JavaScript’s property resolution mechanism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的属性解析机制
- en: The “prototypal inheritance” oxymoron
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “原型继承”的矛盾
- en: Advantages and drawbacks of classes in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中类的优缺点
- en: '*Merely adding “prototypal” in front to distinguish the actually nearly opposite
    behavior in JavaScript has left in its wake nearly two decades of miry confusion.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “仅仅在前面加上‘原型’来区分 JavaScript 中实际上几乎相反的行为，却留下了近二十年的泥潭般的混乱。”
- en: —Kyle Simpson
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ——凯尔·辛普森
- en: 'Aside from a few primitives, everything in JavaScript is an object. Yet for
    something that we deal with routinely, objects continue to be the most intimidating,
    hard-to-get-right parts of the language. The most common question that I hear
    is “How should I write the prototype chain to relate X, Y, and Z?” Every article
    or book you read does it in slightly different ways, and for some reason, even
    experienced developers need to turn to a search engine to relearn the process
    once in a while. The reason is twofold: on one side, a lot of boilerplate code
    is required, and on the other, we’re confusing the terms inheritance and prototype.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了几个原始类型外，JavaScript 中的所有内容都是对象。然而，对于我们日常处理的东西，对象仍然是语言中最令人畏惧、最难正确使用的一部分。我听到的最常见问题是“我应该如何编写原型链来关联
    X、Y 和 Z？”你读过的每一篇文章或书籍都略有不同，而且出于某种原因，即使是经验丰富的开发者有时也需要通过搜索引擎重新学习这个过程。原因有两个：一方面，需要大量的样板代码，另一方面，我们对继承和原型这两个术语感到困惑。
- en: Inheritance is a powerful pattern of code reuse and is something we’ll take
    advantage of in this book, but we should not limit our understanding of prototypes
    to creating parent-child relationships. Inheritance is only one of the many applications
    of prototypes (and an important one indeed), but prototypes can do much more.
    Because one of the largest segments of JavaScript developers comes from class-oriented
    languages, to ensure their seamless transition, it was decided to make classes
    a first-class citizen of the language in ECMAScript 2015\. Support for classes
    snowballed into a bunch of new features to support private and static properties.
    Once again, JavaScript’s history is tainted with attempts to make it look like
    Java. All this syntax is not welcomed with open arms by many JavaScript purists
    because it masks the underlying mechanics of JavaScript’s great object system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种强大的代码复用模式，我们将在本书中利用它，但我们的原型理解不应该仅限于创建父子关系。继承只是原型众多应用之一（而且确实非常重要），但原型可以做得更多。由于
    JavaScript 开发者中很大一部分来自面向类的语言，为了确保他们能够无缝过渡，ECMAScript 2015 决定将类作为语言的第一等公民。对类的支持演变成了一堆支持私有和静态属性的新功能。JavaScript
    的历史再次被试图让它看起来像 Java 的尝试所玷污。所有这些语法并不是所有 JavaScript 纯粹主义者都欢迎的，因为它掩盖了 JavaScript
    伟大对象系统的底层机制。
- en: 'For better or for worse, a lot of the domain modeling has been moving to use
    the streamlined setup of classes instead of the unnecessary boilerplate code of
    direct prototype configuration. It’s important to have a firm understanding of
    how JavaScript’s object system works, however. In this chapter, we’ll discuss
    two patterns that use the prototype feature to model inheritance relationships:
    constructor functions and ECMAScript 2015 classes. Both these patterns give you
    the benefit of sharing data and behavior through JavaScript’s internal prototype
    references and property resolution mechanism.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不管是好是坏，大量的领域建模已经转向使用类的一站式设置，而不是直接原型配置的不必要样板代码。然而，了解 JavaScript 的对象系统是如何工作的是非常重要的。在本章中，我们将讨论两种使用原型功能来建模继承关系的模式：构造函数和
    ECMAScript 2015 类。这两种模式都通过 JavaScript 的内部原型引用和属性解析机制提供了共享数据和行为的优势。
- en: Let’s begin by reviewing the basic prototype inheritance configuration that
    you’ve probably seen many times.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾你很可能已经看过很多次的基于基本原型继承的配置开始。
- en: 2.1 Reviewing prototypal inheritance
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 回顾原型继承
- en: JavaScript borrowed prototypes from a language called Self. The prototype mechanism
    is a big part of what allows JavaScript to be object-oriented; without it, you
    would not be able to send messages to objects higher up in the hierarchy of a
    complex network of interconnected objects (aka inheritance).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript从名为Self的语言中借用了原型。原型机制是JavaScript能够成为面向对象语言的重要组成部分；没有它，你将无法向复杂网络中更高层次的对象发送消息（即继承）。
- en: In this section, we’ll review the code needed to set up a basic prototype chain
    and lay the groundwork for learning about JavaScript’s property resolution mechanism,
    which is JavaScript’s central mechanism for object access.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾设置基本原型链所需的代码，并为学习JavaScript的属性解析机制打下基础，这是JavaScript访问对象的核心机制。
- en: Given your experience, you’ve probably dabbled with objects and their prototypes,
    so I’ll jump straight into some code. The first API we’ll look at to establish
    what looks like a parent-to-child relationship is
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的经验，你可能已经尝试过对象及其原型，所以我会直接进入一些代码。我们将首先查看的API是建立类似父子关系的
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This API creates a new object linked to a prototype and optionally accompanied
    by a collection of new property definitions. For now, we’ll focus only on the
    first argument (`proto`), as shown in the following listing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此API创建了一个链接到原型的新对象，并可选择地附带一组新的属性定义。现在，我们将只关注第一个参数（`proto`），如下面的列表所示。
- en: Listing 2.1 Using `Object.create` to create an object from a prototype
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 使用`Object.create`从原型创建对象
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Using Object.create to configure a new child object based on a parent object
    (proto). Internally, the child object has a reference to the parent to access
    any of its properties. Another way to do this is to call the Object.setPrototypeOf(child,
    proto) API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用`Object.create`根据父对象（proto）配置一个新的子对象。内部，子对象有一个引用指向父对象，以便访问其任何属性。另一种方法是调用`Object.setPrototypeOf(child,
    proto)` API。
- en: With this code, any properties of the parent (`proto`) object, hereafter called
    the prototype, are accessible from the child object. Nothing interesting is going
    on here, let’s do something more meaningful and model our first blockchain concept,
    a transaction.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，可以从子对象访问父对象（`proto`）的任何属性。这里没有发生任何有趣的事情，让我们做一些更有意义的事情，并模拟我们的第一个区块链概念，一笔交易。
- en: A transaction represents an exchange of certain goods, such as money, from a
    sender to a receiver. For the most part, a transaction in the blockchain world
    looks exactly like that of a traditional banking system. To start, we’ll make
    `sender` and `recipient` simple email addresses and `funds` a number of fake Bitcoin
    amount as our form of currency. In our example, Luke uses Bitcoin from his digital
    wallet to buy coffee from Ana’s Café, as shown in figure 2.1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一笔交易代表了一定商品（如货币）从发送者到接收者的交换。在区块链世界中，交易看起来几乎与传统银行系统一模一样。首先，我们将把`sender`和`recipient`设置为简单的电子邮件地址，将`funds`设为一定数量的虚拟比特币作为我们的货币形式。在我们的例子中，Luke使用他的数字钱包中的比特币从Ana的咖啡馆购买咖啡，如图2.1所示。
- en: '![](../Images/2-1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-1.png)'
- en: Figure 2.1 A transaction object captures the details of a sender (Luke) sending
    Bitcoin to a receiver (Ana) to purchase coffee.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 一笔交易对象捕捉了发送者（Luke）向接收者（Ana）发送比特币以购买咖啡的详细信息。
- en: Let’s begin constructing this example. Listing 2.2 uses `Object.create` to establish
    a prototype configuration between two objects, `moneyTransaction` and `transaction`,
    and adds support for `funds`. In the wild, you’ll find some slight variations
    of this setup, but the general idea is always the same.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建这个例子。列表2.2使用`Object.create`在两个对象`moneyTransaction`和`transaction`之间建立原型配置，并添加了对`funds`的支持。在现实世界中，你会发现一些对这个设置的轻微变化，但总体思想始终相同。
- en: Listing 2.2 Transaction objects linked by a basic prototype setup
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 通过基本原型设置链接的交易对象
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Prototype object from which to derive other objects—a regular object, not
    some abstract blueprint
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从中派生其他对象的原型对象——一个普通对象，而不是某种抽象蓝图
- en: ❷ Creates a derived object from the prototype
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从原型创建一个派生对象
- en: ❸ Adds new methods to the child object. Repeating the function name in the declaration
    helps build more-informative stack traces.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向子对象添加新方法。在声明中重复函数名称有助于构建更丰富的堆栈跟踪。
- en: Let’s check whether our assumptions continue to be valid in the next listing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的假设在下一个列表中是否仍然有效。
- en: Listing 2.3 Inspecting the new transaction objects
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 检查新的交易对象
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Checks whether the prototype link has been established
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查原型链接是否已建立
- en: ❷ Verifies that inherited properties are accessible from the child object
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证从子对象中可以访问继承属性
- en: Let’s unpack listing 2.2 a bit further. The prototype object (`transaction`)
    is in fact an arbitrary object literal that we’ll use to group common properties.
    As you can see, prototypes are objects that can be manipulated at any time, even
    at runtime, not created from thin air at the point of forming an inheritance association.
    This fact is important to understand; we’ll come back to why it matters when we
    talk about classes in section 2.3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步解析列表 2.2。原型对象（`transaction`）实际上是一个任意的对象字面量，我们将用它来分组常见的属性。正如你所看到的，原型是可以在任何时间（甚至是在运行时）进行操作的对象，而不是在形成继承关联时凭空创建的。这个事实很重要，我们将在第
    2.3 节讨论它为什么重要。
- en: 'Here’s another take on this code, using `Object.create`’s second parameter,
    which receives an object of data descriptors:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于这段代码的另一种看法，使用了 `Object.create` 的第二个参数，它接收一个数据描述符的对象：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This second argument gives us fine control over how this newly created object’s
    properties behave:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数让我们能够精细控制这个新创建的对象属性的行为：
- en: Enumerable — Controls whether the property can be enumerated or viewed (as when
    you pass the object to `console.log`, enumerating the keys with `Object .keys`),
    or whether it’s seen by `Object.assign` (a topic that we’ll circle back to in
    chapter 3).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可枚举的 —— 控制属性是否可以被枚举或查看（例如，当你将对象传递给 `console.log` 时，使用 `Object.keys` 枚举键），或者是否被
    `Object.assign` 所看到（我们将在第 3 章中再次讨论这个话题）。
- en: Configurable — Controls whether you’re allowed to delete an object’s property
    with the `delete` keyword or whether you can reconfigure the field’s property
    descriptor. Deleting a property alters the shape of an object and makes your code
    more unpredictable, which is why I prefer to use this attribute’s default value
    (`false`) or omit it from the data descriptor.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的 —— 控制是否允许使用 `delete` 关键字删除对象的属性，或者是否可以重新配置字段的属性描述符。删除属性会改变对象的形状，并使你的代码更加不可预测，这就是为什么我更喜欢使用这个属性的默认值（`false`）或者从数据描述符中省略它。
- en: Writable — Controls whether you can reassign the value of this field, effectively
    making its assignment immutable.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写的 —— 控制你是否可以重新分配这个字段的值，从而使其赋值不可变。
- en: When you create a property by using the dot notation directly on the object,
    as in listing 2.2, that act is equivalent to defining a property with a descriptor
    with all settings set to `true`. Typically, most developers don’t bother with
    data descriptors, but they can come in handy when you’re writing your own libraries
    and frameworks for others to use and want to do things such as hide a certain
    field from view or make some fields immutable. Data descriptors help enforce certain
    design principles and communicate clear intentions about how your APIs work. We’ll
    come back to this issue of immutability and why it’s important in chapter 4.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你直接在对象上使用点符号创建属性，就像列表 2.2 中那样，这个行为等同于使用所有设置都设置为 `true` 的描述符定义一个属性。通常，大多数开发者不会去麻烦使用数据描述符，但当你编写供他人使用的库和框架时，它们可能会很有用，比如隐藏某些字段或使某些字段不可变。数据描述符有助于强制执行某些设计原则，并清楚地传达你的
    API 的工作方式。我们将在第 4 章中回到不可变性和它为什么重要的这个问题。
- en: As you can see, `Object.create` offers a simple, elegant way to create objects
    from a shared prototype and establishes the proper inheritance linkage to resolve
    property lookups.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Object.create` 提供了一种简单、优雅的方式来从共享原型创建对象，并建立了适当的继承链接以解决属性查找。
- en: 2.1.1 Property resolution process
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 属性解析过程
- en: A discussion of JavaScript’s prototype mechanism is moot without a discussion
    of its property lookup mechanism, which is the most important concept behind implementing
    object-oriented patterns in JavaScript. According to the ECMAScript specification,
    an internal reference known as `[[Prototype]]` (accessible via the `__proto__`
    property in objects) is configured by `Object.create` and effectively links `moneyTransaction`
    to `transaction`, as shown in figure 2.2\. This is the sole reason why we can
    properly resolve `moneyTransaction.sender` to the value `'luis@tjoj.com'`, as
    shown in figure 2.2.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不讨论 JavaScript 的原型机制，不讨论其属性查找机制，这是在 JavaScript 中实现面向对象模式背后的最重要的概念。根据 ECMAScript
    规范，一个称为 `[[Prototype]]` 的内部引用（在对象中通过 `__proto__` 属性访问）由 `Object.create` 配置，并将
    `moneyTransaction` 与 `transaction` 链接起来，如图 2.2 所示。这就是我们能够正确解析 `moneyTransaction.sender`
    为 `'luis@tjoj.com'` 的唯一原因，如图 2.2 所示。
- en: '![](../Images/2-2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-2.png)'
- en: Figure 2.2 The internal reference `[[Prototype]]` is used to link an object
    (`moneyTransaction`) to another (`transaction`) in a unidirectional fashion, eventually
    ending in `Object.prototype`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 内部引用`[[Prototype]]`以单向方式将一个对象（`moneyTransaction`）链接到另一个对象（`transaction`），最终结束于`Object.prototype`。
- en: This figure points out the relationship among the objects through the prototype
    chain, which guides the JavaScript engine to find a property by a certain key.
    I’ll explain this process in more detail. When requesting a member field, the
    JavaScript engine first looks for the property in the calling object. If JavaScript
    can’t find the property there, it looks in [[Prototype]]. The property `sender`
    is not declared in `moneyTransaction`, yet it still resolves successfully. Why?
    Any property access or method invocation in `moneyTransaction` will travel up
    the prototype chain, continuing to `transaction` until it finds the property there
    and returns it. But what if it doesn’t? The lookup process would continue further,
    finally terminating at the empty object literal `{}` (aka `Object.prototype`).
    If resolution fails, the result of the operation is `undefined` for a value property
    or a `TypeError` for a function-valued property.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此图通过原型链指出了对象之间的关系，这指导JavaScript引擎通过特定的键来查找属性。我将更详细地解释这个过程。当请求成员字段时，JavaScript引擎首先在调用对象中查找该属性。如果JavaScript在那里找不到该属性，它会在`[[Prototype]]`中查找。属性`sender`在`moneyTransaction`中未声明，但它仍然成功解析。为什么？在`moneyTransaction`中的任何属性访问或方法调用都会沿着原型链向上传递，继续到`transaction`，直到找到该属性并返回它。但如果找不到呢？查找过程将继续进行，最终终止在空对象字面量`{}`（也称为`Object.prototype`）。如果解析失败，值属性的运算结果是`undefined`，函数值属性的运算结果是`TypeError`。
- en: Behind the scenes, you can think of the hidden `__proto__` property as being
    the bridge that allows you to traverse the chain. When we use prototypes to implement
    inheritance, which is the most common scenario, we say that property resolution
    “moves up” the inheritance chain.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，你可以将隐藏的`__proto__`属性视为允许你遍历链的桥梁。当我们使用原型来实现继承，这是最常见的场景时，我们说属性解析“向上”移动到继承链。
- en: 'You should never use `__proto__` directly in your applications, as it’s meant
    to be used internally by the JavaScript engine. Hypothetically, if surfaced in
    userland code, it would look something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该直接在你的应用程序中使用`__proto__`，因为它是为了让JavaScript引擎内部使用而设计的。假设在用户代码中暴露出来，它可能看起来是这样的：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: NOTE The use of `__proto__` has been the subject of a heated debate over the
    years, and it’s currently being deprecated. It was standardized in ECMAScript
    2015 as a legacy feature only so that web browsers and other JavaScript runtimes
    could maintain compatibility. Please don’t use it directly (even though you might
    see it used in the book for teaching purposes), as it might cease to work after
    some time. If you need to manipulate this field, the recommended APIs are `Object.getPrototypeOf`
    and `Object.setPrototypeOf`. You can also call the `Object#isPrototypeOf` method
    directly on the object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`__proto__`的使用多年来一直是激烈争论的主题，并且目前正被弃用。它在ECMAScript 2015中被标准化为仅作为遗留功能，以便网络浏览器和其他JavaScript运行时能够保持兼容性。请不要直接使用它（尽管你可能会在书中看到用于教学目的的使用），因为它可能在一段时间后停止工作。如果你需要操作这个字段，推荐使用的API是`Object.getPrototypeOf`和`Object.setPrototypeOf`。你还可以直接在对象上调用`Object#isPrototypeOf`方法。
- en: 'With regard to notation, when referring to a property accessible from a con`structor
    function’s prototype, as in Object.prototype.isPrototypeOf, throughou`t this book
    the # symbol is used instead: `Object#isPrototypeOf`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于符号的使用，当从构造函数的原型中引用一个属性时，例如`Object.prototype.isPrototypeOf`，在这本书中，我们使用`#`符号代替：`Object#isPrototypeOf`。
- en: Figure 2.2 looks straightforward but can get tricky with long, intertwined object
    graphs. I won’t delve into those specific use cases to keep the discussion centered
    on object construction techniques, but you can find out more by exploring the
    great resources in the following sidebar.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2看起来很简单，但处理长而复杂的对象图时可能会变得复杂。我不会深入探讨这些特定的用例，以保持讨论集中在对象构造技术上，但你可以在以下侧边栏中找到更多相关信息。
- en: Understanding the idiosyncrasies of JavaScript objects
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 理解JavaScript对象的特性
- en: In this book, we’ll be using well-formed, simple object hierarchies, so we won’t
    go into detail about what things can go wrong when prototype chains are broken
    or when properties in an object are shadowed. The ins and out of JavaScript objects
    could easily take up an entire book. In fact, an amazing book series by Kyle Simpson,
    You Don’t Know JS ([https://github.com/getify/You-Dont-Know-JS/tree/1st-ed](https://github.com/getify/You-Dont-Know-JS/tree/1st-ed)),
    describes this example in great detail. The series dives deeply into the nuances
    of manipulating object chains, offers lots of good tips and best practices for
    behavior delegation (which we’ll study in chapter 3), and debunks the myths behind
    object creation and the prototype mechanism. This series has been a great inspiration
    and has highly influenced the way I code JavaScript today. It should be on every
    JavaScript developer’s bookshelf.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用良好形成的简单对象层次结构，因此我们不会详细讨论原型链断裂或对象中的属性被覆盖时可能出错的事情。JavaScript 对象的内部和外部可能很容易占据整本书。事实上，Kyle
    Simpson 的一个令人惊叹的书系《你不知道的 JavaScript》（[https://github.com/getify/You-Dont-Know-JS/tree/1st-ed](https://github.com/getify/You-Dont-Know-JS/tree/1st-ed)）详细描述了这个例子。该系列深入探讨了操作对象链的细微差别，提供了许多关于行为委托（我们将在第
    3 章学习）的好建议和最佳实践，并揭穿了对象创建和原型机制背后的神话。这个系列对我来说是一个巨大的灵感，并且极大地影响了今天我编写 JavaScript 的方式。它应该在每个
    JavaScript 开发者的书架上。
- en: Now that we’ve reviewed the basic prototype setup in JavaScript, let’s discuss
    why it’s fundamentally inaccurate to use the overloaded term inheritance to describe
    JavaScript’s object-oriented model.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了 JavaScript 中的基本原型设置，让我们讨论为什么使用重载术语继承来描述 JavaScript 的面向对象模型在本质上是不准确的。
- en: 2.1.2 Differential inheritance
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 差分继承
- en: Differential inheritance, in which derived objects maintain references to the
    objects from which they are derived, is common in prototypal languages. In JavaScript,
    differential inheritance is called [[Prototype]]. By contrast, in class-based
    inheritance, a derived object copies all the state and behavior from its own class,
    as well as all its derived classes. The key distinction is copy versus link.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 差分继承，其中派生对象保留对其派生对象的引用，在原型语言中很常见。在 JavaScript 中，差分继承被称为 [[Prototype]]。相比之下，在基于类的继承中，派生对象从其自身类以及所有派生类复制所有状态和行为。关键的区别是复制与链接。
- en: Although this term sounds a bit intimidating, differential inheritance is a
    simple concept referring to how extended behavior separates a derived object from
    its linked generic parent. If you think about a JavaScript object as being a dynamic
    bag of properties, differentiation means adding properties to another bag and
    linking the two bags. As you saw in figure 2.2, because the prototype resolution
    mechanism flows unidirectionally from a calling object to its linked object (and
    so on), any newly derived object is meant to differentiate itself from its parent
    with new behavior. New behavior includes adding new properties or even overriding
    an existing property from a linked object (known as shadowing). I don’t cover
    shadowing in this book, but you can visit [http://mng.bz/OEmR](http://mng.bz/OEmR)
    for more information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个术语听起来有点令人畏惧，但差分继承是一个简单的概念，指的是扩展行为如何将派生对象与其链接的通用父对象区分开来。如果你把 JavaScript 对象想象成一个动态的属性包，那么差异化意味着向另一个包添加属性并将两个包链接起来。正如你在图
    2.2 中所看到的，因为原型解析机制从调用对象单向流向其链接的对象（等等），任何新派生的对象都旨在通过新行为与父对象区分开来。新行为包括添加新属性或甚至覆盖来自链接对象的现有属性（称为覆盖）。我在这本书中不涉及覆盖，但你可以在
    [http://mng.bz/OEmR](http://mng.bz/OEmR) 上了解更多信息。
- en: Consider another scenario in which we extend the generic `transaction` object
    to define `hashTransaction`. This object differentiates itself from its parent
    by adding a function (`calculateHash`) to compute its own hash value. At a high
    level, hashing is using an object’s state to generate a unique string value, much
    as `JSON.stringify` does, but we need to target only the values, not the entire
    shape of the object. This hash value has many uses in industry, such as fast insert/retrieval
    from hash tables or dictionaries, as well as data integrity checks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一种场景，其中我们将通用的 `transaction` 对象扩展以定义 `hashTransaction`。此对象通过添加一个用于计算其自身哈希值的函数（`calculateHash`）来与父对象区分开来。从高层次来看，哈希化是使用对象的状态生成一个唯一的字符串值，就像
    `JSON.stringify` 所做的那样，但我们只需要针对值，而不是整个对象的结构。此哈希值在工业界有许多用途，例如从哈希表或字典中快速插入/检索，以及数据完整性检查。
- en: In the world of blockchains, a hash is typically used as a `transactionId` that
    uniquely identifies a certain transaction that took place. For simplicity, we’ll
    start with a simple (insecure) hashing function in the next listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链的世界里，哈希通常用作`transactionId`，以唯一标识发生的一定交易。为了简单起见，我们将在下一个列表中从简单的（不安全的）哈希函数开始。
- en: Listing 2.4 Creating `hashTransaction` with basic hashing calculation
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 使用基本的哈希计算创建`hashTransaction`
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Adds a method to calculate its own hash
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个计算自身哈希的方法
- en: ❷ Properties that become input to the hashing algorithm
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 成为哈希算法输入的属性
- en: ❸ Uses the exponentiation operator to square the hash value
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用指数运算符平方哈希值
- en: 'To take another approach, you can also use `Object.setPrototypeOf` to differentiate
    a child object. Suppose that you want to extend `moneyTransaction` from `hashTransaction`.
    All the same mechanisms apply:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 采用另一种方法，你也可以使用`Object.setPrototypeOf`来区分子对象。假设你想要从`hashTransaction`扩展`moneyTransaction`。所有相同的机制都适用：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we’ve reviewed a couple of examples involving simple object literals,
    it’s much more useful to create new transactions with different data in them.
    Section 2.2 jumps into using constructor functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了一些涉及简单对象字面量的例子，创建具有不同数据的新的交易就更有用了。第2.2节跳入使用构造函数。
- en: 2.2 Constructor functions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 构造函数
- en: The constructor functions (aka object constructors pattern) have been the modus
    operandi for building objects in JavaScript for many years. Although object literals
    offer a terse way to define a single object, this method doesn’t scale when you
    need to create hundreds of objects of the same shape. In this case, the constructor
    function acts as a template to initialize objects populated with different data.
    You’re probably familiar with this pattern, but this section discusses some advanced
    techniques that you may not have encountered before.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数（也称为对象构造函数模式）多年来一直是JavaScript中构建对象的方法。尽管对象字面量提供了一种简洁的方式来定义单个对象，但当需要创建数百个形状相同的对象时，这种方法并不适用。在这种情况下，构造函数充当一个模板，用于初始化填充了不同数据的对象。你可能熟悉这个模式，但本节讨论了一些你可能之前未曾遇到的高级技术。
- en: 2.2.1 Functions as templates
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 函数作为模板
- en: Using functions instead of straight object literals to build objects allows
    your model to better evolve because you have much more control of how the objects
    are built. Functions allow you to export a facade to the caller under which changes
    don’t necessarily need to propagate to the calling code. The details of how an
    object gets initialized, such as enforcing any preconditions, are properly tucked
    away inside the constructor.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数而不是直接的对象字面量来构建对象可以让你的模型更好地进化，因为你对对象的构建有更多的控制。函数允许你向调用者导出一个外观，其中更改不一定需要传播到调用代码。对象初始化的细节，例如强制执行任何先决条件，都适当地隐藏在构造函数内部。
- en: 'The following code snippet, for example, never reveals unnecessary details
    about the shape of `HashTransaction` or any operations that might take place during
    instantiation. Encapsulation is always a good choice:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段从不透露关于`HashTransaction`形状的任何不必要的细节，或者可能在实例化过程中发生的任何操作。封装始终是一个好的选择：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This fundamental design decision makes your code less fragile and more maintainable,
    so in most cases, using functions to build objects is the preferred approach.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的设计决策使你的代码更不易破碎且更易于维护，因此在大多数情况下，使用函数来构建对象是首选的方法。
- en: By convention, a constructor function name is capitalized to denote a kind of
    poor man’s class, if you will. Let’s take the use case from listing 2.4 and refactor
    it using constructors (listing 2.5). We have several options here. The simplest
    way to have an object inherit properties from another is to add all its properties
    to this new object; there’s no need to rely on the prototype chain. Because your
    objects are created dynamically (when the function is invoked), you need to pack
    these properties (fill the bag) into a single object context (`this`) within each
    constructor invocation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，构造函数的名称首字母大写，以表示一种穷人的类。让我们从列表2.4中的用例开始，使用构造函数进行重构（列表2.5）。这里有几个选择。将所有属性添加到这个新对象中，以便对象从另一个对象继承属性的最简单方法是；不需要依赖于原型链。因为你的对象是动态创建的（当函数被调用时），你需要将这些属性（装满袋子）打包到每个构造函数调用中的单个对象上下文（`this`）中。
- en: Listing 2.5 Building and linking objects using the constructor functions pattern
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 使用构造函数模式构建和链接对象
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Base constructor
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基础构造函数
- en: ❷ Detects whether the instantiation of the child object omits the new keyword
    and fixes the call. This line helps developers who forget to write new. I’ll come
    back to this topic in section 2.2.2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检测子对象实例化时是否省略了新关键字，并修复调用。这一行帮助那些忘记写 `new` 的开发者。我将在第 2.2.2 节中回到这个话题。
- en: ❸ Calls the parent’s constructor to initialize any parent member properties
    into this object’s context
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用父构造函数以将任何父成员属性初始化到当前对象上下文中
- en: ❹ Adds a new calculateHash method to every instance created
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为创建的每个实例添加一个新的 calculateHash 方法
- en: ❺ Uses the new keyword to instantiate new objects. The new keyword is required
    to pass the newly created object as the this context.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用新关键字实例化新对象。新关键字是必需的，以便将新创建的对象作为 `this` 上下文传递。
- en: By using functions, you can easily instantiate as many `HashTransaction` objects
    as you like, all of them containing the properties defined in `Transaction` as
    well. One caveat is that you need to call the function with the `new` keyword
    to ensure the context (`this`) is initialized properly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用函数，你可以轻松地实例化任意数量的 `HashTransaction` 对象，它们都包含在 `Transaction` 中定义的属性。需要注意的是，你需要使用
    `new` 关键字调用函数，以确保上下文（`this`）被正确初始化。
- en: 'These objects do not share references to any properties, however. You defined
    `calculateHash` directly on `HashTransaction`’s context (`this` variable), for
    example, adding a new `calculateHash` property to each instance of `HashTransaction`.
    In other words, if you create two instances, you’ll see two copies of the same
    method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象不共享任何属性的引用。你直接在 `HashTransaction` 的上下文（`this` 变量）上定义了 `calculateHash`，例如，为
    `HashTransaction` 的每个实例添加一个新的 `calculateHash` 属性。换句话说，如果你创建了两个实例，你会看到相同方法的两个副本：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To fix this problem, you need to configure how prototypes links are set up as
    new objects are created.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要配置原型链接的设置方式，以便在创建新对象时。
- en: 2.2.2 Sharing properties by using constructors and prototypes
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 通过构造函数和原型共享属性
- en: 'One interesting aspect of using constructors is that for every constructor
    `F`, JavaScript automatically creates the object `F.prototype`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数的一个有趣方面是，对于每个构造函数 `F`，JavaScript 会自动创建对象 `F.prototype`：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This object is added to facilitate code sharing and reuse, especially with
    methods, where it’s unnecessary to define more than one copy. Hence, a more optimal
    approach is to add `calculateHash` to `HashTransaction`’s `prototype` so that
    it’s shared among all `HashTransaction` instances, for example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象被添加以促进代码共享和重用，尤其是在方法方面，其中不需要定义多个副本。因此，更优的方法是将 `calculateHash` 添加到 `HashTransaction`
    的 `prototype` 中，使其在所有 `HashTransaction` 实例之间共享，例如：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this slight twist, these two properties refer to the same memory location:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种轻微的变化，这两个属性指向相同的内存位置：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The same applies to any methods added to `Transaction.prototype`. Suppose that
    you add a new method called `displayTransaction` that you want all objects to
    share:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于添加到 `Transaction.prototype` 的任何方法。假设你添加了一个名为 `displayTransaction` 的新方法，你希望所有对象都共享：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As the code is set up, calling it would yield a `TypeError`, indicating that
    the JavaScript engine tried to resolve that property but couldn’t:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码设置好时，调用它会产生一个 `TypeError`，表示 JavaScript 引擎尝试解析该属性，但无法解析：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This error is expected because you had not configured the prototype chain:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是预期的，因为你没有配置原型链：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can fix this problem easily. As before, you can use `Object.create`. The
    following listing shows the complete prototype configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地解决这个问题。和之前一样，你可以使用 `Object.create`。下面的列表显示了完整的原型配置。
- en: Listing 2.6 Configuring the prototype chain using the constructor functions
    pattern
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 使用构造函数模式配置原型链
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Links prototypes for the lookup mechanism to work in case you need to resolve
    properties from Transaction.prototype
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为查找机制链接原型，以便在需要从 `Transaction.prototype` 解析属性时工作
- en: ❷ Fixes or sets the constructor value. Without this line, tx would be a Transaction
    object or constructed from Transaction.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 修复或设置构造函数值。没有这一行，tx 将是一个 Transaction 对象或从 Transaction 构造而来。
- en: From the caller’s point of view, whether you pack all the properties into a
    single object or use prototype resolution, both pieces of code behave and are
    called in exactly the same way. Internally, the object layout in memory is different,
    but it’s abstracted away by the powerful and efficient JavaScript engine. Figure
    2.3 illustrates the inner workings of listing 2.6.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用者的角度来看，无论你是将所有属性打包成一个单独的对象，还是使用原型解析，这两段代码的行为和调用方式都是完全相同的。在内部，内存中的对象布局是不同的，但是强大的、高效的
    JavaScript 引擎将其抽象化。图 2.3 展示了列表 2.6 的内部工作原理。
- en: '![](../Images/2-3.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-3.png)'
- en: Figure 2.3 The instantiation of `tx` per listing 2.6, together with a complete
    picture of all prototype links and constructor references. In JavaScript, constructor
    functions automatically obtain a reference to the `prototype` property upon instantiation
    with the `new` keyword. The navigation annotated with [[Prototype]] represents
    the internal `__proto__` link between objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：根据列表 2.6 实例化 `tx`，以及所有原型链接和构造函数引用的完整图景。在 JavaScript 中，构造函数函数在用 `new` 关键字实例化时会自动获得
    `prototype` 属性的引用。用 [[Prototype]] 标注的导航表示对象之间的内部 `__proto__` 链接。
- en: Although constructor functions are a bit more sophisticated and powerful than
    traditional object literals, the drawback of using this pattern is that it leaks
    a lot of the internal plumbing of JavaScript’s prototype mechanism, as you need
    to deal with the nitty-gritty details of the prototype configuration. If you don’t
    write everything perfectly, you run the risk of strange and unexpected behavior.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构造函数函数比传统的对象字面量更复杂、更强大，但使用这种模式的缺点是它会泄露 JavaScript 原型机制的大量内部结构，因为你需要处理原型配置的细节。如果你没有完美地写出所有内容，你就有可能出现奇怪和意外的行为。
- en: Difference between __proto__ and prototype
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`__proto__` 和 `prototype` 的区别'
- en: 'Reading the sample code, you have encountered references to two properties:
    `__proto__` and `prototype`. As I said earlier, `__proto__` is discouraged, but
    `prototype` isn’t. In case you’re wondering what the difference is, `__proto__`is
    the object used in the lookup chain to resolve methods, whereas `prototype` is
    the object used to build`__proto__`when you create an object with `new.`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读示例代码，你已经遇到了对两个属性的引用：`__proto__` 和 `prototype`。正如我之前所说的，`__proto__` 是不被推荐的，但
    `prototype` 不是。如果你想知道它们之间的区别，`__proto__` 是在查找链中用于解析方法的对象，而 `prototype` 是在用 `new`
    创建对象时用于构建 `__proto__` 的对象。
- en: 'As mentioned earlier, always remember to call the constructor with `new`. Many
    developers forget. Again, using the `new` keyword with a function implicitly sets
    what `this` points to in newly created objects. This task has been a nuisance
    because forgetting to write it changes the resulting object’s context, so we needed
    to include the defensive bit of code I highlighted earlier:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，始终记得用 `new` 调用构造函数。许多开发者会忘记这一点。再次强调，使用 `new` 关键字与函数隐式地设置新创建的对象中 `this`
    的指向。这项任务一直是个麻烦，因为忘记写它会改变结果对象的作用域，因此我们需要包含我之前突出显示的防御性代码：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Old-timers probably remember that the workaround (pre-ECMAScript 2015) was to
    insert the control in the following listing into the body of each constructor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 老手可能还记得，在 ECMAScript 2015 之前的工作区（workaround）是将以下列表中的控制代码插入到每个构造函数体中。
- en: Listing 2.7 Pre-ECMAScript 2015 way to check for proper constructor call
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7：在 ECMAScript 2015 之前检查正确构造函数调用的方法
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s look at what could happen if you didn’t. Suppose that instead of writing
    the preceding control code, you left it as
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果你没有这样做会发生什么。假设你没有写前面的控制代码，而是让它保持原样：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then you tried to create a new instance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你尝试创建一个新的实例：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Oops! This code throws a `TypeError` because the implicit `this` context is
    `undefined`. The error message is alluding to setting a member property of `undefined`,
    but not to the actual user error:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这段代码抛出了一个 `TypeError`，因为隐式的 `this` 上下文是 `undefined`。错误信息暗示了设置 `undefined`
    的成员属性，但没有指出实际的用户错误：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the developer forgot to write `new` in front of the function call:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，开发者忘记在函数调用前写上 `new`：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let’s look at a different, more subtle trap. Suppose that we want transactions
    to have a descriptive name too:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个不同、更微妙的陷阱。假设我们想让事务也有一个描述性的名称：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now create a new instance:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的实例：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Boom! Another type error occurs. This time, the error is even more cryptic
    and doesn’t happen in all JavaScript engines:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 咔嚓！又发生了一个类型错误。这次，错误甚至更加隐晦，并且并非在所有 JavaScript 引擎中都会发生：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Can you find the issue? Don’t worry; I’ll spare you from wasting your time.
    The issue is forgetting to link prototypes correctly. The code should have read
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到问题吗？别担心，我会让你节省时间。问题是忘记正确链接原型。代码应该是这样的
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, writing this code manually every time is painful, leading to different
    behavior that easily escapes you or any linting tool you use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，每次手动编写这段代码都是痛苦的，导致不同的行为，这些行为很容易逃出你的注意或任何你使用的linting工具。
- en: Reducing boilerplate
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 减少样板代码
- en: Using the Node.js `util` library, you can cut down a bit on boilerplate code
    so that you can avoid making some mistakes. Instead of explicitly writing the
    prototype augmentation statement
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js的`util`库，你可以减少一些样板代码，从而避免犯一些错误。而不是明确地编写原型增强语句
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'you can use `util.inherits` to accomplish the same task, saving you from making
    the same mistake again:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`util.inherits`来完成同样的任务，避免你再次犯同样的错误：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you read the documentation, however, you’ll find that the Node.js community
    discourages this practice in favor of using `class` and `extends`, indicating
    that calling `inherits` with prototypes is “semantically incompatible.” You don’t
    say! Earlier, I briefly alluded to the fact that prototypes and classes are incompatible.
    Section 2.3 evaluates this topic in detail.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你阅读文档，你会发现Node.js社区不鼓励这种做法，而是倾向于使用`class`和`extends`，表明使用原型调用`inherits`是“语义上不兼容的”。你不说！早些时候，我简要地提到了原型和类不兼容的事实。第2.3节将详细评估这个主题。
- en: 'This idea of using a constructor function with `new` to create new instances
    is what we know today as the pseudoclassical model. With the advent of ECMAScript
    2015, this model has been largely replaced by a more familiar, streamlined class-oriented
    model that also addresses the amount of boilerplate needed. In fact, with classes,
    forgetting to write `new` when invoking a constructor now generates a clear error,
    as in this example for a `Transaction` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数和`new`来创建新实例的想法，就是我们今天所知道的伪类模型。随着ECMAScript 2015的出现，这个模型已经被一个更熟悉、更精简的面向类模型所取代，同时也解决了所需的样板代码量。实际上，使用类时，在调用构造函数时忘记写`new`会生成一个清晰的错误，就像这个`Transaction`类的例子一样：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Section 2.3 explores the advantages of classes, as well as some of the newer
    proposals that accompany them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.3节探讨了类的好处，以及伴随它们的一些新提议。
- en: 2.3 Class-based inheritance
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 基于类的继承
- en: In this section, we’ll pick up the discussion of the classes and prototypes
    dichotomy. Next, we’ll look at how the mental model of classes makes it simpler
    to represent inheritance hierarchies, as well as provide the syntactical advantage
    of cleaning up and smoothing the rough edges over the complex boilerplate code
    of constructor functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续讨论类和原型二分法。接下来，我们将探讨类的心理模型如何使表示继承层次结构更简单，以及提供清理和平滑构造函数复杂样板代码的语法优势。
- en: We’ve been trained to think that the only form of object orientation is through
    classes, and that’s not the case. Class-oriented does not equate to object-oriented,
    and JavaScript was an object-oriented language long before classes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被训练去认为，唯一的形式的面向对象是通过类，但这并不是事实。面向类并不等同于面向对象，JavaScript在类出现之前就已经是一种面向对象的语言。
- en: Classes were introduced to solve a specific problem, which is to make domain
    modeling in terms of inheritance easier, especially for developers coming from
    class-oriented languages such as Java, C#, and TypeScript. All the cruft and boilerplate
    code of prototype references had to be removed. Ideally, TC39 should have done
    this in a way that remained compatible with JavaScript’s origins, but the community
    clamored for the familiar class-like design.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类的引入是为了解决一个特定的问题，即为了使基于继承的领域建模更容易，特别是对于来自像Java、C#和TypeScript这样的面向类语言的开发者来说。所有原型引用的冗余和样板代码都必须被移除。理想情况下，TC39应该以一种保持与JavaScript起源兼容的方式来做这件事，但社区强烈要求熟悉的类样式的结构。
- en: In a language such as Java, a class is the basic unit of computation. Every
    object derives from some class, which provides the template that gets filled with
    data and allocated in memory during the process of instantiation. During this
    time, all of a class’s member properties, together with any inherited properties,
    get copied into a new object and populated at construction time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Java这样的语言中，类是计算的基本单位。每个对象都从某个类派生，这个类提供了在实例化过程中填充数据并在内存中分配的模板。在这段时间里，一个类的所有成员属性，以及任何继承的属性，都会被复制到一个新对象中，并在构造时填充。
- en: As you learned in section 2.2\. however, prototypes in JavaScript work differently.
    Prototypes are well-formed, concrete objects that get created at the same time
    they are declared (object literal) or as a byproduct of calling a function (constructor
    function), not through a separate instantiation process involving some inanimate
    blueprint or template. In fact, you can use a prototype object as you would any
    other before it’s even added to any inheritance chain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如你在第 2.2 节所学，JavaScript 中的原型工作方式不同。原型是良好形成的、具体的对象，它们在声明时（对象字面量）或作为调用函数（构造函数）的副产品被创建，而不是通过涉及某些无生命的蓝图或模板的单独实例化过程。实际上，你可以在将其添加到任何继承链之前，像使用任何其他对象一样使用原型对象。
- en: Remember that the key factor that separates JavaScript from a language such
    as Java is that JavaScript links to instead of copies from objects higher up in
    the chain. In chapter 3, we’ll discuss patterns that rely heavily on linking and
    delegation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，区分 JavaScript 与像 Java 这样的语言的关键因素是 JavaScript 通过链接而不是复制从链中的更高层对象。在第 3 章中，我们将讨论高度依赖链接和委派的模式。
- en: In terms of classes, inheritance is configured with keywords `class` and `extends`.
    Although inheritance looks dramatically different from direct prototype references,
    it’s syntactic sugar over constructor functions (pseudoclassical model) that accomplishes
    the same thing. As an example, de-sugaring a class like
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方面，继承是通过 `class` 和 `extends` 关键字配置的。尽管继承在语法上与直接原型引用大相径庭，但它是对构造函数（伪经典模型）的语法糖，实现了相同的功能。例如，将以下类
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: is analogous to
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Another enormous difference from class-based languages is that JavaScript objects
    can access parent properties declared even after the child object was instantiated.
    Inherited properties from some base object are shared across all instances of
    child objects, so any changes to it dynamically ripple to all instances as well,
    which might lead to undesired, hard-to-trace behavior. This powerful, yet dangerous,
    mechanism leads to a well-known issue called prototype pollution. Encapsulation
    certainly helps, which is why exporting functions to build your objects as discussed
    in section 2.2.1 is much better than exporting the actual objects literals themselves.
    By the same token, exporting classes has the same benefits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于类的语言相比，另一个巨大的不同之处在于 JavaScript 对象可以访问在子对象实例化之后声明的父级属性。从某些基对象继承的属性在所有子对象实例之间共享，因此对其的任何更改都会动态地影响到所有实例，这可能会导致不希望看到的、难以追踪的行为。这种强大而危险的机制导致了众所周知的原型污染问题。封装当然有帮助，这就是为什么在
    2.2.1 节中讨论的将函数导出以构建你的对象比直接导出对象字面量本身要好得多。同样，导出类也有同样的好处。
- en: Let’s look at the pros and cons of classes more concretely. To do so, we’ll
    refactor `Transaction` yet again, this time using classes, and add a bit more
    code toward the real-life implementation that we’ll need for the rest of the book.
    As listing 2.8 shows, `funds` is now a property of `Transaction`, and we’ve added
    support for computing transaction fees, which is a common banking task.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更具体地看看类的好处和坏处。为此，我们将再次重构 `Transaction`，这次使用类，并添加一些代码，以便在本书的其余部分中实现实际应用。如列表
    2.8 所示，`funds` 现在是 `Transaction` 的一个属性，我们添加了对计算交易费用的支持，这是常见的银行任务。
- en: To illustrate the ease with which classes allow you to set up the prototype
    chain, let’s refactor `Transaction` and `HashTransaction`. I’ll also take the
    opportunity to showcase new syntax proposals related to private class fields ([http://mng.bz/YqVB](http://mng.bz/YqVB))
    and static fields ([http://mng.bz/5jgB](http://mng.bz/5jgB)) that you may not
    be familiar with.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明类如何让你轻松设置原型链，让我们重构 `Transaction` 和 `HashTransaction`。我还会借此机会展示一些关于私有类字段（[http://mng.bz/YqVB](http://mng.bz/YqVB)）和静态字段（[http://mng.bz/5jgB](http://mng.bz/5jgB)）的新语法建议，你可能不太熟悉。
- en: Listing 2.8 Transaction and `HashTransaction` objects defined using classes
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 使用类定义的 `Transaction` 和 `HashTransaction` 对象
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Declares public fields for this class with default values. I recommend using
    default values, because they help code editors perform rudimentary type hinting
    for you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明此类公共字段并使用默认值。我建议使用默认值，因为它们有助于代码编辑器为你执行基本的类型提示。
- en: ❷ Uses the static private field and method declarations
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用静态私有字段和方法声明
- en: ❸ The prototype setup is cleanly tucked away behind the use of class and extends.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 原型设置被干净利落地隐藏在 `class` 和 `extends` 的使用背后。
- en: ❹ Uses the keyword super to invoke the parent constructor. When you override
    a constructor, you must remember to invoke the super constructor with the required
    arguments as the first line.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用关键字`super`来调用父构造函数。当你重写构造函数时，你必须记得在第一行调用带有必要参数的`super`构造函数。
- en: 'At a glance, the refactoring done in listing 2.8 looks clean, terse, and elegant.
    I took the liberty of embellishing the code a little by adding private access
    to variables that need to be encapsulated, as well as a couple of private static
    functions for validation. As you know, these functions are shared by all instances,
    giving us true private access control. So querying for a private field from outside
    the class throws a `SyntaxError`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，列表2.8中进行的重构看起来干净、简洁、优雅。我大胆地稍微修饰了一下代码，添加了对需要封装的变量的私有访问，以及几个用于验证的私有静态函数。正如你所知，这些函数由所有实例共享，为我们提供了真正的私有访问控制。因此，从类外部查询私有字段会抛出`SyntaxError`：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It’s worth pointing out the use of private fields and the private methods feature,
    prefixed with the hash (`#`) modifier. This feature was much needed to get proper
    encapsulation with classes, something you could have done by using modules and
    closures with the Module pattern, shown in listing 2.9 for comparison. (I’ll revisit
    this pattern in chapter 6.) By the same token, private fields and privileged methods
    are emulated by taking advantage of the closure or lexical scope that exists within
    the class—a function behind the scenes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，使用带有哈希(`#`)修饰符的前缀的私有字段和私有方法功能。这个特性对于在类中实现适当的封装至关重要，你本可以使用模块和闭包与模块模式（如列表2.9所示）来实现这一点。（我将在第6章重新讨论这个模式。）同样，私有字段和特权方法通过利用类内部存在的闭包或词法作用域来模拟——这是幕后一个函数。
- en: Listing 2.9 Transaction object implemented using the Module pattern
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 使用模块模式实现的交易对象
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Private variables and/or privileged functions
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 私有变量和/或特权函数
- en: ❷ Public variables and/or functions
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 公共变量和/或函数
- en: With classes, the private state is visible only to methods in the scope of the
    class itself—also known as privileged. Also, static methods such as `static` `#precisionRound`
    won’t unnecessarily leak out to outside users—something that is cumbersome to
    achieve with regular constructor functions or even the Module pattern.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，私有状态仅对类本身作用域内的方法可见——也称为特权。此外，如`static` `#precisionRound`这样的静态方法不会不必要地泄露给外部用户——这在常规构造函数或甚至模块模式中都是一件麻烦事。
- en: Taking a look back at listing 2.8, do you see a reference to the `prototype`
    property anywhere in this snippet of code? Nope! Classes have a well-defined structure,
    which makes them great at abstracting the mundane prototype details away from
    you and, hence, are less error-prone. Also, they offer a syntactical advantage
    for grouping data and behavior in a cohesive manner. Furthermore, `class` and
    `extends` literally put the icing on the cake for us and make third-party libraries
    such as Prototype’s `extend`, Lodash’s `_.extend`, or even Node’s `util.inherits`
    obsolete. Figure 2.4 illustrates this new, simplified mental model.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾列表2.8，你在代码片段中看到对`prototype`属性的引用了吗？没有！类有一个定义良好的结构，这使得它们非常适合抽象出平凡的原型细节，因此它们更不容易出错。此外，它们还提供了将数据和行为以连贯方式组合的语法优势。此外，`class`和`extends`实际上为我们提供了完美的甜点，使得第三方库如Prototype的`extend`、Lodash的`_.extend`或甚至Node的`util.inherits`变得过时。图2.4展示了这个新的、简化的心智模型。
- en: '![](../Images/2-4.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-4.png)'
- en: Figure 2.4 Building the `HashTransaction` class and its ancestor `Transaction`.
    Instances of `HashTransaction` will inherit all the public fields present in the
    parent. Using `class` and `extends` properly sets up the prototype chain so that
    property lookup is done effectively and constructor references line up perfectly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 构建`HashTransaction`类及其祖先`Transaction`。`HashTransaction`的实例将继承父类中存在的所有公共字段。使用`class`和`extends`可以正确设置原型链，以便有效地进行属性查找，并且构造函数引用完美对齐。
- en: This figure is somewhat similar to figure 2.3 but severely cuts the number of
    artifacts to achieve the same prototype configuration. The basic resemblance is
    deliberate because classes work like functions in JavaScript behind the scenes.
    The most obvious difference from figure 2.3, however, is that all of a class’s
    properties (fields and methods) are automatically part of the object’s prototype,
    accessible via the internal `__proto__` object. You don’t have the option that
    you did with constructor functions. You lost that flexibility in favor of more
    structure.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图与图2.3有些相似，但为了达到相同的原型配置，大大减少了艺术品的数量。基本相似性是有意为之，因为类在JavaScript背后就像函数一样工作。然而，与图2.3最明显的区别是，类中的所有属性（字段和方法）都自动成为对象的原型的一部分，可以通过内部的`__proto__`对象访问。你没有像构造函数那样的选择。你牺牲了这种灵活性以换取更多的结构。
- en: 'Creating a new instance looks like the previous pseudoclassical approach (hence
    its name), with no changes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新实例看起来像之前的伪经典方法（因此得名），没有变化：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: On the surface, this code looks clean and compact. Classes are simpler to work
    with than constructor functions, without a doubt. But it’s important to realize
    that you’re adding a familiar façade over prototypes only to be able to think
    of inheritance as done in a class-oriented language.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，这段代码看起来干净紧凑。与构造函数相比，类更易于处理，这是毫无疑问的。但重要的是要意识到，你只是在原型上添加了一个熟悉的界面，以便能够将继承视为面向类语言中已完成的那样。
- en: 'This chapter covered two object construction patterns: constructor functions
    and classes. Both are inheritance-centric in that one way or another, you need
    to explicitly configure how child objects (or classes) relate to parent objects
    (or classes). Chapter 3 takes a different approach, presenting patterns that shift
    the mental model from inheritance to behavior delegation and linking.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种对象构造模式：构造函数和类。两者都以继承为中心，无论哪种方式，你都需要明确配置子对象（或类）与父对象（或类）之间的关系。第三章采用不同的方法，提出了将思维模式从继承转移到行为委托和链接的模式。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JavaScript offers many choices for building objects, including prototypal inheritance,
    constructor functions, and classes.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript提供了许多构建对象的选择，包括原型继承、构造函数和类。
- en: The phrase prototype inheritance is an oxymoron because the idea of a shared
    linked prototype object is contradictory to the class inheritance model, in which
    instances gain copies of the inherited data.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承这个短语是自相矛盾的，因为共享链接的原型对象的概念与类继承模型相矛盾，在类继承模型中，实例获得继承数据的副本。
- en: Constructor functions have been the standard mechanisms used to mimic the idea
    of classes in JavaScript.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数一直是JavaScript中模仿类概念的标准机制。
- en: Classes smooth over the details of the prototype configuration for newcomers
    or developers coming from other class-based languages and have become the preferred
    choice of JavaScript developers.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类简化了原型配置的细节，对于新手或来自其他基于类语言的开发者来说，类已经成为JavaScript开发者的首选选择。
- en: The class syntax can blur your understanding of JavaScript’s prototype inheritance
    mechanism. Classes are useful, but remember that JavaScript is different from
    other class-based languages you may have seen or used.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类语法可能会模糊你对JavaScript原型继承机制的理解。类是有用的，但请记住，JavaScript与其他你可能见过或使用过的基于类的语言不同。
