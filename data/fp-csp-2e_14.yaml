- en: 11 Representing state and change
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 表示状态和变化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The pitfalls of state mutation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变化的陷阱
- en: Representing change without mutation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无变化表示
- en: Enforcing immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制不可变性
- en: Separating data and logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离数据和逻辑
- en: Greek philosopher Heraclitus said that we cannot step into the same river twice;
    the river constantly changes, so the river that was there a moment ago is no longer.
    Many programmers would disagree, objecting that it’s the same river but its *state*
    has changed. Functional programmers try to stay true to Heraclitus’s thinking
    and would create a new river with every observation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 希腊哲学家赫拉克利特说，我们无法两次踏入同一条河流；河流不断变化，所以刚才还在那里的河流已经不再了。许多程序员会不同意，认为这是同一条河流，但其 *状态*
    已经改变了。函数式程序员试图忠实于赫拉克利特的思考，并且会随着每一次观察创造一条新的河流。
- en: 'Most programs are built to represent things and processes in the real world,
    and because the world constantly changes, programs must somehow represent that
    change. The question is *how* we represent change. Commercial applications written
    in the imperative style have state mutation at their core: objects represent entities
    in the business domain, and change in the world is modeled by mutating the state
    of these objects.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序都是用来表示现实世界中的事物和过程的，因为世界不断变化，程序必须以某种方式表示这种变化。问题是 *如何* 表示变化。以命令式风格编写的商业应用程序在其核心具有状态变化：对象代表业务域中的实体，世界的变化通过改变这些对象的状态来建模。
- en: We’ll start by looking at the weaknesses we introduce in our programs when we
    use mutation. We’ll then see how we can avoid these problems at the source by
    representing change *without* using mutation and, more pragmatically, how to enforce
    immutability in C#. Finally, because much of our programs’ data is stored in data
    structures, we’ll introduce the concepts and techniques behind functional data
    structures, which are also immutable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究我们在使用变化时在程序中引入的弱点。然后我们将看到我们如何通过不使用变化来表示变化，以及更实际地，如何在 C# 中强制不可变性。最后，因为我们的程序的大部分数据都存储在数据结构中，我们将介绍函数数据结构背后的概念和技术，这些数据结构也是不可变的。
- en: 11.1 The pitfalls of state mutation
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 状态变化的陷阱
- en: '*State mutation* is when memory is updated in place, and an important problem
    with it is that concurrent access to a shared mutable state is unsafe. You’ve
    already seen examples demonstrating loss of information due to concurrent updates
    in chapters 1 and 3; let’s now look at a more object-oriented scenario. Imagine
    a `Product` class with an `Inventory` field, representing the number of units
    in stock:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态变化* 是指在原地更新内存，与之相关的一个重要问题是，对共享可变状态的并发访问是不安全的。你已经在第 1 章和第 3 章中看到了由于并发更新导致信息丢失的例子；现在让我们看看一个更面向对象的场景。想象一个具有
    `Inventory` 字段的 `Product` 类，表示库存中的单位数量：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If `Inventory` is mutable as this example shows, and you have concurrent threads
    updating its value, that can lead to *race conditions*, and the results can be
    unpredictable. Imagine that you have a thread replenishing the inventory, while
    another thread concurrently processes a sale, diminishing the inventory as figure
    11.1 shows. If both threads read the value at the same time, and the thread with
    the sale has the last update, you’ll end up with an overall decrease in inventory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Inventory` 如此示例所示是可变的，并且你有并发线程更新其值，这可能导致 *竞争条件*，结果可能是不可预测的。想象一下，你有一个线程正在补充库存，而另一个线程同时处理一个销售，如图
    11.1 所示，减少库存。如果两个线程同时读取值，并且销售线程有最后的更新，你最终会看到库存总体减少。
- en: '![](Images/CH11_F01_Buonanno2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F01_Buonanno2.png)'
- en: Figure 11.1 Loss of data as a result of concurrent updates. Both threads cause
    the `Inventory` value to be updated concurrently with the result that one of the
    updates is lost.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 并发更新导致的数据丢失。两个线程都导致 `Inventory` 值被并发更新，结果导致其中一个更新丢失。
- en: 'Not only has the update to replenish the inventory been lost, but the first
    thread now potentially faces a completely invalid state: a product that’s just
    been replenished has zero inventory.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅补充库存的更新已经丢失，而且第一个线程现在可能面临一个完全无效的状态：刚刚补充的产品库存为零。
- en: If you’ve done some basic multithreading, you’re probably thinking, “Easy! You
    just need to wrap the updates to `Inventory` in a critical section using the `lock`
    statement.” It turns out that this solution, which works for this simple case,
    can become the source of some difficult bugs as the complexity of the system increases.
    (A sale affects not only the inventory, but the sales order, the company balance
    sheet, and so on.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做过一些基本的并发编程，你可能正在想，“简单！你只需要使用`lock`语句将`Inventory`的更新包装在临界区中。”实际上，这个解决方案在这个简单情况下是有效的，但随着系统复杂性的增加，它可能成为一些难以解决的错误的原因。（销售不仅影响库存，还影响销售订单、公司资产负债表等等。）
- en: If things can fail when a single variable is set, imagine when an update to
    an entity involves updating several fields. For example, imagine that when you
    update the inventory, you also set a flag indicating whether the product is low
    on inventory as the following listing shows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在设置单个变量时可能会出现故障，那么想象一下当一个实体的更新涉及到更新多个字段时会发生什么。例如，想象一下当你更新库存时，你也会设置一个标志来指示产品库存是否不足，如下面的列表所示。
- en: Listing 11.1 Temporary inconsistency as a result of non-atomic updates
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 非原子更新导致的暂时不一致性
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ At this point, the object can be in an invalid state from the perspective
    of any thread reading its properties.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此时，从任何读取其属性的线程的角度来看，对象可能处于无效状态。
- en: 'This code defines an invariant: when `inventory` is 5 or less, then `IsLowOnInventory`
    must be true.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个不变量：当`inventory`为5或更少时，`IsLowOnInventory`必须为真。
- en: In a single-threaded setting, there aren’t any problems with the preceding code.
    But in a multithreaded setting, a thread could be reading the state of this object
    just as another thread is performing the update in the window during which `Inventory`
    has been updated but `IsLowOnInventory` hasn’t. (Notice that this window widens
    if the logic to compute `IsLowOnInventory` becomes more expensive.) During that
    window, the invariant can be broken, so the object would appear to be in an invalid
    state to the first thread. This will, of course, happen very rarely, and it will
    be nearly impossible to reproduce. This is part of the reason why bugs caused
    by race conditions are so hard to diagnose.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程设置中，前面的代码没有问题。但在多线程设置中，一个线程可能在另一个线程在`Inventory`已更新但`IsLowOnInventory`尚未更新的窗口期间读取该对象的状态。请注意，如果计算`IsLowOnInventory`的逻辑变得更加昂贵，这个窗口会变宽。在这个窗口期间，不变量可能会被破坏，因此第一个线程会看到对象似乎处于无效状态。这当然会非常罕见，并且几乎不可能重现。这也是竞态条件引起的错误如此难以诊断的部分原因。
- en: Indeed, race conditions are known to have caused some of the most spectacular
    failures in the software industry. If you have a system with concurrency and state
    mutation, it’s impossible to prove that the system is free of race conditions.[¹](#pgfId-1142521)
    In other words, if you want concurrency (and, given today’s tendency toward multicore
    processors and distributed computing, you hardly have a choice) *and* strong guarantees
    of correctness, you simply must give up mutation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，竞态条件已知已导致软件行业中最引人注目的失败之一。如果你有一个具有并发性和状态变化的系统，那么你无法证明该系统没有竞态条件。[¹](#pgfId-1142521)换句话说，如果你想实现并发（鉴于今天对多核处理器和分布式计算的倾向，你几乎没有选择）*并且*对正确性有强保证，那么你不得不放弃状态变化。
- en: Lack of safe concurrent access may be the biggest pitfall of a shared mutable
    state, but it’s not the only one. Another problem is the risk of introducing *coupling*—a
    high degree of interdependence between different parts of your system. In figure
    11.1, `Inventory` is *encapsulated*, meaning it can only be set from within the
    class, and according to OOP theory, that’s supposed to give you a sense of comfort.
    But how many methods in the `Product` class can set the inventory value? How many
    code paths lead into these methods so that they ultimately affect the value of
    `Inventory`? How many parts of the application can get the same instance of the
    `Product` and rely on the value of `Inventory`, and how many will be affected
    if you introduce a new component that causes `Inventory` to change?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏安全的并发访问可能是共享可变状态的最大陷阱，但并非唯一。另一个问题是引入*耦合*的风险——系统不同部分之间的高度相互依赖。在图11.1中，`Inventory`是*封装*的，这意味着它只能从类内部设置，根据面向对象理论，这应该给你一种舒适感。但是`Product`类中有多少方法可以设置库存值？有多少代码路径通向这些方法，从而最终影响`Inventory`的值？应用程序的哪些部分可以获取相同的`Product`实例并依赖于`Inventory`的值，以及如果你引入一个导致`Inventory`发生变化的新组件，会有多少部分受到影响？
- en: For a non-trivial application, it’s difficult to answer these questions completely.
    This is why `inventory`, even though it’s a private field and can be set only
    via a private setter, qualifies as a global mutable state; as far as we can tell,
    it could be mutated by any part of the program via public methods in the enclosing
    class. As a result, mutable state couples the behavior of the various components
    that read or update that state, making it difficult to reason about the behavior
    of the system as a whole.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非平凡的应用程序，很难完全回答这些问题。这就是为什么即使`inventory`是一个私有字段，只能通过私有设置器来设置，它也符合全局可变状态的定义；据我们所知，它可以通过封装类中的公共方法被程序的任何部分修改。因此，可变状态将读取或更新该状态的各个组件的行为耦合在一起，使得推理整个系统的行为变得困难。
- en: Finally, shared mutable state implies *loss of purity*. As explained in chapter
    3, mutating global state (remember, that’s all state that’s not local to a function,
    including private variables) constitutes a side effect. If you represent change
    in the world by mutating objects in your system, you lose the benefits of function
    purity. For these reasons, the functional paradigm discourages state mutation
    altogether.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，共享可变状态意味着*纯度丧失*。正如第3章所述，修改全局状态（记住，这指的是所有不属于函数本地的状态，包括私有变量）构成了副作用。如果你通过修改系统中的对象来表示世界的变化，你将失去函数纯度的优势。因此，函数式范式总体上不鼓励状态修改。
- en: NOTE In this chapter, you’ll learn how to work with immutable data objects.
    That’s an important technique, but keep in mind that it’s not always sufficient
    to represent entities that change with time. Immutable data objects can represent
    the state of an entity at any given point in time, somewhat like a frame in a
    film, but to represent the entity itself, to get the full moving picture, you
    need a further abstraction that links those successive states together. We’ll
    discuss techniques for accomplishing that in chapters 13, 15, 18, and 19.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章中，你将学习如何处理不可变数据对象。这是一个重要的技术，但请记住，它并不总是足以表示随时间变化的事物。不可变数据对象可以表示实体在任何给定时间点的状态，有点像电影中的一个镜头，但要表示实体本身，要获得完整的动态画面，你需要进一步抽象，将这些连续状态联系起来。我们将在第13章、第15章、第18章和第19章中讨论实现这一目标的技巧。
- en: Local mutation is OK
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 局部修改是可以接受的
- en: 'Not all state mutation is equally evil. Mutating local state (state that’s
    only visible within the scope of a function) is inelegant but benign. For example,
    imagine the following function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的状态修改都是同样糟糕的。修改局部状态（仅在函数作用域内可见的状态）是不优雅的，但却是良性的。例如，想象以下函数：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although we’re updating `result`, this isn’t visible from outside the scope
    of the function. As a result, this implementation of `Sum` is actually a pure
    function: it has no *observable* side effects from the point of view of a calling
    function.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在更新`result`，但这从函数的作用域之外是不可见的。因此，这个`Sum`的实现实际上是一个纯函数：它对调用函数来说没有*可观察的*副作用。
- en: Naturally, this code is also low-level. You can normally achieve what you want
    with built-in functions like `Sum`, `Aggregate`, and so on. In practice, it’s
    rare that you’ll find a legitimate case for mutating local variables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这段代码也是低级的。你通常可以使用内置函数如`Sum`、`Aggregate`等来实现你想要的功能。在实践中，你很少会找到一个合理的理由来修改局部变量。
- en: 11.2 Understanding state, identity, and change
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 理解状态、身份和变化
- en: Let’s look more closely at change and mutation.[²](#pgfId-1142545) By *change*,
    I mean change in the real world, such as when 50 units of stock become available
    for sale. *Mutation* means data is updated in place; as you saw in the `Product`
    class, when the `Inventory` value is updated, the previous value for `Inventory`
    is lost.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看变化和修改。[²](#pgfId-1142545) 我所说的*变化*是指现实世界中的变化，例如当50个单位的股票可供出售时。*修改*意味着数据在原地更新；正如你在`Product`类中看到的，当`Inventory`值被更新时，`Inventory`的旧值就会丢失。
- en: 'In FP, we represent change without mutation: values aren’t updated in place.
    Instead, we create new instances that represent the data with the desired changes,
    as figure 11.2 shows. The fact that the current level of inventory is 53 doesn’t
    obliterate the fact that it was previously 3.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，我们不通过修改来表示变化：值不会在原地更新。相反，我们创建新的实例来表示具有所需变化的数据，如图11.2所示。当前库存水平为53并不抹去它之前是3的事实。
- en: '![](Images/CH11_F02_Buonanno2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F02_Buonanno2.png)'
- en: Figure 11.2 In FP, change can be represented by creating new versions of the
    data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 在函数式编程中，可以通过创建数据的新版本来表示变化。
- en: 'In FP, we work with *immutable* values: once a value is initialized, it’s never
    updated.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，我们处理的是*不可变*值：一旦一个值被初始化，它就永远不会被更新。
- en: Wrapping your head around immutable objects
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理解不可变对象
- en: 'If you’ve always used mutation to represent change, creating replicas of objects
    when their properties are updated can seem counterintuitive. For example, consider
    this code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直用修改来表示变化，当对象的属性更新时创建对象的副本可能会显得反直觉。例如，考虑以下代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, `Product` is immutable, so we represent new inventory becoming
    available by creating a new `Product` instance. You may feel awkward about this
    because now there are two competing `Product` instances in memory, only one of
    which accurately represents the real-world product.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`Product`是不可变的，所以我们通过创建一个新的`Product`实例来表示新库存的可用性。你可能会觉得这样做有些尴尬，因为现在内存中有两个相互竞争的`Product`实例，其中只有一个准确地代表了现实世界的产品。
- en: Note that in this example, the `updated` instance is returned, while the `original`
    instance runs out of scope and will therefore be garbage-collected. In many cases,
    the obsolete instance will simply be “forgotten” rather than overwritten.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，返回的是`updated`实例，而`original`实例超出作用域，因此将被垃圾回收。在许多情况下，过时的实例只是被“遗忘”而不是被覆盖。
- en: But there are cases in which you *do* want several views of an entity to coexist.
    For example, say your employer offers free shipping for orders that are over $40\.
    You might like to have a view of the order before and after a user removes an
    item to warn them if they have just lost the right to free delivery. Or, an update
    may be part of an in-memory transaction, and you may want to revert to the previous
    state of the entity if the transaction fails.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但有些情况下，你可能确实希望一个实体的多个视图共存。例如，假设你的雇主为超过40美元的订单提供免费运输。你可能希望在用户删除商品之前和之后查看订单，以警告他们是否刚刚失去了免费运输的权利。或者，更新可能是一个内存事务的一部分，如果事务失败，你可能希望将实体回滚到之前的状态。
- en: The idea that only the latest or current view of the data is valuable is just
    a prejudice deriving from mainstream practice. When you give it up, many new possibilities
    appear.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只有最新或当前的数据视图是有价值的这种观点只是源于主流实践的一种偏见。当你放弃这种观点时，许多新的可能性就会出现。
- en: To refine or redefine your intuition about change and mutation, it’s useful
    to distinguish between things that change and things that don’t.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要细化或重新定义你对变化和修改的直觉，区分变化的事物和不变化的事物是有用的。
- en: 11.2.1 Some things never change
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 一些东西永远不会改变
- en: There are some things that we think of as inherently immutable. For example,
    your age may change from 30 to 31, but the number 30 is still the number 30, and
    31 is still 31.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西我们认为是固有的不可变的。例如，你的年龄可能会从30岁变成31岁，但数字30仍然是数字30，31仍然是31。
- en: 'This is modeled in the Base Class Library (BCL) in that *all primitive types
    are immutable*. What about more complex types? Dates are a good example. The third
    of March is still the third of March, even though you may change an appointment
    in your calendar from the third of March to the fourth. This is also reflected
    in the BCL in that types that are used to represent dates such as `DateTime` are
    immutable.[³](#pgfId-1142580) See this for yourself by typing the following in
    the REPL (use `DateTime` instead of `DateOnly` if you don’t have .NET 6):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这在基类库（BCL）中得到了体现，即*所有原始类型都是不可变的*。那么更复杂类型呢？日期是一个很好的例子。3月3日仍然是3月3日，即使你可能将你的日历中的预约从3月3日改为3月4日。这也在BCL中得到了反映，即用于表示日期的类型，如`DateTime`是不可变的。[³](#pgfId-1142580)
    你可以通过在REPL中输入以下内容来自行验证（如果你没有.NET 6，请使用`DateTime`而不是`DateOnly`）：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ John has the same birthday as Mom.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 约翰和母亲的生日相同。
- en: ❷ You realize that John’s birthday is actually one day later.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你意识到约翰的生日实际上晚了一天。
- en: ❸ Mom’s birthday was not affected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 母亲的生日没有受到影响。
- en: 'In the preceding example, we start by saying that Mom and John have the same
    birthday, so we assign the same value to `momsBirthday` and `johnsBirthday`. When
    we then use `AddDays` to create a later date and assign it to `johnsBirthday`,
    this leaves `momsBirthday` unaffected. In this example, we are doubly protected
    from mutating the date:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先说母亲和约翰有相同的生日，所以我们给`momsBirthday`和`johnsBirthday`赋相同的值。当我们使用`AddDays`创建一个较晚的日期并将其赋值给`johnsBirthday`时，这不会影响`momsBirthday`。在这个例子中，我们双重保护了日期不被修改：
- en: Because `System.DateOnly` is a struct, it’s copied upon assignment, so `momsBirthday`
    and `johnsBirthday` are different instances.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`System.DateOnly`是一个结构体，它在赋值时会进行复制，所以`momsBirthday`和`johnsBirthday`是不同的实例。
- en: Even if `DateOnly` were a class, so that `momsBirthday` and `johnsBirthday`
    pointed to the same instance, the behavior would still be the same because `AddDays`
    creates a new instance, leaving the underlying instance unaffected.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使`DateOnly`是一个类，并且`momsBirthday`和`johnsBirthday`指向同一个实例，行为仍然相同，因为`AddDays`创建了一个新的实例，而不会影响底层实例。
- en: If, on the other hand, `DateOnly` were a mutable class and `AddDays` mutated
    the days of its instance, the value of `momsBirthday` would be updated as a result—or,
    rather, as a side effect—of updating `johnsBirthday`. (Imagine explaining to Mom
    that that’s the reason for your belated birthday wishes.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果`DateOnly`是一个可变类，并且`AddDays`变异了其实例的天数，那么`momsBirthday`的值将因为更新`johnsBirthday`而更新——或者更准确地说，作为更新`johnsBirthday`的副作用。（想象一下向妈妈解释这是你迟到生日祝福的原因。）
- en: Immutable types in the .NET framework
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架中的不可变类型
- en: 'Here are the most commonly used immutable types in .NET’s Base Class Library:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是.NET基类库中最常用的不可变类型：
- en: '`DateTime`, `TimeSpan`, `DateTimeOffset`, `DateOnly`, `TimeOnly`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`、`TimeSpan`、`DateTimeOffset`、`DateOnly`、`TimeOnly`'
- en: '`Delegate`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delegate`'
- en: '`Guid`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Guid`'
- en: '`Nullable<T>`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<T>`'
- en: '`String`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Tuple<T1>`, `Tuple<T1`, `T2>`, ...'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tuple<T1>`、`Tuple<T1, T2>`、...'
- en: '`Uri`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uri`'
- en: '`Version`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version`'
- en: Furthermore, all primitive types are immutable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有原始类型都是不可变的。
- en: 'Now let’s define a custom immutable type. Say we represent a `Circle` like
    so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个自定义的不可变类型。比如说我们这样表示一个`Circle`：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You would probably agree that it makes no sense that a circle should ever grow
    or shrink because it’s a completely abstract geometric entity. The preceding implementation
    reflects this by declaring the struct as `readonly`, which makes it immutable.
    This means that it will not be possible to update the values for `Radius` and
    `Center`; once created, the state of the circle can never change.[⁴](#pgfId-1142620)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会同意，一个圆应该永远增长或缩小是没有意义的，因为它是一个完全抽象的几何实体。前面的实现通过将结构体声明为`readonly`来反映这一点，这使得它是不可变的。这意味着将无法更新`Radius`和`Center`的值；一旦创建，圆的状态将永远无法改变。[⁴](#pgfId-1142620)
- en: Structs should be immutable
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体应该是不可变的
- en: Notice that I’ve defined `Circle` as a value type. Because value types are copied
    when passed between functions, it makes sense that structs should be immutable.
    This isn’t enforced by the compiler, so you *could* create a mutable struct. In
    fact, if you declare a `record` `struct` without the `readonly` modifier, you
    get a mutable struct.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将`Circle`定义为值类型。因为值类型在函数之间传递时会被复制，所以结构体应该是不可变的。这不是由编译器强制执行的，所以你可以创建一个可变结构体。事实上，如果你声明一个没有`readonly`修饰符的`record`结构体，你将得到一个可变结构体。
- en: Unlike with classes, any changes you make to a mutable struct propagate down
    but not up the call stack, potentially leading to unexpected behavior. For this
    reason, I recommend you always stick to immutable structs, the only exceptions
    being warranted by proven performance requirements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与类不同，你对可变结构体所做的任何更改都会向下传播，但不会向上调用栈传播，这可能导致意外的行为。因此，我建议你始终坚持使用不可变结构体，唯一的例外是有证明的性能需求。
- en: 'If you have a circle and you’d like a circle double the size, you can define
    functions to create a new circle based on an existing one. Here’s an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个圆，并且想要一个大小是原来两倍的圆，你可以定义函数来根据现有的圆创建一个新的圆。以下是一个例子：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, so far we haven’t used mutation, and these examples are pretty intuitive.
    What do numbers, dates, and geometric entities have in common? Their value captures
    their identity: they are *value objects*. If you change the value of a date .
    . . well, it identifies a different date! The problems begin when we consider
    objects whose value and identity are different things. We’ll look at this next.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，我们还没有使用过变异，这些例子相当直观。数字、日期和几何实体有什么共同之处？它们的值捕捉了它们的身份：它们是*值对象*。如果你改变日期的值……嗯，它标识了一个不同的日期！当我们考虑值和身份不同的事物时，问题就开始了。我们将在下一节探讨这个问题。
- en: 11.2.2 Representing change without mutation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 不使用变异表示变化
- en: 'Many real-world entities change with time: your bank account, your calendar,
    your contacts list—all these things have a state that changes with time. Figure
    11.3 illustrates this idea.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的实体会随时间变化：你的银行账户、你的日历、你的联系人列表——所有这些事物都有随时间变化的状态。图11.3说明了这个概念。
- en: '![](Images/CH11_F03_Buonanno2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F03_Buonanno2.png)'
- en: Figure 11.3 An entity whose state changes over time
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 随时间变化状态的实体
- en: For such entities, their identity isn’t captured by their value because their
    identity remains constant, whereas their value changes with time. Instead, their
    identity is associated with different states at different points in time. Your
    age may change, or your salary, but your identity doesn’t. To represent such entities,
    programs must model not only an entity’s state (that’s the easy part), but the
    transitions from one state to another and often the association of an identity
    with the entity’s current state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的实体，它们的身份不是由它们的值来确定的，因为它们的身份保持不变，而它们的值随着时间的推移而变化。相反，它们的身份与不同时间点的不同状态相关联。你的年龄可能会改变，或者你的薪水，但你的身份不会。为了表示这样的实体，程序必须不仅模拟一个实体的状态（这是容易的部分），还要模拟从一个状态到另一个状态的转换，以及通常将身份与实体的当前状态关联起来。
- en: We’ve discussed some reasons why mutation provides an imperfect mechanism for
    managing state transitions. In FP, states are not mutated; they’re snapshots that,
    like the frames of a film, represent an evolving reality but are in themselves
    static.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一些为什么突变提供的是一个不完美的状态转换机制的原因。在函数式编程（FP）中，状态不会被突变；它们是快照，就像电影帧一样，代表着一个不断发展的现实，但本身是静态的。
- en: 11.3 Using records to capture the state of domain entities
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用记录来捕获领域实体的状态
- en: To illustrate immutable data objects in C#, let’s start working on `AccountState`,
    which we’ll use to represent the state of a bank account in the BOC application.
    The following listing shows our model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 C# 中的不可变数据对象，让我们从 `AccountState` 开始工作，我们将使用它来表示 BOC 应用程序中银行账户的状态。以下列表显示了我们的模型。
- en: Listing 11.2 A simple model for the state of a bank account
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 银行账户状态的简单模型
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For brevity, I’ve omitted the definition of `CurrencyCode`, which simply wraps
    a string value such as EUR or USD similarly to the `ConnectionString` and `SqlTemplate`
    types we saw in section 9.4.1.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我省略了 `CurrencyCode` 的定义，它只是像我们在 9.4.1 节中看到的 `ConnectionString` 和 `SqlTemplate`
    类型一样包装一个字符串值，如 EUR 或 USD。
- en: 'Because `AccountState` has several fields and not all may be meaningful all
    the time, I have provided some reasonable default values for all fields except
    the currency. To create an `AccountState`, all you really need is its currency:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `AccountState` 有几个字段，并且并不是所有字段在所有时间都有意义，所以我为除了货币字段以外的所有字段提供了合理的默认值。要创建一个
    `AccountState`，你实际上只需要它的货币：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates an `AccountState` with a default status of `Requested`. When you’re
    ready to activate the account, you can do this by using a `with` expression:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个默认状态为 `Requested` 的 `AccountState`。当你准备好激活账户时，你可以通过使用 `with` 表达式来完成：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This creates a new instance of `AccountState`, populated with all the values
    from the original except for `Status`, which is set to the new value. The original
    object is still intact:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 `AccountState` 实例，包含原始对象的所有值，除了 `Status`，它被设置为新的值。原始对象仍然完好无损：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that you can use `with` expressions that set more than one property:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以使用设置多个属性的 `with` 表达式：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Performance impact of using immutable objects
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变对象的影响
- en: Working with immutable objects means that every time your data needs to change,
    you create a new, modified instance rather than mutating the object in place.
    “But isn’t that terribly inefficient?” you may be thinking.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与不可变对象一起工作意味着每次你的数据需要更改时，你都会创建一个新的、修改后的实例，而不是在原地突变对象。“但这不是非常低效吗？”你可能正在想。
- en: There is indeed a small performance penalty for creating modified copies, as
    well as for creating a greater number of objects that will eventually need to
    be garbage-collected. This is also why FP isn’t practical in languages that lack
    automatic memory management.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，创建修改后的副本以及创建最终需要垃圾回收的更多对象确实会有轻微的性能损失。这也是为什么在缺乏自动内存管理的语言中，函数式编程（FP）不实用的原因。
- en: But the performance impact is smaller than you might think because the modified
    instance is a *shallow copy* of the original. That is, objects referenced by the
    original object aren’t copied; only the reference is copied. With the exception
    of the field being updated, the new object is a bitwise replica of the original.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是性能影响比你想象的要小，因为修改后的实例是原始对象的浅拷贝。也就是说，原始对象引用的对象没有被复制；只有引用被复制。除了正在更新的字段外，新对象是原始对象的位复制。
- en: '![](Images/CH11_UN01_Buonanno2c.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_UN01_Buonanno2c.png)'
- en: For example, when you create a new `AccountState` with an updated status, the
    list of transactions won’t be copied. Instead, the new object references the original
    list of transactions. (This too should be immutable, so it’s OK for different
    instances to share it.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您使用更新的状态创建新的`AccountState`时，交易列表不会被复制。相反，新对象引用原始的交易列表。（这也应该是不可变的，因此不同的实例共享它是可以的。）
- en: '`with` expressions are fast. Of course, in-place updates are even faster, so
    there’s a tradeoff between performance and safety. The performance penalty of
    creating shallow copies is likely to be negligible in the wide majority of cases.
    My advice is to put safety first and optimize later as needed.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 表达式是快速的。当然，就地更新更快，因此在性能和安全之间有一个权衡。创建浅拷贝的性能惩罚在大多数情况下可能可以忽略不计。我的建议是首先考虑安全，然后在需要时进行优化。'
- en: Next, let’s see how we can further improve this model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何进一步改进这个模型。
- en: 11.3.1 Fine-grained control on record initialization
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 对记录初始化的细粒度控制
- en: 'Have another look at the proposed definition of `AccountState` (replicated
    in the following snippet) and see if you can spot any potential problems with
    it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看提出的`AccountState`定义（在下面的片段中复制），看看您是否能发现任何潜在的问题：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are in fact a couple of issues here. One thing that immediately stands
    out is the default value of `null` for the list of transactions. The reason for
    providing a default value is that when a new account is created, it will have
    no previous transactions, so it makes sense to have this as an optional parameter.
    But we also don’t want `null` to potentially cause a `NullReferenceException`.
    Secondly, this record definition allows you to create an account by changing the
    currency of an existing account, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这里有几个问题。一个立即引起注意的事情是交易列表的默认值是`null`。提供默认值的原因是，当创建新账户时，它将没有之前的交易，因此将其作为可选参数是有意义的。但我们也不希望`null`可能引起`NullReferenceException`。其次，这个记录定义允许您通过更改现有账户的货币来创建账户，如下所示：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes no sense. Although the status of an account may go from, say, `Requested`
    to `Active`, once an account is opened with a given currency, that should never
    change. We’d like our model to represent this. Let’s see how we can address both
    issues, starting with the latter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有意义。尽管账户的状态可能从“请求”变为“活动”，一旦以特定货币开设了账户，这种状态就不应该改变。我们希望我们的模型能够表示这一点。让我们看看我们如何解决这两个问题，从后者开始。
- en: Read-only vs. init-only properties
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性与初始化属性
- en: 'When you use positional records, the compiler creates an *init-only auto property*
    for each parameter you declare. This is a property with a `get` and an `init`
    method; the latter is a setter that can only be called when the record instance
    is initialized. If we were to explicitly declare the `Currency` property as a
    public init-only auto property, just as the compiler would generate, it would
    look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用位置记录时，编译器会为声明的每个参数创建一个只读的自动属性。这是一个具有`get`和`init`方法的属性；后者是一个setter，只能在记录实例初始化时调用。如果我们显式地将`Currency`属性声明为公共只读自动属性，就像编译器会生成的那样，它看起来会是这样：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following listing breaks this down so that you can see what every bit means.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表将这一点分解，以便您可以看到每个位的意义。
- en: Listing 11.3 Explicitly defining a property in a positional record definition
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 在位置记录定义中显式定义属性
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ `Currency` here refers to the name of the property.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这里，“Currency”指的是属性的名称。
- en: ❷ Gets the value of the property
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取属性的值
- en: ❸ Allows the value to be set only upon record initialization
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅在记录初始化时设置值
- en: ❹ Introduces the property initializer
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 介绍了属性初始化器
- en: ❺ `Currency` here refers to the constructor parameter; this means that upon
    initialization the `Currency` property is set to the value provided for the `Currency`
    constructor parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在这里，“Currency”指的是构造函数参数；这意味着在初始化时，“Currency”属性被设置为“Currency”构造函数参数提供的值。
- en: 'When you use a `with` expression to create a modified version of a record,
    the runtime creates a clone of the original and then calls the `init` method of
    any properties for which you’ve provided new values. Now, writing the property
    explicitly allows us to override the compiler’s defaults; in this case, we want
    to define the `Currency` property as a read-only auto property by removing the
    `init` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `with` 表达式创建记录的修改版本时，运行时会创建原始记录的副本，然后调用任何你提供新值的属性的 `init` 方法。现在，显式编写属性允许我们覆盖编译器的默认设置；在这种情况下，我们想要通过删除
    `init` 方法将 `Currency` 属性定义为只读自动属性：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then a `with` expression attempting to create a modified version of an account
    with a different currency will not compile because there’s no `init` method for
    setting the `Currency` of the copy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试创建具有不同货币的账户的修改版本的 `with` 表达式将无法编译，因为没有为副本设置 `Currency` 的 `init` 方法。
- en: 'Immutable objects never change, so all properties of an immutable object must
    be either read-only or init-only:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象永远不会改变，因此不可变对象的属性必须是只读或只初始化：
- en: Use init-only properties if it makes sense to create a copy where a property
    is given an updated value.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在创建副本时给属性赋予一个更新值是有意义的，则使用只初始化属性。
- en: Use read-only properties otherwise.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则使用只读属性。
- en: As you’ve seen, the compiler-generated properties of positional records are
    init-only, so you need to explicitly declare them if you want them to be read-only.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，编译器生成的位置记录属性是只初始化的，所以如果你想它们是只读的，你需要显式声明它们。
- en: Initializing an optional list to be empty
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将可选列表初始化为空
- en: Now let’s go back to the problem of `TransactionHistory`, which is initialized
    to be `null` when no value is passed to the constructor for `AccountState`. What
    we really want is to have an empty list as the default value, so ideally we’d
    like to write
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `TransactionHistory` 的问题，它在将 `AccountState` 的构造函数参数未传递值时初始化为 `null`。我们真正想要的是有一个空列表作为默认值，因此理想情况下我们想要编写
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But this doesn’t compile because default values for optional arguments must
    be compile- time constants. The most concise solution is to explicitly define
    the `Transaction`-`History` property and use a property initializer, as the following
    listing shows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但这无法编译，因为可选参数的默认值必须是编译时常量。最简洁的解决方案是显式定义 `Transaction-History` 属性并使用属性初始化器，如下所示。
- en: Listing 11.4 Initializing a record with an empty list
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 使用空列表初始化记录
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Refers to the constructor parameter
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指的是构造函数参数
- en: ❷ Uses an empty list if the constructor was given `null`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数被给定 `null`，则使用一个空列表
- en: While default values for method arguments must be compile-time constants, property
    initializers don’t have this constraint. Therefore, we can include some logic
    in the property initializer. The previous code replaces the auto-generated property
    for `TransactionHistory` with an explicit declaration; it’s essentially saying,
    “When a new `AccountState` is created, use the value given for the optional `TransactionHistory`
    constructor parameter to populate the `TransactionHistory` property, but use an
    empty list if it’s `null`.”
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然方法参数的默认值必须是编译时常量，但属性初始化器没有这个限制。因此，我们可以在属性初始化器中包含一些逻辑。前面的代码用显式声明替换了自动生成的 `TransactionHistory`
    属性；这本质上是在说，“当创建一个新的 `AccountState` 时，使用可选 `TransactionHistory` 构造函数参数提供的值来填充 `TransactionHistory`
    属性，但如果它是 `null`，则使用空列表。”
- en: 'There are other possible approaches: you could explicitly define a constructor
    and have this logic in the constructor, or define a full property with a backing
    field and have this logic in the property’s `init` method.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他可能的方案：你可以显式定义一个构造函数并在其中包含此逻辑，或者定义一个带有后置字段的完整属性并在属性的 `init` 方法中包含此逻辑。
- en: 11.3.2 Immutable all the way down
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 一直不可变
- en: 'There is one more tweak. For an object to be immutable, all its members must
    be immutable. If you look at the definition for `AccountState`, there’s a catch.
    `TransactionHistory` is defined as an `IEnumerable<Transaction>`, and while `Transaction`
    is immutable, there are many mutable lists that implement `IEnumerable`. For example,
    consider the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个小调整。为了使一个对象不可变，它的所有成员都必须是不可变的。如果你查看 `AccountState` 的定义，会发现一个陷阱。`TransactionHistory`
    被定义为 `IEnumerable<Transaction>`，虽然 `Transaction` 是不可变的，但有许多可变列表实现了 `IEnumerable`。例如，考虑以下代码：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code creates an `AccountState` with a mutable list; it then holds a reference
    to that list so that the list can still be mutated. As a result, we cannot say
    that our definition of `AccountState` is truly immutable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个具有可变列表的 `AccountState`；然后它保留对该列表的引用，以便列表仍然可以被修改。因此，我们无法说我们对 `AccountState`
    的定义真正不可变。
- en: There are two possible solutions. You could change the type definition, declaring
    `TransactionHistory` to be an `ImmutableList` rather than an `IEnumerable`. Alternatively,
    you could rewrite the property as the following listing shows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的解决方案。你可以更改类型定义，将 `TransactionHistory` 声明为 `ImmutableList` 而不是 `IEnumerable`。或者，你可以将属性重写为以下列表所示。
- en: Listing 11.5 Making a record immutable even if given a mutable list
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 即使给定可变列表，使记录不可变
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code creates an `ImmutableList` from the given `IEnumerable`, thus making
    `AccountState` truly immutable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从给定的 `IEnumerable` 创建一个 `ImmutableList`，从而使 `AccountState` 真正不可变。
- en: TIP If given an `ImmutableList`, `CreateRange` will just return it so that you
    don’t incur any overhead by using this approach. Otherwise, it will create a defensive
    copy, ensuring that any subsequent mutation to the given list does not affect
    `AccountState`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果给定一个 `ImmutableList`，`CreateRange` 将直接返回它，这样你就不必使用这种方法承担任何开销。否则，它将创建一个防御性副本，确保对给定列表的任何后续修改都不会影响
    `AccountState`。
- en: If an account has an immutable list of transactions, how do you add a transaction
    to the list? You don’t. You create a new list that has the new transaction as
    well as all existing ones, and that will be part of a new `AccountState`. The
    following listing shows that adding a child to an immutable object involves the
    creation of a new parent object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个账户有一个不可变的交易列表，你如何向列表中添加交易？你不需要。你创建一个新的列表，其中包含新的交易以及所有现有的交易，这将成为新的 `AccountState`
    的一部分。以下列表显示了向不可变对象添加子对象涉及创建新的父对象。
- en: Listing 11.6 Adding a child to an immutable object
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 向不可变对象添加子对象
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Includes `Prepend` as an extension method on `IEnumerable`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 `Prepend` 作为 `IEnumerable` 的扩展方法
- en: ❷ A new `IEnumerable`, including existing values and the one being added
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个新的 `IEnumerable`，包括现有值和正在添加的值
- en: Notice that in this particular case, we’re *prepending* the transaction to the
    list. This is domain-specific; in most cases, you’re interested in the latest
    transactions, so it’s efficient to keep the latest ones at the front of the list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个特定情况下，我们是在列表中 * prepend* 交易。这是特定领域的；在大多数情况下，你感兴趣的是最新的交易，因此将最新的交易保持在列表的前端是高效的。
- en: Copying a list every time a single element is added or removed may sound terribly
    inefficient, but this isn’t necessarily the case. We’ll discuss why in chapter
    12.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加或删除单个元素时都复制列表可能听起来非常低效，但这并不一定是这种情况。我们将在第 12 章中讨论原因。
- en: Hurdles to using C# records
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 记录的障碍
- en: In this section, you’ve seen how we could use records to great effect to define
    custom immutable data types. However, records are a recent feature in C#, so it’s
    possible that you may encounter some hurdles when trying to adopt records.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了我们如何有效地使用记录来定义自定义不可变数据类型。然而，记录是 C# 中的新特性，所以当你尝试采用记录时可能会遇到一些障碍。
- en: Specifically, if you use an object-relational mapper (including Entity Framework),
    which uses change tracking to see which objects have changed and need to be updated
    in the DB, or relies on an empty constructor and settable properties to populate
    objects, you may not be able to use records. Another stumbling block could be
    serialization. While `System.Text.Json` supports serializing records to and from
    JSON, other serializers may not support records yet. In this case, consider using
    immutability by convention (discussed in the appendix). I expect that in time
    records will gain popularity and will eventually be supported by all major libraries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果你使用对象关系映射器（包括 Entity Framework），它使用变更跟踪来查看哪些对象已更改并需要在数据库中更新，或者依赖于空构造函数和可设置属性来填充对象，你可能无法使用记录。另一个障碍可能是序列化。虽然
    `System.Text.Json` 支持将记录序列化为 JSON 并从 JSON 反序列化，但其他序列化程序可能还不支持记录。在这种情况下，考虑使用约定不变性（在第
    9 章附录中讨论）。我预计随着时间的推移，记录将变得流行，并最终被所有主要库支持。
- en: 11.4 Separating data and logic
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 分离数据和逻辑
- en: 'One of the ways in which FP reduces coupling in your applications, therefore
    making them simpler and easier to maintain, is that it naturally leads to a separation
    between data and logic. This is the approach we’ve been following in the preceding
    section:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）通过将数据与逻辑分离来减少应用程序中的耦合，从而使其更简单、更容易维护。这是我们前面章节中一直遵循的方法：
- en: '`AccountState`, which we defined in listing 11.2, only contains data.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在列表11.2中定义的`AccountState`只包含数据。
- en: Business logic, such as activating an account or adding a transaction, is modeled
    through functions.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如激活账户或添加交易等业务逻辑，是通过函数来模拟的。
- en: We can group all these functions into a static `Account` class, including logic
    for creating new and updated versions of `AccountState`, as the following listing
    demonstrates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有这些函数组合成一个静态的`Account`类，包括创建和更新`AccountState`新版本的逻辑，如下所示。
- en: Listing 11.7 A static class that includes account-specific business logic
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 包含特定业务逻辑的静态类
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Account` is a static class for representing changes to an account, including
    a factory function. While `AccountState` represents the *state* of the account
    at a given time, the functions in `Account` represent *state transitions*. This
    is illustrated in figure 11.4.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account`是一个静态类，用于表示账户的变化，包括一个工厂函数。而`AccountState`表示在特定时间点的账户状态，`Account`中的函数则表示状态转换。这如图11.4所示。'
- en: '![](Images/CH11_F04_Buonanno2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F04_Buonanno2.png)'
- en: Figure 11.4 Representing state and logic related to an entity are separate concerns.
    In this example, `AccountState` captures the data representing an account, while
    `Account` is a collection of functions that model changes to an account.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 表示实体状态和与逻辑相关的关注点是分开的。在这个例子中，`AccountState`捕获表示账户的数据，而`Account`是一组模拟账户变化的函数。
- en: 'When we write logic at a high level, we only rely on `Account`: for example,'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在高级别编写逻辑时，我们只依赖于`Account`：例如，
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This means that FP allows you to treat representing state and representing state
    transitions as separate concerns. Also, business logic is higher-level compared
    to the data (`Account` depends on the lower-level `AccountState`).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数式编程（FP）允许你将表示状态和表示状态转换视为不同的关注点。此外，业务逻辑与数据（`Account`依赖于较低级别的`AccountState`）相比处于更高层次。
- en: Naming conventions
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'If you follow the approach of separating logic from data, you have to pick
    a naming convention to differentiate the data object from the class including
    the logic. Here, I used the entity name (`Account`) for the class containing the
    logic; this is because I like to have the best readability when referring to functions
    point-free: for example, `Account.Activate` in'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循将逻辑与数据分离的方法，你必须选择一个命名约定来区分数据对象和包含逻辑的类。在这里，我使用了包含逻辑的类名（`Account`）作为类名；这是因为我喜欢在引用无参数函数时保持最佳的可读性：例如，`Account.Activate`在
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The more verbose `AccountState`, on the other hand, can often be omitted by
    using `var`. Other naming conventions are possible, of course. Pick what makes
    the most sense, and be consistent within your application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，更冗长的`AccountState`通常可以通过使用`var`来省略。当然，其他命名约定也是可能的。选择最符合逻辑的，并在你的应用程序中保持一致性。
- en: '`Account` is a class because C# syntax requires it (with the exception of top-level
    statements, you cannot declare methods or delegates outside of a class), but conceptually,
    it’s just a grouping of related functions. This can be referred to as a *module*.
    These functions don’t rely on any state in the enclosing class, so you can think
    of them as free-standing functions and of the class name as part of the namespace.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account`是一个类，因为C#语法要求它（除了顶层语句外，你无法在类外声明方法或委托），但从概念上讲，它只是相关函数的集合。这可以被称为*模块*。这些函数不依赖于封装类中的任何状态，因此你可以将它们视为独立的函数，并将类名视为命名空间的一部分。'
- en: This separation between data (which is inert) and functions (which perform data
    transformations) is typical of FP. This is in stark contrast with OOP, where objects
    include both data and methods that mutate that data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将数据（无生命的）和函数（执行数据转换的函数）之间的分离是函数式编程（FP）的典型特征。这与面向对象编程（OOP）形成鲜明对比，在OOP中，对象既包含数据也包含修改这些数据的方法。
- en: Separating data from logic results in simpler systems with less coupling that
    are, therefore, easier to understand and to maintain. It is also a logical choice
    when programming with distributed systems, where data structures need to be easy
    to serialize and pass between applications, while logic resides within those applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据与逻辑分离会导致系统更简单、耦合更少，因此更容易理解和维护。在编程分布式系统时，这也是一个合理的选择，因为数据结构需要易于序列化和在应用程序之间传递，而逻辑则位于这些应用程序中。
- en: Data-oriented programming (DOP)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 数据导向编程（DOP）
- en: Several of the ideas I’ve discussed in this chapter are relevant to DOP, a paradigm
    that advocates separating logic from data as a means to decrease the complexity
    of an application. FP and DOP are distinct, but there is some overlap. The principles
    of DOP are
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我讨论的几个想法与DOP相关，DOP是一种倡导通过将逻辑与数据分离来降低应用程序复杂性的范式。FP和DOP是不同的，但它们之间有一些重叠。DOP的原则是
- en: Separate logic from data entities.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑与数据实体分离。
- en: Use immutable data.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不可变数据。
- en: Use generic structures to represent data entities.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用泛型结构来表示数据实体。
- en: FP also advocates using immutable data, and the use of immutable data and pure
    functions naturally leads to separating logic from data entities, as I demonstrated
    in this section. There is definitely some overlap between FP and DOP.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）也提倡使用不可变数据，使用不可变数据和纯函数自然地导致将逻辑与数据实体分离，正如我在本节中演示的那样。FP和DOP之间肯定有一些重叠。
- en: As for the third principle, DOP advocates using generic structures to represent
    data; for example, instead of defining an `AccountState` type with a `Currency`
    property, you would use a dictionary, mapping the value for the account’s currency
    to the Currency key and similarly for other fields.^a It turns out that you can
    represent data of any shape by using just lists, dictionaries, and primitives.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第三个原则，DOP提倡使用泛型结构来表示数据；例如，你不会定义一个具有`Currency`属性的`AccountState`类型，而是会使用一个字典，将账户货币的值映射到`Currency`键，以及其他字段的类似映射.^a
    结果表明，你可以仅使用列表、字典和原始数据类型来表示任何形状的数据。
- en: The main benefit of using generic structures to represent data is that you can
    handle data in a correspondingly general fashion; for example, given two snapshots
    of data of any shape, you can compare them and see what bits have changed. You
    can merge change sets and see if concurrent updates cause conflicts. That’s pretty
    powerful.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型结构来表示数据的主要好处是你可以以相应通用的方式处理数据；例如，给定任何形状的两个数据快照，你可以比较它们并查看哪些位发生了变化。你可以合并更改集并查看并发更新是否导致冲突。这非常强大。
- en: The obvious drawback is that you lose type safety, so it’s a bit of a hard sell
    for programmers who are used to working in statically typed languages like C#.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的缺点是你会失去类型安全，因此对于习惯于在静态类型语言（如C#）中工作的程序员来说，这有点难以推销。
- en: If you want to learn more about DOP, understand how separating logic and data
    simplifies life, and see why using generic structures to represent data entities
    can be worthwhile, see *Data-Oriented Programming* by Yehonathan Sharvit (Manning,
    2021).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于DOP的信息，了解如何通过分离逻辑和数据简化生活，以及为什么使用泛型结构来表示数据实体是有价值的，请参阅Yehonathan Sharvit的《数据导向编程》（Manning,
    2021）。
- en: ^a If you wanted to follow this approach in C#, you would probably use the `dynamic`
    type for sugar-coating an underlying dictionary. This allows you to access field
    values with the dot notation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 如果你想在C#中采用这种方法，你可能会使用`dynamic`类型来对底层字典进行糖包装。这允许你使用点符号访问字段值。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'FP discourages state mutation, preventing several drawbacks associated with
    state mutation, such as lack of thread safety, coupling, and impurity:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP反对状态突变，防止与状态突变相关的一些缺点，如线程不安全、耦合和不纯：
- en: Things that don’t change are represented with immutable objects.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变的事物用不可变对象来表示。
- en: Things that change are also represented with immutable objects; these immutable
    snapshots represent an entity’s state at a given point. Change is represented
    by creating a new snapshot with the desired changes.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化的事物也用不可变对象来表示；这些不可变快照代表了实体在某个特定时刻的状态。变化通过创建一个新的快照并包含所需的变化来表示。
- en: Use records to define custom immutable data types.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录来定义自定义不可变数据类型。
- en: For a type to be immutable, all its children, including lists and other data
    structures, must also be immutable.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使一个类型不可变，它所有的子类型，包括列表和其他数据结构，也必须是不可变的。
- en: 'You can simplify your application and promote loose coupling by separating
    data from logic:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将数据与逻辑分离，你可以简化你的应用程序并促进松耦合：
- en: Use data objects (typically records) to encapsulate data.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据对象（通常是记录）来封装数据。
- en: Use functions (implemented as static methods within stateless static classes)
    to represent business logic.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数（作为无状态静态类中的静态方法实现）来表示业务逻辑。
- en: '* * *'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ The preceding examples refer to multithreading, but the same problems can
    arise if the source of concurrency is asynchrony or parallelism (these terms were
    described in the sidebar on the “Meaning and types of concurrency” in chapter
    3).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 前面的例子提到了多线程，但如果并发源是异步或并行（这些术语在第 3 章的“并发意义和类型”侧边栏中进行了描述），同样的问题也可能出现。
- en: ² The fundamental techniques I discuss in this section are ubiquitous in FP,
    but the concepts and metaphors I use to explain them are largely inspired by Rich
    Hickey, the creator of the Clojure programming language.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ² 我在本节中讨论的基本技术是函数式编程（FP）中普遍存在的，但我用来解释这些技术的概念和隐喻主要受到了 Clojure 编程语言创造者 Rich Hickey
    的启发。
- en: ³ The creators of .NET took inspiration from Java, but in this case, they also
    learned from Java’s mistakes (Java had mutable dates until Java 8).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的创造者从 Java 中汲取了灵感，但在这个案例中，他们还从 Java 的错误中吸取了教训（Java 直到 Java 8 才有可变的日期）。
- en: ⁴ In reality, you can still mutate read-only variables by using reflection.
    But making a field read-only is a clear signal to any clients of your code that
    the field isn’t meant to be mutated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 实际上，你仍然可以通过反射来修改只读变量。但将字段设置为只读是一个明确的信号，表明该字段不应该被修改。
