- en: 9 Parameter packs and std::visit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 参数包和 std::visit
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Practicing with algorithms and execution policies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用算法和执行策略进行练习
- en: Template parameter packs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板参数包
- en: The `std::visit` method and `Overload` pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::visit` 方法与 `Overload` 模式'
- en: Mutable lambdas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变 lambda
- en: Extra practice with variants, `std::format`, and ranges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变体、`std::format` 和范围进行额外练习
- en: We have used parameter packs (the three dots in a template) several times now,
    but we have not paused to understand how they work. In the final chapter, we will
    fill in the dots, as well as practice many things we have learned so far. We will
    generate triangle numbers and briefly consider some of their properties. Triangle
    numbers crop up in various places (e.g., counting how many handshakes would happen
    in a group of people if everyone shakes hands). Because we started with Pascal’s
    triangle, returning to a number sequence feels like a good way to round off.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用参数包（模板中的三个点），但我们没有停下来理解它们是如何工作的。在最后一章中，我们将填补这些点，以及练习我们迄今为止学到的许多东西。我们将生成三角数，并简要考虑它们的某些属性。三角数出现在各种地方（例如，如果每个人在人群中握手，我们可以计算会有多少次握手）。因为我们从帕斯卡三角形开始，回到数字序列感觉像是一个很好的结束方式。
- en: We’ll discover we can create triangle numbers in a couple of lines of code using
    numeric algorithms, and then we will build a slot machine using the first few
    triangle numbers. We will build a simple machine first, which only spins the reels.
    We will then improve the game, allowing holds, nudges, or spins. To implement
    these options, we will learn about `std::visit` and the `Overload` pattern. We
    will practice what we have learned in previous chapters, which will help us write
    more C++ using new features, being confident we can keep up to date with any future
    changes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现我们可以通过几行代码使用数值算法来创建三角数，然后我们将使用前几个三角数构建一个老虎机。我们首先构建一个简单的机器，它只旋转滚筒。然后我们将改进游戏，允许暂停、推动或旋转。为了实现这些选项，我们将学习
    `std::visit` 和 `Overload` 模式。我们将练习我们在前几章中学到的知识，这将帮助我们使用新特性编写更多的 C++ 代码，并自信地跟上任何未来的变化。
- en: 9.1 The triangle numbers
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 三角数
- en: The triangle numbers are 1, 3, 6, 10, and so forth, formed by summing 1, 1 +
    2, 1 + 2 + 3, 1 + 2 + 3 + 4, and so forth. If we racked up that many snooker balls,
    we could make a triangle. Hence the name. To add another row to the five shown
    in figure 9.1, we use six more snooker balls. A further row would add seven and
    so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 三角数是 1、3、6、10 等等，通过累加 1、1 + 2、1 + 2 + 3、1 + 2 + 3 + 4 等等得到。如果我们堆起这么多台球，我们就可以组成一个三角形。因此得名。为了在图
    9.1 中显示的五个三角数上添加另一行，我们使用六个额外的台球。再下一行将增加七个，以此类推。
- en: '![CH09_F01_Buontempo](../Images/CH09_F01_Buontempo.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Buontempo](../Images/CH09_F01_Buontempo.png)'
- en: Figure 9.1 Snooker balls racked up, forming a triangle with 15 = 1 + 2 + 3 +
    4 + 5 balls
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 堆叠的台球，形成包含 15 = 1 + 2 + 3 + 4 + 5 个台球的三角形
- en: 'We will use the first few triangle numbers in this chapter, so let’s make a
    function called `make_ triangle_numbers`. We will take a `count` and return a
    `vector` of `int`s. `std::vector` and `std::string` have supported `constexpr`
    since C++20 (see [http://mng.bz/wjDP](http://mng.bz/wjDP)), so we can mark the
    function as `constexpr`, which we first saw in chapter 3 when we learned how to
    use `static_assert` for testing. We will be able to perform similar checks here
    too. Our new function starts with the following signature:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用前几个三角数，因此让我们创建一个名为 `make_triangle_numbers` 的函数。我们将接受一个 `count` 参数并返回一个
    `int` 类型的 `vector`。自 C++20 起支持 `constexpr` 的 `std::vector` 和 `std::string`（参见
    [http://mng.bz/wjDP](http://mng.bz/wjDP)），因此我们可以将函数标记为 `constexpr`，这是我们首次在第三章中学习如何使用
    `static_assert` 进行测试时看到的。我们也将能够在这里执行类似的检查。我们的新函数以以下签名开始：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s add the details. If we start with the numbers 1, 2, 3, and so on, we can
    then sum these to obtain the triangle numbers. C++11 introduced the `iota` function
    in the `numeric` header, which fills a container with sequentially increasing
    values, starting with a chosen value. If we make a vector with space for 20 numbers
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加细节。如果我们从数字 1、2、3 等开始，然后我们可以将这些数字相加以获得三角数。C++11 在 `numeric` 头文件中引入了 `iota`
    函数，该函数使用递增的值填充容器，从选定的值开始。如果我们创建一个可以容纳 20 个数字的向量
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'we can then call `iota`, starting with the value 1, to create the numbers 1,
    2, 3, and so on:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用 `iota`，从值 1 开始，以创建 1、2、3 等数字：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can use the ranges version, introduced in C++23:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 C++23 中引入的范围版本：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: C++23 isn’t widely supported yet, so you might have to wait until your compiler
    offers the ranges’ version. In either case, this fills the `vector` with numbers
    starting at 1 and increasing by 1 each time. This gives us 1, 2, 3,...20\. The
    `iota` function came from the APL programming language and was proposed before
    C++11, but it was not included until later. It’s a small but useful function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C++23尚未得到广泛支持，所以你可能不得不等到你的编译器提供ranges版本。在任何情况下，这都将`vector`填充为从1开始，每次增加1的数字。这给我们1,
    2, 3,...20\. `iota`函数来自APL编程语言，并在C++11之前提出，但直到后来才被包含进来。这是一个小但有用的函数。
- en: 'If we find the partial or cumulative sums of these numbers (1, 1 + 2, etc.),
    we obtain the triangle numbers. To do this, we can use the function `std::partial_sum`
    from the `numeric` header:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到这些数字（1, 1 + 2, 等等）的部分和或累积和，我们得到三角形数。为此，我们可以使用`numeric`头文件中的`std::partial_sum`函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We then have the triangle numbers we wanted (1, 3, 6, 10, 15,...210).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就得到了我们想要的三角形数（1, 3, 6, 10, 15,...210）。
- en: Listing 9.1 Making the first few triangle numbers
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 制作前几个三角形数
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Container for default initialized ints
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 默认初始化整数的容器
- en: ❷ Fills with 1, 2,...
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 填充1, 2,...
- en: ❸ Sums 1, 1 + 2, 1 + 2 + 3,...
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 求和1, 1 + 2, 1 + 2 + 3,...
- en: We’ve used an older C++ function, `std::partial_sum`, as well as the newer `std::iota`
    function from the `numeric` header. There are many other algorithms we haven’t
    had a chance to use in this book. Have a look through the `algorithm` and `numeric`
    headers, and try one you haven’t used before, or even implement one yourself.
    This is a great way to keep practicing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了一个较旧的C++函数`std::partial_sum`以及来自`numeric`头文件的较新的`std::iota`函数。还有许多其他算法我们没有机会在这本书中使用。查看`algorithm`和`numeric`头文件，尝试一个你之前没有使用过的算法，或者甚至自己实现一个。这是保持练习的好方法。
- en: 9.1.1 Testing our triangle numbers with algorithms
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 使用算法测试我们的三角形数
- en: We should test our triangle numbers and can use a few more algorithms to do
    so. We can undo the `partial_sum`, using `adjacent_difference`, which gives the
    difference between adjacent elements in a container. If we make a `vector` for
    the differences, we can compare these with the integers from 1 to 20 created by
    `iota`, and we can `assert` that they match.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试我们的三角形数，并且可以使用一些额外的算法来做到这一点。我们可以使用`adjacent_difference`来撤销`partial_sum`，它给出了容器中相邻元素之间的差值。如果我们为这些差值创建一个`vector`，我们可以将这些差值与由`iota`创建的从1到20的整数进行比较，并且我们可以使用`assert`来验证它们是否匹配。
- en: Listing 9.2 Testing our triangle numbers
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 测试我们的三角形数
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Finds the differences
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找差值
- en: ❷ Compares with 1, 2,...
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 与1, 2,...比较
- en: 'Let’s spend a little time adding a few more `assert`s to our test function.
    If we find the `adjacent_difference` a second time, we should obtain a `vector`
    of `1`s. We can check this using the `all_of` algorithm with a lambda:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间在我们的测试函数中添加更多的`assert`。如果我们再次找到`adjacent_difference`，我们应该得到一个全为`1`的`vector`。我们可以使用带有lambda的`all_of`算法来检查这一点：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can count the `1`s to check that we have the number we started with using
    `std::coun`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`std::coun`来计数，以检查我们是否得到了我们开始的数字：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have a small handful of tests and will add another shortly. Before we do,
    it’s worth filling in a few more dots. Most algorithms have various overloads.
    For example, `std::count` has three versions (see [https://en.cppreference.com/w/cpp/algorithm/count](https://en.cppreference.com/w/cpp/algorithm/count)).
    We used the first version. The second is marked `constexpr`, so it could be used
    at compile time, and the third uses an *execution policy*, allowing parallel execution
    of an algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些小的测试，并将很快添加另一个。在我们这样做之前，值得补充一些更多的点。大多数算法都有各种重载。例如，`std::count`有三个版本（见[https://en.cppreference.com/w/cpp/algorithm/count](https://en.cppreference.com/w/cpp/algorithm/count)）。我们使用了第一个版本。第二个版本标记为`constexpr`，因此可以在编译时使用，第三个版本使用*执行策略*，允许算法的并行执行。
- en: 9.1.2 Execution policies for algorithms
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 算法的执行策略
- en: 'C++17 introduced several execution type policies that live in the `execution`
    header. By default, a `sequenced_policy`, `std::execution::seq`, is used, which
    causes the algorithm to operate in sequence, one item at a time. We can also use
    `std::execution:: par` or `std::execution::par_unseq` and C++20’s `std::execution::unseq`.
    The latter three allow parallel execution, and the unsequenced policies may cause
    execution to happen in any order. They indicate the algorithm *can* be parallelized,
    so it is a *permission* rather than a *requirement*. These policies fall back
    to a sequential policy if the implementation cannot be parallelized, and even
    if it can, the code might end up being slower (see Bartlomiej Filipek’s blog at
    [http://mng.bz/JdGV](http://mng.bz/JdGV)). The parallel versions give us a simple
    way to indicate that work can be fired off to different threads, but they are
    not guaranteed to speed our code up. They might, but setting up work on new threads
    can have an overhead.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C++17引入了几个存在于`execution`头文件中的执行类型策略。默认情况下，使用`sequenced_policy`，即`std::execution::seq`，这会导致算法按顺序操作，一次处理一个项目。我们也可以使用`std::execution::par`或`std::execution::par_unseq`以及C++20的`std::execution::unseq`。后三种允许并行执行，无序策略可能会以任何顺序执行。它们表明算法*可以*并行化，所以这是一个*许可*而不是*要求*。如果实现不能并行化，这些策略会回退到顺序策略，即使可以实现，代码也可能最终运行得更慢（参见Bartlomiej
    Filipek的博客[http://mng.bz/JdGV](http://mng.bz/JdGV)）。并行版本给我们提供了一个简单的方法来指示可以将工作分发到不同的线程，但它们并不保证加快代码的执行速度。它们可能会，但设置新线程上的工作可能会有开销。
- en: 'If we add `std::execution::par` as the first parameter, we use the overload
    for parallel execution:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`std::execution::par`作为第一个参数添加，我们使用并行执行的覆盖：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Requesting parallel execution is straightforward and may speed up your code.
    Experiment and measure to see what happens. Threading and parallel execution is
    a big topic. Anthony Williams’s book *C++ Concurrency in Action* (Manning Publications,
    2019; see [http://mng.bz/PR5n](http://mng.bz/PR5n)) is an excellent resource,
    and you can find many of his talks on the internet.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请求并行执行很简单，可能会加快你的代码执行速度。进行实验并测量以查看会发生什么。线程和并行执行是一个很大的话题。安东尼·威廉姆斯的书籍《C++并发实战》（Manning
    Publications，2019；见[http://mng.bz/PR5n](http://mng.bz/PR5n)）是一个极好的资源，你可以在互联网上找到他许多的演讲。
- en: 9.1.3 Mutable lambdas
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 可变lambda
- en: Our tests so far are necessary but not sufficient. There is a closed-form formula
    for the triangle numbers, calculating the n^(th) number directly as
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的测试是必要的，但并不充分。三角形数的封闭形式公式可以直接计算第n个数字，如下所示：
- en: '![09_E01](../Images/09_E01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![09_E01](../Images/09_E01.png)'
- en: We can use this relationship to make our tests sufficient, at least for the
    first few numbers, by checking that each value matches the equation’s value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种关系使我们的测试足够充分，至少对于前几个数字，通过检查每个值是否与方程的值相匹配。
- en: Listing 9.3 Checking each value
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 检查每个值
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have seen that we can often use an algorithm instead of a `for` loop, and
    because we want to check the relationship holds for all of the numbers, `std::all_of`
    will work. However, when we switch to the algorithm, we no longer have the variable
    `i` to use in the calculation. We can declare a variable in a lambda’s square
    brackets `[]` and flag the lambda as `mutable`, which allows us to increment the
    variable. Without the `mutable` keyword, we get a compiler error, telling us a
    by-copy capture cannot be modified in a nonmutable lambda.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们通常可以使用算法而不是`for`循环，并且因为我们想检查关系对所有数字都成立，所以`std::all_of`将起作用。然而，当我们切换到算法时，我们不再有变量`i`用于计算。我们可以在lambda的方括号`[]`中声明一个变量，并将lambda标记为`mutable`，这允许我们增加变量。如果没有`mutable`关键字，我们会得到编译器错误，告诉我们不能在不可变的lambda中修改按值捕获的变量。
- en: In addition, `mutable` allows the lambda to modify the objects captured by copy
    and to call non-const member functions of by-copy-captured objects. Using `std::all_of`
    instead of the `for` loop from listing 9.3 with a mutable lambda gives us the
    following code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`mutable`允许lambda修改通过复制捕获的对象，并调用通过复制捕获的对象的非const成员函数。使用具有可变lambda的`std::all_of`而不是列表9.3中的`for`循环，我们可以得到以下代码。
- en: Listing 9.4 Checking each value with a mutable lambda
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 使用可变lambda检查每个值
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ n set to 0 and mutable because n is incremented
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ n设置为0且为可变，因为n会增加
- en: We have the triangle numbers and some tests. If we pause to look at more properties,
    we can get a bit more practice with algorithms. We will also discover a useful
    property making the triangle numbers suitable for use in our slot machine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三角形数和一些测试。如果我们停下来看看更多的属性，我们可以在算法上得到更多的练习。我们还将发现一个有用的属性，使三角形数适合用于我们的老虎机。
- en: 9.1.4 More properties of the triangle numbers
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 三角形数的更多属性
- en: First, let’s consider whether the triangle numbers are odd or even. Then, we
    will find another pattern we can use for our slot machine. We will also get a
    bit more practice with algorithms and the `std::map` as we investigate. The first
    two triangle numbers, 1 and 3, are odd, and then we get two even numbers, 6 and
    10\. Does this pattern continue? We will find out if we transform our `vector`,
    flagging odd numbers with a dot (`'.'`) and even numbers with an asterisk (`'*'`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑三角形数是奇数还是偶数。然后，我们将找到另一个我们可以用于老虎机的模式。在调查过程中，我们还将对算法和`std::map`进行更多的练习。前两个三角形数，1和3，是奇数，然后我们得到两个偶数，6和10。这个模式会继续吗？我们将通过将我们的`vector`转换为标记奇数（点`'.'`）和偶数（星号`'*'`）来找出答案。
- en: 'We can declare another `vector` to hold the transformation. We’ve used the
    `std::transform` algorithm from the `algorithm` header in chapter 7 to make the
    characters in an `std::string` lowercase. There are various overloads, but each
    applies a function to an input range and stores the results in an output. The
    original version took a pair of input iterators, first and last, an output iterator,
    and a unary function: a function taking one input, like our lambda. C++20 introduced
    a ranges’ version, which takes an input source, rather than a pair of iterators,
    along with the output iterator and unary function. There is also a version taking
    two input ranges and a binary function to create the output, as well as a version
    taking execution policies.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明另一个`vector`来保存转换。我们在第7章中使用了`algorithm`头文件中的`std::transform`算法来将`std::string`中的字符转换为小写。有各种重载，但每个都应用于输入范围并存储结果。原始版本接受一对输入迭代器，第一个和最后一个，一个输出迭代器，和一个一元函数：一个接受一个输入的函数，就像我们的lambda。C++20引入了范围版本，它接受一个输入源，而不是一对迭代器，以及输出迭代器和一元函数。还有一个接受两个输入范围和用于创建输出的二元函数的版本，以及一个接受执行策略的版本。
- en: 'Let’s write a function called `demo_further_properties`. We will use a single
    character for each number, so we can use a `vector` of `char` to store the results:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为`demo_further_properties`的函数。我们将为每个数字使用一个字符，因此我们可以使用`char`的`vector`来存储结果：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can write a lambda for the transforming function, taking an `int` and returning
    the appropriate character to indicate the parity of a number:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个转换函数的lambda表达式，它接受一个`int`并返回表示数字奇偶性的适当字符：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If `i%2` is nonzero, we have an odd number, so we return `''.''`; otherwise,
    we return `''*''`. We use this in the transformation, with a `back_inserter` to
    grow the output as needed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`i%2`不为零，我们有一个奇数，因此我们返回`'.'`；否则，我们返回`'*'`。我们在转换中使用这个，使用`back_inserter`按需增长输出：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We could use a range-based `for` loop to display the parity of the numbers,
    but back in chapter 2, we noted that we can use `std::copy` or the ranges’ version
    to insert the contents of a container into a stream. The first parameter is the
    container, or its `begin` and `end`, and the second is an `std::ostream_iterator`
    constructed with a stream (in our case, `std::cout`) and a delimiter (say, a space).
    We can then stream out the odd or even markers in one line of code once we include
    the `iostream` header:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基于范围的`for`循环来显示数字的奇偶性，但在第2章中，我们提到我们可以使用`std::copy`或范围版本的函数将容器的内容插入到流中。第一个参数是容器，或其`begin`和`end`，第二个是一个使用流（在我们的情况下，`std::cout`）和分隔符（例如，空格）构造的`std::ostream_iterator`。一旦包含`iostream`头文件，我们就可以在单行代码中流式传输奇数或偶数标记：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our further properties function looks like this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进一步属性函数看起来像这样。
- en: Listing 9.5 Checking whether the numbers are odd or even
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 检查数字是否为奇数或偶数
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Vector for results
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 结果向量
- en: ❷ Lambda to check parity
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查奇偶性的Lambda
- en: ❸ Copies to cout
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 复制到cout
- en: If we call this from `main` and look at the output, we see
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`main`中调用它并查看输出，我们看到
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It appears that we do get two odd numbers followed by two even numbers, over
    and over. Stack Exchange’s math site explains why this happens (see [http://mng.bz/1JBj](http://mng.bz/1JBj)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们确实得到了两个奇数后面跟着两个偶数，反复出现。Stack Exchange的数学网站解释了为什么会这样（见[http://mng.bz/1JBj](http://mng.bz/1JBj)）。
- en: We found one neat pattern. To build a slot machine, we want a selection of items
    to display on some reels. If some items match, the slot machine will pay out.
    The final digits of the triangle numbers have another pattern. Some digits occur
    more frequently than others, so we can use the final digits of triangle numbers
    for our slot machine. The less frequent digits will give a higher pay out. By
    keeping a tally in an `std::map` and calculating `% 10` rather than `% 2`, we
    will see how often each digit occurs. We need to map the last digit, which is
    an `int`, to a count, so after including the `map` header, we can use
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了一个有趣的模式。为了构建老虎机，我们希望在某个卷轴上显示一些项目。如果某些项目匹配，老虎机将支付。三角数的最后一位数字有另一个模式。一些数字出现的频率比其他数字高，因此我们可以使用三角数的最后一位数字来构建老虎机。出现频率较低的数字将提供更高的支付。通过在
    `std::map` 中保持计数并计算 `% 10` 而不是 `% 2`，我们将看到每个数字出现的频率。我们需要将最后一位数字（一个 `int`）映射到一个计数，因此包含
    `map` 头文件后，我们可以使用
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'in our `demo_further_properties` function. We can base the payout of our slot
    machine on the likelihood of the digits. We’ll use a raw loop to find the last
    digit of each triangle number. We need to look up the number `% 10` using `operator[]`
    and increment the value we obtain. We learned that `operator[]` will insert a
    key-value pair into a map if the key does not exist in chapter 7 when we built
    the answer smash game. The corresponding value is the default for the value’s
    type, in our case, a `size_t` of 0\. This is what we need. We create tallies of
    the last digits as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `demo_further_properties` 函数中。我们可以根据数字的可能性来决定老虎机的支付。我们将使用原始循环来找到每个三角数的最后一位数字。我们需要使用
    `operator[]` 来查找数字 `% 10`，并增加我们获得的价值。我们了解到，在第 7 章中构建答案砸游戏时，`operator[]` 将在键不存在时将键值对插入到映射中。相应的值是值的默认类型，在我们的情况下，是一个
    `size_t` 的 0。这正是我们所需要的。我们创建最后一位数字的计数如下：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can stream out the tallies so we know which digits happen most frequently:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以输出计数，以便我们知道哪些数字发生得最频繁：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pulling this into the function gives us the following.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将其拉入函数中，我们得到以下内容。
- en: Listing 9.6 Adding tallies of digits to further properties
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 将数字的计数添加到更多属性中
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Uses a map to store tallies
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用地图存储计数
- en: ❷ Counts the final digits
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算最后一位数字
- en: ❸ Streams out results
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出结果
- en: Calling this from `main`, we see
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `main` 中调用这个函数，我们看到
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`8`s and `3`s are unlikely; `0`, `1`, `5`, and `6` are twice as likely. In
    fact, the final digits repeat the pattern'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`8`s 和 `3`s 不太可能；`0`、`1`、`5` 和 `6` 的可能性是两倍。事实上，最后一位数字重复的模式'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: over and over. If we pick any three triangle numbers, we are unlikely to get
    three `3`s or `8`s as final digits, so such an outcome could be a jackpot in a
    game.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 反复进行。如果我们选择任意三个三角数，我们不太可能得到三个 `3`s 或 `8`s 作为最后一位数字，所以这样的结果可能是一个游戏的奖金。
- en: Let’s build a slot machine using three reels of triangle numbers. We need to
    make three reels, putting the numbers in random order. We also want to display
    the reels and make them spin for each turn, deciding whether to pay out.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用三个三角数卷轴来构建一个老虎机。我们需要制作三个卷轴，将数字随机排列。我们还希望显示卷轴，并在每次转动时使它们旋转，决定是否支付。
- en: 9.2 A simple slot machine
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 一个简单的老虎机
- en: 'We need three reels of numbers to spin. We will show the numbers on the current
    row, along with the numbers on the rows above and below. We can indicate the current
    row with a `''-''` sign like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要三个数字卷轴来旋转。我们将展示当前行的数字，以及上方和下方行的数字。我们可以用这样的 `'-'` 符号来表示当前行：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will start by spinning the reels on each turn. If two of the final digits
    match, we pay out, and if all three match, we pay out more. Once we have a working
    game, we will extend it in section 9.3, awarding a jackpot if we get three `3`s
    or `8`s.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在每次转动时旋转卷轴。如果两个最后一位数字匹配，我们将支付，如果三个都匹配，我们将支付更多。一旦我们有一个工作的游戏，我们将在 9.3 节中扩展它，如果得到三个
    `3`s 或 `8`s，我们将颁发奖金。
- en: 9.2.1 Revision of constexpr and std::format
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 constexpr 和 std::format 的修订
- en: 'Listing 9.1 generates triangle numbers as an `std::vector<int>`. If we utilize
    the `using` statement we met in the previous chapter, we won’t need to spell out
    `std:: vector<int>` each time we refer to the reels:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 生成三角数作为 `std::vector<int>`。如果我们利用上一章中遇到的 `using` 语句，我们就不必每次提到卷轴时都拼写 `std::vector<int>`：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This can live near the top of the `main.cpp` file. We can now make three reels
    for our slot machine, with 20 numbers in each in a new function called `make_reels`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以放在 `main.cpp` 文件的顶部附近。现在我们可以为老虎机制作三个卷轴，每个卷轴有20个数字，在一个名为 `make_reels` 的新函数中：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The numbers should be shuffled for the game. We can use `std::shuffle` directly
    on a reel:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的数字应该是洗好的。我们可以直接在 `reel` 上使用 `std::shuffle`：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, we know testing code with random behavior can be difficult. If we use
    a template with an invocable function rather than a random number generator, we
    can swap out the generator for testing. The invocable function takes two iterators
    into a `vector` of `Reel`s, so we use
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们知道测试具有随机行为的代码可能很困难。如果我们使用一个带有可调用函数的模板而不是随机数生成器，我们可以为测试替换生成器。可调用函数将两个迭代器放入
    `Reel` 的 `vector` 中，因此我们使用
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'instead of the keyword `typename` in the template head:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是模板头中的 `typename` 关键字：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We would get away with
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: but using a concept instead of the raw typenames means we are likely to get
    clearer diagnostics if we don’t provide a suitable type for `T`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用概念而不是原始类型名称意味着如果我们没有为 `T` 提供合适的类型，我们可能会得到更清晰的诊断信息。
- en: We need to include the `concepts` header, and we can flag the function as `constexpr`.
    Our `make_reels` function looks like this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含 `concepts` 头文件，并且我们可以将函数标记为 `constexpr`。我们的 `make_reels` 函数看起来像这样。
- en: Listing 9.7 Seting up `reels`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 设置 `reels`
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Passes in shuffle to allow testing
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递洗牌以允许测试
- en: ❷ Makes the reels
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建 `reels`
- en: ❸ Shuffles the reels
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 洗牌 `reels`
- en: We can call this code in two ways. To use the function in our game, which we
    will create shortly, we need a seeded generator
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式调用此代码。要使用我们将在不久后创建的游戏中的函数，我们需要一个已播种的生成器
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'and capture this generator by reference in a lambda:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 lambda 引用捕获此生成器：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then call `make_reels` using our lambda:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们的 lambda 调用 `make_reels`：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In addition, as the function is `constexpr`, we can use `static_assert` in
    the `check_ properties` function we started in listing 9.2, mocking out the random
    behavior with a no-op lambda:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于函数是 `constexpr`，我们可以在第 9.2 列表中开始的 `check_properties` 函数中使用 `static_assert`，用无操作
    lambda 模拟随机行为：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This doesn’t test much but indicates what’s possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不测试很多，但表明了可能的情况。
- en: Armed with three shuffled reels, we need to display the numbers on each. We
    will show the previous row, the current row, and the next row, indicating the
    current row with a `'-'`. We used `std::format` back in chapter 2, so let’s use
    it again for practice. If your compiler doesn’t support `std::format`, look back
    to chapter 2 for instructions on using the `fmt` library instead. The numbers
    will be up to three digits long, so we right align them over three characters,
    padding with spaces. We put a format specifier after a colon, using `>` for right
    alignment and `3` for the number of spaces, giving `{:>3}`. We pass in reels,
    along with the stream, so we can test our code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有三组洗好的 `reels`，我们需要显示每组的数字。我们将显示上一行、当前行和下一行，用 `'-'` 标记当前行。我们在第 2 章中使用了 `std::format`，所以让我们再次使用它来练习。如果你的编译器不支持
    `std::format`，请回顾第 2 章中关于使用 `fmt` 库的说明。数字最多三位，因此我们将它们右对齐到三个字符，并用空格填充。我们在冒号后放置一个格式说明符，使用
    `>` 进行右对齐，使用 `3` 表示空格数，给出 `{:>3}`。我们传递 `reels` 和流，以便我们可以测试我们的代码。
- en: Listing 9.8 Displaying `reels`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 显示 `reels`
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Previous row
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 上一行
- en: ❷ Current row indicated with -
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 `-` 标记当前行
- en: ❸ Next row
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 下一行
- en: 'We’ve set up the reels and can now display them. To make a game, we need to
    decide if the current row deserves some kind of payout, and then we need to spin
    the reels. We also want a way to stop the game. We can use `getline` like we have
    done before:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了 `reels`，现在可以显示它们。为了制作游戏，我们需要决定当前行是否应获得某种类型的回报，然后我们需要旋转 `reels`。我们还想有一种停止游戏的方法。我们可以使用
    `getline`，就像我们之前做的那样：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the `response` is anything other than Enter being pressed, we will quit.
    Let’s spin the reels first and then build the game.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `response` 不是按下 Enter，我们将退出。让我们先旋转 `reels`，然后再构建游戏。
- en: 9.2.2 Using std::rotate to spin the reels
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用 std::rotate 旋转 `reels`
- en: The `algorithm` header provides an `std::rotate` function we can use for the
    spin. This function performs a left rotation on the elements. Given some elements
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`algorithm` 头文件提供了一个 `std::rotate` 函数，我们可以用它来旋转。此函数对元素执行左旋转。给定一些元素'
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: we can visualize them as a reel, as shown in figure 9.2.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其可视化为一个可以旋转或旋转的 `reel`，如图 9.2 所示。
- en: '![CH09_F02_Buontempo](../Images/CH09_F02_Buontempo.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Buontempo](../Images/CH09_F02_Buontempo.png)'
- en: Figure 9.2 Elements arranged on a reel we can spin or rotate
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 元素排列在一个可以旋转或旋转的 `reel` 上
- en: 'We can perform a left rotation of the elements by stating a begin, middle (say,
    the number 4, which is three from begin), and end:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定开始、中间（比如说，从开始起的数字 4，即三个位置）和结束来对元素执行左旋转：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using `v.begin()` `+` `3` as the middle moves the number 4 to the beginning,
    and the elements before that move to the end, so we get
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `v.begin()` `+` `3` 作为中间位置将数字 4 移到前面，之前的元素移动到末尾，所以我们得到
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: as if the reel of numbers has spun. Arranged as a reel, the numbers would have
    rotated left, as shown in figure 9.3.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数字盘旋转了一样。排列成盘状，数字会向左旋转，如图 9.3 所示。
- en: '![CH09_F03_Buontempo](../Images/CH09_F03_Buontempo.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Buontempo](../Images/CH09_F03_Buontempo.png)'
- en: Figure 9.3 Rotating left spins the chosen middle to the beginning.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 向左旋转将选中的中间位置旋转到开始位置。
- en: Initially, we had 1, 2, 3, 4, and 5\. We picked a middle of `begin` `+` `3`,
    moving 4 to the front. 1 is now at `begin` `+` `2`, so we can rotate again, using
    the position of the 1
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们有 1, 2, 3, 4 和 5。我们选择 `begin` `+` `3` 的中间位置，将 4 移到前面。现在 1 在 `begin` `+`
    `2` 的位置，因此我们可以再次旋转，使用 1 的位置。
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: and the elements end up back where they started.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 并且元素最终回到了它们开始的位置。
- en: 'We want to spin the slot machine reels at random, varying the middle used.
    The parameters are iterators, so we can add a random number to the beginning of
    a reel to pick which middle to use. We have a random number generator, which we
    used for the initial shuffle. We now need a distribution too. We want each number
    on a reel to be possible, but also want the reels to move, so we need to run from
    the second element to the last element. We can use a distribution of `1` up to
    and including the size of the reel `− 1` to generate an offset to add to `begin`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望随机旋转老虎机的盘，改变使用的中间值。参数是迭代器，因此我们可以向盘的开始添加一个随机数来选择要使用的中间值。我们有一个随机数生成器，我们用它来进行初始洗牌。我们现在还需要一个分布。我们希望盘上的每个数字都是可能的，同时也希望盘可以移动，因此我们需要从第二个元素到最后一个元素。我们可以使用从
    `1` 到包括盘大小 `− 1` 的分布来生成要添加到 `begin` 的偏移量：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we allowed `0`, the reel would not move. We can then spin all three of the
    reels:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们允许 `0`，盘就不会移动。然后我们可以旋转所有三个盘：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We will use this directly in the simple slot machine function in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节简单老虎机函数中直接使用这个方法。
- en: The rotate function has been in C++ for a very long time. If we look at CppReference
    ([http://mng.bz/27E0](http://mng.bz/27E0)), we notice a version taking an execution
    policy, introduced in C++17, and a `constexpr` version, introduced in C++20, along
    with a link to a ranges’ version. We are used to these new features now and will
    see them frequently when we look up an algorithm. We need one more function to
    calculate a payout. Then we can create our game.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转函数在 C++ 中已经存在很长时间了。如果我们查看 CppReference ([http://mng.bz/27E0](http://mng.bz/27E0))，我们会注意到一个接受执行策略的版本，这是
    C++17 中引入的，还有一个 `constexpr` 版本，这是 C++20 中引入的，以及一个指向 ranges 版本的链接。我们现在已经习惯了这些新特性，在查找算法时经常会看到它们。我们需要一个额外的函数来计算支付金额。然后我们可以创建我们的游戏。
- en: 9.2.3 The simple slot machine
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 简单老虎机
- en: To decide on a payout, we need to check whether any of the last digits match.
    All three matching deserves more than just two matching, while none matching receives
    nothing, so for now, we will award a payout of 2 for three matches and 1 for two
    matches.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定支付金额，我们需要检查最后几位数字是否匹配。所有三个匹配的比两个匹配的值得更多，而没有任何匹配则什么也得不到，所以现在我们将为三个匹配奖励 2，为两个匹配奖励
    1。
- en: Listing 9.9 Calculating payout
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 计算支付金额
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Three matches
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 三个匹配
- en: ❷ Two matches
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 两个匹配
- en: Now, if we want to give higher payouts for `3`s or `8`s, which are less likely,
    we are in danger of ending up with a snaky mess of `if`s and `else`s. We will
    revisit this later when we add more features to our game. For now, we have all
    the parts we need to make a simple slot machine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想给 `3` 或 `8` 这样的数字更高的支付金额，这些数字出现的概率较低，我们可能会陷入 `if` 和 `else` 的混乱之中。我们将在添加更多游戏功能时再次讨论这个问题。现在，我们已经有了制作简单老虎机所需的所有部分。
- en: We set up the reels, show the numbers, and award a payout if a line wins. The
    player can press Enter to continue or anything else to quit. If they continue,
    we spin the reels and show the numbers again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置盘，显示数字，如果一条线赢了就发放支付金额。玩家可以按 Enter 键继续或按其他任何键退出。如果他们继续，我们旋转盘并再次显示数字。
- en: Listing 9.10 A simple slot machine
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 简单老虎机
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Setup
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置
- en: ❷ Random int to spin reels
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 随机整数旋转盘
- en: ❸ Tracks credit
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 跟踪信用值
- en: ❹ Allows player to quit
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 允许玩家退出
- en: ❺ Spins reels
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 旋转盘
- en: ❻ Random int to spin reels
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 随机整数旋转盘
- en: 'If we call this from `main`, we can play our game. We probably won’t win very
    often, so watch our credit draining away. A typical output might look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 `main` 中调用它，我们就可以玩游戏了。我们可能不会经常赢，所以看着我们的信用值慢慢减少。一个典型的输出可能看起来像这样：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The payout is not very fair because two or three matching final digits are not
    very likely. We can give a fairer payout. If we also allow a reel to be held or
    nudged by one, we have a greater chance of winning. We can use more new C++ features,
    including `std::visit`, to achieve this. Let’s build a better slot machine.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 奖金并不非常公平，因为两个或三个匹配的最终数字不太可能。我们可以给出一个更公平的奖金。如果我们还允许滚筒被持有或轻推一个，我们就有更大的机会获胜。我们可以使用更多新的C++特性，包括`std::visit`来实现这一点。让我们构建一个更好的老虎机。
- en: 9.3 A better slot machine
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 更好的老虎机
- en: We will make two changes. First, we will improve the payout, and then we will
    allow holds or nudges. Let’s deal with the payout first. The payout is based on
    the last digit of left, middle, and right numbers. We know that `3` or `8` only
    happen twice out of the first 20 triangle numbers, so each has a 1/10 chance of
    appearing. Getting three `3`s therefore has a probability of 1/10×1/10×1/10 =
    1/1000, as does getting three `8`s. The other digits are more likely. Let’s also
    charge two credits per game this time. Without doing a full analysis, let’s give
    250 credits for three `3`s or `8`s and 15 for any other three matching digits.
    Two matching digits are more likely, so let’s give 15 credits for two `3`s or
    two `8`s and just 1 for the others.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行两项更改。首先，我们将提高奖金，然后我们将允许持有或轻推。让我们先处理奖金问题。奖金基于左、中、右数字的最后一位。我们知道`3`或`8`在最初的20个三角形数字中只出现两次，所以每个数字有1/10的机会出现。因此，得到三个`3`的概率是1/10×1/10×1/10
    = 1/1000，得到三个`8`的概率也是如此。其他数字出现的可能性更大。这次我们也将每次游戏收费两个信用点。在不进行全面分析的情况下，我们可以给得到三个`3`或`8`的玩家250个信用点，给其他任何三个匹配数字的玩家15个信用点。两个匹配数字出现的可能性更大，所以我们可以给两个`3`或两个`8`的玩家15个信用点，而其他情况只给1个信用点。
- en: 9.3.1 Parameter packs and fold expressions
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 参数包和折叠表达式
- en: 'When we calculated the payout before, we didn’t use a weighting and noted we
    were in danger of needing several `if`s and `else`s if we added more conditions.
    Let’s take a different approach. If we find the frequencies of our final digits,
    we can then pick the most frequent digit to calculate the payout. We are using
    three reels, so we want a function taking three digits and returning a `map` from
    digits to frequencies:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前计算奖金时，我们没有使用加权，并指出如果我们添加更多条件，我们可能会需要几个`if`和`else`。让我们采取不同的方法。如果我们找到最终数字的频率，然后我们可以选择最频繁的数字来计算奖金。我们使用三个滚筒，所以我们需要一个接受三个数字并返回从数字到频率的`map`的函数：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Rather than writing a function taking three numbers, we can do something more
    general. We’ve used several classes from the STL taking various numbers of parameters,
    including a `variant`. Back in chapter 5, we noted its definition:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写一个接受三个数字的函数，我们可以做更通用的事情。我们已经使用了STL中的几个类，这些类接受不同数量的参数，包括一个`variant`。在第五章中，我们提到了它的定义：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For a `variant`, we use a type. We can also use nontype template parameters.
    For example, we met `std::ratio` in chapter 4, using `int`s to form fractions
    such as `std::ratio<3,` `6>`. We accepted that the three dots or ellipsis in the
    `variant` mean a parameter pack, allowing us to state as many types as we want.
    We can use a parameter pack in a function template, as well as a class, and use
    nontype template parameter packs too. We can use a function with a nontype template
    parameter pack to find the frequencies. We will need to unpack the parameters
    to find the frequencies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个`variant`，我们使用一个类型。我们还可以使用非类型模板参数。例如，我们在第四章中遇到了`std::ratio`，使用`int`来形成分数，如`std::ratio<3,
    6>`。我们接受`variant`中的三个点或省略号表示一个参数包，允许我们声明我们想要的任何类型。我们可以在函数模板以及类中使用参数包，还可以使用非类型模板参数包。我们可以使用具有非类型模板参数包的函数来查找频率。我们需要解包参数来找到频率。
- en: In general, a *variadic template* is a template with at least one parameter
    pack. These were introduced in C++11 but have become easier to use as the language
    has evolved. In C++11, we needed to use recursion to unpack the arguments, using
    one item and then calling the function again with the remaining items. C++17 introduced
    *fold expression* (see [https://en.cppreference.com/w/cpp/language/fold](https://en.cppreference.com/w/cpp/language/fold)),
    avoiding the need for recursion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个*可变模板*是一个至少有一个参数包的模板。这些在C++11中被引入，但随着语言的发展，它们的使用变得更加容易。在C++11中，我们需要使用递归来解包参数，使用一个项目然后再次调用函数，使用剩余的项目。C++17引入了*折叠表达式*（见[https://en.cppreference.com/w/cpp/language/fold](https://en.cppreference.com/w/cpp/language/fold)），避免了递归的需求。
- en: 'Let’s try an example. We can write a fold expression to sum up one or more
    items. Afterwards, we will be able to use a variadic template to find the frequencies
    we want for the improved slot machine payout. We need to pay attention to the
    parameter pack in three places. First, we say `typename...` `Ts` to indicate zero
    or more parameters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个例子。我们可以编写一个折叠表达式来求和一项或多项。之后，我们将能够使用变长模板来找到改进的老虎机收益所需的频率。我们需要注意三个地方参数包。首先，我们说`typename...`
    `Ts`来表示零个或多个参数：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It’s common to use `Ts` here rather than `T` to draw attention to there being
    potentially several `Ts`. We are free to use whatever name we want. We can use
    `class` or `typename`, followed by the ellipsis and then our name `Ts`. Next,
    the function’s parameter is a `tail` of type `Ts...`. Notice the ellipsis has
    switched to appear after the `Ts` now. Finally, in the implementation, we again
    use three dots in conjunction with `operator+` to find the sum. The return type
    depends on the parameters, so we can use `auto`, and the compiler works it out
    for us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里通常使用`Ts`而不是`T`来引起对可能存在多个`Ts`的注意。我们可以自由地使用我们想要的任何名称。我们可以使用`class`或`typename`，然后是省略号，然后是我们的名称`Ts`。接下来，函数的参数是一个类型为`Ts...`的`tail`。注意省略号现在出现在`Ts`之后了。最后，在实现中，我们再次使用三个点与`operator+`结合来找到和。返回类型取决于参数，因此我们可以使用`auto`，编译器会为我们计算出结果。
- en: Listing 9.11 Fold example
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11折叠示例
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Dots in the template head
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模板头中的点
- en: ❷ Dots in the function signature
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 函数签名中的点
- en: ❸ Unpacks the dots in the function
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在函数中解包点
- en: The `... +` unpacks the `tail` and is called a fold expression. Such an expression
    tells the compiler to repeat the operator for each element in a variadic parameter
    pack. We could use `operator-` instead, or any other operator that applies to
    the parameters. We can also unpack using
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`... +`解包了`tail`，被称为折叠表达式。这样的表达式告诉编译器对变长参数包中的每个元素重复操作符。我们可以使用`operator-`代替，或者任何适用于参数的其他操作符。我们还可以使用以下方式解包：'
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can check the value for a few numbers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查几个数字的值：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The arguments `1`, `2`, and `3` are unpacked by ... `+ tail` to a left-associative
    expression:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`1`、`2`和`3`通过... `+ tail`被解包为一个左结合表达式：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we had the dots on the right instead, we would have the right-associative
    expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在右边有省略号，我们将有一个右结合表达式：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For addition of numbers, the side makes no difference. Subtraction would matter
    because
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字的加法，边没有关系。减法会有所不同，因为
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: whereas
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: whereas
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also use a `single` number:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用一个`单个`数字：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our function does not compile for no numbers. If we try
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有数字，我们的函数无法编译。如果我们尝试
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: we are told that a *unary fold expression* over + must have a nonempty expansion.
    A unary fold has the pack and operator, either a right fold
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知，在+上的一个*一元折叠表达式*必须有一个非空展开。一元折叠有一个包和操作符，要么是一个右折叠
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'or a left fold:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个左折叠：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A unary fold does not work for an empty pack. We can use a binary fold instead,
    providing an initial value `init` either a right fold, with the initial value
    on the right
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一元折叠对空包不起作用。我们可以使用二元折叠代替，提供一个初始值`init`，要么是一个右折叠，初始值在右边
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'or a left fold, with the initial value on the left:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个左折叠，初始值在左边：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We could change the return statement to use a binary fold instead, providing
    an initial value of `0`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将返回语句更改为使用二元折叠，提供一个初始值为`0`：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We would then need to be able to add the values in the tail to `0`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要能够将尾部的值加到`0`上。
- en: 'Sticking with the unary fold, we can add other types supporting `operator+`
    as well; for example, some strings:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持使用一元折叠，我们还可以添加其他支持`operator+`的类型；例如，一些字符串：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Be aware that without using a concept to constrain the template, we will get
    a lot of compiler errors if the type does not have the appropriate `operator+`.
    Furthermore, we now have three instantiations of `add`, as we have three calls,
    one using one `int` and one with three `int`s:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有使用概念来约束模板，如果类型没有适当的`operator+`，我们将得到大量的编译器错误。此外，我们现在有三个`add`的实例化，因为我们有三个调用，一个使用一个`int`，一个使用三个`int`：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'and one using three strings for the parameter pack:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个使用三个字符串作为参数的例子：
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Fold expressions are powerful, and we have only scratched the surface. For further
    examples, see [https://www.foonathan.net/2020/05/fold-tricks/](https://www.foonathan.net/2020/05/fold-tricks/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式功能强大，我们只是触及了表面。对于更多示例，请参阅[https://www.foonathan.net/2020/05/fold-tricks/](https://www.foonathan.net/2020/05/fold-tricks/)。
- en: 9.3.2 Using a parameter pack to find frequencies
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 使用参数包查找频率
- en: Back to our game. Let’s write a function to find the frequencies of the digits
    for the payout so we can find which digits appear most often on the current line.
    We used an `std::map<int,` `size_t>` to find how often each last digit appeared
    in the triangle numbers in section 9.1.2\. We can do something similar now using
    another variadic template. Rather than calculating the last digits in the new
    function, we will write a general-purpose frequencies function. Our game will
    send in the last digits, like we did when we called our previous `calculate_payout`
    function in listing 9.9\.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的游戏。让我们编写一个函数来找出回报的数字频率，这样我们就可以找出当前行上哪个数字出现得最频繁。我们在9.1.2节中使用了`std::map<int,
    size_t>`来找出每个最后一位数字在三角数中出现的频率。现在我们可以使用另一个可变参数模板做类似的事情。在新函数中，我们不会计算最后一位数字，而是编写一个通用的频率函数。我们的游戏将发送最后一位数字，就像我们在列表9.9中调用之前的`calculate_payout`函数时做的那样。
- en: 'We want a function that takes a varying number of numbers. We will only call
    it with three numbers but can write a general-purpose function for practice. For
    a variadic template, we noted we put three dots *after* `typename` and then put
    the dots *before* the parameters in the function signature:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个可以接受可变数量数字的函数。我们只使用三个数字，但可以编写一个通用函数来练习。对于可变参数模板，我们注意到我们在`typename`之后放置三个点，然后在函数签名中的参数之前放置点：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can then call the function with as many numbers as we like, which means
    we could generalize our machine to have more than three reels if we so wished.
    Recall that we can also use `auto` rather than the template head:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用函数，喜欢用多少数字就用多少，这意味着如果我们愿意，可以将我们的机器推广到拥有超过三个滚筒。回想一下，我们也可以使用`auto`而不是模板头：
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Before we implement the function, we should ensure the numbers are actually
    numbers, using a concept. We didn’t do that with `add`, so we could concentrate
    on the dots but noted we might get a lot of compiler errors without a concept.
    We are making a tally, so we want an integer or something convertible to an integer
    to tally, and `std::convertible_to<int>` does what we want. We add the requirement
    before `auto` as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现函数之前，我们应该确保这些数字实际上是数字，使用一个概念。我们在`add`中没有这样做，因此我们可以专注于点，但注意如果没有概念，我们可能会得到很多编译器错误。我们正在做一个计数，所以我们需要一个整数或可以转换为整数的某种东西来计数，`std::convertible_to<int>`就做到了我们想要的事情。我们在`auto`之前添加要求如下：
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we can implement the function. We have some numbers, or at least elements
    convertible to `int`s using `static_cast<int>`. We used operators with dots to
    unpack the parameters in the last section. We can also unpack parameters into
    an initializer list:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现这个函数。我们有一些数字，或者至少是可以通过`static_cast<int>`转换为`int`的元素。我们在上一节中使用了带点的运算符来解包参数。我们还可以将参数解包到一个初始化列表中：
- en: '[PRE70]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can then use the initializer list in a range based `for` loop to populate
    a `map` of frequencies.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用初始化列表在基于范围的`for`循环中填充频率的`map`。
- en: Listing 9.12 Finding frequencies using a parameter pack
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 使用参数包查找频率
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ Unpacks parameters into an initializer list
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将参数解包到初始化列表中
- en: ❷ Keeps tally
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 保持计数
- en: 'We can use the frequencies function for different numbers of numbers:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用频率函数处理不同数量的数字：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We obtain a map showing how often each number occurs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个显示每个数字出现频率的映射。
- en: 'Our slot machine will send in the left, middle, and right digits, like we did
    when we calculated the payout in listing 9.9\. We will write a new function to
    calculate a fairer payout, which takes the final digit from each reel as before:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老虎机将发送左、中、右的数字，就像我们在列表9.9中计算回报时做的那样。我们将编写一个新的函数来计算更公平的回报，该函数将像之前一样从每个滚筒中获取最后一位数字：
- en: '[PRE73]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can then count how often each digit appears in the current row
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以计算当前行中每个数字出现的频率
- en: '[PRE74]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: and use these counts to decide a payout. We can give a fairer payout based on
    the likelihood of each outcome rather than our previous approach of `2` for three
    matches and `1` for two matches.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用这些计数来决定回报。我们可以根据每个结果的可能性给出一个更公平的回报，而不是我们之前的方法，即三个匹配得`2`分，两个匹配得`1`分。
- en: 9.3.3 A fairer payout
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 更公平的回报
- en: 'We have three reels, so a final digit appears one, two, or three times. If
    we find the digit with the greatest frequency, we can use that to decide a payout.
    The algorithm header defines `std::max_element`, which finds the greatest element
    in a range using `operator<` for ordering by default. Our frequencies contain
    key-value pairs, and we want the element with the largest value. The key is the
    first element of the pair, and the value is the second, so we use the second element
    for comparison in a lambda:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个滚筒，所以最终数字出现一次、两次或三次。如果我们找到出现频率最高的数字，我们可以用它来决定支付。算法头定义了`std::max_element`，它使用默认的`operator<`按顺序在一个范围内找到最大的元素。我们的频率包含键值对，我们想要具有最大值的元素。键是这对的第一个元素，值是第二个，因此我们在lambda中用第二个元素进行比较：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Provided the counter is not empty, we get an iterator to an element and award
    an appropriate payout. We will now charge 2 credits per go. As we noted, `3`s
    and `8`s are less likely. The jackpot is three matching final digits of `3`s or
    `8`s, so we award this with 250 credits. Three other matching final digits get
    15\. Two `3`s or `8`s can have 10 credits, and any other matching pair gets 1
    credit. If the final digit is a `3` or `8`, we can use an `std::array` with the
    right payout at the index corresponding to the frequency:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 假设计数器不为空，我们得到一个元素的迭代器，并颁发适当的支付。我们现在将每次旋转的费用定为2分。正如我们注意到的，`3`和`8`出现的可能性较小。奖金是三个匹配的`3`或`8`的最终数字，因此我们用250分来颁发这个奖金。三个其他匹配的最终数字得到15分。两个`3`或`8`可以得到10分，任何其他匹配的对得到1分。如果最终数字是`3`或`8`，我们可以使用一个`std::array`，在索引对应频率的位置上有正确的支付：
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Zero or one gives `0`, while two gives a credit of 10, and three gives the jackpot
    of 250\. Similarly, for the more likely digits, we can use
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 零或一个给出`0`，而两个给出10分的信用，三个给出250分的奖金。同样，对于更可能的数字，我们可以使用
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: to give a payout of 1 or 15.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得1或15的支付。
- en: Listing 9.13 A fairer payout
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 更公平的支付
- en: '[PRE78]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We now have a much better payout function and have learned even more C++. If
    we add holds and nudges to the spins, we will have an even better game and can
    use another new C++ feature.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个更好的支付函数，并且已经学习了更多的C++。如果我们给旋转的磁铁添加保持和推动，我们将有一个更好的游戏，并且可以使用另一个新的C++特性。
- en: 9.3.4 Allowing holds, nudges, or spins
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 允许保持、推动或旋转
- en: Our initial game only offered spins. We will do one of two things in our improved
    game. If a player wins, they can either quit or let the reels spin on the next
    turn. Otherwise, they have three options per reel. In the output for the simple
    slot machine, the first spin gave
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的游戏只提供旋转。在我们的改进游戏中，我们将做两件事之一。如果玩家赢了，他们可以退出或让滚筒在下一轮旋转。否则，每个滚筒他们有三个选项。在简单老虎机的输出中，第一次旋转给出
- en: '[PRE79]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Had we been allowed to hold the `45`, spin the middle reel, and nudge the right
    reel to move `105` up, we would have two numbers ending in a `5`, so we would
    have won some credit. For example, we might end up with
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们被允许保持`45`，旋转中间的滚筒，并推动右侧的滚筒以将`105`向上移动，我们将有两个以`5`结尾的数字，因此我们将获得一些信用。例如，我们可能最终得到
- en: '[PRE80]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The middle reel spun, so it could be anything, but we were bound to have `45`
    on the left and `105` on the right, giving at least two last matching digits.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的滚筒旋转了，所以它可以是任何东西，但我们注定要在左边有`45`，在右边有`105`，至少有两个匹配的最后数字。
- en: We can use empty `struct`s to indicate how to move each reel and hold one of
    these in a `variant`. We have used a `variant` before, so some extra practice
    is useful. We include the `variant` header and name our `variant` with the `using`
    directive. It can be one of three empty structs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用空的`struct`来指示如何移动每个滚筒，并在`variant`中保持一个这样的实例。我们之前已经使用过`variant`，所以一些额外的练习是有用的。我们包含`variant`头文件，并使用`using`指令命名我们的`variant`。它可以是三个空`struct`之一。
- en: Listing 9.14 Allowing more options
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 允许更多选项
- en: '[PRE81]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If the player won last time, they can quit or press Enter to spin all three
    reels. We can indicate this with a `vector` of `options`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家上次赢了，他们可以退出或按Enter键旋转所有三个滚筒。我们可以用一个`options`的`vector`来表示这一点：
- en: '[PRE82]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can use `std::getline` like we did in the simple slot machine in listing
    9.10 to populate an `std::string`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`std::getline`，就像我们在列表9.10中的简单老虎机中做的那样，来填充一个`std::string`：
- en: '[PRE83]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If the response is Enter, we get an empty string, and the game should then spin
    all three reels. We can put the parsing in a function. An `optional` is a suitable
    return type. We can also mark the function as `constexpr`, allowing us to use
    it in a `static_assert`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应是Enter，我们得到一个空字符串，然后游戏应该旋转所有三个滚筒。我们可以将解析放入一个函数中。`optional`是一个合适的返回类型。我们还可以将函数标记为`constexpr`，允许我们在`static_assert`中使用它。
- en: Listing 9.15 Three spins for Enter
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 Enter的三个旋转
- en: '[PRE84]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ❶ Enter pressed, so three spins are returned
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按下了 Enter，因此返回三个旋转
- en: ❷ Something else pressed, so empty optional is returned
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按下了其他键，因此返回一个空的 `optional`
- en: We should check whether a player really wants to quit if they type something.
    We’ll ask, giving the opportunity to press Enter to continue playing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入了某些内容，我们应该检查他们是否真的想退出。我们将询问，并给他们按下 Enter 继续游戏的机会。
- en: Listing 9.16 Checking for Enter pressed
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 检查是否按下 Enter
- en: '[PRE85]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ❶ Three spins for enter
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Enter 按下时旋转三次
- en: ❷ Checks whether the player really wants to quit
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查玩家是否真的想退出
- en: If a player doesn’t win, they can hold, nudge, or spin each reel. We can get
    the response like we did before and check the characters one at a time to see
    what the player wants to do with each reel. We can use `'h'`, `'n'`, or `'s'`
    for hold, nudge, or spin, respectively. Pressing Enter can mean spin all three,
    like it does after a win. Anything else indicates the player wishes to stop. First,
    we want to map a character to one of our structs, so we use a `constexpr` function
    and return an `optional`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有赢，他们可以保持、轻推或旋转每个滚筒。我们可以得到之前那样的响应，并逐个检查字符，看看玩家想对每个滚筒做什么。我们可以用 `'h'`、`'n'`
    或 `'s'` 分别表示保持、轻推或旋转。按下 Enter 可以表示旋转所有三个滚筒，就像赢之后那样。其他任何操作都表示玩家希望停止。首先，我们想要将一个字符映射到我们的一种结构中，所以我们使用一个
    `constexpr` 函数并返回一个 `optional`。
- en: Listing 9.17 Mapping a character to an action
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.17 将字符映射到动作
- en: '[PRE86]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We decided to accept Enter for three spins to save the player a few key presses.
    We map each letter, putting the corresponding option in a `vector`. Again, we
    use `constexpr` and return an `optional`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定接受 Enter 以进行三次旋转，以节省玩家一些按键。我们将每个字母映射，将相应的选项放入一个 `vector` 中。同样，我们使用 `constexpr`
    并返回一个 `optional`。
- en: Listing 9.18 Checking for holds, nudges, or spins
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 检查保持、轻推或旋转
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We can now check for the player’s options if they didn’t win on the last go
    using our parsing function. If the input is invalid, either empty or too long,
    we’ll check to see if they want to quit.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在上一次尝试中没有赢，我们可以使用我们的解析函数来检查他们的选项。如果输入无效，即空或过长，我们将检查他们是否想退出。
- en: Listing 9.19 Checking for options
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 检查选项
- en: '[PRE88]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ❶ Parses the input
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解析输入
- en: ❷ Checks whether they want to quit
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查他们是否想退出
- en: 'In our original game in listing 9.10, we checked the response in the main game
    to see whether to spin or quit. This time, we will call the appropriate function,
    depending on whether the player won:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们原始的游戏列表 9.10 中，我们在主游戏中检查响应，以确定是旋转还是退出。这次，我们将根据玩家是否赢了来调用适当的函数：
- en: '[PRE89]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We now need to move the reels appropriately. Previously, we used `std::rotate`
    to spin all three reels. We now need to take the appropriate action based on the
    player’s choice. Using a `variant` for the `options` allows us to use another
    helpful C++ feature, which is a fortuitous choice.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要根据玩家的选择适当地移动滚筒。之前，我们使用了 `std::rotate` 来旋转所有三个滚筒。现在，我们需要根据玩家的选择采取适当的行动。使用
    `variant` 作为 `options` 允许我们使用另一个有用的 C++ 功能，即幸运的选择。
- en: 9.3.5 Spinning reels with std::visit and std::views::zip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 使用 std::visit 和 std::views::zip 旋转滚筒
- en: 'We used an `std::variant` in chapter 5 when we wanted to add jokers to our
    deck of cards, and we also used `std::holds_alternative` to detect a joker. We
    now have one of three possible types. The `variant` header includes a method called
    `std::visit` that lets us supply a callable that accepts each possible type in
    the variant (see [http://mng.bz/RmoK](http://mng.bz/RmoK)). We could build something
    ourselves using lots of `if`s and `else`s, based on `std::holds_alternative`,
    but it is easy to forget to add a branch for one of the types in the variant.
    Using `std::visit` instead means we get a compile error if we miss an alternative.
    The function applies a callable to one or more variants:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，当我们想要在我们的牌组中添加王牌时，我们使用了 `std::variant`，并且我们还使用了 `std::holds_alternative`
    来检测王牌。现在我们有了三种可能类型之一。`variant` 头文件包含一个名为 `std::visit` 的方法，它允许我们提供一个可调用对象，该对象接受变体中每个可能的类型（见
    [http://mng.bz/RmoK](http://mng.bz/RmoK)）。我们可以使用大量的 `if` 和 `else` 语句自己构建一些东西，基于
    `std::holds_alternative`，但很容易忘记为变体中的某个类型添加一个分支。使用 `std::visit` 而不是意味着如果我们遗漏了一个替代方案，我们会得到一个编译错误。该函数将一个可调用对象应用于一个或多个变体：
- en: '[PRE90]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The return value `R` can be `void`. The variants, `vars`, are one or more variants
    in a parameter pack. The visitor, `vis`, is any callable that can be invoked with
    the types from the variants. The callable could be a `struct`, with an overloaded
    `operator()` per type.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值 `R` 可以是 `void`。变体 `vars` 是参数包中的一个或多个变体。访问者 `vis` 是任何可以调用变体类型的可调用对象。可调用对象可以是一个
    `struct`，每个类型都有一个重载的 `operator()`。
- en: Listing 9.20 One way to provide callables for `std::visit`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 为 `std::visit` 提供可调用对象的一种方法
- en: '[PRE91]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Given a player’s option, `opt`, we could then call
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个玩家的选项 `opt`，我们然后可以调用
- en: '[PRE92]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: and the appropriate `operator()` would be invoked. This is cleaner than building
    one long function checking `std::holds_alternative`, and we get a compiler error
    if we forget the overload for a type.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 并且会调用适当的 `operator()`。这比构建一个长函数检查 `std::holds_alternative` 更干净，如果我们忘记了一个类型的重载，编译器会给出错误。
- en: We can also use lambdas in conjunction with another variadic template for more
    practice. Lambdas are callable and therefore have an `operator()`. By creating
    a class template deriving from a lambda, we can expose the `operator()` for that
    lambda with a `using` statement.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以结合另一个变长模板进行更多练习。Lambdas 是可调用的，因此有一个 `operator()`。通过创建一个从 lambda 派生的类模板，我们可以使用
    `using` 语句暴露该 lambda 的 `operator()`。
- en: Listing 9.21 Bring `operator()` into scope in a class
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.21 在类中将 operator() 引入作用域
- en: '[PRE93]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ❶ Derives from T and brings operator() into scope
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 T 派生并引入 operator() 到作用域
- en: In C++17 and versions of Clang before v17, we need to provide a *template deduction
    guide*, which tells the compiler how to deduce the template parameters. The guide
    shows how to interpret a set of constructor arguments into template parameters
    for a class, so for our type `T`, we want an `Overload(T)` to deduce `Overload<T>`.
    Thus, we write
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 和 v17 之前的 Clang 版本中，我们需要提供一个 *模板推导指南*，告诉编译器如何推导模板参数。指南显示了如何将一组构造函数参数解释为类的模板参数，因此对于我们的类型
    `T`，我们希望 `Overload(T)` 推导出 `Overload<T>`。因此，我们写下
- en: '[PRE94]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Since C++20, we no longer need the additional deduction guide. The `struct`
    allows us to create an `Overload` with a lambda and call the lambda. For example,
    we can add an `assert` to the `check_properties` function:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++20 以来，我们不再需要额外的推导指南。`struct` 允许我们使用 lambda 创建一个 `Overload` 并调用该 lambda。例如，我们可以在
    `check_properties` 函数中添加一个 `assert`：
- en: '[PRE95]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: By itself, an overload of a single type is not much use because we only have
    one function. It is simpler to use the lambda directly, but we can use a parameter
    pack to group several lambdas together. This will bring each lambda’s `operator()`
    into scope. Again, we may need a deduction guide, and as we noted earlier, we
    have to think about the ellipsis for a parameter pack in three places.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用单个类型的重载并没有太大用处，因为我们只有一个函数。直接使用 lambda 更简单，但我们可以使用参数包来将几个 lambda 组合在一起。这将每个
    lambda 的 `operator()` 引入作用域。再次提醒，我们可能需要推导指南，并且正如我们之前提到的，我们必须考虑参数包中的省略号，有三个地方需要考虑。
- en: Listing 9.22 The `Overload` pattern
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.22 `Overload` 模式
- en: '[PRE96]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: ❶ Dots in the template head
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模板头中的点
- en: ❷ Dots in the struct’s base
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 结构基中的点
- en: ❸ Unpacks the dots to use each operator()
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 解包点以使用每个 operator()
- en: ❹ Deduction guide for C++17 (and Clang before v17)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ C++17 的推导指南（以及 v17 之前的 Clang）
- en: We can then create a roll method that does the right thing for each reel, using
    the `Overload` from listing 9.22 with three lambdas. Hold does nothing, and nudge
    moves a reel one place. Spin, like before, spins by a random amount, provided
    by the function `random_fn`. Both nudge and spin need to capture the reel used
    by reference.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个滚方法，为每个滚筒执行正确的事情，使用列表 9.22 中的 `Overload` 和三个 lambda。保持（Hold）不做任何事情，微调（nudge）移动滚筒一个位置。旋转（Spin），就像之前一样，通过随机数量旋转，由
    `random_fn` 函数提供。微调和旋转都需要通过引用捕获使用的滚筒。
- en: Listing 9.23 A hold, nudge, or spin `Overload`
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.23 保持、微调或旋转 `Overload`
- en: '[PRE97]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now `std::visit` can use the appropriate function from `RollMethod.`
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `std::visit` 可以使用 `RollMethod` 中的适当函数。
- en: Listing 9.24 Moving the reels
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.24 移动滚筒
- en: '[PRE98]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can now move a specific reel using the player’s option. We have three reels,
    so we want to pair up a player’s choices with the reels. We have a `vector` of
    reels and another `vector` of `options`. We could use an index in a `for` loop,
    but we can use one last new feature, ranges’ zip view, instead. The `std::views::zip`
    was introduced in C++23, so some compilers don’t support it yet, but you can use
    the Range-v3 library instead (see [https://ericniebler.github.io/range-v3/](https://ericniebler.github.io/range-v3/))
    or a `for` loop:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用玩家的选项移动特定的滚筒。我们有三个滚筒，所以我们要将玩家的选择与滚筒配对。我们有一个滚筒的 `vector` 和另一个 `options`
    的 `vector`。我们可以在 `for` 循环中使用索引，但我们可以使用最后一个新特性，即 ranges 的 zip 视图。`std::views::zip`
    是在 C++23 中引入的，所以一些编译器可能还不支持它，但你可以使用 Range-v3 库代替（见 [https://ericniebler.github.io/range-v3/](https://ericniebler.github.io/range-v3/)）或使用
    `for` 循环：
- en: '[PRE99]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We met ranges’ view, `std::view`, when we first used ranges in chapter 2\. We
    used `drop_while` and `filter` to take a *view* of a single collection. After
    including the `ranges` header, we can `zip` up the two `vectors` using
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 2 章首次使用 ranges 时，我们遇到了 ranges 的视图，`std::view`。我们使用了 `drop_while` 和 `filter`
    来获取单个集合的视图。在包含 `ranges` 头文件后，我们可以使用以下方式将两个 `vector` 进行 `zip`：
- en: '[PRE100]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The zip view gives us tuples of items from each `vector`, without making copies.
    If we zip two containers and iterate, the tuple moves over both vectors, giving
    us an item from each vector. The vectors are not joined, but rather, the iterator
    moves over each input collection, as shown in figure 9.4.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 组合视图给我们每个 `vector` 中的项目元组，而不进行复制。如果我们对两个容器进行 `zip` 并迭代，元组会在两个向量之间移动，给我们每个向量中的一个项目。向量没有被连接，而是迭代器在如图
    9.4 所示的每个输入集合上移动。
- en: '![CH09_F04_Buontempo](../Images/CH09_F04_Buontempo.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F04_Buontempo](../Images/CH09_F04_Buontempo.png)'
- en: Figure 9.4 Iterating a zip view for two collections shows us a pair of items.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 迭代两个集合的 zip 视图显示了一对项目。
- en: 'We can zip up more than two collections if we want. Iterating the zipped view
    of reels and choices gives us a tuple of two references, which we can use in a
    loop to move the reels. We can use structured bindings to name the two items in
    the tuple and move the reel appropriately, using the `move_reel` method from listing
    9.24:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，可以 `zip` 超过两个集合。迭代滚筒和选择的组合视图会给我们一个包含两个引用的元组，我们可以在循环中使用它来移动滚筒。我们可以使用结构化绑定来命名元组中的两个项目，并使用列表
    9.24 中的 `move_reel` 方法适当地移动滚筒：
- en: '[PRE101]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Pulling this all together gives our final game.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些结合起来，就得到了我们的最终游戏。
- en: Listing 9.25 An improved triangle number machine
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.25 改进的三角形数字机
- en: '[PRE102]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: ❶ Setup as before
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述设置
- en: ❷ Shows reels as before
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如前所述显示滚筒
- en: ❸ An improved payout
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 改进的回报
- en: ❹ Charges more for this game
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为这款游戏收取更多费用
- en: ❺ Enter for a win; otherwise hold, nudge, or spin
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 参与赢取；否则保持、轻推或旋转
- en: ❻ Moves reels appropriately
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 适当地移动滚筒
- en: 'We call our new game from `main` and have a greater chance of gaining some
    credit. An example game may start with no matching rows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `main` 中调用我们的新游戏，有更大的机会获得一些积分。一个示例游戏可能开始时没有匹配的行：
- en: '[PRE103]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If we hold the `105`, spin the middle reel, and nudge the last reel to move
    up the `45`, we will have at least two matching last digits, so we win at least
    1 credit, although we have to pay 2 for the turn:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持 `105`，旋转中间滚筒，并轻推最后一个滚筒以将 `45` 向上移动，我们至少会有两个匹配的最后一位数字，所以我们可以至少赢得 1 个积分，尽管我们必须为这一轮支付
    2 个积分：
- en: '[PRE104]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We then have to let all the reels spin because we just won something:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须让所有滚筒旋转，因为我们刚刚赢得了一些东西：
- en: '[PRE105]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Our credit ticks down, but again we can hold, spin, and nudge:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的积分减少，但我们可以保持、旋转和轻推：
- en: '[PRE106]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We have a better chance of winning, so the game is more engaging. We also learned
    even more C++.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有更大的赢面，所以游戏更有趣。我们还学习了更多的 C++。
- en: We haven’t covered every new feature in C++, and as the language continues to
    evolve, there will always be more to learn. Starting with a `vector` and finding
    some small games and projects gave us plenty of practice. We now are in a good
    place to keep our skills up to date. Use CppReference, and help others by adding
    missing examples you spot. Experiment with the Compiler Explorer and C++ Insights.
    Watch the ISOCpp website for recent news, articles, and podcasts. Keep learning
    and practicing, and above all, have fun!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖 C++ 中的每一个新特性，随着语言的不断发展，总有更多东西需要学习。从使用 `vector` 开始，并找到一些小游戏和项目，让我们有了大量的实践机会。现在，我们处于一个很好的位置来保持我们的技能更新。使用
    CppReference，并通过添加你发现的缺失示例来帮助他人。尝试使用 Compiler Explorer 和 C++ Insights。关注 ISOCpp
    网站以获取最新的新闻、文章和播客。持续学习和实践，最重要的是，享受乐趣！
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Use `std::iota` to fill a container with sequentially increasing values, starting
    with a chosen value.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::iota` 以递增的方式填充容器，从选定的值开始。
- en: Many algorithms support an execution policy, giving a straightforward way to
    request parallelization. This is a request, which may not be possible, and in
    such cases, execution falls back to a sequential policy.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多算法支持执行策略，这为我们请求并行化提供了一个简单的方法。这是一个请求，可能无法实现，在这种情况下，执行将回退到顺序策略。
- en: We can flag a lambda as `mutable` to allow it to modify the objects captured
    by `copy` and to call their non-const member functions.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将 lambda 标记为 `mutable`，以允许它修改由 `copy` 捕获的对象，并调用它们的非 const 成员函数。
- en: Using a concept instead of the raw typenames in a template means we are likely
    to get clearer diagnostics if we don’t provide a suitable type when we use the
    template.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用概念而不是模板中的原始类型名称意味着，如果我们使用模板时没有提供合适的类型，我们可能会得到更清晰的诊断信息。
- en: We can use `constexpr` for almost anything, including `std::vector` and `std::string`,
    since C++20\. Evaluation might happen at compile time but does not need to. We
    can test `constexpr` code with a `static_assert`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从C++20开始，我们可以几乎使用`constexpr`来处理任何事情，包括`std::vector`和`std::string`。评估可能发生在编译时，但并不需要。我们可以使用`static_assert`来测试`constexpr`代码。
- en: A variadic template is a template with at least one parameter pack, indicated
    by an ellipsis.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数模板是一个至少有一个参数包的模板，由省略号表示。
- en: We unpack parameter packs using ellipsis again. We used `(...` `+` `tail)` in
    listing 9.11 to unpack the tail, and we can also put a parameter pack into an
    initializer list, which we did in listing 9.12 using `{` `static_cast<int>(numbers)...`
    `}`.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们再次使用省略号来解包参数包。在列表9.11中，我们使用了`(...` `+` `tail)`来解包尾部，我们也可以将一个参数包放入初始化列表中，就像我们在列表9.12中使用`{`
    `static_cast<int>(numbers)...` `}`所做的那样。
- en: We can use `std::visit` to call a function for an `std::variant`, which ensures
    we have an appropriate overload for any possible type held.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`std::visit`来为一个`std::variant`调用一个函数，这确保了我们为任何可能持有的类型都有一个合适的重载。
- en: One way to employ `std::visit` is the `Overload` pattern, which uses a parameter
    pack to bring `operator()` into scope, allowing us to package up lambdas for each
    type in an `std::variant`.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::visit`的一种方法是`Overload`模式，它使用参数包将`operator()`引入作用域，允许我们将每个类型的lambda打包到一个`std::variant`中。
- en: Finally, we used `std::views::zip` from the `ranges` library to pair up two
    collections. We can zip more than two collections and can then iterate over the
    tuple of elements in the view.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用了来自`ranges`库的`std::views::zip`来配对两个集合。我们可以配对超过两个集合，然后可以遍历视图中的元素元组。
- en: Keep learning and practicing, and above all, have fun!
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续学习和实践，最重要的是，享受这个过程！
