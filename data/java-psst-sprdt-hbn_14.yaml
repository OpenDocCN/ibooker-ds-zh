- en: 11 Transactions and concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 事务和并发
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining database and system transaction essentials
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库和系统事务基础
- en: Controlling concurrent access with Hibernate and JPA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hibernate和JPA控制并发访问
- en: Using non-transactional data access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非事务性数据访问
- en: Managing transactions with Spring and Spring Data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring和Spring Data管理事务
- en: 'In this chapter, we’ll finally talk about transactions: how we create and control
    concurrent units of work in an application. A *unit of work* is an atomic group
    of operations, and transactions allow us to set unit of work boundaries and help
    us isolate one unit of work from another. In a multiuser application, we may also
    be processing these units of work concurrently.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们最终将讨论事务：如何在应用程序中创建和控制并发作业单元。一个**作业单元**是一组原子的操作，事务允许我们设置作业单元的边界，并帮助我们隔离一个作业单元与另一个作业单元。在多用户应用程序中，我们可能也会并发地处理这些作业单元。
- en: 'To handle concurrency, we’ll first focus on units of work at the lowest level:
    database and system transactions. You’ll learn the APIs for transaction demarcation
    and how to define units of work in Java code. We’ll demonstrate how to preserve
    isolation and control concurrent access with pessimistic and optimistic strategies.
    The overall architecture of the system affects the scope of a transaction; a bad
    architecture may lead to fragile transactions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理并发，我们首先将关注最低级别的作业单元：数据库和系统事务。你将学习事务界定和如何在Java代码中定义作业单元的API。我们将演示如何使用悲观和乐观策略来保持隔离和控制并发访问。系统的整体架构影响事务的范围；糟糕的架构可能导致脆弱的事务。
- en: Then we’ll analyze some special cases and JPA features, based on accessing the
    database without explicit transactions. Finally we’ll demonstrate how to work
    with transactions with Spring and Spring Data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将基于不使用显式事务访问数据库分析一些特殊情况以及JPA功能。最后，我们将演示如何使用Spring和Spring Data处理事务。
- en: Let’s start with some background information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些背景信息开始。
- en: Major new features in JPA 2
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2 中的主要新功能
- en: 'There are new lock modes and exceptions for pessimistic locking:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于悲观锁定，有新的锁定模式和异常：
- en: You can set a lock mode, pessimistic or optimistic, on a `Query`.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在`Query`上设置锁定模式，悲观或乐观。
- en: You can set a lock mode when calling `EntityManager#find()`, `refresh()`, or
    `lock()`. A lock timeout hint for pessimistic lock modes is also standardized.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在调用`EntityManager#find()`、`refresh()`或`lock()`时设置锁定模式。对于悲观锁定模式，也标准化了锁定超时提示。
- en: When the new `QueryTimeoutException` or `LockTimeoutException` is thrown, the
    transaction doesn’t have to be rolled back.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出新的`QueryTimeoutException`或`LockTimeoutException`时，事务不需要回滚。
- en: The persistence context can now be in an *unsynchronized* mode with disabled
    automatic flushing. This allows us to queue modifications until we join a transaction
    and to decouple the `EntityManager` usage from transactions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文现在可以处于一个**未同步**模式，并且禁用了自动刷新。这允许我们将修改排队，直到我们加入一个事务，并将`EntityManager`的使用与事务解耦。
- en: 11.1 Transaction essentials
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 事务基础
- en: 'Application functionality requires that several things be done in one go. For
    example, when an auction finishes, the CaveatEmptor application must perform three
    different tasks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用功能要求一次性完成几件事情。例如，当拍卖结束时，CaveatEmptor应用程序必须执行三个不同的任务：
- en: Find the winning bid (highest amount) for the auction item.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到拍卖物品的最高出价（最高金额）。
- en: Charge the seller of the item the cost of the auction.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向物品的卖家收取拍卖费用。
- en: Notify the seller and successful bidder.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知卖家和成功的竞标者。
- en: What happens if we can’t bill the auction costs because of a failure in the
    external credit card system? The business requirements may state that either all
    listed actions must succeed or none must succeed. If so, we call these steps collectively
    a *transaction* or *unit of work*. If only a single step fails, the entire unit
    of work must fail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于外部信用卡系统故障而无法收取拍卖费用，会发生什么？业务需求可能声明所有列出的操作必须成功，或者没有任何操作必须成功。如果是这样，我们将这些步骤统称为一个**事务**或**作业单元**。如果只有单个步骤失败，整个作业单元必须失败。
- en: 11.1.1 ACID attributes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 ACID属性
- en: '*ACID* stands for *atomicity, consistency, isolation, durability*. *Atomicity*
    is the notion that all operations in a transaction execute as an atomic unit.
    Furthermore, transactions allow multiple users to work concurrently with the same
    data without compromising the *consistency* of the data (consistent with database
    integrity rules). A particular transaction should not be visible to other concurrently
    running transactions; they should run in *isolation*. Changes made in a transaction
    should be *durable*, even if the system fails after the transaction has been completed
    successfully.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*ACID*代表*原子性、一致性、隔离性、持久性*。*原子性*是指事务中的所有操作作为一个原子单元执行。此外，事务允许多个用户同时使用相同的数据，而不会损害数据的*一致性*（与数据库完整性规则一致）。特定的事务不应对其他并发运行的事务可见；它们应在*隔离*下运行。事务中做出的更改应该是*持久*的，即使系统在事务成功完成后失败。'
- en: In addition, we want the *correctness* of a transaction. For example, the business
    rules dictate that the application charges the seller once, not twice. This is
    a reasonable assumption, but we may not be able to express it with database constraints.
    Hence, the correctness of a transaction is the responsibility of the application,
    whereas consistency is the responsibility of the database. Together, these transaction
    attributes define the *ACID* criteria.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望事务的*正确性*。例如，业务规则规定应用程序只向卖家收费一次，而不是两次。这是一个合理的假设，但我们可能无法用数据库约束来表示它。因此，事务的正确性是应用程序的责任，而一致性是数据库的责任。这些事务属性共同定义了*ACID*标准。
- en: 11.1.2 Database and system transactions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 数据库和系统事务
- en: 'We’ve also mentioned *system* and *database* transactions. Consider the last
    example again: during the unit of work ending an auction, we might mark the winning
    bid in a database system. Then, in the same unit of work, we talk to an external
    system to bill the seller’s credit card. This is a transaction spanning several
    systems, with coordinated subordinate transactions on possibly several resources,
    such as a database connection and an external billing processor. This chapter
    focuses on transactions spanning one system and one database.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了*系统*和*数据库*事务。再次考虑最后一个例子：在结束拍卖的工作单元中，我们可能在数据库系统中标记出价。然后，在同一个工作单元中，我们与外部系统通信以向卖家的信用卡收费。这是一个跨越几个系统的交易，涉及在可能多个资源上的协调从属事务，例如数据库连接和外部计费处理器。本章重点介绍跨越一个系统和一个数据库的事务。
- en: Database transactions have to be short because open transactions consume database
    resources and potentially prevent concurrent access due to exclusive locks on
    data. A single database transaction usually involves only a single batch of database
    operations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库事务必须简短，因为打开的事务消耗数据库资源，并可能由于对数据的排他性锁定而阻止并发访问。单个数据库事务通常只涉及单个数据库操作批次。
- en: To execute all of the database operations inside a system transaction, we have
    to set the boundaries of that unit of work. We must start the transaction and,
    at some point, commit the changes. If an error occurs (either while executing
    database operations or when committing the transaction), we have to roll back
    the changes to leave the data in a consistent state. This process defines a *transaction
    demarcation* and, depending on the technique we use, involves manually defining
    transaction boundaries in the code. In general, transaction boundaries that begin
    and end a transaction can be set either programmatically in the application code
    or declaratively. We’ll demonstrate both ways, focusing on declarative transactions
    while working with Spring and Spring Data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要在系统事务中执行所有数据库操作，我们必须设置这个工作单元的边界。我们必须开始事务，并在某个时刻提交更改。如果在执行数据库操作或提交事务时发生错误，我们必须回滚更改以保持数据的一致性。这个过程定义了*事务边界*，并且根据我们使用的技巧，涉及在代码中手动定义事务边界。通常，开始和结束事务的事务边界可以设置为在应用程序代码中程序化或声明化。我们将演示这两种方法，在处理Spring和Spring
    Data时，我们将重点关注声明化事务。
- en: Note All examples in this chapter work in any Java SE environment, without a
    special runtime container. Hence, from now on you’ll see programmatic transaction
    demarcation code until we move on to specific Spring application examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中的所有示例都在任何Java SE环境中工作，无需特殊的运行时容器。因此，从现在起，您将看到程序化事务边界代码，直到我们转向特定的Spring应用程序示例。
- en: 'Next we’ll focus on the most complex aspect of ACID properties: how you can
    *isolate* concurrently running units of work from each other.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注ACID属性中最复杂的一个方面：如何将并发运行的作业单位彼此隔离。
- en: 11.2 Controlling concurrent access
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 控制并发访问
- en: Databases (and other transactional systems) attempt to ensure transaction *isolation*,
    meaning that, from the point of view of each concurrent transaction, it appears
    that no other transactions are in progress. Traditionally, database systems have
    implemented isolation with locking. A transaction can place a lock on a particular
    item of data in the database, temporarily preventing read and/or write access
    to that item by other transactions. Some modern database engines implement transaction
    isolation with multi-version concurrency control (MVCC), which vendors generally
    consider more scalable. We’ll analyze isolation assuming a locking model, but
    most of our observations are also applicable to MVCC.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库（以及其他事务性系统）试图确保事务**隔离性**，这意味着从每个并发事务的角度来看，似乎没有其他事务正在进行。传统上，数据库系统通过锁定来实现隔离。一个事务可以在数据库中的特定数据项上放置一个锁，暂时阻止其他事务对该项的读取和/或写入访问。一些现代数据库引擎使用多版本并发控制（MVCC）来实现事务隔离，供应商通常认为这更具有可伸缩性。我们将基于锁定模型分析隔离，但我们的大多数观察结果也适用于MVCC。
- en: How databases implement concurrency control is of the utmost importance in the
    Java Persistence application. Applications may inherit the isolation guarantees
    provided by the database management system, but frameworks may come on top of
    them and allow you to start, commit, and roll back transactions in a resource-agnostic
    way. If you consider the many years of experience that database vendors have with
    implementing concurrency control, you’ll see the advantage of this approach. Additionally,
    some features in Java Persistence can improve the isolation guarantee beyond what
    the database provides, either because you explicitly use the features or by design.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库如何实现并发控制对于Java持久性应用至关重要。应用程序可能继承数据库管理系统提供的隔离保证，但框架可能在这些之上，允许你以资源无关的方式启动、提交和回滚事务。如果你考虑到数据库供应商在实现并发控制方面多年的经验，你会看到这种方法的优点。此外，Java持久性中的某些特性可以提高隔离保证，超过数据库提供的保证，无论是你明确使用这些特性还是由于设计。
- en: 'We’ll discuss concurrency control in several steps. First we’ll explore the
    lowest layer: the transaction isolation guarantees provided by the database. After
    that, you’ll see the Java Persistence features for pessimistic and optimistic
    concurrency control at the application level, and other isolation guarantees that
    Hibernate can provide.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分几个步骤讨论并发控制。首先，我们将探索最底层：数据库提供的交易隔离保证。之后，你将看到Java持久性在应用层面的悲观和乐观并发控制特性，以及Hibernate可以提供的其他隔离保证。
- en: 11.2.1 Understanding database-level concurrency
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 理解数据库级别的并发
- en: When we talk about isolation, you can assume that two transactions are either
    isolated or not. When we talk about database transactions, complete isolation
    comes at a high price. You can’t stop the world in order to access data exclusively
    in a multiuser online transaction processing (OLTP) system. Therefore, several
    isolation levels are available, which, naturally, weaken full isolation but increase
    the performance and scalability of the system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论隔离时，你可以假设两个事务要么是隔离的，要么不是。当我们谈论数据库事务时，完全隔离的代价很高。你无法停止整个世界来专门访问多用户在线事务处理（OLTP）系统中的数据。因此，有几种隔离级别可供选择，这些级别自然地削弱了完全隔离，但增加了系统的性能和可伸缩性。
- en: Transaction isolation problems
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事务隔离问题
- en: First, let’s examine several problems that may occur when you weaken full transaction
    isolation. The ANSI SQL standard defines the standard transaction isolation levels
    in terms of which of these phenomena are permissible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查在削弱完全事务隔离时可能出现的几个问题。ANSI SQL标准根据哪些现象是可允许的来定义标准的事务隔离级别。
- en: A *lost update* occurs when two concurrent transactions simultaneously update
    the same information in a database. The first transaction reads a value. The second
    transaction starts shortly after and reads the same value. The first transaction
    changes and writes the updated value, and the second transaction overwrites that
    value with its own update. Thus, the update of the first transaction is lost,
    being overwritten by the second transaction. *The last commit wins*. This occurs
    in systems that don’t implement concurrency control, where concurrent transactions
    aren’t isolated. This is shown in figure 11.1\. The `buyNowPrice` field is updated
    from two transactions, but only one update occurred, the other update was lost.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个并发事务同时更新数据库中的相同信息时，会发生**丢失更新**。第一个事务读取一个值。第二个事务在第一个事务之后不久开始读取相同的值。第一个事务更改并写入更新后的值，而第二个事务用其自己的更新覆盖该值。因此，第一个事务的更新丢失了，被第二个事务覆盖。*最后提交的胜出*。这发生在未实现并发控制、并发事务未隔离的系统中的系统。这如图11.1所示。`buyNowPrice`字段由两个事务更新，但只有一次更新发生，另一次更新丢失了。
- en: '![](../../OEBPS/Images/CH11_F01_Tudose2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1](../../OEBPS/Images/CH11_F01_Tudose2.png)'
- en: 'Figure 11.1 Lost update: Two transactions update the same data without isolation.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 丢失更新：两个事务在未隔离的情况下更新相同的数据。
- en: A *dirty read* occurs if transaction 2 reads changes made by transaction 1,
    and it hasn’t yet been committed. This is dangerous because the changes made by
    transaction 1 may later be rolled back, and invalid data will have been read by
    transaction 2\. This is illustrated in figure 11.2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务2读取了事务1所做的更改，而这些更改尚未提交，则发生**脏读**。这是危险的，因为事务1所做的更改可能会稍后回滚，而事务2将读取无效的数据。这如图11.2所示。
- en: '![](../../OEBPS/Images/CH11_F02_Tudose2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2](../../OEBPS/Images/CH11_F02_Tudose2.png)'
- en: 'Figure 11.2 Dirty read: Transaction 2 reads uncommitted data from Transaction
    1.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 脏读：事务2从事务1读取未提交的数据。
- en: An *unrepeatable read* occurs if a transaction reads a data item twice and reads
    different states each time. For example, another transaction may have written
    to the data item and committed between the two reads, as shown in figure 11.3.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个事务在两次读取数据项时读取到不同的状态，则发生**不可重复读**。例如，另一个事务可能在两次读取之间向数据项写入并提交，如图11.3所示。
- en: '![](../../OEBPS/Images/CH11_F03_Tudose2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3](../../OEBPS/Images/CH11_F03_Tudose2.png)'
- en: 'Figure 11.3 Unrepeatable read: The highest bid changed while Transaction 1
    was in execution.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 不可重复读：在事务1执行过程中，最高出价发生了变化。
- en: A *phantom read* is said to occur when a transaction executes a query twice,
    and the second result includes data that wasn’t visible in the first result because
    something was added, or it includes less data because something was deleted. This
    need not necessarily refer to the exact same query. Another transaction inserting
    or deleting data between the executions of the two queries causes this situation,
    as shown in figure 11.4.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个事务执行两次查询，第二次查询的结果包括第一次查询中不可见的数据（因为添加了某些内容），或者包含更少的数据（因为删除了某些内容）时，就称发生了**幻读**。这不必一定是完全相同的查询。另一个事务在两次查询执行之间插入或删除数据会导致这种情况，如图11.4所示。
- en: '![](../../OEBPS/Images/CH11_F04_Tudose2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4](../../OEBPS/Images/CH11_F04_Tudose2.png)'
- en: 'Figure 11.4 Phantom read: Transaction 1 reads new data in the second query.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 幻读：事务1在第二次查询中读取了新数据。
- en: Now that you understand all the bad things that can occur, we can define the
    transaction isolation levels and see what problems they prevent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你已经了解了可能发生的所有不良情况，我们可以定义事务隔离级别并查看它们可以防止哪些问题。
- en: ANSI isolation levels
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI隔离级别
- en: 'The standard isolation levels are defined by the ANSI SQL standard, but they
    aren’t specific to SQL databases. Spring defines exactly the same isolation levels,
    and we’ll use these levels to declare the desired transaction isolation. With
    increased levels of isolation come higher costs and serious degradation of performance
    and scalability:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的隔离级别由ANSI SQL标准定义，但它们并不特定于SQL数据库。Spring定义了完全相同的隔离级别，我们将使用这些级别来声明所需的交易隔离级别。随着隔离级别的提高，成本会更高，性能和可扩展性会严重下降：
- en: '*Read uncommitted isolation*—A system that does not permit lost updates operates
    in read uncommitted isolation. One transaction may not write to a row if another
    uncommitted transaction has already written to it. Any transaction may read any
    row, however. A DBMS may implement this isolation level with exclusive write locks.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未提交读隔离*—不允许丢失更新的系统在未提交读隔离下运行。如果一个未提交的事务已经写入了一行，则一个事务可能无法写入该行。然而，任何事务都可以读取任何行。DBMS可以使用独占写锁来实现此隔离级别。'
- en: '*Read committed isolation*—A system that permits unrepeatable reads and phantom
    reads but neither lost updates nor dirty reads implements read committed isolation.
    A DBMS may achieve this by using shared read locks and exclusive write locks.
    Read transactions don’t block other transactions from accessing a row, but an
    uncommitted write transaction blocks all other transactions from accessing the
    row.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重复读隔离*—在可重复读隔离模式下运行的系统不允许丢失更新、脏读或不可重复读。可能会发生幻读。读事务不会阻止其他事务访问行，但未提交的写事务会阻止所有其他事务访问该行。'
- en: '*Repeatable read isolation*—A system operating in repeatable read isolation
    mode does not permit lost updates, dirty reads, or unrepeatable reads. Phantom
    reads may occur. Read transactions block write transactions but do not block other
    read transactions, and write transactions block all other transactions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重复读隔离*—在可重复读隔离模式下运行的系统不允许丢失更新、脏读或不可重复读。可能会发生幻读。读事务会阻止写事务，但不会阻止其他读事务，而写事务会阻止所有其他事务。'
- en: '*Serializable isolation*—The strictest isolation, serializable, emulates serial
    execution as if transactions were executed one after another, rather than concurrently.
    A DBMS may not implement serializable isolation using only row-level locks. A
    DBMS must instead provide some other mechanism that prevents a newly inserted
    row from becoming visible to a transaction that has already executed a query that
    would return the row. A crude mechanism is exclusively locking the entire database
    table after a write so that no phantom reads can occur.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可串行化隔离*—这是最严格的隔离级别，可串行化，模拟串行执行，就像事务一个接一个地执行，而不是并发执行。数据库管理系统（DBMS）可能无法仅使用行级锁来实现可串行化隔离。相反，DBMS必须提供一些其他机制，以防止新插入的行对已执行查询并返回该行的交易可见。一种简单的机制是在写入后独占锁定整个数据库表，以防止发生幻读。'
- en: Table 11.1 summarizes the ANSI isolation levels and the problems that they address.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1总结了ANSI隔离级别及其解决的问题。
- en: Table 11.1 ANSI isolation levels and the problems that they address
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 ANSI隔离级别及其解决的问题
- en: '| Isolation level | Phantom read | Unrepeatable read | Dirty read | Lost update
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 隔离级别 | 幻读 | 不可重复读 | 脏读 | 丢失更新 |'
- en: '| `READ_UNCOMMITTED` | – | – | – | + |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `READ_UNCOMMITTED` | – | – | – | + |'
- en: '| `READ_COMMITTED` | – | – | + | + |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `READ_COMMITTED` | – | – | + | + |'
- en: '| `REPEATABLE_READ` | – | + | + | + |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `REPEATABLE_READ` | – | + | + | + |'
- en: '| `SERIALIZABLE` | + | + | + | + |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `SERIALIZABLE` | + | + | + | + |'
- en: How exactly a DBMS implements its locking system varies significantly; each
    vendor has a different strategy. You should study the documentation of your DBMS
    to find out more about its locking system, how locks are escalated (from row-level
    to pages to entire tables, for example), and what effect each isolation level
    has on the performance and scalability of the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DBMS如何实现其锁定系统各不相同；每个供应商都有不同的策略。你应该研究你的DBMS文档，以了解更多关于其锁定系统、锁如何升级（例如，从行级到页面到整个表）以及每个隔离级别对系统性能和可扩展性的影响。
- en: It’s nice to know how all these technical terms are defined, but how does that
    help us choose an isolation level for the application?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有这些技术术语的定义固然很好，但这对我们如何为应用程序选择隔离级别有何帮助？
- en: Choosing an isolation level
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择隔离级别
- en: Developers (ourselves included) are often unsure what transaction isolation
    level to use in a production application. Too high an isolation level harms the
    scalability of a highly concurrent application. Insufficient isolation may cause
    subtle, difficult-to-reproduce bugs that we won’t discover until the system is
    working under heavy load.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者（包括我们自己）在生产应用程序中经常不确定使用哪种事务隔离级别。过高的隔离级别会损害高度并发应用程序的可扩展性。隔离不足可能导致微妙且难以复现的bug，我们直到系统在高负载下运行时才会发现这些问题。
- en: Note that we’ll refer to *optimistic locking* (with versioning) in the following
    explanation, which is a concept analyzed later in this chapter. You may want to
    revisit this section when it’s time to pick an isolation level for your application.
    Choosing the correct isolation level is, after all, highly dependent on the particular
    scenario. The following discussion should be read as recommendations, not dictums
    carved in stone.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在以下解释中，我们将提到*乐观锁*（带有版本控制），这是一个在本章后面部分分析的概念。当需要为您的应用选择隔离级别时，您可能需要回顾这一部分。毕竟，选择正确的隔离级别高度依赖于特定场景。以下讨论应被视为建议，而不是刻在石头上的教条。
- en: Hibernate tries hard to be as transparent as possible regarding the transactional
    semantics of the database. Nevertheless, persistence context caching and versioning
    affect these semantics. What is a sensible database isolation level to choose
    in a JPA application?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate尽力使数据库的事务语义尽可能透明。尽管如此，持久化上下文缓存和版本控制会影响这些语义。在JPA应用中选择一个合理的数据库隔离级别是什么？
- en: First, for almost all scenarios, eliminate the *read uncommitted* isolation
    level. It’s extremely dangerous to allow one transaction’s uncommitted changes
    to be used in a different transaction. The rollback or failure of one transaction
    will affect other concurrent transactions. The rollback of the first transaction
    could bring other transactions down with it, or perhaps even cause them to leave
    the database in an incorrect state (the seller of an auction item might be charged
    twice—consistent with database integrity rules but incorrect). It’s possible that
    changes made by a transaction that ends up being rolled back could be committed
    anyway because they could be read and then propagated by another successful transaction!
    You can use the *read uncommitted* isolation level for debugging purposes, to
    follow the execution of long insert queries, make some rough estimates of aggregate
    functions (such as `SUM``(*)` or `COUNT``(*)`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于几乎所有场景，都应该消除*读取未提交*的隔离级别。允许一个事务未提交的更改被另一个事务使用是非常危险的。一个事务的回滚或失败将影响其他并发事务。第一个事务的回滚可能会将其他事务一同拉下，或者甚至可能使它们处于不正确的数据库状态（例如，拍卖物品的卖家可能会被收取两次费用——这与数据库完整性规则一致，但却是错误的）。可能的情况是，最终被回滚的事务所做的更改无论如何都会被提交，因为它们可能被另一个成功的事务读取并传播！你可以为了调试目的使用*读取未提交*的隔离级别，以跟踪长插入查询的执行，对聚合函数（如`SUM(*)`或`COUNT(*)`）做一些粗略估计。
- en: Second, most applications don’t need *serializable* isolation. Phantom reads
    aren’t usually problematic, and this isolation level tends to scale poorly. Few
    existing applications use serializable isolation in production, but rather rely
    on selectively applied pessimistic locks that effectively force a serialized execution
    of operations in certain situations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，大多数应用不需要*可序列化*的隔离级别。幻读通常不会造成问题，而这个隔离级别往往扩展性不佳。现有的应用中很少在生产环境中使用可序列化隔离级别，而是依赖于在特定情况下有效强制序列化操作的选择性悲观锁。
- en: 'Next, let’s consider *repeatable read*. This level provides reproducibility
    for query result sets for the duration of a database transaction. This means we
    won’t read committed updates from the database if we query it several times, but
    phantom reads are still possible: new rows might appear, and rows we thought existed
    might disappear if another transaction committed changes concurrently. Although
    we may sometimes want repeatable reads, we typically don’t need them in every
    transaction.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑*可重复读*。这个级别在数据库事务持续期间为查询结果集提供可重复性。这意味着如果我们多次查询数据库，我们不会读取已提交的更新，但幻读仍然可能发生：新行可能会出现，而我们认为存在的行可能会消失，如果另一个事务同时提交更改。尽管我们有时可能想要可重复读，但我们通常不需要在每个事务中都使用它们。
- en: The JPA specification assumes that *read committed* is the default isolation
    level. This means we have to deal with unrepeatable reads and phantom reads.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JPA规范假定*读取提交*是默认的隔离级别。这意味着我们必须处理不可重复读和幻读。
- en: Let’s assume we’re enabling versioning of our domain model entities, which is
    something Hibernate can do for us automatically. The combination of the (mandatory)
    persistence context cache and versioning already gives us most of the nice features
    of repeatable read isolation. The persistence context cache ensures that the state
    of the entity instances loaded by one transaction is isolated from changes made
    by other transactions. If we retrieve the same entity instance twice in a unit
    of work, the second lookup will be resolved within the persistence context cache
    and not hit the database. Hence, our read *is* repeatable, and we won’t see conflicting
    committed data. (We can still get phantom reads, though, which are typically much
    easier to deal with.) Additionally, versioning switches to *first commit wins*.
    Hence, for almost all multiuser JPA applications, *read committed* isolation for
    all database transactions is acceptable with enabled entity versioning.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在启用对领域模型实体的版本控制，这是Hibernate可以为我们自动完成的。持久化上下文缓存和版本控制的组合已经为我们提供了可重复读隔离的大部分优点。持久化上下文缓存确保了一个事务加载的实体实例的状态与其他事务所做的更改相隔离。如果我们在一个工作单元中两次检索相同的实体实例，第二次查找将在持久化上下文缓存中解决，而不会击中数据库。因此，我们的读取是可重复的，我们不会看到冲突的已提交数据。（尽管如此，我们仍然可能遇到幻读，但这些通常更容易处理。）此外，版本控制切换到“先提交者胜出”。因此，对于几乎所有多用户JPA应用程序，启用实体版本控制后，所有数据库事务的“读取提交”隔离级别是可以接受的。
- en: Hibernate retains the isolation level of the database connection; it doesn’t
    change the level. Most products default to read committed isolation, though MySQL
    defaults to repeatable read. There are several ways we can change either the default
    transaction isolation level or the settings of the current transaction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate保留数据库连接的隔离级别；它不会改变级别。尽管大多数产品默认为读取提交隔离级别，但MySQL默认为可重复读。我们可以通过几种方式更改默认事务隔离级别或当前事务的设置。
- en: First, we can check whether the DBMS has a global transaction isolation level
    setting in its proprietary configuration. If the DBMS supports the standard SQL
    statement `SET SESSION CHARACTERISTICS`, we can execute it to set the transaction
    settings of all transactions started in this particular database *session* (which
    means a particular connection to the database, not a Hibernate `Session`). SQL
    also standardizes the `SET TRANSACTION` syntax, which sets the isolation level
    of the current transaction. Finally, the JDBC `Connection` API offers the `setTransactionIsolation()`
    method, which (according to its documentation) “attempts to change the transaction
    isolation level for this connection.” In a Hibernate/JPA application, we can obtain
    a JDBC `Connection` from the native `Session` API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以检查DBMS是否在其专有配置中有一个全局事务隔离级别设置。如果DBMS支持标准的SQL语句`SET SESSION CHARACTERISTICS`，我们可以执行它来设置在此特定数据库会话（这意味着数据库的特定连接，而不是Hibernate的`Session`）中启动的所有事务的设置。（这意味着数据库的特定连接，而不是Hibernate的`Session`）。SQL还标准化了`SET
    TRANSACTION`语法，该语法设置当前事务的隔离级别。最后，JDBC `Connection` API提供了`setTransactionIsolation()`方法，根据其文档，“尝试更改此连接的事务隔离级别。”在Hibernate/JPA应用程序中，我们可以从本地的`Session`
    API获取JDBC `Connection`。
- en: Frequently, the database connections are, by default, in read committed isolation
    levels. From time to time, a particular unit of work in the application may require
    a different, usually stricter, isolation level. Instead of changing the isolation
    level of the entire transaction, we should use the Jakarta Persistence API to
    obtain additional locks on the relevant data. This fine-grained locking is more
    scalable in a highly concurrent application. JPA offers optimistic version checking
    and database-level pessimistic locking.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据库连接默认处于读取提交隔离级别。有时，应用程序中的特定工作单元可能需要不同的、通常更严格的隔离级别。我们不应该改变整个事务的隔离级别，而应该使用Jakarta
    Persistence API在相关数据上获取额外的锁。这种细粒度锁定在高度并发的应用程序中更具可伸缩性。JPA提供了乐观版本检查和数据库级别的悲观锁定。
- en: 11.2.2 Optimistic concurrency control
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 乐观并发控制
- en: Handling concurrency in an optimistic way is appropriate when concurrent modifications
    are rare and it’s feasible to detect conflicts late in a unit of work. JPA offers
    automatic version checking as an optimistic conflict-detection procedure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当并发修改很少且在单元工作后期检测冲突可行时，以乐观方式处理并发是合适的。JPA提供自动版本检查作为乐观冲突检测过程。
- en: The previous sections have been somewhat dry; it’s time for some code. First
    we’ll enable versioning, because it’s turned off by default. Most multiuser applications,
    especially web applications, should rely on versioning for any concurrently modified
    `@Entity` instances, enabling the more user-friendly *first commit wins*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节可能有些枯燥；现在是时候看看一些代码了。首先，我们将启用版本控制，因为默认情况下它是关闭的。大多数多用户应用程序，尤其是Web应用程序，应该为任何并发修改的`@Entity`实例依赖版本控制，以实现更用户友好的*先提交者胜出*。
- en: After enabling automatic version checking, we’ll see how manual version checking
    works and when we have to use it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用自动版本检查后，我们将了解手动版本检查是如何工作的，以及何时需要使用它。
- en: Note To be able to execute the examples from the source code, you’ll first need
    to run the Ch11.sql script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要能够从源代码执行示例，您首先需要运行Ch11.sql脚本。
- en: Enabling versioning
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 启用版本控制
- en: We can enable versioning with an `@Version` annotation on a special additional
    property of the entity class, as demonstrated next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在实体类的特殊额外属性上使用`@Version`注解来启用版本控制，如下所示。
- en: Listing 11.1 Enabling versioning on a mapped entity
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 在映射实体上启用版本控制
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, each entity instance carries a numeric version. It’s mapped
    to an additional column of the `ITEM` database table; as usual, the column name
    defaults to the property name, here `VERSION`. The actual names of the property
    and column don’t matter—we could rename it if `VERSION` is a reserved keyword
    in the DBMS.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个实体实例都携带一个数字版本。它映射到`ITEM`数据库表的额外列中；通常，列名默认为属性名，这里为`VERSION`。属性和列的实际名称并不重要——如果我们认为`VERSION`是数据库管理系统中的保留关键字，我们可以将其重命名。
- en: 'We could add a `getVersion()` method to the class, but we shouldn’t have a
    setter method, and the application shouldn’t modify the value. Hibernate automatically
    changes the version value: it increments the version number whenever an `Item`
    instance has been found to be dirty during the flushing of the persistence context.
    The version is a simple counter without any useful semantic value beyond concurrency
    control. We can use an `int`, an `Integer`, a `short`, a `Short`, or a `Long`
    instead of a `long`; Hibernate wraps and starts from zero again if the version
    number reaches the limit of the data type.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类中添加一个`getVersion()`方法，但不应该有setter方法，并且应用程序不应该修改该值。Hibernate会自动更改版本值：在持久化上下文刷新期间，每当发现`Item`实例被标记为脏时，它就会增加版本号。版本是一个简单的计数器，除了并发控制之外没有其他有用的语义值。我们可以使用`int`、`Integer`、`short`、`Short`或`Long`来代替`long`；如果版本号达到数据类型的限制，Hibernate会将其包装并从零开始。
- en: After incrementing the version number of a detected dirty `Item` during flushing,
    Hibernate compares versions when executing the `UPDATE` and `DELETE` SQL statements.
    For example, assume that in a unit of work we load an `Item` and change its name,
    as follows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在刷新期间增加检测到的脏`Item`实例的版本号后，Hibernate在执行`UPDATE`和`DELETE` SQL语句时比较版本。例如，假设在一个工作单元中我们加载一个`Item`并更改其名称，如下所示。
- en: Listing 11.2 Hibernate incrementing and checking the version automatically
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 Hibernate自动增加和检查版本
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ Retrieving an entity instance by identifier loads the current version from
    the database with a `SELECT`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 通过标识符检索实体实例将使用`SELECT`从数据库中加载当前版本。
- en: Ⓑ The current version of the `Item` instance is `0`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `Item`实例的当前版本是`0`。
- en: Ⓒ When the persistence context is flushed, Hibernate detects the dirty `Item`
    instance and increments its version to `1`. SQL `UPDATE` now performs the version
    check, storing the new version in the database, but only if the database version
    is still `0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当持久化上下文刷新时，Hibernate会检测到脏的`Item`实例并增加其版本到`1`。SQL `UPDATE`现在执行版本检查，将新版本存储在数据库中，但只有当数据库版本仍然是`0`时。
- en: Pay attention to the SQL statements, in particular, the `UPDATE` and its `WHERE`
    clause. This update will be successful only if there *is* a row with `VERSION
    = 0` in the database. JDBC returns the number of updated rows to Hibernate; if
    that result is zero, it means the `ITEM` row is either gone or doesn’t have version
    `0` anymore. Hibernate detects this conflict during flushing, and a `javax.persistence.OptimisticLockException`
    is thrown.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到SQL语句，特别是`UPDATE`及其`WHERE`子句。此更新只有在数据库中存在`VERSION = 0`的行时才会成功。JDBC将更新的行数返回给Hibernate；如果该结果为零，则意味着`ITEM`行已不存在或不再具有版本`0`。Hibernate在刷新期间检测到这种冲突，并抛出`javax.persistence.OptimisticLockException`异常。
- en: 'Now imagine two users executing this unit of work at the same time, as shown
    previously in figure 11.1\. The first user to commit will update the name of the
    `Item` and flush the incremented version `1` to the database. The second user’s
    flush (and commit) will fail because their `UPDATE` statement can’t find the row
    in the database with version `0`. The database version is `1`. Hence, the *first
    commit wins*, and we can catch the `OptimisticLockException` and handle it specifically.
    For example, we could show the following message to the second user: “The data
    you have been working with has been modified by someone else. Please start your
    unit of work again with fresh data. Click the Restart button to proceed.”'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象有两个用户同时执行这个工作单元，如图11.1所示。第一个提交的用户将更新`Item`的名称并将增加的版本`1`刷新到数据库中。第二个用户的刷新（和提交）将失败，因为他们的`UPDATE`语句在数据库中找不到版本为`0`的行。数据库版本是`1`。因此，*第一个提交获胜*，我们可以捕获`OptimisticLockException`并专门处理它。例如，我们可以向第二个用户显示以下消息：“你正在处理的数据已被其他人修改。请使用新鲜数据重新开始你的工作单元。点击重启按钮继续。”
- en: What modifications trigger the increment of an entity’s version? Hibernate increments
    the version whenever an entity instance is dirty. This includes all dirty value-typed
    properties of the entity, no matter whether they’re single-valued (like a `String`
    or `int` property), embedded (like an `Address`), or collections. The exceptions
    are `@OneToMany` and `@ManyToMany` association collections that have been made
    read-only with `mappedBy`. Adding or removing elements in these collections doesn’t
    increment the version number of the owning entity instance. You should know that
    none of this is standardized in JPA—don’t rely on two JPA providers to implement
    the same rules when accessing a shared database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些修改会触发实体版本的递增？Hibernate在实体实例脏时递增版本。这包括实体所有脏的值类型属性，无论它们是单值（如`String`或`int`属性），嵌入的（如`Address`），还是集合。例外的是使用`mappedBy`标记为只读的`@OneToMany`和`@ManyToMany`关联集合。在这些集合中添加或删除元素不会增加拥有实体实例的版本号。你应该知道，JPA中没有任何标准化的内容——不要依赖于两个JPA提供者在访问共享数据库时实施相同的规则。
- en: If we don’t want to increment the version of the entity instance when a particular
    property’s value has changed, we can annotate the property with `@org.hibernate
    .annotations.OptimisticLock(excluded = true)`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望在特定属性的值发生变化时增加实体实例的版本，我们可以使用`@org.hibernate.annotations.OptimisticLock(excluded
    = true)`注解该属性。
- en: You may not like the additional `VERSION` column in the database schema. Alternatively,
    you may already have a “last updated” timestamp property on the entity class and
    a matching database column. Hibernate can check versions with timestamps instead
    of using the extra counter field.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不喜欢数据库模式中额外的`VERSION`列。或者，你已经在实体类上有一个“最后更新”的时间戳属性以及匹配的数据库列。Hibernate可以使用时间戳而不是额外的计数器字段来检查版本。
- en: Versioning with a shared database
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享数据库进行版本控制
- en: 'If several applications access the database, and they don’t all use Hibernate’s
    versioning algorithm, we’ll have concurrency problems. An easy solution is to
    use database-level triggers and stored procedures: an `INSTEAD OF` trigger can
    execute a stored procedure when any `UPDATE` is made; it runs instead of the update.
    In the procedure, we can check whether the application incremented the version
    of the row; if the version isn’t updated or the version column isn’t included
    in the update, we know the statement wasn’t sent by a Hibernate application. We
    can then increment the version in the procedure before applying the `UPDATE`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个应用程序访问数据库，并且它们并不都使用Hibernate的版本控制算法，我们将遇到并发问题。一个简单的解决方案是使用数据库级别的触发器和存储过程：一个`INSTEAD
    OF`触发器可以在任何`UPDATE`操作时执行一个存储过程；它将代替更新操作。在存储过程中，我们可以检查应用程序是否增加了行的版本；如果版本没有更新或者版本列没有被包含在更新中，我们知道这个语句不是由Hibernate应用程序发送的。然后我们可以在应用`UPDATE`之前在存储过程中增加版本。
- en: Versioning with timestamps
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间戳进行版本控制
- en: If the database schema already contains a timestamp column such as `LASTUPDATED`
    or `MODIFIED_ON`, we can map it for automatic version checking instead of using
    a numeric counter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库模式已经包含一个时间戳列，如`LASTUPDATED`或`MODIFIED_ON`，我们可以将其映射以进行自动版本检查，而不是使用额外的计数器字段。
- en: Listing 11.3 Enabling versioning with timestamps
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 启用时间戳版本控制
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example maps the `LASTUPDATED` column to a `java.time.LocalDateTime` property;
    a `Date` or `Calendar` type would also work with Hibernate. The JPA standard doesn’t
    define these types for version properties; JPA only considers `java.sql.Timestamp`
    portable. This is less attractive, because we’d have to import that JDBC class
    in the domain model. We should try to keep implementation details such as JDBC
    out of the domain model classes so they can be tested, instantiated, serialized,
    and deserialized in as many environments as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将`LASTUPDATED`列映射到`java.time.LocalDateTime`属性；`Date`或`Calendar`类型也可以与Hibernate一起使用。JPA标准没有为版本属性定义这些类型；JPA仅考虑`java.sql.Timestamp`是可移植的。这不太吸引人，因为我们不得不在域模型中导入那个JDBC类。我们应该尽量将像JDBC这样的实现细节从域模型类中排除，以便它们可以在尽可能多的环境中进行测试、实例化、序列化和反序列化。
- en: In theory, versioning with a timestamp is slightly less safe, because two concurrent
    transactions may both load and update the same `Item` in the same millisecond;
    this is exacerbated by the fact that a JVM usually doesn’t have millisecond accuracy
    (you should check your JVM and operating system documentation for the guaranteed
    precision). Furthermore, retrieving the current time from the JVM isn’t necessarily
    safe in a clustered environment, where the system time of nodes may not be synchronized,
    or time synchronization isn’t as accurate as you’d need for your transactional
    load.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，使用时间戳进行版本控制稍微不太安全，因为两个并发事务可能在同一毫秒内同时加载和更新相同的`Item`；这一点由于JVM通常没有毫秒级的精度（您应该检查您的JVM和操作系统文档以获取保证的精度）而加剧。此外，在集群环境中从JVM检索当前时间并不一定安全，因为节点的时间可能没有同步，或者时间同步的精度不如您所需的交易负载精度。
- en: You can switch to retrieving the current time from the database machine by placing
    an `@org.hibernate.annotations.Type(type="dbtimestamp")` annotation on the version
    property. Hibernate now asks the database for the current time before updating,
    which gives a single source of time for synchronization. Not all Hibernate SQL
    dialects support this, so check the source of the configured dialect. In addition,
    there is always the overhead of hitting the database for every increment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在版本属性上放置一个`@org.hibernate.annotations.Type(type="dbtimestamp")`注解来切换为从数据库机器检索当前时间。Hibernate现在在更新之前会向数据库请求当前时间，这为同步提供了一个单一的时间源。并非所有Hibernate
    SQL方言都支持此功能，因此请检查配置方言的来源。此外，每次增量都会产生访问数据库的开销。
- en: We recommend that new projects rely on versioning with a numeric counter, not
    timestamps. If you’re working with a legacy database schema or existing Java classes,
    it may be impossible to introduce a version or timestamp property and column.
    If that’s the case, Hibernate provides an alternative strategy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议新项目依赖数字计数器的版本控制，而不是时间戳。如果您正在使用遗留数据库模式或现有的Java类，可能无法引入版本或时间戳属性和列。如果是这种情况，Hibernate提供了一个替代策略。
- en: Versioning without version numbers or timestamps
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 无版本号或时间戳的版本控制
- en: If you don’t have version or timestamp columns, Hibernate can still perform
    automatic versioning. This alternative implementation of versioning checks the
    current database state against the unmodified values of persistent properties
    at the time Hibernate retrieved the entity instance (or the last time the persistence
    context was flushed).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有版本或时间戳列，Hibernate仍然可以执行自动版本控制。这种版本控制的替代实现将当前数据库状态与Hibernate检索实体实例（或持久化上下文最后刷新）时的持久属性未修改的值进行比较。
- en: 'You can enable this functionality with the proprietary Hibernate annotation
    `@org.hibernate.annotations.OptimisticLocking`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用专有的Hibernate注解`@org.hibernate.annotations.OptimisticLocking`来启用此功能：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For this strategy, you also have to enable dynamic SQL generation of `UPDATE`
    statements, using `@org.hibernate.annotations.DynamicUpdate`, as explained in
    section 5.3.2.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个策略，您还必须启用`UPDATE`语句的动态SQL生成，使用`@org.hibernate.annotations.DynamicUpdate`，如第5.3.2节所述。
- en: 'Hibernate now executes the following SQL to flush a modification of an `Item`
    instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate现在执行以下SQL来刷新一个`Item`实例的修改：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hibernate lists all columns and their last known values in the `WHERE` clause.
    If any concurrent transaction has modified any of these values or even deleted
    the row, this statement returns with zero updated rows. Hibernate then throws
    an exception at flush time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate在`WHERE`子句中列出所有列及其最后已知值。如果任何并发事务修改了这些值中的任何一个，或者甚至删除了该行，则此语句将返回零行更新。然后Hibernate在刷新时抛出异常。
- en: Alternatively, Hibernate includes only the modified properties in the restriction
    (only `NAME`, in this example) if you switch to `OptimisticLockType.DIRTY`. This
    means two units of work can modify the same `Item` concurrently, and Hibernate
    detects a conflict only if they both modify the same value-typed property (or
    a foreign key value). The `WHERE` clause of the last SQL excerpt would be reduced
    to `where ID = 123 and NAME = 'Old Name'`. Someone else could concurrently modify
    the price, and Hibernate wouldn’t detect any conflict. Only if the application
    modified the name concurrently would we get a `javax.persistence.OptimisticLockException`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你切换到`OptimisticLockType.DIRTY`，Hibernate只包括修改过的属性在限制条件中（在这个例子中是`NAME`）。这意味着两个工作单元可以并发修改同一个`Item`，而Hibernate只有在它们都修改了相同值类型的属性（或外键值）时才会检测到冲突。最后一条SQL摘录的`WHERE`子句将简化为`where
    ID = 123 and NAME = 'Old Name'`。其他人可以并发修改价格，Hibernate不会检测到任何冲突。只有当应用程序并发修改名称时，我们才会得到`javax.persistence.OptimisticLockException`。
- en: 'In most cases, checking only dirty properties isn’t a good strategy for business
    entities. It’s probably not OK to change the price of an item if the description
    changes! This strategy also doesn’t work with detached entities and merging: if
    we merge a detached entity into a new persistence context, the “old” values aren’t
    known. The detached entity instance will have to carry a version number or timestamp
    for optimistic concurrency control.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，仅检查脏属性并不是业务实体的好策略。如果描述发生变化，改变商品的价格可能是不合适的！这种策略也不适用于分离实体和合并：如果我们把分离的实体合并到一个新的持久化上下文中，我们不知道“旧”值。分离的实体实例将不得不携带一个版本号或时间戳以进行乐观并发控制。
- en: Automatic versioning in Java Persistence prevents lost updates when two concurrent
    transactions try to commit modifications on the same piece of data. Versioning
    can also help us obtain additional isolation guarantees manually when we need
    them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java持久性中的自动版本控制可以防止两个并发事务尝试对同一份数据提交修改时丢失更新。版本控制还可以在我们需要时帮助我们手动获得额外的隔离保证。
- en: Manual version checking
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 手动版本检查
- en: 'Here’s a scenario that requires repeatable database reads: imagine there are
    some categories in the auction system and that each `Item` is in a `Category`.
    This is a regular `@ManyToOne` mapping of an `Item#category` entity association.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要可重复数据库读取的场景：想象一下，拍卖系统中有一些类别，每个`Item`都位于一个`Category`中。这是`Item#category`实体关联的常规`@ManyToOne`映射。
- en: Let’s say you want to sum up all item prices in several categories. This requires
    a query for all items in each category, to add up the prices. The problem is,
    what happens if someone moves an `Item` from one `Category` to another `Category`
    while you’re still querying and iterating through all the categories and items?
    With read-committed isolation, the same `Item` might show up twice while your
    procedure runs!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要汇总几个类别中所有商品的价格。这需要查询每个类别中的所有商品以累加价格。问题是，如果你在查询和遍历所有类别和商品时有人将一个`Item`从一个`Category`移动到另一个`Category`，会发生什么？在有提交读隔离的情况下，同一个`Item`可能在你的程序运行期间出现两次！
- en: To make the “get items in each category” reads repeatable, JPA’s `Query` interface
    has a `setLockMode()` method. Look at the procedure in the following listing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要使“获取每个类别的商品”读取可重复，JPA的`Query`接口有一个`setLockMode()`方法。查看以下列表中的过程。
- en: Listing 11.4 Requesting a version check at flush time to ensure repeatable reads
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 在刷新时请求版本检查以确保可重复读取
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ For each `Category`, query all `Item` instances with an `OPTIMISTIC` lock
    mode. Hibernate now knows it has to check each `Item` at flush time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 对于每个`Category`，以`OPTIMISTIC`锁定模式查询所有`Item`实例。Hibernate现在知道它必须在刷新时检查每个`Item`。
- en: Ⓑ For each `Item` loaded earlier with the locking query, Hibernate executes
    a `SELECT` during flushing. It checks whether the database version of each `ITEM`
    row is still the same as when it was loaded. If any `ITEM` row has a different
    version or the row no longer exists, an `OptimisticLockException` is thrown.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 对于之前通过锁定查询加载的每个`Item`，Hibernate在刷新期间执行一个`SELECT`。它检查每个`ITEM`行的数据库版本是否仍然与加载时相同。如果任何`ITEM`行版本不同或行不再存在，将抛出`OptimisticLockException`。
- en: 'Don’t be confused by the *locking* terminology: The JPA specification leaves
    open how exactly each `LockModeType` is implemented. For `OPTIMISTIC`, Hibernate
    performs version checking; there are no actual locks involved. We’ll have to enable
    versioning on the `Item` entity class as explained earlier; otherwise, we can’t
    use the optimistic `LockModeType`s with Hibernate.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被*锁定*术语所迷惑：JPA规范没有明确说明每个`LockModeType`是如何实现的。对于`OPTIMISTIC`，Hibernate执行版本检查；实际上没有涉及任何锁。我们必须像前面解释的那样在`Item`实体类上启用版本控制；否则，我们无法使用Hibernate的乐观`LockModeType`s。
- en: Hibernate doesn’t batch or otherwise optimize the `SELECT` statements for manual
    version checking; if we sum up 100 items, we get 100 additional queries at flush
    time. A pessimistic approach, as we’ll demonstrate later in this chapter, may
    be a better solution for this particular case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate不会对手动版本检查的`SELECT`语句进行批处理或优化；如果我们汇总100个项目，在刷新时我们会得到100个额外的查询。正如我们在本章后面将要展示的，一种悲观的策略可能在这个特定情况下是一个更好的解决方案。
- en: Why can’t the persistence context cache prevent the concurrent modification
    problem?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么持久化上下文缓存不能防止并发修改问题？
- en: The “get all items in a particular category” query returns item data in a `ResultSet`.
    Hibernate then looks at the primary key values in this data and first tries to
    resolve the rest of the details of each `Item` in the persistence context cache—it
    checks whether an `Item` instance has already been loaded with that identifier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: “获取特定类别中的所有项目”查询返回一个`ResultSet`中的项目数据。然后Hibernate查看这些数据中的主键值，并首先尝试在持久化上下文缓存中解决每个`Item`的其余详细信息——它检查是否已经使用该标识符加载了`Item`实例。
- en: 'This cache, however, doesn’t help in the example procedure: if a concurrent
    transaction moved an item to another category, that item might be returned several
    times in different `ResultSet`s. Hibernate will perform its persistence context
    lookup and say, “Oh, I’ve already loaded that `Item` instance; let’s use what
    we already have in memory.” Hibernate isn’t even aware that the category assigned
    to the item changed or that the item appeared again in a different result.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个缓存在这个示例过程中并没有帮助：如果一个并发事务将项目移动到另一个类别，该项目可能会在不同的`ResultSet`s中多次返回。Hibernate将执行其持久化上下文查找并说，“哦，我已经加载了那个`Item`实例；让我们使用我们已经在内存中的内容。”Hibernate甚至没有意识到分配给项目的类别已经改变，或者项目再次出现在不同的结果中。
- en: Hence, this is a case where the repeatable-read feature of the persistence context
    hides concurrently committed data. We need to manually check the versions to find
    out if the data changed while we were expecting it not to change.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个持久化上下文的可重复读特性隐藏了并发提交的数据的案例。我们需要手动检查版本号来确定在我们预期数据不会改变的时候，数据是否已经发生了变化。
- en: As shown in the preceding example, the `Query` interface accepts a `LockModeType`.
    Explicit lock modes are also supported by the `TypedQuery` and `NamedQuery` interfaces,
    with the same `setLockMode()` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`Query`接口接受一个`LockModeType`。`TypedQuery`和`NamedQuery`接口也支持显式锁定模式，使用相同的`setLockMode()`方法。
- en: An additional optimistic lock mode is available in JPA, forcing an increment
    of an entity’s version.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JPA中有一个额外的乐观锁定模式，可以强制实体版本的递增。
- en: Forcing a version increment
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 强制版本递增
- en: 'What happens if two users place a bid for the same auction item at the same
    time? When a user makes a new bid, the application must do two things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个用户同时为同一拍卖物品出价会发生什么？当用户提交新的出价时，应用程序必须做两件事：
- en: Retrieve the currently highest `Bid` for the `Item` from the database.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中检索`Item`的当前最高`Bid`。
- en: Compare the new `Bid` with the highest `Bid`; if the new `Bid` is higher, it
    must be stored in the database.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`Bid`与最高`Bid`进行比较；如果新的`Bid`更高，它必须存储在数据库中。
- en: There is the potential for a race condition between these two steps. If, between
    reading the highest `Bid` and placing the new `Bid`, another `Bid` is made, you
    won’t see it. This conflict isn’t visible, and even enabling versioning of the
    `Item` doesn’t help. The `Item` is never modified during the procedure. However,
    forcing a version increment of the `Item` makes the conflict detectable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个步骤之间可能存在竞争条件。如果在读取最高`Bid`和放置新的`Bid`之间，另一个`Bid`被提交，你将看不到它。这种冲突是不可见的，即使启用了`Item`的版本控制，也无法帮助。在程序过程中，`Item`永远不会被修改。然而，强制`Item`的版本递增可以使冲突变得可检测。
- en: Listing 11.5 Forcing a version increment of an entity instance
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 强制实体实例的版本递增
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ `find()` accepts a `LockModeType`. The `OPTIMISTIC_FORCE_INCREMENT` mode tells
    Hibernate that the version of the retrieved `Item` should be incremented after
    loading, even if it’s never modified in the unit of work.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `find()` 接受一个 `LockModeType`。`OPTIMISTIC_FORCE_INCREMENT` 模式告诉 Hibernate，在加载检索到的
    `Item` 后，即使它在工作单元中从未被修改，也应增加其版本。
- en: Ⓑ The code persists a new `Bid` instance; this doesn’t affect any values of
    the `Item` instance. A new row is inserted into the `BID` table. Hibernate wouldn’t
    detect concurrently made bids without a forced version increment of the `Item`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 代码持久化了一个新的 `Bid` 实例；这不会影响 `Item` 实例的任何值。在 `BID` 表中插入了一行新记录。如果没有强制版本增加的 `Item`，Hibernate
    不会检测到并发提交的出价。
- en: Ⓒ When flushing the persistence context, Hibernate executes an `INSERT` for
    the new `Bid` and forces an `UPDATE` of the `Item` with a version check. If someone
    modified the `Item` concurrently or placed a `Bid` concurrently with this procedure,
    Hibernate throws an exception.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当刷新持久化上下文时，Hibernate 执行一个 `INSERT` 以持久化新的 `Bid`，并强制执行带有版本检查的 `Item` 的 `UPDATE`。如果有人在此过程中并发修改了
    `Item` 或与此过程同时提交了一个 `Bid`，Hibernate 将抛出异常。
- en: For the auction system, placing bids concurrently is certainly a frequent operation.
    Incrementing a version manually is useful in many situations where we insert or
    modify data and want the version of some root instance of an aggregate to be incremented.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拍卖系统，并发提交出价当然是一个频繁的操作。在许多情况下，当我们插入或修改数据并希望聚合的某些根实例的版本增加时，手动增加版本是有用的。
- en: Note that if instead of a `Bid#item` entity association with `@ManyToOne`, we
    have an `@ElementCollection` of `Item#bids`, adding a `Bid` to the collection
    *will* increment the `Item` version. The forced increment then isn’t necessary.
    You may want to review the discussion of parent/child ambiguity and how aggregates
    and composition work with ORM in section 8.3.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们没有使用 `Bid#item` 实体关联的 `@ManyToOne`，而是有一个 `@ElementCollection` 的 `Item#bids`，向集合中添加一个
    `Bid` 将会增加 `Item` 的版本。强制增加在这种情况下是不必要的。你可能想回顾第 8.3 节中关于父/子歧义以及聚合和 ORM 一起工作的讨论。
- en: 'So far, we’ve focused on optimistic concurrency control: we expect that concurrent
    modifications are rare, so we don’t prevent concurrent access and detect conflicts
    late. Sometimes, however, we know that conflicts will happen frequently, and we
    want to place an exclusive lock on some data. This calls for a pessimistic approach.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注乐观并发控制：我们预计并发修改很少，因此我们不阻止并发访问，并在晚些时候检测冲突。然而，有时我们知道冲突将频繁发生，并且我们希望对某些数据放置排他锁。这需要一种悲观的方法。
- en: 11.2.3 Explicit pessimistic locking
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 显式悲观锁定
- en: Let’s repeat the procedure demonstrated in the previous “Manual version checking”
    section, but this time with a pessimistic lock instead of optimistic version checking.
    We’ll again summarize the total price of all items in several categories. This
    is the same code as shown earlier in listing 11.5, with a different `LockModeType`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复上一节“手动版本检查”中演示的程序，但这次使用悲观锁定而不是乐观版本检查。我们再次总结几个类别中所有项目的总价。这是与前面列表 11.5 中显示的相同代码，但
    `LockModeType` 不同。
- en: Listing 11.6 Locking data pessimistically
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 悲观锁定数据
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ⓐ For each `Category`, query all `Item` instances in `PESSIMISTIC_READ` lock
    mode. Hibernate locks the rows in the database with the SQL query. If another
    transaction holds a conflicting lock, wait 5 seconds if possible. If the lock
    can’t be obtained, the query throws an exception.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 对于每个 `Category`，以 `PESSIMISTIC_READ` 锁定模式查询所有 `Item` 实例。Hibernate 使用 SQL 查询锁定数据库中的行。如果另一个事务持有冲突锁，如果可能，等待
    5 秒。如果无法获得锁，查询将抛出异常。
- en: Ⓑ If the query returns successfully, we know that we hold an exclusive lock
    on the data, and no other transaction can access it with an exclusive lock or
    modify it until this transaction commits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 如果查询成功返回，我们知道我们持有对数据的排他锁，并且没有其他事务可以以排他锁访问它或修改它，直到此事务提交。
- en: Ⓒ The locks are released after committing, when the transaction completes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 事务完成后提交时，锁被释放。
- en: 'The JPA specification defines that the `PESSIMISTIC_READ` lock mode guarantees
    repeatable reads. JPA also standardizes the `PESSIMISTIC_WRITE` mode, with additional
    guarantees: in addition to repeatable reads, the JPA provider must serialize data
    access, and no phantom reads can occur.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 规范定义了 `PESSIMISTIC_READ` 锁定模式保证可重复读。JPA 还标准化了 `PESSIMISTIC_WRITE` 模式，并提供了额外的保证：除了可重复读之外，JPA
    提供商必须序列化数据访问，并且不能发生幻读。
- en: 'It’s up to the JPA provider to implement these requirements. For both modes,
    Hibernate appends a `FOR UPDATE` clause to the SQL query when loading data. This
    places a lock on the rows at the database level. What kind of lock Hibernate uses
    depends on the `LockModeType` and the Hibernate database dialect:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些要求取决于JPA提供者。对于这两种模式，Hibernate在加载数据时将`FOR UPDATE`子句附加到SQL查询。这将在数据库级别对行进行锁定。Hibernate使用的锁类型取决于`LockModeType`和Hibernate数据库方言：
- en: On H2 the query is `SELECT * FROM ITEM ... FOR UPDATE`. Because H2 supports
    only one type of exclusive lock, Hibernate generates the same SQL for all pessimistic
    modes.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在H2数据库中，查询语句为`SELECT * FROM ITEM ... FOR UPDATE`。因为H2数据库只支持一种类型的排他锁，所以Hibernate为所有悲观模式生成相同的SQL语句。
- en: 'PostgreSQL, on the other hand, supports shared read locks: the `PESSIMISTIC_
    READ` mode appends `FOR SHARE` to the SQL query. `PESSIMISTIC_WRITE` uses an exclusive
    write lock with `FOR UPDATE`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，PostgreSQL支持共享读锁：`PESSIMISTIC_READ`模式将`FOR SHARE`附加到SQL查询。`PESSIMISTIC_WRITE`使用带有`FOR
    UPDATE`的排他写锁。
- en: On MySQL, `PESSIMISTIC_READ` translates to `LOCK IN SHARE MODE`, and `PESSIMISTIC_WRITE`
    to `FOR UPDATE`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MySQL中，`PESSIMISTIC_READ`转换为`LOCK IN SHARE MODE`，而`PESSIMISTIC_WRITE`转换为`FOR
    UPDATE`。
- en: Check your database dialect. The lock is configured with the `getReadLockString()`
    and `getWriteLockString()` methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的数据库方言。锁是通过`getReadLockString()`和`getWriteLockString()`方法配置的。
- en: The duration of a pessimistic lock in JPA is a single database transaction.
    This means we can’t use an exclusive lock to block concurrent access for longer
    than a single database transaction. When the database lock can’t be obtained,
    an exception is thrown.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: JPA中悲观锁的持续时间是一个单独的数据库事务。这意味着我们无法使用排他锁来阻塞并发访问超过单个数据库事务的时间。当数据库锁无法获取时，会抛出异常。
- en: Compare this with an optimistic approach, where Hibernate throws an exception
    at commit time, not when you query. With a pessimistic strategy, we know that
    we can read and write the data safely as soon as the locking query succeeds. With
    an optimistic approach, we hope for the best and may be surprised later, when
    we commit.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与乐观方法进行比较，Hibernate在提交时而不是在查询时抛出异常。在悲观策略中，我们知道一旦锁定查询成功，我们就可以安全地读取和写入数据。在乐观方法中，我们寄希望于最好的结果，但可能在稍后提交时感到惊讶。
- en: Offline locks
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 离线锁
- en: 'Pessimistic database locks are held only for a single transaction. Other lock
    implementations are possible: for example, a lock held in memory, or a so-called
    *lock table* in the database. A common name for these kinds of locks is *offline
    locks*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 悲观数据库锁仅保留在一个事务中。其他锁实现是可能的：例如，内存中的锁，或数据库中的所谓*锁表*。这类锁的常见名称是*离线锁*。
- en: 'Locking pessimistically for longer than a single database transaction is usually
    a performance bottleneck: every data access involves additional lock checks to
    a globally synchronized lock manager. Optimistic locking, however, is the perfect
    concurrency control strategy for long-running conversations (as you’ll see in
    the next chapter), and it performs well. Depending on the conflict-resolution
    strategy—which determines what happens after a conflict is detected—the application’s
    users may be just as happy with optimistic locking as with blocked concurrent
    access. They may also appreciate the application not locking them out of particular
    screens while others look at the same data.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 悲观锁超过单个数据库事务通常会导致性能瓶颈：每次数据访问都涉及对全局同步锁管理器的额外锁检查。然而，乐观锁是长运行会话（如你将在下一章中看到的）的完美并发控制策略，并且性能良好。根据冲突解决策略——它决定了检测到冲突后会发生什么——应用程序的用户可能会像喜欢阻塞并发访问一样喜欢乐观锁。他们也可能欣赏应用程序在其他人查看相同数据时不会将他们锁定在特定屏幕之外。
- en: We can configure how long the database will wait to obtain the lock and block
    the query in milliseconds with the `javax.persistence.lock.timeout` hint. As usual
    with hints, Hibernate might ignore it, depending on the database product. H2,
    for example, doesn’t support lock timeouts for specific queries, only a global
    lock timeout for the connection (defaulting to 1 second). With some dialects,
    such as PostgreSQL and Oracle, a lock timeout of `0` appends the `NOWAIT` clause
    to the SQL string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`javax.persistence.lock.timeout`提示来配置数据库等待获取锁并阻塞查询的时间（以毫秒为单位）。与提示一样，Hibernate可能会根据数据库产品忽略它。例如，H2数据库不支持特定查询的锁超时，只支持连接的全局锁超时（默认为1秒）。在某些方言中，例如PostgreSQL和Oracle，将`0`作为锁超时将`NOWAIT`子句附加到SQL字符串中。
- en: 'We’ve demonstrated the lock timeout hint applied to a `Query`. We can also
    set the timeout hint for `find()` operations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了应用于 `Query` 的锁超时提示。我们也可以为 `find()` 操作设置超时提示：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ Executes `SELECT ... FOR UPDATE WAIT 5000`, if supported by the dialect.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如果方言支持，执行 `SELECT ... FOR UPDATE WAIT 5000`。
- en: When a lock can’t be obtained, Hibernate throws either a `javax.persistence
    .LockTimeoutException` or a `javax.persistence.PessimisticLockException`. If Hibernate
    throws a `PessimisticLockException`, the transaction must be rolled back, and
    the unit of work ends. A timeout exception, on the other hand, isn’t fatal for
    the transaction. Which exception Hibernate throws again depends on the SQL dialect.
    For example, because H2 doesn’t support per-statement lock timeouts, we always
    get a `PessimisticLockException`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法获取锁时，Hibernate 抛出 `javax.persistence.LockTimeoutException` 或 `javax.persistence.PessimisticLockException`。如果
    Hibernate 抛出 `PessimisticLockException`，则必须回滚事务，并且工作单元结束。另一方面，超时异常对事务不是致命的。Hibernate
    抛出哪种异常再次取决于 SQL 方言。例如，因为 H2 不支持每语句锁超时，所以我们总是得到 `PessimisticLockException`。
- en: We can use both the `PESSIMISTIC_READ` and `PESSIMISTIC_WRITE` lock modes even
    if we haven’t enabled entity versioning. They translate to SQL statements with
    database-level locks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有启用实体版本化，我们也可以使用 `PESSIMISTIC_READ` 和 `PESSIMISTIC_WRITE` 锁模式。它们转换为数据库级别的锁的
    SQL 语句。
- en: The special `PESSIMISTIC_FORCE_INCREMENT` mode requires versioned entities.
    In Hibernate, this mode executes a `FOR UPDATE NOWAIT` lock (or whatever the dialect
    supports; check its `getForUpdateNowaitString()` implementation). Then, immediately
    after the query returns, Hibernate increments the version and makes an `UPDATE`
    for each returned entity instance. This indicates to any concurrent transaction
    that we have updated these rows, even if we haven’t so far modified any data.
    This mode is rarely useful, except for aggregate locking as discussed in the “Forcing
    a version increment” section earlier in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的 `PESSIMISTIC_FORCE_INCREMENT` 模式需要版本化实体。在 Hibernate 中，此模式执行一个 `FOR UPDATE
    NOWAIT` 锁（或方言支持的任何内容；检查其 `getForUpdateNowaitString()` 实现）。然后，在查询返回后立即，Hibernate
    增加版本并对每个返回的实体实例执行 `UPDATE`。这向任何并发事务表明我们已经更新了这些行，即使我们尚未修改任何数据。此模式很少有用，除了在本章前面讨论的“强制版本增量”部分中讨论的聚合锁定之外。
- en: What about lock modes READ and WRITE?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 READ 和 WRITE 锁模式呢？
- en: These are older lock modes from JPA 1.0, and you should no longer use them.
    `LockModeType.READ` is equivalent to `OPTIMISTIC`, and `LockModeType.WRITE` is
    equivalent to `OPTIMISTIC_FORCE_INCREMENT`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是来自 JPA 1.0 的旧锁模式，你应该不再使用它们。`LockModeType.READ` 等同于 `OPTIMISTIC`，而 `LockModeType.WRITE`
    等同于 `OPTIMISTIC_FORCE_INCREMENT`。
- en: 'If we enable pessimistic locking, Hibernate locks only rows that correspond
    to entity instance state. In other words, if we lock an `Item` instance, Hibernate
    will lock its row in the `ITEM` table. If we have a joined inheritance mapping
    strategy, Hibernate will recognize this and lock the appropriate rows in supertable
    and subtables. This also applies to any secondary table mappings of an entity.
    Because Hibernate locks entire rows, any relationship where the foreign key is
    in that row will also effectively be locked: the `Item#seller` association is
    locked if the `SELLER_ID` foreign key column is in the `ITEM` table, but the actual
    `Seller` instance isn’t locked! Neither are collections or other associations
    of the `Item` where the foreign keys are in other tables.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用悲观锁，Hibernate 只锁定与实体实例状态相对应的行。换句话说，如果我们锁定一个 `Item` 实例，Hibernate 将锁定 `ITEM`
    表中的其行。如果我们有一个联合继承映射策略，Hibernate 将识别这一点并锁定超表和子表中的适当行。这也适用于实体的任何二级表映射。因为 Hibernate
    锁定整个行，所以任何外键在该行中的关系也将被有效地锁定：如果 `SELLER_ID` 外键列在 `ITEM` 表中，则 `Item#seller` 关联将被锁定，但实际的
    `Seller` 实例不会被锁定！`Item` 的集合或其他关联也不会被锁定，其中外键在其他表中。
- en: Extending lock scope
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展锁作用域
- en: JPA 2.0 defines the `PessimisticLockScope.EXTENDED` option. It can be set as
    a query hint with `javax.persistence.lock.scope`. If enabled, the persistence
    engine expands the scope of locked data to include any data in collections and
    association join tables of locked entities.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2.0 定义了 `PessimisticLockScope.EXTENDED` 选项。它可以作为一个查询提示通过 `javax.persistence.lock.scope`
    设置。如果启用，持久化引擎将锁定数据的范围扩展到包括被锁定实体集合和关联连接表中的任何数据。
- en: With exclusive locking in the DBMS, you may experience transaction failures
    because you run into deadlock situations. Let’s look at how you can avoid that.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DBMS 中使用排他锁时，你可能会遇到事务失败，因为你遇到了死锁情况。让我们看看如何避免这种情况。
- en: 11.2.4  Avoiding deadlocks
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 避免死锁
- en: 'Deadlocks can occur if the DBMS relies on exclusive locks to implement transaction
    isolation. Consider the following unit of work, updating two `Item` entity instances
    in a particular order:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DBMS依赖于排他锁来实现事务隔离，则可能会发生死锁。考虑以下工作单元，按特定顺序更新两个`Item`实体实例：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Hibernate executes two SQL `UPDATE` statements when the persistence context
    is flushed. The first `UPDATE` locks the row representing `Item` one, and the
    second `UPDATE` locks `Item` two:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当持久化上下文被刷新时，Hibernate执行两个SQL `UPDATE`语句。第一个`UPDATE`锁定代表`Item`一的行，第二个`UPDATE`锁定`Item`二：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ⓐ Locks row 1
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 锁定行1
- en: Ⓑ Attempts to lock row 2
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 尝试锁定行2
- en: 'A deadlock may (or may not!) occur if a similar procedure, with the opposite
    order of `Item` updates, executes in a concurrent transaction:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类似的过程，以相反的`Item`更新顺序执行，在并发事务中，可能会（或可能不会！）发生死锁：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ⓐ Locks row 2
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 锁定行2
- en: Ⓑ Attempts to lock row 1
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 尝试锁定行1
- en: With a deadlock, both transactions are blocked and can’t move forward, each
    waiting for a lock to be released. The chance of a deadlock is usually small,
    but in highly concurrent applications, two Hibernate applications may execute
    this kind of interleaved update. Note that we may not see deadlocks during testing
    (unless we write the right kinds of tests). Deadlocks can suddenly appear when
    the application has to handle a high transaction load in production. Usually the
    DBMS terminates one of the deadlocked transactions after a timeout period and
    this transaction fails; the other transaction can then proceed. Alternatively,
    the DBMS may detect a deadlock situation automatically and immediately abort one
    of the transactions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在死锁的情况下，两个事务都被阻塞，无法前进，每个都在等待锁被释放。死锁的可能性通常很小，但在高度并发的应用程序中，两个Hibernate应用程序可能会执行这种交错更新的操作。请注意，我们可能在测试期间看不到死锁（除非我们编写了正确的测试）。当应用程序在生产中必须处理高事务负载时，死锁可能会突然出现。通常，DBMS在超时后终止其中一个死锁事务，该事务失败；然后另一个事务可以继续进行。或者，DBMS可能会自动检测死锁情况并立即中止其中一个事务。
- en: You should try to avoid transaction failures because they’re difficult to recover
    from in application code. One solution is to run the database connection in *serializable*
    mode when updating a single row will lock the entire table. The concurrent transaction
    has to wait until the first transaction completes its work. Alternatively, the
    first transaction can obtain an exclusive lock on all data when you `SELECT` the
    data, as demonstrated in the previous section. Then any concurrent transaction
    also has to wait until these locks are released.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 应该尽量避免事务失败，因为它们在应用程序代码中很难恢复。一个解决方案是在更新单行时以**serializable**模式运行数据库连接，这将锁定整个表。并发事务必须等待第一个事务完成其工作。或者，第一个事务可以在你`SELECT`数据时获取所有数据的排他锁，如前节所示。然后任何并发事务也必须等待这些锁被释放。
- en: 'An alternative pragmatic optimization that significantly reduces the probability
    of deadlocks is to order the `UPDATE` statements by primary key value: Hibernate
    should always update the row with primary key `1` before updating row `2`, no
    matter in what order the data was loaded and modified by the application. You
    can enable this optimization for the entire persistence unit with the `hibernate.order_updates`
    configuration property. Hibernate then orders all `UPDATE` statements it executes
    in ascending order by the primary key value of the modified entity instances and
    collection elements detected during flushing. (As mentioned earlier, make sure
    you fully understand the transactional and locking behavior of your DBMS product.
    Hibernate inherits most of its transaction guarantees from the DBMS; for example,
    your MVCC database product may avoid read locks but probably depends on exclusive
    locks for writer isolation, and you may see deadlocks.)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代的实用优化可以显著降低死锁的概率，即按主键值对`UPDATE`语句进行排序：Hibernate应始终在更新数据被应用程序加载和修改的顺序之前更新主键为`1`的行，无论数据以何种顺序加载和修改。您可以通过`hibernate.order_updates`配置属性为整个持久化单元启用此优化。Hibernate随后按修改的实体实例和集合元素的主键值升序排序执行所有`UPDATE`语句。（如前所述，请确保您完全理解您的DBMS产品的事务和锁定行为。Hibernate从DBMS继承了其大部分事务保证；例如，您的MVCC数据库产品可能避免读锁，但可能依赖于排他锁来实现写隔离，您可能会看到死锁。）
- en: We didn’t have an opportunity to mention the `EntityManager#lock()` method.
    It accepts an already-loaded persistent entity instance and a lock mode. It performs
    the same locking you’ve seen with `find()` and a `Query`, except that it doesn’t
    load the instance. Additionally, if a versioned entity is being locked pessimistically,
    the `lock()` method performs an immediate version check on the database and potentially
    throws an `OptimisticLockException`. If the database representation is no longer
    present, Hibernate throws an `EntityNotFoundException`. Finally, the `EntityManager#refresh()`
    method also accepts a lock mode, with the same semantics.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有机会提到`EntityManager#lock()`方法。它接受一个已加载的持久化实体实例和一个锁定模式。它执行与`find()`和`Query`中看到的相同的锁定操作，只不过它不会加载实例。此外，如果版本化实体正在以悲观方式锁定，`lock()`方法将在数据库上立即执行版本检查，并可能抛出`OptimisticLockException`。如果数据库表示不再存在，Hibernate将抛出`EntityNotFoundException`。最后，`EntityManager#refresh()`方法也接受一个锁定模式，具有相同的语义。
- en: 'We’ve now covered concurrency control at the lowest level—the database—and
    the optimistic and pessimistic locking features of JPA. We still have one more
    aspect of concurrency to examine: accessing data outside of a transaction.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了最低级别的并发控制——数据库——以及JPA的乐观和悲观锁定特性。我们还有一个并发方面需要检查：在事务外访问数据。
- en: 11.3 Non-transactional data access
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 非事务性数据访问
- en: A JDBC `Connection` is by default in *auto-commit* mode. This mode is useful
    for executing ad hoc SQL.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JDBC `Connection`处于*自动提交*模式。这种模式对于执行临时的SQL很有用。
- en: Imagine that you connect to a database with an SQL console, and you run a few
    queries, and maybe even update and delete rows. This interactive data access is
    ad hoc; most of the time you don’t have a plan or a sequence of statements that
    you consider a unit of work. The default auto-commit mode on the database connection
    is perfect for this kind of data access—after all, you don’t want to type `begin
    transaction` and `end transaction` for every SQL statement you write and execute.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你使用SQL控制台连接到数据库，并运行几个查询，甚至更新和删除行。这种交互式数据访问是临时的；大多数时候，你没有计划或一系列你认为是一个工作单元的语句。数据库连接上的默认自动提交模式非常适合这种数据访问——毕竟，你不想为每个你编写和执行的SQL语句都输入`begin
    transaction`和`end transaction`。
- en: In auto-commit mode, a (short) database transaction begins and ends for each
    SQL statement you send to the database. You’re effectively working in the non-transactional
    mode because there are no atomicity or isolation guarantees for your session with
    the SQL console. (The only guarantee is that a single SQL statement is atomic.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动提交模式下，每个发送到数据库的SQL语句都会开始和结束一个（短）数据库事务。你实际上是在非事务模式下工作，因为你的会话与SQL控制台之间没有任何原子性或隔离保证。（唯一的保证是单个SQL语句是原子的。）
- en: An application, by definition, always executes a planned sequence of statements.
    It seems reasonable that you can therefore always create transaction boundaries
    to group the statements into units that are atomic and isolated from each other.
    In JPA, however, special behavior is associated with auto-commit mode, and you
    may need it to implement long-running conversations. You can access the database
    in auto-commit mode and read data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，应用程序总是执行一系列计划的语句。因此，你可以因此始终创建事务边界来将语句分组为原子且相互隔离的单位似乎是合理的。然而，在JPA中，与自动提交模式相关联的是特殊行为，你可能需要它来实现长时间运行的会话。你可以在自动提交模式下访问数据库并读取数据。
- en: 11.3.1 Reading data in auto-commit mode
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 在自动提交模式下读取数据
- en: Consider the following example, which loads an `Item` instance, changes its
    `name`, and then rolls back that change by refreshing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它加载了一个`Item`实例，更改了其`name`，然后通过刷新撤销了该更改。
- en: No transaction is active when we create the `EntityManager`. The persistence
    context will be in a special unsynchronized mode; Hibernate won’t flush automatically.
    You can access the database to read data, and such an operation executes a `SELECT`,
    which is sent to the database in auto-commit mode.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`EntityManager`时，没有任何事务是活跃的。持久化上下文将处于一种特殊的未同步模式；Hibernate不会自动刷新。你可以访问数据库来读取数据，此类操作执行一个`SELECT`，该操作在自动提交模式下发送到数据库。
- en: 'Usually Hibernate flushes the persistence context when you execute a `Query`.
    If the context is unsynchronized, flushing doesn’t occur and the query returns
    the old, original database value. Queries with scalar results aren’t repeatable:
    you see whatever values are in the database and given to Hibernate in the `ResultSet`.
    This also isn’t a repeatable read if you’re in synchronized mode.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你执行一个`Query`时，Hibernate会刷新持久化上下文。如果上下文是非同步的，则不会发生刷新，查询将返回旧的、原始的数据库值。具有标量结果的查询是不可重复的：你将看到数据库中存在的任何值，以及Hibernate在`ResultSet`中接收到的值。即使在同步模式下，这也不是可重复读。
- en: Retrieving a managed entity instance involves a lookup during JDBC result-set
    marshaling in the current persistence context. The already-loaded instance with
    the changed name is returned from the persistence context; values from the database
    are ignored. This is a repeatable read of an entity instance, even without a system
    transaction.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个托管实体实例涉及在当前持久化上下文中进行查找，在JDBC结果集序列化期间。从持久化上下文中返回已加载的具有更改名称的实例；忽略数据库中的值。这是一个即使没有系统事务也能重复读取实体实例的情况。
- en: If you try to flush the persistence context manually to store a new `Item#name`,
    Hibernate throws a `javax.persistence.TransactionRequiredException`. You can’t
    execute an `UPDATE` in unsynchronized mode, because you wouldn’t be able to roll
    back the change.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试手动刷新持久化上下文以存储新的`Item#name`，Hibernate会抛出`javax.persistence.TransactionRequiredException`异常。在非同步模式下执行`UPDATE`是不允许的，因为你将无法回滚更改。
- en: You can roll back the change you made with the `refresh()` method. It loads
    the current `Item` state from the database and overwrites the change you made
    in memory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`refresh()`方法回滚使用该方法所做的更改。它从数据库中加载当前的`Item`状态，并覆盖你在内存中做的更改。
- en: Listing 11.7 Reading data in auto-commit mode
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 在自动提交模式下读取数据
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ⓐ No transaction is active when creating the `EntityManager`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在创建`EntityManager`时没有活动的事务。
- en: Ⓑ Access the database to read data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 访问数据库以读取数据。
- en: Ⓒ Because the context is unsynchronized, flushing doesn’t occur, and the query
    returns the old, original database value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 因为上下文是非同步的，所以不会发生刷新，查询返回旧的、原始的数据库值。
- en: Ⓓ The already-loaded `Item` instance with the changed name is returned from
    the persistence context; values from the database are ignored.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 从持久化上下文中返回具有更改名称的已加载`Item`实例；忽略数据库中的值。
- en: Ⓔ You cannot execute an `UPDATE` in unsynchronized mode, because you wouldn’t
    be able to roll back the change.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 你不能在非同步模式下执行`UPDATE`，因为你将无法回滚更改。
- en: Ⓕ Roll back the change you made with the `refresh()` method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 回滚使用`refresh()`方法所做的更改。
- en: 'With an unsynchronized persistence context, you read data in auto-commit mode
    with `find()`, `getReference()`, `refresh()`, or queries. You can load data on
    demand as well: proxies are initialized if you access them, and collections are
    loaded if you start iterating through their elements. But if you try to flush
    the persistence context or lock data with anything but `LockModeType.NONE`, a
    `TransactionRequiredException` will occur.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在非同步持久化上下文中，你可以使用`find()`、`getReference()`、`refresh()`或查询在自动提交模式下读取数据。你也可以按需加载数据：如果你访问它们，代理将被初始化，如果你开始遍历它们的元素，集合将被加载。但是，如果你尝试使用除`LockModeType.NONE`之外的方式刷新持久化上下文或锁定数据，将会发生`TransactionRequiredException`异常。
- en: 'So far, the auto-commit mode doesn’t seem very useful. Indeed, many developers
    often rely on auto-commit for the wrong reasons:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，自动提交模式似乎并不很有用。事实上，许多开发者经常出于错误的原因依赖自动提交：
- en: Many small per-statement database transactions (that’s what auto-commit means)
    won’t improve the performance of the application.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多小的每语句数据库事务（这就是自动提交的含义）不会提高应用程序的性能。
- en: You won’t improve the scalability of the application. You might think that a
    longer-running database transaction, instead of many small transactions for every
    SQL statement, may hold database locks for a longer time, but this is a minor
    concern, because Hibernate writes to the database as late as possible within a
    transaction (flush at commit), so the database already holds write locks for a
    short time.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会提高应用程序的可伸缩性。你可能会认为，与每个SQL语句的许多小事务相比，一个运行时间较长的数据库事务可能会更长时间地持有数据库锁，但这是一个次要的担忧，因为Hibernate在事务中尽可能晚地写入数据库（在提交时刷新），因此数据库已经持有写锁一段时间了。
- en: Auto-commit provides weaker isolation guarantees if the application modifies
    data concurrently. Repeatable reads based on read locks are impossible with auto-commit
    mode. (The persistence context cache helps here, naturally.)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序并发修改数据，自动提交提供较弱的隔离保证。在自动提交模式下，基于读取锁的重复读取是不可能的。（持久化上下文缓存在这里自然有所帮助。）
- en: If your DBMS has MVCC (for example, Oracle or PostgreSQL), you’ll likely want
    to use its capability for *snapshot isolation* to avoid unrepeatable and phantom
    reads. Each transaction gets its own snapshot of the data; you only see a (database-internal)
    version of the data as it was before your transaction started. With auto-commit
    mode, snapshot isolation makes no sense, because there is no transaction scope.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据库管理系统有MVCC（例如，Oracle或PostgreSQL），你可能会想使用其 *快照隔离* 功能来避免不可重复读取和幻读。每个事务都获得其自己的数据快照；你只能看到在事务开始之前的数据（数据库内部版本）。在自动提交模式下，快照隔离没有意义，因为没有事务范围。
- en: Your code will be more difficult to understand if you use auto-commit. Any reader
    of your code will have to pay special attention to whether a persistence context
    is joined with a transaction, or if it’s in unsynchronized mode. If you always
    group operations within a system transaction, even if you only read data, everyone
    can follow this simple rule, and the likelihood of difficult-to-find concurrency
    problems is reduced.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用自动提交，你的代码将更难以理解。任何阅读你代码的人都将必须特别注意持久化上下文是否与事务关联，或者它是否处于未同步模式。如果你总是将操作分组在系统事务中，即使你只读取数据，每个人都可以遵循这个简单的规则，难以发现的并发问题的可能性就会降低。
- en: So what are the benefits of an unsynchronized persistence context? If flushing
    doesn’t happen automatically, you can prepare and *queue* modifications outside
    of a transaction.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，未同步持久化上下文有哪些好处？如果刷新不会自动发生，你可以在事务之外准备和 *排队* 修改。
- en: 11.3.2 Queuing modifications
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 排队修改
- en: The following example stores a new `Item` instance with an unsynchronized `EntityManager`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用未同步的 `EntityManager` 存储一个新的 `Item` 实例。
- en: You can call `persist()` to save a transient entity instance with an unsynchronized
    persistence context. Hibernate only fetches a new identifier value, typically
    by calling a database sequence, and assigns it to the instance. The instance will
    be in a persistent state in the context, but the SQL `INSERT` hasn’t happened.
    Note that this is only possible with *pre-insert* identifier generators; see section
    5.2.5.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `persist()` 在未同步的持久化上下文中保存一个临时实体实例。Hibernate仅通过调用数据库序列来获取一个新的标识符值，并将其分配给实例。该实例将在上下文中处于持久状态，但SQL
    `INSERT` 尚未发生。请注意，这仅适用于 *预插入* 标识符生成器；请参阅第5.2.5节。
- en: When you’re ready to store the changes, you must join the persistence context
    with a transaction. Synchronization and flushing occur as usual when the transaction
    commits. Hibernate writes all queued operations to the database.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好存储更改时，你必须使用事务将持久化上下文与事务关联。当事务提交时，通常会发生同步和刷新。Hibernate将所有排队操作写入数据库。
- en: '[PRE13]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ⓐ Call `persist()` to save a transient entity instance with an unsynchronized
    persistence context.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 调用 `persist()` 以保存一个具有未同步持久化上下文的临时实体实例。
- en: Ⓑ Join the persistence context with a transaction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用事务将持久化上下文与事务关联。
- en: Ⓒ Synchronization and flushing occur when the transaction commits.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当事务提交时发生同步和刷新。
- en: 'Merged changes of a detached entity instance can also be queued:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 分离的实体实例的合并更改也可以排队：
- en: '[PRE14]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ⓐ Hibernate executes a `SELECT` in auto-commit mode when you `merge()`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 当你 `merge()` 时，Hibernate会在自动提交模式下执行一个 `SELECT`。
- en: Ⓑ Hibernate defers the `UPDATE` until a joined transaction commits.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ Hibernate将 `UPDATE` 延迟到关联事务提交。
- en: 'Queuing also works for the removal of entity instances and `DELETE` operations:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 排队也适用于实体实例的删除和 `DELETE` 操作：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An unsynchronized persistence context, therefore, allows you to decouple persistence
    operations from transactions. The ability to queue data modifications, independent
    of transactions (and client/server requests), is a major feature of the persistence
    context.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，未同步的持久化上下文允许你将持久化操作与事务解耦。能够在事务（和客户端/服务器请求）之外排队数据修改的能力是持久化上下文的主要特性之一。
- en: Hibernate’s MANUAL flush mode
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate的手动刷新模式
- en: Hibernate offers a `Session#setFlushMode()` method, with the additional `FlushMode
    .MANUAL`. It’s a much more convenient switch that disables any automatic flushing
    of the persistence context, even when a joined transaction commits. With this
    mode, you have to call `flush()` explicitly to synchronize with the database.
    In JPA, the idea was that a “transaction commit should always write any outstanding
    changes,” so reading was separated from writing with the *unsynchronized* mode.
    If you don’t agree with this or don’t want auto-committed statements, enable manual
    flushing with the `Session` API. You can then have regular transaction boundaries
    for all units of work, with repeatable reads and even snapshot isolation from
    your MVCC database, but still queue changes in the persistence context for later
    execution and manually `flush()` before your transaction commits.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 提供了 `Session#setFlushMode()` 方法，以及额外的 `FlushMode.MANUAL`。这是一个更方便的开关，它禁用了持久化上下文的任何自动刷新，即使在联合事务提交时也是如此。使用此模式，您必须显式调用
    `flush()` 以与数据库同步。在 JPA 中，想法是“事务提交应始终写入任何未决更改”，因此读取与写入通过 *非同步* 模式分离。如果您不同意这一点或不想自动提交语句，请通过
    `Session` API 启用手动刷新。然后，您可以为所有工作单元拥有常规的事务边界，包括可重复读甚至来自您的 MVCC 数据库的快照隔离，但仍然将更改排队在持久化上下文中以供稍后执行，并在事务提交之前手动
    `flush()`。
- en: 11.4 Managing transactions with Spring and Spring Data
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用 Spring 和 Spring Data 管理事务
- en: We’ll now move on and demonstrate how to implement transactions with Spring
    and Spring Data. The transactional model used by Spring is applicable to different
    APIs, such as Hibernate, JPA, and Spring Data JPA. The management of the transactions
    can be either programmatic (as we have already demonstrated) or declarative, with
    the help of annotations (which is what we’ll mostly use for this section of the
    chapter).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续并演示如何使用 Spring 和 Spring Data 实现事务。Spring 使用的交易模型适用于不同的 API，例如 Hibernate、JPA
    和 Spring Data JPA。事务的管理可以是程序性的（正如我们之前所演示的）或声明性的，通过注解（这是我们将在本章的这一部分主要使用的）。
- en: The key Spring transaction abstraction is defined by the `org.springframework
    .transaction.PlatformTransactionManager` interface.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 事务抽象的关键由 `org.springframework.transaction.PlatformTransactionManager`
    接口定义。
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Typically, this interface is not used directly. You will either mark transactions
    declaratively, through annotations, or you may eventually use `TransactionTemplate`
    for the programmatic transaction definition.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个接口不会直接使用。您将要么通过注解声明性地标记事务，或者您最终可能使用 `TransactionTemplate` 进行程序性事务定义。
- en: Spring uses the previously discussed ANSI isolation levels. For a refresher,
    take a look back at section 11.2.1 and particularly table 11.1, which summarizes
    the isolation levels and the problems that they address.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 使用之前讨论的 ANSI 隔离级别。为了复习，请回顾 11.2.1 节，特别是表 11.1，它总结了隔离级别和它们解决的问题。
- en: 11.4.1 Transaction propagation
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 事务传播
- en: 'Spring deals with the transaction propagation problem. In brief, if `method-A`
    is transactional and it calls `method-B`, how will the latter behave, from the
    transactional point of view? Take a look at figure 11.5:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 处理事务传播问题。简而言之，如果 `method-A` 是事务性的并且它调用 `method-B`，那么从事务的角度来看，后者将如何表现？请看图
    11.5：
- en: '`bean-1` contains `method-A`, which is transactional, executed in transaction
    `TX1`.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bean-1` 包含事务性的 `method-A`，它在事务 `TX1` 中执行。'
- en: '`method-A` calls `bean-2.method-B()`, which is also transactional.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method-A` 调用也是事务性的 `bean-2.method-B()`。'
- en: '![](../../OEBPS/Images/CH11_F05_Tudose2.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH11_F05_Tudose2.png)'
- en: Figure 11.5 The transaction propagation concept
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 事务传播概念
- en: In which transaction will be `method-B` executed?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`method-B` 将在哪个事务中执行？'
- en: 'Spring defines the list of possible propagations through the `org.springframework.transaction
    .annotation.Propagation` enum:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 通过 `org.springframework.transaction.annotation.Propagation` 枚举定义了可能的传播列表：
- en: '`REQUIRED`—If a transaction is in progress, the execution will continue within
    that transaction. Otherwise, a new transaction will be created. `REQUIRED` is
    the default propagation for transactions in Spring.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REQUIRED` — 如果存在事务，则执行将在该事务内继续。否则，将创建新的事务。`REQUIRED` 是 Spring 中事务的默认传播。'
- en: '`SUPPORTS`—If a transaction is in progress, the execution will continue within
    that transaction. Otherwise, no transaction will be created.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUPPORTS` — 如果存在事务，则执行将在该事务内继续。否则，不会创建新的事务。'
- en: '`MANDATORY`—If a transaction is in progress, the execution will continue within
    that transaction. Otherwise, a `TransactionRequiredException` exception will be
    thrown.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANDATORY`—如果存在事务，则执行将在该事务内继续。否则，将抛出 `TransactionRequiredException` 异常。'
- en: '`REQUIRES_NEW`—If a transaction is in progress, it will be suspended and a
    new transaction will be started. Otherwise, a new transaction will be created
    anyway.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REQUIRES_NEW`—如果存在事务，则它将被挂起，并将启动一个新事务。否则，无论如何都将创建一个新事务。'
- en: '`NOT_SUPPORTED`—If a transaction is in progress, it will be suspended and a
    non-transactional execution will continue. Otherwise, the execution will simply
    continue.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT_SUPPORTED`—如果存在事务，则它将被挂起，并将继续非事务性执行。否则，执行将简单地继续。'
- en: '`NEVER`—If a transaction is in progress, an `IllegalTransactionStateException`
    will be thrown. Otherwise, the execution will simply continue.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEVER`—如果存在事务，则将抛出 `IllegalTransactionStateException` 异常。否则，执行将简单地继续。'
- en: '`NESTED`—If a transaction is in progress, a subtransaction of this one will
    be created, and at the same time a savepoint will be created. If the subtransaction
    fails, the execution will roll back to this savepoint. If no transaction was originally
    in progress, a new transaction will be created.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NESTED`—如果存在事务，则将创建此事务的子事务，并同时创建一个保存点。如果子事务失败，执行将回滚到此保存点。如果没有原始事务，则将创建一个新事务。'
- en: Table 11.2 summarizes the possible transaction propagations in Spring (T1 and
    T2 are transactions 1 and 2).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2总结了Spring中可能的事务传播（T1和T2分别是事务1和事务2）。
- en: Table 11.2 Transaction propagation in Spring
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 Spring中的事务传播
- en: '| Transaction propagation | Transaction in the caller method | Transaction
    in the called method |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 事务传播 | 调用方法中的事务 | 被调用方法中的事务 |'
- en: '| `REQUIRED` | No | T1 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `REQUIRED` | 无 | T1 |'
- en: '| T1 | T1 | `SUPPORTS` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| T1 | T1 | `SUPPORTS` |'
- en: '| No | No | T1 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 无 | T1 |'
- en: '| T1 | `MANDATORY` | No |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| T1 | `MANDATORY` | 无 |'
- en: '| Exception | T1 | T1 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 异常 | T1 | T1 |'
- en: '| `REQUIRES_NEW` | No | T1 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `REQUIRES_NEW` | 无 | T1 |'
- en: '| T1 | T2 | `NOT_SUPPORTED` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| T1 | T2 | `NOT_SUPPORTED` |'
- en: '| No | No | T1 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 无 | T1 |'
- en: '| No | `NEVER` | No |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 无 | `NEVER` | 无 |'
- en: '| No | T1 | Exception |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 无 | T1 | 异常 |'
- en: '| `NESTED` | No | T1 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `NESTED` | 无 | T1 |'
- en: '| T1 | T2 with savepoint |  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| T1 | 带保存点的T2 |  |'
- en: 11.4.2 Transaction rollback
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 事务回滚
- en: 'Spring transactions define the default rollback rules: a transaction will be
    rolled back for `RuntimeException`. This behavior can be overwritten and we can
    specify which exceptions automatically roll back the transaction and which will
    not. This is done with the help of the `@Transactional` annotation properties
    `rollbackFor`, `rollbackForClassName`, `noRollbackFor`, `noRollbackForClassName`.
    The behavior determined by these properties is summarized in table 11.3.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Spring事务定义了默认的回滚规则：对于 `RuntimeException`，事务将被回滚。此行为可以被覆盖，并且我们可以指定哪些异常会自动回滚事务，哪些不会。这是通过
    `@Transactional` 注解属性 `rollbackFor`、`rollbackForClassName`、`noRollbackFor`、`noRollbackForClassName`
    来实现的。这些属性确定的行为总结在表11.3中。
- en: Table 11.3 Transaction rollback rules
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.3 事务回滚规则
- en: '| Property | Type | Behavior |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 类型 | 行为 |'
- en: '| `rollbackFor` | Array of `Class` objects extending `Throwable` | Defines
    exception classes that must cause rollback |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `rollbackFor` | 扩展 `Throwable` 的 `Class` 对象数组 | 定义必须导致回滚的异常类 |'
- en: '| `rollbackForClassName` | Array of class names extending `Throwable` | Defines
    exception class names that must cause rollback |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `rollbackForClassName` | 扩展 `Throwable` 的类名数组 | 定义必须导致回滚的异常类名 |'
- en: '| `noRollbackFor` | Array of `Class` objects extending `Throwable` | Defines
    exception classes that must not cause rollback |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `noRollbackFor` | 扩展 `Throwable` 的 `Class` 对象数组 | 定义必须不导致回滚的异常类 |'
- en: '| `noRollbackForClassName` | Array of class names extending `Throwable` | Defines
    exception class names that must not cause rollback |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `noRollbackForClassName` | 扩展 `Throwable` 的类名数组 | 定义必须不导致回滚的异常类名 |'
- en: 11.4.3 Transaction properties
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 事务属性
- en: The `@Transactional` annotation defines the properties in table 11.4\. We’ll
    deal here with the already examined isolation and propagation and with other properties.
    All the meta-information will be transposed at the level of how the transactional
    operation is executed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional` 注解定义了表11.4中的属性。在这里，我们将处理已经检查的隔离和传播以及其他属性。所有元信息都将转换到事务性操作执行的水平。'
- en: Table 11.4 `@Transactional` annotation properties
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.4 `@Transactional` 注解属性
- en: '| Property | Type | Behavior |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 类型 | 行为 |'
- en: '| `isolation` | `Isolation` enum | Declares the isolation levels, following
    the ANSI standard. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `isolation` | `Isolation` 枚举 | 声明隔离级别，遵循ANSI标准。|'
- en: '| `propagation` | `Propagation` enum | Propagation settings following the values
    from table 11.2. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `propagation` | `Propagation` 枚举 | 遵循表11.2中的值的传播设置。|'
- en: '| `timeout` | `int` (seconds) | Timeout after which the transaction will automatically
    roll back. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `timeout` | `int`（秒）| 超时后事务将自动回滚。|'
- en: '| `readOnly` | `boolean` | Declares if the transaction is read-only or read-write.
    Read-only transactions allow optimizations that can make them faster. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `readOnly` | `boolean` | 声明事务是只读的还是读写。只读事务允许进行优化，从而使其更快。|'
- en: The `@Transactional` annotation can be applied to interfaces, to methods in
    interfaces, to classes, or to methods in classes. Once applied to an interface
    or to a class, the annotation is taken over by all methods from that class or
    from that interface. You can change the behavior by annotating particular methods
    in a different way. Also, once it’s applied to an interface or to a method in
    an interface, the annotation is taken over by the classes implementing that interface
    or by the corresponding methods from the classes implementing that interface.
    The behavior can be overwritten. Consequently, for fine-grained behavior, it is
    advisable to apply the `@Transactional` annotation to methods from classes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`注解可以应用于接口、接口中的方法、类或类中的方法。一旦应用于接口或类，注解就会接管该类或接口的所有方法。您可以通过以不同的方式注解特定方法来更改行为。此外，一旦应用于接口或接口中的方法，注解就会由实现该接口的类或实现该接口的相应方法接管。行为可以被覆盖。因此，为了实现细粒度的行为，建议将`@Transactional`注解应用于类的方法。'
- en: 11.4.4 Programmatic transaction definition
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4 程序化事务定义
- en: Declarative transaction management is generally the way to go when using Spring
    in an application. It requires less code to write, and the behavior is determined
    through the meta-information provided by the annotations. However, programmatic
    transaction management is still possible, using the `TransactionTemplate` class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Spring的应用程序时，声明式事务管理通常是首选的方法。它需要编写的代码更少，行为是通过注解提供的元信息确定的。然而，仍然可以使用`TransactionTemplate`类进行程序化事务管理。
- en: 'Once a `TransactionTemplate` object is created, the behavior of the transaction
    can be defined programmatically, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建`TransactionTemplate`对象，就可以通过以下方式程序化地定义事务的行为：
- en: '[PRE17]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once defined, a `TransactionTemplate` object supports the callback approach
    through the `execute` method, which receives a `TransactionCallback` as an argument,
    as in the following code. The operations to be executed in the transaction are
    defined in the `doInTransaction` method.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，`TransactionTemplate`对象通过`execute`方法支持回调方法，该方法接收一个`TransactionCallback`作为参数，如下面的代码所示。事务中要执行的操作在`doInTransaction`方法中定义。
- en: '[PRE18]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As `TransactionCallback` is a functional interface (it even bears the `@FunctionalInterface`
    annotation), the preceding snippet could be shortened as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`TransactionCallback`是一个函数式接口（它甚至带有`@FunctionalInterface`注解），前面的代码片段可以缩短如下：
- en: '[PRE19]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 11.4.5 Transactional development with Spring and Spring Data
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.5 使用Spring和Spring Data进行事务开发
- en: We have been working on the CaveatEmptor application, and now we’re going to
    implement a feature that logs the results of our actions when we work with items.
    We’ll start the implementation using Spring Data JPA, and we’ll first create the
    `ItemRepositoryCustom` interface and its methods, as shown in listing 11.8\. Such
    an interface is known as a *fragment interface*, and its purpose is to extend
    a repository with custom functionality, which will be provided by a later implementation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在开发CaveatEmptor应用程序，现在我们准备实现一个功能，该功能将记录我们在处理项目时的操作结果。我们将使用Spring Data JPA开始实现，首先创建`ItemRepositoryCustom`接口及其方法，如列表11.8所示。这样的接口被称为*片段接口*，其目的是通过自定义功能扩展仓库，这些功能将由后续实现提供。
- en: Listing 11.8 The `ItemRepositoryCustom` interface
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 `ItemRepositoryCustom`接口
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we’ll create an `ItemRepository` interface, extending both `JpaRepository`
    and the previously declared `ItemRepositoryCustom` interface. Additionally, we’ll
    declare the `findByName` method, following the Spring Data JPA naming conventions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`ItemRepository`接口，它扩展了`JpaRepository`和之前声明的`ItemRepositoryCustom`接口。此外，我们将声明`findByName`方法，遵循Spring
    Data JPA的命名约定。
- en: Listing 11.9 The `ItemRepository` interface
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 `ItemRepository`接口
- en: '[PRE21]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ll then create the `LogRepositoryCustom` interface and its methods, as shown
    in listing 11.10\. Again, this is a fragment interface, and its purpose is to
    extend a repository with custom functionality that will be provided by a later
    implementation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建 `LogRepositoryCustom` 接口及其方法，如列表 11.10 所示。同样，这是一个片段接口，其目的是扩展存储库以提供由后续实现提供的自定义功能。
- en: Listing 11.10 The `LogRepositoryCustom` interface
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 `LogRepositoryCustom` 接口
- en: '[PRE22]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ll now create the `LogRepository` interface, extending both `JpaRepository`
    and the previously declared `LogRepositoryCustom` interface.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建 `LogRepository` 接口，它扩展了 `JpaRepository` 以及之前声明的 `LogRepositoryCustom`
    接口。
- en: Listing 11.11 The `LogRepository` interface
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 `LogRepository` 接口
- en: '[PRE23]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ll provide an implementation class for `ItemRepository` next. The key part
    of this class name is the `Impl` ending. It is not connected to Spring Data and
    it only implements `ItemRepositoryCustom`. When injecting an `ItemRepository`
    bean, Spring Data will have to create a proxy class; it will detect that `ItemRepository`
    implements `ItemRepositoryCustom` and will look up a class called `ItemRepositoryImpl`
    to act as a custom repository implementation. Consequently, the methods of the
    injected `ItemRepository` bean will have the same behavior as the methods of the
    `Item-RepositoryImpl` class.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `ItemRepository` 提供一个实现类。这个类名中的 `Impl` 结尾是关键部分。它与 Spring Data 无关，并且仅实现了
    `ItemRepositoryCustom`。在注入 `ItemRepository` 实例时，Spring Data 必须创建一个代理类；它将检测到 `ItemRepository`
    实现了 `ItemRepositoryCustom`，并将查找名为 `ItemRepositoryImpl` 的类作为自定义存储库实现。因此，注入的 `ItemRepository`
    实例的方法将与 `ItemRepositoryImpl` 类的方法具有相同的行为。
- en: Listing 11.12 The `ItemRepositoryImpl` class
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 `ItemRepositoryImpl` 类
- en: '[PRE24]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ⓐ Autowiring an `ItemRepository` and a `LogRepository` bean.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 自动装配 `ItemRepository` 和 `LogRepository` 实例。
- en: 'Ⓑ `MANDATORY` propagation: Spring Data will check if a transaction is already
    in progress and will continue with it. Otherwise, an exception will be thrown.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `MANDATORY` 传播行为：Spring Data 将检查是否已有事务正在进行，并继续使用该事务。否则，将抛出异常。
- en: Ⓒ Throw a `DuplicateItemNameException` if an `Item` with the given name already
    exists.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 如果存在具有给定名称的 `Item`，则抛出 `DuplicateItemNameException`。
- en: Ⓓ Default propagation is `REQUIRED`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 默认传播行为是 `REQUIRED`。
- en: Ⓔ No rollback of the transaction in the case of a `DuplicateItemNameException`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 在出现 `DuplicateItemNameException` 的情况下不会回滚事务。
- en: Next we’ll provide an implementation class for `LogRepository`. As was the case
    for `ItemRepositoryImpl,` the key part of this class name is the `Impl` ending.
    It only implements `LogRepositoryCustom`. When we inject a `LogRepository` bean,
    Spring Data will detect that `LogRepository` implements `LogRepositoryCustom`
    and will look up a class called `LogRepositoryImpl` to act as a custom repository
    implementation. Consequently, the methods of the injected `LogRepository` bean
    will have the same behavior as the methods of the `LogRepositoryImpl` class.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `LogRepository` 提供一个实现类。正如 `ItemRepositoryImpl` 的情况一样，这个类名中的 `Impl`
    结尾是关键部分。它仅实现了 `LogRepositoryCustom`。当我们注入 `LogRepository` 实例时，Spring Data 将检测到
    `LogRepository` 实现了 `LogRepositoryCustom`，并将查找名为 `LogRepositoryImpl` 的类作为自定义存储库实现。因此，注入的
    `LogRepository` 实例的方法将与 `LogRepositoryImpl` 类的方法具有相同的行为。
- en: Listing 11.13 The `LogRepositoryImpl` class
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 `LogRepositoryImpl` 类
- en: '[PRE25]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ⓐ Autowiring a `LogRepository` bean.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 自动装配 `LogRepository` 实例。
- en: Ⓑ `REQUIRES_NEW` propagation. Spring Data will execute the logging in a separate
    transaction, independent of the eventual transaction of the method that called
    `log`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `REQUIRES_NEW` 传播行为。Spring Data 将在单独的事务中执行日志记录，独立于调用 `log` 方法的最终事务。
- en: Ⓒ The `log` method will save a message to the repository.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `log` 方法会将消息保存到存储库中。
- en: Ⓓ `NOT_SUPPORTED` propagation. If a transaction is in progress, it will be suspended
    and a non-transactional execution will continue. Otherwise, the execution will
    simply continue.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `NOT_SUPPORTED` 传播行为。如果已有事务正在进行，它将被挂起，并将继续执行非事务性操作。否则，执行将简单地继续。
- en: Ⓔ `SUPPORTS` propagation. If a transaction is in progress, the execution will
    continue within that transaction. Otherwise, no transaction will be created.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `SUPPORTS` 传播行为。如果已有事务正在进行，执行将在该事务内继续。否则，不会创建事务。
- en: Ⓕ `NEVER` propagation. If a transaction is in progress, an `IllegalTransactionStateException`
    will be thrown. Otherwise, the execution will simply continue.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `NEVER` 传播行为。如果已有事务正在进行，将抛出 `IllegalTransactionStateException`。否则，执行将简单地继续。
- en: We’ll now write a series of tests to verify the behavior of the transactional
    methods we have just written.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一系列测试来验证我们刚刚编写的交易方法的操作行为。
- en: Listing 11.14 The `TransactionPropagationTest` class
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 `TransactionPropagationTest` 类
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ⓐ Autowiring an `ItemRepository` and a `LogRepository` bean.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 自动装配 `ItemRepository` 和 `LogRepository` 实例。
- en: Ⓑ Before the execution of each test, all `Item` entities and all `Log` entities
    are removed from the repositories.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 在每个测试执行之前，所有 `Item` 实体和所有 `Log` 实体都会从仓库中移除。
- en: Ⓒ The `addLogs` method starts a transaction, but it calls the `addSeparateLogsNotSupported`
    method, which will suspend the started transaction before explicitly throwing
    an exception.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `addLogs` 方法启动一个事务，但它调用 `addSeparateLogsNotSupported` 方法，这将在显式抛出异常之前挂起已启动的事务。
- en: Ⓓ Before an exception was thrown, the `logRepository` was able to save one message.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 在抛出异常之前，`logRepository` 能够保存一条消息。
- en: Ⓔ The `showLog` method will display one message in a non-transactional way.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `showLog` 方法将以非事务方式显示一条消息。
- en: Ⓕ The `addSeparateLogsSupports` method will explicitly throw an exception.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `addSeparateLogsSupports` 方法将显式抛出异常。
- en: Ⓖ Before an exception was thrown, the `logRepository` was able to save one message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 在抛出异常之前，`logRepository` 能够保存一条消息。
- en: Ⓗ The `showLog` method will display one message in a non-transactional way.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ `showLog` 方法将以非事务方式显示一条消息。
- en: Ⓘ The `checkNameDuplicate` method can be executed only in a transaction, so
    an `IllegalTransactionStateException` will be thrown when calling it without a
    transaction. We also check the message from the exception.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ `checkNameDuplicate` 方法只能在事务中执行，因此在没有事务的情况下调用它将抛出 `IllegalTransactionStateException`。我们还会检查异常中的消息。
- en: Ⓙ After adding an `Item` to the repository, it is safe to call the `showLogs`
    method from `LogRepository` without a transaction.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 在将 `Item` 添加到仓库后，可以安全地从 `LogRepository` 调用 `showLogs` 方法而不需要事务。
- en: Ⓚ However, we cannot call the `showLogs` method from `LogRepository` within
    a transaction, as the calling method `showLogs` from `ItemRepository` is transactional.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 然而，我们无法在事务中从 `LogRepository` 调用 `showLogs` 方法，因为从 `ItemRepository` 调用的 `showLogs`
    方法是事务性的。
- en: Ⓛ Trying to insert a duplicate `Item` in the repository will throw a `DuplicateItemNameException`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 尝试在仓库中插入重复的 `Item` 将会抛出 `DuplicateItemNameException`。
- en: Ⓜ However, a log message is persisted in the logs even after exception, because
    it was added in a separate transaction.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 然而，即使在异常之后，日志消息也会持久化，因为它是在单独的事务中添加的。
- en: Ⓝ The repository will contain 4 `Log` messages (one for each attempt to insert
    an `Item`, successful or unsuccessful), but only 3 `Item`s (the duplicate `Item`
    was rejected).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 仓库将包含 4 条 `Log` 消息（每个尝试插入一个 `Item`，无论成功与否），但只有 3 个 `Item`（重复的 `Item` 被拒绝）。
- en: Ⓞ Trying to insert a duplicate `Item` in the repository will throw a `DuplicateItemNameException`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 尝试在仓库中插入重复的 `Item` 将会抛出 `DuplicateItemNameException`。
- en: Ⓟ However, a log message is persisted in the logs even after the exception,
    because the transaction was not rolled back. The `addItemNoRollback` method from
    `ItemRepository` does not roll back for `DuplicateItemNameException`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓟ 然而，即使在异常之后，日志消息也会持久化，因为事务没有被回滚。`ItemRepository` 的 `addItemNoRollback` 方法不会对
    `DuplicateItemNameException` 进行回滚。
- en: Ⓠ The repository will contain 4 `Log` messages (one for each attempt to insert
    an `Item`, successful or unsuccessful), but only 3 `Item`s (the duplicate `Item`
    was rejected).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓠ 仓库将包含 4 条 `Log` 消息（每个尝试插入一个 `Item`，无论成功与否），但只有 3 个 `Item`（重复的 `Item` 被拒绝）。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Hibernate relies on a database’s concurrency-control mechanism but provides
    better isolation guarantees in a transaction, thanks to automatic versioning and
    the persistence context cache.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 依赖于数据库的并发控制机制，但由于自动版本化和持久化上下文缓存，在事务中提供了更好的隔离保证。
- en: Transaction boundaries can be set programmatically, and you can handle exceptions.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务边界可以编程设置，并且您可以处理异常。
- en: You can use optimistic concurrency control and explicit pessimistic locking.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用乐观并发控制和显式悲观锁定。
- en: You can work with auto-commit mode and an unsynchronized persistence context
    outside of a transaction.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在事务之外使用自动提交模式和未同步的持久化上下文。
- en: You can work with transactions with Spring and Spring Data, defining and configuring
    transactions using various properties.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Spring 和 Spring Data 与事务一起工作，使用各种属性定义和配置事务。
