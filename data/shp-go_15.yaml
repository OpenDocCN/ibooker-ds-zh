- en: Appendix A. Using Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 使用 Kotlin
- en: Throughout the book, I have mentioned that software development and code maintenance
    patterns are not limited to a single language or technology, so the following
    sections will quickly demonstrate how to introduce these same processes using
    three popular languages, Kotlin, JavaScript, and Python, and present an alternate
    deployment option using tools from HashiCorp. To start, we’ll look into Kotlin,
    a language built on the JVM and growing in popularity as it matures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我提到软件开发和代码维护模式并不局限于单一的语言或技术，因此以下章节将快速展示如何使用三种流行的语言（Kotlin、JavaScript 和
    Python）引入这些相同的流程，并使用 HashiCorp 的工具提供另一种部署选项。首先，我们将探讨 Kotlin，这是一种建立在 JVM 之上的语言，随着其成熟度的提高而越来越受欢迎。
- en: Kotlin has the benefit of being built on top of existing technologies in Java,
    which means that the tools and patterns are fairly mature. We will build a new
    CI pipeline using Kotlin-specific tools, but the steps will remain mostly the
    same in our Makefile. To start, we will build our hello-api again using Kotlin
    and Redis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的好处是它建立在现有的 Java 技术之上，这意味着工具和模式相当成熟。我们将使用 Kotlin 特定的工具构建一个新的 CI 流水线，但在我们的
    Makefile 中步骤将保持基本相同。首先，我们将使用 Kotlin 和 Redis 再次构建我们的 hello-api。
- en: A.1 Frameworks
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 框架
- en: 'Frameworks both aid and hinder development teams. Sometimes a framework will
    help you launch your product quickly, but over time, you may find that you struggle
    against it, losing your momentum. Taking the time to research available frameworks
    and reassessing the ones you are using are very important. Look for these features:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 框架既帮助又阻碍开发团队。有时一个框架可以帮助你快速推出产品，但过了一段时间，你可能会发现你在与之抗争，失去了势头。花时间研究可用的框架并重新评估你正在使用的框架非常重要。寻找以下特性：
- en: Ease of use
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性
- en: Documentation quality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档质量
- en: Viability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可持续性
- en: 'All three are very important. You don’t want to use a framework that is obscure
    and no longer supported because bugs and vulnerabilities may arise, and you will
    not be able to fix them. At the same time, you don’t want to adopt a framework
    that doesn’t support the technology you want to use. In the Java development world,
    an up-and-coming framework called Quarkus fits all these criteria. Luckily, this
    framework can be used with Kotlin and was built to run in container-based ecosystems.
    Developed and supported by Red Hat, Quarkus provides many drivers and out-of-the-box
    tools to help rapidly build and test APIs. To set it up, follow these steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三点都非常重要。你不想使用一个晦涩且不再受支持的框架，因为可能会出现错误和漏洞，而你将无法修复它们。同时，你也不想采用不支持你想要使用的技术框架。在
    Java 开发世界中，一个新兴的框架 Quarkus 符合所有这些标准。幸运的是，这个框架可以与 Kotlin 一起使用，并且是为了在基于容器的生态系统中运行而构建的。由
    Red Hat 开发和支持的 Quarkus 提供了许多驱动程序和开箱即用的工具，以帮助快速构建和测试 API。要设置它，请按照以下步骤操作：
- en: Install Java ([http://mng.bz/e1mz](http://mng.bz/e1mz)).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Java ([http://mng.bz/e1mz](http://mng.bz/e1mz))。
- en: Go to code.quarkus.io.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往 code.quarkus.io。
- en: Name the group `com.manning` and the artifact `hello-api`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组命名为 `com.manning`，工件命名为 `hello-api`。
- en: Keep the Build Tool as Maven, Java Version 17.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持构建工具为 Maven，Java 版本 17。
- en: In the filters section, add Kotlin, RESTEasy Reactive Kotlin Serialization,
    and Redis Client.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过滤器部分，添加 Kotlin、RESTEasy Reactive Kotlin Serialization 和 Redis 客户端。
- en: Click Generate your application, and open your project.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击生成您的应用程序，并打开您的项目。
- en: NOTE Spring is a big player in Java/Kotlin frameworks and has excellent documentation
    in both Java and Kotlin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Spring 是 Java/Kotlin 框架中的大玩家，在 Java 和 Kotlin 中都有优秀的文档。
- en: Once these steps are complete, we can unzip our project and get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们可以解压我们的项目并开始工作。
- en: A.2 Coding
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 编码
- en: Quarkus gives us a lot without us needing to do anything. Like many modern JVM-based
    frameworks, Quarkus makes extensive use of annotations to take care of most of
    the wiring. This can be extremely helpful but also a mystery when it comes time
    for debugging. We first create four files in our `com/manning/hello-api` package.
    First is the main function, which we will call `TranslationResource.kt`. This
    will be our entry point for translations, as shown in the following listing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 给我们很多，我们不需要做任何事情。像许多现代基于 JVM 的框架一样，Quarkus 广泛使用注解来处理大部分的连接。这可以非常有帮助，但在调试时也可能是一个谜。我们首先在我们的
    `com/manning/hello-api` 包中创建四个文件。首先是主函数，我们将称之为 `TranslationResource.kt`。这将是我们的翻译入口点，如下所示。
- en: Listing A.1 `TranslationResource.kt`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.1 `TranslationResource.kt`
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Base path for the request
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 请求的基本路径
- en: ❷ Dependency injection of translation service
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 依赖注入翻译服务
- en: ❸ REST GET method
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ REST GET 方法
- en: ❹ Subpath for request
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 请求的子路径
- en: ❺ Call service based on path and query params
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 根据路径和查询参数调用服务
- en: When our application starts, Quarkus will look for all of our paths and add
    them to the main controller, just like we did manually in Go. There is nothing
    special about this code other than that we mount an interface as our service to
    handle the translation. This interface will act as a barrier behind the actual
    Redis implementation, just like we did in Go. That interface is defined in `ITranslationService.kt`
    as in the following listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序启动时，Quarkus 将查找我们所有的路径并将它们添加到主控制器中，就像我们在 Go 中手动做的那样。这段代码没有特别之处，除了我们将一个接口作为我们的服务来处理翻译。这个接口将作为实际
    Redis 实现背后的屏障，就像我们在 Go 中做的那样。这个接口在 `ITranslationService.kt` 中定义，如下所示。
- en: Listing A.2 `ITranslationResource.kt`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.2 `ITranslationResource.kt`
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines interface method that returns optional translation object
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义返回可选翻译对象的接口方法
- en: Pretty simple, right? It’s almost exactly the same as our Go interface. We optionally
    return a Translation type. This is defined in a separate `Translation.kt` file
    which will replicate our Translation struct from Go (see the following listing).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？它几乎和我们的 Go 接口完全一样。我们可选地返回一个 Translation 类型。这个类型在单独的 `Translation.kt`
    文件中定义，它将复制我们的 Go 中的 Translation 结构（见以下列表）。
- en: Listing A.3 `TranslationResource.kt`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.3 `TranslationResource.kt`
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates a data class or DTO for messages
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为消息创建数据类或 DTO
- en: Finally, we can get to the Redis connection. Here, we have a bit more code (see
    the next listing) and the actual retrieval from Redis itself.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以进入 Redis 连接。在这里，我们有一些更多的代码（见下一条列表）以及从 Redis 本身实际检索的内容。
- en: Listing A.4 `RedisTranslationService.kt`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.4 `RedisTranslationService.kt`
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Injects Redis client
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注入 Redis 客户端
- en: ❷ Sets default language from config
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从配置中设置默认语言
- en: ❸ Gets translation from Redis
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 Redis 获取翻译
- en: In order for Redis to connect, we need to provide some properties that it can
    grab to connect. These values can be overridden, just like in Go, by passing in
    environmental variables. By default, we want to use localhost, so we will fill
    out our `resources/application.properties` file like this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Redis 连接，我们需要提供一些它可以用来自连接的属性。这些值可以被覆盖，就像在 Go 中一样，通过传递环境变量。默认情况下，我们希望使用 localhost，所以我们将填写我们的
    `resources/application.properties` 文件，如下所示。
- en: Listing A.5 `application.properties`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.5 `application.properties`
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Default property of where to connect to Redis
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 连接到 Redis 的默认属性
- en: Now that we have the code, let’s introduce how we build and run it. Then we
    will use this for testing. Finally, we’ll wrap this all in a pipeline.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了代码，让我们介绍一下如何构建和运行它。然后我们将用它来进行测试。最后，我们将所有这些封装在一个管道中。
- en: A.3 Maven
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 Maven
- en: Maven is a build tool under the Apache project that allows Java developers to
    manage their project dependencies (like our `go.mod` file) as well as incorporate
    different build and testing scripts (like our Makefile). Other build tools such
    as Gradle can be used to fulfill similar tasks. In this section, we will focus
    on using Maven. Maven projects are managed by using a `pom.xml` file, which you
    will find at the root of the setup project you downloaded along with an `mvnw`
    script. This script is a wrapper around basic Maven tooling so that developers
    don’t need to worry about environment-specific variables (e.g., their operating
    system and base Maven file).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 是 Apache 项目下的一个构建工具，它允许 Java 开发者管理他们的项目依赖（如我们的 `go.mod` 文件），以及整合不同的构建和测试脚本（如我们的
    Makefile）。其他构建工具，如 Gradle，也可以用来完成类似任务。在本节中，我们将专注于使用 Maven。Maven 项目是通过使用一个 `pom.xml`
    文件来管理的，你将在你下载的设置项目的根目录中找到它，还有一个 `mvnw` 脚本。这个脚本是一个围绕基本 Maven 工具的包装器，这样开发者就不需要担心环境特定的变量（例如，他们的操作系统和基本
    Maven 文件）。
- en: We will use Maven to build, run, and test our code. First, let’s run what we’ve
    written. Make sure you have your Redis database running, and then type in `./mvnw
    compile` `quarkus:dev` in a terminal window. You’ll see a bunch of files being
    downloaded and then compiled, and finally you’ll see a message that says the server
    is listening. At this point, try your trusty `curl` commands from previous chapters
    to test it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Maven 来构建、运行和测试我们的代码。首先，让我们运行我们编写的代码。确保你的 Redis 数据库正在运行，然后在终端窗口中输入 `./mvnw
    compile` `quarkus:dev`。你会看到许多文件被下载和编译，最后你会看到一个消息说服务器正在监听。在这个时候，尝试你之前章节中的可靠 `curl`
    命令来测试它。
- en: Now that we have an understanding of how Maven looks, we will use it for running
    our unit tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Maven 的样子，我们将用它来运行我们的单元测试。
- en: A.4 Testing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 测试
- en: For our testing example, we will jump right into integration tests because they
    give us a sense of how tests are written in Kotlin, and integration tests typically
    are more involved at setup and teardown. This will give us a great overview while
    providing a jumping-off place to fill in the rest of the testing pyramid. For
    our test, we again use a container for the database and a library called RestAssured,
    which will give us a nice REST testing framework for verification. To get started,
    create a file called `TranslationTest.kt` in the test folder (see the following
    listing).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试示例，我们将直接进入集成测试，因为它们让我们了解 Kotlin 中测试的编写方式，集成测试通常在设置和清理方面更为复杂。这将为我们提供一个很好的概述，同时提供一个起点来填充测试金字塔的其余部分。对于我们的测试，我们再次使用数据库容器和一个名为
    RestAssured 的库，它将为我们提供一个用于验证的优秀的 REST 测试框架。要开始，在测试文件夹中创建一个名为 `TranslationTest.kt`
    的文件（见以下列表）。
- en: Listing A.6 `TranslationTest.kt`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.6 `TranslationTest.kt`
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Depends on a container
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 依赖于一个容器
- en: ❷ Tells the build tool that this is a test
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉构建工具这是一个测试
- en: ❸ Tests the request using fluent assertion
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用流畅断言测试请求
- en: The tests should seem familiar from earlier in the book. Now we need to create
    another file that tells our testing plugin that this particular test is an integration
    test. To do that, we simply create a file with the content in the following listing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该与书中早些时候的内容相似。现在我们需要创建另一个文件，告诉我们的测试插件这个特定的测试是一个集成测试。为此，我们只需创建一个包含以下列表内容的文件。
- en: Listing A.7 `TranslationTest.kt`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.7 `TranslationTest.kt`
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Defines this test suite as an integration test
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将此测试套件定义为集成测试
- en: That’s it! Finally, we need our database container to run our tests against.
    To do this, we add a dependency to our `pom.xml` file. There, under dependencies,
    you will add the lines in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！最后，我们需要我们的数据库容器来运行测试。为此，我们在 `pom.xml` 文件中添加一个依赖项。在那里，在依赖项下，你将添加以下列表中的行。
- en: Listing A.8 `pom.xml`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.8 `pom.xml`
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we create a file called `RedisTestContainer.kt` and add the code in the
    following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个名为 `RedisTestContainer.kt` 的文件，并添加以下列表中的代码。
- en: Listing A.9 `RedisTestContainer.kt`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.9 `RedisTestContainer.kt`
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates a redis container with the mounted data directory
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个带有挂载数据目录的 Redis 容器
- en: ❷ Establishes a command map for retrieving messages
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 建立一个命令映射以检索消息
- en: That’s it! To test, run `./mvnw` `clean` `test`, and you will see your test
    run successfully!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！要测试，运行 `./mvnw` `clean` `test`，你将看到你的测试成功运行！
- en: A.5 Linting and the initial pipeline
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 检查和初始管道
- en: For linting, we use an open source tool called `ktlint`, which is written and
    maintained by Pinterest as an open source project. It supports both a downloadable,
    standalone app as well as a Maven plugin. Here, we will use the prebuilt binary
    to make installation a little more straightforward. We often make linting the
    first step of our pipeline because it is the simplest and often the fastest step
    to run. Let’s create our pipeline up to build and deploy, which we will finalize
    in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检查，我们使用一个名为 `ktlint` 的开源工具，它是由 Pinterest 作为开源项目编写和维护的。它支持可下载的独立应用程序以及 Maven
    插件。在这里，我们将使用预构建的二进制文件，使安装更加简单直接。我们通常将检查作为管道的第一步，因为它是最简单且通常是运行最快的步骤。让我们创建我们的管道，直到构建和部署，我们将在下一节中完成。
- en: Create a new workflow file in `.github/workflows/pipeline.yml` using the code
    in the following listing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.github/workflows/pipeline.yml` 中创建一个新的工作流程文件，使用以下列表中的代码。
- en: Listing A.10 `pipeline.kt`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.10 `pipeline.kt`
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Defines the Java version
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义 Java 版本
- en: ❷ Installs and runs ktlint
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安装并运行 ktlint
- en: ❸ Deletes all old files and runs tests
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 删除所有旧文件并运行测试
- en: If you commit your changes and push them, you should see the tests run and the
    lint pass!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提交了更改并推送，你应该能看到测试运行并通过检查！
- en: A.6 Containerizing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 容器化
- en: The final step is putting this application into a container. To do this, we
    use another neat Quarkus trick. In recent years, specialized compilers have been
    developed to allow Java code to be compiled into native system code. This allows
    your containers and packages to be smaller in size and to run faster. Additionally,
    you no longer need to be as concerned about JVM security patches and updates;
    instead, you only need to worry about the OS’s security problems. Quarkus has
    taken this technology and added it to the build system for Quarkus apps. Quarkus
    even provides you with the Maven steps and Docker container to use, so right away
    we can add the last job to our pipeline and verify that it works (see the following
    listing).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将这个应用程序放入容器中。为此，我们使用另一个巧妙的Quarkus技巧。近年来，已经开发出专门的编译器，允许Java代码编译成本地系统代码。这使得你的容器和包体积更小，运行速度更快。此外，你也不再需要过分关注JVM的安全补丁和更新；相反，你只需要担心操作系统的安全问题。Quarkus已经将这项技术添加到Quarkus应用程序的构建系统中。Quarkus甚至为你提供了Maven步骤和Docker容器来使用，因此我们可以立即将最后一个任务添加到我们的管道中，并验证它是否工作（见以下列表）。
- en: Listing A.11 `pipeline.kt`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.11 `pipeline.kt`
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Builds a native Java binary
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建本机Java二进制文件
- en: ❷ Uses an internal Dockerfile to build a container
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用内部Dockerfile构建容器
- en: ❸ Pushes the container to the registry
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将容器推送到注册表
- en: Once you’ve pushed this last change, download your container or deploy it to
    your Kubernetes cluster to see how it works!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你推送了最后一个更改，下载你的容器或将其部署到你的Kubernetes集群中，看看它是如何工作的！
- en: Kotlin and Quarkus are both relatively new in the world of Java-based languages
    and frameworks. This makes them poised to meet the challenges of current software
    development. While this chapter just touches the surface, I encourage you to dig
    deeper and experiment more because JVM languages are not going away, and you may
    find a lot of work in helping migrate and improve Java applications in the future.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin和Quarkus在Java语言和框架的世界中都是相对较新的。这使得它们准备好应对当前软件开发中的挑战。虽然本章只是触及了表面，但我鼓励你深入挖掘并多做实验，因为JVM语言不会消失，你可能会在未来发现很多帮助迁移和改进Java应用程序的工作。
