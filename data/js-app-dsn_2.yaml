- en: Appendix A. Modules in Node.js
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A. Node.js中的模块
- en: This appendix covers things you need to know about modules and Node.js to use
    both effectively in your Grunt builds. Node.js is a platform built on top of the
    V8 JavaScript engine, the same engine that makes JavaScript in Google Chrome a
    reality. Grunt, the build tool you use in this book, runs on Node. Node is single
    threaded, as all JavaScript is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录涵盖了你在Grunt构建中使用模块和Node.js时需要了解的内容。Node.js是一个建立在V8 JavaScript引擎之上的平台，这个引擎使得Google
    Chrome中的JavaScript成为现实。本书中使用的构建工具Grunt运行在Node上。Node是单线程的，就像所有的JavaScript一样。
- en: Node comes with a nice little companion command-line interface (CLI) utility
    called `npm`, which is used to fetch and install packages from the node-packaged
    modules registry. Throughout the book, you’ll learn how to use the `npm` tool
    as needed. Let’s install Node.js first, since `npm` comes bundled with it!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node附带了一个小巧的命令行界面（CLI）实用工具，名为`npm`，用于从node-packaged模块注册表中检索和安装包。在整个书中，你将学习如何根据需要使用`npm`工具。让我们首先安装Node.js，因为`npm`是捆绑在一起的！
- en: A.1\. Installing Node.js
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1. 安装Node.js
- en: You have a few options for installing Node. If you’re the point-and-click type,
    then you might want to head over to their website, [http://nodejs.org](http://nodejs.org),
    and click on the big green Install button. Once the binaries are downloaded, unpack
    them if needed, and then double-click to install them. That’s it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node有多种选择。如果你是点击类型的人，那么你可能想去他们的网站[http://nodejs.org](http://nodejs.org)，点击那个大绿色的安装按钮。一旦二进制文件下载完成，如果需要，解压它们，然后双击安装。就这样。
- en: 'If you prefer to install things in your terminal, consider `nvm`, a user-created
    Node version manager. To install `nvm`, you can type the following line into your
    terminal:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在终端中安装东西，可以考虑使用`nvm`，这是一个用户创建的Node版本管理器。要安装`nvm`，你可以在你的终端中输入以下行：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once `nvm` is installed, reopen your terminal window to get access to the `nvm`
    CLI. If you have any issues installing `nvm`, refer to their public repository
    at [https://github.com/creationix/nvm](https://github.com/creationix/nvm). Once
    you have `nvm` you can install a version of Node, as shown in the following code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`nvm`，重新打开你的终端窗口以获取对`nvm` CLI的访问权限。如果你在安装`nvm`时遇到任何问题，请参考他们的公共仓库[https://github.com/creationix/nvm](https://github.com/creationix/nvm)。一旦你有了`nvm`，你就可以安装Node的一个版本，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first command installs the latest stable version of Node in the `0.10.x`
    branch. The second command makes it so that any terminal window you open from
    now on will have access to the Node version you installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令安装了`0.10.x`分支的最新稳定版本的Node。第二个命令使得从现在开始打开的任何终端窗口都可以访问你安装的Node版本。
- en: Great, now you have Node! Time for you to learn more about its module system,
    which is based on the CommonJS module’s spec.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在你有了Node！是时候学习更多关于它的模块系统了，该系统基于CommonJS模块规范。
- en: A.2\. The module system
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2. 模块系统
- en: Node applications have an entry point that’s specified when executing a node
    process. For example, if you run `node app.js`, your Node process will use `app.js`
    as the entry point. To load other pieces of code, you have to use the `require`
    function. This function takes a path and loads the module found in that location.
    The path passed to `require` can be
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node应用程序在执行node进程时指定一个入口点。例如，如果你运行`node app.js`，你的Node进程将使用`app.js`作为入口点。要加载其他代码片段，你必须使用`require`函数。这个函数接受一个路径，并加载在该位置找到的模块。传递给`require`的路径可以是
- en: A path relative to the script you `require` from, starting with `'.'`. For example,
    if you do `require('./main.js')`, you’ll load a file that’s in the same directory
    as the requiring script. We can also use `..` to get a script in a parent directory.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于你`require`的脚本的路径，以`'.'`开头。例如，如果你执行`require('./main.js')`，你将加载与要求脚本相同的目录中的文件。我们也可以使用`..`来获取父目录中的脚本。
- en: A path to a directory. In these cases, `require` will look for a file named
    `index.js` in the provided directory and give you that.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到一个目录的路径。在这些情况下，`require`将在提供的目录中查找名为`index.js`的文件，并将其提供给你。
- en: 'An absolute path. This one is rarely used, but you could provide an absolute
    file path, as shown in the following code:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径。这个很少使用，但你可能需要提供一个绝对文件路径，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name of a package. Packages can be required by just providing their name;
    for example, to get the `async` package, you should use `require('async')`. Most
    of the time, this is effectively the same as doing `require('./node_modules/async')`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包的名称。你可以仅通过提供包名来引入包；例如，要获取 `async` 包，你应该使用 `require('async')`。大多数情况下，这实际上等同于执行
    `require('./node_modules/async')`。
- en: A.3\. Exporting functionality
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3\. 导出功能
- en: 'Requiring modules wouldn’t be useful if you couldn’t interact with them. Modules
    can export functionality, effectively their API, by assigning to `module.exports`.
    As an example, consider the following module:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能与模块交互，那么引入模块将没有用处。模块可以通过将内容赋值给 `module.exports` 来导出功能，实际上就是它们的API。例如，考虑以下模块：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you fetched this module using `var thing = require('./thing.js')`, then `thing`
    would be assigned whatever `module.exports` ended up becoming inside `thing.js`.
    It is interesting to note that, unlike the browser model, where there are implicit
    globals assigned to `window`, the CommonJS module system keeps variables you declare
    in a module private unless you explicitly make them public by assigning to `module
    .exports`. Node has a `global` object you can assign to, which is called `global`,
    but using it is discouraged because that would break the modularity principle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `var thing = require('./thing.js')` 获取了这个模块，那么 `thing` 将被分配 `thing.js`
    内部 `module.exports` 最终成为的内容。值得注意的是，与浏览器模型不同，在浏览器模型中，`window` 被隐式地分配了全局变量，而CommonJS模块系统将你在模块中声明的变量保持为私有，除非你通过将内容赋值给
    `module.exports` 来显式地使它们公开。Node有一个你可以分配的 `global` 对象，称为 `global`，但使用它是不被推荐的，因为这会破坏模块化原则。
- en: A.4\. Regarding packages
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4\. 关于包
- en: Dependencies are kept in a `package.json` file, which is used by `npm` to figure
    out what packages you need to execute an application. When installing a package,
    you can provide a `--save` flag to have `npm` automatically persist that dependency
    to the `package.json` manifest, so you don’t have to do that by hand. Dependencies
    in `package.json` get installed whenever you run `npm install` without any arguments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系被保存在一个 `package.json` 文件中，该文件被 `npm` 用于确定运行应用程序所需的包。在安装包时，你可以提供一个 `--save`
    标志，让 `npm` 自动将那个依赖关系持久化到 `package.json` 清单中，这样你就不必手动操作。每当你在没有任何参数的情况下运行 `npm install`
    时，`package.json` 中的依赖关系就会被安装。
- en: Local dependencies are installed to a `node_modules` directory, which should
    be ignored in version control. In the case of Git, you can add a line containing
    `node_modules` to a file named `.gitignore`, and Git will know not to revision
    those files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本地依赖关系被安装到 `node_modules` 目录中，这个目录应该在版本控制中忽略。在Git的情况下，你可以在名为 `.gitignore` 的文件中添加包含
    `node_modules` 的行，Git就会知道不要对这些文件进行版本控制。
- en: That’s all you need to know about Node to use it effectively in your Grunt builds.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Node的知识，你只需要知道这些就能在你的Grunt构建中有效地使用它。
