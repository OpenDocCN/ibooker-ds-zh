- en: Part 1\. Build processes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：构建过程
- en: The first part of this book is dedicated to build processes and provides a practical
    introduction to Grunt. You’ll learn the why, how, and what of build processes,
    both in theory and in practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分致力于构建过程，并提供了对Grunt的实用介绍。你将了解构建过程的理论和实践中的为什么、如何以及是什么。
- en: 'In [chapter 1](kindle_split_012.html#ch01), we go over what the Build First
    philosophy entails: a build process and application complexity management. Then,
    we’ll start fiddling with our first build task, using lint to prevent syntax errors
    in our code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](kindle_split_012.html#ch01)中，我们将探讨构建第一哲学包含的内容：构建过程和应用程序复杂性管理。然后，我们将开始处理我们的第一个构建任务，使用lint来防止代码中的语法错误。
- en: '[Chapter 2](kindle_split_013.html#ch02) is all about build tasks. You’ll learn
    about the various tasks that comprise a build, how to configure them, and how
    to create your own tasks. In each case, we’ll take a look at the theory and then
    walk through practical examples using Grunt.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](kindle_split_013.html#ch02)完全是关于构建任务的。你将了解构成构建的各种任务，如何配置它们，以及如何创建自己的任务。在每种情况下，我们将先探讨理论，然后通过使用Grunt的实际示例进行讲解。'
- en: In [chapter 3](kindle_split_014.html#ch03), we’ll learn how to configure application
    environments while keeping sensitive information safe. We’ll go over the development
    environment workflow, and you’ll learn how to automate the build step itself.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](kindle_split_014.html#ch03)中，我们将学习如何在保持敏感信息安全的同时配置应用程序环境。我们将讨论开发环境的工作流程，你将学习如何自动化构建步骤本身。
- en: '[Chapter 4](kindle_split_015.html#ch04) then describes a few more tasks we
    need to take into account when releasing our application, such as asset optimization
    and managing documentation. You’ll learn about keeping code quality in check with
    continuous integration, and we’ll also go through the motions of deploying an
    application to a live environment.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](kindle_split_015.html#ch04)随后描述了在发布我们的应用程序时需要考虑的更多任务，例如资产优化和管理文档。你将了解如何通过持续集成来保持代码质量，我们还将演示如何将应用程序部署到生产环境。'
- en: Chapter 1\. Introduction to Build First
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章：构建第一的介绍
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Identifying problems in modern application design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别现代应用程序设计中的问题
- en: Defining Build First
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义构建第一
- en: Building processes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程
- en: Managing complexity within applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中管理复杂性
- en: Developing an application properly can be hard. It takes planning. I’ve created
    applications over a weekend, but that doesn’t mean they were well-designed. Improvisation
    is great for throw-away prototypes and great when concept-proofing an idea; however,
    building a maintainable application requires a plan, the glue that holds together
    the features you currently have in mind and maybe even those you might add in
    the near future. I’ve participated in countless endeavors where the application’s
    front-end wasn’t all it could be.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正确开发一个应用程序可能很困难。这需要规划。我曾在周末创建过应用程序，但这并不意味着它们设计得很好。即兴创作对于丢弃原型和验证想法来说很棒；然而，构建一个可维护的应用程序需要一个计划，这个计划是当前你心中的功能以及你可能在不久的将来添加的功能的粘合剂。我参与过无数的项目，其中应用程序的前端并没有达到其全部潜力。
- en: Eventually, I realized that back-end services usually have an architect devoted
    to their planning, design, and overview—and often it’s not one architect but an
    entire team of them. This is hardly the case with front-end development, where
    a developer is expected to prototype a working sketch of the application and then
    asked to run with it, hoping that the prototype will survive an implementation
    in production. Front-end development requires as much dedication to architecture
    planning and design as back-end development does.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我意识到后端服务通常有一个专门负责其规划、设计和概览的架构师——而且通常不是一个架构师，而是一个整个团队。前端开发的情况则截然不同，开发者被期望制作一个应用程序的工作草图原型，然后被要求运行它，希望原型能够在生产实施中幸存。前端开发需要与后端开发一样多的对架构规划和设计的投入。
- en: Long gone are the days when we’d copy a few snippets of code off the internet,
    paste them in our page, and call it a day. Mashing together JavaScript code as
    an afterthought no longer holds up to modern standards. JavaScript is now front
    and center. We have many frameworks and libraries to choose from, which can help
    you organize your code by allowing you to write small components rather than a
    monolithic application. Maintainability isn’t something you can tack onto a code
    base whenever you’d like; it’s something you have to build into the application,
    and the philosophy under which the application is designed, from the beginning.
    Writing an application that isn’t designed to be maintainable translates into
    stacking feature after feature in an ever-so-slightly tilting Jenga tower.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那些从互联网上复制几段代码，粘贴到我们的页面，然后就算完成的日子已经一去不复返了。将JavaScript代码随意拼凑在一起的做法已经不符合现代标准了。JavaScript现在处于核心位置。我们有众多框架和库可供选择，这些可以帮助你通过编写小型组件而不是单体应用程序来组织你的代码。可维护性不是你可以随心所欲添加到代码库中的东西；这是你必须构建到应用程序中，并且从设计之初就要遵循的哲学。
- en: If maintainability isn’t built in, it gets to a point where you can’t add any
    more pieces to the tower. The code becomes convoluted and bugs become increasingly
    hard to track down. Refactoring means halting product development, and the business
    can’t afford that. The release schedule must be maintained, and letting the tower
    come crashing down is unacceptable, so we compromise.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有内置可维护性，最终你会达到一个点，无法再向塔中添加任何更多部件。代码会变得复杂，错误变得越来越难以追踪。重构意味着暂停产品开发，而企业无法承担这种损失。发布计划必须保持，让塔楼倒塌是不可接受的，所以我们妥协。
- en: 1.1\. When things go wrong
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 当事情出错时
- en: You might want to deploy a new feature to production, so humans can try it out.
    How many steps do you have to take to do that? Eight? Five? Why would you risk
    a mistake in a routine task such as a deployment? Deploying should be no different
    than building your application locally. One step. That’s it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要将新功能部署到生产环境中，以便人们可以尝试它。你需要执行多少步骤才能做到这一点？八个？五个？你为什么要冒在常规任务中犯错的风险，比如部署？部署应该和本地构建你的应用程序没有区别。一步。就是这样。
- en: Unfortunately that’s rarely the standard. Have you faced the challenging position
    I’ve found myself in of having to take many of these steps manually? Sure, you
    can compile the application in a single step, or you might use an interpreted
    server-side language that doesn’t need any pre-compilation. Maybe later you need
    to update your database to the latest version. You may have even created a script
    for those updates, and yet you log into your database server, upload the file,
    and run the schema updates yourself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这很少是标准做法。你是否遇到过像我一样不得不手动执行许多这些步骤的挑战性位置？当然，你可以一步编译应用程序，或者你可能使用不需要预编译的解释型服务器端语言。也许后来你需要更新数据库到最新版本。你可能甚至为这些更新创建了一个脚本，然后你登录到数据库服务器，上传文件，并自行运行模式更新。
- en: Cool, you’ve updated the database; however, something’s not right and the application
    is throwing an error. You look at the clock. Your application has been down for
    more than 10 minutes. This should’ve been a straightforward update. You check
    the logs; you forgot to add that new variable to your configuration file. Silly!
    You add it promptly, mumbling something about wrestling with the code base. You
    forget to alter the config file before it deploys; it slipped your mind to update
    it before deploying to production!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你已经更新了数据库；然而，有些地方不对劲，应用程序正在抛出错误。你看看时钟。你的应用程序已经宕机超过10分钟了。这应该是一个简单的更新。你检查日志；你忘记将那个新变量添加到配置文件中。真愚蠢！你立即添加它，嘟囔着与代码库搏斗的话。你忘记在部署前更改配置文件；你忘记在部署到生产前更新它！
- en: Sound like a familiar ritual? Fear not, this is an unfortunately common illness,
    spread through different applications. Consider the crisis scenarios described
    next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一个熟悉的仪式吗？不用担心，这不幸是一种常见的疾病，通过不同的应用程序传播。考虑以下描述的危机场景。
- en: 1.1.1\. How to lose $172,222 a second for 45 minutes
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 如何在45分钟内损失172,222美元
- en: I bet you’d consider losing almost half a billion dollars a serious issue, and
    that’s exactly what happened to Knight’s Capital.^([[1](#ch01fn01)]) They developed
    a new feature to allow stock traders to participate in something called the Retail
    Liquidity Program (RLP). The RLP functionality was intended to replace an unused
    piece of functionality called Power Peg (PP), which had been discontinued for
    close to nine years. The RLP code reused a flag, which was used to activate the
    PP code. They removed the Power Peg feature when they added RLP, so all was good.
    Or at least they thought it was good, until the point when they flipped the switch.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，你会认为损失近五亿美元是一个严重的问题，这正是Knight Capital所遭遇的.^([[1](#ch01fn01)]) 他们开发了一个新功能，允许股票交易员参与所谓的零售流动性计划（RLP）。RLP功能旨在取代一个已经停用近九年的未使用功能，称为Power
    Peg（PP）。RLP代码重用了一个标志，该标志用于激活PP代码。他们在添加RLP时移除了Power Peg功能，所以一切看起来都很顺利。或者至少他们认为看起来很顺利，直到他们切换开关的那一刻。
- en: ¹ For more information about Knight’s Capital, see [http://bevacqua.io/bf/knight](http://bevacqua.io/bf/knight).
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 更多关于Knight Capital的信息，请参阅[http://bevacqua.io/bf/knight](http://bevacqua.io/bf/knight)。
- en: Deployments had no formal process and were executed by hand by a single technician.
    This person forgot to deploy the code changes to one of their eight servers, meaning
    that in the case of the eighth server, the PP code, and not the RLP feature, would
    be behind the activation flag. They didn’t notice anything wrong until a week
    later when they turned on the flag, activating RLP on all servers but one, and
    the nine-year-old Power Peg feature on the other.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 部署没有正式流程，由一名技术人员手动执行。这个人忘记将代码更改部署到他们八台服务器中的一台，这意味着在第八台服务器的情况下，PP代码而不是RLP功能会在激活标志后面。直到一周后他们打开标志，激活了除一台以外的所有服务器的RLP，而另一台服务器上则是九年前的Power
    Peg功能，他们才意识到有问题。
- en: Orders routed through the eighth server triggered the PP code rather than RLP.
    As a result, the wrong types of orders were sent to trading centers. Attempts
    to amend the situation only further aggravated it, because they removed the RLP
    code from the servers which did have it. Long story short, they lost somewhere
    in the vicinity of $460 million in less than an hour. When you consider that all
    they needed to do to avoid their downfall was have a more formal build process
    in place, the whole situation feels outrageous, irresponsible, and, in retrospect,
    easily averted. Granted, this is an extreme case, but it boldly illustrates the
    point. An automated process would have increased the probability that human errors
    could be prevented or at least detected sooner.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第八台服务器路由的订单触发了PP代码而不是RLP。结果，错误的订单类型被发送到了交易中心。试图修正这种情况反而使问题更加严重，因为他们从拥有RLP代码的服务器上移除了RLP代码。简而言之，他们在不到一个小时的时间里损失了大约4.6亿美元。当你考虑到他们只需要建立一个更正式的构建流程来避免他们的崩溃时，整个情况感觉是荒谬的、不负责任的，并且事后看来，很容易避免。当然，这是一个极端案例，但它大胆地说明了这一点。一个自动化的流程会提高防止或至少更早发现人为错误的可能性。
- en: 1.1.2\. Build First
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 首先构建
- en: 'In this book, my goal is to teach you the Build First philosophy of designing
    for clean, well-structured, and testable applications before you write a single
    line of code. You’ll learn about process automation, which will mitigate the odds
    of human error, such as those leading to Knight’s Capital’s bankruptcy. Build
    First is the foundation that will empower you to design clean, well-structured,
    and testable applications, which are easy to maintain and refactor. Those are
    the two fundamental aspects of Build First: process automation and design.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我的目标是教你“首先构建”的设计哲学，即在编写任何代码之前设计干净、结构良好和可测试的应用程序。你将了解流程自动化，这将减少人为错误的可能性，例如导致Knight
    Capital破产的错误。首先构建是使你能够设计干净、结构良好和可测试的应用程序的基础，这些应用程序易于维护和重构。这是首先构建的两个基本方面：流程自动化和设计。
- en: To teach you the Build First approach, this book will show you techniques that
    will improve the quality of your software as well as your web development workflow.
    In [Part 1](kindle_split_011.html#part01), we’ll begin by learning how to establish
    build processes appropriate for modern web application development. Then, you’ll
    walk through best practices for productive day-to-day development, such as running
    tasks when your code changes, deploying applications from your terminal by entering
    a single command, and monitoring the state of your application once it’s in production.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了教你“先构建”的方法，这本书将向你展示一些技术，这些技术将提高你的软件质量以及你的Web开发工作流程。在[第一部分](kindle_split_011.html#part01)中，我们将从学习如何建立适合现代Web应用程序开发的构建流程开始。然后，你将了解提高日常开发效率的最佳实践，例如在代码更改时运行任务，通过输入单个命令从终端部署应用程序，以及一旦应用程序投入生产后监控其状态。
- en: The second part of the book—managing complexity and design—focuses on application
    quality. Here I give you an introduction to writing more modular JavaScript components
    by comparing the different options that are currently available. Asynchronous
    flows in JavaScript tend to grow in complexity and length, which is why I prepared
    a chapter where you’ll gain insight into writing cleaner asynchronous code while
    learning about different tools you can use to improve that code. Using Backbone
    as your gateway drug of choice, you’ll learn enough about MVC in JavaScript to
    get you started on the path to client-side MVC. I mentioned testable applications
    are important, and while modularity is a great first step in the right direction,
    testing merits a chapter of its own. The last chapter dissects a popular API design
    mentality denominated REST (Representational State Transfer), helping you design
    your own, as well as delving into application architecture on the server side,
    but always keeping an eye on the front end. We’ll begin our exploration of build
    processes after looking at one more crisis scenario Build First can avert by automating
    your process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 书的第二部分——管理复杂性和设计——侧重于应用程序质量。在这里，我通过比较目前可用的不同选项，为你介绍如何编写更模块化的JavaScript组件。JavaScript中的异步流程往往会变得复杂和冗长，这就是为什么我准备了一章，你将在其中学习编写更干净的异步代码，同时了解你可以使用哪些不同的工具来改进代码。以Backbone作为你的首选入门药物，你将了解足够的JavaScript
    MVC知识，以开始你的客户端MVC之路。我提到可测试的应用程序很重要，虽然模块化是正确方向上的一个很好的第一步，但测试值得单独一章。最后一章剖析了一个流行的API设计理念REST（表示状态传输），帮助你设计自己的，同时深入到服务器端的应用程序架构，但始终关注前端。在查看一个Build
    First可以通过自动化流程避免的危机场景之后，我们将开始探索构建流程。
- en: 1.1.3\. Rites of initiation
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3. 初始化仪式
- en: Complicated setup procedures, such as when new team members come onboard, are
    also a sign you may be lacking in the automation department. Much to my torment,
    I’ve worked on projects where getting a development environment working for the
    first time took a week. A full week before you can even begin to fathom what the
    code does.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的设置流程，例如当新团队成员加入时，也是你可能在自动化部门有所欠缺的迹象。令我痛苦的是，我参与过一些项目，第一次让开发环境工作需要花费一周时间。在你甚至开始理解代码做什么之前，需要整整一周。
- en: Download approximately 60 gigabytes worth of database backups, create a database
    configuring things you’ve never heard of before, such as collation, and then run
    a series of schema upgrade scripts that don’t quite work. Once you’ve figured
    that out, you might want to patch your Windows Media Player by installing specific
    and extremely outdated codecs in your environment, which will feel as futile as
    attempts to cram a pig into a stuffed refrigerator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下载大约60GB的数据库备份，创建一个配置你从未听说过的数据库，例如排序，然后运行一系列不太起作用的模式升级脚本。一旦你弄明白了这一点，你可能想要通过在你的环境中安装特定且极其过时的编解码器来修补你的Windows
    Media Player，这感觉就像是将一头猪塞进一个填充的冰箱一样徒劳。
- en: Last, try compiling the 130+ project monolith in a single pass while you grab
    a cup of coffee. Oh, but you forgot to install the external dependencies; that’ll
    do it. Nope, wait, you also need to compile a C++ program so codecs will work
    again. Compile again, and another 20 minutes go by. Still failing? Shoot. Ask
    around, maybe? Well, nobody truly knows. All of them went through that excruciating
    process when they started out, and they erased the memory from their minds. Check
    out the wiki? Sure, but it’s all over the place. It has bits of information here
    and there, but they don’t address your specific problems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你拿一杯咖啡的时候，尝试一次性编译130多个项目单体。哦，但你忘了安装外部依赖项；这就解释了问题所在。不，等等，你还需要编译一个C++程序，这样编解码器才能再次工作。再次编译，又过去了20分钟。仍然失败？射击。四处问问，也许？嗯，没有人真正知道。他们所有人刚开始时都经历了这个过程，并且从他们的记忆中抹去了这段经历。查看维基百科？当然，但信息散落在各处。这里那里有一些信息，但它们没有解决你的具体问题。
- en: The company never had a formal initiation workflow, and as things started to
    pile up, it became increasingly hard to put one together. They had to deal with
    giant backups, upgrades, codecs, multiple services required by the website, and
    compiling the project took half an hour for every semi-colon you changed. If they’d
    automated these steps from the beginning, like we’ll do in Build First, the process
    would’ve been that much smoother.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 公司从未有过正式的初始化工作流程，随着事情开始堆积，组合起来变得越来越困难。他们不得不处理巨大的备份、升级、编解码器、网站所需的多个服务，以及每次更改分号时编译项目需要半小时。如果他们从一开始就自动化这些步骤，就像我们在“先构建”中将要做的那样，过程就会更加顺畅。
- en: 'Both the Knight’s Capital debacle and the overly complicated setup story have
    one thing in common: if they’d planned ahead and automated their build and deployment
    processes, their issues would’ve been averted. Planning ahead and automating the
    processes surrounding your applications are fundamental aspects of the Build First
    philosophy, as you’ll learn in the next section.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士资本公司的灾难和过于复杂的设置故事有一个共同点：如果他们提前规划并自动化构建和部署流程，他们的问题本可以避免。提前规划和自动化围绕应用程序的流程是“先构建”哲学的基本方面，你将在下一节中了解到这一点。
- en: 1.2\. Planning ahead with Build First
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 使用“先构建”提前规划
- en: In the case of Knight’s Capital, where they forgot to deploy code to one of
    the production web servers, having a single-step deployment process that automatically
    deployed the code to the whole web farm would’ve been enough to save the company
    from bankruptcy. The deeper issue in this case was code quality, because they
    had unused pieces of code sitting around in their code base for almost 10 years.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在骑士资本公司的案例中，他们忘记将代码部署到生产Web服务器之一，如果有一个单步部署流程可以自动将代码部署到整个Web农场，就足以拯救公司免于破产。这个案例中的更深层次问题是代码质量，因为他们几乎有10年在代码库中闲置未使用的代码片段。
- en: A complete refactor that doesn’t provide any functional gains isn’t appealing
    to a product manager; their goal is to improve the visible, consumer-facing product,
    not the underlying software. Instead, you can continuously improve the average
    quality of code in your project by progressively improving the code base and refactoring
    code as you touch it, writing tests that cover the refactored functionality, and
    wrapping legacy code in interfaces, so you can refactor later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不提供任何功能增益的完整重构对产品经理来说没有吸引力；他们的目标是改善可见的、面向消费者的产品，而不是底层软件。相反，你可以通过逐步改进代码库和重构你接触到的代码，编写覆盖重构功能的测试，以及将遗留代码包装在接口中，以便以后可以重构，来持续提高你项目中代码的平均质量。
- en: Refactoring won’t do the trick on its own, though. Good design that’s ingrained
    into the project from its inception is much more likely to stick, rather than
    attempts to tack it onto a poor structure as an afterthought. Design is the other
    fundamental aspect of the book, along with build processes mentioned previously.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重构本身并不能解决问题。从项目一开始就深深植入项目中的良好设计，比试图将其作为事后想法附加到不良结构上更有可能坚持下去。设计是本书的另一个基本方面，与之前提到的构建流程并列。
- en: Before we dive into the uncharted terrains of Build First, I want to mention
    this isn’t a set of principles that only apply to JavaScript. For the most part,
    people usually associate these principles with back-end languages, such as Java,
    C#, or PHP, but here I’m applying them to the development process for JavaScript
    applications. As I mentioned previously, client-side code often doesn’t get the
    love and respect it deserves. That often means broken code because we lack proper
    testing, or a code base that’s hard to read and maintain. The product (and developer
    productivity) suffers as a result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探索Build First的未知领域之前，我想提到这不仅仅是一套只适用于JavaScript的原则。在很大程度上，人们通常将这些原则与后端语言相关联，例如Java、C#或PHP，但在这里我将它们应用于JavaScript应用程序的开发过程。正如我之前提到的，客户端代码往往没有得到应有的关爱和尊重。这通常意味着代码损坏，因为我们缺乏适当的测试，或者代码库难以阅读和维护。因此，产品（和开发者生产力）受到影响。
- en: 'When it comes to JavaScript, given that interpreted languages don’t need a
    compiler, naive developers might think that’s justification enough to ditch the
    build process entirely. The problem when going down that road is that they’ll
    be shooting in the dark: the developer won’t know whether the code works until
    it’s executed by a browser, and won’t know whether it does what it’s expected
    to, either. Later on, they might find themselves manually deploying to a hosting
    environment and logging into it remotely to tweak a few configuration settings
    to make it work.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到JavaScript时，鉴于解释型语言不需要编译器，新手开发者可能会认为这已经足够理由完全放弃构建过程。走这条路的问题在于，他们将在黑暗中射击：开发者不知道代码是否工作，直到它在浏览器中执行，也不知道它是否按预期工作。稍后，他们可能会发现自己手动部署到托管环境，并远程登录以调整一些配置设置以使其工作。
- en: 1.2.1\. Core principles in Build First
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. Build First的核心原则
- en: 'At its core, the Build First approach encourages establishing not only a build
    process but also clean application design. The following list shows at a high
    level what embracing the Build First approach gives us:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Build First方法的核心是鼓励不仅建立构建过程，还要有清晰的应用程序设计。以下列表从高层次展示了采用Build First方法能给我们带来什么：
- en: Reduced error proclivity because there’s no human interaction
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有人为交互，因此降低了错误倾向
- en: Enhanced productivity by automating repetitive tasks
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自动化重复性任务提高生产力
- en: Modular, scalable application design
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化、可扩展的应用程序设计
- en: Testability and maintainability by shrinking complexity
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缩减复杂性提高可测试性和可维护性
- en: Releases that conform to performance best practices
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合性能最佳实践的发布版本
- en: Deployed code that’s always tested before a release
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布前始终测试过的部署代码
- en: Looking at [figure 1.1](#ch01fig01), starting with the top row and moving down,
    you can see
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图1.1[图1.1](#ch01fig01)，从顶部行开始向下看，你可以看到
- en: 'Build process: This is where you compile and test the application in an automated
    fashion. The build can be aimed at facilitating continuous development or tuned
    for maximum performance for a release.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程：这是您以自动化的方式编译和测试应用程序的地方。构建可以旨在促进持续开发，或调整以实现发布时的最大性能。
- en: 'Design: You’ll spend most of your time here, coding and augmenting the architecture
    as you go. While you’re at it, you might refactor your code and update the tests
    to ensure components work as expected. Whenever you’re not tweaking the build
    process or getting ready for a deployment, you’ll be designing and iterating on
    the code base for your application.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计：您将在这里花费大部分时间，在编码的同时增强架构。在此过程中，您可能会重构代码并更新测试以确保组件按预期工作。每当您不是调整构建过程或准备部署时，您将设计和迭代应用程序的代码库。
- en: 'Deployment and Environment: These are concerned with automating the release
    process and configuring the different hosted environments. The deployment process
    is in charge of delivering your changes to the hosted environment, while environment
    configuration defines the environment and the services—or databases—it interacts
    with, at a high level.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和环境：这些涉及自动化发布过程和配置不同的托管环境。部署过程负责将您的更改传递到托管环境，而环境配置定义了环境以及与之交互的服务或数据库，从高层次上讲。
- en: 'Figure 1.1\. High-level view of the four areas of focus in Build First: Build
    process, Design, Deployment, and Environment'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. Build First的四个关注领域的高级视图：构建过程、设计、部署和环境
- en: '![](01fig01_alt.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig01_alt](01fig01_alt.jpg)'
- en: 'As [figure 1.1](#ch01fig01) illustrates, Build First applications have two
    main components: the processes surrounding the project, such as building and deploying
    the application, and the design and quality of the application code itself, which
    is iteratively improved on a daily basis as you work on new features. Both are
    equally important, and they depend on each other to thrive. Good processes don’t
    do any good if you’re lacking in your application design. Similarly, good design
    won’t survive crises such as the ones I described previously without the help
    of decent build and deployment procedures.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1.1](#ch01fig01)所示，Build First应用程序有两个主要组件：围绕项目的流程，如构建和部署应用程序，以及应用程序代码的设计和质量，这些在您开发新功能时每天都会迭代改进。这两者同等重要，并且它们相互依赖以繁荣发展。如果您的应用程序设计不足，良好的流程也不会有任何好处。同样，没有良好的构建和部署流程的帮助，良好的设计也无法在之前描述的危机中生存。
- en: As with the Build First approach, this book is broken into two parts. In [part
    1](kindle_split_011.html#part01), we look at the build process (tuned for either
    development or release) and the deployment process, as well as environments and
    how they can be configured. [Part 2](kindle_split_016.html#part02) delves into
    the application itself, and helps us come up with modular designs that are clear
    and concise. It also takes us through the practical design considerations you’ll
    have to make when building modern applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与“先构建”方法一样，本书分为两部分。在[第一部分](kindle_split_011.html#part01)中，我们查看构建过程（针对开发或发布进行优化）和部署过程，以及环境及其配置方式。[第二部分](kindle_split_016.html#part02)深入探讨应用程序本身，并帮助我们设计出清晰简洁的模块化设计。它还引导我们了解在构建现代应用程序时必须考虑的实际设计因素。
- en: In the next two sections, you’ll get an overview of the concepts discussed in
    each part of the book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，您将概述本书各部分讨论的概念。
- en: 1.3\. Build processes
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 构建过程
- en: 'A build process is intended to automate repetitive tasks such as installing
    dependencies, compiling code, running unit tests, and performing any other important
    functions. The ability to execute all of the required tasks in a single step,
    called a *one-step build*, is critical because of the powerful opportunities it
    unveils. Once you have a one-step build in place, you can execute it as many times
    as required, without the outcome changing. This property is called *idempotence*:
    no matter how many times you invoke the operation, the result will be the same.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程旨在自动化重复性任务，例如安装依赖项、编译代码、运行单元测试以及执行任何其他重要功能。能够一次性执行所有必需任务的能力，称为*单步构建*，至关重要，因为它揭示了强大的机会。一旦您设置了单步构建，就可以根据需要多次执行它，而结果不会改变。这个特性被称为*幂等性*：无论您调用操作多少次，结果都将相同。
- en: '[Figure 1.2](#ch01fig02) highlights in more detail the steps that make up the
    automated build and deployment processes.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#ch01fig02)更详细地说明了自动化构建和部署过程所包含的步骤。'
- en: 'Figure 1.2\. High-level view of the processes in Build First: Build and Deployment'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. Build First过程中的流程高级视图
- en: '![](01fig02_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig02_alt.jpg)'
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pros and cons of automating your build processes**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化构建过程的优缺点**'
- en: Possibly the most important advantage to having an automated build process is
    that you can deploy as frequently as needed. Providing humans with the latest
    features as soon as they’re ready allows us to tighten the feedback loop through
    which we can gain better insights into the product we should be building.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化构建过程最重要的优势可能是可以按需频繁部署。一旦新功能准备好，就立即向人类提供最新功能，这使我们能够通过反馈循环来获得更好的洞察力，从而更好地了解我们应该构建的产品。
- en: The main disadvantage to setting up an automated process is the time you’ll
    need to spend putting the process together before you can start seeing the real
    benefits, but the benefits—such as automated testing, higher code quality, a leaner
    development workflow, and a safer deployment flow—far outweigh the effort spent
    putting together that process. As a general rule, you’ll set up the process once
    and then replay it as much as you’d like, tweaking it a little as you go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自动化流程的主要缺点是您需要花费时间来构建流程，在您开始看到实际好处之前，但好处——如自动化测试、更高的代码质量、更精简的开发工作流程和更安全的部署流程——远远超过了构建该流程所付出的努力。一般来说，您只需设置一次流程，然后可以根据需要多次回放它，并在过程中进行一些调整。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Build
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建
- en: The top of [figure 1.2](#ch01fig02) zooms in on the build portion in the build
    process workflow (shown back in [figure 1.1](#ch01fig01)), detailing the concerns
    as you aim for either development or release. If you aim for development, you’ll
    want to maximize your ability to debug, and I bet you’ll like a build that knows
    when to execute parts of itself without you taking any action. That’s called *continuous
    development* (CD), and you’ll learn about it in [chapter 3](kindle_split_014.html#ch03).
    The release distribution of a build isn’t concerned with CD, but you’ll want to
    spend time optimizing your assets so they perform as fast as possible in production
    environments where humans will use your application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#ch01fig02)的顶部放大了构建过程工作流程中的构建部分（如图[图1.1](#ch01fig01)所示），详细说明了你在旨在开发或发布时的关注点。如果你旨在开发，你将希望最大化你的调试能力，我敢打赌你会喜欢一个知道何时执行自身部分而无需你采取任何行动的构建。这被称为*持续开发*（CD），你将在第[3章](kindle_split_014.html#ch03)中了解到它。构建的发布分发不关心CD，但你将想要花时间优化你的资产，以便它们在生产环境中尽可能快地运行。'
- en: Deployment
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署
- en: The bottom of [figure 1.2](#ch01fig02) zooms into the deployment process (originally
    shown in [figure 1.1](#ch01fig01)), which takes either the debug or release *distribution*
    (what I call distinct process flows with a specific purpose throughout the book)
    and deploys it to a hosted environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#ch01fig02)的底部放大了部署过程（最初在[图1.1](#ch01fig01)中显示），它将调试或发布*分发*（我在书中称为具有特定目的的独立流程）部署到托管环境中。'
- en: This package will work together with the environment-specific configuration
    (which keeps secrets, such as database connection strings and API keys, safe,
    and is discussed in [chapter 3](kindle_split_014.html#ch03)) to serve the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包将与特定环境的配置（它保护秘密，如数据库连接字符串和API密钥，并在第[3章](kindle_split_014.html#ch03)中讨论）一起工作，以提供服务。
- en: '[Part 1](kindle_split_011.html#part01) is dedicated to the build aspect of
    Build First:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1部分](kindle_split_011.html#part01)致力于构建“构建优先”的方面：'
- en: '[Chapter 2](kindle_split_013.html#ch02) explains build tasks, teaching you
    how to write tasks and configure them using Grunt, the task runner you’ll use
    as a build tool throughout [part 1](kindle_split_011.html#part01).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](kindle_split_013.html#ch02)解释了构建任务，教你如何使用Grunt编写任务并配置它们，Grunt是你将在第[1部分](kindle_split_011.html#part01)中用作构建工具的任务运行器。'
- en: '[Chapter 3](kindle_split_014.html#ch03) covers environments, how to securely
    configure your application, and the development work flow.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](kindle_split_014.html#ch03)涵盖了环境、如何安全地配置你的应用程序以及开发工作流程。'
- en: '[Chapter 4](kindle_split_015.html#ch04) discusses tasks you should perform
    during release builds. Then you’ll learn about deployments, running tests on every
    push to version control, and production monitoring.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](kindle_split_015.html#ch04)讨论了你在发布构建期间应执行的任务。然后你将了解部署、在每次推送到版本控制时运行测试以及生产监控。'
- en: Benefits of a Build Process
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建过程的好处
- en: 'Once you’re done with [part 1](kindle_split_011.html#part01), you’ll feel confident
    performing the following operations on your own applications:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第[1部分](kindle_split_011.html#part01)后，你将能够自信地在自己的应用程序上执行以下操作：
- en: Automating repetitive tasks such as compilation, minification, and testing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化重复性任务，如编译、压缩和测试
- en: Building an icon spritesheet so that HTTP requests for iconography are reduced
    to a single one. Such spriting techniques are discussed in [chapter 2](kindle_split_013.html#ch02),
    as well as other HTTP 1.x optimization tricks, as a means to improve page speed
    and application delivery performance.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图标精灵图，以便将图标图形的HTTP请求减少到单个请求。这类精灵技术在第[2章](kindle_split_013.html#ch02)中有所讨论，以及其他HTTP
    1.x优化技巧，作为提高页面速度和应用交付性能的手段。
- en: Spinning up new environments effortlessly and neglecting to differentiate between
    development and production
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需费力即可启动新环境，并忽略开发与生产之间的区别
- en: Restarting a web server and recompiling assets automatically whenever related
    files change
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相关文件更改时自动重启Web服务器和重新编译资产
- en: Supporting multiple environments with flexible, single-step deployments
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个环境，具有灵活的单步部署
- en: The Build First approach eliminates manual labor when it comes to tedious tasks,
    while also improving your productivity from the beginning. Build First acknowledges
    the significance of the build process for shaping a maintainable application iteratively.
    The application itself is also built by iteratively chipping away at its complexity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Build First方法在处理繁琐的任务时消除了人工劳动，同时从一开始就提高了您的生产力。Build First认可构建过程对于迭代塑造可维护应用程序的重要性。应用程序本身也是通过迭代减少其复杂性来构建的。
- en: Clean application design and architecture are addressed in [part 2](kindle_split_016.html#part02)
    of this book, which covers complexity management within the application, as well
    as design considerations with a focus on raising the quality bar. Let’s go over
    that next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁的应用程序设计和架构在本书的[第2部分](kindle_split_016.html#part02)中得到了解决，该部分涵盖了应用程序内的复杂性管理，以及以提升质量标准为重点的设计考虑因素。让我们接下来回顾一下。
- en: 1.4\. Handling application complexity and design
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 处理应用程序复杂性和设计
- en: Modularization, managing dependencies, understanding asynchronous flow, carefully
    following the right patterns, and testing are all crucial if you expect your code
    to work at a certain scale, regardless of language. In [part 2](kindle_split_016.html#part02)
    you’ll learn different concepts, techniques, and patterns to apply to your applications,
    making them more modular, focused, testable, and maintainable. [Figure 1.3](#ch01fig03),
    viewed from the top down, shows the progression we’ll follow in [part 2](kindle_split_016.html#part02).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化、管理依赖关系、理解异步流程、仔细遵循正确的模式以及测试，如果希望您的代码在特定规模下工作，这些都是至关重要的，无论使用哪种语言。在[第2部分](kindle_split_016.html#part02)中，您将学习不同的概念、技术和模式，以应用于您的应用程序，使它们更加模块化、专注、可测试和可维护。[图1.3](#ch01fig03)，从上到下观看，显示了我们在[第2部分](kindle_split_016.html#part02)中将要遵循的进展。
- en: Figure 1.3\. Application design and development concerns discussed in [part
    2](kindle_split_016.html#part02)
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. 在[第2部分](kindle_split_016.html#part02)中讨论的应用程序设计和开发关注点
- en: '![](01fig03_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig03_alt.jpg)'
- en: Modularity
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块化
- en: You’ll learn how to break your application into components, break those components
    down into modules, and then write concise functions that have a single purpose
    inside those modules. Modules can come from external packages, developed by third
    parties, and you can also develop them yourself. External packages should be handled
    by a package manager that takes care of versioning and updates on your behalf,
    which eliminates the need to manually download dependencies (such as jQuery) and
    automates the process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何将应用程序分解成组件，将这些组件分解成模块，然后编写简洁的函数，这些函数在模块内部具有单一目的。模块可以来自外部包，由第三方开发，您也可以自行开发它们。外部包应由包管理器处理，它代表您处理版本和更新，从而消除了手动下载依赖项（如jQuery）的需要，并自动化了此过程。
- en: As you’ll learn in [chapter 5](kindle_split_017.html#ch05), modules indicate
    their dependencies (the modules they depend upon) in code, as opposed to grabbing
    them from the global namespace; this improves self-containment. A module system
    will take advantage of this information, being able to resolve all of these dependencies;
    it’ll save you from having to maintain long lists of `<script>` tags in the appropriate
    order for your application to work correctly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将在[第5章](kindle_split_017.html#ch05)中学习到的，模块在代码中表明它们的依赖关系（它们所依赖的模块），而不是从全局命名空间中获取；这提高了自包含性。模块化系统将利用这些信息，能够解决所有这些依赖关系；它将让您免于维护长列表的`<script>`标签，以确保您的应用程序正确运行。
- en: Design
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计
- en: You’ll get acquainted with separation of concerns and how to design your application
    in a layered way by following the Model-View-Controller pattern, further tightening
    the modularity in your applications. I’ll tell you about shared rendering in [chapter
    7](kindle_split_019.html#ch07), the technique where you render views on the server
    side first, and then let the client side do view rendering for subsequent requests
    on the same single-page application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解关注点分离以及如何通过遵循模型-视图-控制器模式来以分层方式设计您的应用程序，进一步加强您应用程序的模块化。我将在[第7章](kindle_split_019.html#ch07)中告诉您关于共享渲染的内容，这是一种在服务器端首先渲染视图的技术，然后让客户端为同一单页应用程序的后续请求进行视图渲染。
- en: Asynchronous Code
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异步代码
- en: I’ll teach you about the different types of asynchronous code flow techniques,
    using callbacks, Promises, generators, and events and helping you tame the asynchronous
    beast.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您介绍不同类型的异步代码流技术，使用回调、Promise、生成器和事件，并帮助您驯服异步野兽。
- en: Testing Practices
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试实践
- en: In [chapter 5](kindle_split_017.html#ch05) we discuss everything about modularity,
    learn about closures and the module pattern, talk about module systems and package
    managers, and try to pinpoint the strengths found in each solution. [Chapter 6](kindle_split_018.html#ch06)
    takes a deep dive into asynchronous programming in JavaScript. You’ll learn how
    to avoid writing a callback soup that will confuse you a week from now, and then
    you’ll learn about the Promise pattern and the generators API coming in ES6.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](kindle_split_017.html#ch05)中，我们讨论了关于模块化的一切，了解闭包和模块模式，讨论模块系统和包管理器，并尝试确定每个解决方案的优势。[第
    6 章](kindle_split_018.html#ch06)深入探讨了 JavaScript 中的异步编程。你将学习如何避免编写一周后让你困惑的回调汤，然后你将了解
    ES6 中即将到来的 Promise 模式和生成器 API。
- en: '[Chapter 7](kindle_split_019.html#ch07) is dedicated to patterns and practices,
    such as how to best develop code, whether jQuery is the right choice for you,
    and how to write JavaScript code you can use in both the client and the server.
    We’ll then look at the Backbone MVC framework. Keep in mind that Backbone is the
    tool I’ll use to introduce you to MVC in JavaScript, but it’s by no means the
    only tool you can use to this end.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 7 章](kindle_split_019.html#ch07)致力于模式和最佳实践，例如如何最佳地开发代码，jQuery 是否是你正确的选择，以及如何编写可以在客户端和服务器端使用的
    JavaScript 代码。然后我们将探讨 Backbone MVC 框架。请记住，Backbone 是我将用来向你介绍 JavaScript 中 MVC
    的工具，但绝不是你实现这一目标的唯一工具。'
- en: In [chapter 8](kindle_split_020.html#ch08) we’ll go over testing solutions,
    automation, and tons of practical examples of unit testing client-side JavaScript.
    You’ll learn how to develop tests in JavaScript at the unit level by testing a
    particular component and at the integration level by testing the application as
    a whole.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](kindle_split_020.html#ch08)中，我们将讨论测试解决方案、自动化以及大量单元测试客户端 JavaScript
    的实际示例。你将学习如何通过测试特定组件来在单元级别开发 JavaScript 测试，并通过测试整个应用程序来在集成级别开发测试。
- en: The book closes with a chapter on REST API design, and the implications of consuming
    a REST API in the front end, as well as a proposed structure to take full advantage
    of REST.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本书以关于 REST API 设计的章节结束，讨论在前端消费 REST API 的含义，以及一个充分利用 REST 的建议结构。
- en: Practical design considerations
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实际设计考虑因素
- en: The book aims to get you thinking about practical design considerations made
    when building a real application, as well as deciding thoughtfully on the best
    possible tool for a job, all the while focusing on quality in both your processes
    and the application itself. When you set out to build an application, you start
    by determining the scope, choosing a technology stack, and composing a minimum
    viable build process. Then you begin building the app, maybe using an MVC architecture
    and sharing the view rendering engine in both the browser and the server, something
    we discuss in [chapter 7](kindle_split_019.html#ch07). In [chapter 9](kindle_split_021.html#ch09)
    you’ll learn the important bits on how to put an API together, and you’ll learn
    how to define backing services that will be used by both the server-side view
    controllers and the REST API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在让你思考在构建真实应用程序时做出的实际设计考虑，以及深思熟虑地决定最适合工作的最佳工具，同时关注你流程和应用程序本身的质量。当你开始构建一个应用程序时，你首先确定范围，选择技术堆栈，并组成一个最小可行构建过程。然后你开始构建应用程序，可能使用
    MVC 架构，并在浏览器和服务器之间共享视图渲染引擎，这是我们将在[第 7 章](kindle_split_019.html#ch07)中讨论的内容。在[第
    9 章](kindle_split_021.html#ch09)中，你将学习如何组装 API 的重要部分，并学习如何定义将被服务器端视图控制器和 REST
    API 使用的后端服务。
- en: '[Figure 1.4](#ch01fig04) is an overview of how typical Build First applications
    may be organized.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.4](#ch01fig04) 是典型“先构建”应用程序可能组织的概述。'
- en: Figure 1.4\. Pragmatic architectural considerations
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. 语境化架构考虑因素
- en: '![](01fig04_alt.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4](01fig04_alt.jpg)'
- en: Build process
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建过程
- en: Beginning at the upper left, [figure 1.4](#ch01fig04) outlines how you can start
    by composing a build process which helps consolidate a starting point for your
    architecture, by deciding how to organize your code base. Defining a modular application
    architecture is the key to a maintainable code base, as you’ll observe in [chapter
    5](kindle_split_017.html#ch05). The architecture is then consolidated by putting
    in place automated processes that provide you with continuous development, integration,
    and deployment capabilities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从左上角开始，[图1.4](#ch01fig04)概述了你可以如何通过决定如何组织代码库来开始构建一个构建过程，这有助于为你的架构提供一个起点。定义模块化应用程序架构是可维护代码库的关键，正如你在第5章中将会观察到的。然后，通过实施提供持续开发、集成和部署能力的自动化流程来巩固架构。
- en: Design and Rest API
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计和REST API
- en: Designing the application itself, including a REST API that can effectively
    increase maintainability, is only possible by identifying clear cut components
    with clear purposes so they’re orthogonal (meaning that they don’t fight for resources
    on any particular concern). In [chapter 9](kindle_split_021.html#ch09) we’ll explore
    a multi-tiered approach to application design which can help you quickly isolate
    the web interface from your data and your business logic by strictly defining
    layers and the communication paths between those layers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序本身，包括一个可以有效地提高可维护性的REST API，只有通过识别具有明确目的的清晰组件，使它们正交（这意味着它们不会在特定关注点上争夺资源）。在第9章中，我们将探讨一种多级应用程序设计方法，这可以帮助你通过严格定义层以及这些层之间的通信路径，快速地将Web界面从你的数据和业务逻辑中隔离出来。
- en: Battle testing
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 战斗测试
- en: Once a build process and architecture are designed, battle testing is where
    you’ll get drenched in reliability concerns. Here you’ll plumb together continuous
    integration, where tests are executed on every push to your version control system,
    and maybe even continuous deployments, making several deployments to production
    per day. Last, fault tolerance concerns such as logging, monitoring, and clustering
    are discussed. These are glanced over in [chapter 4](kindle_split_015.html#ch04),
    and help make your production environment more robust, or (at worst) warn you
    when things go awry.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计和构建了构建过程和架构，战斗测试就是你在可靠性问题上会全身心投入的地方。在这里，你将集成持续集成，其中测试在每次推送到你的版本控制系统时执行，甚至可能是持续部署，每天进行多次生产部署。最后，讨论了容错问题，如日志记录、监控和集群。这些内容在第4章中简要介绍，有助于使你的生产环境更加健壮，或者（在最坏的情况下）在事情出错时警告你。
- en: All along the way, you’ll write tests, adjust the build process, and tweak the
    code. It will be a terrific experiment for you to battle test Build First. It’s
    time you get comfortable and start learning specifics about the Build First philosophy.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，你将编写测试、调整构建过程，并微调代码。这将是一个极好的实验，让你测试“先构建”的理念。现在是时候让你感到舒适，并开始学习关于“先构建”哲学的具体内容了。
- en: 1.5\. Diving into Build First
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 深入了解“先构建”
- en: Quality is the cornerstone of Build First, and every measure taken by this approach
    works toward the simple goal of improving quality in both your code and the structure
    surrounding it. In this section, you’ll learn about code quality and setting up
    lint, a code quality tool, in your command line. Measuring code quality is a good
    first step toward writing well-structured applications. If you start doing it
    early enough, it’ll be easy to have your code base conform to a certain quality
    standard, and that’s why we’ll do it right off the bat.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 质量是“先构建”的基石，采取的每一项措施都是为了实现一个简单的目标：提高你代码及其周围结构的质量。在本节中，你将了解代码质量以及如何在命令行中设置代码质量工具lint。衡量代码质量是编写结构良好应用程序的良好第一步。如果你尽早开始这样做，你的代码库将很容易符合一定的质量标准，这就是我们为什么从一开始就做这件事的原因。
- en: In [chapter 2](kindle_split_013.html#ch02), once you’ve learned about lint,
    I’ll introduce you to Grunt, the build tool you’ll use throughout the book to
    compose and automate build processes. Using Grunt allows you to run the code quality
    checks as part of a build, meaning you won’t forget about them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，一旦你了解了lint，我将向你介绍Grunt，这是你将在整本书中使用来组合和自动化构建过程的构建工具。使用Grunt允许你在构建过程中运行代码质量检查，这意味着你不会忘记它们。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Grunt: the means to an end**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grunt:达到目的的手段**'
- en: 'Grunt is used intensively in [part 1](kindle_split_011.html#part01) and in
    some of [part 2](kindle_split_016.html#part02) to drive our build processes. I
    chose Grunt because it’s a popular tool that’s easy to teach and satisfies the
    most needs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 在 [第一部分](kindle_split_011.html#part01) 中被广泛使用，并在 [第二部分](kindle_split_016.html#part02)
    的某些部分中使用，以驱动我们的构建过程。我选择 Grunt 是因为它是一个流行的工具，易于教授，并且能满足大多数需求：
- en: It has full support for Windows.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它完全支持 Windows 系统。
- en: Little JavaScript knowledge is required and it takes little effort to pick up
    and run.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要太多的 JavaScript 知识，并且学习起来和运行起来都很简单。
- en: 'It’s important to understand that Grunt is a means to an end, a tool that enables
    you to easily put together the build processes described in this book. This doesn’t
    make Grunt the absolute best tool for the job, and in an effort to make that clear,
    I’ve compiled a comparison between Grunt and two other tools: *npm, which is a
    package manager that can double as a lean build tool, and *Gulp, a code-driven
    build tool that has several conventions in common with Grunt.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，Grunt 只是一个达到目的的手段，一个能够让你轻松组合本书中描述的构建过程的工具。这并不意味着 Grunt 是完成这项工作的绝对最佳工具，为了使这一点清晰，我已经整理了
    Grunt 与其他两个工具的比较：*npm，它是一个可以充当轻量级构建工具的包管理器，以及 *Gulp，一个以代码驱动的构建工具，它与 Grunt 有几个共同约定。
- en: If you’re curious about other build tools such as Gulp or using npm run as a
    build system, then you should read more about the topic in [appendix C](kindle_split_024.html#app03),
    which covers picking your own build tool.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对手动构建工具（如 Gulp）或使用 npm run 作为构建系统感兴趣，那么你应该阅读 [附录 C](kindle_split_024.html#app03)
    中关于选择自己的构建工具的主题，它涵盖了选择构建工具的内容。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lint is a code-quality tool that’s perfect for keeping an interpreted program—such
    as those written in JavaScript—in check. Rather than firing up a browser to check
    if your code has any syntax errors, you can execute a lint program in the command
    line. It can tell you about potential problems in your code, such as undeclared
    variables, missing semicolons, or syntax errors. That being said, lint isn’t a
    magic wand: it won’t detect logic issues in your code, it’ll only warn you about
    syntax and style errors.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Lint 是一个代码质量工具，非常适合保持解释程序（如用 JavaScript 编写的程序）的秩序。你不需要打开浏览器来检查代码是否有语法错误，你可以在命令行中执行
    lint 程序。它可以告诉你代码中可能存在的问题，例如未声明的变量、缺少分号或语法错误。尽管如此，lint 并不是魔杖：它不会检测代码中的逻辑问题，它只会警告你关于语法和风格错误。
- en: 1.5.1\. Keeping code quality in check
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1. 保持代码质量
- en: Lint is useful for determining if a given piece of code contains any syntax
    errors. It also enforces a set of JavaScript coding best practice rules, which
    we’ll cover at the beginning of [part 2](kindle_split_016.html#part02), in [chapter
    5](kindle_split_017.html#ch05), when we look at modularity and dependency management.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Lint 可以用来确定给定的代码片段是否包含任何语法错误。它还强制执行一组 JavaScript 编码最佳实践规则，我们将在 [第二部分](kindle_split_016.html#part02)
    的开头，在 [第五章](kindle_split_017.html#ch05) 中介绍模块化和依赖关系管理时进行讨论。
- en: Around 10 years ago Douglas Crockford released JSLint, a harsh tool that checks
    code and tells us all the little things that are wrong with it. Linting exists
    to help us improve the overall quality of our code. A lint program can tell you
    about the potential issues with a snippet, or even a list of files, straight from
    the command line, and this has the added benefit that you don’t even have to execute
    the code to learn what’s wrong with it. This process is particularly useful when
    it comes to JavaScript code, because the lint tool will act as a compiler of sorts,
    making sure that to the best of its knowledge your code can be interpreted by
    a JavaScript engine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大约 10 年前，Douglas Crockford 发布了 JSLint，这是一个严格的工具，可以检查代码并告诉我们代码中所有的小错误。Linting
    的存在是为了帮助我们提高代码的整体质量。一个 lint 程序可以直接从命令行告诉你代码片段或文件列表中可能存在的问题，并且这个额外的优点是，你甚至不需要执行代码就能了解它的错误。这个过程在处理
    JavaScript 代码时尤其有用，因为 lint 工具将充当某种编译器，确保你的代码在其知识范围内可以被 JavaScript 引擎解释。
- en: 'On another level, linters (the name given to lint programs) can be configured
    to warn you about code that’s too complex, such as functions that include too
    many lines, obscure constructs that might confuse other people (such as `with`
    blocks, `new` statements, or using `this` too aggressively, in the case of JavaScript),
    or similar code style checks. Take the following code snippet as an example (listed
    as ch01/01_lint-sample in the samples online):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个层面上，linters（给 lint 程序起的名字）可以被配置为警告你关于过于复杂的代码，例如包含太多行的函数，可能使其他人困惑的复杂结构（例如
    `with` 块、`new` 语句，或者在 JavaScript 中过于积极地使用 `this`），或者类似的代码风格检查。以下代码片段是一个例子（在线样本中列为
    ch01/01_lint-sample）：
- en: '[PRE0]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Plenty of problems are readily apparent in this small piece, but they may not
    be that easy to spot. When analyzed through JSLint, you’ll get both expected and
    interesting results. It’ll complain that you must declare your variables before
    you try to use them, or that you’re missing semicolons. Depending on the lint
    tool you use, it might complain about your use of the `this` keyword. Most linters
    will also complain about the way you’re using `||` rather than using a more readable
    `if` statement. You can lint this sample online.^([[2](#ch01fn02)]) [Figure 1.5](#ch01fig05)
    shows the output of Crockford’s tool.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小片段中，有很多问题很容易看出，但它们可能并不那么容易发现。当通过 JSLint 分析时，你会得到预期和有趣的结果。它会抱怨你必须在使用变量之前声明它们，或者你遗漏了分号。根据你使用的
    lint 工具，它可能会抱怨你对 `this` 关键词的使用。大多数 linters 也会抱怨你使用 `||` 而不是使用更易读的 `if` 语句的方式。你可以在网上
    lint 这个样本.^([[2](#ch01fn02)]) [图 1.5](#ch01fig05) 展示了 Crockford 工具的输出。
- en: ² Go to [http://jslint.com](http://jslint.com) for the online sample. This is
    the original JavaScript linter Crockford maintains.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 访问 [http://jslint.com](http://jslint.com) 以获取在线样本。这是 Crockford 维护的原始 JavaScript
    linter。
- en: Figure 1.5\. Lint errors found in a code snippet.
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. 代码片段中发现的 lint 错误。
- en: '![](01fig05_alt.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig05_alt.jpg)'
- en: In the case of compiled languages, these kinds of errors are caught whenever
    you attempt to compile your code, and you don’t need any lint tools. In JavaScript,
    though, there’s no compiler because of the dynamic nature of the language. This
    is decidedly powerful, but also more error-prone than what you might expect from
    compiled languages, which wouldn’t even allow you to execute the code in the first
    place.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译型语言，这些错误会在你尝试编译代码时被捕获，你不需要任何 lint 工具。然而，在 JavaScript 中，由于语言的动态性，没有编译器。这无疑是强大的，但与编译语言相比，更容易出错，编译语言甚至不允许你首先执行代码。
- en: Instead of being compiled, JavaScript code is interpreted by an engine such
    as V8 (as seen in Google Chrome) or SpiderMonkey (the engine powering Mozilla
    Firefox). Where other engines do compile the JavaScript code, most famously the
    V8 engine, you can’t benefit from their static code analysis outside the browser.^([[3](#ch01fn03)])
    One of the perceived disadvantages of dynamic languages like JS is that you can’t
    know for sure whether code will work when you execute it. Although that’s true,
    you can vastly diminish this uncertainty using a lint tool. Furthermore, JSLint
    advises us to stay away from certain coding style practices such as using `eval,`
    leaving variables undeclared, omitting braces in block statements, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与编译不同，JavaScript 代码由像 V8（如 Google Chrome 中所见）或 SpiderMonkey（Mozilla Firefox
    的引擎）这样的引擎进行解释。在其他引擎确实会编译 JavaScript 代码的情况下，最著名的是 V8 引擎，你无法从浏览器之外受益于它们的静态代码分析.^([[3](#ch01fn03)])
    动态语言如 JS 的一个明显缺点是，当你执行代码时，你无法确定代码是否真的能工作。虽然这是真的，但你可以使用 lint 工具极大地减少这种不确定性。此外，JSLint
    建议我们避免某些编码风格实践，例如使用 `eval,` 留下未声明的变量，省略块语句中的大括号，等等。
- en: ³ You can see Node.js, a server-side JavaScript platform that also runs on V8,
    in effect in the console instead, but by the time V8 detects syntax issues, it’ll
    be too late for your program, which will implode. It’s always best to lint first,
    regardless of the platform.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 你可以在控制台中看到 Node.js，这是一个在 V8 上运行的 JavaScript 服务器端平台，但实际上，当 V8 检测到语法问题时，你的程序已经崩溃，那时就太晚了。无论如何，最好先进行
    lint。
- en: 'Has your eye caught a potential problem in the last code snippet function we
    looked at? Check out the accompanying code sample ([chapter 1](#ch01), 01_lint-sample)
    to verify your answer! Hint: the problem lies in repetition. The fixed version
    is also found in the source code example; make sure to check out all that good
    stuff.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否在最后一段代码片段函数中发现了潜在的问题？请查看相关的代码示例([第1章](#ch01), 01_lint-sample)以验证您的答案！提示：问题在于重复。修复后的版本也包含在源代码示例中；请确保查看所有这些好东西。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Understanding the source code that comes with this book**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解本书附带源代码**'
- en: The source code included with this book has many nuggets of information, including
    a tweaked version of the linting example function, which passes the lint verification,
    fully commented to let you understand the changes made to it. The sample also
    goes on to explain that linters aren’t bulletproof.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带源代码中包含许多信息要点，包括一个经过调整的代码检查示例函数，该函数通过了代码检查，并进行了全面注释，以便您理解对其所做的更改。示例还进一步解释说，代码检查工具并非万无一失。
- en: The other code samples in the book contain similar pieces of advice and nuggets
    of information, so be sure to check them out! Samples are organized by chapter,
    and they appear in the same order as in the book. Several examples are only discussed
    at a glance in the book, but all of the accompanying code samples are fully documented
    and ready to use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的其他代码示例包含类似的建议和信息要点，所以请务必查看它们！示例按章节组织，并按与书中相同的顺序出现。书中只简要讨论了一些示例，但所有相关的代码示例都进行了全面文档化，并准备好使用。
- en: The reason for this discrepancy between code in the book and the source code
    is that sometimes I want to explain a topic, but there may be too much code involved
    to be included in the book. In those cases, I didn’t want to drift too much from
    the concept in question, but still wanted you to have the code. This way you can
    focus on learning while reading the book, and focus on experimenting when browsing
    the code samples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异的原因在于，有时我想解释一个主题，但涉及到的代码可能太多，无法包含在书中。在这种情况下，我不想偏离问题的概念太远，但仍然希望您拥有这些代码。这样，您在阅读书籍时可以专注于学习，在浏览代码示例时可以专注于实验。
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Linting is often referred to as the first test you should set up when writing
    JavaScript. Where linters fail, unit tests come in. This isn’t to say that using
    linters is unnecessary, but rather, that linting alone is insufficient! Unit testing
    helps ensure your code behaves the way you expect it to. Unit testing is discussed
    in [chapter 8](kindle_split_020.html#ch08), where you’ll learn how to write tests
    for the code you develop throughout [part 2](kindle_split_016.html#part02), which
    is dedicated to writing modular, maintainable, and testable JavaScript code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查通常被称为在编写JavaScript时应该设置的第一项测试。当代码检查工具失败时，单元测试就派上用场了。这并不是说使用代码检查工具是不必要的，而是说仅仅进行代码检查是不够的！单元测试有助于确保您的代码按预期运行。单元测试在第[8章](kindle_split_020.html#ch08)中讨论，您将学习如何为[第2部分](kindle_split_016.html#part02)中开发的代码编写测试，[第2部分]是专门用于编写模块化、可维护和可测试的JavaScript代码的。
- en: Next up, you’ll start putting together a build process from scratch. You’ll
    start small, setting up a task to lint the code, then running it from the command
    line, similar to how the process looks if you use a compiler; you’ll learn to
    make a habit of running the build every time you make a change and see whether
    the code still “compiles” against the linter. [Chapter 3](kindle_split_014.html#ch03)
    teaches you how to have the build run itself, so you don’t have to repeat yourself
    like that, but it’ll be fine for the time being.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将从零开始构建一个构建过程。您将从设置一个用于检查代码的任务开始，然后从命令行运行它，类似于使用编译器时的过程；您将学会每次更改时都运行构建，并查看代码是否仍然“编译”通过代码检查器。[第3章](kindle_split_014.html#ch03)将教您如何让构建过程自动运行，这样您就不必重复这样做，但暂时这样做是可以的。
- en: How can you use a lint tool such as JSLint straight in the command line? Well,
    I’m glad you asked.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何在命令行中直接使用JSLint之类的代码检查工具？很高兴您提出了这个问题。
- en: 1.5.2\. Lint in the command line
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2\. 命令行中的代码检查
- en: One of the most common ways to add a task to a build process is to execute that
    task using a command line. If you execute the task from the command line, it’ll
    be easy to integrate it to your build process. You’re going to use JSHint^([[4](#ch01fn04)])
    to lint your software.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将任务添加到构建过程的最常见方法之一是使用命令行执行该任务。如果您从命令行执行任务，那么将其集成到构建过程中会很容易。您将使用JSHint^([[4](#ch01fn04)])来检查您的软件。
- en: ⁴ For more information on JSHint, see [http://jshint.com](http://jshint.com).
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 关于 JSHint 的更多信息，请参阅 [http://jshint.com](http://jshint.com)。
- en: JSHint is a command line tool that lints JavaScript files and snippets. It’s
    written in Node.js, which is a platform for developing applications using JavaScript.
    If you need a quick overview of Node.js fundamentals, refer to [appendix A](kindle_split_022.html#app01),
    where I explain what modules are and how they work. If you want a deeper analysis
    of Node.js, refer to *Node.js in Action* by Mike Cantelon et al. (Manning, 2013).
    Understanding this will also be useful when working with Grunt, our build tool
    of choice, in the next chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint 是一个命令行工具，用于检查 JavaScript 文件和代码片段。它是用 Node.js 编写的，Node.js 是一个用于使用 JavaScript
    开发应用程序的平台。如果你需要 Node.js 基础知识的快速概述，请参阅附录 A，我在其中解释了模块是什么以及它们是如何工作的。如果你想要对 Node.js
    进行更深入的分析，请参阅 Mike Cantelon 等人所著的《Node.js in Action》（Manning，2013）。了解这一点在下一章使用我们选择的构建工具
    Grunt 时也将非常有用。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Node.js explained**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js 解释**'
- en: Node is a relatively new platform you’ve surely heard of by now. It was initially
    released in 2009, and it follows event-driven and single-threaded patterns, which
    translates into high-performing concurrent request handling. In this regard, it’s
    comparable to the design in Nginx, a highly scalable multi-purpose—and very popular—reverse
    proxy server meant to serve static content and pipe other requests to an application
    server (such as Node).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Node 是一个相对较新的平台，你现在可能已经听说过它了。它最初于 2009 年发布，遵循事件驱动和单线程模式，这转化为高性能的并发请求处理。在这方面，它与
    Nginx 的设计相似，Nginx 是一个高度可扩展的多用途且非常流行的反向代理服务器，旨在提供静态内容并将其他请求管道传输到应用服务器（如 Node）。
- en: Node.js has been praised as particularly easy to adopt by front-end engineers,
    considering it’s merely JavaScript on the server side (for the most part). It
    also made it possible to abstract the front end from the back end entirely,^([[a](#ch01fn01a)])
    only interacting through data and REST API interfaces, such as the one you’ll
    learn to design and then build in [chapter 9](kindle_split_021.html#ch09).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Node.js 主要是服务器端的 JavaScript（大部分情况下），它被赞扬为前端工程师特别容易采用。它还使得将前端从后端完全抽象出来成为可能，仅通过数据和
    REST API 接口进行交互，例如你将在第 9 章中学习设计和构建的接口。
- en: ^a For more information on abstracting the front end from the back end, see
    [http://bevacqua.io/bf/node-frontend](http://bevacqua.io/bf/node-frontend).
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a 关于从后端抽象前端的信息，请参阅 [http://bevacqua.io/bf/node-frontend](http://bevacqua.io/bf/node-frontend)。
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Node.js and JSHint Installation
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Node.js 和 JSHint 安装
- en: Here are the steps for installing Node.js and the JSHint command-line interface
    (CLI) tool. Alternative Node.js installation methods and troubleshooting are also
    offered in [appendix A](kindle_split_022.html#app01).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是安装 Node.js 和 JSHint 命令行界面（CLI）工具的步骤。附录 A 中还提供了替代的 Node.js 安装方法和故障排除信息。
- en: '**1**.  Go to [http://nodejs.org](http://nodejs.org), as shown in [figure 1.6](#ch01fig06),
    and click on the INSTALL button to download the latest version of node.'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  按照图 1.6 所示，访问 [http://nodejs.org](http://nodejs.org)，并点击 INSTALL 按钮下载最新版本的
    Node。'
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 1.6\. The [http://nodejs.org](http://nodejs.org) website
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6\. [http://nodejs.org](http://nodejs.org) 网站
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](01fig06_alt.jpg)'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](01fig06_alt.jpg)'
- en: '**2**.  Execute the downloaded file and follow the installation instructions.'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  执行下载的文件，并按照安装说明进行操作。'
- en: You’ll get a command-line tool called `npm` (Node Package Manager) for free,
    as it comes bundled with Node. This package manager, `npm`, can be used from your
    terminal to install, publish, and manage modules in your node projects. Packages
    can be installed on a project-by-project basis or they can be installed globally,
    making them easier to access directly in the terminal. In reality, the difference
    between the two is that globally installed packages are put in a folder that’s
    in the PATH environment variable, and those that aren’t are put in a folder named
    `node_modules` in the same folder you’re in when you execute the command. To keep
    projects self-contained, local installs are always preferred. But in the case
    of utilities such as the JSHint linter, which you want to use system-wide, a global
    install is more appropriate. The `-g` modifier tells `npm` to install `jshint`
    globally. That way, you can use it on the command line as `jshint.`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你将免费获得一个命令行工具 `npm`（Node 包管理器），因为它与 Node 一起捆绑。这个包管理器 `npm` 可以从你的终端用来安装、发布和管理你的
    node 项目的模块。模块可以按项目安装，或者全局安装，这使得它们更容易在终端中直接访问。实际上，两者的区别在于全局安装的包被放在一个在 PATH 环境变量中的文件夹里，而那些不是的则被放在你执行命令时的同一文件夹中的
    `node_modules` 文件夹里。为了保持项目自包含，本地安装总是首选。但在你希望系统范围内使用，如 JSHint 检查器这样的实用工具时，全局安装更为合适。`-g`
    修饰符告诉 `npm` 全局安装 `jshint`。这样，你就可以在命令行上使用 `jshint`。
- en: '**1**.  Open your favorite terminal window and execute `npm install -g jshint`,
    as shown in [figure 1.7](#ch01fig07). If it failed, you may need to use `sudo`
    to get elevated privileges; for example, `sudo npm install -g jshint.`'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 打开你喜欢的终端窗口并执行 `npm install -g jshint`，如图 1.7 所示。如果失败，你可能需要使用 `sudo`
    获取提升的权限；例如，`sudo npm install -g jshint.`。'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 1.7\. Installing jshint through npm
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.7\. 通过 npm 安装 jshint
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](01fig07_alt.jpg)'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](01fig07_alt.jpg)'
- en: '**2**.  Run `jshint --version.` It should output the version number for the
    `jshint` program, as shown in [figure 1.8](#ch01fig08). It’ll probably be a different
    version, as module versions in actively developed packages change frequently.'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 运行 `jshint --version.` 应该会输出 `jshint` 程序的版本号，如图 1.8 所示。可能版本不同，因为活跃开发中的模块版本经常变化。'
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 1.8\. Verifying `jshint` works in your terminal
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.8\. 验证 `jshint` 在你的终端中是否工作
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](01fig08_alt.jpg)'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](01fig08_alt.jpg)'
- en: The next section explains how to lint your code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解释如何检查你的代码。
- en: Linting your code
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查你的代码
- en: You should now have `jshint` installed on your system, and accessible in your
    terminal, as you’ve verified. To lint your code using JSHint, you can change directories
    using `cd` to your project root, and then type in `jshint .` (the dot tells JSHint
    to lint all of the files in the current folder). If the operation is taking too
    long, you may need to add the `--exclude node_modules` option; this way you’ll
    only lint your own code and ignore third-party code installed via `npm install`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经在你的系统上安装了 `jshint`，并在你的终端中可以访问，正如你已验证的那样。要使用 JSHint 检查你的代码，你可以使用 `cd`
    命令切换到你的项目根目录，然后输入 `jshint .`（点号告诉 JSHint 检查当前文件夹中的所有文件）。如果操作耗时过长，你可能需要添加 `--exclude
    node_modules` 选项；这样你将只检查你自己的代码，并忽略通过 `npm install` 安装的第三方代码。
- en: When the command completes, you’ll get a detailed report indicating the status
    of your code. If your code has any problems, the tool will report the expected
    result and line number for each of those problems. Then it will exit with an error
    code, allowing you to “break the build” if the lint fails. Whenever a build task
    fails to produce the expected output, the entire process should be aborted. This
    presents a number of benefits because it prevents work from continuing if something
    goes wrong, refusing to complete a build until you fix any issues. [Figure 1.9](#ch01fig09)
    shows the results of linting a snippet of code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 命令完成后，你会得到一个详细报告，指示你的代码状态。如果你的代码有任何问题，该工具将报告每个问题的预期结果和行号。然后它将以错误代码退出，允许你在检查失败时“中断构建”。每当构建任务未能产生预期的输出时，整个过程应该被终止。这带来了一系列好处，因为它防止了在出现问题时继续工作，拒绝完成构建直到你修复任何问题。[图
    1.9](#ch01fig09) 展示了检查代码片段的结果。
- en: Figure 1.9\. Linting with JSHint from your terminal
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.9\. 从终端使用 JSHint 检查
- en: '![](01fig09.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig09.jpg)'
- en: 'Once JSHint is all set, you might be tempted to call it a day, because it’s
    your only task; however, that wouldn’t scale up nicely if you want to add extra
    tasks to your build. You might want to include a unit testing step in your build
    process; this becomes a problem because you now have to run at least two commands:
    `jshint` and another one to execute your tests. That doesn’t scale well. Imagine
    remembering to use `jshint` and half a dozen other commands complete with their
    parameters. It would be too cumbersome, hard to remember, and error prone. You
    wouldn’t want to lose half a billion dollars, would you?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JSHint设置完成，你可能会想就此结束，因为那似乎是你唯一要完成的任务；然而，如果你想要添加额外的构建任务，这样做并不会很好地扩展。你可能想在构建过程中包含一个单元测试步骤；这会变成一个问题，因为你现在至少需要运行两个命令：`jshint`和另一个执行测试的命令。这样扩展并不好。想象一下，记得使用`jshint`以及半打其他带有参数的命令。这将非常繁琐，难以记住，且容易出错。你不想损失五亿美元，对吧？
- en: Then you better start putting your build tasks together, because even if you
    only have a single one for now, you’ll soon have a dozen! Composing a build process
    helps you think in terms of automation, and it’ll help you save time by avoiding
    repetition of steps.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你最好开始整理你的构建任务，因为即使你现在只有一个，很快你将会有十几个！编写构建过程有助于你从自动化的角度思考，并且它将通过避免重复步骤来帮助你节省时间。
- en: Every language has its own set of build tools you can use. Most have a tool
    that stands out and sees far wider adoption than the rest. When it comes to JavaScript
    build systems, Grunt is one of the most popular tools, with thousands of plugins
    (to help you with build tasks) to pick from. If you’re writing a build process
    for another language, you’ll probably want to research your own. Even though the
    build tasks in the book are written in JavaScript and use Grunt, the principles
    I describe should apply to almost any language and build tool.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都有自己的构建工具集，你可以使用。大多数语言都有一个突出的工具，其采用率远高于其他工具。当谈到JavaScript构建系统时，Grunt是最受欢迎的工具之一，拥有数千个插件（帮助你完成构建任务）可供选择。如果你正在为另一种语言编写构建过程，你可能需要研究自己的。尽管本书中的构建任务是用JavaScript编写的并使用了Grunt，但我描述的原则几乎适用于任何语言和构建工具。
- en: Flip over to [chapter 2](kindle_split_013.html#ch02) to see how you can integrate
    JSHint into Grunt, as you begin your hands-on journey through the land of build
    processes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 翻到[第二章](kindle_split_013.html#ch02)，看看你如何可以将JSHint集成到Grunt中，作为你开始通过构建过程领域的实际操作之旅。
- en: 1.6\. Summary
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6. 摘要
- en: 'This chapter serves as an overview of the concepts you’ll dig into throughout
    the rest of the book. Here are highlights about what you’ve learned in this chapter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为概述，介绍了你在本书其余部分将要深入探讨的概念。以下是本章你所学到的重点内容：
- en: Modern JavaScript application development is problematic because of the lack
    of regard given to design and architecture.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代JavaScript应用程序开发由于缺乏对设计和架构的关注而存在问题。
- en: Build First is a solution that enables automated processes and maintainable
    application design, and encourages you to think about what you’re building.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建优先是一个能够实现自动化流程和维护性应用程序设计的解决方案，并鼓励你思考你正在构建的内容。
- en: You learned about lint and ran code through a linter, improving its code quality
    without using a browser.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了lint，并通过lint运行代码，在不使用浏览器的情况下提高了其代码质量。
- en: In [part 1](kindle_split_011.html#part01) you’ll learn all about build processes,
    deployments, and environment configuration. You’ll use Grunt to develop builds,
    and in [appendix C](kindle_split_024.html#app03) you’ll learn about other tools
    you can use.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第一部分](kindle_split_011.html#part01)中，你将了解所有关于构建过程、部署和环境配置的内容。你将使用Grunt来开发构建，并在[附录C](kindle_split_024.html#app03)中了解你可以使用的其他工具。
- en: '[Part 2](kindle_split_016.html#part02) is dedicated to complexity in application
    design. Modularity, asynchronous code flows, application and API design, and testability
    all have a role to play, and they come together in [part 2](kindle_split_016.html#part02).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二部分](kindle_split_016.html#part02)致力于应用程序设计中的复杂性。模块化、异步代码流、应用程序和API设计以及可测试性都扮演着角色，它们在[第二部分](kindle_split_016.html#part02)中汇集在一起。'
- en: You’ve barely scratched the surface of what you can achieve using a Build First
    approach to application design! We have much ground to cover! Let’s move to [chapter
    2](kindle_split_013.html#ch02), where we’ll discuss the most common tasks you
    might need to perform during a build and go over implementation examples using
    Grunt.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎还没有触及使用“构建优先”方法进行应用程序设计所能实现的一切！我们还有很多内容要覆盖！让我们转到[第二章](kindle_split_013.html#ch02)，在那里我们将讨论你在构建过程中可能需要执行的最常见任务，并使用Grunt进行实现示例。
- en: Chapter 2\. Composing build tasks and flows
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章. 构建任务和流程的组成
- en: '*This chapter covers*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding what should happen in a build
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解构建中应该发生什么
- en: Learning about key build tasks
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解关键构建任务
- en: Using Grunt to run key tasks
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Grunt 运行关键任务
- en: Configuring a build flow using Grunt
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Grunt 配置构建流程
- en: Creating your own Grunt tasks
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的 Grunt 任务
- en: In the previous chapter you got a quick overview of what the Build First approach
    looks like, and you glanced at a lint task. In this chapter, we’ll go over common
    build tasks and a few more advanced ones. I’ll uncover the use cases and reasoning
    behind each of them, and we’ll look at how to implement them in Grunt. Learning
    the theory might sound dull, but it’s particularly important if you use a task
    runner other than Grunt, as I’m sure you will eventually.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你快速了解了“先构建”方法的样子，并浏览了一个代码检查任务。在本章中，我们将讨论常见的构建任务和一些更高级的任务。我将揭示每个任务的使用案例和背后的原因，并探讨如何在
    Grunt 中实现它们。学习理论可能听起来很枯燥，但如果你使用的是除了 Grunt 之外的任务运行器，那么这尤其重要，我相信你最终会这样做的。
- en: Grunt is a configuration-driven build tool that helps set up complex tasks easily—if
    you know what you’re doing. Using Grunt, you’ll compose workflows, such as those
    I described in [chapter 1](kindle_split_012.html#ch01), which could be tuned for
    development productivity or optimized for releases. Similarly, Grunt helps with
    deployment procedures, which you’ll analyze in [chapter 4](kindle_split_015.html#ch04).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 是一个配置驱动的构建工具，它可以帮助你轻松地设置复杂的任务——如果你知道你在做什么。使用 Grunt，你可以组合工作流程，例如我在[第 1
    章](kindle_split_012.html#ch01)中描述的，这些工作流程可以调整以提高开发效率或优化发布。同样，Grunt 还有助于部署流程，你将在[第
    4 章](kindle_split_015.html#ch04)中分析这些流程。
- en: This chapter focuses on build tasks rather than trying to teach you everything
    about Grunt. You can always learn to use a new tool, as long as you understand
    the concepts underlying its goals, but you can’t learn to use other tools properly
    if you don’t understand those underlying concepts. If you want a deeper understanding
    of Grunt itself, check out [appendix B](kindle_split_023.html#app02). Reading
    that appendix isn’t instrumental to understanding this chapter; however, it does
    define the Grunt features you’ll use throughout [part 1](kindle_split_011.html#part01).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍构建任务，而不是试图教你关于 Grunt 的所有内容。只要你理解其目标背后的概念，你就可以学习使用新的工具，但如果你不理解这些基本概念，你就无法正确地学习使用其他工具。如果你想更深入地了解
    Grunt 本身，请查看[附录 B](kindle_split_023.html#app02)。阅读该附录对于理解本章内容并非至关重要；然而，它确实定义了你在[第一部分](kindle_split_011.html#part01)中将要使用的
    Grunt 功能。
- en: We’ll begin this chapter with a quick introduction to Grunt and its core concepts;
    then you’ll spend the rest of the chapter learning about build tasks and using
    a few different tools. We’ll look at preprocessing (per Manning MOS) tasks such
    as compiling code into another language, postprocessing (per Manning MOS) tasks
    such as asset minification and image spriting, and code integrity tasks such as
    running JavaScript unit tests and linting CSS code. Then you’ll learn how to write
    your own build tasks in Grunt, and you’ll look at a case study on writing your
    own set of database schema update tasks, complete with rollbacks!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章开始于对 Grunt 及其核心概念的快速介绍；然后你将在本章的剩余部分学习关于构建任务和使用一些不同的工具。我们将探讨预处理（按照 Manning
    MOS）任务，例如将代码编译成另一种语言，后处理（按照 Manning MOS）任务，例如资产压缩和图像精灵化，以及代码完整性任务，例如运行 JavaScript
    单元测试和检查 CSS 代码。然后你将学习如何在 Grunt 中编写自己的构建任务，并查看一个编写自己的数据库模式更新任务案例研究，包括回滚！
- en: Let’s get started!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 2.1\. Introducing Grunt
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 介绍 Grunt
- en: Grunt^([[1](#ch02fn01)]) is a task runner that helps you execute commands, run
    JavaScript code, and configure different tasks with the configuration written
    entirely in JavaScript. Grunt borrows its build concepts from Ant, and allows
    you to define your flows using JavaScript.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt^([[1](#ch02fn01)]) 是一个任务运行器，它帮助你执行命令、运行 JavaScript 代码，并使用完全用 JavaScript
    编写的配置来配置不同的任务。Grunt 从 Ant 中借用了其构建概念，并允许你使用 JavaScript 定义你的流程。
- en: ¹ Learn more about Grunt at [http://bevacqua.io/bf/grunt](http://bevacqua.io/bf/grunt).
    You should also take a look at [appendix B](kindle_split_023.html#app02).
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 在 [http://bevacqua.io/bf/grunt](http://bevacqua.io/bf/grunt) 上了解更多关于 Grunt
    的信息。你还应该查看[附录 B](kindle_split_023.html#app02)。
- en: '[Figure 2.1](#ch02fig01) dissects Grunt at a high level, showing how it can
    be configured and what the key players are in defining a build task.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.1](#ch02fig01) 从高层次上剖析了 Grunt，展示了如何配置它以及定义构建任务中的关键角色。'
- en: 'Figure 2.1\. Grunt at a glance: tasks and targets are combined in configuration.'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 一瞥Grunt：任务和目标在配置中结合。
- en: '![](02fig01_alt.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig01_alt.jpg)'
- en: '*Tasks* perform an action.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*任务*执行一个动作。'
- en: '*Targets* help define a context for those tasks.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标*帮助定义任务的上下文。'
- en: '*Task configuration* allows you to determine options for a particular task-target
    combination.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*任务配置*允许你确定特定任务-目标组合的选项。'
- en: Grunt tasks are configured in JavaScript and most of the configuring can be
    done by passing an object to the `grunt.initConfig` method, describing the files
    affected by the task, and passing in a few options to tweak the behavior for a
    particular task target.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt任务在JavaScript中配置，大部分配置可以通过传递一个对象给`grunt.initConfig`方法来完成，描述受任务影响的文件，并传入一些选项来调整特定任务目标的行为了。
- en: In the case of a unit testing task, you might have a target that runs only a
    few tests for local development, or you may want to execute all the tests you
    have before a production release.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试任务的情况下，你可能只为本地开发运行几个测试，或者你可能在产品发布前执行所有测试。
- en: '[Figure 2.2](#ch02fig02) illustrates what task configuration looks like in
    JavaScript code, detailing the `grunt.initConfig` method and its conventions.
    Wildcards can be used when enumerating files, and using these patterns is called
    *globbing*; we’ll examine globbing in detail in [section 2.2.2](#ch02lev2sec5).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.2](#ch02fig02)展示了JavaScript代码中任务配置的样子，详细说明了`grunt.initConfig`方法和其约定。在列举文件时可以使用通配符，使用这些模式称为*globbing*；我们将在[2.2.2节](#ch02lev2sec5)中详细探讨globbing。'
- en: Figure 2.2\. Grunt task configuration in code explained. Each task and task
    target is configured individually.
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 代码中解释的Grunt任务配置。每个任务和任务目标都是单独配置的。
- en: '![](02fig02_alt.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig02_alt.jpg)'
- en: Tasks can be imported from *plugins*, which are Node modules (well-designed
    and self-contained pieces of code) containing one or more Grunt tasks. You only
    need to figure out what configuration to apply to them, and that’s it; the task
    itself is handled by the plugin. You’ll use plugins heavily throughout this chapter.^([[2](#ch02fn02)])
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以从*插件*中导入，这些插件是包含一个或多个Grunt任务的Node模块（设计良好且自包含的代码块）。你只需要确定要应用给它们的配置，然后就可以了；任务本身由插件处理。你将在本章中大量使用插件.^([[2](#ch02fn02)])
- en: ² You can search for Grunt plugins online at [http://gruntjs.com/plugins](http://gruntjs.com/plugins).
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 你可以在网上搜索Grunt插件，地址为[http://gruntjs.com/plugins](http://gruntjs.com/plugins)。
- en: You can also create your own tasks, as you’ll investigate in [sections 2.4](#ch02lev1sec4)
    and [2.5](#ch02lev1sec5). Grunt comes with a CLI (command-line interface) named
    `grunt`, which provides a simple interface to execute build tasks straight from
    the command line. Let’s install that.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建自己的任务，正如你将在[2.4节](#ch02lev1sec4)和[2.5节](#ch02lev1sec5)中调查的那样。Grunt附带一个名为`grunt`的CLI（命令行界面），它提供了一个简单的界面，可以直接从命令行执行构建任务。让我们来安装它。
- en: 2.1.1\. Installing Grunt
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 安装Grunt
- en: 'You should already have `npm`, the package manager that comes with Node, from
    the JSHint lint tool installation in [Chapter 1](kindle_split_012.html#ch01).
    Getting started with Grunt is simple. Type the following into your terminal, and
    it will install the `grunt`^([[3](#ch02fn03)]) CLI for you:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经从[第1章](kindle_split_012.html#ch01)中JSHint代码检查工具的安装中安装了`npm`，这是Node附带的包管理器。开始使用Grunt很简单。在你的终端中输入以下内容，它将为你安装`grunt`^([[3](#ch02fn03)])
    CLI：
- en: ³ Learn more about Grunt at [http://bevacqua.io/bf/grunt](http://bevacqua.io/bf/grunt).
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 在[http://bevacqua.io/bf/grunt](http://bevacqua.io/bf/grunt)了解更多关于Grunt的信息。
- en: '[PRE1]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `-g` flag indicates the package should be installed globally; that lets
    you execute `grunt` in your terminal, regardless of the current working directory.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`标志表示包应该全局安装；这让你可以在终端中执行`grunt`，无论当前工作目录是什么。'
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Find the accompanying annotated samples**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找配套的注释示例**'
- en: Check out the full working example in the accompanying source code. You’ll find
    it in the 01_intro-to-grunt folder, under the ch02 directory. The rest of the
    samples for this chapter can also be found in the ch02 directory. Most of them
    contain code annotations that can help you understand the sample if you’re struggling
    with it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 检查配套源代码中的完整工作示例。你可以在ch02目录下的01_intro-to-grunt文件夹中找到它。本章的其余示例也可以在ch02目录中找到。其中大部分包含代码注释，可以帮助你理解示例，如果你在理解示例上有困难的话。
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You’ll need to take one additional step, which is creating a `package.json`
    manifest file. These files describe Node projects. They indicate a list of packages
    the project depends upon, as well as metadata such as the project name, version,
    description, and homepage. For Grunt to work in your project, you need to add
    it as a development dependency in your `package.json.` It should be a development
    dependency because you won’t use Grunt anywhere other than your local development
    environment. You can create a bare minimum `package.json f`ile containing the
    following JSON code, and you should place it in your project root directory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要采取一个额外的步骤，即创建一个 `package.json` 清单文件。这些文件描述 Node 项目。它们指明了项目依赖的包列表，以及诸如项目名称、版本、描述和主页等元数据。为了让
    Grunt 在你的项目中工作，你需要将其添加为 `package.json` 中的开发依赖。它应该是一个开发依赖，因为你不会在其他任何地方使用 Grunt，除了你的本地开发环境。你可以创建一个包含以下
    JSON 代码的最小 `package.json` 文件，并将其放置在你的项目根目录中：
- en: '[PRE2]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’ll be enough. Node Package Manager (npm) can add the dependency to your
    `package.json` as long as the file exists and it contains a valid JSON object,
    even if it’s an empty {} object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那就足够了。Node 包管理器 (npm) 可以将依赖项添加到你的 `package.json` 中，只要文件存在并且包含一个有效的 JSON 对象，即使它是一个空的
    {} 对象。
- en: Installing Grunt Locally
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本地安装 Grunt
- en: Next up, you need to install the `grunt` package. This time, the `-g` modifier
    won’t do any good, because it needs to be a local install, not a global one^([[4](#ch02fn04)])—that’s
    why you created the `package.json` file. Use the `--save-dev` modifier instead,
    to indicate the module is a development dependency.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要安装 `grunt` 包。这次，`-g` 修饰符将不起作用，因为它需要是本地安装，而不是全局安装^([[4](#ch02fn04)))——这就是你创建
    `package.json` 文件的原因。使用 `--save-dev` 修饰符来表示模块是一个开发依赖。
- en: ⁴ Grunt requires you to make a local install for the Grunt package and any task
    plugins. This keeps your code working across different machines, because you can’t
    include global packages in your package.json manifest.
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ Grunt 要求你为 Grunt 包和任何任务插件进行本地安装。这确保了你的代码可以在不同的机器上工作，因为你不能在 package.json 清单中包含全局包。
- en: 'The command looks like this: `npm install --save-dev grunt`. After `npm` completes
    the installation, your `package.json` manifest will look like the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 命令看起来是这样的：`npm install --save-dev grunt`。在 `npm` 完成安装后，你的 `package.json` 清单将如下所示：
- en: '[PRE3]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition, the Grunt module will be installed to a `node_modules` directory
    inside your project. This directory will contain all the modules you’ll use as
    part of your Grunt setup, and they’ll be declared in the package manifest as well.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Grunt 模块将被安装到你的项目内部的 `node_modules` 目录中。这个目录将包含你作为 Grunt 设置一部分使用的所有模块，并且它们也会在包清单中声明。
- en: Creating a Gruntfile.js
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 Gruntfile.js 文件
- en: 'The last step is creating a `Gruntfile.js` file. Grunt uses this file to load
    any tasks that are available and configure them with any parameters you need.
    The following code shows the bare minimum `Gruntfile.js` module:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个 `Gruntfile.js` 文件。Grunt 使用此文件来加载任何可用的任务，并使用任何所需的参数来配置它们。以下代码显示了最小的
    `Gruntfile.js` 模块：
- en: '[PRE4]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note a few things about that innocent-looking file. Grunt files are Node
    modules that subscribe to the CommonJS Modules spec,^([[5](#ch02fn05)]) so the
    code you write in each file isn’t immediately accessible to others. The local
    `module` object is the implicit object, rather than a global object like `window`
    in the browser. When you import other modules, all you get is the public interface
    exposed in `module.exports`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意关于这个看起来无辜的文件的一些事项。Grunt 文件是遵循 CommonJS 模块规范的 Node 模块^([[5](#ch02fn05)))，因此你每个文件中编写的代码不会立即对他人可用。本地的
    `module` 对象是隐式对象，而不是像浏览器中的 `window` 这样的全局对象。当你导入其他模块时，你得到的是在 `module.exports`
    中公开的接口。
- en: ⁵ Read the Common.JS module specification at [http://bevacqua.io/bf/commonjs](http://bevacqua.io/bf/commonjs).
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 在 [http://bevacqua.io/bf/commonjs](http://bevacqua.io/bf/commonjs) 阅读Common.JS
    模块规范。
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Node modules**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node 模块**'
- en: You can learn more about Common.JS, the spec behind Node.js modules, in [appendix
    A](kindle_split_022.html#app01), which covers these modules. It will also be discussed
    in [chapter 5](kindle_split_017.html#ch05), when we talk about modularity. [Appendix
    B](kindle_split_023.html#app02) expands on [appendix A](kindle_split_022.html#app01),
    reinforcing your understanding of Grunt.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [附录 A](kindle_split_022.html#app01) 中了解更多关于 Common.JS 的信息，这是 Node.js 模块背后的规范，它涵盖了这些模块。它也将在
    [第 5 章](kindle_split_017.html#ch05) 中讨论，当我们谈到模块化时。[附录 B](kindle_split_023.html#app02)
    扩展了 [附录 A](kindle_split_022.html#app01)，以加强你对 Grunt 的理解。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `grunt.registerTask` line, in the previous code snippet, tells Grunt to
    define a default task that will be executed when you run `grunt` in the command
    line without any arguments. The array indicates a task alias, which will run all
    the tasks named in the array, if there are any. For instance, `['lint', 'build']`
    would run the lint task and then run the build task.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`grunt.registerTask` 行告诉 Grunt 定义一个默认任务，当你在命令行中不带任何参数运行 `grunt` 时将执行此任务。数组指示一个任务别名，如果存在，将运行数组中命名的所有任务。例如，`['lint',
    'build']` 将运行代码风格检查任务，然后运行构建任务。
- en: Running the `grunt` command at this point won’t achieve anything, because the
    only task you’ve registered is an empty task alias. You must be eager to set up
    your first Grunt task, so let’s do that.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行 `grunt` 命令不会产生任何效果，因为你注册的唯一任务是一个空的任务别名。你肯定迫不及待地想要设置你的第一个 Grunt 任务，那么让我们开始吧。
- en: 2.1.2\. Setting up your first Grunt task
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 设置你的第一个 Grunt 任务
- en: The first step in setting up a Grunt task is installing a plugin that does what
    you need; then you add configuration to the code, and you’re set up to run the
    task.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Grunt 任务的第一个步骤是安装一个执行你所需功能的插件；然后你添加配置到代码中，你就可以运行任务了。
- en: 'Grunt plugins are usually distributed as `npm` modules, which are pieces of
    JavaScript code someone published so you can use them. We’ll start by installing
    the JSHint plugin for Grunt, which will allow you to run JSHint using Grunt. Note
    that the `jshint` CLI tool you installed in [chapter 1](kindle_split_012.html#ch01)
    is completely unnecessary here; the Grunt plugin contains everything you need
    to run the task without the `jshint` CLI. The command shown below will fetch the
    JSHint Grunt plugin from the `npm` registry, install it to the `node_modules`
    directory, and add it to your `package.json` file as a development dependency:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 插件通常以 `npm` 模块的形式分发，这是某人发布的 JavaScript 代码片段，以便你可以使用。我们将首先安装 JSHint 插件，这将允许你使用
    Grunt 运行 JSHint。请注意，你在 [第 1 章](kindle_split_012.html#ch01) 中安装的 `jshint` CLI 工具在这里是完全不必要的；Grunt
    插件包含了你运行任务所需的所有内容，无需 `jshint` CLI。以下命令将从 `npm` 注册表中获取 JSHint Grunt 插件，将其安装到 `node_modules`
    目录，并将其添加到你的 `package.json` 文件中作为开发依赖项：
- en: '[PRE5]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next you need to tweak your Gruntfile, telling Grunt to lint the Gruntfile itself,
    because it’s JavaScript. You also need to tell it to load the JSHint plugin package,
    which contains the task that sets up the linting, and update your `default` task,
    so you can lint your code using `grunt` in your command line. The following listing
    (named ch02/01_intro-to-grunt in the code samples) shows how you can configure
    your Gruntfile.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要调整你的 Gruntfile 文件，告诉 Grunt 对其自身进行代码风格检查，因为它是 JavaScript 代码。你还需要告诉它加载
    JSHint 插件包，该包包含设置代码风格检查的任务，并更新你的 `default` 任务，这样你就可以在命令行中使用 `grunt` 对代码进行代码风格检查。以下列表（在代码示例中命名为
    ch02/01_intro-to-grunt）展示了如何配置你的 Gruntfile。
- en: Listing 2.1\. Example Gruntfile.js
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 示例 Gruntfile.js
- en: '![](028fig01_alt.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig01_alt.jpg)'
- en: Whenever you install a package, you’ll need to load it in the Gruntfile, using
    `grunt.loadNpmTasks,` as in [listing 2.1](#ch02ex01). It’ll load the tasks in
    the package so you can configure and execute them. Then you need to configure
    the tasks, which can be done by passing an object to `grunt.initConfig`. Each
    task plugin you use needs configuration, and I’ll teach you how to configure each
    one as we go through them. Lastly, I’ve updated the `default` alias to run the
    `jshint` task. The default alias defines what tasks are executed when `grunt`
    is executed without task arguments. Here’s a screenshot of the output.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你安装一个包时，你都需要在 Gruntfile 中加载它，使用 `grunt.loadNpmTasks`，就像在 [列表 2.1](#ch02ex01)
    中那样。它会加载包中的任务，以便你可以配置和执行它们。然后你需要配置这些任务，这可以通过将一个对象传递给 `grunt.initConfig` 来完成。你使用的每个任务插件都需要配置，我会在我们逐一介绍它们时教你如何配置每个插件。最后，我已经更新了
    `default` 别名以运行 `jshint` 任务。默认别名定义了当 `grunt` 在没有任务参数的情况下执行时将执行哪些任务。以下是输出结果的截图。
- en: Figure 2.3\. Our first Grunt task and its output. Our code is lint-free, meaning
    it doesn’t contain any syntax errors.
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 我们的第一个 Grunt 任务及其输出。我们的代码是经过代码风格检查的，这意味着它不包含任何语法错误。
- en: '![](02fig03.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig03.jpg)'
- en: 2.1.3\. Using Grunt to manage the build process
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 使用 Grunt 管理构建过程
- en: You’re pretty much in the same position as you were at the end of [chapter 1](kindle_split_012.html#ch01),
    where you could lint your JavaScript, except that you’re not. Grunt will help
    you put together the full-blown build process that’s at the heart of the Build
    First philosophy. With relative ease, you can focus on different tasks, depending
    on whether you’re building for local development or diagnostics, or building the
    end product humans will ultimately consume. Let’s examine a few properties found
    in build tasks.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎处于与第1章结束时的相同位置，当时你可以对你的JavaScript进行lint检查，只是你现在没有这样做。Grunt将帮助你构建一个完整的构建过程，这是“先构建”哲学的核心。你可以相对轻松地专注于不同的任务，取决于你是为本地开发或诊断构建，还是构建人类最终将消费的最终产品。让我们检查一下构建任务中发现的几个属性。
- en: 'The lint task you set up will serve as the basis for a much more powerful build,
    as you expand your understanding throughout [part 1](kindle_split_011.html#part01)
    of the book. This task innocently shows off one of the fundamental properties
    of build tasks: in the vast majority of cases, they’ll be *idempotent*—repeated
    execution of a task shouldn’t produce different results. In the case of the lint
    task, that might mean getting the same warnings every time, as long as you don’t
    change the source code. More often than not, build tasks are a function of one
    or many provided input files. The idempotence property, when paired with the fact
    that you shouldn’t perform any operations by hand, translates into more consistent
    results.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置的lint任务将成为一个更强大的构建的基础，因为你在阅读本书的第一部分[第1部分](kindle_split_011.html#part01)时扩展了你的理解。这个任务无意中展示了构建任务的一个基本属性：在绝大多数情况下，它们将是**幂等的**——任务的重复执行不应该产生不同的结果。在lint任务的情况下，这可能意味着每次都会得到相同的警告，只要你没有更改源代码。更常见的是，构建任务是一个或多个提供的输入文件的函数。幂等性属性，结合你不应该手动执行任何操作的事实，转化为更一致的结果。
- en: Creating Workflows and Continuous Development
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建工作流程和持续开发
- en: Tasks in your build are meant to follow a clearly defined set of steps to achieve
    a specific goal, such as preparing a release build. This is called a workflow,
    as mentioned in [chapter 1](kindle_split_012.html#ch01). Certain tasks may be
    optional for a particular workflow, while others might be instrumental. For instance,
    you have no incentive to optimize images, so they become smaller when working
    in your local development environment. Because it won’t yield any noticeable performance
    gains, it’s perfectly fine to skip that task in that case. Regardless of whether
    your workflow is meant for development or release, you’ll probably want to make
    sure to look out for issues with a lint task.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建中的任务旨在遵循一组明确定义的步骤以实现一个特定的目标，例如准备发布构建。正如第1章中提到的，这被称为工作流程。对于特定的工作流程，某些任务可能是可选的，而其他任务可能是关键的。例如，你没有优化图像的动机，所以在你的本地开发环境中，它们会变得更小。因为它不会带来任何明显的性能提升，所以在那种情况下跳过那个任务是完全可以接受的。无论你的工作流程是为开发还是发布而设计的，你可能都想确保留意lint任务的问题。
- en: '[Figure 2.4](#ch02fig04) will help you understand the development, release,
    and deployment pieces involved in a build process: how they relate to each other,
    and how they come together when composing different workflows.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.4](#ch02fig04)将帮助你理解构建过程中涉及的开发、发布和部署部分：它们如何相互关联，以及它们在组合不同的工作流程时如何结合在一起。'
- en: Figure 2.4\. Separation of concerns across build and deployment flows
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 构建和部署流程中的关注点分离
- en: '![](02fig04_alt.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig04_alt.jpg)'
- en: Development flow
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 开发流程
- en: With only a glance at the top row of the figure, you can already see that productivity
    and watching for changes are the key aspects of a development flow, while they’re
    completely unnecessary during the release flow, and perhaps even an obstacle.
    You may also notice that both flows produce a built application, although the
    one built during development is geared towards continuous development, as we’ll
    examine in depth in [chapter 3](kindle_split_014.html#ch03).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看一眼图的最上面一行，你就可以看到生产力和监视更改是开发流程的关键方面，而在发布流程中，它们是完全不必要的，甚至可能是一个障碍。你也可能注意到，这两个流程都会产生一个构建的应用程序，尽管在开发过程中构建的应用程序是为了持续开发，我们将在第3章中深入探讨。
- en: Release flow
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发布流程
- en: In the release flow, we’re concerned with performance optimization and building
    a well-tested application overall. Here we’ll run a slightly modified version
    of the development flow, where reducing the byte size of our application is at
    a premium.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布流程中，我们关注性能优化和构建一个经过良好测试的应用程序。在这里，我们将运行一个略微修改后的开发流程，其中减少应用程序的字节大小是首要任务。
- en: Deployment flow
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署流程
- en: The deployment flow doesn’t build the application at all. Instead, it reuses
    the build distribution prepared in one of the other two flows, and delivers it
    to a hosting environment. You’ll learn all about the deployment flow in [chapter
    4](kindle_split_015.html#ch04).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 部署流程根本不构建应用程序。相反，它重用了在其他两个流程中准备好的构建分发，并将其交付到托管环境中。你将在[第4章](kindle_split_015.html#ch04)中了解有关部署流程的所有内容。
- en: Any reasonable build flow needs to be automated every step of the way; otherwise
    you won’t meet the goal of increasing productivity and reducing error proclivity.
    During development, you should switch between your text editor and your browser,
    without having to execute a build by yourself. This is called *continuous development*,
    because the friction introduced by going into the shell and typing something to
    compile your application is removed. You’ll learn how to accomplish this using
    file watches and other mechanisms in [chapter 3](kindle_split_014.html#ch03).
    Deploying the application should be separate from the build flow, but it should
    also be automated; this enables you to build and deploy the application in a single
    step. Similarly, serving your application should be strictly separate from the
    build process.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合理的构建流程都需要在每一步都实现自动化；否则，你将无法达到提高生产力和减少错误倾向的目标。在开发过程中，你应该在文本编辑器和浏览器之间切换，而无需自己执行构建。这被称为*持续开发*，因为进入外壳并输入一些命令来编译应用程序所带来的摩擦被消除了。你将在[第3章](kindle_split_014.html#ch03)中学习如何使用文件监视和其他机制来完成这项任务。部署应用程序应该与构建流程分开，但也应该实现自动化；这使你能够一步构建和部署应用程序。同样，提供应用程序服务也应该严格与构建过程分开。
- en: In the next section, we’ll dive head first into build tasks using Grunt. Namely,
    we’ll start with preprocessing tasks such as taking LESS, a language that can
    be compiled into CSS, and postprocessing tasks, such as bundling and minifying,
    which help you optimize and fine-tune for releases.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨使用Grunt的构建任务。具体来说，我们将从预处理任务开始，例如将LESS（一种可以编译为CSS的语言）转换为CSS，以及后处理任务，如捆绑和压缩，这些任务有助于你优化和微调以发布。
- en: 2.2\. Preprocessing and static asset optimization
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 预处理和静态资产优化
- en: Whenever we talk about building a web application, we need to talk about preprocessing.
    Often, you’ll find yourself using languages that aren’t natively supported by
    internet browsers because they help you wrap away repetitive work by providing
    features not available to plain CSS (such as vendor prefixing), HTML, or JavaScript.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们谈论构建一个Web应用程序时，我们都需要谈论预处理。通常，你会发现自己在使用互联网浏览器原生不支持的语言，因为它们通过提供普通CSS（如供应商前缀）、HTML或JavaScript所不具备的功能，帮助你绕开重复性工作。
- en: The point here isn’t for you to learn LESS, a CSS preprocessor introduced in
    the following section, or even to learn CSS. Great resources are tailored to teach
    you that. The point is to make you aware of the glaring benefits of resorting
    to preprocessing languages. Preprocessing isn’t about CSS. *Preprocessors* help
    transform source code in a language into various target languages. For instance,
    the more powerful and expressive LESS language can be transformed into native
    CSS at build time. Reasons to use preprocessors may vary, but they can be categorized
    as more productivity, less repetition, or having a more pleasant syntax.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的不是让你学习LESS，一个在下一节中引入的CSS预处理器，甚至也不是学习CSS。有很好的资源专门教授这些。目的是让你意识到使用预处理语言的明显好处。预处理并不只是关于CSS。*预处理器*帮助将一种语言中的源代码转换为各种目标语言。例如，更强大和更具表现力的LESS语言可以在构建时转换为原生CSS。使用预处理器的理由可能各不相同，但它们可以归类为提高生产力、减少重复或拥有更愉悦的语法。
- en: '*Postprocessing* tasks such as minification and bundling are mostly meant to
    optimize a build for release purposes, but they’re related to preprocessing closely
    enough that they all belong in the same conversation. We’ll go over preprocessing,
    using LESS, and then we’ll dabble with globbing, a file path pattern-matching
    mechanism used in Grunt, before we move on to bundling and minification, which
    will tune your application’s performance for adequate human consumption.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*后处理*任务，如压缩和打包，主要是为了优化构建以供发布，但它们与预处理紧密相关，以至于它们都属于同一个话题。我们将讨论预处理，使用LESS，然后我们将涉猎globbing，这是在Grunt中使用的文件路径模式匹配机制，在我们继续到打包和压缩之前，这将调整你的应用程序的性能，以便适合人类消费。'
- en: By the end of the section you’ll have a much clearer picture of how assets can
    be preprocessed by using a different, more suitable language, and how they can
    be postprocessed, improving the performance to make the experience easier on humans.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将更清楚地了解如何使用不同的、更合适的语言对资产进行预处理，以及如何进行后处理，以提高性能，使人类体验更加顺畅。
- en: 2.2.1\. Discussing preprocessing
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 讨论预处理
- en: Language preprocessors are fairly common in web development nowadays. Unless
    you’ve been living under a rock for the last decade, you probably understand that
    preprocessors help you write cleaner code, as you first learned with lint in [chapter
    1](kindle_split_012.html#ch01), but require extra work to become useful. Plainly
    put, when you write code in a language that translates into another one, *preprocessing*
    is the translation step.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的Web开发中，语言预处理器相当普遍。除非你过去十年一直住在山洞里，否则你可能明白预处理器可以帮助你编写更干净的代码，就像你在[第1章](kindle_split_012.html#ch01)中第一次学习lint时那样，但需要额外的工作才能变得有用。简单来说，当你用一种翻译成另一种语言的编程语言编写代码时，*预处理*就是翻译步骤。
- en: 'You might not want to write code in the target language for several reasons:
    maybe it’s too repetitive, too error-prone, or you just don’t like that language.
    That’s where these higher-level languages, tuned to keeping your code concise
    and simple, come into play. Writing code in one of these higher-level languages
    comes at a price, though: browsers don’t understand them. Therefore, one of the
    most common build tasks you’ll encounter in front-end development is compiling
    that code down into something a browser understands, namely JavaScript and CSS
    styles.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能出于几个原因不想用目标语言编写代码：可能是因为它太重复了，太容易出错，或者你只是不喜欢那种语言。这就是这些高级语言发挥作用的地方，它们调整以保持你的代码简洁简单。然而，在高级语言中编写代码是有代价的：浏览器不理解它们。因此，你将在前端开发中遇到的最常见的构建任务之一就是将代码编译成浏览器能理解的东西，即JavaScript和CSS样式。
- en: Sometimes, preprocessors also offer practical benefits over the “native” languages
    of the web (HTML, CSS, and JavaScript). For example, several CSS preprocessors
    provide the necessary tools so you don’t need to target each browser. By removing
    these browser inconsistencies, preprocessing languages increase your productivity
    and make it less tedious to do your job.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，预处理器也会比Web的“原生”语言（HTML、CSS和JavaScript）提供实际的好处。例如，几个CSS预处理器提供了必要的工具，这样你就不需要针对每个浏览器。通过消除这些浏览器不一致性，预处理语言提高了你的生产力，并使你的工作不那么繁琐。
- en: LESS is more
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 少即是多
- en: Take LESS, for example. LESS is a powerful language that allows you to write
    code using a variant on CSS that follows the DRY (Don’t Repeat Yourself) principle
    of application design, because it helps you write code that’s less repetitive.
    In plain CSS, you often end up repeating yourself again and again, writing the
    same value for all the different vendor prefixes out there to maximize browser
    support of a style rule you want to apply.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以LESS为例。LESS是一种强大的语言，它允许你使用遵循DRY（不要重复自己）原则的应用程序设计变体来编写代码，因为它可以帮助你编写更少的重复代码。在纯CSS中，你经常会一遍又一遍地重复自己，为所有不同的供应商前缀编写相同的值，以最大化你想要应用的风格规则的浏览器支持。
- en: To illustrate the point, take the `border-radius` CSS property, used whenever
    you want to style an element with rounded borders. The following listing is how
    you might write them using plain CSS.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，以`border-radius` CSS属性为例，每当你要为具有圆角边框的元素设置样式时都会使用它。以下是如何使用纯CSS编写它们的示例。
- en: Listing 2.2\. Rounded borders in plain CSS
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.2\. 纯CSS中的圆角边框
- en: '![](032fig01_alt.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](032fig01_alt.jpg)'
- en: That might be fine for a one-time rule, but for properties such as `border-radius`,
    it quickly becomes unacceptable to write such plain CSS, because this scenario
    occurs too often. LESS allows you to code in a way that’s easier to write, read,
    and maintain. In this use case, you can set up a `.border-radius` reusable function,
    and the code becomes something like the following listing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性规则来说可能还可以，但对于像 `border-radius` 这样的属性，编写这样的纯 CSS 很快就会变得不可接受，因为这种情况太常见了。LESS
    允许你以更易于编写、阅读和维护的方式编码。在这个用例中，你可以设置一个 `.border-radius` 可重用函数，代码可能如下所示。
- en: Listing 2.3\. Rounded borders using LESS
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 使用 LESS 实现圆角边框
- en: '![](032fig02_alt.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片 032fig02_alt.jpg](032fig02_alt.jpg)'
- en: LESS and similar tools boost your productivity by allowing you to reuse snippets
    of CSS code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: LESS 和类似工具通过允许你重用 CSS 代码片段来提高你的生产力。
- en: LESS DRY is better than more WET
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LESS 的 DRY 比更多的 WET 更好
- en: As soon as you need to use the `border-radius` property in more than one place,
    you’ll reap the benefits of not writing everything twice (WET). By following the
    DRY principle, you avoid listing all four properties any time you need to specify
    a border. Instead, you can declare a border by reusing the `.border-radius` LESS
    mixin.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你需要在一个以上的地方使用 `border-radius` 属性，你将享受到不重复编写一切（WET）的好处。通过遵循 DRY 原则，你避免了每次需要指定边框时都列出所有四个属性。相反，你可以通过重用
    `.border-radius` LESS 混合来声明边框。
- en: 'Preprocessing plays a key role in a lean development workflow: now you don’t
    have to use all the vendor prefixes everywhere you want to use this rule, and
    you can update the prefixes in a single place, making your code more maintainable.
    LESS enables you to take this even further, if you want to cleanly separate static
    rules from the variables that affect them. Without LESS, a typical CSS design
    style sheet excerpt might look like the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理在精益开发工作流程中扮演着关键角色：现在你不需要在每个你想使用此规则的地方使用所有供应商前缀，你可以在一个地方更新前缀，使你的代码更易于维护。如果你想干净地分离静态规则和影响它们的变量，LESS
    使你可以更进一步。没有 LESS，一个典型的 CSS 设计样式表摘录可能看起来像以下代码：
- en: '[PRE6]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: LESS allows you to use variables so you don’t have to copy and paste colors
    everywhere. Properly naming these variables also helps you to easily identify
    the colors by scanning the style sheet.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: LESS 允许你使用变量，这样你就不必在各个地方复制粘贴颜色。适当地命名这些变量也有助于你通过扫描样式表轻松地识别颜色。
- en: Using LESS variables
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 LESS 变量
- en: 'Using LESS, you could set up variables for the colors and avoid potential mistakes
    such as updating a color in one place but forgetting to update other occurrences.
    This also enables you to keep colors and other variable elements of your design
    together. The following code shows how it might look using LESS:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LESS，你可以为颜色设置变量，避免潜在的错误，例如在一个地方更新颜色但忘记更新其他出现的地方。这也使你可以将颜色和其他设计变量元素放在一起。以下代码展示了使用
    LESS 可能的样子：
- en: '![](033fig01_alt.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片 033fig01_alt.jpg](033fig01_alt.jpg)'
- en: This way you can keep your code DRY, as I mentioned at the beginning of [section
    2.2](#ch02lev1sec2). Following the Don’t Repeat Yourself principle here is particularly
    useful because you avoid copying and pasting color codes, and that saves you the
    potential trouble of mistyping one. In addition, languages such as LESS (SASS,
    Stylus, and so on) provide functions to derive other colors, such as a darker
    green, a more transparent white, and other amusing color math.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你可以保持你的代码 DRY，正如我在 [第 2.2 节](#ch02lev1sec2) 开头提到的。遵循“不要重复自己”的原则在这里特别有用，因为它可以避免复制粘贴颜色代码，并节省你因误输入而可能遇到的麻烦。此外，像
    LESS（SASS、Stylus 等语言）这样的语言提供了推导其他颜色的函数，例如更深的绿色、更透明的白色以及其他有趣的颜色数学。
- en: Now, let’s turn our attention to compiling the LESS code into CSS within a Grunt
    task.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向在 Grunt 任务中将 LESS 代码编译成 CSS。
- en: 2.2.2\. Doing LESS
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 执行 LESS
- en: 'As we discussed earlier in the chapter, Grunt tasks consist of two different
    components—the task and the configuration:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面讨论的，Grunt 任务由两个不同的组件组成——任务和配置：
- en: 'The *task* itself is the single most important component: this is the code
    that will be executed by Grunt when you run a build, and generally you can find
    a plugin that does what you need.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*任务* 本身是最重要的单个组件：这是当你运行构建时 Grunt 将要执行代码，通常你可以找到一个插件来完成你需要的功能。'
- en: The *configuration* is an object you can pass to `grunt.initConfig`. Almost
    every Grunt task needs configuration.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置* 是你可以传递给 `grunt.initConfig` 的一个对象。几乎每个 Grunt 任务都需要配置。'
- en: 'As you progress through the rest of this chapter, you’ll see how to set up
    the configuration in each case. To compile LESS files with Grunt so you can serve
    CSS directly, you’re going to use the `grunt-contrib-less` package. Remember when
    you installed the JSHint plugin? Same thing here! Only the package name changes,
    because you’re going to use a different plugin now. To install it, run the following
    in your terminal:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续阅读本章的其余部分，你将看到如何设置每种情况下的配置。为了使用Grunt编译LESS文件以便直接提供CSS，你将使用`grunt-contrib-less`包。还记得你安装JSHint插件的时候吗？这里也是同样的情况！只是包名改变了，因为你现在将使用不同的插件。要安装它，请在你的终端中运行以下命令：
- en: '[PRE7]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This plugin provides a task named `less`, and you can load it in your `Gruntfile.js`
    like so:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件提供了一个名为`less`的任务，你可以在`Gruntfile.js`中这样加载它：
- en: '[PRE8]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From now on, I’ll omit the `npm install` and `grunt.loadNpmTasks` bits in the
    examples, for brevity. You still need to run `npm install` to fetch the packages
    and load the plugins in your Gruntfiles! In any case, you can look for the full
    examples for each case in the accompanying source code files.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，为了简洁，我将在示例中省略`npm install`和`grunt.loadNpmTasks`部分。你仍然需要运行`npm install`来获取包并加载你的Gruntfile中的插件！无论如何，你可以在配套的源代码文件中找到每种情况的完整示例。
- en: 'Setting up the build task is straightforward: you specify the output filename
    and provide it with the path to the source used to generate your CSS file. This
    example can be found as ch02/02_less-task in the code samples.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 设置构建任务很简单：你指定输出文件名并提供用于生成CSS文件的源路径。此示例可以在代码示例的ch02/02_less-task中找到。
- en: '[PRE9]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last piece of the puzzle for executing a task is invoking `grunt` from the
    command line. In this case, `grunt less` in your terminal should do the trick.
    Explicitly declaring a target is usually recommended. In this case, you could
    do that by typing `grunt less:compile`. If you don’t provide a target name, all
    targets get executed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 执行任务的最后一部分是从命令行调用`grunt`。在这种情况下，你的终端中的`grunt less`应该可以解决问题。明确声明目标通常推荐。在这种情况下，你可以通过键入`grunt
    less:compile`来实现。如果不提供目标名称，则所有目标都会执行。
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consistency in grunt configuration**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grunt配置的一致性**'
- en: Before we go any further, I want to mention a nicety you’ll enjoy as part of
    using Grunt. Task configuration patterns don’t vary all that much when jumping
    from task to task, particularly when using tasks supported by the Grunt team itself.
    Even those you might find on `npm` are pretty consistent with each other, as far
    as configuration goes. As you’ll learn throughout the chapter, the different tasks
    I’ll show you are configured similarly, even if they provide a wide array of operations
    in a versatile way.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想提到使用Grunt时你会喜欢的一个小优点。任务配置模式在任务之间跳跃时变化不大，尤其是在使用Grunt团队本身支持的任务时。即使在`npm`上找到的，它们在配置方面也相当一致。正如你将在本章中了解到的那样，我将向你展示的不同任务配置方式相似，即使它们以灵活的方式提供了广泛的操作。
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Running the `less:compile` build target in Grunt will now compile `layout.less`
    into `compiled.css`. You could also declare an array of input files, rather than
    using only one. This will result in a bundled file, which will contain the CSS
    for all of the LESS input files. We’ll cover bundling in full later on; bear with
    me. The following listing is an example.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grunt中运行`less:compile`构建目标现在会将`layout.less`编译成`compiled.css`。你也可以声明一个输入文件数组，而不仅仅使用一个。这将生成一个捆绑文件，其中将包含所有LESS输入文件的CSS。我们稍后会详细介绍捆绑；请耐心等待。以下列表是一个示例。
- en: Listing 2.4\. Declaring an array of input files
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 声明一个输入文件数组
- en: '[PRE10]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing each file individually is okay, but you could also use a pattern language
    called globbing and avoid enumerating hundreds of files, as I’ll explain next.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 单独列出每个文件是可以的，但你也可以使用一种称为globbing的模式语言，避免列举数百个文件，正如我接下来要解释的。
- en: Mastering globbing patterns
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 掌握globbing模式
- en: You could further improve the configuration shown in the previous code with
    a nice perk of using Grunt that’s called globbing. *Globbing*^([[6](#ch02fn06)])
    is a file path matching mechanism that will help you include or exclude files
    using file path patterns. It’s particularly useful because you don’t have to maintain
    a list of all the files in your assets folder, which helps you avoid common mistakes
    such as forgetting to add a new style sheet to the list.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用Grunt的globbing功能进一步改进前面代码中的配置，这是一个叫做globbing的额外好处。*Globbing*^([[6](#ch02fn06)])是一种文件路径匹配机制，它将帮助你使用文件路径模式包含或排除文件。它特别有用，因为你不必维护你的资产文件夹中所有文件的列表，这有助于你避免常见的错误，例如忘记将新的样式表添加到列表中。
- en: ⁶ The Grunt website has valuable insight into how globbing works. Go to [http://bevacqua.io/bf/globbing](http://bevacqua.io/bf/globbing).
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ Grunt 网站有关于 Globbing 如何工作的宝贵见解。访问 [http://bevacqua.io/bf/globbing](http://bevacqua.io/bf/globbing)。
- en: 'Globbing might also come in handy if you want to exclude individual files from
    a build task, such as those provided by a third party. The following code shows
    a few globbing patterns you might find useful:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从构建任务中排除单个文件，例如第三方提供的文件，Globbing 可能会很有用。以下代码展示了你可能发现有用的几个 Globbing 模式：
- en: '[PRE11]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note the following about the previous code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于前面代码的内容：
- en: The first pattern will match any file with a LESS extension in the `public`
    folder.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模式将匹配 `public` 文件夹中任何具有 LESS 扩展名的文件。
- en: The second pattern does much the same, except that it matches files that might
    be in subfolders of `public` of any nesting level thanks to the special `**` pattern.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个模式做的是同样的事情，只不过它通过特殊的 `**` 模式匹配 `public` 的任何嵌套级别的子文件夹中的文件。
- en: As you might’ve guessed, the last pattern works the same way as the second one
    does, except that the `!` at the beginning indicates that matched files should
    be excluded from the results.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所猜，最后一个模式与第二个模式的工作方式相同，只不过开头的 `!` 表示匹配的文件应该从结果中排除。
- en: Globbing patterns work in the order they’re presented, and they can be mixed
    with regular file paths too. Globbing patterns will result in arrays containing
    the path for all matching files.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Globbing 模式按照它们呈现的顺序工作，并且可以与常规文件路径混合使用。Globbing 模式将产生包含所有匹配文件路径的数组。
- en: 'Taking globbing patterns into consideration, our latest `less:compile` configuration
    might be refactored a little further, becoming a simplified version:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Globbing 模式，我们的最新 `less:compile` 配置可能需要进一步重构，成为一个简化的版本：
- en: '[PRE12]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before moving on, let me remind you that in this particular case `less` is the
    build task and `compile` is a build target for that task, which offers configuration
    specific to that target. You could easily provide different targets for the `less`
    task by adding other properties to the `less` object, like you did in the `compile`
    task target in the configuration you’re handing over to `initConfig`. For instance,
    you could have a `compile_mobile` target which would create the CSS assets targeting
    mobile devices, and a `compile_desktop` target that would compile assets targeting
    desktop browsers.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我提醒你，在这个特定的情况下，`less` 是构建任务，`compile` 是该任务的构建目标，它提供了针对该目标的特定配置。你可以通过向
    `less` 对象添加其他属性，像你在 `compile` 任务目标配置中传递给 `initConfig` 一样，轻松地为 `less` 任务提供不同的目标。例如，你可以有一个
    `compile_mobile` 目标，它将为移动设备创建 CSS 资产，以及一个 `compile_desktop` 目标，它将为桌面浏览器编译资产。
- en: It should be noted that as a side effect of using a globbing pattern to compile
    LESS using this task, your CSS will be bundled into a single file, regardless
    of how many files are used in the source code. So, let’s look into asset bundling
    now, a postprocessing task that will help you improve a site’s performance by
    reducing the amount of HTTP requests against it.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，作为使用此任务编译 LESS 的副作用，你的 CSS 将被捆绑到一个单独的文件中，无论源代码中使用了多少个文件。因此，现在让我们来看看资产捆绑，这是一个后处理任务，可以帮助你通过减少对网站的
    HTTP 请求量来提高网站的性能。
- en: 2.2.3\. Bundling static assets
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3. 静态资产捆绑
- en: I’ve hinted at what bundling accomplishes, and you might’ve heard about it before
    embarking on this enlightening adventure of ours. It’s okay if you’ve never heard
    of bundling before; it’s not a hard concept to wrap your head around.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经暗示了捆绑能完成什么，你可能在开始这次有启发性的冒险之前就已经听说过它。如果你之前从未听说过捆绑，那也没有关系；这是一个容易理解的概念。
- en: '*Asset bundling* is a fancy name for putting everything together before you
    hand it over to your clients. It’s like the difference between going to the store
    for a single grocery item and coming back home, only to go back to the grocery
    store to get another item on the list again and again, and going to the grocery
    store once and buying all of your groceries at one time.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*资产捆绑* 是在将内容交给客户之前将其全部组合在一起的一个时髦名称。这就像去商店买一个单独的杂货项目和回家，然后再次回到商店去清单上的另一个项目，一次又一次地回到商店，而是一次去商店并一次性购买所有杂货。'
- en: Handing over everything in a single HTTP response reduces transactional network
    costs and benefits everyone. The payload might become larger, but it saves clients
    many unnecessary network trips to your server, which incur associated networking
    costs such as latency, the TCP and TLS handshakes, and so on. If you’d like to
    learn more about the underlying internet protocols (TCP, TLS, UDP, HTTP, and so
    on), I highly recommend *High Performance Browser Networking* by Ilya Grigorik
    (O’Reilly Media, 2013).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个HTTP响应中发送所有内容可以减少事务性网络成本，并使每个人都受益。负载可能会变得更大，但它可以节省客户端许多不必要的网络往返到您的服务器，这会产生相关的网络成本，例如延迟、TCP和TLS握手等。如果您想了解更多关于底层互联网协议（TCP、TLS、UDP、HTTP等）的信息，我强烈推荐Ilya
    Grigorik的《高性能浏览器网络》（O’Reilly Media，2013年）。
- en: In so many words, then, asset bundling consists of literally appending each
    of your files at the end of the previous one. In this way, you might bundle together
    all of your CSS or all of your JavaScript. Fewer HTTP requests yields better performance,
    and that’s reason enough to warrant a static asset bundling build step. [Figure
    2.5](#ch02fig05) examines the interaction between a human and a site that uses
    a bundle, and one that doesn’t, and how each affects network connections.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，资产捆绑实际上是将每个文件附加到前一个文件的末尾。通过这种方式，您可以将所有CSS或所有JavaScript捆绑在一起。更少的HTTP请求带来更好的性能，这就是为什么静态资产捆绑构建步骤值得考虑的原因。[图2.5](#ch02fig05)考察了使用捆绑和不使用捆绑的网站与人类交互，以及它们如何影响网络连接。
- en: Figure 2.5\. Reducing the number of HTTP requests with asset bundling
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5. 使用资产捆绑减少HTTP请求的数量
- en: '![](02fig05_alt.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5](02fig05_alt.jpg)'
- en: As shown in the figure, before bundling the browser has to make many more HTTP
    requests to fetch a site’s resources, while after bundling only a single request
    suffices to fetch every bundle (containing the many different files that make
    up your application’s logic).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，在捆绑之前，浏览器必须发出更多的HTTP请求来获取网站资源，而捆绑之后，只需一个请求就足以获取每个捆绑包（包含构成您应用程序逻辑的许多不同文件）。
- en: Many preprocessors include the option to bundle your assets together in a single
    file, and you already experienced that in the demonstration of `less:compile`,
    where you bundled many assets into one.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 许多预处理器都包括将您的资产捆绑到单个文件中的选项，您在`less:compile`的演示中已经体验过这一点，当时您将许多资产捆绑到一个文件中。
- en: Bundling in the wild
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 野外的捆绑
- en: Using the `grunt-contrib-concat` package, you can easily set up build targets
    to put together any number of files using the globbing patterns I described previously,
    and in a fashion that you might already be comfortable with. Throughout the book,
    the terms concatenation and bundling are used interchangeably. The following listing
    (listed as ch02/03_bundle-task in the accompanying code samples) describes how
    to configure the `concat` task.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grunt-contrib-concat`包，您可以轻松设置构建目标，使用我之前描述的全局模式组合任意数量的文件，并且以一种您可能已经熟悉的方式。在整个书中，术语连接和捆绑是互换使用的。以下列表（在配套代码示例中列为ch02/03_bundle-task）描述了如何配置`concat`任务。
- en: Listing 2.5\. Configuring the concatenation task
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5. 配置连接任务
- en: '![](038fig01_alt.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5](038fig01_alt.jpg)'
- en: Unsurprisingly, the `concat:js` task will take all the files in the `public/js`
    folder (and its subfolders, recursively) and bundle them together, writing the
    results to `build/js/bundle.js`, as indicated. The transition from one task to
    another is so natural that sometimes you won’t believe how easy it is.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，`concat:js`任务将`public/js`文件夹（及其子文件夹，递归）中的所有文件捆绑在一起，并将结果写入`build/js/bundle.js`，如指示。从一项任务到另一项任务的过渡如此自然，有时您甚至不会相信它是多么容易。
- en: One more thing to keep in mind when dealing with static assets during builds
    is minification. Let’s move onto that topic.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中处理静态资产时，还有一点需要注意，那就是压缩。让我们继续讨论这个话题。
- en: 2.2.4\. Static asset minification
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4. 静态资产压缩
- en: '*Minification* resembles concatenation in that it ultimately attempts to reduce
    the strain on network connections, but it applies a different approach. Rather
    than mashing all the files together, minifying consists of removing white space,
    shortening variable names, and optimizing the syntax tree of your code to produce
    a file which, while functionally equivalent to what you wrote, will be significantly
    smaller in file size at the cost of becoming nearly unreadable. This shrinking
    caters to your goal of improving performance, as explained in [figure 2.6](#ch02fig06).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小化*类似于连接，因为它最终试图减轻网络连接的负担，但它采用了一种不同的方法。而不是将所有文件混合在一起，最小化包括删除空白、缩短变量名以及优化代码的语法树，以生成一个文件，虽然功能上与您所写的内容等效，但文件大小将显著减小，代价是几乎无法阅读。这种缩小是为了满足您提高性能的目标，如[图2.6](#ch02fig06)中所述。'
- en: Figure 2.6\. Reducing HTTP response length with asset minification
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. 使用资产最小化减少HTTP响应长度
- en: '![](02fig06_alt.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig06_alt.jpg)'
- en: As you can see in the figure, the minified version of your static assets is
    much smaller, resulting in faster downloads. When combined with GZip^([[7](#ch02fn07)])
    compression on your server-side platform of choice, the minified bundle becomes
    drastically smaller than the source code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，您静态资源的最小化版本要小得多，从而实现更快的下载。当与您选择的服务器端平台上的GZip^([[7](#ch02fn07)])压缩结合使用时，最小化包的大小将大大小于源代码。
- en: ⁷ Visit [http://bevacqua.io/bf/gzip](http://bevacqua.io/bf/gzip) for more information
    on enabling GZip compression on your favorite back-end server.
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 访问[http://bevacqua.io/bf/gzip](http://bevacqua.io/bf/gzip)获取有关在您最喜欢的后端服务器上启用GZip压缩的更多信息。
- en: The obfuscation side effect might make you feel like it’s “safe enough” for
    you to put anything in your JavaScript code, since it will become harder to read,
    but it won’t matter how much you obfuscate your client-side code; people can always
    decode what you’re doing in it if they try hard enough. The corollary is to never
    trust clients and always put sensitive code in your back end instead.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆的副作用可能会让您觉得它“足够安全”，以至于您可以将其中的任何内容放入JavaScript代码中，因为这将使其更难阅读，但无论您如何混淆客户端代码；如果他们足够努力，人们总是可以解码您在其中所做的操作。相应的，永远不要信任客户端，而是将敏感代码放在您的后端。
- en: Bundling can be combined with minification, as they’re completely *orthogonal*
    (meaning they don’t run into each other). One puts files together and the other
    reduces each file’s footprint, but these tasks play well together because they
    don’t overlap in functionality.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 打包可以与最小化结合使用，因为它们是完全*正交的*（这意味着它们不会相互冲突）。一个将文件组合在一起，另一个减少每个文件的占用空间，但这两个任务配合得很好，因为它们在功能上不重叠。
- en: 'Bundling and minification can also be performed in either order, and the result
    will be pretty much the same: a single, compressed file best suited for release
    and hardly useful to your development efforts. While minification and bundling
    are undoubtedly important for your human-facing application, they get in the way
    of the productive, continuous development approach we strive for in our daily
    development flow, because they make debugging harder. That’s why it’s important
    you keep these tasks clearly separated in your build process, so that you can
    execute them in the appropriate environment without hindering your development
    productivity.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和最小化可以按任意顺序执行，结果将大致相同：一个适合发布的单个压缩文件，几乎对您的开发工作没有帮助。虽然最小化和打包对于您面向人类的应用程序无疑很重要，但它们会妨碍我们在日常开发流程中追求的富有成效的持续开发方法，因为它们会使调试变得更加困难。这就是为什么在您的构建过程中将这些任务明确分离出来很重要，这样您就可以在适当的环境中执行它们，而不会阻碍您的开发效率。
- en: Reviewing an asset minification example
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看资产最小化示例
- en: Let’s get into an asset minification example (labeled ch02/04_minify-task in
    the samples), which you could then serve to real humans. Many asset minification
    options exist. In your example, you’ll use the `grunt-contrib-uglify` package
    meant to minify JavaScript files. After installing it from npm and loading the
    plugin, you can set it up as shown in the following listing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个资产最小化示例（在示例中标记为ch02/04_minify-task），然后您可以为真实的人类提供服务。存在许多资产最小化选项。在您的示例中，您将使用`grunt-contrib-uglify`包来最小化JavaScript文件。在从npm安装并加载插件后，您可以按照以下列表进行设置。
- en: Listing 2.6\. Asset minification configuration
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. 资产最小化配置
- en: '![](040fig01_alt.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](040fig01_alt.jpg)'
- en: That setup will help minify `cobra.js`, doing `grunt uglify:cobra`. What if
    you want to minify what you bundled together in the previous step, further improving
    the performance of your application? That’s a matter of taking the concatenated
    file created in [listing 2.6](#ch02ex06) and minifying it, as shown in the following
    listing (labeled ch02/05_bundle-then-minify in the samples).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置将帮助压缩`cobra.js`，执行`grunt uglify:cobra`。如果你想要压缩之前步骤中打包的内容，进一步提高应用程序的性能怎么办？这涉及到取[列表
    2.6](#ch02ex06)中创建的连接文件并进行压缩，如下所示（在示例中标记为ch02/05_bundle-then-minify）。
- en: Listing 2.7\. Asset minification after bundling
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. 打包后的资产压缩
- en: '![](040fig02_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](040fig02_alt.jpg)'
- en: Putting those two steps together is a matter of running both tasks in sequence.
    For that purpose, you might use the `grunt` command `grunt concat:js uglify:bundle`,
    but this also might be an ideal scenario in which to introduce task aliases.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个步骤结合起来，就是按顺序运行这两个任务。为此，你可能需要使用`grunt`命令`grunt concat:js uglify:bundle`，但这也可能是一个引入任务别名的理想场景。
- en: A *task alias* is a group of any number of tasks that are often executed as
    part of the same step and that are related to each other. Tasks in an alias should
    preferably depend on each other to produce a more meaningful output, as this would
    make them easier to follow and more semantic. Task aliases are also great for
    declaring workflows.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务别名*是一组任何数量的任务，这些任务通常作为同一步骤的一部分执行，并且彼此相关。别名中的任务最好相互依赖，以产生更有意义的输出，这样会使它们更容易跟踪和更具语义性。任务别名也非常适合声明工作流程。'
- en: 'In Grunt, you can set up task aliases easily in one line, as I’ll demonstrate
    below. You can also provide an optional description argument; this will be displayed
    when executing `grunt –-help`, but it’s mostly helpful for describing why that
    alias was put together, for developers browsing your code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grunt 中，你可以轻松地在单行中设置任务别名，如下所示。你还可以提供一个可选的描述参数；当执行`grunt –-help`时，这将显示出来，但它主要用于描述为什么创建了这个别名，对于浏览你代码的开发者来说很有帮助：
- en: '[PRE13]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you can treat `assets` as any other Grunt task, and `grunt assets` will
    perform both concatenation and minification.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将`assets`视为任何其他 Grunt 任务，并且运行`grunt assets`将执行连接和压缩操作。
- en: I have a bonus task you can implement on your static asset during builds to
    improve your application’s performance. It’s similar in spirit to bundling, but
    it covers images. This operation results in sprite maps and is a concept that’s
    been around for far longer than minifying or concatenation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个额外的任务，你可以在构建静态资产时实现，以改善应用程序的性能。这与打包类似，但它涵盖了图像。这个操作的结果是精灵图，这是一个比压缩或连接更早的概念。
- en: 2.2.5\. Implementing image sprites
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.5\. 实现图像精灵
- en: '*Sprites* consist of taking many images and building a large file that contains
    all of them. Instead of referencing each individual file, you use the `background-position`,
    `width`, and `height` CSS properties to choose the image you want from the sprite.
    Think of image sprites as asset bundling but for images.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*精灵图*是通过获取许多图像并构建一个包含所有这些图像的大文件来实现的。你不需要为每个单独的文件引用，而是使用`background-position`、`width`和`height`
    CSS 属性来选择你想要的精灵图中的图像。将图像精灵想象成是针对图像的资产打包。'
- en: Spriting is a technique that originated in game development many years ago,
    and it’s still used today. Many graphics get crammed into a single image, significantly
    improving the performance of games. In the web realm, spriting is most useful
    for iconography or any kind of small images.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图是一种技术在多年前起源于游戏开发，至今仍在使用。许多图形被压缩到单个图像中，显著提高了游戏性能。在网页领域，精灵图对于图标或任何类型的小图像最有用。
- en: 'Maintaining the spritesheet and the CSS that goes with it by yourself is work.
    Particularly if you’re cutting and pasting, keeping your icons and the spritesheet
    in sync is tedious. That’s where Grunt comes in as the knight in shining armor,
    ready to save the day. When it comes to setting up image sprites, `npm` has options
    ready for you to start automating your CSS spritesheet generation processes. For
    the purposes of this self-contained example, I’ll refer to the `grunt-spritesmith`
    Grunt plugin. If you have issues installing the plugin, refer to the code samples
    for troubleshooting. Its configuration is similar to what you’re already accustomed
    to:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 自己维护精灵图和相关的CSS是一项工作。尤其是如果你是在剪切和粘贴，保持图标和精灵图同步是繁琐的。这就是Grunt作为闪耀的骑士，准备拯救世界的时刻。在设置图像精灵时，`npm`为你提供了开始自动化CSS精灵图生成过程的选项。为了这个自包含的示例，我将参考`grunt-spritesmith`
    Grunt插件。如果你在安装插件时遇到问题，请参考代码示例进行故障排除。其配置类似于你已经习惯的配置：
- en: '[PRE14]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By now, you can safely assume that the `src` property takes any kind of glob
    patterns. The `destImg` and `destCSS` properties will map to the files where your
    spritesheet will be generated, along with the CSS file that should be used to
    render the sprited images in your HTML. Once you have both the CSS and your newly
    created spritesheet, you can add icons to your site simply by creating HTML elements
    and assigning the different sprite CSS classes to those elements. CSS is used
    to “crop” different parts of the image, effectively taking only the relevant portion
    of the image used for the desired icon.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可以安全地假设`src`属性可以接受任何类型的通配符模式。`destImg`和`destCSS`属性将映射到精灵图将生成的文件，以及用于在HTML中渲染精灵图像的CSS文件。一旦你有了CSS和新建的精灵图，你只需通过创建HTML元素并将不同的精灵CSS类分配给这些元素，就可以简单地给你的网站添加图标。CSS用于“裁剪”图像的不同部分，有效地只取用于所需图标的图像相关部分。
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Perceived performance on the web**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络上的感知性能**'
- en: I can’t stress enough how important a role asset bundling, minification, and
    even spriting play when it comes to release builds. Images typically make up most
    of the footprint for web applications today. Reducing the number of requests to
    your server using these techniques provides you with an immediate performance
    boost that doesn’t require more expensive hardware. A similar case can be made
    for reducing the byte size of the responses by minifying and/or compressing them.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法强调资产打包、最小化和甚至精灵化在发布构建中扮演的重要角色。在当今的Web应用中，图像通常占据了大部分的文件大小。使用这些技术减少对服务器的请求次数，可以立即提供性能提升，而不需要更昂贵的硬件。通过最小化和/或压缩响应内容，减少其字节大小也可以达到类似的效果。
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Speed matters
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 速度很重要
- en: Speed is a fundamental, defining factor of the web. Responsiveness, or at least
    *perceived* responsiveness, has a tremendous impact on the user experience (UX).
    Perceived responsiveness is now more important than ever; this is what the user
    perceives as speed, even though technically it might take even longer to fulfill
    a request. As long as you display immediate feedback for their actions, users
    will perceive your application as “faster.” This is what you see every day on
    Facebook or Twitter when you submit a new post, and it’s immediately added to
    the list, even though its data is still being sent to their servers.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 速度是网络的基本、决定性因素。响应性，或者至少是*感知到的*响应性，对用户体验（UX）有着巨大的影响。感知到的响应性现在比以往任何时候都更重要；这是用户感知到的速度，尽管技术上可能需要更长的时间来满足请求。只要你对他们的操作显示即时的反馈，用户就会感知到你的应用程序“更快”。这就是你每天在Facebook或Twitter上看到的情况，当你提交一条新帖子时，它立即被添加到列表中，尽管其数据仍在发送到他们的服务器。
- en: Numerous experiments have demonstrated how important it is to provide swift
    and reliable services. Two experiments in particular, performed by Google and
    Amazon, respectively, come to mind.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实验已经证明了提供快速可靠服务的重要性。特别是由谷歌和亚马逊分别进行的两个实验。
- en: In 2006, Marissa Mayer was Google’s vice president for UX. She ran an experiment
    after collecting feedback from a group of users who wanted to see more results
    per page in their searches. The experiment increased the number to 30 search results
    per page. Traffic and revenue from customers in the experimental group who got
    more results per page dropped by 20%.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在2006年，玛丽莎·梅耶（Marissa Mayer）是谷歌的用户体验副总裁。她在收集了一组用户反馈后进行了一项实验，这些用户希望在他们的搜索结果中看到更多结果。实验将每页搜索结果的数量增加到30个。每页结果数量增加的实验组的客户流量和收入下降了20%。
- en: Marissa explained that they found an uncontrolled variable. The page with 10
    results took .4 seconds to generate. The page with 30 results took .9 seconds.
    Half a second delay caused a 20% drop in traffic. Half a second delay killed user
    satisfaction.^([[8](#ch02fn08)])
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 马里萨解释说，他们发现了一个未受控制的变量。包含10个结果页面生成耗时0.4秒。包含30个结果页面生成耗时0.9秒。半秒的延迟导致了20%的流量下降。半秒的延迟摧毁了用户满意度.^([[8](#ch02fn08)])
- en: '⁸ You can find a detailed article about the subject here: [http://bevacqua.io/bf/speed-matters](http://bevacqua.io/bf/speed-matters).'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 你可以在这里找到关于这个主题的详细文章：[http://bevacqua.io/bf/speed-matters](http://bevacqua.io/bf/speed-matters)。
- en: Amazon conducted a similar experiment, progressively delaying their website’s
    responsiveness on purpose during split tests. Even the slightest delay resulted
    in significant drops in sales.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊进行了一个类似的实验，在拆分测试中故意逐渐延迟他们网站的响应速度。即使是微小的延迟也会导致销售额的显著下降。
- en: Judging perceived responsiveness vs. actual speed
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 判断感知响应速度与实际速度
- en: On the opposite end of the spectrum, we meet perceived speed. You can increase
    perceived speed by providing instant feedback (as if the action was successful)
    to user interaction, even when the task itself might take a few seconds to process.
    This kind of fast-forwarding is always well received by humans.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端，我们遇到了感知速度。通过向用户交互提供即时反馈（仿佛动作已经成功），即使任务本身可能需要几秒钟来处理，你也可以提高感知速度。这种快进方式总是受到人类的欢迎。
- en: Now that we’ve talked about speeding up network access to your assets, and the
    build tasks relevant to compiling these assets, as well as the performance implications
    of different approaches and techniques, let’s slow down for a minute and start
    talking code quality. Until now, we’ve paid only a little attention to the quality
    of your code, so let’s turn to the kind of tasks you should perform in that regard.
    You have a good idea what preprocessing and post-processing tasks are, how they
    work, and how to apply them.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了加快网络访问您资产的速度，以及与编译这些资产相关的构建任务，以及不同方法和技术的性能影响，让我们放慢脚步，开始谈谈代码质量。到目前为止，我们只稍微关注了您代码的质量，所以让我们转向您应该执行的那种任务。您对预处理和后处理任务有很好的了解，知道它们是如何工作的，以及如何应用它们。
- en: We first talked about code quality in [chapter 1](kindle_split_012.html#ch01),
    when you integrated lint into your build. Cleaning up after yourself is important
    if you want to preserve the idempotence property. Similarly, linting your code
    and running tests are paramount for keeping your code quality standards high.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在第1章[第1章](kindle_split_012.html#ch01)中讨论了代码质量，当时您将代码检查集成到构建中。如果您想保留幂等性属性，清理自己的工作很重要。同样，检查代码和运行测试对于保持您的代码质量标准至关重要。
- en: Now, let’s go a little deeper and find out how to better integrate these tasks
    into a real build process.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入一点，了解如何更好地将这些任务集成到实际的构建过程中。
- en: 2.3\. Setting up code integrity
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 设置代码完整性
- en: 'Keep in mind a few tasks when it comes to code integrity:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑代码完整性时，请记住几个任务：
- en: First and foremost, we should talk about cleaning up after ourselves. Whenever
    our builds start, they should clean up the build artifacts they generate. This
    helps us achieve idempotency, where executing a build many times always results
    in the same output.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们应该谈论的是清理自己的工作。每当我们的构建开始时，它们应该清理它们生成的构建工件。这有助于我们实现幂等性，即多次执行构建总是产生相同的结果。
- en: We’ll go over lint again, adding to what we explored near the end of [chapter
    1](kindle_split_012.html#ch01), making sure that our code doesn’t contain any
    syntax errors whenever we run a build.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将再次讨论代码检查，补充我们在[第1章](kindle_split_012.html#ch01)末尾所探讨的内容，确保我们在运行构建时代码不包含任何语法错误。
- en: We’ll talk briefly about setting up a test runner so that you can automate code
    tests, which we’ll go over in future chapters.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将简要讨论设置测试运行器，以便您可以自动化代码测试，我们将在未来的章节中介绍。
- en: 2.3.1\. Cleaning up your working directory
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1. 清理工作目录
- en: After you’re done with a build, your *working directory* will generally be in
    a dirty state, because you’ll have generated content that’s not part of your source
    code. You want to make sure your working directory is always in the same state
    whenever you run a build, so you get the same results every time. To ensure this,
    it’s generally good practice to clean up generated files before running any other
    tasks.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成构建后，您的**工作目录**通常会处于脏状态，因为您将生成不属于源代码的内容。您想要确保每次运行构建时工作目录始终处于相同的状态，以便每次都能得到相同的结果。为了确保这一点，通常在运行任何其他任务之前清理生成文件是一个很好的做法。
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Working directory
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 工作目录
- en: Working directory is fancy talk for the root directory for your code base during
    development. It’s often best to use a subdirectory to aggregate the compiled results
    of your builds, such as a directory named `build`. This helps you keep your source
    code cleanly separated from build artifacts.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 工作目录是开发期间代码库根目录的时髦说法。通常最好使用子目录来聚合构建的编译结果，例如名为`build`的目录。这有助于您将源代码与构建工件保持干净分离。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: After your release, your servers will use the results of your build, and you
    shouldn’t change its output except by performing another release. Running build
    tasks after the deployment is complete would be as bad as manually executing those
    tasks, as you’d reintroduce the human factor. As a general rule, if something
    doesn’t feel clean, it probably isn’t clean enough and should be revised.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的发布完成后，您的服务器将使用构建的结果，您不应该通过执行另一个发布之外的方式更改其输出。在部署完成后运行构建任务会像手动执行这些任务一样糟糕，因为您会重新引入人为因素。一般来说，如果某件事感觉不够干净，那么它可能还不够干净，应该进行修改。
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Isolating build output**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**隔离构建输出**'
- en: While we’re on the topic of code integrity, I believe it’s important to highlight
    something that you might’ve noticed from the examples I’ve presented so far. I
    strongly recommend you follow the practice of strictly separating build-generated
    content from source code. It’s sufficient to put generated content in a `build`
    directory. Benefits include the ability to remove generated content without hesitation,
    the ability to easily ignore the folder with globbing patterns, browsing generated
    content in one place, and perhaps even more importantly, making sure you don’t
    accidentally delete source code.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论代码完整性时，我认为强调您可能已经从我所展示的示例中注意到的某事很重要。我强烈建议您遵循严格分离构建生成内容与源代码的做法。将生成内容放在`build`目录中就足够了。好处包括能够毫不犹豫地删除生成内容，能够轻松地使用globbing模式忽略文件夹，在一个地方浏览生成内容，也许更重要的是，确保您不会意外删除源代码。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Tasks that generate content but clean up preexisting build artifacts whenever
    they’re run are happily idempotent: running them infinite times doesn’t affect
    their behavior; the result is always the same. The cleanup step is a required
    property for build tasks to become idempotent, granting them the consistency of
    always producing the same output. That being said, let’s see what the cleanup
    task configuration might look like in Grunt. You’ll use the `grunt-contrib-clean`
    package, which provides a `clean` task you can use. This task (available as ch02/07_clean-task
    in the samples) is as simple as it gets: you provide target names, and then you
    can remove specific files or entire folders that you specify using a globbing
    pattern. See the following code for an example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 生成内容但每次运行时都会清理现有构建工件的任务是乐意于幂等的：无限次运行它们不会影响其行为；结果始终相同。清理步骤是构建任务成为幂等的必要属性，赋予它们始终产生相同输出的一致性。话虽如此，让我们看看清理任务配置在Grunt中可能是什么样子。您将使用`grunt-contrib-clean`包，它提供了一个您可以使用`clean`任务。这个任务（在示例中可用为ch02/07_clean-task）是尽可能简单的：您提供目标名称，然后您可以使用globbing模式删除您指定的特定文件或整个文件夹。以下代码是一个示例：
- en: '![](044fig01.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](044fig01.jpg)'
- en: The first two, `build/js` and `build/css`, show how simple it can be to pick
    generated content and remove it, as long as it’s clearly separated from source
    code. On the other hand, the third example shows how messy it becomes when the
    source code lives in the same directory as the build-generated content. Furthermore,
    if you isolate your generated content to one folder, then you could easily exclude
    that folder from your version control system more conveniently.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子`build/js`和`build/css`展示了如何简单地将生成内容挑选出来并移除，只要它明显与源代码分开。另一方面，第三个例子展示了当源代码与构建生成的内容位于同一目录时，情况会变得多么混乱。此外，如果你将生成内容隔离到一个文件夹中，那么你可以更方便地将其从版本控制系统排除。
- en: 2.3.2\. Lint, lint, lint!
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 代码检查，代码检查，代码检查！
- en: 'We already went over the benefits of linting in the previous chapter, but let’s
    look at the configuration for your lint task again. Keep in mind you were using
    the `grunt-contrib-jshint` package here. You can configure it as shown in the
    following code (sample ch02/08_lint-task):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中讨论了代码检查的好处，但让我们再次看看你的代码检查任务的配置。记住你在这里使用的是`grunt-contrib-jshint`包。你可以按照以下代码（示例ch02/08_lint-task）进行配置：
- en: '[PRE15]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s important to consider third-party (someone else’s) code as outside of our
    efforts’ reach. You wouldn’t unit test third-party code. Similarly, it’s not your
    job to lint their code, either. If you weren’t putting generated content in a
    separate folder, you’d also have to exclude it from your JSHint profile. That’s
    yet another benefit of strictly separating build artifacts from the general population
    (your source files).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第三方（别人的）代码时，重要的是要将其视为我们努力范围之外的内容。你不会对第三方代码进行单元测试。同样，检查他们的代码也不是你的工作。如果你没有将生成的内容放在单独的文件夹中，你还需要从你的JSHint配置文件中排除它。这就是严格将构建工件与一般大众（你的源文件）分开的另一个好处。
- en: Lint is often considered the first line of defense when it comes to maintaining
    a reasonable level of code quality in JavaScript. You should still write unit
    tests on top of what lint is capable of for reasons I’ll explain below, and you
    guessed it, there’s a task for that.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查通常被认为是维护JavaScript代码质量合理水平的第一道防线。你应该仍然在代码检查的基础上编写单元测试，原因我将在下面解释，而且，你猜对了，有一个任务就是为了这个。
- en: 2.3.3\. Automating unit testing
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 自动化单元测试
- en: 'One of the most important steps to automate during build is unit testing. Unit
    tests make sure the individual components in your code base work appropriately.
    A popular flow for developing an application that’s well tested is the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中自动化的最重要步骤之一是单元测试。单元测试确保你的代码库中的各个组件按预期工作。开发一个经过良好测试的应用程序的流行流程如下：
- en: Write tests for something you want to implement (or change).
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你想要实现（或更改）的东西编写测试。
- en: Run those tests and see them fail.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这些测试并观察它们失败。
- en: Implement your changes to the code.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现你的代码更改。
- en: Run the tests again.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: If a test failed, keep coding until all tests pass, and finally go back to write
    new tests. This process is called *Test-Driven Development* (TDD). We’ll go deeper
    into unit testing in [chapter 8](kindle_split_020.html#ch08). This is a topic
    that warrants a more dedicated section, so we’ll postpone the discussion of setting
    up the Grunt task to run unit tests.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，继续编码直到所有测试通过，最后再回头编写新的测试。这个过程被称为*测试驱动开发*（TDD）。我们将在第8章中更深入地探讨单元测试。这是一个值得更专门讨论的话题，因此我们将推迟关于设置Grunt任务以运行单元测试的讨论。
- en: The key takeaway for now is that unit tests must be automated. Tests that aren’t
    run often are nearly useless, so the build process should trigger them before
    deploys and probably during your local builds, too. Taking that into account,
    you’ll also want your unit tests to run as quickly as possible, so they don’t
    cripple the performance of your builds. A commonly cited principle is “Test early;
    test often.”
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的主要经验教训是单元测试必须自动化。不经常运行的测试几乎毫无用处，因此构建过程应该在部署之前以及在你本地构建期间触发它们。考虑到这一点，你也会希望你的单元测试尽可能快地运行，以免影响构建的性能。一个常见的原则是“尽早测试；经常测试”。
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: The different packages we’ve seen so far only expose a single Grunt task you
    can use, but that’s not a constraint Grunt itself imposes. You can include as
    many custom tasks in your packages as you deem necessary. This is usually done
    by package authors on purpose. npm packages are commonly modular in their design,
    because they’re designed to do exactly one thing extremely well.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的不同包只暴露了一个你可以使用的 Grunt 任务，但这并不是 Grunt 本身强加的限制。你可以根据需要将尽可能多的自定义任务包含在你的包中。这通常是由包作者有意为之。npm
    包通常在设计上是模块化的，因为它们被设计成只做一件事，而且做得非常好。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You’ve spent most of this chapter learning how to use build tasks that other
    people wrote. Let’s turn our attention to writing your own build tasks, which
    comes in handy whenever the existing task plugins you find on `npm` don’t satisfy
    your needs.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章的大部分时间里都在学习如何使用其他人编写的构建任务。现在让我们转向编写自己的构建任务，这在当你找到的现有任务插件在 `npm` 上不能满足你的需求时非常有用。
- en: 2.4\. Writing your first build task
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 编写你的第一个构建任务
- en: Even though Grunt has an active community around it that provides many high-quality
    npm modules, you’ll certainly come across the need to write your own tasks. Let’s
    go over how that process looks, using an example. We’ve covered tasks loaded from
    npm and setting up task aliases. The simplest way to create a task is using the
    `grunt.registerTask` method. Indeed, that’s the same method you used to register
    aliases in [section 2.2.4](#ch02lev2sec7) when we looked at minification, but
    instead of passing in a list of tasks that compose your task, you’ll pass in a
    function instead.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Grunt有一个活跃的社区，提供了许多高质量的 npm 模块，但你肯定需要编写自己的任务。让我们通过一个示例来了解这个过程。我们已经介绍了从 npm
    加载的任务和设置任务别名。创建任务最简单的方法是使用 `grunt.registerTask` 方法。实际上，这正是我们在查看压缩时在[2.2.4 节](#ch02lev2sec7)中注册别名时使用的方法，但此时你将传递一个函数而不是任务列表。
- en: The following listing (which can be found as ch02/09_timestamp-task in the samples)
    shows how to create a simple build task that creates a file with a timestamp,
    which you could then use as a unique identifier somewhere else in the application.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表（可在 samples 中的 ch02/09_timestamp-task 找到）展示了如何创建一个简单的构建任务，该任务创建一个带有时间戳的文件，你可以在应用程序的其他地方将其用作唯一标识符。
- en: Listing 2.8\. A time-stamping task
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 时间戳任务
- en: '![](046fig01_alt.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](046fig01_alt.jpg)'
- en: 'By default, the timestamp will be created in a file named `.timestamp`; however,
    because you’re using `this.options`, users can change that to use another file
    name by providing one when configuring the task, as shown in the following code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，时间戳将创建在名为 `.timestamp` 的文件中；然而，由于你使用了 `this.options`，用户可以在配置任务时提供另一个文件名来更改它，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In essence, this is the only requirement to write custom build tasks. Grunt
    has an extensive API that abstracts away common functionality, enabling you to
    easily address configuration, perform I/O operations, execute tasks, and perform
    tasks asynchronously. Luckily, the API is well documented, so check it out on
    their website.^([[9](#ch02fn09)])
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是编写自定义构建任务的唯一要求。Grunt 有一个广泛的 API，它抽象出常见功能，使你能够轻松地处理配置、执行 I/O 操作、执行任务以及异步执行任务。幸运的是，API
    有很好的文档，所以请在他们的网站上查看。[^([[9](#ch02fn09))]]
- en: ⁹ You can find Grunt’s documentation at [http://bevacqua.io/bf/grunt](http://bevacqua.io/bf/grunt).
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 你可以在[http://bevacqua.io/bf/grunt](http://bevacqua.io/bf/grunt)找到 Grunt 的文档。
- en: For an all-encompassing analysis of Grunt, head to [appendix B](kindle_split_023.html#app02).
    The `timestamp` task was mightily trivial. Let’s look at a real Grunt task you
    might want to implement.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 若要对 Grunt 进行全面分析，请前往[附录 B](kindle_split_023.html#app02)。`timestamp` 任务非常简单。让我们看看你可能想要实现的实际
    Grunt 任务。
- en: '2.5\. Case study: database tasks'
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 案例研究：数据库任务
- en: As you’ve seen, developing your own build tasks isn’t that complicated; however,
    it’s important to identify whether a task has already been developed for your
    task runner of choice (Grunt in our case) before setting out to reinvent the wheel
    all by yourself! Most task runners offer some sort of search engine for plugins,
    so be sure to look online before sitting down to write your own tasks. Now, let’s
    look at the case of database schema updates and how you can help automate them
    in a build. There aren’t many plugins out there that do this specific sort of
    thing, so we’re better off developing our own.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，开发自己的构建任务并不复杂；然而，在着手自己重新发明轮子之前，确定你的任务运行器（在我们的案例中是Grunt）是否已经为你的任务开发了，这是很重要的！大多数任务运行器都提供某种插件搜索引擎，所以确保在坐下来编写自己的任务之前在网上查找。现在，让我们看看数据库模式更新的案例，以及你如何帮助自动化它们。
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Database case study code**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库案例研究代码**'
- en: Note that the code for this particular case hasn’t been included in the text
    of the book. Instead, you’ll find a fully working example in the accompanying
    code listings, labeled ch02/10_mysql-tasks.^([[a](#ch02fn01a)])
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这本书的文本中没有包含这个特定案例的代码。相反，你可以在配套的代码列表中找到一个完全工作的示例，标记为ch02/10_mysql-tasks.^([[a](#ch02fn01a)])
- en: ^a The code sample for the database tasks can be found online at [http://bevacqua.io/bf/db-tasks](http://bevacqua.io/bf/db-tasks).
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a 数据库任务的代码样本可以在网上找到，地址为[http://bevacqua.io/bf/db-tasks](http://bevacqua.io/bf/db-tasks)。
- en: Before you look at the code, read this section in the book to find out what
    the code is, what it does, and why.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看代码之前，阅读这本书的这一部分，以了解代码是什么，它做什么，以及为什么。
- en: '|  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Database migrations are one of those tasks that are complicated to set up, but
    after you have, you’ll wonder how you managed to keep applications together without
    the automated process.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移是那些设置起来很复杂的任务之一，但一旦设置好，你就会 wonder 你是如何在没有自动化过程的情况下管理应用程序的。
- en: 'The general concept is that you start with the original database schema designed
    for the application. As time goes by, you’ll probably make adjustments to the
    schema: maybe you’ll add a table, remove unnecessary fields, change constraints,
    and so on.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 通用概念是，你从一个为应用程序设计的原始数据库模式开始。随着时间的推移，你可能会对模式进行调整：也许你会添加一个表，删除不必要的字段，更改约束等等。
- en: These schema updates are more often than not shamelessly done by hand, typically
    using the excuse that they’re too sensitive to automate. We do them by hand and
    waste tons of time. It’s easy to make mistakes in the process, wasting even more
    time. Needless to say, this becomes unbearable in larger development teams.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式更新往往是不加掩饰地手工完成的，通常以它们太敏感而无法自动化的借口。我们手工完成它们，浪费了大量时间。在这个过程中很容易出错，浪费更多时间。不用说，这对大型开发团队来说变得难以忍受。
- en: Two-way schema changes
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双向模式更改
- en: 'I propose that an automated set of tasks should gracefully handle migrations
    in both directions: upgrade and rollback. If you build them carefully enough,
    you can even integrate them into an automated process. The line of thinking is
    you should apply these schema changes only within these tasks, and never directly
    on the database. When you adopt that line of thinking, consider two additional
    tasks: creating the database from the ground up, and seeding it with data to aid
    in your development workflow. These tasks would allow you to manage your database
    directly from the command line, easily creating new instances, changing the schema,
    populating with data, and rolling back changes.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议一套自动化的任务应该优雅地处理双向迁移：升级和回滚。如果你足够小心地构建它们，你甚至可以将它们集成到自动化流程中。这种思考方式是，你应该只在这些任务中应用这些模式更改，而永远不要直接在数据库上操作。当你采用这种思考方式时，请考虑两个额外的任务：从头创建数据库，并使用数据填充以帮助你的开发工作流程。这些任务将允许你直接从命令行管理数据库，轻松创建新实例，更改模式，用数据填充，并回滚更改。
- en: '[Figure 2.7](#ch02fig07) summarizes these steps, consolidating them as Grunt
    tasks, and also explains how they could interact with a given database.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.7](#ch02fig07)总结了这些步骤，将它们作为Grunt任务进行整合，并解释了它们如何与特定的数据库交互。'
- en: Figure 2.7\. Interaction of proposed tasks with a database instance
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7显示了所提出的任务与数据库实例的交互。
- en: '![](02fig07_alt.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig07_alt.jpg)'
- en: 'Taking a close look at the figure, you’ll notice there’s a flow to it:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察这张图，你会注意到它有一个流程：
- en: Create the database once.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次创建数据库。
- en: Run schema update scripts whenever new ones come out.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当有新的模式更新时运行模式更新脚本。
- en: Seed your development database once.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性在你的开发数据库中种下种子。
- en: Run rollback scripts as an extra layer of security in case something goes wrong.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现问题时，运行回滚脚本作为额外的安全层。
- en: 'Using `db_create,` you can create a database instance, and that’s it. It shouldn’t
    recreate the database if it already exists, to avoid errors. It won’t write anything
    to the schema yet: tables, views, procedures, and such, are part of the next step.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `db_create`，你可以创建一个数据库实例，这就足够了。它不应该在数据库已存在的情况下重新创建，以避免错误。它目前不会写入任何内容到模式中：表、视图、过程等都是下一步的内容。
- en: The `db_upgrade` task will run the upgrade scripts that haven’t yet been executed.
    You’ll want to check the accompanying source code for this chapter to learn how
    it works.^([[10](#ch02fn10)]) In simple terms, you create a table where you can
    keep track of the upgrade scripts that were applied; then you check if unapplied
    scripts exist and execute those, updating your tracking records as you go along.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_upgrade` 任务将运行尚未执行的升级脚本。你将想要检查本章的配套源代码来了解它是如何工作的。[^([10](#ch02fn10))] 简单来说，你创建一个表来跟踪已应用的升级脚本；然后检查是否存在未应用的脚本并执行它们，在执行过程中更新跟踪记录。'
- en: ^(10) The code sample for the database tasks can be found online at [http://bevacqua.io/bf/db-tasks](http://bevacqua.io/bf/db-tasks).
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(10) 数据库任务的代码示例可以在网上找到，链接为 [http://bevacqua.io/bf/db-tasks](http://bevacqua.io/bf/db-tasks)]。
- en: Having a backup plan
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有一个备份计划
- en: When things go awry, `db_rollback` will take the last upgrade script applied
    and execute its downgrade counterpart. It then updates the tracking table by deleting
    the last record, so that you can effectively go back and forth in your schema
    with upgrades and rollbacks, by using these two tasks. Keep in mind that while
    `db_upgrade` executes all of the unapplied upgrade scripts, `db_rollback` only
    downgrades the last one that’s still applied.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情出错时，`db_rollback` 将执行最后一个应用的升级脚本，并执行其降级对应脚本。然后它通过删除最后一条记录来更新跟踪表，这样你就可以通过使用这两个任务在模式中有效地来回升级和回滚。请注意，虽然`db_upgrade`执行所有未应用的升级脚本，但`db_rollback`只降级最后一个仍然应用的脚本。
- en: Last, the `db_seed` task is used to insert records you can play with in your
    development environment. This one will be crucial in making it dead simple to
    set up new developers with a working environment by running Grunt tasks exclusively.
    These tasks would look something like those in [figure 2.7](#ch02fig07).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`db_seed` 任务用于在开发环境中插入你可以操作的记录。这个任务对于通过仅运行Grunt任务来使新开发者轻松设置工作环境至关重要。这些任务看起来可能像[图2.7](#ch02fig07)中的那些。
- en: At this point, you should be comfortable enough to go through the fully documented
    code listing for database tasks (which is ch02/10_mysql-tasks in the samples),
    and get a sense of how it could be implemented.^([[11](#ch02fn11)])
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经足够熟悉，可以查看数据库任务的完整文档代码列表（在示例中为ch02/10_mysql-tasks），并了解它如何实现。[^([11](#ch02fn11))]
- en: ^(11) You can dig through the [Chapter 2](#ch02) code samples, and look for
    the one named 10_mysql-tasks.
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(11) 你可以查看[第2章](#ch02)的代码示例，并寻找名为10_mysql-tasks的那个示例。]
- en: In upcoming chapters, you’ll see different ways of configuring tasks such as
    this one to avoid relying on a configuration file directly. Rather, you’ll learn
    how to use environment variables and encrypted JSON configuration files to store
    your environment configuration.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到不同的方法来配置此类任务，以避免直接依赖于配置文件。相反，你将学习如何使用环境变量和加密的JSON配置文件来存储你的环境配置。
- en: 2.6\. Summary
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6. 摘要
- en: 'You’ve learned a lot about build tasks! Let’s go over a quick recap:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多关于构建任务的知识！让我们快速回顾一下：
- en: A build process should facilitate everything that’s needed to produce a fully
    configured environment that’s ready and can do its job.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程应该促进生产一个完全配置的环境所需的一切，使其准备好并能够完成其工作。
- en: The different tasks in a build are clearly separated, and similar tasks are
    grouped together under task targets.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建中的不同任务被清楚地分开，并且类似任务被分组在任务目标下。
- en: Primary tasks that comprise a build include static asset compilation and optimization,
    linting, and running unit tests.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成构建的主要任务包括静态资产编译和优化、代码风格检查以及运行单元测试。
- en: You’ve learned how to write your own build tasks and studied how to approach
    the automated database schema updates.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经学会了如何编写自己的构建任务，并研究了如何自动处理数据库模式更新。
- en: Armed with the knowledge you’ve garnered, we’ll switch gears in the two upcoming
    chapters and expand your understanding of how to target different environments,
    namely local development and release servers, and you’ll learn best practices
    that you can apply to maximize productivity and performance.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 借助你获得的知识，我们将在接下来的两个章节中转换方向，扩展你对如何针对不同环境（即本地开发和发布服务器）的理解，你将学习可以应用于最大化生产力和性能的最佳实践。
- en: Chapter 3\. Mastering environments and the development workflow
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 掌握环境和开发工作流程
- en: '*This chapter covers*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating build distributions and workflows
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建构建版本和工作流程
- en: Setting up application environments
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用程序环境
- en: Building secure environment configuration
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建安全的环境配置
- en: Automating first-time setup
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化首次设置
- en: Using Grunt for continuous development
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Grunt进行持续开发
- en: We spent the last chapter going over what to do and what not to do during builds.
    We covered build tasks and configured different targets in them. I also hinted
    at how your workflow differs according to whether you build your application for
    debug or release distributions; these differences in your build workflow, based
    on either debug or release goals of your target environment, are called *build
    distributions*.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中讨论了在构建过程中应该做什么和不应该做什么。我们涵盖了构建任务，并在其中配置了不同的目标。我还暗示了你的工作流程如何根据你为调试或发布版本构建应用程序而有所不同；这些基于目标环境的调试或发布目标的构建工作流程差异被称为*构建版本*。
- en: Understanding the interaction between development, staging, and production environments
    and build distributions is vital to creating a build process that can be used
    regardless of environment, allowing you to develop your application in a setting
    loyal to what your end users will see, but that can still be debugged with ease.
    Additionally, this understanding will allow you to create middle-tier environments,
    which are instrumental to robust deployment mechanisms, which we’ll discuss in
    the next chapter.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 理解开发、预发布和生产环境以及构建版本之间的交互对于创建一个无论在何种环境下都可以使用的构建过程至关重要，这允许你在与最终用户所见环境忠诚的设置中开发你的应用程序，同时仍然可以轻松地进行调试。此外，这种理解将使你能够创建中间层环境，这对于强大的部署机制至关重要，我们将在下一章中讨论。
- en: In this chapter we’ll start off learning what we mean by environments and distributions,
    and I’ll propose a typical configuration that should suffice for most use cases,
    where you’ll have your
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从了解我们所说的环境和版本开始，我将提出一个典型的配置，它应该适用于大多数用例，其中你将拥有
- en: Local development environment, used to improve the application on a daily basis
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地开发环境，用于日常改进应用程序
- en: Staging or testing environment, dedicated to making sure no issues would arise
    from deploying to production
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预发布或测试环境，专门用于确保不会因部署到生产环境而产生问题
- en: Production environment, which is the one customers have access to
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境，这是客户可以访问的环境
- en: Then we’ll look at different approaches to take when configuring an application
    under different contexts. You’ll learn how to automate the oftentimes tedious
    first-time setup, and then have fun setting up a continuous development workflow
    using Grunt. Let’s get started.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨在配置应用程序时在不同上下文中采取的不同方法。你将学习如何自动化通常繁琐的首次设置，然后使用Grunt设置一个持续的开发工作流程，让我们开始吧。
- en: 3.1\. Application environments
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 应用程序环境
- en: In the previous chapter we talked a bit about environments, but we didn’t detail
    the options you have when it comes to setting up new ones or how they differ from
    one another.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们谈到了一些关于环境的内容，但我们没有详细说明在设置新环境时你有哪些选择，以及它们之间有何不同。
- en: The *development environment* is where you spend most of your time, working
    on a local web server, which is often configured in such a way to allow debugging,
    reading stack traces, and getting diagnostics more readily than other environments.
    The development environment is also the environment that’s closest to the developers
    and the source code they write. The application used in this environment is almost
    always built using the *debug distribution*, which is fancy talk for setting a
    flag that will allow you to turn on certain capabilities, such as debug symbols,
    increased logging (or logging verbosity), and so on.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发环境* 是你大部分时间所在的地方，你在这里使用本地Web服务器进行工作，该服务器通常配置得允许调试、读取堆栈跟踪和更容易地获取诊断信息，比其他环境都要方便。开发环境也是与开发者及其编写的源代码最接近的环境。在这个环境中使用的应用程序几乎总是使用
    *调试版本* 构建，这相当于设置一个标志，允许你开启某些功能，例如调试符号、增加日志记录（或日志详细程度）等。'
- en: The *staging environment* is where you make sure everything works correctly
    on a hosted environment and that you can deploy to production with confidence
    that nothing will break. In the *production environment*, you’ll almost always
    want to build for the release distribution, as that build flow will be designed
    to optimize your application and squeeze as many bytes as possible out of your
    static assets.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试环境* 是你确保在托管环境中一切工作正常，并且可以自信地部署到生产环境，而不用担心任何东西会出错的地方。在 *生产环境* 中，你几乎总是希望为发布版本构建，因为该构建流程将设计为优化你的应用程序，并尽可能多地从你的静态资源中挤出字节。'
- en: 'Now let’s look at how you can configure your build distribution for each of
    these environments, tuning the distribution’s output to meet your specific goals:
    either debug or release.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何为这些环境中的每一个配置你的构建版本，调整版本输出以满足你的特定目标：要么是调试，要么是发布。
- en: 3.1.1\. Configuring build distributions
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1. 配置构建版本
- en: 'To help understand build distributions, think of application building like
    working in a bakery. When you’re preparing the mixture for a cake, there’s a myriad
    of pans you might use to hold the batter. You can use a standard round cake pan,
    a square baking dish, a loaf pan, or whatever’s available to you. These pans are
    like tools in the development environment, which would be your kitchen. The ingredients
    are always the same: flour, butter, sugar, a pinch of salt, cocoa powder, eggs,
    and half a cup of buttermilk. The ingredients you use to build your cake are akin
    to assets in your application.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解构建版本，可以将应用程序构建比作在面包房工作。当你准备蛋糕的混合物时，你可能会有许多不同的模具来盛放面糊。你可以使用标准的圆形蛋糕模具、方形烤盘、长面包模具，或者你所能找到的任何东西。这些模具就像开发环境中的工具，你的厨房。原料总是相同的：面粉、黄油、糖、一点盐、可可粉、鸡蛋和半杯牛奶。你用来构建蛋糕的原料类似于你应用程序中的资源。
- en: 'Furthermore, the ingredients are combined into a recipe that indicates how
    to mix them together: when, in what quantities, and how long you should store
    the mix in the fridge to get a good consistency before putting it in the oven
    at a well-defined temperature. Choosing different recipes can result in a spongier
    cake or a crustier one, the way choosing different distributions results in an
    application that’s easier to debug or performs better.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，原料被组合成一份食谱，指示如何将它们混合在一起：何时、以何种数量、以及你应该在冰箱中存放多长时间，以便在以定义良好的温度放入烤箱之前获得良好的质地。选择不同的食谱可能会导致蛋糕更加松软或更加酥脆，就像选择不同的版本会导致应用程序更容易调试或性能更好。
- en: While you’re trying out different ways to put together your mixture, you might
    change the ingredients (your assets), and maybe even the recipe (your distribution),
    but you’ll still do the work in your kitchen (the development environment).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试不同的方法来组合你的混合物时，你可能会改变原料（你的资源），甚至可能会改变食谱（你的版本），但你仍然会在你的厨房（开发环境）中完成工作。
- en: Eventually you get better at baking, and you attend competitions. You’re provided
    with professional tools in a different setting (a new environment), given guidelines,
    and expected to bake a cake with what you have. You might pick the ingredients
    yourself, you might choose to use syrup to give the cake a final touch, and you
    might want to cook the mixture for a little longer than you do in your own kitchen.
    These changes to the recipe are influenced by the environment you’re working in,
    as it may affect your decision on what recipe to use, but you can still use *any*
    recipe you want in *any* environment you see fit!
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你会在烘焙方面变得更好，并参加比赛。你将在不同的环境中（一个新环境）获得专业工具，遵循指南，并期望使用你拥有的材料烘焙蛋糕。你可能自己选择配料，你可能选择使用糖浆给蛋糕最后的点缀，你可能想要比你在自己厨房里多煮一会儿。这些对食谱的改变受你工作环境的影响，因为它可能会影响你决定使用哪种食谱，但你仍然可以在你认为合适的任何环境中使用*任何*食谱！
- en: Note that build distributions are constrained to either debug or release, although
    you can have any number of different environments configured to use either of
    those distributions, as you deem necessary. Environments don’t have a one-to-one
    relationship with build distributions. You may have a preferred distribution for
    each environment, but that doesn’t mean the preference is set in stone. For instance,
    in your development environment you’ll typically use the debug distribution, as
    that yields more productivity in your day-to-day activities. However, you might
    want to occasionally try the release distribution in your development environment,
    to be sure it works as expected regardless of the environment, before deploying
    to production.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构建分发被限制在调试或发布，尽管你可以配置任意数量的不同环境来使用这些分发中的任何一个，只要你认为有必要。环境与构建分发之间没有一对一的关系。你可能为每个环境都有一个首选的分发，但这并不意味着这个偏好是固定不变的。例如，在你的开发环境中，你通常会使用调试分发，因为这会在你的日常活动中带来更高的生产力。然而，你可能会偶尔在开发环境中尝试发布分发，以确保它在任何环境中都能按预期工作，然后再部署到生产环境。
- en: Determining which build distribution to use
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确定使用哪个构建分发
- en: 'It’s hardly possible for you to be ready to bake a cake in any kitchen: different
    ovens, pans, and skillets might not be the tools you’re comfortable with. Similarly,
    the build process doesn’t have much control over which environment it’s targeting.
    But you can determine the appropriate build distribution based on the purpose
    of the target environment; either'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何厨房里准备好烘焙蛋糕几乎是不可能的：不同的烤箱、平底锅和煎锅可能不是你感到舒适的工具。同样，构建过程对它针对的环境控制很少。但你可以根据目标环境的用途确定适当的构建分发；要么
- en: '*Debugging* purposes, where you aim to rapidly develop and debug your application'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试*目的，你的目标是快速开发和调试你的应用程序'
- en: '*Release* purposes, where your goals are performance and uptime'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布*目的，其中你的目标是性能和可用性'
- en: These purposes determine your build distributions. In your development environment,
    you’ll use a distribution that’s better tuned to meet your development needs,
    and that mostly comes down to finding problems and resolving them. This is the
    debug distribution. Later in the chapter, you’ll look at ways to improve the flow
    to go beyond simple debugging, also enabling true continuous development that
    runs specific build tasks whenever the code that involves a task changes.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目的决定了你的构建分发。在你的开发环境中，你会使用一个更适合满足你的开发需求的分发，这主要归结于发现问题和解决它们。这就是调试分发。在本章的后面部分，你将了解如何改进流程，以超越简单的调试，并实现真正的持续开发，即当涉及任务的代码发生变化时，运行特定的构建任务。
- en: '[Figure 3.1](#ch03fig01) displays how build distributions answer questions
    about the type of goals you want to accomplish, using configuration to define
    a build flow.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](#ch03fig01) 展示了构建分发如何回答关于你想要完成的目标类型的问题，使用配置来定义构建流程。'
- en: Figure 3.1\. Build distributions and how they define your build flow to fulfill
    specific goals
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 构建分发及其如何定义你的构建流程以实现特定目标
- en: '![](03fig01_alt.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig01_alt.jpg)'
- en: Build distributions for Production environments
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生产环境的构建分发
- en: On the farthest end of the spectrum, far from the development environment, you
    have the *production environment*. Returning to our baking analogy, in this case,
    you’ll aim for high-end, quality cakes that paying customers love, and that can
    only be baked by using the best recipes you have. Production is the environment
    that ultimately serves the application to real end users, manipulating data they
    provide.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端，远离开发环境，是*生产环境*。回到我们的烘焙类比，在这种情况下，你将追求高端、高质量的蛋糕，这是付费客户所喜爱的，并且只能使用你拥有的最佳食谱来烘焙。生产是最终将应用程序提供给真实最终用户的环境，操作他们提供的数据。
- en: This is in contrast to the development environment, where you should use mostly
    fake dummy data, although similar in appearance to real customer data. Production
    environments will rarely be built with a distribution other than release. This
    distribution usually regards performance as the most important factor, and as
    you saw in [chapter 2](kindle_split_013.html#ch02), that might mean minifying
    and bundling static assets, producing spritesheets out of your icons, and optimizing
    your images, but we’ll cover those topics in [chapter 4](kindle_split_015.html#ch04).
    Although the production environment shouldn’t use debug builds, you should definitely
    make sure the release build process works in your development environment.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这与开发环境形成对比，在开发环境中，你应该主要使用假数据，尽管这些数据在外观上与真实客户数据相似。生产环境很少会使用除发布外的其他发行版。这个发行版通常将性能视为最重要的因素，正如你在[第2章](kindle_split_013.html#ch02)中看到的，这可能意味着压缩和捆绑静态资源，从你的图标中生成精灵图，以及优化你的图像，但我们将这些主题留到[第4章](kindle_split_015.html#ch04)中讨论。尽管生产环境不应该使用调试构建，但你确实应该确保发布构建过程在你的开发环境中能够正常工作。
- en: Build Distributions for Staging Environments
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为预发布环境构建发行版
- en: 'In between development and production, you might have a *staging environment;*
    its goal would be to replicate, as much as possible, the configuration used in
    production (although not affecting user data or interacting with services used
    in production). The staging environment will commonly be hosted somewhere other
    than on a local machine. Think of this as working as a baker: you might want to
    bake cakes that hold up to a certain quality, regardless of the kitchen you’re
    working in.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和生产之间，你可能会有一个*预发布环境*；其目标是在尽可能的情况下，复制生产环境中使用的配置（尽管不会影响用户数据或与生产中使用的服务交互）。预发布环境通常托管在除本地机器以外的其他地方。想象一下你是一名面包师：你可能希望制作出能够达到一定质量的蛋糕，无论你在哪个厨房工作。
- en: A staging environment might involve working somewhere other than your own kitchen,
    but it wouldn’t be in a restaurant’s kitchen, either. Maybe you want to bake a
    treat for a friend, so you use her kitchen instead. Staging environments attempt
    to bring production and development to a middle ground, meaning they try to stay
    as close to both environments as possible. For this purpose they might periodically
    get a *curated* version of the production database (by curated I mean sensitive
    data, such as credit cards or passwords, must be stripped off or blanked). You’ll
    pick a distribution for this environment based on what you’re testing, but you’ll
    generally default to release, because that’s closer to the production environment.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 预发布环境可能涉及在除了你自己的厨房以外的其他地方工作，但也不会在餐厅的厨房里。也许你想为朋友制作一份礼物，所以你使用她的厨房。预发布环境试图将生产和开发带到中间地带，这意味着它们试图尽可能接近这两个环境。为此，它们可能会定期获取生产数据库的*精选*版本（通过精选，我的意思是敏感数据，如信用卡或密码，必须被删除或清空）。你将为这个环境选择一个发行版，基于你要测试的内容，但通常默认为发布，因为这样更接近生产环境。
- en: The real purpose of having a staging environment is to allow for quality assurance
    (QA) engineers, product owners, and others to test the application before it goes
    live to production. Given that staging is basically the same as production, except
    it’s inaccessible to end users, your team can quickly identify issues in the upcoming
    release without compromising the production environment, and with certainty that
    it’ll work as expected on a hosted environment.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有预发布环境的真正目的是为了允许质量保证（QA）工程师、产品所有者和其他人在应用程序上线到生产之前对其进行测试。鉴于预发布基本上与生产相同，只是对最终用户不可访问，你的团队能够快速识别即将发布的版本中的问题，而不会影响生产环境，并且可以确信它将在托管环境中按预期工作。
- en: Let’s swim in code for a moment and consider how you can use distributions to
    approach build configuration so your build tasks adequately portray which build
    flow (debug or release) they belong to.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时沉浸在代码中，考虑一下如何使用发行版来处理构建配置，以便你的构建任务能够充分体现它们所属的构建流程（调试或发布）。
- en: Distributions in Grunt Tasks
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grunt任务中的发行版
- en: In [chapter 2](kindle_split_013.html#ch02) we went over a few build tasks and
    their configurations, but they were mostly standalone and not part of a flow.
    With build distributions, you’ll improve your build process by assigning each
    task the intent of using it in a given build flow. Are you aiming for debugging
    quality or smaller file sizes and fewer HTTP requests? Well, if you start using
    naming conventions in your Grunt tasks and aliases, the answer will become much
    easier for you to deduce.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_013.html#ch02)中，我们讨论了一些构建任务及其配置，但它们大多是独立的，不是流程的一部分。通过构建发行版，你可以通过为每个任务分配在给定构建流程中使用它的意图来改进你的构建过程。你是追求调试质量还是更小的文件大小和更少的HTTP请求？好吧，如果你开始在Grunt任务和别名中使用命名约定，答案将对你来说更容易推断。
- en: As a general rule, I propose you call your build targets `debug` or `release`
    based on what distribution the task target is geared toward. General purpose tasks
    such as `JSHint` don’t need to abide by this convention, and you can still call
    your targets names such as `jshint:client`, `jshint:server`, and `jshint:support`.
    You could use the `support` target for the remainder of the code base, which isn’t
    server- or client-related, but mostly build- or deploy-related.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般性规则，我建议你根据任务目标所针对的发行版来命名你的构建目标为`debug`或`release`。通用任务，如`JSHint`，不需要遵循此约定，你仍然可以给你的目标命名，例如`jshint:client`、`jshint:server`和`jshint:support`。你可以使用`support`目标来处理剩余的代码库，这些代码与服务器或客户端无关，但主要与构建或部署相关。
- en: Considering this convention, you may see yourself having a series of tasks such
    as `jade:debug` and l`ess:debug`, which you could then bundle together in a `build:debug`
    alias. The same could apply to release, clearly separating your build flows in
    code as well as in your thinking. The following listing (sample 03/01_distribution-config)
    shows what this would be like in code.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个约定，你可能会看到一系列任务，如`jade:debug`和`less:debug`，然后你可以将这些任务捆绑在一起，创建一个`build:debug`别名。同样，这也适用于发布，清楚地分离你的代码和思维中的构建流程。以下列表（sample
    03/01_distribution-config）展示了在代码中这会是什么样子。
- en: Listing 3.1\. Distributed build configuration
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1. 分布式构建配置
- en: '![](ch03ex01-0.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03ex01-0.jpg)'
- en: '![](ch03ex01-1.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03ex01-1.jpg)'
- en: 'Using this kind of separation, it’s easy to create aliases to build the application
    for either distribution. Here are a couple of sample aliases:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种分离，很容易创建别名来为任意发行版构建应用程序。这里有一些示例别名：
- en: '[PRE17]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can look for the fully working code listing example in the accompanying
    source code repository. Remember, these are organized by chapter, so look for
    the 01_distribution-config folder under [chapter 3](#ch03).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在配套的源代码仓库中查找完整的代码列表示例。记住，这些是按章节组织的，所以请在[第3章](#ch03)下查找01_distribution-config文件夹。
- en: This provides an excellent base for you to build on. You can keep iterating
    on each of these flows, possibly reusing tasks, such as `jshint` in this example,
    adding more tasks to both distributions or maybe to one of them in case it only
    applies to one flow. For example, you’ll want to keep tasks such as updating the
    change log in the release flow, because the product to be released might change
    across debug builds, and you need to accompany your deployment with documentation
    about all the changes introduced. We’ll come back to the topic, looking at debug
    distribution-specific tasks later in the chapter. Release-specific tasks are analyzed
    in [chapter 4](kindle_split_015.html#ch04).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个很好的基础来构建。你可以对这些流程中的每一个进行迭代，可能重用任务，例如本例中的`jshint`，向两个发行版或其中一个添加更多任务，或者如果它只适用于一个流程，那么可能只添加到其中一个。例如，你可能会希望在发布流程中保留更新变更日志的任务，因为要发布的产品可能会在调试构建中发生变化，你需要伴随你的部署提供关于所有引入的变更的文档。我们将在本章后面回到这个话题，查看调试发行版特定的任务。发布特定的任务在第4章（kindle_split_015.html#ch04）中进行分析。
- en: You’ve now learned what build distributions are and how they define the different
    flows created when putting together a build process; let’s turn our attention
    to the application configuration within each environment, or what I call environment-level
    configuration.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了构建发行版是什么以及它们是如何定义构建过程中创建的不同流程的；让我们将注意力转向每个环境中的应用配置，或者我称之为环境级配置。
- en: 3.1.2\. Environment-level configuration
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 环境级别配置
- en: 'Environment configuration is separate from build distributions, and the distinction
    is clear: *build distributions* determine how your application should be built.
    They shouldn’t bear any weight in the application itself, but only affect the
    build process, or more concretely, the build flow you follow. *Environment configuration*,
    in contrast, is environment-specific.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 环境配置与构建分发是分开的，区别是明显的：*构建分发*决定了你的应用程序应该如何构建。它们不应该在应用程序本身中承担任何重量，而只影响构建过程，或者更具体地说，你遵循的构建流程。相比之下，*环境配置*是特定于环境的。
- en: '|  |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Environment-level configuration: what does it include?**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境级别配置：它包括什么？**'
- en: Moving forward, whenever I mention configuration in this chapter, I’m referring
    to environment-level configuration, unless otherwise noted. By *environment-level
    configuration* I mean values such as
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，每当我在本章中提到配置时，我指的是环境级别的配置，除非另有说明。通过*环境级别配置*，我指的是如下值
- en: Database connection strings
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接字符串
- en: API authentication credentials
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API认证凭证
- en: Session encryption secrets
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话加密密钥
- en: The port your web server listens on for HTTP requests
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的Web服务器监听HTTP请求的端口
- en: 'These kinds of configuration values tend to contain mostly sensitive data.
    I strongly discourage merrily packaging these kinds of secrets in plain text along
    with the rest of your code base. Developers shouldn’t have direct access to services,
    such as your database, and therefore access to user data. It also becomes an attack
    vector: gaining access to your code repository translates into gaining access
    into your databases or API secrets, and most frighteningly, accessing your customer’s
    data.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这类配置值往往包含大量敏感数据。我强烈建议不要将这类秘密与代码库中的其他部分一起以纯文本形式打包。开发者不应直接访问服务，例如您的数据库，因此不应访问用户数据。这也成为了一个攻击向量：访问您的代码库意味着可以访问您的数据库或API密钥，最可怕的是，可以访问您的客户数据。
- en: In this respect, an excellent rule of thumb is to develop your applications
    as if you were developing open source software. You wouldn’t push sensitive API
    keys and database connection strings into your publicly available open source
    repositories, would you?
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，一个很好的经验法则是将你的应用程序开发得就像你在开发开源软件一样。你不会把敏感的API密钥和数据库连接字符串推送到你公开可用的开源存储库中，对吧？
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 3.2](#ch03fig02) depicts how your application combines build distribution
    output and environment configuration to serve an application.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.2](#ch03fig02)展示了您的应用程序如何结合构建分发输出和环境配置来提供服务。'
- en: Figure 3.2\. Environment-level configuration—environments, configuration, and
    distributions, coming together in an application. Environment configuration consists
    of secret credentials and any other configuration that might change across environments.
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 环境级别配置——环境、配置和分发在一个应用程序中的结合。环境配置包括密钥凭证以及可能在不同环境中变化的任何其他配置。
- en: '![](03fig02_alt.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig02_alt.jpg)'
- en: Build flows
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建流程
- en: As you can see on the left of the figure, the debug and release distributions
    only affect the build itself, while environment configuration will affect the
    application directly, after a build is executed, for either debug or release.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图左侧所示，调试和发布分发只影响构建本身，而环境配置将在构建执行后直接影响应用程序，无论是调试还是发布。
- en: Environment-level Configuration
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 环境级别配置
- en: Application configuration must be environment-specific. These environment variables
    are not to be confused with build distributions, which only affect the build process
    itself. Application configuration refers to small (and often sensitive) snippets
    of data such as database connection strings, API keys, encryption secrets, logging
    verbosity level, and so on.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置必须是特定于环境的。这些环境变量不应与仅影响构建过程的构建分发混淆。应用程序配置指的是小（通常是敏感）的数据片段，例如数据库连接字符串、API密钥、加密密钥、日志详细程度等。
- en: Although distributions generally don’t contain sensitive data, environment-level
    configuration often does. For example, an environment’s configuration might have
    access credentials to a database instance, an API service such as Twitter’s REST
    API, or maybe a username and a password used to send out emails through IMAP.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分发通常不包含敏感数据，但环境级别配置通常包含。例如，一个环境配置可能包含对数据库实例、API服务（如Twitter的REST API）的访问凭证，或者可能是用于通过IMAP发送电子邮件的用户名和密码。
- en: But not all environment configuration is sensitive or poses a security threat
    if leaked. For instance, the application’s listening port and the logging verbosity
    level, which determine how verbose your logger should be, are both environment-specific,
    but they’re not sensitive information in the slightest. That being said, you don’t
    have any reason to treat “safe” configuration differently from sensitive configuration,
    except that you might include configuration defaults with safe variables, such
    as the application’s listening port. You should never do that with sensitive data.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有环境配置都是敏感的，或者泄露后构成安全威胁。例如，应用程序的监听端口和日志详细程度级别，这些决定了您的日志记录器应该有多详细，都是特定环境的，但它们在本质上并不敏感。话虽如此，您没有理由将“安全”配置与敏感配置区别对待，除非您可能包含与安全变量（如应用程序的监听端口）相关的配置默认值。您绝对不应该对敏感数据这样做。
- en: You’ll focus on the development environment for now, and move on to staging
    and production environments in the following chapter.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您将专注于开发环境，并在下一章中继续讨论预发布和生成环境。
- en: 3.1.3\. What’s so special about development?
  id: totrans-560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3\. 开发环境有什么特别之处？
- en: What’s so different about local development in comparison with other environments?
    Well, much, and ideally, not so much. The two most remarkable differences are
    that this is the environment where you’ll spend most of your time, and it doesn’t
    matter if something stops working; you can always fix it, and nobody else is going
    to notice it. In contrast, you should spend little time in production, because
    that probably translates into people not using your product, and if something
    stops working, that won’t be good, either. We’ll go over measures to mitigate
    and monitor for problems in release-grade environments in the next chapter.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他环境相比，本地开发有什么不同之处？嗯，很多，理想情况下，并不多。两个最显著的区别是，这是您将花费大部分时间的环境，而且如果某些东西停止工作，您可以随时修复它，而且没有人会注意到。相比之下，您应该在生产环境中花费很少的时间，因为这可能意味着人们不会使用您的产品，如果某些东西停止工作，那也不会很好。我们将在下一章中讨论减轻和监控发布级环境问题的措施。
- en: The Build First approach carries a slew of benefits when it comes to the development
    environment, and that’s the meat of this chapter. We’ll talk about tools and mechanisms
    that are famously helpful during development. Let’s save the fun for last; we
    need to talk about configuration first. We’ll go over your options when it comes
    to managing, reading, and storing the sensitive data of your environment-level
    configuration in a sensible way, so as not to expose your secrets to potential
    intruders.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Build First 方法在开发环境中带来了一系列的好处，这也是本章的重点。我们将讨论在开发过程中非常有帮助的工具和机制。让我们把乐趣留到最后；我们首先需要讨论配置问题。我们将探讨如何以合理的方式管理、读取和存储环境级配置的敏感数据，以免将您的秘密暴露给潜在的入侵者。
- en: 3.2\. Configuring environments
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 配置环境
- en: Until now, you’ve established that committing sensitive configuration to your
    repositories in plain text poses a security risk. In this section we’ll cover
    how to manage configuration from different sources, such as a file, the database,
    or application memory. At the same time, you’ll explore different approaches for
    protecting your configuration data. Please note that the information I’m about
    to give you isn’t limited to Node.js. I picked that platform because I needed
    to give you a concrete example of how to configure your environment-level variables,
    and because this is a JavaScript book. That being said, the environment configuration
    approaches we’ll discuss can be applied to applications running on any server-side
    platform you like.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经确定将敏感配置以纯文本形式提交到您的存储库存在安全风险。在本节中，我们将介绍如何从不同的来源管理配置，例如文件、数据库或应用程序内存。同时，您将探索保护配置数据的不同方法。请注意，我即将提供的信息并不仅限于Node.js。我选择这个平台是因为我需要给您提供一个具体的例子，说明如何配置环境级变量，并且因为这是一本JavaScript书籍。话虽如此，我们将讨论的环境配置方法可以应用于您喜欢的任何服务器端平台上的应用程序。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Environment-specific variables**'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**特定环境的变量**'
- en: Environment configuration is changing any variable that could change depending
    on the environment you run your application in. For example, you might need variables
    with credentials so you can send emails, and you might want to allow an option
    to send all emails to a catch-all account for debug environments. API keys to
    services you consume usually change on a per-environment basis, too. Environment
    configuration is the place where you should keep all of these settings and credentials
    so you can adjust them for each environment.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 环境配置会改变任何可能根据你运行应用程序的环境而改变的变量。例如，你可能需要带有凭证的变量来发送电子邮件，你可能还希望允许在调试环境中将所有电子邮件发送到通配符账户。你消费的服务的API密钥通常也是按环境变化的。环境配置是存放所有这些设置和凭证的地方，这样你可以为每个环境调整它们。
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'More often than I’d like to admit, I’ve worked on projects that shamefully
    broke this configuration principle and contained configuration for all of their
    environments directly in their repository. Development, staging, production—they
    all were fair game. Configuration for each of these was maintained in a separate
    file, and something such as a string that contains “development” governed which
    of those files was used. This is bad because of a number of problems:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常不情愿地参与那些羞于启齿的项目，这些项目违反了这一配置原则，将所有环境的配置直接放在了他们的仓库中。开发、预发布、生产——它们都是公平的游戏。每个环境的配置都保存在一个单独的文件中，例如包含“开发”字符串的配置决定了使用哪个文件。这样做有多个问题：
- en: First, I can’t stress enough the importance of not packing credentials to your
    live environments directly in your repositories. That’s exactly the kind of thing
    that belongs in environment-level configuration.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我必须强调，不要直接将凭证打包到你的仓库中，放入你的实际环境配置中。这正是属于环境级配置的东西。
- en: Second, you shouldn’t have to repeat configuration values for each environment
    you have, effectively maintaining the same value in multiple different files;
    this would be WET code. It doesn’t scale well when you want to add new environments
    or configuration values to your application.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，你不应该需要为每个环境重复配置值，实际上是在多个不同的文件中维护相同的值；这将导致WET（Write Every Time）代码。当你想要向应用程序添加新的环境或配置值时，它扩展性不好。
- en: 'I’ve also participated in endeavors where configuration was tediously manual:
    you’d get a brand new code base, ask around for a few credentials to get started,
    and type them into a single configuration file. If you had to deploy, then you’d
    manually change those same values again to whatever configuration that satisfied
    the environment you were deploying to. In the previous case, at least you didn’t
    have to change configuration around to get your application to work any time you
    changed environments. You’d change a magic string, setting it to something such
    as “staging,” and it’d work.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我还参与过配置繁琐的项目：你会得到一个全新的代码库，四处询问以获取一些凭证来开始，然后将它们输入到一个配置文件中。如果你需要部署，那么你必须手动更改这些相同的值，以适应你部署到的环境。在前一种情况下，至少你不必每次更改环境时都更改配置来使应用程序工作。你会更改一个魔法字符串，将其设置为“预发布”，然后它就会工作。
- en: How can you go with that approach without sharing everything with everyone?
    You might think that’s not a big deal; it’s not as if you’re going to open source
    your project overnight. But if you’re thinking like that, you’re missing the point
    entirely. It’s not good practice to give everyone access to potentially sensitive
    information about your production environment. And there’s no reason to—that configuration
    belongs with that environment, nowhere else.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么能不与每个人分享一切就采用这种方法呢？你可能会认为这不是什么大问题；你不会一夜之间开源你的项目。但如果你这样想，你就完全错过了重点。给每个人访问你生产环境中可能敏感信息的权限不是好的做法。而且没有必要——这种配置应该属于那个环境，不应该放在其他地方。
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Open source software**'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**开源软件**'
- en: Experimenting in open source projects, something I vigorously encourage you
    to try, helped me vastly improve over time the techniques and measures I take
    to protect sensitive data. I started thinking in a “what if a stranger downloaded
    my code?” kind of way, and it opened my eyes as to what was fine, and what wasn’t,
    when it came to pushing code to my repositories.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源项目中进行实验，这是我强烈鼓励你尝试的事情，这极大地帮助我在保护敏感数据的技术和措施上随着时间的推移得到了显著提升。我开始思考“如果陌生人下载了我的代码怎么办？”这样的问题，这让我对将代码推送到我的仓库时什么可以接受，什么不可以接受有了更清晰的认识。
- en: '|  |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s start our discussion of configuring environments by talking about waterfall
    configuration, and then we’ll cover different methods you can use to protect it,
    namely, encryption and environment variables.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论瀑布配置来开始我们的环境配置讨论，然后我们将介绍你可以用来保护它的不同方法，即加密和环境变量。
- en: 3.2.1\. Storing configuration in a waterfall
  id: totrans-579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1. 在瀑布中存储配置
- en: '*Waterfall* is a method for storing your configuration. It’s as simple as picking
    a priority that determines the order of importance of these stores as you merge
    them together. Waterfall is useful because it helps your configuration to be divided
    in different places but still be part of a whole. A few places exist where you
    can define your configuration; for example'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '*瀑布*是一种存储配置的方法。它就像选择一个优先级，这个优先级决定了这些存储在合并时的顺序。瀑布之所以有用，是因为它帮助你的配置被分散在不同的地方，但仍然是一个整体的一部分。有几个地方可以定义你的配置；例如'
- en: Plain text directly in your code base, only meant for data that doesn’t violate
    your security
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在代码库中的纯文本，仅用于不违反你安全的数据
- en: In encrypted files; it’s meant to distribute configuration securely.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加密文件中；它的目的是安全地分发配置。
- en: At the machine level, setting operating system environment variables
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器级别，设置操作系统环境变量
- en: Passing command-line arguments to your application at the process level
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程级别向你的应用程序传递命令行参数
- en: Keep in mind, you’re configuring the environment, regardless of the level at
    which you do it; thus, all configuration sources must always be accessed from
    a single point in your application. This configuration root service should be
    careful to determine which source is most important when providing a requested
    value. In the list above, I ordered a few potential configuration sources from
    lowest to highest priority. For example, a command-line argument setting the port
    number will overwrite the port number stored in a plain text file within the repository.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论你在哪个级别配置环境，你都是在配置环境；因此，所有配置源都必须始终从应用程序的单一点访问。这个配置根服务应该小心确定在提供请求的值时哪个来源最重要。在上面的列表中，我从最低到最高优先级对几个潜在的配置来源进行了排序。例如，设置端口号的命令行参数将覆盖存储在存储库中纯文本文件中的端口号。
- en: 'Clearly these aren’t the only places where we can store configuration, but
    they provide a great starting point for any application. I know I’ve severely
    thrashed plain text, but it’s okay to have a plain JSON file to set up absolute
    basics, such as the environment name and the port number. Let’s call this one
    `defaults.json`:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些并不是我们存储配置的唯一地方，但它们为任何应用程序提供了一个很好的起点。我知道我严重地破坏了纯文本，但有一个纯JSON文件来设置绝对基本设置，例如环境名称和端口号是可以的。让我们称这个文件为`defaults.json`：
- en: '[PRE18]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is perfectly reasonable as far as plain text goes. I also encourage keeping
    a second plain text file, which you might call `user.json,` to keep personal configuration
    you might want to use, but not necessarily commit to modifying the defaults. The
    `user.json` file is also useful if you need to quickly test with a different configuration:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这在纯文本方面是完全合理的。我也鼓励保留第二个纯文本文件，你可能称之为`user.json`，以保存你可能想要使用但不必提交修改默认值的个人配置。`user.json`文件在需要快速使用不同配置进行测试时也非常有用：
- en: '[PRE19]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As long as it’s encrypted, sensitive configuration can be checked into source
    control. I advocate using this kind of configuration to share environment defaults
    among your developers. The reasoning is that instead of having to redistribute
    a JSON file every time the defaults change, you distribute the key to decrypt
    the secure file once, and whenever a change is made it’s checked into source control,
    and the developers can decrypt it using the key they already had.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 只要加密，敏感的配置就可以被检查到源控制中。我提倡使用这种配置来在开发者之间共享环境默认值。理由是，你不必每次默认值更改时都重新分发JSON文件，而是一次性分发解密安全文件的密钥，每次更改都会被检查到源控制中，开发者可以使用他们已有的密钥来解密。
- en: I should mention that to maximize security, different private keys should be
    used for each encrypted configuration file. This is particularly important when
    dealing with one file per environment, because a breach would be chaotic for every
    environment; in addition, it’ll be easier to change the keys if they’re only used
    in one place.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到，为了最大化安全性，每个加密配置文件应使用不同的私钥。这在处理每个环境一个文件的情况下尤为重要，因为任何环境的泄露都会造成混乱；此外，如果私钥只在一个地方使用，更换密钥也会更容易。
- en: You have a few different ways to safely distribute configuration among your
    environments; we’ll go over a couple of them next. The first one is through encryption,
    and we’ll go over the process of safely encrypting your configuration files using
    a concrete example. The second alternative is not to distribute environment configuration
    files with your code base, but rather to store the configuration solely in the
    target environment. Let’s start with security through encryption.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种不同的方式可以在你的环境中安全地分发配置；我们将在下面介绍其中几种。第一种是通过加密，我们将通过一个具体的例子来介绍如何安全地加密配置文件。第二种选择是不将环境配置文件与代码库一起分发，而是仅在目标环境中存储配置。让我们从加密安全开始。
- en: 3.2.2\. Using encryption to harden environment configuration security
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2. 使用加密来强化环境配置安全性
- en: 'To securely transmit configuration within your code base, you need to take
    a few security measures. First and foremost, you shouldn’t commit decrypted configuration
    files to source control, as this would defeat the entire purpose of encryption.
    The same holds true for encryption keys: you should keep these somewhere safe,
    preferably off the cloud altogether—maybe on a USB pen drive. What you should
    share in your repositories are the encrypted versions of these files and simple
    command-line tools to decrypt or update their encrypted counterparts. [Figure
    3.3](#ch03fig03) describes this flow.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码库中安全地传输配置，你需要采取一些安全措施。首先，你不应该将解密后的配置文件提交到源代码控制，因为这会违背加密的全部目的。对于加密密钥也是如此：你应该将它们保存在安全的地方，最好是完全不在云端——也许可以放在U盘上。你应该在仓库中共享的是这些文件的加密版本以及简单的命令行工具，用于解密或更新它们的加密副本。[图3.3](#ch03fig03)描述了这一流程。
- en: Figure 3.3\. Configuration encryption and decryption flows using private RSA
    keys
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3. 使用私有RSA密钥进行配置加密和解密流程
- en: '![](03fig03_alt.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig03_alt.jpg)'
- en: To this purpose, you can set up a couple of folders. For example, use `env/private`,
    where you’ll keep the unsecured data that’s been decrypted, and `env/secure` to
    store the encrypted files. Because the `env/private` folder contains sensitive
    data, it shouldn’t be committed to source control systems. Rather, you’re going
    to distribute an encryption key by another means; for example, physically giving
    it to the interested parties. Then the repository will contain tools (Grunt tasks
    in your case) to encrypt and decrypt each particular file using its corresponding
    RSA (an encryption algorithm) key. You’ll use three different Grunt tasks for
    encryption purposes. The first one will generate the private key; the other two
    will encrypt and decrypt your configuration using that private key.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，你可以设置几个文件夹。例如，使用`env/private`，你将在这里保存已解密的未加密数据，以及`env/secure`来存储加密文件。因为`env/private`文件夹包含敏感数据，所以它不应该提交到源代码控制系统。相反，你将通过其他方式分发加密密钥；例如，物理地将其交给相关人员。然后，仓库将包含工具（在你的情况下是Grunt任务）来使用相应的RSA（一种加密算法）密钥加密和解密每个特定的文件。你将使用三个不同的Grunt任务进行加密。第一个将生成私钥；其他两个将使用该私钥加密和解密你的配置。
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**RSA encryption example**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA加密示例**'
- en: I wrote a fully working example that’s available in the accompanying source
    code listings, named 02_rsa-config-encryption,^([[a](#ch03fn01a)]) under ch03\.
    In that example, you’ll use the `grunt-pemcrypt` package I wrote, which facilitates
    the tasks required to deal with encryption and decryption of secure configuration
    files. We won’t deviate into the code itself, because it’s fairly straightforward
    to follow and properly documented.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个完全工作的示例，可在附带的源代码列表中找到，名为02_rsa-config-encryption，^([[a](#ch03fn01a)])在ch03目录下。在该示例中，你将使用我编写的`grunt-pemcrypt`包，该包简化了处理安全配置文件加密和解密所需的任务。我们不会深入代码本身，因为它相当直观，并且有很好的文档记录。
- en: ^a The code example is available online at [http://bevacqua.io/bf/secure-config](http://bevacqua.io/bf/secure-config).
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a 代码示例可在网上找到，地址为[http://bevacqua.io/bf/secure-config](http://bevacqua.io/bf/secure-config)。
- en: '|  |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To recap RSA encryption
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾RSA加密
- en: Create a private key; don’t share it with anyone.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个私钥；不要与任何人分享。
- en: Use it to encrypt your sensitive files.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用它来加密你的敏感文件。
- en: Transmit the encrypted file with your code base.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加密文件与代码库一起传输。
- en: When you need to update the secure file, update the plain one and encrypt it
    again.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要更新安全文件时，更新明文文件并重新加密它。
- en: When someone else copies your code base, they can’t access the encrypted configuration
    unless you give them the key.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他人复制你的代码库时，除非你给他们提供密钥，否则他们无法访问加密配置。
- en: 'In the next section, let’s look at the pros and cons of taking the alternative
    route: not encrypting your environment-level configuration but also not distributing
    it (and your sensitive secrets with it) together with the rest of your application’s
    code repository.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看采取替代路线的优缺点：不加密你的环境级配置，也不将其（以及你的敏感机密）与你的应用程序代码库的其他部分一起分发。
- en: 3.2.3\. Setting environment-level configuration at the OS level
  id: totrans-610
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. 在操作系统级别设置环境级配置
- en: When it comes to release environments (staging, production, and anything in
    between) you might want to configure sensitive values in the environment directly
    and keep them off your code base. Keeping your configuration off the code base
    enables you to change it without the need for a full redeployment. Using system-level
    environment variables is a great way to do that.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到发布环境（预发布、生产以及介于两者之间的任何环境）时，你可能希望在环境中直接配置敏感值，并使其远离你的代码库。将你的配置从代码库中移除，使你能够在无需全面重新部署的情况下更改它。使用系统级环境变量是做到这一点的好方法。
- en: 'This is something I picked up from working with cloud-based hosting solutions
    (such as Heroku), and it’s convenient to set up. An added benefit of using environment
    variables is that you don’t need to touch the code base to change its behavior.
    The downside is that, similar to your previous approach, you don’t have access
    to most of the configuration when you clone the repository for the first time.
    An exception to that downside is any unprotected defaults you might have, such
    as the development environment listen port. That downside, however, is also the
    goal of taking this route: being unable to deploy a newly cloned repository as
    is to one of the production environments.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我从与基于云的托管解决方案（如Heroku）合作中获得的，它设置起来很方便。使用环境变量的额外好处是，你不需要接触代码库来改变其行为。缺点是，与你的先前方法类似，当你第一次克隆仓库时，你无法访问大多数配置。那个缺点的例外是任何未受保护默认值，例如开发环境监听端口。然而，那个缺点也是采取这条路线的目标：无法将新克隆的仓库直接部署到生产环境之一。
- en: The difference between encrypted file stores and environment-level configuration
    is that it’s more secure not to share anything with your code base at all, even
    if it’s encrypted. But the downside of going the environment variables route is
    that you still need to get the configuration there.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文件存储和环境级配置之间的区别在于，完全不与你的代码库共享任何内容更为安全，即使它是加密的。但采用环境变量方法的缺点是，你仍然需要将配置放置在那里。
- en: In the next chapter, I’ll introduce Heroku, a cloud hosting Platform as a Service
    (PaaS) provider, which enables hosting of web applications in the cloud as easily
    as doing a `git push`. Heroku uses environment variables for your environment
    configuration, and they thoroughly documented their philosophy (on web application
    building, architecture, and scaling) and published it on a website called 12factor.net^([[1](#ch03fn01)])
    that everyone should read.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将介绍Heroku，这是一个云托管平台即服务（PaaS）提供商，它使你在云中托管Web应用变得与执行`git push`一样简单。Heroku使用环境变量进行环境配置，并且他们详细记录了他们的理念（关于Web应用构建、架构和扩展）并在一个名为12factor.net的网站上发布，每个人都应该阅读。
- en: ¹ 12 Factor is an excellent guide to robust application development. Check it
    out at [http://bevacqua.io/bf/12factor](http://bevacqua.io/bf/12factor).
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 12 Factor 是一个关于稳健应用开发的优秀指南。请在此处查看[http://bevacqua.io/bf/12factor](http://bevacqua.io/bf/12factor)。
- en: 'For local development, you’ll still use a JSON file that doesn’t get committed
    to source control, and it contains what you would’ve put in the secure JSON file
    in the previous section. The following is a sample environment JSON file:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发，你仍然会使用一个不会提交到源控制的JSON文件，它包含了你之前章节中会放入安全JSON文件的内容。以下是一个示例环境JSON文件：
- en: '[PRE20]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you want to provision new contributors to your project with a copy of the
    environment file you use locally, consider going the encryption approach for that
    one file (the `development` configuration), and taking the environment variables
    approach for hosted environments (those that aren’t local to your development
    machine) to maximize security.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为你的项目的新贡献者提供你本地使用的环境文件副本，考虑为该单个文件（`development`配置）采用加密方法，而对于托管环境（那些不是本地于你的开发机器的）采用环境变量方法以最大化安全性。
- en: 'For hosted solutions (such as `staging` or `production`), a different approach
    takes place. Heroku provides a command-line interface that makes it easy to set
    environment variables.^([[2](#ch03fn02)]) With the example below, you could set
    the environment to `staging` so your code can tune the experience to that environment—increased
    logging, for example, but mostly the same as production:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于托管解决方案（如 `staging` 或 `production`），采取不同的方法。Heroku 提供了一个命令行界面，这使得设置环境变量变得容易。[2](#ch03fn02)
    以下示例中，你可以将环境设置为 `staging`，这样你的代码就可以调整到该环境——例如，增加日志记录，但主要与生产环境相同：
- en: ² Learn more about configuring your Node.js environments with Heroku at [http://bevacqua.io/bf/heroku-cli](http://bevacqua.io/bf/heroku-cli).
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 在 [http://bevacqua.io/bf/heroku-cli](http://bevacqua.io/bf/heroku-cli) 了解更多关于使用
    Heroku 配置 Node.js 环境的信息。
- en: '[PRE21]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The command line should have the last say on what values go where, making it
    easy to enable small modifications to your environment, such as setting a port
    or the execution mode (debug or release). Here’s an example of an override that
    changes the port and the environment:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行应该对值的选择有最后的决定权，这使得启用对环境的小幅修改变得容易，例如设置端口或执行模式（调试或发布）。以下是一个示例，它覆盖了端口和环境：
- en: '[PRE22]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Last, let’s go over how you could pull together all the different sources of
    configuration (environment variables, text files, and command-line arguments)
    in a way that makes sense.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回顾一下如何以有意义的方式将所有不同的配置源（环境变量、文本文件和命令行参数）组合在一起。
- en: 3.2.4\. Merging configuration as a waterfall in code
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 将配置作为代码中的瀑布合并
- en: You’re ready to glue all this together into pieces of JavaScript. Considering
    how lazy we are, let’s not write much code to accomplish this.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将所有这些合并成 JavaScript 代码片段。考虑到我们有多懒，让我们不要写太多代码来完成这个任务。
- en: 'There’s an npm module called `nconf` that deals with merging configuration
    sources together, regardless of what you’re using: JSON files, JavaScript objects,
    environment variables, process arguments, and so on. The following code is an
    example (labeled ch03/03_merging-config in the samples) of how you could configure
    `nconf` to use the plain JSON files from [section 3.2.2](#ch03lev2sec5). Note
    that while the configuration source order in the code listing might seem counterintuitive,
    `nconf` prioritizes configuration on a “first-come first-served” basis:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `nconf` 的 npm 模块，用于合并配置源，无论你使用什么：JSON 文件、JavaScript 对象、环境变量、进程参数等等。以下代码是一个示例（在示例中标记为
    ch03/03_merging-config），展示了如何配置 `nconf` 以使用 [3.2.2 节](#ch03lev2sec5) 中的纯 JSON
    文件。请注意，虽然代码列表中的配置源顺序可能看起来有些不合常理，但 `nconf` 会根据“先来先服务”的原则优先处理配置：
- en: '[PRE23]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After you set up this module, you can use it to get configuration values from
    any of those stores, in order of appearance:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好此模块后，你可以使用它从任何存储中获取配置值，按照出现的顺序：
- en: First, `nconf.argv()` prioritizes command-line arguments above everything else,
    as it’s the first source we’ve added. For instance, executing the application
    with `node app --PORT 80` means that the PORT variable will be assigned that value,
    regardless of configuration from other sources.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`nconf.argv()` 将命令行参数的优先级置于所有其他内容之上，因为它是我们添加的第一个源。例如，使用 `node app --PORT
    80` 执行应用程序意味着 PORT 变量将被分配该值，无论其他来源的配置如何。
- en: The `nconf.env()` line tells `nconf` to source configuration from the environment
    as well. For instance, executing `PORT=80 node app` will set the port to `80`,
    while `PORT=80 node app --PORT 3000` will set the port to `3000`, because command-line
    arguments have more priority than environment variables.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nconf.env()` 行指示 `nconf` 从环境中获取配置。例如，执行 `PORT=80 node app` 将端口设置为 `80`，而 `PORT=80
    node app --PORT 3000` 将端口设置为 `3000`，因为命令行参数的优先级高于环境变量。'
- en: 'Last, the `nconf.file()` line sources a JSON file to pull the least important
    values: these will be overridden by both environment variables and command-line
    arguments! If you provide a command-line argument such as `--PORT 80`, it won’t
    matter that you had `"PORT": 3000` in your development JSON file; you’ll still
    use port 80\. Again, you’ll find a complete example in the accompanying source
    code, also detailing how to use `nconf` when going the Heroku route. This will
    prove useful in the following chapter, so I’d advise you to read this chapter
    to the end and then get up to speed with the code samples if you haven’t gone
    through them yet.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后，`nconf.file()` 行从 JSON 文件中拉取最不重要的值：这些值将被环境变量和命令行参数覆盖！如果你提供了一个命令行参数，例如 `--PORT
    80`，那么你开发 JSON 文件中的 `"PORT": 3000` 就不重要了；你仍然会使用端口 80。再次强调，你将在附带的源代码中找到一个完整的示例，也详细说明了如何在使用
    Heroku 路线时使用 `nconf`。这将在下一章中非常有用，所以我建议你把这一章读到结尾，然后如果你还没有看过，就熟悉一下代码示例。'
- en: Now that you know how to properly configure builds and environments, we’ll head
    on to the last couple of sections. Before getting to continuous development, let
    me emphasize a couple of best practices when it comes to setting up environments
    for the first time.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何正确配置构建和环境，我们将继续到最后几个部分。在进入持续开发之前，让我强调一下在第一次设置环境时的一些最佳实践。
- en: 3.3\. Automating tedious first-time setup tasks
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 自动化繁琐的首次设置任务
- en: 'When setting up your environment for the first time, you’ve got to think about
    what you’re doing, and you need to automate anything that’s plausible to automate.
    The reason: if you don’t automate, it’ll translate directly into more work for
    newcomers. Another reason for preemptively automating these tasks is purely that
    you can.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次设置环境时，你必须考虑你在做什么，并且你需要自动化任何可以自动化的东西。原因：如果你不自动化，这会直接转化为新来者更多的工 作。预先自动化这些任务的另一个原因纯粹是因为你可以这样做。
- en: In the beginning, it’s simple to automate the little stuff one bit at a time.
    Yet, as the project develops, it becomes daunting and implausible to do so. Your
    coworkers might be against doing so at this point, and yet setting up a working
    environment might take you as long as a week. I had this happen to me on a ridiculously
    huge project I worked on in the past, and management was okay with that. Setting
    up a local development environment involved
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，一次自动化一小部分简单的事情是很简单的。然而，随着项目的开发，这样做变得越来越令人畏惧和不可能。你的同事可能在这个时候反对这样做，而设置一个工作环境可能需要你一周的时间。我过去在一个极其庞大的项目上遇到过这种情况，管理层对此表示可以接受。设置本地开发环境涉及
- en: Reading through a daunting series of poorly written wiki articles
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读一系列令人畏惧的、写得不好的维基文章
- en: Installing dependencies by hand
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动安装依赖项
- en: Applying schema updates by hand
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动应用模式更新
- en: Applying those updates every morning by hand after getting the latest code
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取最新代码后，每天早上手动应用这些更新
- en: Installing audio codecs and even proprietary software, such as a specific version
    of Windows Media Player
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装音频编解码器，甚至专有软件，例如特定版本的 Windows Media Player
- en: After a week all I had to show for it was a “kind-of-working” environment. Three
    weeks after that I landed another job, because I couldn’t bear the manual, laborious
    work in that project. The driving issue behind this problem is that changing the
    way an application is built is hard, and not having a straightforward and automated
    process to set up new environments can become extremely costly down the line,
    and so cumbersome to change, in fact, that you wouldn’t want to bother doing it.
    The frustration I felt during that experience is one of the root motivators that
    drove me to Build First, the build-oriented approach I’m pile-driving in this
    book.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 一周后，我所展示的只是一个“有点工作”的环境。在那之后的三个星期，我找到了另一份工作，因为我无法忍受那个项目中手动、繁重的工作。这个问题的驱动因素是改变应用程序构建方式很难，没有直接和自动化的流程来设置新环境可能会在以后变得极其昂贵，实际上变得如此繁琐，以至于你都不想麻烦去改变它。我在那次经历中感到的挫败感是推动我提出“先构建”这一构建导向方法的主要动机之一，这也是我在这本书中大力倡导的方法。
- en: 'In [chapter 2](kindle_split_013.html#ch02) we covered how to automate our build
    process, and you even learned how you could automatically create, provision, and
    update a MySQL database instance (found at ch02/10_mysql-tasks in the samples).^([[3](#ch03fn03)])
    Setting up database seeding is complex, as you saw in the sample code, but it
    can also be rewarding: not having to provide new collaborators with anything other
    than the code repository, and a few instructions asking them to execute a Grunt
    task.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_013.html#ch02)中，我们介绍了如何自动化我们的构建过程，你甚至学会了如何自动创建、配置和更新一个MySQL数据库实例（在示例中的ch02/10_mysql-tasks目录下）。正如你在示例代码中所看到的，设置数据库初始化是复杂的，但它也可以很有成就感：你不需要为新合作伙伴提供除了代码仓库和几条指令让他们执行Grunt任务之外的其他任何东西。
- en: ³ The database provisioning task examples can be found at [http://bevacqua.io/bf/db-tasks](http://bevacqua.io/bf/db-tasks).
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 数据库配置任务示例可以在[http://bevacqua.io/bf/db-tasks](http://bevacqua.io/bf/db-tasks)找到。
- en: We’ve discussed at great length the measures you can take when it comes to configuration,
    and in that regard all you need to do when setting up a new development environment
    is get the decryption key (stored somewhere safe) and run a Grunt task. First-time
    setup shouldn’t involve more manual labor than getting your environment configuration
    in place; it should be that easy.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了在配置方面可以采取的措施，在这方面，当你设置新的开发环境时，你所需要做的就是获取解密密钥（存储在某个安全的地方）并运行一个Grunt任务。首次设置不应该比设置你的环境配置需要更多的手动劳动；它应该那么简单。
- en: Okay, you’ve taken care of all the environments, distributions, configuring,
    and automating, including the tedious first-time set up. It’s time for the fun
    I promised at the beginning of the chapter! Continuous development is up next!
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经处理好了所有环境、发行版、配置和自动化，包括繁琐的首次设置。现在是时候享受本章开头承诺的乐趣了！接下来是持续开发！
- en: 3.4\. Working in continuous development
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 工作在持续开发中
- en: Continuous development is the ability to work uninterruptedly in your code base,
    and by interruptions I don’t mean pesky project managers asking what you’re up
    to or coworkers asking for help with a bug they can’t seem to track down. When
    I say interruptions, I mean the repetitive stuff that slowly pecks away at your
    work day, such as re-executing `node` every time your application changes. Even
    now, with your fancy new build process in place, do you have to run it yourself
    every time files change? No way! You don’t have time for all that. You’ll use
    yet another task to do that.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 持续开发是指能够在代码库中不间断地工作，当我提到中断时，我并不是指那些烦人的项目经理询问你在忙什么，或者同事请求帮助解决他们似乎找不到的bug。当我提到中断时，我指的是那些慢慢侵蚀你工作日的工作，比如每次你的应用程序发生变化时都要重新执行`node`。即使现在，有了你新搭建的构建过程，你每次文件更改时都必须亲自运行它吗？不可能！你没有那么多时间。你将使用另一个任务来完成这个工作。
- en: 'Then there’s the smaller stuff, like saving your changes and refreshing your
    browser. You’ll get rid of that too, by letting the tools do that. Repetitive
    routines don’t carry much prestige in Build First systems. Let’s see how much
    you can automate away from your workflow. This isn’t to prove you can automate
    anything; the benefit instead lies in that you can spend more time doing what
    matters: thinking and tinkering with code.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有一些小事情，比如保存你的更改和刷新你的浏览器。你将通过让工具来做这些事情来摆脱这些烦恼。在“先构建”系统中，重复的例行公事并不怎么有威望。让我们看看你能从你的工作流程中自动化多少。这并不是为了证明你可以自动化任何事情；相反，好处在于你可以花更多的时间做有意义的事情：思考和摆弄代码。
- en: The first step you’re going to take in this direction is investing in a good
    watch (in the figurative sense—using a watch task in your favorite task runner),
    which will allow you to have the build process restart itself whenever you save
    changes to your files.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要采取的第一个步骤是投资一个好的手表（从字面上讲——在你的最喜欢的任务运行器中使用手表任务），这将允许你在保存文件更改时自动重启构建过程。
- en: 3.4.1\. Waste no time, use a watch!
  id: totrans-651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1. 不浪费时间，使用监视器！
- en: If you’re like me, you hit save or change tabs every few seconds. You can’t
    afford to run a full build every time you change a comment or a comma; that would
    be a tremendous waste of your time. Yet many people do this, because they haven’t
    found a better way to go about it yet. You’re reading this, so you’re one step
    ahead. Kudos.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你每隔几秒钟就会保存或切换标签。你不能每次更改注释或逗号时都运行完整的构建；那会浪费你大量的时间。然而，许多人这样做，因为他们还没有找到更好的方法。你正在阅读这本书，所以你领先了一步。恭喜你。
- en: 'One of Grunt’s most useful plugins is, undoubtedly, `grunt-contrib-watch`.
    This plugin will watch your file system for changes to your code and run the tasks
    affected by those code changes. Whenever a file change affects one of your build
    tasks, you should execute that task again. This is one of the pillars of continuous
    development, because you won’t have to do anything; the build process will run
    itself as needed. Let’s look at a quick example:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 最有用的插件之一无疑是 `grunt-contrib-watch`。这个插件会监控你的文件系统中的代码变化，并运行受这些代码变化影响的任务。每当文件变化影响你的构建任务之一时，你应该再次执行该任务。这是持续开发的一个支柱，因为你不需要做任何事情；构建过程会根据需要自动运行。让我们来看一个快速示例：
- en: '[PRE24]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this example, called 04_watch-task, and found under ch03 in the code samples,
    you can run the build process again entirely whenever any file changes or is created
    in your `public` folder. Now you won’t ever have to worry about constantly running
    the build; it can run itself!
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，称为 04_watch-task，并在代码示例中的 ch03 目录下找到，你可以在任何文件在 `public` 文件夹中更改或创建时重新运行整个构建过程。现在你再也不必担心不断运行构建；它可以自动运行！
- en: 'But even this approach isn’t the most efficient way to do it, because this
    will run all your build tasks, even the ones unaffected by the changed file. For
    example, it won’t matter if you edit a LESS file; any JavaScript-related tasks
    such as `jshint` will also run, because they’re part of the build, too. To correct
    that behavior, you should break down `watch` into many targets: one for each build
    task that can be affected by file changes. The following listing is a brief demonstration
    of what I’m talking about.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这种方法也不是最有效的方法，因为这将运行所有的构建任务，即使是没有受更改文件影响的任务。例如，如果你编辑了一个 LESS 文件，这并不重要；任何与
    JavaScript 相关的任务，如 `jshint`，也会运行，因为它们也是构建的一部分。为了纠正这种行为，你应该将 `watch` 分解成多个目标：每个可能受文件更改影响的构建任务一个。以下列表简要展示了我在说什么。
- en: Listing 3.2\. Breaking down `watch` into multiple targets
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 将 `watch` 分解成多个目标
- en: '[PRE25]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Breaking down your watch like this might seem tedious, but it will be well worth
    it. It will speed up your continuous development flow, because you’re getting
    into a mode where what you build is what changed, rather than blindly rebuilding
    everything, every time. You can find the fully working sample in the code listings,
    labeled as ch03/05_better-watch-closely.^([[4](#ch03fn04)])
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这样分解你的监控可能看起来有些繁琐，但这样做是非常值得的。它会加快你的持续开发流程，因为你会进入一种模式，即你构建的内容就是发生变化的内容，而不是盲目地重建一切。你可以在代码列表中找到一个完全工作的示例，标记为
    ch03/05_better-watch-closely.^([[4](#ch03fn04)])
- en: ⁴ You can find the code sample online at [http://bevacqua.io/bf/watch-out](http://bevacqua.io/bf/watch-out).
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 你可以在网上找到代码示例，地址为 [http://bevacqua.io/bf/watch-out](http://bevacqua.io/bf/watch-out)。
- en: Watching for such changes in your build is great, but what if you could expand
    on that, watching for changes to your Node application? Well, it turns out you
    can and should do that. Gather round, and let’s talk about `nodemon`.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 观察你构建中的此类变化是很好的，但如果你能进一步扩展，观察你的 Node 应用程序的变化呢？嗯，实际上你可以，也应该这样做。围坐在一起，让我们来谈谈 `nodemon`。
- en: 3.4.2\. Monitoring for changes to the Node app
  id: totrans-662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 监控 Node 应用的变化
- en: In the continuous development field, you try as hard as possible not to repeat
    anything incessantly, and to stay DRY instead of WET. You just saw how beneficial
    that could be—not having to run the build every time something changes. Now you’ll
    take the same shortcut for Node.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续开发领域，你应尽可能避免无休止地重复任何内容，而是保持 DRY（Don't Repeat Yourself）原则，而不是 WET（Write Everything
    Twice）。你刚刚看到了这样做的好处——不需要每次有变化时都运行构建。现在，你将为 Node 使用相同的快捷方式。
- en: 'Think of the `nodemon` command as using the `node` command, except it will
    monitor for changes and restart your application, running `node` again so you
    don’t have to. To install it, use `npm,` with the `-g` modifier, so that it’s
    installed globally, making it readily accessible from the command line:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 把 `nodemon` 命令想象成使用 `node` 命令，只不过它会监控变化并重新启动你的应用程序，再次运行 `node`，这样你就不必亲自做了。要安装它，使用
    `npm`，并带上 `-g` 修饰符，这样它就会全局安装，便于从命令行访问：
- en: '[PRE26]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now you can run `nodemon app.js`, instead of `node app.js`. By default, `nodemon`
    monitors `*.js` files, but you might want to restrict that even further. In these
    cases, you can provide it with a `.nodemonignore` file, which works much like
    `.gitignore,` and lets you ignore files you don’t want `nodemon` to monitor. Here’s
    an example
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行 `nodemon app.js`，而不是 `node app.js`。默认情况下，`nodemon` 监控 `*.js` 文件，但你可能希望进一步限制。在这种情况下，你可以提供一个
    `.nodemonignore` 文件，它的工作方式与 `.gitignore` 类似，并允许你忽略 `nodemon` 不需要监控的文件。以下是一个示例
- en: '[PRE27]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running `grunt watch` and using another terminal to run `nodemon app.js` is
    admittedly a tad faster than running both together through Grunt, due to the overhead
    Grunt adds. However, it’s convenient enough to run a single command, not having
    to spin up two terminal windows, that it might cancel out the extra overhead introduced.
    Generally speaking, there’s a tradeoff of speed (running them separately) versus
    convenience (running them both under Grunt). Personally, I prefer the convenience
    of not having to execute an additional command separately.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `grunt watch` 并在另一个终端中运行 `nodemon app.js` 虽然确实比通过 Grunt 同时运行它们要快一些，但这多出来的开销。然而，运行单个命令就足够方便，不需要打开两个终端窗口，这可能会抵消引入的额外开销。一般来说，速度（分别运行）和便利性（在
    Grunt 下运行它们）之间有一个权衡。我个人更喜欢便利性，不需要单独执行额外的命令。
- en: Next, we’ll examine how to integrate `nodemon` into Grunt.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何将 `nodemon` 集成到 Grunt 中。
- en: Combining watch and nodemon
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结合 watch 和 nodemon
- en: 'There’s a problem you need to resolve before you can integrate `nodemon` into
    Grunt, and that is that both `nodemon` and `watch` are *blocking tasks*: these
    tasks never end; they sit and watch for changes to your code. Grunt runs tasks
    sequentially, waiting for a task to end before you can run another one. But if
    neither of them end, the other one can’t start!'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将 `nodemon` 集成到 Grunt 之前，你需要解决一个问题，那就是 `nodemon` 和 `watch` 都是 *阻塞任务*：这些任务永远不会结束；它们会坐着等待你的代码发生变化。Grunt
    按顺序运行任务，在你可以运行另一个任务之前，会等待当前任务结束。但如果它们两个都不结束，另一个就无法开始！
- en: To get around this you could use `grunt-concurrent`, which will spawn a new
    process for each task you provide, and turn you into a happier nerd. Running `nodemon`
    through Grunt can be easily achieved using `grunt-nodemon`. The following listing
    is an example.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以使用 `grunt-concurrent`，它将为每个你提供的任务启动一个新的进程，让你成为一个更快乐的极客。通过 `grunt-nodemon`
    可以轻松地将 `nodemon` 通过 Grunt 运行。以下是一个示例。
- en: Listing 3.3\. Using `nodemon` from Grunt
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 使用 Grunt 的 `nodemon`
- en: '[PRE28]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example is also in the accompanying source code listings, named 06_nodemon
    (under [chapter 3](#ch03).) In this chapter, you’ve improved the sequence of events
    because your changes get saved, but you’re still doing the saving!
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也在配套的源代码列表中，命名为 06_nodemon（在 [第 3 章](#ch03) 下。）在这一章中，你改进了事件的顺序，因为你的更改被保存了，但你仍然在进行保存！
- en: Let’s have a quick word about saving changes.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈保存更改的问题。
- en: 3.4.3\. A text editor that cares
  id: totrans-677
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. 关心文本编辑器的编辑器
- en: Picking the right editor is key to your day-to-day work productivity, and productivity
    translates into happiness. Take your time to learn the ins and outs of your editor
    of choice. You might feel nerdy the first time you find yourself watching a YouTube
    video about a text editor’s shortcuts, but it will be time well spent. You spend
    most of the day using code editing tools, so you might as well learn how to exploit
    the features those editors provide.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的编辑器对你的日常工作效率至关重要，而效率可以转化为幸福感。花时间学习你选择的编辑器的细节。当你第一次发现自己正在观看一个关于文本编辑器快捷键的
    YouTube 视频时，你可能会觉得自己很古怪，但这将是值得的时间。你大部分时间都在使用代码编辑工具，所以你最好学会如何利用这些编辑器提供的功能。
- en: Luckily, most editors now provide a mechanism to get them to auto-save your
    changes. It feels kind of weird at first, but as you get used to it, you’ll fall
    in love and never look back. Personally, I like Sublime Text, the editor I typed
    these words with, and the one I use for most of my writing. If you’re on a Mac,
    TextMate seems like a viable option. Other options include WebStorm, which is
    an IDE specifically tailored for web development, and then there’s vim, for those
    who dare learn to use its complex, shortcut-intensive user interface.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在大多数编辑器都提供了一种机制来自动保存你的更改。一开始可能会觉得有点奇怪，但当你习惯了，你会爱上它，并且永远不会回头。我个人喜欢 Sublime
    Text，这是我打这些字的编辑器，也是我大部分写作时使用的编辑器。如果你使用的是 Mac，TextMate 似乎是一个可行的选择。其他选项包括 WebStorm，这是一个专门针对
    Web 开发的 IDE，然后是 vim，对于那些敢于学习使用其复杂、快捷键密集的用户界面的人来说。
- en: All the editors I mentioned are capable of auto-saving; if the editor you’re
    using isn’t, I strongly suggest you switch to one that is. You’ll be uncomfortable
    at first, but you’ll quickly start writing me thank-you notes after using your
    new text editor.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到的所有编辑器都支持自动保存；如果你使用的编辑器不支持，我强烈建议你切换到一个支持自动保存的编辑器。一开始你可能会感到不舒服，但使用你新的文本编辑器后，你很快就会开始给我写感谢信。
- en: Let’s wrap up with talk about the LiveReload technology for browser reloading,
    and how you can benefit from it.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以关于 LiveReload 技术的讨论来结束，以及你如何从中受益。
- en: 3.4.4\. Browser refresh is so Y2K
  id: totrans-682
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.4\. 浏览器刷新是如此Y2K
- en: LiveReload is a technology that understands you can’t waste precious time refreshing
    your browser whenever something changes. It exploits web sockets, a real-time
    communication technology that’s available in browsers (and which is awesome).
    Through its use of web sockets, LiveReload can decide whether it needs to apply
    small changes to your CSS, for example, or perform a full page reload when the
    HTML changes.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: LiveReload是一种理解你无法浪费宝贵时间在每次变化时刷新浏览器的技术。它利用了浏览器中可用的实时通信技术——WebSocket（它非常棒）。通过使用WebSocket，LiveReload可以决定是否需要对你的CSS应用小改动，或者当HTML发生变化时执行完整的页面刷新。
- en: Enabling it is fairly easy, enough so that we don’t have any excuse not to do
    it at this point. It comes bundled with `grunt-contrib-watch`, so setting it up
    is as easy as adding a `watch` target, as shown in the following listing.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 启用它相当简单，简单到我们没有任何借口不在这个时候去做它。它包含在`grunt-contrib-watch`中，因此设置起来就像添加一个`watch`目标一样简单，如下面的列表所示。
- en: Listing 3.4\. Enabling LiveReload
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 启用LiveReload
- en: '[PRE29]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, you’ll need to install the browser extension and enable it. Now you won’t
    ever again need to refresh your browser by yourself while debugging your applications.
    There’s also a readily available example^([[5](#ch03fn05)]) for you to look at
    (labeled ch03/07_livereload in the code samples), filled with all the necessary
    setup instructions, but it’s straightforward to get up and running.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要安装浏览器扩展并启用它。现在，在调试应用程序时，你再也不需要自己刷新浏览器了。还有一个现成的例子^([[5](#ch03fn05)])供你参考（在代码示例中标记为ch03/07_livereload），其中包含了所有必要的设置说明，但启动起来非常简单。
- en: ⁵ See LiveReload in action using this code sample at [http://bevacqua.io/bf/livereload](http://bevacqua.io/bf/livereload).
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 使用以下代码示例查看LiveReload的实际操作：[http://bevacqua.io/bf/livereload](http://bevacqua.io/bf/livereload)。
- en: 3.5\. Summary
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 摘要
- en: 'You made it through the environments and development workflow crash course!
    Here’s a quick recap of the teachings in this chapter:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了环境和开发工作流程的快速入门课程！以下是本章教学内容的快速回顾：
- en: The debug and release distributions affect your build flow in different ways;
    debug aims for bug catching and continuous development, while release aims for
    monitoring and speed optimizations, as you’ll see in the next chapter.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和发布版本以不同的方式影响你的构建流程；调试旨在捕捉错误和持续开发，而发布旨在监控和速度优化，正如你将在下一章中看到的。
- en: Your application should be configured so that secrets don’t make their way to
    the source code, and also provide enough flexibility to configure it based on
    the environment you’re running.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序应该配置得让秘密不会进入源代码，同时也应该提供足够的灵活性，以便根据你运行的环境进行配置。
- en: We’ve covered continuous development and how you can benefit from using a `watch`
    task that rebuilds your application and `nodemon` to restart it after changes,
    as well as the importance of picking the right tool for text editing.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经介绍了持续开发和如何通过使用`watch`任务来重新构建你的应用程序以及`nodemon`在更改后重启它来获得好处，以及选择合适的文本编辑工具的重要性。
- en: In the following chapter we’ll cover in more detail the performance optimizations
    that you can consider for release builds, what continuous integration is and how
    to use it to your advantage, how you should monitor analytics in your application,
    and finally, how to deploy your application to hosted environments such as staging
    and production.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地介绍你可以考虑用于发布构建的性能优化，什么是持续集成以及如何利用它来获得优势，你应该如何监控应用程序中的分析，以及最后如何将你的应用程序部署到托管环境，如预发布和生产环境。
- en: Chapter 4\. Release, deployment, and monitoring
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 发布、部署和监控
- en: '*This chapter covers*'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding release flow and predeployment tasks
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解发布流程和预部署任务
- en: Deploying to Heroku
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到Heroku
- en: Using Travis for continuous integration
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Travis进行持续集成
- en: Understanding continuous deployments
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解持续部署
- en: We’ve covered the build process, common build tasks you can perform (and how
    to do that using Grunt), and, at a high level, environments and configuration.
    We discussed the development environment extensively, but that’s only half the
    story. The development environment is where you’ll spend most of your time working,
    because you’ll have a system in place, so you can prepare your application for
    a release, deploy it to a platform that humans can access, and then monitor the
    application state. Thanks to the Build First mentality, you’ll be automating the
    workflows I’ve just mentioned, avoiding repetition, human error, and running tests,
    all while saving time, as I promised in [chapter 1](kindle_split_012.html#ch01).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了构建过程，你可以执行的一些常见构建任务（以及如何使用Grunt来完成这些任务），以及从高层次上讲，环境和配置。我们详细讨论了开发环境，但这只是故事的一半。开发环境是你将花费大部分时间工作的地方，因为你将有一个系统在位，这样你就可以为发布准备你的应用程序，将其部署到人类可以访问的平台，然后监控应用程序状态。多亏了“先构建”的心态，你将自动化我刚才提到的流程，避免重复、人为错误，并在测试的同时节省时间，正如我在[第1章](kindle_split_012.html#ch01)中承诺的那样。
- en: A continuous integration (CI) platform will help deploy more robust builds to
    production by ensuring your tests pass in a hosted environment. As you’ll see
    later in the chapter, CI helps test your code base remotely every time you push
    to your version control system (VCS). Build automation (and continuous development)
    is crucial for keeping your day-to-day development efforts productive and efficient.
    Comparably, having a workflow that’s easy to execute ensures you can deploy your
    application as often as needed, without worrying about an embarrassing manual
    set of tasks that take half an hour to perform.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）平台将通过确保你的测试在托管环境中通过，来帮助部署更健壮的构建到生产环境中。正如你将在本章后面看到的那样，CI会在你每次向版本控制系统（VCS）推送时远程测试你的代码库。构建自动化（和持续开发）对于保持你日常开发工作的生产力和效率至关重要。同样，拥有一个易于执行的流程可以确保你可以根据需要频繁地部署你的应用程序，而不用担心执行半小时的令人尴尬的手动任务集。
- en: 'By the end of this chapter, you’ll be ready to perform safe, continuous deployments,
    which are similar to continuous development in spirit. They’re both intended to
    cut down the repetitive work and reduce human mistakes. The release flow has a
    few stages we’re going to follow in this book:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将准备好执行安全、连续的部署，这在精神上与持续开发相似。它们都旨在减少重复工作和减少人为错误。发布流程有几个阶段，我们将在本书中遵循：
- en: The first step is the build process, under the release distribution.
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是构建过程，在发布分发下进行。
- en: Once the build is compiled, you’ll run tests to make sure recent changes didn’t
    break the build. Minor syntax issues should be constantly resolved during development
    by using lint programs.
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦构建完成，你将运行测试以确保最近的变化没有破坏构建。在开发过程中，应通过使用代码检查程序来持续解决小的语法问题。
- en: If the tests succeed, you might get into predeployment operations such as updating
    the version number and the release changelog.
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试成功，你可能会进入预部署操作，例如更新版本号和发布变更日志。
- en: After that, you’ll investigate deployment options, such as cloud hosting options
    and CI platforms.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，你将调查部署选项，例如云托管选项和持续集成平台。
- en: '[Figure 4.1](#ch04fig01) describes this proposed release and deployment flow.
    As you look at the figure, keep a mental note of my proposal to deploy to staging
    first, to make sure everything works as expected in a hosted environment, before
    going live to production.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.1](#ch04fig01)描述了这个提出的发布和部署流程。当你查看这张图时，请记住我提出的先部署到预发布环境，以确保在上线到生产环境之前，托管环境中的所有事情都按预期工作。'
- en: Figure 4.1\. Proposed release and deployment flow
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1. 提出的发布和部署流程
- en: '![](04fig01_alt.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![04fig01_alt.jpg](04fig01_alt.jpg)'
- en: You have a long road ahead; let’s commence by discussing the release and deployment
    flow. You’ll visit predeployment operations in detail in [section 4.2](#ch04lev1sec2).
    Then in [section 4.3](#ch04lev1sec3), I’ll tell you all about deployments, and
    you’ll learn how to deploy an application to Heroku. [Section 4.4](#ch04lev1sec4)
    covers continuous integration and the tools you can use to get CI to do the heavy
    lifting on your behalf.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 你面前还有很长的路要走；让我们先从讨论发布和部署流程开始。你将在[4.2节](#ch04lev1sec2)中详细了解预部署操作。然后在[4.3节](#ch04lev1sec3)中，我将告诉你所有关于部署的事情，你将学习如何将应用程序部署到Heroku。[4.4节](#ch04lev1sec4)涵盖了持续集成以及你可以用来让CI为你做繁重工作的工具。
- en: 4.1\. Releasing your application
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 发布你的应用程序
- en: When preparing your application for release, you’ll want to place the web’s
    best practices on your plate. In [chapter 2](kindle_split_013.html#ch02), we discussed
    *minification*, shrinking your assets for better performance, and *concatenation*,
    joining files together to reduce the number of HTTP requests, which you’ll definitely
    want to include in your release builds. These improve the web application’s user
    experience by bundling your developer-readable source code into single files containing
    everything in the source code, but in a compressed form to hasten downloads. In
    that chapter we also covered *sprite maps and sprites*, large files containing
    many images. These would be used for debug distributions, too, for the sole reason
    that they enable you to keep debug and release more tightly bound together and
    less dissimilar. Otherwise you’d need to reference the individual icons in your
    debug CSS, and then somehow reference the spritemap and each icon’s position in
    release, defeating the purpose of uniting both build flows and repeating yourself,
    breaking the DRY principle.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备发布你的应用程序时，你希望将网络的最佳实践放在你的餐盘上。在[第2章](kindle_split_013.html#ch02)中，我们讨论了*压缩*，为了更好的性能缩小你的资源，以及*连接*，将文件合并在一起以减少HTTP请求的数量，这些你肯定希望包含在你的发布构建中。这些通过将可读的开发者源代码捆绑成包含源代码中所有内容的单个文件来提高Web应用程序的用户体验，但这些文件是压缩的，以便加快下载速度。在那一章中，我们还介绍了*精灵图和精灵*，包含许多图像的大文件。这些也会用于调试分发，仅仅是因为它们允许你将调试和发布更紧密地结合在一起，而不是那么不同。否则，你需要在调试CSS中引用单个图标，然后在发布中
    somehow 引用精灵图和每个图标的定位，这违背了将两个构建流程统一并重复自己的目的，打破了DRY原则。
- en: Minification, concatenation, spriting—what else is there to a release flow?
    In this section we’ll go over image optimization and asset caching; then we’ll
    move on to the deployment flow, semantic versioning, and keeping changelogs up-to-date
    effortlessly.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩、连接、精灵化——发布流程中还有什么其他内容吗？在本节中，我们将介绍图像优化和资源缓存；然后我们将继续讨论部署流程、语义版本控制和轻松更新变更日志。
- en: 4.1.1\. Image optimization
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1. 图像优化
- en: Concatenated and minified JavaScript and CSS files don’t tell the whole story.
    Images represent, more often than not, the bulk of a web page’s download footprint,
    meaning they are even more important to optimize than any other static assets.
    You already did a good chunk of optimization in [chapter 2](kindle_split_013.html#ch02),
    when you examined how to generate a spritesheet using different images, which
    is comparable to how concatenation works for text files, merging many files into
    a single one. The other optimization, minification, reduces the contents of script
    and stylesheet files by shortening variable names and other micro-optimizations
    that minifiers perform. In the world of images, you have various ways to compress
    files, resulting in gains somewhere between 9% and 80%, typically above 50%. Luckily
    for us, certain Grunt packages, much like we’re becoming accustomed to, do the
    heavy lifting for us in this regard.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 连接和压缩的 JavaScript 和 CSS 文件并不能完全说明问题。通常情况下，图片代表了网页下载量的大部分，这意味着它们比其他任何静态资源都更需要优化。在[第2章](kindle_split_013.html#ch02)中，你已经做了一部分优化工作，当时你学习了如何使用不同的图片生成精灵图，这与文本文件中连接的工作方式类似，即将多个文件合并成一个。另一种优化方法是压缩，通过缩短变量名和其他微优化来减少脚本和样式表文件的内容。在图片的世界里，你有各种方法来压缩文件，这通常可以带来9%到80%的增益，通常超过50%。幸运的是，对于某些Grunt包，就像我们逐渐习惯的那样，它们在这方面为我们做了大量的工作。
- en: 'One such package is `grunt-contrib-imagemin,` which does exactly what you want:
    image compression for different formats such as PNG, GIF, and JPG. Before plunging
    into it, I’ll briefly cover the two aspects of image optimization it can help
    you with: lossless compression and interlacing.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个包是 `grunt-contrib-imagemin,` 它正好做了你想要的事情：对不同格式的图片如PNG、GIF和JPG进行图像压缩。在深入探讨之前，我将简要介绍它可以帮助你优化的两个方面：无损压缩和交错。
- en: Lossless Image Compression
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无损图像压缩
- en: '*Lossless image compression* is, much like JavaScript minification, tasked
    with the removal of unimportant bits of data from your image’s raw binary data.
    The important thing to notice is that lossless compression doesn’t alter the image’s
    appearance, but solely its binary representation. The only result of lossless
    compression is a smaller image that looks identical to the larger image. Lucky
    for us, smarter people have spent time working on tools that do advanced image
    compression work for us. You can specify the path to your image and have their
    algorithms work at it. Furthermore, `grunt-contrib-imagemin` configures these
    low-level programs with the right parameters, so you don’t have to. Note that
    lossless compression produces modest byte savings compared to lossy compression;
    it’s great, however, when you can’t afford to lose any image quality. When you
    can afford to lose image quality (and most of the time the losses are almost unnoticeable),
    you should use lossy image compression.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**无损图像压缩**与JavaScript最小化类似，其任务是移除图像原始二进制数据中的不重要的数据位。重要的是要注意，无损压缩不会改变图像的外观，而仅仅是其二进制表示。无损压缩的唯一结果是图像尺寸更小，看起来与较大的图像完全相同。幸运的是，有更聪明的人已经花费时间开发出为我们执行高级图像压缩的工具。你可以指定图像的路径，并让它们的算法进行处理。此外，`grunt-contrib-imagemin`配置了这些低级程序的正确参数，因此你不需要这样做。请注意，与有损压缩相比，无损压缩产生的字节节省较少；然而，当你不能承受任何图像质量损失时，它是非常好的。当你能够承受图像质量损失（而且大多数时候损失几乎不明显）时，你应该使用有损图像压缩。'
- en: Lossy Image Compression
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有损图像压缩
- en: Lossy compression is an image compression technique where inexact approximation
    is applied (also known as partial data discarding) when re-encoding the image,
    resulting in far greater byte savings than those gained through lossless compression
    (up to 90% savings), where the removed information is usually only metadata such
    as geolocation, camera type, and so on. The `grunt-contrib-imagemin` package uses
    lossy compression by default, in addition to lossless compression, to remove unnecessary
    metadata. If you only want to use lossless compression, you should consider using
    the `imagemin` package directly.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '有损压缩是一种图像压缩技术，在重新编码图像时应用不精确的近似（也称为部分数据丢弃），这比无损压缩获得的字节节省更多（高达90%的节省），其中移除的信息通常是元数据，如地理位置、相机类型等。`grunt-contrib-imagemin`包默认使用有损压缩，除了无损压缩外，还用于移除不必要的元数据。如果你只想使用无损压缩，你应该考虑直接使用`imagemin`包。 '
- en: Interlacing Images
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 交错图像
- en: The other image optimizing task you’re going to study is *interlacing*.^([[1](#ch04fn01)])
    Interlaced images have a larger size than regular images, but these added bytes
    are usually well worth it, because they improve perceived performance. Even though
    the image might take a little longer to complete downloading, it will start rendering
    faster than normal images do. Progressive images work exactly as they sound. They
    render a minimum view of the pixels in the image, which roughly looks like your
    complete image, and then they’re progressively enhanced (as more data gets streamed
    to the browser), until the full-quality image is available.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要研究的另一个图像优化任务是**交错**。^([[1](#ch04fn01)]) 交错图像的大小比普通图像大，但这些增加的字节通常是非常值得的，因为它们可以提升感知性能。即使图像可能需要更长的时间来完成下载，但它将比普通图像更快地开始渲染。渐进式图像的工作方式正如其名。它们首先渲染图像中像素的最小视图，这大致看起来像是你的完整图像，然后随着更多数据被传输到浏览器，它们会逐步增强（直到全质量图像可用）。
- en: ¹ Learn more about how interlacing improves perceived performance by visiting
    [http://bevacqua.io/bf/interlacing](http://bevacqua.io/bf/interlacing). There’s
    also an animated GIF that better explains how an interlaced image works.
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 通过访问[http://bevacqua.io/bf/interlacing](http://bevacqua.io/bf/interlacing)了解更多关于交错如何提升感知性能的信息。还有一个动画GIF更好地解释了交错图像的工作原理。
- en: Traditionally, images load top-down, in full quality, which translates into
    a faster download time but slower perceived rendering. The time to view the entire
    image equals the completion time. In progressive rendering mode, humans perceive
    a faster experience because they don’t have to wait as long to see a (garbled)
    view of the entire image.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，图像是从上到下、以全质量加载的，这转化为更快的下载时间但较慢的感知渲染。查看整个图像所需的时间等于完成时间。在渐进式渲染模式下，人类感知到的体验更快，因为他们不需要等待那么长时间才能看到整个图像的（混乱的）视图。
- en: Setting up grunt-contrib-imagemin
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置grunt-contrib-imagemin
- en: Setting up `grunt-contrib-imagemin` is, happily, as easy as the rest of the
    tasks we’ve gone over. Keep in mind that the important bits are in learning what
    the tasks do and how and when to apply them. The following listing configuration
    optimizes `*.jpg` images during release builds.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `grunt-contrib-imagemin`，幸运的是，就像我们之前讨论的其他任务一样简单。记住，重要的是要了解任务做什么，以及何时以及如何应用它们。以下列表配置在发布构建过程中优化
    `*.jpg` 图片。
- en: Listing 4.1\. Optimizing images during release builds
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 发布构建过程中的图像优化
- en: '[PRE30]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Listing 4.1](#ch04ex01) doesn’t need any extra configuration to compress the
    images; that’s done by default. A fully working example can be found in the accompanying
    source for this chapter, labeled ch04/01_image-optimization, with a complete build
    workflow for both the `debug` and `release` distributions. Now that you’ve made
    the web a slightly better place for humans to drift around aimlessly, you can
    turn your attention to static asset caching.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.1](#ch04ex01) 不需要任何额外的配置来压缩图片；这是默认完成的。一个完整的工作示例可以在本章的配套源代码中找到，标记为 ch04/01_image-optimization，包括
    `debug` 和 `release` 分发版本的完整构建工作流程。现在你已经让网络对人类漫无目的地漫游变得稍微好一些，你可以将注意力转向静态资源缓存。'
- en: 4.1.2\. Static asset caching
  id: totrans-731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 静态资源缓存
- en: In case you’re unfamiliar with the term, think of *caching* as photocopying
    history books from the library. Rather than going to the library every time you
    want to read them, you might prefer to print copies of a few pages, take those
    home, and read them whenever you please without having to hit the library again.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个术语不熟悉，可以把 *缓存* 想象成从图书馆复印历史书籍。与其每次想阅读它们时都去图书馆，你可能会更喜欢打印几页，带回家，然后随时阅读，而无需再次访问图书馆。
- en: Caching in the web is more complicated than photocopying books borrowed from
    a library, but that should give you the gist of it.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的缓存比从图书馆借阅的书籍的复印要复杂，但这应该能让你抓住其精髓。
- en: Expires headers
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Expires` 头部信息'
- en: 'A best practice you should definitely follow is using `Expires` headers for
    your static assets. This header, according to the HTTP protocol, tells the browser
    not to request the resource again if it was requested at least once (and therefore
    cached), and the cached version hasn’t become stale. The expiration date in the
    `Expires` header determines when the cached version is no longer considered valid,
    and the asset has to be redownloaded. An example `Expires` header might be `Expires:
    Tue, 25 Dec 2012 16:00:00 GMT.`'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该绝对遵循的最佳实践之一是使用 `Expires` 头部信息来处理你的静态资源。根据 HTTP 协议，这个头部信息告诉浏览器，如果资源至少请求过一次（并且因此被缓存），并且缓存的版本尚未过时，则不要再次请求该资源。`Expires`
    头部信息中的过期日期决定了缓存的版本何时不再被认为是有效的，并且资产需要重新下载。一个示例 `Expires` 头部信息可能是 `Expires: Tue,
    25 Dec 2012 16:00:00 GMT.`'
- en: This is both an awesome and a terrible practice. It’s awesome for humans, because
    after their first visit to one of your pages, they don’t need to redownload resources
    their browser stored in its cache, saving them requests and time. It’s terrible
    for us, the developers, because it won’t matter if you deploy changes to your
    assets, humans won’t download them anymore.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这既是一个令人惊叹的实践，也是一个糟糕的实践。对于人类来说，这是一个令人惊叹的实践，因为他们在访问你的页面之一后，不需要重新下载浏览器缓存中存储的资源，从而节省了请求和时间。对于我们这些开发者来说，这是一个糟糕的实践，因为即使你部署了资产的变化，人类也不会再下载它们。
- en: To solve that inconvenience, and make `Expires` headers useful, you can rename
    your assets every time you deploy changes to them, appending a hash to their names,
    which forces browsers to download the file again, because for all intents and
    purposes, it’s a different file from what they used to have in their cache.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种不便，并使 `Expires` 头部信息变得有用，你可以在部署对资产进行更改时，将哈希值附加到它们的名称上，这会迫使浏览器重新下载文件，因为从所有目的来看，这是一个与它们之前缓存中的文件不同的文件。
- en: '|  |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Hashing
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 哈希
- en: A *hash* is a function that returns a fixed-length value that’s an encoded representation
    of data. In your situation, the hash could be computed from the asset contents
    and its last modified date. One such hash might be `a38cbf9e.` Although seemingly
    arbitrary, there’s no randomness involved. That would defeat the purpose of using
    an `Expires` header, because files would always have different names and be requested
    again every time.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *哈希* 是一个函数，它返回一个固定长度的值，这是数据的编码表示。在你的情况下，哈希可以从资产内容和它的最后修改日期计算得出。这样一个哈希可能是
    `a38cbf9e.` 虽然看起来是随机的，但实际上没有随机性。这会违背使用 `Expires` 头部信息的目的，因为文件总是有不同的名称，并且每次都会再次请求。
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Once you’ve computed a hash, you can use it as a query string parameter in your
    page, `/all.js?_=a38cbf9e`, or you can append it to the filename, such as `/a38cbf9e
    .all.js.` Alternatively, you can add the hash to an `ETag` header. Choosing the
    right approach is a matter of identifying your needs. If you’re dealing with static
    assets such as `JavaScript` resources, then you’re probably better off hashing
    the filename (or its query string) and using an `Expires` header. If you’re dealing
    with dynamic content, setting the hash in an `ETag` is preferred.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出一个哈希值，您可以使用它作为页面中的查询字符串参数，例如 `/all.js?_=a38cbf9e`，或者将其附加到文件名上，例如 `/a38cbf9e.all.js`。另外，您还可以将哈希值添加到
    `ETag` 头部。选择正确的方法取决于您的需求。如果您处理的是静态资源，如 `JavaScript` 资源，那么您可能更倾向于对文件名（或其查询字符串）进行哈希处理，并使用
    `Expires` 头部。如果您处理的是动态内容，则建议在 `ETag` 中设置哈希值。
- en: Using Last-Modified or an ETag header
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Last-Modified 或 ETag 头部
- en: 'An `ETag` header uniquely identifies one version of a resource. Similarly,
    `Last-Modified` identifies the last modification date of the resource. If you
    use either of these headers, then you should use the `max-age` modifier in the
    `cache-control` header, instead of the `Expires` header. This combination allows
    for softer caching, as the user agent can determine whether the cached copy should
    be used, or if the resource should be requested again. The following example shows
    how to combine the `ETag` and the `cache-control` headers:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '`ETag` 头部唯一标识资源的一个版本。同样，`Last-Modified` 标识资源的最后修改日期。如果您使用这两个头部中的任何一个，那么您应该在
    `cache-control` 头部中使用 `max-age` 修饰符，而不是 `Expires` 头部。这种组合可以实现更软的缓存，因为用户代理可以确定是否应该使用缓存的副本，或者是否需要再次请求资源。以下示例展示了如何结合
    `ETag` 和 `cache-control` 头部：'
- en: '[PRE31]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Last-Modified header behaves as an alternative to the `ETag` header, for
    convenience. Here we don’t specify a uniquely identifying `ETag`, but achieve
    the same uniqueness by setting a modification date:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '`Last-Modified` 头部作为 `ETag` 头部的替代，出于方便考虑。在这里，我们没有指定一个唯一标识的 `ETag`，而是通过设置修改日期来实现相同的唯一性：'
- en: '[PRE32]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s find out how you can use Grunt to create hashes for your file names that
    can then be used to set far-futures `Expires` headers safely.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看您如何使用 Grunt 为您的文件名创建哈希值，然后可以安全地使用这些哈希值设置远期 `Expires` 头部。
- en: Cache busting with Grunt
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Grunt 进行缓存破坏
- en: Within your build process, you can do little to set HTTP headers, as those must
    go out with each response, rather than be statically determined. But what you
    can do is assign hashes to your assets using `grunt-rev.` This package will compute
    the hash for each of your assets and then rename them, appending the corresponding
    hash to their original names. For example, `public/js/all.js` would be changed
    to something such as `public/js/1be2cd73.all.js,` where `1be2cd73` would be the
    computed hash for the contents of `all.js.` One issue emerges from this task,
    and it’s that now your views won’t reference the correct assets, because they’ve
    been renamed with a hash in front of them. To remedy that, you can use the `grunt-usemin`
    package, which looks for static asset references in your HTML and CSS and refreshes
    them with the updated filenames. That’s exactly what you need. The relevant Grunt
    configuration then looks like the following listing (labeled ch04/02_asset-hashing
    in the samples).
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的构建过程中，您几乎无法设置 HTTP 头部，因为这些必须在每个响应中发送出去，而不是静态确定。但您可以做的就是在 `grunt-rev` 的帮助下为您的资产分配哈希值。这个包将为您的每个资产计算哈希值，然后重命名它们，将相应的哈希值附加到原始名称上。例如，`public/js/all.js`
    将被更改为类似 `public/js/1be2cd73.all.js` 的内容，其中 `1be2cd73` 将是 `all.js` 内容计算出的哈希值。从这个任务中产生的一个问题是，现在您的视图不会引用正确的资产，因为它们已经被带有哈希值的前缀重命名了。为了解决这个问题，您可以使用
    `grunt-usemin` 包，该包会在您的 HTML 和 CSS 中查找静态资产引用，并使用更新的文件名刷新它们。这正是您所需要的。相关的 Grunt
    配置如下所示（在示例中标记为 ch04/02_asset-hashing）。
- en: Listing 4.2\. Updating filenames
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 更新文件名
- en: '[PRE33]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Keep in mind you don’t have any use for either of these tasks in the `debug`
    flow, because these are optimizations that do nothing to benefit you during development,
    so it might be appropriate to name their targets `release` to make that distinction
    more explicit. The `usemin` task, however, is written in such a way that Grunt
    targets have a special meaning. The `css` and `html` targets are respectively
    used to configure which CSS and HTML files you want to update with the hashed
    filenames, but targets such as `release` would be ignored by `usemin`.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在`debug`流程中，你不需要这两项任务中的任何一项，因为这些优化在开发过程中对你没有任何好处，所以可能适当地将它们的目标命名为`release`，以使这种区别更加明确。然而，`usemin`任务是以一种方式编写的，Grunt目标具有特殊含义。`css`和`html`目标分别用于配置你想要使用哈希文件名更新的CSS和HTML文件，但像`release`这样的目标将被`usemin`忽略。
- en: The next technique we’ll cover involves inlining CSS in a style tag to avoid
    the render-blocking request for CSS, resulting in faster page loads.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的下一个技术涉及在样式标签中内联CSS，以避免对CSS的渲染阻塞请求，从而实现更快的页面加载。
- en: 4.1.3\. Inlining critical above-the-fold CSS
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3. 内联关键“折叠以上”CSS
- en: Browsers block rendering whenever they encounter a CSS resource they need to
    download. Yet, we’ve taught each other for years to place CSS at the top of our
    pages (in the `<head>`), so users won’t see a flash of unstyled content (abbreviated
    as FOUC). The inlining technique aims to improve page load time speed without
    damaging user experience by avoiding FOUC. This technique only works effectively
    if you’re rendering your views on the server side as well as the client side,
    as we explore in [chapter 7](kindle_split_019.html#ch07).
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器在遇到需要下载的CSS资源时会阻止渲染。然而，多年来我们一直教导对方将CSS放在页面顶部（在`<head>`中），这样用户就不会看到未样式化的内容的闪光（简称FOUC）。内联技术旨在通过避免FOUC来提高页面加载速度，而不会损害用户体验。只有在你同时在服务器端和客户端渲染视图的情况下，这种技术才能有效，正如我们在[第7章](kindle_split_019.html#ch07)中探讨的那样。
- en: 'To implement this feature, you have to do a number of different things:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，你必须做几件不同的事情：
- en: First, you need to identify the “above-the-fold” CSS; these are the styles that
    are required to correctly render the visible elements on the page, on first load.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要确定“折叠以上”的CSS；这些是在首次加载时正确渲染页面可见元素所需的样式。
- en: Once we’ve identified the styles that are effectively used above the fold (those
    that the browser needs to render the page properly and avoid the FOUC), you need
    to inline them in a `<style>` tag on the `<head>` of your pages.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们确定了在“折叠以上”有效使用的样式（那些浏览器需要正确渲染页面并避免FOUC的样式），你需要在页面的`<head>`中用`<style>`标签内联它们。
- en: Last, now that the required styles are inlined in a `<style>` tag, you can eliminate
    the render-blocking request for the CSS style sheet by deferring the request until
    after the `onload` event has triggered, using JavaScript.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，现在所需的样式已经内联在`<style>`标签中，你可以通过在`onload`事件触发后延迟请求来消除对CSS样式表的渲染阻塞请求，使用JavaScript。
- en: Naturally, you wouldn’t want to leave users with JavaScript turned off stranded,
    and because we’re good citizens of the web, you’ll also use a fallback `<noscript>`
    tag to make the render-blocking request anyway.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然地，你不会想让用户在JavaScript关闭的情况下陷入困境，并且因为我们作为网络的好公民，你也会使用一个后备的`<noscript>`标签来确保渲染阻塞请求无论如何都会执行。
- en: 'As you’ve probably noticed, this is a complicated and error-prone process,
    much like the case study in [chapter 1](kindle_split_012.html#ch01), where Knight’s
    Capital lost half a billion dollars due to human error. It’s probably not going
    to be that catastrophic for you if something goes wrong, but automating this process
    is almost mandatory: there’s too much work involved to be done every time your
    styles change, or whenever your markup changes!'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，这是一个复杂且容易出错的流程，就像[第1章](kindle_split_012.html#ch01)中的案例研究一样，Knight Capital由于人为错误损失了五亿美元。如果出了问题，对你来说可能不会那么灾难性，但自动化这个流程几乎是强制性的：每次你的样式或标记发生变化时，都需要做太多工作！
- en: Let’s learn how we can use Grunt to automate this process, using `grunt-critical`.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用`grunt-critical`自动化这个过程。
- en: Having Grunt do the heavy lifting
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 让Grunt做重活
- en: 'Using `grunt-critical` for this purpose is incredibly easy, although it does
    provide a wealth of configuration options. In the following code, you’ll find
    the configuration for a simple use case. In this case, you’re extracting critical
    CSS from a page and inlining those styles after the build, inside a `<style>`
    tag. `critical` goes the extra mile of deferring the rest of the styles so as
    not to block rendering, and it also adds the `<noscript>` fallback tag for those
    that have JavaScript disabled:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grunt-critical`来完成这个任务非常简单，尽管它确实提供了大量的配置选项。在下面的代码中，你会找到简单用例的配置。在这种情况下，你正在从页面中提取关键CSS并在构建后内联这些样式，在`<style>`标签内。`critical`会进一步延迟其他样式的加载，以避免阻塞渲染，并且它还添加了`<noscript>`回退标签，以供禁用JavaScript的用户使用：
- en: '[PRE34]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You probably are already familiar with all of the provided options, which are
    file paths. The base option indicates the root directory that should be used when
    finding absolute resource paths such as `/page.css`. Once you set up Grunt to
    perform inlining on your behalf, remember to serve the upgraded HTML files, rather
    than the prebuilt ones.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经熟悉所有提供的选择项，它们都是文件路径。基本选项表示在查找绝对资源路径（如`/page.css`）时应使用的根目录。一旦你设置Grunt为你执行内联操作，请记住要提供升级后的HTML文件，而不是预构建的文件。
- en: Before switching gears and soaking in the thermal spring waters of automated
    deployments, you need to reflect upon the importance of testing a release build
    ahead of each deployment to mitigate the possibility of the spring being in an
    active volcanic area.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到自动化部署的热水温泉之前，你需要反思在每次部署之前测试发布构建的重要性，以降低温泉位于活跃火山区的可能性。
- en: 4.1.4\. Testing before a deployment
  id: totrans-769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 部署前的测试
- en: Before you get into the deployment stage, or even the predeployment stage as
    we’ll explore soon, you need to test your release build. Testing a release build
    becomes important when there’s a deployment in your future, because you want to
    make sure your application behaves as you expect, or at the least, behaves as
    the tests you’ve written expect it to behave.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入部署阶段，甚至是我们即将探讨的预部署阶段之前，你需要测试你的发布构建。当未来有部署计划时，测试发布构建变得很重要，因为你想要确保你的应用程序按预期运行，或者至少按你编写的测试预期运行。
- en: 'In the next part of the book, we’ll delve into the underworld of application
    testing and examine two types of testing (though many, many more exist) in detail.
    These are unit testing and integration testing:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将深入探讨应用程序测试的地下世界，并详细考察两种测试类型（尽管存在许多其他类型）：
- en: 'Unit testing: Here you test individual components of your application by isolating
    them, making sure the components work fine on their own.'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：在这里，你通过隔离应用程序的各个组件来测试它们，确保组件在单独运行时工作正常。
- en: 'Integration (or end-to-end) testing: This takes a series of unit-tested components
    and tests the interactions between them, making sure they communicate appropriately.'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成（或端到端）测试：这涉及一系列经过单元测试的组件，并测试它们之间的交互，确保它们能够适当通信。
- en: It’ll be a while before you embark on testing practices and examples. We’ll
    discuss testing practices and see examples in [chapter 8](kindle_split_020.html#ch08).
    Keep in mind that before deployments, you need to test your application, reducing
    the odds of shipping a faulty build to one of your hosted environments, particularly
    if said environment is production. Let’s discuss a few more tasks you can perform
    after a release is tested but before it’s deployed.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始测试实践和示例之前，还需要一段时间。我们将在第8章中讨论测试实践并展示示例。[第8章](kindle_split_020.html#ch08)。请记住，在部署之前，你需要测试你的应用程序，以降低将故障构建发送到托管环境之一的风险，尤其是如果该环境是生产环境。让我们讨论一些在测试后但部署前你可以执行的任务。
- en: 4.2\. Predeployment operations
  id: totrans-775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 预部署操作
- en: Once you’ve prepared a build for release and had it carefully tested, you’re
    ready to deploy. But I have a couple of important predeployment tasks I want to
    mention before taking a swim in the deployment hot springs.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为发布准备了一个构建并对其进行了仔细的测试，你就可以部署了。但在我们跳入部署温泉之前，我想先提几个重要的预部署任务。
- en: '[Figure 4.2](#ch04fig02) is an overview of the deployment flow, as well as
    the operations that come before a build can be considered deploy-ready. It also
    shows how you’re going to progressively roll out your update to different environments,
    ensuring maximum predictability.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.2](#ch04fig02)是部署流程的概述，以及构建前的操作，这些操作可以被认为是部署就绪的。它还展示了你将如何逐步将更新部署到不同的环境中，确保最大程度的可预测性。'
- en: Figure 4.2\. Versioning before a deployment and progressive deployment rollout.
    Testing by QA team in staging ensures robustness before deployment to production.
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 部署前的版本控制和渐进式部署滚动。在预发布阶段由QA团队进行测试，确保在生产部署前具有稳健性。
- en: '![](04fig02_alt.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig02_alt.jpg)'
- en: Predeployment operations
  id: totrans-780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署前操作
- en: '***Semantic versioning:*** This helps keep track of meaningful application
    versions. Semantic versions are formatted similarly to `MAJOR.MINOR.PATCH-BUILD`.
    This standard helps avoid confusion when managing dependencies. Keeping your application
    versioned is important if you want any control over what code is currently deployed
    on hosted environments, such as production. It enables you to roll back to an
    older version when things go awry. Considering this is fairly easy to set up,
    and taking into account how costly it is to be unprepared for deployments not
    panning out, versioning becomes a no-brainer.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***语义版本控制：*** 这有助于跟踪有意义的应用程序版本。语义版本格式类似于`MAJOR.MINOR.PATCH-BUILD`。这个标准有助于在管理依赖关系时避免混淆。如果你想对托管环境（如生产环境）上当前部署的代码有任何控制权，保持应用程序版本化是很重要的。它使你能够在事情出错时回滚到旧版本。考虑到这相当容易设置，并且考虑到没有准备好部署失败的成本很高，版本控制变得是理所当然的。'
- en: '***Change logging:*** A *changelog* is a list of changes that were made throughout
    the history of your project, divided by which version they were introduced in
    (partly why keeping versions is important) and further segmented as bug fixes,
    breaking changes, and new features. By convention, changelogs in `git` repositories
    are often placed at the project root, and named something along the lines of `CHANGELOG.txt`,
    or using whatever extension you prefer (such as `md` for Markdown,^([[2](#ch04fn02)])
    a text-to-HTML conversion tool).'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***变更日志：*** 变更日志是记录了项目历史中所有变更的列表，根据它们引入的版本进行划分（这也是为什么保持版本很重要的一部分）并进一步细分为错误修复、破坏性变更和新功能。按照惯例，`git`仓库中的变更日志通常放置在项目根目录，命名为`CHANGELOG.txt`或使用你偏好的任何扩展名（例如，Markdown的`md`，^([[2](#ch04fn02)))，这是一个文本到HTML的转换工具）。'
- en: ² The Markdown format is a plain-text representation of HTML that’s easy to
    read, write, and convert into HTML. Read the original article introducing Markdown
    in 2004 at [http://bevacqua.io/bf/markdown](http://bevacqua.io/bf/markdown).
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² Markdown格式是一种易于阅读、编写和转换为HTML的纯文本表示。阅读2004年介绍Markdown的原始文章，请访问[http://bevacqua.io/bf/markdown](http://bevacqua.io/bf/markdown)。
- en: We’ll delve into how you can better allocate your changelog upkeep time in a
    bit, but first let’s explore the details of semantic versioning.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后深入探讨如何更好地分配你的变更日志维护时间，但首先让我们来探讨语义版本控制的细节。
- en: 4.2.1\. Semantic versioning
  id: totrans-785
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 语义版本控制
- en: Because you’re using Node, you might be familiar with the term semantic versioning.
    `npm` uses semantic versioning^([[3](#ch04fn03)]) for all packages, because it’s
    a powerful specification to manage dependency resolution among different Node
    modules. Because every Node application you produce already has a `package.json`,
    and considering those contain a semantic version in them, you’ll use these to
    tag your releases before deployments.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用Node，你可能对语义版本控制这个术语很熟悉。`npm`为所有包使用语义版本控制^([[3](#ch04fn03)))，因为它是一种强大的规范，用于管理不同Node模块之间的依赖关系解析。因为每个你生产的Node应用程序都已经有一个`package.json`，考虑到它们包含语义版本，你将在部署前使用这些来标记你的发布。
- en: ³ You can read more about semantic versioning at [http://bevacqua.io/bf/semver](http://bevacqua.io/bf/semver).
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[http://bevacqua.io/bf/semver](http://bevacqua.io/bf/semver)了解更多关于语义版本控制的信息。
- en: When I talk about versioning, I mean updating the package version and then creating
    a tag (a moment in your version history you can refer to) in your VCS. You can
    set up any scheme you want when it comes to numbering your releases, but the important
    part is that you don’t overwrite a release; you shouldn’t make two releases using
    the same version number. To ensure this uniqueness, I’ve settled for increasing
    the build number after every build (regardless of distribution) automatically
    with Grunt, and I also increase the patch number when I perform a deploy. Major
    version changes are intentionally manual, as those are probably introducing breaking
    changes. The same applies for minor version changes, as new features are usually
    introduced in new minors.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈论版本控制时，我指的是更新包版本并在你的版本控制系统（VCS）中创建一个标签（你可以参考的版本历史中的时刻）。在为你的发布编号时，你可以设置任何你想要的方案，但重要的是你不应该覆盖一个发布；你不应该使用相同的版本号发布两个版本。为了确保这种唯一性，我决定使用
    Grunt 在每次构建后（无论分发情况如何）自动增加构建号，并在执行部署时增加补丁号。主要版本更改是故意手动进行的，因为这些可能引入破坏性更改。同样，对于次要版本更改也适用，因为新功能通常在新的次要版本中引入。
- en: 'With Grunt, you could perform these version increments (from now on referred
    to as bumps) using the `grunt-bump` package. It’s easy to configure, it does the
    version tagging for you, and it even commits the changes to the `package.json`
    file for you. Here’s an example:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Grunt，你可以使用 `grunt-bump` 包来执行这些版本增量（从现在起称为增量）。它很容易配置，它会为你进行版本标记，甚至还会自动将更改提交到
    `package.json` 文件。以下是一个示例：
- en: '[PRE35]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These are, in fact, the defaults provided by this task. They’re sensible enough
    that you don’t have to configure it at all. The task will bump the version found
    in `package .json`, commit exactly that file with a relevant message, and then
    create a tag in `git` to finally push those changes to the `origin` remote. If
    you turn off all three of those options, the task only updates your package version.
    Sample ch04/03_version-bump shows this behavior in action.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是此任务提供的默认值。它们足够合理，以至于你根本不需要进行配置。任务将增加 `package.json` 中找到的版本，精确提交该文件并附带相关消息，然后在
    `git` 中创建一个标签，最后将这些更改推送到 `origin` 远程。如果你关闭所有三个选项，任务只会更新你的包版本。示例 ch04/03_version-bump
    展示了这种行为在实际中的应用。
- en: Once versioning is sorted out, you’ll want to set up a changelog, enumerating
    what changed since the previous release. Let’s mull that over.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦版本控制问题得到解决，你将想要设置一个变更日志，列出自上次发布以来发生了什么变化。让我们来考虑一下这一点。
- en: 4.2.2\. Using changelogs
  id: totrans-793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 使用变更日志
- en: You’re probably used to reading changelogs from products that interest you when
    new releases come out (games, in particular, have a strong presence of changelogs
    in their culture), but have you ever maintained one yourself? It’s not as hard
    as you might think.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 当新版本发布时，你可能习惯于阅读你感兴趣的产品（尤其是游戏，在其文化中变更日志有很强的存在感）的变更日志，但你是否曾经自己维护过变更日志？这并不像你想象的那么困难。
- en: Setting up a changelog—as an internal document that helps track changes made
    over time—could be a positive addition to your project even if you’re not showing
    it to consumers.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个变更日志——作为一个帮助跟踪随时间变化所做的更改的内部文档——即使你不向消费者展示，也可能对你的项目是一个积极的补充。
- en: If you have any sort of transparency policy, or you don’t like keeping humans
    in the dark, then a changelog becomes almost mandatory to maintain. You shouldn’t
    update the changelog every time you build for release, because you might want
    to produce a release build for debugging purposes. You shouldn’t update them before
    testing, either. If testing fails, then the changelog would be out of sync with
    the last release-ready build. Then you’re left with the need to update the changelog
    after you produce a build that passes all of the tests. Then and only then can
    you update the changelog to reflect the changes made since the last deployment.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何透明度政策，或者你不喜欢让人类处于黑暗中，那么维护一个变更日志几乎成为强制性的。你不应该在构建发布版本时更新变更日志，因为你可能想要为调试目的生成一个发布构建。同样，你也不应该在测试之前更新它们。如果测试失败，那么变更日志就会与最后一个发布就绪的构建不同步。然后你将需要在你生成通过所有测试的构建后更新变更日志。然后，并且只有那时，你才能更新变更日志以反映自上次部署以来所做的更改。
- en: Putting changelogs together is often hard because you forget what changed since
    the previous release, and you don’t want to go through the `git` version history
    figuring out which changes deserve a spot in the changelog. Similarly, updating
    it by hand every time you make a change is tedious, and you might forget to do
    that if you’re in the zone. A better alternative might be to set up `grunt-conventional-changelog`
    and have it build a changelog for you. All you’d have to do then is commit messages
    that, by convention, start with `fix` for bug fixes, `feat` when new features
    are introduced, or `BREAKING` when you break backwards compatibility. Furthermore,
    this package will allow you to edit the changelog by hand once it’s done with
    its own parsing and updates.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 将变更日志合并在一起通常很困难，因为你可能会忘记自上次发布以来发生了什么变化，而且你不想通过查看`git`版本历史来找出哪些变化值得写入变更日志。同样，每次更改时手动更新它也很繁琐，如果你完全沉浸在某个状态中，可能会忘记这样做。一个更好的选择可能是设置`grunt-conventional-changelog`，并让它为你生成变更日志。那时你只需提交消息，按照惯例，这些消息以`fix`开头用于修复错误，以`feat`开头用于引入新功能，或者以`BREAKING`开头用于破坏向后兼容性。此外，这个包将允许你在它完成自己的解析和更新后手动编辑变更日志。
- en: 'As far as configuration goes, this task doesn’t need any. Here are a few sample
    commit messages:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 就配置而言，这个任务不需要任何设置。以下是一些示例提交消息：
- en: '[PRE36]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 4.2.3\. Bumping changelogs
  id: totrans-800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3. 更新变更日志
- en: The `bump-only` and `bump-commit` tasks allow you to bump the version without
    committing any changes, so that you can then update your changelog (as you’ll
    see in a minute). Last, you should `bump-commit` to check in both `package.json`
    and `CHANGELOG.txt` at once in the same commit. Once you configure the `bump`
    task to also commit the changelog, you can now use the following alias to update
    your build version and changelog in one fell swoop. You can find an example using
    `grunt-conventional-changelog` in the samples, listed as ch04/04_conventional-changelog.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`bump-only`和`bump-commit`任务允许你在不提交任何更改的情况下增加版本号，这样你就可以更新你的变更日志（如你将在下一分钟看到的）。最后，你应该使用`bump-commit`一次性将`package.json`和`CHANGELOG.txt`检查到同一个提交中。一旦你配置了`bump`任务以同时提交变更日志，你现在可以使用以下别名一次性更新你的构建版本和变更日志。你可以在示例中找到一个使用`grunt-conventional-changelog`的例子，列在ch04/04_conventional-changelog。'
- en: '[PRE37]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now you’re done building for release, your tests are passing, and you’ve updated
    your changelog. You’re ready to deploy to a hosted environment from which you
    can serve your application. In the past, it was fairly commonplace to deploy applications
    merely by means of uploading your built packages by hand to your production servers.
    You’ve come a long way from those good old days, and deployment tools, as well
    as application hosting platforms, have gotten better.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了发布构建，测试通过，并且你已经更新了变更日志。你现在准备好将应用程序部署到托管环境中，从那里你可以提供服务。在过去，通过手动上传构建包到生产服务器来部署应用程序相当普遍。你已经从那些美好的旧时光中走了很长的路，部署工具以及应用程序托管平台都变得更好了。
- en: Let’s next dive into Heroku, a Platform as a Service (PaaS) provider that enables
    you to deploy your application easily from the command line.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解Heroku，这是一个平台即服务（PaaS）提供商，它使你能够轻松地从命令行部署你的应用程序。
- en: 4.3\. Deploying to Heroku
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. 部署到Heroku
- en: Setting up a deployment flow can be as hard as preparing sushi or as easy as
    ordering take-out; it all depends on how much control you want over the deployment.
    At one end of the spectrum you have services such as Amazon’s Infrastructure as
    a Service (IaaS) platform, where you have full control over your hosted environment.
    You can pick your preferred operating system, choose how much processing power
    you’d like, configure it at will, install things on it, and then deal with the
    whole SysOps heavy lifting, such as securing the application against attacks,
    setting up proxies, picking a deployment strategy that guarantees uptime, and
    configuring most everything from the ground up.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 设置部署流程可能像准备寿司一样困难，也可能像订购外卖一样简单；这完全取决于你对部署的控制程度。在光谱的一端，你有像亚马逊的基础设施即服务（IaaS）平台这样的服务，在那里你对托管环境有完全的控制权。你可以选择你喜欢的操作系统，选择你想要的处理能力，随意配置它，在上面安装东西，然后处理整个SysOps的重活，比如保护应用程序免受攻击，设置代理，选择保证正常运行时间的部署策略，以及从头开始配置大多数一切。
- en: On the other end of the spectrum are services where you don’t have to do anything,
    such as those solutions often offered by domain name registrars such as GoDaddy.
    In these solutions you generally pick a theme, flesh out a few pages of static
    content, and you’re done; everything else is done for you.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，有一些服务您无需做任何事情，例如那些由域名注册商如 GoDaddy 提供的解决方案。在这些解决方案中，您通常选择一个主题，填充几页静态内容，然后就可以完成；其余的一切都由您来完成。
- en: For the purposes of this book, I looked into the possibility of explaining how
    to host an application on Amazon, but I concluded that it’d be going too far off-scope.
    That being said, I’ll be mentioning near the end of this section a way in which
    you can explore this alternative on your own.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我研究了如何解释如何在亚马逊上托管应用程序的可能性，但最终我得出结论，这将超出范围。话虽如此，我将在本节的末尾提到一种您可以自己探索这种替代方案的方法。
- en: I decided to go with Heroku (although there are similar alternatives, such as
    DigitalOcean), which isn’t as complicated as setting up an instance on Amazon
    Web Services (AWS), but is fairly nontrivial, as opposed to using a website generator.
    Heroku simplifies your life by easily enabling you to configure and deploy your
    application to a hosted environment on their platform, straight from the command
    line. As I mentioned previously, Heroku is a Platform as a Service (PaaS) provider
    where you can host your application regardless of language or lack of server administration
    knowledge. In this section we’ll go over the deployment of a simple application
    to Heroku, step by step.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定选择 Heroku（尽管还有类似的替代方案，如 DigitalOcean），它不像在亚马逊网络服务（AWS）上设置实例那样复杂，但与使用网站生成器相比，它相当复杂。Heroku
    通过轻松地让您从命令行配置和部署应用程序到其平台上的托管环境，简化了您的生活。正如我之前提到的，Heroku 是一个平台即服务（PaaS）提供商，无论您的语言或缺乏服务器管理知识，您都可以在其平台上托管您的应用程序。在本节中，我们将逐步介绍如何将一个简单应用程序部署到
    Heroku。
- en: At the time of this writing, Heroku offers a tier that allows you to host your
    applications with them for free. Let’s get started there. You can find these instructions^([[4](#ch04fn04)])
    in the accompanying source code as well.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Heroku 提供了一个允许您免费托管应用程序的层级。让我们从这里开始。您可以在配套源代码中找到这些说明^([[4](#ch04fn04)])。
- en: ⁴ Find the Heroku deployment example online at [http://bevacqua.io/bf/heroku](http://bevacqua.io/bf/heroku).
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 您可以在网上找到 Heroku 部署示例，链接为 [http://bevacqua.io/bf/heroku](http://bevacqua.io/bf/heroku)。
- en: '**1**.  Go to [https://id.heroku.com/signup/devcenter](https://id.heroku.com/signup/devcenter),
    and enter your email.'
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  访问 [https://id.heroku.com/signup/devcenter](https://id.heroku.com/signup/devcenter)，并输入您的电子邮件。'
- en: '**2**.  The next manual step you need to follow is installing their toolbelt,
    a series of command-line programs that help you manage your applications hosted
    on Heroku. You can find it at [https://toolbelt.heroku.com](https://toolbelt.heroku.com),
    and then follow the instructions to run `heroku login,` which you can find on
    that same website.'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  接下来，您需要遵循的下一个手动步骤是安装他们的工具包，这是一系列命令行程序，可以帮助您管理在 Heroku 上托管的您的应用程序。您可以在
    [https://toolbelt.heroku.com](https://toolbelt.heroku.com) 找到它，然后按照网站上的说明运行 `heroku
    login`，该说明同样可以在该网站上找到。'
- en: '**3**.  You’ll then need a `Procfile,` which is a fancy file to describe the
    OS processes your application runs on.'
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  然后您需要一个 `Procfile`，这是一个描述您的应用程序在操作系统上运行的进程的文件。'
- en: Heroku’s definition of a Procfile can be found below. Note that there are also
    a few more steps to this process that can be found a few paragraphs later.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 对 Procfile 的定义如下。请注意，此过程还有一些额外的步骤，可以在接下来的几段中找到。
- en: '|  |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Procfile
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Procfile
- en: A `Procfile` is a text file named Procfile placed in the root of your application
    that lists the process types in an application. Each process type is a declaration
    of a command that’s executed when an instance (called `dyno` in Heroku’s jargon)
    of that process type is started. You can use a Procfile to declare various process
    types, such as multiple types of workers, a singleton process like a clock, or
    a consumer of the Twitter streaming API.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`Procfile` 是一个名为 Procfile 的文本文件，放置在您的应用程序根目录中，列出了应用程序中的进程类型。每个进程类型都是当该进程类型的实例（在
    Heroku 的术语中称为 `dyno`）启动时执行的命令的声明。您可以使用 Procfile 声明各种进程类型，例如多种类型的工人、一个单例进程（如时钟）或
    Twitter 流式 API 的消费者。'
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Long story short, for most well-designed Node applications out there, the Procfile
    will look similar to the following code:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于大多数设计良好的 Node 应用程序，Procfile 将类似于以下代码：
- en: '[PRE38]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As far as the application goes, you’re going for the bare minimum, because
    this is a taste of what deploying to Heroku feels like. `app.js` could be as small
    as the following snippet of JavaScript (ch04/05_heroku-deployments):'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 就应用程序而言，你追求的是最基本的要求，因为这是部署到 Heroku 的感觉。`app.js` 可以小到以下 JavaScript 片段（ch04/05_heroku-deployments）：
- en: '[PRE39]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that you use `process.env.PORT || 3000`, because Heroku will provide your
    application with a port it should listen on that will be exposed on the environment
    variable named `PORT.`
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你使用 `process.env.PORT || 3000`，因为 Heroku 将为你提供应用程序应监听并暴露在名为 `PORT` 的环境变量上的端口。
- en: 'Then you use `3000` for local development. Now, here are a few more steps to
    take:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用 `3000` 进行本地开发。现在，这里还有一些额外的步骤要执行：
- en: '**1**.  Once you’re sitting on your project root, execute the following in
    terminal, to initialize a `git` repository:'
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 一旦你坐在项目根目录下，请在终端中执行以下命令以初始化一个 `git` 仓库：'
- en: ''
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`git init git add . git commit -m "init"`'
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`git init git add . git commit -m "init"`'
- en: '**2**.  Next create the app on Heroku with `heroku create.` This is a one-time
    thing.'
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 接下来使用 `heroku create.` 在 Heroku 上创建应用程序。这是一次性操作。'
- en: ''
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At this point, your terminal should look similar to [figure 4.3](#ch04fig03).
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，你的终端应该看起来类似于[图 4.3](#ch04fig03)。
- en: ''
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 4.3\. Creating an app on Heroku using their CLI
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 使用他们的 CLI 在 Heroku 上创建一个应用
- en: ''
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](04fig03_alt.jpg)'
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](04fig03_alt.jpg)'
- en: On every deploy you want to make, you can push to the `heroku` remote using
    `git push heroku master`. This will trigger a deploy, which looks something like
    [figure 4.4](#ch04fig04).
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在你想要进行的每次部署中，你可以使用 `git push heroku master` 将更改推送到 `heroku` 远程。这将触发一个部署，看起来就像[图
    4.4](#ch04fig04)。
- en: Figure 4.4\. Deploying to Heroku—as simple as `git push`
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 部署到 Heroku——就像 `git push` 一样简单
- en: '![](04fig04_alt.jpg)'
  id: totrans-838
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig04_alt.jpg)'
- en: 'If you want to pull up the application in the browser, use the following command:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在浏览器中打开应用程序，请使用以下命令：
- en: '[PRE40]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There’s one caveat about Heroku and PaaS providers. When it comes to deploying
    build results, there’s no simple solution. You shouldn’t include build artifacts
    in your repository, as that may cause undesirable results such as forgetting to
    rebuild after changing something. You shouldn’t get too comfortable building on
    their platforms, either, because building is something that should be done locally
    or on an integration platform, but not on the application server itself, because
    that would put a dent in your application’s performance.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Heroku 和 PaaS 提供商有一个注意事项。在部署构建结果时，没有简单的解决方案。你不应该将构建工件包含在你的仓库中，因为这可能会导致不希望的结果，例如在更改某些内容后忘记重新构建。你也不应该过于依赖他们在平台上的构建，因为构建应该是本地或集成平台上进行的，而不是在应用程序服务器本身上，因为这会降低你的应用程序性能。
- en: 4.3.1\. Deploying builds
  id: totrans-842
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 部署构建
- en: 'The problem is you shouldn’t put build results in version control, because
    those are the output of your source. Instead you should build before deployments,
    and deploy the build results along with the rest of your code. Most PaaS providers
    don’t offer many alternatives. Platforms such as Heroku take deployments from
    Git when you push to their remote, but you don’t want to include the build artifacts
    in revision control, so that becomes an issue. The solution: treat Heroku as you
    would any continuous integration platform (more on that in [section 4.4](#ch04lev1sec4)),
    and allow Heroku to build your application in its servers.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你不应该将构建结果放入版本控制中，因为那些是你源代码的输出。相反，你应该在部署前进行构建，并将构建结果与你的其他代码一起部署。大多数 PaaS
    提供商不提供很多替代方案。例如，Heroku 在你向其远程推送时会从 Git 获取部署，但你不想将构建工件包含在版本控制中，这成为一个问题。解决方案：将 Heroku
    视为任何持续集成平台（更多内容请参阅[第 4.4 节](#ch04lev1sec4))，并允许 Heroku 在其服务器上构建你的应用程序。
- en: 'Heroku doesn’t usually install `devDependencies` for Node projects, because
    it uses `npm install –-production`, and you need to use a custom buildpack to
    get around that. *Buildpacks* are interfaces between the language you use and
    the Heroku platform, and they’re collections of shell scripts. Creating an application
    with the custom Grunt-enabled buildpack is easy using the following command, where
    `thing` is the name of your app on Heroku:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 通常不会为 Node 项目安装 `devDependencies`，因为它使用 `npm install –-production`，你需要使用自定义构建包来解决这个问题。*构建包*是你使用的语言和
    Heroku 平台之间的接口，它们是一系列 shell 脚本。使用以下命令创建具有自定义 Grunt 启用的构建包的应用程序很容易，其中 `thing` 是你在
    Heroku 上的应用程序名称：
- en: '[PRE41]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you’ve created an application using the custom buildpack, you could push
    the way you usually do, and that would trigger a build on Heroku servers. The
    last thing you need to set up is a `heroku` task:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用自定义构建包创建了应用程序，您就可以像平常一样推送，这将触发 Heroku 服务器上的构建。您最后需要设置的是 `heroku` 任务：
- en: '[PRE42]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Heroku will terminate deployments if the build fails, keeping the previously
    deployed application unaffected by failed builds. There’s a detailed explanation
    in the accompanying samples, listed as ch04/06_heroku-grunt, which will walk you
    through setting this up.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建失败，Heroku 将终止部署，保持之前部署的应用程序不受失败构建的影响。在附带的示例中有详细的解释，列在 ch04/06_heroku-grunt
    中，它将指导您如何设置此功能。
- en: Let’s take a look at how you can fit multiple environments in a single Heroku
    application.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将多个环境整合到单个 Heroku 应用程序中。
- en: 4.3.2\. Managing environments
  id: totrans-850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 管理环境
- en: 'If you want to set yourself up so you can host multiple environments^([[5](#ch04fn05)])
    on Heroku, such as `staging` and `production,` use different `git` remote endpoints
    to achieve this. Create a remote other than `heroku` with the CLI:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Heroku 上设置多个环境，例如 `staging` 和 `production`，可以使用不同的 `git` 远程端点来实现。使用 CLI
    创建一个除 `heroku` 之外的远程：
- en: ⁵ Heroku has advice on managing multiple environments. Go to [http://bevacqua.io/bf/heroku-environments](http://bevacqua.io/bf/heroku-environments).
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ Heroku 提供了关于管理多个环境的建议。请访问 [http://bevacqua.io/bf/heroku-environments](http://bevacqua.io/bf/heroku-environments)。
- en: '[PRE43]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instead of `git push heroku master,` you should now do `git push staging master.`
    Similarly, instead of doing `heroku config:set FOO=bar`, you now need to explicitly
    tell `heroku` to use a particular remote, such as `heroku config:set FOO=bar --remote
    staging.` Remember environment configuration is environment-specific, and should
    be treated as such, so environments shouldn’t share API keys to third-party services,
    database credentials, or any authentication data in general.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该使用 `git push staging master` 而不是 `git push heroku master`，同样，您现在需要明确告诉
    `heroku` 使用特定的远程，例如使用 `heroku config:set FOO=bar --remote staging` 而不是 `heroku
    config:set FOO=bar`。请记住，环境配置是针对特定环境的，应该这样处理，因此环境之间不应共享第三方服务的API密钥、数据库凭证或任何一般认证数据。
- en: Now that you can configure and deploy to specific environments directly from
    your command line, it’s time to learn about a practice known as continuous integration,
    which will help tighten the leash on overall code quality. If you want to look
    into deployments to Amazon Web Services, there’s a small guide^([[6](#ch04fn06)])
    you can follow in the accompanying source code (labeled ch04/07_aws-deployments
    in the samples).
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以直接从命令行配置和部署到特定环境，是时候了解一种称为持续集成的实践了，这将有助于提高整体代码质量。如果您想了解如何将应用程序部署到亚马逊网络服务，可以遵循附带的源代码中的小型指南^([[6](#ch04fn06)))（在示例中标记为
    ch04/07_aws-deployments）。
- en: ⁶ Walk through the deployment process to AWS with this code sample at [http://bevacqua.io/bf/aws](http://bevacqua.io/bf/aws).
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 通过这个代码示例了解如何将应用程序部署到 AWS 的部署过程 [http://bevacqua.io/bf/aws](http://bevacqua.io/bf/aws)。
- en: 4.4\. Continuous integration
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 持续集成
- en: Martin Fowler is one of the most renowned proponents of continuous integration.
    In his own words,^([[7](#ch04fn07)]) Fowler describes CI as follows.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler 是持续集成最著名的倡导者之一。用他自己的话说，^([[7](#ch04fn07)])，Fowler 如下描述CI。
- en: ⁷ Read Fowler’s full article on continuous integration at [http://bevacqua.io/bf/integration](http://bevacqua.io/bf/integration).
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 在 [http://bevacqua.io/bf/integration](http://bevacqua.io/bf/integration) 阅读Fowler关于持续集成的完整文章。
- en: '|  |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Continuous integration
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 持续集成
- en: is a software development practice where members of a team integrate their work
    frequently; usually each person integrates at least daily, leading to multiple
    integrations per day. Each integration is verified by an automated build (including
    test) to detect integration errors as quickly as possible. Many teams find that
    this approach leads to significantly reduced integration problems and allows a
    team to develop cohesive software more rapidly.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 是一种软件开发实践，团队成员经常集成他们的工作；通常每个人至少每天集成一次，导致每天有多次集成。每次集成都会通过自动构建（包括测试）来验证，以尽可能快地检测集成错误。许多团队发现这种方法可以显著减少集成问题，并允许团队更快地开发出具有凝聚力的软件。
- en: '|  |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Furthermore, he entices us to run the test suite in an environment that’s as
    close to our production environment as possible. The implication is that your
    best bet, when it comes to testing your application, is doing it in the cloud,
    the way you do your hosting. CI platforms such as Travis-CI provide features like
    build error notifications and access to the full build logs, detailing everything
    that happened during the build (and its testing).
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，他还诱惑我们在尽可能接近生产环境的环境中运行测试套件。这意味着，当涉及到测试你的应用程序时，你的最佳选择是在云中做，就像你做托管一样。CI平台如Travis-CI提供诸如构建错误通知和访问完整的构建日志等功能，详细记录了构建（及其测试）期间发生的一切。
- en: I mentioned Travis-CI; let’s see how we can set ourselves up in such a way that
    we can remotely add builds to a queue on its platform on every commit made to
    our repository. Then Travis-CI build servers will process this queue one item
    at a time, running our builds and letting us know about the results.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了Travis-CI；让我们看看我们如何设置自己，以便在每次向我们的仓库提交时，都可以远程将其构建添加到其平台上的队列中。然后Travis-CI构建服务器将逐个处理这个队列，运行我们的构建并通知我们结果。
- en: 4.4.1\. Hosted CI using Travis
  id: totrans-866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 使用Travis的托管CI
- en: Continuous integration means to run tests on a remote server (which is as similar
    as possible to the production environment) in hopes of catching bugs that would
    otherwise make their way to the general population. Travis-CI is one CI platform
    (Circle-CI is another) where you can get feedback remotely on the result of a
    build once you’ve properly configured it. If the build is successful, you won’t
    even notice. If the build fails, you’ll get an email notification telling you
    someone broke your build (oops!). Later, when a subsequent push fixes the build,
    you’ll get another notification letting you know about the fix. Additionally,
    you can also access full build logs on the Travis website, which always comes
    in handy when figuring out why a build failed. [Figure 4.5](#ch04fig05) shows
    one such email notification.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成意味着在远程服务器（尽可能接近生产环境）上运行测试，希望捕捉到那些否则会进入普通用户的错误。一旦你正确配置了它，Travis-CI（Circle-CI是另一个）就是一个你可以远程获取构建结果的CI平台。如果构建成功，你甚至都不会注意到。如果构建失败，你会收到一封电子邮件通知，告诉你有人破坏了你的构建（哎呀！）。稍后，当后续的推送修复了构建时，你将收到另一封通知，告诉你修复了什么。此外，你还可以在Travis网站上访问完整的构建日志，这在找出构建失败的原因时总是很有帮助。[图4.5](#ch04fig05)
    展示了这样一个电子邮件通知。
- en: Figure 4.5\. A typical Travis notification for a build fix
  id: totrans-868
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 一个典型的Travis构建修复通知
- en: '![](04fig05.jpg)'
  id: totrans-869
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05.jpg)'
- en: 'Setting up CI is almost too easy in this day and age. The first thing you’ll
    need to do is create a `.travis.yml` file at the project root. In the file, you’ll
    need to declare the language you’re using, which in your case is identified as
    `node_js,` the runtime version you’re testing your builds against, and a series
    of scripts to execute before, during, and after the integration test. For the
    purposes of illustration, such a file might look like the following code:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时代，设置持续集成（CI）几乎太简单了。你首先需要做的是在项目根目录下创建一个 `.travis.yml` 文件。在这个文件中，你需要声明你使用的语言，在你的情况下被标识为
    `node_js`，你正在测试的运行时版本，以及一系列在集成测试之前、期间和之后执行的脚本。为了说明，这样的文件可能看起来像以下代码：
- en: '[PRE44]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Configuring Travis and Grunt
  id: totrans-872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置Travis和Grunt
- en: Before executing your tests, you need to install the command-line interface
    for Grunt, `grunt-cli,` through `npm`. You’ll need it in the integration test
    server the way you need it in your development environments so you can run Grunt
    tasks. You can use the `before_install` section to install the CLI.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行你的测试之前，你需要通过 `npm` 安装Grunt的命令行界面 `grunt-cli`。你需要在集成测试服务器上安装它，就像你需要在你的开发环境中安装它一样，以便运行Grunt任务。你可以使用
    `before_install` 部分来安装CLI。
- en: All that’s left then is to set up a `ci` task for Grunt. The ci task could run
    `jshint` to mitigate syntax errors, just like you’re already doing locally every
    time something changes, thanks to your newfangled continuous development workflow.
    You should configure the `ci` task to run unit and integration tests as well,
    on top of linting your code with `jshint.`
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 然后剩下的就是为Grunt设置一个 `ci` 任务。`ci` 任务可以运行 `jshint` 来减轻语法错误，就像你已经在你的新式持续开发工作流程中，每次有东西改变时在本地做的那样。你应该配置
    `ci` 任务，在用 `jshint` 检查你的代码的基础上，运行单元和集成测试。
- en: The real value in CI comes from having the remote server build your entire application
    and apply your tests (lint included) against the code base, ensuring you don’t
    depend on files not checked into version control or dependencies you might have
    installed locally but not made available in your code base at large.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成（CI）中，真正的价值在于远程服务器构建你的整个应用程序，并对代码库应用你的测试（包括代码风格检查），确保你不会依赖于未提交到版本控制中的文件，或者你可能已经安装但未在代码库中提供的本地依赖。
- en: You’ll probably want to try out this example yourself, and I recommend you do
    so, because it’s a good exercise for deployment-craving minds. You can follow
    the detailed instruction set I laid out in the accompanying sample repository,^([[8](#ch04fn08)])
    named 08_ci-by-example, under ch04\. Once you’re done with that, you might as
    well learn about continuous deployments, a practice that may or may not fit into
    your workflow, but one that you should be fully aware of, regardless.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想亲自尝试这个示例，我强烈推荐这样做，因为它对于渴望部署的人来说是一个很好的练习。你可以在附带的示例仓库中找到我详细说明的指令集，该仓库名为08_ci-by-example，位于ch04目录下。完成这些后，你还可以了解持续部署，这是一种可能或可能不适合你的工作流程的实践，但无论如何，你应该完全了解它。
- en: ⁸ Find the fully documented code sample online at [http://bevacqua.io/bf/travis](http://bevacqua.io/bf/travis).
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 你可以在网上找到完整的代码示例，地址为[http://bevacqua.io/bf/travis](http://bevacqua.io/bf/travis)。
- en: 4.4.2\. Continuous deployments
  id: totrans-878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 持续部署
- en: The Travis platform supports continuous deployments to Heroku.^([[9](#ch04fn09)])
    *Continuous deployments* are a fancy way of saying that every single time you
    push to version control, you also trigger a build job in the CI server (which
    you’re already doing as of last section, when you turned on Travis CI integration).
    When those builds succeed, the CI server deploys on your behalf to the release
    environments of your choosing.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: Travis平台支持持续部署到Heroku.^([[9](#ch04fn09)]) *持续部署*是一种说法，即每次你推送到版本控制时，你也会在CI服务器上触发一个构建作业（正如你在上一节中开启Travis
    CI集成时所做的）。当这些构建成功时，CI服务器会代表你将应用程序部署到你选择的发布环境中。
- en: ⁹ Read the article on Travis continuous deployments to Heroku at [http://docs.travis-ci.com/user/deployment/heroku/](http://docs.travis-ci.com/user/deployment/heroku/).
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 在[http://docs.travis-ci.com/user/deployment/heroku/](http://docs.travis-ci.com/user/deployment/heroku/)上阅读关于Travis持续部署到Heroku的文章。
- en: In my experience, continuous deployments are a two-edged sword. When they work,
    you are cutting into a world of joy and less tedious deployments where passing
    the build and test integration cycle is validation enough to push to production.
    But you have to be confident that you’ve got enough tests in place to catch errors
    sensibly. A safe bet might be to enable continuous deployment to your staging
    environment rather than directly to production. Then, you’d make sure there are
    no issues in staging, and perform a deploy to production. This workflow looks
    like [figure 4.6](#ch04fig06).
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，持续部署是一把双刃剑。当它们起作用时，你将进入一个充满喜悦和减少繁琐部署的世界，其中通过构建和测试集成周期是推向生产环境的充分验证。但你必须自信地认为你已经有了足够的测试来合理地捕获错误。一个安全的赌注可能是先启用对预发布环境的持续部署，而不是直接对生产环境进行部署。然后，你将确保预发布环境中没有问题，并执行生产环境的部署。这个工作流程看起来像[图4.6](#ch04fig06)。
- en: Figure 4.6\. Proposed continuous deployment flow
  id: totrans-882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 建议的持续部署流程
- en: '![](04fig06_alt.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6的替代文本](04fig06_alt.jpg)'
- en: There’s work involved in enabling continuous deployments to Heroku. You need
    an API key from Heroku, and you need to encrypt it and then configure `.travis.yml`
    with the encrypted data. I’ll leave that up to you, now that I’ve voiced my concerns
    about deploying to production directly. If you choose to do that, visit [http://bevacqua.io/bf/travis-heroku](http://bevacqua.io/bf/travis-heroku)
    for instructions.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 启用对Heroku的持续部署需要做些工作。你需要从Heroku获取一个API密钥，然后对其进行加密，并将加密数据配置到`.travis.yml`文件中。现在，我已经表达了对直接部署到生产环境的担忧，所以这个步骤就留给你自己来完成。如果你选择这样做，请访问[http://bevacqua.io/bf/travis-heroku](http://bevacqua.io/bf/travis)获取说明。
- en: We’ve spent the majority of this chapter addressing deployments, which is a
    good thing. Now you can finally turn your attention to the options you have when
    it comes to monitoring the state of your application as a whole, and individual
    requests in particular, when live in production. You’ll also examine approaches
    to logging, debugging, and catastrophe tracing.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的大部分内容中都在讨论部署，这是好事。现在你终于可以关注你的应用程序在生产环境中的整体状态以及特定请求的监控选项了。你还将检查日志记录、调试和灾难追踪的方法。
- en: 4.5\. Monitoring and diagnostics
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 监控和诊断
- en: Production application monitoring is as important as having loyal customers.
    If you don’t appreciate application uptime, your customers won’t appreciate you.
    This is to say that you can’t afford not to monitor your production servers. By
    monitoring I mean keeping access logs (who’s visited what, when, and where from),
    as well as error logs (what went wrong), and perhaps even more importantly, setting
    up alerts so that you are immediately notified when things go *expectedly* wrong.
    “Expectedly” wasn’t a typo; you should expect things to go wrong, and be as prepared
    as you can for those situations. Your enterprise probably doesn’t warrant a simian
    army roaming around and randomly terminating off instances and services like Netflix
    advocates^([[10](#ch04fn10)]) to ensure their servers can reliably and consistently
    endure faults, such as hardware failure, without it affecting the end users consuming
    their services. But their advice, quoted as follows, still applies to most every
    software development effort.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 生产应用程序的监控与拥有忠诚的客户一样重要。如果你不重视应用程序的可用性，你的客户也不会欣赏你。这意味着你不能不监控你的生产服务器。通过监控，我指的是保留访问日志（谁访问了什么，何时以及从哪里访问），以及错误日志（出了什么问题），也许更重要的是，设置警报，以便在事情“意料之外”出错时立即通知你。“意料之外”并不是打字错误；你应该预料到事情会出错，并尽可能为这些情况做好准备。你的企业可能不需要像Netflix所倡导的那样有一支猴子军队四处游荡，随机终止实例和服务，以确保他们的服务器能够在没有影响最终用户消费其服务的情况下可靠和一致地承受故障，如硬件故障。但他们的建议，如下引用，仍然适用于大多数软件开发工作。
- en: ^(10) Learn about Chaos Monkey, a chaos mongering service at Netflix, at [http://bevacqua.io/bf/netflix](http://bevacqua.io/bf/netflix).
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((10) 了解Netflix的混沌猴子服务，一个混沌服务，请访问 [http://bevacqua.io/bf/netflix](http://bevacqua.io/bf/netflix)).
- en: '|  |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: QUOTE from netflix blog
  id: totrans-890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 引自Netflix博客
- en: If we aren’t constantly testing our ability to succeed despite failure, then
    it isn’t likely to work when it matters most—in the event of an unexpected outage.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不经常测试在失败中取得成功的能力，那么在关键时刻——在意外停机时，它可能就不会起作用。
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: How do you plan for failure, though? Well, that’s the sad part; nothing you
    do will prevent failure. Everyone has downtime, even giants such as Microsoft,
    Google, Facebook, and Twitter. You can plan all you want, but your application
    is going to fail regardless of what you do. What you can do is develop a modular
    architecture that’s capable of dealing with services going boom and instances
    going bust. If you can achieve that modularity, it shouldn’t be as damaging when
    a single module stops working, because the rest would still be perfectly functional.
    We’ll develop notions of modularity, and the single responsibility principle (SRP)
    in [chapter 5](kindle_split_017.html#ch05), dedicated to modular design and a
    crash-course introduction to the Node.js platform.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你如何计划失败呢？嗯，这就是令人难过的地方；你做的任何事情都无法阻止失败。每个人都有停机时间，即使是像微软、谷歌、Facebook和Twitter这样的巨头也不例外。你可以计划得再多，但你的应用程序最终还是会失败。你能做的是开发一个模块化架构，能够处理服务崩溃和实例故障。如果你能实现这种模块化，那么当单个模块停止工作时，它的影响就不会那么大了，因为其余部分仍然可以完美地工作。我们将在第5章中开发模块化和单一责任原则（SRP）的概念，该章专门介绍模块化设计和Node.js平台的快速入门。
- en: The first rule about Fight Club is you do not talk about Fight Club. Sorry,
    wrong movie. The first rule about application monitoring is you log things and
    set up notifications when bad things happen. Let’s go over a possible implementation
    for that.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 拳击俱乐部的第一条规则是，你不说关于拳击俱乐部的事情。抱歉，电影不对。应用程序监控的第一条规则是，当发生坏事时，你记录事情并设置通知。让我们来探讨一个可能的实现方案。
- en: 4.5.1\. Logging and notifications
  id: totrans-895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1\. 日志记录和通知
- en: I’m sure you’re more than used to `console.log` on the front end to inspect
    variables, and maybe even as a debugging mechanism, using it to figure out which
    code paths are being followed, and helping you nail down bugs. On the server side
    you have the standard output and standard error streams, both logging to your
    terminal window. These transports (`stdout` and `stderr`; more on transports in
    a minute!) are useful for development, but they are near useless to you if you
    can’t capture what’s being transmitted to them in a hosted environment, where
    you can’t monitor the process in your own terminal.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经非常习惯在前端使用 `console.log` 来检查变量，甚至可能将其作为调试机制，用它来确定哪些代码路径正在被跟踪，并帮助你定位错误。在服务器端，你有标准输出和标准错误流，两者都记录到你的终端窗口。这些传输（`stdout`
    和 `stderr`；稍后会更详细地介绍传输！）对于开发很有用，但如果你无法捕获在托管环境中传输给它们的任何内容，那么它们对你几乎毫无用处，因为你无法在自己的终端中监控这些过程。
- en: Heroku has a mechanism where it captures the standard output of your processes,
    so you can access it down the road. It also has add-ons to further extend that
    behavior. Heroku add-ons provide much-needed companion services such as databases,
    emailing, caching, monitoring, and other resources. Most logging add-ons would
    allow you to set up filtering and notifications; however, I’d advise against leveraging
    Heroku’s logging capabilities, as that would be too platform-specific, and it
    can severely limit your ability to migrate to another PaaS provider. Dealing with
    logging on your own isn’t that hard, and you’ll soon see the upside of doing so.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 有一种机制可以捕获你的进程的标准输出，因此你可以稍后访问它。它还提供了扩展该行为的附加组件。Heroku 附加组件提供了许多必需的配套服务，例如数据库、电子邮件、缓存、监控和其他资源。大多数日志附加组件都会允许你设置过滤和通知；然而，我建议不要利用
    Heroku 的日志记录功能，因为这会过于平台特定，并且可能会严重限制你迁移到另一个 PaaS 提供商的能力。自己处理日志并不那么困难，你很快就会看到这样做的好处。
- en: Winston for logging
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Winston 用于日志记录
- en: I’m not a huge fan of taking advantage of the Heroku logging facilities, because
    it binds your code base to their infrastructure by assuming writing to standard
    output will suffice in your log tracking efforts. A more durable and versatile
    approach would be to use a multitransport logger rather than writing to `stdout`.
    Transports dictate what happens with the information you’re trying to log. A transport
    might log to a file, write a database record, send an email, or send push notifications
    to your phone. In multitransport loggers, you can use many of these at the same
    time, but you’d still use the same API to perform the logging. Adding or removing
    transports doesn’t affect the way you write log statements.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是特别喜欢利用 Heroku 的日志记录功能，因为它通过假设将内容写入标准输出就足以满足你的日志跟踪需求，从而将你的代码库绑定到他们的基础设施上。一个更持久和灵活的方法是使用多传输记录器，而不是写入
    `stdout`。传输决定了你试图记录的信息会发生什么。一个传输可能会记录到一个文件，写入数据库记录，发送电子邮件，或者将推送通知发送到你的手机。在多传输记录器中，你可以同时使用这些功能中的许多，但你仍然会使用相同的
    API 来执行记录。添加或删除传输不会影响你编写日志语句的方式。
- en: 'Node has a few popular logging libraries, and I’ve picked `winston` because
    it has every feature you’re looking for in a logger: logging levels, contexts,
    multiple transports, an easy API, and community support. Plus, it’s easily extensible,
    and people have written transports for nearly everything you’ll ever need.'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: Node 有几个流行的日志库，我选择了 `winston`，因为它具有你在记录器中寻找的所有功能：日志级别、上下文、多个传输、简单的 API 和社区支持。此外，它易于扩展，人们已经为几乎所有你可能需要的功能编写了传输。
- en: By default, `winston` uses the `Console` transport, which is the same as using
    `stdout` directly. But you can set it up to use other transports, such as logging
    to a database or to a log management service. The latter are notably flexible
    in that they provide a platform where you can choose to get notified on important
    events without changing anything in your application.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`winston` 使用 `Console` 传输，这与直接使用 `stdout` 相同。但你也可以设置它来使用其他传输，例如将日志记录到数据库或日志管理服务。后者在灵活性方面尤为突出，它们提供了一个平台，你可以选择在重要事件发生时接收通知，而无需更改你的应用程序中的任何内容。
- en: 'Using a logging solution such as `winston` is platform agnostic. Your code
    won’t depend on the hosting platform to capture standard output to work. To get
    started using `winston,` you have to install the package by the same name:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `winston` 这样的日志记录解决方案是平台无关的。你的代码不会依赖于托管平台来捕获标准输出才能工作。要开始使用 `winston`，你必须通过同名包来安装它：
- en: '[PRE45]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using --save vs using --save-dev**'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 --save 与使用 --save-dev**'
- en: In this case, you’ll use the `--save` flag rather than `--save-dev`, because
    `winston` isn’t a build-only package like the Grunt packages you’ve toyed with
    so far. When providing the `--save` flag to `npm`, the package will be added to
    your `package.json` file under `dependencies.`
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该使用`--save`标志而不是`--save-dev`，因为`winston`不是一个像你之前玩过的Grunt包那样的仅用于构建的包。当向`npm`提供`--save`标志时，该包将被添加到你的`package.json`文件中的`dependencies`部分。
- en: '|  |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Once you’ve installed `winston`, you can use it right away by putting `logger`
    where you used to put `console`:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了`winston`，你就可以立即使用它，只需将`logger`放在你之前放置`console`的地方：
- en: '[PRE46]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You might have gotten used to the idea of `console` being a global variable.
    In my experience, it’s not wrong to use globals in this kind of scenario, and
    it’s one of the two cases where I allow myself to use globals (the other one being
    `nconf`, as I mentioned in [chapter 3](kindle_split_014.html#ch03)). I like setting
    all the globals in a single file (even if there are only two), so that I can quickly
    scan it and figure out what’s going on when I call something that’s not otherwise
    defined in a module, or a part of Node. An illustrative `globals.js` might be
    as follows:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了`console`是一个全局变量的想法。根据我的经验，在这种场景下使用全局变量并没有错，这也是我允许自己使用全局变量的两种情况之一（另一个是`nconf`，如我在第3章中提到的）。我喜欢在一个单独的文件中设置所有全局变量（即使只有两个），这样我可以在调用一个在模块或Node中未定义的东西时快速扫描它，并找出发生了什么。一个说明性的`globals.js`可能如下所示：
- en: '[PRE47]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'I also propose keeping a single file where you can define the transports for
    your logger. Let’s kick things off by using a `File` transport, as well as the
    default `Console` one. This would be the `logger.js` file referenced in the previous
    snippet:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议保留一个单独的文件，你可以在这里定义你的日志记录器的传输方式。让我们从使用`File`传输以及默认的`Console`传输开始。这将是在前面的代码片段中引用的`logger.js`文件：
- en: '[PRE48]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, whenever you do `logger.debug`, you’ll be logging a debug message to both
    the terminal and to a file. Although convenient, other transports offer more flexibility
    and reliability, and such is the case of a few transports we’ll be covering in
    the accompanying samples: `winston-mail` will enable you to send out emails whenever
    something happens (at a level that warrants an email), `winston-pushover` sends
    notifications directly in your phone, and `winston-mongodb` is one of many traditional
    logging transports where you write a record in your database.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你执行`logger.debug`时，你都会将调试消息记录到终端和文件中。虽然很方便，但其他传输方式提供了更多的灵活性和可靠性，这正是我们将要介绍的几个传输方式的特点：`winston-mail`将允许你在发生某些事情时发送电子邮件（在需要发送电子邮件的水平上），`winston-pushover`可以直接在手机上发送通知，而`winston-mongodb`是许多传统日志传输方式之一，你可以在数据库中写入记录。
- en: Once you’ve made sure to check out the sample listings, you’ll have a better
    idea of how configuration, logging, and globals are tied together according to
    what I suggested. In case you’re religiously against globals, don’t panic. I’ve
    also included a sample where they aren’t used. I like globals (in the two cases
    I mentioned previously) only because I find it convenient not having to `require`
    the same things in every module.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你仔细检查了示例列表，你将更好地了解如何根据我提出的建议将配置、日志记录和全局变量结合起来。如果你对全局变量有强烈的反对意见，请不要慌张。我也包括了一个不使用全局变量的示例。我喜欢全局变量（在之前提到的两种情况下），只是因为我发现不需要在每一个模块中重复`require`同样的事情。
- en: Now that you’ve spent time dealing with logging, we might as well talk about
    debugging Node applications.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经花时间处理日志记录了，我们不妨谈谈调试Node应用程序。
- en: 4.5.2\. Debugging Node applications
  id: totrans-917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2. 调试Node应用程序
- en: You’ll want all the help you can get when it comes to tracing down a bug, and
    in my experience the best approach to debugging is increased logging, which is
    one of the reasons we’ve talked about it. That being said, you have more than
    a few ways to debug Node apps. You might use node-inspector^([[11](#ch04fn11)])
    inside of Chrome’s DevTools, you could use the features provided by an integrated
    IDE such as WebStorm, and then there’s good old `console.log`. You could also
    use the native debugger^([[12](#ch04fn12)]) in V8 (the JavaScript engine Node
    runs on) directly.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要追踪一个错误时，你会想要得到所有你能得到的帮助，根据我的经验，调试的最佳方法是增加日志记录，这也是我们之前讨论它的原因之一。话虽如此，你有很多种方法可以调试Node应用。你可以在Chrome的DevTools中使用node-inspector^([[11](#ch04fn11)))，你可以使用WebStorm等集成IDE提供的功能，然后还有古老的`console.log`。你还可以直接在V8（Node运行的JavaScript引擎）中使用本地的调试器^([[12](#ch04fn12)))。
- en: ^(11) Find the open source repository for node-inspector at GitHub at [http://bevacqua.io/bf/node-inspector](http://bevacqua.io/bf/node-inspector).
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（11）在 GitHub 上找到 node-inspector 的开源存储库 [http://bevacqua.io/bf/node-inspector](http://bevacqua.io/bf/node-inspector)。
- en: ^(12) Read the Node.js API documentation on debugging at [http://bevacqua.io/bf/node-debugger](http://bevacqua.io/bf/node-debugger).
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（12）在 [http://bevacqua.io/bf/node-debugger](http://bevacqua.io/bf/node-debugger)
    上阅读 Node.js API 调试文档。
- en: Depending on which kind of bug you’re tracing, you’ll pick the right tool for
    the job. For example, if you’re tracing a memory leak, you might use a package
    such as `memwatch,` which emits events when it’s likely that a memory leak occurred.
    A more common use case, such as pinning down a rounding bug, or finding out what’s
    wrong with your API calls, can be satisfied by adding log statements (temporarily
    with `console.log,` or in a more permanent fashion with `logger.debug`), or using
    the `node-inspector` package.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你追踪的哪种类型的错误，你将选择适合的工具。例如，如果你正在追踪内存泄漏，你可能使用 `memwatch` 这样的包，它在可能发生内存泄漏时发出事件。对于更常见的用例，例如定位舍入错误，或找出你的
    API 调用出了什么问题，可以通过添加日志语句（暂时使用 `console.log`，或以更永久的方式使用 `logger.debug`），或使用 `node-inspector`
    包来满足。
- en: Using Node Inspector
  id: totrans-922
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Node Inspector
- en: 'The `node-inspector` package hooks onto the native debugger in V8, but it lets
    you debug using the full-featured debugging tools found in Chrome as an alternative
    to the terminal-based debugger provided by Node. To use it, the first thing you’ll
    need to do is install it globally:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-inspector` 包连接到 V8 的原生调试器，但它允许你使用 Chrome 中的完整功能调试工具进行调试，作为 Node 提供的基于终端的调试器的替代方案。要使用它，你需要做的第一件事是全局安装它：'
- en: '[PRE49]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To enable debugging on your Node process, you can pass the `--debug` flag to
    `node` when you launch the process, like so:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node 进程上启用调试，你可以在启动进程时向 `node` 传递 `--debug` 标志，如下所示：
- en: '[PRE50]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As an alternative, you can enable it on a running process. To do this, you’ll
    need to find the process ID (PID). The following command, `pgrep`, takes care
    of that:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，你可以在运行中的进程上启用它。为此，你需要找到进程 ID（PID）。以下命令 `pgrep` 负责处理：
- en: '[PRE51]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output will be the PID for your running Node process. For example, it might
    be as follows:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是运行中的 Node 进程的 PID。例如，它可能如下所示：
- en: '[PRE52]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Sending a `USR1` signal to the process will enable debugging. This is done
    using the `kill -s` command (note I’m using the process ID from the results of
    the previous command):'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 向进程发送 `USR1` 信号将启用调试。这可以通过 `kill -s` 命令完成（注意我使用的是上一个命令的结果中的进程 ID）：
- en: '[PRE53]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If everything worked correctly, Node will notify you where the debugger is
    listening through its standard output:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，Node 将通过其标准输出通知你调试器正在监听的位置：
- en: '[PRE54]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now you need to execute `node-inspector` and then open Chrome, pointing it
    at the link provided by the inspector:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要执行 `node-inspector` 并然后打开 Chrome，将其指向检查器提供的链接：
- en: '[PRE55]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If all goes well, you should see something similar to [figure 4.7](#ch04fig07)
    and have a full-blown debugger in your Chrome browser ready to use, which will
    behave (for the most part) exactly like the debugger for client-side JavaScript
    applications. This debugger will allow you to watch expressions, set breakpoints,
    step through the code, and inspect the call stack, among other useful features.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到类似于[图 4.7](#ch04fig07) 的内容，并在 Chrome 浏览器中准备好一个完整的调试器，该调试器（大部分情况下）的行为与客户端
    JavaScript 应用程序的调试器完全一样。这个调试器将允许你监视表达式、设置断点、逐行执行代码，并检查调用栈，以及其他有用功能。
- en: Figure 4.7\. Debugging Node.js code in Chrome using Node Inspector
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 使用 Node Inspector 在 Chrome 中调试 Node.js 代码
- en: '![](04fig07_alt.jpg)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07_alt.jpg)'
- en: On a higher level than debugging, there’s performance analysis, which will help
    detect potential problems in your code, such as memory leaks causing a spike in
    memory consumption that could cripple your servers.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试之上，还有性能分析，这有助于检测代码中的潜在问题，例如内存泄漏导致内存消耗激增，可能会削弱你的服务器。
- en: 4.5.3\. Adding performance analytics
  id: totrans-941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.3\. 添加性能分析
- en: You have a few options when it comes to performance profiling, depending on
    how specific (we must track down a memory leak!) or generic (how could we detect
    a spike in memory consumption?) your needs are. Let’s look into a third-party
    service, which can relieve you of the burden of doing the profiling on your own.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能分析方面，你有几种选择，具体取决于你的需求是具体（我们必须追踪内存泄漏！）还是通用（我们如何检测内存消耗的激增？）。让我们看看第三方服务，它可以减轻你自行进行性能分析的压力。
- en: 'Nodetime is a service you can literally set up in seconds, which tracks analytics
    such as server load, free memory, CPU usage, and the like. You can sign up at
    [http://bevacqua.io/bf/nodetime-register](http://bevacqua.io/bf/nodetime-register)
    with your email, and once you do you’ll be provided with an API key you can use
    to set up `nodetime,` which takes a few lines of JavaScript to configure:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: Nodetime 是一种服务，你可以用几秒钟的时间轻松设置，它可以跟踪诸如服务器负载、空闲内存、CPU 使用率等分析数据。您可以通过电子邮件在 [http://bevacqua.io/bf/nodetime-register](http://bevacqua.io/bf/nodetime-register)
    注册，一旦注册成功，您将获得一个可以用来设置 `nodetime` 的 API 密钥，`nodetime` 需要几行 JavaScript 代码来配置：
- en: '[PRE56]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That’s it, and you’ll now have access to metrics, as well as the ability to
    take snapshots of CPU load, like the one presented in [figure 4.8](#ch04fig08).
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你现在将能够访问指标，以及能够对 CPU 负载进行快照，就像图 4.8 中展示的那样。
- en: Figure 4.8\. Server load over time, tracked by Nodetime
  id: totrans-946
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. 通过 Nodetime 跟踪的服务器负载随时间变化
- en: '![](04fig08.jpg)'
  id: totrans-947
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08.jpg)'
- en: To conclude, we’ll analyze a useful process scaling technique available to Node
    applications, known as `cluster`.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，我们将分析 Node 应用程序可用的一种有用的进程扩展技术，称为 `cluster`。
- en: 4.5.4\. Uptime and process management
  id: totrans-949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.4\. 运行时间和进程管理
- en: 'When it comes to release environments, production in particular, you can’t
    afford to have your process roll over and die with any particular exception. This
    can be mitigated using a native Node API called `cluster` that allows you to execute
    your application in multiple processes, dividing the load among them, and create
    new processes as needed. `cluster` takes advantage of multicore processors and
    the fact that Node is single-threaded, allowing you to easily spawn an array of
    processes that run the same web application. This has the benefit of making your
    app more fault tolerant; you can spawn a new process! For example, in a few lines
    of code, you could configure `cluster` to spawn a worker every time another one
    dies, effectively replacing it:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到发布环境，尤其是生产环境时，你不能容忍你的进程因为任何特定的异常而崩溃和死亡。这可以通过使用名为 `cluster` 的原生 Node API
    来缓解，该 API 允许你在多个进程中执行你的应用程序，将负载分配给它们，并在需要时创建新的进程。`cluster` 利用多核处理器和 Node 是单线程的事实，允许你轻松地启动一个运行相同
    Web 应用程序的过程数组。这使你的应用程序具有更高的容错性；你可以启动一个新的进程！例如，在几行代码中，你可以配置 `cluster` 以在另一个进程死亡时启动一个工作进程，从而有效地替换它：
- en: '[PRE57]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This doesn’t mean you should be careless about what happens inside your processes,
    as starting new ones can be expensive. Forking has a cost, tied to the amount
    of load your servers are under (requests / time), and also tied to the *startup
    time* for your process (wait period between spawning it and when it can handle
    HTTP requests). What `cluster` gives us is a way to transparently keep serving
    responses even if your workers die: others will come in his name.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你应该对进程内部发生的事情掉以轻心，因为启动新的进程可能会很昂贵。分叉是有成本的，与服务器承受的负载量（请求/时间）相关，也与你进程的 *启动时间*（从启动到可以处理
    HTTP 请求的等待时间）相关。`cluster` 给我们提供了一种透明地继续提供服务的方式，即使你的工作进程死亡：其他人会以他的名义加入。
- en: In [chapter 3](kindle_split_014.html#ch03) we introduced `nodemon` as a way
    to reload your application whenever a file changed during active development.
    This time you’ll review `pm2`, which is similar to `nodemon` in spirit, but geared
    toward release environments.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](kindle_split_014.html#ch03) 中，我们介绍了 `nodemon` 作为在积极开发期间文件更改时重新加载应用程序的一种方式。这次，你将回顾
    `pm2`，它在精神上与 `nodemon` 相似，但针对的是发布环境。
- en: Arranging a cluster
  id: totrans-954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安排集群
- en: 'Configuring `cluster` can be tricky, and it’s also an experimental API at this
    time, so it might change in the future. But the upsides brought forth by the `cluster`
    module are undeniable and definitely appealing. The `pm2` module allows you to
    use fully configured `cluster` functionality in your application without writing
    a single line of code, making it a no-brainer to use. `pm2` is a command-line
    utility, and you need to install it using the `-g` flag:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `cluster` 可能很棘手，而且目前它也是一个实验性 API，因此它可能会在未来发生变化。但 `cluster` 模块带来的好处是无可否认的，并且确实很有吸引力。`pm2`
    模块允许你在应用程序中使用完全配置的 `cluster` 功能，而不需要编写任何代码，这使得它成为使用时的不二选择。`pm2` 是一个命令行工具，你需要使用
    `-g` 标志来安装它：
- en: '[PRE58]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once installed, you can now run your application through it, and `pm2` will
    take care of setting up `cluster` for you. Think of the following command as a
    drop-in replacement for `node app`:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你现在可以通过它运行你的应用程序，`pm2` 将为你设置 `cluster`。将以下命令视为 `node app` 的直接替代品：
- en: '[PRE59]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The main difference is that your application will use `cluster` with two workers
    (due to the `-i 2` option). The workers will handle requests to your app, and
    if one of them crashes, another one will spawn so that the show can go on. Another
    useful perk of `pm2` is the ability to do *hot code reloads*, which will allow
    you to replace running apps with their newly deployed counterpart without any
    downtime. You’ll find related examples in the accompanying source code, listed
    as ch04/11_cluster-by-pm2, as well as one on how to use `cluster` directly, listed
    as ch04/10_a-node-cluster.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于你的应用程序将使用`cluster`模块与两个工作进程（由于`-i 2`选项）。工作进程将处理对应用程序的请求，如果一个工作进程崩溃，另一个将启动以确保应用程序正常运行。`pm2`的另一个有用功能是能够进行*热代码重载*，这将允许你在没有任何停机时间的情况下用新部署的应用程序替换正在运行的应用程序。你可以在附带的源代码中找到相关示例，列在ch04/11_cluster-by-pm2下，以及一个直接使用`cluster`的示例，列在ch04/10_a-node-cluster下。
- en: While clustering across a single computer is immediately beneficial and cheap,
    you should also consider clustering across multiple servers, mitigating the possibility
    of your site going down when your server crashes.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在单台计算机上进行集群具有立即的效益且成本低廉，但你也应该考虑在多台服务器上进行集群，以减轻服务器崩溃时网站可能宕机的情况。
- en: 4.6\. Summary
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6. 摘要
- en: 'Phew, that was intense! We worked hard in this chapter:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，这真是一场激烈的战斗！我们在本章中努力工作：
- en: You became more intimate friends with release flow optimizations such as image
    compression and static asset caching.
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你与发布流程优化，如图像压缩和静态资源缓存，成为了更亲密的朋友。
- en: You learned about the importance of testing a release before calling it a day,
    bumping your package version, and putting together a changelog.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到在结束一天的工作前测试发布版本、增加包版本和整理变更日志的重要性。
- en: Then you went through the motions of deploying to Heroku, and I mentioned `grunt-ec2`,
    which is one of many alternative deployment methods.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后你按照步骤部署到Heroku，我提到了`grunt-ec2`，这是许多替代部署方法之一。
- en: Attaining knowledge on continuous integration was a good thing, as you’ve learned
    the importance of validating your build process and the quality of the code base
    you released.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握持续集成的知识是一件好事，因为你已经学会了验证你的构建过程和发布代码库质量的重要性。
- en: Continuous deploys are something you can perform, but you understand the implications
    of doing that, so you’ll be careful about it.
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署是你能够执行的操作，但你理解这样做的影响，所以你会对此非常小心。
- en: You also took a quick look at logging, debugging, managing, and monitoring release
    environments, which will prove fundamental when troubleshooting production applications.
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还快速浏览了日志记录、调试、管理和监控发布环境的内容，这在解决生产应用问题时将证明是基础性的。
- en: All this talk about monitoring and debugging calls for a deeper analysis of
    architecture design, code quality, maintainability, and testability, which are
    conveniently at the core of [part 2](kindle_split_016.html#part02) in the book.
    [Chapter 5](kindle_split_017.html#ch05) is all about modularity and dependency
    management, different approaches to JavaScript modules, and part of what’s coming
    in ES6 (a long awaited ECMAScript standard update). In [chapter 6](kindle_split_018.html#ch06),
    you’ll uncover different ways you can properly organize the asynchronous code
    that’s the backbone of Node applications, while playing it safe when it comes
    to exception handling. [Chapter 7](kindle_split_019.html#ch07) will help you model,
    write, and refactor your code effectively. We’ll also analyze small code examples
    together. [Chapter 8](kindle_split_020.html#ch08) is dedicated to testing principles,
    automation, techniques, and examples. [Chapter 9](kindle_split_021.html#ch09)
    teaches you how to design REST API interfaces and also explains how they can be
    consumed on the client side.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于监控和调试的讨论都需要对架构设计、代码质量、可维护性和可测试性进行更深入的分析，这些恰好是书中[第2部分](kindle_split_016.html#part02)的核心。第5章[Chapter
    5](kindle_split_017.html#ch05)全部关于模块化和依赖管理，JavaScript模块的不同方法，以及即将到来的ES6（一个长期期待的ECMAScript标准更新）的部分内容。在第6章[chapter
    6](kindle_split_018.html#ch06)中，你将发现不同的方法来正确组织Node应用程序的异步代码，同时在异常处理方面确保安全。第7章[Chapter
    7](kindle_split_019.html#ch07)将帮助你有效地建模、编写和重构代码。我们还将一起分析一些小的代码示例。[第8章](kindle_split_020.html#ch08)专门介绍测试原则、自动化、技术和示例。[第9章](kindle_split_021.html#ch09)教你如何设计REST
    API接口，并解释它们如何在客户端被消费。
- en: You’ll leave [part 2](kindle_split_016.html#part02) with a deep understanding
    of how to design a coherent application architecture using JavaScript code. Pairing
    that with everything you’ve learned in [part 1](kindle_split_011.html#part01)
    about build processes and workflows, you’ll be ready to design a JavaScript application
    using a Build First approach, the ultimate goal of this book.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 你将带着如何使用JavaScript代码设计一个连贯的应用架构的深入理解离开[第二部分](kindle_split_016.html#part02)。将这部分内容与你已学到的[第一部分](kindle_split_011.html#part01)中关于构建过程和工作流程的所有知识相结合，你将准备好使用“先构建”的方法来设计一个JavaScript应用，这是本书的最终目标。
