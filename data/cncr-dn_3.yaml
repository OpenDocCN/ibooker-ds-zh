- en: A
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A
- en: Functional programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程
- en: It’s anecdotal to say that learning FP makes you a better programmer. It’s true
    that FP provides an alternative, often simpler, way of thinking about problems.
    Moreover, many techniques from FP can be successfully applied to other languages.
    No matter what language you work in, programming in a functional style provides
    benefits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 说学习FP使你成为一个更好的程序员是轶事性的。确实，FP提供了一种替代方案，通常更简单，可以用来思考问题。此外，许多FP技术可以成功地应用于其他语言。无论你使用什么语言，以函数式风格进行编程都能带来好处。
- en: FP is more a mindset than a particular set of tools or languages. Getting familiar
    with different programming paradigms is what makes you a better programmer, and
    a multiparadigm programmer is more powerful than a polyglot programmer. Therefore
    . . .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FP与其说是一套特定的工具或语言，不如说是一种心态。熟悉不同的编程范式使你成为一个更好的程序员，而多范式程序员比多语言程序员更有力量。因此……
- en: With the technical background having been sorted out in the chapters of this
    book, this appendix doesn’t cover the aspects of FP applied to concurrency, such
    as immutability, referential transparency, side-effect-free functions, and lazy
    evaluations. Rather, it covers general information about what FP means and the
    reasons why you should care about it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的章节已经整理好了技术背景，这个附录不涉及FP在并发方面的应用，如不可变性、引用透明性、无副作用函数和惰性评估。相反，它涵盖了关于FP是什么以及为什么你应该关心它的基本信息。
- en: What is functional programming?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: FP means different things to different people. It’s a program paradigm that
    treats a computation as an evaluation of an expression. A *paradigm* in science
    describes distinct concepts or thought patterns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FP对不同的人意味着不同的事情。它是一种将计算视为表达式评估的程序范式。科学中的*范式*描述了不同的概念或思维模式。
- en: FP involves using state and mutable data to solve domain problems, and it’s
    based on lambda calculus. Consequently, functions are *first-class values*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FP涉及使用状态和可变数据来解决领域问题，它基于λ演算。因此，函数是*一等值*。
- en: 'FP is a programming style that reasons in terms of evaluation of expressions
    versus the execution of a statement. The term *expression* comes from mathematics;
    an expression is always returning a result (value) without mutating the program
    state. A *statement* doesn’t return anything and can change the program state:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: FP是一种编程风格，它通过评估表达式与执行语句之间的推理来进行。术语*表达式*来自数学；表达式总是返回一个结果（值），而不改变程序状态。一个*语句*不返回任何内容，并且可以改变程序状态：
- en: '*Execution of statements* refers to a program expressed as a sequence of commands
    or statements. Commands specify how to achieve an end result by creating objects
    and manipulating them.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语句执行*指的是将程序表达为一系列命令或语句。命令指定如何通过创建对象和操作它们来实现最终结果。'
- en: '*Evaluation of expressions* refers to how a program specifies object properties
    that you want to get as result. You don’t specify the steps necessary to construct
    the object, and you can’t accidentally use the object before it’s created.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表达式评估*指的是程序如何指定你想要作为结果获取的对象属性。你不需要指定构建对象所需的步骤，并且不能在对象创建之前意外地使用该对象。'
- en: The benefits of functional programming
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程的好处
- en: 'Here’s a list of the benefits of FP:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是FP（函数式编程）的好处列表：
- en: '*Composability and modularity*—With the introduction of pure functions, you
    can compose functions and create higher-level abstractions from simple functions.
    Using modules, the program can be organized in a better way. Composability is
    the most powerful tool to defeat complexity; it lets you define and build solutions
    for complex problems.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可组合性和模块化*——通过引入纯函数，你可以组合函数并从简单函数中创建高级抽象。使用模块，程序可以以更好的方式组织。可组合性是战胜复杂性的最有力的工具；它让你能够定义和构建复杂问题的解决方案。'
- en: '*Expressiveness*—You can express complex ideas in a succinct and declarative
    format, improving the clarity of the intention and ability to reason about your
    program and reducing code complexity.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表达性*——你可以用简洁和声明性的格式表达复杂的思想，提高意图的清晰度和对程序进行推理的能力，并减少代码复杂性。'
- en: '*Reliability and testing*—Functions exist without side effects; a function
    only evaluates and returns a value that depends on its arguments. Therefore, you
    can examine a function by focusing solely on its arguments, which allows for better
    testing to easily validate the correctness of your code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可靠性和测试*—函数不存在副作用；一个函数只评估并返回一个依赖于其参数的值。因此，你可以通过仅关注其参数来检查函数，这允许进行更好的测试，以便轻松验证代码的正确性。'
- en: '*Easier concurrency*—Concurrency encourages referential transparency and immutability,
    which are the primary keys for writing correct, lock-free concurrent applications
    to run effectively on multiple cores.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更易并发的实现*—并发鼓励引用透明性和不可变性，这是在多个核心上有效运行正确、无锁的并发应用程序的主要关键。'
- en: '*Lazy evaluation*—You can retrieve the result of the function on demand. Suppose
    you have a big data stream to analyze. Thanks to LINQ, you can use deferred execution
    and lazy evaluation to process your data analysis on demand (only when needed).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*惰性评估*—你可以按需检索函数的结果。假设你有一个大数据流要分析。多亏了LINQ，你可以使用延迟执行和惰性评估按需（仅在需要时）处理你的数据分析。'
- en: '*Productivity*—This is an enormous benefit: you can write fewer lines of code
    while achieving the same implementation as other paradigms. Productivity reduces
    the time it takes to develop programs, which can translate to a larger profit
    margin.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产力*—这是一个巨大的好处：你可以用更少的代码行数实现与其他范式相同的功能。生产力减少了开发程序所需的时间，这可以转化为更大的利润空间。'
- en: '*Correctness*—You can write less code, naturally reducing the possible number
    of bugs.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正确性*—你可以编写更少的代码，自然地减少可能出现的错误数量。'
- en: '*Maintainability*—This benefit results from the other benefits, such as the
    code being composable, modular, expressive, and correct.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*——这种好处来自于其他好处，例如代码可组合、模块化、表达性强和正确。'
- en: Learning to program functionally leads to more modular, expression-oriented,
    conceptually simple code. The combinations of these FP assets let you understand
    what your code is doing, regardless of how many threads it’s executing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 学习函数式编程将导致代码更加模块化、面向表达式、概念简单。这些函数式编程资产的组合让你能够理解你的代码正在做什么，无论它正在执行多少线程。
- en: The tenets of functional programming
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程的原则
- en: 'There are four main tenets to FP that lead to a composable and declarative
    programming style:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）有四个主要原则，这些原则导致了一种可组合和声明式的编程风格：
- en: Higher-order functions (HOFs) as first-class values
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数（HOFs）作为一等值
- en: Immutability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变性
- en: Pure functions, also known as side-effect-free functions
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数，也称为无副作用函数
- en: Declarative programming style
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式编程风格
- en: 'The clash of program paradigms: from imperative to object-oriented to functional
    programming'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序范式的冲突：从命令式到面向对象再到函数式编程
- en: Object-oriented programming makes code understandable by encapsulating moving
    parts. Functional programming makes code understandable by minimizing moving parts.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面向对象编程通过封装移动部分使代码易于理解。函数式编程通过最小化移动部分来使代码易于理解。
- en: —Michael Feathers, author of *Working with Legacy Code*, via Twitter
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: —迈克尔·费思，著有《与遗留代码一起工作》，通过推特
- en: 'This section describes three programming paradigms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了三种编程范式：
- en: '*Imperative programming* describes computations in terms of statements that
    change the program’s state and define the sequence of commands to perform. Therefore,
    an imperative paradigm is a style that computes a series of statements to mutate
    a state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令式编程*通过改变程序状态和定义执行命令的顺序来描述计算。因此，命令式范式是一种通过计算一系列语句来改变状态的风格。'
- en: '*Functional programming* builds the structures and elements of a program by
    treating computations as the evaluation of expressions; therefore, FP promotes
    immutability and avoids state.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式编程*通过将计算视为表达式的评估来构建程序的结构和元素；因此，FP促进不可变性和避免状态。'
- en: '*Object-oriented programming* (OOP) organizes objects rather than actions,
    and its data structures contain data rather than logic. The main programming paradigms
    can be distinguished between imperative and functional. OOP is orthogonal to imperative
    and functional programming, in the sense that it can be combined with both. You
    don’t have to prefer one paradigm over another, but you can write software with
    an OOP style using functional or imperative concepts.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象编程*（OOP）组织对象而不是动作，其数据结构包含数据而不是逻辑。主要的编程范式可以分为命令式和函数式。OOP与命令式和函数式编程是正交的，这意味着它可以与两者结合使用。你不必偏好一种范式而牺牲另一种，但你可以使用函数式或命令式概念编写具有OOP风格的软件。'
- en: OOP has been around for almost two decades, and its design principles were used
    by languages such as Java, C#, and VB.Net. OOP has had great success because of
    its ability to represent and model the user domain, raising the level of abstraction.
    The primary idea behind the introduction of OOP languages was code reusability,
    but this idea is often corrupted by modifications and customizations required
    for specific scenarios and ad hoc objects. OOP programs developed with low coupling
    and good code reusability felt like a complex maze, with many secret and convoluted
    passages reducing code readability.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）已经存在了近二十年，其设计原则被Java、C#和VB.Net等语言所采用。OOP之所以取得巨大成功，是因为它能够表示和模拟用户域，提高了抽象级别。OOP语言引入背后的主要思想是代码复用性，但这一思想常常被特定场景和临时对象所需的修改和定制所扭曲。使用低耦合和良好代码复用性开发的OOP程序就像一个复杂的迷宫，有许多秘密和复杂的通道，降低了代码的可读性。
- en: To mitigate this hard-to-achieve code reusability, developers started to create
    design patterns to address OOP’s cumbersome nature. Design patterns encouraged
    developers to tailor software around the patterns, making the code base more complex,
    difficult to understand, and, in certain cases, maintainable but still far from
    reusable. In OOP, design patterns are useful when defining solutions to recurring
    design problems, but they can be considered a defect of abstraction in the language
    itself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种难以实现的代码复用性，开发者开始创建设计模式来应对面向对象编程（OOP）繁琐的本质。设计模式鼓励开发者根据模式定制软件，使得代码库更加复杂、难以理解，并且在某些情况下，尽管可维护但仍然远未达到可复用的程度。在OOP中，设计模式在定义解决重复设计问题时是有用的，但它们可以被视为语言本身抽象的缺陷。
- en: In FP, design patterns have a different meaning; in fact, most of the OOP-specific
    design patterns are unnecessary in functional languages because of the higher
    level of abstraction and HOFs used as building blocks. The higher level of abstraction
    and reduced workload around the low-level details in FP style has the advantage
    of producing shorter programs. When the program is small, it’s easier to understand,
    improve, and verify. FP has fantastic support for code reuse and for reducing
    repetitive code, which is the most effective way to write code that’s less prone
    to error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，设计模式有不同的含义；实际上，由于抽象级别更高以及作为构建块使用的高阶函数，大多数特定于OOP的设计模式在函数式语言中都是不必要的。FP风格中更高的抽象级别和围绕低级细节的减少工作量具有产生更短程序的优势。当程序变得小的时候，它更容易理解、改进和验证。FP对代码复用和减少重复代码有出色的支持，这是编写更少出错代码的最有效方式。
- en: Higher-order functions for increasing abstraction
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于提高抽象级别的高阶函数
- en: 'The principle of an HOF means that functions can be passed as arguments to
    other functions, and functions can return different functions within their return
    values. .NET has the concept of generic delegates, such as `Action<T>` and `Func<T,
    TResult>`, which can be used as HOFs to pass functions as parameters with lambda
    support. Here’s an example of using the generic delegate `Func<T,R>` in C#:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HOF的原则意味着函数可以作为参数传递给其他函数，并且函数可以在它们的返回值中返回不同的函数。.NET有泛型委托的概念，如`Action<T>`和`Func<T,
    TResult>`，可以用作HOF来传递带有lambda支持的函数作为参数。以下是在C#中使用泛型委托`Func<T,R>`的示例：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The equivalent code can be represented in F# with function semantics, without
    the need to use the `Func<T, TResult>` delegate explicitly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的代码可以用F#中的函数语义来表示，无需显式使用`Func<T, TResult>`委托：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'HOFs are at the core of harnessing the power of FP. HOFs have the following
    benefits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HOFs（高阶函数）是利用FP（函数式编程）力量的核心。HOFs具有以下优势：
- en: Composition and modularity
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和模块化
- en: Code reusability
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复用性
- en: Ability to create highly dynamic and adaptable systems
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建高度动态和适应性的系统
- en: 'Functions in FP are considered first-class values, meaning that functions can
    be named by variables, can be assigned to variables, and can appear anywhere that
    any other language constructs can appear. If you’re coming from a straight OOP
    experience, this concept allows you to use functions in a non-canonical way, such
    as applying relatively generic operations to standard data structures. HOFs let
    you focus on results, not steps. This is a fundamental and powerful shift in approaching
    functional languages. Different functional techniques allow you to achieve functional
    composition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，函数被视为一等值，这意味着函数可以被变量命名，可以被分配给变量，并且可以出现在任何其他语言构造可以出现的地方。如果你来自直接的面向对象（OOP）经验，这个概念允许你以非规范的方式使用函数，例如将相对通用的操作应用于标准数据结构。高阶函数（HOFs）让你专注于结果，而不是步骤。这是在处理函数式语言时的一个基本且强大的转变。不同的函数式技术允许你实现函数式组合：
- en: Composition
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Currying
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化
- en: Partially applied functions or partial applications
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用函数或部分应用
- en: 'The power of using delegates leads to express functionality that targets not
    only methods that do one thing, but also behavioral engines that you can enhance,
    reuse, and extend. This kind of programming style, which is at the root of the
    functional paradigm, has the benefit of reducing the amount of code refactoring:
    instead of having several specialized and rigid methods, the program can be expressed
    by fewer but much more general and reusable methods that can be amplified to handle
    multiple and different scenarios.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用委托的强大功能可以表达针对不仅执行单一操作的方法，还可以增强、重用和扩展的行为引擎的功能。这种编程风格是函数范式的基础，其优点是减少了代码重构的数量：而不是拥有多个专用且僵化的方法，程序可以通过更少但更通用和可重用的方法来表示，这些方法可以扩展以处理多个和不同的场景。
- en: HOFs and lambda expressions for code reusability
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高阶函数和 lambda 表达式用于代码重用
- en: 'One of the many useful reasons for using lambda expressions is to refactor
    the code, reducing redundancy. It’s good practice in memory-managed languages
    such as C# to dispose of resources deterministically when possible. Consider the
    following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式的一个许多有用的原因是为了重构代码，减少冗余。在像 C# 这样的内存管理语言中，尽可能确定性地释放资源是一种良好的实践。考虑以下示例：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, the `StreamReader` resource is disposed with the `using` keyword.
    This is a well-known pattern, but limitations do exist. The pattern isn’t reusable
    because the disposable variable is declared inside the using scope, making it
    impossible to reuse after it’s disposed, and it generates exceptions if it calls
    the disposed objects. Refactoring the code in a classic OOP style is no trivial
    task. It’s possible to use a template method pattern, but this solution also introduces
    more complexity with the need for a new base class and implementation for each
    derived class. A better and more elegant solution is to use a lambda expression
    (anonymous delegate). Here’s the code to implement the static helper method and
    its use:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`StreamReader` 资源通过 `using` 关键字进行释放。这是一个众所周知的模式，但存在局限性。由于可释放变量是在 `using`
    范围内声明的，因此该模式不可重用，一旦释放后便无法重用，并且如果它调用已释放的对象，会引发异常。以经典面向对象（OOP）风格重构代码并非易事。可以使用模板方法模式，但这种解决方案也引入了更多复杂性，需要为每个派生类创建新的基类和实现。一个更好且更优雅的解决方案是使用
    lambda 表达式（匿名委托）。以下是实现静态辅助方法及其使用的代码：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code implements a flexible and reusable pattern for cleaning up disposable
    resources. Here the only constraint is that the generic type `T` must be a type
    that implements `IDisposable`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码实现了一个灵活且可重用的清理可释放资源的模式。这里唯一的约束是泛型类型 `T` 必须是实现 `IDisposable` 的类型。
- en: Lambda expressions and anonymous functions
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 表达式和匿名函数
- en: The term *lambda* or *lambda expression* most often refers to anonymous functions.
    The intention behind a lambda expression is to express computations based on a
    function, using variable binding and substitution. In simpler terms, a lambda
    expression is an unnamed method written in place of a delegate instance that introduces
    the notion of *anonymous functions*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *lambda* 或 *lambda 表达式* 最常指匿名函数。lambda 表达式的目的是基于函数表达计算，使用变量绑定和替换。用更简单的话说，lambda
    表达式是替代委托实例的无名方法，引入了 *匿名函数* 的概念。
- en: Lambda expressions raise the level of abstraction to simplify the programming
    experience. Functional languages such as F# are based on lambda calculus, which
    is used to express computations on function abstractions; therefore, a lambda
    expression is part of the FP language. In C#, however, the main motivation for
    introducing lambdas is to facilitate streaming abstractions that enable stream-based
    declarative APIs. Such abstraction presents an accessible and natural path to
    multicore parallelism, making lambda expressions a valuable tool in the domain
    of current computing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式提高了抽象级别，从而简化了编程体验。基于 Lambda 演算的函数式语言，如 F#，用于表达对函数抽象的计算；因此，Lambda 表达式是
    FP 语言的一部分。然而，在 C# 中，引入 Lambda 的主要动机是促进基于流的抽象，这使基于声明的 API 成为可能。这种抽象提供了一条通往多核并行处理的自然路径，使
    Lambda 表达式成为当前计算领域的一个宝贵工具。
- en: To create a lambda expression, you specify input parameters (if any) on the
    left side of the lambda operator `=>` (pronounced “goes to”), and you put the
    expression or statement block on the right side. For example, the lambda expression
    `(x, y) => x + y` specifies two parameters `x` and `y` and returns the sum of
    these values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Lambda 表达式，您需要在 Lambda 操作符 `=>`（发音为“goes to”）的左侧指定输入参数（如果有），并将表达式或语句块放在右侧。例如，Lambda
    表达式 `(x, y) => x + y` 指定了两个参数 `x` 和 `y`，并返回这些值的总和。
- en: 'Each lambda expression has three parts:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Lambda 表达式有三个部分：
- en: '`(x, y)` —A set of parameters.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(x, y)` — 一组参数。'
- en: '`=>` —The goes to operator (`=>)` that separates an argument list from the
    result expression.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=>` — 分隔参数列表和结果表达式的“goes to”运算符（`=>`）。'
- en: '`x + y` —A set of statements that perform an action or return a value. In this
    example, the lambda expression returns the sum of `x` and `y`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x + y` — 一组执行操作或返回值的语句。在这个例子中，Lambda 表达式返回 `x` 和 `y` 的总和。'
- en: 'Here’s how you implement three lambda expressions with the same behavior:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现具有相同行为的三个 Lambda 表达式：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The part `Func<int, int, int>` defines a function that takes two integers and
    returns a new integer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func<int, int, int>` 这一部分定义了一个函数，它接受两个整数并返回一个新的整数。'
- en: 'In F#, the strong type system can bind a name or label to a function without
    an explicit declaration. F# functions are primitive values, similar to integers
    and strings. It’s possible to translate the previous function into the equivalent
    F# syntax as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，强类型系统可以在没有显式声明的情况下将名称或标签绑定到函数。F# 函数是原始值，类似于整数和字符串。可以将前面的函数翻译成等效的 F# 语法，如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In F#, the *plus* (+) operator is a function that has the same signature as
    *add,* which takes two numbers and returns the sum as a result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，`*plus*`（+）运算符是一个与 `*add*` 具有相同签名的函数，它接受两个数字并返回它们的和作为结果。
- en: 'Lambda expressions are a simple and effective solution to assign and execute
    a block of inline code, especially in an instance when the block of code serves
    one specific purpose and you don’t need to define it as a method. There are numerous
    advantages for introducing lambda expressions into your code. Here is a short
    list:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是一种简单而有效的解决方案，用于分配和执行一段内联代码块，尤其是在代码块仅服务于特定目的且不需要将其定义为方法的情况下。将 Lambda
    表达式引入代码中有许多优点。以下是一个简短的列表：
- en: You don’t need explicit parameterization of types; the compiler can figure out
    the parameter types.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要对类型进行显式参数化；编译器可以确定参数类型。
- en: Succinct inline coding (the functions exist within the line) avoids disruptions
    caused when developers must look elsewhere in the code to find functionality.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁的内联编码（函数存在于行内）避免了开发者必须在其他地方查找功能时造成的干扰。
- en: Captured variables limit the exposure of class-level variables.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获变量限制了类级别变量的暴露。
- en: Lambda expressions make the code flow readable and understandable.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式使代码的流程易于阅读和理解。
- en: Currying
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Currying
- en: The term *currying* originates from Haskell Curry, a mathematician who was an
    important influence on the development of FP. *Currying* is a technique that lets
    you modularize functions and reuse code. The basic idea is to transform the evaluation
    of a function that takes multiple parameters into the evaluation of a sequence
    of functions, each with a single parameter. Functional languages are closely related
    to mathematical concepts, where functions can have only one parameter. F# follows
    this concept because functions with multiple parameters are declared as a series
    of new functions, each with only one parameter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “柯里化”这个术语起源于 Haskell Curry，他是函数式编程发展的重要影响者，一位数学家。柯里化是一种让你模块化函数和重用代码的技术。基本思想是将接受多个参数的函数的评估转换为一系列函数的评估，每个函数只有一个参数。函数式语言与数学概念密切相关，其中函数只能有一个参数。F#
    遵循这一概念，因为具有多个参数的函数被声明为一系列新函数，每个函数只有一个参数。
- en: In practice, the other .NET languages have functions with more than one argument;
    and from the OOP perspective, if you don’t pass into a function all the arguments
    expected, the compiler throws an exception. Conversely, in FP it’s extremely easy
    to write a curried function that returns any function you give it. But as previously
    mentioned, lambda expressions provide a great syntax for creating anonymous delegates,
    thereby making it easy to implement a curried function. Moreover, it’s possible
    to implement currying in any programming language that supports closure—an interesting
    concept because this technique simplifies lambda expressions, including only single-parameter
    functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，其他 .NET 语言具有具有多个参数的函数；从面向对象的角度来看，如果你没有传递给函数所有期望的参数，编译器会抛出异常。相反，在函数式编程（FP）中，编写一个返回任何你给出的函数的柯里化函数非常容易。但如前所述，lambda
    表达式提供了创建匿名委托的出色语法，从而使得实现柯里化函数变得简单。此外，在支持闭包的任何编程语言中都可以实现柯里化——这是一个有趣的概念，因为这种技术简化了
    lambda 表达式，包括只有单个参数的函数。
- en: The currying technique makes it possible to treat all functions with one or
    any number of arguments as if they take only one argument, independent of the
    number of arguments needed to execute. This creates a chain of functions where
    each consumes a single parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化技术使得可以将所有具有一个或多个参数的函数视为只接受一个参数，而不考虑执行所需的参数数量。这创建了一个函数链，其中每个函数只消耗一个参数。
- en: At the end of this chain of functions, all parameters are available at once,
    which allows the original function to execute. Moreover, currying allows you to
    create specialized groups of functions generated from fixing the arguments of
    a base function. For instance, when you curry a function of two arguments and
    apply it to the first argument, then the functionality is limited by one dimension.
    This isn’t a limitation but a powerful technique, because then you can apply the
    new function to the second argument to compute a particular value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数链的末尾，所有参数都一次性可用，这使得原始函数可以执行。此外，柯里化允许你创建由固定基函数参数生成的专用函数组。例如，当你对一个具有两个参数的函数进行柯里化并将其应用到第一个参数时，功能被限制在一维。这不是限制，而是一种强大的技术，因为然后你可以将新函数应用到第二个参数来计算特定的值。
- en: 'In mathematic notation, an important difference exists between these two functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学符号中，这两个函数之间存在一个重要的区别：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The difference is that the first function takes a single argument of type `tuple`
    (composed by the three items `x`, `y`, and `z`), and the second function takes
    the input item `x` and returns a function that takes the input item `y`, which
    returns a function that takes item `z` and then returns the result of the final
    computation. In simpler words, the equivalent function can be rewritten as
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于第一个函数接受一个类型为 `tuple` 的单个参数（由三个项目 `x`、`y` 和 `z` 组成），而第二个函数接受输入项 `x` 并返回一个接受输入项
    `y` 的函数，该函数返回一个接受项目 `z` 的函数，然后返回最终计算的结果。用更简单的话说，等效函数可以重写为
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s important to mention that function applications are left associative, taking
    one argument at a time. The previous function `Add` is an application against
    `x`, and the result is then applied to `y`. The result of this application `((Add
    x) y)` is then applied to `z`. Because each of these transitional steps yields
    a function, it’s perfectly acceptable to define a function as
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，函数应用是左结合的，一次只接受一个参数。之前的函数 `Add` 是对 `x` 的应用，然后结果被应用到 `y` 上。这个应用的结果 `((Add
    x) y)` 然后被应用到 `z` 上。因为每个过渡步骤都产生一个函数，所以定义一个函数如下是完全可行的
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function is equivalent to `Add x`. In this case, you can expect the function
    `Plus2` to take two input arguments, and it always passes 2 as a fixed parameter.
    For clarity, it’s possible to rewrite the previous function as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数等同于`Add x`。在这种情况下，你可以期待函数`Plus2`接受两个输入参数，并且它总是传递2作为固定参数。为了清晰起见，可以将前面的函数重写如下：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The process of yielding intermediate functions (each taking one input argument)
    is called *currying*. Let’s see currying in action. Consider the following simple
    C# function that uses a lambda expression:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 产生中间函数（每个函数接受一个输入参数）的过程称为*柯里化*。让我们看看柯里化的实际应用。考虑以下使用lambda表达式的简单C#函数：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code defines the function `Func<int, int, int> add`, which takes two integers
    as arguments and returns an integer as a result. When this function is called,
    the compiler requires both arguments `x` and `y`. But the curried version of the
    function `add`, `curried­Add`, results in a delegate with the special signature
    `Func<int,Fun< int, int>>.`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个函数`Func<int, int, int> add`，它接受两个整数作为参数并返回一个整数。当调用此函数时，编译器需要两个参数`x`和`y`。但函数`add`的柯里化版本`curried­Add`导致一个具有特殊签名`Func<int,Fun<
    int, int>>`的委托。
- en: 'In general, any delegate of type `Func<A,B,R>` can be transformed into a delegate
    of type `Func<A, Func<B,R>>`. This curried function takes only one argument and
    returns a function that takes the original function as an argument and then returns
    a value of type `A`. The curried function `curriedAdd` can be used to create powerful
    specialized functions. For example, you can define an `increment` function by
    adding the value 1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何类型为`Func<A,B,R>`的委托都可以转换为类型为`Func<A, Func<B,R>>`的委托。这个柯里化函数只接受一个参数，并返回一个函数，该函数接受原始函数作为参数，然后返回类型为`A`的值。柯里化函数`curriedAdd`可以用来创建强大的专用函数。例如，你可以通过添加值1来定义一个`increment`函数：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can use this function to define other functions that perform several
    forms of addition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个函数来定义其他执行多种形式的加法操作的函数：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One benefit of currying a function is that the creation of specialized functions
    is easier to reuse; but the real power is that curried functions introduce a useful
    concept called *partially applied functions*, which is covered in the next section.
    Additional benefits of the currying technique are function parameter reduction
    and easy-to-reuse abstract functions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数柯里化的一个好处是创建专用函数更容易重用；但真正的力量在于柯里化函数引入了一个有用的概念，称为*部分应用函数*，这在下一节中会介绍。柯里化技术的其他好处包括函数参数减少和易于重用的抽象函数。
- en: Automatic currying in C#
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C#中的自动柯里化
- en: 'It’s possible to automate and raise the level of abstraction of the currying
    technique in C# with the help of extension methods. In this example, the purpose
    of the curry extension method is to introduce syntactic sugar to hide the currying
    implementation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法可以在C#中自动化并提高柯里化技术的抽象级别。在这个例子中，curry扩展方法的目的是通过引入语法糖来隐藏柯里化实现：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the previous code refactored using the helper extension method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用辅助扩展方法重构的代码：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This syntax looks more succinct. It’s important to notice that the compiler
    can infer the types used in all the functions and, for this, it’s most helpful.
    In fact, even though `Curry` is a generic function, it’s not required to pass
    generic parameters explicitly. Using this currying technique lets you use a different
    syntax that’s more conducive to building a library of complex composite functions
    from simple functions. The source code, which you can download as part of the
    resources for this book, has a library that contains a full implementation of
    helper methods, including an extension method for automatic currying.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法看起来更简洁。重要的是要注意，编译器可以推断出所有函数中使用的类型，并且这对于这一点非常有帮助。事实上，尽管`Curry`是一个泛型函数，但不需要显式传递泛型参数。使用这种柯里化技术让你可以使用不同的语法，这更有利于从简单函数构建复杂复合函数的库。你可以作为本书资源的部分下载的源代码中包含了一个包含完整辅助方法实现的库，包括自动柯里化的扩展方法。
- en: Un-currying
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消柯里化
- en: As easily as applying the curry technique to a function, you can un-curry a
    function by using higher-order functions to revert the curried function. Un-currying is,
    obviously, the opposite transformation to currying. Think of un-currying as a
    technique to undo currying by applying a generic un-curry function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像将柯里化技术应用于一个函数一样，你可以通过使用高阶函数来逆转柯里化函数，从而取消柯里化一个函数。显然，取消柯里化是柯里化的相反转换。将取消柯里化视为通过应用通用的取消柯里化函数来撤销柯里化的技术。
- en: 'In the following example, the curried function with signature `Func<A, Func<B,
    R>>` will be converted back to a multi-argument function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，具有签名`Func<A, Func<B, R>>`的柯里化函数将被转换回一个多参数函数：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The primary purpose of un-currying a function is to bring the signature of a
    curried function back into a more OOP style.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数去柯里化的主要目的是将柯里化函数的签名转换回更面向对象（OOP）的风格。
- en: Currying in F#
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: F#中的柯里化
- en: In F#, function declarations are curried by default. But even though this is
    done automatically by the compiler for you, it’s helpful to understand how F#
    handles curried functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，函数声明默认是柯里化的。尽管这是编译器为你自动完成的，但了解F#如何处理柯里化函数是有帮助的。
- en: 'The following example shows two F# functions that multiply two values. If you’re
    not familiar with F#, these functions may seem equivalent or at least similar,
    but they aren’t:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了两个F#函数，它们用于乘以两个值。如果你不熟悉F#，这些函数可能看起来等效或至少相似，但它们并不相同：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Besides the syntax, no apparent difference exists between these functions, but
    they behave differently. The first function has only one parameter, which is a
    tuple with the required values, but the second function has two distinct parameters
    `x` and `y.`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法之外，这些函数之间没有明显的差异，但它们的行为不同。第一个函数只有一个参数，它是一个包含所需值的元组，但第二个函数有两个不同的参数`x`和`y`。
- en: 'The difference becomes clear when you look into the signatures of these functions’
    declarations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这些函数声明的签名时，差异变得明显：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now it’s obvious that these functions are different. The first function takes
    a tuple as an input argument and returns an integer. The second function takes
    an integer as its first input and returns a function that takes an integer as
    input and then returns an integer. This second function, which takes two arguments,
    is transformed automatically by the compiler into a chain of functions, each with
    one input argument.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，这些函数是不同的。第一个函数接受一个元组作为输入参数并返回一个整数。第二个函数接受一个整数作为其第一个输入，并返回一个接受整数作为输入并返回整数的函数。这个接受两个参数的第二个函数被编译器自动转换成一系列函数，每个函数有一个输入参数。
- en: 'This example shows the equivalent curried functions, which is how the compiler
    interprets it for you:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了等效的柯里化函数，这是编译器为你解释的方式：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In F#, the implementation of these functions is equivalent because, as previously
    mentioned, they’re curried by default. The main purpose of currying is to optimize
    a function for easily applying partial application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，这些函数的实现是等效的，因为，如前所述，它们默认是柯里化的。柯里化的主要目的是为了优化函数，以便更容易地进行部分应用。
- en: Partially applied functions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: The *partially applied function* (or partial function application) is a technique
    of fixing multiple arguments to a function and producing another function of smaller
    arity (the *arity* of a function is the number of its arguments). In this way,
    a partial function provides a function with fewer arguments than expected, which
    produces a specialized function for the given values. Partially applied functions,
    in addition to function composition, make functional modularization possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分应用函数*（或部分函数应用）是将多个参数固定到函数中并产生另一个较小阶数（函数的*阶数*是它的参数数量）的函数的技术。通过这种方式，部分函数提供了一个比预期更少的参数的函数，为给定的值产生一个专门的函数。除了函数组合外，部分应用函数还使函数模块化成为可能。'
- en: More simply, a partial function application is a process of binding values to
    parameters, which means that partially applied functions are functions that reduce
    the number of function arguments by using fixed (default) values. If you have
    a function with `N` arguments, it’s possible to create a function with `N-1` arguments
    that calls the original function with a fixed argument. Because partial application
    depends on currying, the two techniques occur together. The difference between
    partial application and currying is that partial application binds more than one
    parameter to a value, so to evaluate the rest of the function you need to apply
    the remaining arguments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单地说，部分函数应用是一个将值绑定到参数的过程，这意味着部分应用函数是通过使用固定（默认）值来减少函数参数数量的函数。如果你有一个具有`N`个参数的函数，你可以创建一个具有`N-1`个参数的函数，该函数使用固定参数调用原始函数。因为部分应用依赖于柯里化，所以这两种技术同时发生。部分应用与柯里化的区别在于，部分应用将多个参数绑定到一个值上，因此要评估函数的其余部分，你需要应用剩余的参数。
- en: 'In general, partial application transforms a generic function into a new and
    specialized function. Let’s take the C# curried function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，部分应用将一个通用函数转换为一个新且专门的函数。让我们以 C# 的柯里化函数为例：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How can you create a new function with a single argument?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何创建一个单参数的新函数？
- en: 'This is the case where partial function application becomes useful, because
    you can partially apply a function against an HOF with a default value for the
    first argument to the original function. Here’s the extension method that can
    be used to partially apply a function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，部分函数应用变得有用，因为你可以对原始函数的第一个参数应用一个默认值来部分应用一个函数到一个高阶函数 (HOF)。以下是可以用来部分应用函数的扩展方法：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here’s an example to exercise this technique:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个练习这种技术的例子：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Math.Max(int,int)`is an example of a function that can be extended with partially
    applied functions. Introducing a partially applied function in this case, the
    default argument `5` is fixed, and it creates a new specialized function `max5`
    that evaluates the maximum value between two numbers with a default of `5`. Thanks
    to partial application, you created a new and more specific function out of an
    existing one.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.Max(int, int)` 是一个可以通过部分应用函数进行扩展的函数示例。在这种情况下引入部分应用函数，默认参数 `5` 被固定，它创建了一个新的专用函数
    `max5`，该函数在两个数字之间评估最大值，默认为 `5`。多亏了部分应用，你从一个现有的函数中创建了一个新的、更具体的函数。'
- en: From an OOP perspective, think of partial function applications as a way to
    override functions. It’s also possible to use this technique to extend on-the-fly
    functionality of a third-party library that isn’t extensible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从面向对象的角度来看，将部分函数应用视为覆盖函数的一种方式。还可以使用这种技术来扩展第三方库的即时功能，该库本身不可扩展。
- en: 'As mentioned, in F# functions are curried by default, which leads to an easier
    way to create partial functions than in C#. Partial function applications have
    many benefits, including the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 F# 中函数默认是柯里化的，这比在 C# 中创建部分函数更容易。部分函数应用有许多好处，包括以下内容：
- en: They allow functions to be composed without hesitation.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许函数在没有犹豫的情况下被组合。
- en: They alleviate the need to pass a separate set of parameters, by avoiding building
    unnecessary classes that contain override versions of same method with a different
    number of inputs.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过避免构建包含具有不同输入数量重写版本的同一种方法的不必要类，减轻了传递一组单独参数的需求。
- en: They enable the developer to write highly general functions by parameterizing
    their behavior.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使开发者能够通过参数化其行为来编写高度通用的函数。
- en: The practical benefit of using partial function applications is that functions
    constructed by supplying only a portion of the argument are good for code reusability,
    functional extensibility, and composition. Moreover, partially applied functions
    simplify the use of HOFs in your programming style. Partial function application
    can also be deferred for performance improvement, which was introduced in section
    2.6.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部分函数应用的实际好处是，只提供部分参数构建的函数有利于代码重用、功能扩展性和组合。此外，部分应用函数简化了在编程风格中使用高阶函数。部分函数应用还可以延迟以改进性能，这在第
    2.6 节中介绍过。
- en: Power of partial function application and currying in C#
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 中部分函数应用和柯里化的力量
- en: Let’s consider a more complete example of partial function application and currying
    that can cover a real-use scenario. `Retry` in [Listing A.1](#listingA.1) is an
    extension method for a delegate `Func<T>` for any function that takes no parameters
    and returns a value of type `T`. The purpose of this method is to execute the
    incoming function in a `try-catch` block, and if an exception is thrown while
    executing, the function will retry the operation up to a maximum of three times.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更完整的部分函数应用和柯里化的例子，它可以涵盖实际使用场景。`Retry` 在 [列表 A.1](#listingA.1) 中是一个为任何无参数且返回类型为
    `T` 的函数的 `Func<T>` 委托的扩展方法。此方法的目的是在 `try-catch` 块中执行传入的函数，如果在执行过程中抛出异常，则函数将重试操作，最多重试三次。
- en: '[Listing A.1](#listinganchorA.1) `Retry` extension method in C#'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 A.1](#listinganchorA.1) 中的 `Retry` 扩展方法'
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s say that this method tries to read text from a file. In the following
    code, the method `ReadText` accepts a file path as input and returns the text
    from a file. To execute the functionality with the attached `Retry` behavior to
    fall back on and recover in case of issues, you can use a closure, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这种方法试图从文件中读取文本。在下面的代码中，方法`ReadText`接受一个文件路径作为输入并返回文件中的文本。为了执行带有附加的`Retry`行为的功能，以便在出现问题时回退并恢复，你可以使用闭包，如下所示：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can use a lambda expression to capture the local variable `filePath` and
    pass it into the method `ReadText`. This process lets you create a `Func<string>`
    that matches the signature of the `Retry` extension method, which can be attached.
    If the file is blocked or owned by another process, an error is thrown, and the
    `Retry` functionality kicks in as expected. If the first call fails, the method
    will retry a second time and a third time. Finally, it returns the default value
    of `T`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用lambda表达式捕获局部变量`filePath`并将其传递给`ReadText`方法。这个过程让你可以创建一个与`Retry`扩展方法的签名匹配的`Func<string>`，并将其附加。如果文件被阻塞或被另一个进程拥有，将抛出错误，并且`Retry`功能将按预期启动。如果第一次调用失败，该方法将第二次和第三次重试。最后，它返回类型`T`的默认值。
- en: 'This works, but you might wonder what happens if you want to retry a function
    that needs a string parameter. The solution is to partially apply the function.
    The following code implements a function that takes a string as a parameter, which
    is the file path to read the text from, and then it passes that parameter to the
    `ReadText` method. The `Retry` behavior only works with functions that take no
    parameters, so the code doesn’t compile:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，但你可能会想知道如果你想要重试一个需要字符串参数的函数会发生什么。解决方案是部分应用该函数。下面的代码实现了一个接受字符串参数的函数，该参数是从中读取文本的文件路径，然后将其传递给`ReadText`方法。由于`Retry`行为只适用于不接受参数的函数，所以代码无法编译：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The behavior of `Retry` doesn’t work with this version of `readText`. One possible
    solution is to write another version of the `Retry` method that takes an additional
    generic-­type parameter that specifies the type of the parameter you need to pass
    once invoked. This isn’t ideal, because you have to figure out how to share this
    new `Retry` logic across all the methods using it, each with different arguments
    or implementations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retry`的行为不适用于这个版本的`readText`。一个可能的解决方案是编写另一个版本的`Retry`方法，该方法接受一个额外的泛型类型参数，该参数指定了在调用时需要传递的参数类型。这不是最佳选择，因为你必须弄清楚如何将这种新的`Retry`逻辑共享到所有使用它的方法中，每个方法都有不同的参数或实现。'
- en: A better option is to use and combine currying and partial function application.
    In the following listing, the helper methods `Curry` and `Partial` are defined
    as extension methods.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是使用并组合柯里化和部分函数应用。在下面的列表中，辅助方法`Curry`和`Partial`被定义为扩展方法。
- en: Listing A.2 `Retry` helper extensions in C#
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 C#中的`Retry`辅助扩展
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This approach lets you inject the file path and use the `Retry` function smoothly.
    This is possible because both helper functions, `Partial` and `Curry`, adapt the
    function `readText` into a function that doesn’t need a parameter, ultimately
    matching the signature of `Retry`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让你可以注入文件路径并平滑地使用`Retry`函数。这是因为辅助函数`Partial`和`Curry`都将`readText`函数转换为一个不需要参数的函数，最终与`Retry`的签名相匹配。
