- en: 10 Directory tree
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 目录树
- en: Of all the programming tasks, I’m embarrassed to admit that I enjoy coding file
    utilities the most. The casual user is unaware of the mountain of information
    about files provided by the operating system. It’s highly detailed low-hanging
    fruit, eager for plucking. Plus, exploring files and directories opens your understanding
    of how computer storage works. Exploring this field may inspire you to write your
    own interesting file utilities. If it doesn’t, you can keep reading this chapter—your
    introduction to filesystems and storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有编程任务中，我羞于承认我最喜欢编写文件实用程序。普通用户不知道操作系统提供的关于文件的大量信息。这些信息非常详细，触手可及，渴望被摘取。此外，探索文件和目录可以打开你对计算机存储工作原理的理解。探索这个领域可能会激发你编写自己有趣的文件实用程序。如果不行，你可以继续阅读本章——这是你对文件系统和存储的入门。
- en: 'The goal here is to create a directory tree program. The output shows subdirectories
    as they sit in the hierarchical filesystem. In addition to being exposed to the
    word *hierarchical* (which I can amazingly both spell and type), in this chapter
    you learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是创建一个目录树程序。输出显示了子目录在分层文件系统中的位置。除了接触到单词 *hierarchical*（我竟然能神奇地既拼对又打出来）之外，在本章中你还将学习如何：
- en: Examine information about a file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查文件信息
- en: Decipher file modes and permissions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码文件模式和权限
- en: Read a directory entry
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取目录条目
- en: Use recursion to explore the directory structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归来探索目录结构
- en: Extract a directory name from a full pathname
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从完整路径名中提取目录名
- en: Output a directory tree
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出目录树
- en: Avoid confusing the word *hierarchical* with *hieroglyphical*
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将单词 *hierarchical* 与 *hieroglyphical* 混淆
- en: Before diving into the details, be aware that GUI nomenclature prefers the term
    *folder* over *directory*. As a C programmer, you must use the term *directory*,
    not *folder*. All C functions that deal with files and directories use *directory*
    or contain the abbreviation “dir.” Don’t wimp out and use the term *folder*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解细节之前，请注意，GUI术语更喜欢使用术语 *folder* 而不是 *directory*。作为一名C程序员，你必须使用术语 *directory*，而不是
    *folder*。所有处理文件和目录的C函数都使用 *directory* 或包含缩写“dir。”不要退缩，使用术语 *folder*。
- en: The point of the directory tree utility is to output a map of the directory
    structure. The map details which directories are parents and children of each
    other. Unlike years ago, today’s directory structures are busy with lots of organization.
    Users are more attentive when it comes to saving files. Programs are geared toward
    this type of organization and provide hints to help users employ the subdirectory
    concept.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目录树实用程序的目的在于输出目录结构的地图。地图详细说明了哪些目录是彼此的父目录和子目录。与多年前相比，今天的目录结构充满了许多组织。当涉及到保存文件时，用户更加关注。程序针对这种类型的组织，并提供提示以帮助用户使用子目录概念。
- en: Even if a directory map seems trivial, the process of exploring the directory
    tree lends itself well to other handy disk utilities. For example, chapter 11
    covers a file-finding utility, which relies heavily upon the information presented
    in this chapter to make the utility truly useful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使目录地图看似微不足道，探索目录树的过程非常适合其他有用的磁盘实用程序。例如，第11章涵盖了文件查找实用程序，它严重依赖于本章提供的信息，以使实用程序真正有用。
- en: 10.1 The filesystem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 文件系统
- en: At the core of all media storage lies the filesystem. The *filesystem* describes
    the way data is stored on media, how files are accessed, and various nerdy tidbits
    about the files themselves.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有媒体存储的核心是文件系统。*文件系统*描述了数据在媒体上的存储方式，如何访问文件，以及关于文件本身的许多技术细节。
- en: 'The only time most users deal with the filesystem concept is when formatting
    media. Choosing a filesystem is part of the formatting process, because it determines
    how the media is formatted and which protocols to follow. This step is necessary
    for compatibility: not every filesystem is compatible with every computer operating
    system. Therefore, the user is allowed to select a filesystem for the media’s
    format to allow for sharing between operating systems, such as Linux and PC or
    Macintosh.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户唯一一次处理文件系统概念的情况是在格式化媒体时。选择文件系统是格式化过程的一部分，因为它决定了媒体如何格式化以及需要遵循哪些协议。这一步对于兼容性是必要的：并非每个文件系统都与每个计算机操作系统兼容。因此，用户可以选择媒体格式所用的文件系统，以便在操作系统之间进行共享，例如Linux和PC或Macintosh。
- en: The filesystem’s duty is to organize storage. It takes a file’s data and writes
    it to one or more locations on the media. This information is recorded along with
    other file details, such as the file’s name, size, dates (created, modified, accessed),
    permissions, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的职责是组织存储。它将文件的数据写入媒体的一个或多个位置。这些信息与其他文件详细信息（如文件名、大小、日期（创建、修改、访问）、权限等）一起记录。
- en: Some of the file details are readily obtainable through existing utilities or
    from various C library functions. But most of the mechanics of the filesystem
    are geared toward saving, retrieving, and updating the file’s data lurking on
    the media. All this action takes place automatically under the supervision of
    the operating system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件详细信息可以通过现有实用程序或各种 C 库函数轻松获取。但大多数文件系统的机制都是针对在媒体上保存、检索和更新文件数据的。所有这些操作都在操作系统的监督下自动进行。
- en: The good news for most coders is that it isn’t necessary to know the minutiae
    of how files are stored on media. Even if you go full nerd and understand the
    subtle differences between the various filesystems and can tout the benefits of
    the High Performance File System (HPFS) at nerd cocktail parties, the level of
    media access required to manipulate a filesystem requires privileges above where
    typical C programs operate. Functions are available for exploring a file’s details.
    These functions are introduced in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数程序员来说，好消息是无需了解文件在媒体上存储的细节。即使你完全成为技术宅，理解各种文件系统之间的细微差别，并在技术聚会上吹嘘高性能文件系统（HPFS）的好处，但操作文件系统所需的媒体访问级别超出了典型
    C 程序操作的范围。有函数可用于探索文件的详细信息。这些函数将在下一节中介绍。
- en: Aside from knowing the names and perhaps a few details on how filesystems work,
    if you’re curious, you can use common tools on your computer to see which filesystems
    are in use. In a Linux terminal window, use the **man fs** command to review details
    on how Linux uses a filesystem and the different filesystems available. The /proc/filesystems
    directory lists available filesystems for your Linux installation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了了解文件系统的名称以及可能的一些关于文件系统工作方式的细节外，如果您好奇，可以使用计算机上的常用工具来查看正在使用哪些文件系统。在 Linux 终端窗口中，使用
    **man fs** 命令查看 Linux 如何使用文件系统以及可用的不同文件系统。/proc/filesystems 目录列出了您的 Linux 安装中可用的文件系统。
- en: 'Windows keeps its filesystem information tucked away in the Disk Management
    console. To access this window, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 将其文件系统信息隐藏在磁盘管理控制台中。要访问此窗口，请按照以下步骤操作：
- en: Tap the Windows key on the keyboard to open the Start menu.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下键盘上的 Windows 键以打开开始菜单。
- en: Type **Disk Management**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**磁盘管理**。
- en: From the list of search results, choose Create and Format Hard Disk Partitions.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从搜索结果列表中，选择创建和格式化硬盘分区。
- en: Figure 10.1 shows the Disk Management console from one of my Windows computers.
    Available media is presented in the table, with the File System column listing
    the filesystems used; only NTFS is shown in the figure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 展示了我的一台 Windows 电脑上的磁盘管理控制台。可用媒体以表格形式呈现，其中文件系统列列出了所使用的文件系统；图中只显示了 NTFS。
- en: '![10-01](Images/10-01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![10-01](Images/10-01.png)'
- en: Figure 10.1 The Disk Management console reveals the filesystem used to format
    media available to the PC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 磁盘管理控制台显示了 PC 可用媒体所使用的文件系统。
- en: 'On the Macintosh, you can use the Disk Utility to browse available media to
    learn which filesystem is in use. This app is found in the Utilities directory:
    in the Finder, click Go > Utilities to view the directory and access the Disk
    Utility app.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Macintosh 上，您可以使用磁盘实用程序浏览可用媒体以了解正在使用哪种文件系统。此应用程序位于实用程序目录中：在 Finder 中，点击“前往”>“实用程序”以查看目录并访问磁盘实用程序应用程序。
- en: If it were easy or necessary to program a filesystem, I’d explore the topic
    further. For now, understand that the filesystem is the host for data stored on
    media in a computer. A program such as a directory tree uses the filesystem, but
    in C, such a utility doesn’t need to know details about the filesystem type to
    do its job.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编写文件系统既容易又必要，我会进一步探讨这个主题。目前，请理解文件系统是计算机中存储在媒体上的数据的宿主。例如，目录树程序使用文件系统，但在 C 语言中，此类实用程序无需了解文件系统类型即可完成其工作。
- en: 10.2 File and directory details
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 文件和目录详细信息
- en: 'To gather directory details at the command prompt, use the ls command. It’s
    available in all shells, dating back to the first, prehistoric version of Unix
    used by the ancient Greeks, when the command was known as λσ. The output is a
    list of filenames in the current directory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令提示符下收集目录详细信息，请使用ls命令。它在所有shell中都有，可以追溯到古希腊人使用的第一个史前Unix版本，当时该命令被称为λσ。输出是当前目录中文件名的列表：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For more detail, the -l (long) switch is specified:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多详细信息，请指定-l（长）开关：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This output shows details about each file, its permissions, ownership, size,
    date, and other trivia you can use to intimidate your computer illiterate pals.
    It’s not secret stuff; the details output by the ls -l command are stored in the
    directory like a database. In fact, directories on storage media are really databases.
    Their records aren’t specifically files, but rather inodes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了每个文件的详细信息，包括权限、所有权、大小、日期以及其他你可以用来吓唬那些电脑文盲朋友的琐事。这不是秘密信息；ls -l 命令输出的详细信息就像数据库一样存储在目录中。实际上，存储介质上的目录真的是数据库。它们的记录不是特定的文件，而是inode。
- en: An *inode* is not an Apple product. No, it’s a collection of data that describes
    a file. Although your C programs can’t readily access low-level filesystem details,
    you can easily examine a file’s inode data. The inode’s name is the same as the
    file’s name. But beyond the name, the inode contains oodles of details about the
    file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*inode* 不是一个苹果产品。不，它是一组描述文件的数据集合。尽管你的C程序不能轻易访问低级文件系统细节，但你可以轻松检查文件inode数据。inode的名称与文件名相同。但除了名称之外，inode还包含大量关于文件的详细信息。'
- en: 10.2.1 Gathering file info
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 收集文件信息
- en: 'To obtain details about a file, as well as to read a directory, you need to
    access inode data. The command-line program that does so is called *stat*. Here’s
    some sample output on the *stat* program file fileinfo:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取文件详细信息以及读取目录，你需要访问inode数据。执行此操作的命令行程序称为 *stat*。以下是在 *stat* 程序文件 fileinfo
    上的部分输出示例：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These details are stored in the directory database. In fact, part of the output
    shows the file’s inode number: 11258999068563657\. Of course, the name fileinfo
    is far easier to use as a reference.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些详细信息存储在目录数据库中。实际上，输出的一部分显示了文件的inode编号：11258999068563657\. 当然，fileinfo这个名字作为参考要容易得多。
- en: 'To read this same information in your C programs, you use the *stat()* function.
    It’s prototyped in the sys/stat.h header file. Here is the *man* page format:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的C程序中读取相同的信息，你使用 *stat()* 函数。它在 sys/stat.h 头文件中声明。以下是 *man* 页面格式：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The pathname is a filename or a full pathname. Argument statbuf is the address
    of a stat structure. Here’s a typical stat() function statement, with the filename
    char pointer containing the filename, fs as a stat structure, and int variable
    r capturing the return value:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名是一个文件名或完整路径名。statbuf参数是stat结构的地址。以下是一个典型的stat()函数语句，其中包含文件名char指针、fs作为stat结构，以及int变量r捕获返回值：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Upon failure, value -1 is returned. Otherwise, 0 is returned and the stat structure
    fs is joyously filled with details about the file—inode data. Table 10.1 lists
    the common members of the stat structure, though different filesystems and operating
    systems add or change specific members.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下，返回值是-1。否则，返回0，并且stat结构fs充满有关文件的详细信息——inode数据。表10.1列出了stat结构的常见成员，尽管不同的文件系统和操作系统可能会添加或更改特定成员。
- en: Table 10.1 Members in the *stat()* function’s statbuf structure
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 *stat()*函数的statbuf结构成员
- en: '| Member | Data type (placeholder) | Detail |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 数据类型（占位符） | 详细信息 |'
- en: '| st_dev | dev_t (%lu) | ID of the media (device) containing the file |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| st_dev | dev_t (%lu) | 包含文件的媒体（设备）ID |'
- en: '| st_ino | ino_t (%lu) | Inode number |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| st_ino | ino_t (%lu) | Inode编号 |'
- en: '| st_mode | mode_t (%u) | File type, mode, permissions |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| st_mode | mode_t (%u) | 文件类型、模式、权限 |'
- en: '| st_nlink | nlink_t (%lu) | Number of links |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| st_nlink | nlink_t (%lu) | 链接数量 |'
- en: '| st_uid | uid_t (%u) | Owner’s user ID |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| st_uid | uid_t (%u) | 文件所有者的用户ID |'
- en: '| st_gid | gid_t (%u) | Group’s user ID |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| st_gid | gid_t (%u) | 组的用户ID |'
- en: '| st_rdev | dev_t (%lu) | Special file type’s device ID |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| st_rdev | dev_t (%lu) | 特殊文件类型的设备ID |'
- en: '| st_size | off_t (%lu) | File size in bytes |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| st_size | off_t (%lu) | 文件大小（字节） |'
- en: '| st_blksize | blksize_t (%lu) | Filesystem’s block size |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| st_blksize | blksize_t (%lu) | 文件系统的块大小 |'
- en: '| st_blocks | blkcnt_t (%lu) | File blocks allocated (512-byte blocks) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| st_blocks | blkcnt_t (%lu) | 分配的文件块（512字节块） |'
- en: '| st_atime | struct timespec | Time file last accessed |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| st_atime | struct timespec | 文件最后访问时间 |'
- en: '| st_mtime | struct timespec | Time file last modified |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| st_mtime | struct timespec | 文件最后修改时间 |'
- en: '| st_ctime | struct timespec | Time file status last changed |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| st_ctime | struct timespec | 文件状态最后更改的时间 |'
- en: Most of the stat structure members are integers; I’ve specified the *printf()*
    placeholder type in table 10.1\. They’re all *unsigned*, though some values are
    *unsigned long*. Watch out for the *long unsigned* values because the compiler
    bemoans using the incorrect placeholder to represent these values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数stat结构体成员都是整数；我在表10.1中指定了*printf()*占位符类型。它们都是*unsigned*，尽管一些值是*unsigned long*。注意*long
    unsigned*值，因为编译器会哀叹使用不正确的占位符来表示这些值。
- en: 'The timespec structure is accessed as a *time_t* pointer. It contains two members:
    tv_sec and tv_nsec for seconds and nanoseconds, respectively. An example of using
    the *ctime()* function to access this structure is shown later.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: The timespec结构体作为*time_t*指针访问。它包含两个成员：tv_sec和tv_nsec，分别代表秒和纳秒。稍后将会展示如何使用*ctime()*函数访问这个结构体的示例。
- en: The following listing shows a sample program, fileinfo01.c, that outputs file
    (or inode) details. Each of the stat structure members is accessed for a file
    supplied as a command-line argument. Most of the code consists of error-checking—for
    example, to confirm that a filename argument is supplied and to check on the return
    status of the *stat()* function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了一个示例程序，fileinfo01.c，该程序输出文件（或inode）的详细信息。stat结构体的每个成员都会访问作为命令行参数提供的文件。大部分代码都是错误检查——例如，确认是否提供了文件名参数，并检查*stat()*函数的返回状态。
- en: Listing 10.1 Source code for fileinfo01.c
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 文件info01.c的源代码
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The filename is supplied as a program argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 文件名作为程序参数提供。
- en: ❷ Confirms the first argument
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确认第一个参数
- en: ❸ Referring to the argument using char pointer filename aids readability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用字符指针filename引用参数有助于提高可读性。
- en: ❹ Calls the *stat()* function
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用*stat()*函数
- en: ❺ Checks for an error
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查错误
- en: ❻ Outputs the members of the stat structure fs
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出stat结构体fs的成员
- en: ❼ The time structures use the *ctime()* function to output their values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 时间结构使用*ctime()*函数输出它们的值。
- en: 'The information output by the fileinfo01.c program mirrors what the command-line
    stat utility coughs up. Here’s a sample run on the same file, fileinfo, this code’s
    program:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: fileinfo01.c程序输出的信息与命令行stat实用工具输出的信息相匹配。以下是在同一文件fileinfo上运行此代码程序的示例输出：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The details are the same as for the *stat* command’s output shown earlier in
    this section. The *stat* command does look up the Device ID, Owner ID, and Group
    ID details, which your code could do as well. But one curious item is structure
    member st_mode, the type and mode value. The value shown in the output above is
    33279\. This integer value contains a lot of details—bit fields—which you see
    interpreted in the *stat* command’s output. Your code can also examine this value
    to determine the file type and its permissions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节与本章前面展示的*stat*命令的输出相同。*stat*命令确实会查找设备ID、所有者ID和组ID的详细信息，你的代码也可以做到这一点。但有一个有趣的项目是结构成员st_mode，类型和模式值。上面输出显示的值是33279。这个整数值包含了很多细节——位字段，你可以在*stat*命令的输出中看到这些细节的解释。你的代码也可以检查这个值以确定文件类型及其权限。
- en: 10.2.2 Exploring file type and permissions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 探索文件类型和权限
- en: Examining a file’s (or inode’s) st_mode value is how you determine whether a
    file is a regular old file, a directory, or some other special type of file. Remember
    that in the Linux environment, everything is a file. Using the *stat()* function
    is how your code can determine which type of file the inode represents.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件（或inode）的st_mode值是确定文件是普通文件、目录或其他特殊类型文件的方法。记住，在Linux环境中，一切都是文件。使用*stat()*函数是确定inode表示哪种类型文件的方法。
- en: The bit fields in the st_mode member of the stat structure also describe the
    file’s permissions. Though you could code a series of complex bitwise logical
    operations to ferret out the specific details contained in the st_mode value’s
    bits, I recommend that you use instead the handy macros available in the sys/stat.h
    header file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: stat结构体中st_mode成员的位字段也描述了文件的权限。虽然你可以编写一系列复杂的位运算逻辑操作来找出st_mode值位中的具体细节，但我建议你使用sys/stat.h头文件中可用的便捷宏。
- en: 'For example, the S_ISREG() macro returns TRUE for regular files. To update
    the fileinfo01.c code to test for regular files, add the following statements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，S_ISREG()宏对于普通文件返回TRUE。为了更新fileinfo01.c代码以测试普通文件，添加以下语句：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the S_ISREG() test on the fs.st_mode variable returns TRUE, the *printf()*
    statement belonging to the *if* statement outputs text confirming that the file
    is regular. The *else* condition handles other types of files, such as directories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果fs.st_mode变量上的S_ISREG()测试返回TRUE，则属于*if*语句的*printf()*语句会输出确认文件是常规文件的文本。*else*条件处理其他类型的文件，例如目录。
- en: 'In my update to the code, fieinfo02.c (available in the online archive), I
    removed all the *printf()* statements from the original code. The five statements
    shown earlier replace the original printf() statements, because the focus of this
    update is to determine file type. Here’s sample output on the fileinfo02.c source
    code file itself:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对代码的更新中，从在线存档中可获得的fieinfo02.c，我移除了原始代码中的所有*printf()*语句。前面显示的五个语句替换了原始的printf()语句，因为这次更新的重点是确定文件类型。以下是关于fileinfo02.c源代码文件的示例输出：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If I instead specify the single dot (.), representing the current directory,
    I see this output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我指定单个点（.），代表当前目录，我会看到以下输出：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the output above, the st_mode value changes as well as the return value
    from the S_ISREG() macro; a directory isn’t a regular file. In fact, you can test
    for directories specifically by using the S_ISDIR() macro:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，st_mode值以及S_ISREG()宏的返回值都会发生变化；目录不是常规文件。实际上，你可以通过使用S_ISDIR()宏来专门测试目录：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’ve made these modifications and additions to the code in fileinfo02.c, with
    the improvements saved in fileinfo03.c, available in this book’s online repository.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经对文件info02.c中的代码进行了这些修改和添加，改进后的代码保存在fileinfo03.c中，可在本书的在线仓库中找到。
- en: Further modifications to the code are possible by using the full slate of file
    mode macros, listed in table 10.2\. These are the common macros, though your C
    compiler and operating system may offer more. Use these macros to identify files
    by their type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用文件模式宏的全套，在代码中进行进一步的修改，这些宏列在表10.2中。这些是常见的宏，尽管你的C编译器和操作系统可能提供更多。使用这些宏通过文件类型来识别文件。
- en: Table 10.2 Macros defined in sys/stat.h to help determine file type
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2 sys/stat.h中定义的宏，用于帮助确定文件类型
- en: '| Macro | True for this type of file |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 宏 | 对此类文件为真 |'
- en: '| S_ISBLK() | Block special, such as mass storage in the /dev directory |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| S_ISBLK() | 块特殊设备，例如/dev目录中的大容量存储 |'
- en: '| S_ISCHR() | Character special, such as a pipe or the /dev/null device |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| S_ISCHR() | 字符特殊设备，例如管道或/dev/null设备 |'
- en: '| S_ISDIR() | Directories |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| S_ISDIR() | 目录 |'
- en: '| S_ISFIFO() | A FIFO (named pipe) or socket |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| S_ISFIFO() | FIFO（命名管道）或套接字 |'
- en: '| S_ISREG() | Regular files |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| S_ISREG() | 常规文件 |'
- en: '| S_ISLNK() | Symbolic link |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| S_ISLNK() | 符号链接 |'
- en: '| S_ISSOCK() | Socket |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| S_ISSOCK() | 套接字 |'
- en: 'File type details aren’t the only information contained in the st_mode member
    of the stat structure. This value also reveals the file’s permissions. File permissions
    refer to access bits that determine who-can-do-what to a file. Three access bits,
    called an octet, are available:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型细节并不是stat结构体中st_mode成员包含的唯一信息。此值还揭示了文件的权限。文件权限是指确定谁可以做什么的访问位。有三个访问位，称为八进制位，是可用的：
- en: Read (r)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取（r）
- en: Write (w)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入（w）
- en: Execute (x)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行（x）
- en: 'Read permission means that the file is accessed read-only: the file’s data
    can be read but not modified. Write permission allows the file to be read and
    written to. Execute permission is set for program files, such as your C programs
    (set automatically by the compiler or linker), shell scripts (set manually), and
    directories. This is all standard Linux stuff, so if you desire more information,
    hunt down a grim, poorly written book on Linux for specifics.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 读取权限意味着文件以只读方式访问：可以读取文件的数据但不能修改。写入权限允许读取和写入文件。执行权限用于程序文件，例如你的C程序（由编译器或链接器自动设置），shell脚本（手动设置）和目录。这些都是标准的Linux内容，所以如果你需要更多信息，可以查找一本关于Linux的糟糕书籍以获取详细信息。
- en: 'In Linux, the *chmod* command sets and resets file permissions. These permissions
    can be seen in the long listing of a file when using the *ls* command with the
    -l (little L) switch:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，*chmod*命令设置和重置文件权限。这些权限可以在使用带有-l（小写的L）开关的*ls*命令的文件的长列表中看到：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first chunk of info, -rwxrwxrwx, indicates the file type and permissions,
    which are detailed in figure 10.2\. Next is the number of hard links (1), the
    owner (dang), and the group (dang). The value 8,464 is the file size in bytes,
    and then comes the date and time stamp, and finally the filename.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分信息，-rwxrwxrwx，表示文件类型和权限，这些在图10.2中有详细说明。接下来是硬链接数（1），所有者（dang）和组（dang）。值8,464是字节数，然后是日期和时间戳，最后是文件名。
- en: '![10-02](Images/10-02.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![10-02](Images/10-02.png)'
- en: Figure 10.2 Deciphering file permission bits in a long directory listing
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 在长目录列表中解码文件权限位
- en: 'Three sets of file permissions octets are used for a file. These sets are based
    on user classification:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文件使用三组文件权限八进制值。这些集合基于用户分类：
- en: Owner
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者
- en: Group
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组
- en: Other
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他
- en: You are the owner of the files you create. As a user on the computer, you are
    also a member of a group. Use the *id* command to view your username and ID number,
    as well as the groups you belong to (names and IDs). View the /etc/group file
    to see the full list of groups on the system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你是所创建文件的拥有者。作为计算机上的用户，你也是某个组的成员。使用 *id* 命令查看你的用户名和 ID 号，以及你所属的组（名称和 ID）。查看 /etc/group
    文件以查看系统上的完整组列表。
- en: File owners grant themselves full access to their files. Setting group permissions
    is one way to grant access to a bunch of system users at once. The third field,
    other, applies to anyone who is not the owner or in the named group.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件所有者授予自己对其文件的完全访问权限。设置组权限是一次性授予多个系统用户访问权限的一种方法。第三个字段，其他，适用于不是所有者或不在指定组中的任何人。
- en: In the long directory listing, a file’s owner and group appear as shown earlier.
    This value is interpreted from the st_mode member of the file’s stat structure.
    As with obtaining the file’s type, you can use defined constants and macros available
    in the sys/stat.h header file to test for the permissions for each user classification.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在长目录列表中，文件的所有者和组如前所述显示。此值是从文件的 stat 结构的 st_mode 成员中解释的。与获取文件类型一样，你可以使用 sys/stat.h
    头文件中可用的定义常量和宏来测试每个用户分类的权限。
- en: 'I count nine permission-defined constants available in sys/stat.h, which accounts
    for each permission octet (three) and the three permission types: read, write,
    and execute. These are shown in table 10.3.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我计算了 sys/stat.h 中可用的九个权限定义常量，这涵盖了每个权限八进制值（三个）和三种权限类型：读、写和执行。这些在表 10.3 中显示。
- en: Table 10.3 Defined constants used for permissions, available from the sys/stat.h
    header file
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3 用于权限的 sys/stat.h 头文件中定义的常量
- en: '| Defined constant | Permission octet |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 定义常量 | 权限八进制值 |'
- en: '| S_IRUSR | Owner read permission |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| S_IRUSR | 拥有者读权限 |'
- en: '| S_IWUSR | Owner write permission |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| S_IWUSR | 拥有者写权限 |'
- en: '| S_IXUSR | Owner execute permission |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| S_IXUSR | 拥有者执行权限 |'
- en: '| S_IRGRP | Group read permission |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| S_IRGRP | 组读权限 |'
- en: '| S_IWGRP | Group write permission |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| S_IWGRP | 组写权限 |'
- en: '| S_IXGRP | Group execute permission |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| S_IXGRP | 组执行权限 |'
- en: '| S_IROTH | Other read permission |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| S_IROTH | 其他读权限 |'
- en: '| S_IWOTH | Other write permission |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| S_IWOTH | 其他写权限 |'
- en: '| S_IXOTH | Other execute permission |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| S_IXOTH | 其他执行权限 |'
- en: 'The good news is that these defined constants follow a naming pattern: each
    defined constant starts with S_I. The I is followed by R, W, or X for read, write,
    or execute, respectively. This letter is followed by USR, GRP, OTH for Owner (user),
    Group, and Other. This naming convention is summarized in figure 10.3.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是这些定义的常量遵循一个命名模式：每个定义的常量都以 S_I 开头。I 后面跟着 R、W 或 X，分别代表读、写或执行。这个字母后面跟着 USR、GRP、OTH，分别代表拥有者（用户）、组和其他。这种命名约定总结在图
    10.3 中。
- en: '![10-03](Images/10-03.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![10-03](Images/10-03.png)'
- en: Figure 10.3 The naming convention used for permission defined constants in sys/stat.h
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 sys/stat.h 中定义的权限常量的命名约定
- en: 'For example, if you want to test the read permission for a group user, you
    use the S_IRGRP defined constant: S_I plus R for read and GRP for group. This
    defined constant is used in an *if* test with a bitwise AND operator to test the
    permission bit on the st_mode member:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想测试组用户的读权限，你使用 S_IRGRP 定义常量：S_I 加 R 代表读，GRP 代表组。这个定义常量用于与位运算符进行 *if* 测试，以测试
    st_mode 成员上的权限位：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value in fs_st_mode (the file’s mode, including type and permissions) is
    tested against the bit in the S_IRGRP defined constant. If the test is true, meaning
    the bit is set, the file has read-only permissions set for the “other” group.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: fs_st_mode（文件的模式，包括类型和权限）中的值与 S_IRGRP 定义常量中的位进行比较。如果测试为真，意味着位被设置，则文件为“其他”组设置了只读权限。
- en: Listing 10.2 puts the testing macros and defined constants to work for a file
    supplied as a command-line argument. This update to the *fileinfo* series of programs
    outputs the file type and permissions for the named file. An *if else-if else*
    structure handles the different file types as listed in table 10.2\. Three sets
    of *if* tests output permissions for the three different groups. You see all the
    macros and defined constants discussed in this section used in the code. The code
    appears lengthy, but it contains a lot of copied and pasted information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 使用测试宏和定义的常量为命令行参数提供的文件工作。这个更新版本的 *fileinfo* 系列程序输出指定文件的文件类型和权限。一个 *if
    else-if else* 结构处理表 10.2 中列出的不同文件类型。三组 *if* 测试输出三个不同组的权限。你看到本节中讨论的所有宏和定义的常量都在代码中使用。代码看起来很长，但它包含了很多复制粘贴的信息。
- en: Listing 10.2 Source code for fileinfo04.c
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 fileinfo04.c 的源代码
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ New stuff starts here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新内容从这里开始。
- en: ❷ Determines the file type, a long *if-else* structure
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确定文件类型，一个长的 *if-else* 结构
- en: ❸ Tests owner permission bits
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试所有者权限位
- en: ❹ Tests group permission bits
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试组权限位
- en: ❺ Tests other permission bits
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 测试其他权限位
- en: 'The program I created from the source code shown in listing 10.2 is named a.out,
    the default. Here is a sample run on the original *fileinfo* program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我从列表 10.2 中的源代码创建的程序命名为 a.out，这是默认的。以下是原始 *fileinfo* 程序的示例运行：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The information shown here corresponds to an ls -l listing output of -rwxrwxrwx.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的信息对应于 ls -l 列表输出的 -rwxrwxrwx。
- en: 'Here is the output for system directory /etc:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是系统目录 /etc 的输出：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From this output, the file type is correctly identified as a directory. The
    owner permissions are rwx (the owner is root). The group and other permissions
    are r-x, which means anyone on the computer can read and access (execute) the
    directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，文件类型被正确地识别为目录。所有者权限是 rwx（所有者是root）。组和其它权限是 r-x，这意味着计算机上的任何人都可以读取和访问（执行）目录。
- en: Exercise 10.1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1
- en: The *if-else* structures in listing 10.2 (fileinfo04.c) contain a lot of repetition.
    Seeing repetitive statements in code cries out to me for a function. Your task
    for this exercise is to a write a function that outputs a file’s permissions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2（fileinfo04.c）中的 *if-else* 结构包含了很多重复。看到代码中的重复语句，我强烈建议使用一个函数。这个练习的任务是编写一个输出文件权限的函数。
- en: 'Call the function *permissions_out()*. It takes a *mode_t* argument of the
    st_mode member in a stat structure. Here is the prototype:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数 *permissions_out()*。它接受一个 *mode_t* 参数，该参数是 stat 结构中的 st_mode 成员。以下是原型：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the function to output a string of permissions for each of the three access
    levels: owner, group, other. Use characters r, w, x, for read, write, and execute
    access if a bit is set; use a dash (-) for unset items. This output is the same
    as shown in the ls -l listing, but without the leading character identifying the
    file type.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数输出三个访问级别（所有者、组、其它）的权限字符串。如果设置了位，使用字符 r、w、x 表示读取、写入和执行访问；对于未设置的项目，使用破折号
    (-)。这个输出与 ls -l 列表显示的相同，但没有标识文件类型的开头字符。
- en: A simple approach exists for this function, and I hope you find it. If not,
    you can view my solution in the source code file fileinfo05.c, available in the
    online repository. Please try this exercise on your own before peeking at my solution;
    comments in my code explain my philosophy. Use the *fileinfo* series of programs
    to perform the basic operations for the *stat()* function, if you prefer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，存在一个简单的方法，我希望你能找到它。如果找不到，你可以在源代码文件 fileinfo05.c 中查看我的解决方案，该文件可在在线仓库中找到。请在查看我的解决方案之前自己尝试这个练习；我的代码中的注释解释了我的哲学。如果你更喜欢，可以使用
    *fileinfo* 系列程序来执行 *stat()* 函数的基本操作。
- en: 10.2.3 Reading a directory
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 阅读目录
- en: 'A directory is a database of files, but call them inodes if you want to have
    a nerd find you attractive. Just like a file, a directory database is stored on
    media. But you can’t use the *fopen()* function to open and read the contents
    of a directory. No, instead you use the *opendir()* function. Here is its *man*
    page format:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 目录是一个文件数据库，但如果你想吸引一个书呆子，你可以称它们为inode。就像文件一样，目录数据库存储在媒体上。但是你不能使用 *fopen()* 函数来打开和读取目录的内容。不，相反，你使用
    *opendir()* 函数。以下是它的 *man* 页面格式：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The *opendir()* function accepts a single argument, a string representing the
    pathname of the directory to examine. Specifying the shortcuts . and .. for the
    current and parent directory are also valid.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*opendir()* 函数接受一个单一参数，一个表示要检查的目录路径名的字符串。指定当前目录和父目录的快捷方式 . 和 .. 也是有效的。'
- en: The function returns a pointer to a *DIR* handle, similar to the *FILE* handle
    used by the *fopen()* command. As the *FILE* handle represents a file stream,
    the *DIR* handle represents a directory stream.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个指向 *DIR* 处理句柄的指针，类似于 *fopen()* 命令使用的 *FILE* 处理句柄。由于 *FILE* 处理句柄代表一个文件流，*DIR*
    处理句柄代表一个目录流。
- en: Upon an error, the NULL pointer is returned. The global errno value is set,
    indicating the specific booboo the function encountered.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 发生错误时，返回 NULL 指针。全局 errno 值被设置，指示函数遇到的具体错误。
- en: 'The *opendir()* function features a companion *closedir()* function, similar
    to the *fclose()* function as a companion to *fopen()*. The *closedir()* function
    requires a single argument, the *DIR* handle of an open directory stream, humorously
    called “dirp” in the *man* page format example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*opendir()* 函数有一个配套的 *closedir()* 函数，类似于 *fclose()* 函数是 *fopen()* 的配套。*closedir()*
    函数需要一个参数，即打开的目录流的 *DIR* 处理句柄，在 *man* 页面格式示例中幽默地称为“dirp”：'
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes, I know that the internet spells it “derp.”
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道互联网上拼作“derp”。
- en: Upon success, the *closedir()* function returns 0\. Otherwise, the value -1
    is returned and the global errno variable is set, yadda-yadda.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*closedir()* 函数返回 0。否则，返回值 -1，并设置全局 errno 变量，等等。
- en: Both the *opendir()* and *closedir()* functions are prototyped in the dirent.h
    header file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*opendir()* 和 *closedir()* 函数都在 dirent.h 头文件中进行了原型声明。'
- en: In the following listing, you see both the *opendir()* and *closedir()* functions
    put to work. The current directory "." is opened because it’s always valid.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，你可以看到 *opendir()* 和 *closedir()* 函数被投入使用。当前目录 "." 被打开，因为它始终有效。
- en: Listing 10.3 Source code for readdir01.c
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 readdir01.c 的源代码
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Directory handle
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 目录句柄
- en: ❷ Opens the current directory, whatever it may be
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打开当前目录，无论是什么目录
- en: ❸ Exits the program upon failure to open
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打开失败时退出程序
- en: ❹ And just closes it back up
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 然后将其关闭
- en: 'The code in listing 10.3 merely opens and closes the current directory. Boring!
    To access the files stored in the directory, you use another function, *readdir()*.
    This function is also prototyped in the dirent.h header file. Here is the *man*
    page format:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 中的代码只是打开和关闭当前目录。无聊！要访问目录中存储的文件，你使用另一个函数，*readdir()*。这个函数也在 dirent.h
    头文件中进行了原型声明。以下是 *man* 页面格式：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function consumes an open *DIR* handle as its only argument. The return
    value is the address of a dirent structure, which contains details about a directory
    entry. This function is called repeatedly to read file entries (inodes) from the
    directory stream. The value NULL is returned after the final entry in the directory
    has been read.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个打开的 *DIR* 处理句柄作为其唯一参数。返回值是 dirent 结构的地址，其中包含有关目录条目的详细信息。这个函数被反复调用以从目录流中读取文件条目（inode）。在读取目录中的最后一个条目后，返回
    NULL 值。
- en: Sadly, the dirent structure isn’t as rich as I’d like it to be. Table 10.4 lists
    the two consistent structure members, though some C libraries offer more members.
    Any extra members are specific to the compiler or operating system and shouldn’t
    be relied on for code you plan to release into the wild. The only two required
    members for the POSIX.1 standard are d_ino for the entry’s inode and d_name for
    the entry’s filename.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，dirent 结构不像我希望的那样丰富。表 10.4 列出了两个一致的成员，尽管一些 C 库提供了更多成员。任何额外的成员都是特定于编译器或操作系统的，不应依赖于你计划发布到野外的代码。POSIX.1
    标准仅要求两个必需的成员：d_ino 用于条目的 inode 和 d_name 用于条目的文件名。
- en: Table 10.4 Common members of the dirent structure
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.4 dirent 结构的常见成员
- en: '| Member | Data type (placeholder) | Description |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 数据类型（占位符） | 描述 |'
- en: '| d_ino | *ino_t* (%lu) | Inode number |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| d_ino | *ino_t* (%lu) | Inode 编号 |'
- en: '| d_reclen | *unsigned short* (%u) | Record length |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| d_reclen | *unsigned short* (%u) | 记录长度 |'
- en: The best structure member to use, and one that’s consistently available across
    all compilers and platforms, is d_name. This member is used in the source code
    for readdir02.c, shown in the next listing. This update to readdir01.c removes
    two silly *puts()* statements. Added is a *readdir()* statement, along with a
    *printf()* function to output the name of the first file found in the current
    directory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的结构成员是 d_name，它在所有编译器和平台上都一致可用。这个成员在 readdir02.c 的源代码中使用，如下一列表所示。对 readdir01.c
    的这次更新删除了两个愚蠢的 *puts()* 语句。添加了一个 *readdir()* 语句，以及一个 *printf()* 函数来输出当前目录中找到的第一个文件的名称。
- en: Listing 10.4 Source code for readdir02.c
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 readdir02.c 的源代码
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ The dirent structure is created as a pointer, a memory address.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ dirent 结构被创建为一个指针，一个内存地址。
- en: ❷ The entry is read and stored in the dirent structure entry.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 该条目被读取并存储在dirent结构体中的entry成员。
- en: ❸ The d_name member is output.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出d_name成员。
- en: The program generated from the readdir02.c source code outputs only one file—most
    likely, the entry for the current directory itself, the single dot. Obviously,
    if you want a real directory-reading program, you must modify the code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由readdir02.c源代码生成的程序只输出一个文件——很可能是当前目录本身的条目，即单个点。显然，如果你想要一个真正的目录读取程序，你必须修改代码。
- en: As with using the fread() function to read data from a regular file , the readdir()
    function is called repeatedly. When the function returns a pointer to a dirent
    structure, another entry is available in the directory. Only when the function
    returns NULL has the full directory been read.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用fread()函数从常规文件读取数据一样，readdir()函数会被反复调用。当函数返回指向dirent结构的指针时，目录中就有另一个条目可用。只有当函数返回NULL时，才表示已读取完整目录。
- en: 'To update the code from readdir02.c to readdir03.c, you must change the *readdir()*
    statement into a while loop condition. The *printf()* statement is then set inside
    the *while* loop. Here are the changed lines:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代码从readdir02.c更新到readdir03.c，你必须将*readdir()*语句改为while循环的条件。然后，将*printf()*语句设置在*while*循环内。以下是更改的行：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The *while* loop repeats as long as the value returned from *readdir()* isn’t
    NULL. With this update, the program now outputs all files in the current directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*while*循环会一直重复，直到*readdir()*返回的值不是NULL。通过这次更新，程序现在会输出当前目录中的所有文件。'
- en: To gather more information about files in a directory, use the *stat()* function,
    covered earlier in this chapter. The *readdir()* function’s dirent structure contains
    the file’s name in the d_name member. When this detail is known, you use the *stat()*
    function to gather details on the file’s type as well as other information.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取目录中文件的更多信息，请使用本章之前介绍过的*stat()*函数。*readdir()*函数的dirent结构体包含文件名，位于d_name成员中。当知道这个细节时，你使用*stat()*函数来获取文件类型以及其他信息。
- en: The final rendition of the *readdir* series of programs is shown next. It combines
    code previously covered in this chapter to create a crude directory listing program.
    Entries are read one at a time, with the *stat()* function returning specific
    values for file type, size, and access date.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了*readdir*系列程序的最终版本。它结合了本章之前介绍过的代码，创建了一个粗糙的目录列表程序。条目逐个读取，*stat()*函数返回文件类型、大小和访问日期的特定值。
- en: Listing 10.5 Source code for readdir04.c
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 readdir04.c的源代码
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Saves the directory entry’s name for readability and easy access
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保存目录条目的名称以提高可读性和易于访问
- en: ❷ Fills the stat structure for the current filename/directory entry
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为当前文件名/目录条目填充stat结构
- en: ❸ Calls out directories from other file types
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从其他文件类型中调用目录
- en: ❹ Outputs the directory filename left-justified in a 16-character width
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 以16字符宽度左对齐输出目录文件名
- en: ❺ Lines up a standard filename just like the directory filename
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将标准文件名与目录文件名对齐
- en: ❻ Outputs the file size in an 8-character width
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 以8字符宽度输出文件大小
- en: ❼ Outputs the access time, which automatically adds a newline
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 输出访问时间，这会自动添加换行符
- en: This code shows that to truly read a directory, you need both the *readdir()*
    and *stat()* functions. Together, they pull in details about files in the directory—useful
    information if you plan on exploring directories or writing similar file utilities,
    such as a directory tree.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码表明，要真正读取目录，你需要*readdir()*和*stat()*函数。它们一起获取目录中文件的详细信息——如果你计划探索目录或编写类似文件工具（如目录树），这将是有用的信息。
- en: 'Here is sample output from the program generated by the readdir04.c source
    code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是readdir04.c源代码生成的程序示例输出：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Incidentally, the order in which directory entries appear is dependent on the
    operating system. Some operating systems sort the entries alphabetically, so the
    *readdir()* function fetches filenames in that order. This behavior isn’t consistent,
    so don’t rely upon it for the output of your directory-reading programs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，目录条目出现的顺序取决于操作系统。一些操作系统按字母顺序排序条目，因此*readdir()*函数按该顺序获取文件名。这种行为并不一致，因此不要依赖它来输出你的目录读取程序。
- en: 10.3 Subdirectory exploration
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 子目录探索
- en: 'Directories are referenced in three ways:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目录可以通过三种方式引用：
- en: As a named path
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为命名路径
- en: As the .. shortcut to the parent directory
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为指向父目录的..快捷方式
- en: As a directory entry in the current directory, a subdirectory
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为当前目录中的一个目录条目，一个子目录
- en: Whatever the approach, pathnames are either direct or relative. A direct path
    is a fully named path, starting at the root directory, your home directory, or
    the current directory. A relative pathname uses the .. shortcut for the parent
    directory—sometimes, a lot of them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用何种方法，路径名要么是直接的，要么是相对的。直接路径是一个完全命名的路径，从根目录、您的家目录或当前目录开始。相对路径名使用 .. 快捷方式表示父目录——有时，很多。
- en: 'As an example, a full pathname could be:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'As an example, a full pathname could be:'
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This direct pathname shows the directories as they branch from the root, through
    my home directory, down to the statements directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直接路径显示了从根目录分支的目录，通过我的家目录，直到 statements 目录。
- en: 'If I have another directory, /home/dang/documents/vacations, but I’m using
    the statements directory (shown earlier), the relative path from statements to
    vacations is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我还有一个目录，/home/dang/documents/vacations，但我使用的是前面的语句目录，从语句到 vacations 的相对路径是：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first .. represents the bank directory. The second .. represents the finances
    directory. The third .. represents the documents directory, where vacations exists
    as a subdirectory. This construction demonstrates a relative path.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 .. 代表 bank 目录。第二个 .. 代表 finances 目录。第三个 .. 代表 documents 目录，其中 vacations
    存在作为一个子目录。这种结构演示了一个相对路径。
- en: These details about the path are a basic part of using Linux at the command
    prompt. Understanding these items is vital when it comes to your C programs and
    how they explore and access directories.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于路径的细节是使用 Linux 命令提示符的基本部分。当涉及到您的 C 程序以及它们如何探索和访问目录时，理解这些项目至关重要。
- en: 10.3.1 Using directory exploration tools
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 使用目录探索工具
- en: 'Along with using the *opendir()* function to read a directory and *readdir()*
    to examine directory entries, your code may need to change directories. Further,
    the program may want to know in which directory it’s currently running. Two C
    library functions exist to sate these desires: *chdir()* and *getcwd()*. I cover
    *getcwd()* first because it can be used to confirm that the *chdir()* function
    did its job.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 *opendir()* 函数读取目录和 *readdir()* 检查目录条目外，您的代码可能需要更改目录。此外，程序可能想知道它当前正在哪个目录中运行。有两个
    C 库函数可以满足这些需求：*chdir()* 和 *getcwd()*。我首先介绍 *getcwd()*，因为它可以用来确认 *chdir()* 函数是否完成了其工作。
- en: 'The *getcwd()* function obtains the directory in which the program is operating.
    Think of the name as Get the Current Working Directory. It works like the *pwd*
    command in the terminal window. This function is prototyped in the unistd.h header
    file. Here is the *man* page format:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'The *getcwd()* function obtains the directory in which the program is operating.
    Think of the name as Get the Current Working Directory. It works like the *pwd*
    command in the terminal window. This function is prototyped in the unistd.h header
    file. Here is the *man* page format:'
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Buffer buf is a character array or buffer of size characters. It’s where the
    current directory string is saved, an absolute path from the root. Here’s a tip:
    you can use the BUFSIZ defined constant for the size of the buffer as well as
    the second argument to *getcwd()*. Some C libraries have a PATH_MAX defined constant,
    which is available from the limits.h header file. Because its availability is
    inconsistent, I recommend using BUFSIZ instead. (The PATH_MAX defined constant
    is covered in chapter 11.)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区 buf 是一个大小为字符的字符数组或缓冲区。它用于保存当前目录字符串，一个从根目录的绝对路径。这里有一个提示：您可以使用定义的常量 BUFSIZ
    作为缓冲区的大小，以及 *getcwd()* 的第二个参数。一些 C 库定义了常量 PATH_MAX，它可以从 limits.h 头文件中获取。由于其可用性不一致，我建议使用
    BUFSIZ。 (PATH_MAX 定义常量在第 11 章中介绍。)
- en: The return value from getcwd() is the same character string saved in buf, or
    NULL upon an error. For the specific error, check the global errno variable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: The return value from getcwd() is the same character string saved in buf, or
    NULL upon an error. For the specific error, check the global errno variable.
- en: The following listing shows a tiny demo program, getcwd.c, that outputs the
    current working directory. I use the BUFSIZ defined constant to set the size for
    char array cwd[]. The function is called and then the string output.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个小型演示程序，getcwd.c，它输出当前工作目录。我使用定义的常量 BUFSIZ 为字符数组 cwd[] 设置大小。函数被调用，然后输出字符串。
- en: Listing 10.6 Source code for getcwd.c
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 getcwd.c 的源代码
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The defined constant BUFSIZ is defined in the stdio.h header file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义常量 BUFSIZ 在 stdio.h 头文件中定义。
- en: ❷ Outputs the current working directory
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出当前工作目录
- en: When run, the program outputs the current working directory as a full pathname.
    The buffer is filled with the same text you’d see output from the *pwd* command.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，程序以完整路径名输出当前工作目录。缓冲区填充了您从 *pwd* 命令中看到的相同文本。
- en: The second useful directory function is *chdir()*. This function works like
    the *cd* command in Linux. If you pay the senior price to see a movie, you may
    have used the *chdir* command in MS-DOS, though *cd* was also available and quicker
    to type.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个有用的目录函数是`*chdir()*`。这个函数的工作方式类似于Linux中的`*cd*`命令。如果你支付了看电影的“高级价格”，你可能在MS-DOS中使用了`*chdir*`命令，尽管`*cd*`也是可用的，并且输入更快。
- en: 'Like *getcwd()*, the *chdir()* function is prototyped in the unistd.h header
    file. Here is the *man* page format:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与`*getcwd()*`一样，`*chdir()*`函数在`unistd.h`头文件中进行了原型化。以下是`*man*`页面格式：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The sole argument is a string representing the directory (path) to change to.
    The return value is 0 upon success, with -1 indicating an error. As you may suspect
    by now, the global variable errno is set to indicate exactly what went afoul.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的参数是一个表示要更改到的目录（路径）的字符串。成功时返回值为0，-1表示错误。正如你可能已经猜到的，全局变量`errno`被设置为指示具体出了什么问题。
- en: I use both directory exploration functions in the changecwd.c source code shown
    in the next listing. The *chdir()* function changes to the parent directory, indicated
    by the double dots. The *getcwd()* function obtains the full pathname to the new
    directory, outputting the results.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我在下一列表中展示的`changecwd.c`源代码中使用了两个目录遍历函数。`*chdir()*`函数将目录更改为由双点表示的父目录。`*getcwd()*`函数获取新目录的完整路径名，并输出结果。
- en: Listing 10.7 Source code for changecwd.c
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 `changecwd.c`的源代码
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Changes to the parent directory
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更改为父目录
- en: ❷ Obtains the parent directory’s path
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取父目录的路径
- en: ❸ Outputs the parent directory’s path
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出父目录的路径
- en: The resulting program outputs the pathname to the parent directory of the directory
    in which the program is run.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的程序输出程序运行的目录的父目录的路径名。
- en: You notice in the source code for changecwd.c that I don’t bother returning
    to the original directory. Such coding isn’t necessary. An important thing to
    remember about using the *chdir()* function is that the directory change happens
    only in the program’s environment. The program may change to directories all over
    the media, but when it’s done, the directory is the same as where the program
    started.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在`changecwd.c`的源代码中注意到，我没有麻烦返回到原始目录。这样的编码是不必要的。在使用`*chdir()*`函数时，需要记住的一个重要事情是目录更改仅在程序的环境中发生。程序可能更改到媒体上的所有目录，但当它完成后，目录与程序开始时相同。
- en: 10.3.2 Diving into a subdirectory
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 深入子目录
- en: It’s easy to change to a subdirectory when you know its full path. An absolute
    path can be supplied by the user or it can be hardcoded into the program. But
    what happens when the program isn’t aware of its directory’s location?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道子目录的完整路径时，更改到子目录很容易。用户可以提供绝对路径，或者可以将它硬编码到程序中。但是，当程序不知道其目录位置时会发生什么？
- en: The parent directory is always known; you can use the double-dot abbreviation
    (..) to access the parent of every directory except the top level. Going up is
    easy. Going down requires a bit more work.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 父目录始终是已知的；你可以使用双点缩写（..）来访问除了顶级目录之外每个目录的父目录。向上移动很容易。向下移动需要做更多的工作。
- en: 'Subdirectories are found by using the tools presented so far in this chapter:
    scan the current directory for subdirectory entries. Once known, plug the subdirectory
    name into the *chdir()* function to visit that subdirectory.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用本章前面介绍的工具找到子目录：扫描当前目录以查找子目录条目。一旦知道，将子目录名称插入到`*chdir()*`函数中，以访问该子目录。
- en: 'The code for subdir01.c in the next listing builds a program that lists potential
    subdirectories in a named directory. Portions of the code are pulled from other
    examples listed earlier in this chapter: a directory argument is required and
    tested for. The named directory is then opened and its entries read. If any subdirectories
    are found, they’re listed.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表中的`subdir01.c`的代码构建了一个程序，该程序列出命名目录中的潜在子目录。代码的一部分是从本章前面列出的其他示例中提取的：需要并检查目录参数。然后打开命名目录并读取其条目。如果找到任何子目录，则列出它们。
- en: Listing 10.8 Source code for subdir01.c
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8 `subdir01.c`的源代码
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Confirms that a command-line argument (directory name) is available
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确认存在命令行参数（目录名）
- en: ❷ Assigns a pointer dirname to the first argument for readability
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为第一个参数分配一个指针`dirname`以提高可读性
- en: ❸ Opens the directory and tests for an error
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打开目录并检查错误
- en: ❹ Reads entries in the directory
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 读取目录中的条目
- en: ❺ Assigns a pointer filename to each entry for readability
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为每个条目分配一个指针`filename`以提高可读性
- en: ❻ Obtains inode details
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 获取inode详细信息
- en: ❼ Tests for an error
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 检查错误
- en: ❽ Tests to see whether the file is a directory (subdirectory)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 测试文件是否为目录（子目录）
- en: ❾ Outputs the directory’s name
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 输出目录的名称
- en: 'The program generated from the source code subdir01.c reads the directory supplied
    as a command-line argument and then outputs any subdirectories found in that directory.
    Here is output from a sample run, using my home directory:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码 subdir01.c 生成的程序读取作为命令行参数提供的目录，然后输出在该目录中找到的任何子目录。以下是使用我的主目录进行的示例运行输出：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is output from the root directory:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是根目录的输出：
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In both examples, the *stat()* function fails. Your code could examine the
    errno variable, set when the function returns -1, but I can tell you right away
    what the error is: the first argument passed to the *stat()* function must be
    a pathname. In the program, only the directory’s name is supplied, not a pathname.
    For example, the .bash_history subdirectory found in the first sample run shown
    earlier, and the bin directory found in the second don’t exist in the current
    directory.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，*stat()* 函数失败了。你的代码可以检查 errno 变量，该变量在函数返回 -1 时设置，但我可以立即告诉你错误是什么：传递给
    *stat()* 函数的第一个参数必须是路径名。在程序中，只提供了目录的名称，而不是路径名。例如，在前面示例运行中找到的 .bash_history 子目录和
    bin 目录在当前目录中并不存在。
- en: 'The solution is for the program to change to the named directory. Only when
    you change to a directory can the code properly read the files—unless you make
    the effort to build full pathnames. I’m too lazy to do that, so to modify the
    code, I add the following statements after the statement dirname = argv[1]:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是程序切换到指定的目录。只有当你切换到目录时，代码才能正确读取文件——除非你费力地构建完整的路径名。我太懒了，不想这么做，所以为了修改代码，我在
    dirname = argv[1] 语句之后添加了以下语句：
- en: '[PRE34]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Further, you must include the unistd.h header file so that the compiler doesn’t
    complain about the *chdir()* function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你必须包含 unistd.h 头文件，这样编译器就不会对 *chdir()* 函数提出抱怨。
- en: 'With these updates to the code, available in the online repository as subdir02.c,
    the program now runs properly:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码的这些更新，这些更新可在在线存储库的子目录 subdir02.c 中找到，程序现在可以正常运行：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Remember: to read files from a directory, you must either change to the directory
    (easy) or manually construct full pathnames for the files (not so easy).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：要从目录中读取文件，你必须要么切换到该目录（容易），要么手动为文件构造完整的路径名（不那么容易）。
- en: Exercise 10.2
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.2
- en: Every directory has the dot and dot-dot entries. Plus, many directories host
    hidden subdirectories. All hidden files in Linux start with a single dot. Your
    task for this exercise is to modify the source code from subdir02.c to have the
    program not output any file that starts with a single dot. My solution is available
    in the online repository as subdir03.c.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录都有点和点点的条目。此外，许多目录还包含隐藏的子目录。Linux 中的所有隐藏文件都以单个点开头。本练习的任务是修改 subdir02.c 的源代码，使程序不输出任何以单个点开头的文件。我的解决方案可在在线存储库中找到，作为
    subdir03.c。
- en: 10.3.3 Mining deeper with recursion
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 使用递归进行更深入的挖掘
- en: It wasn’t until I wrote my first directory tree exploration program that I fully
    understood and appreciated the concept of recursion. In fact, directory spelunking
    is a great way to teach any coder the mechanics behind recursion and how it can
    be beneficial.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我编写了我的第一个目录树探索程序，我才完全理解和欣赏递归的概念。事实上，目录探险是向任何程序员教授递归的机制以及它如何有益的绝佳方式。
- en: As a review, *recursion* is the amazing capability of a function to call itself.
    It seems dumb, like an endless loop. Yet within the function exists an escape
    hatch, which allows the recursive function to unwind. Providing that the unwinding
    mechanism works, recursion is used in programming to solve all sorts of wonderful
    problems beyond just confusing beginners.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，*递归* 是函数调用自身的惊人能力。它看起来很愚蠢，就像一个无限循环。然而，在函数内部存在一个逃生门，它允许递归函数展开。只要展开机制正常工作，递归在编程中就用于解决各种奇妙的问题，而不仅仅是让初学者感到困惑。
- en: When the *subdir* program encounters a subdirectory, it can change to that directory
    to continue mining for even more directories. To do so, the same function that
    read the current directory is called again but with the subdirectory’s path. The
    process is illustrated in figure 10.4\. Once the number of entries in a directory
    is exhausted, the process ends with a return to the parent directory. Eventually
    the functions return, backtracking to the original directory, and the program
    is done.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *subdir* 程序遇到子目录时，它可以切换到该目录以继续挖掘更多目录。为此，调用读取当前目录的相同函数，但使用子目录的路径。这个过程在图 10.4
    中展示。一旦目录中的条目数用尽，过程将以返回父目录结束。最终，函数返回，回溯到原始目录，程序完成。
- en: '![10-04](Images/10-04.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![10-04](Images/10-04.png)'
- en: Figure 10.4 The process of recursively discovering directories
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 递归发现目录的过程
- en: My issue with recursion is always how to unwind it. Plumbing the depths of subdirectories
    showed me that once all the directories are processed, control returns to the
    parent directory. Even then, as a seasoned Assembly language programmer accustomed
    to working where memory is tight, I fear blowing up the stack. It hasn’t happened
    yet—well, not when I code things properly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我对递归的问题总是如何展开它。深入子目录的探索让我意识到，一旦所有目录都处理完毕，控制权会返回父目录。即使如此，作为一个习惯于在内存紧张的环境中工作的经验丰富的汇编语言程序员，我担心会崩溃堆栈。到目前为止还没有发生——好吧，至少在我正确编码的时候没有。
- en: 'To modify the *subdir* series of programs into a recursive directory spelunker,
    you must remove the program’s core, which explores subdirectories, and set it
    into a function. I call such a function *dir()*. Its argument is a directory name:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 *subdir* 系列程序修改为递归目录探险者，你必须移除程序的核心，即探索子目录的部分，并将其设置为函数。我称这样的函数为 *dir()*. 它的参数是目录名：
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The *dir()* function uses a *while* loop to process directory entries, looking
    for subdirectories. When found, the function is called again (within itself) to
    continue processing directory entries, looking for another subdirectory. When
    the entries are exhausted, the function returns, eventually ending in the original
    directory.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*dir()* 函数使用 *while* 循环来处理目录条目，寻找子目录。当找到时，函数再次被调用（在自身内部）以继续处理目录条目，寻找另一个子目录。当条目用尽时，函数返回，最终回到原始目录。'
- en: The following listing implements the program flow from figure 10.4, as well
    as earlier versions of the *subdir* programs, to create a separate *dir()* function.
    It’s called recursively (within the function’s *while* loop) when a subdirectory
    is found. The *main()* function is also modified so that the current directory
    (".") is assumed when a command line argument isn’t supplied.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表实现了图 10.4 中的程序流程，以及 *subdir* 程序的早期版本，以创建一个单独的 *dir()* 函数。当找到子目录时，它会递归调用（在函数的
    *while* 循环内）。同时修改了 *main()* 函数，以便在没有提供命令行参数时假定当前目录（"."）。
- en: Listing 10.9 Source code for subdir04.c
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 subdir04.c 的源代码
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ The function’s sole argument is a directory name, dirname.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数的唯一参数是目录名，dirname。
- en: ❷ Confirms that the program can change to the name directory
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确认程序可以切换到命名目录
- en: ❸ Gets the full pathname
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取完整路径名
- en: ❹ Confirms that the directory can be opened
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确认目录可以打开
- en: ❺ Outputs the directory’s name
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出目录的名称
- en: ❻ Loops through the directory’s entries, looking for subdirectories
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历目录的条目，寻找子目录
- en: ❼ Saves the found filename for readability
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 保存找到的文件名以提高可读性
- en: ❽ Ignores the dot and dot-dot entries as well as hidden files
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 忽略点（.）和点点（..）条目以及隐藏文件
- en: ❾ Obtains details on the found directory entry (inode)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 获取找到的目录条目的详细信息（inode）
- en: ❿ Checks for a subdirectory
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 检查子目录
- en: ⓫ Recursively calls the *dir()* function again
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 递归地再次调用 *dir()* 函数
- en: ⓬ If no argument is supplied, assumes the current directory
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 如果没有提供参数，则假定当前目录
- en: ⓭ Uses the argument as the named directory
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 使用参数作为命名目录
- en: Don’t bother typing in the code for subdir04.c. (Does anyone type in code from
    a book anymore?) Don’t even bother obtaining the source code from the online repository.
    The program won’t blow up your computer, but it contains several flaws.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 不要费心输入 subdir04.c 的代码。（还有谁会从书中输入代码吗？）甚至不要费心从在线仓库中获取源代码。程序不会让你的电脑崩溃，但它包含几个缺陷。
- en: 'For example, here is a sample run on my home directory:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是在我的主目录上的一个示例运行：
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You see the starting directory output correctly, /home/dang. Next, the program
    jumps on a symbolic link to my user profile directory in Windows (from the Linux
    command line). So far, so good; it followed the symbolic link to /mnt/c/Users/Dan.
    It successfully goes to the 3D Objects directory, but then it gets lost. The directory
    AppData exists, but it’s not the next proper subdirectory to which the code should
    branch.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到起始目录的输出是正确的，/home/dang。接下来，程序跳转到Windows中我的用户配置文件目录的符号链接（从Linux命令行）。到目前为止，一切顺利；它跟随符号链接到
    /mnt/c/Users/Dan。它成功进入3D Objects目录，但随后它迷路了。存在AppData目录，但它不是代码应该分支的下一个合适的子目录。
- en: What’s wrong?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: 'The flaw is present in figure 10.4 as well as in the source code shown in listing
    10.9: when the *dir()* function starts, it issues the *chdir()* function to change
    to the named directory, dirname. But the *dir()* function doesn’t change back
    to the parent/original directory when it has finished processing a subdirectory.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷存在于图10.4以及列表10.9中显示的源代码中：当 *dir()* 函数开始时，它发出 *chdir()* 函数来更改到命名的目录 dirname。但是，当
    *dir()* 函数完成处理子目录后，它并没有将目录改回到父目录/原始目录。
- en: 'To update the code and make the program return to the parent directory, add
    the following statements at the end of the *dir()* function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新代码并使程序返回父目录，请在 *dir()* 函数的末尾添加以下语句：
- en: '[PRE39]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The updated code is found in the online repository as subdir05.c. A sample run
    on my home directory outputs pages and pages of directories, almost properly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码可以在在线存储库中找到，作为 subdir05.c。在我的主目录上的一次示例运行输出了许多页的目录，几乎正确。
- en: Almost.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎。
- en: 'Turns out, the program created from subdir05.c can get lost, specifically with
    symbolic links. The code follows the symbolic link, but when it tries to return
    to the parent, it either loses its location or goes to the wrong parent. The problem
    lies with the *chdir()* chunk of statements just added to the code at the end
    of the *dir()* function. The parent directory isn’t specific:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，从 subdir05.c 创建的程序可能会迷路，特别是与符号链接相关。代码跟随符号链接，但当它尝试返回父目录时，它要么丢失了位置，要么去了错误的父目录。问题在于在
    *dir()* 函数末尾添加到代码中的 *chdir()* 语句块。父目录并不具体：
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This statement changes to the parent directory, but it’s far better to use the
    parent directory’s full path. In fact, as I was playing with the code, I discovered
    that it’s just best to work with full pathnames throughout the *dir()* function.
    Some changes are required.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句更改到父目录，但使用父目录的完整路径会更好。事实上，当我玩弄代码时，我发现最好在整个 *dir()* 函数中处理完整路径名。一些更改是必要的。
- en: 'My final update redefines the *dir()* function as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我最后的更新将 *dir()* 函数重新定义为以下内容：
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For readability, I changed the arguments name to reflect that both are full
    pathnames. The first is the full pathname to the directory to scan. The second
    is the full pathname to the parent directory. Both are *const char* types because
    neither string is modified within the function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，我将参数名称更改为反映这两个都是完整路径名。第一个是扫描目录的完整路径名。第二个是父目录的完整路径名。两者都是 *const char*
    类型，因为在函数内部不会修改这两个字符串。
- en: Listing 10.10 shows the updated *dir()* function. Most of the changes involve
    removing *char* variable directory and replacing it with argument dirpath. It’s
    also no longer necessary to change to the named directory in the function, which
    now assumes that the dirpath argument represents the current directory. Further
    comments are found in the code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10显示了更新的 *dir()* 函数。大多数更改涉及删除 *char* 变量 directory 并将其替换为参数 dirpath。现在也不再需要在函数中更改到命名的目录，现在假设
    dirpath 参数代表当前目录。进一步的注释可以在代码中找到。
- en: Listing 10.10 The updated *dir()* function from subdir06.c
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 subdir06.c中的更新 *dir()* 函数
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Storage for the new directory to change to, storing the full pathname
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储要更改的新目录，存储完整路径名
- en: ❷ The program is already in the desired directory, so rather than change to
    it, the code attempts to open the directory and read entries.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 程序已经在所需的目录中，因此而不是改变到它，代码尝试打开目录并读取条目。
- en: ❸ Outputs the current directory path
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出当前目录路径
- en: ❹ Reads all entries in the directory
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 读取目录中的所有条目
- en: ❺ Avoids any dot entries
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 避免任何点条目
- en: ❻ Gets info for each directory entry (inode)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 获取每个目录条目（inode）的信息
- en: ❼ Checks for a subdirectory entry
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 检查子目录条目
- en: ❽ Changes to the subdirectory
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 更改到子目录
- en: ❾ Gets the subdirectory’s full pathname for the recursive call
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 获取递归调用中子目录的完整路径名
- en: ❿ Recursively calls the function with the subdirectory and current directory
    as arguments
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 递归地以子目录和当前目录作为参数调用函数
- en: ⓫ Closes the current directory after all entries are read
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 在读取所有条目后关闭当前目录
- en: ⓬ Changes back to the parent directory—full pathname
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 返回到父目录——完整路径名
- en: ⓭ Checks for NULL, in which case, just returns
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 检查 NULL，如果是，则直接返回
- en: 'Updating the *dir()* function requires that the *main()* function be updated
    as well. It has more work to do: the *main()* function must obtain the full pathname
    to the current directory or the argv[1] value, as well as the directory’s parent.
    This update to the main() function is shown here.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *dir()* 函数需要更新 *main()* 函数。它需要做更多的工作：*main()* 函数必须获取当前目录的完整路径名或 argv[1] 的值，以及目录的父目录。这里展示了
    main() 函数的更新。
- en: Listing 10.11 The updated *main()* function for subdir06.c
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 subdir06.c 的更新后的 *main()* 函数
- en: '[PRE43]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ For no arguments, obtains and stores the full path to the current directory
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于没有参数的情况，获取并存储当前目录的完整路径
- en: ❷ Copies the first argument; hopefully, a directory
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 复制第一个参数；希望是一个目录
- en: ❸ Changes to the directory and checks for errors
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 切换到目录并检查错误
- en: ❹ Gets the directory’s full pathname
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取目录的完整路径名
- en: ❺ Calls the function; NULL is checked in *dir()*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用函数；在 *dir()* 中检查 NULL。
- en: The full source code file is available in the online repository as subdir06.c.
    It accepts a directory argument or no argument, in which case the current directory
    is plumbed.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码文件可在在线仓库中找到，文件名为 subdir06.c。它接受目录参数或无参数，如果没有参数，则当前目录会被追踪。
- en: Even though the program uses full pathnames, it may still get lost. Specifically,
    for symbolic links, the code may wander away from where you intend. Some types
    of links, such as aliases in Mac OS X, aren’t recognized as directories, so they’re
    skipped. And when processing system directories, specifically those that contain
    block or character files, the program’s stack may overflow and generate a segmentation
    fault.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序使用完整路径名，但它仍然可能会迷路。特别是对于符号链接，代码可能会偏离你预期的位置。某些类型的链接，如 Mac OS X 中的别名，不被识别为目录，因此会被跳过。并且在处理系统目录时，特别是包含块或字符文件的目录，程序的堆栈可能会溢出并生成段错误。
- en: 10.4 A directory tree
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 目录树
- en: 'The ancient MS-DOS operating system featured the TREE utility. It dumped a
    map of the current directory structure in a festive, graphical (for a text screen)
    manner. This command is still available in Windows. In the CMD (command prompt)
    program in Windows, type **TREE** and you see output like that shown in figure
    10.5: directories appear in a hierarchical structure, with lines connecting parent
    directories and subdirectories in a festive manner, along with indentation showing
    directory depth.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 古老的 MS-DOS 操作系统具有 TREE 工具。它以节日般、图形化的方式（对于文本屏幕）显示当前目录结构的地图。此命令在 Windows 中仍然可用。在
    Windows 的 CMD（命令提示符）程序中，键入 **TREE**，你会看到如图 10.5 所示的输出：目录以层次结构的形式出现，以节日般的方式用线条连接父目录和子目录，同时通过缩进来显示目录深度。
- en: '![10-05](Images/10-05.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![10-05](Images/10-05.png)'
- en: Figure 10.5 Output from the TREE command
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 TREE 命令的输出
- en: The mechanics behind creating a directory tree program are already known to
    you. The source code for subdir06.c processes directories and subdirectories in
    the same manner as the output shown in figure 10.5\. What’s missing are the shortened
    directory names, text mode graphics, and indentation. You can add these items,
    creating your own directory tree utility.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 创建目录树程序的机制你已经知道了。subdir06.c 的源代码以与图 10.5 所示的输出相同的方式处理目录和子目录。缺少的是缩短的目录名、文本模式图形和缩进。你可以添加这些项目，创建自己的目录树工具。
- en: 10.4.1 Pulling out the directory name
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 提取目录名
- en: To mimic the old TREE utility, the *dir()* function must extract the directory
    name from the full pathname. Because full pathnames are used, and the string doesn’t
    end with a trailing slash, everything from the last slash in the string to the
    null character qualifies as the directory’s name.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模仿旧的 TREE 工具，*dir()* 函数必须从完整路径名中提取目录名。因为使用了完整路径名，并且字符串不以反斜杠结尾，所以从字符串中的最后一个反斜杠到最后一个空字符之间的所有内容都符合目录名的条件。
- en: 'The easy way to extract the current directory name from a full pathname is
    to save the name when it’s found in the parent directory: the entry->d_name structure
    member contains the directory’s name as it appears in the parent’s directory listing.
    To make this modification, the *dir()* function requires another argument, the
    short directory name. This modification is simple to code, which is why this approach
    is the easy way.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 从完整的路径名中提取当前目录名的简单方法是保存在父目录中找到的名称：entry->d_name 结构成员包含目录的名称，正如它在父目录列表中显示的那样。为了进行这种修改，*dir()*
    函数需要另一个参数，即短目录名。这种修改简单易编码，这就是为什么这种方法被称为简单方法。
- en: The problem with the easy way is that the *main()* function obtains a full directory
    path when the program is started without an argument. So, even if you choose the
    easy way, you still must extract the directory name from the full pathname in
    the *main()* function. Therefore, my approach is to code a new function that pulls
    a directory name (or filename) from the end of a path.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 容易方法的缺点是 *main()* 函数在程序启动时没有参数时获取完整的目录路径。因此，即使你选择容易的方法，你仍然必须在 *main()* 函数中从完整的路径名中提取目录名。因此，我的方法是为从路径末尾提取目录名（或文件名）编写一个新函数。
- en: 'When I add new features to a program, such as when extracting a directory name
    from the butt end of a pathname, I write test code. In the next listing, you see
    the test code for the *extract()* function. Its job is to plow through a pathname
    to pull out the last part—assuming the last part of the string (after the final/separator
    character) is a directory name. Oh, and the function also assumes the environment
    is Linux; if you’re using Windows, you specify the backslash (two of them: \\)
    as the path separator, though Windows 10 may also recognize the forward slash.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为程序添加新功能时，例如从路径末尾提取目录名时，我会编写测试代码。在下一个列表中，你可以看到 *extract()* 函数的测试代码。它的任务是遍历路径名以提取最后一部分——假设字符串的最后一部分（在最后的/分隔符字符之后）是目录名。哦，该函数还假设环境是
    Linux；如果你使用 Windows，则指定反斜杠（两个：\\）作为路径分隔符，尽管 Windows 10 也可能识别正斜杠。
- en: Listing 10.12 Source code for extractor.c
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 extractor.c 的源代码
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ If the string is empty, returns NULL
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果字符串为空，则返回 NULL
- en: ❷ Performs a special test for the root directory
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对根目录执行特殊测试
- en: ❸ Positions pointer p at the end of string path
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将指针 p 定位在字符串 path 的末尾
- en: ❹ Backs up p to find the separator; for Windows, uses \\ as the separator
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 回退 p 以找到分隔符；对于 Windows，使用 \\ 作为分隔符
- en: ❺ If p backs up too far, returns NULL
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果 p 回退得太远，则返回 NULL
- en: ❻ Increments p over the separator character
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在分隔符字符上递增 p
- en: ❼ Tests to see if the string is empty or malformed and returns NULL
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 测试字符串是否为空或格式不正确，并返回 NULL
- en: ❽ Returns the address where the final directory name starts
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 返回最终目录名开始的地址
- en: ❾ Tests strings for a variety of configurations
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 测试字符串的各种配置
- en: 'The *extract()* function backs up through the pathname string passed. Pointer
    p scans for the / separator. It leaves the function referencing the position in
    the string path where the final directory name starts. Upon an error, NULL is
    returned. A series of test strings in the *main()* function puts the *extract()*
    function to work. Here is the output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*extract()* 函数在传递的路径名字符串中回退。指针 p 搜索 / 分隔符。它离开函数时引用字符串 path 中最终目录名开始的位置。在出现错误时，返回
    NULL。*main()* 函数中的一系列测试字符串使 *extract()* 函数发挥作用。以下是输出：'
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The *extract()* function successfully processes each string, returning the last
    part, the directory name. It even catches the malformed string, properly returning
    NULL.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*extract()* 函数成功处理每个字符串，返回最后一部分，即目录名。它甚至可以捕获格式不正确的字符串，正确地返回 NULL。'
- en: 'For my first rendition of the directory tree program, I added the *extract()*
    function to the final update to the *subdir* series of programs, subdir06.c. The
    *extract()* function is called from within the *dir()* function, just before the
    main *while* loop that reads directory entries, replacing the existing *printf()*
    statement at that line:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的第一个目录树程序版本，我在对 *subdir* 系列程序的最后更新 subdir06.c 中添加了 *extract()* 函数。*extract()*
    函数在 *dir()* 函数内部调用，就在读取目录条目的主要 *while* 循环之前，替换了该行上的现有 *printf()* 语句：
- en: '[PRE46]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This update is saved as dirtree01.c. The resulting program, *dirtree*, outputs
    the directories but only their names and not the full pathnames. The output is
    almost a directory tree program, but without proper indenting for each subdirectory
    level.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新被保存为 dirtree01.c。生成的程序 *dirtree* 输出目录，但只输出它们的名称，而不是完整的路径名。输出几乎是一个目录树程序，但没有为每个子目录级别进行适当的缩进。
- en: 10.4.2 Monitoring directory depth
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 监控目录深度
- en: Programming the fancy output from the old TREE command, shown in figure 10.5,
    is more complicated than it looks. Emulating it exactly requires that the code
    use wide character output (covered in chapter 8). Further, the directory’s depth
    must be monitored as well as when the last subdirectory in a directory is output.
    Indeed, to fully emulate the TREE command requires massively restructuring the
    *dirtree* program, primarily to save directory entries for output later.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 从旧 TREE 命令中获取的复杂输出，如图 10.5 所示，看起来比实际复杂。要完全模拟它，代码需要使用宽字符输出（在第 8 章中介绍）。此外，还需要监控目录的深度，以及输出目录中的最后一个子目录时。实际上，要完全模拟
    TREE 命令，需要对 *dirtree* 程序进行大量重构，主要是为了保存目录条目以便稍后输出。
- en: Yeah, so I’m not going there—not all the way.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，所以我不会去那里——不会完全去。
- en: 'Rather than restructure the entire code, I thought I’d add some indentation
    to make the directory output of my *dirtree* series a bit more “tree”-like. This
    addition requires that the directory depth be monitored so that each subdirectory
    is indented a notch. To monitor the directory depth, the definition of the *dir()*
    function is updated:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是重构整个代码，我想添加一些缩进，使我的 *dirtree* 系列目录输出看起来更“树形”。这个添加需要监控目录深度，以便每个子目录都缩进一点。为了监控目录深度，更新了
    *dir()* 函数的定义：
- en: '[PRE47]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I consider three arguments to be the maximum for a function. Any more arguments,
    and it becomes obvious to me that what should really be passed to the function
    is a structure. In fact, I wrote a version of the *dirtree* program that held
    directory entries in an array of structures. That code became overly complex,
    however, so I decided to just modify the *dir()* function as shown earlier.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为三个参数对于一个函数来说是最大的。如果参数更多，对我来说很明显，真正应该传递给函数的是结构体。实际上，我编写了一个版本的 *dirtree* 程序，它将目录条目存储在结构体数组中。然而，这段代码变得过于复杂，所以我决定只修改前面显示的
    *dir()* 函数。
- en: 'To complete the modification in the code, three more changes are required.
    First, in the *main()* function, the *dir()* function is originally called with
    zero as its third argument:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成代码的修改，还需要进行三个更改。首先，在 *main()* 函数中，*dir()* 函数最初调用时第三个参数为零：
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The zero sets the indent depth as the program starts; the first directory is
    the top level.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 零将缩进深度设置为程序开始时的值；第一个目录是顶级目录。
- en: 'Second, the recursive call within the *dir()* function must be modified, adding
    the third argument depth:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，必须修改 *dir()* 函数内的递归调用，添加第三个参数深度：
- en: '[PRE49]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For the recursive call, which means the program is diving down one directory
    level, the indent level depth is increased by one.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归调用，这意味着程序正在深入一个目录级别，缩进级别深度增加一。
- en: 'Finally, something must be done with the depth variable within the *dir()*
    function. I opted to add a loop that outputs a chunk of three spaces for every
    depth level. This loop requires a new variable to be declared for function *dir()*,
    integer i (for indent):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须在 *dir()* 函数内部对深度变量进行处理。我选择添加一个循环，为每个深度级别输出三个空格。这个循环需要为 *dir()* 函数声明一个新的变量，整数
    i（用于缩进）：
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This loop appears before the *printf()* statement that outputs the directory’s
    name, just before the *while* loop. The result is that each subdirectory is indented
    three spaces as the directory tree is output.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环出现在输出目录名称的 *printf()* 语句之前，就在 *while* 循环之前。结果是，每个子目录在输出目录树时都缩进了三个空格。
- en: 'The source code for dirtree02.c is available in the online repository. Here
    is the program’s output for my prog (programming) directory:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: dirtree02.c 的源代码可在在线仓库中找到。以下是程序对我 prog（编程）目录的输出：
- en: '[PRE51]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Each subdirectory is indented three spaces. The sub-subdirectories of the c
    directory are further indented.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子目录缩进了三个空格。c 目录的子子目录进一步缩进。
- en: Exercise 10.3
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.3
- en: 'Modify the source code for dirtree02.c so that instead of indenting with blanks,
    the subdirectories appear with text mode graphics. For example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 dirtree02.c 的源代码，使其不是使用空格缩进，而是使用文本模式图形显示子目录。例如：
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These graphics aren’t as fancy (or precise) as those from the MS-DOS TREE command,
    but they are an improvement. This modification requires only a few lines of code.
    My solution is available in the online repository as dirtree03.c.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图形不如 MS-DOS TREE 命令中的那些花哨（或精确），但它们是一个改进。这个修改只需要几行代码。我的解决方案可以在在线仓库中找到，文件名为
    dirtree03.c。
