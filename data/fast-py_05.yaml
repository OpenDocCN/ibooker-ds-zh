- en: 4 High-performance NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 高性能NumPy
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Rediscovering NumPy from a performance perspective
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从性能角度重新发现NumPy
- en: Leveraging NumPy views for computing efficiency and memory conservation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用NumPy视图提高计算效率和内存节省
- en: Introducing array programming as a paradigm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍数组编程作为一种范例
- en: Configuring NumPy internals for efficiency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置NumPy内部结构以提高效率
- en: 'It is difficult to overstate the importance of NumPy for doing data analytics
    with Python. This book might as well be called *High-Performance Python with NumPy*.
    NumPy will be found somewhere in your stack: Do you use pandas? NumPy. Do you
    use scikit-learn? NumPy. Dask? NumPy. SciPy? NumPy. Matplotlib? NumPy. TensorFlow?
    NumPy. If you are doing data analytics in Python, almost surely your answer includes
    NumPy.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy对于使用Python进行数据分析的重要性难以言表。这本书甚至可以被称为*高性能Python与NumPy*。NumPy将在你的堆栈中某个地方被发现：你使用pandas吗？NumPy。你使用scikit-learn吗？NumPy。Dask？NumPy。SciPy？NumPy。Matplotlib？NumPy。TensorFlow？NumPy。如果你在Python中进行数据分析，几乎可以肯定你的答案中包括NumPy。
- en: NumPy is a Python library that provides N-dimensional or multidimensional array
    objects such as matrices, which are two-dimensional, along with the functionality
    to manipulate them. The implementation is extremely efficient with its core written
    in Fortran and C. Many data analysis problems can be modeled at their core by
    N-dimensional arrays; this is why NumPy is pervasive in this field.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是一个Python库，它提供了多维或N维数组对象，如矩阵（二维），以及操作这些数组的功能。其实现效率极高，核心是用Fortran和C编写的。许多数据分析问题可以通过N维数组在核心进行建模；这就是为什么NumPy在这个领域无处不在。
- en: 'Given the importance and wide usage of NumPy in Python’s data analysis, some
    topics related to it will be discussed in other chapters, notably:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到NumPy在Python数据分析中的重要性和广泛使用，一些与之相关的主题将在其他章节中讨论，特别是：
- en: Vectorization of functions using Cython in chapter 5
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第5章中使用Cython对函数进行向量化
- en: Internal memory organization of arrays in chapter 6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6章中数组的内部内存组织
- en: Using NumExpr for fast numerical expression evaluation in chapter 6
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第6章使用NumExpr进行快速数值表达式评估
- en: Using arrays larger than memory in chapters 8 and 10
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8章和第10章中使用大于内存的数组
- en: Efficient storage of arrays in chapters 8 and 10
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8章和第10章中高效存储数组
- en: Making use of GPU computing for array processing in chapter 9
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第9章中使用GPU计算进行数组处理
- en: 'In this chapter, we will start with a refresher on NumPy. While this book assumes
    that you have had some exposure to NumPy, it is not uncommon that, even if you
    are using the library, it might be in an indirect manner. For example, you might
    be using pandas or Matplotlib and do very little direct NumPy programming yourself.
    This refresher focuses on NumPy concepts *from a performance perspective*. If
    you feel that you need a more thorough introduction, there are countless free
    examples on the web. The official one is really good: [https://numpy.org/devdocs/user/quickstart.html](https://numpy.org/devdocs/user/quickstart.html).
    The NumPy site also provides a curated list of learning resources at [https://numpy.org/learn/](https://numpy.org/learn/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从NumPy的复习开始。虽然本书假设你已经接触过NumPy，但即使你在使用这个库，也可能是在间接使用。例如，你可能在使用pandas或Matplotlib，但自己进行的直接NumPy编程很少。这次复习侧重于从*性能角度*的NumPy概念。如果你觉得你需要更全面的介绍，网上有无数免费示例。官方的示例非常好：[https://numpy.org/devdocs/user/quickstart.html](https://numpy.org/devdocs/user/quickstart.html)。NumPy网站还提供了一个精选的学习资源列表，位于[https://numpy.org/learn/](https://numpy.org/learn/)。
- en: After the primer, we will examine array programming as a *programming model*
    where an operation is applied to more than one atomic value at a time. This approach
    is valuable both from a performance perspective and also as an elegant approach
    to writing code. In the final part of the chapter, we will discuss the effect
    of NumPy’s internal architecture and dependencies on its performance—and we will
    learn how to fine-tune it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在入门篇之后，我们将探讨数组编程作为一种*编程模型*，其中一次对多个原子值执行操作。这种方法在性能方面非常有价值，同时也是编写代码的一种优雅方法。在第章的最后一部分，我们将讨论NumPy内部架构和依赖对其性能的影响——我们将学习如何对其进行微调。
- en: 4.1 Understanding NumPy from a performance perspective
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 从性能角度理解NumPy
- en: 'In this section, and throughout this chapter, we will learn the key concepts
    and techniques through the use of a practical example: the development of simple
    image manipulation routines. Images are, on first approach, two-dimensional arrays
    (i.e., matrices) and thus lend themselves quite easily to NumPy manipulation.
    So we will assume we are developing a new image-processing software. Again, while
    this section is a kind of NumPy primer, it emphasizes how NumPy affects performance.
    So even if you know NumPy basics, you may learn something new about it here.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及本章的其余部分，我们将通过使用一个实际例子来学习关键概念和技术：简单图像处理例程的开发。从最初接触来看，图像是二维数组（即矩阵），因此很容易进行
    NumPy 操作。因此，我们假设我们正在开发一款新的图像处理软件。再次强调，虽然本节类似于 NumPy 入门教程，但它强调 NumPy 对性能的影响。所以即使你已经了解了
    NumPy 的基础知识，你在这里也可能学到一些新的东西。
- en: 4.1.1 Copies vs. views of existing arrays
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 数组的副本与视图
- en: Our first task is to read an image from a file and perform several rotation
    operations on it. We will use NumPy directly to rotate the image, not the functions
    provided by the Pillow image library that we use to read the image. We will learn
    to do this with both NumPy memory copying and with view creation so we can compare
    their efficiency. Views are based on arrays that share the same memory but interpret
    it differently, so they are generally more efficient, although they cannot always
    be used, as we will see.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是读取一个图像文件并对它执行几个旋转操作。我们将直接使用 NumPy 来旋转图像，而不是使用我们读取图像时使用的 Pillow 图像库提供的函数。我们将学习如何使用
    NumPy 的内存复制和视图创建来完成这项工作，以便我们可以比较它们的效率。视图基于共享相同内存的数组，但以不同的方式解释它，因此它们通常更高效，尽管它们并不总是可以使用，正如我们将看到的。
- en: 'Let’s start by loading a familiar image, the logo from Manning Publications,
    and then getting a NumPy array from it. Note that some operations like rotating
    an image can be conceived as nothing more than interpreting an array in a different
    way: columns become rows and rows become columns. This is exactly what a NumPy
    view is: a different interpretation of the same raw data. We will divide this
    process into very small steps, as we need to carefully consider and understand
    each line (the code can be found in `04-numpy/sec1-basics/image_processing.py`):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从加载一个熟悉的图像开始，即来自 Manning 出版物的标志，然后从中获取一个 NumPy 数组。请注意，一些操作，如旋转图像，可以被视为不过是对数组进行不同方式的解释：列变成行，行变成列。这正是
    NumPy 视图的作用：对相同原始数据的另一种解释。我们将把这个过程分解成非常小的步骤，因为我们需要仔细考虑和理解每一行（代码可以在 `04-numpy/sec1-basics/image_processing.py`
    中找到）：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① The convert(“L”) operation reduces the image to grayscale.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ① `convert("L")` 操作将图像转换为灰度。
- en: 'We use the Pillow library to load the Manning logo (figure 4.1), converting
    the image to grayscale. Every pixel will be represented by an unsigned byte. The
    size of the image is 182 × 45\. The output is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Pillow 库加载 Manning 标志（图 4.1），将图像转换为灰度。每个像素将由一个无符号字节表示。图像的大小为 182 × 45。输出如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We then get an array representing the image data by using the function `np.array`.
    The reason this works with a Pillow image is not because NumPy knows what an image
    is, but because the image object implements `__array__interface__` which NumPy
    uses to construct an array representation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用函数 `np.array` 获取表示图像数据的数组。NumPy 能够与 Pillow 图像一起工作，并不是因为 NumPy 知道图像是什么，而是因为图像对象实现了
    `__array__interface__`，这是 NumPy 用于构建数组表示的方法。
- en: We then print the array `shape`, which is 45 × 182\. Notice that the *convention*
    for images—width followed by height—is the reverse of the convention followed
    by NumPy, which comes from mathematics—the number of rows followed by the number
    of columns. This nuance is substantially more important than it seems, and we
    will start to see this when we discuss different views of data in the next subsection.
    But the magnitude of the problem will become especially clear when we discuss
    memory representation in chapter 6.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后打印出数组的`shape`，其大小为 45 × 182。请注意，对于图像而言——宽度在前，高度在后——这一惯例与 NumPy 所遵循的惯例相反，NumPy
    的惯例源自数学——行数在前，列数在后。这种细微差别实际上比看起来更重要，我们将在下一小节讨论不同数据视图时开始看到这一点。但当我们讨论第 6 章中的内存表示时，问题的严重性将变得尤为明显。
- en: 'We then print the data type of the array, which comes as `uint8` (i.e., unsigned
    integer of 8 bits, or a byte). A `uint8` is sufficient to keep enough information
    for grayscale images. Following that, we print the memory occupied by the array
    in two different ways: (1) by multiplying the number of items in the array (45
    * 182 = 8190) times the size of each element (1 byte in our case), or (2) we can
    use the `nbytes` field directly.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打印数组的类型，它为`uint8`（即8位无符号整数，或一个字节）。`uint8`足以保存足够的信息以用于灰度图像。随后，我们以两种不同的方式打印数组占用的内存：（1）通过将数组中的项目数（45
    * 182 = 8190）乘以每个元素的大小（在我们的例子中是1字节），或者（2）我们可以直接使用`nbytes`字段。
- en: Finally, we use the `getsizeof` function introduced in chapter 2 to get the
    size of the array *object*. This includes the raw array (8190) plus the Python
    and NumPy overhead and metadata (for a total of 8302).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用第2章中介绍的`getsizeof`函数来获取数组*对象*的大小。这包括原始数组（8190）加上Python和NumPy的开销和元数据（总计8302）。
- en: 'We have seen a few ways to establish the size of our array—with and without
    object overhead. Now we will flip the image upside down. Image flipping can be
    done by copying the array or simply by changing our interpretation of the raw
    data, so it’s a good example for introducing views. After we get the two flips,
    we will black out half of the original image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种确定我们数组大小的方法——有和没有对象开销。现在我们将翻转图像上下颠倒。图像翻转可以通过复制数组或简单地改变我们对原始数据的解释来完成，因此它是一个介绍视图的好例子。在得到两个翻转之后，我们将遮挡原始图像的一半：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Flips the image in the vertical axis. This is done using a view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在垂直轴上翻转图像。这是通过视图完成的。
- en: ② Takes a flipped image and creates a copy of it
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从翻转的图像中创建一个副本
- en: Figure 4.1 shows the four images combined. `flipped_from_view` is created from
    a view of `image_arr`. This means that when you change `image_arr` with `image_arr[:,
    :width//2] = 0`, `flipped_from_view` will also be altered because the raw array
    is shared.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1显示了四个图像的组合。`flipped_from_view`是从`image_arr`的视图中创建的。这意味着当你用`image_arr[:,
    :width//2] = 0`更改`image_arr`时，`flipped_from_view`也会被更改，因为原始数组是共享的。
- en: '![](../Images/CH04_F01_Antao.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F01_Antao.png)'
- en: 'Figure 4.1 The four images: the original Manning logo (image.png), the left
    part blacked out (removed.png), a vertical flip from a copy (flipped_copy.png),
    and a flip from a view (flipped_view.png)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 四个图像：原始Manning标志（image.png）、左侧被遮挡（removed.png）、从副本中垂直翻转（flipped_copy.png）和从视图翻转（flipped_view.png）
- en: Views share the underlying raw array; copies don’t. Therefore, the image of
    `flipped_from_copy` is not affected by the change on `image_arr`. As a side note,
    `Image.fromarray` creates a copy of the original array. That is why image.png
    and removed.png are different. If it had provided a view, then the images would
    be equal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 视图共享底层原始数组；副本不共享。因此，`flipped_from_copy`的图像不会受到`image_arr`上变化的影响。作为旁注，`Image.fromarray`创建原始数组的副本。这就是为什么image.png和removed.png不同的原因。如果它提供了一个视图，那么这些图像将是相等的。
- en: The underlying data structures supporting the images are shown in figure 4.2\.
    Note that the original image was destroyed, and `image_arr` contains the blacked-out
    array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 支持图像的底层数据结构在图4.2中显示。请注意，原始图像已被销毁，`image_arr`包含被遮挡的数组。
- en: '![](../Images/CH04_F02_Antao.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Antao.png)'
- en: Figure 4.2 Many NumPy operations can generate new objects, or views, which share
    the raw data with the original objects. Sometimes that is not possible or desirable,
    and data is copied.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 许多NumPy操作可以生成新的对象或视图，这些对象或视图与原始对象共享原始数据。有时这可能不可能或不是所希望的，数据会被复制。
- en: Sometimes it is not desirable to do view sharing. For example, you might not
    want to black out the original image. In that case, you need to make a copy so
    that the original object is preserved intact. There are also times when it is
    not possible to get the data as a view; we will see a case of this later in the
    section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能不希望进行视图共享。例如，你可能不想遮挡原始图像。在这种情况下，你需要创建一个副本，以便原始对象保持完整。也有时候不可能以视图的形式获取数据；我们将在本节稍后看到一个例子。
- en: 'It is possible to see whether an array is based on another array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到数组是否基于另一个数组：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Checks whether it is the same object
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查是否是同一个对象
- en: ② Checks whether all values of both arrays are equal
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查两个数组的所有值是否相等
- en: 'The output is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`flipped_from_copy.base` will be `None` as it is its own fresh copy. `flipped_
    from_view.base` will have a value—a matrix. We can check whether it is the same
    object as `image_arr` by using `is`. Be careful: if you use `==`, you are getting
    a value-by-value comparison of all elements of the array. For `is`, you will get
    `True`; for `==` you will get an array of `True`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`flipped_from_copy.base` 将会是 `None`，因为它是一个全新的副本。`flipped_from_view.base` 将会有一个值——一个矩阵。我们可以通过使用
    `is` 来检查它是否与 `image_arr` 是同一个对象。请注意：如果你使用 `==`，你将得到数组所有元素逐个比较的结果。对于 `is`，你将得到
    `True`；对于 `==`，你将得到一个包含 `True` 的数组。'
- en: Tip The base of any view is not the object from which the view is derived but
    the very first object in the chain. So, for example, if you have `v2 = v1[:-1]`
    and `v1 = arr[::-1]`, `v2.base is arr` and `v1.base is arr` are both `True`, but
    `v2.base is v1` is not.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：任何视图的基础不是视图所派生的对象，而是链中的第一个对象。例如，如果你有 `v2 = v1[:-1]` 和 `v1 = arr[::-1]`，`v2.base
    is arr` 和 `v1.base is arr` 都是 `True`，但 `v2.base is v1` 不是。
- en: As we have seen, Numpy objects have a set of metadata like `shape` or `dtype`.
    The raw array data is in a field called `data`, which points to a Python built-in
    type, a `memoryview`. The `memoryview` class provides a lot of basic functionality
    from the Python side to deal with blocks of allocated memory with homogeneous
    types. For example, it implements indexing, slicing, and memory sharing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Numpy 对象有一组元数据，如 `shape` 或 `dtype`。原始数组数据位于一个名为 `data` 的字段中，它指向一个 Python
    内置类型，一个 `memoryview`。`memoryview` 类提供了许多基本功能，从 Python 端处理具有相同类型的分配内存的块。例如，它实现了索引、切片和内存共享。
- en: 'It is possible to inquire whether NumPy arrays share memory, which is more
    general than being a view because `memoryviews` can be belong simultaneously to
    other objects and, potentially, other arrays without using a view to create them:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能查询 NumPy 数组是否共享内存，这比仅仅是视图更通用，因为 `memoryviews` 可以同时属于其他对象，以及，可能地，其他数组，而无需使用视图来创建它们：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`np.shares_memory` will be `False` for `image_arr` and `flipped_from_copy`
    because we are dealing with a copy. It will be `True` for both `image_arr` and
    `flipped_from_view`. Generally, if `base` is shared, then memory is shared, but
    the reverse doesn’t have to be true: memory can be shared without having the same
    base.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.shares_memory` 对于 `image_arr` 和 `flipped_from_copy` 将是 `False`，因为我们正在处理一个副本。对于
    `image_arr` 和 `flipped_from_view`，它将是 `True`。一般来说，如果 `base` 是共享的，那么内存也是共享的，但反之不一定成立：内存可以共享，而不一定有相同的
    `base`。'
- en: Tip Determining whether two arrays share memory is not a trivial problem. In
    complex scenarios, it may take a lot of time, making it impractical. In those
    cases, there is a faster function, `may_share_memory`, to provide a guess whether
    two arrays share memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：确定两个数组是否共享内存不是一个简单的问题。在复杂场景中，可能需要花费很多时间，这使得它变得不切实际。在这些情况下，有一个更快的函数 `may_share_memory`，可以提供一个猜测，即两个数组是否共享内存。
- en: The takeaway
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收要点
- en: The take-home point here is that *views tend to be substantially more efficient
    than copies*. There are two main reasons for this. First, when you copy an array,
    you pay the computing price of copying the raw data whereas with views, only the
    view information is remade. Probably more important, when you copy an array, you
    double the memory that you need, which might not be feasible when you are dealing
    with large in-memory arrays. In any case, don’t forget that if you change any
    view, all objects that share the same memory will be affected.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要记住的关键点是：*视图通常比副本要高效得多*。这有两个主要原因。首先，当你复制一个数组时，你需要支付复制原始数据的计算成本，而使用视图时，只需重新创建视图信息。可能更重要的是，当你复制一个数组时，你需要加倍所需的内存，这在处理大型内存数组时可能不可行。无论如何，不要忘记，如果你更改任何视图，所有共享相同内存的对象都将受到影响。
- en: 'Let’s run a short example to grasp the consequence of this difference in efficiency.
    We will create an array with variable sizes and measure how long it takes to create
    both a view and a copy (table 4.1):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简短的示例来了解这种效率差异的影响。我们将创建一个具有可变大小的数组，并测量创建视图和副本所需的时间（表 4.1）：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① If you use iPython, remember that the %timeit magic is available.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果你使用 iPython，请记住 %timeit 魔法命令是可用的。
- en: Table 4.1 Comparing the time and memory allocations between copies and views
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 比较复制和视图之间的时间和内存分配
- en: '| Array size | Array memory (b) | View time | Copy time |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 数组大小 | 数组内存（b） | 视图时间 | 复制时间 |'
- en: '| 1 | 2 | 0.171 | 0.281 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 0.171 | 0.281 |'
- en: '| 10 | 20 | 0.137 | 0.259 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 20 | 0.137 | 0.259 |'
- en: '| 100 | 200 | 0.139 | 0.286 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 200 | 0.139 | 0.286 |'
- en: '| 1000 | 2000 | 0.162 | 0.502 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 2000 | 0.162 | 0.502 |'
- en: '| 10000 | 20000 | 0.142 | 2.275 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 10000 | 20000 | 0.142 | 2.275 |'
- en: '| 100000 | 200000 | 0.138 | 31.257 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 100000 | 200000 | 0.138 | 31.257 |'
- en: '| 200000 | 400000 | 0.152 | 67.005 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 200000 | 400000 | 0.152 | 67.005 |'
- en: '| 400000 | 800000 | 0.144 | 354.287 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 400000 | 800000 | 0.144 | 354.287 |'
- en: '| 800000 | 1600000 | 0.177 | 547.843 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 800000 | 1600000 | 0.177 | 547.843 |'
- en: '| 1000000 | 2000000 | 0.142 | 729.966 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 1000000 | 2000000 | 0.142 | 729.966 |'
- en: 'The memory burden of a copy is quite easy to understand: you double the amount
    of memory needed every time you copy.[¹](#pgfId-1013727) The time burden of a
    copy is less obvious: from a naive perspective, you can assume that the time needed
    to copy an array is linear with its size. If you look at the table, sometimes
    the linear relationship breaks. This will be explained in chapter 6.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的内存负担很容易理解：每次复制时，内存需求量都会加倍。[¹](#pgfId-1013727) 复制的计算负担则不那么明显：从直观的角度来看，你可以假设复制数组所需的时间与其大小成正比。如果你查看表格，有时线性关系会中断。这一点将在第
    6 章中解释。
- en: The takeaway
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: As we have seen, views can save you both compute time and memory, so you should
    generally try to use views when possible. The biggest drawback of views is that
    they are not always an option; sometimes there is simply no alternative to copying.
    That said, NumPy’s view mechanism is both powerful and flexible, so it can be
    used in plenty of situations. Let’s have a deeper look at the view mechanism so
    we can see how to put it to use in a wide range of situations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，视图可以节省你计算时间和内存，因此你应该尽可能使用视图。视图的最大缺点是它们并不总是可行的；有时没有其他选择，只能复制。尽管如此，NumPy
    的视图机制既强大又灵活，因此可以在许多情况下使用。让我们更深入地了解视图机制，以便我们可以看到如何在各种情况下使用它。
- en: 4.1.2 Understanding NumPy’s view machinery
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 理解 NumPy 的视图机制
- en: 'To be able to make the most of views for efficient processing, we first have
    to understand how they work. The flexibility of views comes mostly from two pieces
    of metadata: the first, which we have just seen, is the shape. The second is the
    strides; we’ll get a more precise definition of strides in a moment. First, let’s
    look at a few examples illustrating different shape and stride values.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够充分利用视图进行高效处理，我们首先必须了解它们是如何工作的。视图的灵活性主要来自两块元数据：第一块，我们刚刚看到的是形状。第二块是步长；我们将在稍后给出步长的更精确定义。首先，让我们看看几个说明不同形状和步长值的例子。
- en: 'Let’s start by allocating an array consisting of `[0, 1, 2, 3, 4, 5, 6, 7,
    8, 9]`, of 4-byte unsigned integers and look at its stride and shape. We will
    later reshape this simple linear array into a two-dimensional structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分配一个包含 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` 的数组，它是 4 字节无符号整数，并查看它的步长和形状。我们稍后将这个简单的线性数组重塑成二维结构：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The array will be allocated *contiguously* in memory. This means that 0 will
    be followed by 1; 1 by 2; 2 by 3, and so on. This might seem obvious at this stage,
    but as we will see, it is far from it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数组将在内存中连续分配。这意味着 0 将被 1 接着，1 被 2 接着，2 被 3，以此类推。在这个阶段，这可能会显得很明显，但正如我们将看到的，它远非如此。
- en: Warning The contiguous allocation with NumPy presented in this example is an
    oversimplification—albeit a correct one for this case—for pedagogical purposes.
    From this point on, we will see examples of arrays that are not contiguous. But
    we will delay important details about allocation until chapter 6\. As a suggestion,
    if this is the first time you’re seeing a discussion about an array being contiguous,
    refrain from visiting that chapter immediately. Get the basic concepts right first.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 NumPy 中展示的连续分配是一个简化的例子——尽管对于这个案例是正确的——出于教学目的。从现在开始，我们将看到非连续数组的例子。但我们将在第 6
    章中推迟关于分配的重要细节。作为一个建议，如果你第一次看到有关数组连续性的讨论，请先不要立即查看那一章。首先确保基本概念正确。
- en: 'Let’s get a view as a 2 × 5 matrix of the same data. After that, let’s create
    another view, a 5 × 2 matrix from a transposition of the 2 × 5 matrix. We want
    to understand the relationship between the original array and the new matrices:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取一个 2 × 5 矩阵的视图，该视图与相同的数据。之后，让我们创建另一个视图，一个 5 × 2 矩阵，它是通过 2 × 5 矩阵的转置得到的。我们想了解原始数组与新矩阵之间的关系：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing we want to do is to make sure the matrices share memory (i.e.,
    they are views, not copies). `np.shares memory` shows that both `linear`, `m5x2`,
    and `m2x5` share memory, which is depicted in figure 4.3\. We also print the corners
    of the newly declared matrices so that their boundaries are clear.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要确保矩阵共享内存（即，它们是视图，而不是副本）。`np.shares memory` 显示 `linear`、`m5x2` 和 `m2x5`
    都共享内存，这在图 4.3 中有所描述。我们还打印了新声明矩阵的角点，以便它们的边界清晰。
- en: '![](../Images/CH04_F03_Antao.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_Antao.png)'
- en: Figure 4.3 The three arrays, irrespective of dimension, share the same memory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 这三个数组，无论维度如何，都共享相同的内存。
- en: 'The question is, how can NumPy know how to find an element from the same memory?
    The shape may be enough to distinguish between the one-dimensional array and one
    of the matrices. But what about distinguishing between the two differently shaped
    matrices from the same memory? That is what strides are for:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，NumPy 如何知道如何从相同的内存中找到一个元素？形状可能足以区分一维数组和矩阵之一。但是，如何区分来自相同内存的两个不同形状的矩阵呢？这就是步长的用途：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The results will be `4, (4, 20)`, and `(20, 4)`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `4, (4, 20)` 和 `(20, 4)`。
- en: The *stride*, then, is how many bytes you need to jump to get to the next element
    along a dimension. Let’s make this concept clear by relating it to the three previous
    examples.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，步长就是你需要跳过多少字节才能到达一个维度上的下一个元素。让我们通过将其与前面三个例子联系起来，来使这个概念更加清晰。
- en: 'The stride for the `linear` variable is `4`: this means that there is only
    one dimension and that to hop from one element to the next one, you need to jump
    4 bytes, which is the size of the data type that we chose, `np.uint32`. In figure
    4.4, every time you advance one position in the linear array, you advance 4 bytes
    in memory to get the value. The memory position for index `i` is then `stride
    * i` or `4 * i`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`linear` 变量的步长是 `4`：这意味着只有一个维度，并且要从当前元素跳到下一个元素，你需要跳过 4 字节，这是我们所选择的数据类型的大小，`np.uint32`。在图
    4.4 中，每次你在线性数组中前进一个位置，你就在内存中前进 4 字节以获取值。索引 `i` 的内存位置然后是 `stride * i` 或 `4 * i`。'
- en: '![](../Images/CH04_F04_Antao.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F04_Antao.png)'
- en: 'Figure 4.4 Jumping to adjacent elements in a one-dimensional array. This has
    a single stride: the number is the size of our data type.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 在一维数组中跳转到相邻元素。这有一个单一的步长：数字是我们数据类型的大小。
- en: Things get a little more complicated with two-dimensional arrays. For our 2
    × 5 array, if you want to jump a column forward, then the element is adjacent,
    so a jump of one element—the current one—is required (figure 4.5). Given that
    our element size is 4 bytes, we end up with a stride of 4\. But if you want to
    jump a row forward, then you have to skip the current element plus an extra 4
    (given that each row has five elements). So 5 elements times the element size
    of 4 equals 20\. In this interpretation of the memory, you can get to element
    `i,j` with the function `strides[0]*i + strides[1]*j` (`20*i + 4*j`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维数组，事情会变得稍微复杂一些。对于我们的 2 × 5 数组，如果你想向前跳过一列，那么元素是相邻的，所以需要跳过一个元素——当前这个元素——（如图
    4.5）。鉴于我们的元素大小是 4 字节，我们得到的步长是 4。但是，如果你想向前跳过一行，那么你必须跳过当前元素加上额外的 4（因为每一行有五个元素）。所以
    5 个元素乘以元素大小 4 等于 20。在这种对内存的解释中，你可以通过函数 `strides[0]*i + strides[1]*j`（`20*i + 4*j`）来获取元素
    `i,j`。
- en: '![](../Images/CH04_F05_Antao.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F05_Antao.png)'
- en: 'Figure 4.5 Jumping to adjacent elements in a 2 × 5 in a two-dimensional array.
    We will need two strides: one for each dimension.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 在二维数组中跳转到 2 × 5 的相邻元素。我们需要两个步长：每个维度一个。
- en: 'The stride for the `m5x2` is `20, 4`: this means that there are two dimensions
    and that to go to the next row you need to hop 20 bytes (five columns at 4 bytes
    each). The next column is the next value, which is 4 bytes away.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`m5x2` 的步长是 `20, 4`：这意味着有两个维度，并且要到达下一行，你需要跳过 20 字节（五个列，每个列 4 字节）。下一个列是下一个值，距离
    4 字节。'
- en: Figure 4.6 should make this clear. (This will vary substantially with the inner
    representation of the array, something we will consider in chapter 6.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 应该会使这一点更加清晰。（这将与数组的内部表示有显著差异，我们将在第 6 章中考虑这一点。）
- en: '![](../Images/CH04_F06_Antao.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F06_Antao.png)'
- en: Figure 4.6 Jumping to adjacent elements in a 2 × 5 in a two-dimensional array.
    The stride for rows will depend on the number of columns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 在二维数组中跳转到 2 × 5 的相邻元素。行步长将取决于列数。
- en: 'Many NumPy operations are view transformations. For example, reversing an array
    can also be rendered as a view:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 NumPy 操作都是视图转换。例如，反转数组也可以表示为一个视图：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the stride is now `-4`. NumPy can create views that go backward (figure
    4.7).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在的步长是 `-4`。NumPy 可以创建可以向后移动的视图（如图 4.7）。
- en: '![](../Images/CH04_F07_Antao.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F07_Antao.png)'
- en: Figure 4.7 Reversing a one-dimensional array will invert the signal of the stride.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 反转一维数组将反转步长的信号。
- en: A similar approach can be used with two-dimensional arrays. What would be the
    strides for `m2x5` and `m5x2` if they were reversed?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用类似的方法处理二维数组。如果它们被反转，`m2x5` 和 `m5x2` 的步长会是什么？
- en: 'The ability to render a transformation as a view is not always possible, as
    it depends on the ability to establish a linear relationship between the existing
    and new view. For example, let’s take a 20 × 5 matrix and then choose a row out
    of three and a column of two, creating a matrix of 7 × 3\. Finally, let’s get
    a one-dimensional version of that 7 × 3 matrix:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将变换渲染为视图的能力并不总是可行的，因为这取决于在现有视图和新视图之间建立线性关系的能力。例如，让我们考虑一个 20 × 5 的矩阵，然后从三个行中选择一行，从两个列中选择一列，创建一个
    7 × 3 的矩阵。最后，让我们得到这个 7 × 3 矩阵的一维版本：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The 7 × 3 matrix can still be rendered as a view using a stride of 15, 2\. The
    apparently easier process of converting it to a one-dimensional representation
    is impossible to do as a view, and as such, a copy is created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用步长 15, 2，7 × 3 矩阵仍然可以渲染为视图。将其转换为单维表示的看似更容易的过程无法作为视图完成，因此会创建一个副本。
- en: 'NumPy’s so-called fancy indexing is always rendered as a copy. Here is an example
    where we get five alternate values, top and down, from a 2 × 5 matrix:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 所称的花式索引始终以副本的形式渲染。以下是一个从 2 × 5 矩阵中获取五个交替值（上下）的例子：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To refresh your memory on fancy indexing, it takes a list of indexes, one for
    each of the dimensions of the array, and returns the element corresponding to
    the positions on the lists. Let’s see this in action with the matrix shown in
    table 4.2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新您对花式索引的记忆，它需要一个索引列表，每个数组维度一个索引，并返回对应于列表上位置的元素。让我们通过表 4.2 中的矩阵来观察这一过程。
- en: Table 4.2 Original matrix
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 原始矩阵
- en: '| 0 | 1 | 2 | 3 | 4 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 2 | 3 | 4 |'
- en: '| 5 | 6 | 7 | 8 | 9 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 6 | 7 | 8 | 9 |'
- en: We will have an `alternate` of `[0 6 2 8 4]` for the list of rows `[0, 1, 0,
    1, 0]` and the list of columns `[0, 1, 2, 3, 4]`. `np.shares_memory` will be `False`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于行列表 `[0, 1, 0, 1, 0]` 和列列表 `[0, 1, 2, 3, 4]`，我们将有一个 `alternate` 列表 `[0 6 2
    8 4]`。`np.shares_memory` 将为 `False`。
- en: The takeaway
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要点
- en: First, views can be substantially more efficient than copies. Second, views
    can be used in the ways that we just learned in this section. Let’s apply those
    uses to our image processing code so we can see some advantages as well as some
    pitfalls of using views.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，视图可以比复制更有效率。其次，视图可以像我们在本节中学到的那样使用。让我们将这些用途应用到我们的图像处理代码中，这样我们就可以看到使用视图的一些优点以及一些陷阱。
- en: 4.1.3 Making use of views for efficiency
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 利用视图提高效率
- en: 'We are now going to transform our example image by using operations that only
    require views. This is a good time to remember why we are doing this in the context
    of big data: for very large arrays, memory can be limited, and copying large arrays
    incurs a time cost as well.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过仅使用视图的操作来转换我们的示例图像。这是在大数据背景下记住我们为什么要这样做的好时机：对于非常大的数组，内存可能有限，复制大数组也会产生时间成本。
- en: 'Let’s start by flipping the image vertically and horizontally:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先垂直和水平翻转图像：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① We can flip an image with an array reverse over a dimension. Remember that
    in the previous section we used Image.flipud to flip the image horizontally.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们可以使用数组 reverse 在一个维度上翻转图像。记住，在前一节中我们使用了 Image.flipud 来水平翻转图像。
- en: 'At this stage, the code should be easy to read: for the 182 × 24 Manning logo,
    the original array has a shape of 45, 182 with a stride of 182, 1\. We are dealing
    with a data type of unsigned integers of 1 byte, hence a single byte per pixel.
    When we flip the image horizontally (i.e., by rows), the only thing that changes
    is the second stride, which goes from 1 to -1\. Conversely, when we flip the image
    vertically, the first stride goes from 182 to -182.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，代码应该很容易阅读：对于 182 × 24 的曼宁标志，原始数组具有 45, 182 的形状，步长为 182, 1。我们正在处理 1 字节的无符号整数数据类型，因此每个像素一个字节。当我们水平翻转图像（即通过行翻转）时，唯一改变的是第二个步长，从
    1 变为 -1。相反，当我们垂直翻转图像时，第一个步长从 182 变为 -182。
- en: 'Let’s now try to rotate the image. We will use three approaches: reshape, transpose
    (`.T`), and 90-degree rotation (`.rot90`). We are doing this to check the output
    for the three different strategies and how they are internally represented:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试旋转图像。我们将使用三种方法：重塑（reshape）、转置（`.T`）和 90 度旋转（`.rot90`）。我们这样做是为了检查三种不同策略的输出以及它们在内部是如何表示的：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① The same thing can be done with the swapaxes method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ① 可以使用 swapaxes 方法完成相同的事情。
- en: To check whether we have a view or a copy, we are printing the `memoryview`
    object, which will give us a hexadecimal number reflecting the memory position.
    All the memory locations will be the same so the operations created views.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否有视图或副本，我们正在打印`memoryview`对象，这将给我们一个反映内存位置的十六进制数。所有的内存位置都将相同，因此这些操作创建了视图。
- en: 'Now, let’s include a slice—just the word *Manning* from the logo, which, in
    this case, is also a view:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们包括一个切片——仅从标志中提取的单词*Manning*，在这种情况下，它也是一个视图：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The shapes and strides are shown in table 4.3.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 形状和步长如表4.3所示。
- en: Table 4.3 Shapes and strides of axes swap, transposing, and rotation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3轴交换、转置和旋转的形状和步长
- en: '| Operation | Shape | Stride |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 形状 | 步长 |'
- en: '| `swapaxes` | 182 45 | 45 1 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `swapaxes` | 182 45 | 45 1 |'
- en: '| `transpose` | 182 45 | 1 182 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `transpose` | 182 45 | 1 182 |'
- en: '| `rot90` | 182 45 | -1 182 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `rot90` | 182 45 | -1 182 |'
- en: '| `slice` | 30 105 | 182 1 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `slice` | 30 105 | 182 1 |'
- en: Can you predict how the images will look, especially the axes swap, rotation,
    and the transposition? The results are shown in figure 4.8.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你能预测图像将如何显示吗，特别是轴交换、旋转和转置？结果如图4.8所示。
- en: '![](../Images/CH04_F08_Antao.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F08_Antao.png)'
- en: Figure 4.8 The images resulting from using direct array manipulation of the
    original Manning logo
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8使用原始Manning标志的直接数组操作产生的图像
- en: Tip For ease of explanation we only used one- and two-dimensional arrays with
    views, but all this NumPy machinery can be used with higher-order arrays.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：为了便于解释，我们只使用了具有视图的一维和二维数组，但所有这些NumPy机制都可以用于高阶数组。
- en: Warning It is possible to change the stride and shape values directly. Module
    `numpy.lib.stride_tricks` has a function called `as_strided` that takes an existing
    array, desired shape, and stride values and returns the results.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：直接更改步长和形状值是可能的。模块`numpy.lib.stride_tricks`有一个名为`as_strided`的函数，它接受一个现有数组、所需的形状和步长值，并返回结果。
- en: 'The fact that such a function is inside a module called `stride_tricks` should
    raise some flags. Also, the help page of the function starts with this text: “This
    function has to be used with extreme care.”'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，这样的函数位于名为`stride_tricks`的模块中，这应该引起一些注意。此外，该函数的帮助页面以以下文本开头：“此函数必须极其小心地使用。”
- en: The problem is that you can pass arbitrary values (i.e., wrong values) to the
    function. This is one of the rare cases where you can cause memory corruption
    in Python, as wrong values will be used to access wrong memory positions. Your
    program might crash or even expose sensitive information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你可以传递任意值（即，错误的值）给函数。这是少数几个你可以在Python中造成内存损坏的情况之一，因为错误的值将被用来访问错误的内存位置。您的程序可能会崩溃，甚至可能暴露敏感信息。
- en: The takeaway
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验
- en: 'Views can severely reduce computation and memory costs. While they cannot be
    used in all cases, NumPy’s view machinery is quite flexible and can be used in
    many situations where data can be reinterpreted with NumPy machinery: shape and
    stride.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以显著减少计算和内存成本。虽然它们不能在所有情况下使用，但NumPy的视图机制非常灵活，可以在许多可以用NumPy机制重新解释数据的情况中使用：形状和步长。
- en: That’s enough for now about views and copies from a performance perspective.
    Let’s now look at ways to program NumPy more efficiently, and as you’ll see, that
    means using more idiomatic NumPy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视图和副本的性能方面，我们已经说得足够多了。现在，让我们看看如何更有效地编程NumPy，正如您将看到的，这意味着使用更多惯用的NumPy。
- en: 4.2 Using array programming
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用数组编程
- en: 'Array programming is a programming model in which operations are applied to
    all values of an array at once. This model is used in scientific and high-performance
    programming. It has two main purposes: making code writing more declarative and
    more readable and making the code run more efficiently. It turns out that NumPy
    *can be* mostly done using array programming techniques.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数组编程是一种编程模型，其中操作一次应用于数组的所有值。这种模型用于科学和高性能编程。它有两个主要目的：使代码编写更具声明性和可读性，并使代码运行更高效。结果证明，NumPy*可以*主要使用数组编程技术来完成。
- en: We should make a distinction between *an array library* and *array programming*.
    A simple example will make this difference clear. (This example is just for teaching
    purposes, and I wouldn’t expect anyone to use the non-array solution.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在*数组库*和*数组编程*之间做出区分。一个简单的例子将使这种区别变得清晰。（这个例子只是为了教学目的，我不期望任何人使用非数组解决方案。）
- en: Note While there is no expectation that anyone would use the non-array solution
    in this simple example, it is quite common to see NumPy code written using non-array
    dialects. In this example, the benefits of an array approach are obvious, but
    it is perfectly possible, and undesirable, to use NumPy in the less-efficient
    way as presented in the first solution. Probably one of the most important skills
    when using NumPy and many other similar libraries (e.g., pandas) is recognizing
    when array code can replace naive Python code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然没有人会在这个简单的例子中使用非数组解决方案，但看到使用非数组语法的NumPy代码是很常见的。在这个例子中，数组方法的好处是显而易见的，但完全有可能，并且是不希望的，以第一解决方案中展示的较低效的方式使用NumPy。在使用NumPy和许多其他类似库（例如pandas）时，最重要的技能之一是识别何时数组代码可以替换原始Python代码。
- en: 'Imagine that you want to compute the sum of two vectors. From a user perspective,
    here is the common, non-array programming version (the code is available in `04-numpy/
    sec3-vectorize/array_and_broadcasting.py`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想计算两个向量的和。从用户的角度来看，这里是一个常见的、非数组编程版本（代码位于`04-numpy/sec3-vectorize/array_and_broadcasting.py`）：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We explicitly wrote code to go through all elements. This implementation is
    riddled with problems, which we will discuss later. For now, let’s just compare
    it to the array version:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确编写了代码来遍历所有元素。这种实现充满了问题，我们将在稍后讨论。现在，让我们仅将其与数组版本进行比较：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The glaringly obvious advantage is that the array version is more succinct and
    declarative, and that, by itself, is enough to make the array idiom preferable.
    But from our high-performance perspective, there is something more relevant going
    on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的优势是，数组版本更加简洁和声明性，仅此一点就足以使数组习语更可取。但从我们高性能的角度来看，还有一些更相关的事情正在发生。
- en: The array example is probably also orders of magnitude faster. The first example
    is Python code and has the already discussed inherent speed limits of native Python
    code. The array example in the overloaded `+` operator will be implemented as
    fast as possible. This means a non-Python implementation typically in C or Fortran,
    probably making use of vectorized CPU operations or even running over a GPU.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数组示例可能也快得多。第一个示例是Python代码，具有已经讨论过的原生Python代码固有的速度限制。重载`+`运算符中的数组示例将尽可能快地实现。这意味着非Python实现通常在C或Fortran中，可能利用了向量化CPU操作，甚至可能运行在GPU上。
- en: At this stage, we will not be overly concerned with how the `+` operator is
    implemented. We just need to grasp the potential performance advantages of using
    the array dialect.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们不会过分关注`+`运算符的实现方式。我们只需要掌握使用数组语法的潜在性能优势。
- en: 4.2.1 The takeaway
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 总结
- en: Efficient code can be clean code. The myth that efficient code must always be
    dirty is, I hope, put to rest here. The array implementation is both more efficient
    and cleaner.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的代码可以是干净的代码。关于高效代码必须始终是脏的这种神话，我希望在这里被搁置。数组实现既更高效又更干净。
- en: 'Now that I’ve advocated for the use of array programming, let’s take the previous
    pure Python implementation to briefly introduce another NumPy concept: broadcasting.
    Broadcasting is important because it allows us to make more use of array programming
    and write clearer, more concise code.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经提倡使用数组编程，让我们简要介绍另一个NumPy概念：广播。广播很重要，因为它允许我们更好地利用数组编程，并编写更清晰、更简洁的代码。
- en: 4.2.2 Broadcasting in NumPy
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 NumPy中的广播
- en: 'To understand broadcasting, let’s start by taking a deeper look at our pure
    Python implementation of adding two arrays. That code is repeated here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解广播，让我们首先深入探讨我们纯Python实现的两个数组相加。那段代码在这里重复出现：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Assumes shape and type from the first array
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从第一个数组假设形状和类型
- en: 'Before we discuss the major problem of this code, it is worthwhile noting one
    redeeming feature of it: the use of `np.empty`. This function allocates the memory
    for the array but does not initialize it with any value. This can be a time-saver
    when you are creating a massive array. You have to be sure that you initialize
    the array later, as we do here, or you will end up with garbage. As such, this
    is not a general solution, but it can increase performance in many cases.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论这段代码的主要问题之前，值得注意的一个优点是：它使用了`np.empty`。这个函数为数组分配内存，但不会用任何值初始化它。当你创建一个大型数组时，这可以节省时间。你必须确保稍后初始化数组，就像我们在这里做的那样，否则你将得到垃圾数据。因此，这不是一个通用的解决方案，但它可以在许多情况下提高性能。
- en: 'The major problem with the previous code is that it has no input checking,
    so it accepts arrays of any shape, including ones that can be potentially incompatible.
    The seemingly simple solution would be to impose the constraint that `a` and `b`
    would have to be of the same shape and to reshape the output accordingly. This
    would work but would be very clumsy to use. For example, if you add an array with
    100,000 elements and would like to increase all elements by one you would have
    to do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的主要问题是没有输入检查，因此它接受任何形状的数组，包括可能不兼容的数组。看似简单的解决方案是强制 `a` 和 `b` 必须具有相同的形状，并相应地重塑输出。这会起作用，但使用起来会很笨拙。例如，如果你要添加一个包含
    100,000 个元素的数组，并希望将所有元素增加 1，你必须这样做：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This would mean allocating and initializing a big array just to increment our
    original array by 1\. This is both ugly and, with big data, can be too expensive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只是为了将我们的原始数组增加 1，就需要分配和初始化一个大数组。这不仅难看，而且在处理大数据时可能过于昂贵。
- en: 'Wouldn’t it be nice if we could write something like `sum_arrays(array_100000,
    1)`? It turns out that in NumPy we can! The following code is perfectly valid:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能写 `sum_arrays(array_100000, 1)` 会怎么样？实际上，在 NumPy 中我们可以这样做！以下代码是完全有效的：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① As we will see later, this is not the same thing as writing array_100000 =
    array_100000 + 1.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们稍后会看到，这并不等同于编写 `array_100000 = array_100000 + 1`。
- en: '`array_100000` is an array with 100,000 positions while 1 is an atomic value
    (i.e., they have different types). This is an example of *broadcasting*, which
    is a set of sensible rules so that NumPy applies operators to arrays with different
    dimensions.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_100000` 是一个有 100,000 个位置的数组，而 1 是一个原子值（即它们有不同的类型）。这是一个广播的例子，广播是一组合理的规则，使得
    NumPy 可以将运算符应用于不同维度的数组。'
- en: 'Following are a few practical examples of broadcasting rules being applied.
    We also compare them to functions that can be confused with broadcasting operators.
    Let’s start with 1D arrays:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些应用广播规则的实用示例。我们还比较了它们与可以与广播运算符混淆的函数。让我们从一维数组开始：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `+` operator adds 1 to all elements of the array in the first print. It
    will add element by element on the second print: `[0 20 21 9]] + [10, 2, 25, 5]
    = [10 22 46 14]`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符在第一次打印时将数组中所有元素加 1。在第二次打印时，它将逐个元素相加：`[0 20 21 9] + [10, 2, 25, 5] =
    [10 22 46 14]`。'
- en: 'Notice that the `*` operator works similarly with arrays: the first case `*
    2` will multiply all values by 2\. The second case will multiply element by element:
    `[0 20 21 9]] + [10, 2, 25, 5] = [0 40 525 45]`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`*` 运算符与数组一起工作的方式类似：第一种情况 `* 2` 将所有值乘以 2。第二种情况将逐个元素相乘：`[0 20 21 9] + [10,
    2, 25, 5] = [0 40 525 45]`。
- en: The inner product is implemented by `np.dot` and the `@ (np.matmul)` operator
    (more on `@` later).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 内积是通过 `np.dot` 和 `@ (np.matmul)` 运算符实现的（关于 `@` 的更多信息稍后介绍）。
- en: 'Now let’s see some matrix examples with broadcasting:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些使用广播的矩阵示例：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adding a matrix to itself produces the expected result, as all values are doubled.
    You can also add a one-dimensional array to a matrix: it should have the size
    of the number of columns, and it will be applied row by row. You cannot do the
    converse (i.e., add a one-dimensional array with the number of rows). But a fast
    way of doing that (i.e., not involving excessive copying or non-array programming)
    can be achieved by transposing the matrix—remember, a very fast view operation—and
    then transposing the result.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵加到自身会产生预期的结果，因为所有值都加倍。你还可以将一维数组加到矩阵上：它应该有列的数量，并且将按行应用。你不能做相反的操作（即，添加一个行数为数的数组）。但有一种快速的方法（即，不涉及过多的复制或非数组编程）可以实现这一点，那就是转置矩阵——记住，这是一个非常快的视图操作——然后转置结果。
- en: Tip NumPy operators do not map directly to standard mathematics expectations.
    For example, `*` is *not* a mathematical matrix multiplication; that would be
    `np.dot`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 NumPy 运算符并不直接映射到标准的数学期望。例如，`*` 并不是数学上的矩阵乘法；那将是 `np.dot`。
- en: The takeaway
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验教训
- en: There’s a lot more to learn about broadcasting, but here we have covered its
    essential uses from a performance perspective. The most important thing to remember
    about broadcasting from this perspective is that its implementation is normally
    vectorized, and as we discussed in the previous section, vectorized implementation
    can be orders of magnitude faster. We are now ready to go back to our image processing
    code, hopefully armed with enough motivation to consider array-based approaches.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于广播还有很多东西要学习，但在这里，我们从性能的角度来看，我们已经涵盖了其基本用法。从这个角度来看，关于广播最重要的记住的事情是，它的实现通常是向量化的，正如我们在上一节中讨论的，向量化的实现可以快几个数量级。我们现在可以回到我们的图像处理代码，希望有了足够的动力来考虑基于数组的方案。
- en: 4.2.3 Applying array programming
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 应用数组编程
- en: 'Let’s now apply some of these array-based programming techniques to our image
    manipulation program. While we are doing this more efficient approach, we will
    have to learn how to deal with some pitfalls. Do not let these pitfalls discourage
    you from applying these approaches: array programming is more efficient and elegant
    than typical imperative programming based on `for` loops.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这些基于数组的编程技术应用到我们的图像处理程序中。在采用这种更高效的方法的同时，我们还需要学会如何处理一些潜在的问题。不要让这些问题让你对应用这些方法感到气馁：基于数组的编程比基于`for`循环的典型命令式编程更高效、更优雅。
- en: 'We will now try to brighten our image. Remember that we are using 1 byte per
    pixel—the `L` option when converting the image—varying between 0 and 255\. We
    will increase the brightness using two different approaches: by adding 5 to every
    pixel and by doubling the value, like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将尝试使我们的图像变亮。记住，我们正在使用每个像素1字节——在转换图像时选择`L`选项——其值在0到255之间变化。我们将通过两种不同的方法来增加亮度：给每个像素加5，以及将值加倍，如下所示：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In an ideal world, our problem would be solved. But, if you look at the results
    in figure 4.9, something needs to be corrected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我们的问题将会得到解决。但是，如果你看图4.9的结果，有些东西需要纠正。
- en: '![](../Images/CH04_F09_Antao.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 原始图像变亮没有达到预期的效果](../Images/CH04_F09_Antao.png)'
- en: Figure 4.9 Brightening the original image doesn’t have the expected effect.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 原始图像变亮没有达到预期的效果。
- en: 'The doubling figure is *apparently* correct, but there is some problem with
    the one we increased by 5\. Remember that the image is represented by 1-byte unsigned
    integers that range from 0 to 255\. Because 5 is added to 255, you end up with
    an overflow: 260 becomes 4\. Hence, the color becomes fairly black.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 加倍数字看起来是正确的，但我们增加5的那个数字有问题。记住，图像由0到255范围的1字节无符号整数表示。因为255加上5，你最终得到溢出：260变成4。因此，颜色变得相当黑。
- en: 'There is a more insidious problem—because it’s unnoticed—with the doubling
    figure. The figure seems right but suffers from the very same problem. To understand
    what is going on, let’s print the maximum value on the original image and on `brighter2`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个更隐蔽的问题——因为它没有被注意到——与加倍数字有关。这个数字看起来是正确的，但同样存在相同的问题。为了理解发生了什么，让我们打印原始图像和`brighter2`上的最大值：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The maximum value for the original image is 255 (total white) whereas the maximum
    value for the double image is 254, how so? Remember that in binary, 255 is 0x11111111
    (8 bits, all 1s), 2 * 255 is 510 0x1111111110 (8 higher bits, all 1s with last
    bit 0) but the overflow cuts the right bit. We end up with 0x111111110 (i.e.,
    254). The image looks correct, but it is not.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像的最大值是255（全白），而加倍图像的最大值是254，这是怎么回事？记住，在二进制中，255是0x11111111（8位，全部为1），2 * 255是510，0x1111111110（8位更高，全部为1，最后一位为0），但溢出切掉了右边的位。我们最终得到0x111111110（即，254）。图像看起来是正确的，但并不是。
- en: Warning Be extremely careful when choosing your data type. When there are no
    memory or speed concerns, you can be lax and get something wide. But if you need
    to save as much memory as possible, make sure you do not choose a type that is
    too small. Unless you have memory and time to spare, there is no general rule
    other than having good test coverage for corner cases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在选择数据类型时，请务必非常小心。当没有内存或速度方面的考虑时，你可以放宽要求，选择一个较宽的类型。但如果你需要尽可能节省内存，确保不要选择一个过小的类型。除非你有足够的内存和时间，否则除了对边缘情况有良好的测试覆盖外，没有一般性的规则。
- en: 'The simplest, although not more memory-efficient solution, is to use a larger
    data type. For example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法，尽管不是更节省内存的解决方案，是使用更大的数据类型。例如：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Do not confuse minimum with min. min returns the minimum of the array; minimum
    chooses the smallest value with broadcasting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ① 不要混淆最小值和min。min返回数组的最小值；最小值通过广播选择最小的值。
- en: We can assume that a value cannot be whiter than maximum white. So we convert
    all values greater than 255 to 255\. We start by taking the original array and
    converting it to a 2-byte unsigned int; the array is then doubled. When we check
    the maximum, it is the correct value, 510\. We then use `np.minimum` to choose
    the minimum from 255 and each element of the array, which is a prime example of
    broadcasting to create a copy. This makes the maximum value representable by a
    single byte. Finally, we recast to 8-bit unsigned int where the maximum is now
    correct. In the next section, we will look at a more memory-efficient approach
    to do this.[²](#pgfId-1016695)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设一个值不可能比最大白色还要白。因此，我们将所有大于255的值转换为255。我们首先将原始数组转换为2字节的无符号整数；然后数组被翻倍。当我们检查最大值时，它是正确的值，510。然后我们使用`np.minimum`从255和数组的每个元素中选择最小值，这是一个广播创建副本的典型例子。这使得最大值可以用单个字节表示。最后，我们将它重新铸造成8位无符号整数，此时最大值现在是正确的。在下一节中，我们将探讨一种更节省内存的方法来完成这项工作。[²](#pgfId-1016695)
- en: There are more efficient ways of doing some of the casting, such as making the
    multiplication return a `np.uint16` automatically, which we will see in the next
    subsection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些铸造过程中，有更有效的方法，例如让乘法自动返回`np.uint16`，我们将在下一小节中看到。
- en: 'Finally, let’s take another look at the way we double values. Previously, we
    used:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们再次看看我们翻倍值的方式。之前，我们使用：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This dialect creates an intermediary array that will be used to hold the result
    of the multiplication. The variable `brighter3_arr` is then replaced with the
    new one. But, for a short time—actually, until garbage collection is run—both
    arrays will exist in memory. This can be problematic for very large arrays both
    in terms of memory and time to create the new array. It turns out that we can
    do much better:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方言创建了一个中间数组，该数组将用于存储乘法的结果。然后，变量`brighter3_arr`被替换为新的变量。但是，在短时间内——实际上，直到运行垃圾回收——这两个数组都将存在于内存中。这在内存和时间上对非常大的数组都可能是问题。但事实上，我们可以做得更好：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, NumPy understands that the array is going to be mutated and does
    the multiplication *in place*. This means no doubling of memory and no time wasted
    in initialization and garbage collecting. The final result is the same, but from
    a performance perspective these two dialects are completely different. `x = x
    * 2` uses double memory and more time. `x *= 2` is more efficient and should be
    used whenever possible.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，NumPy理解数组将要被修改，并执行*原地*乘法。这意味着不需要加倍内存，也不需要在初始化和垃圾回收上浪费时间。最终结果是一样的，但从性能角度来看，这两种方言完全不同。`x
    = x * 2`使用了双倍内存和更多时间。`x *= 2`更高效，应该尽可能使用。
- en: The takeaway
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验教训
- en: Part of the problem when using libraries like NumPy or pandas is the tendency
    to return to non-array programming dialects, which are not efficient. This is
    not intentional, but we tend to maintain “normal” dialects unless we make a conscious
    effort to change. Let’s continue to delve deeper into array programming as it
    has a lot more to offer when working on performance problems and also because
    we want to insist on the paradigm.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像NumPy或pandas这样的库时，问题的一部分是倾向于回到非数组编程方言，这些方言效率不高。这并非有意为之，但我们倾向于保持“正常”的方言，除非我们有意改变。让我们继续深入研究数组编程，因为它在处理性能问题时提供了更多的好处，而且因为我们想坚持这种范式。
- en: 4.2.4 Developing a vectorized mentality
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 培养矢量化思维
- en: Vectorized *pure* Python code is not more efficient than nonvectorized code.
    The documentation of `np.vectorize` is quite explicit about this.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量化*纯*Python代码并不比非矢量化代码更高效。`np.vectorize`的文档对此非常明确。
- en: 'But we will be thinking in vectorized terms in many chapters of the book: when
    we discuss Cython, pandas, CPU vectorization, and, to an extreme level, GPU processing.
    It will probably make your learning curve in those chapters easier if you are
    exposed to these concepts in pure Python and NumPy before facing them in less
    familiar environments. In other words, the vectorization mentality stressed in
    this section will be very useful later.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但在本书的许多章节中，我们将以矢量化术语进行思考：当我们讨论Cython、pandas、CPU矢量化以及，达到极致的GPU处理时。如果你在遇到这些概念之前先在纯Python和NumPy中接触过这些概念，那么这可能会使你在这些章节中的学习曲线更加容易。换句话说，本节中强调的矢量化思维在以后将会非常有用。
- en: 'To understand vectorization and NumPy’s universal functions, we will return
    to a familiar example. From the previous subsection, we have seen that `brighter_image
    = image * 2` can overflow. How would a function that doesn’t overflow look? That
    is quite simple with a vectorized function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解矢量化以及 NumPy 的通用函数，我们将回到一个熟悉的例子。在前一小节中，我们看到了 `brighter_image = image * 2`
    可能会溢出。一个不会溢出的函数会是什么样子？使用矢量化函数就很简单：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will now vectorize this function and apply it to our image:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将矢量化这个函数并将其应用到我们的图像上：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① We need to specify the output type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要指定输出类型。
- en: '`np.vectorize` takes a typical (i.e., nonvectorized) function and, in this
    case, allows it to be applied to each scalar. We then apply the new `vec_double_wo_overflow`
    to our image. It will compute element by element.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.vectorize` 接收一个典型（即非矢量化）的函数，在这种情况下，允许它应用于每个标量。然后我们将新的 `vec_double_wo_overflow`
    应用到我们的图像上。它将逐元素计算。'
- en: Tip While `np.vectorize` is essentially a `for` loop, it could, in theory, be
    called in parallel using all the cores of your machine so it could potentially
    speed things up. Grasping this mode of programming and its potential for parallelization
    gives you great insight into how a GPU works. If you learn the concept here, you
    will have a much easier time when we discuss GPU optimizations in chapter 10.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 虽然 `np.vectorize` 实质上是一个 `for` 循环，但在理论上，它可以并行调用以使用机器的所有核心，从而可能加快速度。掌握这种编程模式和其并行化的潜力，将使你对
    GPU 的工作方式有更深刻的理解。如果你在这里学习了这个概念，那么在讨论第 10 章中的 GPU 优化时，你会更容易理解。
- en: Just to drive the message home that this code is not faster, a `%timeit` of
    our function is in the millisecond range. For the `*`, we are in the *microsecond*
    range.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这段代码并不更快，我们的函数的 `%timeit` 测试结果显示在毫秒范围内。对于 `*`，我们处于 *微秒* 范围。
- en: '`np.vectorize` is substantially more sophisticated than this, as it allows
    the support of broadcasting rules. To exemplify this, let’s take a color image
    as an example. We will use a NASA image, called “St. Patricks’s Aurora” ([https://images.nasa.gov/details-GSFC_20171208_Archive_e000760](https://images.nasa.gov/details-GSFC_20171208_Archive_e000760)).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.vectorize` 比这要复杂得多，因为它允许支持广播规则。为了举例说明这一点，让我们以一个彩色图像为例。我们将使用一个名为“圣帕特里克节极光”的
    NASA 图像（[https://images.nasa.gov/details-GSFC_20171208_Archive_e000760](https://images.nasa.gov/details-GSFC_20171208_Archive_e000760))。'
- en: 'Let’s start by reading the image, which has now a slightly different representation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从读取图像开始，现在的图像表示略有不同：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The image size is 2040 × 1367\. Because we are reading a color image, the default
    mode is RGB (i.e., three channels: red, green, and blue), and there will be an
    unsigned byte per channel. Each pixel now takes 3 bytes, not 1\. We thus have
    a three-dimensional NumPy array in the shape of 2048 × 1367 × 3\. Making an image
    grayscale is a trivial algorithm when we have a RGB image: we compute the mean
    of the three components and that becomes our gray intensity:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图像大小为 2040 × 1367。因为我们正在读取一个彩色图像，默认模式是 RGB（即三个通道：红色、绿色和蓝色），每个通道将有一个无符号字节。每个像素现在占用
    3 个字节，而不是 1 个。因此，我们有一个形状为 2048 × 1367 × 3 的三维 NumPy 数组。当我们有一个 RGB 图像时，将图像转换为灰度是一个简单的算法：我们计算三个分量的平均值，这成为我们的灰度强度：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① This is the mean of the three RGB values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是三个 RGB 值的平均值。
- en: ② The mean will be a float, so we convert it to int.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ② 平均值将是一个浮点数，因此我们将其转换为 int。
- en: ③ We override the default expectation for the signature of the function being
    vectorized.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们覆盖了矢量化函数签名的默认期望。
- en: While by default `np.vectorize` will send a scalar to our function, we can change
    the signature to accept and return other kinds of objects. In our case, we want
    our function to accept an array (i.e., the three components) and return a scalar,
    hence the signature `(n)→()`. The final result is shown in figure 4.10.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`np.vectorize` 将向我们的函数发送一个标量，但我们可以更改签名以接受和返回其他类型的对象。在我们的情况下，我们希望我们的函数接受一个数组（即三个分量）并返回一个标量，因此签名是
    `(n)→()`。最终结果如图 4.10 所示。
- en: '![](../Images/CH04_F10_Antao.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F10_Antao.png)'
- en: Figure 4.10 The result of our simple grayscaling algorithm
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 我们简单灰度化算法的结果
- en: Warning It is worthwhile repeating here that we are showing solutions for the
    sake of illustrating vectorization, and they might not be the most efficient.
    In this case, by far the most efficient and *best* solution would be
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 这里值得重复的是，我们展示的解决方案是为了说明矢量化，它们可能不是最有效的。在这种情况下，最有效和 *最佳* 的解决方案可能是
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will compute the means across the last axis (i.e., the one with the color
    channels). While an iterative solution is the worst choice, that doesn’t mean
    creating your own vectorized function is always the best approach. In this case,
    the best approach is a good understanding of the use of *built-in* vectorized
    functions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算最后一个轴（即颜色通道所在的轴）上的平均值。虽然迭代解法是最差的选择，但这并不意味着创建自己的向量化函数总是最佳方法。在这种情况下，最佳方法是充分理解内置向量化函数的使用。
- en: The takeaway
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验教训
- en: From a performance perspective, pure Python vectorization is not really an option.
    But in other contexts, such as working with Cython and GPUs, vectorization can
    have an effect of several orders of magnitude on performance. So if you understand
    the vectorization approach in general, it will be much easier to understand the
    Cython and GPU chapters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，纯Python向量化实际上并不是一个选项。但在其他上下文中，例如使用Cython和GPU时，向量化可以在性能上产生几个数量级的效应。所以如果你理解了向量化方法的一般原理，那么理解Cython和GPU章节将会容易得多。
- en: Now that we have considered the basics of NumPy programming for performance,
    we will take a look at NumPy internals and how we can optimize them for performance.
    It turns out that the choices that we make when we install NumPy can make quite
    a difference in terms of speed and multiprocessing choices.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考虑了NumPy编程性能的基础，我们将看看NumPy的内部结构以及如何优化它们以提高性能。结果是我们安装NumPy时所做的选择在速度和进程选择方面可以产生相当大的差异。
- en: 4.3 Tuning NumPy’s internal architecture for performance
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 调优NumPy内部架构以提高性能
- en: In this section, we will delve into NumPy and learn how to make sure it is configured
    for maximum performance. We start with an overview of NumPy’s internal architecture.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究NumPy，学习如何确保它配置为最大性能。我们首先概述NumPy的内部架构。
- en: A lot of NumPy’s internals that make it a highly performant library are not
    implemented in pure Python. This is not really a surprise, is it? The nonpure
    Python parts, especially the external libraries, can be configured, and those
    choices can have a massive effect on performance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使NumPy成为一个高性能库的许多内部实现并不是用纯Python编写的。这并不令人惊讶，对吧？非纯Python部分，特别是外部库，可以进行配置，这些选择可以对性能产生巨大影响。
- en: The subject of this next section might be, I have to be honest, a bit dry for
    programmers who are mostly concerned with the Python side of the equation. If
    you trust that your NumPy library is in good shape (or you have no control over
    it), then feel free to skip to the last subsection, Threads in NumPy, as it is
    very actionable from a Python side. If you have control over all your Python stack,
    you like systems-based problems, and you want to make sure you are extracting
    all performance possible, read on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节的主题可能对大多数只关心Python方面的程序员来说有点枯燥。如果你信任你的NumPy库状态良好（或者你无法控制它），那么你可以自由地跳到最后一个小节，即NumPy中的线程，因为它在Python方面非常实用。如果你控制着整个Python栈，喜欢系统级问题，并且想要确保你提取了所有可能的性能，请继续阅读。
- en: 4.3.1 An overview of NumPy dependencies
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 NumPy依赖概述
- en: 'Many scientific libraries, Python-based or not, depend on two widely used library
    APIs for linear algebra: BLAS (Basic Library Algebra System) and LAPACK (Linear
    Algebra PACKage).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 许多科学库，无论是基于Python的还是不是，都依赖于两个广泛使用的线性代数库API：BLAS（基本库代数系统）和LAPACK（线性代数包）。
- en: BLAS implements a set of basic functions to deal with arrays and matrices. The
    BLAS library will implement functions like vector addition and matrix multiplication.
    On top of that, LAPACK implements several linear algebraic algorithms. For example,
    SVD (singular value decomposition) is fundamental for principal components analysis.
    Figure 4.11 depicts NumPy’s architecture.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: BLAS实现了一套处理数组和矩阵的基本函数。BLAS库将实现如向量加法和矩阵乘法等函数。在此基础上，LAPACK实现了多个线性代数算法。例如，奇异值分解（SVD）是主成分分析的基础。图4.11展示了NumPy的架构。
- en: '![](../Images/CH04_F11_Antao.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F11_Antao.png)'
- en: Figure 4.11 The NumPy stack, including library dependencies
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 NumPy栈，包括库依赖
- en: There are many alternative implementations and the one you choose has operational
    consequences. For example, the standard LAPACK implementation available at [netlib.org](https://netlib.org/)
    is nonthreaded and not very efficient on modern architectures. A common BLAS/LAPACK
    alternative is OpenBLAS, and another is Intel MKL; both are threaded. The way
    you use your computer resources can vary substantially if your NumPy implementation
    is threaded or not. For example, if you have a nonthreaded version, you can allocate
    as many processes as CPU cores as you want, but if the BLAS and LAPACK are multithreaded,
    you have to be careful not to overcommit CPU resources.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多替代实现，你选择哪一个会有操作上的后果。例如，在[netlib.org](https://netlib.org/)上可用的标准LAPACK实现是非线程的，并且在现代架构上效率不高。一个常见的BLAS/LAPACK替代品是OpenBLAS，另一个是Intel
    MKL；两者都是线程化的。如果你的NumPy实现是线程化的，那么你使用计算机资源的方式可能会有很大的不同。例如，如果你有一个非线程化的版本，你可以分配尽可能多的进程，但如果你使用的是多线程的BLAS和LAPACK，你必须小心不要过度承诺CPU资源。
- en: 'Thus, knowing which libraries your NumPy implementation depends on is important
    to understand the next optimization steps. In theory, you can detect dependencies
    by using:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，了解你的NumPy实现依赖于哪些库对于理解下一步的优化步骤很重要。理论上，你可以通过以下方式检测依赖关系：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In practice, you might have to go to your file system and package management
    system to understand what is going on. For example, when I link MKL using Anaconda
    Python, part of the output is:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能需要访问你的文件系统和包管理系统来了解发生了什么。例如，当我使用Anaconda Python链接MKL时，部分输出如下：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you do this in your computer you might get lucky, but in my case, this is
    stupendously uninformative (`book-mkl` comes from the name I gave the environment;
    there is nothing to infer from it). To determine what I was using, I ended up
    doing `ls -l ''/home/tra/anaconda3/envs/book-mkl/lib/libcblas.so*` and noticed
    this: `libcblas .so.3 → libmkl_rt.so`. Hence, MKL seems to be the linked library.
    You might have to research what libraries are being linked in your case.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你可能会很幸运，但在我这个例子中，这非常没有信息量（`book-mkl`来自我给环境的命名；从中无法推断出任何信息）。为了确定我使用的是什么，我最终做了`ls
    -l '/home/tra/anaconda3/envs/book-mkl/lib/libcblas.so*'`并注意到这一点：`libcblas .so.3
    → libmkl_rt.so`。因此，MKL似乎是链接的库。你可能需要研究你自己的情况下链接了哪些库。
- en: Tip NumPy not only uses BLAS and LAPACK but also provides a Python interface
    to them so that you can access them directly if you desire. Or rather, SciPy provides
    that interface.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：NumPy不仅使用BLAS和LAPACK，还提供了对它们的Python接口，以便你可以直接访问它们（或者更确切地说，SciPy提供了这个接口）。
- en: SciPy is the sister library to NumPy, and they share a close historical relationship.
    SciPy implements higher-level functions than NumPy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy是NumPy的姐妹库，它们有着密切的历史关系。SciPy实现了比NumPy更高级的功能。
- en: 'Because NumPy and SciPy share such a close relationship, you might be confused
    by their APIs. SciPy’s documentation makes this very clear. Here is a verbatim
    copy of the SciPy linear algebra module, `scipy.linalg`, documentation:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NumPy和SciPy有着如此紧密的关系，你可能会被它们的API所困惑。SciPy的文档对此非常明确。以下是SciPy线性代数模块`scipy.linalg`的文档的逐字复制：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, sometimes SciPy imports, and re-exports, NumPy functions. Sometimes the
    APIs can be slightly different. Sometimes the implementations can be completely
    different.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时SciPy会导入并重新导出NumPy函数。有时API可能略有不同。有时实现可能完全不同。
- en: 'If you want, you can access BLAS as LAPACK directly: you can find Python APIs
    in, respectively, `scipy.linalg.blas` and `scipy.linalg.lapack`. If you were thinking
    that it would make more sense to have this interface in NumPy and not SciPy, know
    that you are not alone.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以直接将BLAS作为LAPACK访问：你可以在`scipy.linalg.blas`和`scipy.linalg.lapack`中找到相应的Python
    API。如果你认为在NumPy而不是SciPy中拥有这个接口更有意义，要知道你并不孤单。
- en: You can thus make use of the libraries directly from Python, but it tends to
    be more useful, from a performance perspective, to use a library from a lower-level
    language. We will not discuss it here further, but we will revisit this in the
    Cython chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以直接从Python中使用这些库，但从性能角度来看，使用底层语言的库更有用。我们在这里不再进一步讨论，但将在Cython章节中重新讨论这个问题。
- en: Before we return to more practical concerns regarding NumPy internals, we still
    need to discuss the effect of our installation on performance by taking a look
    at Python distributions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回到关于NumPy内部更实际的问题之前，我们仍然需要通过查看Python发行版来讨论我们的安装对性能的影响。
- en: 4.3.2 How to tune NumPy in your Python distribution
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 如何调整Python发行版中的NumPy
- en: Here we’ll explore some tips on how to make sure your NumPy is optimized for
    your distribution. It is impossible to cover all existing Python distributions
    against all operating systems so we will cover the standard Python one from [python.org](https://www.python.org/)
    and Anaconda Python. We will be using Linux, given that this is also OS dependent.
    The comments will be made in a general way to be useful in other scenarios.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨一些确保你的NumPy针对你的发行版进行优化的技巧。由于无法涵盖所有现有的Python发行版和操作系统，我们将涵盖来自[python.org](https://www.python.org/)的标准Python和一个Anaconda
    Python。我们将使用Linux，因为这也是操作系统相关的。评论将以通用方式编写，以便在其他场景中也有用。
- en: If you install NumPy on the standard distribution, you will most probably do
    it by using `pip install numpy`. This will only work if you have BLAS and LAPACK
    installed in your operating system. The problem becomes then *what* version is
    installed? The most common version is the original NetLib one, which is slow and
    not threaded. This will be terrible from a performance perspective. You will then
    have to make sure that (1) you install something more efficient like OpenBLAS
    or Intel’s MKL, and (2) following the previously discussed `np.show_config` trail,
    you are linking the fastest BLAS/LAPACK version on your system.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个标准发行版上安装NumPy，你很可能会通过使用`pip install numpy`来安装它。这只有在你的操作系统中已经安装了BLAS和LAPACK的情况下才会工作。问题变成了*安装了什么版本？*
    最常见的版本是原始NetLib版本，它速度慢且不是线程化的。这从性能角度来看将是可怕的。你将不得不确保（1）你安装了更高效的版本，如OpenBLAS或Intel的MKL，并且（2）按照之前讨论的`np.show_config`方法，你正在链接系统中最快的BLAS/LAPACK版本。
- en: If you use another distribution, it is quite possible that the packaging system
    of that distribution will take care of BLAS and LAPACK for you. Furthermore, the
    dependency install will be quite reasonable. For example, with Anaconda Python,
    when you do `conda install numpy`, at this point, you will probably be getting
    OpenBLAS, which is fine for most cases.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用另一个发行版，那么那个发行版的打包系统很可能已经为你处理了BLAS和LAPACK。此外，依赖性安装也将相当合理。例如，在使用Anaconda
    Python时，当你执行`conda install numpy`，此时你可能会得到OpenBLAS，这对于大多数情况来说都是可以的。
- en: 'While the default installed with most scientific Python distributions is probably
    good enough, you might want to consider alternatives. Most distributions will
    allow you to do that. For example, with Anaconda, you can install NumPy with MKL
    by using:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数科学Python发行版默认安装的版本可能已经足够好，但你可能想要考虑其他替代方案。大多数发行版都允许你这样做。例如，在使用Anaconda时，你可以通过以下方式使用MKL安装NumPy：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We create a new environment called `book-mkl` just to be sure the current environment
    is untouched and maintains its defaults. We then install `blas=*=mk`, which specifies
    the MKL build of BLAS. With that at the core, we can go ahead and install NumPy.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`book-mkl`的新环境，以确保当前环境不受影响并保持其默认设置。然后我们安装`blas=*=mk`，这指定了MKL构建的BLAS。有了这个核心，我们可以继续安装NumPy。
- en: Tip For most use cases, you need to make sure you are not using the slow NetLib
    implementation of BLAS. In many situations, either OpenBLAS or MKL will be good
    enough. If you use other implementations, you will have to research them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：对于大多数用例，你需要确保你没有使用速度较慢的NetLib BLAS实现。在许多情况下，OpenBLAS或MKL将足够好。如果你使用其他实现，你将不得不研究它们。
- en: If you really need to squeeze the maximum performance possible out of your system,
    then you will have to benchmark the alternative implementations yourself. While
    there are some benchmarks available on the internet, you should devise a test
    for *your* specific code because different implementations have different strengths,
    and no size fits all in terms of benchmarking.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要从你的系统中榨取尽可能多的性能，那么你必须自己基准测试替代实现。虽然互联网上有些基准测试可用，但你应该为你的特定代码设计一个测试，因为不同的实现有不同的优势，基准测试没有一种适合所有情况。
- en: Now that you have your NumPy installation properly configured, let’s make use
    of it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经正确配置了NumPy安装，让我们来利用它。
- en: 4.3.3 Threads in NumPy
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 NumPy中的线程
- en: 'NumPY will be threaded or not depend on the BLAS/LAPACK implementations. Most
    implementations of BLAS/LAPACK libraries are threaded—the GIL is released by NumPy,
    so we are talking real parallelism here—and you can make use of them. But there
    are two caveats: (1) most, but not all, implementations are threaded, and (2))
    you might actually prefer BLAS/LAPACK to be single-threaded.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: NumPY是否使用线程取决于BLAS/LAPACK的实现。大多数BLAS/LAPACK库的实现都是线程化的——NumPy释放了全局解释器锁（GIL），所以我们在这里谈论的是真正的并行性——你可以利用它们。但是有两个注意事项：（1）大多数但并非所有实现都是线程化的，（2）你可能实际上更喜欢BLAS/LAPACK是单线程的。
- en: Imagine the following scenario in our image processing application. You have
    thousands of images to process, and as such, you spawn 8 parallel processes on
    your eight-core machine. If your NumPy is threaded, you will end up with 8 processes,
    each running 8 threads for a total of 64 concurrent threads. We want the compound
    maximum to be just eight.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下场景在我们的图像处理应用程序中。你有成千上万张图像需要处理，因此你在八核机器上启动了8个并行进程。如果你的NumPy是线程化的，你最终会有8个进程，每个进程运行8个线程，总共64个并发线程。我们希望复合最大值仅为8。
- en: To be more efficient, it is quite common to have eight processes of one thread
    each rather than one process with eight threads. Remember that the non-BLAS code
    in each Python process will be single-threaded, so you only make use of the eight
    threads when you are inside NumPy/BLAS.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，通常有一个线程数为一个的八个进程，而不是一个有八个线程的进程。记住，每个Python进程中的非BLAS代码将是单线程的，所以你只有在NumPy/BLAS内部时才使用这八个线程。
- en: Sometimes we would like to reduce the number of threads used by BLAS and LAPACK,
    potentially to one. That should be easy, right? Unfortunately, there is no way
    to control the number of threads in NumPy directly. You have to configure the
    BLAS/ LAPACK implementation; hence, the code is not portable.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能希望减少BLAS和LAPACK使用的线程数量，可能减少到一。这应该很容易，对吧？不幸的是，没有直接控制NumPy中线程数量的方法。你必须配置BLAS/LAPACK实现；因此，代码是不可移植的。
- en: 'For NetLib, it is simple because it’s single-threaded. However, you should
    avoid it anyway if you are looking for performance. OpenBLAS and Intel’s MKL have
    different interfaces, as they can still have another lower-level dependency for
    doing the threading: they *might* be compiled and dependent on OpenMP. So you
    have to configure your BLAS/LAPACK implementation and *maybe* the multiprocessing
    library being used.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NetLib，因为它单线程，所以很简单。然而，如果你在寻找性能，你应该避免使用它。OpenBLAS和Intel的MKL有不同的接口，因为它们仍然可能有一个用于线程的更低级别的依赖：它们*可能*被编译并依赖于OpenMP。因此，你必须配置你的BLAS/LAPACK实现，*可能*还要配置使用的多进程库。
- en: 'For OpenBLAS, before you call your Python code, do:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OpenBLAS，在你调用Python代码之前，请执行：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① The standard way to configure OpenBLAS
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ① 配置OpenBLAS的标准方式
- en: ② Legacy variable based on the original package GotoBLAS2 that OpenBLAS forked
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ② 基于原始包GotoBLAS2的OpenBLAS的遗留变量
- en: ③ Just in case OpenBLAS is using OpenMP
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 万一OpenBLAS使用了OpenMP
- en: 'For MKL, you will need:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MKL，你需要：
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① The standard way to configure MKL
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ① 配置MKL的标准方式
- en: ② Just in case OpenBLAS is using OpenMP
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ② 万一OpenBLAS使用了OpenMP
- en: For other libraries, you will have to check yourself. Be careful with potential
    dependencies on lower-level threading libraries like OpenMP and their configuration
    requirements.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他库，你需要自己检查。在使用像OpenMP这样的底层线程库及其配置要求时，要小心潜在的依赖关系。
- en: 'From a practical standpoint, there is still another problem: when you move
    your code from one computer to another—say, your development machine to production—the
    linked libraries might change. You can tune your initialization code to account
    for that or just set all variables for all libraries all the time, which is a
    more pragmatic solution.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度出发，还有一个问题：当你将代码从一个计算机移动到另一个计算机时——比如说，从你的开发机器到生产环境——链接的库可能会发生变化。你可以调整你的初始化代码来适应这种情况，或者始终为所有库设置所有变量，这是一个更实际的解决方案。
- en: The Takeaway
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: Perhaps looking into the details of NymPy’s underlying libraries is not the
    most exciting takeaway from this book. But if you want an efficient use of NumPy
    and all the stack on top of it, it’s important to investigate which libraries
    your NumPy implementation depends on, optimize NumPy for your Python distribution,
    and find out whether the underlying libraries use multithreading.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 也许深入研究NymPy底层库的细节并不是这本书最令人兴奋的收获。但如果你想高效地使用NumPy及其之上的所有堆栈，了解你的NumPy实现所依赖的库、为你的Python发行版优化NumPy以及找出底层库是否使用多线程是很重要的。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Array views can be extremely efficient compared to copies, both in terms of
    memory and performance. They should be considered when possible.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与复制相比，数组视图在内存和性能方面都可以非常高效。在可能的情况下应该考虑使用它们。
- en: NumPy’s view machinery is very flexible and can be used to render perspectives
    over existing data with very little computing and memory costs.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy的视图机制非常灵活，可以用极低的计算和内存成本渲染现有数据的不同视角。
- en: Understanding shape (i.e., the number of elements across each dimension of an
    array) and strides (i.e., the number of bytes to step in each dimension to find
    the next element) is the basis of making the most use of views. Both shape and
    stride can be changed from view to view to present data differently.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解形状（即数组每个维度上的元素数量）和步长（即在每个维度上跳过的字节数以找到下一个元素）是充分利用视图的基础。形状和步长都可以从视图到视图进行更改，以不同的方式呈现数据。
- en: Array programming (i.e., doing declarative operations on whole arrays instead
    of using an imperative style element by element) can provide an orders of magnitude
    increase in performance. It should be used whenever possible.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组编程（即对整个数组执行声明性操作，而不是逐个元素使用命令式风格）可以提供数量级的性能提升。在可能的情况下应该使用它。
- en: NumPy’s broadcasting rules—the flexible way NumPy can use operators over arrays
    of different dimensions—allow for more efficient and elegant programming.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy的广播规则——NumPy可以灵活地在不同维度的数组上使用运算符——允许更高效和优雅的编程。
- en: The internal architecture of NumPy can be optimized for computing performance.
    NumPy depends on BLAS and LAPACK libraries, and there are different offerings
    available for those.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy的内部架构可以针对计算性能进行优化。NumPy依赖于BLAS和LAPACK库，并且为这些库提供了不同的选择。
- en: Make sure you check that your NumPy implementation is using the most efficient
    libraries for your architecture.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保检查你的NumPy实现是否使用了针对你架构的最有效库。
- en: Parallel programming in NumPy can be tricky because the threading semantics
    of NumPy depends on the threading semantics of algebra libraries.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NumPy中进行并行编程可能很棘手，因为NumPy的线程语义依赖于代数库的线程语义。
- en: Make sure you understand whether NumPy’s underlying libraries make use of multithreading
    before you use Python-based multiprocessing on top of your NumPy implementation.
    If they don’t use multithreading, you probably should change the underlying libraries.
    If they do, you should be careful not to use multiprocessing on top of NumPy calls
    that are themselves multithreaded.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用基于Python的进程多处理在NumPy实现之上之前，确保你理解NumPy的底层库是否使用了多线程。如果它们没有使用多线程，你可能应该更改底层库。如果它们确实使用了多线程，你应该小心不要在本身是线程化的NumPy调用上使用多进程。
- en: There is much more to be said about NumPy as it is *the* core of data analysis
    in Python. Given its importance, we will revisit the library in other chapters.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于NumPy还有很多可以说的，因为它是Python数据分析的核心。鉴于其重要性，我们将在其他章节重新审视这个库。
- en: '* * *'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**** '
- en: ¹  For very small arrays this doesn’t hold as metadata would be an important
    portion of the allocation, but for large arrays, which are what we care about,
    it is a very good approximation as the 96 bytes of overhead from Python and NumPy
    are negligible.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 对于非常小的数组，这并不成立，因为元数据将是分配的重要部分，但对于我们关心的较大数组来说，这是一个非常好的近似，因为Python和NumPy的96字节开销是可以忽略不计的。
- en: ²  There is a very simple solution to this problem that is not very useful from
    a pedagogical perspective. Can you think of it? As a tip, consider using the maximum
    instead of the minimum.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ² 对于这个问题有一个非常简单的解决方案，但从教学角度来看并不很有用。你能想到吗？作为一个提示，考虑使用最大值而不是最小值。
