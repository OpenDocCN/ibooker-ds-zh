- en: 4 Dealing with sequence data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 处理序列数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Using slice objects to retrieve and manipulate subsequences
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切片对象来检索和操作子序列
- en: Combining the use of positive and negative indexing in item retrieval
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合使用正负索引进行项目检索
- en: Finding items in a sequence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在序列中查找项目
- en: Unpacking a sequence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包序列
- en: Considering data models other than lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑除列表之外的数据模型
- en: 'In chapter 3, you learned to use lists and tuples to hold data. One shared
    characteristic of lists and tuples is that the held items have a specific order.
    These two data structures are examples of the more general data type *sequence.*
    Python has other sequence data types, such as strings and bytes. These sequence
    data models are essential data structures that we use in our projects. The reason
    is simple: we use data to model real life, which is full of ordered objects/events,
    such as waiting lines, written languages, and house numbers, to name a few. Thus,
    the effective handling of sequence data is a universal need in programming projects
    regardless of our business specialty.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，你学习了如何使用列表和元组来存储数据。列表和元组的一个共同特征是它们持有的项目具有特定的顺序。这两个数据结构是更通用数据类型*序列*的例子。Python还有其他序列数据类型，如字符串和字节。这些序列数据模型是我们项目中使用的必要数据结构。原因很简单：我们使用数据来模拟现实生活，现实生活充满了有序的对象/事件，例如排队、书面语言和门牌号码，仅举几例。因此，有效地处理序列数据是编程项目中的普遍需求，无论我们的业务专业是什么。
- en: From Python’s implementation perspective, these sequence data structures share
    many characteristics, and it’s worth discussing them together here. You want to
    kill two birds with one stone, and you’ll find that the skills you may have thought
    applied only to a specific data model (such as unpacking a tuple object) can be
    applied to all sequence data models. As a related note, even though I’ll mostly
    use lists or strings in the examples in this chapter, don’t mistakenly think that
    these techniques are available only to lists or strings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python的实现角度来看，这些序列数据结构有许多共同特征，在这里一起讨论它们是值得的。你希望一石二鸟，你会发现你可能认为只适用于特定数据模型（例如解包元组对象）的技能可以应用于所有序列数据模型。作为一个相关的说明，尽管我在本章的示例中主要使用列表或字符串，但不要错误地认为这些技术仅适用于列表或字符串。
- en: 4.1 How do I retrieve and manipulate subsequences with slice objects?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 我如何使用切片对象检索和操作子序列？
- en: 'When we have sequence data, we may be interested in obtaining a specific subset
    of the sequence, which we refer to as *subsequence.* The built-in data types include
    the common sequence data models str, list, and tuple:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有序列数据时，我们可能对获取序列的特定子集感兴趣，我们将其称为*子序列*。内置的数据类型包括常见的序列数据模型str、list和tuple：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we retrieve a subsequence of a list object, we can use slicing. The simplest
    form of slicing is list[start:end], and the items between the start and end indices
    (the item at the end index is excluded) are retrieved:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从列表对象检索子序列时，我们可以使用切片。切片的最简单形式是list[start:end]，在起始和结束索引之间（不包括结束索引处的项目）的项目将被检索：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this section, going beyond the basic form of slicing list[start:end], I’ll
    be discussing more advanced features of slicing, and you’ll learn how to use these
    features to retrieve and manipulate subsequences.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将超越基本形式的切片列表[start:end]，讨论切片的更多高级特性，你将学习如何使用这些特性来检索和操作子序列。
- en: 4.1.1 Taking advantage of the full features of slicing
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 充分利用切片的完整功能
- en: 'Besides specifying the start and end indices, slicing has a variety of permutations,
    giving us different ways to retrieve subsequences. We’ll discuss the most notable
    ones here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定起始和结束索引外，切片有多种排列组合，给我们提供了不同的方式来检索子序列。我们将在这里讨论最显著的一些：
- en: Ignoring the start or the end index
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略起始或结束索引
- en: Not abusing the tolerance of out-of-range slicing indices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要滥用超出范围的切片索引的容错性
- en: Applying stride to the slicing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将步长应用于切片
- en: Ignoring the start or the end index
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略起始或结束索引
- en: 'By default, the start index is zero, so if you want to retrieve the first *n*
    items, the Pythonic way is by omitting the start index and using list[:end]. By
    default, the end index is the length of the list, and slicing selection doesn’t
    include the end index, so if you want to retrieve the last *n* items of a list,
    you use list[start:]. As you can tell, ignoring the start or end index removes
    the unnecessary code and improves readability:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，起始索引为零，因此如果你想检索前*n*个元素，Python的方式是省略起始索引并使用list[:end]。默认情况下，结束索引是列表的长度，并且切片选择不包括结束索引，所以如果你想检索列表的最后*n*个元素，你使用list[start:]。正如你所看到的，忽略起始或结束索引可以删除不必要的代码并提高可读性：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if you ignore both the start and end indices? You may have guessed the
    right answer: list[:] retrieves all the items, which are a copy of the original
    list. (Section 10.3 discusses copying objects in more detail.) The following code
    snippet shows you that [:] retrieves all the items of the list object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时忽略起始和结束索引怎么办？你可能已经猜到了正确答案：list[:]检索所有元素，这是原始列表的副本。（第10.3节更详细地讨论了复制对象。）以下代码片段显示了[:]检索列表对象的所有元素：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Readability The code is easier to read when you ignore the start or the end
    index (if possible).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 当你忽略起始或结束索引（如果可能的话），代码更易于阅读。
- en: Not abusing the tolerance of out-of-range slicing indices
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不要滥用超出范围切片索引的容忍
- en: 'One feature of slicing is the tolerance of out-of-range indices, as Python
    bounds the slicing with the maximally allowed range. Each item in a sequence has
    an index to denote its position. When you use an index that matches no items in
    the sequence, you encounter the IndexError exception, stating that the used index
    is out of range:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的一个特点是容忍超出范围的索引，因为Python使用最大允许的范围来限制切片。序列中的每个元素都有一个索引来表示其位置。当你使用一个与序列中没有任何元素匹配的索引时，你会遇到IndexError异常，指出所使用的索引超出范围：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notably, Python tolerates the used indices in slicing if they’re out of the
    available range, such as using indices that don’t correspond to any item in a
    sequence. Consider the following examples to observe this feature:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显著的是，Python容忍切片中使用的超出范围的索引，例如使用与序列中任何元素都不对应的索引。考虑以下示例来观察此功能：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Uses an index greater than the last item’s
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用大于最后一个元素的索引
- en: ❷ Uses an index smaller than the first item’s
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用小于第一个元素的索引
- en: Although slicing’s tolerance of out-of-range indices appears to give us the
    flexibility of retrieving items, I don’t recommend using this feature because
    it confuses readers. They may wonder whether the code contains a typo or the programmer
    forgot to update the indices. Either way, your code loses its clarity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然切片对超出范围索引的容忍似乎给了我们检索元素的灵活性，但我不建议使用此功能，因为它会混淆读者。他们可能会想知道代码中是否有拼写错误或程序员忘记更新索引。无论如何，你的代码都会失去其清晰性。
- en: Maintainability When you use out-of-range indices, you’re only confusing yourself
    or your teammates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 当你使用超出范围的索引时，你只是在混淆自己或你的队友。
- en: Applying stride to the slicing
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将步长应用于切片
- en: 'We can apply stride to the slicing to retrieve evenly spaced items. Slicing
    annotation accepts an optional stride parameter: list[start:end:stride], which
    takes every *n*th item from start until it reaches end. When we use stride (or
    step, as some users name this parameter), we can still omit the start and end
    indices, and Python supplies the applicable boundaries for us. Following are some
    common usages (illustrated in figure 4.1):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将步长应用于切片以检索等间隔的元素。切片注解接受一个可选的步长参数：list[start:end:stride]，它从起始位置取每*n*个元素，直到达到结束。当我们使用步长（或一些用户称之为步）时，我们仍然可以省略起始和结束索引，Python会为我们提供适用的边界。以下是一些常见用法（如图4.1所示）：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ When the stride is 2, every other item is kept.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当步长为2时，每隔一个元素被保留。
- en: ❷ When the stride is 3, every third item is kept.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当步长为3时，每隔两个元素被保留。
- en: ❸ When the stride is -1, slicing starts from the right and moves toward the
    left.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当步长为-1时，切片从右侧开始并朝左侧移动。
- en: Using positive strides is straightforward. Notably, slicing also supports negative
    strides, which can be confusing to many people. One Python trick that many people
    have seen is reversing a list using list[::-1], as shown in the preceding example,
    but many people don’t understand why. The reason is that when the step is negative,
    the slicing starts from the right side and moves to the left side. Thus, the step
    of -1 means that we’re continuously retrieving the item to the left. Because we
    didn’t specify the start and end indices, the entire list was sliced from the
    right to the left; thus, it was reversed. Figure 4.1 shows the contrast between
    positive and negative strides.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正步长很简单。值得注意的是，切片还支持负步长，这对许多人来说可能会令人困惑。许多人看到的一个Python技巧是使用list[::-1]反转列表，如前例所示，但许多人不明白为什么。原因是当步长为负时，切片从右侧开始并向左侧移动。因此，步长-1意味着我们正在连续检索左侧的项目。因为我们没有指定起始和结束索引，所以整个列表从右侧到左侧被切片；因此，它被反转了。图4.1展示了正负步长之间的对比。
- en: '![CH04_F01_Cui](../Images/CH04_F01_Cui.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Cui](../Images/CH04_F01_Cui.png)'
- en: Figure 4.1 Slicing a list with positive and negative strides. When the stride
    is positive, slicing starts from the left side. When the stride is negative, slicing
    starts from the right side.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1使用正负步长进行列表切片。当步长为正时，切片从左侧开始。当步长为负时，切片从右侧开始。
- en: Although slicing supports negative steps, I don’t recommend using this feature
    because it reduces readability. If you want subsequences from the left to the
    right, you can use the reverse method to reverse the list in place (calling reverse
    changes the original list), and then perform any slicing operations in the left-to-right
    direction. This approach requires an extra line of code, but it makes it much
    easier for readers to understand the slicing operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然切片支持负步长，但我不建议使用此功能，因为它会降低可读性。如果您想从左到右获取子序列，可以使用reverse方法就地反转列表（调用reverse会改变原始列表），然后以从左到右的方向执行任何切片操作。这种方法需要额外的代码行，但它使读者更容易理解切片操作。
- en: Maintainability Avoid negative steps other than -1 when you use slices. They’re
    not intuitive and can cause great confusion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：在使用切片时，除了-1之外，避免使用负步长。它们不直观，可能会造成很大的困惑。
- en: 4.1.2 Not confusing slices with ranges
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 不要混淆切片和range
- en: 'Under the hood, retrieving a subsequence involves creating a slice object.
    That is, slicing a list list[start:stop:end] is equivalent to list[slice(start,
    stop, step)]. But another class, range, has the same calling signature: range(start,
    stop, step). This similarity confuses some beginners. In this section, I clarify
    this.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，检索子序列涉及创建切片对象。也就是说，切片列表list[start:stop:end]等价于list[slice(start, stop, step)]。但另一个类range具有相同的调用签名：range(start,
    stop, step)。这种相似性可能会让一些初学者感到困惑。在本节中，我将澄清这一点。
- en: 'slice and range are similar, as their constructors take start, stop, and step,
    creating the three attributes start, stop, and step:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: slice和range相似，因为它们的构造函数接受起始值、结束值和步长，创建三个属性：start、stop和step：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These similarities can be confusing. Slices and ranges differ in two aspects,
    however, making them not interchangeable. First, ranges are iterables, but slices
    are not. The implication is that we can use ranges to create a list or use them
    in a for loop, whereas we can’t use slices in these operations. The following
    code snippet shows an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相似之处可能会令人困惑。然而，切片和range在两个方面有所不同，这使得它们不能互换。首先，range对象是可迭代的，而切片对象不是。这意味着我们可以使用range对象创建列表或将其用于for循环，而我们不能在这些操作中使用切片对象。以下代码片段展示了示例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Second, we can use a slice object to retrieve items in a list or other sequence
    data. In the following example, we get the odd numbers with the slice object,
    but the same operation is not allowed with a range object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以使用切片对象来检索列表或其他序列数据中的项目。在下面的示例中，我们使用切片对象获取奇数，但使用range对象进行相同的操作是不允许的：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 4.2 shows you how slice and range objects differ; it also shows their
    similarities in constructors and attributes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2展示了切片对象和range对象之间的差异；它还展示了它们在构造函数和属性上的相似之处。
- en: '![CH04_F02_Cui](../Images/CH04_F02_Cui.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Cui](../Images/CH04_F02_Cui.png)'
- en: Figure 4.2 The similarities and differences between slice and range objects.
    They have a similar constructor pattern and attributes. Ranges, but not slices,
    are iterables, whereas slices, but not ranges, serve as subscripts for retrieving
    items from a sequence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2切片对象和range对象之间的相似之处和不同之处。它们具有相似的构造函数模式和属性。range对象是可迭代的，而切片对象不是。这意味着我们可以使用range对象创建列表或将其用于for循环，而我们不能在这些操作中使用切片对象。以下代码片段展示了示例：
- en: 4.1.3 Using named slice objects to process sequence data
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 使用命名切片对象处理序列数据
- en: 'Most of the time, we use subscript-based slicing to retrieve items: list[start:stop].
    This approach works when the data in the sequence is straightforward. When the
    sequence has more complicated data, however, we should use slice objects with
    sensible names to improve our code’s readability.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们使用基于下标的切片来检索项：`list[start:stop]`。当序列中的数据简单时，这种方法有效。然而，当序列有更复杂的数据时，我们应该使用具有合理名称的切片对象来提高代码的可读性。
- en: 'Suppose that we’re processing text data generated from an external source for
    our task management app. Due to some formatting settings, the text data looks
    like this (the numbers in the text are the indices of the characters):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理为我们任务管理应用生成的外部源文本数据。由于一些格式设置，文本数据看起来像这样（文本中的数字是字符索引）：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the text, we notice that the same fields of data are aligned vertically in
    each row. Using slice objects is a best practice, and you can find a possible
    implementation in the next listing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本中，我们注意到相同的数据字段在每一行中垂直对齐。使用切片对象是一种最佳实践，你可以在下一个列表中找到一个可能的实现。
- en: Listing 4.1 Using named slices in processing data
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 在数据处理中使用命名切片
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Uses the strip method to get rid of trailing spaces
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用条带法去除尾随空格
- en: To separate the task ID, title, description, and urgency level, we create four
    slice objects that extract each corresponding substring. Technically, we can apply
    slicing directly to the string, such as line[:5] for the title. The names of these
    slice objects, however, clearly indicate what data each slice obtains. More importantly,
    from a maintainability perspective, when we’re using named slices, if we have
    formatting changes in the text files, such as extra spaces between data fields,
    it’s easier to modify slice objects by updating the indices to reflect the new
    formatting requirements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离任务ID、标题、描述和紧急程度，我们创建了四个切片对象，分别提取每个对应的子字符串。技术上，我们可以直接对字符串应用切片，例如`line[:5]`用于标题。然而，这些切片对象的名称清楚地表明了每个切片获取的数据。更重要的是，从可维护性的角度来看，当我们使用命名切片时，如果文本文件中有格式更改，例如数据字段之间的额外空格，通过更新索引以反映新的格式要求，修改切片对象会更简单。
- en: Maintainability Named slices are easy to read and clearly indicate what data
    they’re representing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 命名切片易于阅读，并清楚地表明它们代表什么数据。
- en: 4.1.4 Manipulating list items with slicing operations
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 使用切片操作操作列表项
- en: In sections 4.1.1 to 4.1.3, you learned about retrieving subsequences with slicing.
    These operations are available to all sequence data models, including mutable
    ones, such as list and bytearray, and to immutable ones, such as tuple and string
    (table 4.1). Mutable sequence data models support another set of operations, which
    we term *slice surgery.* In this section, you’ll learn how to manipulate items
    in a mutable sequence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.1.1到4.1.3节中，你学习了如何使用切片检索子序列。这些操作对所有序列数据模型都可用，包括可变的，如列表和bytearray，以及不可变的，如元组和字符串（表4.1）。可变序列数据模型支持另一组操作，我们称之为*切片手术*。在本节中，你将学习如何操作可变序列中的项。
- en: Table 4.1 Common sequence data models as a function of mutability
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 可变序列数据模型作为可变性的函数
- en: '| Mutability | Data types | Allowed for slice surgery |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 可变性 | 数据类型 | 允许切片手术 |'
- en: '| Mutable | list, bytearray | Yes |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 可变 | list, bytearray | 是 |'
- en: '| Immutable | str, tuple, range, bytes | No |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 不可变 | str, tuple, range, bytes | 否 |'
- en: 'Using lists as an example, slice surgery means that we can manipulate a list’s
    subsequence obtained with a slice object. We can do several things with slice
    surgery to manipulate a subsequence, including replacement, extension, shrinkage,
    and removal. To replace a subsequence, we assign the same number of items to the
    subsequence that is retrieved:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以列表为例，切片手术意味着我们可以使用切片对象操作列表的子序列。我们可以通过切片手术对子序列执行几个操作，包括替换、扩展、收缩和删除。要替换子序列，我们将相同数量的项目分配给检索到的子序列：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To extend a subsequence, we assign a longer subsequence to the original subsequence:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展子序列，我们将较长的子序列分配给原始子序列：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To shrink a subsequence, we assign a shorter subsequence to the original one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要收缩子序列，我们将较短的子序列分配给原始子序列：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notably, the subsequence doesn’t have to be contiguous. Even with a stride
    in the slice, we can still perform a replacement. As shown in the following example,
    because the stride is 2, we’re updating every second item in the list, using the
    provided items:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，子序列不必是连续的。即使在切片中有步长，我们仍然可以执行替换。如下例所示，因为步长是2，所以我们正在更新列表中的每个第二个项目，使用提供的项目：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When necessary, you can remove a subsequence by using the del statement. Alternatively,
    you can assign an empty list to the subsequence so that the corresponding items
    are removed too:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，你可以使用del语句删除子序列。或者，你可以将空列表赋值给子序列，这样相应的项目也会被删除：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 4.1.5 Discussion
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 讨论
- en: When you use a negative step in slicing, the slicing processes the sequence
    from right to left. Because people are generally more familiar with left-to-right
    order, negative striding can be confusing, and you should use it with caution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在切片中使用负步长时，切片会从右向左处理序列。因为人们通常更熟悉从左到右的顺序，所以负步长可能会令人困惑，你应该谨慎使用。
- en: When you process a series of sequences in a consistent format, as shown in the
    example of processing the text data (section 4.1.3), you should use named slice
    objects, because each name clearly indicates the data that corresponds to that
    subsequence, improving your code’s readability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以一致格式处理一系列序列时，例如在处理文本数据（第4.1.3节）的示例中，你应该使用命名切片对象，因为每个名称都清楚地指明了对应子序列的数据，这可以提高你代码的可读性。
- en: 4.1.6 Challenge
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6 挑战
- en: Jason is learning Python to analyze news about tourism as part of his machine
    learning interests. In his job, he deals with a variety of sequence data. He wants
    to try slicing with different sequence data types, such as strings and tuples.
    Can you help him find the data types for the generated subsequences of these sequence
    types? Note that as revealed in table 4.1, ranges are also a type of sequence.
    Please also try to subsequence ranges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 杰森正在学习Python，以便分析有关旅游的新闻，这是他机器学习兴趣的一部分。在他的工作中，他处理各种序列数据。他想尝试使用不同序列数据类型（如字符串和元组）进行切片。你能帮助他找到这些序列类型生成的子序列的数据类型吗？请注意，如表4.1所示，范围也是一种序列类型。请尝试子序列范围。
- en: Hint The generated subsequence should resemble the “parent” sequence in terms
    of its type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：生成的子序列在类型上应该类似于“父”序列。
- en: 4.2 How do I use positive and negative indexing to retrieve items?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 我如何使用正负索引来检索项目？
- en: 'One shared characteristic of sequence objects is that the stored data follows
    the linear order, and each data point corresponds to a specific index, so we can
    use indexing to retrieve the data from the sequence. In most programming languages,
    the index starts counting from the left. Because we know that lists are a representative
    sequence data model, we’ll use the following list object as an example throughout
    this section. Specifically, this list object stores the monthly revenue of a bookstore
    for the past year:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 序列对象的一个共同特征是存储的数据遵循线性顺序，每个数据点对应一个特定的索引，因此我们可以使用索引从序列中检索数据。在大多数编程语言中，索引从左侧开始计数。因为我们知道列表是代表性的序列数据模型，所以在本节中我们将使用以下列表对象作为示例。具体来说，这个列表对象存储了过去一年书店的月收入：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Suppose that we want to retrieve November’s record. How can we do that? In this
    section, you’re learning about using positive and negative indexing to solve data
    retrieval questions from a sequence. As you’ll see, Python supports indices counting
    from the right (negative indexing), and you’ll learn when to use positive or negative
    indexing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想检索11月的记录。我们该如何做？在本节中，你将学习如何使用正负索引来解决从序列中检索数据的问题。正如你将看到的，Python支持从右向左计数的索引（负索引），你将学习何时使用正索引或负索引。
- en: 4.2.1 Positive indexing starts from the beginning of the list
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 正向索引从列表的起始位置开始
- en: 'In section 4.1, you’ve seen that slices use positive indexing to create a subsequence.
    From a general perspective, as in most other languages, we retrieve individual
    items based on their indices, starting with 0 from the left. In this section,
    we’ll review how to use positive indexing. I know that most of you are familiar
    with this technique, so I’ll keep the discussion brief. Using positive indexing,
    to access January’s revenue and the second season’s revenue, we can do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.1节中，您已经看到切片使用正索引来创建子序列。从一般的角度来看，就像在大多数其他语言中一样，我们根据它们的索引检索单个项目，从左边的0开始。在本节中，我们将回顾如何使用正索引。我知道你们大多数人熟悉这项技术，所以我会简要地讨论。使用正索引，要访问一月份的收入和第二个季度的收入，我们可以这样做：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The first item has an index of 0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一个项目的索引为0。
- en: ❷ Retrieve the fourth, fifth, and sixth items with indices 3, 4, and 5.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用索引3、4和5检索第四、第五和第六个项目。
- en: 'What should we do if we retrieve items toward the end? We may want to retrieve
    November’s revenue and the fourth season’s revenue, for example. Our first reaction
    may be the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检索列表末尾的项目，我们应该怎么做？例如，我们可能想检索十一月的收入和第四季度的收入。我们的第一个反应可能是以下内容：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ November’s revenue has an index of 10.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 十一月收入的索引为10。
- en: ❷ Retrieve items starting at index of 9 until the last item.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从索引9开始检索直到最后一个项目。
- en: 'Using positive indexing and slicing, we had to count to 10 and 9, respectively,
    to retrieve the desired items. Certainly, it is manageable to count the indices
    if lists contain tens of items. When there are more items, however, getting the
    correct indices by counting from the beginning can be error-prone. Aren’t better
    ways available? The next section discusses one of them: negative indexing.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正索引和切片，我们必须分别数到10和9，才能检索到所需的项目。当然，如果列表包含几十个项目，计数索引是可行的。但是，当有更多项目时，从开始计数以获取正确的索引可能会出错。难道没有更好的方法吗？下一节将讨论其中之一：负索引。
- en: 4.2.2 Negative indexing starts from the end of the list
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 负索引从列表的末尾开始
- en: Fortunately, Python supports negative indexing. We can count from left to right,
    and we can also count from right to left. In this section, we’ll see how negative
    indexing improves readability when we’re retrieving items near a sequence’s end.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python支持负索引。我们可以从左到右计数，也可以从右到左计数。在本节中，我们将看到当我们检索序列末尾附近的项时，负索引如何提高可读性。
- en: In the typical way, the indices of positive indexing start with 0 for the first
    item and end with the list’s length minus 1 for the last item. With negative indexing,
    we use -1 for the last item, -2 for the last but one, -3 for the last but two,
    and so on. Thus, the first item has a negative index of -len(list). Negative indexing
    is a brilliant design, as it’s more intuitive. In daily life, we count from 1,
    with the adjustment of using a negative sign. Figure 4.3 shows both positive and
    negative indices for a list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规方式中，正索引的索引从第一个项目的0开始，到列表长度的减1结束。使用负索引，我们用-1表示最后一个项目，-2表示倒数第二个项目，-3表示倒数第三个项目，依此类推。因此，第一个项目的负索引为-`len(list)`。负索引是一种非常巧妙的设计，因为它更直观。在日常生活中，我们通常从1开始计数，通过使用负号进行调整。图4.3显示了列表的正索引和负索引。
- en: '![CH04_F03_Cui](../Images/CH04_F03_Cui.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Cui](../Images/CH04_F03_Cui.png)'
- en: Figure 4.3 Positive and negative indices in a list. Positive indices start the
    count from the left side with an initial count of 0, whereas negative indices
    start the count from the right side with an initial count of -1.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 列中的正索引和负索引。正索引从左侧开始计数，初始计数为0，而负索引从右侧开始计数，初始计数为-1。
- en: 'Let’s apply the feature of negative indexing to the retrieval of November’s
    revenue and the fourth season’s revenue for the bookstore:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将负索引的特性应用于书店十一月收入和第四季度收入的检索：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ November has an index of -2.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 十一月有一个索引为-2。
- en: ❷ The fourth season includes the last three items of the list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第四季度包括列表的最后三个项目。
- en: 'As shown in this example, we obtained the same results that we did with positive
    indexing. But the negative-indexing approach has three advantages:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们得到了与使用正索引相同的结果。但负索引方法有三个优点：
- en: '*It saves time.* We need to count only a few items from the end of the list.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*节省时间。* 我们只需要从列表末尾计数几个项目。'
- en: '*It’s straightforward.* We count from the right, and the n-th item has a negative
    index of -n. We don’t have to make a mental adjustment to positive indices starting
    with 0\. We simply negate the number: 2 -> -2.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*很简单。* 我们从右边开始计数，第n个项有一个负索引为-n。我们不需要对以0开始的正索引进行心理调整。我们只需取反这个数字：2 -> -2。'
- en: '*It’s clear.* We make it clear to the readers of our code that we are retrieving
    items toward the end of the list, which is the most important advantage.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*很明显。* 我们让代码的读者清楚地知道我们正在检索列表末尾的项，这是最重要的优势。'
- en: Thus, whenever you want to retrieve items that are close to the end of a sequence,
    using negative indexing is always a good idea.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次你想检索接近序列末尾的项时，使用负索引总是一个好主意。
- en: Readability It’s easy to spot the negative index when you’re trying to retrieve
    any items near the end of the sequence.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 当你试图检索序列末尾附近的任何项时，很容易找到负索引。
- en: 4.2.3 Combining positive and negative indices as needed
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 根据需要组合正索引和负索引
- en: Positive and negative indices aren’t mutually exclusive. For each item in the
    sequence, the positive index and negative index are equivalent despite their different
    values, and they both refer to the same item, allowing us to combine both kinds
    of indices whenever applicable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正索引和负索引不是相互排斥的。对于序列中的每个项，正索引和负索引在它们的值不同的情况下是等效的，它们都指向相同的项，这使得我们可以在适用的情况下结合这两种索引。
- en: 'Suppose that you want to retrieve the items in the middle of a list. You can
    define the slice by using both positive and negative indexing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要检索列表中间的项。你可以通过使用正索引和负索引来定义切片：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Accesses revenue records from February to November
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问2月到11月的收入记录
- en: 4.2.4 Discussion
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 讨论
- en: When you retrieve items toward the end of a sequence, you should use negative
    indices. This section may be tedious to some readers, but I decided to include
    it because sequence data models are used in many projects. It’s essential to form
    the good habit of using negative indexing to denote the last item(s) in a sequence.
    You not only make it easier to find an index of the last items, but also clearly
    signal to readers that the code is concerned about items toward the sequence’s
    end. As always, readability is key in any codebase.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检索序列末尾的项时，你应该使用负索引。本节可能对一些读者来说有些枯燥，但我决定包括它，因为序列数据模型在许多项目中都有应用。养成使用负索引来表示序列中最后一个或最后几个项的好习惯是至关重要的。这不仅使找到最后一个项的索引变得更容易，而且向读者清楚地表明代码关注的是序列末尾的项。像往常一样，可读性在任何代码库中都是关键。
- en: 4.2.5 Challenge
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 挑战
- en: Jeffrey is a middle-school student who participates on the school’s robotics
    team. He recently learned about positive indexing of a sequence. He knows that
    he can use the length of the list to compute the positive index of an item toward
    the end, and he wants to write some code to retrieve November’s revenue; this
    code involves calculating the list’s length. Can you help him?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 杰弗里是一名中学生，他参加了学校的机器人队。他最近学习了序列的正索引。他知道可以使用列表的长度来计算接近末尾的项的正索引，并且他想编写一些代码来检索11月的收入；这段代码涉及到计算列表的长度。你能帮他吗？
- en: Hint Remember that positive indexing starts with 0\. Therefore, the last item’s
    positive index is off 1 from the sequence’s length.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 记住，正索引从0开始。因此，最后一个项的正索引比序列的长度少1。
- en: 4.3 How do I find items in a sequence?
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 我如何在序列中查找项？
- en: In sections 4.1 and 4.2, you learned about shared characteristics of sequence
    data types, such as slicing and indexing. When we have a sequence, we want to
    know where a specific item is in the sequence. In a list object consisting of
    tasks, for example, we may want to know whether any task deals with completing
    a survey. As another example, we may want to know whether the text description
    of a task includes the term *homework.* More generally speaking, finding an item
    in a sequence is a common task, and this section discusses several approaches
    that address this need.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.1和4.2节中，你学习了序列数据类型的共有特征，如切片和索引。当我们有一个序列时，我们想知道特定项在序列中的位置。例如，在一个由任务组成的列表对象中，我们可能想知道是否有任何任务涉及完成调查。作为另一个例子，我们可能想知道任务的文本描述中是否包含术语*作业*。更普遍地说，在序列中查找项是一个常见任务，本节讨论了几个解决这一需求的方法。
- en: 4.3.1 Checking an item’s presence
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 检查项的存在
- en: The first step in finding an item in a sequence is checking the presence of
    the item. This section discusses this topic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列中查找项的第一步是检查项的存在。本节讨论了这一主题。
- en: 'Many programming languages, such as JavaScript, check an item’s presence in
    a sequence by implementing a named method: list.contains(item), list.includes
    (item), or something similar. Python, however, takes a different approach to solving
    this problem, using the in keyword. The general syntax is item in sequence, which
    returns a Boolean value to indicate whether the item is present in the sequence.
    Following are some examples:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言，如 JavaScript，通过实现一个命名方法来检查项在序列中的存在：list.contains(item)，list.includes(item)
    或类似的方法。然而，Python 采用不同的方法来解决这个问题，使用 in 关键字。一般语法是 item in sequence，它返回一个布尔值以指示项是否存在于序列中。以下是一些示例：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ The parentheses are required. Otherwise, the equality == will be evaluated
    first.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要括号。否则，等号 == 将首先被评估。
- en: ❷ == True can be omitted. I’m including it here for clarity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ == True 可以省略。我在这里包含它是为了清晰起见。
- en: The item in sequence feature is useful when you’re interested only in the presence
    of a specific item in the sequence. But a binary True or False isn’t enough in
    situations when you need to know the exact index of the item. You may need to
    use the index of the searched item as an anchor and retrieve a subsequence that
    starts with the anchor, for example. In that case, you need to use the index method,
    as discussed in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只对序列中特定项的存在感兴趣时，序列中的项功能很有用。但在需要知道项的确切索引的情况下，二进制的 True 或 False 就不够了。你可能需要使用搜索项的索引作为锚点并检索从锚点开始的子序列，例如。在这种情况下，你需要使用下一节中讨论的索引方法。
- en: 4.3.2 Using the index method to locate the item
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 使用索引方法定位项
- en: Another shared characteristic of sequence data is support for the index method,
    which returns the item’s index in a sequence. In this section, you’ll learn how
    to use the index method to locate a specific item.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 序列数据的另一个共同特点是支持索引方法，它返回项在序列中的索引。在本节中，你将学习如何使用索引方法来定位特定项。
- en: 'The following code snippet shows a few examples of using different types of
    sequence data. As you can see, all sequence data has the index method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用不同类型的序列数据的几个示例。正如你所见，所有序列数据都有索引方法：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By default, the index is using the 0-based positive indices. When the checked
    item is indeed in the sequence, everything works as expected, and we find the
    item’s index.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，索引使用基于 0 的正索引。当检查的项确实在序列中时，一切按预期工作，我们找到了项的索引。
- en: Note When there are duplicate items in the sequence, the index method returns
    the index of the first matching item.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当序列中有重复项时，索引方法返回第一个匹配项的索引。
- en: 'One caveat of the index method that many people fail to appreciate is that
    sometimes the item isn’t contained in the sequence. Following is an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 索引方法的一个许多人未能充分理解的缺点是，有时项并不包含在序列中。以下是一个例子：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When an exception is raised—in this case, a ValueError exception—your program
    crashes if this exception isn’t handled. Although you’ll learn exception handling
    in chapter 12, here’s a quick peek at a solution that uses the try...except...
    statement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时——在这个例子中，是 ValueError 异常——如果这个异常没有被处理，你的程序会崩溃。虽然你将在第 12 章学习异常处理，但这里先快速看一下使用
    try...except... 语句的解决方案：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can write this code snippet in a different way to perform a presence check
    before finding the index, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用不同的方式编写这个代码片段，在找到索引之前先进行存在性检查，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On the surface, both approaches do the same job, but I prefer the first option,
    as it’s more performant than the other. When we use the index method, Python needs
    to traverse the sequence to check it against each item to identify a match, which
    is a time-consuming operation. In a similar fashion, when we find whether an item
    is contained in the sequence, Python needs to traverse the sequence too. Thus,
    when you use the process_item_check_first approach, the time consumption is expected
    to double because two traverses are involved, compared to one in the process_item_try
    approach. Thus, when the sequence is short, either approach is fine, but when
    the sequence is long, you should use the first approach.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，这两种方法做的是相同的工作，但我更喜欢第一种，因为它比另一种更高效。当我们使用索引方法时，Python 需要遍历序列以将每个项与它进行比较以找到匹配项，这是一个耗时的操作。同样，当我们检查项是否包含在序列中时，Python
    也需要遍历序列。因此，当你使用 process_item_check_first 方法时，时间消耗预计会加倍，因为涉及到两次遍历，而 process_item_try
    方法只涉及一次。因此，当序列较短时，两种方法都行得通，但当序列较长时，你应该使用第一种方法。
- en: EAFP vs. LBYL
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: EAFP vs. LBYL
- en: A widely respected principle in Python is EAFP (Easier to Ask for Forgiveness
    Than Permission). In this pattern, you use try...except... with the assumption
    that things should work. If something goes wrong, we handle the error accordingly
    (forgiveness).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的一个广受尊重的原则是EAFP（请求宽恕比请求许可更容易）。在这种模式中，你使用try...except...，假设事情应该会按预期工作。如果出现问题，我们将相应地处理错误（宽恕）。
- en: By contrast, another principle is known as LBYL (Look Before You Leap). This
    pattern is more prevalent in other programming languages, such as C. In this pattern,
    you check the applicable condition first, probably using an if statement (look),
    and apply the operation (leap) only if the condition is valid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，另一个原则被称为LBYL（先检查后跳）。这种模式在其他编程语言中更为普遍，例如C语言。在这种模式中，你首先检查适用条件，可能使用if语句（检查），只有在条件有效时才执行操作（跳过）。
- en: 4.3.3 Finding substrings in a string
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 在字符串中查找子字符串
- en: 'As a sequence data type, strings support the index method, as you saw in section
    4.3.2\. Moreover, we addressed the potential ValueError exception associated with
    the index method. Compared with other sequence types, however, strings are special
    in that they have two additional item-finding methods: find and rfind.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为序列数据类型，字符串支持index方法，正如你在第4.3.2节中看到的。此外，我们解决了与index方法相关的潜在ValueError异常。然而，与其他序列类型相比，字符串是特殊的，因为它们有两个额外的项查找方法：find和rfind。
- en: 'Both methods return the index of the searched substring. What makes them better
    than the index method is that they return -1 instead of raising the ValueError
    exception when the substring isn’t found in the string. Thus, I recommend that
    you use find or rfind when you search any substring, as shown in this example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都返回搜索子字符串的索引。它们比索引方法更好的地方在于，当子字符串在字符串中未找到时，它们返回-1而不是引发ValueError异常。因此，我建议你在搜索任何子字符串时使用find或rfind，如下例所示：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Please note that the find method is available only to strings. You can’t use
    it with other sequence data types, although I don’t see any technical difficulty
    in implementing this feature in non-str sequence models.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，find方法仅适用于字符串。你不能用它与其他序列数据类型一起使用，尽管我认为在非字符串序列模型中实现此功能没有技术困难。
- en: Trivia You can use find only with strings, not with other sequence data types.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 你可以使用find仅与字符串一起使用，而不能与其他序列数据类型一起使用。
- en: 4.3.4 Finding an instance of custom classes in a list
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 在列表中查找自定义类的实例
- en: When our projects grow in scope, we’ll use custom classes as our data models.
    In our projects, we use lists to store multiple instances of a custom class. Chances
    are that we want to know whether a specific instance exists in the list. In this
    section, you’ll learn how to locate an instance of a custom class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的项目规模扩大时，我们将使用自定义类作为我们的数据模型。在我们的项目中，我们使用列表来存储自定义类的多个实例。我们很可能会想知道特定实例是否存在于列表中。在本节中，你将学习如何定位自定义类的实例。
- en: Suppose that in our task management application, we use a list object to store
    a day’s tasks. Consider the following listing to be our starting point. For simplicity,
    the Task class has minimum implementations. To provide a proof of concept, the
    list object contains four instances.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的任务管理应用程序中，我们使用列表对象来存储一天的任务。以下列表是我们的起点。为了简单起见，Task类有最小实现。为了提供概念证明，列表对象包含四个实例。
- en: Listing 4.2 Creating a list of objects of custom classes
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 创建自定义类对象的列表
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In our application, the interface shows the list of these tasks. One possible
    feature of our application highlights the row of the task that matches the filtering
    criterion, such as an urgency level of 5\. To implement this feature, we need
    to know the index of the task that has the desired urgency level. As you may realize,
    we can’t use the index method, as we don’t know the task with the needed urgency
    level beforehand. Thus, we must consider a different approach. Because we’re interested
    in obtaining a task with the desired urgency level, we can iterate the entire
    list to find the potential match. The following code snippet shows a working solution:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，界面显示了这些任务的列表。我们应用程序的一个可能特性是突出显示与过滤标准匹配的任务行，例如紧急程度为5的任务行。为了实现此功能，我们需要知道具有所需紧急程度的任务的索引。正如你可能意识到的，我们不能使用index方法，因为我们事先不知道具有所需紧急程度的任务。因此，我们必须考虑不同的方法。因为我们感兴趣的是获取具有所需紧急程度的任务，所以我们可以遍历整个列表以找到潜在的匹配项。以下代码片段显示了可行的解决方案：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ See section 4.3.6 for an alternative technique.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 请参阅第4.3.6节以获取一种替代技术。
- en: ❷ Uses break to exit the for loop
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用break退出for循环
- en: We use a for loop to iterate the list to check each instance’s urgency attribute
    against the desired level. When the task is found, we use the break statement
    (see section 5.4.1) to exit the for loop and complete the search. With the identified
    index, we can update our application’s interface by highlighting the corresponding
    row of the task.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用for循环遍历列表，将每个实例的紧急属性与所需级别进行比较。当找到任务时，我们使用break语句（见第5.4.1节）退出for循环并完成搜索。有了确定的索引，我们可以通过突出显示任务对应的行来更新我们应用程序的界面。
- en: Concept The break statement exits the present loop instantaneously.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 概念：break语句立即退出当前循环。
- en: 4.3.5 Discussion
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 讨论
- en: Calling index on a sequence returns the index of only the first matching item,
    so be mindful that the sequence might contain other matching items. Because the
    index method raises a ValueError exception if the item isn’t in the sequence,
    we can use the try...except... statement (section 12.3) to handle the exception.
    Although we can check the presence of a specific item, this LBYL approach requires
    two traverses of the sequence, causing extra time overhead. Thus, it’s a good
    idea to use the EAFP approach for better performance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列上调用索引只返回第一个匹配项的索引，因此请注意序列可能包含其他匹配项。由于索引方法如果项目不在序列中会引发ValueError异常，我们可以使用try...except...语句（第12.3节）来处理异常。虽然我们可以检查特定项目的存在，但这种LBYL方法需要遍历序列两次，导致额外的开销。因此，使用EAFP方法以获得更好的性能是个好主意。
- en: Maintainability Prefer adopting the EAFP pattern whenever possible, as it is
    generally more performant than LBYL.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：尽可能采用EAFP模式，因为它通常比LBYL模式更高效。
- en: 4.3.6 Challenge
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6 挑战
- en: 'In the example of locating an object of custom class, the task with the needed
    urgency level has an index of 2, which is the object Task("Homework", 5). What
    happens if you run the code: tasks.index(Task("Homework", 5))? Will you get an
    index of 2 as the result?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在定位自定义类对象的示例中，具有所需紧急级别的任务索引为2，即对象Task("Homework", 5)。如果你运行代码：tasks.index(Task("Homework",
    5))，你会得到结果索引2吗？
- en: Hint Even though some objects appear to have the same data, they’re distinct
    objects that have different memory addresses. You can use the id function to explain
    the findings.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：尽管一些对象看起来具有相同的数据，但它们是不同的对象，具有不同的内存地址。你可以使用id函数来解释这些发现。
- en: 4.4 How do I unpack a sequence? Beyond tuple unpacking
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 如何解包一个序列？超越元组解包
- en: 'Because tuples are immutable data containers, we use them to hold multiple
    objects without the intention of changing the contents. To retrieve items from
    the tuple object individually or consecutively, we’ve learned to use indexing
    and slicing (sections 4.2 and 4.3):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组是不可变的数据容器，我们使用它们来保存多个对象，而不打算更改其内容。为了从元组对象中单独或连续地检索项目，我们已经学会了使用索引和切片（第4.2节和第4.3节）：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we used three separate assignments to create three variables,
    each of which corresponds to one item of the tuple task. If the tuple object has
    more items, we need to have more assignments, which can be tedious work that can
    make our code look busy and less readable. Is there a better way to access multiple
    items with corresponding variables?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了三个单独的赋值来创建三个变量，每个变量对应于元组task的一个项目。如果元组对象有更多项目，我们需要进行更多赋值，这可能是一项繁琐的工作，会使我们的代码看起来忙碌且难以阅读。有没有更好的方法来使用相应的变量访问多个项目？
- en: The answer is the *unpacking technique.* When it’s applied to tuples, it’s best
    known as the *tuple unpacking technique*. The essential idea is that we conceptualize
    creating tuples to hold data as a process of packing information. Not surprisingly,
    the reverse process—retrieving the items—is termed *unpacking.* In this section,
    you’ll learn this important technique with a primary focus on tuple objects. Note,
    however, that unpacking isn’t only for tuples; it’s also for any iterables, including
    sequence data types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是*解包技术*。当它应用于元组时，它最著名的名称是*元组解包技术*。基本思想是我们将创建元组来保存数据的过程概念化为打包信息的过程。不出所料，相反的过程——检索项目——被称为*解包*。在本节中，你将学习这个重要的技术，主要关注元组对象。然而，请注意，解包不仅限于元组；它也适用于任何可迭代对象，包括序列数据类型。
- en: 4.4.1 Unpacking short sequences with one-to-one correspondence
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 使用一对一对应解包短序列
- en: 'When we work with tuples that contain a few items and need to use all items,
    we use one-to-one unpacking, in which each item is assigned to a matching variable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理包含少量项目并需要使用所有项目的元组时，我们使用一对一解包，其中每个项目都分配给匹配的变量：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this one-to-one unpacking technique, we used one line of code to create
    multiple variables that correspond to each item in the tuple object. Please note
    that in the preceding examples, the tuples were created first, mimicking the real-life
    situation in which we obtain tuple objects created by other parts of our projects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种一对一解包技术，我们使用一行代码创建了多个变量，这些变量对应于元组对象中的每个项。请注意，在前面的示例中，元组是首先创建的，模拟了我们项目其他部分创建元组对象的真实情况。
- en: 'Closely related to one-to-one unpacking is the *multiple-assignment technique**,*
    in which we create multiple variables by sharing a single assignment operator
    (the equal sign):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与一对一解包紧密相关的是**多重赋值技术**，其中我们通过共享单个赋值运算符（等号）来创建多个变量：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code snippet shows a few varieties of multiple assignments. Although
    their appearances are different, they perform the same job. On the right side,
    we create tuple objects, and on the left side, we pass the same number of variables
    in such a way that the items are unpacked on a one-to-one basis. Also, a notable
    feature to observe in these assignments is the fact that parentheses are optional
    for creating and unpacking tuples. The following code snippet shows the missing
    permutation that complements the precedings in string examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了多种多重赋值的形式。尽管它们的表面看起来不同，但它们执行的是相同的工作。在右侧，我们创建元组对象，在左侧，我们以相同数量的变量传递，这样项就可以一对一地解包。在这些赋值中，一个值得注意的特点是创建和解包元组时括号是可选的。以下代码片段显示了在字符串示例中补充前面的缺失排列：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Readability Use multiple assignments only if the variables are closely related.
    Prefer using separate lines of code for assignments when the variables serve different
    purposes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：只有在变量紧密相关时才使用多重赋值。当变量服务于不同目的时，优先使用单独的代码行进行赋值。
- en: 4.4.2 Retrieving consecutive items using the starred expression
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 使用带星号的表达式检索连续项
- en: In the preceding section, we retrieved multiple items by using the one-to-one
    unpacking technique, which works well with tuples that contain a few items. When
    the tuples have more items, we may want to retrieve some items as separate variables
    and some consecutive items as a single variable. This section shows you how.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用一对一解包技术检索了多个项，这对于包含少量项的元组效果很好。当元组包含更多项时，我们可能希望将一些项作为单独的变量检索，而将一些连续项作为一个变量检索。本节将向您展示如何做到这一点。
- en: 'Suppose that we’re hosting a gymnastics meet, and each player is scored by
    eight judges. To calculate a player’s final score, we get rid of the lowest and
    highest scores and then compute the mean of the remaining six scores. For the
    purpose of data recording, we save the score records for each player: the lowest,
    middle, highest, and final score. To simplify the example, assume that the scores
    have already been sorted from low to high. Certainly, we can use indexing to generate
    these score records, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在举办一场体操比赛，每位运动员由八位裁判评分。为了计算运动员的最终得分，我们去掉最低分和最高分，然后计算剩余六个分数的平均值。为了数据记录的目的，我们保存每位运动员的得分记录：最低分、中间分、最高分和最终得分。为了简化示例，假设得分已经按从低到高的顺序排序。当然，我们可以使用索引来生成这些得分记录，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of using the unpacking technique discussed later in this section, we
    use multiple lines of code to create these variables one by one. This solution
    is not the most Pythonic way to create multiple variables from sequence data.
    Unfortunately, if we try to solve the problem by applying the syntax of the one-to-one
    unpacking technique, we encounter a problem:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用本节后面讨论的解包技术，而是使用多行代码逐个创建这些变量。这种方法不是从序列数据中创建多个变量的最Pythonic方式。不幸的是，如果我们尝试通过应用一对一解包技术的语法来解决问题，我们会遇到一个问题：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The error message is clear: there are too many values to unpack. Let’s take
    a closer look. On the left side, we have three variables, so Python expects to
    unpack three items from the tuple. But the tuple object contains eight items,
    which leads to a mismatch. How can we solve the problem? A *starred expression*
    comes into play:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息很明确：要解包的值太多。让我们更仔细地看看。在左侧，我们有三个变量，所以Python期望从元组中解包三个项。但是元组对象包含八个项，这导致了不匹配。我们如何解决这个问题？一个**带星号的表达式**就派上用场了：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Uses a starred expression
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用带星号的表达式
- en: 'You should note several characteristics of a starred expression:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意带星号表达式的几个特点：
- en: '*A starred expression uses an asterisk as a prefix for the variable* (*var_name).
    All items that are not denoted by other variables are captured by the variable.
    In this case, the first and last items go with lowest2 and highest2, respectively.
    The six items in the middle are captured by middles2. Thus, some Python users
    refer to the starred expression as the *capture-all asterisk**.*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带星号的表示法使用星号作为变量* (*var_name*) 的前缀。所有未由其他变量表示的项目都将被该变量捕获。在这种情况下，第一个和最后一个项目分别与
    lowest2 和 highest2 相关联。中间的六个项目被 middles2 捕获。因此，一些 Python 用户将带星号的表示法称为 *捕获所有项目的星号***。'
- en: '*A starred expression produces a* list *object* *of the captured items, regardless
    of the data type of the original sequence.* We can observe this effect with a
    str object, as shown in the following code snippet. Don’t make the mistake of
    assuming that the variable b is a str object consisting of all the characters
    in the middle:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带星号的表示法会产生一个捕获项目的列表* *对象*，无论原始序列的数据类型如何。我们可以通过以下代码片段观察此效果。不要犯错误，认为变量 b 是一个包含所有中间字符的
    str 对象：'
- en: '[PRE37]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*The number of captured items in the list object can be zero.* If all items
    are unpacked with the proper number of variables, leaving zero items to account
    for, the starred expression produces an empty list. Observe this effect:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*列表对象中捕获的项目数量可以是零。* 如果所有项目都使用正确的变量数量解包，留下零个项目来计算，则带星号的表示法将生成一个空列表。观察以下效果：'
- en: '[PRE38]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*One assignment can use only one starred expression.* Trying to use two starred
    expressions is a syntax error. The reason is simple: a starred expression is intended
    to capture all items that are not accounted for, so when two starred expressions
    are used, it’s impossible to determine which one should capture which items:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个赋值只能使用一个带星号的表示法。尝试使用两个带星号的表示法是语法错误。原因很简单：带星号的表示法旨在捕获所有未计算的项目，因此当使用两个带星号的表示法时，无法确定哪个应该捕获哪些项目：'
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.4.3 Denoting unwanted items with underscores to remove distraction
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 使用下划线表示不需要的项目以消除干扰
- en: We’ve discussed how to unpack a tuple or a list to access individual or consecutive
    items. In any unpacking, we must provide a proper number of variables (with a
    starred expression, if necessary) that corresponds to the items in the sequence.
    But we don’t always use the unpacked items. In this case, we should use underscores
    in unpacking.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何解包元组或列表以访问单个或连续的项目。在任何解包中，我们必须提供与序列中的项目相对应的正确数量的变量（如果需要，可以使用带星号的表示法）。但我们并不总是使用解包的项目。在这种情况下，我们应该在解包中使用下划线。
- en: 'In our task management app, suppose that we have an application programming
    interface (API) that returns a task saved as a tuple object with four items: the
    task’s ID, the task’s title, the task’s description, and the task’s status. As
    a reminder, the task’s ID uniquely identifies a task in our application. We can
    define a function to update data in our database, as shown in this code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务管理应用程序中，假设我们有一个返回包含四个项目的元组对象的 API，这四个项目是：任务的 ID、任务的标题、任务的描述和任务的状态。作为提醒，任务的
    ID 在我们的应用程序中唯一标识一个任务。我们可以定义一个函数来更新我们的数据库中的数据，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ A utility function for database updating
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数据库更新的实用函数
- en: ❷ The API returns a four-item tuple.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ API 返回一个包含四个项目的元组。
- en: ❸ Unpacks the tuple object completely
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 完全解包元组对象
- en: 'In the preceding code snippet, we unpacked the tuple object in such a way that
    all the items are associated with their respective variables. By doing the one-to-one
    unpacking, we present a significant implication to readers: we’ll use each unpacked
    item next. As shown in the code, however, we needed to work only on the task’s
    ID and status.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们以这种方式解包了元组对象，使得所有项目都与相应的变量相关联。通过进行一对一的解包，我们向读者传达了一个重要的含义：我们将使用每个解包的项目。然而，正如代码所示，我们只需要处理任务的
    ID 和状态。
- en: 'Thus, complete unpacking, which includes the assignment of variables that we
    don’t need, is a distracting signal. To remove such a distraction, we should use
    the underscores to denote these unwanted items, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完全解包，包括分配我们不需要的变量，是一个分散注意力的信号。为了消除这种干扰，我们应该使用下划线来表示这些不需要的项目，如下所示：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The idea of using underscores is that if we don’t need some of the variables,
    we don’t assign them meaningful names. The following features are associated with
    using underscores in unpacking:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下划线的想法是，如果我们不需要一些变量，我们就不分配它们有意义的名称。以下功能与在解包中使用下划线相关联：
- en: '*You can use as many underscores as applicable.* In our example, the tuple
    object has four items. As we’re interested in only two items, we use two underscores
    plus the task_id and task_status to unpack these items.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你可以使用尽可能多的下划线。* 在我们的例子中，元组对象有四个项。由于我们只对两个项感兴趣，我们使用两个下划线加上task_id和task_status来解包这些项。'
- en: '*The underscores are valid variable names.* More than unpacking, using underscores
    is a convention among Python users to denote unwanted variables. Even though we
    give a signal that we don’t need these variables, we can refer to them if we choose
    to do so. In our example, the _ variable holds the task description because the
    former assignment of the task title (the first _) was overwritten.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下划线是有效的变量名。* 除了解包之外，使用下划线是Python用户中的一种约定，用来表示不需要的变量。尽管我们发出了我们不需要这些变量的信号，但如果我们选择这样做，我们仍然可以引用它们。在我们的例子中，_变量保存了任务描述，因为之前的任务标题（第一个_）的赋值被覆盖了。'
- en: '*You can combine an asterisk and underscore in the starred expression.* The
    following code snippet shows an example:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你可以在星号表达式中组合星号和下划线。* 以下代码片段展示了示例：'
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Combination of the asterisk and underscore in the starred expression
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 星号和下划线在星号表达式中的组合
- en: Readability In sequence unpacking, denote unwanted items with underscores, which
    signifies that we shouldn’t bother using these items.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 在序列解包中，用下划线表示不需要的项，这表示我们不应该费心去使用这些项。
- en: 4.4.4 Discussion
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 讨论
- en: Unpacking is the most readable way to retrieve individual or consecutive items
    in a sequence. We should have a thorough understanding of the various techniques
    of unpacking. Notably, I’ve mostly used tuples to show how unpacking works, but
    you can apply the same unpacking technique to any iterables. When you learn more
    about iterables in chapter 5, you can try using the unpacking technique with any
    iterables.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解包是检索序列中单个或连续项的最可读方式。我们应该彻底理解解包的各种技术。值得注意的是，我主要使用元组来展示解包是如何工作的，但你也可以将相同的解包技术应用于任何可迭代对象。当你学习到第5章关于可迭代对象的内容时，你可以尝试使用解包技术来处理任何可迭代对象。
- en: 4.4.5 Challenge
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 挑战
- en: Danny is working on a project in which he uses the unpacking technique to extract
    data from list objects. What’s special about the data is the fact that the list
    objects in his project have two layers, such as [1, (2, 3), 4]. How can he use
    one line of code to unpack both layers to extract these four numbers as four variables?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 丹尼正在做一个项目，在这个项目中，他使用解包技术从列表对象中提取数据。这些数据特殊之处在于他的项目中的列表对象有两层，例如[1, (2, 3), 4]。他是如何使用一行代码来解包这两层，提取这四个数字作为四个变量的？
- en: Hint You can use parentheses to create layers during unpacking.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 你可以使用括号在解包过程中创建层级。
- en: 4.5 When should I consider data models other than lists and tuples?
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 我应该在什么情况下考虑使用列表和元组之外的数据模型？
- en: Of the various sequence data types, the versatility of their features doubtless
    makes lists and tuples satisfactory data containers in many common situations.
    When you move on to specific projects, however, you’ll find that lists and tuples
    become less ideal. Thus, you should be open-minded about alternative data structures
    that can be the correct choice in certain use cases. In this section, I review
    some common scenarios and recommended alternatives.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种序列数据类型中，它们功能的多样性无疑使得列表和元组在许多常见情况下成为令人满意的数据容器。然而，当你转向特定项目时，你会发现列表和元组变得不那么理想。因此，你应该对其他可能适用于某些用例的数据结构持开放态度。在本节中，我将回顾一些常见场景和推荐的替代方案。
- en: 4.5.1 Using sets where membership is concerned
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 在关注成员资格时使用集合
- en: We often need to check whether the data container has the specific item under
    examination, a functionality that is termed *membership checking.* With lists
    and tuples, we’ve learned that we can use either item in the_list to check the
    membership or the index method as an indirect way to determine whether a list
    contains a specific item. Please note that using index is less desirable because
    when the item isn’t in the list, the ValueError exception is raised.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要检查数据容器是否包含正在检查的特定项，这种功能被称为*成员资格检查。* 对于列表和元组，我们已经了解到我们可以使用_in_the_list中的任何项来检查成员资格，或者使用索引方法作为确定列表是否包含特定项的间接方式。请注意，使用索引是不太可取的，因为当项不在列表中时，会引发ValueError异常。
- en: Although lists support membership testing, you should consider using sets if
    your application is concerned with membership. As covered in greater detail in
    section 3.5, Python requires all the items in a set to be unique because under
    the hood, sets are implemented by means of a hash table, which offers a significant
    benefit of constant item lookup time, known as O(1) time complexity. By contrast,
    membership testing lookup time is linear with the length of the list because Python
    needs to traverse the sequence to find a potential match. The more items a list
    has, the more time the traverse costs. Thus, you should use sets when your application
    is concerned with membership testing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表支持成员资格测试，但如果您的应用程序关注成员资格，您应该考虑使用集合。在第3.5节中详细说明，Python要求集合中的所有项目都是唯一的，因为底层，集合是通过哈希表实现的，这提供了常数项查找时间的重要优势，称为O(1)时间复杂度。相比之下，成员资格测试的查找时间是线性的，与列表的长度成正比，因为Python需要遍历序列以找到潜在的匹配项。列表中的项目越多，遍历的成本就越高。因此，当您的应用程序关注成员资格测试时，您应该使用集合。
- en: QUESTION Do you remember the hash table implementation as the storage mechanism
    for set? See section 3.5.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 您还记得哈希表实现作为集合的存储机制吗？请参阅第3.5节。
- en: 4.5.2 Using deques if you care about first-in-first-out
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 如果您关心先进先出（FIFO）顺序，则使用双端队列
- en: In certain applications, we want our data to have *first-in, first-out* (FIFO)
    capability. FIFO emphasizes that the items that are added to the sequence first
    (first in) are removed from the sequence first (first out). In this section, we’ll
    see a better model when FIFO is concerned.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，我们希望我们的数据具有 *先进先出*（FIFO）功能。FIFO强调首先添加到序列中的项目（先进）首先从序列中移除（先出）。在本节中，我们将看到当涉及FIFO时，一个更好的模型。
- en: Suppose that we’re building an online customer chat system for an enterprise.
    Throughout business hours, clients check in, and we use a list to track the order
    of the check-in sequence. It’s reasonable to connect those who check in first
    with the customer support associates, which represents a FIFO need in the application.
    One possible solution uses lists, as shown in the following listing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为企业构建一个在线客户聊天系统。在营业时间内，客户登记，我们使用列表来跟踪登记顺序。将首先登记的客户与客户支持同事连接起来是合理的，这代表了应用程序中的FIFO需求。一个可能的解决方案使用列表，如下所示。
- en: Listing 4.3 Using lists to create the client queue system
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 使用列表创建客户队列系统
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Appends a new item to the end of the list
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将新项目添加到列表的末尾
- en: ❷ Examines whether there are items in the list. When the list is empty, pop
    results in an IndexError.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查列表中是否有项目。当列表为空时，pop会导致IndexError。
- en: ❸ Removes the first item in the list
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从列表中移除第一个项目
- en: In the snippet, the check_in function adds a new client to the end of the waiting
    queue, which is a list object named clients. When an associate becomes available,
    we connect the first client in the queue to the associate. To retrieve the first
    client, we use the pop method of list objects. This method doesn’t only return
    the first item in the list, but also removes it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，check_in函数将新客户添加到等待队列的末尾，该队列是一个名为clients的列表对象。当有同事有空闲时，我们将队列中的第一个客户与同事连接起来。为了检索第一个客户，我们使用列表对象的pop方法。此方法不仅返回列表中的第一个项目，而且还移除它。
- en: 'The removal of the item at the beginning of a list object is significant. Under
    the hood, Python shifts each of the items in the list to adjust the vacancy of
    the first item in memory, which is an expensive operation with a time complexity
    of O(n). Given its considerable complexity, we should consider an alternative
    solution: using deques.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表对象的开头移除项目是重要的。在底层，Python将列表中的每个项目都移动以调整内存中第一个项目的空位，这是一个具有O(n)时间复杂度的昂贵操作。鉴于其相当大的复杂性，我们应该考虑一个替代方案：使用双端队列。
- en: Trivia *Deque* is pronounced “deck,” not “dee-queue.”
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 *Deque* 发音为“deck”，而不是“dee-queue”。
- en: The deque data type is a double-ended queue. Because of its double-ended feature,
    it supports insertion and removal from both ends, making it a perfect data type
    for implementing the client chat management system, which requires FIFO. As mentioned
    previously, the invocation of the pop method on a list object is an expensive
    operation in terms of both time and memory. By contrast, because deques’ ends
    are both open, removing the leftmost item from a deque is a computationally trivial
    operation. Figure 4.4 illustrates the contrast between lists and deques.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列数据类型是一个双端队列。由于其双端特性，它支持从两端进行插入和移除，这使得它成为实现需要FIFO（先进先出）的客户端聊天管理系统的一个完美数据类型。如前所述，在列表对象上调用pop方法在时间和内存方面都是一个昂贵的操作。相比之下，由于双端队列的两端都是开放的，从双端队列中移除最左边的元素是一个计算上微不足道的操作。图4.4展示了列表和双端队列之间的对比。
- en: '![CH04_F04_Cui](../Images/CH04_F04_Cui.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Cui](../Images/CH04_F04_Cui.png)'
- en: Figure 4.4 Removing the first item in a list vs. a deque. Removing the leftmost
    item of a list requires the shifting of all remaining items, making it an O(n)
    operation, whereas removing the leftmost item of a deque requires no actions on
    the remaining items, making it an O(1) operation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 从列表中移除第一个元素与从双端队列中移除第一个元素的比较。从列表中移除最左边的元素需要移动所有剩余的元素，这使得它成为一个O(n)的操作，而从不移除双端队列中最左边的元素则不需要对剩余元素进行任何操作，这使得它成为一个O(1)的操作。
- en: Let’s make a direct comparison between lists and deques for this operation.
    Consider the following simplified setup for removing the first item from the waiting
    queue. Please note that the next listing includes the use of a lambda function
    (chapter 7).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对列表和双端队列在这个操作上进行直接比较。考虑以下用于从等待队列中移除第一个元素的简化设置。请注意，接下来的列表中包含了lambda函数的使用（第7章）。
- en: Listing 4.4 Comparing the performance of deques and lists
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 比较双端队列和列表的性能
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ The deque data type is available in the collections module in the standard
    library.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 双端队列数据类型在标准库的collections模块中可用。
- en: ❷ The timeit function calculates the average execution time of an expression.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ timeit函数计算表达式的平均执行时间。
- en: ❸ The popleft method pops the first item from the beginning of the deque.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ popleft方法从双端队列的起始位置移除第一个元素。
- en: The performance gain in this trivial example using deques over lists is significant
    with two orders of magnitude for 100,000 items. For enterprise applications, such
    improvement in a single aspect can be essential for improving overall user experiences.
    It’s important to note that using the deque data type doesn’t involve any complicated
    implementations. So why not enjoy the performance gain without any cost other
    than using a built-in data type? The next listing shows the modified implementation
    using deques.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，使用双端队列而不是列表的性能提升是显著的，对于10万个元素来说，提升了两个数量级。对于企业应用来说，这种在单一方面的改进对于提升整体用户体验可能是至关重要的。需要注意的是，使用双端队列数据类型并不涉及任何复杂的实现。那么，为何不享受这种性能提升，而无需付出除了使用内置数据类型之外的任何代价呢？接下来的列表展示了使用双端队列的修改后的实现。
- en: Listing 4.5 Using lists to create the client queue system
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 使用列表创建客户端队列系统
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 4.5.3 Processing multidimensional data with NumPy and Pandas
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 使用NumPy和Pandas处理多维数据
- en: So far, we’ve focused on linear sequence data structures, such as lists, tuples,
    and strings. In real life, however, data can take a multidimensional shape, such
    as images and videos. Images, for example, can be represented mathematically as
    three layers (red, green, and blue) of two-dimensional pixel panels. It can be
    a nightmare to try to use basic data models to represent high-dimensional data.
    Fortunately, Python’s open source nature has bolstered the development of many
    third-party libraries and packages for processing multidimensional large-scale
    datasets. Thus, instead of using lists, we should consider using alternatives
    that are designed for computationally heavy jobs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注线性序列数据结构，如列表、元组和字符串。然而，在现实生活中，数据可以具有多维形状，例如图像和视频。例如，图像可以用数学上的三层（红色、绿色和蓝色）二维像素面板来表示。尝试使用基本数据模型来表示高维数据可能会是一场噩梦。幸运的是，Python的开源特性促进了众多第三方库和包的开发，用于处理多维大规模数据集。因此，我们不应该使用列表，而应该考虑使用专为计算密集型工作设计的替代方案。
- en: If you need to work on a large amount of numeric data, for example, you should
    consider using NumPy arrays, which are the core data type implemented in the NumPy
    package. It’s important to note that lots of related manipulations are available
    in the package, such as reshaping, transformation, and various arithmetic operations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理大量数值数据，例如，你应该考虑使用NumPy数组，这是NumPy包中实现的核心数据类型。重要的是要注意，该包中提供了许多相关操作，例如重塑、转换和各种算术运算。
- en: If you need to work on spreadsheet-like data with mixed data types (such as
    strings, dates, and numbers), you should consider using pandas DataFrame, one
    of the core data types implemented in the pandas packages. If you do machine learning,
    you need to use tensors, which are the most important data types in major machine
    learning frameworks, such as TensorFlow and PyTorch. If your applications deal
    with a large amount of multidimensional data, especially in the form of numeric
    values, you should take advantage of these third-party libraries, which have specialized
    data types and associated methods to ease your life.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理类似电子表格的数据，并且数据类型混合（如字符串、日期和数字），你应该考虑使用pandas DataFrame，这是pandas包中实现的核心数据类型之一。如果你进行机器学习，你需要使用张量，这是TensorFlow和PyTorch等主要机器学习框架中最重要的数据类型。如果你的应用程序处理大量多维数据，尤其是以数值形式，你应该利用这些第三方库，它们具有专门的数据类型和相关方法，以简化你的工作。
- en: 4.5.4 Discussion
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.4 讨论
- en: Lists and tuples are useful sequence data types for storing ordered items. Now,
    however, we know essential alternative data models. Certainly, the data models
    covered here aren’t an exhaustive list. Instead, I want to convey only that you
    should be open-minded about the data model choices. The decision must be driven
    by the specific business need.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组是有用的有序项存储序列数据类型。现在，然而，我们知道基本替代数据模型。当然，这里涵盖的数据模型并不是一个详尽的列表。相反，我想传达的是，你应该对数据模型的选择持开放态度。决策必须由具体的业务需求驱动。
- en: Maintainability Always pick the proper data models for different purposes. Using
    an improper data model can make your project extremely hard to maintain.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 总是选择适合不同目的的数据模型。使用不适当的数据模型可以使你的项目难以维护。
- en: The bottom line in selecting data models is that you should take a *need-driven
    approach* to choosing the best data model for specific components of your application.
    In other words, your application should contain as many different data models
    as possible, with each data model chosen to address specific needs. Figure 4.5
    provides an overview of the need-driven approach to data model selection.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据模型的基本原则是，你应该采取*需求驱动的方法*来选择最适合你应用程序特定组件的最佳数据模型。换句话说，你的应用程序应该包含尽可能多的不同数据模型，每个数据模型的选择都是为了解决特定的需求。图4.5提供了数据模型选择需求驱动方法的概述。
- en: '![CH04_F05_Cui](../Images/CH04_F05_Cui.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F05_Cui](../Images/CH04_F05_Cui.png)'
- en: Figure 4.5 The data models you choose depend on the specific needs of your application’s
    components.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 你选择的数据模型取决于你应用程序组件的具体需求。
- en: 4.5.5 Challenge
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.5 挑战
- en: 'Emma is a beginner data scientist who is starting to use Python for her projects.
    She understands that she can use lists to store one-dimensional data, such as
    a list of numbers. But her projects involve lists embedded in another list object
    to hold two-dimensional data that resembles a spreadsheet of four rows and three
    columns:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Emma是一位初学者数据科学家，她开始使用Python来处理她的项目。她明白她可以使用列表来存储一维数据，例如数字列表。但她的项目涉及嵌套在其他列表对象中的列表，以存储类似于四行三列电子表格的二维数据：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What should she do if she wants to multiply each item by 3? You may notice that
    this job is tedious. Can you help her think of another data model that is more
    appropriate?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果她想要将每个元素乘以3，她应该怎么做？你可能注意到这项工作很繁琐。你能帮她想到另一个更合适的数据模型吗？
- en: Hint The array type in NumPy is specialized for performing operations on multidimensional
    numeric data.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 NumPy中的数组类型专门用于执行多维数值数据的操作。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use slicing to retrieve a subsequence. With slicing, you can specify
    start, end, and step. Note that slicing supports a variety of methods of calling,
    including omission of the start and end indices.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用切片来检索子序列。使用切片时，你可以指定起始、结束和步长。请注意，切片支持多种调用方法，包括省略起始和结束索引。
- en: We use slices to create subsequences from sequence data, whereas we use ranges
    for iterations using the specified range and steps.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用切片从序列数据中创建子序列，而使用指定范围和步长的迭代则使用范围。
- en: Sequence data includes mutable and immutable types. We can manipulate mutable
    types, such as lists and bytearrays, through slice surgery to replace, expand,
    shrink, and remove subsequences.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列数据包括可变和不可变类型。我们可以通过切片操作来操纵可变类型，例如列表和字节序列，以替换、扩展、缩减和删除子序列。
- en: In a sequence, each item has an index to indicate its position. The positive
    indices start with 0 from the left with an increment of 1 moving toward the right,
    and the negative indices start with -1 from the right with an increment of -1
    moving toward the left.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个序列中，每个项目都有一个索引来指示其位置。正索引从左侧开始，以1为增量向右移动，起始值为0；负索引从右侧开始，以-1为增量向左移动，起始值为-1。
- en: To improve our code’s readability, we should form the habit of using a positive
    index when we refer to items at the beginning of the sequence and a negative index
    for items toward the sequence’s end.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高代码的可读性，我们应该养成在引用序列开头项目时使用正索引，在引用序列末尾项目时使用负索引的习惯。
- en: We need to know the different ways of checking the item’s presence in a sequence
    and understand the limitation of using the index method. For strings, we should
    use the find or rfind method to locate a substring. For custom instances, we should
    use iteration to check each of the items for a possible match.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要了解检查序列中项目存在性的不同方法，并理解使用索引方法的局限性。对于字符串，我们应该使用find或rfind方法来定位子字符串。对于自定义实例，我们应该使用迭代来检查每个项目以查找可能的匹配项。
- en: Tuple unpacking is a notable feature for extracting items from a tuple object.
    This technique is available for all sequence data types and other kinds of iterables.
    But we should be familiar with different methods of unpacking, including using
    underscores and starred expressions.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组解包是从元组对象中提取项目的一个显著特性。这项技术适用于所有序列数据类型和其他类型的可迭代对象。但我们应该熟悉不同的解包方法，包括使用下划线和星号表达式。
- en: Lists aren’t a one-size-fits-all solution. We should explore alternative data
    structures that are better for addressing specific business needs, such as NumPy
    arrays for multidimensional numeric computations.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表并不是万能的解决方案。我们应该探索更适合解决特定业务需求的其他数据结构，例如用于多维数值计算的NumPy数组。
