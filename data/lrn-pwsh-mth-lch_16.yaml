- en: '16 Variables: A place to store your stuff'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 变量：存储你的东西的地方
- en: We’ve already mentioned that PowerShell contains a scripting language, and in
    a few more chapters, we’ll start to play with it. But once you start scripting,
    you may want to store your objects as variables for later use, so we’ll get those
    out of the way in this chapter. You can use variables in many places other than
    long, complex scripts, so we’ll also use this chapter to show you some practical
    ways to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到PowerShell包含一种脚本语言，在接下来的几章中，我们将开始使用它。但一旦你开始编写脚本，你可能希望将你的对象作为变量存储起来以供以后使用，所以我们将在这个章节中介绍这些内容。你可以在许多地方使用变量，而不仅仅是长而复杂的脚本中，所以我们也将在这个章节中展示一些实际使用变量的方法。
- en: 16.1 Introduction to variables
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 变量的介绍
- en: 'A simple way to think of a *variable* is as a box in the computer’s memory
    that has a name. You can put whatever you want into the box: a single computer
    name, a collection of services, an XML document, and so on. You access the box
    by using its name, and when accessing it, you can put things in it or retrieve
    things from it. Those things stay in the box, allowing you to retrieve them over
    and over.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将*变量*想象成计算机内存中的一个带有名称的盒子是一种简单的方法。你可以把任何东西放进盒子里：单个计算机名、一组服务、一个XML文档等等。你可以通过使用其名称来访问盒子，在访问时，你可以往里面放东西或从中检索东西。这些东西会留在盒子里，让你可以反复检索。
- en: 'PowerShell doesn’t place a lot of formality around variables. For example,
    you don’t have to explicitly announce or declare your intention to use a variable
    before you do so. You can also change the types or objects of the contents of
    a variable: one moment you might have a single process in it, and the next moment
    you can store an array of computer names in it. A variable can even contain multiple
    different things, such as a collection of services *and* a collection of processes
    (although we admit that, in those cases, using the variable’s contents can be
    tricky).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 对变量没有太多的正式要求。例如，在使用变量之前，你不必明确宣布或声明你打算使用变量。你还可以更改变量的内容类型或对象：这一刻你可能在里面有一个单个进程，下一刻你可以在里面存储一个计算机名数组。变量甚至可以包含多个不同的事物，例如一组服务和一组进程（尽管我们承认在这些情况下，使用变量的内容可能会很棘手）。
- en: 16.2 Storing values in variables
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 在变量中存储值
- en: 'Everything in PowerShell—and we do mean *everything*—is treated as an object.
    Even a simple string of characters, such as a computer name, is considered an
    object. For example, piping a string to `Get-Member` (or its alias, `gm`) reveals
    that the object is of the type `System.String` and that it has a great many methods
    you can work with (we’re truncating the following list to save space):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中——我们确实是指*一切*——都被视为对象。即使是像计算机名这样的简单字符字符串也被视为对象。例如，将字符串管道到`Get-Member`（或其别名`gm`）会显示该对象是`System.String`类型，并且它有许多你可以与之交互的方法（我们截断以下列表以节省空间）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives you:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Try it Now Run this same command in PowerShell to see if you get the complete
    list of methods—and even a property—that comes with a `System.String` object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Run this same command in PowerShell to see if you get the complete list
    of methods—and even a property—that comes with a `System.String` object.
- en: Although that string is technically an object, you’ll find that folks tend to
    refer to it as a simple value like everything else in the shell. That’s because,
    in most cases, what you’re concerned about is the string itself—`"SRV-02"` in
    the previous example—and you’re less concerned about retrieving information from
    properties. That’s different from, say, a process where the entire process object
    is a big, abstract data construct, and you’re usually dealing with individual
    properties such as `VM`, `PM`, `Name`, `CPU`, `ID`, and so forth. A `String` is
    an object, but it’s a much less complicated object than something like a `Process`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲，这个字符串是一个对象，但你可能会发现人们倾向于像在shell中的其他所有东西一样，将其称为一个简单的值。这是因为，在大多数情况下，你关心的是字符串本身——例如前一个例子中的`"SRV-02"`——而你不太关心从属性中检索信息。这与一个整个进程对象是一个大型的抽象数据结构的过程不同，你通常处理的是单个属性，如`VM`、`PM`、`Name`、`CPU`、`ID`等等。`String`是一个对象，但它比`Process`这样的对象要简单得多。
- en: 'PowerShell allows you to store these simple values in a variable. To do this,
    specify the variable, and use the equals sign operator—the *assignment* operator—followed
    by whatever you want to put within the variable. Here’s an example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 允许你将这些简单的值存储在变量中。为此，指定变量，并使用等号运算符——即*赋值*运算符——后跟你想放入变量中的任何内容。以下是一个示例：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Try it Now Follow along with these examples, because then you’ll be able to
    replicate the results we demonstrate. You should use your test server’s name rather
    than `SRV-02.`
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。跟随这些例子，因为这样你就能复制我们展示的结果。你应该使用你的测试服务器的名称，而不是 `SRV-02.`
- en: It’s important to note that the dollar sign (`$`) isn’t part of the variable’s
    name. In our example, the variable name is `var`. The dollar sign is a cue to
    the shell that what follows is going to be a variable name and that we want to
    access the contents of that variable. In this case, we’re setting the contents
    of the variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，美元符号 (`$`) 不是变量名的一部分。在我们的例子中，变量名是 `var`。美元符号是shell的一个提示，表明接下来的是变量名，并且我们想要访问该变量的内容。在这种情况下，我们正在设置变量的内容。
- en: 'Let’s look at some key points to keep in mind about variables and their names:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于变量及其名称的一些关键点：
- en: Variable names usually contain letters, numbers, and underscores, and it’s most
    common for them to begin with a letter or an underscore.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名通常包含字母、数字和下划线，并且它们通常以字母或下划线开头。
- en: Variable names can contain spaces, but the name must be enclosed in curly braces.
    For example, `${My Variable}` represents a variable named `My` `Variable`. Personally,
    we dislike variable names that contain spaces because they require more typing,
    and they’re harder to read.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名可以包含空格，但名称必须用大括号括起来。例如，`${My Variable}` 表示一个名为 `My` `Variable` 的变量。个人来说，我们不喜欢包含空格的变量名，因为它们需要更多的输入，而且更难阅读。
- en: Variables don’t persist between shell sessions. When you close the shell, any
    variables you created go away.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量在shell会话之间不会持久存在。当你关闭shell时，你创建的任何变量都会消失。
- en: Variable names can be quite long—long enough that you don’t need to worry about
    how long. Try to make variable names sensible. For example, if you’ll be putting
    a computer name into a variable, use `computername` as the variable name. If a
    variable will contain a bunch of processes, then `processes` is a good variable
    name.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名可以相当长——长到你不必担心长度。尽量使变量名合理。例如，如果你要将计算机名放入变量中，使用 `computername` 作为变量名。如果一个变量将包含多个进程，那么
    `processes` 是一个好的变量名。
- en: Some folks who have experience with other scripting languages may be used to
    using prefixes to indicate what is stored in the variable. For example, `strComputerName`
    is a common type of variable name, meaning that the variable holds a string (the
    `str` part). PowerShell doesn’t care whether you do that, but it’s no longer considered
    a desirable practice by the PowerShell community.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些有其他脚本语言经验的用户可能习惯于使用前缀来指示变量中存储的内容。例如，`strComputerName` 是一种常见的变量名，意味着该变量包含一个字符串（`str`
    部分）。PowerShell并不关心你是否这样做，但PowerShell社区不再认为这是一种可取的做法。
- en: 'To retrieve the contents of a variable, use the dollar sign followed by the
    variable name, as shown in the following example. Again, the dollar sign tells
    the shell that you want to access the *contents* of a variable; following it with
    the variable name tells the shell which variable you’re accessing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索变量的内容，请使用美元符号后跟变量名，如下面的示例所示。同样，美元符号告诉shell你想要访问变量的 *内容*；跟在它后面的是变量名告诉shell你要访问哪个变量：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This outputs
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use a variable in place of a value in almost any situation, for example,
    when using `Get-Process` `ID`. The command might typically look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在任何情况下使用变量代替值，例如，当使用 `Get-Process` `ID` 时。命令可能看起来像这样：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This outputs
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can substitute a variable for any of the values:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用变量替换任何值：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Which gives you
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By the way, we realize that `var` is a pretty generic variable name. We’d normally
    use `processId`, but in this specific instance, we plan to reuse `$var` in several
    situations, so we decided to keep it generic. Don’t let this example stop you
    from using more sensible variable names in real life. We may have put a string
    into `$var` to begin with, but we can change that anytime we want:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们意识到 `var` 是一个相当通用的变量名。我们通常会使用 `processId`，但在这个特定的情况下，我们计划在几种情况下重用 `$var`，所以我们决定保持其通用性。不要让这个例子阻止你在现实生活中使用更合理的变量名。我们最初可能已经将一个字符串放入
    `$var` 中，但我们可以随时更改它：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we placed an integer into `$var`, and then we piped
    `$var` to `Get-Member`. You can see that the shell recognizes the contents of
    `$var` as a `System .Int32`, or a 32-bit integer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将一个整数放入 `$var` 中，然后我们将 `$var` 管道到 `Get-Member`。你可以看到，shell 将 `$var`
    的内容识别为 `System .Int32`，即32位整数。
- en: '16.3 Using variables: Fun tricks with quotes'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 使用变量：引号中的趣味技巧
- en: Because we’re talking about variables, this is an excellent time to cover a
    neat PowerShell feature. Up to this point in the book, we’ve advised you to generally
    enclose strings within single quotation marks. The reason for that is PowerShell
    treats everything enclosed in single quotation marks as a literal string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在谈论变量，这是一个介绍一个整洁的PowerShell特性的好时机。到目前为止，这本书中我们建议你通常用单引号括起字符串。这样做的原因是PowerShell将单引号内的一切视为字面量字符串。
- en: 'Consider the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here you can see that the `$var` within single quotes is treated as a literal.
    But in double quotation marks, that’s not the case. Check out the following trick:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到单引号内的`$var`被视为一个字面量。但在双引号中，情况并非如此。看看下面的技巧：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We start our example by storing `SRV-02` in the variable `$computername`. Next,
    we store `"The computer name is $computername"` in the variable `$phrase`. When
    we do this, we use double quotes. PowerShell automatically seeks out dollar signs
    within double quotes and replaces any variables it finds *with their contents*.
    Because we display the contents of `$phrase`, the `$computername` variable is
    replaced with `SRV-02`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从将`SRV-02`存储在变量`$computername`中开始我们的示例。接下来，我们将`"The computer name is $computername"`存储在变量`$phrase`中。当我们这样做时，我们使用双引号。PowerShell会自动在双引号内寻找美元符号，并用它找到的任何变量替换它们的内容。因为我们显示`$phrase`的内容，所以`$computername`变量被替换为`SRV-02`。
- en: 'This replacement action happens only when the shell initially parses the string.
    At this point, `$phrase` contains `"The computer name is SRV-02"`—it doesn’t contain
    the `"$computername"` string. We can test that by trying to change the contents
    of `$computername` to see whether `$phrase` updates itself:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替换动作仅在shell最初解析字符串时发生。此时，`$phrase`包含`"The computer name is SRV-02"`——它不包含`"$computername"`字符串。我们可以通过尝试更改`$computername`的内容来测试这一点，看看`$phrase`是否会更新自己：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the `$phrase` variable stays the same.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`$phrase`变量保持不变。
- en: Another facet of this double-quotes trick is the PowerShell escape character.
    This character is the backtick (`` ` ``), and on a US keyboard it’s located on
    one of the upper-left keys, usually below the Esc key and often on the same key
    as the tilde (`~`) character. The problem is that, in some fonts, it’s practically
    indistinguishable from a single quote. In fact, we usually configure our shell
    to use the Consolas font, because that makes distinguishing the backtick easier
    than when using the Lucida Console or Raster fonts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号技巧的另一个方面是PowerShell的转义字符。这个字符是反引号（`` ` ``），在美国键盘上，它位于左上角的一个键上，通常位于Esc键下方，有时与波浪号（`~`）字符在同一个键上。问题是，在某些字体中，它与单引号几乎无法区分。事实上，我们通常配置我们的shell使用Consolas字体，因为这样比使用Lucida
    Console或Raster字体更容易区分反引号。
- en: 'Let’s look at what this escape character does. It removes whatever special
    meaning might be associated with the character after it, or in some cases, it
    adds special meaning to the following character. We have an example of the first
    use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个转义字符的作用。它移除可能与它后面的字符关联的任何特殊含义，或者在某些情况下，它给后面的字符添加特殊含义。我们有一个第一个使用的例子：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we assign the string to `$phrase`, we use `$computername` twice. The first
    time, we precede the dollar sign with a backtick. Doing this takes away the dollar
    sign’s special meaning as a variable indicator and makes it a literal dollar sign.
    You can see in the preceding output, on the last line, that `$computername` is
    stored in the variable. We don’t use the backtick the second time, so `$computername`
    is replaced with the contents of that variable. Now let’s look at an example of
    the second way a backtick can work:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将字符串赋值给`$phrase`时，我们使用了`$computername`两次。第一次，我们在美元符号前加了一个反引号。这样做消除了美元符号作为变量指示符的特殊含义，使其成为一个字面量美元符号。你可以在前面的输出中看到，在最后一行，`$computername`被存储在变量中。我们没有在第二次使用反引号，所以`$computername`被替换为该变量的内容。现在让我们看看反引号可以以第二种方式工作的例子：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Look carefully, and you’ll notice we use `` `n `` twice in the phrase—once after
    the first `$computername` and once after `contains`. In the example, the backtick
    adds special meaning. Normally, *n* is a letter, but with the backtick in front
    of it, it becomes a carriage return and line feed (think *n* for *new line*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会发现我们在短语中使用了`` `n ``两次——一次在第一个`$computername`之后，一次在`contains`之后。在示例中，反引号添加了特殊含义。通常，*n*是一个字母，但反引号在它前面时，它变成了回车和换行（想想*n*代表*新行*）。
- en: Run `help about_escape` for more information, including a list of other special
    escape characters. You can, for example, use an escaped *t* to insert a tab, or
    an escaped *a* to make your computer beep (think *a* for *alert*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `help about_escape` 获取更多信息，包括其他特殊转义字符的列表。例如，你可以使用转义的 *t* 来插入制表符，或者使用转义的 *a*
    来使计算机发出蜂鸣声（想想 *a* 代表 *alert*）。
- en: 16.4 Storing many objects in a variable
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 在变量中存储多个对象
- en: Up till now, we’ve been working with variables that contain a single object,
    and those objects have all been simple values. We’ve worked directly with the
    objects themselves, rather than with their properties or methods. Let’s now try
    putting a bunch of objects into a single variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理包含单个对象的变量，而这些对象都是简单值。我们直接与对象本身而不是它们的属性或方法一起工作。现在让我们尝试将多个对象放入一个变量中。
- en: 'One way to do this is to use a comma-separated list, because PowerShell recognizes
    those lists as collections of objects:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是用逗号分隔的列表，因为 PowerShell 识别这些列表为对象的集合：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we’re careful in this example to put the commas outside the quotation
    marks. If we put them inside, we’d have a single object that includes commas and
    three computer names. With our method, we get three distinct objects, all of which
    are `String` types. As you can see, when we examine the contents of the variable,
    PowerShell displays each object on its own line.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们小心地将逗号放在引号外面。如果我们把它们放在里面，我们会得到一个包含逗号和三个计算机名称的单个对象。使用我们的方法，我们得到三个不同的对象，它们都是
    `String` 类型。正如你所看到的，当我们检查变量的内容时，PowerShell 会单独显示每个对象。
- en: 16.4.1 Working with single objects in a variable
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.1 在变量中处理单个对象
- en: 'You can also access individual elements in the variable, one at a time. To
    do this, specify an index number for the object you want, in square brackets.
    The first object is always at index number `0`, and the second is at index number
    `1`, and so forth. You can also use an index of `-1` to access the last object,
    `-2` for the next-to-last object, and so on. Here’s an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以逐个访问变量中的单个元素。为此，指定你想要的对象的索引号，用方括号表示。第一个对象始终在索引号 `0`，第二个在索引号 `1`，依此类推。你还可以使用索引
    `-1` 来访问最后一个对象，`-2` 用于倒数第二个对象，依此类推。以下是一个例子：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The variable itself has a property that lets you see how many objects are in
    it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 变量本身有一个属性，可以让你看到里面有多少个对象：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This results in
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also access the properties and methods of the objects inside the variable
    as if they were properties and methods of the variable itself. This is easier
    to see, at first, with a variable that contains a single object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像访问变量的属性和方法一样访问变量内部对象的属性和方法。一开始，这在一个只包含单个对象的变量中更容易看到：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we’re using the `$computername` variable we created earlier
    in the chapter. As you may remember, that variable contains an object of the type
    `System .String`, and you should have seen the complete list of properties and
    methods of that type when you piped a string to `Get-Member` in section 16.2\.
    We use the `Length` property, as well as the `ToUpper``()`, `ToLower``()`, and
    `Replace()` methods. In each case, we have to follow the method name with parentheses,
    even though neither `ToUpper()` nor `ToLower()` requires any parameters inside
    those parentheses. Also, none of these methods change what is in the variable—you
    can see that on the last line. Instead, each method creates a new `String` based
    on the original one, as modified by the method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用本章前面创建的 `$computername` 变量。你可能还记得，这个变量包含一个 `System.String` 类型的对象，当你将字符串管道传输到
    16.2 节中的 `Get-Member` 时，你应该已经看到了该类型的完整属性和方法列表。我们使用 `Length` 属性以及 `ToUpper()`、`ToLower()`
    和 `Replace()` 方法。在每种情况下，我们都必须在方法名后跟括号，即使 `ToUpper()` 和 `ToLower()` 不需要括号内的任何参数。此外，这些方法中的任何一个都不会改变变量中的内容——你可以在最后一行看到这一点。相反，每个方法都会根据原始对象创建一个新的
    `String`，该对象由方法修改。
- en: 'What if you want to change the contents of the variable? You can assign a new
    value to the variable pretty easily:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想改变变量的内容？你可以很容易地为变量分配一个新的值：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 16.4.2 Working with multiple objects in a variable
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.2 在变量中处理多个对象
- en: 'When a variable contains multiple objects, the steps can get trickier. Even
    if every object inside the variable is of the same type, as is the case with our
    `$computers` variable, and you can call a method on every object, it might not
    be what you want to do. You probably want to specify which object within the variable
    you want and then access a property or execute a method on that specific object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量包含多个对象时，步骤可能会变得复杂。即使变量内的每个对象都是同一类型，就像我们的 `$computers` 变量一样，并且你可以对每个对象调用方法，但这可能不是你想要做的。你可能想要指定变量中你想要的对象，然后访问该特定对象的属性或执行方法：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, these methods are producing new strings, not changing the ones inside
    the variable. You can test that by examining the contents of the variable:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些方法是在生成新的字符串，而不是改变变量内部的字符串。你可以通过检查变量的内容来测试这一点：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What if you want to change the contents of the variable? You assign a new value
    to one of the existing objects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要改变变量的内容？你给现有的对象之一分配一个新值：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see in this example that we change the second object in the variable,
    rather than produce a new string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在这个例子中，我们改变了变量中的第二个对象，而不是生成一个新的字符串。
- en: 16.4.3 Other ways to work with multiple objects
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.3 其他处理多个对象的方法
- en: 'We want to show you two other options for working with the properties and methods
    of a bunch of objects contained in a variable. The previous examples executed
    methods on only a single object within the variable. If you want to run the `ToLower()`
    method on every object within the variable, and store the results back into the
    variable, you do something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想向您展示两种处理变量中包含的一组对象的属性和方法的其他选项。前面的示例仅对变量中的单个对象执行了方法。如果你想在变量中的每个对象上运行 `ToLower()`
    方法，并将结果存储回变量，你可以这样做：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example is a bit complicated, so let’s break it down in figure 16.1\. We
    start the pipeline with `$computers` `=`, which means the results of the pipeline
    will be stored in that variable. Those results overwrite whatever was in the variable
    previously.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有点复杂，所以让我们在图16.1中分解它。我们以 `$computers` `=` 开始管道，这意味着管道的结果将存储在那个变量中。这些结果覆盖了变量中之前的内容。
- en: '![](Images/CH16_F01_Plunk.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH16_F01_Plunk.png)'
- en: Figure 16.1 Using `ForEach-Object` to execute a method against each object contained
    within a variable
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 使用 `ForEach-Object` 对变量中包含的每个对象执行方法
- en: The pipeline begins with `$computers` being piped to `ForEach-Object`. The cmdlet
    enumerates each object in the pipeline (we have three computer names, which are
    `string` objects) and executes its script block for each. Within the script block,
    the `$_ `placeholder contains one piped-in object at a time, and we’re executing
    the `ToLower()` method on each object. The new `String` objects produced by `ToLower()`
    are placed into the pipeline—and into the `$computers` variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 管道从 `$computers` 被管道传输到 `ForEach-Object` 开始。该命令枚举管道中的每个对象（我们有三个计算机名称，它们是 `string`
    对象）并为每个对象执行其脚本块。在脚本块中，`$_` 占位符每次包含一个管道输入的对象，并且我们在每个对象上执行 `ToLower()` 方法。由 `ToLower()`
    产生的新 `String` 对象被放入管道——以及 `$computers` 变量中。
- en: 'You can do something similar with properties by using `Select-Object`. This
    example selects the `Length` property of each object you pipe to the cmdlet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Select-Object` 来做类似的事情。这个例子选择了传递给该命令的每个对象的 `Length` 属性：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This gives you
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这给你
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because the property is numeric, PowerShell right-aligns the output.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为属性是数字，PowerShell 将输出右对齐。
- en: 16.4.4 Unrolling properties and methods in PowerShell
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.4 在 PowerShell 中展开属性和方法
- en: 'You *can* access properties and methods by using a variable that contains multiple
    objects:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用包含多个对象的变量来访问属性和方法：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Under the hood, PowerShell “sees” that you’re trying to access a property in
    that example. It also sees that the collection in `$processes` doesn’t have a
    `Name` property—but the individual objects within the collection do. So it implicitly
    enumerates, or unrolls, the objects and grabs the `Name` property of each. This
    is equivalent to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，PowerShell “看到”你试图在示例中访问属性。它还看到 `$processes` 中的集合没有 `Name` 属性——但是集合中的每个单独的对象都有。因此，它隐式枚举或展开对象，并获取每个对象的
    `Name` 属性。这相当于以下内容：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And it is also equivalent to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这也等同于以下操作：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same thing works for methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于方法：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 16.5 More tricks with double quotes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 双引号的一些更多技巧
- en: 'We have another cool technique you can use with double quotes, which is a somewhat
    conceptual extension of the variable-replacement trick. Suppose, for example,
    that you’ve put a bunch of processes into the `$processes` variable. Now you want
    to put only the name of the first one into a string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个你可以使用双引号使用的酷炫技巧，这是对变量替换技巧的一种概念上的扩展。例如，假设你已经将一些进程放入了 `$processes` 变量中。现在你只想将第一个进程的名称放入一个字符串中：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This results in:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Err, oops. The `[` immediately after `$processes` in the example isn’t normally
    a legal character in a variable name, which causes PowerShell to try to replace
    `$processes`. Doing this jams the name of every service into your string. The
    `[0].name` part isn’t replaced at all. The solution is to put all of that into
    an expression:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，哎呀。示例中 `$processes` 后面的 `[` 通常不是一个变量名中的合法字符，这会导致 PowerShell 尝试替换 `$processes`。这样做会将每个服务的名称都挤入你的字符串中。`[0].name`
    这部分根本不会被替换。解决方案是将所有这些放入一个表达式中：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This results in
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Everything within `$()` is evaluated as a normal PowerShell command, and the
    result is placed into the string, replacing anything that’s already there. Again,
    this works only in double quotes. This `$()` construct is called a *subexpression*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`$()` 中的所有内容都被评估为正常的 PowerShell 命令，并将结果放入字符串中，替换掉任何已经存在的内容。再次强调，这仅在双引号中有效。这个
    `$()` 构造被称为 *子表达式*。'
- en: 'We have another cool trick you can do in PowerShell. Sometimes you’ll want
    to put something more complicated into a variable and then display that variable’s
    contents within quotation marks. In PowerShell, the shell is smart enough to enumerate
    all of the objects in a collection even when you refer to a single property or
    method, provided that all of the objects in the collection are of the same type.
    For example, we’ll retrieve a list of processes and put them into the `$processes`
    variable, and then include only the process names in double quotes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 PowerShell 中还有一个你可以做的酷炫技巧。有时你可能会想要将一些更复杂的东西放入变量中，然后显示该变量的内容，在引号内。在 PowerShell
    中，外壳足够聪明，即使你只引用单个属性或方法，也能枚举集合中的所有对象，只要集合中的所有对象都是同一类型。例如，我们将检索进程列表并将它们放入 `$processes`
    变量中，然后只包括进程名称在双引号中：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This results in
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We truncated the preceding output to save space, but we hope you get the idea.
    Obviously, this might not be the exact output you’re looking for, but between
    this technique and the subexpressions technique we showed you earlier in this
    section, you should be able to get exactly what you want.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们截断了前面的输出以节省空间，但我们希望你能理解这个概念。显然，这可能不是你想要的精确输出，但通过这个技术和我们在本节中之前展示的子表达式技术，你应该能够得到你想要的精确结果。
- en: 16.6 Declaring a variable’s type
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 声明变量的类型
- en: So far, we’ve put objects into variables and let PowerShell figure out what
    types of objects we were using. PowerShell doesn’t care what kind of objects you
    put into the box. But you might care.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将对象放入变量中，让 PowerShell 确定我们使用的是哪种类型的对象。PowerShell 不在乎你把什么类型的对象放入盒子中。但你可能在乎。
- en: 'For example, suppose you have a variable that you expect to contain a number.
    You plan to do some arithmetic with that number, and you ask a user to input that
    number. Let’s look at an example, which you can type directly into the command
    line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个你期望包含数字的变量。你计划用这个数字做一些算术运算，并要求用户输入这个数字。让我们看看一个例子，你可以直接在命令行中输入：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Try it Now We haven’t shown you `Read-Host` yet—we’re saving it for the next
    chapter—but its operation should be obvious if you follow along with this example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 我们还没有向你展示 `Read-Host`——我们将其留到下一章，但如果你跟随这个例子，它的操作应该是显而易见的。
- en: What the heck? How can `100` multiplied by `10` be `100100100100100100100100100100`?
    What crazy new math is that?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是什么情况？`100` 乘以 `10` 怎么会是 `100100100100100100100100100100`？那是哪种疯狂的新数学？
- en: If you’re sharp-eyed, you may have spotted what’s happening. PowerShell doesn’t
    treat our input as a number; it treats it as a string. Instead of multiplying
    `100` by `10`, PowerShell *duplicated the string* `"100"` *10 times*. The result,
    then, is the string `100`, listed 10 times in a row. Oops.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你眼尖，你可能已经发现了正在发生的事情。PowerShell 不将我们的输入视为数字；它将其视为字符串。而不是将 `100` 乘以 `10`，PowerShell
    *重复了字符串* `"100"` *10 次*。因此，结果是字符串 `100`，连续列出 10 次。哎呀。
- en: 'We can verify that the shell is in fact treating the input as a string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证，外壳实际上是将输入作为字符串处理的：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Yep, piping `$number` to `Get-Member` confirms that the shell sees it as a `System.String`,
    not a `System.Int32`. There are a couple of ways to deal with this problem, and
    we’ll show you the easiest one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，将 `$number` 传递给 `Get-Member` 可以确认，shell 将其视为 `System.String`，而不是 `System.Int32`。处理这个问题的方法有几个，我们将向您展示最简单的一个。
- en: 'First, we tell the shell that the `$number` variable should contain an integer,
    which will force the shell to try to convert any input to a real number. We do
    that in the following example by specifying the desired data type, `int`, in square
    brackets immediately prior to the variable’s first use:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉 shell `$number` 变量应该包含一个整数，这将迫使 shell 尝试将任何输入转换为实数。我们在以下示例中通过在变量首次使用之前立即指定所需的数据类型
    `int`，在方括号中完成这一点：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Forces the variable to [int]
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 强制变量为 [int]
- en: ❷ Confirms that the variable is Int32
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确认变量是 Int32
- en: ❸ The variable was treated as a number.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 变量被当作数字处理。
- en: In this example, we use `[int]` to force `$number` to contain only integers.
    After entering our input, we pipe `$number` to `Get-Member` to confirm that it
    is indeed an integer and not a string. At the end, you can see that the variable
    is treated as a number, and multiplication takes place.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `[int]` 来强制 `$number` 只包含整数。在输入我们的输入后，我们将 `$number` 传递给 `Get-Member`
    以确认它确实是一个整数而不是字符串。最后，您可以看到变量被当作数字处理，并且发生了乘法操作。
- en: 'Another benefit to using this technique is that the shell will throw an error
    if it can’t convert the input into a number, because `$number` is capable of storing
    only integers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术的另一个好处是，如果 shell 无法将输入转换为数字，它将抛出一个错误，因为 `$number` 只能存储整数：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a great example of how to prevent problems down the line, because you’re
    assured that `$number` will contain the exact type of data you expect it to.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了如何防止未来的问题，因为您可以确保 `$number` 将包含您期望的确切数据类型。
- en: 'You can use many object types in place of `[int]`, but the following list includes
    some of the ones you’ll most commonly use:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多对象类型来代替 `[int]`，但以下列表包括您最常使用的一些类型：
- en: '`[int]`—Integer numbers'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[int]`—整数'
- en: '`[single]` and `[double]`—Single-precision and double-precision floating numbers
    (numbers with a decimal portion)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[single]` 和 `[double]`—单精度和双精度浮点数（有小数部分的数字）'
- en: '`[string]`—A string of characters'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[string]`—字符字符串'
- en: '`[char]`—Exactly one character (e.g., `[char]$c = ''X''`)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[char]`—恰好一个字符（例如，`[char]$c = ''X''`）'
- en: '`[xml]`—An XML document; whatever string you assign to this will be parsed
    to make sure it contains valid XML markup (e.g., `[xml]$doc` `=` `Get-Content`
    `MyXML.xml`)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[xml]`—XML 文档；分配给此的任何字符串都将被解析以确保它包含有效的 XML 标记（例如，`[xml]$doc = Get-Content
    MyXML.xml`）'
- en: 'Specifying an object type for a variable is a great way to prevent certain
    tricky logic errors in more-complex scripts. As the following example shows, once
    you specify the object type, PowerShell enforces it until you explicitly retype
    the variable:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为变量指定对象类型是防止更复杂脚本中某些棘手的逻辑错误的好方法。以下示例显示，一旦指定了对象类型，PowerShell 就会强制执行它，直到您明确地重新类型化变量：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Declares $x as an integer
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明 $x 为整数
- en: ❷ Creates an error by putting a string into $x
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将字符串放入 $x 中创建错误
- en: ❸ Retypes $x as a string
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 $x 重新类型化为字符串
- en: ❹ Confirms a new type of $x
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确认 $x 的新类型
- en: You can see that we start by declaring `$x` as an integer and placing an integer
    into it. When we try to put a string into it, PowerShell throws an error because
    it can’t convert that particular string into a number. Later we retype `$x` as
    a string, and we’re able to put a string into it. We confirm that by piping the
    variable to `Get-Member` and checking its type name.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们首先声明 `$x` 为整数并将一个整数放入其中。当我们尝试放入一个字符串时，PowerShell 会抛出一个错误，因为它无法将那个特定的字符串转换为数字。后来我们将
    `$x` 重新类型化为字符串，我们能够放入一个字符串。我们通过将变量传递给 `Get-Member` 并检查其类型名称来确认这一点。
- en: 16.7 Commands for working with variables
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.7 变量操作命令
- en: 'We’ve started to use variables at this point, without formally declaring our
    intention to do so. PowerShell doesn’t require advanced variable declaration,
    and you can’t force it to make a declaration. (Some folks may be looking for something
    like `Option Explicit` and will be disappointed; PowerShell has something called
    `Set-StrictMode`, but it isn’t exactly the same thing.) But the shell does include
    the following commands for working with variables:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开始使用变量，但没有正式声明我们的意图。PowerShell 不需要高级变量声明，你不能强迫它进行声明。（有些人可能正在寻找类似 `Option
    Explicit` 的东西，但会感到失望；PowerShell 有一个叫做 `Set-StrictMode` 的东西，但它并不完全相同。）但是，shell
    包含以下用于处理变量的命令：
- en: '`New-Variable`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-Variable`'
- en: '`Set-Variable`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set-Variable`'
- en: '`Remove-Variable`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove-Variable`'
- en: '`Get-Variable`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-Variable`'
- en: '`Clear-Variable`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear-Variable`'
- en: You don’t need to use any of these except perhaps `Remove-Variable`, which is
    useful for permanently deleting a variable (you can also use the `Remove-Item`
    command within the `VARIABLE:` drive to delete a variable). You can perform every
    other function—creating new variables, reading variables, and setting variables—by
    using the ad hoc syntax we’ve used up to this point in the chapter. Using these
    cmdlets offers no specific advantages, in most cases, as you are forcing variable
    assignment until you run your script. This can be problematic for tools that provide
    completions as you type, such as Visual Studio Code. These complications will
    be more accurate if you use the normal assignment operators, because PowerShell
    can look at your script and predict the data style of the variable’s value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要使用这些中的任何一项，除非可能是 `Remove-Variable`，这对于永久删除变量很有用（你还可以在 `VARIABLE:` 驱动器中使用
    `Remove-Item` 命令来删除变量）。你可以通过使用本章中到目前为止我们所使用的临时语法来执行每个其他功能——创建新变量、读取变量和设置变量。在大多数情况下，使用这些
    cmdlet 没有特定的优势，因为你是在运行脚本之前强制变量赋值。这可能会对提供即时补全的工具（如 Visual Studio Code）造成问题。如果你使用正常的赋值运算符，这些复杂情况将更加准确，因为
    PowerShell 可以查看你的脚本并预测变量值的样式。
- en: If you do decide to use these cmdlets, you give your variable name to the cmdlets’
    `-name` parameters. This is *only the variable name*—it doesn’t include the dollar
    sign. The one time you might want to use one of these cmdlets is when working
    with something called an *out-of-scope* variable. Messing with out-of-scope variables
    is a poor practice, and we don’t cover them (or much more on scope) in this book,
    but you can run `help about_scope` in the shell to learn more.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实决定使用这些 cmdlet，你需要将变量名提供给 cmdlet 的 `-name` 参数。这**仅是变量名**——它不包括美元符号。你可能会想使用这些
    cmdlet 的情况之一是处理所谓的**超出作用域**的变量。玩弄超出作用域的变量是一种不良做法，我们在这本书中没有涉及（或关于作用域的更多内容），但你可以在
    shell 中运行 `help about_scope` 来了解更多信息。
- en: 16.8 Variable best practices
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.8 变量最佳实践
- en: 'We’ve mentioned most of these practices already, but this is a good time to
    review them quickly:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了这些实践中的大部分，但这是一个快速复习它们的好时机：
- en: Keep variable names meaningful but succinct. Whereas `$computername` is a great
    variable name because it’s clear and concise, `$c` is a poor name because what
    it contains isn’t clear. The variable name `$computer_to_query_for_data` is a
    bit long for our taste. Sure, it’s meaningful, but do you want to type that over
    and over?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持变量名既有意义又简洁。例如，`$computername` 是一个很好的变量名，因为它既清晰又简洁，而 `$c` 则是一个糟糕的名字，因为它包含的内容并不明确。变量名
    `$computer_to_query_for_data` 对于我们的口味来说有点长。当然，它是有意义的，但你真的想一遍又一遍地输入它吗？
- en: Don’t use spaces in variable names. We know you can, but it’s ugly syntax.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在变量名中使用空格。我们知道你可以这样做，但这是一种丑陋的语法。
- en: If a variable contains only one kind of object, declare that when you first
    use the variable. This can help prevent confusing logic errors. Suppose you’re
    working in a commercial script development environment (such as Visual Studio
    Code). In that case, the editor software can provide code-hinting features when
    you tell it the type of object that a variable will contain.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个变量只包含一种类型的对象，那么在第一次使用变量时就应该声明这一点。这有助于防止逻辑错误。假设你在一个商业脚本开发环境中工作（例如 Visual
    Studio Code）。在这种情况下，编辑软件可以在你告诉它变量将包含的对象类型时提供代码提示功能。
- en: 16.9 Common points of confusion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.9 常见混淆点
- en: 'The biggest single point of confusion we see new students struggle with is
    the variable name. We hope we’ve done an excellent job explaining it in this chapter,
    but always remember that the dollar sign *isn’t part of the variable’s name*.
    It’s a cue to the shell that you want to access the *contents* of a variable;
    what follows the dollar sign is taken as the variable’s name. The shell has two
    parsing rules that let it capture the variable name:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的新学生最常遇到的一个困惑点是变量名。我们希望我们已经在本章中很好地解释了它，但请始终记住，美元符号**不是变量名的一部分**。它是向 shell
    发出的一个信号，表明你想要访问变量的**内容**；美元符号之后的内容被视为变量名。shell 有两个解析规则，允许它捕获变量名：
- en: If the character immediately after the dollar sign is a letter, number, or underscore,
    the variable name consists of all the characters following the dollar sign, up
    to the next white space (which might be a space, tab, or carriage return).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果美元符号后面的字符是一个字母、数字或下划线，则变量名由美元符号之后直到下一个空白字符（可能是空格、制表符或回车符）的所有字符组成。
- en: If the character immediately after the dollar sign is an opening curly brace
    `{`, the variable name consists of everything after that curly brace up to, but
    not including, the closing curly brace `}`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果美元符号后面的字符是一个开括号 `{`，则变量名由该括号之后直到但不包括闭括号 `}` 的所有内容组成。
- en: 16.10 Lab
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.10 实验项目
- en: Create a background job that gets all processes that start with `pwsh` from
    two computers (use `localhost` twice if you have only one computer to experiment
    with).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个后台作业，从两台计算机上获取以 `pwsh` 开头的所有进程（如果你只有一个计算机进行实验，请使用 `localhost` 两次）。
- en: When the job finishes running, receive the results of the job into a variable.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当作业运行完成后，将作业的结果接收到一个变量中。
- en: Display the contents of that variable.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示该变量的内容。
- en: Export the variable’s contents to a CLIXML file.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量的内容导出到 CLIXML 文件中。
- en: Get a list of all the services currently running on your local machine and save
    it in a variable `$processes``.`
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取你本地机器上当前运行的所有服务的列表，并将其保存到变量 `$processes` 中。
- en: Replace `$processes` with just the bits and print spooler service.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `$processes` 替换为仅包含 bits 和打印打印机的服务。
- en: Display the contents of `$processes`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 `$processes` 的内容。
- en: Export `$processes` to a CSV file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `$processes` 导出为 CSV 文件。
- en: 16.11 Lab answers
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.11 实验答案
- en: '`Invoke-Command {Get-Process pwsh} –computernamelocalhost,$env:computername
    –asjob`'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-Command {Get-Process pwsh} –computernamelocalhost,$env:computername
    –asjob`'
- en: '`$results = Receive-Job 4 –Keep`'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$results = Receive-Job 4 –Keep`'
- en: '`$results`'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$results`'
- en: '`$results | Export-CliXml processes.xml`'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$results | Export-CliXml processes.xml`'
- en: '`$processes = get-service`'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$processes = get-service`'
- en: '`$processes = get-service -name bits,spooler`'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$processes = get-service -name bits,spooler`'
- en: '`$processes`'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$processes`'
- en: '`$processes | export-csv -path c:\services.csv`'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$processes | export-csv -path c:\services.csv`'
- en: 16.12 Further exploration
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.12 进一步探索
- en: Take a few moments and skim through some of the previous chapters in this book.
    Given that variables are primarily designed to store something you might use more
    than once, can you find a use for variables in our topics in previous chapters?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空浏览一下本书的一些前面的章节。鉴于变量主要是为了存储你可能需要多次使用的东西而设计的，你能否在我们的前几章的主题中找到变量的用途？
- en: For example, in chapter 13 you learned to create connections to remote computers.
    In that chapter, you created, used, and closed a connection more or less in one
    step. Wouldn’t it be useful to create the connection, store it in a variable,
    and use it for several commands? That’s only one instance of where variables can
    come in handy (and we’ll show you how to do that in chapter 20). See if you can
    find any more examples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第 13 章中，你学习了如何创建到远程计算机的连接。在那个章节中，你几乎是一步一步地创建了、使用了并关闭了连接。将连接创建、存储在变量中并用于多个命令不是很有用吗？这仅仅是变量可以派上用场的一个例子（我们将在第
    20 章中向你展示如何做到这一点）。看看你是否能找到更多的例子。
