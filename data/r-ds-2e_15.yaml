- en: Chapter 12\. Logical Vectors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 逻辑向量
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In this chapter, you’ll learn tools for working with logical vectors. Logical
    vectors are the simplest type of vector because each element can be only one of
    three possible values: `TRUE`, `FALSE`, and `NA`. It’s relatively rare to find
    logical vectors in your raw data, but you’ll create and manipulate them in the
    course of almost every analysis.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习处理逻辑向量的工具。逻辑向量是最简单的向量类型，因为每个元素只能是三个可能值之一：`TRUE`、`FALSE`和`NA`。在原始数据中找到逻辑向量相对较少，但在几乎每次分析过程中，您都会创建和操作它们。
- en: 'We’ll begin by discussing the most common way of creating logical vectors:
    with numeric comparisons. Then you’ll learn about how you can use Boolean algebra
    to combine different logical vectors, as well as some useful summaries. We’ll
    finish off with [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    and [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml), two
    useful functions for making conditional changes powered by logical vectors.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论创建逻辑向量的最常见方法开始：使用数字比较。然后，您将了解如何使用布尔代数来组合不同的逻辑向量，以及一些有用的摘要。我们将以[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)和[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)两个使用逻辑向量进行条件更改的实用函数结束。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: Most of the functions you’ll learn about in this chapter are provided by base
    R, so we don’t need the tidyverse, but we’ll still load it so we can use [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml),
    [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml), and friends
    to work with data frames. We’ll also continue to draw examples from the [`nycflights13::flights`](https://rdrr.io/pkg/nycflights13/man/flights.xhtml)
    dataset.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章学习的大多数函数由基本R提供，因此我们不需要tidyverse，但仍将加载它以便使用[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)、[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)和其伙伴处理数据框。我们还将继续从[`nycflights13::flights`](https://rdrr.io/pkg/nycflights13/man/flights.xhtml)数据集中提取示例。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, as we start to cover more tools, there won’t always be a perfect real
    example. So we’ll start making up some dummy data with [`c()`](https://rdrr.io/r/base/c.xhtml):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着我们开始涵盖更多工具，就不会总是有一个完美的实际示例。因此，我们将开始使用[`c()`](https://rdrr.io/r/base/c.xhtml)创建一些虚拟数据：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This makes it easier to explain individual functions at the cost of making it
    harder to see how it might apply to your data problems. Just remember that any
    manipulation we do to a free-floating vector, you can do to a variable inside
    a data frame with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    and friends.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以更轻松地解释单个函数，但代价是更难看到它如何适用于您的数据问题。只需记住，我们对自由浮动向量进行的任何操作，您都可以通过[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)和其伙伴在数据框中对变量执行相同的操作。
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Comparisons
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较
- en: 'A common way to create a logical vector is via a numeric comparison with `<`,
    `<=`, `>`, `>=`, `!=`, and `==`. So far, we’ve mostly created logical variables
    transiently within [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)—they
    are computed, used, and then thrown away. For example, the following filter finds
    all daytime departures that arrive roughly on time:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建逻辑向量的常见方法是通过与`<`、`<=`、`>`、`>=`、`!=`和`==`的数字比较。到目前为止，我们主要在[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)内部临时创建逻辑变量——它们被计算、使用，然后丢弃。例如，以下过滤器找到所有准时到达的白天出发航班：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s useful to know that this is a shortcut and you can explicitly create the
    underlying logical variables with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这是一个快捷方式是有用的，您可以使用[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)显式创建底层逻辑变量：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is particularly useful for more complicated logic because naming the intermediate
    steps makes it easier to both read your code and check that each step has been
    computed correctly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于更复杂的逻辑特别有用，因为命名中间步骤使您能够更轻松地阅读代码并检查每个步骤是否已正确计算。
- en: 'All told, the initial filter is equivalent to the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，初始过滤相当于以下操作：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Floating-Point Comparison
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数比较
- en: 'Beware of using `==` with numbers. For example, it looks like this vector contains
    the numbers 1 and 2:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 谨防使用`==`与数字。例如，看起来这个向量包含数字1和2：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But if you test them for equality, you get `FALSE`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您将它们进行相等性测试，将会得到`FALSE`：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What’s going on? Computers store numbers with a fixed number of decimal places,
    so there’s no way to exactly represent 1/49 or `sqrt(2)`, and subsequent computations
    will be very slightly off. We can see the exact values by calling [`print()`](https://rdrr.io/r/base/print.xhtml)
    with the `digits`^([1](ch12.xhtml#idm44771302207136)) argument:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？计算机以固定的小数位数存储数字，所以无法精确表示 1/49 或 `sqrt(2)`，随后的计算将会稍微偏离。我们可以通过调用 [`print()`](https://rdrr.io/r/base/print.xhtml)
    并使用 `digits`^([1](ch12.xhtml#idm44771302207136)) 参数来查看精确值：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see why R defaults to rounding these numbers; they really are very close
    to what you expect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到为什么 R 默认四舍五入这些数字；它们确实非常接近你所期望的值。
- en: 'Now that you’ve seen why `==` is failing, what can you do about it? One option
    is to use [`dplyr::near()`](https://dplyr.tidyverse.org/reference/near.xhtml),
    which ignores small differences:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到为什么 `==` 失败了，你能做些什么？一种选择是使用 [`dplyr::near()`](https://dplyr.tidyverse.org/reference/near.xhtml)，它忽略小差异：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Missing Values
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失值
- en: 'Missing values represent the unknown, so they are “contagious”: almost any
    operation involving an unknown value will also be unknown:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值代表未知，因此它们是“传染性”的：几乎任何涉及未知值的操作也将是未知的：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The most confusing result is this one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人困惑的结果是这个：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It’s easiest to understand why this is true if we artificially supply a little
    more context:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们人为地提供一点更多的上下文，就可以更容易理解这是为什么：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So if you want to find all flights where `dep_time` is missing, the following
    code doesn’t work because `dep_time == NA` will yield `NA` for every single row,
    and [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml) automatically
    drops missing values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想找到所有 `dep_time` 缺失的航班，下面的代码不起作用，因为 `dep_time == NA` 会对每一行都返回 `NA`，而 [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)
    会自动丢弃缺失值：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead we’ll need a new tool: [`is.na()`](https://rdrr.io/r/base/NA.xhtml).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要一个新的工具：[`is.na()`](https://rdrr.io/r/base/NA.xhtml)。
- en: is.na()
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: is.na()
- en: '`is.na(x)` works with any type of vector and returns `TRUE` for missing values
    and `FALSE` for everything else:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`is.na(x)` 适用于任何类型的向量，并返回缺失值为 `TRUE`，其他值为 `FALSE`：'
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can use [`is.na()`](https://rdrr.io/r/base/NA.xhtml) to find all the rows
    with a missing `dep_time`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [`is.na()`](https://rdrr.io/r/base/NA.xhtml) 找到所有具有缺失 `dep_time` 的行：
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[`is.na()`](https://rdrr.io/r/base/NA.xhtml) can also be useful in [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml).
    [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml) usually puts
    all the missing values at the end, but you can override this default by first
    sorting by [`is.na()`](https://rdrr.io/r/base/NA.xhtml):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is.na()`](https://rdrr.io/r/base/NA.xhtml) 在 [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)
    中也很有用。[`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml) 通常将所有缺失值放在最后，但你可以通过首先按
    [`is.na()`](https://rdrr.io/r/base/NA.xhtml) 排序来覆盖此默认行为：'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll come back to cover missing values in more depth in [Chapter 18](ch18.xhtml#chp-missing-values).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 18 章](ch18.xhtml#chp-missing-values) 中更深入地讨论缺失值。
- en: Exercises
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: How does [`dplyr::near()`](https://dplyr.tidyverse.org/reference/near.xhtml)
    work? Type `near` to see the source code. Is `sqrt(2)^2` near 2?
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`dplyr::near()`](https://dplyr.tidyverse.org/reference/near.xhtml) 是如何工作的？输入
    `near` 查看源代码。`sqrt(2)^2` 是否接近于 2？'
- en: Use [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml), [`is.na()`](https://rdrr.io/r/base/NA.xhtml),
    and [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml) together to
    describe how the missing values in `dep_time`, `sched_dep_time`, and `dep_delay`
    are connected.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)，[`is.na()`](https://rdrr.io/r/base/NA.xhtml)，和
    [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml) 一起描述 `dep_time`，`sched_dep_time`，和
    `dep_delay` 中缺失值的关联。
- en: Boolean Algebra
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔代数
- en: Once you have multiple logical vectors, you can combine them using Boolean algebra.
    In R, `&` is “and,” `|` is “or,” `!` is “not,” and [`xor()`](https://rdrr.io/r/base/Logic.xhtml)
    is exclusive or.^([2](ch12.xhtml#idm44771301699872)) For example, `df |> filter(!is.na(x))`
    finds all rows where `x` is not missing, and `df |> filter(x < -10 | x > 0)` finds
    all rows where `x` is smaller than -10 or bigger than 0\. [Figure 12-1](#fig-bool-ops)
    shows the complete set of Boolean operations and how they work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了多个逻辑向量，你可以使用布尔代数将它们组合起来。在 R 中，`&` 表示“与”，`|` 表示“或”，`!` 表示“非”，而 [`xor()`](https://rdrr.io/r/base/Logic.xhtml)
    是异或运算。^([2](ch12.xhtml#idm44771301699872)) 例如，`df |> filter(!is.na(x))` 找到所有 `x`
    不缺失的行，而 `df |> filter(x < -10 | x > 0)` 找到所有 `x` 小于 -10 或大于 0 的行。[图 12-1](#fig-bool-ops)
    显示了完整的布尔操作集合及其工作原理。
- en: '![Six Venn diagrams, each explaining a given logical operator. The circles
    (sets) in each of the Venn diagrams represent x and y. 1\. y & !x is y but none
    of x; x & y is the intersection of x and y; x & !y is x but none of y; x is all
    of x none of y; xor(x, y) is everything except the intersection of x and y; y
    is all of y and none of x; and x | y is everything.](assets/rds2_1201.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![六个维恩图，每个解释一个给定的逻辑运算符。每个维恩图中的圆圈（集合）代表 x 和 y。1\. y & !x 是 y 但不包含 x；x & y 是
    x 和 y 的交集；x & !y 是 x 但不包含 y；x 是 x 的全部，不包含 y；xor(x, y) 是除了 x 和 y 的交集外的所有内容；y 是
    y 的全部，不包含 x；而 x | y 是所有内容。](assets/rds2_1201.png)'
- en: Figure 12-1\. The complete set of Boolean operations. `x` is the left circle,
    `y` is the right circle, and the shaded region show which parts each operator
    selects.
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 完整的布尔运算集合。`x` 是左圆圈，`y` 是右圆圈，阴影区域显示了每个运算符选择的部分。
- en: As well as `&` and `|`, R also has `&&` and `||`. Don’t use them in dplyr functions!
    These are called *short-circuiting operators* and only ever return a single `TRUE`
    or `FALSE`. They’re important for programming, not data science.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `&` 和 `|` 外，R 还有 `&&` 和 `||`。不要在 dplyr 函数中使用它们！这些被称为 *短路操作符*，只会返回一个单一的 `TRUE`
    或 `FALSE`。它们对编程很重要，但不适合数据科学。
- en: Missing Values
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失值
- en: 'The rules for missing values in Boolean algebra are a little tricky to explain
    because they seem inconsistent at first glance:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数中缺失值的规则有点难以解释，因为乍看起来似乎不一致：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To understand what’s going on, think about `NA | TRUE`. A missing value in a
    logical vector means that the value could be either `TRUE` or `FALSE`. `TRUE |
    TRUE` and `FALSE | TRUE` are both `TRUE` because at least one of them is `TRUE`.
    So `NA | TRUE` must also be `TRUE` because `NA` can either be `TRUE` or `FALSE`.
    However, `NA | FALSE` is `NA` because we don’t know if `NA` is `TRUE` or `FALSE`.
    Similar reasoning applies with `NA & FALSE`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解发生了什么，请考虑 `NA | TRUE`。逻辑向量中的缺失值意味着该值可以是 `TRUE` 或 `FALSE`。`TRUE | TRUE` 和
    `FALSE | TRUE` 都是 `TRUE`，因为至少其中一个是 `TRUE`。因此 `NA | TRUE` 也必须是 `TRUE`，因为 `NA` 可以是
    `TRUE` 或 `FALSE`。然而，`NA | FALSE` 是 `NA`，因为我们不知道 `NA` 是 `TRUE` 还是 `FALSE`。类似的推理也适用于
    `NA & FALSE`。
- en: Order of Operations
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作顺序
- en: 'Note that the order of operations doesn’t work like English. Take the following
    code that finds all flights that departed in November or December:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意操作顺序与英语不同。考虑以下代码，找到所有在十一月或十二月出发的航班：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You might be tempted to write it like you’d say in English: “Find all flights
    that departed in November or December”:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会倾向于像用英语说的那样写：“找到所有在十一月或十二月出发的航班”：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code doesn’t error, but it also doesn’t seem to have worked. What’s going
    on? Here, R first evaluates `month == 11` creating a logical vector, which we
    call `nov`. It computes `nov | 12`. When you use a number with a logical operator,
    it converts everything apart from 0 to `TRUE`, so this is equivalent to `nov |
    TRUE`, which will always be `TRUE`, so every row will be selected:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有错误，但似乎也没有起作用。出了什么问题？在这里，R 首先评估 `month == 11` 创建一个逻辑向量，我们称之为 `nov`。它计算
    `nov | 12`。当你在逻辑运算符中使用一个数字时，除了 0 外的所有内容都会转换为 `TRUE`，因此这相当于 `nov | TRUE`，这将始终为
    `TRUE`，因此每一行都将被选中：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '%in%'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '%in%'
- en: An easy way to avoid the problem of getting your `==`s and `|`s in the right
    order is to use `%in%`. `x %in% y` returns a logical vector the same length as
    `x` that is `TRUE` whenever a value in `x` is anywhere in `y`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在正确顺序中使用 `==` 和 `|` 的简单方法是使用 `%in%`。`x %in% y` 返回与 `x` 相同长度的逻辑向量，只要 `x` 中的值在
    `y` 中的任何位置，就为 `TRUE`。
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So to find all flights in November and December, we could write:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以要找到所有在十一月和十二月出发的航班，我们可以写成：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `%in%` obeys different rules for `NA` to `==`, as `NA %in% NA` is
    `TRUE`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `%in%` 在处理 `NA` 时与 `==` 有不同的规则，因为 `NA %in% NA` 结果为 `TRUE`。
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This can make for a useful shortcut:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为一个有用的快捷方式：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Exercises
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Find all flights where `arr_delay` is missing but `dep_delay` is not. Find all
    flights where neither `arr_time` nor `sched_arr_time` is missing, but `arr_delay`
    is.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找所有 `arr_delay` 缺失但 `dep_delay` 不缺失的航班。查找所有 `arr_time` 和 `sched_arr_time` 都不缺失，但
    `arr_delay` 缺失的航班。
- en: How many flights have a missing `dep_time`? What other variables are missing
    in these rows? What might these rows represent?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少个航班的 `dep_time` 缺失？这些行中还有哪些变量缺失？这些行可能代表什么？
- en: Assuming that a missing `dep_time` implies that a flight is cancelled, look
    at the number of cancelled flights per day. Is there a pattern? Is there a connection
    between the proportion of canceled flights and the average delay of non-cancelled
    flights?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设缺失的 `dep_time` 表示航班取消，看一看每天取消的航班数。是否存在某种模式？取消航班的比例与非取消航班的平均延误之间是否有联系？
- en: Summaries
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The following sections describe some useful techniques for summarizing logical
    vectors. As well as functions that only work specifically with logical vectors,
    you can also use functions that work with numeric vectors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节描述了一些有用的逻辑向量摘要技术。除了专门用于逻辑向量的函数外，还可以使用适用于数值向量的函数。
- en: Logical Summaries
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑摘要
- en: 'There are two main logical summaries: [`any()`](https://rdrr.io/r/base/any.xhtml)
    and [`all()`](https://rdrr.io/r/base/all.xhtml). `any(x)` is the equivalent of
    `|`; it’ll return `TRUE` if there are any `TRUE`s in `x`. `all(x)` is equivalent
    of `&`; it’ll return `TRUE` only if all values of `x` are `TRUE`s. Like all summary
    functions, they’ll return `NA` if there are any missing values present, and as
    usual you can make the missing values go away with `na.rm = TRUE`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种逻辑摘要：[`any()`](https://rdrr.io/r/base/any.xhtml) 和 [`all()`](https://rdrr.io/r/base/all.xhtml)。`any(x)`
    相当于 `|`；如果 `x` 中有任何 `TRUE`，则返回 `TRUE`。`all(x)` 相当于 `&`；只有当 `x` 的所有值都是 `TRUE` 时才返回
    `TRUE`。与所有摘要函数一样，如果存在任何缺失值，它们会返回 `NA`，通常你可以通过 `na.rm = TRUE` 来处理缺失值。
- en: 'For example, we could use [`all()`](https://rdrr.io/r/base/all.xhtml) and [`any()`](https://rdrr.io/r/base/any.xhtml)
    to find out if every flight was delayed on departure by at most an hour or if
    any flights were delayed on arrival by five hours or more. And using [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)
    allows us to do that by day:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 [`all()`](https://rdrr.io/r/base/all.xhtml) 和 [`any()`](https://rdrr.io/r/base/any.xhtml)
    来查找是否每次航班的出发都延误不超过一小时，或者是否有航班的到达延误超过五小时。通过 [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)
    允许我们按天来做到这一点：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In most cases, however, [`any()`](https://rdrr.io/r/base/any.xhtml) and [`all()`](https://rdrr.io/r/base/all.xhtml)
    are a little too crude, and it would be nice to be able to get a little more detail
    about how many values are `TRUE` or `FALSE`. That leads us to the numeric summaries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，[`any()`](https://rdrr.io/r/base/any.xhtml) 和 [`all()`](https://rdrr.io/r/base/all.xhtml)
    太过粗糙，希望能够更详细地了解有多少值是 `TRUE` 或 `FALSE`。这引导我们进入了数值摘要的领域。
- en: Numeric Summaries of Logical Vectors
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑向量的数值摘要
- en: When you use a logical vector in a numeric context, `TRUE` becomes 1, and `FALSE`
    becomes 0\. This makes [`sum()`](https://rdrr.io/r/base/sum.xhtml) and [`mean()`](https://rdrr.io/r/base/mean.xhtml)
    useful with logical vectors because `sum(x)` gives the number of `TRUE`s and `mean(x)`
    gives the proportion of `TRUE`s (because [`mean()`](https://rdrr.io/r/base/mean.xhtml)
    is just [`sum()`](https://rdrr.io/r/base/sum.xhtml) divided by [`length()`](https://rdrr.io/r/base/length.xhtml)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在数值上下文中使用逻辑向量时，`TRUE` 变为 1，`FALSE` 变为 0。这使得 [`sum()`](https://rdrr.io/r/base/sum.xhtml)
    和 [`mean()`](https://rdrr.io/r/base/mean.xhtml) 在逻辑向量中非常有用，因为 `sum(x)` 给出了 `TRUE`
    的数量，`mean(x)` 给出了 `TRUE` 的比例（因为 [`mean()`](https://rdrr.io/r/base/mean.xhtml)
    只是 [`sum()`](https://rdrr.io/r/base/sum.xhtml) 除以 [`length()`](https://rdrr.io/r/base/length.xhtml)）。
- en: 'That, for example, allows us to see the proportion of flights that were delayed
    on departure by at most an hour and the number of flights that were delayed on
    arrival by five hours or more:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这使我们可以查看在出发延误不超过一小时的航班中延误比例以及到达延误超过五小时的航班数量：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Logical Subsetting
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑子集
- en: 'There’s one final use for logical vectors in summaries: you can use a logical
    vector to filter a single variable to a subset of interest. This makes use of
    the base `[` (pronounced subset) operator, which you’ll learn more about in [“Selecting
    Multiple Elements with [”](ch27.xhtml#sec-subset-many).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑向量在摘要中还有一种最终用途：你可以使用逻辑向量来过滤感兴趣的子集中的单个变量。这利用了基本的 `[`（子集）运算符，你可以在 [“使用 `[` 选择多个元素”](ch27.xhtml#sec-subset-many)
    中了解更多相关内容。
- en: 'Imagine we wanted to look at the average delay just for flights that were actually
    delayed. One way to do so would be to first filter the flights and then calculate
    the average delay:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要查看实际延误的航班的平均延误时间。一种方法是首先筛选航班，然后计算平均延误：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This works, but what if we wanted to also compute the average delay for flights
    that arrived early? We’d need to perform a separate filter step and then figure
    out how to combine the two data frames together.^([3](ch12.xhtml#idm44771300937360))
    Instead, you could use `[` to perform an inline filtering: `arr_delay[arr_delay
    > 0]` will yield only the positive arrival delays.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，但如果我们想要计算提前到达的航班的平均延误呢？我们需要执行一个单独的过滤步骤，然后找出如何将两个数据框合并在一起。^([3](ch12.xhtml#idm44771300937360))
    相反，您可以使用`[`来执行内联过滤：`arr_delay[arr_delay > 0]`将仅产生正到达延误。
- en: 'This leads to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also note the difference in the group size: in the first chunk, [`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)
    gives the number of delayed flights per day; in the second, [`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)
    gives the total number of flights.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意群组大小的差异：在第一个块中，[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)给出每天延误航班的数量；在第二个块中，[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)给出总航班数。
- en: Exercises
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: What will `sum(is.na(x))` tell you? How about `mean(is.na(x))`?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sum(is.na(x))`告诉你什么？`mean(is.na(x))`又会告诉你什么？'
- en: What does [`prod()`](https://rdrr.io/r/base/prod.xhtml) return when applied
    to a logical vector? What logical summary function is it equivalent to? What does
    [`min()`](https://rdrr.io/r/base/Extremes.xhtml) return when applied to a logical
    vector? What logical summary function is it equivalent to? Read the documentation
    and perform a few experiments.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用于逻辑向量时，[`prod()`](https://rdrr.io/r/base/prod.xhtml)返回什么？它等同于哪个逻辑汇总函数？当应用于逻辑向量时，[`min()`](https://rdrr.io/r/base/Extremes.xhtml)返回什么？它等同于哪个逻辑汇总函数？阅读文档并进行一些实验。
- en: Conditional Transformations
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件转换
- en: 'One of the most powerful features of logical vectors are their use for conditional
    transformations, i.e., doing one thing for condition x and doing something different
    for condition y. There are two important tools for this: [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    and [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑向量最强大的特性之一是它们在条件变换中的使用，即针对条件 x 执行一件事，针对条件 y 执行另一件事。有两个重要的工具可以做到这一点：[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    和 [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)。
- en: if_else()
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if_else()
- en: If you want to use one value when a condition is `TRUE` and another value when
    it’s `FALSE`, you can use [`dplyr::if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml).^([4](ch12.xhtml#idm44771300775168))
    You’ll always use the first three argument of [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml).
    The first argument, `condition`, is a logical vector; the second, `true`, gives
    the output when the condition is true; and the third, `false`, gives the output
    if the condition is false.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在条件为`TRUE`时使用一个值，在条件为`FALSE`时使用另一个值，你可以使用[`dplyr::if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)。^([4](ch12.xhtml#idm44771300775168))
    你总是会使用[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)的前三个参数。第一个参数`condition`是一个逻辑向量；第二个参数`true`在条件为真时输出；第三个参数`false`在条件为假时输出。
- en: 'Let’s begin with a simple example of labeling a numeric vector as either “+ve”
    (positive) or “-ve” (negative):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，将数值向量标记为“+ve”（正数）或“-ve”（负数）：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There’s an optional fourth argument, `missing`, which will be used if the input
    is `NA`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可选的第四个参数，`missing`，如果输入为`NA`，将会使用它：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also use vectors for the `true` and `false` arguments. For example,
    this allows us to create a minimal implementation of [`abs()`](https://rdrr.io/r/base/MathFun.xhtml):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用向量作为`true`和`false`参数。例如，这使我们能够创建[`abs()`](https://rdrr.io/r/base/MathFun.xhtml)的最小实现：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So far all the arguments have used the same vectors, but you can of course
    mix and match. For example, you could implement a simple version of [`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有参数都使用了相同的向量，但你当然可以混合和匹配。例如，您可以像这样实现[`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)的简单版本：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You might have noticed a small infelicity in our previous labeling example:
    zero is neither positive nor negative. We could resolve this by adding an additional
    [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们先前标记示例中的一个小错误：零既不是正数也不是负数。我们可以通过添加额外的[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)来解决这个问题：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is already a little hard to read, and you can imagine it would only get
    harder if you have more conditions. Instead, you can switch to [`dplyr::case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经有点难以阅读了，你可以想象如果有更多条件，阅读起来将变得更加困难。相反，你可以切换到[`dplyr::case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)。
- en: case_when()
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: case_when()
- en: dplyr’s [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)
    is inspired by SQL’s `CASE` statement and provides a flexible way of performing
    different computations for different conditions. It has a special syntax that
    unfortunately looks like nothing else you’ll use in the tidyverse. It takes pairs
    that look like `condition ~ output`. `condition` must be a logical vector; when
    it’s `TRUE`, `output` will be used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr的[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)受SQL的`CASE`语句启发，并提供了一种灵活的方式根据不同条件执行不同的计算。它有一个特殊的语法，不幸的是看起来与tidyverse中的其他内容完全不同。它接受看起来像`condition
    ~ output`的成对输入。`condition`必须是一个逻辑向量；当它为`TRUE`时，将使用`output`。
- en: 'This means we could re-create our previous nested [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将之前嵌套的[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)重新创建如下：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is more code, but it’s also more explicit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更多的代码，但也更加明确。
- en: 'To explain how [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)
    works, let’s explore some simpler cases. If none of the cases matches, the output
    gets an `NA`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)的工作原理，让我们探索一些更简单的情况。如果没有一种情况匹配，输出将会是`NA`：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to create a “default”/catchall value, use `TRUE` on the left side:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个“默认”/捕获所有值，可以在左侧使用`TRUE`：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that if multiple conditions match, only the first will be used:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果多个条件匹配，只会使用第一个：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Just like with [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    you can use variables on both sides of the `~`, and you can mix and match variables
    as needed for your problem. For example, we could use [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)
    to provide some human-readable labels for the arrival delay:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)一样，你可以在`~`的两侧使用变量，并且可以根据问题需要混合和匹配变量。例如，我们可以使用[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)为到达延迟提供一些可读的标签：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Be wary when writing this sort of complex [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)
    statement; my first two attempts used a mix of `<` and `>`, and I kept accidentally
    creating overlapping conditions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写这种复杂的[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)语句时要小心；我的前两次尝试使用了`<`和`>`的混合，并且我不断地创建重叠的条件。
- en: Compatible Types
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容的类型
- en: 'Note that both [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    and [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml) require
    *compatible* types in the output. If they’re not compatible, you’ll see errors
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)和[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)在输出中需要*兼容的*类型。如果它们不兼容，你会看到类似这样的错误：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Overall, relatively few types are compatible, because automatically converting
    one type of vector to another is a common source of errors. Here are the most
    important cases that are compatible:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总体上，兼容的类型相对较少，因为自动将一个类型的向量转换为另一种类型是常见的错误来源。以下是一些最重要的兼容情况：
- en: Numeric and logical vectors are compatible, as we discussed in [“Numeric Summaries
    of Logical Vectors”](#sec-numeric-summaries-of-logicals).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字和逻辑向量是兼容的，正如我们在[“逻辑向量的数值摘要”](#sec-numeric-summaries-of-logicals)中讨论的那样。
- en: Strings and factors ([Chapter 16](ch16.xhtml#chp-factors)) are compatible, because
    you can think of a factor as a string with a restricted set of values.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和因子（[第16章](ch16.xhtml#chp-factors)）是兼容的，因为你可以将因子视为具有受限值集的字符串。
- en: Dates and date-times, which we’ll discuss in [Chapter 17](ch17.xhtml#chp-datetimes),
    are compatible because you can think of a date as a special case of date-time.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和日期时间，我们将在[第17章](ch17.xhtml#chp-datetimes)中讨论，因为你可以将日期视为日期时间的特殊情况，所以它们是兼容的。
- en: '`NA`, which is technically a logical vector, is compatible with everything
    because every vector has some way of representing a missing value.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NA`，技术上是一个逻辑向量，因为每个向量都有表示缺失值的方式，所以它与所有其他类型兼容。'
- en: We don’t expect you to memorize these rules, but they should become second nature
    over time because they are applied consistently throughout the tidyverse.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望你记住这些规则，但随着时间的推移，它们应该会变得自然而然，因为它们在整个tidyverse中应用得很一致。
- en: Exercises
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: A number is even if it’s divisible by two, which in R you can find out with
    `x %% 2 == 0`. Use this fact and [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    to determine whether each number between 0 and 20 is even or odd.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个数能被两整除，那么它是偶数，在R中你可以用`x %% 2 == 0`来判断。利用这个事实和[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)来确定0到20之间每个数是偶数还是奇数。
- en: Given a vector of days like `x <- c("Monday", "Saturday", "Wednesday")`, use
    an [`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml) statement to label them as
    weekends or weekdays.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个类似`x <- c("Monday", "Saturday", "Wednesday")`的天数向量，使用[`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml)语句将它们标记为周末或工作日。
- en: Use [`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml) to compute the absolute
    value of a numeric vector called `x`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml)计算数值向量`x`的绝对值。
- en: Write a [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)
    statement that uses the `month` and `day` columns from `flights` to label a selection
    of important US holidays (e.g., New Years Day, Fourth of July, Thanksgiving, and
    Christmas). First create a logical column that is either `TRUE` or `FALSE`, and
    then create a character column that either gives the name of the holiday or is
    `NA`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)语句，使用`flights`中的`month`和`day`列来标记一些重要的美国节日（例如，新年、独立日、感恩节和圣诞节）。首先创建一个逻辑列，该列为`TRUE`或`FALSE`，然后创建一个字符列，该列要么给出假期的名称，要么是`NA`。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: The definition of a logical vector is simple because each value must be either
    `TRUE`, `FALSE`, or `NA`. But logical vectors provide a huge amount of power.
    In this chapter, you learned how to create logical vectors with `>`, `<`, `<=`,
    `=>`, `==`, `!=`, and [`is.na()`](https://rdrr.io/r/base/NA.xhtml); how to combine
    them with `!`, `&`, and `|`; and how to summarize them with [`any()`](https://rdrr.io/r/base/any.xhtml),
    [`all()`](https://rdrr.io/r/base/all.xhtml), [`sum()`](https://rdrr.io/r/base/sum.xhtml),
    and [`mean()`](https://rdrr.io/r/base/mean.xhtml). You also learned the powerful
    [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml) and [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)
    functions that allow you to return values depending on the value of a logical
    vector.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑向量的定义很简单，因为每个值必须是`TRUE`、`FALSE`或`NA`。但是逻辑向量提供了很大的功能。在这一章中，你学会了如何用`>`, `<`,
    `<=`, `=>`, `==`, `!=`和[`is.na()`](https://rdrr.io/r/base/NA.xhtml)创建逻辑向量；如何用`!`,
    `&`和`|`组合它们；以及如何用[`any()`](https://rdrr.io/r/base/any.xhtml)、[`all()`](https://rdrr.io/r/base/all.xhtml)、[`sum()`](https://rdrr.io/r/base/sum.xhtml)和[`mean()`](https://rdrr.io/r/base/mean.xhtml)对它们进行总结。你还学习了强大的[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)和[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.xhtml)函数，它们允许你根据逻辑向量的值返回不同的值。
- en: 'We’ll see logical vectors again and again in the following chapters. For example,
    in [Chapter 14](ch14.xhtml#chp-strings), you’ll learn about `str_detect(x, pattern)`,
    which returns a logical vector that’s `TRUE` for the elements of `x` that match
    the `pattern`, and in [Chapter 17](ch17.xhtml#chp-datetimes), you’ll create logical
    vectors from the comparison of dates and times. But for now, we’re going to move
    onto the next most important type of vector: numeric vectors.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中我们会反复看到逻辑向量。例如，在[第14章](ch14.xhtml#chp-strings)中，你将学习`str_detect(x, pattern)`，它返回一个逻辑向量，对于与`pattern`匹配的`x`元素为`TRUE`；在[第17章](ch17.xhtml#chp-datetimes)中，你将通过比较日期和时间创建逻辑向量。但现在，我们将继续讨论下一个最重要的向量类型：数值向量。
- en: ^([1](ch12.xhtml#idm44771302207136-marker)) R normally calls print for you (i.e.,
    `x` is a shortcut for `print(x)`), but calling it explicitly is useful if you
    want to provide other arguments.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.xhtml#idm44771302207136-marker)) 在R中，通常`print`函数会为你调用（即，`x`是`print(x)`的一种简写），但显式调用它在你想要提供其他参数时很有用。
- en: ^([2](ch12.xhtml#idm44771301699872-marker)) That is, `xor(x, y)` is true if
    `x` is true or `y` is true, but not both. This is how we usually use “or” in English.
    “Both” is not usually an acceptable answer to the question “Would you like ice
    cream or cake?”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.xhtml#idm44771301699872-marker)) 也就是说，`xor(x, y)`在`x`为真或`y`为真时为真，但不是同时为真。这通常是我们在英语中使用“或”的方式。“两者都是”通常不是对于问题“你想要冰淇淋还是蛋糕？”的可接受回答。
- en: ^([3](ch12.xhtml#idm44771300937360-marker)) We’ll cover this in [Chapter 19](ch19.xhtml#chp-joins).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.xhtml#idm44771300937360-marker)) 我们将在[第19章](ch19.xhtml#chp-joins)中讨论这个。
- en: '^([4](ch12.xhtml#idm44771300775168-marker)) dplyr’s [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    is similar to base R’s [`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml). There
    are two main advantages of [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    over [`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml): you can choose what should
    happen to missing values, and [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    is much more likely to give you a meaningful error if your variables have incompatible
    types.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch12.xhtml#idm44771300775168-marker)) dplyr 的 [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    类似于基础 R 的 [`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml)。[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    相较于 [`ifelse()`](https://rdrr.io/r/base/ifelse.xhtml) 有两个主要优势：你可以选择如何处理缺失值，并且如果变量类型不兼容，[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    更有可能给出有意义的错误提示。
