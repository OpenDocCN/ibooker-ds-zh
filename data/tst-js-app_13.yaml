- en: 11 Writing UI-based end-to-end tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 编写基于UI的端到端测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Writing end-to-end UI tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写端到端UI测试
- en: Eliminating flakiness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除不稳定性
- en: Best practices for end-to-end UI tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端UI测试的最佳实践
- en: Running tests on multiple browsers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个浏览器上运行测试
- en: Performing visual regression testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行视觉回归测试
- en: It doesn’t matter how many business books you read or how many successful pastry
    chefs you talk to—to open your own business, you have to roll up your sleeves
    and put in the work. Learning about the “good principles” is useful, but without
    baking and talking to customers yourself, you can’t succeed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你读过多少商业书籍，还是与多少成功的糕点师交谈，要开设自己的业务，你必须卷起袖子付出努力。了解“良好原则”是有用的，但如果没有自己烘焙并与客户交谈，你就无法成功。
- en: Also in testing, learning about the different tools you can use and understanding
    their trade-offs is helpful, but, without writing tests yourself, you won’t know
    how to build reliable software in less time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方面，了解你可以使用的不同工具以及理解它们的权衡是有帮助的，但如果没有自己编写测试，你就不会知道如何在更短的时间内构建可靠的软件。
- en: In this chapter, you’ll learn how to write UI-based end-to-end tests by testing
    the application you built in chapter 6\. Throughout this chapter, I’ll use Cypress
    to demonstrate how you can test that application and which advanced techniques
    you can use to improve your tests’ efficacy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你们将学习如何通过测试第6章中构建的应用程序来编写基于UI的端到端测试。在整个章节中，我将使用Cypress来演示如何测试该应用程序以及你可以使用哪些高级技术来提高测试的有效性。
- en: NOTE Even though I’ve used Cypress in this chapter’s code samples, I’ll teach
    you the principles necessary to be able to adapt and apply these the patterns
    and best practices, regardless of the tools you choose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管我在本章的代码示例中使用了Cypress，但我会教给你们必要的原则，以便能够适应和应用这些模式和最佳实践，无论你选择什么工具。
- en: You can find the code for these tests as well as the code for the server *and*
    client under test in this book’s GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到这些测试的代码以及受测试的服务器和客户端的代码：[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: This chapter’s first section demonstrates how to write actual UI-based end-to-end
    tests using Cypress. In this section, I will guide you through writing tests for
    the application you built in chapter 6\. You will learn how to test features by
    interacting directly with your UI and how to check these interaction’s effects
    both on your client and server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分演示了如何使用Cypress编写实际的基于UI的端到端测试。在本节中，我将指导你们编写第6章中构建的应用程序的测试。你们将学习如何通过直接与UI交互来测试功能，以及如何检查这些交互对客户端和服务器的影响。
- en: In the second section, I’ll cover best practices to make the tests you’ve written
    more robust and, therefore, less costly, while preserving their rigorousness.
    To teach you that, I will show scenarios in which specific tests would break and
    how to refactor these tests to make them more robust.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我将介绍最佳实践，使你编写的测试更加健壮，因此成本更低，同时保持其严谨性。为了教你们这一点，我将展示特定测试可能会失败的场景以及如何重构这些测试以使其更加健壮。
- en: After you’ve understood how to write effective Cypress tests in a maintainable
    way, you’ll learn how to eliminate *flaky tests*, which are tests that, given
    the same code, may fail sometimes and succeed in others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你理解了如何以可维护的方式编写有效的Cypress测试之后，你将学习如何消除不稳定的测试，这些测试在相同的代码下有时会失败，有时会成功。
- en: You will understand why it’s crucial to avoid tests that fall into the “flaky”
    category and why flakiness is one of the most common problems when dealing with
    end-to-end tests, especially when these tests involve interactions with a graphical
    user interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你们将理解为什么避免落入“不稳定”类别的测试至关重要，以及为什么不稳定是处理端到端测试时最常见的问题之一，尤其是在这些测试涉及与图形用户界面的交互时。
- en: To teach you how to avoid flaky tests, I will implement tests that are prone
    to flakiness, give you multiple alternatives to make these tests deterministic,
    and explain the pros and cons of each strategy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了教你们如何避免不稳定的测试，我将实现一些容易出错的测试，提供多种替代方案来使这些测试变得确定，并解释每种策略的优缺点。
- en: The penultimate section of this chapter is about running tests in multiple browsers.
    In this section, I will explain which strategies you can adopt to run tests in
    various browsers and the tools you’ll need for that. Furthermore, you’ll learn
    why it’s important to do so and which strategy to pick, depending on what you’re
    building and how you’re building it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的倒数第二部分是关于在多个浏览器中运行测试。在本节中，我将解释你可以采用哪些策略在各个浏览器中运行测试，以及你需要哪些工具。此外，你将了解为什么这样做很重要，以及根据你构建的内容和方式选择哪种策略。
- en: At last, I will talk about visual regression testing. By creating visual regression
    tests for the application you built in chapter 6, I will teach you how to guarantee
    that your product will look as it should in every release.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将讨论视觉回归测试。通过为第 6 章中构建的应用程序创建视觉回归测试，我将教你如何确保你的产品在每次发布时都应看起来如何。
- en: In this final section, I’ll demonstrate how to write visual regression tests
    using Percy and explain the advantages of having this kind of test. Besides teaching
    how to integrate these tests into your workflow, I’ll explain how they can make
    your release process safer and facilitate collaboration among different stakeholders.
    In this section, you will understand how to integrate these tools into your workflow
    so that the process of releasing changes into production happens safely and quickly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一部分，我将演示如何使用 Percy 编写视觉回归测试，并解释这种测试的优势。除了教授如何将这些测试集成到你的工作流程中，我还会解释它们如何使你的发布过程更安全，并促进不同利益相关者之间的协作。在本节中，你将了解如何将这些工具集成到你的工作流程中，以便将更改安全快速地发布到生产环境中。
- en: 11.1 Your first UI-based end-to-end tests
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 你的第一个基于 UI 的端到端测试
- en: Pastry chefs are defined by their ability to bake sublime desserts, not by their
    fancy oven, premium cookware, or a thousand different pastry bag nozzles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 面点师以其制作精美甜点的能力而闻名，而不是他们的豪华烤箱、高端厨具或一千种不同的裱花袋喷嘴。
- en: In this section, you’ll write your first fully integrated end-to-end tests.
    You’ll learn how to write these tests by using Cypress to test the server and
    client you used in chapter 6.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将编写你的第一个完全集成的端到端测试。你将通过使用 Cypress 测试第 6 章中使用的服务器和客户端来学习如何编写这些测试。
- en: Throughout this process, I’ll demonstrate how to test features and clarify the
    differences and similarities between fully integrated UI tests and the tests you’ve
    previously written.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我将演示如何测试功能，并阐明完全集成的 UI 测试与之前编写的测试之间的差异和相似之处。
- en: NOTE Despite this book’s examples using Cypress, the end-to-end testing principles
    about which I’ll teach you will be valid regardless of the tool you choose.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管本书的示例使用了 Cypress，但我将要教你的端到端测试原则，无论你选择什么工具都是有效的。
- en: 11.1.1 Setting up a test environment
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 设置测试环境
- en: In this section’s first part, you’ll learn how to use Cypress to test the application
    you built in chapter 6\. I’ll explain how to install and configure Cypress and
    how to interact with your application and perform assertions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，你将学习如何使用 Cypress 测试你在第 6 章中构建的应用程序。我将解释如何安装和配置 Cypress，以及如何与你的应用程序交互并执行断言。
- en: NOTE You can find the code for these tests as well as the code for the server
    *and* client under test in this book’s GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书的 GitHub 仓库中找到这些测试的代码，以及要测试的服务器 *和* 客户端代码，网址为 [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Before installing Cypress, create a new folder into which you will put your
    tests. In this folder, you’ll execute the `npm init` command to generate a `package.json`
    file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Cypress 之前，创建一个新文件夹，你将把你的测试放在这个文件夹中。在这个文件夹中，你将执行 `npm init` 命令来生成一个 `package.json`
    文件。
- en: TIP I like to have a separate project for my tests because they usually cover
    multiple pieces of software.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我喜欢为我的测试创建一个单独的项目，因为它们通常涵盖多个软件组件。
- en: Alternatively, if your product’s applications live in the same folder, or if
    you prefer to manage tests alongside a particular project’s files, you can install
    Cypress as a dev dependency of that project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你的产品应用程序位于同一个文件夹中，或者你更喜欢将测试与特定项目的文件一起管理，你可以将 Cypress 安装为该项目的开发依赖项。
- en: If you work in a monorepo, I’d recommend you to install Cypress within that
    repository so that you can centralize your tests in the same way you centralize
    your code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个 monorepo 中工作，我建议你在那个仓库中安装 Cypress，这样你就可以像集中代码一样集中测试。
- en: Once you have created this folder and added a `package.json` file to it, install
    Cypress as a dev dependency by running `npm install --save-dev cypress`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此文件夹并向其中添加 `package.json` 文件后，通过运行 `npm install --save-dev cypress` 来将 Cypress
    作为开发依赖项安装。
- en: To have Cypress perform the scaffolding for your end-to-end tests, you must
    use its binaries’ `open` command by executing `./node_modules/.bin/cypress open`.
    Besides creating the files necessary for you to start writing tests, this command
    will create a folder with examples of tests and open the Cypress UI.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Cypress 为您的端到端测试执行脚手架，您必须通过执行 `./node_modules/.bin/cypress open` 来使用其二进制
    `open` 命令。除了创建您开始编写测试所需的必要文件外，此命令还将创建一个包含测试示例的文件夹，并打开 Cypress UI。
- en: Within the Cypress UI (figure 11.1), you can access previous tests’ recordings,
    check configuration options, and choose which tests to execute and in which browser
    they’ll run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cypress UI（图 11.1）中，您可以访问之前测试的录制，检查配置选项，并选择要执行的测试以及它们将在哪个浏览器中运行。
- en: '![](../Images/CH11_F01_DaCosta.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F01_DaCosta.png)'
- en: Figure 11.1 Cypress’s graphical user interface showing its sample tests
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 显示 Cypress 示例测试的图形用户界面
- en: TIP To make this command easier to remember and quicker to access, create an
    NPM script to execute it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了使此命令更容易记忆和快速访问，创建一个 NPM 脚本来执行它。
- en: You can, for example, create a `cypress:open` command that invokes `cypress
    open`, similar to what you’ve done for running Jest’s tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以创建一个 `cypress:open` 命令来调用 `cypress open`，类似于您为运行 Jest 的测试所做的那样。
- en: Listing 11.1 package.json
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 package.json
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Invokes Cypress binary’s open command
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 Cypress 的二进制打开命令
- en: After creating this script, you can open the Cypress UI by running `npm run
    cypress:open` instead of typing the full path to the project’s binaries.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此脚本后，您可以通过运行 `npm run cypress:open` 来打开 Cypress UI，而不是输入项目的完整路径。
- en: For now, just try executing an example by clicking on one of them. Running these
    example tests will give you an idea of how your tests will run once you have created
    them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需通过点击其中一个来尝试执行一个示例。运行这些示例测试将让您了解一旦创建测试后，您的测试将如何运行。
- en: As these examples run, on the left, you will see an action log that you can
    use to inspect the different states your application went through as the test’s
    actions happened.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些示例运行时，在左侧，您将看到一个操作日志，您可以使用它来检查您的应用程序在测试操作发生过程中经历的不同状态。
- en: After playing around with Cypress’s samples, feel free to delete the `examples`
    folder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了 Cypress 的示例之后，您可以自由地删除 `examples` 文件夹。
- en: TIP To run all of your Cypress tests, you can use the `cypress run` command
    instead of `cypress open`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要运行所有 Cypress 测试，您可以使用 `cypress run` 命令而不是 `cypress open`。
- en: As you’ve done with the `open` command, you can add a new NPM script for `run`
    to make it easier to remember and execute.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您使用 `open` 命令所做的那样，您可以为 `run` 添加一个新的 NPM 脚本，使其更容易记忆和执行。
- en: Listing 11.2 package.json
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 package.json
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Invokes Cypress’s binary’s open command
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 Cypress 的二进制打开命令
- en: ❷ Invokes Cypress’s binary’s run command
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 Cypress 的二进制运行命令
- en: 11.1.2 Writing your first tests
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 编写您的第一个测试
- en: Now that you know how to execute tests and that Cypress has created an initial
    file structure for you, you will write your first tests for the application you
    built in chapter 6.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何执行测试，并且 Cypress 已经为您创建了一个初始文件结构，您将为您在第 6 章中构建的应用程序编写第一个测试。
- en: NOTE Both the `client` and `server` applications under test are available in
    the `chapter11` folder in this book’s GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
    Within that folder, you will also find all the tests written in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书 GitHub 仓库 [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)
    中的 `chapter11` 文件夹下提供了测试中的 `client` 和 `server` 应用程序。在该文件夹中，您还将找到本章编写的所有测试。
- en: To run each of those applications, you must install their dependencies with
    `npm` `install`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些应用程序中的每一个，您必须使用 `npm install` 安装它们的依赖项。
- en: Once you have installed each project’s dependencies, you will need to ensure
    that your database schema is up-to-date by running `npm` `run` `migrate:dev`.
    Only then you will be able to run the server, which will be bound to port `3000`
    by default. Before running the client, you must build its bundle with `npm` `run`
    `build`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装每个项目的依赖项后，您需要通过运行 `npm run migrate:dev` 来确保您的数据库模式是最新的。只有在这种情况下，您才能运行服务器，默认情况下它将绑定到端口
    `3000`。在运行客户端之前，您必须使用 `npm run build` 来构建其包。
- en: To start each application, run `npm start` in their respective folders.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动每个应用程序，请在各自的文件夹中运行 `npm start`。
- en: Before writing your first test, start your client and server, and play around
    with your application at `http:/./localhost:8080`. This step is essential because
    for Cypress to interact with your application, you must guarantee it’s accessible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写第一个测试之前，启动您的客户端和服务器，并在 `http:/./localhost:8080` 上与您的应用程序进行交互。这一步是必不可少的，因为为了
    Cypress 能够与您的应用程序交互，您必须确保它可访问。
- en: Finally, it’s time to write your first test. This test will access `http://localhost:8000`
    and check whether the form for submitting new items contains the correct fields
    and a submission button.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候编写您的第一个测试了。这个测试将访问 `http://localhost:8000` 并检查提交新物品的表单是否包含正确的字段和提交按钮。
- en: Start by creating a file named `itemSubmission.spec.js` inside the `integration`
    folder. This new file will contain the tests for the item submission form.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `integration` 文件夹内创建一个名为 `itemSubmission.spec.js` 的文件。这个新文件将包含物品提交表单的测试。
- en: Within the `itemSubmission.spec.js` file, write a test that checks whether the
    item submission form contains the expected elements. This test will use methods
    from the global `cy` instance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `itemSubmission.spec.js` 文件中，编写一个测试来检查物品提交表单是否包含预期的元素。这个测试将使用全局 `cy` 实例的方法。
- en: To cause Cypress to access `http:/./localhost:8080`, you will use the `cy.visit`
    method. To find each element on the page, you will use `cy.get`. Once you locate
    matching nodes using `get`, you can chain a call to `contains` to find the one
    that contains the desired text.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Cypress 访问 `http:/./localhost:8080`，您将使用 `cy.visit` 方法。要找到页面上的每个元素，您将使用 `cy.get`。一旦使用
    `get` 定位到匹配的节点，您就可以通过调用 `contains` 来找到包含所需文本的那个元素。
- en: TIP You can use the Cypress’ `baseUrl` configuration option, shown in the next
    listing, to avoid having to type your application’s address every time you call
    `visit`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可以使用 Cypress 的 `baseUrl` 配置选项，如下一列表中所示，以避免每次调用 `visit` 时都输入您应用程序的地址。
- en: By configuring a `baseUrl`, Cypress will use it as a prefix when you call `cy.visit`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置 `baseUrl`，Cypress 将在您调用 `cy.visit` 时使用它作为前缀。
- en: Listing 11.3 cypress.json
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 cypress.json
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Prefixes http:/`.`/localhost:8080 to the string passed to cy.visit
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 http:/`.`/localhost:8080 前缀添加到传递给 cy.visit 的字符串
- en: Alternatively, to find elements, you can directly invoke `contains` and pass
    a selector as its first argument and the inner text as the second, as shown next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了查找元素，您可以直接调用 `contains` 并将其选择器作为第一个参数传递，将内部文本作为第二个参数，如下所示。
- en: Listing 11.4 itemSubmission.spec.js
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 itemSubmission.spec.js
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Visits the application’s page
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找物品名称的输入框
- en: ❸ Finds the input for an item’s quantity
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找物品数量的输入框
- en: ❹ Finds the button which adds items to the inventory
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找添加物品到库存的按钮
- en: NOTE Even though Cypress’s test runner is Mocha, *not* Jest, the syntax used
    to organize tests is identical.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管 Cypress 的测试运行器是 Mocha，而不是 Jest，但组织测试所使用的语法是相同的。
- en: Once you’ve finished writing this test, start Cypress with your `npm run cypress:open`
    command, and click on `itemSubmission.spec.js`. Once you’ve run the test, Cypress
    will show you a screen similar to the one in figure 11.2.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成测试的编写，使用 `npm run cypress:open` 命令启动 Cypress，并点击 `itemSubmission.spec.js`。运行测试后，Cypress
    将显示一个类似于图 11.2 的屏幕。
- en: '![](../Images/CH11_F02_DaCosta.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F02_DaCosta.png)'
- en: Figure 11.2 Cypress executing the test that checks the inventory management
    application’s elements
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 Cypress 执行检查库存管理应用程序元素的测试
- en: TIP When searching for elements within Cypress tests, you should find them using
    characteristics that are integral to what the element is. In this case, I’ve decided
    to use each input’s placeholder, for example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在 Cypress 测试中搜索元素时，您应该使用与元素本身本质相关的特征来查找它们。在这种情况下，我决定使用每个输入的占位符，例如。
- en: If you use selectors that are too specific or too tightly coupled to page’s
    structure, your tests will frequently break and, therefore, will incur in extra
    maintenance cost.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过于具体或与页面结构紧密耦合的选择器，您的测试将经常中断，因此将产生额外的维护成本。
- en: 'When writing selectors, follow the same guidelines from chapters 4 and 5: **avoid
    brittle selectors**.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写选择器时，遵循第 4 章和第 5 章中的相同指南：**避免脆弱的选择器**。
- en: Your next task will be to render this test more elaborate by making it fill
    each input, submit the form, and check whether the item list contains the new
    item.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个任务将是使这个测试更加详细，通过填写每个输入框，提交表单，并检查项目列表是否包含新项目。
- en: To fill each input, you will use Cypress’s `type` method after finding each
    one of them. This method will type the string passed as the first argument into
    the element.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到每个输入后，你将使用 Cypress 的 `type` 方法来填写每个输入。此方法将第一个参数传递的字符串输入到元素中。
- en: After filling each input, you will call `click` on the submission button and
    `contains` to find a `li` whose contents match what you expect.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写每个输入后，你将调用提交按钮上的 `click` 和 `contains` 以找到内容与预期匹配的 `li`。
- en: Listing 11.5 itemSubmission.spec.js
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 itemSubmission.spec.js
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Visits the application’s page
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, and types “cheesecake” into it
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 找到物品名称的输入，并输入“cheesecake”
- en: ❸ Finds the input for an item’s quantity, and types “10” into it
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到物品数量的输入，并输入“10”
- en: ❹ Finds the button that adds items to the inventory, and clicks it
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 找到添加物品到库存的按钮，并点击它
- en: ❺ Finds the list item that indicates the quantity of cheesecakes in the inventory
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到表示库存中cheesecake数量的列表项
- en: TIP Because your test will fail if Cypress can’t find any of these elements,
    you don’t necessarily need to explicitly assert that each element exists. By default,
    the `get` and `contains` commands will assert that elements exist.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：因为如果你的测试无法找到这些元素，你的测试将失败，所以你不必明确断言每个元素都存在。默认情况下，`get` 和 `contains` 命令将断言元素存在。
- en: The problem with the test you’ve written is that it will pass only once. After
    running this test for the first time, your database will already contain cheesecakes,
    and, therefore, the number of cheesecakes will be greater than 10 in each subsequent
    run, causing the test to fail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你所编写的测试的问题在于它只会通过一次。在第一次运行此测试后，你的数据库中已经包含cheesecake，因此每次后续运行中cheesecake的数量都将超过10，导致测试失败。
- en: 'To make this test deterministic, you have a few options, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此测试具有确定性，你有几个选择，如下所示：
- en: Fake the server’s responses for fetching and adding items.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟服务器对获取和添加物品的响应。
- en: Calculate what should be the expected quantity of the item added according to
    what’s currently in the database.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据数据库中当前的内容计算应该添加的物品的预期数量。
- en: Empty the database before the test.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前清空数据库。
- en: Personally, the third approach is the one I’d recommend.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我认为第三种方法是我会推荐的方法。
- en: The problem with the first approach is that it doesn’t cover the server’s functionality.
    Because it mocks the server responses for fetching and adding items, it will cause
    the test to validate only the frontend functionality.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法的问题在于它没有涵盖服务器的功能。因为它模拟了获取和添加物品的服务器响应，这将导致测试只验证前端功能。
- en: For myself, I like my end-to-end tests to simulate a user’s actions as accurately
    as possible, which is why I use test doubles only in tests further down the testing
    pyramid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我自己来说，我喜欢我的端到端测试尽可能地模拟用户的操作，这就是为什么我只在测试金字塔更底部的测试中使用测试替身。
- en: Additionally, the first approach will couple the test to the specific route
    the application uses for fetching and adding items instead of focusing on what
    the user does and what the results of their actions should be.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第一种方法将测试耦合到应用程序用于获取和添加物品的特定路由，而不是关注用户做什么以及他们的操作结果应该是什么。
- en: The problem with the second approach is that it will have different semantics,
    depending on whether it’s the first time it is running. The *first* time the test
    runs, it will *add* a new row to the database and attach an item to the list.
    The *second* time it runs, the test will *update* a database row and the existing
    item list. These are, in essence, different test cases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法的问题在于它的语义将取决于它是否是第一次运行。第一次运行测试时，它将在数据库中添加一行新记录并将物品附加到列表中。第二次运行时，测试将更新数据库行和现有的物品列表。本质上，这些都是不同的测试用例。
- en: I consider the third approach to the better than the others because it guarantees
    that the application’s state will be the exact same every time the test runs.
    Additionally, it always tests the same functionality and is way simpler to implement
    and to debug.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为第三种方法比其他方法更好，因为它保证了每次测试运行时应用程序的状态将完全相同。此外，它总是测试相同的功能，并且实现和调试都更加简单。
- en: Important Like what you do when you write any other kinds of tests, **your end-to-end
    tests should be deterministic**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：就像你编写其他类型的测试一样，**你的端到端测试应该是确定的**。
- en: To make this test deterministic, let’s create a new function to empty the database’s
    inventory table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此测试具有确定性，让我们创建一个新的函数来清空数据库的库存表。
- en: Because this function includes arbitrary code to run within Node.js instead
    of the browser, it must be bound to a **task**. When you invoke the task to which
    the function is bound, the inventory table will be truncated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个函数包含在 Node.js 中运行的任意代码，而不是在浏览器中运行，所以它必须绑定到一个 **任务**。当你调用绑定到该函数的任务时，库存表将被截断。
- en: Before writing this function, you’ll need to install `knex` with `npm install
    --save-dev knex` to be able to connect to the database. Because `knex` needs the
    `sqlite3` package to connect to SQLite databases, you must also install it with
    `npm install --save-dev sqlite3`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此函数之前，你需要使用 `npm install --save-dev knex` 安装 `knex`，以便能够连接到数据库。因为 `knex`
    需要使用 `sqlite3` 包来连接到 SQLite 数据库，所以你也必须使用 `npm install --save-dev sqlite3` 来安装它。
- en: NOTE To avoid having to rebuild the `sqlite3` package to be compatible with
    the version of Electron used by Cypress, you must configure Cypress to use your
    system’s Node.js executable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 为了避免需要重新构建 `sqlite3` 包以与 Cypress 使用的 Electron 版本兼容，你必须配置 Cypress 使用你的系统
    Node.js 可执行文件。
- en: For that, you need to set `nodeVersion` to `system` in `cypress.json`, as shown
    next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要在 `cypress.json` 中将 `nodeVersion` 设置为 `system`，如下所示。
- en: Listing 11.6 cypress.json
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 cypress.json
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Configures Cypress to use the system’s Node.js executable
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Cypress 使用系统的 Node.js 可执行文件
- en: Once you’ve installed `knex`, you’ll configure it to connect to the application’s
    database as you’ve done when writing your backend application. First, in your
    test’s root folder, create a `knexfile` with the connection configurations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `knex` 后，你需要将其配置为连接到应用程序数据库，就像你编写后端应用程序时做的那样。首先，在你的测试根文件夹中，创建一个包含连接配置的 `knexfile`。
- en: Listing 11.7 knexfile.js
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 knexfile.js
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Uses sqlite3 as the database client
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 sqlite3 作为数据库客户端
- en: ❷ Specifies the database file in which the application will store its data
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定应用程序将存储其数据的数据库文件
- en: ❸ Use NULL instead of DEFAULT for undefined keys
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 NULL 而不是 DEFAULT 来处理未定义的键
- en: Then, within the same folder, create a file that is responsible for connecting
    to the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个文件夹内创建一个负责连接数据库的文件。
- en: Listing 11.8 dbConnection.js
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 dbConnection.js
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Obtains the value of the NODE_ENV environment variable
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取 NODE_ENV 环境变量的值
- en: ❷ Uses the value of NODE_ENV assigned to environmentName to determine which
    database configuration to pick
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用分配给 environmentName 的 NODE_ENV 值来确定选择哪个数据库配置
- en: ❸ A function that closes the connections to the database
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个关闭数据库连接的函数
- en: TIP When you install Cypress in the same folder as your other applications,
    you can directly require these kinds of files instead of rewriting them. Additionally,
    you also won’t need to reinstall dependencies that your application already uses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 当你在与你的其他应用程序相同的文件夹中安装 Cypress 时，你可以直接引入这类文件，而不是重新编写它们。此外，你也不需要重新安装应用程序已经使用的依赖项。
- en: Personally, I like to have a script to create within the `cypress` folder symbolic
    links to the repositories of the applications under tests. These links help me
    reuse other application’s code more easily, even when I keep my Cypress tests
    separate from other projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我喜欢在 `cypress` 文件夹内创建一个脚本来创建指向测试应用程序的代码库的符号链接。这些链接帮助我更容易地重用其他应用程序的代码，即使我保持我的
    Cypress 测试与其他项目分离。
- en: Finally, you’ll create a new file called `dbPlugin.js` in the `plugins` folder
    to bind to a task the function that truncates the inventory table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将在 `plugins` 文件夹中创建一个名为 `dbPlugin.js` 的新文件，以绑定截断库存表的函数到任务。
- en: Listing 11.9 dbPlugin.js
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 dbPlugin.js
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Defines a task to truncate the inventory table in the application’s database
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个任务，用于截断应用程序数据库中的库存表
- en: NOTE The `on` function and the `config` object are both passed by Cypress. The
    `on` function registers the tasks in the object passed as the second argument,
    and `config` contains Cypress’ configurations for you to read or update.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE `on` 函数和 `config` 对象都是由 Cypress 传递的。`on` 函数将任务注册在作为第二个参数传递的对象中，而 `config`
    包含 Cypress 的配置，供你读取或更新。
- en: To make this task available within your tests, you must attach it to Cypress
    in the `index.js` inside the `plugins` folder. Here, you will pass Cypress’s `on`
    function and its `config` object to `dbPlugin`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此任务在测试中可用，你必须将其附加到 `plugins` 文件夹内的 `index.js` 中的 Cypress。在这里，你将传递 Cypress
    的 `on` 函数及其 `config` 对象给 `dbPlugin`。
- en: Listing 11.10 index.js
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 index.js
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Registers the plugin that contains the task to truncate the inventory table
    in the application’s database
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注册包含截断应用程序数据库中库存表任务的插件
- en: You can now attach this task to a `beforeEach` hook in the `itemSubmission.spec.js`
    file to truncate the `inventory` table before each test.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将此任务附加到`itemSubmission.spec.js`文件中的`beforeEach`钩子，在每个测试之前截断`inventory`表。
- en: Listing 11.11 itemSubmission.spec.js
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 itemSubmission.spec.js
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Truncates the application’s inventory table before each test
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前截断应用程序的库存表
- en: After these changes, your test should *always* pass because the `inventory`
    table will be truncated before each test, as shown in the workflow illustrated
    in figure 11.3.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，你的测试应该*始终*通过，因为`inventory`表将在每个测试之前被截断，如图11.3所示的流程图所示。
- en: '![](../Images/CH11_F03_DaCosta.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F03_DaCosta.png)'
- en: Figure 11.3 Before each test, Cypress will use the system’s Node.js executable
    to connect to the database and truncate the table with inventory items.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 在每个测试之前，Cypress将使用系统的Node.js可执行文件连接到数据库并截断包含库存项目的表。
- en: To see this test pass, run Cypress and set the `NODE_ENV` environment variable
    to `development`. By using the `NODE_ENV=development npm run cypress:open` command
    to run Cypress, it will connect to the same database your application uses.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个测试通过，运行Cypress并将`NODE_ENV`环境变量设置为`development`。通过使用`NODE_ENV=development
    npm run cypress:open`命令来运行Cypress，它将连接到你的应用程序使用的相同数据库。
- en: NOTE The syntax for setting environment variables on Windows is different from
    the syntax used in this book. Therefore, if you’re using Windows, you will need
    to modify these commands slightly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Windows上设置环境变量的语法与本书中使用的语法不同。因此，如果你使用Windows，你需要稍微修改这些命令。
- en: On Windows, the open command, for example, should be `set` `NODE_ENV= development`
    `&` `cypress` `open`. The run command will be `set` `NODE_ENV= development` `&`
    `cypress` `run`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，例如，打开命令应该是`set NODE_ENV= development & cypress open`。运行命令将是`set NODE_ENV=
    development & cypress run`。
- en: Alternatively, if you want to run tests straightaway instead of opening the
    Cypress UI, you can use the Cypress `run` command I previously mentioned with
    `NODE_ENV= development` `npm` `run` `cypress:run`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想立即运行测试而不是打开Cypress UI，你可以使用我之前提到的带有`NODE_ENV= development`的Cypress `run`命令来运行测试。
- en: TIP When running Cypress tests, I’d recommend you use a separate database for
    end-to-end tests so that they won’t interfere in your local development environment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在运行Cypress测试时，我建议你为端到端测试使用一个单独的数据库，这样它们就不会干扰你的本地开发环境。
- en: To do that, you must add to your `knexfile.js` a configuration entry for a new
    `NODE_ENV` and use the new environment’s name as the `NODE_ENV` when creating
    and migrating databases, when starting your server, and when running tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你必须向你的`knexfile.js`添加一个新的`NODE_ENV`配置条目，并在创建和迁移数据库、启动服务器以及运行测试时使用新的环境名称作为`NODE_ENV`。
- en: The next test you’ll write will validate your application’s “undo” functionality.
    It will use the form to add a new item to the inventory, click the Undo button,
    and check whether the application updates the item list correctly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的下一个测试将验证你应用程序的“撤销”功能。它将使用表单添加一个新项目到库存中，点击撤销按钮，并检查应用程序是否正确更新了项目列表。
- en: To write this test, you will use the same methods you used for the previous
    one. You’ll use `visit` to access the application’s page; `get` and `contains`
    to find buttons, inputs, and list items; and `type` to enter information into
    each field.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写这个测试，你将使用与上一个测试相同的方法。你将使用`visit`来访问应用程序的页面；使用`get`和`contains`来查找按钮、输入和列表项；以及使用`type`来输入每个字段的信息。
- en: The only new method in this test is `clear`, which is responsible for clearing
    the `quantity` field before entering information into it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试中唯一的新方法是`clear`，它在输入信息之前负责清除`quantity`字段。
- en: Warning After this test’s act stage, you must be careful when finding the action
    log entries that indicate that the inventory has 10 cheesecakes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在这个测试的行为阶段之后，在查找指示库存中有10个芝士蛋糕的操作日志条目时必须小心。
- en: Because there will be two of those entries, you must use an assertion to ensure
    that both are present. Otherwise, if you use only `get` or `contains`, you will
    find the same element twice, and your test will pass, even if there’s only one
    action log entry for 10 cheesecakes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为会有两个这样的条目，你必须使用断言来确保它们都存在。否则，如果你只使用`get`或`contains`，你将找到相同的元素两次，你的测试将通过，即使只有一个10个芝士蛋糕的操作日志条目。
- en: Listing 11.12 itemSubmission.spec.js
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.12 itemSubmission.spec.js
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Visits the application’s page
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, and types “cheesecake” into it
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找项目名称的输入框，并将“cheesecake”输入其中
- en: ❸ Finds the input for an item’s quantity, and types “10” into it
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到项目数量的输入框，并输入“10”
- en: ❹ Finds the button that adds items to the inventory, and clicks it
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 找到添加项目到库存的按钮，并点击它
- en: ❺ Finds the input for an item’s quantity, clears it, and types “5” into it
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到项目数量的输入框，清除它，并输入“5”
- en: ❻ Finds the button that adds items to the inventory, and clicks it again
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 找到添加项目到库存的按钮，并再次点击它
- en: ❼ Finds the button that undoes actions, and clicks it
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 找到撤销操作的按钮，并点击它
- en: ❽ Ensures there are two action log entries that indicate that the inventory
    contains 10 cheesecakes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 确保有两个操作日志条目指示库存包含 10 个芝士蛋糕
- en: The third test you’ll write is one that validates the application’s action log.
    This test adds an item to the inventory, clicks the Undo button, and checks whether
    the action log contains the correct entries.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的第三个测试是验证应用程序的操作日志。这个测试向库存中添加一个项目，点击撤销按钮，并检查操作日志是否包含正确的条目。
- en: Listing 11.13 itemSubmission.spec.js
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 itemSubmission.spec.js
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Visits the application’s page
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, and types “cheesecake” into it
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 找到项目名称的输入框，并输入“cheesecake”
- en: ❸ Finds the input for an item’s quantity, and types “10” into it
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到项目数量的输入框，并输入“10”
- en: ❹ Finds the button that adds items to the inventory, and clicks it
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 找到添加项目到库存的按钮，并点击它
- en: ❺ Finds the input for an item’s quantity, clears it, and types “5” into it
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到项目数量的输入框，清除它，并输入“5”
- en: ❻ Finds the button that adds items to the inventory, and clicks it again
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 找到添加项目到库存的按钮，并再次点击它
- en: ❼ Finds the button that undoes actions, and clicks it
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 找到撤销操作的按钮，并点击它
- en: ❽ Finds the action log entry that indicates that the inventory has loaded
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 找到指示库存已加载的操作日志条目
- en: ❾ Ensures there are two action log entries that indicate that the inventory
    contains 10 cheesecakes
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 确保有两个操作日志条目指示库存包含 10 个芝士蛋糕
- en: ❿ Finds the action log entry that indicates that the inventory has 15 cheesecakes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 找到指示库存包含 15 个芝士蛋糕的操作日志条目
- en: Even though this test performs the same actions as the previous one, it’s good
    to keep your assertions separate so that you get granular feedback.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个测试执行了与上一个测试相同的操作，但保持你的断言分开是好的，这样你可以得到更细致的反馈。
- en: If you simply checked the action log within the previous test, it would take
    more time for you to understand whether the test failed because the application
    didn’t update the item list correctly or because the action log didn’t contain
    the expected entries. Additionally, if finding the submitted item in the item
    list fails, Cypress won’t execute the lines of code that check the action log.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是在上一个测试中检查操作日志，那么你需要更多的时间来理解测试失败是因为应用程序没有正确更新项目列表，还是因为操作日志没有包含预期的条目。此外，如果找到提交的项目在项目列表中失败，Cypress
    不会执行检查操作日志的代码行。
- en: When organizing Cypress tests and writing assertions, the same recommendations
    you’ve seen in chapter 2 still apply.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当组织 Cypress 测试和编写断言时，你仍然可以应用第 2 章中看到的相同建议。
- en: The last test you’ll write will validate whether the application disables the
    form’s submit button when users enter an invalid item name. This test should access
    the application, enter an invalid item name into the form’s first field and a
    valid quantity in the form’s second field, and assert that the submission button
    is disabled.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的最后一个测试将验证当用户输入无效的项目名称时，应用程序是否会禁用表单的提交按钮。这个测试应该访问应用程序，将无效的项目名称输入到表单的第一个字段，并将有效的数量输入到表单的第二个字段，并断言提交按钮已被禁用。
- en: Because Cypress doesn’t have a command with a built-in assertion to check whether
    a button is disabled, you’ll have to write an explicit assertion to validate that.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Cypress 没有内置断言命令来检查按钮是否被禁用，因此您必须编写一个显式的断言来验证这一点。
- en: To write assertions in Cypress, you’ll chain its `should` method on the element
    on which you want to assert and pass it the desired assertion as the first argument,
    as shown in the next piece of code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Cypress 中编写断言，你需要在你想断言的元素上链式调用其 `should` 方法，并将所需的断言作为第一个参数传递，如下一段代码所示。
- en: Listing 11.14 itemSubmission.spec.js
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 itemSubmission.spec.js
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Visits the application’s page
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, and types “boat” into it
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 找到项目名称的输入框，并输入“boat”
- en: ❸ Finds the input for an item’s quantity, and types “10” into it
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到项目数量的输入框，并输入“10”
- en: ❹ Finds the button that adds items to the inventory, and expects it to be disabled
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找添加到库存的按钮，并期望它被禁用
- en: Like what happens with commands, Cypress will retry assertions until they pass
    before proceeding to execute any subsequent commands.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像命令一样，Cypress会在执行任何后续命令之前重试断言，直到它们通过。
- en: As an exercise, try writing a test that validates whether your application can
    *update* the number of items in the inventory. To do that, first, create a task
    that can seed the database with a few cheesecakes. Then, in your test, execute
    that task before visiting `http:/./localhost:8080`, use the form to add more cheesecakes
    to the inventory, and check whether the application updates the item list correctly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试编写一个测试来验证你的应用是否可以*更新*库存中项目的数量。为此，首先创建一个可以给数据库种入几个芝士蛋糕的任务。然后，在你的测试中，在访问`http:/./localhost:8080`之前执行该任务，使用表单添加更多的芝士蛋糕到库存中，并检查应用是否正确更新了项目列表。
- en: NOTE You can find the solution for this exercise on this book’s GitHub repository
    at GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书的GitHub仓库中找到这个练习的解决方案，GitHub仓库地址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: 11.1.3 Sending HTTP requests
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 发送HTTP请求
- en: When testing your applications, you may want to test functionalities that depend
    on sending HTTP requests directly to your server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试你的应用时，你可能想要测试那些依赖于直接向你的服务器发送HTTP请求的功能。
- en: You may want to do this if, for example, you need to set up an initial state
    or check whether your application updates as users interact with the backend.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要设置初始状态或检查应用是否在用户与后端交互时更新，你可能想要这样做。
- en: In the case of the current application under test, for example, you may want
    to validate whether the item list updates when other users add items.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正在测试的应用程序，例如，你可能想要验证当其他用户添加项目时，项目列表是否更新。
- en: To validate that the application updates the item list as others add items,
    you’ll write a test that sends an HTTP request directly to the server and check
    whether the item list contains the item added through the request.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证应用是否在其他人添加项目时更新项目列表，你需要编写一个测试，该测试直接向服务器发送HTTP请求，并检查项目列表是否包含通过请求添加的项目。
- en: You will encapsulate this HTTP request into a new `command`, which will then
    become available on the `cy` global instance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把这个HTTP请求封装到一个新的`command`中，然后它将成为`cy`全局实例可用。
- en: The command you will write should go into the `commands.js` file in the `support`
    folder. Because this command will run within the browser, you can use native browser
    APIs like `fetch`, for example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的命令应该放入`support`文件夹中的`commands.js`文件。因为此命令将在浏览器中运行，所以你可以使用原生的浏览器API，例如`fetch`。
- en: Listing 11.15 commands.js
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.15 commands.js
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a command named addItem, whose handler function takes an item’s name
    and quantity
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个名为addItem的命令，其处理函数接受一个项目的名称和数量
- en: ❷ Uses the native fetch function to send a POST request with the item’s name
    and quantity to the server route, which adds items to the inventory
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用原生的fetch函数向服务器路由发送带有项目名称和数量的POST请求，该路由添加项目到库存
- en: Alternatively, if you don’t like `fetch`, you can either install another module
    to perform HTTP requests or use Cypress’s own `request` command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不喜欢`fetch`，你可以安装另一个模块来执行HTTP请求，或者使用Cypress自己的`request`命令。
- en: Listing 11.16 commands.js
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.16 commands.js
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Creates a command named addItem, whose handler function takes an item’s name
    and quantity
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个名为addItem的命令，其处理函数接受一个项目的名称和数量
- en: ❷ Uses the Cypress request method to send a POST request with the item’s name
    and quantity to the server route, which adds items to the inventory
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Cypress请求方法向服务器路由发送带有项目名称和数量的POST请求，该路由添加项目到库存
- en: After creating this command, you can use it in the test that validates whether
    your application updates itself as others add items.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此命令后，你可以在验证应用是否在其他人添加项目时更新自身的测试中使用它。
- en: Within the `integration` folder, create a new file called `itemListUpdates.spec
    .js`, and write a test that accesses `http:/./localhost:8080`, waits two seconds
    for the socket connection to be set up, sends an HTTP request to add cheesecakes
    to the inventory, and checks whether the list updates to include the cheesecakes
    added through the server’s route.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`integration`文件夹中，创建一个名为`itemListUpdates.spec .js`的新文件，并编写一个测试，该测试访问`http:/./localhost:8080`，等待两秒钟以建立套接字连接，发送一个HTTP请求将蛋糕添加到库存中，并检查列表是否更新以包括通过服务器路由添加的蛋糕。
- en: To make sure this test will be deterministic, make sure to add a `beforeEach`
    hook that truncates the inventory table before each test.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个测试是确定的，请确保添加一个`beforeEach`钩子，在每个测试之前截断库存表。
- en: Listing 11.17 itemListUpdates.spec.js
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.17 itemListUpdates.spec.js
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Truncates the application’s database’s inventory table before each test
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前截断应用程序数据库的库存表
- en: ❷ Visits the application’s page
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问应用程序的页面
- en: ❸ Waits for two seconds
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待两秒钟
- en: ❹ Sends a request to the server that adds 22 cheesecakes to the inventory
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 向服务器发送请求以将22个蛋糕添加到库存中
- en: ❺ Finds the item list that indicates that the inventory has 22 cheesecakes
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到表示库存中有22个蛋糕的项目列表
- en: NOTE Waiting for fixed amounts of time is usually not recommended. In the section
    “Dealing with flakiness,” you’ll learn why waiting for fixed periods is inadequate
    and how to avoid doing it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：通常不建议等待固定的时间。在“处理不可靠性”部分，你将了解为什么等待固定时间段是不够的，以及如何避免这样做。
- en: The test you’ve written accurately simulates what’s necessary for the item list
    to update, and, therefore, it provides you with a reliable guarantee that the
    application will display new items as other users add them (figure 11.4).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的测试准确地模拟了项目列表更新的必要条件，因此它为你提供了一个可靠的保证，即应用程序将显示新项目，就像其他用户添加它们一样（图11.4）。
- en: '![](../Images/CH11_F04_DaCosta.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F04_DaCosta.png)'
- en: Figure 11.4 Your test adds items through HTTP requests sent directly to the
    backend. The server then communicates with the client through WebSockets to update
    the list of products.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 你的测试通过直接发送到后端的HTTP请求添加项目。然后服务器通过WebSockets与客户端通信以更新产品列表。
- en: Besides allowing you to check how your application reacts to actions happening
    in the backend, being capable of sending HTTP requests will enable you to seed
    the database without having to insert rows directly into the database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许你检查你的应用程序如何对后端发生的行为做出反应之外，能够发送HTTP请求将使你能够在不直接将行插入数据库的情况下对数据库进行初始化。
- en: By sending HTTP requests, you can create entities without coupling your tests
    to the database’s schema. Additionally, because your test will depend on the routes
    to work appropriately, you will indirectly cover them with tests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发送HTTP请求，你可以创建实体，而无需将你的测试与数据库的模式耦合。此外，因为你的测试将依赖于路由以正确工作，所以你将间接通过测试覆盖它们。
- en: In the case of the inventory management software you’re testing, for example,
    you could write a test to validate whether the application loads an initial list
    of items when you open it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在测试库存管理软件时，你可以编写一个测试来验证当你打开应用程序时，应用程序是否加载初始项目列表。
- en: This test would send HTTP requests to add a few items to the database, visit
    `http:/./localhost:8080`, and check whether the list contains the items added
    through HTTP requests.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将向数据库发送HTTP请求以添加一些项目，访问`http:/./localhost:8080`，并检查列表是否包含通过HTTP请求添加的项目。
- en: Listing 11.18 itemListUpdates.spec.js
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.18 itemListUpdates.spec.js
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Sends a request to the server that adds 2 cheesecakes to the inventory
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向服务器发送请求以将2个蛋糕添加到库存中
- en: ❷ Sends a request to the server that adds 5 apple pies to the inventory
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向服务器发送请求以将5个苹果派添加到库存中
- en: ❸ Adds 96 carrot cakes to the inventory
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向库存中添加96个胡萝卜蛋糕
- en: ❹ Visits the application’s page
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 访问应用程序的页面
- en: ❺ Finds the item list that indicates that the inventory has 2 cheesecakes
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到表示库存中有2个蛋糕的项目列表
- en: ❻ Finds the item list that indicates that the inventory has 5 cheesecakes
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 找到表示库存中有5个蛋糕的项目列表
- en: ❼ Finds the item list that indicates that the inventory has 96 cheesecakes
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 找到表示库存中有96个蛋糕的项目列表
- en: As an exercise, write a test to validate whether the server can handle deleting
    items. This test should add a few products to the database through HTTP requests,
    send to the route `/inventory/:itemName` a `DELETE` request whose body contains
    the number of items to delete, and refresh the page to check whether the item
    list displays the correct quantities of the available items.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，编写一个测试来验证服务器是否可以处理删除项目。这个测试应该通过 HTTP 请求将几个产品添加到数据库中，向 `/inventory/:itemName`
    路由发送一个包含要删除的项目数量的 `DELETE` 请求，并刷新页面以检查项目列表是否显示了正确的可用项目数量。
- en: 11.1.4 Sequencing actions
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4 动作排序
- en: So far, none of the commands you’ve written in your tests is synchronous. Yet,
    you don’t need to use `await` or chain promises to sequence these commands. In
    this subsection, you will learn how this is possible and why it happens.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你编写的测试中的所有命令都不是同步的。然而，你不需要使用 `await` 或链式承诺来排序这些命令。在本小节中，你将了解这是如何可能的以及为什么会发生。
- en: Cypress’s commands are *not* promises. When your test starts, Cypress immediately
    invokes the functions you’ve written and adds to a queue the actions bound to
    them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 的命令**不是**承诺。当你的测试开始时，Cypress 立即调用你编写的函数，并将与之绑定的操作添加到队列中。
- en: Cypress then executes these actions in the order they were added to the queue.
    Once an action in the queue fails or all actions in the queue are complete, your
    test finishes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 然后按照它们被添加到队列的顺序执行这些操作。一旦队列中的操作失败或队列中的所有操作都已完成，你的测试就会结束。
- en: As an example, think about what happens when Cypress executes the test that
    validates whether customers can use the application’s form to add items.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑当 Cypress 执行验证客户是否可以使用应用程序表单添加项目的测试时会发生什么。
- en: Listing 11.19 itemListUpdates.spec.js
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.19 itemListUpdates.spec.js
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Visits the application’s page
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, and types “cheesecake” into it
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找用于项目名称的输入，并将“cheesecake”输入其中
- en: ❸ Finds the input for an item’s quantity, and types “10” into it
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找用于项目数量的输入，并将“10”输入其中
- en: ❹ Finds the button that adds items to the inventory, and clicks it
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找添加项目到库存的按钮，并点击它
- en: ❺ Finds the list item that indicates that the inventory contains 10 cheesecakes
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查找表示库存中有10个芝士蛋糕的列表项
- en: When Cypress runs this test, it immediately executes each of its lines, from
    top to bottom, but it doesn’t mark the test as finished.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Cypress 运行这个测试时，它会立即从上到下逐行执行其每一行，但它不会将测试标记为完成。
- en: To see this behavior, add a call to `console.log` after the last line of your
    test, and execute it with your browser’s console open. As the test runs, you will
    see that Cypress logs a message to the browser’s console *before* carrying out
    the test’s actions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种行为，在你的测试最后一行之后添加一个对 `console.log` 的调用，并在浏览器控制台打开的情况下执行它。当测试运行时，你会看到 Cypress
    在执行测试的操作之前将消息记录到浏览器的控制台。
- en: Listing 11.20 itemListUpdates.spec.js
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.20 itemListUpdates.spec.js
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Visits the application’s page
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, and types “cheesecake” into it
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找用于项目名称的输入，并将“cheesecake”输入其中
- en: ❸ Finds the input for an item’s quantity, and types “10” into it
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找用于项目数量的输入，并将“10”输入其中
- en: ❹ Finds the button that adds items to the inventory, and clicks it
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找添加项目到库存的按钮，并点击它
- en: ❺ Finds the list item that indicates that the inventory contains 10 cheesecakes
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查找表示库存中有10个芝士蛋糕的列表项
- en: ❻ Logs a message to the console that is written to the console before the test
    starts carrying out its actions
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 记录一条消息到控制台，该消息在测试开始执行其操作之前被写入控制台
- en: TIP As you go through this section, to obtain quicker feedback, I’d recommend
    you run the tests you update in isolation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当你阅读本节时，为了获得更快的反馈，我建议你单独运行你更新的测试。
- en: To run a single test at a time, add a `.only` to it, as shown in the next piece
    of code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次运行一个测试，请向其中添加一个 `.only`，如下一段代码所示。
- en: Listing 11.21 itemListUpdates.spec.js
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.21 itemListUpdates.spec.js
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Runs the test in isolation
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在隔离状态下运行测试
- en: The order of your tests or whether they run in isolation does not affect each
    test’s action queue.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的顺序或它们是否单独运行不会影响每个测试的动作队列。
- en: Cypress executes the `console.log` first because its commands don’t *execute*
    actions. Instead, they immediately *queue* the actions you’d like to perform,
    as shown in figure 11.5.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 首先执行 `console.log`，因为它的命令不**执行**操作。相反，它们立即**排队**你想要执行的操作，如图 11.5 所示。
- en: '![](../Images/CH11_F05_DaCosta.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F05_DaCosta.png)'
- en: Figure 11.5 Cypress queues commands before running the test’s console log, but
    the commands are executed only *after* the message is logged.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 Cypress在运行测试的控制台日志之前排队命令，但命令仅在消息记录后执行。
- en: Even if you chain other actions to a command, Cypress guarantees that the entire
    command’s chain will run to termination before executing the next.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你将其他动作链接到命令，Cypress也保证整个命令链在执行下一个命令之前会运行到终止。
- en: When you chain a `type` command to a `get` command, for example, `type` is guaranteed
    to run immediately after `get` and *before* the next action starts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将`type`命令链接到`get`命令时，例如，`type`保证在`get`之后立即运行，并且在下一个动作开始之前运行。
- en: To visualize the order in which Cypress executes chained actions, try using
    a command’s `then` method to write different messages to the console. By doing
    this, you will see that each of these actions’ chains run *serially*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化Cypress执行链式动作的顺序，尝试使用命令的`then`方法将不同的消息写入控制台。通过这样做，你会看到这些动作链是**串行**运行的。
- en: Listing 11.22 itemListUpdates.spec.js
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.22 itemListUpdates.spec.js
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Visits the application’s page
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Finds the input for an item’s name, types “cheesecake” into it, and logs a
    message to the console right after typing into the field
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找项目名称的输入，将其输入“cheesecake”，并在输入字段后立即将消息记录到控制台
- en: ❸ Finds the input for an item’s quantity, types “10” into it, and logs a message
    to the console right after typing into the field
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找项目数量的输入，将其输入“10”，并在输入字段后立即将消息记录到控制台
- en: ❹ Finds the button that adds items to the inventory, clicks it, and logs a message
    to the console after clicking the button
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找添加项目到库存的按钮，点击它，并在点击按钮后将消息记录到控制台
- en: ❺ Finds the list item that indicates that the inventory contains 10 cheesecakes
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查找表示库存中有10个芝士蛋糕的列表项
- en: ❻ Logs a message to the console before any other messages
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在任何其他消息之前记录消息到控制台
- en: TIP Cypress commands have a `then` method, but they’re *not* promises. Both
    promises and commands have a `then` method, but, unlike promises, **Cypress’s
    commands can’t run concurrently**.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Cypress命令有一个`then`方法，但它们**不是**承诺。承诺和命令都有`then`方法，但与承诺不同，**Cypress的命令不能并发运行**。
- en: Because each chain of actions runs serially, Cypress will preserve the order
    of the `console.log` statements added to the test, except for the last one, which
    is executed immediately rather than being queued because it is not chained to
    any actions. This sequence of actions is shown in figure 11.6.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个动作链都是串行运行的，Cypress将保留添加到测试中的`console.log`语句的顺序，除了最后一个，它将立即执行而不是排队，因为它没有链接到任何动作。这些动作序列如图11.6所示。
- en: '![](../Images/CH11_F06_DaCosta.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F06_DaCosta.png)'
- en: Figure 11.6 Each queued command has a `console.log` chained to it. These commands
    are executed only after the test’s final `console.log` call.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6每个排队的命令都附加了一个`console.log`。这些命令仅在测试的最终`console.log`调用之后执行。
- en: If Cypress’s commands were promises, it would be possible for the second action
    to finish *before* the first, and, therefore, the order of the logged messages
    would change.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Cypress的命令是承诺，第二个动作可能会在第一个动作完成之前完成，因此记录的消息的顺序会改变。
- en: In the case of logged messages, having them logged in different orders is not
    a problem, but imagine what would happen if you replace those `console.log` calls
    with clicks. If that were the case, your test could click elements in different
    orders every time it runs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于记录的消息，它们以不同的顺序记录没有问题，但想象一下，如果你将这些`console.log`调用替换为点击操作会发生什么。如果是这样，每次测试运行时，测试可能会以不同的顺序点击元素。
- en: Cypress’s commands are *not* promises to guarantee that a test’s actions will
    always happen in the same order. By serially executing a test’s actions, it will
    be easier to write deterministic tests because you won’t have to sequence events
    manually.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress的命令**不是**承诺，以确保测试的动作始终以相同的顺序发生。通过串行执行测试的动作，将更容易编写确定性的测试，因为你不需要手动排序事件。
- en: '**Users act serially, and so does Cypress**.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户的行为是串行的，Cypress也是如此**。'
- en: NOTE Additionally, to avoid one test interfering into another, a test’s actions
    won’t be carried over to the next test, even if Cypress didn’t execute the whole
    queue once the test finishes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此外，为了避免一个测试干扰另一个测试，即使Cypress在测试完成后没有执行整个队列，测试的动作也不会传递到下一个测试。
- en: 11.2 Best practices for end-to-end-tests
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 端到端测试的最佳实践
- en: Ask a methodic French chef to teach you how to cook desserts, and they’ll spend
    half a day talking about the importance of *mise en place* principles before touching
    a single gram of butter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请一位方法论的法国厨师教您如何制作甜点，他们会在触摸任何黄油之前花半天时间谈论*mise en place*原则的重要性。
- en: These chefs are known for their heavenly food because they know that best practices
    lead to excellent results. Baking cakes is for everyone. Having a star in *that*
    famous food guide is way harder.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些厨师因其天赐的食物而闻名，因为他们知道最佳实践能带来卓越的结果。烘焙蛋糕对每个人来说都是一件容易的事。在*那个*著名的美食指南中拥有明星地位要难得多。
- en: In this section, I’ll teach you the best practices—the *mise en place* equivalents—for
    writing fully integrated end-to-end tests.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您传授最佳实践——即“ mise en place”的等价物——用于编写完全集成的端到端测试。
- en: First, I’ll explain why you shouldn’t repeat selectors throughout your tests
    and how you can encapsulate them into modules called “page objects” to make your
    tests more maintainable. I will teach you what page objects are, when to use them,
    and the advantages of adopting this technique.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将解释为什么您不应该在测试中重复选择器，以及如何将它们封装到名为“页面对象”的模块中，以使测试更易于维护。我将向您介绍页面对象是什么，何时使用它们，以及采用这种技术的优势。
- en: Once you’ve learned about page objects, you’ll learn how to interact directly
    with your application’s code through *application actions*. Besides explaining
    what they are and how to use them, I will demonstrate the ways in which they complement
    page objects and when to choose one or the other.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了页面对象，您将学习如何通过*应用程序动作*直接与应用程序的代码进行交互。除了解释它们是什么以及如何使用它们之外，我还将演示它们如何补充页面对象，以及何时选择一个或另一个。
- en: Finally, in the last part of this section, I’ll revisit a few of the best practices
    I’ve covered in the previous chapters and explain how they apply to the kinds
    of end-to-end tests you’re writing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本节的最后一部分，我将回顾前几章中提到的几个最佳实践，并解释它们如何应用于您正在编写的端到端测试。
- en: 11.2.1 Page objects
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 页面对象
- en: When using the page objects pattern, instead of repeating selectors and actions
    throughout your tests, you will use a separate object’s methods into which those
    actions are encapsulated.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用页面对象模式时，您将使用一个单独的对象的方法，而不是在整个测试中重复选择器和动作。
- en: Important Page objects are objects that encapsulate the interactions you make
    with a page.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要页面对象是封装与页面交互的交互的对象。
- en: The main advantage of encapsulating actions into separate methods instead of
    repeating them throughout your tests is that it will be quicker to update your
    tests if your page’s structure changes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将动作封装到单独的方法中而不是在整个测试中重复它们的主要优势是，如果您的页面结构发生变化，更新测试将更快。
- en: Currently, for example, all of your tests depend on the input for an item’s
    name placeholder to equal `Item name`. If you change that input’s placeholder,
    all the tests that depend on it will fail. To fix them, you’ll have to update
    that field’s selector in every test that uses it, as illustrated in figure 11.7\.
    Making this change is tedious and time-consuming.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，目前，您所有的测试都依赖于一个项目名称占位符的输入等于`Item name`。如果您更改该输入的占位符，所有依赖它的测试都将失败。为了修复它们，您将不得不更新每个使用该字段的测试中的该字段选择器，如图11.7所示。进行这种更改既繁琐又耗时。
- en: '![](../Images/CH11_F07_DaCosta.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7](../Images/CH11_F07_DaCosta.png)'
- en: Figure 11.7 If a page changes in such a way that the selector you’ve previously
    used won’t work, you need to update multiple tests.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 如果页面发生变化，您之前使用的选择器将无法工作，您需要更新多个测试。
- en: Had you encapsulated the field’s selector into a method and reused that method
    throughout your tests, if the field’s placeholder changed, you’d have to update
    only the method’s body, as shown in figure 11.8.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将字段的选择器封装到方法中并在整个测试中重用该方法，如果字段的占位符发生变化，您只需更新该方法的主体，如图11.8所示。
- en: '![](../Images/CH11_F08_DaCosta.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8](../Images/CH11_F08_DaCosta.png)'
- en: Figure 11.8 By centralizing your selectors into a page object, when your selectors
    break, you need to update only the page object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 通过将选择器集中到页面对象中，当您的选择器损坏时，您只需要更新页面对象。
- en: By encapsulating your selectors into page objects, you have to make fewer changes
    when the page structure changes in such a way that requires selectors to be updated.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将选择器封装到页面对象中，当页面结构发生变化需要更新选择器时，您需要做出的更改更少。
- en: To learn how to write these page objects, create a file called `inventoryManagement`
    within a new `pageObjects` folder in the `cypress` directory, and write a page
    object for the inventory management application’s main page.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何编写这些页面对象，在`cypress`目录中创建一个名为`inventoryManagement`的新`pageObjects`文件夹，并为库存管理应用程序的主页面编写一个页面对象。
- en: This page object should include methods for visiting the application’s main
    page, submitting items, and finding products in the item’s list.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面对象应包括访问应用程序主页面、提交项目和在项目列表中查找产品的方法。
- en: Listing 11.23 inventoryManagement.js
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.23 inventoryManagement.js
- en: '[PRE22]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ A static method that visits the application’s inventory management page
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个静态方法，用于访问应用程序的库存管理页面
- en: ❷ A static method that interacts with the page elements to add items to the
    inventory
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个静态方法，用于与页面元素交互以将项目添加到库存中
- en: ❸ A static method that finds an item’s entry in the item’s list
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个静态方法，用于在项目列表中查找项目的条目
- en: Once you’ve written this page object, start updating your tests so that they
    interact with the page using the object’s methods instead of frequently repeating
    selectors and commands.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了这个页面对象，开始更新你的测试，以便它们使用对象的这些方法与页面交互，而不是频繁地重复选择器和命令。
- en: For now, these methods in your page object are enough to update the first test
    in `itemSubmission.spec.js` so that it doesn’t directly include any selectors.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些方法足以更新`itemSubmission.spec.js`中的第一个测试，使其不直接包含任何选择器。
- en: Listing 11.24 itemSubmission.spec.js
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.24 itemSubmission.spec.js
- en: '[PRE23]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Truncates the application’s inventory table before each test
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前截断应用程序的库存表
- en: ❷ Visits the application’s page
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问应用程序的页面
- en: ❸ Interacts with the page’s form to add 10 cheesecakes to the inventory
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与页面表单交互，将10个芝士蛋糕添加到库存中
- en: ❹ Finds the item entry indicating that the inventory contains 10 cheesecakes
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找项目条目，指示库存中有10个芝士蛋糕
- en: NOTE In a previous section’s exercise, I suggested that you add a test to validate
    whether the item list updates adequately when adding an item that already exists.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在前面章节的练习中，我建议你添加一个测试来验证在添加已存在的项目时，项目列表是否适当更新。
- en: If you’ve written a test as a solution for that exercise, you should be able
    to use these page object methods to update that test.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为该练习编写了一个测试作为解决方案，你应该能够使用这些页面对象方法来更新那个测试。
- en: To see this exercise’s solution *and* the updated test, go to [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications),
    and check the files in the directory named `chapter11`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此练习的解决方案和更新的测试，请访问[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)，并检查名为`chapter11`的目录中的文件。
- en: If you run your tests after these changes, you’ll see that they still pass because
    they behave exactly as they did before.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这之后运行测试，你会看到它们仍然通过，因为它们的行为与之前完全一样。
- en: The next test in `itemSubmission.spec.js` validates the behavior of the Undo
    button, but your page object doesn’t have a method to click this button yet.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemSubmission.spec.js`中的下一个测试验证了撤销按钮的行为，但你的页面对象还没有一个方法来点击这个按钮。'
- en: To eliminate any direct use of selectors from this test, add another method
    to your page object, as shown in the next code excerpt. This method should find
    the Undo button and click it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除测试中任何直接使用选择器的行为，请向你的页面对象添加另一个方法，如以下代码片段所示。此方法应找到撤销按钮并点击它。
- en: Listing 11.25 inventoryManagement.js
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.25 inventoryManagement.js
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ A static method that clicks the page’s Undo button
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个静态方法，用于点击页面的撤销按钮
- en: After creating this method you can update the third test in `itemSubmission.spec.js`
    and eliminate any direct use of selectors.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此方法后，你可以更新`itemSubmission.spec.js`中的第三个测试，并消除任何直接使用选择器的行为。
- en: Listing 11.26 itemSubmission.spec.js
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.26 itemSubmission.spec.js
- en: '[PRE25]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Visits the application’s page
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Interacts with the page’s form to add 10 cheesecakes to the inventory
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 与页面表单交互，将10个芝士蛋糕添加到库存中
- en: ❸ Interacts with the page’s form to add 5 cheesecakes to the inventory
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与页面表单交互，将5个芝士蛋糕添加到库存中
- en: ❹ Clicks the Undo button
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 点击撤销按钮
- en: ❺ Finds the item entry indicating that the inventory contains 10 cheesecakes
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查找项目条目，指示库存中有10个芝士蛋糕
- en: Once again, your tests should still be passing, as should always be the case
    when you simply encapsulate actions into page objects.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你的测试应该仍然通过，正如在将动作封装到页面对象中时始终应该发生的那样。
- en: After the test you’ve just updated, you should write one that validates the
    application’s action log. This test submits items, clicks the Undo button, and
    checks whether the action log includes the correct entries.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新后的测试之后，你应该编写一个验证应用程序操作日志的测试。此测试提交项目，点击撤销按钮，并检查操作日志是否包含正确的条目。
- en: To avoid having to repeat a selector and the desired text for each entry in
    the action log, you’ll add to your page object a method that finds an entry in
    the action log. This method should take the state of the inventory that should
    be included in the action and find *all* the corresponding entries in the action
    log.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在操作日志中的每个条目中重复选择器和所需文本，你将在页面对象中添加一个方法来查找操作日志中的条目。此方法应接受应包含在操作中的库存状态，并找到操作日志中**所有**相应的条目。
- en: Finding multiple entries is essential for you to be able to assert on the number
    of duplicate entries. You will encounter this situation when, for example, users
    click the Undo button, taking the inventory to the previous state.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 找到多个条目对于你能够断言重复条目的数量至关重要。例如，当用户点击撤销按钮，将库存恢复到之前的状态时，你会遇到这种情况。
- en: Listing 11.27 inventoryManagement.js
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.27 inventoryManagement.js
- en: '[PRE26]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ A static method that, given an inventory state, finds the corresponding actions
    among the action log’s paragraphs
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个静态方法，给定一个库存状态，在操作日志的段落中找到相应的操作
- en: NOTE I’m using a `not` pseudoclass in my selector to guarantee that Cypress
    will *not* search for the desired action message within the first paragraph of
    the page. The first paragraph of the page contains an error message, so you must
    skip it.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我在选择器中使用了一个`not`伪类，以确保Cypress不会在页面的第一段中搜索所需的操作消息。页面的第一段包含一个错误消息，因此你必须跳过它。
- en: With this method in place, update the fourth test in `itemSubmission.spec.js`
    so that it uses *only* the page object’s methods, as shown in the next piece of
    code.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法后，更新`itemSubmission.spec.js`中的第四个测试，使其仅使用页面对象的**方法**，如下所示。
- en: Listing 11.28 itemSubmission.spec.js
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.28 itemSubmission.spec.js
- en: '[PRE27]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Visits the application’s page
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Adds 10 cheesecakes through the page’s inventory
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过页面库存添加10个芝士蛋糕
- en: ❸ Adds 5 cheesecakes through the page’s inventory
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过页面库存添加5个芝士蛋糕
- en: ❹ Clicks the Undo button
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 点击撤销按钮
- en: ❺ Finds the item entry indicating that the inventory contains 10 cheesecakes
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查找表示库存包含10个芝士蛋糕的项目条目
- en: ❻ Finds the action log entry for the empty inventory
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 查找空库存的操作日志条目
- en: ❼ Ensures there are two action log entries that indicate that the inventory
    contains 10 cheesecakes
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 确保有两个操作日志条目表示库存包含10个芝士蛋糕
- en: ❽ Finds the action log entry that indicates the inventory has 15 cheesecakes
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 查找表示库存有15个芝士蛋糕的操作日志条目
- en: Finally, you’ll automate the last test in `itemSubmission.spec.js`, which enters
    an invalid item name into one of the form’s fields and checks whether the submission
    button is disabled.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将自动化`itemSubmission.spec.js`中的最后一个测试，该测试将无效的项目名称输入到表单的一个字段中，并检查提交按钮是否被禁用。
- en: Currently, your page object doesn’t have separate methods to fill inputs or
    to find the submission button. Therefore, you’ll need to refactor the page object.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的页面对象没有单独的方法来填充输入或查找提交按钮。因此，你需要重构页面对象。
- en: In this case, what you should do is create separate methods for entering values
    into the form’s fields and finding the submission button.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该为在表单字段中输入值和查找提交按钮创建单独的方法。
- en: Listing 11.29 inventoryManagement.js
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.29 inventoryManagement.js
- en: '[PRE28]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ A static method that finds the input for an item’s name, clears it, and enters
    the passed name into it
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个静态方法，用于查找项目名称的输入，清除它，并将传递的名称输入其中
- en: ❷ A static method that finds the input for an item’s quantity, clears it, and
    enters the passed quantity into it
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个静态方法，用于查找项目数量的输入，清除它，并将传递的数量输入其中
- en: ❸ A static method that gets the form’s submit button
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个静态方法，用于获取表单的提交按钮
- en: ❹ A static method that adds items to the inventory by interacting with a page’s
    form
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一个静态方法，通过与页面表单交互向库存添加项目
- en: After creating these methods, you have enough to update the last test in `item-
    Submission.spec.js` so that it doesn’t need to use any selectors directly.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些方法后，你就有足够的内容来更新`item-Submission.spec.js`中的最后一个测试，使其不需要直接使用任何选择器。
- en: Listing 11.30 itemSubmission.spec.js
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.30 itemSubmission.spec.js
- en: '[PRE29]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Visits the application’s page
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Enters “boat” into the form’s item name field
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在表单的项目名称字段中输入“boat”
- en: ❸ Enters “10” into the form’s quantity field
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在表单的数量字段中输入“10”
- en: ❹ Finds the submit button, and expects it to be disabled
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找提交按钮，并期望它处于禁用状态
- en: NOTE In this case, I’ve chosen to write the assertion within the test because
    it’s not coupled with the button’s selector. By writing the assertion within the
    test, I can keep the `getSubmitButton` button method flexible and chain any other
    assertions or actions into it if I need to.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这种情况下，我选择在测试中编写断言，因为它与按钮的选择器无关。通过在测试中编写断言，我可以保持`getSubmitButton`按钮方法的灵活性，并在需要时将其链接到任何其他断言或操作。
- en: The last improvement you should do is to reuse your page object’s methods within
    the page object itself. Currently, if your inputs’ placeholders change, for example,
    even though you don’t have to update your tests, you have to update *two* of the
    page object’s methods.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该做的最后一个改进是在页面对象内部重用页面对象的方法。目前，如果你的输入占位符发生变化，例如，即使你不需要更新你的测试，你也必须更新页面对象的*两个*方法。
- en: To avoid having to update selectors in more than one place, refactor your page
    object so that it uses the `enterItemName`, `enterQuantity`, and `getSubmitButton`
    methods within `addItem`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要在多个地方更新选择器，重构你的页面对象，使其在`addItem`中使用`enterItemName`、`enterQuantity`和`getSubmitButton`方法。
- en: Listing 11.31 inventoryManagement.js
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.31 inventoryManagement.js
- en: '[PRE30]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ A static method that finds the input for an item’s name, clears it, and enters
    the passed name into it
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个静态方法，用于查找项目的名称输入框，清除它，并将传入的名称输入到其中
- en: ❷ A static method that finds the input for an item’s quantity, clears it, and
    enters the passed quantity into it
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个静态方法，用于查找项目的数量输入框，清除它，并将传入的数量输入到其中
- en: ❸ A static method that gets the form’s submit button
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取表单的提交按钮的静态方法
- en: ❹ A static method that uses the class’s own methods to fill the form and submit
    it
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一个静态方法，使用类自己的方法填写表单并提交它
- en: By making tests use a page object’s methods, you avoid having to change multiple
    tests to update selectors. Instead, when you need to update selectors, you will
    have to change only a page object’s methods. By diminishing the effort necessary
    to keep tests up-to-date, you will make it quicker to do changes and, therefore,
    reduce your tests’ costs.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使测试使用页面对象的方法，你可以避免需要更改多个测试来更新选择器。相反，当你需要更新选择器时，你只需更改页面对象的方法。通过减少保持测试更新所需的努力，你可以更快地进行更改，从而降低测试的成本。
- en: NOTE Personally, I prefer to use static methods in my page objects, and I avoid
    storing any state in them.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我个人更喜欢在我的页面对象中使用静态方法，并避免在其中存储任何状态。
- en: Sharing page object instances is a *bad* idea because it can cause one test
    to interfere into another.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 共享页面对象实例是一个*坏主意*，因为它可能导致一个测试干扰另一个测试。
- en: By treating page objects exclusively as modules in which I centralize selectors,
    I make tests easier to debug. Stateless page objects make tests easier to debug
    because each of their functions *always* perform the same actions. When page objects
    hold an internal state, they may perform different actions, depending on their
    state.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将页面对象仅作为模块来集中选择器，我可以使测试更容易调试。无状态页面对象使测试更容易调试，因为它们的每个函数*总是*执行相同的操作。当页面对象持有内部状态时，它们可能会根据其状态执行不同的操作。
- en: Thanks to Cypress’s built-in retriability, it’s trivial to write stateless page
    objects. Instead of having to keep track of whether a page has loaded or whether
    an item is visible, you can rely on Cypress to retry finding an item until it
    reaches the configured timeout.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Cypress 内置的重试机制，编写无状态页面对象变得非常简单。你不必跟踪页面是否已加载或项目是否可见，你可以依赖 Cypress 重复查找项目，直到达到配置的超时时间。
- en: Besides centralizing selectors, because page objects couple a test’s actions
    to a page’s semantics instead of its structure, they make your tests more readable
    and maintanable.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集中选择器之外，因为页面对象将测试的操作与页面的语义而不是其结构相关联，它们使你的测试更易于阅读和维护。
- en: TIP A single page object doesn’t necessarily need to represent an entire page.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：单个页面对象不一定需要代表整个页面。
- en: When you have pages which share common UI elements, you can create a separate
    page object for those share elements and reuse it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有共享常见 UI 元素的页面时，你可以为这些共享元素创建一个单独的页面对象，并重用它。
- en: Imagine, for example, that the application you’re testing displays a form to
    add items only when a user clicks a lateral menu’s “add item” option.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，例如，你正在测试的应用程序仅在用户点击侧边菜单的“添加项目”选项时显示添加表单。
- en: In that case, you could create a page object called `LateralMenuPage` to interact
    *exclusively* with the lateral menu and reuse it within the `InventoryManagement`
    page object or make it inherit from `LateralMenuPage`, as shown in the next piece
    of code.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，你可以创建一个名为`LateralMenuPage`的页面对象，专门与侧边菜单交互，并在`InventoryManagement`页面对象中重用它或使其继承自`LateralMenuPage`，如下所示。
- en: Listing 11.32 lateralMenuPage.js
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.32 lateralMenuPage.js
- en: '[PRE31]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ A page object that represents an element that is present in multiple pages
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 代表多个页面中存在的元素的页面对象
- en: Listing 11.33 inventoryManagement.js
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.33 inventoryManagement.js
- en: '[PRE32]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ A method that adds items to the inventory and uses the LateralMenuPage page
    object to interact with the lateral menu
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一种方法，它将项目添加到库存中，并使用LateralMenuPage页面对象与侧边菜单交互
- en: In other words, **by using page objects, you’ll write tests in terms of what
    they do, *not* in terms of what the page’s structure is**.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，**通过使用页面对象，你将根据它们的功能来编写测试，而不是根据页面的结构**。
- en: As an exercise, try updating the tests in the `itemListUpdates.spec.js` file
    so that they use the `InventoryManagement` page object, too.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试更新`itemListUpdates.spec.js`文件中的测试，以便它们也使用`InventoryManagement`页面对象。
- en: NOTE To check how the tests in the `itemListUpdates.spec.js` file would look
    after updating them to use the `InventoryManagement` page object, check this book’s
    GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要检查更新后使用`InventoryManagement`页面对象的`itemListUpdates.spec.js`文件中的测试将如何显示，请查看此书的GitHub仓库[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: 11.2.2 Application actions
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 应用程序动作
- en: Application actions allow your tests to interface directly with your application’s
    code instead of its graphical interface, as shown in the example in figure 11.9\.
    When using an application action in a test, instead of finding an element in the
    page and interacting with it, you invoke a function from your application’s code.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序动作允许你的测试直接与你的应用程序代码而不是其图形界面进行接口，如图11.9所示的示例。当在测试中使用应用程序动作时，你将不再在页面上查找元素并与它交互，而是调用应用程序代码中的一个函数。
- en: Using application actions decouple your tests from the page’s structure so that
    you can reduce the overlap among multiple tests and, therefore, obtain more granular
    feedback.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序动作将你的测试与页面结构解耦，这样你可以减少多个测试之间的重叠，因此可以获得更细粒度的反馈。
- en: Additionally, your tests will be way faster because they won’t depend on waiting
    for elements to be visible or for Cypress to type in a form’s fields or click
    buttons.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的测试将更快，因为它们不会依赖于等待元素可见或Cypress在表单字段中输入或点击按钮。
- en: '![](../Images/CH11_F09_DaCosta.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F09_DaCosta.png)'
- en: Figure 11.9 Application actions directly invoke the functions your application
    has attached to the global window.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 应用程序动作直接调用应用程序附加到全局窗口的函数。
- en: As an example, think about the overlap between the test for adding items through
    the inventory management application’s form and the test for the Undo button.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑通过库存管理应用程序的表单添加项目测试与撤销按钮测试之间的重叠。
- en: Listing 11.34 itemSubmission.spec.js
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.34 itemSubmission.spec.js
- en: '[PRE33]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ A test that interacts with the application’s form to add items and expects
    the item list to contain an entry for 10 cheesecakes
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一种与应用程序的表单交互以添加项目并期望项目列表包含10个芝士蛋糕条目的测试
- en: ❷ A test that adds items through the application’s forms, clicks the Undo button,
    and expects the item list to indicate that the inventory contains the correct
    number of cheesecakes
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一种通过应用程序的表单添加项目、点击撤销按钮并期望项目列表指示库存包含正确数量的芝士蛋糕的测试
- en: In this case, the tests for the Undo button depend not only on the Undo button
    itself but also on the form’s UI elements.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对撤销按钮的测试不仅依赖于撤销按钮本身，还依赖于表单的UI元素。
- en: If the form’s selectors change, or if the application can’t interact with the
    form, for example, both tests would break.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单的选择器发生变化，或者如果应用程序无法与表单交互，例如，这两个测试都会失败。
- en: By decoupling the tests for the Undo button from the form’s UI elements, when
    the test failed, you’d almost immediately be able to tell that the failure happened
    because of the Undo button’s functionality.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将撤销按钮的测试与表单的UI元素解耦，当测试失败时，你几乎可以立即知道失败是因为撤销按钮的功能问题。
- en: To isolate one test from another, instead of using the form to set up the test’s
    scenario, you will use an *application action* that directly invokes the application’s
    `handleAddItem` method called when users submit the form.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隔离一个测试与另一个测试，而不是使用表单来设置测试场景，你将使用一个 *应用程序操作*，该操作直接调用当用户提交表单时调用的应用程序的 `handleAddItem`
    方法。
- en: For your tests to be able to invoke this method, in the client’s source code,
    update the `domController.js` file so that it attaches to the global `window`
    object a function that directly calls `handleAddItem` with an event, as shown
    in the next piece of code.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的测试能够调用此方法，在客户端的源代码中，更新 `domController.js` 文件，使其附加到全局 `window` 对象的函数直接调用带有事件的
    `handleAddItem`，如下面的代码片段所示。
- en: Listing 11.35 domController.js
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.35 domController.js
- en: '[PRE34]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ The function that handles the form’s submission events and adds items to the
    inventory
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理表单提交事件并添加项目到库存的函数
- en: ❷ A method that is attached to window and directly invokes the handleAddItem
    function with an event containing the passed item’s name and quantity
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个附加到窗口并直接使用包含传递的项目名称和数量的事件的 `handleAddItem` 函数调用的方法
- en: TIP Ideally, when it’s too complicated to call one of your application’s actions,
    you should consider refactoring it.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 理想情况下，当调用应用程序的操作过于复杂时，你应该考虑重构它。
- en: In this case, I’d probably refactor my application so that I could call a function
    that adds an item without having to manually replicate an event’s interface.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我可能会重构我的应用程序，以便我可以调用一个函数来添加项目，而无需手动复制事件的界面。
- en: For the sake of keeping this chapter short and focused, I have manually replicated
    the event’s interface within the function I attach to `window`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章简短且专注，我已手动在附加到 `window` 的函数中复制了事件的界面。
- en: After updating the `domController.js` file, don’t forget to rebuild your client
    by going into its folder and running `npm run build`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `domController.js` 文件后，别忘了进入其文件夹并运行 `npm run build` 来重新构建你的客户端。
- en: Now that `handleAddItem` is globally exposed through a function in `window`,
    you can update the tests for the Undo button so that they directly invoke the
    window’s `handleAddItem` function instead of using the form’s elements to set
    up the test’s scenario.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 `handleAddItem` 通过 `window` 中的函数全局暴露，你可以更新撤销按钮的测试，以便它们直接调用窗口的 `handleAddItem`
    函数，而不是使用表单的元素来设置测试场景。
- en: Listing 11.36 itemSubmission.spec.js
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.36 itemSubmission.spec.js
- en: '[PRE35]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Visits the application’s page
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 访问应用程序的页面
- en: ❷ Waits for one second
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一秒钟
- en: ❸ Directly invokes the window’s handleAddItem method to add 10 cheesecakes to
    the inventory
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 直接调用窗口的 `handleAddItem` 方法，将 10 个芝士蛋糕添加到库存中
- en: ❹ Waits for one second
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一秒钟
- en: ❺ Directly invokes the window’s handleAddItem method to add 5 cheesecakes to
    the inventory
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 直接调用窗口的 `handleAddItem` 方法，将 5 个芝士蛋糕添加到库存中
- en: ❻ Waits for one second
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一秒钟
- en: ❼ Clicks the Undo button
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 点击撤销按钮
- en: ❽ Expects the list of items to contain an element indicating that the inventory
    has 10 cheesecakes
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 期望项目列表包含一个元素，指示库存中有 10 个芝士蛋糕
- en: After this update, besides reducing the overlap between this test and the test
    for adding items through the form, this test’s setup will be way quicker because
    it won’t depend on waiting for Cypress to interact with the page’s UI elements.
    Instead, this test will directly invoke your application’s code in its *arrange*
    stage.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更新之后，除了减少此测试与通过表单添加项目的测试之间的重叠之外，此测试的设置将更快，因为它不会依赖于等待 Cypress 与页面 UI 元素交互。相反，此测试将在其
    *arrange* 阶段直接调用你的应用程序代码。
- en: NOTE Using application actions makes this test so efficient that you application
    can’t update quickly enough after each action. To make sure these actions will
    happen at the right time, you’ll have to wait for a few milliseconds for the application
    to update.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 使用应用程序操作使此测试如此高效，以至于应用程序在每次操作后无法快速更新。为了确保这些操作将在正确的时间发生，你将不得不等待几毫秒以等待应用程序更新。
- en: Without using `cy.wait` to synchronize these actions with the application’s
    updates, your test will become flaky.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用 `cy.wait` 来同步这些操作与应用程序的更新，你的测试将变得不可靠。
- en: In the next section, you’ll learn how to avoid waiting for fixed amounts of
    time and take full advantage of application actions.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何避免等待固定的时间量，并充分利用应用程序的操作。
- en: The disadvantage of using application actions is that they couple your tests
    to your application code instead of coupling it to its UI. Therefore, if you were
    to *always* use application actions to interact with your page, your tests wouldn’t
    accurately simulate user behavior.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序动作的缺点是它们将您的测试与您的应用程序代码耦合，而不是将其与 UI 耦合。因此，如果您总是使用应用程序动作与页面交互，您的测试将无法准确模拟用户行为。
- en: If, for example, you used only application actions throughout your tests for
    the inventory management system, your tests would pass, even if you completely
    removed all the form’s elements from the page.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在整个库存管理系统测试中只使用了应用程序动作，即使您完全从页面上移除了所有表单元素，测试也会通过。
- en: Application actions should be used to reduce the overlap among different tests,
    *not* to completely eliminate page objects.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序动作应该用于减少不同测试之间的重叠，*而不是* 完全消除页面对象。
- en: In the previous example, you used an application action to reduce overlap and
    make the test faster because you had *already* tested the page’s form. Therefore,
    if the form stopped working, you would still have a failing test.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您使用应用程序动作来减少重叠并使测试更快，因为您已经测试了页面的表单。因此，如果表单停止工作，您仍然会有一个失败的测试。
- en: A perfect use case for an application action is logging in to your application.
    If your functionalities are hidden behind an authentication screen, you don’t
    want to manually interact with the authentication form before each test. Instead,
    to make your tests quicker and decouple them from the authentication form’s elements,
    you could use an application action to directly log in to the system.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序动作的一个完美用例是登录到您的应用程序。如果您的功能隐藏在身份验证屏幕后面，您不想在每次测试之前手动与身份验证表单交互。相反，为了使您的测试更快，并使其与身份验证表单的元素解耦，您可以使用应用程序动作直接登录到系统中。
- en: TIP When assigning methods to the global window, you can wrap those assignments
    into an `if` statement that checks whether `window.Cypress` is defined before
    executing them.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 当将方法分配给全局窗口时，您可以将这些分配包裹在一个 `if` 语句中，该语句在执行它们之前检查 `window.Cypress` 是否已定义。
- en: Listing 11.37 domController.js
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.37 domController.js
- en: '[PRE36]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because `window.Cypress` will be truthy when Cypress is running tests, your
    application won’t pollute the global `window` when customers access your application.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当 Cypress 运行测试时 `window.Cypress` 将为真值，所以当客户访问您的应用程序时，您的应用程序不会污染全局的 `window`。
- en: Personally, I use application actions only in my test’s *arrange* step. To *act*
    and *assert*, I use selectors from a page object.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我只在我的测试的 *arrange* 步骤中使用应用程序动作。对于 *act* 和 *assert*，我使用页面对象的选择器。
- en: 11.3 Dealing with flakiness
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 处理不稳定性
- en: In this book, we appreciate flaky pie crusts, *not* flaky tests.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们欣赏的是不稳定的馅饼皮，*而不是* 不稳定的测试。
- en: Unfortunately, creating solid tests is more challenging than baking a flaky
    crust. To achieve the first, you’ll need to apply multiple techniques. To achieve
    the latter, some leaf lard is enough.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，创建稳定的测试比烘焙不稳定的馅饼更具挑战性。为了实现前者，您需要应用多种技术。为了实现后者，一些叶猪油就足够了。
- en: 'In this section, I’ll teach a few techniques to guarantee that your tests will
    be deterministic: given the same unit under test, they’ll *always* yield the same
    results.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍一些技术，以确保您的测试将是确定的：对于相同的测试单元，它们将 *始终* 产生相同的结果。
- en: As I’ve mentioned in chapter 5, flaky tests will make it difficult for you to
    determine whether a failure occurs because the application has a bug or because
    you’ve written tests poorly.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第 5 章中提到的，不稳定的测试会使您难以确定失败是由于应用程序存在错误还是因为您编写的测试不好。
- en: '**Flaky tests make you less confident that your tests—your bug-detection mechanisms—can
    identify mistakes**.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**不稳定的测试会降低您对测试——您的错误检测机制——能够识别错误的信心**。'
- en: To demonstrate how to eliminate flaky tests, I’ll show you cases in which the
    tests you have already written could fail intermittently. Once you’ve experienced
    this flaky behavior, I’ll teach you how to update your tests so that they become
    robust and deterministic.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何消除不稳定的测试，我将向您展示一些测试可能间歇性失败的案例。一旦您体验过这种不稳定的特性，我将教您如何更新您的测试，使它们变得稳健和确定。
- en: 'The first two parts of this section cover the two most relevant practices for
    building robust and deterministic tests: avoiding waiting for fixed amounts of
    time and stubbing factors over which you have no control.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的前两部分涵盖了构建稳健和确定性的测试的两个最相关实践：避免等待固定的时间量，以及模拟您无法控制的因素。
- en: The final part of this section explains how to retry failing tests and when
    it’s valuable to do that.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后部分解释了如何重试失败的测试，以及何时这样做是有价值的。
- en: 11.3.1 Avoiding waiting for fixed amounts of time
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 避免等待固定的时间量
- en: As a rule of thumb, whenever using Cypress, you should avoid waiting for a fixed
    amount of time. In other words, **using `cy.wait` is almost always a bad idea**.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，在每次使用 Cypress 时，你应该避免等待固定的时间。换句话说，**使用`cy.wait`几乎总是个坏主意**。
- en: Waiting for a fixed amount of time is a bad practice because your software may
    take a different time to respond every time a test runs. If, for example, you’re
    always waiting for your server to respond to a request within two seconds, your
    tests will fail if it takes three. Even if you try to err on the side of caution
    and wait for four seconds instead, that still doesn’t guarantee your tests will
    pass.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 等待固定的时间是一种不良做法，因为你的软件每次测试运行时可能需要不同的时间来响应。例如，如果你总是等待服务器在两秒内响应请求，如果它需要三秒，你的测试将会失败。即使你试图谨慎行事，等待四秒，这仍然不能保证你的测试会通过。
- en: Additionally, by increasing these waiting periods in an attempt to make tests
    deterministic, you’ll be making your tests slower. If you’re always waiting for
    four seconds for your server to respond but 95% of the time it responds within
    a second, most of the time you’ll be unnecessarily delaying your test by three
    seconds.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过增加这些等待期来尝试使测试确定，你将使你的测试变慢。如果你总是等待四秒来等待服务器响应，但实际上95%的时间它在一秒内就响应了，那么大多数情况下你将不必要地延迟测试三秒。
- en: '**Instead of waiting for a fixed amount of time, you should wait for conditions
    to be met**.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**而不是等待固定的时间，你应该等待条件满足**。'
- en: For example, if you expect your page to contain a new element once the server
    responds to a request, don’t wait for a few seconds before checking the page’s
    elements. Instead, configure the test to proceed when it detects that the new
    element is there.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你期望服务器响应请求后页面会包含一个新元素，不要在检查页面元素之前等待几秒钟。相反，配置测试在检测到新元素存在时继续。
- en: To demonstrate this principle, I’ll show you how to eliminate the need for waiting
    for fixed amounts of time in the test that validates your application’s undo functionality.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个原则，我将向你展示如何消除在验证应用程序撤销功能测试中等待固定时间量的需求。
- en: Currently, this test needs to use `cy.wait`. Otherwise, it may dispatch an action
    before the application has had a chance to process the *previous* action and update
    accordingly.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个测试需要使用`cy.wait`。否则，它可能会在应用程序有机会处理*上一个*动作并相应更新之前就发出动作。
- en: This test waits for an unnecessarily long time and still doesn’t guarantee that
    the application will have had a chance to update itself after a second, even though
    in the vast majority of cases it *will*.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试等待了不必要的时间，并且仍然不能保证应用程序在第二秒后有机会更新自己，尽管在绝大多数情况下它*会*。
- en: For example, if you try removing the calls to `cy.wait` and rerunning this test
    a couple of times, you’ll be able to see it intermittently failing.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你尝试移除对`cy.wait`的调用并重新运行这个测试几次，你将能够看到它间歇性地失败。
- en: NOTE On my machine, removing the calls to `cy.wait` was enough to see the test
    failing 50% of the time.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：在我的机器上，移除对`cy.wait`的调用就足以看到测试有50%的时间失败。
- en: Because this test would pass 50% of the time, there’s an unnecessary three-second
    delay in 50% of the test’s executions.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个测试有50%的时间会通过，所以在测试执行的50%中存在不必要的三秒延迟。
- en: Instead of waiting for a fixed amount of time, you can wait for certain conditions
    to be met instead.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是等待固定的时间，你可以等待满足某些条件。
- en: In this case, after each action, you could wait for the action log updates with
    each of the actions dispatched.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在每次动作之后，你可以等待动作日志随着每个发出的动作更新。
- en: Listing 11.38 itemSubmission.spec.js
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.38 itemSubmission.spec.js
- en: '[PRE37]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Visits the application’s page
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Before proceeding, keeps trying to find an action log entry indicating that
    the application has loaded with an empty inventory
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在继续之前，持续尝试找到动作日志条目，表明应用程序已加载为空库存
- en: ❸ Directly invokes the window’s handleAddItem method to add 10 cheesecakes to
    the inventory
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 直接调用窗口的handleAddItem方法向库存中添加10个芝士蛋糕
- en: ❹ Before proceeding, keeps trying to find an action log entry indicating that
    the application contains 10 cheesecakes
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在继续之前，持续尝试找到动作日志条目，表明应用程序包含10个芝士蛋糕
- en: ❺ Directly invokes the window’s handleAddItem method to add 5 cheesecakes to
    the inventory
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 直接调用窗口的 handleAddItem 方法向库存中添加 5 个芝士蛋糕
- en: ❻ Before proceeding, keeps trying to find an action log entry indicating that
    the application contains 15 cheesecakes
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在继续之前，持续尝试查找一个动作日志条目，指示应用程序包含 15 个芝士蛋糕
- en: ❼ Clicks the Undo button
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 点击撤销按钮
- en: ❽ Expects the list of items to contain an element indicating that the inventory
    has 10 cheesecakes
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 期望项目列表包含一个指示库存中有 10 个芝士蛋糕的元素
- en: After this change, Cypress will keep retrying to find the necessary actions
    in the action log before it allows the test to proceed to dispatch the next action.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，Cypress 将在允许测试继续执行下一个操作之前，持续重试在动作日志中找到必要的操作。
- en: Thanks to this update, you will be able to sequence the test’s actions, depending
    on when the application is ready to deal with them instead of always waiting for
    the same amount of time.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个更新，你将能够根据应用程序何时准备好处理它们来按顺序排列测试的操作，而不是总是等待相同的时间量。
- en: Waiting for the application to update to the desired state eliminates flakiness
    because it ensures that your actions happen at the right time—when your application
    is ready to accept and handle them.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 等待应用程序更新到所需状态可以消除不可靠性，因为它确保你的操作在正确的时间发生——当你的应用程序准备好接受和处理它们时。
- en: Additionally, this practice causes your tests to run more quickly because they’ll
    wait for only the minimum necessary amount of time.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种做法会使你的测试运行得更快，因为它们将只等待必要的最短时间。
- en: Waiting for HTTP requests
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 HTTP 请求
- en: Besides waiting for elements to appear, your Cypress tests can monitor HTTP
    requests and wait for them to resolve before proceeding.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 除了等待元素出现外，你的 Cypress 测试还可以监控 HTTP 请求，并在继续之前等待它们解决。
- en: To wait for a request to resolve, you can use Cypress’s `cy.server` method to
    start intercepting requests and `cy.route` to determine specific actions to deal
    with requests to a particular route.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待一个请求解决，你可以使用 Cypress 的 `cy.server` 方法开始拦截请求，并使用 `cy.route` 来确定处理特定路由请求的具体操作。
- en: To see how `cy.server` and `cy.route` work, you’ll update the test that validates
    whether the item list updates as other users add items.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `cy.server` 和 `cy.route` 的工作原理，你将更新验证项目列表是否在其他用户添加项目时更新的测试。
- en: You’ll eliminate that test’s `cy.wait` call by waiting for the initial `GET`
    request to `/inventory` to resolve. By waiting for that initial request to resolve,
    you ensure that your test will proceed only when your application is ready to
    receive updates.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过等待对 `/inventory` 的初始 `GET` 请求解决来消除该测试的 `cy.wait` 调用。通过等待那个初始请求解决，你确保你的测试只有在你的应用程序准备好接收更新时才会继续。
- en: For the test to wait until the `GET` request to `/inventory` resolves, you must
    call `cy.server` to be able to intercept requests and then chain a call to Cypress’s
    `route` method to specify that it should intercept all the requests to `http:/./localhost:3000/inventory`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试等待对 `/inventory` 的 `GET` 请求解决，你必须调用 `cy.server` 以能够拦截请求，然后链式调用 Cypress
    的 `route` 方法来指定它应该拦截所有对 `http:/./localhost:3000/inventory` 的请求。
- en: Once you have configured which route to intercept, you’ll chain Cypress’s `as`
    method to create an `alias` through which you’ll be able to retrieve the request
    later.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了要拦截哪个路由，你将链式调用 Cypress 的 `as` 方法来创建一个 `alias`，通过它你将能够稍后检索请求。
- en: Listing 11.39 itemListUpdates.spec.js
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.39 itemListUpdates.spec.js
- en: '[PRE38]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Intercepts requests to http:/`.`/localhost:3000/inventory, and aliases matching
    requests to inventoryRequest
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 拦截对 http:/`.`/localhost:3000/inventory 的请求，并为 inventoryRequest 创建别名
- en: NOTE The application you’re testing uses the browser’s `fetch` method to perform
    the request to `/inventory`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你正在测试的应用程序使用浏览器的 `fetch` 方法执行对 `/inventory` 的请求。
- en: Because at the time of this writing Cypress doesn’t spy on the browser’s `fetch`
    method by default, you’ll need to update the `cypress.json` configuration file
    so that it sets the `experimentalFetchPolyfill` option to `true`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在撰写本文时，Cypress 默认不会监视浏览器的 `fetch` 方法，所以你需要更新 `cypress.json` 配置文件，使其将 `experimentalFetchPolyfill`
    选项设置为 `true`。
- en: Listing 11.40 cypress.json
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.40 cypress.json
- en: '[PRE39]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Allows Cypress to intercept requests made with fetch
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许 Cypress 拦截使用 fetch 发出的请求
- en: After this update, you’ll be able to intercept `GET` requests to `/inventory`,
    but you haven’t yet configured your tests to wait for this request to resolve
    before proceeding to add an item.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新之后，你将能够拦截对 `/inventory` 的 `GET` 请求，但你还没有配置你的测试在添加项目之前等待此请求解决。
- en: To cause your test to wait for that initial `GET` request to resolve, add a
    `cy.wait` call after vising `http:/./localhost:8080`. Instead of waiting for a
    fixed amount of time, this `cy.wait` call will wait for the request whose alias
    is `inventoryRequest` to resolve.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的测试等待那个初始的`GET`请求解决，在访问`http:/./localhost:8080`后添加一个`cy.wait`调用。这个`cy.wait`调用将等待一个别名匹配`inventoryRequest`的请求解决，而不是等待固定的时间。
- en: By waiting for the request to resolve, you don’t need to wait for a fixed amount
    of time anymore.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 通过等待请求解决，你不再需要等待固定的时间了。
- en: Listing 11.41 itemListUpdates.spec.js
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.41 itemListUpdates.spec.js
- en: '[PRE40]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Intercepts requests to http:/`.`/localhost:3000/inventory, and aliases matching
    requests to inventoryRequest
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 截获对http:/`.`/localhost:3000/inventory的请求，并为匹配的请求分配别名inventoryRequest
- en: ❷ Visits the application’s page
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问应用程序的页面
- en: ❸ Waits for a request to http:/`.`/localhost:3000/inventory to be resolved so
    that the application is in the correct initial state for the test to happen
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待对http:/`.`/localhost:3000/inventory的请求解决，以便应用程序处于测试发生的正确初始状态
- en: ❹ Sends an HTTP request to add 22 cheesecakes to the inventory
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 向库存发送一个HTTP请求以添加22个芝士蛋糕
- en: ❺ Expects the list of items to contain an element indicating that the inventory
    has 22 cheesecakes
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 期望项目列表包含一个元素，表明库存有22个芝士蛋糕
- en: This change causes your test to *always* pass and doesn’t require your test
    to wait for a fixed amount of time, which could be wasteful and cause your test
    to be flaky if the request took too long to resolve.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改导致你的测试**总是**通过，并且不需要你的测试等待固定的时间，这可能是浪费的，如果请求解决时间过长，可能会导致你的测试不稳定。
- en: 11.3.2 Stubbing uncontrollable factors
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 存根不可控因素
- en: You can’t write robust tests for uncontrollable behavior. To write deterministic
    tests, you *must* make the unit under test predictable before you can assert on
    its results.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能为不可控的行为编写健壮的测试。要编写确定性的测试，你**必须**在可以对结果进行断言之前，使被测试的单元可预测。
- en: If, for example, your application does an HTTP request to a third-party API,
    the third-party API can change its response or become unavailable at any time,
    and, therefore, your tests will fail, even though the unit under test didn’t change.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的应用程序向第三方API发出HTTP请求，第三方API可以随时更改其响应或变得不可用，因此，即使被测试的单元没有改变，你的测试也会失败。
- en: Similar to how you’d stub uncontrollable behavior in other kinds of tests, **to
    have deterministic tests, you need to stub uncontrollable behavior when writing
    fully integrated UI tests**.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在其他类型的测试中存根不可控行为的方式类似，**为了有确定性的测试，在编写完全集成的UI测试时，你需要存根不可控的行为**。
- en: The difference between using stubs in UI-based end-to-end tests and other kinds
    of tests is that, in the first, you should *not* use stubs to isolate different
    parts of your application. The main goal of the tests you’re writing in this chapter
    is to simulate your user’s behavior as accurately as possible, and stubs will
    defeat that purpose.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于UI的端到端测试中使用存根与其他类型的测试之间的区别在于，在第一种情况下，你不应该使用存根来隔离应用程序的不同部分。你在这章中编写的测试的主要目标是尽可能准确地模拟用户的行为，而存根将破坏这个目的。
- en: Important When writing UI-based end-to-end tests, you should use stubs to make
    your tests deterministic, *not* to isolate different parts of your application.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 当编写基于UI的端到端测试时，你应该使用存根来使你的测试具有确定性，**而不是**来隔离应用程序的不同部分。
- en: 'In this subsection I’ll show you the three most common situations in which
    you’ll need to use stubs in your UI-based end-to-end tests: when your application
    depends on time, when it depends on an API resource you can’t control, and when
    it depends on an indeterministic method, like `Math.random()`.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我将向你展示你需要在基于UI的端到端测试中使用存根的三个最常见情况：当你的应用程序依赖于时间、当它依赖于你无法控制的API资源，以及当它依赖于像`Math.random()`这样的不可预测方法。
- en: Using fake timers
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用假定时器
- en: Similar to the fake timers you saw in chapter 4, **Cypress’s fake timers allow
    you to control time-related methods**. If, for example, your application uses
    `setTimeout` to schedule a function or the `Date` constructor to obtain the current
    time, you can use fake timers to control the clock upon which those functions
    depend.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在第4章中看到的假定时器类似，**Cypress的假定时器允许你控制与时间相关的方法**。例如，如果你的应用程序使用`setTimeout`来安排一个函数或使用`Date`构造函数来获取当前时间，你可以使用假定时器来控制这些函数所依赖的时钟。
- en: By using fake timers, you’ll be able to control when a scheduled function should
    run, and you’ll know which are the exact values that the `Date` constructor will
    return.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模拟计时器，你将能够控制预定函数何时运行，并且将知道 `Date` 构造函数将返回的确切值。
- en: Because you’ve used fake timers to stub a factor you can’t control—functions
    that depend on time—you’ll be able to make your tests deterministic.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了模拟计时器来模拟你无法控制的因素——依赖于时间的函数——你将能够使你的测试具有确定性。
- en: To see how you’d use fake timers to write deterministic tests for applications
    that depend on time, assume that each of your action log entries had to include
    a timestamp so that the system’s operators know *when* each action happened.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解你如何使用模拟计时器为依赖于时间的应用程序编写确定性测试，假设你的每个操作日志条目都必须包含一个时间戳，以便系统操作员知道每个操作发生的时间。
- en: Listing 11.42 domController.js
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.42 domController.js
- en: '[PRE41]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Adds the current date and time to the start of every new action log entry
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将当前日期和时间添加到每个新的操作日志条目的开头
- en: NOTE The `client` folder you’ll find in the `chapter11` directory of this book’s
    GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)
    already includes this update.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书 GitHub 仓库的 `chapter11` 目录中找到的 `client` 文件夹已经包含了此更新。[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)
- en: If you’re updating the client application from chapter 6 yourself, make sure
    to run `npm run build` again after this change.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自己更新第 6 章的客户端应用程序，请确保在此更改后再次运行 `npm run build`。
- en: After this change, your tests will still pass because each action log entry
    will still *contain* the same text as before, but they won’t be able to validate
    the dates in each of those entries because the dates will be different every time
    the tests run.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，你的测试仍然会通过，因为每个操作日志条目仍然会包含与之前相同的文本，但它们将无法验证每个条目中的日期，因为日期每次运行测试时都会不同。
- en: For example, if you try updating the page object’s `findAction` method to check
    for a date in each action log entry, you will have failing tests.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你尝试更新页面对象的 `findAction` 方法以检查每个操作日志条目中的日期，你的测试将会失败。
- en: NOTE Now that you will use a timestamp to find each action log entry, you don’t
    need to return multiple entries anymore. Instead, you can merely use `get` and
    `contains` because, as you advance the time, the timestamp guarantees you will
    find a different entry on each query.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在你将使用时间戳来查找每个操作日志条目，你不再需要返回多个条目。相反，你只需使用 `get` 和 `contains`，因为当你推进时间时，时间戳保证你将在每次查询时找到不同的条目。
- en: Listing 11.43 itemSubmission.spec.js
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.43 itemSubmission.spec.js
- en: '[PRE42]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Finds action log entries by the inventory state that also include the current
    date and time
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过库存状态查找操作日志条目，这些条目还包括当前日期和时间
- en: For you to make your tests pass again and assert on the date in each of your
    action log entries, you must make time deterministic and have control over it.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的测试再次通过并断言每个操作日志条目中的日期，你必须使时间确定并对其有控制权。
- en: Similar to what you did in chapter 4, you’ll use fake timers to stub your application’s
    time functions.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在第 4 章中所做的那样，你将使用模拟计时器来模拟应用程序的时间函数。
- en: To demonstrate how you can fix your tests, I’ll use as an example the test that
    validates each of the application’s action log entries, as shown in the next piece
    of code.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示你如何修复测试，我将使用一个示例来验证应用程序的每个操作日志条目，如下面的代码片段所示。
- en: Listing 11.44 itemSubmission.spec.js
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.44 itemSubmission.spec.js
- en: '[PRE43]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Visits the application’s page
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问应用程序的页面
- en: ❷ Uses the application’s form to add 10 cheesecakes to the inventory
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用应用程序的表单将 10 个芝士蛋糕添加到库存中
- en: ❸ Uses the application’s form to add 5 cheesecakes to the inventory
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用应用程序的表单将 5 个芝士蛋糕添加到库存中
- en: ❹ Clicks the Undo button
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 点击撤销按钮
- en: ❺ Expects the list of items to contain an element indicating that the inventory
    has 10 cheesecakes
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 期望项目列表包含一个指示库存有 10 个芝士蛋糕的元素
- en: ❻ Finds an action log entry indicating that the inventory is empty
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 找到一个操作日志条目，指示库存为空
- en: ❼ Finds an action log entry indicating that the inventory has 10 cheesecakes
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 找到一个操作日志条目，指示库存有 10 个芝士蛋糕
- en: ❽ Finds an action log entry indicating that the inventory has 15 cheesecakes
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 找到一个操作日志条目，指示库存有 15 个芝士蛋糕
- en: ❾ Finds an action log entry indicating that the inventory has 10 cheesecakes
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 找到一个操作日志条目，指示库存有 10 个芝士蛋糕
- en: In Cypress, to install fake timers, you must use `cy.clock`. Once Cypress has
    installed the fake timers, you can control them with `cy.tick`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cypress 中，要安装模拟计时器，你必须使用 `cy.clock`。一旦 Cypress 安装了模拟计时器，你就可以使用 `cy.tick` 控制它们。
- en: Go ahead and add a global `beforeEach` hook to the `index.js` file in the `support`
    folder so that it installs fake timers before each test and uses `fakeTimers`
    as its alias.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 请将全局 `beforeEach` 钩子添加到 `support` 文件夹中的 `index.js` 文件，以便在每个测试之前安装模拟计时器，并使用 `fakeTimers`
    作为其别名。
- en: Listing 11.45 index.js
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.45 index.js
- en: '[PRE44]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Before each test, installs fake timers that will always return the time when
    the fake timers were installed
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，安装始终返回模拟计时器安装时时间的模拟计时器
- en: NOTE Cypress resets fake clocks automatically between tests, so you don’t need
    to do that yourself.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Cypress 在测试之间自动重置模拟时钟，因此你不需要自己这样做。
- en: After adding your global hook to this file, update the `findAction` method in
    your page object so that it uses Cypress’s time from the fake timer when checking
    your date.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在将你的全局钩子添加到此文件后，更新你的页面对象中的 `findAction` 方法，使其在检查日期时使用 Cypress 的来自模拟计时器的时间。
- en: Listing 11.46 domController.js
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.46 domController.js
- en: '[PRE45]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Obtains the object that represents installed fake timers, and calls the passed
    function with them
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取表示已安装的模拟计时器的对象，并使用它们调用传入的函数
- en: ❷ Gets the fake timer’s current time, and transforms it into an ISO 8601 compliant
    string
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取模拟计时器的当前时间，并将其转换为 ISO 8601 兼容的字符串
- en: ❸ Finds an action log entry containing the fake timer’s current time and the
    passed inventory state
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找一个包含模拟计时器的当前时间和传入的库存状态的操作日志条目
- en: After this change, all your tests should pass because `dateStr` will always
    have the same value.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，所有你的测试都应该通过，因为 `dateStr` 将始终具有相同的值。
- en: Furthermore, if you wish to make your test more thorough, you can use `tick`
    between actions to generate action log entries with different times, as shown
    in this code excerpt.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望使你的测试更加彻底，你可以在操作之间使用 `tick` 生成具有不同时间的操作日志条目，如本代码摘录所示。
- en: Listing 11.47 itemSubmission.spec.js
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.47 itemSubmission.spec.js
- en: '[PRE46]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Finds an action log entry indicating that the inventory is empty and that
    it has the fake timer’s current time
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找一个操作日志条目，指示库存为空，并且它有模拟计时器的当前时间
- en: ❷ Advances the fake timers by one second
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将模拟计时器向前推进一秒
- en: ❸ Uses the application’s form to add 10 cheesecakes to the inventory
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用应用程序的表单将 10 个芝士蛋糕添加到库存中
- en: ❹ Finds an action log entry indicating that the inventory has 10 cheesecakes
    and that it has the fake timer’s current time
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找一个操作日志条目，指示库存中有 10 个芝士蛋糕，并且它有模拟计时器的当前时间
- en: ❺ Advances the fake timers by one second
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将模拟计时器向前推进一秒
- en: ❻ Uses the application’s form to add five cheesecakes to the inventory
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用应用程序的表单将五个芝士蛋糕添加到库存中
- en: ❼ Finds an action log entry indicating that the inventory has 15 cheesecakes
    and that it has the fake timer’s current time
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找一个操作日志条目，指示库存中有 15 个芝士蛋糕，并且它有模拟计时器的当前时间
- en: ❽ Advances the fake timers by one second
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将模拟计时器向前推进一秒
- en: ❾ Clicks the Undo button
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 点击撤销按钮
- en: ❿ Expects the list of items to contain an element indicating that the inventory
    has 10 cheesecakes
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 预期项目列表包含一个元素，指示库存中有 10 个芝士蛋糕
- en: ⓫ Finds an action log entry indicating that the inventory has 10 cheesecakes
    and that it has the fake timer’s current time
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 查找一个操作日志条目，指示库存中有 10 个芝士蛋糕，并且它有模拟计时器的当前时间
- en: Stubbing API requests
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟 API 请求
- en: When your application makes requests to an API whose answer you can’t control,
    that API may change its response at any time, or become unavailable for a few
    minutes, causing your tests to fail, even though your application didn’t change.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序向一个你无法控制的 API 发送请求时，该 API 可能随时更改其响应，或者在一小段时间内不可用，导致你的测试失败，即使你的应用程序没有更改。
- en: Imagine, for example, that you wanted to include a link to one of Recipe Puppy
    API’s recipes for each item in the inventory.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要在每个库存项目中包含指向 Recipe Puppy API 中某个菜谱的链接。
- en: To include that link, your application needs to send a `GET` request to your
    server’s `/inventory/:itemName` route, which, in turn, sends a request to the
    Recipe Puppy API to fetch recipes and embeds them in the response.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含该链接，你的应用程序需要向服务器的 `/inventory/:itemName` 路径发送一个 `GET` 请求，该请求反过来向 Recipe Puppy
    API 发送请求以获取菜谱并将其嵌入到响应中。
- en: Listing 11.48 domController.js
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.48 domController.js
- en: '[PRE47]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Adds an anchor tag to the list item the application will append to the list
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将锚点标签添加到应用程序将附加到列表中的列表项
- en: ❷ Fetches an inventory item entry containing recipes from the Recipe Puppy API
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 Recipe Puppy API 获取包含菜谱的库存项目条目
- en: ❸ Obtains the URL to the first recipe in the response’s list
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取响应列表中的第一个菜谱的 URL
- en: ❹ Sets the anchor tag’s href property to be the recipe’s URL
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将锚标签的 `href` 属性设置为菜谱的 URL
- en: NOTE If you’re updating the application from chapter 6 yourself, make sure to
    run `npm run build` again after this change.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你自己更新第 6 章的应用程序，请确保在此更改后再次运行 `npm run build`。
- en: Additionally, to avoid having items that are about to sold out from being colored
    in blue due to the anchor tag’s default styles, update the styles in your client’s
    `index.html` file so that `a` tags inherit `color`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了避免即将售罄的项目因为锚标签的默认样式而变成蓝色，更新客户端的 `index.html` 文件中的样式，使 `a` 标签继承 `color`。
- en: Listing 11.49 index.html
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.49 index.html
- en: '[PRE48]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you were to implement a naive validation for this, you could add a test that
    adds items through an application action and checks the new item’s `href`. When
    checking the item’s `href`, the test assumes that its value will remain the same.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算实现一个简单的验证，你可以添加一个通过应用程序操作添加项目并检查新项目的 `href` 的测试。当检查项目的 `href` 时，测试假设其值将保持不变。
- en: Listing 11.50 itemSubmission.spec.js
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.50 itemSubmission.spec.js
- en: '[PRE49]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Expects the anchor tag within the list item for cheesecakes to contain an
    href attribute pointing to a recipe’s URL, which came from the Recipe Puppy API
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 期望列表项中的锚标签包含一个指向来自 Recipe Puppy API 的菜谱 URL 的 `href` 属性
- en: The problem with this test is that it may fail because you don’t have any control
    over the responses that the Recipe Puppy API will provide. If the first recipe’s
    URL changes, for example, your test will fail, even though you haven’t changed
    your application’s code and it still works perfectly.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的问题在于它可能会失败，因为你无法控制 Recipe Puppy API 将提供的响应。例如，如果第一个菜谱的 URL 发生变化，你的测试将失败，即使你没有更改你的应用程序代码，它仍然可以完美运行。
- en: To solve this problem, you can use Cypress’s `cy.server` and `cy.route` methods
    to intercept this request, prevent it from getting to the server, and provide
    a canned response.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，你可以使用 Cypress 的 `cy.server` 和 `cy.route` 方法来拦截这个请求，阻止它到达服务器，并提供一个预定义的响应。
- en: Because Cypress resets your server’s configuration between each test, you must
    configure your canned response within a `beforeEach` hook so that it applies to
    every test in that test suite, as shown in the next piece of code.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Cypress 在每个测试之间重置你的服务器配置，所以你必须在一个 `beforeEach` 钩子中配置你的预定义响应，以便它适用于该测试套件中的每个测试，如下一段代码所示。
- en: Listing 11.51 itemSubmission.spec.js
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.51 itemSubmission.spec.js
- en: '[PRE50]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Intercepts GET requests sent to /inventory/cheesecake, and always provides
    the same response to them
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 拦截发送到 /inventory/cheesecake 的 GET 请求，并对它们始终提供相同的响应
- en: ❷ Expects an item from the item list to always contain the URL defined in the
    canned response
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 期望项目列表中的项目始终包含预定义响应中定义的 URL
- en: After this update, your test will *always* pass because it doesn’t depend on
    the Recipe Puppy API anymore. Instead, you have used `cy.server` and `cy.route`
    to obtain full control over your server’s response.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，你的测试将始终通过，因为它不再依赖于 Recipe Puppy API。相反，你已经使用了 `cy.server` 和 `cy.route` 来完全控制你的服务器响应。
- en: NOTE Alternatively, you could allow the request to reach the server and manipulate
    its response. In this case, for example, I could’ve let the server respond and
    provided a callback for Cypress to manipulate the server’s response and change
    *exclusively* the fields that come from RecipePuppy’s API.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另外，你也可以允许请求到达服务器并操纵其响应。在这种情况下，例如，我本可以让服务器响应，并为 Cypress 提供一个回调来操纵服务器的响应并仅更改来自
    RecipePuppy API 的字段。
- en: The disadvantage with manipulating your server’s response is that the server
    still needs to reach the Recipe Puppy API. Therefore, if the Recipe Puppy API
    yields a response the server can’t handle, the test will fail.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 操作你服务器响应的缺点是服务器仍然需要到达 Recipe Puppy API。因此，如果 Recipe Puppy API 提供的响应是服务器无法处理的，测试将失败。
- en: Besides not making your tests fully deterministic, if you need to provide credentials
    to invoke a third-party API, the process of running your tests will become more
    complicated because everyone who wants to run tests will need access to those
    credentials.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不会使你的测试完全确定之外，如果你需要提供凭证来调用第三方 API，运行测试的过程将变得更加复杂，因为每个想要运行测试的人都需要访问这些凭证。
- en: Besides making the process of running tests more complicated, requiring access
    to credentials during your tests can compromise the secrecy of your keys.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使测试过程更加复杂，需要在测试期间访问凭证可能会泄露你的密钥的机密性。
- en: Furthermore, if you have to pay for API calls, your tests will generate extra
    costs.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你必须为API调用付费，你的测试将产生额外的费用。
- en: In addition to providing a canned response for a route, you can use `cy.server`
    to trigger edge cases that you couldn’t easily simulate otherwise. By using this
    technique, you can, for example, simulate situations like the server being unavailable
    or its response being delayed.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为路由提供一个预定义的响应外，您还可以使用`cy.server`来触发其他情况下难以模拟的边缘情况。通过使用此技术，例如，你可以模拟服务器不可用或其响应延迟的情况。
- en: Simulating these kinds of situations allows you to validate whether your application
    can handle errors without demanding that you introduce indeterminism into your
    tests or change the application under test’s code.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟这些类型的场景允许你验证你的应用程序是否能够处理错误，而无需在你的测试中引入不可预测性或更改待测试应用程序的代码。
- en: Even though using stubs is helpful to prevent flaky tests, you should use this
    technique judiciously to avoid compromising your tests’ scope and, therefore,
    their reliability.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用模拟可以帮助防止测试不稳定，但你应谨慎使用此技术，以避免损害测试的范围，从而影响其可靠性。
- en: When you stub a request’s response, you’re limiting a test’s scope and preventing
    your tests from covering any of the server’s code. If you mock every HTTP request
    your inventory management application makes, for example, you wouldn’t be able
    to catch bugs caused by your server returning an incorrect quantity of items when
    someone submits the form.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当你模拟一个请求的响应时，你限制了测试的范围，并阻止你的测试覆盖服务器上的任何代码。例如，如果你模拟了库存管理应用程序发出的每个HTTP请求，那么你将无法捕捉到当有人提交表单时，服务器返回错误数量项所引起的错误。
- en: To determine whether you should stub an HTTP request, you must consider whether
    you have control over the request’s response. If you can’t predict what the request’s
    response will be, you should use a stub to make your tests deterministic. In every
    other case, I’d recommend avoiding stubs as much as you can—unless you want to
    test your UI *exclusively*.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定你是否应该模拟一个HTTP请求，你必须考虑你是否能控制请求的响应。如果你无法预测请求的响应将是什么，你应该使用模拟来使你的测试具有确定性。在其他所有情况下，我建议尽可能避免使用模拟——除非你只想测试你的UI
    *专门*。
- en: Stubbing functions
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟函数
- en: You can’t test code that depends on a function whose result you can’t predict.
    For example, you can’t write deterministic tests for code that depends on an indeterministic
    `Math.random`. It’s impossible to write deterministic tests for indeterministic
    code because in these situations, you can’t determine what the expected result
    should be.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法测试依赖于一个你无法预测其结果的函数的代码。例如，你不能为依赖于不可预测的`Math.random`的代码编写确定性测试。对于不可预测的代码，无法编写确定性测试，因为这些情况下，你无法确定预期的结果应该是什么。
- en: Assume that, for example, instead of always using the URL to the first recipe
    your server returns when listing items, you had to pick a random recipe from the
    list and use its URL.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你不必总是使用服务器返回的第一个菜谱的URL来列出项目，而是必须从列表中随机选择一个菜谱并使用其URL。
- en: Listing 11.52 domController.js
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.52 domController.js
- en: '[PRE51]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Picks a random number representing an index in the list of recipes obtained
    from the server
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从服务器获取的菜谱列表中选择一个代表索引的随机数字
- en: ❷ Uses a random index to select which recipe’s URL to use for the anchor tag
    in the list item
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用随机索引来选择在列表项中使用的哪个菜谱的URL
- en: NOTE The client you’ll find in the `chapter11` folder of this book’s GitHub
    repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)
    already includes this update.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在本书GitHub仓库的`chapter11`文件夹中找到的客户端[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)已经包含了这个更新。
- en: If you’re updating the application from chapter 6 yourself, make sure to run
    `npm run build` again after this change.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自己更新第6章的应用程序，请确保在此更改后再次运行`npm run build`。
- en: In this case, even though you can predict your server’s response, you can’t
    predict which of the recipes in that response your application will select. This
    indeterminism causes your tests to become flaky.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使你可以预测服务器的响应，你也无法预测应用程序将选择响应中的哪个菜谱。这种不可预测性导致你的测试变得不稳定。
- en: To solve this problem, you will stub `Math.random` to determine its result and
    thus be able to predict to which link your list item will point.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您将存根 `Math.random` 以确定其结果，从而能够预测您的列表项将指向哪个链接。
- en: In Cypress, stubbing can be done through `cy.stub`, which takes an object as
    its first argument and a method’s name as the second.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cypress 中，可以通过 `cy.stub` 来进行存根，它将对象作为第一个参数，将方法名称作为第二个参数。
- en: Go ahead and use `cy.stub` in your tests to cause the `window` object’s `Math.random`
    method to always return `0.5`, which will cause your application always to pick
    the second recipe in the server’s response.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续在您的测试中使用 `cy.stub`，使 `window` 对象的 `Math.random` 方法始终返回 `0.5`，这将导致您的应用程序始终选择服务器响应中的第二个菜谱。
- en: Listing 11.53 itemSubmission.spec.js
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.53 itemSubmission.spec.js
- en: '[PRE52]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ Causes the window’s Math.random method to always return 0.5
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致窗口的 Math.random 方法始终返回 0.5
- en: After stubbing `Math.random`, you will be able to determine which URL your application
    will use.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在存根 `Math.random` 之后，您将能够确定应用程序将使用哪个 URL。
- en: Now, update your assertion so that it expects the list item’s `href` attribute
    to correspond to the second recipe’s URL.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新您的断言，使其期望列表项的 `href` 属性与第二个菜谱的 URL 相对应。
- en: Listing 11.54 itemSubmission.spec.js
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.54 itemSubmission.spec.js
- en: '[PRE53]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Causes the window’s Math.random method to always return 0.5
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致窗口的 Math.random 方法始终返回 0.5
- en: ❷ Expects the href property in an item list’s anchor tag to be equal to the
    second URL in the canned response
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 期望列表项的锚标签中的 href 属性等于预定义响应中的第二个 URL
- en: After this change, your tests will become deterministic because `Math.random`
    will always yield the same result. As long as the application under test remains
    unchanged, your tests should pass.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改后，您的测试将变得确定化，因为 `Math.random` 将始终产生相同的结果。只要测试中的应用程序保持不变，您的测试应该会通过。
- en: Whenever you have methods whose return value you can’t predict, you should stub
    them so that you can determine what should be the expected result.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您有无法预测返回值的函数时，您应该对它们进行存根处理，以便您可以确定预期的结果。
- en: Besides making indeterministic methods deterministic, you can use stubs to prevent
    native methods like the window’s `confirm` or `prompt` methods from being invoked
    and provide canned responses to them.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使不确定的方法确定化之外，您还可以使用存根来防止调用原生方法，如窗口的 `confirm` 或 `prompt` 方法，并向它们提供预定义的响应。
- en: Because stubs also include a spy’s functionality, you can then check whether
    those methods have been called and assert on their usage.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 因为存根也包括间谍的功能，所以您可以检查这些方法是否被调用，并对它们的用法进行断言。
- en: TIP In addition to using stubs, you can also use spies in your Cypress tests.
    As previously mentioned, spies preserve a method’s original implementation but
    add instrumentation to it so that you can inspect the method’s usage.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：除了使用存根之外，您还可以在 Cypress 测试中使用间谍。如前所述，间谍保留方法的原实现，但对其添加了仪器，以便您可以检查方法的用法。
- en: You can find Cypress’s official guidance on stubs and spies at [https://docs.cypress.io/guides/guides/stubs-spies-and-clocks.html](https://docs.cypress.io/guides/guides/stubs-spies-and-clocks.html).
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Cypress 的官方指南中找到有关存根和间谍的说明，请参阅 [https://docs.cypress.io/guides/guides/stubs-spies-and-clocks.html](https://docs.cypress.io/guides/guides/stubs-spies-and-clocks.html)。
- en: Cypress’s stubs are also useful when you need to stub APIs that cause the client
    to navigate to a different page or when your tests must simulate a method’s failure.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要存根导致客户端导航到不同页面的 API 或您的测试必须模拟方法失败时，Cypress 的存根非常有用。
- en: Personally, I try to avoid stubs as much as I can because, when writing UI-based
    end-to-end tests, I want to simulate my application’s run-time behavior as accurately
    as possible to obtain reliable guarantees.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我尽量避免使用存根，因为在编写基于 UI 的端到端测试时，我希望尽可能准确地模拟应用程序的运行时行为，以获得可靠的保证。
- en: By stubbing methods, I’d prevent the application from behaving as it would without
    my intervention, and, therefore, I may not catch bugs that could occur at run
    time.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 通过存根方法，我将防止应用程序在没有我的干预下表现正常，因此我可能无法捕获在运行时可能发生的错误。
- en: I’d recommend you to use stubs only when dealing with indeterministic behavior
    or when handling native functionality with which you can’t or don’t want to interact,
    such as triggering alerts or prompts, managing navigation events, or simulating
    failures that you couldn’t simulate otherwise.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您仅在处理不确定行为或处理无法或不想与之交互的本地功能时使用存根，例如触发警报或提示、管理导航事件或模拟您无法以其他方式模拟的失败。
- en: 11.3.3 Retrying tests
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 重试测试
- en: Imagine, for example, that you’ve discovered that a few of your tests are flaky,
    but you currently don’t have time to fix them because you have an urgent feature
    to deliver.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你发现了一些测试是易变的，但你目前没有时间修复它们，因为你有一个紧急功能要交付。
- en: You’re a few weeks away from Christmas, and the bakery’s staff estimates that
    they could triple December’s profit by delivering a feature that allows clients
    to customize their Christmas dessert.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在离圣诞节还有几周时间，面包店的员工估计，通过提供一个允许客户定制圣诞甜点的功能，他们可以将12月的利润翻三倍。
- en: In that case, you don’t want to risk causing the bakery to miss out on such
    an important revenue opportunity because you had to spend time making tests deterministic.
    Therefore, you will focus *exclusively* on the feature, not on updating your tests.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不想因为不得不花费时间使测试确定性而使面包店错失这样重要的收入机会。因此，你将专注于**专门**于功能，而不是更新你的测试。
- en: Delivering this feature on time causes an immediate, significant, and measurable
    positive impact in the business. Making tests deterministic, on the other hand,
    is a long-term investment.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 及时交付这个功能会对业务产生立即的、显著的、可衡量的积极影响。另一方面，使测试确定性的则是长期投资。
- en: Nonetheless, when building the new feature, you still want to extract value
    from your tests because they can save you the time you’d have to spend doing manual
    testing. Furthermore, these tests would make you more confident that you haven’t
    broken your application.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在构建新功能时，你仍然希望从测试中提取价值，因为它们可以节省你进行手动测试所需的时间。此外，这些测试会使你更有信心，因为你没有破坏你的应用程序。
- en: To extract value from your tests, even though they are flaky, you can configure
    your end-to-end testing tool to retry your tests when they fail.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从你的测试中提取价值，即使它们是易变的，你也可以配置你的端到端测试工具，在测试失败时重试它们。
- en: If you’re confident that your tests pass most of the time and that they fail
    only because of indeterministic behavior, you can retry them twice or thrice and
    hedge against how unlikely it would be for your tests to fail in every attempt.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确信你的测试大多数时候都能通过，而且它们失败只是因为不确定的行为，你可以尝试两次或三次，并防范你的测试在每次尝试中都失败的可能性。
- en: Assume, for example, that while implementing the new feature, you’ve accidentally
    introduced a bug that causes every cart’s price to be multiplied by two on every
    checkout. As long as this bug happens on *every* checkout, your tests *will* fail
    no matter how many times you retry them.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在实现新功能时，你意外引入了一个错误，导致每个购物车的价格在结账时都翻倍。只要这个错误在每次结账时都发生，无论你重试多少次，你的测试都会失败。
- en: On the other hand, if a customer’s cart price was likely to be incorrect only
    half of the time, retrying failing tests could cause this bug to go unnoticed.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果客户的购物车价格可能只有一半的时间是正确的，重试失败的测试可能会导致这个错误被忽视。
- en: Your tests wouldn’t alert you, if, for example, a test failed twice because
    of this bug but passed in a third attempt when, luckily, this bug didn’t occur,
    and your source of indeterministic behavior yielded the result your test expected.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的测试因为这种错误失败了两次，但在第三次幸运地没有发生这种错误时通过了，你的测试源的不确定性产生了你测试预期的结果，你的测试不会提醒你。
- en: Important Flaky tests can catch only consistent bugs. Your tests can’t distinguish
    failures caused by bugs from failures caused by poorly written tests.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 重要易变的测试只能捕获一致的错误。你的测试无法区分由错误引起的失败和由编写不良的测试引起的失败。
- en: Even though not being able to catch these kinds of intermittent bugs reliably
    is definitely a problem, it’s still better to have suboptimal tests than to have
    none.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无法可靠地捕获这些类型的间歇性错误确实是一个问题，但仍然比没有测试要好。
- en: 'Once you finish the urgent feature the bakery needs for Christmas, Louis would
    undoubtedly be delighted to give *you* a gift: time to make tests deterministic
    so that you can move even faster and more confidently next time.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了面包店需要的紧急圣诞功能，路易斯无疑会非常高兴地给你一个礼物：时间来使测试确定性，这样你下次可以更快、更有信心地行动。
- en: Deciding whether you should retry your tests, as you’ve seen, is a business
    decision more than a technical decision.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，决定你是否应该重试你的测试，这更多是一个商业决策，而不是技术决策。
- en: In the *ideal* software world, every test should be deterministic so that it
    can reliably catch bugs. In the *real* world, a business’s priority is to increase
    revenue and diminish costs, and you must balance the cost of having perfect tests
    and the value you will extract from them.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的软件世界中，每个测试都应该是确定性的，这样它就可以可靠地捕获错误。在现实世界中，企业的优先事项是增加收入和降低成本，你必须平衡拥有完美测试的成本和从它们中提取的价值。
- en: By configuring your end-to-end testing tool to retry failing tests, you can
    delay investing a considerable amount of time and effort into making your tests
    deterministic.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置你的端到端测试工具来重试失败的测试，你可以推迟投入大量时间和精力来使你的测试变得确定性。
- en: Delaying this investment allows you to tackle more urgent tasks while still
    extracting value from the tests you’ve written.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟这种投资可以使你在处理更紧急任务的同时，仍然从你编写的测试中提取价值。
- en: Nonetheless, retrying tests should *not* be considered a long-term solution.
    Instead, it’s a provisional strategy that empowers your team to tackle other priorities
    without compromising your test suite entirely.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，重试测试不应被视为长期解决方案。相反，它是一种临时策略，使你的团队能够在不完全牺牲测试套件的情况下处理其他优先事项。
- en: In the long run, retrying tests can cause intermittent bugs to go unnoticed,
    and, therefore, this strategy will gradually undermine your team’s confidence
    in their test suite.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，重试测试可能会导致间歇性错误被忽视，因此这种策略将逐渐削弱你团队对其测试套件的信心。
- en: Ideally, I’d recommend you to enable test retries only during periods in which
    you have tight deadlines to meet and you can’t spend time updating your tests.
    Once you’ve met those deadlines, you should advocate for time to make your tests
    deterministic so that you can continue to move fast and confidently. In general,
    I would advise you to keep test retries disabled most of the time.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我建议你只在有紧迫的截止日期要满足且无法花时间更新测试的时期启用测试重试。一旦你满足了这些截止日期，你应该争取时间来使你的测试变得确定性，这样你就可以继续快速且自信地前进。一般来说，我会建议你大多数时间保持测试重试关闭。
- en: Having explained *why* test retries are helpful, I’ll show you how to enable
    them.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 解释了为什么测试重试是有帮助的之后，我将向你展示如何启用它们。
- en: To configure the number of times Cypress should attempt to rerun your tests
    if they fail, you can use the `runMode` and `openMode` options. These options
    should live within an object assigned to the `retries` property of your `cypress.json`
    configuration file.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Cypress 在测试失败时应该尝试重新运行测试的次数，你可以使用 `runMode` 和 `openMode` 选项。这些选项应该位于分配给
    `cypress.json` 配置文件中 `retries` 属性的对象内。
- en: The `openMode` option determines how many times Cypress should retry your tests
    when running them using Cypress’s GUI through the `cypress open` command. The
    `runMode` option determines the number of retries when running tests headlessly
    by using the `cypress run` command.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`openMode` 选项确定当使用 `cypress open` 命令通过 Cypress 的 GUI 运行测试时，Cypress 应该重试你的测试多少次。`runMode`
    选项确定当使用 `cypress run` 命令无头运行测试时的重试次数。'
- en: To retry your tests thrice when running them using `cypress run` but disable
    retries when using Cypress’s GUI, for example, set the `runMode` option to three
    and the `openMode` option to zero, as shown next.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行 `cypress run` 时重试测试三次，但在使用 Cypress 的 GUI 时禁用重试，例如，将 `runMode` 选项设置为三，将
    `openMode` 选项设置为零，如下所示。
- en: Listing 11.55 cypress.json
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.55 cypress.json
- en: '[PRE54]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Configures Cypress to rerun failing tests thrice when executing its binary’s
    run command
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Cypress 在执行其二进制文件的 run 命令时重试失败的测试三次
- en: ❷ Configures Cypress not to rerun failing tests when executing its binary’s
    open command
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置 Cypress 在执行其二进制文件的 open 命令时不要重新运行失败的测试
- en: Alternatively, if you know exactly which tests fail due to a source of indeterministic
    behavior, you can configure Cypress to retry those tests *exclusively*.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你确切知道哪些测试由于不确定性行为的原因而失败，你可以配置 Cypress 仅重试这些测试。
- en: Listing 11.56 example.spec.js
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.56 example.spec.js
- en: '[PRE55]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Configures Cypress to rerun failing tests in this describe block thrice when
    running them headlessly and not to rerun failing tests when using Cypress’s UI
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Cypress 在无头运行时在这个 describe 块中重试失败的测试三次，而在使用 Cypress 的 UI 时不重试失败的测试
- en: '**Enabling retries for only a few tests is a much better approach than enabling
    retries for every test**. By selectively enabling this feature, the tests that
    have it disabled will still be able to catch intermittent bugs.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅对少数测试启用重试比对所有测试启用重试要好得多**。通过选择性地启用此功能，禁用此功能的测试仍然能够捕获间歇性错误。'
- en: Selectively enabling test retries causes your test suite as a whole to be more
    thorough and diminishes the impact that retrying tests could have in your bug-detection
    mechanisms.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性地启用测试重试可以使你的整个测试套件更加彻底，并减少重试测试对你的错误检测机制可能产生的影响。
- en: 11.4 Running tests on multiple browsers
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 在多个浏览器上运行测试
- en: 'Ice cream: I’ve hardly ever met anyone who doesn’t like it. A few people may
    not *love* it, but ask someone about ice cream, and they’ll tell you their favorite
    flavor.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 冰淇淋：我几乎没有遇到过不喜欢它的人。可能有些人可能并不**热爱**它，但问问别人关于冰淇淋，他们会告诉你他们最喜欢的口味。
- en: Because there are so many flavors to choose from, ice cream is the kind of dessert
    that caters to all audiences.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有这么多风味可供选择，冰淇淋是一种满足所有受众的甜点。
- en: Web browsers, similarly, come in multiple “flavors.” Some are more popular than
    others, but, still, everyone gets to choose the browser they like the most.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，网络浏览器也有多种“风味”。有些比其他更受欢迎，但无论如何，每个人都可以选择他们最喜欢的浏览器。
- en: Another similarity between browsers and ice cream is that no matter which flavor
    you pick, you expect it to be good. It doesn’t matter whether you’re going for
    the classic vanilla cone or the exotic açaí berry, it better make your eyes gleam.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和冰淇淋之间的另一个相似之处在于，无论你选择哪种口味，你都会期望它是好的。无论是追求经典的香草锥还是异国情调的阿萨伊浆果，它最好让你的眼睛发光。
- en: When it comes to browsers, customers have a similar expectation. They expect
    your application to work regardless of whether they access it through the traditional
    Internet Explorer or the newer Chrome and Firefox.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到浏览器时，客户有类似的期望。他们期望无论他们通过传统的Internet Explorer还是较新的Chrome和Firefox访问，你的应用程序都能正常工作。
- en: It’s great for the web that all these different browsers exist because they
    create a healthy, competitive environment. The talented folks who work on these
    amazingly complex pieces of software are highly skilled and are always looking
    for better and more efficient ways to solve problems.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络来说，存在这么多不同的浏览器真是太好了，因为它们创造了一个健康、竞争的环境。致力于这些令人惊叹的复杂软件的才华横溢的人们技术高超，并且总是寻找更好、更高效的方法来解决问题。
- en: The problem with having so many different options is that, despite the brilliance
    of their authors, not all browsers run JavaScript in the same way. As new features
    come out, some browsers may release them more quickly than others, and there may
    be bugs or misunderstandings in these features’ implementation.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多不同选项的问题在于，尽管它们的作者非常聪明，但并非所有浏览器都以相同的方式运行JavaScript。随着新功能的推出，一些浏览器可能比其他浏览器更快地发布它们，并且在这些功能的实现中可能存在错误或误解。
- en: These differences cause the same program to yield a particular result in one
    browser and a completely different result in another.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异导致相同的程序在一个浏览器中产生特定的结果，而在另一个浏览器中则产生完全不同的结果。
- en: To avoid having your program behaving differently depending on your customers’
    browsers, you should test your application in different environments so that you
    can catch any failures related to a particular one.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免你的程序根据客户的浏览器表现不同，你应该在不同的环境中测试你的应用程序，这样你就可以捕捉到与特定浏览器相关的任何故障。
- en: Even though it’s important to test your application in various browsers, you
    do *not* necessarily *need* to support every browser out there.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在多种浏览器中测试你的应用程序很重要，但你并不**一定**需要支持所有浏览器。
- en: Instead of trying to support every possible browser, you should check which
    browsers your customers tend to use and define which ones you should support.
    Once you have made this decision, you can then focus on running tests only in
    the environments that interest you and your business.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图支持所有可能的浏览器，你应该检查你的客户倾向于使用哪些浏览器，并定义你应该支持哪些。一旦你做出了这个决定，你就可以专注于只在你和你的业务感兴趣的环境中运行测试。
- en: NOTE For the well-being of the web, which is, in my opinion, humanity’s most
    significant engineering achievement to this date, I’d recommend readers to support
    multiple browsers.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：为了网络的福祉，在我看来，这是迄今为止人类最重要的工程成就，我建议读者支持多个浏览器。'
- en: By giving users a choice, you contribute to making the web more democratic and
    foster a competitive environment in which multiple organizations can collaborate
    to innovate and define standards.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给用户选择权，你有助于使网络更加民主，并促进一个多组织可以合作创新和定义标准的竞争环境。
- en: To test your applications in multiple browsers, the two most common strategies
    developers usually adopt are to run their test suite inside a browser or to have
    their whole application run within the browser and then test it with a tool like
    Cypress or Selenium.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在多个浏览器中测试你的应用程序，开发者通常采用的两种最常见策略是在浏览器内运行测试套件，或者让整个应用程序在浏览器内运行，然后使用 Cypress
    或 Selenium 等工具进行测试。
- en: The main advantage of having your test suite run *inside* the browser is that
    you can have more granular tests and, therefore, obtain more precise feedback.
    Additionally, if you can execute the same test suite in a browser and Node.js,
    you can diminish your costs by not having to spend time writing new tests for
    a different tool.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器内运行测试套件的主要优势是可以进行更细粒度的测试，因此可以获得更精确的反馈。此外，如果你可以在浏览器和 Node.js 中执行相同的测试套件，你可以通过不必为不同的工具编写新测试来降低成本。
- en: The problem with running your test suite inside the browser is that, depending
    on the testing tools you’re using, your tools may not be supported by the browser
    because they rely on resources that are available only in a platform like Node.js.
    If your test runner needs access to the filesystem, for example, it won’t be able
    to run in the browser.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器内运行测试套件的问题在于，根据你使用的测试工具，你的工具可能不受浏览器支持，因为它们依赖于仅在 Node.js 这样的平台上可用的资源。例如，如果你的测试运行器需要访问文件系统，它将无法在浏览器中运行。
- en: Running UI-based tests by controlling a real browser, on the other hand, is
    more time-consuming but yields more reliable results. Because their scope is broader,
    and because they simulate your user’s actions more accurately, they’re more representative
    of your application’s run-time behavior.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过控制真实浏览器来运行基于 UI 的测试，虽然更耗时，但结果更可靠。因为它们的范围更广，并且能更准确地模拟用户的操作，所以它们更能代表应用程序的运行时行为。
- en: When deciding which of these approaches to adopt, you must consider the time
    you have available and the value each strategy will deliver.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定采用哪种方法时，你必须考虑你可用的时间和每种策略将带来的价值。
- en: If you have the time and resources to write tests using tools like Selenium
    or Cypress, I’d recommend you to do so. Otherwise, merely configuring your existing
    test suite to run in a browser is already a great start. Running existing tests
    in a browser will deliver a considerable amount of value and, in some cases, require
    minimal effort.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有时间和使用 Selenium 或 Cypress 等工具编写测试，我建议你这样做。否则，仅仅配置你的现有测试套件以在浏览器中运行就已经是一个很好的开始了。在浏览器中运行现有测试将带来相当大的价值，在某些情况下，可能只需要最小的努力。
- en: 11.4.1 Using a testing framework to run tests within a browser
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 在浏览器内使用测试框架运行测试
- en: To execute an existing test suite within a browser, I’d recommend you to use
    a tool like Karma.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器内执行现有的测试套件，我建议你使用像 Karma 这样的工具。
- en: Karma spawns a web server that serves a page containing your code and your tests—including
    the test framework that runs them. By pointing a browser to that page, you can
    then execute your tests *within* the browser.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 启动一个 Web 服务器，该服务器提供包含你的代码和测试（包括运行它们的测试框架）的页面。通过将浏览器指向该页面，你可以在浏览器内执行你的测试。
- en: As tests run, the browser communicates with the Karma server through WebSockets
    to report passing and failing tests.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试的运行，浏览器通过 WebSocket 与 Karma 服务器通信，以报告通过和失败的测试。
- en: Unfortunately, Jest, the primary tool I’ve used throughout the book, can’t easily
    be executed within the browser because it depends on Node.js-specific resources.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，本书中主要使用的 Jest 工具无法轻松地在浏览器中执行，因为它依赖于 Node.js 特定的资源。
- en: If that’s something you’d like to do, I’d highly recommend looking into Mocha,
    the second most popular JavaScript test runner.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望这样做，我强烈建议你考虑 Mocha，这是第二受欢迎的 JavaScript 测试运行器。
- en: Because Mocha doesn’t depend on Node.js-specific resources, it can run within
    browsers. Additionally, its API is almost identical to Jest.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Mocha 不依赖于 Node.js 特定的资源，它可以在浏览器中运行。此外，它的 API 几乎与 Jest 相同。
- en: Therefore, if running your tests in multiple browsers is a priority for your
    project, it will be easy to migrate from Jest to Mocha.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你的项目将运行多个浏览器作为优先事项，从 Jest 迁移到 Mocha 将会很容易。
- en: When considering migrating your tests, you must also take into account how heavily
    you rely on features that exist exclusively in Jest. Given that Mocha doesn’t
    include tools for managing test doubles and running assertions, you’ll have to
    look into other tools like Sinon, Proxyquire, and Chai.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑迁移测试时，您还必须考虑您对仅存在于 Jest 中的功能的依赖程度。鉴于 Mocha 不包括管理测试替身和运行断言的工具，您将不得不考虑其他工具，如
    Sinon、Proxyquire 和 Chai。
- en: If it would be too time-consuming for you to migrate your tests, it will probably
    be less costly and more beneficial to write different tests using tools like Cypress
    or Selenium. Otherwise, if you don’t depend on these features, or if you’re starting
    a new project, Mocha may be a viable solution.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迁移测试对您来说太耗时，那么使用 Cypress 或 Selenium 等工具编写不同测试可能成本更低且更有益。否则，如果您不依赖这些功能，或者您正在启动一个新项目，Mocha
    可能是一个可行的解决方案。
- en: 11.4.2 Running UI-based tests in multiple browsers
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 在多个浏览器中运行基于 UI 的测试
- en: If you decide to run UI-based tests in multiple browsers, you must observe which
    tools can interface with the browsers you wish to support.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定在多个浏览器中运行基于 UI 的测试，您必须观察哪些工具可以与您希望支持的浏览器进行接口。
- en: Cypress, for example, can run tests only in Edge, Firefox, Chrome, and Electron.
    Therefore, if you need to support Internet Explorer, you will need to choose a
    different tool.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Cypress 只能在 Edge、Firefox、Chrome 和 Electron 中运行测试。因此，如果您需要支持 Internet Explorer，您将需要选择不同的工具。
- en: Given that the compatibility among browsers has become better over recent years,
    you will still obtain reliable results even if you decide to run tests exclusively
    in Edge, Chrome, and Firefox. Again, in this case, you’d need to consider your
    time and resources to determine whether it’s worth using a friendly tool like
    Cypress, which allows you to write tests quickly, or whether you’d need a more
    complex yet multifaceted solution.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 由于近年来浏览器之间的兼容性变得更好，即使您决定仅在 Edge、Chrome 和 Firefox 中运行测试，您仍然可以获得可靠的结果。再次强调，在这种情况下，您需要考虑您的时间和资源，以确定使用像
    Cypress 这样的友好工具（它允许您快速编写测试）是否值得，或者您是否需要一个更复杂但功能更全面的解决方案。
- en: Among the alternatives available, Selenium is the one that provides the best
    support for multiple browsers. Because its architecture decouples browser automation
    APIs from the drivers that control different browsers, it’s easier to find the
    drivers you need for the browsers you want to target.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用的替代方案中，Selenium 是提供多浏览器最佳支持的解决方案。由于其架构将浏览器自动化 API 与控制不同浏览器的驱动程序解耦，因此更容易找到您想要针对的浏览器的驱动程序。
- en: In addition to the vast array of drivers available, you can also use Selenium
    Grid to run your tests in parallel across multiple machines, each with a different
    browser, running on top of a different operating system.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可用的各种驱动程序之外，您还可以使用 Selenium Grid 在多台机器上并行运行测试，每台机器运行不同的浏览器，并基于不同的操作系统。
- en: Besides giving you more flexibility in terms of having multiple environments
    in which your tests will run, Grid speeds up your test executions by running tests
    in parallel across multiple machines.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在多个环境中运行测试提供更多灵活性之外，Grid 通过在多台机器上并行运行测试来加速测试执行。
- en: The main disadvantage of adopting Selenium is setting up the necessary infrastructure
    to run your tests and allocating the time and resources required to create tests
    given that they’re usually more challenging to write.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 Selenium 的主要缺点是设置运行测试所需的必要基础设施，以及分配创建测试所需的时间和资源，因为它们通常更难以编写。
- en: 11.5 Visual regression tests
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 视觉回归测试
- en: Presentation matters. Over the years, as Louis ran his baking business, he noticed
    that the more time he’d invest in making the desserts look attractive, the more
    he’d be able to sell.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 展示很重要。多年来，随着路易斯经营他的烘焙业务，他注意到，他投入更多时间使甜点看起来更有吸引力，他就能卖出更多。
- en: When building web applications, as well as when baking a tempting batch of éclairs,
    looks are a core part of what makes your customers’ experience delightful. A lovely
    experience, in turn, tends to lead to more engaged customers and, therefore, better
    business results.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Web 应用程序时，以及当烘焙一盒诱人的泡芙时，外观是使客户体验愉悦的核心部分。反过来，愉快的体验往往会导致客户更加投入，从而带来更好的商业结果。
- en: To ensure your application *looks* right and, therefore, generates better business
    results, visual regression testing is one of the most valuable practices you can
    adopt.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的应用程序看起来正确，从而产生更好的商业结果，视觉回归测试是您可以采用的最有价值的实践之一。
- en: Visual regression tests focus on your application’s looks. To ensure that your
    application is correctly displayed, these kinds of tests compare your application’s
    looks to previously approved snapshots. The process of creating these tests is
    similar to the process of using Jest’s snapshots to validate a component’s style.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉回归测试专注于你的应用程序的外观。为了确保你的应用程序正确显示，这类测试会将你的应用程序的外观与之前批准的快照进行比较。创建这些测试的过程与使用Jest的快照验证组件样式的过程类似。
- en: The main difference between visual regression tests and Jest’s snapshot tests
    for a component’s styles is that visual regression tests compare images, not strings.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉回归测试与组件样式的Jest快照测试之间的主要区别在于，视觉回归测试比较的是图像，而不是字符串。
- en: The problem with writing these kinds of tests using Jest is that, because they
    validate a set of CSS rules, they won’t break if, for example, another component’s
    margin is too big and pushes a node to the wrong position. When such situations
    happen, your tests will still pass because the previous component’s styles will
    still match the existing snapshot.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest编写这类测试的问题在于，由于它们验证一组CSS规则，如果例如另一个组件的边距太大，导致节点移动到错误的位置，它们不会中断。当这种情况发生时，由于前一个组件的样式仍然与现有的快照匹配，你的测试仍然会通过。
- en: On the other hand, when you write visual regression tests in this kind of scenario,
    because these tests compare *images*, you’ll be alerted when something changes.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你在这种场景下编写视觉回归测试时，因为这些测试比较的是*图像*，所以当有变化发生时，你会收到提醒。
- en: My favorite tool to write these kinds of tests is Percy, whose documentation
    you can find at [https://docs.percy.io](https://docs.percy.io).
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的编写这类测试的工具是Percy，你可以在[https://docs.percy.io](https://docs.percy.io)找到它的文档。
- en: Besides easily integrating with Cypress, it facilitates collaboration across
    multiple teams in an organization. Additionally, it makes visual regression testing
    trivial, which, therefore, helps you reduce costs by delivering valuable tests
    more quickly.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与Cypress轻松集成外，它还促进了组织内多个团队之间的协作。此外，它使视觉回归测试变得简单，因此，通过快速交付有价值的测试，有助于你降低成本。
- en: In this section, you’ll learn how to use Percy to write visual regression tests
    by creating a test to validate whether your application will color in red the
    items that are about to run out of stock.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何通过创建一个测试来验证你的应用程序是否会将即将售罄的项目着色为红色来使用Percy编写视觉回归测试。
- en: To write visual regression tests with Percy, you must first install its Cypress-specific
    module with `npm install --save-dev @percy/cypress`.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Percy编写视觉回归测试，你必须首先使用`npm install --save-dev @percy/cypress`安装其Cypress特定模块。
- en: Once you have installed it, import it at the top of your `command.js` file,
    which is located in Cypress’s `support` directory.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你需要在位于Cypress的`support`目录中的`command.js`文件顶部导入它。
- en: Listing 11.57 commands.js
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.57 commands.js
- en: '[PRE56]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Imports Percy’s module for Cypress
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入Percy的Cypress模块
- en: Besides importing the necessary module within the `commands.js`, Percy also
    requires you to register with Cypress a task called `percyHealthCheck` and assign
    it the main export from Percy’s `@percy/cypress/task` namespace.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在`commands.js`中导入必要的模块外，Percy还要求你向Cypress注册一个名为`percyHealthCheck`的任务，并将其分配给Percy的`@percy/cypress/task`命名空间的主导出。
- en: To register this task, you’ll need to add the following code to the `index.js`
    file in Cypress’s `plugins` directory.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册此任务，你需要在Cypress的`plugins`目录中的`index.js`文件中添加以下代码。
- en: Listing 11.58 index.js
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.58 index.js
- en: '[PRE57]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Registers Percy’s health-check task as a Cypress task
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将Percy的健康检查任务注册为Cypress任务
- en: After these two changes, writing visual regression tests with Percy is as easy
    as calling `cy.percySnapshot` whenever you want to take a snapshot within a test.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个更改之后，使用Percy编写视觉回归测试就像在测试中想要拍摄快照时调用`cy.percySnapshot`一样简单。
- en: In the case of the test that validates a list item’s color, you can write a
    test that seeds the database with a single unit of cheesecake, visits your application’s
    page, waits for the list to be updated, and calls `cy.percySnapshot`. You can
    write this test in a new file called `itemList.spec.js` in the `integration` folder.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证列表项颜色的测试案例中，你可以编写一个测试，将单个奶酪蛋糕单元种入数据库，访问你的应用程序页面，等待列表更新，并调用`cy.percySnapshot`。你可以在`integration`文件夹中名为`itemList.spec.js`的新文件中编写这个测试。
- en: Listing 11.59 itemList.spec.js
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.59 itemList.spec.js
- en: '[PRE58]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Seeds the application’s database with a single cheesecake
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在应用程序数据库中种入单个奶酪蛋糕
- en: ❷ Visits the application’s page
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问应用程序页面
- en: ❸ Finds an entry in the item list indicating that the inventory has 1 cheesecake
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在项目列表中找到一个条目，表明库存中有1个芝士蛋糕
- en: ❹ Uses Percy to take a snapshot of the page at that point in time
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用Percy在该时间点捕获页面的快照
- en: Finally, to execute this test and be able to compare Percy’s snapshots, you
    must sign in to Percy at [Percy.io](https://percy.io) and obtain the token for
    your project, which you will assign to an environment variable when running your
    tests.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了执行此测试并能够比较Percy的快照，你必须登录到[Percy.io](https://percy.io)并获取你项目的令牌，你将在运行测试时将其分配给环境变量。
- en: NOTE Before running this test, make sure you’re on a git branch called `master`.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在运行此测试之前，请确保你在一个名为`master`的git分支上。
- en: If you haven’t created a repository in which you write this book’s code samples,
    you can create one with `git init`.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建一个用于编写本书代码示例的仓库，你可以使用`git init`来创建一个。
- en: Once you’ve obtained your token, assign it to an environment variable named
    `PERCY _TOKEN`. On Linux and Mac, you can do this by running `export` `PERCY_TOKEN
    =your_token_here` on your terminal.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了令牌，将其分配给名为`PERCY_TOKEN`的环境变量。在Linux和Mac上，你可以在终端运行`export PERCY_TOKEN =your_token_here`来做到这一点。
- en: Now, try using `NODE_ENV=development ./node_modules/.bin/percy exec—npm run
    cypress:run` to run your tests.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用`NODE_ENV=development ./node_modules/.bin/percy exec—npm run cypress:run`来运行你的测试。
- en: TIP You can make this command easier to remember by updating your NPM scripts
    so that the command that executes Cypress tests uses Percy when running them.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以通过更新你的NPM脚本来使此命令更容易记住，这样在运行Cypress测试时就会使用Percy。
- en: Listing 11.60 package.json
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.60 package.json
- en: '[PRE59]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Wraps Cypress’s run command into Percy so that Percy can upload snapshots
    to its platform
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将Cypress的运行命令包装到Percy中，以便Percy可以将其快照上传到其平台
- en: Remember to keep your Percy token safe, and do *not* add it to your `package
    .json` file.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要安全地保存你的Percy令牌，并且不要将其添加到你的`package .json`文件中。
- en: When this test runs, Percy will detect in which git branch you are, and, by
    default, if you’re on `master`, it will consider the snapshot taken to be the
    way you expect the application to look from here onward.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试运行时，Percy会检测你所在的git分支，并且默认情况下，如果你在`master`分支上，它将认为所拍摄的快照是你期望应用程序从这里开始的外观。
- en: Whenever you take a snapshot in your tests, Percy will upload it to its service.
    Once it uploads these snapshots, each test execution in branches other than `master`
    will, by default, be compared to the snapshots from test executions that happened
    on `master`.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在测试中捕获快照，Percy都会将其上传到其服务。一旦它上传了这些快照，除了`master`分支之外的其他分支上的每个测试执行默认情况下都会与在`master`分支上发生的测试执行的快照进行比较。
- en: Before merging commits, you can then require engineers or other stakeholders
    to log in to Percy’s service to approve the new snapshots.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并提交之前，你可以要求工程师或其他利益相关者登录到Percy的服务以批准新的快照。
- en: Having other stakeholders approve these snapshots instills more confidence in
    each deployment and allows other members of the team to easily validate whether
    the application looks as they expect without creating communication overhead.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 让其他利益相关者批准这些快照可以增加每个部署的信心，并允许团队成员轻松验证应用程序是否如他们所期望，而无需产生通信开销。
- en: NOTE I recommend enforcing this rule by integrating it into your pull request
    approval process. Ideally, before the team can merge any pull request, there should
    be an automated check to ensure that any visual diffs have been approved. To find
    out more about how to do that, visit Percy’s docs at [docs.percy.io](https://docs.percy.io/docs).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我建议通过将其集成到你的pull request审批流程中来强制执行此规则。理想情况下，在团队可以合并任何pull request之前，应该有一个自动检查来确保任何视觉差异已被批准。要了解更多关于如何做到这一点，请访问Percy的文档[docs.percy.io](https://docs.percy.io/docs)。
- en: Once you’ve had the chance to execute your tests on `master`, to see how Percy’s
    approval process looks, check out another branch using, for example, `git checkout
    -b new-feature`, and rerun your tests.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有机会在`master`分支上执行你的测试，以查看Percy的审批流程看起来如何，你可以使用例如`git checkout -b new-feature`来检查另一个分支，并重新运行你的测试。
- en: After you’ve rerun tests in another branch, log in to Percy’s platform, and
    you’ll see that your latest build says it needs to be approved because the snapshots
    didn’t match.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个分支上重新运行测试后，登录到Percy的平台，你会看到最新的构建表示需要批准，因为快照不匹配。
- en: By clicking to see the side-by-side comparison of both snapshots, you’ll notice
    that they don’t match because there’s a different timestamp in the action log
    entries in each snapshot.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击查看两个快照的并排比较，你会注意到它们不匹配，因为每个快照中的操作日志条目中都有一个不同的时间戳。
- en: To solve this problem and have your new snapshot automatically approved, you
    can either mock the timestamp so that it’s always the same, or you can apply a
    specific CSS rule to set the action log’s visibility to `hidden` when running
    within Percy.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并使你的新快照自动获得批准，你可以模拟时间戳使其始终相同，或者你可以应用特定的 CSS 规则，在运行于 Percy 时将操作日志的可见性设置为
    `hidden`。
- en: Given I’ve previously demonstrated how to use fake timers in Cypress, in this
    section, I’ll use a different strategy and write a little bit of CSS in `index.html`
    to hide action log entries from the tests.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我之前已经演示了如何在 Cypress 中使用模拟计时器，在本节中，我将使用不同的策略，并在 `index.html` 中编写一些 CSS 代码来隐藏测试中的操作日志条目。
- en: For that, my CSS will use a media query that hides items only for Percy.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我的 CSS 将使用一个媒体查询，只为 Percy 隐藏项目。
- en: Listing 11.61 index.html
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.61 index.html
- en: '[PRE60]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Hides the action log entries exclusively in Percy’s snapshots
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在 Percy 的快照中隐藏操作日志条目
- en: After a test execution on `master`, which uploads this test’s snapshot to Percy,
    you’ll then have a stable snapshot to which you’ll compare future test executions.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `master` 分支上执行测试后，该测试快照将被上传到 Percy，你将得到一个稳定的快照，你可以将其与未来的测试执行进行比较。
- en: Thanks to Percy, if you accidentally apply a CSS rule that changes the color
    of an item in the page, you’ll be asked to review the different snapshots and
    approve them. Additionally, if a developer makes an unexpected visual change,
    a product manager can intervene and refuse the snapshot approval on Percy, preventing
    unwanted code from being merged.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Percy，如果你不小心应用了一个改变页面项目颜色的 CSS 规则，你将被要求审查不同的快照并批准它们。此外，如果开发者做出了意外的视觉更改，产品经理可以介入并拒绝在
    Percy 上批准快照，防止不想要的代码被合并。
- en: Personally, I like to use Percy because it’s easy to set up and because it facilitates
    collaborating with nontechnical members of your organization.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我喜欢使用 Percy，因为它易于设置，并且它便于与组织中的非技术成员协作。
- en: If you want to use an open source solution, you can use a module like `jest-image-snapshot`,
    which allows Jest to serialize and compare image snapshots.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用开源解决方案，你可以使用像 `jest-image-snapshot` 这样的模块，它允许 Jest 序列化和比较图像快照。
- en: Summary
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Cypress, the tool with which you’ve written tests in this chapter, has retriability
    built into its APIs. When an assertion fails, or when it can’t find an element
    at first, it will keep retrying until it reaches a maximum timeout.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在本章中编写测试所使用的工具 Cypress，其 API 中内置了可重试性。当断言失败，或者它最初找不到元素时，它将不断重试，直到达到最大超时时间。
- en: When using Cypress, you can reduce the overlap among your tests by creating
    commands that can send HTTP requests directly to your server, or registering tasks
    that can run within Node.js to, for example, seed or clear database tables.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 Cypress 时，你可以通过创建可以直接发送 HTTP 请求到你的服务器的命令，或者注册可以在 Node.js 中运行的任务（例如，初始化或清除数据库表）来减少测试之间的重叠。
- en: Despite having a `.then` method, Cypress commands are *not* promises. Cypress’s
    commands collect actions in a queue that is always executed serially. This design
    decision makes it easy to write tests that accurately simulate a user’s behavior
    and prevent actions from running concurrently.
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管 Cypress 命令有 `.then` 方法，但它们**不是**承诺。Cypress 的命令将动作收集到一个队列中，该队列始终按顺序执行。这个设计决策使得编写能够准确模拟用户行为的测试变得容易，并防止动作并发运行。
- en: You can make your tests less costly to maintain by encapsulating your pages’
    structures into page objects. Page objects centralize a page’s selectors and interactions
    so that when you update your application, you don’t have to change multiple tests.
    Instead, when your page changes, you’ll have to update only your page objects.
    Additionally, page objects make tests much more readable.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将页面结构封装到页面对象中来降低测试的维护成本。页面对象集中管理页面选择器和交互，这样当你的应用程序更新时，你不需要更改多个测试。相反，当你的页面发生变化时，你只需更新你的页面对象。此外，页面对象使测试更加易于阅读。
- en: To accelerate your tests’ execution and reduce the overlap between multiple
    tests, you can use page actions. Page actions will directly invoke your application’s
    functions, and, therefore, can help you avoid having various tests which depend
    on the same pieces of UI that you already validate elsewhere. Furthermore, because
    invoking functions is quicker than filling forms and pressing buttons, page actions
    will make your tests faster.
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了加速测试的执行并减少多个测试之间的重叠，你可以使用页面操作。页面操作将直接调用你的应用程序的功能，因此可以帮助你避免有各种测试依赖于你已经在其他地方验证过的相同
    UI 部分。此外，由于调用函数比填写表单和按按钮更快，页面操作会使你的测试更快。
- en: Flaky tests undermine the confidence you have in your test suite because, when
    you have flaky tests, you can’t determine whether a test failed because of a source
    of indeterministic behavior or because your application has a bug.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不确定的测试会削弱你对测试套件的信心，因为当你有不确定的测试时，你无法确定测试失败是因为不确定行为的来源还是因为你的应用程序有错误。
- en: Most of the time, you will be able to eliminate flakiness by taking advantage
    of Cypress’s reliability features and its stubs, and by applying other techniques
    we’ve previously covered. Among these techniques is ensuring that your tests don’t
    interfere with one another and that you’re using robust selectors to find elements.
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数时候，你可以通过利用 Cypress 的可靠性功能和它的存根，以及应用我们之前介绍的其他技术来消除不确定性。这些技术中包括确保你的测试不会相互干扰，并且你正在使用健壮的选择器来查找元素。
- en: Instead of waiting for fixed amounts of time in your tests, you should wait
    for conditions to be met. By waiting for elements to appear or for requests to
    be resolved, you can avoid unnecessary delays in your tests and make them deterministic
    because they won’t depend on your server’s performance anymore.
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的测试中，不要等待固定的时间，而应该等待条件满足。通过等待元素出现或请求解决，你可以避免测试中的不必要延迟，并使测试变得确定，因为它们不再依赖于服务器的性能。
- en: If you have a test that depends on third-party APIs, you can stub their responses
    so that your test will still pass, regardless of whether those APIs are unavailable
    or they changed their response’s format.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个依赖于第三方 API 的测试，你可以模拟它们的响应，这样无论这些 API 是否不可用或它们改变了响应的格式，你的测试仍然可以通过。
- en: In case you don’t have time to fix indeterministic tests, you should ponder
    configuring Cypress to retry failing tests. Even though you should *not* consider
    this solution to be permanent because it undermines your confidence in your test
    suite, it is an excellent way to still extract value from your tests without the
    incurring the costs associated with updating them.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有时间修复不确定性的测试，你应该考虑配置 Cypress 重新尝试失败的测试。尽管你不应该将此解决方案视为永久性的，因为它会削弱你对测试套件的信心，但它是一种仍然可以从测试中提取价值而不产生更新它们的成本的优秀方法。
- en: To support various browsers, you must run your tests within them. To run tests
    within different browsers, you can either configure your test suite to run in
    multiple browsers or use a tool like Cypress to execute UI tests in the different
    environments you’d like to support.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持各种浏览器，你必须在其中运行你的测试。要运行不同浏览器的测试，你可以配置你的测试套件以在多个浏览器中运行，或者使用像 Cypress 这样的工具来在不同的环境中执行你想要支持的
    UI 测试。
- en: Visual regression tests allow you to catch visual inconsistencies in your application.
    Unlike Jest, these test’s snapshots compare images, not strings. Therefore, they
    can alert you when, for example, a component’s styles interfere with another component.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉回归测试允许你捕捉应用程序中的视觉不一致。与 Jest 不同，这些测试的快照比较的是图像，而不是字符串。因此，当例如组件的样式干扰另一个组件时，它们可以提醒你。
