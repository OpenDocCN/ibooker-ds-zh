- en: Appendix C. Modeling a bench in Blender
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 在Blender中建模长椅
- en: 'In chapters 2 and 4, we looked at creating levels with large flat walls and
    floors. But what about more detailed objects? What if you want, say, interesting
    furniture in the room? You can accomplish that by building 3D models in external
    3D art apps. Recall the definition from the introduction to chapter 4: 3D models
    are the mesh objects in the game (the 3D shapes). In this appendix, I’ll show
    you how to create a mesh object of a simple bench (figure C.1).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章和第4章中，我们探讨了创建带有大型平坦墙壁和地板的水平面。但更详细的对象怎么办？如果你想在房间里放置有趣的家具怎么办？你可以通过在外部3D艺术应用程序中构建3D模型来实现这一点。回想一下第4章引言中的定义：3D模型是游戏中的网格对象（3D形状）。在本附录中，我将向你展示如何创建一个简单的长椅网格对象（图C.1）。
- en: '![APPC_F01_Hocking3](../Images/APPC_F01_Hocking3.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F01_Hocking3](../Images/APPC_F01_Hocking3.png)'
- en: Figure C.1 Diagram of the simple bench you’re going to model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 你将要建模的简单长椅的示意图。
- en: Although appendix B lists several 3D art tools, we’ll use Blender for this exercise
    because it’s open source and thus accessible to all readers. You’ll create a mesh
    object in Blender and export that to an art asset that works with Unity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管附录B列出了几个3D艺术工具，但我们将使用Blender进行此练习，因为它开源，因此所有读者都可以访问。你将在Blender中创建一个网格对象，并将其导出为与Unity兼容的艺术资产。
- en: TIP Modeling is a huge topic, but we’ll cover only a handful of modeling functions
    that will allow you to create the bench. If you want to keep learning more about
    modeling after this chapter, look at some of the many books and tutorials on the
    subject (to start with, look at the learning resources at [www.blender.org](https://www.blender.org/)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：建模是一个很大的主题，但我们将只介绍一些建模功能，这将允许你创建长椅。如果你想在本章之后继续学习更多关于建模的知识，请查看许多关于该主题的书籍和教程（首先，查看[www.blender.org](https://www.blender.org/)的学习资源）。
- en: WARNING I used Blender 2.91, so the explanations and screenshots come from that
    version of the software. Newer versions of Blender are released frequently, and
    changes may occur to the placement of buttons or names of commands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：我使用了Blender 2.91，因此解释和截图来自该软件版本。Blender的新版本频繁发布，按钮位置或命令名称可能会有所变化。
- en: C.1 Building the mesh geometry
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 构建网格几何形状
- en: 'Launch Blender and click outside the splash screen to dismiss it; the initial
    default screen looks like figure C.2, with a cube in the middle of the scene.
    Use the middle mouse button to manipulate the camera view: click and drag to tumble,
    Shift with click-drag to pan, and Ctrl with click-drag to zoom. Left-click the
    camera to select it, hold Shift while clicking the light to select it too, and
    then press X to delete both.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Blender并点击启动屏幕外的任何位置以关闭它；初始默认屏幕看起来像图C.2，场景中间有一个立方体。使用鼠标中键来操纵相机视图：点击并拖动以旋转，按住Shift并点击拖动以平移，按住Ctrl并点击拖动以缩放。左键单击相机以选择它，按住Shift同时单击灯光以选择它，然后按X键删除两者。
- en: '![APPC_F02_Hocking3](../Images/APPC_F02_Hocking3.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F02_Hocking3](../Images/APPC_F02_Hocking3.png)'
- en: Figure C.2 The initial default screen in Blender
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.2 Blender中的初始默认屏幕
- en: Blender starts out in Object mode, which, as the name implies, enables you to
    manipulate entire objects, moving them around the scene. To edit a single mesh
    object in detail, you must select it and switch to Edit mode; figure C.3 shows
    the menu you use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Blender从对象模式开始，正如其名称所暗示的，它使你能够操纵整个对象，在场景中移动它们。要详细编辑单个网格对象，你必须选择它并切换到编辑模式；图C.3显示了您使用的菜单。
- en: '![APPC_F03_Hocking3](../Images/APPC_F03_Hocking3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F03_Hocking3](../Images/APPC_F03_Hocking3.png)'
- en: Figure C.3 Menu for switching from Object to Edit mode
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.3 从对象模式切换到编辑模式的菜单
- en: WARNING Many parts of Blender’s interface are context sensitive, and this menu
    is one. The menu items listed vary depending on which object is selected, be it
    a mesh, a camera, or something else.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Blender界面的许多部分都是上下文相关的，这个菜单就是其中之一。菜单项根据所选对象而变化，无论是网格、相机还是其他对象。
- en: When you first switch to Edit mode, Blender is set to Vertex Selection mode,
    but buttons let you switch between Vertex, Edge, and Face Selection modes (refer
    to figure C.4). The various selection modes allow you to select different mesh
    elements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次切换到编辑模式时，Blender设置为顶点选择模式，但按钮允许你在顶点、边和面选择模式之间切换（参见图C.4）。不同的选择模式允许你选择不同的网格元素。
- en: '![APPC_F04_Hocking3](../Images/APPC_F04_Hocking3.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F04_Hocking3](../Images/APPC_F04_Hocking3.png)'
- en: Figure C.4 Controls along the sides of the viewport
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4 视口侧面的控件
- en: Fundamental mouse and keyboard shortcuts in Blender
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Blender中的基本鼠标和键盘快捷键
- en: Also depicted in figure C.4 are the transform tools. As in Unity, the transforms
    are Move, Rotate, and Scale. Toward the top right of the viewport is a button
    to toggle Show Gizmo (the arrows in the scene) on and off; I recommend leaving
    that gizmo on, because otherwise you can access the transform tools only via keyboard
    shortcuts. The keyboard shortcuts in Blender are difficult to use, and the main
    reason Blender’s UI has a bad reputation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4中还包括了变换工具。与Unity一样，变换有移动、旋转和缩放。在视口的右上角有一个按钮可以切换显示Gizmo（场景中的箭头）的开和关；我建议保持Gizmo开启，因为否则你只能通过键盘快捷键来访问变换工具。Blender的键盘快捷键很难使用，这也是Blender的UI有坏名声的主要原因。
- en: 'Blender also used to force rather nonstandard mouse functionality. Though the
    use of the middle mouse button to manipulate the camera always made sense, selecting
    elements in the scene was done with the right mouse button (in most applications,
    the left mouse button selects things). Left-click is now the default for selecting,
    but the old functionality is why the splash screen shows this setting (accessible
    in Edit > Preferences after the first launch) when you first launch Blender:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Blender过去也经常使用非常非标准的鼠标功能。尽管使用中间鼠标按钮来操纵摄像机总是有道理的，但在场景中选择元素通常使用的是右键鼠标（在大多数应用程序中，左键鼠标用于选择）。现在左键点击是默认的选择方式，但正是这种旧功能使得启动Blender时的启动画面显示了此设置（在第一次启动后，在编辑
    > 首选项中可以访问此设置）：
- en: '![APPC_UN01_Hocking3](../Images/APPC_UN01_Hocking3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_UN01_Hocking3](../Images/APPC_UN01_Hocking3.png)'
- en: Blender mouse settings
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Blender鼠标设置
- en: Similarly, both box selection and deselecting used to be pretty odd, although
    now you simply click and drag or click empty space, respectively. Incidentally,
    you can hold Shift while something is already selected to add to the selection,
    and simply press A (for All) to select everything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，选择框选择和取消选择过去也很奇怪，尽管现在你只需点击并拖动或点击空白区域即可。顺便说一句，如果你已经选择了某些东西，可以按住Shift键来添加到选择中，只需按下A键（代表全部）即可选择所有内容。
- en: DEFINITION *Mesh elements* are the vertices, edges, and faces that make up the
    geometry of the mesh—in other words, the individual corner points, the lines connecting
    the points, and the shapes filled in between connected lines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *网格元素* 是构成网格几何形状的顶点、边和面——换句话说，就是单个角落点、连接点的线条以及填充在连接线条之间的形状。
- en: These are the basic controls for using Blender, so now we’ll see some functions
    for editing the model. To start, scale the cube into a long, thin plank. Select
    every vertex of the model (be sure to also select vertices on the side of the
    object facing away; press A to select all) and then switch to the Scale tool.
    Click-drag the blue arm to scale down vertically, and then click-drag the green
    arrow to scale out sideways (see figure C.5).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用Blender的基本控制方法，因此现在我们将看到一些用于编辑模型的函数。首先，将立方体缩放成长条形。选择模型上的每个顶点（务必也选择面向远离物体的侧面的顶点；按A键选择全部）然后切换到缩放工具。点击并拖动蓝色臂向下缩放，然后点击并拖动绿色箭头向侧面扩展（见图C.5）。
- en: '![APPC_F05_Hocking3](../Images/APPC_F05_Hocking3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F05_Hocking3](../Images/APPC_F05_Hocking3.png)'
- en: Figure C.5 Mesh scaled into a long, thin plank
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.5 网格拉伸成长条形
- en: Switch to Face Selection mode (use the button indicated in figure C.4) and select
    both small ends of the plank. You can click faces individually, and remember to
    hold Shift when adding to the selection. Now click the Mesh menu at the top of
    the viewport and choose Extrude > Extrude Individual Faces (see figure C.6). As
    you move the mouse, you’ll see additional sections added to the ends of the plank;
    move them out slightly and then left-click to confirm. Make this additional section
    only the width of the bench legs, giving yourself a little additional geometry
    to work with.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到面选择模式（使用图C.4中指示的按钮）并选择长条的两端。你可以单独点击面，记得在添加到选择时按住Shift键。现在点击视口顶部的网格菜单，选择拉伸
    > 拉伸单个面（见图C.6）。当你移动鼠标时，你会看到长条两端的额外部分被添加；稍微移动它们，然后左键点击以确认。使这个额外部分只有长凳腿的宽度，给自己留一点额外的几何形状来工作。
- en: '![APPC_F06_Hocking3](../Images/APPC_F06_Hocking3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F06_Hocking3](../Images/APPC_F06_Hocking3.png)'
- en: Figure C.6 In the Mesh menu, use Extrude Individual Faces to pull out extra
    sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.6 在网格菜单中，使用拉伸单个面来拉出额外的部分。
- en: 'DEFINITION *Extrude* pushes out new geometry with a cross section in the shape
    of the selected faces. The different extrude commands define what to do when multiple
    elements are selected: Extrude Individual Faces treats each face as a separate
    piece to extrude, whereas the standard Extrude Faces command treats the entire
    selection as a single piece.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*拉伸*通过具有所选面形状的横截面推出新的几何形状。不同的拉伸命令定义了在多个元素被选中时应该做什么：拉伸单个面将每个面视为一个单独的部分进行拉伸，而标准的拉伸面命令将整个选择视为一个单独的部分。
- en: Now look at the bottom of the plank and select the two thin faces on each end.
    Use the Extrude Individual Faces command again to pull down legs for the bench
    (refer to figure C.7).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看板子的底部，并选择每端的两个薄面。再次使用“拉伸单个面”命令向下拉出长椅的腿（参见图C.7）。
- en: '![APPC_F07_Hocking3](../Images/APPC_F07_Hocking3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F07_Hocking3](../Images/APPC_F07_Hocking3.png)'
- en: Figure C.7 Select the thin faces underneath the bench and pull down legs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.7 选择长椅下方的薄面并向下拉出腿。
- en: The shape is complete! But before you export the model over to Unity, you want
    to take care of texturing the model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 形状已经完成！但在将模型导出到Unity之前，你需要注意对模型进行纹理处理。
- en: C.2 Texture-mapping the model
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 纹理映射模型
- en: '3D models can have 2D images (referred to as *textures*) displayed on their
    surface. How exactly the 2D images relate to the 3D surface is straightforward
    for a large, flat surface like a wall: simply stretch the image across the flat
    surface. But what about an oddly shaped surface, like the sides of the bench?
    This is where it becomes important to understand the concept of texture coordinates.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 3D模型可以在其表面显示2D图像（称为*纹理*）。对于像墙壁这样的大而平的表面，2D图像如何与3D表面相关联是直观的：只需将图像拉伸到平坦的表面上即可。但是，对于像长椅侧面这样的不规则形状表面呢？这就是理解纹理坐标概念变得重要的地方。
- en: '*Texture coordinates* define how parts of the texture relate to parts of the
    mesh. These coordinates assign mesh elements to areas of the texture. Think about
    it like wrapping paper (see figure C.8); the 3D model is the box being wrapped,
    the texture is the wrapping paper, and the texture coordinates represent the points
    on the box where the wrapping paper will go. The texture coordinates define points
    and shapes on the 2D image; those shapes correlate to polygons on the mesh, and
    that part of the image appears on that part of the mesh.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*纹理坐标*定义了纹理的哪些部分与网格的哪些部分相关联。这些坐标将网格元素分配到纹理的各个区域。想象一下包装纸（见图C.8）；3D模型是被包装的盒子，纹理是包装纸，而纹理坐标代表盒子上的点，包装纸将放在这些点上。纹理坐标定义了2D图像上的点和形状；这些形状与网格上的多边形相关联，图像的这一部分就出现在网格的这一部分上。'
- en: '![APPC_F08_Hocking3](../Images/APPC_F08_Hocking3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F08_Hocking3](../Images/APPC_F08_Hocking3.png)'
- en: Figure C.8 Wrapping paper makes a good analogy for how texture coordinates work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.8 包装纸很好地说明了纹理坐标的工作原理。
- en: TIP Another name for texture coordinates is *UV coordinates*. This is because
    texture coordinates are defined using the letters U and V, just as coordinates
    on the 3D model are defined using X, Y, and Z.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：纹理坐标的另一个名称是*UV坐标*。这是因为纹理坐标是使用字母U和V定义的，就像3D模型上的坐标是使用X、Y和Z定义的一样。
- en: The technical term for correlating part of one thing to part of another is *mapping*—hence
    the term *texture mapping* for the process of creating texture coordinates. Coming
    from the wrapping paper analogy, another name for the process is *unwrapping*.
    And still more terms are created by mashing up the other terminology, like *UV
    unwrapping*; a lot of essentially synonymous terms surrounding texture mapping
    exist, so try not to get confused.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个事物的一部分与另一个事物的一部分相关联的技术术语是*映射*——因此，创建纹理坐标的过程被称为*纹理映射*。从包装纸的类比中，这个过程还有另一个名字，即*展开*。还有更多术语是通过混合其他术语创建的，例如*UV展开*；围绕纹理映射存在许多本质上同义的术语，所以尽量不要混淆。
- en: Traditionally, the process of texture mapping has been wickedly complicated,
    but fortunately, Blender provides tools to make the process fairly simple. First
    you define seams on the model; if you think further about wrapping around a box
    (or better yet, think about the other direction, unfolding a box), you’ll realize
    that not every part of a 3D shape can remain seamless when unfolded into two dimensions.
    There will have to be seams in the 3D form where the sides come apart. Blender
    enables you to select edges and declare them as seams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，纹理映射的过程非常复杂，但幸运的是，Blender提供了使过程变得相当简单的工具。首先你在模型上定义接缝；如果你进一步思考围绕一个盒子（或者更好的是，考虑相反的方向，展开一个盒子），你会意识到当展开到二维时，3D形状的每个部分并不都能保持无缝。在3D形状中，侧面分开的地方将需要接缝。Blender允许你选择边缘并将它们声明为接缝。
- en: Switch to Edge Selection mode (see the buttons in figure C.4) and select the
    edges along the outside of the bottom of the bench. Now choose Edge > Mark Seam
    (see figure C.9). This tells Blender to separate the bottom of the bench for the
    purposes of texture mapping. Do the same thing for the sides of the bench, but
    don’t separate the sides entirely. Instead, seam only the edges running up the
    legs of the bench; this way, the sides will remain connected to the bench while
    spreading out like wings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到边缘选择模式（见图C.4中的按钮）并选择长椅底部的边缘。现在选择边缘 > 标记接缝（见图C.9）。这告诉Blender为了纹理映射的目的将长椅底部分开。对长椅的侧面也做同样的事情，但不要完全分开侧面。相反，只对接缝沿着长椅腿的边缘进行接缝处理；这样，侧面将保持与长椅相连，同时像翅膀一样展开。
- en: '![APPC_F09_Hocking3](../Images/APPC_F09_Hocking3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F09_Hocking3](../Images/APPC_F09_Hocking3.png)'
- en: Figure C.9 Seam edges along the bottom of the bench and along the legs
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.9 长椅底部和腿部的接缝边缘
- en: Once all the seams are marked, run the texture unwrap command. First, select
    the entire mesh (just press A to select everything, or box select and don’t forget
    the side of the object facing away). Next, choose UV > Unwrap to create the texture
    coordinates. But you can’t see the texture coordinates in this view; Blender defaults
    to a 3D view of the scene. Switch to the UV Editing workspace to see the texture
    coordinates, using the workspace tabs at the top of the screen (see figure C.10).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有接缝都被标记，运行纹理展开命令。首先，选择整个网格（只需按A键选择所有内容，或者使用框选，别忘了选择面向远离物体的那一侧）。接下来，选择UV >
    展开以创建纹理坐标。但在这个视图中你无法看到纹理坐标；Blender默认以场景的3D视图显示。切换到UV编辑工作区以查看纹理坐标，使用屏幕顶部的工具栏标签（见图C.10）。
- en: '![APPC_F10_Hocking3](../Images/APPC_F10_Hocking3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F10_Hocking3](../Images/APPC_F10_Hocking3.png)'
- en: Figure C.10 Switch to UV Editing, then Export UV Layout.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.10 切换到UV编辑，然后导出UV布局。
- en: Now you can see the texture coordinates. You can see the polygons of the bench
    laid out flat, separated, and unfolded according to the seams you marked. To paint
    a texture, you have to see these UV coordinates in your image-editing program.
    Referring again to figure C.10, choose Export UV Layout under the UV menu in the
    texture coordinates viewport; save the image as bench.png (this name will also
    be used later when importing into Unity) with a size of 256.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到纹理坐标了。你可以看到长椅的多边形被平铺、分离和展开，这些都是根据你标记的接缝进行的。要绘制纹理，你必须在你图像编辑程序中看到这些UV坐标。再次参考图C.10，在纹理坐标视图中UV菜单下选择导出UV布局；将图像保存为bench.png（这个名称将在稍后导入Unity时使用），大小为256。
- en: Open this image in your image editor and paint colors for the various parts
    of your texture. Painting different colors for different UVs will put different
    colors on those faces. For example, figure C.11 shows darker blue where the bottom
    of the bench was unfolded on the top of the UV layout, and red was painted on
    the sides of the bench. Now the image can be brought back into Blender to texture
    the model; choose Image > Open.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的图像编辑器中打开这张图片，并为纹理的各个部分绘制颜色。为不同的UV绘制不同的颜色将把不同的颜色放在那些面上。例如，图C.11显示了在UV布局顶部展开的长椅底部较暗的蓝色，以及长椅侧面的红色。现在可以将图像带回到Blender中为模型添加纹理；选择图像
    > 打开。
- en: '![APPC_F11_Hocking3](../Images/APPC_F11_Hocking3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F11_Hocking3](../Images/APPC_F11_Hocking3.png)'
- en: Figure C.11 Paint colors over the exported UVs and then bring the texture into
    Blender.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.11 在导出的UV上绘制颜色，然后将纹理带入Blender。
- en: 'Even though the texture image is open in the UV editing view, you still can’t
    see the texture on the model in the 3D view. That requires a couple more steps:
    assign the image to the object’s material and then turn on textures in the viewport
    (see figure C.12). Now you can see the finished bench, with texture applied!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 UV 编辑视图中打开了纹理图像，你仍然无法在 3D 视图中看到模型上的纹理。这需要额外的几个步骤：将图像分配给对象的材质，然后在视图中打开纹理（见图
    C.12）。现在你可以看到应用了纹理的完成后的长椅了！
- en: '![APPC_F12_Hocking3](../Images/APPC_F12_Hocking3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F12_Hocking3](../Images/APPC_F12_Hocking3.png)'
- en: Figure C.12 Set the image on the object’s material to view the texture on the
    model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.12 将图像设置在对象的材质上以在模型上查看纹理。
- en: Save the model now. Blender will save the file with the .blend extension, using
    the native file format for Blender. Work in the native file format so that all
    the features of Blender will be preserved correctly, but later you’ll have to
    export the model to a different file format (FBX is recommended in chapter 4)
    to import it into Unity. Note that the texture image isn’t saved in the model
    file; what’s saved is a reference to the image, but you still need the image file
    that’s being referenced.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存模型。Blender 会使用 Blender 的原生文件格式（.blend 扩展名）保存文件。在原生文件格式下工作，以确保 Blender 的所有功能都能正确保留，但稍后你将不得不将模型导出为不同的文件格式（第
    4 章推荐 FBX 格式）以导入到 Unity 中。请注意，纹理图像不会保存在模型文件中；保存的是对图像的引用，但你仍然需要被引用的图像文件。
