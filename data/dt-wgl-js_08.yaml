- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Practical data analysis
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实践数据分析
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: 'Using statistical tools: sum, average, standard deviation, and frequency distributions'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统计工具：求和、平均值、标准差和频率分布
- en: Grouping and summarizing a data set to make sense of it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据集进行分组和汇总，以便理解其含义
- en: 'Using tools for working with time series data: rolling average, linear regression,
    and more'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具处理时间序列数据：滚动平均、线性回归等
- en: Using data analysis techniques for comparing data and making predictions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据分析技术来比较数据和进行预测
- en: Using correlation to understand the relationship between data variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相关性来理解数据变量之间的关系
- en: Congratulations, you made it to the data analysis chapter. It took much work
    to get here. We’ve had to fetch our data from somewhere, and we had to clean and
    prepare it. Then it turned out that we had more data than we could deal with,
    so we had to move it to our database to deal with it. It’s been a long road.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你来到了数据分析章节。到达这里需要很多努力。我们不得不从某处获取我们的数据，并且我们需要对其进行清理和准备。然后我们发现我们拥有的数据比我们能处理的多，所以我们必须将其移动到我们的数据库中处理。这是一条漫长的道路。
- en: 'Data analysis is the study of our data for better understanding, to glean insights,
    and answer the questions that we have. For instance, when I’m searching for a
    place to live or to visit on vacation, I might have specific requirements for
    the weather. In this chapter, we’ll study 100 years’ worth of weather data from
    a weather station in New York City’s Central Park. Later, we’ll compare it to
    the weather in Los Angeles and see how it stacks up. I’m also interested in the
    overall trend: Is it getting hotter? Which city is heating up more quickly?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '数据分析是研究我们的数据以获得更好的理解、获取洞察力并回答我们问题的学科。例如，当我正在寻找一个居住地或度假地时，我可能对天气有具体的要求。在本章中，我们将研究纽约市中央公园气象站100年的天气数据。稍后，我们将将其与洛杉矶的天气进行比较，看看它们如何相互比较。我还对整体趋势感兴趣：天气是否变热了？哪个城市升温更快？ '
- en: In this chapter, we’ll learn data analysis and we’ll practice on the weather
    stations data from NOAA that we used in chapters 7 and 8\. We’ll start with fundamentals
    and build up to more advanced techniques. By the end, we’ll have tools for understanding,
    comparing, and forecasting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习数据分析，并将在第7章和第8章中使用过的NOAA气象站数据上进行实践。我们将从基础知识开始，逐步过渡到更高级的技术。到结束时，我们将拥有理解、比较和预测的工具。
- en: This chapter delves into math, but don’t let that put you off. The math we go
    into is basic, and for the more advanced math, we’ll rely on third-party libraries
    that abstract away the hard stuff. I firmly believe that you don’t need to be
    a math wizard to use data analysis; you simply need to know what each technique
    is good for and how to use it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了数学，但不要因此而气馁。我们涉及的数学是基础的，对于更高级的数学，我们将依赖第三方库来抽象处理困难的部分。我坚信，你不需要成为一个数学大师就能使用数据分析；你只需要知道每种技术适合做什么以及如何使用它。
- en: When you understand how powerful these techniques can be, you’ll think of all
    sorts of uses for them; they’re going to help even with routine tasks such as
    understanding your server’s or app’s performance metrics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你了解到这些技术有多么强大时，你会想到它们的各种用途；它们甚至可以帮助你完成像理解你的服务器或应用性能指标这样的常规任务。
- en: 9.1 Expanding your toolkit
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 扩展你的工具箱
- en: In this chapter, we’ll add to our toolkit several data analysis techniques as
    listed in [table 9.1](#table9.1). We’ll look at how you can code these formulas
    for yourself. For the more advanced math, we’ll use third-party libraries. We’ll
    also use Data-Forge more in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加几种数据分析技术到我们的工具箱中，如[表9.1](#table9.1)所示。我们将探讨如何自己编写这些公式的代码。对于更高级的数学，我们将使用第三方库。我们还将在本章中更多地使用Data-Forge。
- en: Table 9.1 Tools used in chapter 9
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 第9章中使用的工具
- en: '| **Technique** | **Function** | **Notes** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **技术** | **函数** | **说明** |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Basic statistics | `sum` | Sum the total from a set of values. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 基本统计学 | `sum` | 从一组值中求和。 |'
- en: '|  | `average` | Compute the average or *central* value from a set of values.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  | `average` | 从一组值中计算平均值或*中心*值。 |'
- en: '|  | `std` | Compute the standard deviation from a set of values; this is a
    measure of volatility, fluctuation, or dispersion of our data. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | `std` | 从一组值中计算标准差；这是衡量数据波动性、波动或分散程度的指标。 |'
- en: '| Group and summarize | `groupBy, select` | Condense a data set and make it
    easier to understand by grouping records and summarizing them with sum, average,
    or standard deviation. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 分组和汇总 | `groupBy, select` | 通过分组记录并使用总和、平均值或标准差进行汇总，使数据集更加紧凑，更容易理解。|'
- en: '| Frequency distribution | `bucket, detectValues` | Determine the distribution
    of values in a data set, and if it matches a normal distribution, this gives us
    certain predictive powers. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 频率分布 | `bucket, detectValues` | 确定数据集中的值分布，如果它符合正态分布，这将给我们一定的预测能力。|'
- en: '| Time series | `rollingAverage` | Smooth out time series data, removing noise
    so that we can better detect trends and patterns. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 时间序列 | `rollingAverage` | 平滑时间序列数据，去除噪声，以便我们更好地检测趋势和模式。|'
- en: '|  | `rollingStandardDeviation` | See the fluctuation or variability of a data
    series over time. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  | `rollingStandardDeviation` | 查看数据系列随时间的变化或波动。|'
- en: '|  | `linearRegression` | Use for forecasting and detecting trends. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  | `linearRegression` | 用于预测和检测趋势。|'
- en: '|  | `difference` | Understand the difference between time series and determine
    if they’re diverging. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  | `difference` | 理解时间序列之间的差异，并确定它们是否在发散。|'
- en: '| Data standardization | `average, std` | Standardize two data sets for direct
    comparison. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 数据标准化 | `average, std` | 标准化两个数据集以进行直接比较。|'
- en: '| Correlation coefficient | `sampleCorrelation` | Understand the relationship
    between data variables and how strongly (or weakly) correlated they are. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 相关系数 | `sampleCorrelation` | 理解数据变量之间的关系以及它们的相关性强弱。|'
- en: In this chapter, we’ll look at various code examples that generate charts. As
    we have yet to learn about visualization, I’ve prepared a series of toolkit functions
    that you will use for rendering charts. All you have to do is pass data into the
    toolkit function, and it will render a chart for you to an image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看各种生成图表的代码示例。由于我们尚未学习可视化，我准备了一系列工具函数，您将使用这些函数来渲染图表。您只需将数据传递给工具函数，它就会为您渲染一个图表到图像中。
- en: As we work through this chapter, you’ll see how these functions are used. In
    the following chapters on visualization (chapters 10 and 11), you’ll learn how
    to create such charts from scratch.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们学习本章，您将看到这些函数是如何使用的。在接下来的可视化章节（第10章和第11章）中，您将学习如何从头开始创建这样的图表。
- en: 9.2 Analyzing the weather data
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 分析天气数据
- en: In this chapter, we analyze the weather data we worked with in the previous
    two chapters. We have any number of questions we might ask of this data. Already
    mentioned is that we might want to move somewhere with an agreeable climate, or
    we might want to go on a holiday somewhere warm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了前两章中使用的天气数据。我们对这些数据可能提出的问题有很多。已经提到的是，我们可能想要搬到一个气候宜人的地方，或者我们可能想去一个温暖的地方度假。
- en: The full weather station data set from NOAA is extremely large, weighing in
    at 27 GB uncompressed. If we were doing a global analysis, we’d want to work with
    and aggregate this entire data set; however, that’s a massive operation. For this
    chapter, we’re going to have a more local focus, so from the big data set, I’ve
    extracted the data from two particular weather stations. One is in New York City
    (NYC), and the other is in Los Angeles (LA).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 来自NOAA的完整气象站数据集非常大，未压缩时达到27 GB。如果我们进行全球分析，我们希望处理和汇总整个数据集；然而，这是一个庞大的操作。对于本章，我们将有一个更本地化的焦点，因此从大数据集中，我提取了两个特定气象站的数据。一个是纽约市（NYC），另一个是洛杉矶（LA）。
- en: After loading the massive data set into my MongoDB database, I indexed it by
    `StationId`. The process of loading the database and creating the index took significant
    time, but after that it was quick to extract all the data for a particular station.
    I extracted the data for NYC and LA to two separate CSV files that are available
    for you in the GitHub repository for this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在将庞大的数据集加载到我的MongoDB数据库后，我通过`StationId`对其进行索引。加载数据库和创建索引的过程花费了相当多的时间，但在此之后，提取特定气象站的所有数据变得非常快。我将NYC和LA的数据提取到两个单独的CSV文件中，这些文件可在本章的GitHub存储库中找到。
- en: 9.3 Getting the code and data
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 获取代码和数据
- en: The code and data for this chapter are available in the Data Wrangling with
    JavaScript Chapter-9 repository in GitHub at [https://github.com/data-wrangling-with-javascript/chapter-9](https://github.com/data-wrangling-with-javascript/chapter-9)[.](http://.)
    The example data is located under the *data* subdirectory in the repository.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和数据可在 GitHub 上的 Data Wrangling with JavaScript Chapter-9 仓库中找到，网址为 [https://github.com/data-wrangling-with-javascript/chapter-9](https://github.com/data-wrangling-with-javascript/chapter-9)[.](http://.)
    示例数据位于仓库中的 *data* 子目录下。
- en: Much of the example code for this chapter renders charts to image files, which
    will be available in the *output* subdirectory after you run each of the code
    listings. The code for rendering such charts is in the *toolkit* subdirectory
    (we’ll dig into this code in chapters 10 and 11). Refer to “Getting the code and
    data” in chapter 2 for help on getting the code and data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分示例代码将图表渲染为图像文件，这些文件将在你运行每个代码列表后可在 *output* 子目录中找到。渲染此类图表的代码位于 *toolkit*
    子目录中（我们将在第 10 章和第 11 章中深入研究此代码）。有关获取代码和数据的信息，请参阅第 2 章中的“获取代码和数据”。
- en: 9.4 Basic data summarization
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 基本数据汇总
- en: Three basic functions are commonly used in statistics and data analysis. They
    are for the operations sum, average, and standard deviation. These statistical
    tools allow us to summarize and make comparisons between data sets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学和数据分析中常用三个基本函数。它们是求和、平均和标准差。这些统计工具使我们能够总结数据集，并对其进行比较。
- en: 9.4.1 Sum
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 求和
- en: 'You can hardly ask for a more basic operation than sum: adding up the values
    in a data set. Sum is useful in its own right—say, when we need to tally up the
    total amount from individual values—but we’ll soon also need it to compute an
    average. I thought this would be a good way to warm up to the more advanced functions.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎找不到比求和更基本的操作了：将数据集中的值加起来。求和本身很有用——比如说，当我们需要从单个值中累计总量时，但我们很快还需要用它来计算平均值。我认为这将是一个很好的方式来为更高级的函数做准备。
- en: We’ll compute the sum of all rainfall collected at the NYC weather station in
    2016\. We create the `sum` function using the JavaScript `reduce` function, and
    in the process, we create a new reusable `statistics` code module to add to our
    toolkit. This is shown in the following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算 2016 年在纽约市气象站收集到的所有降雨量。我们使用 JavaScript 的 `reduce` 函数创建 `sum` 函数，在这个过程中，我们创建了一个新的可重用
    `statistics` 代码模块，并将其添加到我们的工具箱中。这将在以下列表中展示。
- en: Listing 9.1 A sum function for our toolkit (toolkit/statistics.js)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 我们工具箱中的求和函数（toolkit/statistics.js）
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Listing 9.2](#listing9.2) shows how we use our new `sum` function to compute
    the total amount of rainfall. To keep things simple, we’ll start with a hard-coded
    data set, but soon we’ll level up to some real data. Try running the following
    listing, and you should see that it computes the total rainfall as 1072.2 mm.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.2](#listing9.2) 展示了我们是怎样使用新的 `sum` 函数来计算总降雨量的。为了保持简单，我们首先使用硬编码的数据集，但很快我们将升级到一些真实数据。尝试运行以下列表，你应该会看到它计算的总降雨量为
    1072.2 毫米。'
- en: Listing 9.2 Computing total rainfall for 2016 (listing-9.2.js)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 计算 2016 年的总降雨量（listing-9.2.js）
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 9.4.2 Average
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 平均
- en: Now that we have our `sum` function, we can use it to build our `average` function.
    The `average` function computes the *average* or *arithmetic* *mean* of a set
    of values and is one way to compute a *central value* for a data set. Average
    is useful when you want to know the most common value because we can detect when
    new values are above or below the norm. Let’s calculate the average monthly rainfall.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `sum` 函数，我们可以用它来构建我们的 `average` 函数。`average` 函数计算一组值的 *平均值* 或 *算术平均值*，这是计算数据集
    *中心值* 的一种方法。当你想知道最常见值时，平均值很有用，因为我们可以在新值高于或低于正常值时检测到。让我们计算平均月降雨量。
- en: The following listing shows the `average` function that we built based on the
    `sum` function. This is another function added to our reusable statistics code
    module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们基于 `sum` 函数构建的 `average` 函数。这是另一个添加到我们可重用统计代码模块中的函数。
- en: Listing 9.3 An average function for our toolkit (toolkit/statistics.js)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 我们工具箱中的平均函数（toolkit/statistics.js）
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following listing shows how we can use our `average` function to compute
    the average from our hard-coded data set. Run this code, and you should see that
    it computes an average of roughly 89.35 mm.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们如何使用 `average` 函数从硬编码的数据集中计算平均值。运行此代码，你应该会看到它计算的平均值约为 89.35 毫米。
- en: Listing 9.4 Computing the average monthly rainfall for 2016 (listing-9.4.js)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 计算 2016 年的平均月降雨量（listing-9.4.js）
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 9.4.3 Standard deviation
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 标准差
- en: Standard deviation is a more complicated formula. This tells us the average
    amount that our values deviate from the average value. It quantifies the amount
    of variation or dispersion in our data set.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差是一个更复杂的公式。这告诉我们我们的值与平均值平均偏离的程度。它量化了我们数据集中的变化或分散程度。
- en: We can use it to measure the variability or volatility of our data, and this
    allows us to understand when our data values are calm and orderly or whether they’re
    volatile and all over the place. Let’s compute the standard deviation of monthly
    rainfall.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来衡量我们数据的可变性或波动性，这使我们能够了解我们的数据值是平静有序还是波动不定、四处散布。让我们计算一下月降雨量的标准差。
- en: In the following listing, we add a `std` function to our statistics code module
    for calculating standard deviation. It builds on the `average` function we created
    previously.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们向我们的统计代码模块添加了一个 `std` 函数，用于计算标准差。它基于我们之前创建的 `average` 函数。
- en: Listing 9.5 A standard deviation function for our toolkit (toolkit/statistics.js)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 为我们的工具包（toolkit/statistics.js）提供一个标准差函数
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following listing shows how we use the `std` function to compute standard
    deviation for monthly rainfall in 2016\. You can run this code, and it should
    put the standard deviation at around 40.92 mm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用 `std` 函数计算 2016 年月降雨量的标准差。你可以运行此代码，它应该将标准差放在大约 40.92 毫米的位置。
- en: Listing 9.6 Computing standard deviation of monthly rainfall for 2016 (listing-9.6.js)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 计算 2016 年月降雨量的标准差（listing-9.6.js）
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although standard deviation can be used standalone as a measure of fluctuation,
    it’s also used in combination with a *distribution* so that we can predict the
    probability of future values. It can also be used to *standardize* data so that
    we may compare different data sets like for like. We’ll look at both techniques
    later in the chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准差可以作为波动性的度量单独使用，但它也常与 *分布* 结合使用，以便我们可以预测未来值的概率。它还可以用于 *标准化* 数据，以便我们可以像比较不同的数据集一样进行比较。我们将在本章后面讨论这两种技术。
- en: 9.5 Group and summarize
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 分组并总结
- en: Now that we have basic statistics in place, we can move on to more advanced
    data analysis techniques. The data we’ve worked with so far has been a hard-coded
    JavaScript array of monthly rainfall values. How was this data prepared?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本的统计数据，我们可以继续进行更高级的数据分析技术。我们之前处理的数据一直是一个硬编码的月降雨值 JavaScript 数组。这些数据是如何准备的？
- en: That data was prepared by grouping daily values by month and then summing the
    daily rainfall in each group to compute the monthly rainfall. This kind of *group
    and summarize* operation is frequently used, and I consider it to be a fundamental
    data analysis technique.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那些数据是通过按月份分组每日值，然后对每个组中的每日降雨量求和来计算月降雨量准备的。这种 *分组和总结* 操作经常被使用，我认为它是一种基本的数据分析技术。
- en: When we’re inundated with data, it’s difficult to glean information, but when
    we group and summarize it, we boil it down into something that’s easier to understand.
    We might even condense the data down multiple times as we *drill down* searching
    for interesting data points or anomalies in the data set.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们被数据淹没时，很难提取信息，但当我们分组和总结时，我们将其简化为更容易理解的东西。我们甚至可能多次压缩数据，当我们 *深入挖掘* 寻找数据集中的有趣数据点或异常时。
- en: Let’s start using a real data set instead of hard-coded data. We’ll analyze
    the data set from the NYC weather station. The CSV files that accompany this chapter
    have records that go back 100 years, but we’ll start by looking at just the data
    from 2016.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用实际的数据集而不是硬编码的数据。我们将分析来自纽约市气象站的数据集。本章附带的 CSV 文件包含回溯 100 年的记录，但我们将从 2016
    年的数据开始查看。
- en: We could look at a bar chart of daily temperature data for all of 2016, but
    as you can imagine, such a chart would be rather noisy and wouldn’t provide a
    good summary of the data. Let’s instead use our group and summarize technique
    to condense the data into monthly summaries resulting in the chart in [figure
    9.1](#figure9.1), which shows average monthly temperature in degrees Celsius on
    the Y axis.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看 2016 年全年每日温度数据的条形图，但正如你所想象的那样，这样的图表会相当嘈杂，并且不会提供很好的数据总结。相反，让我们使用我们的分组和总结技术将数据压缩成月度总结，结果就是
    [图 9.1](#figure9.1) 中的图表，它显示了 Y 轴上的平均月度温度（摄氏度）。
- en: '![c09_01.tif](Images/c09_01.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![c09_01.tif](Images/c09_01.png)'
- en: '[Figure 9.1](#figureanchor9.1) Monthly average temperature in NYC for 2016'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.1](#figureanchor9.1) 2016 年纽约市月平均温度'
- en: '[Figure 9.1](#figure9.1) makes it easy see the hottest and coldest months of
    the year in NYC. If I’m planning a trip there, and I’m not keen on the cold weather,
    it’s probably best to avoid December, January, and February (I actually like the
    cold weather, considering I come from a fairly hot country).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.1](#figure9.1) 使我们能够轻松地看到纽约市一年中最热和最冷的月份。如果我计划去那里旅行，而且我不喜欢冷天气，那么最好避免十二月份、一月份和二月份（实际上，我来自一个相对炎热的国度，所以我喜欢冷天气）。'
- en: '[Figure 9.2](#figure9.2) illustrates the *group and summarize* process. We
    take daily weather data on the left. We organize all data records into groups
    based on the *Month* column. For each group, we then compute the average temperature.
    This produces the much-compressed table that we see on the right of [figure 9.2](#figure9.2).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.2](#figure9.2) 阐述了分组和总结的过程。我们取左侧的每日天气数据。我们根据 *月份* 列将所有数据记录组织成组。然后，对于每个组，我们计算平均温度。这产生了我们在
    [图 9.2](#figure9.2) 右侧看到的压缩后的表格。'
- en: '[Listing 9.7](#listing9.7) contains a code example of the group and summarize
    technique. We’re moving onto more advanced data analysis techniques here, so we’ll
    use Data-Forge to make things easier. If you installed dependencies for the Chapter-9
    code repository, you already have it installed; otherwise, you can install it
    in a fresh Node.js project as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.7](#listing9.7) 包含了一个分组和总结技术的代码示例。在这里，我们将进入更高级的数据分析技术，因此我们将使用 Data-Forge
    来简化操作。如果你已经为第 9 章代码仓库安装了依赖项，那么它已经安装好了；否则，你可以在一个新的 Node.js 项目中按照以下步骤安装它：'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In [listing 9.7](#listing9.7) we first read in the whole data set of 100 years
    of NYC weather. In this example, we’re only interested in 2016, so we use the
    `where` function to filter down to records from 2016.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.7](#listing9.7) 中，我们首先读取了 100 年纽约市天气的整个数据集。在这个例子中，我们只对 2016 年感兴趣，因此我们使用
    `where` 函数筛选出 2016 年的记录。
- en: '![c09_02.eps](Images/c09_02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![c09_02.eps](Images/c09_02.png)'
- en: '[Figure 9.2](#figureanchor9.2) Condensing daily data by grouping it by month
    and summarizing each group'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.2](#figureanchor9.2) 通过按月份分组并总结数据来压缩每日数据'
- en: We then use the `groupBy` function to sort the 2016 records into monthly groups.
    After that, the `select` function transforms each group (computing min, max, and
    average), and we’ve rewritten our data set. We took it from noisy daily data and
    condensed it down to monthly summaries. Run this code, and it prints console output
    similar to the right of [figure 9.2](#figure9.2) and renders a bar chart like
    [figure 9.1](#figure9.1) to output/nyc-monthly-weather.png.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `groupBy` 函数将 2016 年的记录排序到每月的组中。之后，`select` 函数将每个组（计算最小值、最大值和平均值）进行转换，我们已重新编写了数据集。我们从嘈杂的每日数据中提取出来，并将其压缩成每月的总结。运行此代码，它将打印出类似于
    [图 9.2](#figure9.2) 右侧的控制台输出，并渲染一个类似于 [图 9.1](#figure9.1) 的条形图到输出/nyc-monthly-weather.png。
- en: Listing 9.7 Grouping and summarizing daily weather data by month (listing-9.7.js)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 按月份分组和总结每日天气数据（listing-9.7.js）
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the call to `renderMonthlyBarChart` at the end of [listing 9.7](#listing9.7).
    This is a toolkit function that I prepared for you so that we can focus on the
    data analysis and not yet be concerned with the details of visualization. We’ll
    come back to visualization and understand how to create such charts in chapters
    10 and 11.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 [列表 9.7](#listing9.7) 结尾处的 `renderMonthlyBarChart` 调用。这是一个我为你准备的工具函数，这样我们就可以专注于数据分析，而不必担心可视化的细节。我们将在第
    10 章和第 11 章中回到可视化，并了解如何创建这样的图表。
- en: In [listing 9.7](#listing9.7) we only summarized the temperature. We did this
    by averaging it. We can add other metrics to our summary. For example, we can
    easily modify the code in [listing 9.7](#listing9.7) to include total rain and
    total snow per month. The updated code is presented in the following listing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.7](#listing9.7) 中，我们只总结了温度。我们通过取平均值来完成这项工作。我们可以在我们的总结中添加其他指标。例如，我们可以轻松修改
    [列表 9.7](#listing9.7) 中的代码，以包括每月的总降雨量和总降雪量。更新后的代码在下面的列表中展示。
- en: Listing 9.8 Adding code to summarize rainfall and snowfall per month (upgraded
    from [listing 9.7](#listing9.7))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 向总结每月降雨量和降雪量的代码中添加代码（从 [列表 9.7](#listing9.7) 升级）
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we’re summarizing the new values, we can also add them to our bar chart.
    [Figure 9.3](#figure9.3) shows an updated chart with rainfall and snow added,
    with temperature on the left-hand axis (degrees Celsius) and snowfall/rainfall
    on the right-hand axis (millimeters).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结新值的同时，我们也可以将它们添加到我们的条形图中。[图 9.3](#figure9.3) 展示了一个更新后的图表，其中添加了降雨量和降雪量，温度位于左侧坐标轴（摄氏度）上，而降雪量/降雨量位于右侧坐标轴（毫米）上。
- en: '![c09_03.tif](Images/c09_03.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![c09_03.tif](Images/c09_03.png)'
- en: '[Figure 9.3](#figureanchor9.3) Weather chart for NYC for 2016 including rainfall
    and snow'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.3](#figureanchor9.3) 2016年纽约市包括降雨和降雪的天气图表'
- en: It doesn’t take much study of the chart in [figure 9.3](#figure9.3) to notice
    the huge spike in snowfall that occurred in January. What happened here? Was it
    a snowy month? Or did the snow only fall on a handful of days. This is an example
    of finding an interesting data point or anomaly in our data. We can’t help but
    be curious about what’s happening here. It could even be an error in our data!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9.3](#figure9.3)中的图表上稍加研究，就能注意到1月份降雪量出现了巨大的峰值。这里发生了什么？是整个月都在下雪吗？还是只有少数几天下雪。这是我们数据中找到有趣的数据点或异常的例子。我们不禁对这里发生的事情感到好奇。这甚至可能是我们数据中的一个错误！
- en: You could now drill down and look at a day-by-day chart of January. To do this,
    you’d filter down to records from January 2016 and plot a daily bar chart of snowfall—you
    could do this with simple modifications to listings 9.7 or 9.8\. If you do this,
    you’ll find that the snowfall spike occurs on January 23\. Search the web for
    this date in NYC, and you’ll find that was the day of a massive blizzard. Mystery
    solved. If you vacation in NYC in January, you might find yourself stuck in a
    blizzard! (This happened to me in NYC about 20 years ago.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以深入查看一月份的每日图表。为此，你需要筛选出2016年1月的记录，并绘制每日降雪柱状图——你可以通过简单修改列表9.7或9.8来实现这一点。如果你这样做，你会发现降雪峰值出现在1月23日。在网络上搜索这个日期在纽约市的情况，你会发现那天发生了一场巨大的暴风雪。谜团解开。如果你在1月份去纽约度假，你可能会发现自己被困在暴风雪中！（这在我大约20年前在纽约发生过的。）
- en: It might be interesting to understand how common an occurrence such an event
    is. How often do blizzards occur in NYC? For that, we’d have to do a wider analysis
    of the data set, but 100 years of data is available, so how about you try and
    find other blizzards. How would you go about doing this?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这样一个事件发生的频率可能很有趣。纽约市暴风雪发生的频率是多少？为此，我们需要对数据集进行更广泛的分析，但有一百年的数据可用，所以你尝试找到其他暴风雪怎么样？你将如何进行这项工作？
- en: First, you’d probably want to summarize snowfall by year and generate a chart.
    Look for years with spikes in snowfall. Second, drill down to those years and
    find the months with spikes. Last, drill down to the daily chart for those years
    and months and find the days with spikes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能想按年份总结降雪量并生成图表。寻找降雪量峰值出现的年份。其次，深入到那些年份，找到峰值出现的月份。最后，深入到那些年份和月份的每日图表，找到峰值出现的日期。
- en: 'Here’s a general summary of what we did:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所做的一般总结：
- en: Filter down to the records you’re interested in.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选出你感兴趣的数据记录。
- en: Group by a metric.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按指标分组。
- en: Summarize the data for that group.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结该组的数据。
- en: Look for anomalies and then drill down into an interesting group. Then repeat
    this process at a more granular level.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找异常，然后深入到一个有趣的小组。然后在更细粒度的层面上重复这个过程。
- en: This process of looking at a summary of data and then drilling down to a finer
    resolution is an effective technique for quickly locating data and events of interest.
    In this approach, we start with a bird’s-eye view of the data and progressively
    home in on the data points that stand out.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查看数据摘要然后深入到更细粒度的方法是一种快速定位感兴趣数据和事件的有效技术。在这种方法中，我们从一个数据的全局视角开始，逐步聚焦于突出的数据点。
- en: We now have tools that will help us understand our weather data, but we don’t
    yet have any technique that might help us predict the likelihood of future values
    in new weather data, so now we’ll look at how to do that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了帮助我们理解气象数据的工具，但我们还没有任何技术可以帮助我们预测新气象数据中未来值的可能性，所以现在我们将探讨如何做到这一点。
- en: 9.6 The frequency distribution of temperatures
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 温度的频率分布
- en: Let’s now look at the distribution of temperatures in NYC. As you’ll soon see,
    this might allow us to make predictions about the probability of new temperature
    values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看纽约市的温度分布。很快你就会看到，这可能让我们能够预测新温度值的概率。
- en: '[Figure 9.4](#figure9.4) shows a histogram of the frequency distribution of
    temperature in NYC for the past 100 years. A chart like this arranges values into
    a series of *buckets* with the amount of values in each bucket represented as
    a vertical bar. Each bar summarizes a collection of temperature values with the
    midpoint of each bucket on the X axis as degrees Celsius. The height of each bar,
    the Y axis, indicates the percentage of values (from the total data set) that
    fall within the range of the bucket.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.4](#figure9.4)显示了过去100年纽约市温度频率分布的直方图。这样的图表将数值排列成一系列*桶*，每个桶中的数值量用垂直条表示。每个条形图总结了温度值的一个集合，每个桶的中点位于X轴上，以摄氏度表示。每个条形图的高度，即Y轴，表示落在桶范围内的值（来自总数据集）的百分比。'
- en: '![c09_04.eps](Images/c09_04.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![c09_04.eps](Images/c09_04.png)'
- en: '[Figure 9.4](#figureanchor9.4) Distribution of temperatures in NYC from the
    past 100 years'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.4](#figureanchor9.4) 纽约市过去100年的温度分布'
- en: Looking at [figure 9.4](#figure9.4), we can quickly get a feel for the range
    of temperatures experienced by New York City. For instance, we can see the temperature
    range that the majority of recorded values falls in and that the largest group
    of recorded values accounts for 11% of all the values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到[图9.4](#figure9.4)，我们可以迅速了解纽约市所经历的温度范围。例如，我们可以看到大多数记录值所在的温度范围，以及记录值中最大的群体占所有值的11%。
- en: The 11% value isn’t important here—that’s the tallest bar, and it’s a way for
    us to see the temperature range where the values are most densely clustered. A
    histogram like this can only be rendered after we’ve first produced a frequency
    distribution table as shown in [figure 9.5](#figure9.5). Each row in this particular
    table corresponds to a bar in the histogram from [figure 9.4](#figure9.4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的11%值并不重要——这是最高的条形，它是一种让我们看到值最密集聚集的温度范围的方法。这样的直方图只能在首先生成如图9.5所示的频率分布表之后绘制。这个特定表格中的每一行都对应于[图9.4](#figure9.4)中的直方图中的一个条形。
- en: '![c09_05.png](Images/c09_05.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![c09_05.png](Images/c09_05.png)'
- en: '[Figure 9.5](#figureanchor9.5) Frequency distribution table of NYC temperatures
    (used to render the histogram in [figure 9.4](#figure9.4))'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.5](#figureanchor9.5) 纽约市温度频率分布表（用于绘制[图9.4](#figure9.4)中的直方图))'
- en: In my limited experience in working with weather data, I anticipated that the
    temperature distribution might fall in a normal distribution (which I’ll explain
    in a moment), but the actual data failed to oblige my assumption (as is so often
    the case when working with data).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我有限的工作经验中，处理气象数据时，我预计温度分布可能呈正态分布（我稍后会解释），但实际数据并未符合我的假设（在处理数据时这种情况很常见）。
- en: Although I did notice that [figure 9.4](#figure9.4) kind of looked like two
    normal distributions jammed up against each other. After some investigation, I
    decided to split out the winter and summer data. After designating winter and
    summer months, I then split the data based on this criterion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我确实注意到[图9.4](#figure9.4)看起来像是两个正态分布紧挨在一起。经过一些调查后，我决定将冬季和夏季数据分开。在指定了冬季和夏季月份后，我根据这一标准分割了数据。
- en: Next, I created separate histograms for each season. When I looked at the new
    visualizations, it became apparent that the temperature distribution for each
    season aligned closely with a normal distribution. As an example, you can see
    the winter temperatures histogram in [figure 9.6](#figure9.6).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我为每个季节创建了单独的直方图。当我查看新的可视化时，很明显，每个季节的温度分布都与正态分布紧密吻合。例如，您可以在[图9.6](#figure9.6)中看到冬季温度的直方图。
- en: '![c09_06.eps](Images/c09_06.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![c09_06.eps](Images/c09_06.png)'
- en: '[Figure 9.6](#figureanchor9.6) Winter temperatures in NYC align closely to
    a normal distribution.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.6](#figureanchor9.6) 纽约市的冬季温度与正态分布紧密吻合。'
- en: By this point, especially if you’ve forgotten high school statistics, you’re
    probably wondering what a normal distribution is. It’s an important concept in
    statistics and is informally known as a *bell curve*. Is it ringing any bells
    yet? Data sets that fall in a normal or close to normal distribution have properties
    that allow us to estimate the probability of new data values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，尤其是如果你已经忘记了高中统计学，你可能想知道什么是正态分布。它是统计学中的一个重要概念，非正式地被称为*钟形曲线*。这让你想起什么了吗？落在正态或接近正态分布的数据集具有允许我们估计新数据值概率的特性。
- en: What does this mean in relation to temperature values? It means we can quickly
    determine the probability of a particular temperature occurring. Once we know
    that a data set falls in a normal distribution, we can now make certain statements
    about the data set, such as
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这与温度值有什么关系？这意味着我们可以快速确定特定温度发生的概率。一旦我们知道数据集属于正态分布，我们现在可以对数据集做出某些陈述，例如
- en: 68% of values fall within 1 SD (standard deviation) of the average.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 68%的值落在平均值加减1个标准差（SDs）的范围内。
- en: 95% of values fall within 2 SDs of the average.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 95%的值落在平均值加减2个标准差（SDs）的范围内。
- en: 99.7% of values fall within 3 SDs of the average.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.7%的值落在平均值加减3个标准差（SDs）的范围内。
- en: By the inverse, only 0.3% of values will fall outside of 3 SDs from the average.
    We can consider these values to be extreme.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反过来，只有0.3%的值将落在平均值加减3个标准差（SDs）之外。我们可以将这些值视为极端值。
- en: How can we know these probabilities? It’s because these are the known properties
    of the normal distribution (as illustrated in [figure 9.7](#figure9.7)). Now we
    don’t have a perfectly normal distribution, but it’s close enough that we can
    use the properties to understand our most common values and to make predictions
    about values we might see in the future.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这些概率？这是因为这些是正态分布的已知特性（如图9.7所示）。现在我们并不拥有一个完美的正态分布，但它足够接近，我们可以利用这些特性来理解我们最常见的值，并对未来可能看到的值进行预测。
- en: For example, if we had an extremely hot day in winter in NYC with a temperature
    of, say, 18 degrees Celsius, then we’d know *statistically* that this is an extreme
    temperature. We know that it’s extreme because it’s more than three standard deviations
    (SDs) from the average temperature, so a day with this temperature is unlikely
    to occur. That doesn’t mean that such a day won’t ever occur, but it means that
    it has a low probability based on the data we analyzed from the past 100 years.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们纽约市在冬天有一个极端的高温天气，比如说18摄氏度，那么我们可以从统计学上知道这是一个极端的温度。我们知道这是极端的，因为它比平均温度高出三个标准差（SDs），所以这样的温度一天发生的可能性很小。这并不意味着这样的日子永远不会发生，但根据我们从过去100年中分析的数据，它发生的概率很低。
- en: What’s interesting about the normal distribution and its properties is that
    much of statistics and science depend on it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布及其特性有趣之处在于，大量统计学和科学都依赖于它。
- en: Say that we run an experiment, make observations, and record data. We also need
    a *control group* to compare against and understand if the result of the experiment
    is significant. We set up a separate control group that is unaffected by the experiment,
    and again we observe and record data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们进行一项实验，进行观察并记录数据。我们还需要一个*对照组*来与之比较，并了解实验结果是否具有显著性。我们设置了一个不受实验影响的单独对照组，然后再次进行观察和记录数据。
- en: We can look at the distribution of the data from the control group and see how
    it relates to the experimental result. The further away the experimental result
    is from the average of the control group, the more confidence we’ll have that
    the experimental result is *statistically significant*. As the experimental result
    moves more than two SDs away from the control group result, we gain more and more
    confidence that the experiment *caused* the result and wasn’t just by accident
    or coincidence. This kind of statistical testing relies upon our data being normally
    distributed. If you’re trying this at home, please first verify that your data
    approximates the normal distribution.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看对照组的数据分布，看看它与实验结果有何关联。实验结果与对照组平均值的差距越大，我们对实验结果具有统计学意义的信心就越强。当实验结果比对照组结果超出两个标准差（SDs）时，我们越来越有信心认为实验是导致结果的原因，而不是偶然或巧合。这种统计检验依赖于我们的数据呈正态分布。如果您在家中尝试此方法，请首先验证您的数据是否近似正态分布。
- en: '![c09_07.eps](Images/c09_07.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![c09_07.eps](Images/c09_07.png)'
- en: '[Figure 9.7](#figureanchor9.7) Examples of how values relate to the normal
    distribution'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.7](#figureanchor9.7) 举例说明值与正态分布的关系'
- en: '[Listing 9.9](#listing9.9) shows the code for creating a frequency distribution
    that’s used to render the histogram that was shown in [figure 9.4](#figure9.4).
    First, we use the Data-Forge `bucket` function to organize our temperature values
    into the buckets required by the histogram. The `detectValues` function then summarizes
    the frequency of the *bucketed* values. The output is our frequency table. We
    need to call `orderBy` to sort the frequency table by value so that it’s in the
    right order for the histogram.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.9](#listing9.9)展示了创建用于绘制[图9.4](#figure9.4)中显示的直方图的频率分布的代码。首先，我们使用Data-Forge的`bucket`函数将我们的温度值组织成直方图所需的桶。然后`detectValues`函数总结了*桶化*值的频率。输出是我们的频率表。我们需要调用`orderBy`来按值对频率表进行排序，以便它以直方图正确的顺序排列。'
- en: Listing 9.9 Computing frequency distribution and histogram for NYC temperatures
    (listing-9.9.js)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 计算纽约市温度的频率分布和直方图（listing-9.9.js）
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note in [listing 9.9](#listing9.9) how we read the entire 100-year data set
    for NYC, but we then filter the data so that we’re left with only temperatures
    that occurred in winter months.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[列表9.9](#listing9.9)中，我们如何读取纽约市100年的整个数据集，但我们随后过滤数据，只留下在冬季月份发生的温度。
- en: Now we have tools for describing our data set, comparing data sets, and understanding
    which values are normal and which are extreme. Let’s turn our attention to techniques
    for analyzing time series data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了描述我们的数据集、比较数据集和理解哪些值是正常值以及哪些是极端值所需的工具。让我们将注意力转向分析时间序列数据的技术。
- en: 9.7 Time series
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 时间序列
- en: A time series is a series of data points that are *ordered* or *indexed by*
    date and/or time. Our data set for weather in NYC is a time series because it
    is composed of daily weather readings ordered by date.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是一系列按日期和/或时间顺序排列或索引的数据点。我们关于纽约市天气的数据集是一个时间序列，因为它由按日期排序的每日天气读数组成。
- en: We can use the techniques in this section for detecting trends and patterns
    that occur over time and for comparing time series data sets.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用本节中的技术来检测随时间发生的变化的趋势和模式，以及比较时间序列数据集。
- en: 9.7.1 Yearly average temperature
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 年度平均温度
- en: '[Figure 9.8](#figure9.8) is a chart of yearly average temperature in NYC over
    the past 100 years. To produce this chart, I used the *group and summarize* technique
    to create a yearly time series with the average temperature per year. Then I created
    the line chart as a visual representation of the time series data.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.8](#figure9.8)是过去100年纽约市年度平均温度的图表。为了生成此图表，我使用了*分组和总结*技术来创建一个按年度平均温度的时间序列。然后我创建了线形图作为时间序列数据的视觉表示。'
- en: '![c09_08.tif](Images/c09_08.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![c09_08.tif](Images/c09_08.png)'
- en: '[Figure 9.8](#figureanchor9.8) Average yearly temperature in NYC for the past
    100 years'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.8](#figureanchor9.8)过去100年纽约市的平均年度温度'
- en: '[Listing 9.10](#listing9.10) shows the code that groups the data by year and
    produces the yearly average temperature. It calls the `renderLineChart` toolkit
    function that I prepared for you. In chapters 10 and 11, we’ll look more closely
    at how such charts are created. You can run this code, and it will produce the
    chart shown in [figure 9.8](#figure9.8).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.10](#listing9.10)展示了按年份分组数据并生成年度平均温度的代码。它调用了我为你们准备的`renderLineChart`工具函数。在第10章和第11章中，我们将更详细地探讨此类图表的创建过程。你可以运行此代码，它将生成[图9.8](#figure9.8)中所示的图表。'
- en: Listing 9.10 Group by year and summarize temperature data for NYC (listing-9.10.js)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 按年份分组并总结纽约市的温度数据（listing-9.10.js）
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We might have created a chart from the daily data, but that would be noisy with
    wild day-to-day fluctuations. Noisy data makes it more difficult to spot trends
    and patterns—that’s why we grouped by year before making the chart.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经从每日数据中创建了一个图表，但那将会有很多噪声，因为每天的波动很大。噪声数据使得观察趋势和模式更加困难——这就是为什么我们在制作图表之前按年份分组的原因。
- en: Summarizing our data on a yearly basis makes it much easier to spot the upward
    trend in temperature. However, the data is still noisy. Did you notice the large
    up and down movements in the chart? Such variability can make it difficult for
    us to be sure about any trends or patterns that we think we see. We think we can
    see an uptrend in [figure 9.8](#figure9.8), but how can we know for sure?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按年度总结我们的数据使得观察温度上升的趋势变得容易得多。然而，数据仍然存在噪声。你注意到图表中大幅度的上下波动了吗？这种变异性可能会使得我们难以确定我们认为是的趋势或模式。我们认为我们可以在[图9.8](#figure9.8)中看到上升趋势，但我们如何才能确定呢？
- en: 9.7.2 Rolling average
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 滚动平均
- en: If we want to see the trend more clearly, we need a way to eliminate the noise.
    One way to do this is by generating a *rolling average* (also known as a *moving
    average*) from the yearly temperature time series. We can chart this new time
    series as shown in [figure 9.9](#figure9.9).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更清楚地看到趋势，我们需要一种消除噪声的方法。一种方法是从年温度时间序列中生成一个*滚动平均*（也称为*移动平均*）。我们可以像[图9.9](#figure9.9)中那样绘制这个新的时间序列。
- en: '![c09_09.tif](Images/c09_09.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![c09_09.tif](Images/c09_09.png)'
- en: '[Figure 9.9](#figureanchor9.9) Twenty-year rolling average of NYC temperatures
    for the past 100 years'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.9](#figureanchor9.9) 过去100年纽约市20年滚动平均温度'
- en: Notice how [figure 9.9](#figure9.9) is like a smoothed-out version of the chart
    in [figure 9.8](#figure9.8). This smoothing out eliminates much of the noise and
    allows us to more clearly see the upward trend.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[图9.9](#figure9.9)是如何像[图9.8](#figure9.8)的图表的平滑版本。这种平滑消除了大部分噪声，并允许我们更清楚地看到上升趋势。
- en: To compute the rolling average, we use the Data-Forge `rollingWindow` function.
    We first encountered this function in chapter 5, at which time I said I’d explain
    it later. Well, now is the time for a better explanation, so let’s understand
    how this works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算滚动平均，我们使用Data-Forge的`rollingWindow`函数。我们第一次遇到这个函数是在第5章，当时我说我会稍后解释。好吧，现在是时候更好地解释它了，让我们了解它是如何工作的。
- en: The `rollingWindow` function moves a *data window* across the time series one
    value at a time. Each window is a group of values on which we may perform a statistics
    operation. In this case we’re using *average*, but we could just as easily use
    our functions for sum or standard deviation. The output of the operation performed
    on each window is captured, and in the process, we compute a new time series.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`rollingWindow`函数将一个*数据窗口*逐个值地移动到时间序列上。每个窗口是一组值，我们可以在其上执行统计操作。在这种情况下，我们使用*平均*，但我们同样可以使用我们的求和或标准差函数。对每个窗口执行的操作的输出被捕获，在这个过程中，我们计算出一个新的时间序列。'
- en: '[Figure 9.10](#figure9.10) illustrates the process of computing a rolling average
    on a series of values. For ease of illustration, this is a small set of values
    and the window size is set to four. The data window starts at the beginning of
    the time series, and the first set of four values is averaged to produce the number
    9.025 (A).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.10](#figure9.10) 阐述了在一系列值上计算滚动平均的过程。为了便于说明，这是一个小值集，窗口大小设置为四。数据窗口从时间序列的开始处开始，第一组四个值被平均，产生出数字9.025（A）。'
- en: The data window is then moved one value forward, and the operation is repeated
    on the next four values, producing the number 8.875 (B).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将数据窗口向前移动一个值，并在下一个四个值上重复操作，产生出数字8.875（B）。
- en: This process continues until the data window reaches the end of the time series,
    where it produces the number 3.225 from the last four values (C). We now have
    a new time series that is averaged out over time and produces a smoothed chart
    similar to that in [figure 9.9](#figure9.9).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程一直持续到数据窗口达到时间序列的末尾，此时它从最后四个值（C）中产生出数字3.225。现在我们有一个新的时间序列，它是随时间平均出来的，并生成了一条类似于[图9.9](#figure9.9)的平滑图表。
- en: '![c09_10.eps](Images/c09_10.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![c09_10.eps](Images/c09_10.png)'
- en: '[Figure 9.10](#figureanchor9.10) The process of producing a rolling average
    from a time series'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.10](#figureanchor9.10) 从时间序列生成滚动平均的过程'
- en: In the following listing, we create a new code module called `time-series.js`
    for our toolkit. We start it with the function `rollingAverage` that computes
    a rolling average from a time series. The period of the average or the length
    of the data window is passed in as a parameter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们为我们的工具包创建了一个名为`time-series.js`的新代码模块。我们以计算时间序列的滚动平均的`rollingAverage`函数开始。平均的周期或数据窗口的长度作为参数传入。
- en: Listing 9.11 A new toolkit module with the `rollingAverage` function (toolkit/time-series.js)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 带有`rollingAverage`函数的新工具包模块（toolkit/time-series.js）
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note in [listing 9.11](#listing9.11) how we reuse the `average` function that
    we created earlier.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[列表9.11](#listing9.11)中我们如何重用我们之前创建的`average`函数。
- en: The following listing shows how we can use our new `rollingAverage` function
    to compute the rolling average temperature for NYC using a period of 20 years.
    At the end of [listing 9.12](#listing9.12), we render a line chart. You can run
    this code, and it will produce the chart shown in [figure 9.9](#figure9.9).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们如何使用新的`rollingAverage`函数，通过20年的周期来计算纽约市的滚动平均温度。在[列表9.12](#listing9.12)的末尾，我们绘制了一条线形图。你可以运行这段代码，它将生成[图9.9](#figure9.9)中所示的图表。
- en: Listing 9.12 Computing a 20-year rolling average of NYC temperature (listing-9.12.js)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 计算纽约市温度的20年滚动平均值（listing-9.12.js）
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 9.7.3 Rolling standard deviation
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.3 滚动标准差
- en: We can also use Data-Forge’s `rollingWindow` function to create a rolling standard
    deviation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Data-Forge的`rollingWindow`函数来创建滚动标准差。
- en: Assuming we compute a rolling standard deviation over a rolling average of NYC
    temperature and then plot it as a line chart, we would end up with the chart similar
    to what’s shown in [figure 9.11](#figure9.11).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计算了纽约市温度的滚动平均值上的滚动标准差，并将其作为折线图绘制，我们最终会得到类似于[图9.11](#figure9.11)所示的图表。
- en: This allows us to see how temperatures are fluctuating over time. We’re using
    standard deviation as a way to visualize variability or volatility over time.
    We can see from the chart that in the 1960s, temperature fluctuations declined
    and stabilized. Since the start of the 1970s, temperature variability has been
    on the rise, and this might indicate that in the future we can expect more extreme
    fluctuations in temperature.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够看到温度随时间的变化情况。我们使用标准差作为一种可视化随时间变化波动性或波动性的方法。从图表中我们可以看出，在20世纪60年代，温度波动下降并趋于稳定。自20世纪70年代初以来，温度波动性一直在上升，这可能会表明在未来我们可以预期温度将出现更极端的波动。
- en: '![c09_11.tif](Images/c09_11.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![c09_11.tif](Images/c09_11.png)'
- en: '[Figure 9.11](#figureanchor9.11) Twenty-year rolling standard deviation of
    NYC temperatures'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.11](#figureanchor9.11) 纽约市温度的20年滚动标准差'
- en: If you added a `rollingStandardDeviation` function to your time series code
    module, it would be similar to the `rollingAverage` function we created in the
    last section but computed with the `std` function instead of the `average` function.
    I’ll leave it as a reader exercise to create this function if you’d like to plot
    a chart like [figure 9.11](#figure9.11).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在时间序列代码模块中添加了一个`rollingStandardDeviation`函数，它将类似于我们在上一节中创建的`rollingAverage`函数，但使用`std`函数而不是`average`函数来计算。如果您想绘制类似于[图9.11](#figure9.11)的图表，我将把它留作读者的练习来创建这个函数。
- en: 9.7.4 Linear regression
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.4 线性回归
- en: Using a rolling average isn’t our only option for highlighting trends in a time
    series. We can also use linear regression. In addition, with linear regression
    we can forecast and predict future data points.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用滚动平均并不是我们突出时间序列趋势的唯一选项。我们还可以使用线性回归。此外，使用线性回归，我们可以预测和预测未来的数据点。
- en: We first saw an example of linear regression in chapter 5 when we used Excel’s
    `FORECAST` function to forecast a data point into the future. Under the hood,
    this was using linear regression, a modeling technique that fits a *line* to our
    data set. We can then use the *equation* of that *line* to forecast a trend into
    the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第五章中首次看到了线性回归的例子，当时我们使用Excel的`FORECAST`函数预测一个数据点进入未来。在底层，这是使用线性回归，一种将一条线拟合到我们的数据集的建模技术。然后我们可以使用那条线的*方程*来预测未来的趋势。
- en: '[Figure 9.12](#figure9.12) shows the yearly temperature in NYC for the past
    100 years. We computed and overlaid a linear regression of this chart (the orange
    line). This makes the upward trend unambiguous. We forecasted the temperature
    out to 2100 so that we can predict how much it might rise by heading into the
    future.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.12](#figure9.12)显示了过去100年纽约市的年温度。我们计算并叠加了此图表的线性回归（橙色线）。这使得上升趋势变得明确。我们预测了到2100年的温度，以便我们可以预测未来可能会上升多少。'
- en: 'Creating a linear regression involves complex math that figures out how to
    best fit a line to our data points. It’s the toughest math yet in this book. Let’s
    avoid that and use a third-party library to do the heavy lifting for us. If you
    installed dependencies for the Chapter-9 code repository, you already have simple-statistics
    installed. If not, you can install it in a fresh Node.js project as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线性回归涉及复杂的数学，它确定如何将一条线最好地拟合到我们的数据点。这是本书中最难的数学。让我们避免它，并使用第三方库来为我们做繁重的工作。如果您为第9章代码库安装了依赖项，您已经安装了simple-statistics。如果没有，您可以在新的Node.js项目中安装它，如下所示：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In [listing 9.13](#listing9.13), we add a `linearRegression` function to our
    `time-series.js` code module. This is based on the `rollingAverage` function that
    we created earlier in [listing 9.12](#listing9.12), but instead of computing the
    average of the data window, we compute the linear regression using the simple-statistics
    library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表9.13](#listing9.13)中，我们将一个`linearRegression`函数添加到我们的`time-series.js`代码模块中。这是基于我们之前在[列表9.12](#listing9.12)中创建的`rollingAverage`函数，但不是计算数据窗口的平均值，而是使用simple-statistics库计算线性回归。
- en: Listing 9.13 Adding a linear regression function to our time series toolkit
    (toolkit/time-series.js)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 将线性回归函数添加到我们的时间序列工具包中（toolkit/time-series.js）
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![c09_12.eps](Images/c09_12.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![c09_12.eps](Images/c09_12.png)'
- en: '[Figure 9.12](#figureanchor9.12) Linear regression used to forecast the average
    temperature for NYC in 2100'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.12](#figureanchor9.12) 使用线性回归预测 2100 年纽约市平均温度'
- en: The following listing shows how we use our new `linearRegression` function to
    compute a linear regression from our NYC temperature time series. You should run
    this listing to see that it produces the chart from [figure 9.12](#figure9.12).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们如何使用新的 `linearRegression` 函数从纽约市温度时间序列中计算线性回归。你应该运行此列表以查看它是否生成了 [图
    9.12](#figure9.12) 中的图表。
- en: Listing 9.14 Computing a linear regression to forecast the temperature in 2100
    (listing-9.14.js)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 计算线性回归以预测 2100 年的温度（listing-9.14.js）
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 9.7.5 Comparing time series
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.5 比较时间序列
- en: How do we compare one time series to another? Say that we want to compare the
    temperature in NYC to LA. We could describe each data set using average and standard
    deviation, but what’s more informative when dealing with time series data is to
    visualize and compare in a chart.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何比较一个时间序列与另一个时间序列？比如说，我们想比较纽约市和洛杉矶的温度。我们可以使用平均值和标准差来描述每个数据集，但在处理时间序列数据时，更具有信息量的做法是可视化和在图表中进行比较。
- en: We could render both time series in a chart, as shown in [figure 9.13](#figure9.13),
    but this chart makes the comparison difficult because of the large vertical gap
    between the time series. It would be better if we could make the comparison *side
    by side*, although to do this, we have to find a way to overlay time series so
    that they’re directly comparable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图表中绘制两个时间序列，如图 [图 9.13](#figure9.13) 所示，但由于时间序列之间有较大的垂直差距，这使得比较变得困难。如果能将它们并排比较会更好，尽管要做到这一点，我们必须找到一种方法来叠加时间序列，以便它们可以直接比较。
- en: '![c09_13.eps](Images/c09_13.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![c09_13.eps](Images/c09_13.png)'
- en: '[Figure 9.13](#figureanchor9.13) Comparing NYC and LA temperature in the same
    chart'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.13](#figureanchor9.13) 在同一图表中比较纽约市和洛杉矶的温度'
- en: Measuring Difference
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测量差值
- en: One way to compare the two time series is to compute the difference between
    them. We can then chart the difference, as shown in [figure 9.14](#figure9.14).
    This data series fluctuates wildly, so we might fit a linear regression (the orange
    line) to more easily see the trend. This looks like a slight upward trend in the
    difference between LA and NYC temperatures. What does this mean? It means that
    LA is getting hotter slightly more quickly than NYC.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个时间序列的一种方法是通过它们之间的差值。然后我们可以绘制差值图，如图 [图 9.14](#figure9.14) 所示。这个数据序列波动很大，因此我们可能需要拟合一个线性回归（橙色线）以便更容易地看到趋势。这看起来是洛杉矶和纽约市温度差的一个轻微上升趋势。这意味着什么？这意味着洛杉矶的气温上升速度略快于纽约市。
- en: '![c09_14.tif](Images/c09_14.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![c09_14.tif](Images/c09_14.png)'
- en: '[Figure 9.14](#figureanchor9.14) Measuring the difference between NYC and LA
    temperatures'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.14](#figureanchor9.14) 测量纽约市和洛杉矶温度之间的差值'
- en: '[Listing 9.15](#listing9.15) shows how we might add a `difference` function
    to our time series code module to compute the difference between two time series.
    This uses Data-Forge’s `zip` function to zip together our two-time series. The
    `zip` function produces a new series using the function we provide. The function
    computes the difference between each value in the series.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.15](#listing9.15) 展示了如何将 `difference` 函数添加到我们的时间序列代码模块中，以计算两个时间序列之间的差值。这使用了
    Data-Forge 的 `zip` 函数将我们的两个时间序列组合在一起。`zip` 函数使用我们提供的函数生成一个新的序列。该函数计算序列中每个值的差值。'
- en: Listing 9.15 Adding a difference function to our time series toolkit (toolkit/time-series.js)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 将差分函数添加到我们的时间序列工具包中（toolkit/time-series.js）
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To put our new `difference` function to work, we must load two data sets. The
    code to compute the chart shown in [figure 9.14](#figure9.14) is similar to listings
    9.12 and 9.14, but we don’t load only the weather data for NYC; we also load the
    data for LA. When we have the two time series loaded, we can use our `difference`
    function to compute the difference between them. As you can see in [figure 9.14](#figure9.14),
    I also used our `linearRegression` function to produce a linear regression of
    the difference. I’ll leave this as an exercise for you to create the code that
    produces [figure 9.14](#figure9.14).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们新的 `difference` 函数，我们必须加载两个数据集。计算[图9.14](#figure9.14)中显示的图表的代码与9.12和9.14中的列表类似，但我们不仅加载了纽约市的天气数据；我们还加载了洛杉矶的数据。当我们加载了这两个时间序列后，我们可以使用我们的
    `difference` 函数来计算它们之间的差异。正如你在[图9.14](#figure9.14)中可以看到的，我还使用了我们的 `linearRegression`
    函数来生成差异的线性回归。我将把这个留给你作为一个练习，让你编写生成[图9.14](#figure9.14)的代码。
- en: Standardizing the data points for comparison
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准化数据点以进行比较
- en: Assuming that we do want to plot both NYC and LA temperatures in a chart *and*
    compare them directly, we must standardize our data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们确实想在图表中绘制纽约市和洛杉矶的温度，并且直接进行比较，我们必须标准化我们的数据。
- en: When I say standardize the data, I mean that we’re bringing both our time series
    into a common scale so that they’re directly comparable. The reason we’re doing
    this for temperature data (which technically is already in the same scale) is
    that we don’t care about the actual temperatures. Instead, we want to compare
    the year-to-year fluctuations. In statistics speak, we’d say that we’re converting
    our data to *standard scores*, also known as *z-values* or *z-scores*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说标准化数据时，我的意思是我们将两个时间序列都转换到同一个尺度，以便它们可以直接比较。我们这样做的原因是，对于温度数据（技术上已经处于相同的尺度），我们并不关心实际的温度。相反，我们想要比较年与年之间的波动。用统计学的术语来说，我们可以说我们正在将我们的数据转换为*标准分数*，也称为*z值*或*z分数*。
- en: In [figure 9.15](#figure9.15) you can see the comparison of NYC and LA temperatures
    after they’ve been standardized. I should add that this kind of standardization
    isn’t only for time series data, it actually works for any kind of data that we
    might wish to compare.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9.15](#figure9.15)中，你可以看到纽约市和洛杉矶温度经过标准化后的比较。我应该补充一点，这种标准化不仅适用于时间序列数据，实际上它适用于我们可能希望比较的任何类型的数据。
- en: How do we standardize our data? It’s simple. We must convert each data point
    to the number of standard deviations from the average. We first compute the average
    and the standard deviation (we keep coming back to these fundamental statistics
    tools!). Our code then visits each data point and subtracts its value from the
    average. The following listing shows this in action. If you run this code, it
    will generate the chart from [figure 9.15](#figure9.15).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何标准化我们的数据？很简单。我们必须将每个数据点转换为平均值的标准差数。我们首先计算平均值和标准差（我们经常回到这些基本的统计工具上！）。然后我们的代码遍历每个数据点，并从其值中减去平均值。以下列表展示了这一过程。如果你运行此代码，它将生成[图9.15](#figure9.15)中的图表。
- en: Listing 9.16 Standardizing NYC and LA temperature data for easier comparison
    (listing-9.16.js)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 标准化纽约市和洛杉矶温度数据以便于比较（listing-9.16.js）
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![c09_15.tif](Images/c09_15.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![c09_15.tif](Images/c09_15.png)'
- en: '[Figure 9.15](#figureanchor9.15) Comparing standardized NYC and LA temperatures'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.15](#figureanchor9.15) 比较标准化的纽约市和洛杉矶温度'
- en: 9.7.6 Stacking time series operations
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.6 时间序列操作的堆叠
- en: You’ve probably noticed this already, but I’d like to point it out explicitly.
    The time series operations we’ve created so far (rolling average, rolling standard
    deviation, linear regression, and difference) can all be stacked up like normal
    mathematical operations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了这一点，但我还想明确指出。我们迄今为止创建的时间序列操作（滚动平均值、滚动标准差、线性回归和差异）都可以像正常的数学运算一样堆叠起来。
- en: You’ve already seen in section 9.7.5 where we computed the difference between
    NYC and LA temperatures and then stacked a linear regression on top of that. We
    can apply the operations in almost any order that we want or at least any order
    that makes sense and suits our purpose.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在9.7.5节中看到了我们如何计算纽约市和洛杉矶温度的差异，并在其上堆叠线性回归。我们可以以几乎任何我们想要的顺序或至少任何有意义的顺序应用这些操作。
- en: For instance, we might produce a rolling average from NYC temperature and then
    layer a linear regression on top of that, or we might create a rolling standard
    deviation and stack a moving average on top of that. We can mix and match these
    operations as we need, depending on the understanding that we’re trying to extract
    from our data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能从纽约市的温度中生成滚动平均值，然后在上面叠加线性回归，或者我们可能创建滚动标准差，然后在上面叠加移动平均。我们可以根据我们试图从数据中提取的理解来混合和匹配这些操作。
- en: 9.8 Understanding relationships
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 理解关系
- en: Say we have two data variables and we suspect a relationship between them. We
    can use a scatter plot chart to help us identify the relationship. Looking at
    the scatter plot, perhaps you’ll notice that when one variable goes up, the other
    also goes up and vice versa. In statistics, this is called *correlation*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个数据变量，并且我们怀疑它们之间存在某种关系。我们可以使用散点图来帮助我们识别这种关系。观察散点图，你可能注意到当一个变量上升时，另一个变量也上升，反之亦然。在统计学中，这被称为*相关性*。
- en: Staying with the weather theme, let’s say we want to see if there’s a relationship
    between rainfall and umbrella sales. Now as you might imagine, it’s difficult
    to find data on umbrella sales, so I’ve *synthesized* data (using custom JavaScript
    code) so that I can show you what correlated data looks like. If your business
    is being an umbrella salesperson in New York’s Central Park, then you might want
    to use this technique to determine how the amount of rainfall affects your sales!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持天气主题，假设我们想看看降雨量和雨伞销量之间是否存在关系。现在，正如你可能想象的那样，找到雨伞销量的数据很困难，所以我使用自定义JavaScript代码*合成*了数据，以便我可以向你展示相关数据看起来是什么样子。如果你的业务是在纽约中央公园卖雨伞，那么你可能想使用这种技术来确定降雨量如何影响你的销售！
- en: 9.8.1 Detecting correlation with a scatter plot
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.1 使用散点图检测相关性
- en: '[Figure 9.16](#figure9.16) is a scatter plot chart of umbrella sales versus
    rainfall. The Y axis shows the number of umbrellas that were sold. The X axis
    shows the amount of rainfall (in mm). You can see that the data points are scattered
    in a noticeable band from bottom left to top right. The points aren’t particularly
    evenly distributed, but you can easily see that they’re more or less arranged
    in a line that’s pointing diagonally up and to the right. From this, we can infer
    a kind of positive relationship or *correlation* between the amount of rainfall
    and the number of umbrellas that we’ll sell on any given day.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.16](#figure9.16) 是雨伞销量与降雨量的散点图。Y轴显示售出的雨伞数量。X轴显示降雨量（以毫米为单位）。你可以看到数据点从左下角到右上角呈现出一个明显的带状分布。这些点分布并不特别均匀，但你很容易看出它们大致排列成一条对角向上和向右的线。从这个角度来看，我们可以推断出降雨量和我们将在任何给定的一天售出的雨伞数量之间存在一种正相关或*相关性*。'
- en: '![c09_16.png](Images/c09_16.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![c09_16.png](Images/c09_16.png)'
- en: '[Figure 9.16](#figureanchor9.16) Scatter plot of rainfall vs umbrella sales'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.16](#figureanchor9.16) 降雨量与雨伞销量散点图'
- en: 9.8.2 Types of correlation
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2 相关性的类型
- en: '[Figure 9.16](#figure9.16) shows a level of positive correlation between rainfall
    and umbrella sales. A positive correlation means that as one variable increases,
    the other does as well. We might also have seen a negative correlation or no correlation,
    as shown in [figure 9.17](#figure9.17).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.16](#figure9.16) 显示了降雨量和雨伞销量之间存在正相关性。正相关意味着当一个变量增加时，另一个变量也会增加。我们也可能看到负相关或无相关，如[图9.17](#figure9.17)所示。'
- en: '![c09_17.eps](Images/c09_17.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![c09_17.eps](Images/c09_17.png)'
- en: '[Figure 9.17](#figureanchor9.17) Comparing positive, negative, and no correlation'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.17](#figureanchor9.17) 比较正相关、负相关和无相关'
- en: When we’ve seen a relationship between two variables in this way, we can use
    it to predict future values. We’d do this by computing a linear regression with
    our two data series as input. This gives us the ability to forecast one value
    based on the other.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式看到两个变量之间的关系时，我们可以用它来预测未来的值。我们会通过计算两个数据序列作为输入的线性回归来做这件事。这使我们能够根据另一个值来预测一个值。
- en: Such forecasting is limited by the strength of the correlation. If your data
    points are scattered close to your linear regression line, then the correlation
    is high, and your forecasting ability will be good. When the data points are scattered
    further apart, this reduces the predictive ability of the linear regression.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的预测受相关性强度的限制。如果你的数据点靠近线性回归线，那么相关性就很高，你的预测能力就会很好。当数据点分布得更远时，这会降低线性回归的预测能力。
- en: 9.8.3 Determining the strength of the correlation
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.3 确定相关性的强度
- en: We don’t have to rely on our visual judgment to determine the strength of the
    correlation between two variables. We can quantify the amount and type of correlation
    using the *correlation coefficient,* which is a numerical measure of correlation.
    The values of the correlation coefficient range from –1 to +1, with –1 indicating
    a perfect negative correlation and +1 indicating a perfect positive correlation.
    This forms the spectrum shown in [figure 9.18](#figure9.18). Negative correlation
    is on the left, positive on the right, and no correlation is in the middle.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必依赖我们的视觉判断来确定两个变量之间相关性的强度。我们可以使用*相关系数*来量化相关性的数量和类型，这是一个相关性的数值度量。相关系数的值范围从-1到+1，其中-1表示完全负相关，+1表示完全正相关。这形成了[图9.18](#figure9.18)中显示的光谱。负相关位于左侧，正相关位于右侧，无相关位于中间。
- en: The correlation coefficient for rainfall versus umbrella sales turns out to
    be around 0.64\. [Figure 9.18](#figure9.18) shows that this value fits in the
    spectrum under the category of *strong positive correlation*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 雨量与雨伞销售的相关系数结果是大约0.64。[图9.18](#figure9.18)显示这个值符合*强烈正相关*类别下的光谱。
- en: '![c09_18.eps](Images/c09_18.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![c09_18.eps](Images/c09_18.png)'
- en: '[Figure 9.18](#figureanchor9.18) The correlation coefficient for rainfall vs
    umbrella sales on the spectrum of possible values'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.18](#figureanchor9.18) 雨量与雨伞销售的相关系数在可能值的光谱上'
- en: In this case, it’s obvious that more rainfall causes more people to buy umbrellas.
    We’d like to say this is a *causal relationship*, but we can’t know that for sure!
    This should make us think of the popular saying “correlation doesn’t imply causation.”
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，显然更多的降雨会导致更多的人购买雨伞。我们想说这是一种*因果关系*，但我们不能确定这一点！这应该让我们想到流行的说法“相关性不等于因果关系”。
- en: What does that mean? When we see strong correlation between two data variables,
    we’re enticed to think that one data variable *causes* the other, but correlation
    doesn’t work this way. In this example, it seems obvious that the variables are
    causally linked (well, at least I *synthesized* the data so it would look that
    way). Although in other cases it won’t be so clear cut and you shouldn’t assume
    that one variable causes the other, it’s entirely possible that another as yet
    undiscovered variable *is* the causal variable and is responsible for the relationship
    between the two variables under examination. For example, it might be the forecasted
    news of the rainfall that drives up umbrella sales, and then the rain comes later!
    I bet you hadn’t thought of that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？当我们看到两个数据变量之间有强烈的相关性时，我们会倾向于认为一个数据变量*导致*另一个，但相关性并不这样工作。在这个例子中，变量之间似乎有明显的因果联系（嗯，至少我是*合成*了数据，让它看起来是这样）。尽管在其他情况下可能不会这么明显，你不应该假设一个变量导致另一个变量，但完全有可能另一个尚未发现的变量*是*因果变量，并负责两个被检验变量之间的关系。例如，可能是预报的降雨新闻推动了雨伞销售，然后雨才来！我敢打赌你没想到这一点。
- en: 9.8.4 Computing the correlation coefficient
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.4 计算相关系数
- en: You have various ways to compute the correlation coefficient, and in each case
    the math is rather complicated. Fortunately, we already have the simple-statistics
    code module, and it has a convenient `sampleCorrelation` function ready for us
    to use. The following listing shows how we can use this function to compute the
    correlation coefficient for rainfall versus umbrella sales since 2013.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多种方法可以计算相关系数，并且每种情况下数学都相当复杂。幸运的是，我们已经有了一个简单的统计代码模块，它有一个方便的`sampleCorrelation`函数供我们使用。以下代码清单显示了如何使用此函数来计算自2013年以来雨量和雨伞销售的相关系数。
- en: Listing 9.17 Computing the correlation coefficient for rainfall vs umbrella
    sales since 2013 (listing-9.17.js)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清单9.17 自2013年以来计算雨量和雨伞销售的相关系数（listing-9.17.js）
- en: '[PRE18]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can run [listing 9.17](#listing9.17), and it will print a correlation coefficient
    of around 0.64, which should meet our expectations after having visually studied
    the scatter plot chart in [figure 9.16](#figure9.16). We expected a strong positive
    correlation, but not a perfect correlation. We’ve quantified the relationship
    between rainfall and umbrella sales.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行[代码清单9.17](#listing9.17)，它将打印出大约0.64的相关系数，这在视觉上研究了[图9.16](#figure9.16)中的散点图图表后应该符合我们的预期。我们预期有一个强烈的正相关，但不是完美的相关。我们已经量化了雨量和雨伞销售之间的关系。
- en: You now have various tools at your disposal for analyzing your data. You can
    find trends and patterns, compare your data sets, and make predictions about future
    data points.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您拥有各种工具来分析您的数据。您可以找到趋势和模式，比较您的数据集，并对未来的数据点进行预测。
- en: In this chapter, we used specially prepared functions to create our charts.
    In the coming chapters 10 and 11, we’ll take a step back and learn how to create
    such charts both in the browser (chapter 10) and on the server side (chapter 11).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了特别准备好的函数来创建我们的图表。在接下来的第10章和第11章中，我们将退后一步，学习如何在浏览器中（第10章）和服务器端（第11章）创建这样的图表。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You learned about fundamental statistics operations: sum, average, and standard
    deviation.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学习了基本的统计操作：总和、平均值和标准差。
- en: You discovered how to group and summarize a data set to boil it down and make
    it easier to understand.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您发现了如何对数据集进行分组和总结，以便将其简化并使其更容易理解。
- en: We discussed how to compare data sets using standardization, differences, and
    the distribution of values.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了如何使用标准化、差异和值的分布来比较数据集。
- en: You learned how to make predictions about new values using a distribution.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学习了如何使用分布来对新值进行预测。
- en: We explored analysis of time series data using rolling average, rolling standard
    deviation, and linear regression.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了使用滚动平均值、滚动标准差和线性回归来分析时间序列数据。
- en: You learned that you can quantify the relationship of two data variables using
    the correlation coefficient.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您了解到可以使用相关系数来量化两个数据变量之间的关系。
