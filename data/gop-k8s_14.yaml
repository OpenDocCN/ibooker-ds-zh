- en: 11 Flux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 Flux
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What is Flux?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Flux？
- en: Deploying an application using Flux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flux部署应用程序
- en: Setting up multitenancy with Flux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flux设置多租户
- en: In this chapter, you will learn how to use the Flux GitOps operator to deploy
    our reference example application to Kubernetes. You will also learn how Flux
    can be used as part of a multitenancy solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Flux GitOps操作员将我们的参考示例应用程序部署到Kubernetes。您还将了解Flux如何作为多租户解决方案的一部分使用。
- en: We recommend you read chapters 1, 2, 3, and 5 before reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在阅读本章之前阅读第1、2、3和5章。
- en: 11.1 What is Flux?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 什么是Flux？
- en: Flux is an open source project that implements GitOps-driven continuous deployment
    for Kubernetes. The project was started in 2016 at Weaveworks^([1](#pgfId-1088737))
    and joined the CNCF Sandbox three years later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是一个开源项目，它实现了基于GitOps的Kubernetes持续部署。该项目始于2016年Weaveworks，三年后加入了CNCF沙箱。
- en: Notably, Weaveworks is the same company that coined the term *GitOps*. Along
    with other great open source projects for Kubernetes, the company formulated GitOps
    best practices and contributed a lot to GitOps evangelizing. The Flux evolution
    illustrates how the idea of GitOps evolved over time, based on practical experience,
    into its current form.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Weaveworks是提出*GitOps*术语的公司。该公司还制定了Kubernetes的GitOps最佳实践，并为GitOps的推广做出了大量贡献。Flux的发展历程说明了GitOps理念如何基于实践经验随着时间的推移演变到当前的形式。
- en: The Flux project was created to automate container image delivery to Kubernetes
    and fill the gap between the continuous integration and continuous deployment
    processes. The workflow described in the project introduction blog is focused
    on Docker registry scanning, calculating the latest image version, and promoting
    it to the production cluster. After several iterations, the Flux team realized
    all the benefits of a Git-centric approach. Before publishing the v1.0 release,
    the project architecture was reworked to use Git as the source of truth and formulated
    the main phases of the GitOps workflow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Flux项目旨在自动化容器镜像交付到Kubernetes，并填补持续集成和持续部署过程之间的差距。项目介绍博客中描述的工作流程专注于Docker注册扫描、计算最新镜像版本并将其提升到生产集群。经过多次迭代，Flux团队意识到了以Git为中心的方法的所有优势。在发布v1.0版本之前，项目架构被重新设计，使用Git作为事实来源，并制定了GitOps工作流程的主要阶段。
- en: 11.1.1 What Flux does
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 Flux做什么
- en: Flux is laser focused on automated manifest delivery to the Kubernetes cluster.
    The project is probably the least opinionated GitOps operation of the operators
    described in this book. Flux does not introduce any additional layers on top of
    Kubernetes, such as applications or its own access control system. A single Flux
    instance manages one Kubernetes cluster and requires the user to maintain one
    Git repository that represents the cluster state. Instead of introducing user
    management, SSO integration, and its own access control, Flux typically runs inside
    of the managed cluster and relies on Kubernetes RBAC. This approach significantly
    simplifies the Flux configuration and helps flatten the learning curve.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Flux专注于将清单自动交付到Kubernetes集群。该项目可能是本书中描述的操作员中最少有偏见的GitOps操作。Flux不在Kubernetes之上引入任何额外的层，例如应用程序或其自己的访问控制系统。单个Flux实例管理一个Kubernetes集群，并要求用户维护一个代表集群状态的Git仓库。Flux通常在管理的集群内部运行，并依赖于Kubernetes
    RBAC。这种方法显著简化了Flux配置，并有助于降低学习曲线。
- en: RBAC Kubernetes supports role-based access control (RBAC), which allows containers
    to be bound to roles that give them permission to operate on various resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC Kubernetes支持基于角色的访问控制（RBAC），它允许容器绑定到赋予它们操作各种资源权限的角色。
- en: The simplicity of Flux also makes it virtually maintenance free and simple to
    integrate into cluster bootstrapping since no new component or admin privilege
    is required. With the Flux command-line interface, Flux deployment can be easily
    incorporated into the cluster provisioning scripts to enable automated cluster
    creation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Flux的简单性也使得它几乎无需维护，并且易于集成到集群引导过程中，因为不需要新的组件或管理员权限。使用Flux命令行界面，Flux部署可以轻松地集成到集群配置脚本中，以实现集群自动创建。
- en: Flux is not limited to only cluster bootstrapping. It is successfully used as
    a continuous deployment tool for applications. In the multitenant environment,
    each team can install an instance of Flux with limited access and use it to manage
    a single Namespace. That fully empowers the team to manage resources in the application
    Namespace and is still 100% secure because Flux access is managed by Kubernetes
    RBAC.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 不仅限于集群引导。它作为应用程序的持续部署工具被成功使用。在多租户环境中，每个团队都可以安装一个具有有限访问权限的 Flux 实例，并使用它来管理单个命名空间。这完全赋予了团队管理应用程序命名空间中资源的能力，并且仍然100%安全，因为
    Flux 访问由 Kubernetes RBAC 管理。
- en: The simplicity of the project brings advantages and disadvantages that are viewed
    differently by different teams. One of the most important considerations is that
    Flux has to be configured and maintained by the Kubernetes end user. That implies
    that the team gets more power but also has more responsibility. The alternate
    approach, which is taken by Argo CD, is to provide GitOps functions as a service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的简单性带来了优点和缺点，不同团队有不同的看法。最重要的考虑因素之一是 Flux 必须由 Kubernetes 最终用户配置和维护。这意味着团队获得了更多权力，但也承担了更多责任。另一种方法，即
    Argo CD 所采用的方法，是作为一项服务提供 GitOps 功能。
- en: 11.1.2 Docker registry scanning
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 Docker 仓库扫描
- en: In addition to the core functionality of GitOps, the project offers one more
    notable feature. Flux is able to scan the Docker registry and automatically update
    images in the deployment repository when new tags get pushed into the registry.
    Although this functionality is not a core GitOps feature, it simplifies the lives
    of developers and increases productivity. Let’s consider the developer workflow
    without automated deployment repository updates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 GitOps 的核心功能外，该项目还提供了一项显著的功能。Flux 能够扫描 Docker 仓库，并在新标签推送到仓库时自动更新部署仓库中的镜像。尽管这项功能不是
    GitOps 的核心功能，但它简化了开发者的工作，提高了生产力。让我们考虑在没有自动化部署仓库更新的开发者工作流程。
- en: '![](Images/CH11_F01_Yuen.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F01_Yuen.png)'
- en: Figure 11.1 A Developer pushes new images manually using continuous integration
    tools, and then updates the deployment Git repository with a new image’s tag.
    Flux notices the manifest change in Git and propagates it to the Kubernetes cluster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 开发者使用持续集成工具手动推送新镜像，然后使用新镜像的标签更新部署 Git 仓库。Flux 注意到 Git 中的清单变更并将其传播到 Kubernetes
    集群。
- en: Developer teams often complain about the second step, because it requires manual
    work, and they try to automate it. Typically the solution is to automate manifest
    updates using the CI pipeline. The CI approach solves the problem but requires
    scripting and might be fragile.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队经常抱怨第二步，因为它需要手动操作，所以他们试图自动化它。通常的解决方案是使用 CI 流水线自动化清单更新。CI 方法解决了问题，但需要脚本编写，可能不够稳定。
- en: Flux goes one step beyond and automates the deployment repository updates. Instead
    of using the CI system and scripting, you can configure Flux to automatically
    update the deployment repository every time a new image is pushed to the Docker
    registry. The developer’s workflow with automated Docker registry scanning is
    represented in figure 11.2.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 走得更远一步，自动化了部署仓库的更新。你不必使用 CI 系统和脚本，可以配置 Flux 在每次新镜像推送到 Docker 仓库时自动更新部署仓库。自动化
    Docker 仓库扫描的开发者工作流程在图 11.2 中表示。
- en: Figure 11.2 When automated repository updates are enabled, Flux takes full control
    over both the deployment repository and Kubernetes cluster management.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 当启用自动化仓库更新时，Flux 完全控制部署仓库和 Kubernetes 集群管理。
- en: '![](Images/CH11_F02_Yuen.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F02_Yuen.png)'
- en: The developer’s only responsibility is to make a code change and let the CI
    system push the updated Docker image into the registry. The automated deployment
    repository management is especially useful if the image tags follow semantic versioning
    convention.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的唯一责任是进行代码更改，并让 CI 系统将更新的 Docker 镜像推送到仓库。如果镜像标签遵循语义版本控制约定，自动化的部署仓库管理特别有用。
- en: 'Semantic versioning Semantic versioning^([2](#pgfId-1088782)) is a formal convention
    for specifying compatibility using a three-part version number: major version,
    minor version, and patch.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制 语义版本控制^([2](#pgfId-1088782)) 是一种使用三部分版本号（主版本、次版本和修订版）来指定兼容性的正式约定。
- en: Flux allows configuring the image tag filter that leverages the semantic version
    convention. The typical use case is to automate minor and patch releases that
    are supposed to be safe and backward compatible and manually deploy major releases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 允许配置利用语义版本约定进行图像标签过滤。典型用例是自动化次要和补丁版本，这些版本应该是安全且向后兼容的，而主要版本则需要手动部署。
- en: The obvious benefit of the Docker registry scanning feature, compared to using
    the continuous integration pipeline, is that you don’t have to spend time to implement
    the repository update step in your pipeline. The convenience, however, comes with
    more responsibility. Incorporating a deployment repository update into the continuous
    integration pipeline gives full control and allows us to run more tests after
    an image is pushed to the Docker registry. If Flux Docker registry scanning is
    enabled, you have to make sure that the image is well tested before pushing it
    to the Docker registry to avoid accidentally deploying to production.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用持续集成管道相比，Docker 仓库扫描功能的明显好处是你不需要花费时间在你的管道中实现仓库更新步骤。然而，这种便利性伴随着更多的责任。将部署仓库更新纳入持续集成管道提供了完全的控制权，并允许我们在将镜像推送到
    Docker 仓库后运行更多测试。如果启用了 Flux Docker 仓库扫描，你必须确保在将其推送到 Docker 仓库之前对镜像进行了充分的测试，以避免意外部署到生产环境。
- en: Exercise 11.1
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.1
- en: Consider the advantages and disadvantages of the Docker registry monitoring
    feature and try to decide if it is suitable for your team.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 Docker 仓库监控功能的优缺点，并尝试决定它是否适合你的团队。
- en: 11.1.3 Architecture
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 架构
- en: 'Flux consists of only two components: the Flux daemon and the key-value store
    Memcached.^([3](#pgfId-1088799))'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 只由两个组件组成：Flux 守护进程和键值存储 Memcached.^([3](#pgfId-1088799))
- en: Memcached Memcached is an open source, high-performance, distributed memory
    object-caching system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached Memcached 是一个开源的、高性能的、分布式内存对象缓存系统。
- en: The Flux architecture is represented in figure 11.3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 架构在图 11.3 中展示。
- en: '![](Images/CH11_F03_Yuen.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F03_Yuen.png)'
- en: Figure 11.3 The Flux daemon is the main component responsible for the majority
    of Flux features. It clones the Git repository, generates manifests, propagates
    changes to the Kubernetes cluster, and scans to the Docker registry.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 Flux 守护进程是负责 Flux 大多数功能的主要组件。它克隆 Git 仓库，生成清单，将更改传播到 Kubernetes 集群，并扫描
    Docker 仓库。
- en: There must be only one replica of the Flux daemon running at any time. This
    is not an issue, however, because even if the daemon crashes in the middle of
    a deployment, it restarts quickly and idempotently resumes the deployment process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，Flux 守护进程只能有一个副本运行。然而，这并不是一个问题，因为即使守护进程在部署过程中崩溃，它也会快速且幂等地重新启动并继续部署过程。
- en: The main purpose of Memcached is to support Docker registry scanning. Flux uses
    it to store a list of available image versions of each Docker image. The Memcached
    deployment is an optional component and not required unless you want to use the
    Docker registry scanning feature. To remove it, just use the `--registry-disable-scanning`
    flag during the installation step.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached 的主要目的是支持 Docker 仓库扫描。Flux 使用它来存储每个 Docker 图像的可用图像版本列表。Memcached 部署是一个可选组件，除非你想使用
    Docker 仓库扫描功能，否则不需要。要移除它，只需在安装步骤中使用 `--registry-disable-scanning` 标志。
- en: Exercise 11.2
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.2
- en: Which component logs should you check to troubleshoot deployment issues?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该检查哪个组件的日志来排查部署问题？
- en: 11.2 Simple application deployment
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 简单应用部署
- en: 'We’ve learned a lot about Flux already, and now it is time to see it in action.
    First of all, we need to get it running. The Flux installation consists of two
    steps: installing the Flux CLI and configuring the demon in your cluster. Use
    appendix B to learn how to install `fluxctl` and get ready to deploy your first
    application.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对 Flux 了解了很多，现在是时候看到它在实际中的应用了。首先，我们需要让它运行起来。Flux 安装包括两个步骤：安装 Flux CLI 和配置集群中的守护进程。使用附录
    B 学习如何安装 `fluxctl` 并准备部署你的第一个应用。
- en: 11.2.1 Deploying the first application
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 部署第一个应用
- en: 'The `fluxctl` and `minikube` applications are the only two components required
    to start managing Kubernetes resources with Flux. The next step is to prepare
    the Git repository with the Kubernetes manifests. The manifests for our sample
    application are available at the following link:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`fluxctl` 和 `minikube` 应用程序是启动使用 Flux 管理 Kubernetes 资源所需的唯一两个组件。下一步是准备包含 Kubernetes
    清单的 Git 仓库。我们示例应用的清单可在以下链接找到：'
- en: '[https://github.com/gitopsbook/sample-app-deployment](https://github.com/gitopsbook/sample-app-deployment)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/gitopsbook/sample-app-deployment](https://github.com/gitopsbook/sample-app-deployment)'
- en: Go ahead and create a repository fork^([4](#pgfId-1088835)) as the first step.
    Flux requires write permissions to the deployment repository to automatically
    update image tags in the manifests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续创建一个仓库分支^([4](#pgfId-1088835)) 作为第一步。Flux 需要部署仓库的写入权限以自动更新清单中的图像标签。
- en: Reset your fork Have you already forked the deployment repository while working
    on previous chapters? Make sure to revert changes for the best experience. The
    simplest way is to delete the previously forked repository and fork it again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重置您的分支 在您之前章节工作时，您是否已经为部署仓库创建了分支？请确保撤销更改以获得最佳体验。最简单的方法是删除之前创建的分支仓库，然后再次创建。
- en: 'Use `fluxctl` to install and configure the Flux daemon:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fluxctl` 安装和配置 Flux 守护进程：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command creates the Flux daemon and configures it to deploy manifests
    from your Git repository. Make sure the Flux daemon is running using the following
    command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建 Flux 守护进程并将其配置为从您的 Git 仓库部署清单。请确保使用以下命令运行 Flux 守护进程：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As part of this tutorial, we are going to try an automated repository update
    feature, so we need to give the Flux repository write access. The convenient and
    secure way to provide write access to the GitHub repository is to use the deploy
    key.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本教程的一部分，我们将尝试自动仓库更新功能，因此我们需要给予 Flux 仓库写入访问权限。向 GitHub 仓库提供写入访问权限的方便且安全的方式是使用部署密钥。
- en: Deploy key A deploy key is an SSH key that is stored on your server and grants
    access to a single GitHub repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 部署密钥 部署密钥是存储在您的服务器上并授予对单个 GitHub 仓库访问权限的 SSH 密钥。
- en: 'There is no need to generate the new SSH key manually. Flux generates a key
    during the first start and uses it to access the deployment repository. Run the
    following command to get the generated SSH key:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无需手动生成新的 SSH 密钥。Flux 在首次启动时生成密钥，并使用它来访问部署仓库。运行以下命令以获取生成的 SSH 密钥：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Navigate to [https://github.com/<username>/sample-app-deployment/settings/keys
    /](https://github.com/<username%3E/sample-app-deployment/settings/keys/)new, and
    use the output of the `fluxctl` identity command to create a new deployment key.
    Make sure to check the “Allow write access” check box to provide write access
    to the repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 [https://github.com/<username>/sample-app-deployment/settings/keys /](https://github.com/<username%3E/sample-app-deployment/settings/keys/)新，并使用
    `fluxctl` 身份命令的输出创建一个新的部署密钥。请确保勾选“允许写入访问”复选框以提供对仓库的写入访问权限。
- en: The configuration is done! While you are reading this, Flux should be cloning
    the repository and deploying manifests. Go ahead and check the Flux daemon logs
    to confirm that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 配置已完成！当您阅读此内容时，Flux 应该正在克隆仓库并部署清单。请继续检查 Flux 守护进程日志以确认。
- en: Can you see `kubectl` `apply` in the logs?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您在日志中看到 `kubectl apply` 吗？
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great, that means Flux successfully performed the deployment. Next, run the
    following command to confirm that the sample app deployment resource has been
    created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，这意味着 Flux 成功执行了部署。接下来，运行以下命令以确认已创建样本应用程序部署资源：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! You successfully deployed your first application using Flux.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功使用 Flux 部署了您的第一个应用程序。
- en: 11.2.2 Observing application state
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 观察应用程序状态
- en: 'Reading the logs of the Flux daemon is not the only way to get information
    about resources managed by Flux. The `fluxctl` CLI provides a set of commands
    that allow us to get detailed information about cluster resources. The first one
    we should try is `fluxctl` `list-workloads`. The command prints information about
    all Kubernetes resources that manage Pods in the cluster. Run the following command
    to output information about the `sample-app` deployment:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 Flux 守护进程的日志并不是获取 Flux 管理的资源信息的唯一方法。`fluxctl` CLI 提供了一组命令，允许我们获取有关集群资源的详细信息。我们应该尝试的第一个命令是
    `fluxctl list-workloads`。该命令打印有关集群中管理 Pods 的所有 Kubernetes 资源的信息。运行以下命令以输出有关 `sample-app`
    部署的信息：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the output, Flux is managing one deployment that creates
    a `sample-app` container using the `v0.1` version of the `gitopsbook/sample-app`
    image.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，Flux 正在管理一个部署，该部署使用 `gitopsbook/sample-app` 图像的 `v0.1` 版本创建了一个 `sample-app`
    容器。
- en: 'In addition to the information about the current image, Flux has scanned the
    Docker registry and collected all available image tags. Run the following command
    to print the list of discovered image tags:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当前图像的信息外，Flux 还扫描了 Docker 仓库并收集了所有可用的图像标签。运行以下命令以打印发现的图像标签列表：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the command output, we can see that Flux correctly discovered both available
    image versions. In addition, Flux identified `v0.2` as a newer version and is
    ready to upgrade our deployment if we configure automated upgrades. Let’s go ahead
    and do so.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令输出中，我们可以看到 Flux 正确地发现了两个可用的镜像版本。此外，Flux 将 `v0.2` 识别为较新版本，并准备好升级我们的部署，如果我们配置了自动升级。让我们继续这样做。
- en: 11.2.3 Upgrading the deployment image
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 升级部署镜像
- en: By default, Flux does not upgrade the resource image version unless the resource
    has the `fluxcd.io/automated:` `'true'` annotation. This annotation tells Flux
    that the resource image is managed automatically, and the image should be upgraded
    as soon as a new version is pushed to the Docker registry. The following listing
    contains the `sample-app` Deployment manifest with the applied annotation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flux 不会升级资源镜像版本，除非资源具有 `fluxcd.io/automated:` `'true'` 注解。这个注解告诉 Flux
    资源镜像是自动管理的，并且一旦将新版本推送到 Docker 仓库，镜像就应该升级。以下列表包含应用了注解的 `sample-app` 部署清单。
- en: Listing 11.1 deployment.yaml
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 deployment.yaml
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Annotation that enables automated management
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用自动化管理的注解
- en: ❷ The deployment image tag
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 部署镜像标签
- en: 'One way to add the annotation is to manually edit the deployment.yaml file
    and commit it to the deployment repository. During the next reconciliation cycle,
    Flux should detect the annotation and enable automated management. `fluxctl` provides
    convenience commands, `automate` and `deautomate`, which can add or remove the
    annotation for you. Run the following command to automate the `sample-app` deployment
    management:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 添加注解的一种方法是通过手动编辑 deployment.yaml 文件并将其提交到部署存储库。在下一个协调周期中，Flux 应该会检测到注解并启用自动化管理。`fluxctl`
    提供了方便的命令 `automate` 和 `deautomate`，可以为你添加或删除注解。运行以下命令来自动化 `sample-app` 部署管理：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command updates the manifest and pushes the change into the Git repository.
    If you check the repository history using GitHub, you will see two commits where
    the first commit updates the deployment annotation and the second updates the
    image version.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令更新清单并将更改推送到 Git 存储库。如果你使用 GitHub 检查存储库历史记录，你会看到两个提交，第一个提交更新了部署注解，第二个更新了镜像版本。
- en: 'Finally, let’s verify the deployment status using the `fluxctl` `list-workloads`
    command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 `fluxctl` 的 `list-workloads` 命令来验证部署状态：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The deployment image has been successfully updated to use the `v0.2` version
    of the `gitopsbook/sample-app` image. Don’t forget to pull the changes executed
    by Flux into the local Git repository:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 部署镜像已成功更新为使用 `gitopsbook/sample-app` 镜像的 `v0.2` 版本。别忘了将 Flux 执行的更改拉取到本地 Git
    仓库中：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 11.2.4 Using Kustomize for manifest generation
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 使用 Kustomize 生成清单
- en: Managing plain YAML files in the deployment repository is not a very difficult
    task but is also not very practical in real life. As we’ve learned in previous
    chapters, it is common practice to maintain the base set of manifests for the
    application and generate environment-specified manifests using tools like Kustomize
    or Helm. Integration with config management tools solves that problem, and Flux
    enables that feature using generators. Let’s learn what generators are and how
    to use them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署存储库中管理纯 YAML 文件并不是一个很难的任务，但在现实生活中也不是非常实用。正如我们在前面的章节中学到的，维护应用程序的基础清单集并使用 Kustomize
    或 Helm 等工具生成环境特定的清单是一种常见的做法。与配置管理工具的集成解决了这个问题，Flux 通过生成器实现了这一功能。让我们学习生成器是什么以及如何使用它们。
- en: Instead of providing first-class support for the selected set of config management
    tools, Flux provides the ability to configure the manifest generation process
    and integrate with any config management tool. The generator is a command that
    invokes the config management tool inside the Flux daemon that produces the final
    YAML. Generators are configured in the file named .flux.yaml stored in the deployment
    manifest repository.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与为所选的配置管理工具集提供一级支持不同，Flux 提供了配置清单生成过程的能力，并能够与任何配置管理工具集成。生成器是一个命令，它在 Flux 守护进程内部调用配置管理工具，生成最终的
    YAML 文件。生成器配置在存储在部署清单存储库中的名为 .flux.yaml 的文件中。
- en: 'Let’s dive deep into the feature and learn configuration details on a real
    example. First of all, we need to enable manifest generation in our Flux deployment.
    This is done using the `--manifest-generation` CLI flag of the Flux daemon. Run
    the following command to inject the flag into the Flux deployment using the JSON
    patch:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这个特性，并通过一个真实示例了解配置细节。首先，我们需要在Flux部署中启用清单生成。这是通过Flux守护进程的`--manifest-generation`
    CLI标志来完成的。运行以下命令，使用JSON补丁将标志注入到Flux部署中：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: JSON Patch JSON Patch^([5](#pgfId-1088957)) is a format for describing changes
    to a JSON document. The patch document is a sequential list of operations that
    are applied to JSON objects, allowing changes such as adding, removing, and replacing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JSON补丁 JSON补丁^([5](#pgfId-1088957)) 是描述对JSON文档更改的格式。补丁文档是一个操作序列列表，这些操作应用于JSON对象，允许进行添加、删除和替换等更改。
- en: As soon as the Flux configuration is updated, it is time to introduce Kustomize
    into our deployment repository and start leveraging it. Add the kustomization.yaml
    file using the following code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Flux配置更新，就是时候将Kustomize引入我们的部署仓库并开始利用它了。使用以下代码添加kustomization.yaml文件。
- en: Listing 11.2 kustomization.yaml
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 kustomization.yaml
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ List of manifests including resource manifests
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包括资源清单在内的清单列表
- en: ❷ Transformer that changes image tag
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更改镜像标签的转换器
- en: 'The next step is to configure a generator that uses Kustomize. Add the following
    .flux.yaml file to the `sample-app-deployment` repository:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置一个使用Kustomize的生成器。将以下.flux.yaml文件添加到`sample-app-deployment`仓库中：
- en: Listing 11.3 flux.yaml
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 flux.yaml
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ List of generators
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成器列表
- en: ❷ Generator command that leverages Kustomize to generate manifests
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 利用Kustomize生成清单的生成器命令
- en: ❸ Name of the file that stores manifest modifications; required for automated
    image updates
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 存储清单修改的文件名；对于自动镜像更新是必需的
- en: 'The configuration is done. Go ahead and push the changes to the deployment
    repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 配置已完成。继续将更改推送到部署仓库：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s take a look at .flux.yaml one more time and learn what was configured
    in detail. The generators section configures Flux to use Kustomize for manifest
    generation. You can run the exact same command locally to verify that Kustomize
    is producing the expected YAML manifests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看.flux.yaml，并详细了解配置了什么。生成器部分配置Flux使用Kustomize进行清单生成。您可以在本地运行完全相同的命令来验证Kustomize是否生成了预期的YAML清单。
- en: 'But what is the `patchFile` property? This is an updater configuration. To
    demonstrate how it works, lets trigger the Flux release using the following commands:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但`patchFile`属性是什么？这是一个更新器配置。为了演示它是如何工作的，让我们使用以下命令触发Flux的发布：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve downgraded the `sample-app` deployment back to the `v0.1` version and
    asked Flux to fix it. The `sync` command starts the reconciliation loop, which,
    once completed, should update the image tag and push changes back to the Git repository.
    Since manifests are now generated using Kustomize, Flux no longer knows which
    file to update. The `patchFile` property specifies the file path within the deployment
    repository where image tag updates must be stored. The file contains the JSON
    merge patch that is automatically applied to the generator output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`sample-app`部署降级回`v0.1`版本，并要求Flux修复它。`sync`命令启动了协调循环，一旦完成，应该更新镜像标签并将更改推回Git仓库。由于现在清单是通过Kustomize生成的，Flux不再知道哪个文件需要更新。`patchFile`属性指定了部署仓库中存储镜像标签更新的文件路径。该文件包含自动应用到生成器输出的JSON合并补丁。
- en: JSON Merge Patch The JSON merge patch is a JSON document that describes changes
    to be made to a target JSON and contains the nodes of the target document, which
    should be different after the patch is applied.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JSON合并补丁 JSON合并补丁是一个描述对目标JSON进行更改的JSON文档，它包含目标文档的节点，在应用补丁后，这些节点应该不同。
- en: The generated merge patch includes managed resource image changes. During the
    synchronization process, Flux generates and pushes the file with a merge patch
    to the Git repository and applies it on the fly to the generated YAML manifests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的合并补丁包括管理资源镜像的更改。在同步过程中，Flux生成并推送到Git仓库的文件包含合并补丁，并实时应用到生成的YAML清单上。
- en: 'Don’t forget to pull the changes executed by Flux into the local Git repository:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将Flux执行的改变拉取到本地Git仓库中：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 11.2.5 Securing deployment using GPG
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 使用GPG保护部署
- en: Flux is a very practical tool and focuses on real-life use cases. The deployment
    changes verification is one such case. As we’ve learned in chapter 6, commits
    in the deployment repository should be signed and validated using a GPG key to
    ensure the author identity of the commit, preventing unauthorized changes being
    pushed to the cluster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 是一个非常实用的工具，专注于现实生活中的用例。部署更改验证就是其中之一。正如我们在第 6 章中学到的，部署存储库中的提交应该使用 GPG 密钥签署和验证，以确保提交的作者身份，防止未经授权的更改被推送到集群。
- en: The typical approach is to incorporate the GPG validation into the continuous
    integration pipeline. Flux provides this integration out of the box, which saves
    time and provides a more robust implementation. The best way to learn how that
    feature operates is to try it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GPG 验证集成到持续集成管道中的典型方法是将 GPG 验证集成到持续集成管道中。Flux 提供了这种集成，无需额外操作，这节省了时间并提供了更稳健的实现。了解该功能如何操作的最佳方式是尝试它。
- en: First of all, we need a valid GPG key that can be used to sign and verify Git
    commits. If you’ve completed the chapter 6 tutorials, then you already have a
    GPG key and can sign commits. Otherwise, use the steps described in appendix C
    to create the GPC key. After configuring the GPG key, we need to make it available
    to Flux and enable commit verification.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个有效的 GPG 密钥，它可以用来签署和验证 Git 提交。如果您已经完成了第 6 章的教程，那么您已经有一个 GPG 密钥并且可以签署提交。否则，使用附录
    C 中描述的步骤创建 GPC 密钥。配置 GPG 密钥后，我们需要使其对 Flux 可用并启用提交验证。
- en: 'To verify the commit, Flux needs to have access to which GPG key we trust.
    The key can be configured using a ConfigMap. Use the following command to create
    the ConfigMap and store your public key in it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证提交，Flux 需要访问我们信任的哪个 GPG 密钥。密钥可以通过 ConfigMap 进行配置。使用以下命令创建 ConfigMap 并将您的公钥存储在其中：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The next step is to update the Flux deployment to enable commit verification.
    Update the username in the flux-deployment-patch.yaml file represented in the
    following listing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更新 Flux 部署以启用提交验证。更新以下列表中所示的 flux-deployment-patch.yaml 文件中的用户名。
- en: Listing 11.4 flux-deployment-patch.yaml
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 flux-deployment-patch.yaml
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Kubernetes Volume that uses ConfigMap as a data source
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 ConfigMap 作为数据源的 Kubernetes 卷
- en: ❷ Volume mount that stores ConfigMap keys in /root/gpg-public-keys directory
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 ConfigMap 密钥存储在 /root/gpg-public-keys 目录的卷挂载
- en: ❸ The --git-gpg-key-import arg specifies the location of trusted GPG keys.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ --git-gpg-key-import 参数指定了受信任 GPG 密钥的位置。
- en: ❹ The --git-verify-signatures arg enables commit verification.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ --git-verify-signatures 参数启用提交验证。
- en: ❺ The --git-verify-signatures-modes=first-parent arg allows having unsigned
    commits in repo history.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ --git-verify-signatures-modes=first-parent 参数允许在仓库历史中存在未签署的提交。
- en: 'Apply the Flux deployment modifications using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用 Flux 部署修改：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Commit verification is now enabled. To prove it is working, try triggering
    sync using the `fluxctl sync` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提交验证现在已启用。为了证明它正在工作，尝试使用 `fluxctl sync` 命令触发同步：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command fails as expected, since the most recent commit in the deployment
    repository is not signed. Let’s go ahead and fix it. First create an empty signed
    Git commit using this command, and sync again:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命令如预期失败，因为部署存储库中最新的提交未签署。让我们继续修复它。首先使用此命令创建一个空的已签署 Git 提交，然后再次同步：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to sign the sync tag maintained by Flux:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是签署由 Flux 维护的同步标签：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The repository is successfully synced. Finally, use the `fluxctl sync` command
    to confirm that verification is configured correctly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库已成功同步。最后，使用 `fluxctl sync` 命令确认验证配置正确：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 11.3 Multitenancy with Flux
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用 Flux 的多租户
- en: Flux is a powerful and flexible tool but does not have features that are built
    specifically for multitenancy. So the question is, can we use it in a large organization
    with multiple teams? The answer is definitely yes. Flux embraces the “Git PUSH
    all” philosophy and relies on GitOps to manage multiple Flux instances deployed
    in a multitenant cluster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 是一个强大且灵活的工具，但它没有专门为多租户构建的功能。所以问题是，我们能否在一个拥有多个团队的大型组织中使用它？答案是绝对可以。Flux 赞同“Git
    PUSH 全部”的理念，并依靠 GitOps 来管理在多租户集群中部署的多个 Flux 实例。
- en: With a multitenant cluster, cluster users have only limited Namespace access
    and cannot create new Namespaces or any other cluster-level resources. Each team
    owns their own Namespace resources and performs operations on them independently
    of each other. In this case, it does not make sense to force everyone to use a
    single Git repository and rely on the infrastructure team to review every configuration
    change. On the other hand, the infrastructure team is responsible for overall
    cluster health and needs tools to manage cluster services. The application teams
    can still rely on Flux to manage the Application resource. The infrastructure
    team uses Flux to provision Namespaces as well as multiple Flux instances configured
    with the proper Namespace-level access. Figure 11.4 demonstrates the idea.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户集群中，集群用户只有有限的命名空间访问权限，不能创建新的命名空间或任何其他集群级资源。每个团队拥有自己的命名空间资源，并独立于其他团队进行操作。在这种情况下，强迫每个人都使用单个Git仓库并依赖基础设施团队审查每个配置更改是没有意义的。另一方面，基础设施团队负责集群的整体健康，需要工具来管理集群服务。应用团队仍然可以依赖Flux来管理应用资源。基础设施团队使用Flux提供命名空间以及配置了适当命名空间级访问权限的多个Flux实例。图11.4展示了这一概念。
- en: '![](Images/CH11_F04_Yuen.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F04_Yuen.png)'
- en: Figure 11.4 The cluster has one “control plane” Namespace and a centralized
    cluster Git repository managed by the infrastructure team. The centralized repository
    contains manifests that represent centralized Flux deployment and team-specific
    Namespaces and Flux configurations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 集群有一个“控制平面”命名空间和一个由基础设施团队管理的集中式集群Git仓库。集中式仓库包含表示集中式Flux部署和特定团队命名空间以及Flux配置的清单。
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Centralized Flux deployment that provisions team-specific Namespaces
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 集中式Flux部署，为特定团队提供命名空间
- en: ❷ Team-specific Namespace manifest
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 特定团队的命名空间清单
- en: ❸ Team-specific Flux deployment
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 特定团队的Flux部署
- en: The application team can onboard themselves by creating the pull request to
    the centralized repository and adding the Namespace and Flux manifests. As soon
    as the pull request is merged, the central Flux creates the Namespace and provision-team-specific
    Flux, ensuring the correct RBAC settings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应用团队可以通过向集中式仓库创建拉取请求并添加命名空间和Flux清单来自主加入。一旦拉取请求被合并，中央Flux就会创建命名空间并为特定团队提供Flux，确保正确的RBAC设置。
- en: The team-specific Flux instance is configured to pull manifests from the separate
    Git repository that is managed by the application team. That means the application
    team is fully independent and doesn’t have to involve the infrastructure team
    to update resources within their Namespace.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 特定团队的Flux实例配置为从由应用团队管理的单独Git仓库中拉取清单。这意味着应用团队完全独立，无需涉及基础设施团队来更新其命名空间内的资源。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Flux is simple to install and maintain because Flux does not require new components
    and uses Kubernetes RBAC for access control.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux易于安装和维护，因为Flux不需要新的组件，并使用Kubernetes RBAC进行访问控制。
- en: Flux can be configured with automated repository updates to automatically deploy
    new images.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux可以通过自动仓库更新配置来自动部署新镜像。
- en: Because Flux interfaces directly with either Git or the Docker registry, Flux
    eliminates the need for custom integration in the CI pipeline for deployment.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Flux直接与Git或Docker注册库接口，Flux消除了在CI管道中部署时进行自定义集成的需求。
- en: Flux comes with the CLI tool `fluxctl` for Flux installation and deploying applications.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux附带CLI工具`fluxctl`，用于Flux的安装和部署应用。
- en: Flux does not come with manifest-generation tools but can easily integrate with
    tools such as Kustomize through simple configuration.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux不自带清单生成工具，但可以通过简单的配置轻松集成Kustomize等工具。
- en: Flux can easily integrate with GPG for secure deployment with simple configuration.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux可以通过简单的配置轻松集成GPG以实现安全的部署。
- en: Flux can be configured for multitenancy through centralized provisioning of
    Namespaces with access control and Namespace-specific Flux instances.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux可以通过集中提供命名空间（带有访问控制和命名空间特定的Flux实例）进行多租户配置。
- en: '* * *'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.[https://www.weave.works/](https://www.weave.works/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 1.[https://www.weave.works/](https://www.weave.works/).
- en: 2.[https://semver.org/](https://semver.org/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[https://semver.org/](https://semver.org/).
- en: 3.[https://memcached.org/](https://memcached.org/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://memcached.org/](https://memcached.org/).
- en: 4.[https://help.github.com/en/github/getting-started-with-github/fork-a-repo](https://help.github.com/en/github/getting-started-with-github/fork-a-repo).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[https://help.github.com/en/github/getting-started-with-github/fork-a-repo](https://help.github.com/en/github/getting-started-with-github/fork-a-repo).
- en: 5.[http://jsonpatch.com/](http://jsonpatch.com/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[http://jsonpatch.com/](http://jsonpatch.com/).
