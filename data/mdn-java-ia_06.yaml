- en: Appendix A. Miscellaneous language updates
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A. 其他语言更新
- en: 'In this appendix, we discuss three other language updates in Java 8: repeated
    annotations, type annotations, and generalized target-type inference. [Appendix
    B](kindle_split_038.xhtml#app02) discusses library updates in Java 8\. We don’t
    discuss JDK 8 updates such as Nashorn and Compact Profiles because they’re new
    JVM features. This book focuses on *library* and *language* updates. We invite
    you to read the following links if you’re interested in Nashorn and Compact Profiles:
    [http://openjdk.java.net/projects/nashorn/](http://openjdk.java.net/projects/nashorn/)
    and [http://openjdk.java.net/jeps/161](http://openjdk.java.net/jeps/161).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们讨论了 Java 8 中的三个其他语言更新：重复注解、类型注解和泛型目标类型推断。[附录 B](kindle_split_038.xhtml#app02)
    讨论了 Java 8 中的库更新。我们不讨论 JDK 8 更新，如 Nashorn 和 Compact Profiles，因为它们是新的 JVM 功能。本书重点介绍
    *库* 和 *语言* 更新。如果您对 Nashorn 和 Compact Profiles 感兴趣，请阅读以下链接：[http://openjdk.java.net/projects/nashorn/](http://openjdk.java.net/projects/nashorn/)
    和 [http://openjdk.java.net/jeps/161](http://openjdk.java.net/jeps/161)。
- en: A.1\. Annotations
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1. 注解
- en: 'The annotation mechanism in Java 8 has been enhanced in two ways:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 中的注解机制在两个方面得到了增强：
- en: You can repeat annotations.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以重复注解。
- en: You can annotate any type uses.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对任何类型使用注解。
- en: Before we explain these updates, it’s worth quickly refreshing what you can
    do with annotations before Java 8.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释这些更新之前，快速回顾一下在 Java 8 之前你可以用注解做什么是有价值的。
- en: '*Annotations* in Java are a mechanism that lets you decorate program elements
    with additional information (note that prior to Java 8 only declarations can be
    annotated). In other words, it’s a form of *syntactic metadata.* For example,
    annotations are popular with the JUnit framework. In the following code, the method
    `setUp` is annotated with the annotation `@Before`, and the method `testAlgorithm`
    is annotated with `@Test`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的 *注解* 是一种机制，允许你用附加信息装饰程序元素（注意，在 Java 8 之前，只有声明可以被注解）。换句话说，它是一种 *语法元数据*。例如，注解在
    JUnit 框架中很受欢迎。在以下代码中，方法 `setUp` 被注解为 `@Before`，而方法 `testAlgorithm` 被注解为 `@Test`：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Annotations are suitable for several use cases:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注解适用于多种用例：
- en: In the context of JUnit, annotations can differentiate methods that should be
    run as a unit test and methods that are used for setup work.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JUnit 的上下文中，注解可以区分应该作为单元测试运行的方法和用于设置工作的方法。
- en: Annotations can be used for documentation. For instance, the `@Deprecated` annotation
    is used to indicate that a method should no longer be used.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解可以用于文档。例如，`@Deprecated` 注解用于指示一个方法不应再使用。
- en: The Java compiler can also process annotations in order to detect errors, suppress
    warnings, or generate code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 编译器也可以处理注解，以检测错误、抑制警告或生成代码。
- en: Annotations are popular in Java EE, where they’re used to configure enterprise
    applications.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解在 Java EE 中很受欢迎，它们用于配置企业应用程序。
- en: A.1.1\. Repeated annotations
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.1. 重复注解
- en: 'Previous versions of Java forbid more than one annotation of a given annotation
    type to be specified on a declaration. For this reason, the following code is
    invalid:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的 Java 版本禁止在声明上指定给定注解类型的多个注解。因此，以下代码是无效的：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Error: duplicate annotation**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：重复注解**'
- en: 'Java EE programmers often make use of an idiom to circumvent this restriction.
    You declare a new annotation, which contains an array of the annotation you want
    to repeat. It looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 程序员经常使用一种惯用语来规避这个限制。你声明一个新的注解，其中包含一个要重复的注解数组。它看起来像这样：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The nested annotation on the `Book` class is pretty ugly. This is why Java 8
    essentially removes this restriction, which tidies things a bit. You’re now allowed
    to specify multiple annotations of the same annotation type on a declaration,
    provided they stipulate that the annotation is repeatable. It’s not the default
    behavior; you have to explicitly ask for an annotation to be repeatable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book` 类的嵌套注解看起来相当丑陋。这就是为什么 Java 8 基本上移除了这个限制，从而使事情变得整洁一些。现在，你可以在声明上指定多个相同类型的注解，前提是它们规定该注解是可重复的。这不是默认行为；你必须明确要求注解可重复。'
- en: Making an annotation repeatable
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使注解可重复
- en: 'If an annotation has been designed to be repeatable, you can just use it. But
    if you’re providing annotations for your users, then setup is required to specify
    that an annotation can be repeated. There are two steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个注解被设计为可重复的，你只需使用它即可。但是，如果你为用户提供注解，则需要设置来指定注解可以重复。这里有两个步骤：
- en: Mark the annotation as `@Repeatable`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注解标记为`@Repeatable`。
- en: Provide a container annotation.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个容器注解。
- en: 'Here’s how you can make the `@Author` annotation repeatable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你可以使`@Author`注解可重复：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a result, the `Book` class can be annotated with multiple `@Author` annotations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Book`类可以用多个`@Author`注解进行注解：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At compile time `Book` is considered to be annotated by `@Authors({ @Author(name=
    "Raoul"), @Author(name="Mario"), @Author(name="Alan")})`, so you can view this
    new mechanism as syntactic sugar around the previous idiom used by Java programmers.
    Annotations are still wrapped in a container to ensure behavioral compatibility
    with legacy reflection methods. The method `getAnnotation(Class<T> annotationClass)`
    in the Java API returns the annotation of type `T` for an annotated element. Which
    annotation should this method return if there are several annotations of type
    `T`?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，`Book`类被认为是通过`@Authors({ @Author(name= "Raoul"), @Author(name="Mario"),
    @Author(name="Alan")})`注解的，因此你可以将这种新机制视为Java程序员之前使用的惯用语的语法糖。注解仍然被封装在一个容器中，以确保与旧版反射方法的兼容性。Java
    API中的`getAnnotation(Class<T> annotationClass)`方法返回注解元素上的类型为`T`的注解。如果有多个类型为`T`的注解，这个方法应该返回哪个注解？
- en: 'Without diving into too much detail, the class `Class` supports a new `get-AnnotationsByType`
    method that facilitates working with repeatable annotations. For example, you
    can use it as follows to print all the `Author` annotations on the `Book` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，类`Class`支持一个新的`get-AnnotationsByType`方法，它简化了可重复注解的处理。例如，你可以如下使用它来打印`Book`类上的所有`Author`注解：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Retrieve an array consisting of the repeatable Author annotations**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取由可重复的`Author`注解组成的数组**'
- en: 'For this to work, both the repeatable annotation and its container must have
    a `RUNTIME` retention policy. More information about compatibility with legacy
    reflection methods can be found here: [http://cr.openjdk.java.net/~abuckley/8misc.pdf](http://cr.openjdk.java.net/~abuckley/8misc.pdf).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，可重复注解及其容器都必须有`RUNTIME`保留策略。有关与旧版反射方法兼容性的更多信息，请参阅此处：[http://cr.openjdk.java.net/~abuckley/8misc.pdf](http://cr.openjdk.java.net/~abuckley/8misc.pdf)。
- en: A.1.2\. Type annotations
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.2\. 类型注解
- en: 'As of Java 8, annotations can be also applied to any type uses. This includes
    the `new` operator, type casts, `instanceof` checks, generic type arguments, and
    `implements` and `throws` clauses. Here we indicate that the variable `name` of
    type `String` can’t be `null` using a `@NonNull` annotation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Java 8，注解也可以应用于任何类型的使用。这包括`new`运算符、类型转换、`instanceof`检查、泛型类型参数以及`implements`和`throws`子句。在这里，我们使用`@NonNull`注解表明`String`类型的变量`name`不能为`null`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, you can annotate the type of the elements in a list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以注解列表中元素的类型：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why is this interesting? Annotations on types can be useful to perform program
    analysis. In these two examples, a tool could ensure that `getName` doesn’t return
    `null` and that the elements of the list of cars are always non-`null`. This can
    help reduce unexpected errors in your code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么有趣的地方？类型上的注解可以用于程序分析。在这两个例子中，一个工具可以确保`getName`不会返回`null`，以及列表中的汽车元素始终不是`null`。这可以帮助减少你代码中的意外错误。
- en: 'Java 8 doesn’t provide official annotations or a tool to use them out of the
    box. It provides only the ability to use annotations on types. Luckily, a tool
    called the Checker framework exists, which defines several type annotations and
    lets you enhance type checking using them. If you’re curious, we invite you to
    take a look at its tutorial: [http://www.checkerframework.org](http://www.checkerframework.org).
    More information about where you can use annotations in your code can be found
    here: [http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.4](http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.4).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8不提供官方注解或使用它们的工具。它只提供了在类型上使用注解的能力。幸运的是，存在一个名为Checker框架的工具，它定义了几个类型注解，并允许你使用它们来增强类型检查。如果你感兴趣，我们邀请你查看它的教程：[http://www.checkerframework.org](http://www.checkerframework.org)。有关在你的代码中可以使用注解的位置的更多信息，请参阅此处：[http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.4](http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.4)。
- en: A.2\. Generalized target-type inference
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2\. 泛化目标类型推断
- en: 'Java 8 enhances the inference of generic arguments. You’re already familiar
    with type inference using context information before Java 8\. For example, the
    method `empty-List` in Java is defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8增强了泛型参数的推断。你已经在Java 8之前熟悉了使用上下文信息进行类型推断。例如，Java中`empty-List`方法的定义如下：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The method `emptyList` is parameterized with the type parameter `T`. You can
    call it as follows to provide an explicit type to the type parameter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`emptyList`使用类型参数`T`进行参数化。你可以如下调用它以向类型参数提供显式类型：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But Java is capable of inferring the generic argument. The following is equivalent:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但Java能够推断泛型参数。以下等价：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before Java 8, this inference mechanism based on the context (that is, target
    typing) was limited. For example, the following wasn’t possible:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，这种基于上下文（即目标类型）的推断机制是有限的。例如，以下是不可能的：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You’d get the following error:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下错误：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To fix it you’d have to provide an explicit type argument like the one we showed
    previously.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复它，你必须提供像我们之前展示的那样显式的类型参数。
- en: 'In Java 8 the target type includes arguments to a method, so you don’t need
    to provide an explicit generic argument:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，目标类型包括方法参数，因此你不需要提供显式的泛型参数：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code, it’s exactly this enhancement that lets you write `Collectors.toList()`
    instead of `Collectors.<Car>toList()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，正是这种增强让你能够编写`Collectors.toList()`而不是`Collectors.<Car>toList()`。
