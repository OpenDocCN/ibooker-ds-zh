- en: '16 The scrambler: Randomly reordering the middles of words'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 破碎器：随机重新排列单词的中间部分
- en: '| Yuor brian is an azinamg cmiobiaontn of hdarware and sftraowe. Yoru’e rdineag
    tihs rhgit now eevn thgouh the wrdos are a mses, but yuor biran can mkae snese
    of it bceause the frsit and lsat ltrtees of ecah wrod hvae saeytd the smae. Yuor
    biran de’onst atlaulcy raed ecah lteetr of ecah wrod but rades wlohe wdors. The
    scamrbeld wrdos difteienly solw you dwon, but y’roue not rlleay eevn tyinrg to
    ulsrmbance the lrttees, are you? It jsut hnaepps! | ![](../Images/16-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 你的大脑是一个令人惊讶的硬件和软件的结合体。即使单词顺序混乱，你也能理解它，因为每个单词的首尾字母都相同。你的大脑不会逐个字母阅读，而是读取整个单词。混乱的单词会引导你向下，但你实际上并不是在尝试重新排列字母，对吧？这只是巧合！
    | ![图片](../Images/16-unnumb-1.png) |'
- en: In this chapter, you will write a program called scrambler.py that will scramble
    each word of the text given as an argument. The scrambling should only work on
    words with four characters or more, and it should only scramble the letters in
    the middle of the word, leaving the first and last characters unchanged. The program
    should take an `-s` or `--seed` option (an `int` with default `None`) to pass
    to `random.seed()`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将编写一个名为 scrambler.py 的程序，该程序将打乱作为参数提供的文本中的每个单词。打乱操作仅适用于有四个或更多字符的单词，并且它仅打乱单词中间的字母，保持首尾字符不变。程序应接受
    `-s` 或 `--seed` 选项（一个默认为 `None` 的 `int`），并将其传递给 `random.seed()`。
- en: 'It should handle text on the command line:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该处理命令行上的文本：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or text from a file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 或者来自文件的文本：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 16.1 shows a string diagram to help you think about it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1显示了一个字符串图，以帮助您思考。
- en: '![](../Images/16-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/16-1.png)'
- en: Figure 16.1 Our program will take input text from the command line or a file
    and will scramble the letters in words with four or more characters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1我们的程序将从命令行或文件中获取输入文本，并将单词中的字母打乱。
- en: In this chapter you will
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将
- en: Use a regular expression to split text into words
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式将文本分割成单词
- en: Use the `random.shuffle()` function to shuffle a `list`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.shuffle()` 函数来打乱一个 `list`
- en: Create scrambled versions of words by shuffling the middle letters while leaving
    the first and last letters unchanged
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重新排列中间字母而保持首尾字母不变来创建单词的混乱版本
- en: 16.1 Writing scrambler.py
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 编写 scrambler.py
- en: I recommend you start by using `new.py` `scrambler.py` to create the program
    in the 16_scrambler directory. Alternatively, you can copy template/template.py
    to 16_scrambler/scrambler.py. You can refer to previous exercises, like the one
    in chapter 5, to remember how to handle a positional argument that might be text
    or might be a text file to read.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你首先使用 `new.py` `scrambler.py` 在 16_scrambler 目录中创建程序。或者，你可以将模板/template.py
    复制到 16_scrambler/scrambler.py。你可以参考之前的练习，比如第5章中的练习，来回忆如何处理可能为文本或文本文件的定位参数。
- en: 'When run with no arguments or the flags `-h` or `--help`, scrambler.py should
    present a usage statement:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当不提供参数或使用 `-h` 或 `--help` 标志时，scrambler.py 应该显示一个用法说明：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once your program’s usage statement matches this, change your `main()` definition
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的程序的使用说明与这个匹配，就按以下方式更改你的 `main()` 定义：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then verify that your program can echo text from the command line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后验证你的程序是否可以从命令行回显文本：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or from an input file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者来自输入文件：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 16.1.1 Breaking the text into lines and words
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 将文本分解成行和单词
- en: 'As in chapter 15, we want to preserve the line breaks of the input text by
    using `str .splitlines()`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与第15章一样，我们想要通过使用 `str.splitlines()` 保留输入文本的换行符：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we are reading the spiders.txt haiku, this is the first line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在读取 spiders.txt 俳句，这是第一行：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to break the `line` into words. In chapter 6 we used `str.split()`,
    but that approach leaves punctuation stuck to our words--both `worry` and `spiders`
    have commas:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `line` 分解成单词。在第6章中，我们使用了 `str.split()`，但这种方法会将标点符号粘附在我们的单词上--`worry` 和
    `spiders` 都有逗号：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In chapter 15 we used the `re.split()` function with the regular expression
    `(\W+)` to split text on one or more non-word characters. Let’s try that:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15章中，我们使用了 `re.split()` 函数和正则表达式 `(\W+)` 来根据一个或多个非单词字符分割文本。让我们试试：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That won’t work because it splits `Don’t` into three parts: `Don`, `''`, and
    `t`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会起作用，因为它将 `Don’t` 分成了三部分：`Don`、`'` 和 `t`。
- en: Perhaps we could use `\b` to break on *word boundaries*. Note that we’d have
    to put an `r''` in front of the first quote, `r'\b'`, to denote that it is a “raw”
    string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以使用 `\b` 来在 *单词边界* 上断开。注意，我们不得不在第一个引号前加上 `r''`，即 `r'\b'`，以表示它是一个“原始”字符串。
- en: 'This still won’t work because `\b` thinks the apostrophe is a word boundary
    and so splits the contracted word:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不起作用，因为`\b`认为撇号是一个单词边界，因此将缩合词分割：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While searching the internet for a regex to split this text properly, I found
    the following pattern on a Java discussion board. It perfectly separates *words*
    from *non-words*:[1](#pgfId-1012822)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在网上搜索一个可以正确分割这个文本的正则表达式时，我在一个Java论坛上找到了以下模式。它完美地将*单词*从*非单词*中分离出来：[1](#pgfId-1012822)
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The beautiful thing about regular expressions is that they are their own language--one
    that is used inside many other languages from Perl to Haskell. Let’s dig into
    this pattern, shown in figure 16.2\.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的美妙之处在于它们是一种自己的语言——一种在从Perl到Haskell的许多其他语言中使用的语言。让我们深入探讨图16.2中显示的这个模式。
- en: '![](../Images/16-2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-2.png)'
- en: Figure 16.2 A regular expression that will find words that include an apostrophe
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 一个将找到包含撇号的单词的正则表达式
- en: 16.1.2 Capturing, non-capturing, and optional groups
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 捕获、非捕获和可选组
- en: 'In figure 16.2 you can see that groups can contain other groups. For instance,
    here is a regex that can capture the entire string “foobarbaz” as well as the
    substring “bar”:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在图16.2中，你可以看到组可以包含其他组。例如，这里有一个正则表达式可以捕获整个字符串“foobarbaz”以及子字符串“bar”：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Capture groups are numbered by the position of their left parenthesis. Since
    the first left parenthesis starts the capture starting at “f” and going to “z,”
    that is group `1`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组按其左括号的顺序编号。由于第一个左括号从“f”开始，延伸到“z”，因此是组`1`：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second left parenthesis starts just before the “b” and goes to the “r”:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个左括号从“b”之前开始，延伸到“r”：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also make a group *non-capturing* by using the starting sequence `(?:`.
    If we use this sequence on the second group, we no longer capture the substring
    “bar”:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用起始序列`(?:`来使一个组*非捕获*。如果我们在这个第二个组上使用这个序列，我们就不再捕获子字符串“bar”：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Non-capturing groups are commonly used when you are grouping primarily for the
    purpose of making it optional by placing a `?` after the closing parenthesis.
    For instance, we can make the “bar” optional and then match both “foobarbaz,”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 非捕获组通常在主要目的是通过在闭括号后放置一个`?`来使其可选时使用。例如，我们可以使“bar”可选，然后匹配“foobarbaz”和
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'as well as “foobaz”:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以及“foobaz”：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 16.1.3 Compiling a regex
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.3 编译正则表达式
- en: I mentioned the `re.compile()` function in chapter 15 as a way to incur the
    cost of compiling a regular expression just once. Whenever you use something like
    `re.search()` or `re.split()`, the regex engine must parse the `str` value you
    provide for the regex into something it understands and can use. This parsing
    step must happen *each time* you call the function. When you compile the regex
    and assign it to a variable, the parsing step is done before you call the function,
    which improves performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第15章中提到了`re.compile()`函数，作为一次性编译正则表达式成本的方法。每次你使用类似`re.search()`或`re.split()`的东西时，正则表达式引擎都必须将你提供的`str`值解析成它可以理解和使用的格式。这个解析步骤必须在你每次调用函数时发生。当你编译正则表达式并将其分配给变量时，解析步骤是在你调用函数之前完成的，这提高了性能。
- en: 'I especially like to use `re.compile()` to assign a regex to a meaningful variable
    name and/or reuse the regex in multiple places in my code. Because this regex
    is quite long and complicated, I think it makes the code more readable to assign
    it to a variable called `splitter`, which will help me to remember how it will
    be used:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别喜欢使用`re.compile()`将正则表达式分配给一个有意义的变量名，并在我的代码的多个地方重用正则表达式。因为这个正则表达式相当长且复杂，我认为将它分配给名为`splitter`的变量可以使代码更易于阅读，这将帮助我记住它将如何被使用：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 16.1.4 Scrambling a word
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.4 打乱单词
- en: '| Now that we have a way to process the *lines* and then *words* of the text,
    let’s think about how we’ll scramble the words by starting with just *one word*.
    You and I will need to use the same algorithm for scrambling the words in order
    to pass the tests, so here are the rules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '| 现在我们有了处理文本的*行*和*单词*的方法，让我们考虑一下我们如何通过只从*一个单词*开始来打乱单词。你和我需要使用相同的算法来打乱单词，以便通过测试，所以这里有规则：'
- en: If the word is three characters or shorter, return the word unchanged.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单词是三个字符或更短，则返回单词不变。
- en: Use a string slice to copy the characters, not including the first and last.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串切片来复制字符，但不包括第一个和最后一个字符。
- en: Use the `random.shuffle()` method to mix up the letters in the middle.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`random.shuffle()`方法来打乱中间的字母。
- en: Return the new “word” by combining the first, middle, and last parts.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回新的“单词”通过组合第一、中间和最后一部分。
- en: '| ![](../Images/16-unnumb-2.png)  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '![图片](../Images/16-unnumb-2.png)'
- en: 'I recommend you create a function called `scramble()` that will do all this,
    and also create a test for it. Feel free to add this to your program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你创建一个名为 `scramble()` 的函数来完成所有这些操作，并为其创建一个测试。你可以自由地将此添加到你的程序中：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① The pass is a no-op (no operation), so this function literally does nothing.
    This is just a placeholder so that we can write a test and verify that the function
    fails.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ① `pass` 是一个无操作（no operation），所以这个函数实际上什么也没做。这只是一个占位符，这样我们就可以编写测试并验证函数是否失败。
- en: ② The change we’ll make by setting the random.seed() in the next line will be
    a global change. We’ll want to restore the state after testing, so here we use
    random.getstate() to get the current state of the random module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们将在下一行通过设置 `random.seed()` 实现的更改将是全局性的。我们希望在测试后恢复状态，因此在这里我们使用 `random.getstate()`
    来获取随机模块的当前状态。
- en: ③ Set random.seed() to a known value for testing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将 `random.seed()` 设置为已知值以进行测试。
- en: ④ Words with three characters or fewer should be returned unchanged.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 对于三个字符或更少的单词应返回不变。
- en: ⑤ This word looks unchanged, but that’s just because with the seed of 1 the
    shuffling didn’t end up changing the middle characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 这个单词看起来没有变化，但这只是因为种子值为1时，洗牌并没有最终改变中间字符。
- en: ⑥ Now it’s more evident that the word is being scrambled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 现在更明显，单词正在被洗牌。
- en: ⑦ Restore the state to the previous value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将状态恢复到之前的值。
- en: 'Inside the `scramble()` function, we will have a word like “worry.” We can
    use list slices to extract part of a string. Since Python starts numbering at
    `0`, we use `1` to indicate the *second* character:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `scramble()` 函数内部，我们将有一个像 “worry” 这样的单词。我们可以使用字符串切片来提取字符串的一部分。由于 Python 从
    `0` 开始编号，我们使用 `1` 来表示 *第二个* 字符：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last index of any string is `-1`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字符串的最后一个索引是 `-1`：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To get a slice, we use the `list[start:stop]` syntax. Since the `stop` position
    is not included, we can get the `middle` like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取切片，我们使用 `list[start:stop]` 语法。由于 `stop` 位置不包括在内，我们可以这样获取 `middle`：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can `import` `random` to get access to the `random.shuffle()` function.
    As with the `list.sort()` and `list.reverse()` methods, the argument will be shuffled
    in place, and the function will return `None`. That is, you might be tempted to
    write code like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以 `import` `random` 来获取访问 `random.shuffle()` 函数的权限。与 `list.sort()` 和 `list.reverse()`
    方法一样，参数将就地洗牌，函数将返回 `None`。也就是说，你可能想编写如下代码：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What is the value of `shuffled`? Is it something like `[3,` `1,` `2]`, or is
    it `None`?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffled` 的值是多少？它是类似 `[3,` `1,` `2]` 的东西，还是 `None`？'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `shuffled` value now holds `None`, while the `x` list has been shuffled
    in place (see figure 16.3):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `shuffled` 的值是 `None`，而 `x` 列表已经就地洗牌（见图16.3）：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](../Images/16-3.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/16-3.png)'
- en: Figure 16.3 The return from `random.shuffle()` was `None`, so `shuffled` was
    assigned `None`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 `random.shuffle()` 的返回值是 `None`，因此 `shuffled` 被赋值为 `None`。
- en: 'If you’ve been following along, it turns out that we cannot shuffle the `middle`
    like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随，结果是我们不能像这样对 `middle` 进行洗牌：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `middle` variable is a `str`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`middle` 变量是一个 `str`：'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `random.shuffle()` function is trying to directly modify a `str` value
    in place, but `str` values in Python are *immutable*. One workaround is to make
    `middle` into a new `list` of the characters from `word`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`random.shuffle()` 函数试图直接就地修改一个 `str` 值，但 Python 中的 `str` 值是不可变的。一种解决方案是将 `middle`
    转换为 `word` 中字符的新 `list`：'
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That is something we can shuffle:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们能洗牌的东西：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then it’s a matter of creating a new string with the original first letter,
    the shuffled middle, and the last letter. I’ll leave that for you to work out.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就是创建一个新的字符串，包含原始的第一个字母、洗牌后的中间部分和最后一个字母。我将把这个留给你来完成。
- en: Use `pytest` `scrambler.py` to have Pytest execute the `test_scramble()` function
    to see if it works correctly. Run this command *after every change to your program*.
    Ensure that your program always compiles and runs properly. Only make one change
    at a time, and then save your program and run the tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pytest` 和 `scrambler.py` 来让 Pytest 执行 `test_scramble()` 函数，以查看其是否正确工作。每次修改程序后都要运行此命令。确保程序始终正确编译和运行。一次只做一项更改，然后保存程序并运行测试。
- en: 16.1.5 Scrambling all the words
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.5 洗牌所有单词
- en: As in several previous exercises, we’re now down to applying the `scramble()`
    function to all the words. Can you see a familiar pattern?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前的几个练习一样，我们现在将 `scramble()` 函数应用于所有单词。你能看到熟悉的模式吗？
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ve talked about how to apply a function to each element in a sequence. You
    might try a `for` loop, a list comprehension, or maybe a `map()`. Think about
    how you can split the text into words, feed them to the `scramble()` function,
    and then join them back together to reconstruct the text.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何将函数应用于序列中的每个元素。你可能尝试一个 `for` 循环、列表推导或 `map()`。考虑一下你如何将文本拆分成单词，将它们传递给
    `scramble()` 函数，然后将它们重新连接以重建文本。
- en: Note that this approach will pass both the words and the non-words (the bits
    in between each word) to the `scramble()` function. You don’t want to modify the
    non-words, so you’ll need a way to check that the argument looks like a word.
    Maybe a regular expression?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种方法会将单词和非单词（每个单词之间的部分）都传递给 `scramble()` 函数。你不想修改非单词，所以你需要一种方法来检查参数看起来像单词。也许是一个正则表达式？
- en: That should be enough to go on. Write your solution and use the included tests
    to check your program.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够你继续了。编写你的解决方案，并使用包含的测试来检查你的程序。
- en: 16.2 Solution
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 解决方案
- en: To me, the program comes down to properly splitting the words and then figuring
    out the `scramble()` function. Then it’s a matter of applying the function and
    reconstructing the text.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，程序归结为正确分割单词，然后找出 `scramble()` 函数。然后就是应用该函数并重建文本的问题。
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① The text argument may be plain text on the command line or the name of a file
    to read.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ① 文本参数可以是命令行上的纯文本或要读取的文件名。
- en: ② The seed option is an int that defaults to None.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ② 种子选项是一个默认为 None 的 int。
- en: ③ Get the arguments so we can check the text value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取参数以便我们可以检查文本值。
- en: ④ If args.text names an existing file, replace the value of args.text with the
    result of opening and reading the file’s contents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果 args.text 指定了现有文件，则将 args.text 的值替换为打开和读取文件内容的值。
- en: ⑤ Return the arguments to the caller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将参数返回给调用者。
- en: ⑥ Get the command-line arguments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 获取命令行参数。
- en: ⑦ Use args.seed to set the random.seed() value. If args.seed is the default
    None, this is the same as not setting the seed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用 args.seed 设置 random.seed() 的值。如果 args.seed 是默认的 None，则与未设置种子相同。
- en: ⑧ Save the compiled regex into a variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将编译后的正则表达式保存到变量中。
- en: ⑨ Use str.splitlines() to preserve the line breaks in the input text.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用 str.splitlines() 保留输入文本中的换行符。
- en: ⑩ Use the splitter to break the line into a new list that map() will feed into
    the scramble() function. Join the resulting list on the empty string to create
    a new str to print.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用拆分器将行拆分为一个新列表，该列表将映射()函数输入到打乱()函数中。使用空字符串连接结果列表以创建一个新字符串进行打印。
- en: ⑪ Define a function to scramble() a single word.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 定义一个函数来打乱()单个单词。
- en: ⑫ Only scramble words with four or more characters if they contain word characters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 只有当单词包含单词字符时，才对四个或更多字符的单词进行打乱。
- en: ⑬ Copy the second through the second-to-last characters of the word into a new
    list called middle.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 将单词的第二个到倒数第二个字符复制到一个名为 middle 的新列表中。
- en: ⑭ Shuffle the middle letters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 打乱中间字母。
- en: ⑮ Set the word equal to the first character, plus the middle, plus the last
    character.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 将单词设置为第一个字符，加上中间部分，加上最后一个字符。
- en: ⑯ Return the word, which may have been altered if it met the criteria.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 返回单词，如果它符合条件，单词可能已被更改。
- en: ⑰ The test for the scramble() function
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 对 scramble() 函数的测试
- en: 16.3 Discussion
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 讨论
- en: There is nothing new in `get_args()`, so I trust you’ll understand that code.
    Refer to chapter 5 if you want to revisit how to handle the `args.text` coming
    from the command line or from a file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()` 中没有新内容，所以我相信你会理解那段代码。如果你想回顾如何处理来自命令行或文件的 `args.text`，请参阅第 5 章。'
- en: 16.3.1 Processing the text
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1 处理文本
- en: 'As mentioned earlier in the chapter, I often assign a *compiled* regex to a
    variable. Here I did it with the `splitter`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，我经常将一个 *编译过的* 正则表达式分配给变量。这里我是用 `splitter` 做的：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The other reason I like to use `re.compile()` is because I feel it can make
    my code more readable. Without it, I would have to write this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用 `re.compile()` 的另一个原因是，我觉得它可以使我的代码更易读。没有它，我不得不这样写：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That ends up creating a line of code that is 86 characters wide, and the PEP
    8 style guide (www.python.org/dev/peps/pep-0008/) recommends we “limit all lines
    to a maximum of 79 characters.” I find the following version much easier to read:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终会创建一个 86 个字符宽的代码行，PEP 8 风格指南（www.python.org/dev/peps/pep-0008/）建议我们“将所有行限制在最多
    79 个字符。”我发现以下版本更容易阅读：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You may still find that code somewhat confusing. Figure 16.4 shows the flow
    of the data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能仍然觉得代码有些难以理解。图 16.4 展示了数据流：
- en: First Python will split the string `"Don’t` `worry,` `spiders,"`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先 Python 会将字符串 `"Don’t` `worry,` `spiders,"` 分割。
- en: The splitter creates a new list composed of words (that matched our regex) and
    non-words (the bits in between).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分隔符创建了一个新列表，包含匹配我们正则表达式的单词和非单词（中间的片段）。
- en: The `map()` function will apply the `scramble()` function to each element of
    the list.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map()` 函数将 `scramble()` 函数应用于列表的每个元素。'
- en: The result of `map()` is a new list with the results of each application of
    the `scramble()` function.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map()` 的结果是包含每个 `scramble()` 函数应用结果的新列表。'
- en: The result of `str.join()` is a new string, which is the argument to `print()`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str.join()` 的结果是一个新的字符串，它是 `print()` 的参数。'
- en: '![](../Images/16-4.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-4.png)'
- en: Figure 16.4 A visualization of how data moves through the `map()` function
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 `map()` 函数中数据流动的可视化
- en: 'A longer way to write this with a `for` loop might look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环来写这段代码可能看起来像这样：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① Use str.splitlines() to preserve the original line breaks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 `str.splitlines()` 保留原始行分隔符。
- en: ② For each line of input, create an empty list to hold the scrambled words.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ② 对于输入的每一行，创建一个空列表来存储打乱的单词。
- en: ③ Use the splitter to split the line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用分隔符拆分行。
- en: ④ Add the result of scramble(word) to the words list.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将 `scramble(word)` 的结果添加到单词列表中。
- en: ⑤ Join the words on the empty string and pass the result to print().
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用空字符串连接单词，并将结果传递给 `print()`。
- en: 'Because the goal is to create a new `list`, this is better written as a list
    comprehension:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为目标是创建一个新的 `list`，所以最好用列表推导式来写：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or you could go in quite the opposite direction and replace all the `for` loops
    with `map()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以完全相反的方向，用 `map()` 替换所有的 `for` 循环：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This last solution reminds me of a programmer I used to work with who would
    jokingly say, “If it was hard to write, it should be hard to read!” It becomes
    somewhat clearer if you rearrange the code. Note that Pylint will complain about
    assigning a `lambda`, but I really don’t agree with that criticism:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的解决方案让我想起了我曾经一起工作的一个程序员，他开玩笑地说，“如果写起来难，读起来也应该难！”如果你重新排列代码，这会变得稍微清晰一些。注意，Pylint
    会抱怨关于分配 `lambda` 的问题，但我真的不同意这种批评：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Writing code that is correct, tested, and understandable is as much an art as
    it is a craft. Choose the version that you (and your teammates!) believe is the
    most readable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编写正确、经过测试且易于理解的代码，既是一门艺术，也是一种手艺。选择你认为最易读的版本。
- en: 16.3.2 Scrambling a word
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2 打乱单词
- en: 'Let’s take a closer look at my `scramble()` function. I wrote it in a way that
    would make it easy to incorporate into `map()`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我的 `scramble()` 函数。我以使其易于集成到 `map()` 中的方式编写了它：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Check if the given word is one I ought to scramble. First, it must be longer
    than three characters. Second, it must contain one or more word characters because
    the function will be passed both “word” and “non-word” strings. If either check
    returns False, I will return the word unchanged. The r'\w+' is used to create
    a “raw” string. Note that the regex works fine with or without it being a raw
    string, but Pylint complains about an “invalid escape character” unless it is
    a raw string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查给定的单词是否应该打乱。首先，它必须长于三个字符。其次，它必须包含一个或多个单词字符，因为函数将传递“单词”和“非单词”字符串。如果任一检查返回
    False，我将返回未更改的单词。使用 r'\w+' 创建一个“原始”字符串。请注意，正则表达式在有或没有原始字符串的情况下都可以正常工作，但 Pylint
    会抱怨一个“无效的转义字符”，除非它是原始字符串。
- en: ② Copy the middle of the word to a new list called middle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将单词的中间部分复制到一个名为 middle 的新列表中。
- en: ③ Shuffle the middle in place. Remember that this function returns None.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在原地打乱中间部分。记住，这个函数返回 None。
- en: ④ Reconstruct the word by joining together the first character, the shuffled
    middle, and the last character.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过连接第一个字符、打乱的中间部分和最后一个字符来重构单词。
- en: ⑤ Return the word, which may or may not have been shuffled.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 返回单词，该单词可能已经被打乱，也可能没有。
- en: 16.4 Going further
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 进一步探索
- en: Write a version of the program where the `scramble()` function sorts the middle
    letters into alphabetical order rather than shuffling them.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序版本，其中 `scramble()` 函数将中间字母按字母顺序排序，而不是打乱它们。
- en: Write a version that reverses each word rather than scrambles them.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个版本，它反转每个单词而不是打乱它们。
- en: Write a program to *unscramble* the text. For this, you need to have a dictionary
    of English words, which I have provided as inputs/words.txt.zip. You will need
    to split the scrambled text into words and non-words, and then compare each “word”
    to the words in your dictionary. I recommend you start by comparing the words
    as anagrams (that is, they have the same composition/frequency of letters) and
    then using the first and last letters to positively identify the unscrambled word.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序来 *解乱码* 文本。为此，你需要有一个英语单词的字典，我已经将其作为输入提供在 inputs/words.txt.zip 中。你需要将乱码文本拆分成单词和非单词，然后比较每个“单词”与你的字典中的单词。我建议你首先将单词作为字母组合（即它们有相同的字母组成/频率）进行比较，然后使用首尾字母来正确定义未乱码的单词。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The regex we used to split the text into words was quite complex, but it also
    gave us exactly what we needed. Writing the program without this piece would have
    been significantly more difficult. Regexes, while complex and deep, are wildly
    powerful black magic that can make your programs incredibly flexible and useful.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用来将文本拆分成单词的正则表达式相当复杂，但它也正好给了我们我们需要的东西。如果没有这个部分，编写程序将会显著更加困难。正则表达式虽然复杂且深奥，但它们是一种强大的黑魔法，可以使你的程序变得极其灵活和有用。
- en: The `random.shuffle()` function accepts a `list`, which is mutated in place.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random.shuffle()` 函数接受一个 `list`，并且会就地修改。'
- en: List comprehensions and `map()` can often lead to more compact code, but going
    too far can reduce readability. Choose wisely.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导和 `map()` 经常可以使代码更加紧凑，但过度使用可能会降低可读性。明智地选择。
- en: '| ![](../Images/16-unnumb-3.png)  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/16-unnumb-3.png)  |'
- en: '* * *'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 I would like to stress that a significant part of my job is spent looking
    for answers both in the books I own but also on the internet!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 1 我想强调，我的工作中有很大一部分时间是在寻找答案，这些答案既来自我拥有的书籍，也来自互联网！
