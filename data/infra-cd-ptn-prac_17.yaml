- en: Appendix A. Running examples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 运行示例
- en: The examples in this book use Python to create a JSON configuration file for
    you to run with HashiCorp Terraform. This appendix provides guidance on running
    the examples. Why bother with this manual two-step process of generating the JSON
    file using Python and *then* creating the resources using Terraform?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例使用 Python 创建一个 JSON 配置文件，以便您可以使用 HashiCorp Terraform 运行。本附录提供了运行示例的指导。为什么要费心进行这个两步手动过程：首先使用
    Python 生成 JSON 文件，然后使用 Terraform 创建资源？
- en: First, I want to ensure that anyone who wants to run the examples but cannot
    use Google Cloud Platform (GCP) has an opportunity to examine them further. This
    allows for “local” development and testing and optionally creating live infrastructure
    resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想确保任何想要运行示例但无法使用 Google Cloud Platform (GCP) 的人都有机会进一步检查它们。这允许进行“本地”开发和测试，并可选择创建实时基础设施资源。
- en: Second, JSON files have a lot of content! They turned out quite verbose in code
    listings. A Python wrapper allows me to provide examples of the patterns without
    wading through lines of JSON configuration. Adding Python code around Terraform
    JSON syntax offers some future-proofing in case I need to rewrite the examples
    in another tool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，JSON 文件内容很多！它们在代码列表中显得相当冗长。一个 Python 包装器允许我提供模式示例，而无需浏览 JSON 配置的行。在 Terraform
    JSON 语法周围添加 Python 代码提供了一些未来保障，以防我需要将示例重写为另一个工具。
- en: Note Reference links, libraries, and tool syntax change. Review [https://github.com/joatmon08/manning-book](https://github.com/joatmon08/manning-book)
    for the most up-to-date code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：参考链接、库和工具语法可能会更改。请查阅 [https://github.com/joatmon08/manning-book](https://github.com/joatmon08/manning-book)
    以获取最新的代码。
- en: '![](../../OEBPS/Images/APPA_F01_Wang.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPA_F01_Wang.png)'
- en: Figure A.1 Use the code listings written in Python to generate a JSON file and
    run it with Terraform.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1 使用用 Python 编写的代码列表生成 JSON 文件，并用 Terraform 运行它。
- en: Figure A.1 reiterates the workflow you need to run the examples. If you run
    `python` `main.py`, you will get a JSON file with the file extension .tf.json.
    Run `terraform` `init` in your CLI to initialize the tool state, and `terraform`
    `apply` to provision resources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1 重复说明了运行示例所需的流程。如果您运行 `python main.py`，您将得到一个扩展名为 .tf.json 的 JSON 文件。在您的
    CLI 中运行 `terraform init` 以初始化工具状态，然后运行 `terraform apply` 以配置资源。
- en: I will briefly discuss how to set up an account with various cloud providers.
    Then, I’ll introduce Python and the libraries I referenced throughout the examples,
    such as infrastructure API access and testing. Finally, I will provide a short
    explanation of how to use Terraform with GCP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简要讨论如何设置各种云提供商的账户。然后，我将介绍 Python 以及我在示例中引用的库，例如基础设施 API 访问和测试。最后，我将简要解释如何使用
    Terraform 与 GCP 一起使用。
- en: A.1 Cloud providers
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 云提供商
- en: The examples in this book use Google Cloud Platform (GCP) as the cloud provider.
    If you prefer another cloud provider, many examples have sidebars on an equivalent
    implementation to achieve a similar architecture. Table A.1 maps the approximations
    for each resource type across GCP, Amazon Web Services (AWS), and Microsoft Azure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例使用 Google Cloud Platform (GCP) 作为云提供商。如果您更喜欢其他云提供商，许多示例都有侧边栏，提供了等效的实现来达到类似的架构。表
    A.1 将 GCP、Amazon Web Services (AWS) 和 Microsoft Azure 中每种资源类型的近似值进行了映射。
- en: Table A.1 Mapping resources across cloud providers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.1 云提供商间资源映射
- en: '| Resource | GCP | AWS | Azure |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | GCP | AWS | Azure |'
- en: '| Grouping resources | Google project | AWS account | Azure subscription and
    resource groups |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 资源分组 | GCP 项目 | AWS 账户 | Azure 订阅和资源组 |'
- en: '| Identity and access management (IAM) | Google IAM | AWS IAM | Azure Active
    Directory |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 身份和访问管理 (IAM) | Google IAM | AWS IAM | Azure Active Directory |'
- en: '| Linux servers (Ubuntu) | Google compute instance | Amazon EC2 instance |
    Azure Linux Virtual Machine |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Linux 服务器（Ubuntu） | Google 计算实例 | Amazon EC2 实例 | Azure Linux 虚拟机 |'
- en: '| Networking | Google Virtual Private Cloud (VPC)SubnetsNote: Has default network
    | Amazon Virtual Private Cloud (VPC)SubnetsRoute tablesGatewaysNote: Has default
    network | Azure Virtual NetworkSubnetsRoute table associations |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | Google 虚拟私有云 (VPC) 子网 注意：具有默认网络 | Amazon 虚拟私有云 (VPC) 子网 路由表 网关 注意：具有默认网络
    | Azure 虚拟网络 子网 路由表关联 |'
- en: '| Firewall rules | Firewall rules | Security groupsNetwork access control lists
    | Network security groups |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 防火墙规则 | 防火墙规则 | 安全组网络访问控制列表 | 网络安全组 |'
- en: '| Load balancing | Google compute forwarding rule (L4)HTTP(S) load balancing
    (L7) | AWS Elastic Load Balancing (ELB) (L4)AWS Application Load Balancer (ALB)
    (L7) | Azure Load Balancer (L4)Azure Application Gateway (L7) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 负载均衡 | Google compute forwarding rule (L4)HTTP(S) 负载均衡 (L7) | AWS Elastic
    Load Balancing (ELB) (L4)AWS 应用程序负载均衡器 (ALB) (L7) | Azure 负载均衡器 (L4)Azure 应用程序网关
    (L7) |'
- en: '| Relational database (PostgreSQL) | Google Cloud SQL | Amazon Relational Database
    Service (RDS) | Azure Database for PostgreSQL |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 关系型数据库 (PostgreSQL) | Google Cloud SQL | Amazon Relational Database Service
    (RDS) | Azure Database for PostgreSQL |'
- en: '| Container orchestrator (Kubernetes) | Google Kubernetes Engine (GKE) | Amazon
    Elastic Kubernetes Service (EKS) | Azure Kubernetes Service (AKS) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 容器编排器 (Kubernetes) | Google Kubernetes Engine (GKE) | Amazon Elastic Kubernetes
    Service (EKS) | Azure Kubernetes Service (AKS) |'
- en: In this section, I’ll outline some initial setup you’ll need to do for each
    cloud provider, if you choose.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将概述如果您选择，为每个云服务提供商需要进行的初始设置。
- en: A.1.1 Google Cloud Platform
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 Google Cloud Platform
- en: When you start using GCP, create a new project ([http://mng.bz/mOV2](http://mng.bz/mOV2))
    and run all of the examples in that project. This allows you to delete the project
    and its resources when you finish the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用 GCP 时，创建一个新项目 ([http://mng.bz/mOV2](http://mng.bz/mOV2)) 并在该项目中运行所有示例。这允许您在完成本书后删除项目及其资源。
- en: 'Next, install the `gcloud` CLI ([https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install)).
    The CLI will help you authenticate so Terraform can access the GCP API:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 `gcloud` CLI ([https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install))。CLI
    将帮助您进行验证，以便 Terraform 可以访问 GCP API：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This sets up credentials on your machine so Terraform can authenticate to GCP
    ([http://mng.bz/5Qw1](http://mng.bz/5Qw1)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的机器上设置凭据，以便 Terraform 可以验证 GCP ([http://mng.bz/5Qw1](http://mng.bz/5Qw1))。
- en: A.1.2 Amazon Web Services
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 Amazon Web Services
- en: When you start using AWS, create a new account ([http://mng.bz/6XDD](http://mng.bz/6XDD))
    and run all of the examples in that account. This allows you to delete the account
    and its resources when you finish the book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用 AWS 时，创建一个新账户 ([http://mng.bz/6XDD](http://mng.bz/6XDD)) 并在该账户中运行所有示例。这允许您在完成本书后删除账户及其资源。
- en: Next, create a set of access keys in the AWS console ([http://mng.bz/o21r](http://mng.bz/o21r)).
    You will need to save these keys so Terraform can access the AWS API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 AWS 控制台中创建一组访问密钥 ([http://mng.bz/o21r](http://mng.bz/o21r))。您需要保存这些密钥，以便
    Terraform 可以访问 AWS API。
- en: 'Copy the access key ID and secret access key and save it to environment variables:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 复制访问密钥 ID 和秘密访问密钥并将其保存到环境变量中：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, set the AWS region you want to use:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置您想要使用的 AWS 区域：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets up credentials on your machine so Terraform can authenticate to AWS
    ([http://mng.bz/nNWg](http://mng.bz/nNWg)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的机器上设置凭据，以便 Terraform 可以验证 AWS ([http://mng.bz/nNWg](http://mng.bz/nNWg))。
- en: A.1.3 Microsoft Azure
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 Microsoft Azure
- en: When you start using Azure, create a new account ([http://mng.bz/v6nJ](http://mng.bz/v6nJ)).
    Creating a new account gives you a subscription by default. This allows you to
    create resources within the subscription and group them by resource groups. After
    you finish the book, you can delete the resource group.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用 Azure 时，创建一个新账户 ([http://mng.bz/v6nJ](http://mng.bz/v6nJ))。创建新账户会默认为您提供一个订阅。这允许您在订阅内创建资源并将它们按资源组分组。完成本书后，您可以删除资源组。
- en: Next, install the Azure CLI ([http://mng.bz/44Da](http://mng.bz/44Da)). The
    CLI will help you authenticate so Terraform can access the Azure API.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 Azure CLI ([http://mng.bz/44Da](http://mng.bz/44Da))。CLI 将帮助您进行验证，以便
    Terraform 可以访问 Azure API。
- en: 'Log into the Azure CLI:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 Azure CLI：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'List the subscriptions so you can get the ID for the default subscription:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列出订阅，以便您可以获取默认订阅的 ID：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Copy the subscription ID and save it to an environment variable:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 复制订阅 ID 并将其保存到环境变量中：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sets up credentials on your machine so Terraform can authenticate to Azure
    ([http://mng.bz/QvPw](http://mng.bz/QvPw)). You should create an Azure resource
    group ([http://mng.bz/XZNG](http://mng.bz/XZNG)) for each example. Delete the
    resource group to remove all infrastructure resources for the example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的机器上设置凭据，以便 Terraform 可以验证 Azure ([http://mng.bz/QvPw](http://mng.bz/QvPw))。您应该为每个示例创建一个
    Azure 资源组 ([http://mng.bz/XZNG](http://mng.bz/XZNG))。删除资源组以移除示例的所有基础设施资源。
- en: A.2 Python
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 Python
- en: Before you start running the examples, you must download Python. I used Python
    3 in the code listings. You can install Python in a few ways, such as using your
    package manager of choice or the Python downloads page ([www.python.org/downloads/](https://www.python.org/downloads)).
    However, I prefer to use pyenv ([https://github.com/pyenv/pyenv](https://github.com/pyenv/pyenv))
    to download and manage my Python versions. pyenv allows you to choose the Python
    version you need and install it into a virtual environment using Python’s venv
    library ([https://docs.python.org/3/library/venv.xhtml](https://docs.python.org/3/library/venv.xhtml)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始运行示例之前，您必须下载 Python。我在代码列表中使用 Python 3。您可以通过选择您的包管理器或 Python 下载页面（[www.python.org/downloads/](https://www.python.org/downloads)）来安装
    Python。然而，我更喜欢使用 pyenv ([https://github.com/pyenv/pyenv](https://github.com/pyenv/pyenv))
    来下载和管理我的 Python 版本。pyenv 允许您选择所需的 Python 版本，并使用 Python 的 venv 库（[https://docs.python.org/3/library/venv.xhtml](https://docs.python.org/3/library/venv.xhtml)）将其安装到虚拟环境中。
- en: I use a virtual environment because I have many projects that require different
    Python versions. Installing different versions of each project in the same environment
    gets confusing and often breaks code. As a result, I want to separate each project
    into a development environment with its dependencies and Python version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用虚拟环境，因为我有多个项目需要不同的 Python 版本。在同一个环境中安装每个项目的不同版本会让人困惑，并且经常导致代码损坏。因此，我想将每个项目与其依赖项和
    Python 版本分开，分别放入一个开发环境中。
- en: A.2.1 Install Python libraries
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 安装 Python 库
- en: After you install Python 3 into your development or virtual environment, you
    need to install some external libraries. In listing A.1, I capture libraries and
    dependencies in requirements.txt, a plaintext file with a list of packages and
    versions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将 Python 3 安装到您的开发或虚拟环境之后，您需要安装一些外部库。在列表 A.1 中，我捕获了 requirements.txt 文件中的库和依赖项，这是一个包含包和版本的纯文本文件。
- en: Listing A.1 Python requirements.txt with libraries for this book
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.1 包含本书库的 Python requirements.txt
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Installs Apache Libcloud library
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装 Apache Libcloud 库
- en: ❷ Installs client libraries for GCP, including the Python client and Cloud Billing
    client
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安装 GCP 的客户端库，包括 Python 客户端和 Cloud Billing 客户端
- en: ❸ Installs netaddr, a Python library for parsing network information
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安装 netaddr，这是一个用于解析网络信息的 Python 库
- en: ❹ Installs pytest, a Python testing framework
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安装 pytest，这是一个 Python 测试框架
- en: 'The example repository contains a requirements.txt file that freezes the library
    versions you need to install. In your Python development environment, use your
    CLI to install the libraries with pip, Python’s package installer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例仓库包含一个 requirements.txt 文件，该文件冻结了您需要安装的库版本。在您的 Python 开发环境中，使用您的 CLI 通过 pip
    安装库，这是 Python 的包安装程序：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some of the examples require more complex automation or testing. They reference
    libraries that you will need to import separately. Let’s examine the libraries
    to download in more detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例需要更复杂的自动化或测试。它们引用了您需要单独导入的库。让我们更详细地检查需要下载的库。
- en: Apache Libcloud
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Libcloud
- en: Apache Libcloud ([https://libcloud.apache.org/](https://libcloud.apache.org/))
    offers a Python interface to create, update, read, and delete cloud resources.
    It includes a single interface agnostic of the cloud service or provider. I reference
    this library in the early sections of the book for examples on integration and
    end-to-end testing. To use Apache Libcloud in the following listing, you can import
    the `libcloud` package and set up a driver to connect to GCP.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Libcloud ([https://libcloud.apache.org/](https://libcloud.apache.org/))
    提供了一个 Python 接口来创建、更新、读取和删除云资源。它包含一个与云服务或提供商无关的单个接口。我在本书的早期部分引用了这个库，以提供集成和端到端测试的示例。要在以下列表中使用
    Apache Libcloud，您可以导入 `libcloud` 包并设置一个驱动程序以连接到 GCP。
- en: Listing A.2 Import Apache Libcloud
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.2 导入 Apache Libcloud
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Imports the object to set the cloud provider, such as GCP
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入设置云提供商的对象，例如 GCP
- en: ❷ Imports the function to initialize the driver for a cloud provider
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入初始化云提供商驱动程序的函数
- en: ❸ Sets up the driver that will connect to Google Cloud
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置连接到 Google Cloud 的驱动程序
- en: ❹ Passes credentials to connect to the Google Cloud API to initialize the driver
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将凭证传递给 Google Cloud API 以初始化驱动程序
- en: I use Apache Libcloud in the tests instead of Google Cloud’s client libraries
    because it provides a unified API to access any cloud. If I want to switch my
    examples to AWS or Azure, I need to change only the driver for the cloud provider.
    The tests only read information from the cloud provider and do not run any complex
    operations with Apache Libcloud.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我使用 Apache Libcloud 而不是 Google Cloud 的客户端库，因为它提供了一个统一的 API 来访问任何云。如果我想将示例切换到
    AWS 或 Azure，我只需要更改云提供商的驱动程序。测试只从云提供商读取信息，并不使用 Apache Libcloud 执行任何复杂操作。
- en: AWS and Azure equivalents
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: You will need to update the Apache Libcloud driver to use Amazon EC2 Driver
    ([http://mng.bz/yvQG](http://mng.bz/yvQG)) or Azure ARM Compute Driver ([http://mng.bz/M5B7](http://mng.bz/M5B7)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新 Apache Libcloud 驱动程序以使用 Amazon EC2 驱动程序 ([http://mng.bz/yvQG](http://mng.bz/yvQG))
    或 Azure ARM Compute 驱动程序 ([http://mng.bz/M5B7](http://mng.bz/M5B7))。
- en: Python Clients for Google Cloud
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 的 Python 客户端
- en: The later part of the book includes more complicated IaC and tests, which I
    could not implement in Apache Libcloud. Apache Libcloud could not support my use
    case of retrieving specific information about Google Cloud resources, such as
    pricing information! The following listing shows how I used client libraries specific
    to Google Cloud in these use cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 书的后面部分包括更复杂的 IaC 和测试，这些我无法在 Apache Libcloud 中实现。Apache Libcloud 无法支持我获取 Google
    Cloud 资源特定信息的用例，例如定价信息！下面的列表展示了我是如何在这些用例中使用特定于 Google Cloud 的客户端库的。
- en: Listing A.3 Import Google Cloud Client Library
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.3 导入 Google Cloud 客户端库
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Imports the Google Cloud Client Library for Python
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Python 的 Google Cloud 客户端库
- en: ❷ Imports the Python Client for Google Cloud Billing API
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入 Google Cloud Billing API 的 Python 客户端
- en: AWS and Azure equivalents
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: You can import the AWS SDK for Python ([https://aws.amazon.com/sdk-for-python/](https://aws.amazon.com/sdk-for-python/))
    or Azure library for Python ([http://mng.bz/VMV0](http://mng.bz/VMV0)) to build
    the examples in AWS or Azure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以导入 AWS SDK for Python ([https://aws.amazon.com/sdk-for-python/](https://aws.amazon.com/sdk-for-python/))
    或 Azure Python 库 ([http://mng.bz/VMV0](http://mng.bz/VMV0)) 来构建 AWS 或 Azure 中的示例。
- en: The examples use two libraries maintained by Google Cloud. The Google Cloud
    Client Library for Python ([http://mng.bz/aJ1z](http://mng.bz/aJ1z)) allows you
    to access many of the APIs on Google Cloud and create, read, update, and delete
    resources. However, it *does not* include access to Google’s Cloud Billing API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用了两个由 Google Cloud 维护的库。Python 的 Google Cloud 客户端库 ([http://mng.bz/aJ1z](http://mng.bz/aJ1z))
    允许您访问 Google Cloud 上的许多 API 并创建、读取、更新和删除资源。然而，它*不包含*对 Google Cloud Billing API
    的访问。
- en: As a result, for chapter 12 on cost, I had to import a different library maintained
    by Google Cloud to retrieve billing catalog information. The Python Client for
    Google Cloud Billing API ([http://mng.bz/gwBl](http://mng.bz/gwBl)) allows me
    to read information from the Google Cloud service catalog.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于第 12 章关于成本的内容，我不得不导入由 Google Cloud 维护的另一个库来检索计费目录信息。Google Cloud Billing
    API 的 Python 客户端 ([http://mng.bz/gwBl](http://mng.bz/gwBl)) 允许我从 Google Cloud
    服务目录中读取信息。
- en: When you have IaC that needs to reference specific resources or APIs not available
    in a unified API, like Apache Libcloud, you often need to find a separate library
    to retrieve the information you need. While we would like to minimize dependencies,
    we must recognize that not every library achieves every use case! Choose a different
    library if you feel that your existing one cannot accomplish the automation you
    need.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有需要引用特定资源或 API（如 Apache Libcloud 中的统一 API 所不具备的）的 IaC 时，您通常需要找到一个单独的库来检索所需的信息。虽然我们希望最小化依赖，但我们必须认识到并非每个库都能满足每个用例！如果您觉得现有的库无法完成所需的自动化，请选择不同的库。
- en: netaddr
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: netaddr
- en: In chapter 5, I needed to modify an IP address block. While I entertained the
    possibility of mathematically calculating the correct address, I decided to use
    a library instead. Python does have a built-in ipaddress library, but it does
    not include the functionality I needed. I installed netaddr ([https://netaddr.readthedocs.io/en/latest/](https://netaddr.readthedocs.io/en/latest/))
    instead to reduce the additional code I needed to calculate the IP addresses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，我需要修改一个 IP 地址块。虽然我考虑了通过数学计算正确地址的可能性，但我决定使用库。Python 确实有一个内置的 ipaddress
    库，但它不包括我需要的功能。我安装了 netaddr ([https://netaddr.readthedocs.io/en/latest/](https://netaddr.readthedocs.io/en/latest/))
    来减少我需要计算 IP 地址的额外代码。
- en: pytest
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: pytest
- en: Many of the tests in this book use pytest, a Python testing framework. You can
    use Python’s unittest module to write and run tests as well. I prefer pytest since
    it offers a minimal interface to write and run tests without more complicated
    testing features. Rather than explain pytest in depth, I will outline some of
    the features I use in the tests and how to run them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多测试使用 pytest，一个 Python 测试框架。您也可以使用 Python 的 unittest 模块来编写和运行测试。我更喜欢 pytest，因为它提供了一个简单的接口来编写和运行测试，而不需要更复杂的测试功能。而不是深入解释
    pytest，我将概述我在测试中使用的一些功能和如何运行它们。
- en: Pytest searches for Python files prefixed with test_. This filename signals
    that the file contains Python tests. Each test function also uses the prefix test_.
    Pytest selects and runs the tests based on the prefix.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 搜索以 test_ 为前缀的 Python 文件。此文件名表示该文件包含 Python 测试。每个测试函数也使用前缀 test_。Pytest
    根据前缀选择并运行测试。
- en: Many of the tests in this book include test fixtures. A *test fixture* captures
    a known object, such as a name or constant, that you can use for comparison across
    multiple tests. In the following listing, I use fixtures to pass commonly processed
    objects, like network attributes, among multiple tests.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多测试都包括测试夹具。一个 *测试夹具* 捕获一个已知对象，例如一个名称或常量，您可以在多个测试中进行比较。在下面的列表中，我使用夹具传递多个测试中常用的对象，如网络属性。
- en: Listing A.4 An example using pytest
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.4 使用 pytest 的示例
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Imports the pytest library
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 pytest 库
- en: ❷ Sets a known object, or test fixture
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置已知对象或测试夹具
- en: ❸ Returns the known network name “my-network” and passes it to your first test
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回已知的网络名称“my-network”并将其传递给您的第一个测试
- en: ❹ Asserts that the network name matches the expected, fails the test if it does
    not. You can also include a descriptive error message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言网络名称与预期匹配，如果不匹配则测试失败。您还可以包含一个描述性错误消息。
- en: The most important part of the test involves checking that the expected value
    matches the actual value, or *asserting*. Pytest suggests one `assert` statement
    for each test. I follow this convention because it helps me write more descriptive,
    helpful tests. Your tests should describe their intent and what they test as clearly
    as possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试最重要的部分是检查预期值与实际值是否匹配，或 *断言*。Pytest 建议每个测试使用一个 `assert` 语句。我遵循这个约定，因为它有助于我编写更描述性、更有帮助的测试。您的测试应该尽可能清晰地描述其意图和测试内容。
- en: 'To run a set of tests with pytest, you can pass in the directory with the tests.
    However, make sure your testing directory has absolute paths to any files you
    read in via pytest! For example, the tests in chapter 4 read external JSON files.
    As a result, you need to change the working directory to the chapter and section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 pytest 运行一系列测试，您可以传递包含测试的目录。但是，请确保您的测试目录包含通过 pytest 读取的任何文件的绝对路径！例如，第 4
    章的测试读取外部 JSON 文件。因此，您需要将工作目录更改为章节和部分：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can run all the tests in the directory by passing a dot (`.`) to pytest
    in the CLI:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在命令行中将点（`.`）传递给 pytest 来运行目录中的所有测试：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can run one file by adding the filename to pytest in the CLI:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在命令行中添加文件名来运行一个文件：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Many of the tests in this book use similar patterns of fixtures and `assert`
    statements. For more information on other pytest features, review its documentation
    ([https://docs.pytest.org](https://docs.pytest.org)). You will run either `pytest`
    or `python main.py` commands in your CLI for the examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多测试使用类似的夹具和 `assert` 语句模式。有关其他 pytest 功能的更多信息，请参阅其文档（[https://docs.pytest.org](https://docs.pytest.org)）。您将在
    CLI 中运行 `pytest` 或 `python main.py` 命令来运行示例。
- en: A.2.2 Run Python
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 运行 Python
- en: I separate each infrastructure resource into a Python file. Every directory
    contains a main.py file, as shown in listing A.5\. The file always includes code
    that writes a Python dictionary to a JSON file. The object needs to use Terraform’s
    JSON configuration syntax for an infrastructure resource.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将每个基础设施资源分离到一个 Python 文件中。每个目录都包含一个 main.py 文件，如列表 A.5 所示。该文件始终包含将 Python 字典写入
    JSON 文件的代码。该对象需要使用 Terraform 的 JSON 配置语法来表示基础设施资源。
- en: Listing A.5 Example main.py file writes dictionary to JSON file
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.5 示例 main.py 文件将字典写入 JSON 文件
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Generates a Python dictionary for a GCP server
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为 GCP 服务器生成 Python 字典
- en: ❷ Creates a JSON file named “main.tf.json,” which contains Terraform-compatible
    JSON configuration
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个名为“main.tf.json”的 JSON 文件，其中包含与 Terraform 兼容的 JSON 配置
- en: ❸ Writes out the server dictionary to the JSON file
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将服务器字典写入 JSON 文件
- en: 'You can run the Python script in your terminal:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在终端中运行 Python 脚本：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you list the files, you will find a new JSON file named main.tf.json:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您列出文件时，您将找到一个名为 main.tf.json 的新 JSON 文件：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Many examples require you to run Python for main.py and generate a JSON file
    named main.tf.json unless otherwise noted. However, some examples use other libraries
    or code for automation or testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多示例要求您运行 Python 的 main.py 并生成一个名为 main.tf.json 的 JSON 文件，除非另有说明。然而，一些示例使用其他库或代码进行自动化或测试。
- en: A.3 HashiCorp Terraform
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 HashiCorp Terraform
- en: After you generate a main.tf.json file by using `python main.py`, you need to
    create the resources in GCP. The .tf.json files need HashiCorp Terraform to create,
    read, update, and delete the resources in GCP.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `python main.py` 生成 main.tf.json 文件后，您需要在 GCP 中创建资源。.tf.json 文件需要使用 HashiCorp
    Terraform 来创建、读取、更新和删除 GCP 中的资源。
- en: You can download and install Terraform with the package manager of your choice
    ([www.terraform.io/downloads.xhtml](https://www.terraform.io/downloads.xhtml)).
    You run it with a set of CLI commands, so you will need to download the binary
    and make sure you can run it in your terminal. Terraform searches for files with
    the .tf or .tf.json extension within a working directory and creates, reads, updates,
    and deletes the resources you define in those files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您选择的软件包管理器下载并安装 Terraform（[www.terraform.io/downloads.xhtml](https://www.terraform.io/downloads.xhtml)）。您通过一组
    CLI 命令运行它，因此您需要下载二进制文件并确保您可以在终端中运行它。Terraform 在工作目录中搜索具有 .tf 或 .tf.json 扩展名的文件，并创建、读取、更新和删除您在这些文件中定义的资源。
- en: A.3.1 JSON configuration syntax
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 JSON 配置语法
- en: Terraform offers various interfaces for you to create infrastructure resources.
    Most of its documentation uses HashiCorp Configuration Language (HCL), a DSL that
    defines infrastructure resources for each cloud provider. For more on Terraform,
    review its documentation ([www.terraform.io/docs/index.xhtml](https://www.terraform.io/docs/index.xhtml)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 提供了各种接口供您创建基础设施资源。其大部分文档使用 HashiCorp 配置语言（HCL），这是一种 DSL，用于为每个云提供商定义基础设施资源。有关
    Terraform 的更多信息，请参阅其文档（[www.terraform.io/docs/index.xhtml](https://www.terraform.io/docs/index.xhtml)）。
- en: The examples in this book do not use HCL. Instead, they use a JSON configuration
    syntax ([www.terraform.io/docs/language/syntax/json.xhtml](https://www.terraform.io/docs/language/syntax/json.xhtml))
    specific to Terraform. This syntax uses the same DSL as the HCL, just formatted
    in JSON.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例不使用 HCL。相反，它们使用 Terraform 特定的 JSON 配置语法（[www.terraform.io/docs/language/syntax/json.xhtml](https://www.terraform.io/docs/language/syntax/json.xhtml)）。这种语法使用与
    HCL 相同的 DSL，只是格式化为 JSON。
- en: Each main.py file in Python writes a dictionary out to the JSON file. Listing
    A.6 shows how I create a dictionary that defines a Terraform resource in JSON
    configuration syntax. The JSON resource references the `google_compute_instance`
    resource defined by Terraform ([http://mng.bz/e71z](http://mng.bz/e71z)) and sets
    all of the required attributes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每个 main.py 文件都会将一个字典写入 JSON 文件。列表 A.6 展示了如何创建一个字典，该字典使用 JSON 配置语法定义
    Terraform 资源。JSON 资源引用了 Terraform 定义的 `google_compute_instance` 资源（[http://mng.bz/e71z](http://mng.bz/e71z)）并设置了所有必需的属性。
- en: Listing A.6 Python dictionary for a server in Terraform JSON
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.6 Terraform JSON 中服务器的 Python 字典
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Signals to Terraform that you will define a list of resources
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向 Terraform 信号，您将定义资源列表
- en: ❷ Defines a “google_compute_instance,” a Terraform resource that will create
    and configure a server in GCP
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义了一个“google_compute_instance”，这是一个将在 GCP 中创建和配置服务器的 Terraform 资源
- en: ❸ Defines a unique identifier for the server so Terraform can track it
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为服务器定义一个唯一标识符，以便 Terraform 可以跟踪它
- en: AWS and Azure equivalents
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 的等效资源
- en: In AWS, you would use the `aws_instance` Terraform resource with a reference
    to the default VPC ([http://mng.bz/pOPG](http://mng.bz/pOPG)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 中，您将使用带有默认 VPC 引用的 `aws_instance` Terraform 资源（[http://mng.bz/pOPG](http://mng.bz/pOPG)）。
- en: In Azure, you would need to create a virtual network and subnets. Then, create
    the `azurerm_linux_virtual_machine` Terraform resource ([http://mng.bz/Ooxn](http://mng.bz/Ooxn))
    on the network.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，您需要创建一个虚拟网络和子网。然后，在网络上创建 `azurerm_linux_virtual_machine` Terraform
    资源（[http://mng.bz/Ooxn](http://mng.bz/Ooxn)）。
- en: The Python dictionary becomes Terraform JSON configuration syntax when you write
    it to a JSON file. Terraform will create the resources defined in its current
    working directory only with files that have the extension .tf or .tf.json. If
    you update the code to write the configuration to a JSON file that does not have
    the .tf.json extension, Terraform will not recognize the resources in the file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将其写入 JSON 文件时，Python 字典变为 Terraform JSON 配置语法。Terraform 只会创建其当前工作目录中定义的资源，这些资源具有
    .tf 或 .tf.json 扩展名。如果您更新代码以将配置写入没有 .tf.json 扩展名的 JSON 文件，Terraform 将不会识别文件中的资源。
- en: A.3.2 Initialize state
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 初始化状态
- en: After running Python and creating a JSON file, you need to initialize Terraform
    in the working directory. Figure A.2 outlines the commands you need to run in
    your terminal to initialize state and apply infrastructure changes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Python 并创建 JSON 文件后，您需要在工作目录中初始化 Terraform。图 A.2 概述了您需要在终端中运行的命令以初始化状态并应用基础设施更改。
- en: '![](../../OEBPS/Images/APPA_F02_Wang.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPA_F02_Wang.png)'
- en: Figure A.2 Initialize and deploy resources using Terraform in a working directory;
    then destroy the resources when you complete the example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2 在工作目录中使用 Terraform 初始化和部署资源；完成示例后销毁资源。
- en: 'In your terminal, change to a directory with a *.tf.json file. For example,
    I change to the directory that contains examples for section 2.3:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中，切换到包含 *.tf.json 文件的目录。例如，我切换到包含 2.3 节示例的目录：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Initialize Terraform in your terminal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中初始化 Terraform：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Terraform runs an initialization step that creates a tool state called *backend*
    and installs plugins and modules. The initialization creates a series of files
    that you should not delete from your filesystem. After you initialize Terraform,
    you will find some hidden and new files when you list the contents of your directory:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 执行一个初始化步骤，创建一个名为 *backend* 的工具状态，并安装插件和模块。初始化会创建一系列文件，您不应从文件系统中删除这些文件。初始化
    Terraform 后，您在列出目录内容时将找到一些隐藏的新文件：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Terraform stores its tool state in a state file to quickly reconcile any changes
    that you make to infrastructure resources. Terraform can reference a state file
    stored locally or on a server, artifact registry, object store, or other. The
    examples store tool state in a local file named terraform.tfstate. If you accidentally
    delete this file, Terraform will no longer recognize resources under its management!
    Ensure that you do not remove the local state file or update the examples to use
    a remote backend. You may also find a terraform.tfstate.backup file, which Terraform
    uses to back up its tool state before it makes changes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 将其工具状态存储在状态文件中，以便快速协调您对基础设施资源所做的任何更改。Terraform 可以引用存储在本地或服务器、工件注册库、对象存储或其他位置的状态文件。示例将工具状态存储在名为
    terraform.tfstate 的本地文件中。如果您意外删除此文件，Terraform 将不再识别其管理下的资源！请确保您不要删除本地状态文件或更新示例以使用远程后端。您还可能找到一个
    terraform.tfstate.backup 文件，Terraform 在进行更改之前使用该文件来备份其工具状态。
- en: Initialization also installs a plugin for Terraform to communicate to Google.
    Terraform uses a plugin system to extend its engine and interface with cloud providers.
    The AWS examples use the same command of `terraform init` to download the AWS
    plugin for you automatically. Plugins or modules get downloaded to the .terraform
    folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化还安装了一个用于 Terraform 与 Google 通信的插件。Terraform 使用插件系统来扩展其引擎并与云提供商接口。AWS 示例使用相同的
    `terraform init` 命令为您自动下载 AWS 插件。插件或模块将被下载到 .terraform 文件夹中。
- en: Terraform also pins the versions of plugins for you, similar to the requirements.txt
    file for Python. You’ll find a list of pinned versions for plugins in .terraform.lock.hcl.
    In the examples repository, I committed the .terraform.lock.hcl to version control
    so that Terraform installs only the plugins I’ve tested with at the time I generated
    the examples.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 还为您固定了插件版本，类似于 Python 的 requirements.txt 文件。您将在 .terraform.lock.hcl
    中找到一个固定插件版本的列表。在示例存储库中，我将 .terraform.lock.hcl 提交到版本控制，这样 Terraform 只会安装我在生成示例时测试过的插件。
- en: A.3.3 Set credentials in your terminal
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.3 在您的终端中设置凭证
- en: 'Most Terraform plugins read credentials for infrastructure provider APIs by
    using environment variables. I usually set the GCP project environment variable,
    so Terraform connects to the correct GCP project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Terraform 插件通过使用环境变量来读取基础设施提供者 API 的凭证。我通常设置 GCP 项目环境变量，这样 Terraform 就能连接到正确的
    GCP 项目：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I also authenticate to GCP by using the gcloud CLI tool. The command automatically
    sets credentials for Terraform to access GCP:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我还通过使用 gcloud CLI 工具验证 GCP。该命令会自动为 Terraform 设置凭证以访问 GCP：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For other cloud providers, I recommend setting environment variables in your
    terminal to authenticate to your AWS or Azure account. Reference section A.1 for
    their configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他云提供商，我建议在您的终端中设置环境变量以验证您的 AWS 或 Azure 账户。参考 A.1 节以获取它们的配置。
- en: A.3.4 Apply Terraform
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.4 应用 Terraform
- en: 'After setting your credentials, you can use Terraform to dry-run and deploy
    your infrastructure resources. In your terminal, you can run `terraform apply`
    to start the deployment of your changes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好凭证后，您可以使用 Terraform 进行干运行和部署您的基础设施资源。在您的终端中，您可以通过运行 `terraform apply` 来开始部署您的更改：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The command will stop and wait for you to enter `yes` at `Enter a value`. It
    waits for you to review the changes and check that you want to add, change, or
    destroy resources. Always review changes before entering yes!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将停止并等待您在 `Enter a value` 处输入 `yes`。它等待您审查更改并确认您想要添加、更改或销毁资源。在输入 yes 之前，始终审查更改！
- en: 'After you type `yes`, Terraform will start deploying the resources:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在您输入 `yes` 后，Terraform 将开始部署资源：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will find your resources in your GCP project after you use `terraform` `apply`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `terraform apply` 后，您将在您的 GCP 项目中找到您的资源。
- en: A.3.5 Clean up
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.5 清理
- en: Many of the examples use overlapping names or network CIDR blocks. I recommend
    you clean up the resources between each chapter and section. Terraform uses the
    `terraform destroy` command to delete all the resources listed in terraform.tfstate
    from GCP. In your terminal, make sure you authenticate to GCP or your infrastructure
    provider.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多示例使用重叠的名称或网络 CIDR 块。我建议您在每个章节和部分之间清理资源。Terraform 使用 `terraform destroy` 命令从
    GCP 删除 terraform.tfstate 中列出的所有资源。在您的终端中，请确保您已验证 GCP 或您的基础设施提供商。
- en: When you run `terraform destroy`, it outputs the resources it will destroy.
    Review the list of resources and make sure you want to delete them!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `terraform destroy` 时，它会输出它将销毁的资源。请审查资源列表，并确保您想要删除它们！
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After you review the resources you expect to delete, enter `yes` at the command
    prompt. Terraform will delete the resources from GCP. Deletion will take some
    time, so expect this to run for a few minutes. Some examples will take even longer
    to deploy and destroy because they have many resources involved:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在您审查了预期要删除的资源后，在命令提示符处输入 `yes`。Terraform 将从 GCP 删除资源。删除将需要一些时间，因此请预计这将运行几分钟。一些示例的部署和销毁可能需要更长的时间，因为它们涉及许多资源：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After destroying the resources, you can remove the terraform.tfstate, terraform
    .tfstate.backup, and .terraform files if you would like. Remember to delete your
    resources from GCP (or delete the entire project) each time you finish an example
    so you can reduce your cloud bill!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁资源后，如果您愿意，可以删除 terraform.tfstate、terraform .tfstate.backup 和 .terraform 文件。请记住，每次完成示例后，都要从
    GCP 删除您的资源（或删除整个项目），这样您可以减少云费用！
