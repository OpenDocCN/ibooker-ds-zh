- en: Lesson 20\. Building programs to last
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20课\. 编写持久程序的构建
- en: After reading [lesson 20](#ch20), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第20课](#ch20)之后，你将能够
- en: Understand how a bigger task is divided into modules
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一个更大的任务是如何被分解成模块的
- en: Understand why you should hide away details of complicated tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么你应该隐藏复杂任务的细节
- en: Understand what it means for tasks to be dependent on or independent of other
    tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解任务相互依赖或相互独立的意义
- en: You saw how useful loops are at getting the computer to repeat a certain group
    of statements many times. As you’re writing code, it’s important to be aware of
    how you can harness the power of computers to make life easier for you. In this
    lesson, you’ll take this idea a step further to see how to divide a larger program
    into smaller mini-programs, each one constructed to achieve a specific task.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了循环如何有助于让计算机重复执行一组语句多次。当你编写代码时，重要的是要意识到你如何利用计算机的力量使你的生活变得更轻松。在本课中，你将把这个想法更进一步，看看如何将一个较大的程序分解成较小的子程序，每个子程序都是为了完成一个特定的任务。
- en: 'For example, if you think about the process of building a car as a large program,
    you’d never build one machine that builds the entire car. That would be one extremely
    complicated machine. Instead, you’d build various machines and robots that focus
    on doing different and specific tasks: one machine might assemble the frame, one
    might paint the frame, and another might program the on-board computer.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你把制造汽车的过程看作是一个大程序，你永远不会建造一个能制造整个汽车的机器。那将是一个极其复杂的机器。相反，你会建造各种机器和机器人，专注于执行不同的特定任务：一个机器可能组装车架，一个可能喷漆车架，另一个可能编程车载电脑。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You’re getting married! You don’t have time to take care of everything on your
    own, so you want to hire people to take care of various tasks. Write some tasks
    that you can outsource.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你要结婚了！你没有时间自己处理所有事情，所以你想雇佣人来处理各种任务。列出你可以外包的任务。
- en: 'Answer: Find and book venue, decide on catering (food, bar, cake), finalize
    guest list (invite people, keep track of attendees, seating), decorate, hire officiant,
    and dress up the wedding party.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回答：寻找并预订场地，决定餐饮（食物、酒吧、蛋糕），确定宾客名单（邀请人，跟踪出席者，座位安排），装饰，聘请司仪，并为婚礼团队打扮。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 20.1\. Breaking a big task into smaller tasks
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1\. 将大任务分解成小任务
- en: The main idea behind taking one task and breaking it into smaller tasks is to
    help you write programs more effectively. If you start with a smaller problem,
    you can debug it quicker. If you know that a few smaller problems work as expected,
    you can focus on making sure they work well together as opposed to trying to debug
    a large and complex one all at once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个任务分解成更小任务的背后主要思想是帮助你更有效地编写程序。如果你从一个较小的难题开始，你可以更快地调试它。如果你知道几个较小的难题按预期工作，你可以专注于确保它们能很好地协同工作，而不是试图一次性调试一个庞大而复杂的难题。
- en: 20.1.1\. Ordering an item online
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.1.1\. 在线订购商品
- en: 'Think about what happens when you order an item online. You start by putting
    your personal information on a website order form, and you end with getting the
    item delivered to your house. This entire process can be broken into a few steps,
    as you can see in [figure 20.1](#ch20fig01):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想想当你在线订购商品时会发生什么。你首先在网站订单表单上填写你的个人信息，然后以商品被送到你家结束。这个整个过程可以分解成几个步骤，就像你在[图20.1](#ch20fig01)中看到的那样：
- en: 'You fill in a web form to place the order. The order information goes to the
    seller, who extracts the important details: what item, how many, and your name/address.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你填写一个网页表单来下单。订单信息发送给卖家，卖家提取重要细节：什么商品，数量，以及你的姓名/地址。
- en: Using the item type and number, the seller (a person or a robot) finds the item
    in a warehouse and gives it to the packer.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用商品类型和数量，卖家（人或机器人）在仓库中找到商品并将其交给包装员。
- en: The packer takes the item(s) and puts them in a box.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装员将商品取走并放入一个箱子中。
- en: Using your name/address, someone else makes a shipping label.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的姓名/地址，其他人制作一个运输标签。
- en: The box is matched with a label, and the package is sent to the post office,
    which takes care of finding your house and delivering the package.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 箱子与标签匹配，包裹被送往邮局，邮局负责找到你的房子并交付包裹。
- en: Figure 20.1\. One possible way to divide the task of ordering an item online
    into smaller, self-contained, and reusable subtasks. Each gray box represents
    a task. Things to the left of the box are the inputs to a task, and things to
    the right are outputs of the task.
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 20.1\. 将在线订购商品的任务划分为更小、自包含和可重用的子任务的一种可能方式。每个灰色框代表一个任务。框左侧是任务的输入，框右侧是任务的输出。
- en: '![](images/20fig01_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/20fig01_alt.jpg)'
- en: '[Figure 20.1](#ch20fig01) shows how to divide the big task of ordering an item
    into five other subtasks. Each subtask might be handled by separate people or
    machines and represent different specialties in the process of ordering an item
    online.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20.1](#ch20fig01) 展示了如何将订购商品的大任务划分为五个其他子任务。每个子任务可能由不同的人或机器处理，并代表在线订购商品过程中的不同专业领域。'
- en: This example also illustrates a few other important ideas. The first idea is
    *task dependence/independence*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还说明了几个其他重要的观点。第一个观点是 *任务依赖/独立性*。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A task depends on another one if it can’t start before the other one completes.
    Two tasks are independent if they can be performed at the same time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个任务在另一个任务完成之前不能开始，那么这个任务就依赖于另一个任务。如果两个任务可以同时执行，那么这两个任务是独立的。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Some tasks depend on the completion of others, whereas some tasks are completely
    independent. You first do the task “extract order details.” You use its output
    to do the “find item in warehouse” and the “make label” tasks. Notice that these
    last two tasks are independent of each other and can be done in any order. The
    task “box them up” depends on the task “find in warehouse.” The “send via mail”
    task depends on both “box them up” and “make label” tasks to be finished before
    it can begin.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些任务依赖于其他任务的完成，而有些任务是完全独立的。你首先执行“提取订单详情”任务。你使用它的输出来做“在仓库中找到商品”和“制作标签”任务。注意，最后这两个任务是相互独立的，可以按任何顺序执行。任务“装箱”依赖于“在仓库中找到商品”任务。任务“通过邮件发送”依赖于“装箱”和“制作标签”任务完成之前才能开始。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 20.1**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.1**'
- en: Are the following actions dependent or independent?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下动作是依赖的还是独立的？
- en: '**[1](kindle_split_056.html#app01qa75q0a1)**'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa75q0a1)**'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (1) Eating pie and (2) writing 3.1415927 on a piece of paper.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (1) 吃派和 (2) 在一张纸上写下 3.1415927。
- en: '**[2](kindle_split_056.html#app01qa75q0a2)**'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa75q0a2)**'
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (1) You don’t have an internet connection and (2) you can’t check your email.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (1) 你没有互联网连接和 (2) 你无法检查你的电子邮件。
- en: '**[3](kindle_split_056.html#app01qa75q0a3)**'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa75q0a3)**'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (1) It’s January 1 and (2) it’s sunny.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (1) 1月1日和 (2) 天气晴朗。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: Abstraction of a task is a way to simplify the task such that you understand
    it by using the least amount of information; you hide all unnecessary details.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任务抽象是一种简化任务的方法，通过使用最少的信息来理解它；你隐藏了所有不必要的细节。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To understand what happens when you order an item online, you don’t need to
    understand every detail behind the scenes. This brings us to the second idea:
    abstraction. In the warehouse example, you don’t need to know the details of how
    to find an item in a warehouse; whether the seller employs a person to get your
    item or whether they use a sophisticated robot doesn’t matter to you. You need
    to know only that you supply it an “item name” and an “item count” and that you
    get back the items requested.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解在线订购商品时会发生什么，你不需要了解幕后每个细节。这引出了第二个观点：抽象。在仓库的例子中，你不需要知道如何在仓库中找到商品的细节；卖家是雇佣人来取你的商品还是使用复杂的机器人对你来说并不重要。你只需要知道你提供“商品名称”和“商品数量”，然后你就能得到请求的商品。
- en: Broadly speaking, to understand a task, you need to know only what input a task
    needs before starting (for example, personal information on a form) and what the
    task will do (for example, items show up at your door). You don’t need to know
    the details of each step in the task to understand what it does.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，要理解一个任务，你只需要在开始之前知道任务需要什么输入（例如，表格上的个人信息）以及任务将做什么（例如，物品出现在你的门口）。你不需要知道任务中每一步的细节来理解它做什么。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 20.2**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.2**'
- en: 'For each of the following, what are possible inputs and outputs (if any)? Ask
    what items you need in order to perform each action and what items you get out
    of doing the action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个任务，可能的输入和输出（如果有）是什么？询问执行每个动作所需的物品以及执行动作后得到的物品：
- en: '**[1](kindle_split_056.html#app01qa76q0a1)**'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa76q0a1)**'
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Writing a wedding invitation
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 写婚礼请柬
- en: '**[2](kindle_split_056.html#app01qa76q0a2)**'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa76q0a2)**'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Making a phone call
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打电话
- en: '**[3](kindle_split_056.html#app01qa76q0a3)**'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa76q0a3)**'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flipping a coin
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 抛硬币
- en: '**[4](kindle_split_056.html#app01qa76q0a4)**'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa76q0a4)**'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Buying a dress
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 买裙子
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The third idea is of *reusable subtasks*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个想法是关于*可重用子任务*。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: Reusable subtasks are tasks whose steps can be reused with different inputs
    to produce different output.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用子任务是那些步骤可以与不同的输入一起重用以产生不同输出的任务。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Sometimes you want to do a task that’s slightly different from another one.
    In the warehouse example, you might want to find a book in the warehouse or you
    might want to find a bicycle. It wouldn’t make sense to have a separate robot
    for every item that you might want to retrieve. That would lead to too many robots
    that kind of do the same thing! It’s better to make one robot that can find any
    item you want. Or to make two robots: one that can retrieve big items and one
    for small items. This trade-off between creating subtasks while making the subtasks
    generic enough to be reusable can be subjective. With a little bit of practice
    in the next few lessons, you’ll get the hang of striking a good balance.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要执行一个与另一个任务略有不同的任务。在仓库的例子中，你可能想要在仓库里找一本书，或者你可能想要找一辆自行车。为每一个你可能想要取回的物品都配备一个单独的机器人是没有意义的！这会导致太多做类似事情的机器人！最好做一个能够找到你想要的任何物品的机器人。或者制作两个机器人：一个用于取回大件物品，另一个用于小件物品。在创建子任务的同时，使子任务足够通用以便可重用之间的权衡可能是主观的。在接下来的几节课中，通过一点练习，你会掌握找到良好平衡的方法。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 20.3**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查20.3**'
- en: '**[Q1:](kindle_split_056.html#app01qa77q0a1)**'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa77q0a1)**'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Divide the following task into smaller subtasks: “Research the history of crayons,
    write a five-page paper, and give a presentation.” Draw diagrams similar to [figure
    20.1](#ch20fig01).'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下任务分解成更小的子任务：“研究蜡笔的历史，写一篇五页的论文，并进行一次演讲。”绘制类似于[图20.1](#ch20fig01)的图表。
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 20.1.2\. Understanding the main points
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.1.2. 理解主要观点
- en: When you deal with tasks, consider each one a *black box*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理任务时，考虑每个任务都是一个*黑盒*。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A black box is a way to visualize a system that does a certain task. A black
    box on top of the system reminds you that you don’t get to (or need to) see inside
    the box in order to understand what the system does.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒是一种可视化执行特定任务系统的方法。系统顶部的黑盒提醒你，你不需要（或不需要）看到盒子内部才能理解系统做什么。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Right now, you don’t need to know how that task is accomplished; you’re only
    trying to visualize your overall system in terms of these smaller tasks without
    getting bogged down in their details.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不需要知道该任务是如何完成的；你只是在尝试从这些较小任务的角度可视化你的整体系统，而不陷入它们的细节。
- en: Take the task “find in warehouse” from [figure 20.1](#ch20fig01) and look at
    [figure 20.2](#ch20fig02) to see one way the task could look under the black box.
    Without a black box, you get more details on how the task is implemented—what
    steps and actions are done using the inputs. But these details don’t help you
    understand the task itself; the details of the task implementation aren’t important
    or necessary to understand what the task does. In some situations, seeing these
    details might even create more confusion. Ultimately, the inputs and outputs to
    the overall system are the same with and without the black box over the system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图20.1](#ch20fig01)中的“在仓库中查找”任务开始，查看[图20.2](#ch20fig02)以了解任务在黑盒下的一个可能外观。没有黑盒，你会得到更多关于任务如何实现的细节——使用输入执行了哪些步骤和动作。但这些细节并不能帮助你理解任务本身；任务实现的细节对于理解任务做什么并不重要或必要。在某些情况下，看到这些细节甚至可能造成更多的困惑。最终，无论是否有黑盒，系统的输入和输出都是相同的。
- en: Figure 20.2\. “Find in warehouse” shown with and without a black box over the
    task. Seeing the details of how the item is found and retrieved in the warehouse
    doesn’t add any more understanding of the task itself.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图20.2. 在任务上方带有和没有黑盒的“在仓库中查找”。看到在仓库中找到和取回物品的细节并不能增加对任务本身的更多理解。
- en: '![](images/20fig02_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](images/20fig02_alt.jpg)'
- en: Each task is a sequence of actions or steps. These steps should be generic enough
    that they can be repeated for any appropriate inputs. How do you determine what’s
    an appropriate input? You need to document your black boxes so that whoever wants
    to use them knows exactly what’s expected of them in terms of inputs to supply
    and outputs they’ll get back.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都是一个动作或步骤的序列。这些步骤应该足够通用，以便可以针对任何适当的输入重复使用。你如何确定什么是一个适当的输入？你需要记录你的黑盒，以便任何想要使用它们的人都知道他们需要提供什么输入以及他们将会得到什么输出。
- en: 20.2\. Introducing black boxes of code in programming
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2\. 在编程中引入代码黑盒
- en: The programs you’ve seen so far have been simple enough that the entire program
    is a black box. The tasks you’ve been given aren’t complex enough to warrant having
    specialized pieces of code to do different tasks; your entire programs have been
    pieces of code to each do one task.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到的程序足够简单，整个程序就是一个黑盒。你被分配的任务并不复杂，不需要有专门用于不同任务的代码片段；你的整个程序都是代码片段，每个都执行一个任务。
- en: 'Your programs so far have mostly done the following: (1) ask the user for input,
    (2) do some operations, and (3) show some output. From now on, you’ll find it
    helpful and necessary to divide the program into smaller and more manageable pieces.
    Each piece will solve part of the puzzle. You can put all the pieces together
    to implement a larger program.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的程序主要做了以下事情：（1）向用户请求输入，（2）执行一些操作，以及（3）显示一些输出。从现在开始，你会发现将程序分解成更小、更易于管理的部分是很有帮助且必要的。每个部分将解决一部分谜题。你可以将这些部分组合起来实现一个更大的程序。
- en: In programming, these tasks are considered black boxes of code. You don’t need
    to know how each block of code works. You only need to know what inputs go into
    the box, what the box is supposed to do, and what output the box gives you. You’re
    abstracting the programming task to these three pieces of information. Each black
    box becomes a *module* of code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，这些任务被认为是代码的黑盒。你不需要知道每个代码块是如何工作的。你只需要知道输入到盒子的内容，盒子应该做什么，以及盒子给出的输出。你正在将编程任务抽象为这三部分信息。每个黑盒变成一个
    *模块* 代码。
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A code module is a piece of code that achieves a certain task. A module is associated
    with input, a task, and output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码模块是一段实现特定任务的代码。模块与输入、任务和输出相关联。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 20.2.1\. Using code modules
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.1\. 使用代码模块
- en: '*Modularity* is the division of a big program into smaller tasks. You write
    code for each task separately, independent of other tasks. In general, each code
    module is supposed to stand on its own. You should be able to quickly test whether
    the code that you wrote for this module works. Dividing a larger task in this
    way makes the larger problem seem easier and will reduce the time it takes you
    to debug.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块化* 是将一个大程序分解成更小的任务。你为每个任务单独编写代码，独立于其他任务。一般来说，每个代码模块应该能够独立存在。你应该能够快速测试你为这个模块编写的代码是否工作。以这种方式将更大的任务分解会使更大的问题看起来更容易，并将减少你调试所需的时间。'
- en: 20.2.2\. Abstracting code
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.2\. 抽象代码
- en: You likely watch TV and use a remote to change the channel. If I gave you all
    the parts necessary to build a TV and a remote, would you know how to put them
    together? Probably not. But if I assembled the TV and the remote for you, would
    you know how to use the two to achieve a task such as changing the channel? Probably.
    This is because you know the inputs of each item, what each item is supposed to
    do, and what each item outputs. [Figure 20.3](#ch20fig03) and [table 20.1](#ch20table01)
    show inputs, behavior, and output for the process of using a remote with a TV.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看过电视并使用遥控器来换频道。如果我把组装电视和遥控器所需的所有部件都给你，你会知道如何把它们组装起来吗？可能不会。但如果我们为你组装了电视和遥控器，你会知道如何使用这两个设备来完成像换频道这样的任务吗？可能会的。这是因为你知道每个项目的输入，每个项目应该做什么，以及每个项目输出什么。[图20.3](#ch20fig03)
    和 [表20.1](#ch20table01) 展示了使用电视遥控器的输入、行为和输出。
- en: Figure 20.3\. Black box view of a remote and a TV
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图20.3\. 遥控器和电视的黑盒视图
- en: '![](images/20fig03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](images/20fig03.jpg)'
- en: Table 20.1\. Input, behavior, and output of a TV and remote for changing the
    channel or the volume
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表20.1\. 电视和遥控器用于更改频道或音量的输入、行为和输出
- en: '| Item | Input | Behavior | Output |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 输入 | 行为 | 输出 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Remote | Push a button | Generates a signal depending on the button pressed
    | A wireless signal |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 遥控器 | 按下按钮 | 根据按下的按钮生成信号 | 无线信号 |'
- en: '| TV | A wireless signal from a remote | Image on the screen changes (whole
    image or a volume bar appears) or volume changes | What you see or hear changes
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| TV | 来自遥控器的无线信号 | 屏幕上的图像改变（整个图像或出现音量条）或音量改变 | 你看到或听到的内容改变 |'
- en: 'In programming, abstraction aims to present ideas at a *high level*. It’s the
    process of documenting what a piece of code does, with three key bits of information:
    inputs, the task, and outputs. You’ve seen black boxes represented using this
    information.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，抽象的目标是**在高级别**呈现想法。这是记录一段代码执行过程的过程，包含三个关键信息点：输入、任务和输出。你已经看到了如何使用这些信息来表示黑盒。
- en: 'Abstraction in code eliminates the details of how the code for a task/module
    is implemented; instead of looking at the code for a module, you look at its documentation.
    To document the module, you use a special type of code comment, called a *docstring*.
    A docstring contains the following information:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的抽象消除了任务/模块代码实现细节；你不再查看模块的代码，而是查看它的文档。为了记录模块，你使用一种特殊的代码注释，称为*docstring*。docstring包含以下信息：
- en: '*All inputs to the module*—Represented by variables and their types.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块的所有输入*—由变量及其类型表示。'
- en: '*What the module is supposed to do*—Its function.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块应该做什么*—它的功能。'
- en: '*What output the module gives you*—This might be an object (variable) or it
    might be something that the module prints.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块给出的输出是什么*—这可能是一个对象（变量）或者模块打印的内容。'
- en: You’ll see examples of code and docstrings in the next lesson.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一课中看到代码和docstring的示例。
- en: 20.2.3\. Reusing code
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.3\. 代码重用
- en: 'Suppose someone gives you two numbers, and you want to be able to do four operations
    on the numbers: add, subtract, multiply, and divide. The code might look like
    the following listing.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有人给你两个数字，你想要能够对这两个数字执行四种操作：加、减、乘和除。代码可能看起来像以下列表。
- en: Listing 20.1\. Code to add, subtract, multiply, and divide two numbers
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.1\. 添加、减法、乘法和除法两个数字的代码
- en: '[PRE0]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Variables a and b are used to do a + b, a - b, a * b, and a / b.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 变量a和b用于执行a + b, a - b, a * b和a / b操作。**'
- en: In addition to this code, you also want to add, subtract, multiply, and divide
    a different pair of numbers. Then yet another pair of numbers. To write a program
    that does the same four operations on many pairs of numbers, you’d have to copy
    and paste the code in [listing 20.1](#ch20ex01) and change the values of `a` and
    `b` a bunch of times. That sounds tedious, and looks ugly, as you can see in the
    following listing! Notice that the code to do the operations themselves is the
    same no matter what variables `a` and `b` are.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码，你还想对另一对数字进行加、减、乘和除操作。然后是另一对数字。要编写一个程序对多对数字执行相同的四种操作，你必须复制粘贴[列表20.1](#ch20ex01)中的代码，并多次更改`a`和`b`的值。这听起来很繁琐，看起来也很丑，就像以下列表所示！请注意，无论变量`a`和`b`是什么，执行操作的代码都是相同的。
- en: Listing 20.2\. Code to add, subtract, multiply, and divide for three pairs of
    numbers
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.2\. 对三对数字进行加、减、乘和除的代码
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Code to do operations on a = 1 and b = 2**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对a = 1和b = 2执行操作的代码**'
- en: '***2* Code to do operations on a = 3 and b = 4**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对a = 3和b = 4执行操作的代码**'
- en: '***3* Code to do operations on a = 5 and b = 6**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对a = 5和b = 6执行操作的代码**'
- en: This is where the idea of reusability comes into play. The part where you do
    operations and print the results of the operations is common across any pairs
    of numbers `a` and `b`. It doesn’t make sense to copy and paste it every time.
    Instead, think of this common set of operations as a black box; the inputs to
    this black box change (as does the output). [Figure 20.4](#ch20fig04) shows a
    black-box view of a task that can do four simple mathematical operations on any
    two numbers, `a` and `b`, where `a` and `b` are now inputs to the black box.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是重用性概念发挥作用的地方。你执行操作并打印操作结果的部分在任意一对数字`a`和`b`之间是通用的。每次都复制粘贴它没有意义。相反，将这个通用的操作集视为一个黑盒；这个黑盒的输入（以及输出）会变化。[图20.4](#ch20fig04)展示了可以执行任何两个数字`a`和`b`（其中`a`和`b`现在是黑盒的输入）的四种简单数学操作的任务的黑盒视图。
- en: Figure 20.4\. Black-box view of code that adds, subtracts, multiplies, and divides
    any two numbers
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图20.4\. 执行任何两个数字加、减、乘和除操作的代码的黑盒视图
- en: '![](images/20fig04.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](images/20fig04.jpg)'
- en: Now, instead of copying and pasting code in a program and changing a small part
    of it, you can write a black box around the code, which is reusable. The box is
    a *code wrapper* that adds a piece of functionality to the program. You can write
    programs that are more complex by reusing wrappers you already wrote. The code
    in [listing 20.2](#ch20ex02) can be abstracted away using the black-box concept
    to become something like the following. Variables `a` and `b` still change, but
    now you’re using code wrapped up in a black box. The four lines of code to do
    the four mathematical operations are simplified as one bundle under a black box.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不再需要在程序中复制粘贴代码并更改其中的一小部分，你可以在代码周围写一个黑色盒子，它是可重用的。这个盒子是一个 *代码包装器*，它给程序添加了一部分功能。你可以通过重用已经写好的包装器来编写更复杂的程序。在[列表20.2](#ch20ex02)中的代码可以使用黑色盒子的概念进行抽象，变成以下样子。变量
    `a` 和 `b` 仍然会改变，但现在你正在使用包裹在黑色盒子中的代码。执行四个数学运算的四个代码行被简化为一个黑色盒子下的一个捆绑包。
- en: Listing 20.3\. Code to add, subtract, multiply, and divide for three pairs of
    numbers
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.3\. 为三对数字添加、减去、乘法和除法的代码
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* (Not actual code) placeholder for a black box that does four operations**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* (非实际代码) 用于表示执行四个操作的黑色盒子的占位符**'
- en: In the next lesson, you’ll see the details on how to write the wrappers for
    the black boxes around code. You’ll also see how to use these wrappers in your
    program. These wrappers are called functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，你将看到如何编写围绕代码的黑色盒子的包装器的详细内容。你还将看到如何在你的程序中使用这些包装器。这些包装器被称为函数。
- en: 20.3\. Subtasks exist in their own environments
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3\. 子任务存在于它们自己的环境中
- en: Think about doing a group project with two other people; you must research the
    history of telephones and give a presentation. You’re the leader. Your job is
    to assign tasks to the other two people and to give the final presentation. As
    the leader, you don’t have to do any research. Instead, you call upon the two
    other group members to do research, and they relay their results to you.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下和另外两个人一起做一个小组项目；你必须研究电话的历史并做一个展示。你是领导者。你的工作是分配任务给其他两个人，并做最后的展示。作为领导者，你不需要做任何研究。相反，你召唤其他两个小组成员进行研究，然后他们把他们的结果传达给你。
- en: The other two people are like smaller worker modules helping you with the project.
    They’re in charge of doing the research, coming up with results, and giving you
    a summary of their findings. This demonstrates the idea of *dividing a larger
    task into subtasks*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个人就像较小的工人模块，帮助你完成项目。他们负责进行研究，得出结果，并给你提供他们发现总结。这展示了将更大的任务分解为子任务的概念 *。
- en: Notice that you, as the leader, aren’t concerned with the details of their research.
    You don’t care whether they use the internet, go to the library, or interview
    a random group of people. You just want them to tell you their findings. The summary
    they give you demonstrates the idea of *abstraction of details*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作为领导者，你并不关心他们研究的细节。你不在乎他们是否使用互联网，去图书馆，或者采访一个随机的人群。你只想让他们告诉你他们的发现。他们给你的总结展示了
    *抽象细节* 的概念。
- en: Each person doing the research might use an item that has the same name. One
    might read a children’s picture book named *Telephone* and one might read a reference
    book named *Telephone*. Unless these two people pass a book to each other or communicate
    with each other, they have no idea what information the other is gathering. Each
    researcher is in their own environment, and any information they gather stays
    only with them—unless they share it. You can think of a code module as a mini-program
    to achieve a certain task. Each module exists in its own environment, independent
    from the environment of other modules. Any item created inside the module is specific
    to the module, unless explicitly passed on to another module. Modules can pass
    items through output and input. You’ll see many examples of how this looks in
    code in the next lesson.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进行研究的人可能会使用具有相同名称的物品。一个人可能读一本名为 *电话* 的儿童图画书，另一个人可能读一本名为 *电话* 的参考书。除非这两个人互相传递书籍或进行沟通，否则他们不知道对方收集了什么信息。每个研究人员都在他们自己的环境中，他们收集的任何信息都只属于他们——除非他们分享。你可以把代码模块想象成一个用于完成特定任务的微型程序。每个模块存在于它们自己的环境中，独立于其他模块的环境。模块内部创建的任何物品都是特定于该模块的，除非明确传递给另一个模块。模块可以通过输出和输入传递物品。你将在下一课中看到许多代码中这种外观的例子。
- en: In the group project example, the group project is like the main program. Each
    person is like a separate module, each in charge of doing a task. Some tasks may
    communicate with each other, and some may not. For larger group projects, some
    people in the group might not need to share information with others if they’re
    in charge of independent pieces. But all group members communicate with the leader
    to relay information gathered.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队项目示例中，团队项目就像主程序。每个人就像一个独立的模块，负责执行一项任务。有些任务可能相互通信，而有些则可能不通信。对于更大的团队项目，如果负责独立部分的人不需要与其他人共享信息，那么团队中的一些人可能不需要与其他人共享信息。但所有团队成员都与领导者沟通，以传达收集到的信息。
- en: Each person does the research in a separate environment. They might use different
    objects or methods to do the research, each being useful only in the environment
    of that one person. The leader doesn’t need to know the details of how the research
    takes place.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都在一个独立的环境中进行研究。他们可能会使用不同的对象或方法进行研究，每种方法只对一个人的环境有用。领导者不需要知道研究进行的细节。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 20.4**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.4**'
- en: '**[Q1:](kindle_split_056.html#app01qa78q0a1)**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa78q0a1)**'
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw a black-box system for the task of researching the telephone in a group
    project setting described in this section. Draw a black box for each person and
    indicate what each person may take as input and may output.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本节描述的团队项目中，为研究电话的任务绘制一个黑盒系统。为每个人绘制一个黑盒，并指出每个人可能作为输入和可能输出的内容。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you why it’s important to view tasks
    as black boxes and, ultimately, as code modules. You saw that different modules
    can work together to pass information to each other to achieve a larger goal.
    Each module lives in its own environment, and any information it creates is private
    to that module, unless explicitly passed around through outputs. In the bigger
    picture, you don’t need to know the details of how modules accomplish their specific
    tasks. Here are the major takeaways:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你为什么将任务视为黑盒，最终视为代码模块很重要。你看到了不同的模块可以协同工作，相互传递信息以实现更大的目标。每个模块都生活在自己的环境中，它创建的任何信息都是私有的，除非明确通过输出传递。从更大的角度来看，你不需要知道模块完成其特定任务的细节。以下是主要收获：
- en: Modules are independent and in their own self-contained environments.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是独立的，并且在其自身的自包含环境中。
- en: Code modules should be written only once and be reusable with different inputs.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码模块应该只编写一次，并且可以用不同的输入进行重用。
- en: Abstracting away module details allows you to focus on the way many modules
    work together to accomplish a larger task.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象掉模块的细节，让你能够专注于许多模块如何协同工作以完成更大的任务。
- en: Let’s see if you got this...
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: '**[Q20.1](kindle_split_056.html#app01qa79q0a1)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q20.1](kindle_split_056.html#app01qa79q0a1)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Divide the following task into smaller subtasks: “A couple orders at a restaurant
    and gets drinks and food.” Draw a diagram.'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下任务划分为更小的子任务：“在餐厅点了几份订单并获得了饮料和食物。”绘制一个图表。
