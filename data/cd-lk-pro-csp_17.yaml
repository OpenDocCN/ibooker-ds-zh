- en: 12 Using IAsyncEnumerable<T> and yield return
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 使用IAsyncEnumerable<T>和yield return
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the generic `Queue` data structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用的`Queue`数据结构
- en: Using `yield return` and `IAsyncEnumerable<T>`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`yield return`和`IAsyncEnumerable<T>`
- en: Creating views
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视图
- en: Using private getters and setters with auto-properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有自动属性的私有获取器和设置器
- en: How structs differ from classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体与类有何不同
- en: Using `checked` and `unchecked` keywords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`checked`和`unchecked`关键字
- en: In the previous chapters, we examined the codebase we inherited and noted where
    we could make improvements. Then, we partially implemented our version of the
    codebase, adhering to FlyTomorrow’s OpenAPI specification. In chapters 10 and
    11, we implemented the `BookingService` class and decided that there was no need
    for a `CustomerService` class. Figure 12.1 shows where we are in the scheme of
    the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们检查了我们继承的代码库，并记录了我们可以进行改进的地方。然后，我们部分实现了我们版本的代码库，遵循FlyTomorrow的OpenAPI规范。在第10章和第11章中，我们实现了`BookingService`类，并决定不需要`CustomerService`类。图12.1显示了我们在本书结构中的位置。
- en: '![](../Images/12_01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_01.png)'
- en: Figure 12.1 In this chapter, we wrap up the services layer by implementing the
    `AirportService` and `FlightService` classes. By implementing those classes, we
    finish the service layer rewrite of the Flying Dutchman Airlines service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 在本章中，我们通过实现`AirportService`和`FlightService`类来封装服务层。通过实现这些类，我们完成了飞荷兰人航空公司服务层的重写。
- en: 'If we look at which classes we need to implement to complete our service layer,
    an encouraging picture follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看我们需要实现哪些类来完成我们的服务层，一个鼓舞人心的画面随之而来：
- en: '`CustomerService` (chapter 10)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerService` (第10章)'
- en: '`BookingService` (chapters 10 and 11)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookingService` (第10章和第11章)'
- en: '`AirportService` (this chapter)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AirportService` (本章)'
- en: '`FlightService` (this chapter)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlightService` (本章)'
- en: 'We are halfway done with the service layer classes. In this chapter, we’ll
    wrap up the service layer implementation by writing code for the `AirportService`
    and `FlightService` classes. After this chapter, we are in an excellent spot to
    move on to our last architectural layer: the controller layer.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了服务层类的一半。在本章中，我们将通过编写`AirportService`和`FlightService`类的代码来封装服务层的实现。在本章之后，我们将处于一个极佳的位置，可以继续到最后一个架构层：控制器层。
- en: 12.1 Do we need an AirportService class?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 我们是否需要AirportService类？
- en: In section 10.2, we determined that if a service class would never get called
    by a controller class, we do not need to implement the service class. We also
    saw that you can determine whether you need a particular controller by checking
    the controller’s model name against the OpenAPI specification. If there is no
    need for a controller, there is no need for a service class. As humans, being
    creatures of habit, let’s repeat that process for the `AirportService` class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.2节中，我们确定如果一个服务类永远不会被控制器类调用，我们不需要实现服务类。我们还看到，你可以通过将控制器模型名称与OpenAPI规范进行比较来确定是否需要特定的控制器。如果没有控制器需求，就没有必要实现服务类。作为习惯性生物，让我们为`AirportService`类重复这个过程。
- en: 'The OpenAPI specification (as shown in figure 12.2) tells us we need to implement
    the following three endpoints:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范（如图12.2所示）告诉我们我们需要实现以下三个端点：
- en: '`GET /Flight`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight`'
- en: '`GET /Flight/{FlightNumber}`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight/{FlightNumber}`'
- en: '`POST /Booking/{FlightNumber}`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /Booking/{FlightNumber}`'
- en: '![](../Images/12_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_02.png)'
- en: 'Figure 12.2 The OpenAPI specification from FlyTomorrow. We need to implement
    three endpoints: two `GET`s and one `POST`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 FlyTomorrow的OpenAPI规范。我们需要实现三个端点：两个`GET`和一个`POST`。
- en: 'Do any of those endpoints have a controller related to the `Airport` model
    in their path? As shown in figure 12.3, I see two `Flight` controllers and one
    `Booking` controller, but no endpoints requiring an `Airport` controller. Well,
    that settles it then: we do not need to implement an `AirportService` class.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点中有哪些与`Airport`模型相关的控制器？如图12.3所示，我看到两个`Flight`控制器和一个`Booking`控制器，但没有需要`Airport`控制器的端点。那么，事情就这样定了：我们不需要实现`AirportService`类。
- en: '![](../Images/12_03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_03.png)'
- en: Figure 12.3 The Airport table has two incoming foreign key constraints. Both
    come from the Flight table and retrieve `Airport.AirportID`. These foreign key
    constraints can be used to retrieve information on a particular `Airport`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 机场表有两个外键约束。这两个都来自航班表，检索`Airport.AirportID`。这些外键约束可以用来检索特定`Airport`的信息。
- en: 'On the other hand, we do have a use case to keep the `AirportRepository` class.
    If we look at the database schema of our deployed database, we see that the Airport
    table has the following two incoming foreign key constraints:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们确实有一个用例需要保留`AirportRepository`类。如果我们查看已部署数据库的数据库模式，我们会看到机场表有以下两个外键约束：
- en: '`Flight.Origin` to `Airport.AirportID`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flight.Origin` 对 `Airport.AirportID`'
- en: '`Flight.Destination` to `Airport.AirportID`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flight.Destination` 对 `Airport.AirportID`'
- en: In section 12.2, we’ll dive deeper into those foreign key constraints and implement
    them. From our experiences in chapter 11, we know that we need to use the receiving
    table’s repository to trace down these foreign key constraints.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在12.2节中，我们将更深入地探讨这些外键约束并实现它们。从第11章的经验中，我们知道我们需要使用接收表的重构库来追踪这些外键约束。
- en: 12.2 Implementing the FlightService class
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 实现FlightService类
- en: 'So far, we implemented the `BookingService` and decided not to implement services
    for the `Airport` and `Customer` entities. In this section, we’ll finish the service
    layer by implementing the `FlightService` class. As with the prior sections, let’s
    ask ourselves, do we need to implement this class? We have two endpoints that
    require a `Flight` controller. Both the `GET /Flight` and the `GET /Flight/{FlightNumber}`
    endpoints make their requests against a `Flight` controller. Perfect—that means
    we need to implement a `FlightService` class. Both endpoints return data that
    already exists in the database and are fairly simple in their complexity. Let’s
    begin with the first: `GET /Flight.`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了`BookingService`并决定不实现`Airport`和`Customer`实体服务。在本节中，我们将通过实现`FlightService`类来完成服务层的实现。与前面的章节一样，让我们问问自己，我们需要实现这个类吗？我们有两个端点需要一个`Flight`控制器。`GET
    /Flight`和`GET /Flight/{FlightNumber}`端点都向`Flight`控制器发出请求。太好了——这意味着我们需要实现一个`FlightService`类。这两个端点返回的数据已经在数据库中，并且它们的复杂性相对简单。让我们从第一个开始：`GET
    /Flight.`。
- en: 12.2.1 Getting information on a specific flight from the FlightRepository
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 从FlightRepository获取特定航班的详细信息
- en: In this section, we’ll implement the `GET /Flight` endpoint as discussed in
    section 12.1\. FlyTomorrow uses the `GET /Flight` endpoint to query our service
    for all available flights. We don’t need to take into account (or validate) any
    special input parameters, but we have some foreign key restrictions to track down.
    We’ll also create a `View` class for `Flight` so we can return a combination of
    data stemming from the `Flight` and `Airport` tables.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现12.1节中讨论的`GET /Flight`端点。FlyTomorrow使用`GET /Flight`端点来查询我们的服务以获取所有可用的航班。我们不需要考虑（或验证）任何特殊输入参数，但我们有一些外键限制需要追踪。我们还将为`Flight`创建一个`View`类，这样我们就可以返回来自`Flight`和`Airport`表的组合数据。
- en: 'But first, the starting point of all our endeavors: we need to create skeleton
    classes for both the `FlightService` and `FlightServiceTests` classes, as shown
    in figure 12.4\. You know what to do.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们所有努力的起点：我们需要为`FlightService`和`FlightServiceTests`类创建骨架类，如图12.4所示。你知道该怎么做。
- en: '![](../Images/12_04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4](../Images/12_04.png)'
- en: 'Figure 12.4 To start the implementation of the `FlightService`, create two
    skeleton classes: `FlightService` and `FlightServiceTests`. These classes form
    the basis of our `FlightService` and `FlightServiceTests` implementations.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 要开始实现`FlightService`，创建两个骨架类：`FlightService`和`FlightServiceTests`。这些类构成了我们`FlightService`和`FlightServiceTests`实现的基础。
- en: Now that we have the required classes in our projects, we can think about the
    things we need our method to do. Our method—let’s call it `GetFlights`—has to
    return data on every flight in the database. To do this, we should use an injected
    instance of the `FlightRepository` class. The `FlightRepository` class does not
    have a method to return all flights from the database, however, so we need to
    add that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在项目中有了所需的类，我们可以考虑我们的方法需要做什么。我们的方法——让我们称它为`GetFlights`——必须返回数据库中每个航班的详细信息。为此，我们应该使用`FlightRepository`类的注入实例。然而，`FlightRepository`类没有返回数据库中所有航班的函数，因此我们需要添加这个功能。
- en: 'In `FlightRepository`, let’s add a virtual method called `GetFlights`. We don’t
    need to make the method asynchronous, because we do not query the actual database
    for the required information. Even though we want to get all the data from a specific
    table in the database, remember that Entity Framework Core stores a lot of metadata
    in memory. This brings us to one of the drawbacks of using an ORM: performance
    at scale. If you have a database that contains millions of records, Entity Framework
    Core still stores a lot of data locally. On the flip side, it means that we can
    query Entity Framework Core’s internal `DbSet<Flight>` and see all flights currently
    in the database.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FlightRepository` 中，让我们添加一个名为 `GetFlights` 的虚拟方法。我们不需要使该方法异步，因为我们不需要查询实际数据库以获取所需信息。即使我们想要从数据库中的特定表中获取所有数据，请记住，Entity
    Framework Core 在内存中存储了大量的元数据。这让我们想到了使用 ORM 的一个缺点：在规模上的性能。如果你有一个包含数百万条记录的数据库，Entity
    Framework Core 仍然会在本地存储大量数据。另一方面，这也意味着我们可以查询 Entity Framework Core 的内部 `DbSet<Flight>`
    并查看当前数据库中的所有航班。
- en: The `GetFlights` method should return a collection of `Flight`, but which collection
    to use? We don’t need to access elements by some kind of key or index, so an `Array`,
    `Dictionary`, or `List` is unnecessary. Perhaps a simple `Queue<Flight>` would
    suffice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlights` 方法应该返回一个 `Flight` 集合，但应该使用哪个集合呢？我们不需要通过某种键或索引访问元素，所以 `Array`、`Dictionary`
    或 `List` 都是不必要的。也许一个简单的 `Queue<Flight>` 就足够了。'
- en: A queue is a “first-in, first-out” (often abbreviated to FIFO) data structure.
    The first element to enter the queue is the first to come out, as shown in as
    shown in listing 12.1\. Having a FIFO structure is helpful in our case because
    we can ensure we have an isomorphic relationship between how we represent the
    flights in our data structure and how they are represented in the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种“先进先出”的数据结构（通常缩写为 FIFO）。首先进入队列的元素是第一个出来的，如图 12.1 所示。在我们的情况下，有一个 FIFO 结构是有帮助的，因为我们能确保我们在数据结构中表示航班的方式与数据库中表示的方式之间有一个同构关系。
- en: Listing 12.1 `FlightRepository.GetFlights`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1 `FlightRepository.GetFlights`
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates a queue to store flights
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个队列来存储航班
- en: ❷ Adds every flight to the queue (in order)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个航班按顺序添加到队列中
- en: ❸ Returns the queue
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回队列
- en: '| ![](../Images/LightBulb.png)   | EF Core FOREACH An alternative implementation
    to a `foreach` loop when dealing with an Entity Framework Core `DbSet<T>` collection
    is to use EF Core’s `ForEachAsync` method: `_context.Flight.ForEachAsync(f =>
    flights .Enqueue(f));`. Depending on your readability preferences and asynchronous
    needs, this may be a good option for you. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | EF Core FOREACH 当处理 Entity Framework Core
    `DbSet<T>` 集合时，`foreach` 循环的一个替代实现是使用 EF Core 的 `ForEachAsync` 方法：`_context.Flight.ForEachAsync(f
    => flights.Enqueue(f));`。根据你的可读性偏好和异步需求，这可能是一个不错的选择。'
- en: That’s all for the `FlightRepository.GetFlights` method, but we need unit tests
    to back this up. I’ll walk you through the success case unit test, but I want
    you to think about some potential failure cases and write tests for them. If you
    find that you want to change the `FlightRepository.GetFlights` method for any
    reason, please do so!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `FlightRepository.GetFlights` 方法，这就是全部内容，但我们还需要单元测试来支持它。我将向您介绍成功案例的单元测试，但我希望您考虑一些潜在的失败情况并编写针对它们的测试。如果您发现出于任何原因需要更改
    `FlightRepository.GetFlights` 方法，请这样做！
- en: 'If we look at the existing `FlightRepositoryTest` class’s `TestInitialize`
    method, we see that only one flight is added to the in-memory database before
    each test. In an ideal world, we would like to have at least two flights in the
    in-memory database so we can assert against the order in the returned `Queue<Flight>`
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看现有的 `FlightRepositoryTest` 类的 `TestInitialize` 方法，我们会看到在每次测试之前只向内存数据库中添加了一个航班。在一个理想的世界里，我们希望内存数据库中至少有两个航班，这样我们就可以断言返回的
    `Queue<Flight>` 中的顺序，如下所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| ![](../Images/LightBulb.png)   | YIELD RETURN keywords If you are okay with
    using a generic class instead of a concrete collection type such as `Queue`, `List`,
    or `Dictionary`, a neat concept to use is the `yield return` keywords. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | YIELD RETURN 关键字 如果你愿意使用泛型类而不是 `Queue`、`List`
    或 `Dictionary` 这样的具体集合类型，一个整洁的概念是使用 `yield return` 关键字。'
- en: When dealing with collections that implement the `IEnumerable<T>` interface,
    we can return the `IEnumerable<T>` type and not have to declare an actual collection
    inside a method. That may sound a bit confusing, so let me show you in the next
    code sample what the code in listing 12.1 looks like if we were to use this approach.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理实现`IEnumerable<T>`接口的集合时，我们可以返回`IEnumerable<T>`类型，而不需要在方法内部声明一个实际的集合。这听起来可能有些令人困惑，所以让我在下一个代码示例中展示如果使用这种方法，列表12.1中的代码会是什么样子。
- en: Listing 12.2 Using `yield` `return` and `IEnumerable<Flight>`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2 使用`yield` `return`和`IEnumerable<Flight>`
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code in listing 12.2 does not explicitly declare a collection in which to
    store the `Flight` objects. Instead, by using the `yield return` keywords, we
    abstract away the collection initialization and let the compiler do its magic.
    (This is a simple example, and the code in listing 12.2 could also simply return
    the existing `_context.Flight` collection in this case.) This compiler magic consists
    of the compiler generating a class implementing the `IEnumerable` interface under
    the hood and returning that. The syntax suggests we are using the `IEnumerable`
    interface directly, but in fact, you are using the compiler-generated wrapper
    class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2中的代码没有明确声明一个用于存储`Flight`对象的集合。相反，通过使用`yield return`关键字，我们抽象掉了集合的初始化，让编译器发挥其魔力。（这是一个简单的例子，列表12.2中的代码在这种情况下也可以简单地返回现有的`_context.Flight`集合。）这种编译器魔力包括编译器在幕后生成一个实现`IEnumerable`接口的类，并返回该类。语法暗示我们直接使用了`IEnumerable`接口，但实际上，我们使用的是编译器生成的包装类。
- en: You will also sometimes hear about the `yield return` keyword within the context
    of lazy evaluation. Lazy evaluation means that we delay all processing/iterating
    until it is absolutely necessary. The opposite of this is greedy evaluation, which
    does all processing up front and then lets us iterate over the results once it
    has all the information. By using the `yield return` keyword, we can come up with
    lazy logic that doesn’t operate on the returned results until they are returned.
    This is explained further in the discussion on `IAsyncEnumerable<T>` later in
    this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时也会在延迟评估的上下文中听到`yield return`关键字。延迟评估意味着我们推迟所有处理/迭代，直到绝对必要。这与贪婪评估相反，贪婪评估在所有处理都完成并获取所有信息后，让我们迭代结果。通过使用`yield
    return`关键字，我们可以提出一种延迟逻辑，它不会在返回结果之前对它们进行操作。这将在本节稍后的`IAsyncEnumerable<T>`讨论中进一步解释。
- en: 'Now that we can get a queue of all the flights in the database by calling the
    `FlightRepository.GetFlights` method, we can start to assemble the view we want
    to return to the controller. By default, the `Flight` object has three properties:
    `FlightNumber`, `OriginID`, and `DestinationID`. This information is crucial to
    the customer, so we want to return it. However, simply returning IDs for the origin
    and destination airports is not very useful. If we look at the database schema,
    we see that we can use foreign keys to get more information about the origin and
    destination airports.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用`FlightRepository.GetFlights`方法来获取数据库中所有航班的队列，然后我们可以开始组装要返回给控制器的视图。默认情况下，`Flight`对象有三个属性：`FlightNumber`、`OriginID`和`DestinationID`。这些信息对客户至关重要，因此我们希望返回它们。然而，仅仅返回起点和目的地的机场ID并不很有用。如果我们查看数据库模式，我们会发现我们可以使用外键来获取更多关于起点和目的地机场的信息。
- en: 'The `Flight` table has the following two outgoing foreign key constraints,
    as shown in figure 12.5:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如图12.5所示，`Flight`表有以下两个外键约束：
- en: '`Flight.Origin` to `Airport.AirportID`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Flight.Origin`映射到`Airport.AirportID`
- en: '`Flight.Destination` to `Airport.AirportID`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Flight.Destination`映射到`Airport.AirportID`
- en: '![](../Images/12_05.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12_05.png)'
- en: Figure 12.5 The Flight table has two outgoing foreign key constraints. This
    figure does not show any other foreign key constraints (inbound or outbound).
    We’ll use these foreign key constraints to create a view in section 12.2.2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 航班表有两个外键约束。此图未显示任何其他外键约束（入站或出站）。我们将在12.2.2节中使用这些外键约束来创建视图。
- en: 'If we were to trace down those foreign key constraints, we could get `Airport`
    information based on their IDs. The `AirportRepository` class has the following
    method that can help us here: `GetAirportByID`. The `GetAirportByID` method accepts
    an airport ID and returns the appropriate airport (if found in the database).
    We know that the `Airport` model has a property for its city name, so we can return
    the origin and destination city names along with the flight number to the controller.
    This amalgamation of two data sources forms the thinking behind our yet-to-be-created
    `FlightView` class.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们追踪那些外键约束，我们可以根据它们的ID获取`Airport`信息。`AirportRepository`类有以下方法可以帮助我们：`GetAirportByID`。`GetAirportByID`方法接受一个机场ID，并返回相应的机场（如果数据库中存在）。我们知道`Airport`模型有一个城市名称属性，因此我们可以将出发地和目的地城市名称以及航班号一起返回给控制器。这种将两个数据源合并的思考方式是我们尚未创建的`FlightView`类背后的理念。
- en: 12.2.2 Combining two data streams into a view
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 将两个数据流合并到视图中
- en: In section 10.1.1, we discussed views. We talked about how a view can give us
    a window into a model and combine data from various data sources. In this section,
    we’ll create the `FlightView` class and populate it with data from both the `Flight`
    model and the `Airport` model.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在10.1.1节中，我们讨论了视图。我们讨论了视图如何为我们提供一个窗口来查看模型，并从各种数据源中组合数据。在本节中，我们将创建`FlightView`类，并用来自`Flight`模型和`Airport`模型的数据填充它。
- en: 'We can easily create the `FlightView` class. It is a public class with the
    following three public properties:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地创建`FlightView`类。它是一个公共类，具有以下三个公共属性：
- en: '`FlightNumber` of type `string`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlightNumber`的类型为`string`'
- en: An `Airport` object containing `OriginCity` (type `string`) and `Code` (type
    `string`)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`OriginCity`（类型`string`）和`Code`（类型`string`）的`Airport`对象
- en: An `Airport` object containing `DestinationCity` (type `string``)` and `Code`
    (type `string`)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`DestinationCity`（类型`string`）和`Code`（类型`string`）的`Airport`对象
- en: The data for `FlightNumber` comes from the `Flight` model, whereas the data
    for the `Airport` object and the `OriginCity` and `DestinationCity` properties
    comes from the `Airport` model, as shown in figure 12.6\. This information (for
    every flight in the database) is the data we ultimately return to FlyTomorrow
    when they query the `GET /Flight` endpoint.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightNumber`的数据来自`Flight`模型，而`Airport`对象以及`OriginCity`和`DestinationCity`属性的数据来自`Airport`模型，如图12.6所示。这些信息（对于数据库中的每架航班）是我们最终返回给FlyTomorrow在查询`GET
    /Flight`端点时所需的数据。'
- en: '![](../Images/12_06.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![12_06.png](../Images/12_06.png)'
- en: Figure 12.6 The `FlightView` class combines the `FlightNumber` data from the
    Flight table with the city and code data from the Airport table. This allows us
    to present exactly the information we want from multiple sources to the end user.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 `FlightView`类将航班表中的`FlightNumber`数据与机场表中的城市和代码数据相结合。这使得我们能够向最终用户展示来自多个来源的精确信息。
- en: To keep things organized, let’s create a new folder for the `FlightView` class
    called Views. The folder lives in the `FlyingDutchmanAirlines` project. Even though
    we don’t expect a lot of views in this project, it is always good to be somewhat
    organized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，让我们为`FlightView`类创建一个新的文件夹，命名为Views。这个文件夹位于`FlyingDutchmanAirlines`项目中。尽管我们预计这个项目中不会有太多视图，但保持一定的组织性总是好的。
- en: '| ![](../Images/LightBulb.png)   | Structs How do we deal with this `Airport`
    object we want to add inside the `FlightView`? Sure, we could add instances of
    `Airport` and ignore some fields, but that seems heavy handed to me. This is a
    prime chance to use the struct type. Many languages support either structs or
    classes, but C# does both. We can think of structs (within the context of C#)
    as light-weight classes that store simple information. Structs have less overhead
    than a full-fledged class, so when you just want to store a little information,
    use a struct. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | 结构体我们如何处理我们想要添加到`FlightView`中的这个`Airport`对象呢？当然，我们可以添加`Airport`的实例并忽略一些字段，但我觉得这样做有点过于强硬。这是一个使用结构体类型的绝佳机会。许多语言支持结构体或类，但C#两者都支持。我们可以在C#的上下文中将结构体视为轻量级的类，用于存储简单的信息。结构体比完整的类开销更小，所以当你只想存储少量信息时，使用结构体。
    |'
- en: 'Let’s add a struct called `AirportInfo` inside the FlightView.cs file (Note:
    Not inside the `FlightView` class.), as shown in the next code sample. The `AirportInfo`
    type should store information about the `City` and `Code` of a destination. We
    could use `IATA` instead of `Code` and reflect the database. However, because
    this is a view, we can change the name of things if we feel they better represent
    the data. IATA is correct, but `Code` is easier to understand for people unfamiliar
    with aviation terms.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `FlightView.cs` 文件中添加一个名为 `AirportInfo` 的结构体（注意：不是在 `FlightView` 类内部），如下面的代码示例所示。`AirportInfo`
    类型应存储有关目的地 `City` 和 `Code` 的信息。我们可以使用 `IATA` 代替 `Code` 并反映数据库。然而，因为这是一个视图，我们可以根据它们是否更好地表示数据来更改事物的名称。IATA
    是正确的，但 `Code` 对于不熟悉航空术语的人来说更容易理解。
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `AirportInfo` constructor accepts a tuple containing two fields: `city`
    and `code`. This brings us to the second cool thing about using a struct: when
    adding a constructor to a struct, you need to assign every property a value. In
    a class, you do not need to assign a value to all properties, but this does not
    fly with a struct! If we were to have an `AirportInfo` constructor that assigns
    a value only to the `City` property, the compiler would cry foul. By adding a
    constructor to a struct, you guarantee a complete setup of the respective struct.
    We can use this for future-proofing against a (well-intended) developer not completely
    initializing a struct as needed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`AirportInfo` 构造函数接受一个包含两个字段的元组：`city` 和 `code`。这让我们想到了使用结构体的第二个酷点：当向结构体添加构造函数时，你需要为每个属性分配一个值。在类中，你不需要为所有属性分配值，但结构体不适用这一点！如果我们有一个只分配
    `City` 属性值的 `AirportInfo` 构造函数，编译器会发出警告。通过向结构体添加构造函数，你确保了相应结构体的完整设置。我们可以利用这一点来防止（有良好意图的）开发者没有完全初始化结构体。'
- en: Coming back to the `FlightView` class, we can do something cool with the properties
    there as well. We can use private setters to make sure code only within the struct
    itself can change the value. We know that we don’t need to change the data once
    we retrieve it from the database, so let’s make the properties reflect that as
    much as possible. We don’t want just anybody to come in and try to set these properties,
    anyway.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `FlightView` 类，我们也可以在其中的属性上做一些酷的事情。我们可以使用私有设置器来确保只有结构体内部的代码可以更改值。我们知道一旦我们从数据库中检索数据，我们就不需要更改数据，所以让我们尽可能让属性反映这一点。我们也不想让任何人随意进来尝试设置这些属性。
- en: ACCESS MODIFIERS AND AUTO-PROPERTIES When using auto-properties, we can have
    different access modifiers for setting and getting a property.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符和自动属性：当使用自动属性时，我们可以为设置和获取属性使用不同的访问修饰符。
- en: 'Let’s see what the `FlightView` class looks like with a split `get` and `set`
    system, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `FlightView` 类在具有分离的 `get` 和 `set` 系统时的样子，如下所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this situation, only code that can access the properties through their private
    access modifiers can set new values, yet the `get` is still public. So where do
    we set these values? How about in a constructor? An alternative approach to using
    a private setter would be to make the properties `readonly`, because you can only
    set `readonly` properties in a constructor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有可以通过它们的私有访问修饰符访问属性的代码可以设置新值，但 `get` 仍然是公共的。那么我们把这些值设置在哪里呢？何不在构造函数中设置？使用私有设置器的另一种方法是将其属性设置为
    `readonly`，因为在构造函数中只能设置 `readonly` 属性。
- en: 'Let’s create a constructor that accesses the properties’ private setters and
    accepts arguments to set them to as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个构造函数，它访问属性的私有设置器并接受参数来设置它们，如下所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should also do some input validation on the passed-in parameters. We can
    use the `String.IsNullOrEmpty` method to see whether any of the input arguments
    are a null pointer or an empty string. Alternatively, you can use the `String.IsNullOrWhitespace`,
    which checks whether the string is null, empty, or just consists of whitespace.
    If they are, we set them to appropriate values. We also use the ternary conditional
    operator, as shown next:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在传入的参数上进行一些输入验证。我们可以使用 `String.IsNullOrEmpty` 方法来检查任何输入参数是否为空指针或空字符串。或者，你可以使用
    `String.IsNullOrWhitespace`，它检查字符串是否为空、空字符串或仅由空白字符组成。如果是这样，我们将它们设置为适当的值。我们同样使用三元条件运算符，如下所示：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: NOTE Technically, we could make the `FlightNumber`, `Origin`, `Destination`,
    `City`, and `Code` properties to be “get” only and remove the private setter altogether.
    The compiler is smart enough to realize that we want to privately set the properties
    in the constructor. I like the verbosity of having the private setter, however.
    Your mileage may vary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：技术上，我们可以将`FlightNumber`、`Origin`、`Destination`、`City`和`Code`属性设置为“只读”的，并且完全移除私有的设置器。编译器足够聪明，能够意识到我们想在构造函数中私有地设置属性。不过，我喜欢私有设置器的详尽性。你的体验可能会有所不同。
- en: Of course, we should also create a test class and some unit tests to verify
    the `FlightView` constructor logic. Figure 12.7 shows the newly created files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也应该创建一个测试类和一些单元测试来验证`FlightView`构造函数的逻辑。图12.7显示了新创建的文件。
- en: '![](../Images/12_07.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_07.png)'
- en: 'Figure 12.7 Two new files are created: FlightView in FlyingDutchmanAirlines/Views,
    and FlightViewTests in FlyingDutchmanAirlines_Tests/Views. Storing the classes
    in a separate Views folder helps us with organizing our codebase.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7创建了两个新文件：在`FlyingDutchmanAirlines/Views`中的`FlightView`和在`FlyingDutchmanAirlines_Tests/Views`中的`FlightViewTests`。将类存储在单独的`Views`文件夹中有助于我们组织代码库。
- en: 'There are different trains of thought on testing constructors. Some people
    say that testing a constructor is simply testing the instantiation of a new object
    and, therefore, testing a language feature. Others say testing a constructor is
    useful because you never know what happens with the code. I fall into the latter
    camp. Especially when testing a constructor represents a minimal effort, having
    a test suite, such as the following code, to back up your code is the way to go:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试构造函数方面有不同的观点。有些人说测试构造函数只是测试新对象的实例化，因此是测试语言特性。其他人说测试构造函数是有用的，因为你永远不知道代码会发生什么。我属于后一种观点。特别是当测试构造函数代表最小努力时，拥有如以下代码所示的测试套件来支持你的代码是正确的做法：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can now rest easy knowing that whatever may happen to the code in the `FlightView`
    class and the `AirportInfo` struct, we have tests to catch any changes that break
    existing functionality. We can now move on to populating the `FlightView` for
    every flight we get back from the `FlightRepository`. Of the five pieces of data
    we need for the `FlightView` (the flight number, the destination city, the destination
    code, the origin city, and the origin code), we know how to get the flight number.
    We just need to call the `FlightRepository.GetFlights` method. Of course, we need
    a `GetFlights` method in the `FlightService` first.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以放心了，无论`FlightView`类和`AirportInfo`结构体中的代码发生什么变化，我们都有测试来捕捉任何破坏现有功能的变化。现在我们可以继续为从`FlightRepository`获取的每趟航班填充`FlightView`。对于`FlightView`所需的五项数据（航班号、目的地城市、目的地代码、出发城市和出发代码），我们知道如何获取航班号。我们只需要调用`FlightRepository.GetFlights`方法。当然，我们首先需要在`FlightService`中有一个`GetFlights`方法。
- en: The `GetFlights` method returns an instance of `FlightView` wrapped in an `IAsyncEnumerable`.
    We discussed `IEnumerable` and how we can use the `yield return` keywords with
    it earlier in this section. The `IAsyncEnumerable` return type allows us to return
    an asynchronous collection implementing the `IEnumerable` interface. Because it
    is already asynchronous, we do not need to wrap it in a `Task`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlights`方法返回一个被`IAsyncEnumerable`包装的`FlightView`实例。我们之前讨论了`IEnumerable`以及如何使用`yield
    return`关键字。`IAsyncEnumerable`返回类型允许我们返回一个实现`IEnumerable`接口的异步集合。因为它已经是异步的，所以我们不需要将其包装在`Task`中。'
- en: To start, let’s call the `FlightRepository.GetFlights` method and construct
    a `FlightView` for every flight returned from the database, as shown in the next
    listing. To do this, we also need to inject an instance of `FlightRepository`
    into the `FlightService` class. I leave that to you. You know what to do there.
    If you get stuck, see the provided source code. Note that the code in listing
    12.3 does not compile, as explained after the listing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调用`FlightRepository.GetFlights`方法，并为数据库返回的每趟航班构造一个`FlightView`，如下一列表所示。为此，我们还需要将`FlightRepository`的一个实例注入到`FlightService`类中。这个任务留给你们。你们知道该怎么做。如果你卡住了，请参阅提供的源代码。注意，列表12.3中的代码无法编译，正如列表之后所解释的。
- en: Listing 12.3 `FlightService.GetFlights` asks for all flights in the database
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3 `FlightService.GetFlights`请求数据库中的所有航班
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Asks for all flights in the database
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 请求数据库中的所有航班
- en: ❷ Loops over the returned flights
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历返回的航班
- en: ❸ Creates a FlightView instance for every flight
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每趟航班创建一个`FlightView`实例
- en: 'Take a minute to read through listing 12.3 and see if you can spot why this
    code does not compile (besides not returning the correct type). Did you see it?
    The compiler throws an error because we did not provide enough arguments when
    instantiating the `FlightView` object for every flight. We don’t even have the
    correct information to give the view, though. The view wants us to pass in values
    for the flight number, origin city, and destination city. We passed in the flight
    number but neither of the cities. The closest thing we have to city names are
    the `originAirportID` and `destinationAirportID` properties on the returned `Flight`
    objects. We know how to take those and get the airport city names and codes: we
    call the `AirportRepository.GetAirportByID` method and take the `Airport.City`
    property (we also need an injected `AirportRepository` instance), as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 花一分钟时间阅读列表 12.3，看看你是否能找出为什么这段代码无法编译（除了没有返回正确的类型）。你看到了吗？编译器抛出一个错误，因为我们没有为每个航班实例化
    `FlightView` 对象时提供足够的参数。我们甚至没有提供正确的信息来给出视图。视图希望我们传递航班号、出发城市和目的城市的值。我们传递了航班号，但没有传递任何城市。我们拥有的最接近城市名称的东西是返回的
    `Flight` 对象上的 `originAirportID` 和 `destinationAirportID` 属性。我们知道如何获取这些属性并获取机场城市名称和代码：我们调用
    `AirportRepository.GetAirportByID` 方法并获取 `Airport.City` 属性（我们还需要一个注入的 `AirportRepository`
    实例），如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, here is where the real magic happens. Because we return a type of `IAsyncEnumerable<FlightView>`,
    we can use the `yield return` keywords to automatically add the created `FlightView`
    instances to a compiler-generated list as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里就是真正的魔法发生的地方。因为我们返回的是 `IAsyncEnumerable<FlightView>` 类型，我们可以使用 `yield return`
    关键字自动将创建的 `FlightView` 实例添加到编译器生成的列表中，如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We should also add a unit test in `FlightServiceTests` to verify we did a good
    job. Remember, we do not have to test the repository layers when testing service
    layer methods. Instead, we can use instances of `Mock<FlightRepository>` and `Mock<AirportRepository>`
    as the injected dependencies to the `FlightService` class. To mock the `AirportRepository`
    class, make the appropriate methods virtual and add a parameterless constructor,
    as shown in the next listing. We’ve done this a couple of times now, so I leave
    that to you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在 `FlightServiceTests` 中添加一个单元测试来验证我们是否做得很好。记住，当我们测试服务层方法时，我们不需要测试仓库层。相反，我们可以使用
    `Mock<FlightRepository>` 和 `Mock<AirportRepository>` 的实例作为注入到 `FlightService`
    类中的依赖项。为了模拟 `AirportRepository` 类，将适当的方法设置为虚拟的，并添加一个无参构造函数，如下所示。我们已经这样做了几次，所以我就留给你了。
- en: Listing 12.4 Unit testing a method returning `IAsyncEnumerable<T>`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 单元测试返回 `IAsyncEnumerable<T>` 的方法
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Sets up the FlightRepository.GetAllFlights mocked return
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置 FlightRepository.GetAllFlights 模拟返回
- en: ❷ Sets up the AirportRepository.GetAirportByID mocked returns
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置 AirportRepository.GetAirportByID 模拟返回
- en: ❸ Injects the mocked dependencies, and creates a new instance of FlightService
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注入模拟依赖项，并创建一个新的 FlightService 实例
- en: ❹ Receives flightViews as we construct them in the GetFlights method (one in
    this case)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 `GetFlights` 方法中（本例中为一个）构建 `flightViews`
- en: ❺ Makes sure we received the correct flightView back
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 确保我们收到了正确的 flightView
- en: In listing 12.4, we get our first peek at how to use the returned `IAsyncEnumerable`
    type and can put together the puzzle of why it is such an outstanding feature.
    Instead of calling the `FlightService.GetFlights` method once, waiting for all
    the data to come back, and then operating on it, the `IAsyncEnumerable` type allows
    us to `await` on a `foreach` loop and operate on the returned data as it comes
    in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12.4 中，我们第一次看到了如何使用返回的 `IAsyncEnumerable` 类型，并可以拼凑出为什么它是一个如此出色的功能。我们不是一次调用
    `FlightService.GetFlights` 方法，等待所有数据返回，然后再对其进行操作，`IAsyncEnumerable` 类型允许我们在 `foreach`
    循环上 `await`，并随着数据的到来对其进行操作。
- en: 12.2.3 Using the yield return keywords with try-catch code blocks
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 使用 try-catch 代码块与 yield return 关键字
- en: 'In section 12.2.2, we implemented the `FlightService.GetFlights` method. We
    did not, however, handle any exceptions coming out of the `AirportRepository.GetAirportByID`
    method. Unfortunately, we cannot simply add a `try-catch` code block and wrap
    the entire method in it because we cannot use the `yield return` keywords in such
    a code block. Not allowing `yield` statements in `try-catch` blocks has been a
    point of discussion within the C# language community for a while. Because adding
    `yield` statements to just `try` code blocks (without the `catch`) is allowed,
    and the only blocker for adding `yield` statement support to `try-catch` code
    blocks is added compiler complexity due to garbage collection difficulties, we
    may see this feature added in the future. The workaround is to add the calls to
    the `AirportRepository.GetAirportByID` method only in a `try-catch` block, so
    we can catch any outgoing exceptions, and then proceed as usual, as shown next:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在12.2.2节中，我们实现了`FlightService.GetFlights`方法。然而，我们没有处理来自`AirportRepository.GetAirportByID`方法的任何异常。不幸的是，我们无法简单地添加一个`try-catch`代码块并将整个方法包裹在其中，因为我们不能在这样一个代码块中使用`yield
    return`关键字。不允许在`try-catch`块中使用`yield`语句一直是C#语言社区讨论的焦点。因为允许在仅包含`try`代码块（没有`catch`）中添加`yield`语句，而添加对`try-catch`代码块`yield`语句支持的唯一障碍是由于垃圾回收困难而增加的编译器复杂性，我们可能会看到这个功能在未来被添加。解决方案是在`try-catch`块中仅添加对`AirportRepository.GetAirportByID`方法的调用，这样我们就可以捕获任何传出的异常，然后像往常一样继续操作，如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: NOTE We have seen both `IAsyncEnumerable` and `Task<IEnumerable>` as return
    types. `IAsyncEnumerable` does not need to be wrapped in a `Task<T>` when returning
    from an asynchronous method, because `IAsyncEnumerable` is already asynchronous.
    Using a type with the generic `Task<T>` allows us to return a synchronous type
    from an asynchronous method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们已经看到了`IAsyncEnumerable`和`Task<IEnumerable>`作为返回类型。`IAsyncEnumerable`在从异步方法返回时不需要包裹在`Task<T>`中，因为`IAsyncEnumerable`本身就是异步的。使用具有泛型`Task<T>`的类型允许我们从异步方法返回同步类型。
- en: This code allows us to catch any exception coming from the `AirportRepository
    .GetAirportByID` method. If the service class finds the repository method threw
    an exception of type `FlightNotFoundException`, it throws a new instance of `FlightNotFoundException`.
    If the code throws a different type of exception, the second `catch` block is
    entered and the code throws an `ArgumentException`. The controller calling the
    service layer handles this exception.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码允许我们捕获来自`AirportRepository.GetAirportByID`方法的任何异常。如果服务类发现存储库方法抛出了类型为`FlightNotFoundException`的异常，它将抛出一个新的`FlightNotFoundException`实例。如果代码抛出不同类型的异常，将进入第二个`catch`块，并抛出`ArgumentException`。调用服务层的控制器处理此异常。
- en: The last piece of our service layer implementations is to write a unit test
    that verifies our handling of the exception code we just wrote. Let’s look at
    that unit test shown next. It should be pretty straightforward.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务层实现中的最后一部分是编写一个单元测试来验证我们刚刚编写的异常处理代码。让我们看看下面的单元测试。它应该相当直接。
- en: Listing 12.5 Testing for exceptions in the `FlightService`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 在`FlightService`中测试异常
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Expects the executed logic in this test to throw an exception
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预期此测试中执行的逻辑会抛出异常
- en: ❷ Starts at the FlightRepository.GetAllFlights mocked return (same as listing
    12.4)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从FlightRepository.GetAllFlights模拟返回值开始（与列表12.4相同）
- en: ❸ Sets up the AirportRepository.GetAirportByID mocked returns (same as listing
    12.4)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置AirportRepository.GetAirportByID模拟返回值（与列表12.4相同）
- en: ❹ Creates a new instance of FlightService (same as listing 12.4)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个新的FlightService实例（与列表12.4相同）
- en: ❺ Calls the GetFlights method, using the discard operator for the return assignment
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用GetFlights方法，使用丢弃操作符进行返回赋值
- en: ❻ Empty statement
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 空语句
- en: ❼ Expects the executed logic in this test to throw an exception
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 预期此测试中执行的逻辑会抛出异常
- en: ❽ Starts at the FlightRepository.GetAllFlights mocked return (same as listing
    12.4)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从FlightRepository.GetAllFlights模拟返回值开始（与列表12.4相同）
- en: ❾ Sets up the AirportRepository.GetAirportByID mocked returns (same as listing
    12.4)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 设置AirportRepository.GetAirportByID模拟返回值（与列表12.4相同）
- en: ❿ Creates a new instance of FlightService (same as listing 12.4)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 创建一个新的FlightService实例（与列表12.4相同）
- en: ⓫ Calls the GetFlights method, using the discard operator for the return assignment
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 调用GetFlights方法，使用丢弃操作符进行返回赋值
- en: Overall, the code in listing 12.5 should pose no challenges. It is good to point
    out that by using the `discard` operator in the `foreach`, we tell other developers
    that we do not need to use the returned values. In the same vein, inside the `foreach`
    loop, we added an empty statement (`;`). This does absolutely nothing but provide
    more readable code. By adding the empty statement, we say that having no logic
    inside the `foreach` loop was not a mistake.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，列表 12.5 中的代码应该不会带来任何挑战。值得注意的是，通过在 `foreach` 中使用 `discard` 操作符，我们告诉其他开发者我们不需要使用返回的值。同样，在
    `foreach` 循环内部，我们添加了一个空语句（`;`）。这绝对没有任何作用，但提供了更易读的代码。通过添加空语句，我们表明在 `foreach` 循环内部没有逻辑并不是一个错误。
- en: 'We can do some further cleaning up: I am sure you noticed we have identical
    setup code for the `Mock<Flight>` and `Mock<Airport>` instances in both unit tests.
    Because this violates the DRY principle, we should refactor both unit tests and
    do this initialization in the `TestInitialize` method. This shortens our test
    methods considerably, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行一些进一步的清理：我确信你已经注意到了，在两个单元测试中，`Mock<Flight>` 和 `Mock<Airport>` 实例的设置代码是相同的。因为这也违反了
    DRY 原则，我们应该重构这两个单元测试，并在 `TestInitialize` 方法中完成这个初始化。这将显著缩短我们的测试方法，如下所示：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And that does it for the `GetFlights` method!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`GetFlights` 方法就完成了！
- en: 12.2.4 Implementing GetFlightByFlightNumber
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 实现 GetFlightByFlightNumber
- en: 'All that is left is to add a similar method that retrieves only a single flight’s
    information when given a flight number. The patterns should be very familiar to
    you by now, as shown next:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是添加一个类似的方法，当给定一个航班号时，只检索单个航班的详细信息。这些模式现在应该对你来说非常熟悉，如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We should also add some unit tests to verify we can get the correct flight
    from the database and handle the `FlightNotFoundException` and `Exception` error
    paths. To do this, we first have to add a new setup call to the `TestInitalize`
    method. Our mock currently does not return any data when we call `FlightRepository.GetFlightByFlightNumber`.
    Let’s fix that as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该添加一些单元测试来验证我们能否从数据库中获取正确的航班并处理 `FlightNotFoundException` 和 `Exception`
    错误路径。为此，我们首先必须向 `TestInitalize` 方法添加一个新的设置调用。我们的模拟在调用 `FlightRepository.GetFlightByFlightNumber`
    时目前不返回任何数据。让我们按照以下方式修复它：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the mock’s `GetFlightByFlightNumber` returns data, we return the previously
    created flight instance. With that, we can add the `GetFlightByFlightNumber_Success`
    test case as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟的 `GetFlightByFlightNumber` 返回数据时，我们返回之前创建的航班实例。有了这个，我们可以添加 `GetFlightByFlightNumber_Success`
    测试用例，如下所示：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The unit test is pretty simple. We mimicked (read: copied and pasted) the airport
    setup code, so we added a flight to use in the in-memory database. Then we called
    `FlightService.GetFlightByFlightNumber` to check our service layer logic. Finally,
    we verified the return data. Now, when you saw the airport setup from the `GetFlights_Success`
    unit test in the code that we copied and pasted, alarm bells should have started
    to ring in your mind. Obviously, this repetition is a giant violation of the DRY
    principle, and we should refactor the test class to do this database setup in
    the `TestInitialize` method as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试相当简单。我们模仿（即：复制粘贴）了机场设置代码，因此添加了一个航班用于内存数据库中。然后我们调用 `FlightService.GetFlightByFlightNumber`
    来检查我们的服务层逻辑。最后，我们验证了返回的数据。现在，当你从复制粘贴的代码中看到 `GetFlights_Success` 单元测试中的机场设置时，你的心中应该开始响起警钟。显然，这种重复是严重违反
    DRY 原则的，我们应该重构测试类，在 `TestInitialize` 方法中完成这个数据库设置，如下所示：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This shortens the `GetFlights_Success` and the `GetFlightByFlightNumber_Success`
    unit tests by a fair amount, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这显著缩短了 `GetFlights_Success` 和 `GetFlightByFlightNumber_Success` 单元测试，如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, all unit tests still pass. This gives us the confidence to know we
    broke nothing. Let’s add some failure case unit tests for the `GetFlightByFlightNumber`
    method and then we can call it a day.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有单元测试仍然通过。这让我们有信心知道我们没有破坏任何东西。让我们为 `GetFlightByFlightNumber` 方法添加一些失败案例单元测试，然后我们就可以结束了。
- en: 'Starting with the failure path where the service layer throws an exception
    of type `FlightNotFoundException`, we expect the service layer to throw another
    such exception, as shown next:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务层抛出类型为 `FlightNotFoundException` 的异常的失败路径开始，我们期望服务层会再次抛出这样的异常，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `GetFlightByFlightNumber_Failure_RepositoryException_Exception` unit test
    sees our old friend the `ExpectedException` method attribute again. We are well
    aware of its usefulness by now and also use it in the unit test to check for the
    next (and last) exception path: the repository layer throws an exception of any
    type besides `FlightNotFoundException`. The `FlightService.GetFlightByFlightNumber`
    method catches the thrown exception and throws a new `ArgumentException`. Or so
    it says. Let’s see if it actually does:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightNumber_Failure_RepositoryException_Exception` 单元测试再次看到了我们熟悉的老朋友
    `ExpectedException` 方法属性。现在我们已经非常清楚它的有用性，并在单元测试中使用它来检查下一个（也是最后一个）异常路径：仓库层抛出除 `FlightNotFoundException`
    之外任何类型的异常。`FlightService.GetFlightByFlightNumber` 方法捕获抛出的异常并抛出一个新的 `ArgumentException`。或者至少它说是这样。让我们看看它实际上是否真的这样做：'
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `GetFlightByFlightNumber_Failure_RepositoryException_Exception` unit test
    tells the `Mock<FlightRepository>` to throw an exception of type `OverflowException`
    when we call the `FlightRepository.GetFlightByFlightNumber` and pass in an input
    argument of `-1`. We could have used any exception class here because they are
    all derived from the base `Exception` class, and that is what the `catch` block
    in the method looks for. This is also the reason why the test is not more specific
    in its name regarding the exception type. We are testing the logic that happens
    if any type of `Exception` is thrown, not a specific one. Because `Exception`
    is the base class for all exceptions, we can test it with just that.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightNumber_Failure_RepositoryException_Exception` 单元测试指示 `Mock<FlightRepository>`
    在我们调用 `FlightRepository.GetFlightByFlightNumber` 并传入输入参数 `-1` 时抛出 `OverflowException`
    类型的异常。在这里，我们可以使用任何异常类，因为它们都派生自基类 `Exception`，这正是方法中的 `catch` 块所寻找的。这也是为什么测试名称在异常类型方面没有更具体的原因。我们正在测试如果抛出任何类型的
    `Exception` 会发生什么逻辑，而不是特定的一个。因为 `Exception` 是所有异常的基类，所以我们只需测试它。'
- en: Overflows and underflows (checked and unchecked)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出和下溢（已检查和未检查）
- en: What do you get when you add two integers together? Let’s say 2147483647 and
    1? You get a negative number. Similarly, what do you get when you subtract 1 from
    –2147483647? A positive number. This is what we call over- and underflow. When
    you go over the maximum value of a primitive type, or under the minimum value
    of a primitive type, you are greeted by a “wrapped around” value. Why is this,
    and how can we protect against this?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将两个整数相加时，你会得到什么？比如说 2147483647 和 1？你会得到一个负数。同样，当你从 -2147483647 减去 1 时，你会得到一个正数。这就是我们所说的溢出和下溢。当你超过原始类型的最大值或低于原始类型的最低值时，你会得到一个“环绕”的值。为什么会这样，我们如何才能防止这种情况发生？
- en: 'When there are not enough binary bits available in a type to represent your
    requested value, the type wraps around and flips (if it is an unsigned integer).
    This, depending on the context, is overflow and underflow. For example (albeit
    a simplistic one): an integer is a four-byte data type. This means we have 32
    bits to play with (one byte contains eight bits, and 8 × 4 = 32). So, if we declare
    one variable that sets all 32 (31 if signed) bits to their “on” value, we have
    the maximum value we can represent in a 32-bit (or four-byte) type (in C#, we
    can use decimal, hexadecimal, or binary representations directly in our code;
    this is binary):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类型中可用的二进制位不足以表示你请求的值时，该类型会环绕并翻转（如果它是一个无符号整数）。这取决于上下文，我们称之为溢出和下溢。例如（尽管这是一个简化的例子）：整数是一个四字节的数据类型。这意味着我们有
    32 位可以操作（一个字节包含八个位，8 × 4 = 32）。因此，如果我们声明一个变量，将所有 32（如果是有符号整数则为 31）位设置为“开启”值，我们就有了在
    32 位（或四字节）类型中可以表示的最大值（在 C# 中，我们可以在代码中直接使用十进制、十六进制或二进制表示；这是二进制表示）：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In C#, when using direct binary representation, you have to prefix your value
    with either 0b or 0B (with hexadecimal, use 0x or 0X). You can opt, as in the
    code snippet, to include underscores in the binary representation for readability.
    We prefix these values so the compiler knows how to treat the value. In this code
    snippet, we do the equivalent of adding 1 to the max 2147483647\. So, what does
    the overflow variable resolve to? It resolves to –2147483648\. And if we were
    to subtract a value of 1 from that, we would end up with a positive value: 2147483647\.
    Often, when you know you are dealing with values over a particular type’s capacity,
    you use a different one. For example, you may use a `long` instead of an integer,
    or a `BigInteger` instead of a `long`. But what if you are, for whatever reason,
    restricted to a specific type, yet can see overflows and underflows as a realistic
    scenario?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，当使用直接二进制表示时，你必须使用 0b 或 0B（对于十六进制，使用 0x 或 0X）来前缀你的值。你可以选择，如代码片段所示，在二进制表示中包含下划线以提高可读性。我们使用这些前缀是为了让编译器知道如何处理这些值。在这个代码片段中，我们做了相当于将
    1 加到最大值 2147483647 上的操作。那么，溢出变量解析成什么？它解析为 –2147483648。如果我们从那个值中减去 1，我们就会得到一个正值：2147483647。通常，当你知道你正在处理超过特定类型容量的值时，你会使用不同的类型。例如，你可能使用
    `long` 而不是整数，或者使用 `BigInteger` 而不是 `long`。但是，如果你因为某种原因被限制在特定类型上，同时又能看到溢出和下溢作为一个现实场景，该怎么办呢？
- en: '| ![](../Images/LightBulb.png)   | BIGINTEGER is an immutable, nonprimitive
    “type” that grows with your data and is effectively capped only by your memory.
    A `BigInteger` acts as an integer but is actually a cleverly designed struct.
    Java developers may be familiar with `BigInteger``.` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | `BIGINTEGER` 是一个不可变、非原始的“类型”，随着你的数据增长而增长，并且实际上仅受限于你的内存。`BigInteger`
    起整数的作用，但实际上是一个巧妙设计的结构。Java 开发者可能熟悉 `BigInteger`。|'
- en: 'C# provides us with a keyword and compilation mode that can somewhat prevent
    unexpected overflows and underflows: `checked`. By default, C# compiles in `unchecked`
    mode. This means that the CLR does not throw any exceptions on arithmetic overflow
    and underflow. This is fine for most use cases, because we have some additional
    overhead with checking for this possibility, and it is not a common occurrence
    in a lot of programs. But, if we use `checked` mode, the CLR throws an exception
    when it detects under- or overflow. To use `checked` mode, we can either compile
    the entire codebase with these checks in place, by adding the `-checked` compiler
    option to the build instructions, or we can use the `checked` keyword.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一个关键字和编译模式，可以在一定程度上防止意外的溢出和下溢：`checked`。默认情况下，C# 以 `unchecked` 模式编译。这意味着
    CLR 在算术溢出和下溢时不会抛出任何异常。这对于大多数用例来说是可以的，因为我们有一些额外的开销来检查这种可能性，而且在很多程序中这种情况并不常见。但是，如果我们使用
    `checked` 模式，当 CLR 检测到下溢或溢出时，它会抛出一个异常。要使用 `checked` 模式，我们可以通过在构建指令中添加 `-checked`
    编译器选项来编译整个代码库，或者我们可以使用 `checked` 关键字。
- en: 'To have the CLR throw an exception when it sees under- or overflow in a specific
    code block, we can wrap code in a `checked` block as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 CLR 在特定代码块中看到下溢或溢出时抛出异常，我们可以将代码包裹在一个 `checked` 块中，如下所示：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, when we add the `maxVal` and `oneVal` variables, the CLR throws an `OverflowException`!
    Consequently, if you compiled the entire codebase in `checked` mode, you can use
    the `unchecked` code block to tell the CLR *not* to throw any `OverflowExceptions`
    for that block’s scope.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们添加 `maxVal` 和 `oneVal` 变量时，CLR 会抛出一个 `OverflowException`！因此，如果你在 `checked`
    模式下编译了整个代码库，你可以使用 `unchecked` 代码块来告诉 CLR 不要为该代码块的范围内抛出任何 `OverflowExceptions`。
- en: And that does it for the service layer classes. I hope you learned some valuable
    things, and if not, the end of the book is in sight. In chapter 13, we’ll look
    at implementing the controller layer and integration testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是服务层类的全部内容了。我希望你学到了一些有价值的东西，如果没有，书的结尾就在眼前。在第 13 章，我们将探讨实现控制层和集成测试。
- en: Exercises
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 12.1
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.1
- en: True or false? For the endpoint `GET /Band/Song`, we need to implement the `BandService`
    class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正误判断？对于端点 `GET /Band/Song`，我们需要实现 `BandService` 类。
- en: Exercise 12.2
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.2
- en: True or false? For the endpoint `POST /Inventory/SKU`, we need to implement
    the `SKUService` class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正误判断？对于端点 `POST /Inventory/SKU`，我们需要实现 `SKUService` 类。
- en: Exercise 12.3
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.3
- en: What best describes the interactions with a `Queue<T>` data structure?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个最能描述与 `Queue<T>` 数据结构的交互？
- en: a. First-in, last-out (FILO)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: a. 先入后出（FILO）
- en: b. First-in, first-out (FIFO)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: b. 先入先出（FIFO）
- en: c. Last-in, first-out (LIFO)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: c. 后入先出（LIFO）
- en: d. Last-in, last-out (LILO)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: d. 后入后出（LILO）
- en: Exercise 12.4
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.4
- en: If we use the `yield return` keywords inside a `foreach` loop embedded in a
    method with a return type of `IEnumerable<T>`, what could we expect to get back
    as a value from the method?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个返回类型为 `IEnumerable<T>` 的方法中嵌入的 `foreach` 循环中使用 `yield return` 关键字，我们期望从方法中返回什么值？
- en: a. A collection implementing the `IEnumerable` interface containing all the
    data from the `foreach` loop.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个实现 `IEnumerable` 接口且包含 `foreach` 循环中所有数据的集合。
- en: b. A collection implementing the `IEnumerable` interface containing only the
    first piece of data to be processed in the `foreach` loop.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: b. 一个实现 `IEnumerable` 接口且只包含 `foreach` 循环中要处理的第一条数据的集合。
- en: c. A collection not implementing the `IEnumerable` interface returning a reference
    to the original collection.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个未实现 `IEnumerable` 接口且返回原始集合引用的集合。
- en: Exercise 12.5
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.5
- en: Imagine a class called `Food` with a Boolean property `IsFruit`. This property
    has a public getter and a protected setter. Can the class `Dragonfruit`, which
    derives from the `Food` class, set the `IsFruit` value?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有一个名为 `Food` 的类，它有一个布尔属性 `IsFruit`。这个属性有一个公共的获取器和受保护的设置器。从 `Food` 类派生的 `Dragonfruit`
    类能否设置 `IsFruit` 的值？
- en: Exercise 12.6
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.6
- en: What does this evaluate to? `string.IsNullOrEmpty(string.empty``);`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这会评估成什么？`string.IsNullOrEmpty(string.empty``);`
- en: Exercise 12.7
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.7
- en: What does this evaluate to? `string.IsNullOrWhitespace("` `");`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这会评估成什么？`string.IsNullOrWhitespace("` `");`
- en: Exercise 12.8
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.8
- en: True or false? If you add a constructor to a struct, you can set only one property.
    The other properties must go unset.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？如果你向结构体添加一个构造函数，你只能设置一个属性。其他属性必须保持未设置状态。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To determine whether we need to implement a particular service, we can look
    at the required API endpoints. If there is no need for a particular model’s controller,
    we don’t need a service for that model, either. This saves us from implementing
    unnecessary code.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确定我们是否需要实现特定的服务，我们可以查看所需的 API 端点。如果没有必要为特定模型创建控制器，那么我们也不需要为该模型创建服务。这可以避免我们实现不必要的代码。
- en: A `Queue<T>` is a “first-in, first-out” (FIFO) data structure. Queues are very
    helpful when we want to preserve order and deal with information as if we are
    dealing with a queue of people. The first one there is the first one processed,
    or, “the early bird gets the worm.”
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T>` 是一个“先进先出”（FIFO）的数据结构。当我们想要保持顺序并像处理排队的人一样处理信息时，队列非常有用。第一个到达的是第一个被处理的，或者说，“早起的鸟儿有虫吃。”'
- en: We can use the `yield return` keywords to asynchronously return an `IEnumerable<T>`
    implementation if we iterate over some data. This can make our code more readable
    and concise.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在一个返回类型为 `IEnumerable<T>` 的方法中嵌入的 `foreach` 循环中使用 `yield return` 关键字，我们可以异步返回一个
    `IEnumerable<T>` 实现。这可以使我们的代码更易于阅读和简洁。
- en: A struct can be thought of as a “lightweight” class. We often use them to store
    small amounts of information and typically do not do any processing of data in
    a struct. Structs are a great way to signify to our fellow developers that this
    piece of code acts as a data storage device.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体可以被看作是一个“轻量级”类。我们经常使用它们来存储少量信息，并且在结构体中通常不会进行数据处理。结构体是向我们的开发者伙伴表明这段代码作为数据存储设备的好方法。
- en: When adding a constructor to a struct, the compiler requires us to assign every
    property in the struct to a value. This is to prevent structs that are only partly
    initialized and stops us from accidentally forgetting to set values.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向结构体添加构造函数时，编译器要求我们为结构体中的每个属性分配一个值。这是为了防止结构体只部分初始化，并阻止我们意外忘记设置值。
- en: We can have different access modifiers for getters and setters in an auto-property.
    This allows us to make a property that can be publicly accessed but only set inside
    its respective class (private). Any combination of access modifiers is allowed.
    Because encapsulation is often our goal, by using these access modifiers, we can
    better control the encapsulation story.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动属性中，我们可以为获取器和设置器使用不同的访问修饰符。这允许我们创建一个可以公开访问但只能在相应类内部设置的属性（私有）。允许任何访问修饰符的组合。因为封装通常是我们的目标，通过使用这些访问修饰符，我们可以更好地控制封装的故事。
- en: We can only set `readonly` values at their declaration or in a constructor.
    Because we can set a `readonly` value only once, and declaring a field means the
    compiler automatically assigns a default value to its spot in memory, we need
    to set it at the earliest possible moment. A `readonly` field can greatly reduce
    the amount of data manipulation others can do on our code.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只能在声明或构造函数中设置 `readonly` 值。因为我们只能设置一次 `readonly` 值，而声明一个字段意味着编译器会自动为其在内存中的位置分配一个默认值，所以我们需要在尽可能早的时刻设置它。`readonly`
    字段可以大大减少他人对我们代码的数据操作量。
- en: By using an `IAsyncEnumerable<T>` along with the `yield return` keywords, we
    can create code that asynchronously awaits on data and processes it as it receives
    the data. This is very helpful when dealing with external interactions such as
    database queries.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `IAsyncEnumerable<T>` 以及 `yield return` 关键字，我们可以创建异步等待数据并按接收数据时处理数据的代码。这在处理外部交互，例如数据库查询时非常有用。
- en: Overflows and underflows happened when we try to represent a value that needs
    more bits than a specific type has access to. When this happens, your variable
    values suddenly become incorrect, which can have unexpected side effects.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们尝试表示一个需要比特定类型可访问的位数更多的值时，会发生溢出和下溢。当这种情况发生时，变量的值会突然变得不正确，这可能会产生意外的副作用。
- en: By default, C# code is compiled using `unchecked` mode. This means the CLR does
    not throw an `OverflowException` if it encounters an overflow or underflow. Similarly,
    `checked` mode means the CLR *does* throw such an exception.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，C# 代码使用 `unchecked` 模式编译。这意味着 CLR 在遇到溢出或下溢时不会抛出 `OverflowException`。同样，`checked`
    模式意味着 CLR 会抛出这样的异常。
- en: We can use `checked` and `unchecked` code blocks to change the compilation mode
    on a per-code-block basis. This is helpful when wanting to control the `Exception`
    story.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `checked` 和 `unchecked` 代码块来按代码块更改编译模式。当想要控制异常故事时，这非常有用。
- en: In C#, we can represent integer values with decimal, hexadecimal, or binary
    representation. When using hexadecimal, we need to prefix our values with either
    0x or 0X. With binary representation, use 0b or 0B. These different representations
    allow us to pick and choose what makes the most sense for our code’s readability.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中，我们可以用十进制、十六进制或二进制表示整数。当使用十六进制时，我们需要在值前加上 0x 或 0X。对于二进制表示，使用 0b 或 0B。这些不同的表示方式使我们能够选择最适合代码可读性的表示方法。
