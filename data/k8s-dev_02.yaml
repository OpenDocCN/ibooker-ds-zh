- en: 1 Kubernetes for application deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 Kubernetes用于应用部署
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The benefits of packaging applications in containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用打包在容器中的好处
- en: What makes Kubernetes an ideal platform to deploy containers with
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes为何是部署容器的理想平台
- en: Deciding when to use Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定何时使用Kubernetes
- en: It’s 5 pm on a Friday, and the product you’ve been working on for the last year
    just went viral. You need to scale everything—and fast. Is your application and
    the platform it runs on capable of scaling 100×, ready to capture your success,
    or are you stuck with brittle code and an inflexible platform, meaning all your
    work will be for naught?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 周五下午5点，你过去一年一直在工作的产品突然走红。你需要快速扩展一切。你的应用及其运行的平台能否扩展100倍，准备好捕捉你的成功，还是你将陷入脆弱的代码和缺乏弹性的平台，这意味着你所有的努力都将付诸东流？
- en: You built an amazing stateless application on a popular application platform
    capable of scaling rapidly, and everything is working great. Until one day, your
    business requirements shift, and suddenly you need to run a bespoke stateful application
    for some critical business data or configure a nightly batch processing pipeline.
    Will these new workloads fit in seamlessly with your existing ones, or will you
    need to start over from scratch or patch together multiple disparate systems?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你在流行的应用平台上构建了一个令人惊叹的无状态应用，该平台能够快速扩展，一切运行良好。然而，有一天，你的业务需求发生了变化，你突然需要运行一个定制的有状态应用来处理一些关键业务数据或配置一个夜间批量处理管道。这些新工作负载能否无缝地与现有的工作负载结合，还是你需要从头开始或拼凑多个不同的系统？
- en: Kubernetes is fast becoming the industry standard for running workloads of all
    different shapes and sizes and at different scales by promising to solve these
    concerns and more. It enables you to launch containerized applications with the
    ability to scale rapidly while, at the same time, handling a variety of complex
    deployment patterns, from stateless applications to stateful databases, batch
    jobs with ephemeral storage, and so on. Invented at Google,[¹](#pgfId-1063123)
    open-sourced, and used by countless organizations like Spotify,[²](#pgfId-1063126)
    CapitalOne,[³](#pgfId-1063129) and OpenAI,[⁴](#pgfId-1063133) Kubernetes is an
    open, vendor-agnostic, and well-proven platform that is to cloud deployments what
    Linux is to operating systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes正迅速成为运行各种形状和大小的工作负载的行业标准，通过承诺解决这些担忧以及更多问题。它使你能够以快速扩展的能力启动容器化应用，同时，它还能处理从无状态应用到有状态数据库、具有短暂存储的批量作业等各种复杂的部署模式。Kubernetes是在谷歌发明、开源并由Spotify[¹](#pgfId-1063123)、CapitalOne[²](#pgfId-1063126)、OpenAI[³](#pgfId-1063129)等无数组织使用[⁴](#pgfId-1063133)的，它是一个开放、供应商无关且经过充分验证的平台，对于云部署来说，就像Linux对于操作系统一样。
- en: However, all this flexibility comes with a bit of a learning curve. Being a
    general-purpose platform capable of handling so many different deployment constructs,
    Kubernetes can be a daunting thing to learn. I’m here to tell you, though, that
    (a) it’s not as hard as people make it out to be and (b) it’s worth learning.
    If you start with the basics and gradually layer on new constructs (which is how
    this book is structured), it’s a lot more approachable. You can get a stateless
    app deployed with a few lines of YAML and build your knowledge from there.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些灵活性都伴随着一定的学习曲线。作为一个能够处理如此多不同部署结构的通用平台，Kubernetes的学习可能会让人感到畏惧。不过，我要告诉你的是，（a）它并没有人们想象中那么难，（b）学习它是值得的。如果你从基础知识开始，并逐渐添加新的结构（这正是本书的结构），它就会变得更容易接近。你可以用几行YAML部署一个无状态应用，并从那里开始构建你的知识。
- en: As a professional, when you are faced with a problem, like how best to deploy
    your applications, I believe the right answer isn’t always to pick the simplest
    option available that can solve your immediate concern but rather to invest your
    time to learn a system that can meet your needs both now and in the future, one
    that allows you to develop your skills and grow professionally as your requirements
    evolve. Kubernetes fits this bill. You can get up and running in hours with some
    simple deployments while knowing a wealth of functionality exists, ready for you
    to learn and employ when, and if, you need it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名专业人士，当你面临问题，比如如何最好地部署你的应用时，我相信正确的答案并不总是选择可以解决你当前问题的最简单选项，而是投入时间去学习一个能够满足你当前和未来需求、让你随着需求的发展而发展技能和职业的平台。Kubernetes就是这样一种平台。你可以通过一些简单的部署在几小时内启动并运行，同时知道有大量的功能可供你学习和应用，当你需要时，无论何时。
- en: If you’re already sold on the idea of Kubernetes, I suggest skipping to chapter
    2 to start building a Docker image, and if you already know what a Docker container
    is and want to start deploying to Kubernetes, go right to chapter 3\. The rest
    of this chapter covers why Kubernetes and containers are proving so popular for
    application deployment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经接受了Kubernetes的概念，我建议跳到第2章开始构建Docker镜像，如果您已经知道Docker容器是什么，并想开始部署到Kubernetes，请直接跳到第3章。本章的其余部分将涵盖为什么Kubernetes和容器对于应用程序部署如此受欢迎的原因。
- en: 1.1 Why containers?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 为什么选择容器？
- en: Kubernetes is a deployment platform for containers. All code deployed into Kubernetes,
    like your application, needs to be first packaged into a container. What are containers,
    and why bother with them at all?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个容器部署平台。所有部署到Kubernetes中的代码，就像您的应用程序一样，需要首先打包成容器。什么是容器，为什么要费心去使用它们呢？
- en: Containers are the modern way to package and run applications. Unless you’re
    running one application per host (which is pretty inefficient), you typically
    want some way to deploy multiple applications onto a machine or collection of
    machines. What are the choices?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是打包和运行应用程序的现代方式。除非您在每个主机上运行一个应用程序（这相当低效），否则您通常希望有一种方法将多个应用程序部署到一台机器或一组机器上。有哪些选择？
- en: 'Before virtual machines (VMs), it was common to install each application into
    a different directory on a shared host, with each served on a separate port. This
    presents a few problems in that the various applications need to cooperate with
    each other to some extent when it comes to sharing dependencies and the resources
    of the machine, like CPU, memory, and available ports. It can also be hard to
    scale: if you have one application that suddenly is receiving more traffic, how
    do you scale just that application while leaving the others as they are?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机（VMs）出现之前，通常是将每个应用程序安装到共享主机上的不同目录中，每个应用程序都在单独的端口上提供服务。这带来了一些问题，因为各种应用程序在共享依赖项和机器资源（如CPU、内存和可用端口）时需要相互协作。这也可能难以扩展：如果您有一个应用程序突然接收了更多流量，您如何仅扩展该应用程序，而让其他应用程序保持不变？
- en: More recently, with VMs, the solution was to package each application into a
    VM of its own. In this way, each application has its own operating environment
    so that dependencies can be isolated and resources divided up and allocated. Since
    each VM has the complexity of an individual host, though, you now need to maintain
    the operating system and all packages for each application, which has high overheads
    and is complex to maintain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，随着虚拟机（VMs）的出现，解决方案是将每个应用程序打包成独立的虚拟机。这样，每个应用程序都有自己的操作系统环境，以便可以隔离依赖项并分配资源。然而，由于每个虚拟机都具有独立主机的复杂性，因此现在您需要为每个应用程序维护操作系统和所有包，这具有很高的开销且难以维护。
- en: This brings us to containers. Containers are a way to package just your application
    and its required dependencies for hosting in an isolated environment, much like
    a VM but without needing to install and manage an operating system with the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了容器。容器是一种将您的应用程序及其所需的依赖项打包到隔离环境中托管的方法，类似于虚拟机，但无需为应用程序安装和管理操作系统。
- en: Figure 1.1 illustrates the evolution of hosting services, from running multiple
    workloads on a single host, to running them on separate VMs, and, finally, containers.
    Containers provide many of the benefits of VMs but without the overheads of running
    another operating system kernel, making them the logical modern path forward.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1展示了托管服务的演变，从在单个主机上运行多个工作负载，到在单独的虚拟机上运行，最后到容器。容器提供了虚拟机的大部分优势，但无需运行另一个操作系统内核，这使得它们成为逻辑上的现代前进路径。
- en: '![01-01](../../OEBPS/Images/01-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![01-01](../../OEBPS/Images/01-01.png)'
- en: Figure 1.1 Evolution of shared hosting architectures
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 共享托管架构的演变
- en: 1.1.1 Container benefits
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 容器优势
- en: Some of the top reasons people choose containers are for the language flexibility
    (being able to run any language or environment on a container platform), lightweight
    isolation (protecting your workloads from interfering with each other without
    using VMs), developer efficiency (bringing production closer to development and
    allowing easy setup), and reproducibility (recording the steps used to create
    the environment in the container build file).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 人们选择容器的一些主要原因包括语言灵活性（能够在容器平台上运行任何语言或环境）、轻量级隔离（在不使用虚拟机的情况下保护工作负载免受彼此干扰）、开发者效率（将生产环境更接近开发环境并允许轻松设置）以及可重复性（在容器构建文件中记录创建环境的步骤）。
- en: Language flexibility
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 语言灵活性
- en: Containers unbind you from language or library requirements from your deployment
    systems. You can bring any language and update any package. No longer are you
    locked into specific languages and versions or stuck with some outdated version
    of a critical dependency that shipped in the operating system years ago, as you
    might be on a traditional platform as a service (PaaS).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使你摆脱了部署系统中的语言或库要求。你可以带来任何语言并更新任何包。你不再被锁定在特定的语言和版本中，或者被一些可能在操作系统几年前的版本中发货的关键依赖项所困扰，就像你可能在传统的平台即服务（PaaS）平台上一样。
- en: 'There are no shared libraries between two containers running on the same host,
    meaning the configuration of one will not interfere with the other. Need two different
    versions of Java or some random dependency? No problem. This isolation extends
    beyond just the libraries of the containers: each container can use a completely
    different base OS and package manager—for example, one using Ubuntu and APT, while
    another uses CentOS and RPM. This flexibility makes it simpler to potentially
    string together a system from multiple services (a pattern known as *microservices*),
    each maintained by separate teams, with their own dependencies or languages. Containers
    keep these different app dependencies isolated from each other, making it simple
    to run them all on the same host (figure 1.2).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一主机上运行的两个容器之间没有共享库，这意味着一个容器的配置不会干扰另一个。需要两个不同版本的Java或一些随机依赖项？没问题。这种隔离不仅限于容器的库：每个容器都可以使用完全不同的基础操作系统和包管理器——例如，一个使用Ubuntu和APT，而另一个使用CentOS和RPM。这种灵活性使得从多个服务（称为*微服务*的模式）中构建系统变得简单，每个服务由不同的团队维护，具有自己的依赖项或语言。容器将这些不同的应用程序依赖项相互隔离，使得在同一个主机上运行它们变得简单（图1.2）。
- en: '![01-02](../../OEBPS/Images/01-02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![01-02](../../OEBPS/Images/01-02.png)'
- en: Figure 1.2 Four containers with different languages sharing a host
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 具有不同语言的四个容器共享主机
- en: Isolation without overhead
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无开销的隔离
- en: In the past, to achieve isolation between multiple apps running on the same
    host, you would use VMs. VMs are heavier, both in image size and CPU/memory resource
    overhead, as the kernel and much of the OS are duplicated in each VM. While containers
    are lighter than VMs, they still offer most of the same resource isolation benefits.
    You can limit your containers on Kubernetes to use only some of the resources
    of the host, and the system will restrict them from using more. This ultimately
    means you can pack more applications onto a single host, reducing your infrastructure
    costs (figure 1.3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，为了在同一个主机上运行多个应用程序之间的隔离，你会使用虚拟机（VMs）。虚拟机在镜像大小和CPU/内存资源开销方面都比较重，因为每个虚拟机都会复制内核和大部分操作系统。虽然容器比虚拟机轻，但它们仍然提供了大部分相同的资源隔离优势。你可以在Kubernetes上将容器限制为仅使用主机的一些资源，系统将限制它们使用更多资源。这最终意味着你可以在单个主机上打包更多的应用程序，从而降低你的基础设施成本（图1.3）。
- en: '![01-03](../../OEBPS/Images/01-03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![01-03](../../OEBPS/Images/01-03.png)'
- en: Figure 1.3 Four containers running on the same host, fully isolated but sharing
    the kernel
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 在同一主机上运行的四个容器，完全隔离但共享内核
- en: Developer efficiency
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者效率
- en: What makes containers great for production by isolating dependencies also makes
    them great for development, as you can develop a myriad of applications on a single
    machine without needing to configure the host with the dependencies of each (figure
    1.4). In addition to developing Linux applications directly on Linux, with Docker
    you can use macOS or Windows workstations to develop a Linux container, without
    needing to create a version of the app that runs natively on those platforms,
    eliminating platform-specific configurations for development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使容器通过隔离依赖项在生产中变得出色的特性，也使它们在开发中变得出色，因为你可以在一台机器上开发无数的应用程序，而无需为每个应用程序配置主机的依赖项（图1.4）。除了直接在Linux上开发Linux应用程序外，使用Docker，你还可以使用macOS或Windows工作站来开发Linux容器，而无需为这些平台创建应用程序的原生版本，从而消除了开发中的平台特定配置。
- en: '![01-04](../../OEBPS/Images/01-04.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![01-04](../../OEBPS/Images/01-04.png)'
- en: Figure 1.4 A developer machine with two container-based projects
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 具有两个基于容器的项目的开发机器
- en: No longer do you need to have pages of setup instructions for developers to
    get started either, as setup is now as easy as installing Docker, checking out
    the code, building, and running. Working on multiple projects within a team or
    for different teams is now simple as well, as each project is nicely isolated
    in its container without needing a particular host configuration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您也不再需要为开发者提供大量的设置说明来开始工作，因为设置现在就像安装Docker、检出代码、构建和运行一样简单。在团队内部或为不同团队工作多个项目现在也变得简单，因为每个项目都很好地隔离在其容器中，无需特定的主机配置。
- en: With containers, your development and production app looks very similar and
    can be the exact same container—no more development-specific idiosyncrasies getting
    in the way, like MacOS having a different MySQL library or subtle differences
    in the way the code is packaged for production. Trying to diagnose a production
    problem? Download that exact container, run it against your development environment,
    and see what’s up (figure 1.5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器，您的开发和生产应用程序看起来非常相似，甚至可以是完全相同的容器——不再有开发特定的特性阻碍，比如MacOS有不同的MySQL库或代码打包生产时的微妙差异。试图诊断生产问题？下载那个确切的容器，在您的开发环境中运行它，看看出了什么问题（图1.5）。
- en: '![01-05](../../OEBPS/Images/01-05.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![01-05](../../OEBPS/Images/01-05.png)'
- en: Figure 1.5 The same container being deployed in the production and development
    environments
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 同一个容器在生产环境和开发环境中的应用
- en: Reproducibility
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可重现性
- en: Containers make it easier to reproduce your application environment as well.
    Imagine you have a VM on which your application is deployed, and you need to configure
    Transport Layer Security (TLS) for secure HTTPs connections. You SSH into the
    production host, and add the TLS certificates to a folder. It didn’t work, so
    you add them to another folder. Soon they’re in three folders, and it’s working
    so you don’t touch it. A year later, you need to update the TLS certificate. Can
    you remember how, and which of the three locations needs to be updated?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还使您更容易重现应用程序环境。想象一下，您有一个部署了应用程序的虚拟机，您需要为安全的HTTPs连接配置传输层安全性（TLS）。您通过SSH连接到生产主机，并将TLS证书添加到一个文件夹中。它不起作用，所以您将其添加到另一个文件夹。很快，它们就在三个文件夹中，而且它开始工作了，所以您没有去动它。一年后，您需要更新TLS证书。您能记得如何操作，以及三个位置中的哪一个需要更新吗？
- en: Containers solve this. Rather than SSHing and tweaking the state, you would
    add the TLS certificate as a build step in the container. If it didn’t work, you’d
    tweak that build step until it does but, crucially, only keep the step (or steps)
    that actually do work. The files added in this step are also nicely isolated from
    the rest of the system, so essentially you’re capturing the delta, or differences,
    over the base system—just those modifications you needed to make. This means that
    a year later when you need to update the certificate, you just replace the certificate
    file and rerun the container build, and it will put it in the right place.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器解决了这个问题。而不是通过SSH和调整状态，您会在容器中添加TLS证书作为构建步骤。如果不起作用，您会调整那个构建步骤直到它起作用，但关键是要只保留真正起作用的步骤（或步骤）。在这个步骤中添加的文件也很好地与系统其他部分隔离，所以本质上您是在捕捉基于系统的增量，或差异——只是您需要做的那些修改。这意味着一年后当您需要更新证书时，您只需替换证书文件并重新运行容器构建，它就会放在正确的位置。
- en: The following listing provides a pseudocode example of a Dockerfile—that is,
    the code to configure the container expressed in plain English (in chapter 2,
    we’ll use some real ones).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表提供了一个Dockerfile的伪代码示例——即用纯英语表达的配置容器的代码（在第2章中，我们将使用一些真实的例子）。
- en: Listing 1.1 Chapter01/1.1.1_Pseudocode Dockerfile
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 第一章/1.1.1_伪代码 Dockerfile
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note Docker as a tool for creating containers isn’t perfect for reproducibility.
    Commands like `apt-get` to install a dependency operate on a live system, so you
    won’t actually get the same output for the same input, as those dependent systems
    (like the APT repository) may have changed between builds. Tools like Bazel, open-sourced
    by Google, are designed to solve this problem and more but come with their own
    complexities and are more recommended for sophisticated enterprise deployments.
    Despite this limitation, Docker’s build system is still a heck of a lot more reproducible
    than trying to remember what you did a year ago when you SSHed into that Linux
    box to fix a problem, and it is good enough for most projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将Docker作为创建容器的工具并不完美地适用于可重复性。例如，使用`apt-get`安装依赖项的命令是在一个实时系统上运行的，因此你实际上不会为相同的输入获得相同的输出，因为那些依赖系统（如APT仓库）可能在构建之间发生了变化。像Bazel这样的工具，由谷歌开源，旨在解决这个问题以及更多，但它们也带来了自己的复杂性，并且更推荐用于复杂的企业部署。尽管存在这种限制，但Docker的构建系统仍然比试图回忆一年前当你通过SSH连接到那个Linux盒子来修复问题时所做的事情要强得多，而且对于大多数项目来说已经足够好了。
- en: 1.2 Why Kubernetes?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 为什么选择Kubernetes？
- en: If containers sound like a great idea for packaging your application, you’ll
    still need a way to actually run and manage those containers. Sure, you could
    just run a container or a handful of containers on each host in much the same
    way it is possible to run a bunch of different applications from folders or VM
    images, but operating like this tends to create special snowflakes of machines
    and limits your ability to scale due to the high-touch required to configure and
    manage hosts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器听起来像是一个打包您应用程序的好主意，你仍然需要一种实际运行和管理这些容器的方法。当然，你可以在每个主机上运行一个或几个容器，就像从文件夹或虚拟机镜像中运行多个不同的应用程序一样，但以这种方式运行往往会创建特殊的机器，并限制了你的扩展能力，因为配置和管理主机需要大量的手动操作。
- en: A better option is to have a shared pool (cluster) of machines (nodes) and use
    a so-called container orchestrator (like Kubernetes) to run your containers on
    this resource pool. In this way, machines are managed together as a group, where
    none need to be ascribed any special meaning. Should one fail, another will be
    there to pick up the slack. This pattern gets you out of the individual-machine
    business and allows you to scale your application faster than your team size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是拥有一个共享的机器（节点）池（集群），并使用所谓的容器编排器（如Kubernetes）来运行资源池上的容器。这样，机器作为一个组一起管理，其中没有任何一个需要赋予任何特殊意义。如果其中一个失败了，另一个会来填补空缺。这种模式让你摆脱了单机业务，并允许你比团队规模更快地扩展你的应用程序。
- en: Previously, systems that could flexibly orchestrate containers at scale were
    the domain of large companies. Kubernetes—in particular, managed Kubernetes offerings
    on public clouds—makes this operations model accessible to deployments of all
    sizes, from a single container application running on one machine to a set of
    microservices, each published by a different team running on a 15,000-machine
    behemoth.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，能够在大规模上灵活编排容器的系统是大型公司的专属。特别是，公共云上的托管Kubernetes服务使得这种操作模式对所有规模的项目都变得可访问，从在一台机器上运行的单个容器应用程序到由不同团队在15000台机器的巨兽上运行的多个微服务集合。
- en: Kubernetes also makes it easy to achieve *high availability* for your applications.
    As illustrated in figure 1.6, we can deploy the same service across multiple availability
    zones, where the loss of an entire zone would not result in downtime. With a manual
    deployment system, this can be complex, but we can achieve such deployment patterns
    rapidly in Kubernetes by simply defining what we want to see (in this case, containers
    spread over multiple zones). Section 8.2.1 covers this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还使得为您的应用程序实现高可用性变得容易。如图1.6所示，我们可以在多个可用区部署相同的服务，即使整个区域丢失也不会导致停机。使用手动部署系统，这可能很复杂，但我们可以通过简单地定义我们想要看到的内容（在这种情况下，跨多个区域的容器）在Kubernetes中快速实现这种部署模式。第8.2.1节对此进行了介绍。
- en: '![01-06](../../OEBPS/Images/01-06.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![01-06](../../OEBPS/Images/01-06.png)'
- en: Figure 1.6 A Kubernetes cluster operating in three zones, managing four services
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 一个在三个区域中运行的Kubernetes集群，管理四个服务
- en: 'The best part is that updating a service in Kubernetes requires a single line
    of config to be changed, and Kubernetes will handle the rollout of the update
    to each of the zones for you, per your requirements. Updates to the Kubernetes
    platform itself happen in a similar, automated fashion (provided you are using
    a managed platform, which handles this), where nodes are replaced gradually with
    updated versions, and your workload is migrated to avoid downtime. If your app
    isn’t big enough to require a high-availability multizone deployment, fear not:
    Kubernetes can run at a small scale too, with the added benefit that you can scale
    up when you need.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，在 Kubernetes 中更新服务只需要更改一行配置，Kubernetes 会根据你的要求自动将更新部署到每个区域。Kubernetes
    平台本身的更新也以类似、自动化的方式进行（前提是你使用的是托管平台，它会处理这一点），节点会逐渐被更新版本所取代，你的工作负载会被迁移以避免停机。如果你的应用程序规模不大，不需要高可用性的多区域部署，无需担心：Kubernetes
    也可以在小规模上运行，并且当你需要时可以扩展。
- en: Kubernetes has gained popularity as it automates much of the operational aspects
    of scheduling and running containers on a pool of resources and provides the level
    of abstraction to developers that seems to have hit the sweet spot. It isn’t so
    low level that you are worried about individual machines, while also not being
    so high level as to constrain what workloads you can deploy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 因其自动化了在资源池上调度和运行容器的许多操作方面而受到欢迎，并为开发者提供了看似恰到好处的抽象级别。它既不是那么低级，以至于你担心单个机器，同时也不是那么高级，以至于限制了你可以部署的工作负载。
- en: 1.2.1 Composable building blocks
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 可组合的构建块
- en: In Kubernetes, containers are grouped into what are called *Pods*. A Pod is
    simply a set of containers that get scheduled together and treated as a single
    unit. Quite often, a Pod is just a single container, but it could be multiple
    containers in the case where your app consists of multiple connected parts. Conceptually,
    the Pod is your application and its dependencies. Services are used to provide
    connectivity to groups of Pods, both internally within the cluster and externally.
    Figure 1.7 illustrates the resources of a typical app deployed to a Kubernetes
    cluster.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，容器被分组为所谓的 *Pods*。Pod 简单地是一组被一起调度并被视为单一单元的容器。通常，Pod 只是一个容器，但在你的应用程序由多个连接部分组成的情况下，它也可能是多个容器。从概念上讲，Pod
    是你的应用程序及其依赖项。服务用于向 Pod 组提供连接性，无论是在集群内部还是外部。图 1.7 展示了部署到 Kubernetes 集群中的典型应用程序的资源。
- en: '![01-07](../../OEBPS/Images/01-07.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![01-07](../../OEBPS/Images/01-07.png)'
- en: Figure 1.7 A Kubernetes cluster with several VMs running two different application
    containers, exposed with load balancing
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 一个运行着两个不同应用容器的 Kubernetes 集群，通过负载均衡暴露
- en: Kubernetes has several higher-order workload constructs, described throughout
    this book, that encapsulate Pods. For a stateless application, you will create
    a *Deployment* object that wraps the Pod definition (specifying your container
    versions), where you specify how many replicas (instances) you want. In all these
    cases, Kubernetes will do the heavy lifting of finding space in your cluster to
    place the Pods according to your requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有几个更高阶的工作负载构建块，本书中会对其进行描述，这些构建块封装了 Pods。对于无状态应用程序，你会创建一个 *Deployment*
    对象，它封装了 Pod 定义（指定你的容器版本），在这里你指定你想要多少个副本（实例）。在这些所有情况下，Kubernetes 会为你完成繁重的任务，在集群中找到空间来放置
    Pods，以满足你的要求。
- en: 'The range of workload types you can describe in Kubernetes configuration is
    wide and varied and includes the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Kubernetes 配置中描述的工作负载类型范围广泛，包括以下内容：
- en: Stateless applications
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态应用程序
- en: Databases and other applications with persistent state
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有持久状态的数据库和其他应用程序
- en: Applications formerly configured in a VM
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前在虚拟机中配置的应用程序
- en: A batch process you wish to run at a certain schedule
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望按特定时间表运行的批处理过程
- en: A batch task you want to run once, like training a machine learning model
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要一次性运行的批处理任务，例如训练机器学习模型
- en: In all cases, the applications are containerized and grouped in Pods, and you
    describe to Kubernetes in configuration files how you want your workload to be
    run.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，应用程序都被容器化并分组在 Pods 中，你通过配置文件向 Kubernetes 描述你想要如何运行你的工作负载。
- en: 1.2.2 Features and benefits
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 特性和优势
- en: In this section, we will discuss some of the top reasons why people choose Kubernetes
    to deploy their containers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些人们选择 Kubernetes 来部署他们的容器的主要原因。
- en: Automated operations
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化操作
- en: Provided you configure your deployment correctly, Kubernetes will automate various
    operational aspects for you. Processes running on the node restart containers
    that crash, while liveness and readiness probes continue to monitor the container’s
    health and ability to serve live traffic. Pod autoscalers can be configured on
    your deployments to automatically increase the number of replicas based on metrics
    like utilization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 只要正确配置你的部署，Kubernetes就会为你自动化各种操作方面。在节点上运行的进程会重新启动崩溃的容器，同时存活性和就绪性探针会继续监控容器的健康和提供实时流量的能力。你可以在部署上配置Pod自动扩展器，根据如利用率等指标自动增加副本的数量。
- en: 'Kubernetes itself doesn’t repair compute node-level problems. However, you
    can choose a managed platform that will provide such automation. Take, for example,
    the Autopilot mode of Google Kubernetes Engine: it automatically provisions the
    compute capacity for your Pods, scaling up and down automatically as you change
    your replica count, and will repair and upgrade nodes as needed.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes本身不会修复计算节点级别的问题。然而，你可以选择一个提供此类自动化的托管平台。以Google Kubernetes Engine的Autopilot模式为例：它会自动为你的Pods提供计算能力，根据你更改副本数量的情况自动扩展和缩减，并在需要时修复和升级节点。
- en: High scalability
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 高可扩展性
- en: No matter the size of your application, you will want to think about how it
    will scale. Whether you are deploying a huge enterprise application or you are
    a bootstrapped startup, you will need a solution that can scale as you do. The
    time when you need to scale is not the time to start thinking about how you are
    going to scale!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的应用程序大小如何，你都需要考虑它如何进行扩展。无论是部署一个大型企业级应用程序，还是你是一个自筹资金的初创公司，你都需要一个能够随着你一起扩展的解决方案。当你需要扩展的时候，并不是开始思考你将如何扩展的时候！
- en: It is hard enough to create a successful product; the last thing you want in
    your moment of success—when everyone is beating down your door trying to use your
    product—is for your application to go offline. At that moment, and perhaps even
    in the months and years to come, you’re likely not going to be able to completely
    re-architect your application for scale.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创造一个成功的产品已经足够困难；在你成功的时刻——当每个人都试图使用你的产品而敲你的门时——你最不希望看到的是你的应用程序离线。在那个时刻，甚至在未来几个月和几年里，你可能无法完全重新架构你的应用程序以实现扩展。
- en: Kubernetes can handle applications of any size. You can have a single-node cluster
    with a single CPU and a bunch of memory or a multi-thousand-node behemoth like
    the 10s of thousands of cores Niantic used to run Pokémon Go when it launched.[⁵](#pgfId-1063250)
    Of course, your application itself will need to have properties that enable it
    to scale, and so will any dependencies, particularly database ones, but at least
    you can rest assured that your compute platform will scale as you do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以处理任何大小的应用程序。你可以有一个单节点集群，只有一个CPU和大量内存，或者一个多千节点的巨兽，就像Niantic在推出Pokémon
    Go时使用的拥有数万个核心。当然，你的应用程序本身需要具有使其能够扩展的特性，以及任何依赖项，尤其是数据库依赖项，但至少你可以放心，你的计算平台会随着你一起扩展。
- en: Workload abstraction
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载抽象
- en: Abstraction layers are great, until they aren’t. It is a challenge to find tools
    that abstract away precisely those things you do not want to care about, without
    hiding details you do care about. But, in my experience, Kubernetes comes the
    closest to achieving exactly that.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层是很好的，直到它们不是。找到工具来抽象你不想关心的事情，同时不隐藏你关心的细节，这是一个挑战。但是，根据我的经验，Kubernetes最接近于实现这一点。
- en: Infrastructure as a service (IaaS) is a hardware-level abstraction. Rather than
    interacting with actual machines with spinning disks and network cards, you interact
    with an API that provides software that implements those same interfaces.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即服务（IaaS）是硬件级别的抽象。你不需要与实际带有旋转磁盘和网络卡的机器交互，而是与一个提供实现相同接口的软件的API进行交互。
- en: Kubernetes, by comparison, is a workload-level abstraction. Meaning that you
    describe your application in workload terms. For example, I have a server that
    needs to run in a distributed fashion; I have a database that requires certain
    disk volumes to be attached; I have a logging utility that needs to run on every
    node; or maybe I have a movie to render, one frame at a time, on the cheapest
    resources available. All these deployment constructs and more can be represented
    natively in Kubernetes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，Kubernetes是一个工作负载级别的抽象。这意味着你用工作负载术语描述你的应用程序。例如，我有一个需要以分布式方式运行的服务器；我有一个需要连接特定磁盘卷的数据库；我有一个需要在每个节点上运行的日志工具；或者也许我有一个电影需要渲染，一次渲染一帧，在可用的最便宜的资源上。所有这些部署结构和更多都可以在Kubernetes中本地表示。
- en: 'Kubernetes provides a layer above compute instances (VMs), freeing you from
    the need to manage or care about individual machines. You specify what resources
    your container needs: CPU, memory, disk, GPU, etc. A managed Kubernetes platform
    will also typically provision the compute capacity to handle your workloads. You
    don’t need to worry about individual machines, but you can still do things that
    you would expect at a machine level, like write to a persistent local disk, tasks
    that until recently were often not possible at this level of abstraction.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在计算实例（虚拟机）之上提供了一个层，让你无需管理或关心单个机器。你指定你的容器需要哪些资源：CPU、内存、磁盘、GPU等。一个管理的Kubernetes平台通常也会提供计算能力来处理你的工作负载。你不需要担心单个机器，但仍然可以做一些你期望在机器级别做的事情，比如写入持久性本地磁盘，这些任务直到最近在这个抽象级别通常是不可能的。
- en: The abstraction layer also remains quite clean by not interfering with your
    application (figure 1.8). Unlike many traditional PaaS environments, Kubernetes
    does not modify how your app runs; for example, no code is injected or changed,
    and very few restrictions are placed on what your app can do. If the app can be
    run in a container, then it can likely be run on Kubernetes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层通过不干扰你的应用程序（图1.8）而保持相当干净。与许多传统的PaaS环境不同，Kubernetes不会修改你的应用程序的运行方式；例如，没有代码被注入或更改，对应用程序可以做什么的限制也非常少。如果应用程序可以在容器中运行，那么它很可能可以在Kubernetes上运行。
- en: '![01-08](../../OEBPS/Images/01-08.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![01-08](../../OEBPS/Images/01-08.png)'
- en: Figure 1.8 Illustration of the separation of concerns between the different
    compute layers
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 不同计算层之间关注点分离的示意图
- en: Declarative configuration
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式配置
- en: Kubernetes uses a declarative resource model. You describe your workload in
    the configuration (primarily YAML files), and the system strives to enact your
    configuration and make it a reality. For example, if, in the Deployment, you specify
    that you want three replicas (copies) of your application connected by a load
    balancer to the outside world, Kubernetes will find space in your cluster to run
    those three replicas and attach a load balancer. Not only does Kubernetes place
    these replicas initially, but it will continue to monitor them and attempt to
    keep them running in the event of a crash or failure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用声明式资源模型。你在配置（主要是YAML文件）中描述你的工作负载，系统会努力执行你的配置并使其成为现实。例如，如果在Deployment中你指定你想要三个由负载均衡器连接到外部世界的应用副本（复制品），Kubernetes将在你的集群中找到空间来运行这三个副本并附加一个负载均衡器。Kubernetes不仅最初放置这些副本，而且它将继续监控它们，并在发生崩溃或故障的情况下尝试保持它们运行。
- en: A declarative configuration is useful because it allows you to describe what
    your desired state is (e.g., run three copies of my application) and lets Kubernetes
    do the work of actually producing that state, as opposed to issuing imperative
    commands (e.g., create three copies of my application) and doing the monitoring
    and adjusting yourself (like querying how many copies of my application are currently
    running and adjusting accordingly).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式配置很有用，因为它允许你描述你希望的状态（例如，运行我的应用程序的三个副本）并让Kubernetes完成实际产生该状态的工作，而不是发出命令式命令（例如，创建我的应用程序的三个副本）然后你自己进行监控和调整（比如查询当前运行的应用程序副本数量并相应调整）。
- en: Cost efficiency
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 成本效益
- en: Kubernetes takes the lowest-level compute building blocks (VMs) and makes them
    easy to manage. Whereas in the past, you might have assigned one app per VM for
    maintenance reasons, Kubernetes allows you to efficiently host multiple instances
    of an app or apps on a single machine for high efficiency (so-called bin-packing).
    The combination of using commodity building blocks (raw compute nodes) with robust
    orchestration of the workloads often makes Kubernetes attractive from a price
    perspective.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将最低层的计算构建块（虚拟机）进行管理，使其变得易于管理。在过去，你可能出于维护原因，每个虚拟机分配一个应用程序，而Kubernetes允许你在一个机器上高效地托管多个应用程序实例或应用程序，以实现高效率（所谓装箱）。使用通用构建块（原始计算节点）与强大的工作负载编排相结合，通常从价格角度使Kubernetes具有吸引力。
- en: Beyond bin-packing, resource pooling is another benefit of Kubernetes that improves
    efficiency. Your workloads can be configured in a way where they have a set amount
    of guaranteed resources and, when there’s a usage spike, utilize the capacity
    that other containers have reserved but are not currently using.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了装箱之外，资源池也是Kubernetes的另一个好处，可以提高效率。你可以配置你的工作负载，使其具有一定数量的保证资源，当出现使用高峰时，利用其他容器已预留但尚未使用的容量。
- en: Extensibility
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性
- en: When you need to do something that Kubernetes can’t, you can source or even
    write your own Kubernetes-style API to implement it. This isn’t for everyone and
    definitely isn’t needed to deploy most workloads like stateless or stateful web
    applications, but it can be extremely handy when you need to add particular business
    logic or some new construct that Kubernetes doesn’t support. The custom resource
    definition object and operator patterns allow you to create your own Kubernetes-style
    APIs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要做Kubernetes无法做到的事情时，你可以获取或甚至编写自己的Kubernetes风格的API来实现它。这并不是针对每个人，而且绝对不是部署大多数工作负载（如无状态或有状态Web应用程序）所必需的，但当你需要添加特定的业务逻辑或Kubernetes不支持的新结构时，它可能非常有用。自定义资源定义对象和操作符模式允许你创建自己的Kubernetes风格的API。
- en: Open source
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 开源
- en: Kubernetes is open source and available on all major clouds as a managed offering.
    Despite the proliferation of many different platforms, distributions, and installers,
    most such offerings have been certified under the Cloud Native Computing Foundation’s
    certification program,[⁶](#pgfId-1063286) which offers several guarantees around
    workload portability and compatibility. In fact, the only way for a product to
    include the name *Kubernetes* in it (as in Google Kubernetes Engine) is to have
    formally passed these tests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是开源的，并且作为托管服务在所有主要云平台上提供。尽管存在许多不同的平台、发行版和安装程序，但大多数此类服务都通过了云原生计算基金会认证计划[⁶](#pgfId-1063286)的认证，该计划围绕工作负载的可移植性和兼容性提供了一些保证。实际上，一个产品要包含名称*Kubernetes*（例如Google
    Kubernetes Engine），唯一的方法是正式通过这些测试。
- en: You can also run Kubernetes yourself from scratch. And if you do run Kubernetes
    yourself, then the quality of the code will matter to you. Not all open source
    is created equal. While open source does typically remove you from propriety lock-in,
    you might end up having to maintain it yourself (you use it, you own it) unless
    there is a strong community. The exception is for large, well-maintained open
    source projects of the caliber of, say, Linux, where so many people depend on
    it and so many people use it that you can rest assured you won’t need to take
    over maintenance. Fortunately, Kubernetes, as the leading open source container
    orchestrator, fits into this category.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从头开始自己运行Kubernetes。如果你自己运行Kubernetes，那么代码的质量对你来说很重要。并非所有开源项目都是平等的。虽然开源通常可以让你摆脱专有锁定，但除非有一个强大的社区，否则你可能会发现自己需要自己维护它（你使用它，你就拥有它）。例外是像Linux这样的大型、维护良好的开源项目，如此多的人依赖它，如此多的人使用它，以至于你可以放心，你不需要接管维护。幸运的是，作为领先的开放源代码容器编排器，Kubernetes属于这一类别。
- en: TIP While it is possible to host Kubernetes yourself, whether on a public cloud
    or on a cluster of Raspberry Pis, I don’t recommend this approach for production
    use (i.e., outside of learning how to manage a cluster) in most cases. Spend the
    time doing what you do best—building great applications—and let someone else handle
    the minutiae of running Kubernetes for you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：虽然你可以在公共云或树莓派集群上自己托管Kubernetes，但我通常不推荐这种做法用于生产环境（即除了学习如何管理集群之外的情况）。花时间做你最擅长的事情——构建出色的应用程序——并让其他人帮你处理运行Kubernetes的细节。
- en: Beyond the project itself being open source, Kubernetes is surrounded by a vibrant
    community. There are open source tools for accomplishing pretty much anything,
    so you typically have the option to go with a managed service or deploy an open
    source tool yourself. This is a break from proprietary-only marketplaces in PaaS
    systems of the past, where your only option for any type of component was a paid
    one. Do you get value from a managed monitoring tool? Use a proprietary product.
    Want to just manage it yourself? Go install open source Prometheus. Kubernetes
    has a large and growing number of practitioners as well, so whatever the topic
    is, you should be able to find help on Stack Overflow or in books like this one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目本身是开源的，Kubernetes 还有一个充满活力的社区。有开源工具可以完成几乎所有的事情，所以你通常可以选择使用托管服务或自己部署开源工具。这与过去
    PaaS 系统中仅有的专有市场形成对比，在那里，任何类型的组件的唯一选择都是付费的。你是否从托管监控工具中获得了价值？使用专有产品。只想自己管理？去安装开源的
    Prometheus。Kubernetes 拥有大量不断增长的使用者，所以无论是什么主题，你都应该能在 Stack Overflow 或像这本书这样的书中找到帮助。
- en: Customized workflows
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定制化工作流程
- en: Kubernetes is very unopinionated about how you set up development workflows.
    Want a “git push to deploy” style workflow? There are a bunch of ways to do that,
    some with only minimal setup. Typically, you’ll start with a bunch of CI/CD building
    blocks, which you assemble into your desired workflow, from simple push-to-deploy
    to complex pipelines with admissions control, auto-injecting secrets, and security
    scanning. The downside is that it’s not quite as ready to use out of the box as,
    say, a traditional PaaS, but this book will show you it’s not *that* hard to get
    started.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 对如何设置开发工作流程持中立态度。想要“git push 即部署”风格的流程？有很多种方法可以实现，其中一些只需要最少的设置。通常，你会从一系列
    CI/CD 构建块开始，将它们组装成你想要的流程，从简单的推送部署到具有准入控制、自动注入密钥和安全扫描的复杂管道。缺点是它不像传统的 PaaS 那样即买即用，但本书将向你展示它并非*那么*难上手。
- en: Particularly for larger teams, the flexibility provided by Kubernetes in this
    area is often a huge advantage. Companies with a central core platforms team will
    create opinionated pipelines for their application developer teams to use. The
    pipeline can be used to ensure certain development practices around things like
    security, resource usage, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其对于大型团队来说，Kubernetes 在这个领域提供的灵活性通常是一个巨大的优势。拥有中央核心平台团队的公司将为他们的应用程序开发团队创建有观点的管道。这个管道可以用来确保围绕安全、资源使用等方面的一些开发实践。
- en: 1.2.3 Kubernetes vs. platforms as a service
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 Kubernetes 与平台即服务（PaaS）的比较
- en: Another approach to application deployment is to use a PaaS. A PaaS makes it
    easy to deploy your application code at scale by taking care of a lot of the packaging
    and deployment aspects for you. As long as your application fits within the scope
    of what the PaaS offers in terms of languages, dependencies, how it handles state,
    etc., you can launch each application into the PaaS and not worry about the machines
    underneath.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序部署的另一种方法是使用 PaaS。PaaS 通过为你处理大量的打包和部署方面，使大规模部署应用程序代码变得容易。只要你的应用程序在语言、依赖项、如何处理状态等方面符合
    PaaS 提供的范围，你就可以将每个应用程序部署到 PaaS 中，而不必担心底下的机器。
- en: However, what happens when you need to highly customize your dependencies, like
    using a specific version of Java? Can you host a stateful backend alongside your
    stateless frontends? And is it cost-effective when you have many applications,
    each needing many replicas? At a certain point, the limitations of a PaaS can
    be prohibitive, and once you move out of the PaaS world, you have to start over
    from scratch—a daunting prospect.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你需要高度定制依赖项时，比如使用特定版本的 Java，会发生什么？你能否在无状态的前端旁边托管有状态的后端？当你有多个应用程序，每个都需要许多副本时，这是否具有成本效益？在某个点上，PaaS
    的局限性可能会变得阻碍重重，一旦你离开了 PaaS 世界，你就必须从头开始——这是一个令人畏惧的前景。
- en: A traditional PaaS is often fast to learn but slows down as you mature, and
    there’s a potential cliff if you exceed the capabilities of the system and need
    to start from scratch. Kubernetes has a slower learning curve at the beginning
    but expansive possibilities as you grow (figure 1.9).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 PaaS 通常学习速度快，但随着你的成熟，速度会减慢，如果你超出了系统的功能，需要从头开始，可能会遇到一个潜在的悬崖。Kubernetes 的学习曲线在开始时较慢，但随着你的成长，可能性却很广泛（图
    1.9）。
- en: '![01-09](../../OEBPS/Images/01-09.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![01-09](../../OEBPS/Images/01-09.png)'
- en: Figure 1.9 Developer efficiency using a traditional PaaS and Kubernetes
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 使用传统 PaaS 和 Kubernetes 提高开发者效率
- en: If you’re using a PaaS and everything is going great, there may not be a need
    to move to Kubernetes. However, a common problem I’ve seen is that teams hit a
    certain level of complexity where their requirements exceed what the PaaS is capable
    of. One of the scariest things about being in that position is that you can’t
    simply “break the glass” and assume more control yourself. Often, you’ll need
    to re-architect the entire system, losing even the bits you were happy with, to
    build the new parts that you need. In this book, I’ll show you how Kubernetes
    can run PaaS-type workloads with marginal added complexity over a dedicated PaaS,
    as well as how to run various other workload constructs like stateful workloads,
    background processing, and batch jobs, which set you up for success in the future
    by enabling you to implement more complex product requirements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用PaaS并且一切都很顺利，可能没有必要迁移到Kubernetes。然而，我常见的一个问题是，团队达到一定程度的复杂性，他们的需求超过了PaaS的能力。处于这种位置的最可怕的事情之一是你不能简单地“打破玻璃”并假设自己有更多的控制权。通常，你需要重新架构整个系统，甚至失去你原本满意的部分，来构建你需要的新部分。在这本书中，我将向你展示Kubernetes如何以比专用PaaS略高的复杂性运行PaaS类型的工作负载，以及如何运行各种其他工作负载结构，如具有状态的工作负载、后台处理和批处理作业，这些都可以通过使你能够实现更复杂的产品需求来为你未来的成功奠定基础。
- en: A word on simplicity
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性一词
- en: I like to say, be wary of tools that make the simple easier but the complex
    harder. Sure, it’s nice when something helps you get up and running sooner, but
    is it leaving you in a good state, with the right knowledge and tools to get the
    job done? Kubernetes is easy enough to get started on, while being powerful enough
    to serve your needs as you grow and expand. When choosing your platforms, prioritize
    making hard tasks possible over making simple tasks even easier.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢说，要警惕那些让简单的事情更容易但让复杂的事情更难的工具。当然，当某件事能帮助你更快地上手时，那很好，但它是否让你处于良好的状态，拥有完成工作的正确知识和工具？Kubernetes足够简单，可以开始使用，同时足够强大，可以满足你随着成长和扩展的需求。在选择你的平台时，优先考虑使复杂任务成为可能，而不是使简单任务变得更加容易。
- en: Kubernetes will enable you to run a simple, 12-factor stateless application;
    migrate over a bespoke stateful custom application previously installed on a VM;
    or even run your own database. The abstraction layer doesn’t limit what you can
    do, while still allowing you to get started using only the bits you need at first.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将使你能够运行一个简单的、12因素无状态应用程序；迁移之前安装在虚拟机上的定制状态应用程序；甚至运行你自己的数据库。抽象层不会限制你可以做什么，同时仍然允许你只使用最初需要的部分来开始。
- en: 'Some more modern PaaSs support containers, so you could run there and get the
    best of both worlds: the flexibility of containers with easy deployments. A downside
    is that even modern PaaSs come with many restrictions on the types of workloads
    you can run. Can it, for example, run a stateful application with a block-based
    volume attached, as you might need if you have a legacy application to migrate,
    or run a bespoke database where no managed offering exists? I suggest you carefully
    consider your current and future needs and choose a platform that will be able
    to grow and scale as you do.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更现代的PaaS支持容器，因此你可以在那里运行并享受到两者的最佳结合：容器的灵活性和易于部署。一个缺点是，即使是现代的PaaS也对你可以运行的工作负载类型有许多限制。例如，它能否运行一个带有基于块的卷的具有状态的应用程序，就像你需要迁移遗留应用程序时可能需要的那样？或者运行一个没有托管服务存在的定制数据库？我建议你仔细考虑你当前和未来的需求，并选择一个能够随着你的成长而扩展的平台。
- en: 1.2.4 When (not) to use Kubernetes
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 何时（不）使用Kubernetes
- en: Like most tools, the goal of Kubernetes is to improve your efficiency—in this
    case, managing your application deployments. It’s best to ignore the hype and
    really consider whether Kubernetes will help or hinder your ability to run your
    service. Managed Kubernetes platforms exist to keep your cluster components running
    smoothly, but be aware that there is some overhead to running a general-purpose
    platform like Kubernetes. Operational tasks include allocating CPU and memory
    resources to containers, updating deployments, configuring your network, and keeping
    everything up to date without disrupting your running services.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数工具一样，Kubernetes的目标是提高你的效率——在这种情况下，管理你的应用程序部署。最好忽略炒作，真正考虑Kubernetes是否会帮助你或阻碍你运行服务的能力。托管Kubernetes平台存在是为了保持你的集群组件平稳运行，但请注意，运行像Kubernetes这样的通用平台有一些开销。操作任务包括为容器分配CPU和内存资源、更新部署、配置你的网络，以及在不中断运行服务的情况下保持一切更新。
- en: If you can predict the exact scope of your business requirements now and in
    the future and don’t need the flexibility that Kubernetes provides, don’t care
    about the vendor portability of the Kubernetes ecosystem, and can fit your application
    architecture neatly into the expectations of a more special-purpose platform,
    then go ahead and use it instead! Honestly, you’ll probably have a simpler time
    of it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在和未来都能准确预测业务需求的确切范围，并且不需要 Kubernetes 提供的灵活性，不关心 Kubernetes 生态系统的供应商可移植性，并且可以将您的应用程序架构完美地适应更特殊用途平台的期望，那么请继续使用它！说实话，您可能会更容易一些。
- en: I don’t generally recommend using Kubernetes for deployments of software where
    fully-managed equivalents exist. For example, why run a SQL database in Kubernetes
    when your cloud provider can do that for you? There are some exceptions where
    it becomes desirable to self-manage, but, in general, I believe if the managed
    service exists, you should use it!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不推荐在存在完全托管等效软件的情况下使用 Kubernetes 进行部署。例如，为什么要在 Kubernetes 中运行 SQL 数据库，当您的云提供商可以为您做这件事时？有些情况下，自我管理变得令人向往，但总的来说，我相信如果托管服务存在，您应该使用它！
- en: Kubernetes *is* really good at a few things, though, like running stateless
    applications at high density; mixing multiple workloads like a modern stateless
    application and legacy stateful monolith; migrating services from outdated systems
    to a unified platform; handling high-performance compute, like batch processing
    jobs for data analytics and machine learning; and, of course, running a bunch
    of microservices. In each of these cases, Kubernetes brings a lot to the table
    by enabling high efficiency, unifying your hosting platform, automating your systems,
    and running your batch jobs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Kubernetes 在一些事情上确实非常出色，比如在高密度下运行无状态应用程序；混合多个工作负载，如现代无状态应用程序和遗留有状态单体；将服务从过时的系统迁移到统一平台；处理高性能计算，如数据分析和机器学习的批处理作业；当然，运行大量微服务。在这些情况下，Kubernetes
    通过提高效率、统一您的托管平台、自动化您的系统以及运行您的批处理作业，带来了很多好处。
- en: Kubernetes does introduce a new level of management overhead, which needs to
    be considered. There’s a risk of simply replacing one problem with another if
    you take what you’re doing (assuming it’s working well) and throw it onto Kubernetes.
    Some cases where you may want to consider carefully would be replacing a stateless
    platform *if* it’s already handling your requirements and moving standardized
    stateful workloads that have well-established deployment patterns like SQL databases.
    While you may see benefits in Kubernetes for such workloads, the advantages may
    not be as many, and so the tradeoff needs to be more carefully considered.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 确实引入了新的管理开销级别，这需要考虑。如果您将当前正在进行的操作（假设它运行良好）直接扔到 Kubernetes 上，可能会简单地用另一个问题替换一个问题。您可能需要仔细考虑的情况包括：如果无状态平台已经满足您的需求，那么替换它；以及移动具有良好建立部署模式的标准有状态工作负载，如
    SQL 数据库。虽然您可能会在 Kubernetes 中看到这样的工作负载的好处，但优势可能不会那么多，因此权衡需要更加仔细地考虑。
- en: To help decide, I suggest weighing the benefits of moving to containers and
    unifying your compute platform around one deployment system suitable for varied
    workloads, with the added knowledge needed to administer Kubernetes. If what you’re
    starting with is a bunch of services running on bespoke VMs in various stages
    of disrepair, it’s likely not going to be a hard choice. Similarly, if you’ve
    outgrown your PaaS or have a highly proficient team wanting to deploy faster with
    modern tools, go for it. But that MySQL cluster that’s running like a charm on
    a custom clustering setup with four 9s of reliability? Maybe that one’s OK to
    leave for now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出决定，我建议权衡将迁移到容器并统一您的计算平台，围绕一个适合各种工作负载的部署系统所带来的好处，以及管理 Kubernetes 所需的额外知识。如果您一开始就是一堆在各个阶段损坏的定制虚拟机上运行的服务，那么这很可能不是一个艰难的选择。同样，如果您已经超过了您的
    PaaS 或有一个高度熟练的团队希望使用现代工具更快地部署，那么就去做吧。但那个运行得如丝般顺滑的 MySQL 集群，在定制的集群设置下具有四个9的可靠性？也许现在让它保持现状是可行的。
- en: Going to Kubernetes doesn’t need to be an all-or-nothing decision. I’d suggest
    starting with those workloads that make the most sense and gradually migrating
    them as you and your team build up knowledge in operating Kubernetes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 转向 Kubernetes 不需要是一个全有或全无的决定。我建议从那些最有意义的负载开始，随着您和您的团队在操作 Kubernetes 方面积累知识，逐步迁移它们。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Containers are the modern way to run applications that achieve isolation between
    multiple applications running on the same host and do so with low overhead compared
    to VMs.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是运行应用程序的现代方式，它能够在同一主机上运行多个应用程序之间实现隔离，并且与虚拟机相比具有低开销。
- en: Kubernetes is a deployment platform for containerized applications.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 是容器化应用程序的部署平台。
- en: Kubernetes has a bit of a learning curve, but it enables you to express a vast
    variety of deployment constructs and takes care of configuring infrastructure
    and keeping applications running.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 有一定的学习曲线，但它允许你表达大量的部署结构，并负责配置基础设施和保持应用程序运行。
- en: Hosted platforms (like Google Kubernetes Engine) take away the administrative
    burden of managing Kubernetes, allowing you to focus on your application deployments.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管平台（如 Google Kubernetes Engine）承担了管理 Kubernetes 的管理负担，让你可以专注于应用程序部署。
- en: Application developers can focus on describing their application configuration
    in Kubernetes terms, after which the system is responsible for running it in the
    way you described.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用开发者可以专注于使用 Kubernetes 术语描述他们的应用程序配置，之后系统将负责以你描述的方式运行它。
- en: A key benefit of Kubernetes is that it allows you to grow as your needs evolve;
    you likely won’t need to change platforms due to new requirements like an application
    needing to have its own local state.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的一个关键好处是，它允许你随着需求的演变而增长；你很可能不需要因为新要求（如应用程序需要其自己的本地状态）而更改平台。
- en: When you need to scale up due to increased demand, Kubernetes can help you do
    so in an efficient way.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需求增加需要扩展时，Kubernetes 可以帮助你以高效的方式完成。
- en: '* * *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.) [https://cloud.google.com/learn/what-is-kubernetes](https://cloud.google.com/learn/what-is-kubernetes)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) [https://cloud.google.com/learn/what-is-kubernetes](https://cloud.google.com/learn/what-is-kubernetes)
- en: ^(2.) [https://kubernetes.io/case-studies/spotify/](https://kubernetes.io/case-studies/spotify/)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: (2.) [https://kubernetes.io/case-studies/spotify/](https://kubernetes.io/case-studies/spotify/)
- en: ^(3.) [https://kubernetes.io/case-studies/capital-one/](https://kubernetes.io/case-studies/capital-one/)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (3.) [https://kubernetes.io/case-studies/capital-one/](https://kubernetes.io/case-studies/capital-one/)
- en: ^(4.) [https://kubernetes.io/case-studies/openai/](https://kubernetes.io/case-studies/openai/)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: (4.) [https://kubernetes.io/case-studies/openai/](https://kubernetes.io/case-studies/openai/)
- en: ^(5.) [https://cloud.google.com/blog/products/gcp/bringing-pokemon-go-to-life-on-google-cloud](https://cloud.google.com/blog/products/gcp/bringing-pokemon-go-to-life-on-google-cloud)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (5.) [https://cloud.google.com/blog/products/gcp/bringing-pokemon-go-to-life-on-google-cloud](https://cloud.google.com/blog/products/gcp/bringing-pokemon-go-to-life-on-google-cloud)
- en: ^(6.) [https://www.cncf.io/certification/software-conformance/](https://www.cncf.io/certification/software-conformance/)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (6.) [https://www.cncf.io/certification/software-conformance/](https://www.cncf.io/certification/software-conformance/)
