- en: Chapter 8\. External API patterns
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 外部API模式
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The challenge of designing APIs that support a diverse set of clients
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计支持多样化客户端的API的挑战
- en: Applying API gateway and Backends for frontends patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用API网关和后端为前端模式
- en: Designing and implementing an API gateway
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现API网关
- en: Using reactive programming to simplify API composition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式编程简化API组合
- en: Implementing an API gateway using GraphQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL实现API网关
- en: The FTGO application, like many other applications, has a REST API. Its clients
    include the FTGO mobile applications, JavaScript running in the browser, and applications
    developed by partners. In such a monolithic architecture, the API that’s exposed
    to clients is the monolith’s API. But when once the FTGO team starts deploying
    microservices, there’s no longer one API, because each service has its own API.
    Mary and her team must decide what kind of API the FTGO application should now
    expose to its clients. For example, should clients be aware of the existence of
    services and make requests to them directly?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他应用程序一样，FTGO应用程序有一个REST API。其客户端包括FTGO移动应用程序、在浏览器中运行的JavaScript以及合作伙伴开发的应用程序。在这样的单体架构中，暴露给客户端的API是单体API。但是当FTGO团队开始部署微服务时，就不再有一个API了，因为每个服务都有自己的API。玛丽和她的团队必须决定FTGO应用程序现在应该向其客户端暴露哪种类型的API。例如，客户端是否应该知道服务的存在并直接向它们发出请求？
- en: The task of designing an application’s external API is made even more challenging
    by the diversity of its clients. Different clients typically require different
    data. A desktop browser-based UI usually displays far more information than a
    mobile application. Also, different clients access the services over different
    kinds of networks. The clients within the firewall use a high-performance LAN,
    and the clients outside of the firewall use the internet or mobile network, which
    will have lower performance. Consequently, as you’ll learn, it often doesn’t make
    sense to have a single, one-size-fits-all API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序外部API的任务由于客户端的多样性而变得更加具有挑战性。不同的客户端通常需要不同的数据。基于桌面浏览器的UI通常显示比移动应用程序多得多的信息。此外，不同的客户端通过不同类型的网络访问服务。防火墙内的客户端使用高性能的局域网，而防火墙外的客户端使用互联网或移动网络，这将具有较低的性能。因此，正如你将学到的，通常没有单一、通用的API是有意义的。
- en: This chapter begins by describing various external API design issues. I then
    describe the external API patterns. I cover the API gateway pattern and then the
    Backends for frontends pattern. After that, I discuss how to design and implement
    an API gateway. I review the various options that are available, which include
    off-the-shelf API gateway products and frameworks for developing your own. I describe
    the design and implementation of an API gateway that’s built using the Spring
    Cloud Gateway framework. I also describe how to build an API gateway using GraphQL,
    a framework that provides graph-based query language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先描述了各种外部API设计问题。随后，我介绍了外部API模式。我涵盖了API网关模式和后端为前端模式。之后，我讨论了如何设计和实现API网关。我回顾了可用的各种选项，包括现成的API网关产品和用于开发自己的框架。我描述了使用Spring
    Cloud Gateway框架构建的API网关的设计和实现。我还描述了如何使用GraphQL框架，它提供了一个基于图查询语言，来构建API网关。
- en: 8.1\. External API design issues
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 外部API设计问题
- en: 'In order to explore the various API-related issues, let’s consider the FTGO
    application. As [figure 8.1](#ch08fig01) shows, this application’s services are
    consumed by a variety of clients. Four kinds of clients consume the services’
    APIs:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索各种API相关的问题，让我们考虑FTGO应用程序。如图8.1所示，该应用程序的服务被各种客户端消费。四种类型的客户端消费服务的API：
- en: Web applications, such as `Consumer web application`, which implements the browser-based
    UI for consumers, `Restaurant web application`, which implements the browser-based
    UI for restaurants, and `Admin web application`, which implements the internal
    administrator UI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序，例如`消费者网络应用程序`，它实现了面向消费者的基于浏览器的UI，`餐厅网络应用程序`，它实现了面向餐厅的基于浏览器的UI，以及`管理员网络应用程序`，它实现了内部管理员UI
- en: JavaScript applications running in the browser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中运行的JavaScript应用程序
- en: Mobile applications, one for consumers and the other for couriers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序，一个面向消费者，另一个面向快递员
- en: Applications written by third-party developers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由第三方开发者编写的应用程序
- en: Figure 8.1\. The FTGO application’s services and their clients. There are several
    different types of clients. Some are inside the firewall, and others are outside.
    Those outside the firewall access the services over the lower-performance internet/mobile
    network. Those clients inside the firewall use a higher-performance LAN.
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. FTGO应用程序的服务及其客户端。存在几种不同类型的客户端。一些在防火墙内部，而另一些在外部。那些在防火墙外部的客户端通过低性能的互联网/移动网络访问服务。那些在防火墙内部的客户端使用高性能的局域网。
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: The web applications run inside the firewall, so they access the services over
    a high-bandwidth, low-latency LAN. The other clients run outside the firewall,
    so they access the services over the lower-bandwidth, higher-latency internet
    or mobile network.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序运行在防火墙内部，因此它们通过高带宽、低延迟的局域网访问服务。其他客户端运行在防火墙外部，因此它们通过低带宽、高延迟的互联网或移动网络访问服务。
- en: 'One approach to API design is for clients to invoke the services directly.
    On the surface, this sounds quite straightforward—after all, that’s how clients
    invoke the API of a monolithic application. But this approach is rarely used in
    a microservice architecture because of the following drawbacks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: API设计的一种方法是为客户端直接调用服务。表面上，这似乎非常直接——毕竟，这就是客户端调用单体应用程序API的方式。但由于以下缺点，这种方法在微服务架构中很少使用：
- en: The fine-grained service APIs require clients to make multiple requests to retrieve
    the data they need, which is inefficient and can result in a poor user experience.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精细粒度的服务API要求客户端进行多次请求以检索所需的数据，这既低效又可能导致用户体验不佳。
- en: The lack of encapsulation caused by clients knowing about each service and its
    API makes it difficult to change the architecture and the APIs.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于客户端了解每个服务和其API，导致缺乏封装，这使得改变架构和API变得困难。
- en: Services might use IPC mechanisms that aren’t convenient or practical for clients
    to use, especially those clients outside the firewall.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可能使用对客户端来说不方便或不实用的IPC机制，尤其是那些在防火墙外部的客户端。
- en: To learn more about these drawbacks, let’s take a look at how the FTGO mobile
    application for consumers retrieves data from the services.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些缺点，让我们看看FTGO移动应用程序如何从服务中检索数据。
- en: 8.1.1\. API design issues for the FTGO mobile client
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. FTGO移动客户端的API设计问题
- en: Consumers use the FTGO mobile client to place and manage their orders. Imagine
    you’re developing the mobile client’s `View Order` view, which displays an order.
    As described in [chapter 7](kindle_split_015.xhtml#ch07), the information displayed
    by this view includes basic order information, including its status, payment status,
    status of the order from the restaurant’s perspective, and delivery status, including
    its location and estimated delivery time if in transit.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者使用FTGO移动客户端来下单和管理他们的订单。想象一下，你正在开发移动客户端的“查看订单”视图，该视图显示一个订单。如[第7章](kindle_split_015.xhtml#ch07)所述，此视图显示的信息包括基本订单信息，包括其状态、支付状态、从餐厅角度的订单状态以及配送状态，包括其位置和如果在途中，预计的配送时间。
- en: 'The monolithic version of the FTGO application has an API endpoint that returns
    the order details. The mobile client retrieves the information it needs by making
    a single request. In contrast, in the microservices version of the FTGO application,
    the order details are, as described previously, scattered across several services,
    including the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序的单一版本有一个API端点，返回订单详情。移动客户端通过单次请求检索所需信息。相比之下，在FTGO应用程序的微服务版本中，订单详情，如前所述，分散在几个服务中，包括以下服务：
- en: '**`Order Service`—** Basic order information, including the details and status'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`订单服务`—** 基本订单信息，包括细节和状态'
- en: '**`Kitchen Service`—** The status of the order from the restaurant’s perspective
    and the estimated time it will be ready for pickup'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`厨房服务`—** 从餐厅角度的订单状态和预计取货准备时间'
- en: '**`Delivery Service`—** The order’s delivery status, its estimated delivery
    time, and its current location'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`配送服务`—** 订单的配送状态、预计配送时间和当前位置'
- en: '**`Accounting Service`—** The order’s payment status'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`会计服务`—** 订单的支付状态'
- en: If the mobile client invokes the services directly, then it must, as [figure
    8.2](#ch08fig02) shows, make multiple calls to retrieve this data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移动客户端直接调用服务，那么它必须，如[图8.2](#ch08fig02)所示，进行多次调用以检索这些数据。
- en: Figure 8.2\. A client can retrieve the order details from the monolithic FTGO
    application with a single request. But the client must make multiple requests
    to retrieve the same information in a microservice architecture.
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2。客户端可以通过单个请求从单体FTGO应用程序中检索订单详情。但在微服务架构中，客户端必须进行多次请求来检索相同的信息。
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2的替代文本](Images/08fig02_alt.jpg)'
- en: In this design, the mobile application is playing the role of API composer.
    It invokes multiple services and combines the results. Although this approach
    seems reasonable, it has several serious problems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，移动应用程序扮演着API作曲家的角色。它调用多个服务并组合结果。尽管这种方法看起来合理，但它有几个严重的问题。
- en: Poor user experience due to the client making multiple requests
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 由于客户端进行多次请求导致的用户体验差
- en: The first problem is that the mobile application must sometimes make multiple
    requests to retrieve the data it wants to display to the user. The chatty interaction
    between the application and the services can make the application seem unresponsive,
    especially when it uses the internet or a mobile network. The internet has much
    lower bandwidth and higher latency than a LAN, and mobile networks are even worse.
    The latency of a mobile network (and internet) is typically 100x greater than
    a LAN.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题在于，移动应用程序有时必须进行多次请求以检索它想要向用户显示的数据。应用程序与服务之间的频繁交互可能会让应用程序看起来没有响应，尤其是在它使用互联网或移动网络时。互联网的带宽比局域网低得多，延迟也更高，而移动网络的情况更糟。移动网络（和互联网）的延迟通常是局域网的100倍。
- en: The higher latency might not be a problem when retrieving the order details,
    because the mobile application minimizes the delay by executing the requests concurrently.
    The overall response time is no greater than that of a single request. But in
    other scenarios, a client may need to execute requests sequentially, which will
    result in a poor user experience.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当检索订单详情时，较高的延迟可能不是问题，因为移动应用程序通过并发执行请求来最小化延迟。整体响应时间不会超过单个请求。但在其他场景中，客户端可能需要顺序执行请求，这将导致用户体验不佳。
- en: What’s more, poor user experience due to network latency is not the only issue
    with a chatty API. It requires the mobile developer to write potentially complex
    API composition code. This work is a distraction from their primary task of creating
    a great user experience. Also, because each network request consumes power, a
    chatty API drains the mobile device’s battery faster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于网络延迟导致的用户体验差并不是频繁交互的API的唯一问题。它要求移动开发者编写可能复杂的API组合代码。这项工作会分散他们创建良好用户体验的主要任务。而且，因为每个网络请求都会消耗电量，频繁交互的API会更快地耗尽移动设备的电池。
- en: Lack of encapsulation requires frontend developers to change thei- ir code in
    lockstep with the backend
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缺乏封装要求前端开发者与后端同步更改他们的代码
- en: Another drawback of a mobile application directly accessing the services is
    the lack of encapsulation. As an application evolves, the developers of a service
    sometimes change an API in a way that breaks existing clients. They might even
    change how the system is decomposed into services. Developers may add new services
    and split or merge existing services. But if knowledge about the services is baked
    into a mobile application, it can be difficult to change the services’ APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序直接访问服务的另一个缺点是封装不足。随着应用程序的发展，服务的开发者有时会以破坏现有客户端的方式更改API。他们甚至可能改变系统分解为服务的方式。开发者可能会添加新的服务，分割或合并现有服务。但如果关于服务的知识已经嵌入到移动应用程序中，那么更改服务的API可能会变得困难。
- en: Unlike when updating a server-side application, it takes hours or perhaps even
    days to roll out a new version of a mobile application. Apple or Google must approve
    the upgrade and make it available for download. Users might not download the upgrade
    immediately—if ever. And you may not want to force reluctant users to upgrade.
    The strategy of exposing service APIs to mobile creates a significant obstacle
    to evolving those APIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与更新服务器端应用程序不同，推出移动应用程序的新版本可能需要数小时甚至数天。苹果或谷歌必须批准升级并使其可供下载。用户可能不会立即下载升级——如果他们下载的话。而且你可能不希望强迫不愿意升级的用户。将服务API暴露给移动的策略为这些API的演变设置了重大的障碍。
- en: Services might use client-unfriendly IPC mechanisms
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务可能会使用对客户端不友好的IPC机制
- en: Another challenge with a mobile application directly calling services is that
    some services could use protocols that aren’t easily consumed by a client. Client
    applications that run outside the firewall typically use protocols such as HTTP
    and WebSockets. But as described in [chapter 3](kindle_split_011.xhtml#ch03),
    service developers have many protocols to choose from—not just HTTP. Some of an
    application’s services might use gRPC, whereas others could use the AMQP messaging
    protocol. These kinds of protocols work well internally, but might not be easily
    consumed by a mobile client. Some aren’t even firewall friendly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直接调用服务的移动应用程序来说，另一个挑战是某些服务可能使用客户端难以消费的协议。运行在防火墙之外的客户应用程序通常使用 HTTP 和 WebSockets
    等协议。但如[第 3 章](kindle_split_011.xhtml#ch03)所述，服务开发者有许多协议可供选择——不仅仅是 HTTP。一个应用程序的一些服务可能使用
    gRPC，而其他服务可能使用 AMQP 消息协议。这类协议在内部运行良好，但可能不易被移动客户端消费。有些甚至对防火墙不友好。
- en: 8.1.2\. API design issues for other kinds of clients
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 其他类型客户端的 API 设计问题
- en: I picked the mobile client because it’s a great way to demonstrate the drawbacks
    of clients accessing services directly. But the problems created by exposing services
    to clients aren’t specific to just mobile clients. Other kinds of clients, especially
    those outside the firewall, also encounter these problems. As described earlier,
    the FTGO application’s services are consumed by web applications, browser-based
    JavaScript applications, and third-party applications. Let’s take a look at the
    API design issues with these clients.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择移动客户端，因为它是一种很好的方式来展示客户端直接访问服务的缺点。但是，向客户端公开服务所造成的问题并不仅限于移动客户端。其他类型的客户端，尤其是那些在防火墙之外运行的客户端，也会遇到这些问题。如前所述，FTGO
    应用程序的服务被 Web 应用程序、基于浏览器的 JavaScript 应用程序和第三方应用程序消费。让我们看看这些客户端的 API 设计问题。
- en: API design issues for web applications
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络应用的 API 设计问题
- en: Traditional server-side web applications, which handle HTTP requests from browsers
    and return HTML pages, run within the firewall and access the services over a
    LAN. Network bandwidth and latency aren’t obstacles to implementing API composition
    in a web application. Also, web applications can use non-web-friendly protocols
    to access the services. The teams that develop web applications are part of the
    same organization and often work in close collaboration with the teams writing
    the backend services, so a web application can easily be updated whenever the
    backend services are changed. Consequently, it’s feasible for a web application
    to access the backend services directly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的服务器端网络应用程序，它处理来自浏览器的 HTTP 请求并返回 HTML 页面，运行在防火墙内并通过局域网访问服务。网络带宽和延迟不是在 Web
    应用程序中实现 API 组合的障碍。此外，Web 应用程序可以使用非 Web 友好的协议来访问服务。开发 Web 应用程序的团队属于同一组织，并且通常与编写后端服务的团队紧密合作，因此
    Web 应用程序可以很容易地随时更新后端服务。因此，Web 应用程序直接访问后端服务是可行的。
- en: API design issues for browser-based JavaScript applications
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于浏览器的 JavaScript 应用程序的 API 设计问题
- en: Modern browser applications use some amount of JavaScript. Even if the HTML
    is primarily generated by a server-side web application, it’s common for JavaScript
    running in the browser to invoke services. For example, all of the FTGO application
    web applications—`Consumer`, `Restaurant`, and `Admin`—contain JavaScript that
    invokes the backend services. The `Consumer` web application, for instance, dynamically
    refreshes the `Order Details` page using JavaScript that invokes the service APIs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器应用程序使用一定量的 JavaScript。即使 HTML 主要由服务器端网络应用程序生成，浏览器中运行的 JavaScript 调用服务是很常见的。例如，FTGO
    应用程序的所有 Web 应用程序——`Consumer`、`Restaurant` 和 `Admin`——都包含调用后端服务的 JavaScript。例如，`Consumer`
    Web 应用程序使用调用服务 API 的 JavaScript 动态刷新 `Order Details` 页面。
- en: On one hand, browser-based JavaScript applications are easy to update when service
    APIs change. On the other hand, JavaScript applications that access the services
    over the internet have the same problems with network latency as mobile applications.
    To make matters worse, browser-based UIs, especially those for the desktop, are
    usually more sophisticated and need to compose more services than mobile applications.
    It’s likely that the `Consumer` and `Restaurant` applications, which access services
    over the internet, won’t be able to compose service APIs efficiently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，基于浏览器的JavaScript应用程序在服务API更改时易于更新。另一方面，通过互联网访问服务的JavaScript应用程序与移动应用程序一样，存在网络延迟的问题。更糟糕的是，基于浏览器的UI，尤其是桌面应用程序，通常更复杂，需要组合比移动应用程序更多的服务。很可能会出现，通过互联网访问服务的`Consumer`和`Restaurant`应用程序无法有效地组合服务API。
- en: Designing APIs for third-party applications
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为第三方应用程序设计API
- en: FTGO, like many other organizations, exposes an API to third-party developers.
    The developers can use the FTGO API to write applications that place and manage
    orders. These third-party applications access the APIs over the internet, so API
    composition is likely to be inefficient. But the inefficiency of API composition
    is a relatively minor problem compared to the much larger challenge of designing
    an API that’s used by third-party applications. That’s because third-party developers
    need an API that’s stable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO，像许多其他组织一样，向第三方开发者公开API。开发者可以使用FTGO API编写放置和管理订单的应用程序。这些第三方应用程序通过互联网访问API，因此API组合可能效率低下。但与设计供第三方应用程序使用的API相比，API组合的低效率是一个相对较小的问题。这是因为第三方开发者需要一个稳定的API。
- en: Very few organizations can force third-party developers to upgrade to a new
    API. Organizations that have an unstable API risk losing developers to a competitor.
    Consequently, you must carefully manage the evolution of an API that’s used by
    third-party developers. You typically have to maintain older versions for a long
    time—possibly forever.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有组织能够强迫第三方开发者升级到新的API。具有不稳定API的组织可能会失去开发者，转而使用竞争对手。因此，您必须仔细管理供第三方开发者使用的API的演变。通常，您必须长期维护旧版本——可能永远如此。
- en: This requirement is a huge burden for an organization. It’s impractical to make
    the developers of the backend services responsible for maintaining long-term backward
    compatibility. Rather than expose services directly to third-party developers,
    organizations should have a separate public API that’s developed by a separate
    team. As you’ll learn later, the public API is implemented by an architectural
    component known as an *API gateway*. Let’s look at how an API gateway works.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求对组织来说是一个巨大的负担。让后端服务的开发者负责维护长期向后兼容性是不切实际的。与其直接向第三方开发者公开服务，组织应该有一个由不同团队开发的独立公共API。正如您稍后将要了解的，公共API是由一个称为*API网关*的架构组件实现的。让我们看看API网关是如何工作的。
- en: 8.2\. The API gateway pattern
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. API网关模式
- en: As you’ve just seen, there are numerous drawbacks with services accessing services
    directly. It’s often not practical for a client to perform API composition over
    the internet. The lack of encapsulation makes it difficult for developers to change
    service decomposition and APIs. Services sometimes use communication protocols
    that aren’t suitable outside the firewall. Consequently, a much better approach
    is to use an API gateway.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚刚看到的，直接访问服务的服务存在许多缺点。客户端在互联网上执行API组合通常不切实际。缺乏封装使得开发者难以更改服务分解和API。服务有时使用不适合防火墙外的通信协议。因此，一个更好的方法是用API网关。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: API gateway**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：API网关**'
- en: Implement a service that’s the entry point into the microservices-based application
    from external API clients. See [http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个服务，作为外部API客户端进入基于微服务的应用程序的入口点。参见[http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html)。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: An *API gateway* is a service that’s the entry point into the application from
    the outside world. It’s responsible for request routing, API composition, and
    other functions, such as authentication. This section covers the API gateway pattern.
    I discuss its benefits and drawbacks and describe various design issues you must
    address when developing an API gateway.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*API网关*是一个服务，它是从外部世界进入应用程序的入口点。它负责请求路由、API组合和其他功能，例如身份验证。本节介绍了API网关模式。我讨论了它的优点和缺点，并描述了在开发API网关时必须解决的各种设计问题。'
- en: 8.2.1\. Overview of the API gateway pattern
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. API网关模式的概述
- en: '[Section 8.1.1](#ch08lev2sec1) described the drawbacks of clients, such as
    the FTGO mobile application, making multiple requests in order to display information
    to the user. A much better approach is for a client to make a single request to
    an API gateway, a service that serves as the single entry point for API requests
    into an application from outside the firewall. It’s similar to the Facade pattern
    from object-oriented design. Like a facade, an API gateway encapsulates the application’s
    internal architecture and provides an API to its clients. It may also have other
    responsibilities, such as authentication, monitoring, and rate limiting. [Figure
    8.3](#ch08fig03) shows the relationship between the clients, the API gateway,
    and the services.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8.1.1节](#ch08lev2sec1)描述了客户端（如FTGO移动应用程序）的缺点，例如，为了向用户显示信息而进行多次请求。一个更好的方法是客户端向API网关发送单个请求，该网关作为API请求进入应用程序的外部防火墙的单一点。这与面向对象设计中的外观模式类似。像外观一样，API网关封装了应用程序的内部架构，并为客户端提供了一个API。它还可能具有其他职责，例如身份验证、监控和速率限制。[图8.3](#ch08fig03)显示了客户端、API网关和服务之间的关系。'
- en: Figure 8.3\. The API gateway is the single entry point into the application
    for API calls from outside the firewall.
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3。API网关是外部防火墙进入应用程序进行API调用的单一入口点。
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03_alt.jpg)'
- en: The API gateway is responsible for request routing, API composition, and protocol
    translation. All API requests from *external* clients first go to the API gateway,
    which routes some requests to the appropriate service. The API gateway handles
    other requests using the API composition pattern and by invoking multiple services
    and aggregating the results. It may also translate between client-friendly protocols
    such as HTTP and WebSockets and client-unfriendly protocols used by the services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: API网关负责请求路由、API组合和协议转换。所有来自*外部*客户端的API请求首先到达API网关，其中一些请求被路由到适当的服务。API网关通过使用API组合模式和调用多个服务并汇总结果来处理其他请求。它还可能在客户端友好的协议（如HTTP和WebSockets）和客户端不友好的协议（由服务使用）之间进行转换。
- en: Request routing
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 请求路由
- en: One of the key functions of an API gateway is *request routing*. An API gateway
    implements some API operations by routing requests to the corresponding service.
    When it receives a request, the API gateway consults a routing map that specifies
    which service to route the request to. A routing map might, for example, map an
    HTTP method and path to the HTTP URL of a service. This function is identical
    to the reverse proxying features provided by web servers such as NGINX.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: API网关的关键功能之一是**请求路由**。API网关通过将请求路由到相应的服务来执行一些API操作。当它收到一个请求时，API网关会咨询一个路由映射表，该映射表指定将请求路由到哪个服务。例如，一个路由映射表可能会将HTTP方法和路径映射到服务的HTTP
    URL。这个功能与由像NGINX这样的Web服务器提供的反向代理功能相同。
- en: API Composition
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API组合
- en: An API gateway typically does more than simply reverse proxying. It might also
    implement some API operations using API composition. The FTGO API gateway, for
    example, implements the `Get Order Details` API operation using API composition.
    As [figure 8.4](#ch08fig04) shows, the mobile application makes one request to
    the API gateway, which fetches the order details from multiple services.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: API网关通常不仅仅是反向代理。它还可能使用API组合来实现一些API操作。例如，FTGO API网关使用API组合来实现`获取订单详情`API操作。如图8.4所示，移动应用程序向API网关发送一个请求，该网关从多个服务中检索订单详情。
- en: Figure 8.4\. An API gateway often does API composition, which enables a client
    such as a mobile device to efficiently retrieve data using a single API request.
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4。API网关通常执行API组合，这使得客户端（如移动设备）能够通过单个API请求有效地检索数据。
- en: '![](Images/08fig04_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04_alt.jpg)'
- en: The FTGO API gateway provides a coarse-grained API that enables mobile clients
    to retrieve the data they need with a single request. For example, the mobile
    client makes a single `getOrderDetails()` request to the API gateway.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO API网关提供了一个粗粒度的API，允许移动客户端通过单个请求检索所需的数据。例如，移动客户端向API网关发出单个`getOrderDetails()`请求。
- en: Protocol translation
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 协议转换
- en: An API gateway might also perform protocol translation. It might provide a RESTful
    API to external clients, even though the application services use a mixture of
    protocols internally, including REST and gRPC. When needed, the implementation
    of some API operations translates between the RESTful external API and the internal
    gRPC-based APIs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: API网关还可能执行协议转换。它可能为外部客户端提供RESTful API，尽管应用程序服务内部使用多种协议，包括REST和gRPC。当需要时，某些API操作的实现会在RESTful外部API和基于gRPC的内部API之间进行转换。
- en: The API gateway provides each client with client-specific API
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API网关为每个客户端提供特定于客户端的API
- en: An API gateway could provide a single one-size-fits-all (OSFA) API. The problem
    with a single API is that different clients often have different requirements.
    For instance, a third-party application might require the `Get Order Details`
    API operation to return the complete `Order` details, whereas a mobile client
    only needs a subset of the data. One way to solve this problem is to give clients
    the option of specifying in a request which fields and related objects the server
    should return. This approach is adequate for a public API that must serve a broad
    range of third-party applications, but it often doesn’t give clients the control
    they need.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: API网关可能提供一个适用于所有情况的单一API（OSFA）。单一API的问题在于，不同的客户端通常有不同的需求。例如，第三方应用程序可能需要`Get
    Order Details` API操作返回完整的`Order`详情，而移动客户端只需要数据的一个子集。解决此问题的一种方法是在请求中允许客户端指定服务器应返回哪些字段和相关对象。这种方法对于必须服务于广泛第三方应用的公共API来说是足够的，但它通常不会给客户端提供他们需要的控制权。
- en: A better approach is for the API gateway to provide each client with its own
    API. For example, the FTGO API gateway can provide the FTGO mobile client with
    an API that’s specifically designed to meet its requirements. It may even have
    different APIs for the Android and iPhone mobile applications. The API gateway
    will also implement a public API for third-party developers to use. Later on,
    I’ll describe the Backends for frontends pattern that takes this concept of an
    API-per-client even further by defining a separate API gateway for each client.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是API网关为每个客户端提供其自己的API。例如，FTGO API网关可以为FTGO移动客户端提供一个专门设计以满足其需求的API。它甚至可能为Android和iPhone移动应用程序提供不同的API。API网关还将为第三方开发者实现一个公共API。稍后，我将描述“前后端分离”模式，该模式通过为每个客户端定义一个单独的API网关将API-per-client的概念进一步扩展。
- en: Implementing edge functions
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现边缘函数
- en: 'Although an API gateway’s primary responsibilities are API routing and composition,
    it may also implement what are known as edge functions. An *edge function* is,
    as the name suggests, a request-processing function implemented at the edge of
    an application. Examples of edge functions that an application might implement
    include the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管API网关的主要职责是API路由和组合，但它也可能实现所谓的边缘函数。正如其名称所示，边缘函数是在应用程序边缘实现的请求处理函数。应用程序可能实现的边缘函数示例包括以下内容：
- en: '***Authentication*—** Verifying the identity of the client making the request.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**—**验证发起请求的客户端身份**。'
- en: '***Authorization*—** Verifying that the client is authorized to perform that
    particular operation.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**—**验证客户端是否有权执行特定操作**。'
- en: '***Rate limiting*—** Limiting how many requests per second from either a specific
    client and/or from all clients.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制**—**限制来自特定客户端和/或所有客户端的每秒请求数量**。'
- en: '***Caching*—** Cache responses to reduce the number of requests made to the
    services.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**—**缓存响应以减少对服务的请求次数**。'
- en: '***Metrics collection*—** Collect metrics on API usage for billing analytics
    purposes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标收集**—**收集API使用情况指标，用于计费分析目的**。'
- en: '***Request logging*—** Log requests.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求记录**—**记录请求**。'
- en: There are three different places in your application where you could implement
    these edge functions. First, you can implement them in the backend services. This
    might make sense for some functions, such as caching, metrics collection, and
    possibly authorization. But it’s generally more secure if the application authenticates
    requests on the edge before they reach the services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你可以在三个不同的地方实现这些边缘功能。首先，你可以在后端服务中实现它们。对于某些功能，如缓存、指标收集和可能授权，这可能是有意义的。但通常，在请求到达服务之前在边缘对请求进行身份验证会更安全。
- en: The second option is to implement these edge functions in an edge service that’s
    upstream from the API gateway. The edge service is the first point of contact
    for an external client. It authenticates the request and performs other edge processing
    before passing it to the API gateway.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是在API网关上游的边缘服务中实现这些边缘功能。边缘服务是外部客户端的第一个接触点。它验证请求并在将其传递给API网关之前执行其他边缘处理。
- en: An important benefit of using a dedicated edge service is that it separates
    concerns. The API gateway focuses on API routing and composition. Another benefit
    is that it centralizes responsibility for critical edge functions such as authentication.
    That’s particularly valuable when an application has multiple API gateways that
    are possibly written using a variety of languages and frameworks. I’ll talk more
    about that later. The drawback of this approach is that it increases network latency
    because of the extra hop. It also adds to the complexity of the application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用边缘服务的一个重要好处是它分离了关注点。API网关专注于API路由和组合。另一个好处是它将关键边缘功能（如身份验证）的责任集中化。当应用程序有多个API网关，且可能使用多种语言和框架编写时，这一点尤其有价值。我稍后会详细讨论这一点。这种方法的缺点是它增加了网络延迟，因为多了一个跳转。它还增加了应用程序的复杂性。
- en: As a result, it’s often convenient to use the third option and implement these
    edge functions, especially authorization, in the API gateway itself. There’s one
    less network hop, which improves latency. There are also fewer moving parts, which
    reduces complexity. [Chapter 11](kindle_split_019.xhtml#ch11) describes how the
    API gateway and the services collaborate to implement security.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常使用第三种方法并在API网关本身实现这些边缘功能，特别是授权，是非常方便的。这样可以减少一个网络跳转，从而提高延迟。同时，移动部件也更少，这降低了复杂性。[第11章](kindle_split_019.xhtml#ch11)描述了API网关和服务的协作方式以实现安全性。
- en: API gateway architecture
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API网关架构
- en: 'An API gateway has a layered, modular architecture. Its architecture, shown
    in [figure 8.5](#ch08fig05), consists of two layers: the API layer and a common
    layer. The API layer consists of one or more independent API modules. Each API
    module implements an API for a particular client. The common layer implements
    shared functionality, including edge functions such as authentication.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: API网关具有分层、模块化的架构。其架构，如图8.5所示，由两层组成：API层和通用层。API层由一个或多个独立的API模块组成。每个API模块为特定客户端实现一个API。通用层实现共享功能，包括如身份验证之类的边缘功能。
- en: Figure 8.5\. An API gateway has a layered modular architecture. The API for
    each client is implemented by a separate module. The common layer implements functionality
    common to all APIs, such as authentication.
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5\. API网关具有分层模块化的架构。每个客户端的API由一个单独的模块实现。通用层实现所有API共有的功能，如身份验证。
- en: '![](Images/08fig05_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig05_alt.jpg)'
- en: 'In this example, the API gateway has three API modules:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，API网关有三个API模块：
- en: '***Mobile API*—** Implements the API for the FTGO mobile client'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***移动API*—** 实现FTGO移动客户端的API'
- en: '***Browser API*—** Implements the API for the JavaScript application running
    in the browser'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***浏览器API*—** 实现运行在浏览器中的JavaScript应用的API'
- en: '***Public API*—** Implements the API for third-party developers'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***公共API*—** 实现第三方开发者的API'
- en: An API module implements each API operation in one of two ways. Some API operations
    map directly to single service API operation. An API module implements these operations
    by routing requests to the corresponding service API operation. It might route
    requests using a generic routing module that reads a configuration file describing
    the routing rules.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: API模块以两种方式之一实现每个API操作。一些API操作直接映射到单个服务API操作。API模块通过将请求路由到相应的服务API操作来实现这些操作。它可能使用一个通用路由模块来路由请求，该模块读取描述路由规则的配置文件。
- en: An API module implements other, more complex API operations using API composition.
    The implementation of this API operation consists of custom code. Each API operation
    implementation handles requests by invoking multiple services and combining the
    results.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: API模块通过API组合实现其他更复杂的API操作。该API操作的实现由自定义代码组成。每个API操作实现通过调用多个服务并组合结果来处理请求。
- en: API gateway ownership model
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API网关所有权模型
- en: An important question that you must answer is who is responsible for the development
    of the API gateway and its operation? There are a few different options. One is
    for a separate team to be responsible for the API gateway. The drawback to that
    is that it’s similar to SOA, where an Enterprise Service Bus (ESB) team was responsible
    for all ESB development. If a developer working on the mobile application needs
    access to a particular service, they must submit a request to the API gateway
    team and wait for them to expose the API. This kind of centralized bottleneck
    in the organization is very much counter to the philosophy of the microservice
    architecture, which promotes loosely coupled autonomous teams.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须回答的一个重要问题是，谁负责API网关的开发和运营？有几个不同的选择。一个是设立一个专门的团队负责API网关。其缺点是，这与SOA类似，在SOA中，企业服务总线（ESB）团队负责所有ESB的开发。如果一个移动应用的开发者需要访问特定的服务，他们必须向API网关团队提交请求，并等待他们公开API。这种在组织中的集中式瓶颈与微服务架构的哲学非常不符，微服务架构推崇松散耦合的自治团队。
- en: A better approach, which has been promoted by Netflix, is for the client teams—the
    mobile, web, and public API teams—to own the API module that exposes their API.
    An API gateway team is responsible for developing the `Common` module and for
    the operational aspects of the gateway. This ownership model, shown in [figure
    8.6](#ch08fig06), gives the teams control over their APIs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix推广的一种更好的方法是，让客户端团队——移动、Web和公共API团队——拥有暴露其API的API模块。API网关团队负责开发“公共”模块和网关的运营方面。这种所有权模型如图8.6所示，使团队能够控制他们的API。
- en: Figure 8.6\. A client team owns their API module. As they change the client,
    they can change the API module and not ask the API gateway team to make the changes.
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6。客户端团队拥有自己的API模块。随着客户端的变化，他们可以更改API模块，而无需请求API网关团队进行更改。
- en: '![](Images/08fig06_alt.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig06_alt.jpg)'
- en: When a team needs to change their API, they check in the changes to the source
    repository for the API gateway. To work well, the API gateway’s deployment pipeline
    must be fully automated. Otherwise, the client teams will often be blocked waiting
    for the API gateway team to deploy the new version.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个团队需要更改他们的API时，他们将更改检查到API网关的源代码库中。为了有效工作，API网关的部署管道必须完全自动化。否则，客户端团队经常会因为等待API网关团队部署新版本而被阻塞。
- en: Using the Backends for frontends pattern
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用前后端分离模式
- en: One concern with an API gateway is that responsibility for it is blurred. Multiple
    teams contribute to the same code base. An API gateway team is responsible for
    its operation. Though not as bad as a SOA ESB, this blurring of responsibilities
    is counter to the microservice architecture philosophy of “if you build it, you
    own it.”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API网关的一个担忧是，其责任界限模糊。多个团队共同贡献相同的代码库。API网关团队负责其运营。虽然不如SOA ESB那样糟糕，但这种责任模糊与微服务架构哲学“如果你建造它，你就拥有它”相悖。
- en: The solution is to have an API gateway for each client, the so-called Backends
    for frontends (BFF) pattern, which was pioneered by Phil Calçado ([http://philcalcado.com/](http://philcalcado.com/))
    and his colleagues at SoundCloud. As [figure 8.7](#ch08fig07) shows, each API
    module becomes its own standalone API gateway that’s developed and operated by
    a single client team.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是为每个客户端提供一个API网关，即所谓的“前后端分离”（BFF）模式，这一模式由Phil Calçado（[http://philcalcado.com/](http://philcalcado.com/)）及其在SoundCloud的同事开创。如图8.7所示，每个API模块都成为其自己的独立API网关，由单个客户端团队开发和运营。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Backends for frontends**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：前后端分离**'
- en: Implement a separate API gateway for each type of client. See [http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为每种类型的客户端实现一个独立的API网关。参见[http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html)。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 8.7\. The Backends for frontends pattern defines a separate API gateway
    for each client. Each client team owns their API gateway. An API gateway team
    owns the common layer.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7。前后端分离模式为每个客户端定义了一个独立的API网关。每个客户端团队拥有自己的API网关。API网关团队拥有公共层。
- en: '![](Images/08fig07_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig07_alt.jpg)'
- en: The public API team owns and operates their API gateway, the mobile team owns
    and operates theirs, and so on. In theory, different API gateways could be developed
    using different technology stacks. But that risks duplicating code for common
    functionality, such as the code that implements edge functions. Ideally, all API
    gateways use the same technology stack. The common functionality is a shared library
    implemented by the API gateway team.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 公共API团队拥有并运营他们的API网关，移动团队拥有并运营他们的，以此类推。从理论上讲，可以使用不同的技术栈来开发不同的API网关。但这可能导致重复编写实现边缘功能的通用代码，例如实现边缘功能的代码。理想情况下，所有API网关都使用相同的技术栈。通用功能是由API网关团队实现的共享库。
- en: Besides clearly defining responsibilities, the BFF pattern has other benefits.
    The API modules are isolated from one another, which improves reliability. One
    misbehaving API can’t easily impact other APIs. It also improves observability,
    because different API modules are different processes. Another benefit of the
    BFF pattern is that each API is independently scalable. The BFF pattern also reduces
    startup time because each API gateway is a smaller, simpler application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明确定义责任外，BFF模式还有其他好处。API模块彼此隔离，这提高了可靠性。一个表现不佳的API不太可能轻易影响其他API。它还提高了可观察性，因为不同的API模块是不同的进程。BFF模式的另一个好处是每个API都可以独立扩展。BFF模式还减少了启动时间，因为每个API网关都是一个更小、更简单的应用程序。
- en: 8.2.2\. Benefits and drawbacks of an API gateway
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2. API网关的优缺点
- en: As you might expect, the API gateway pattern has both benefits and drawbacks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，API网关模式既有优点也有缺点。
- en: Benefits of an API gateway
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API网关的优点
- en: A major benefit of using an API gateway is that it encapsulates internal structure
    of the application. Rather than having to invoke specific services, clients talk
    to the gateway. The API gateway provides each client with a client-specific API,
    which reduces the number of round-trips between the client and application. It
    also simplifies the client code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API网关的一个主要优点是它封装了应用程序的内部结构。而不是调用特定的服务，客户端与网关进行通信。API网关为每个客户端提供一个特定于客户端的API，这减少了客户端与应用程序之间的往返次数。它还简化了客户端代码。
- en: Drawbacks of an API gateway
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API网关的缺点
- en: The API gateway pattern also has some drawbacks. It is yet another highly available
    component that must be developed, deployed, and managed. There’s also a risk that
    the API gateway becomes a development bottleneck. Developers must update the API
    gateway in order to expose their services’s API. It’s important that the process
    for updating the API gateway be as lightweight as possible. Otherwise, developers
    will be forced to wait in line in order to update the gateway. Despite these drawbacks,
    though, for most real-world applications, it makes sense to use an API gateway.
    If necessary, you can use the Backends for frontends pattern to enable the teams
    to develop and deploy their APIs independently.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: API网关模式也有一些缺点。它又是一个必须开发、部署和管理的可用性很高的组件。还有风险，即API网关成为开发瓶颈。开发者必须更新API网关才能公开他们的服务的API。重要的是，更新API网关的过程应该尽可能轻量。否则，开发者将被迫排队等待更新网关。尽管如此，对于大多数实际应用来说，使用API网关是有意义的。如果需要，您可以使用前后端分离模式，以使团队能够独立开发和部署他们的API。
- en: 8.2.3\. Netflix as an example of an API gateway
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3. Netflix作为API网关的例子
- en: A great example of an API gateway is the Netflix API. The Netflix streaming
    service is available on hundreds of different kinds of devices including televisions,
    Blu-ray players, smartphones, and many more gadgets. Initially, Netflix attempted
    to have a one-size-fits-all style API for its streaming service ([www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15](http://www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15)).
    But the company soon discovered that didn’t work well because of the diverse range
    of devices and their different needs. Today, Netflix uses an API gateway that
    implements a separate API for each device. The client device team develops and
    owns the API implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: API网关的一个很好的例子是Netflix API。Netflix流媒体服务可在数百种不同的设备上使用，包括电视、蓝光播放器、智能手机以及许多其他小工具。最初，Netflix试图为其流媒体服务提供一个通用的API风格([www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15](http://www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15))。但公司很快发现，由于设备种类繁多且需求不同，这并不奏效。如今，Netflix使用一个API网关，为每种设备实现一个单独的API。客户端设备团队开发和拥有API实现。
- en: In the first version of the API gateway, each client team implemented their
    API using Groovy scripts that perform routing and API composition. Each script
    invoked one or more service APIs using Java client libraries provided by the service
    teams. On one hand, this works well, and client developers have written thousands
    of scripts. The Netflix API gateway handles billions of requests per day, and
    on average each API call fans out to six or seven backend services. On the other
    hand, Netflix has found this monolithic architecture to be somewhat cumbersome.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在API网关的第一个版本中，每个客户端团队使用Groovy脚本实现他们的API，这些脚本执行路由和API组合。每个脚本使用服务团队提供的Java客户端库调用一个或多个服务API。一方面，这效果很好，客户端开发者已经编写了数千个脚本。Netflix
    API网关每天处理数十亿次请求，平均每个API调用会扩展到六个或七个后端服务。另一方面，Netflix发现这种单体架构有些笨重。
- en: As a result, Netflix is now moving to an API gateway architecture similar to
    the Backends for frontends pattern. In this new architecture, client teams write
    API modules using NodeJS. Each API module runs its own Docker container, but the
    scripts don’t invoke the services directly. Rather, they invoke a second “API
    gateway,” which exposes the service APIs using Netflix Falcor. *Netflix Falcor*
    is an API technology that does declarative, dynamic API composition and enables
    a client to invoke multiple services using a single request. This new architecture
    has a number of benefits. The API modules are isolated from one another, which
    improves reliability and observability, and the client API module is independently
    scalable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Netflix现在正在转向与前端后端模式类似的API网关架构。在这个新的架构中，客户端团队使用NodeJS编写API模块。每个API模块运行自己的Docker容器，但脚本不会直接调用服务。相反，它们调用第二个“API网关”，使用Netflix
    Falcor公开服务API。*Netflix Falcor*是一种API技术，它执行声明性、动态的API组合，并允许客户端使用单个请求调用多个服务。这种新的架构有许多优点。API模块彼此隔离，这提高了可靠性和可观察性，并且客户端API模块可以独立扩展。
- en: 8.2.4\. API gateway design issues
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4\. API网关设计问题
- en: 'Now that we’ve looked at the API gateway pattern and its benefits and drawbacks,
    let’s examine various API gateway design issues. There are several issues to consider
    when designing an API gateway:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API网关模式及其优点和缺点，让我们来探讨各种API网关设计问题。在设计API网关时需要考虑几个问题：
- en: Performance and scalability
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和可扩展性
- en: Writing maintainable code by using reactive programming abstractions
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用响应式编程抽象编写可维护的代码
- en: Handling partial failure
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理部分失败
- en: Being a good citizen in the application’s architecture
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为应用程序架构中的良好公民
- en: We’ll look at each one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一探讨。
- en: Performance and scalability
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 性能和可扩展性
- en: An API gateway is the application’s front door. All external requests must first
    pass through the gateway. Although most companies don’t operate at the scale of
    Netflix, which handles billions of requests per day, the performance and scalability
    of the API gateway is usually very important. A key design decision that affects
    performance and scalability is whether the API gateway should use synchronous
    or asynchronous I/O.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: API网关是应用程序的前门。所有外部请求都必须首先通过网关。尽管大多数公司没有Netflix那样每天处理数十亿次请求的规模，但API网关的性能和可扩展性通常非常重要。影响性能和可扩展性的一个关键设计决策是API网关应该使用同步I/O还是异步I/O。
- en: In the *synchronous* I/O model, each network connection is handled by a dedicated
    thread. This is a simple programming model and works reasonably well. For example,
    it’s the basis of the widely used Java EE servlet framework, although this framework
    provides the option of completing a request asynchronously. One limitation of
    synchronous I/O, however, is that operating system threads are heavyweight, so
    there is a limit on the number of threads, and hence concurrent connections, that
    an API gateway can have.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在**同步**I/O模型中，每个网络连接都由一个专用的线程处理。这是一个简单的编程模型，并且效果相当不错。例如，它是广泛使用的Java EE servlet框架的基础，尽管这个框架提供了异步完成请求的选项。然而，同步I/O的一个局限性是操作系统线程是重量级的，因此线程的数量，以及API网关可以拥有的并发连接数，都有限制。
- en: The other approach is to use the *asynchronous* (nonblocking) I/O model. In
    this model, a single event loop thread dispatches I/O requests to event handlers.
    You have a variety of asynchronous I/O technologies to choose from. On the JVM
    you can use one of the NIO-based frameworks such as Netty, Vertx, Spring Reactor,
    or JBoss Undertow. One popular non-JVM option is NodeJS, a platform built on Chrome’s
    JavaScript engine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 *异步*（非阻塞）I/O 模型。在这个模型中，单个事件循环线程将 I/O 请求调度到事件处理器。您有多种异步 I/O 技术可供选择。在
    JVM 上，您可以使用基于 NIO 的框架之一，如 Netty、Vertx、Spring Reactor 或 JBoss Undertow。一个流行的非 JVM
    选项是 NodeJS，这是一个基于 Chrome JavaScript 引擎的平台。
- en: Nonblocking I/O is much more scalable because it doesn’t have the overhead of
    using multiple threads. The drawback, though, is that the asynchronous, callback-based
    programming model is much more complex. The code is more difficult to write, understand,
    and debug. Event handlers must return quickly to avoid blocking the event loop
    thread.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 I/O 的可扩展性更好，因为它没有使用多个线程的开销。然而，缺点是异步、基于回调的编程模型更加复杂。代码更难编写、理解和调试。事件处理器必须快速返回，以避免阻塞事件循环线程。
- en: Also, whether using nonblocking I/O has a meaningful overall benefit depends
    on the characteristics of the API gateway’s request-processing logic. Netflix
    had mixed results when it rewrote Zuul, its edge server, to use NIO (see [https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c](https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c)).
    On one hand, as you would expect, using NIO reduced the cost of each network connection,
    due to the fact that there’s no longer a dedicated thread for each one. Also,
    a Zuul cluster that ran I/O-intensive logic—such as request routing—had a 25%
    increase in throughput and a 25% reduction in CPU utilization. On the other hand,
    a Zuul cluster that ran CPU-intensive logic—such as decryption and compression—showed
    no improvement.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用非阻塞 I/O 是否具有有意义的整体效益取决于 API 网关请求处理逻辑的特征。Netflix 在重写其边缘服务器 Zuul 时，使用 NIO
    得到了混合的结果（见 [https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c](https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c)）。一方面，正如预期的那样，使用
    NIO 减少了每个网络连接的成本，因为不再为每个连接分配专用线程。此外，运行 I/O 密集型逻辑（如请求路由）的 Zuul 集群吞吐量提高了 25%，CPU
    利用率降低了 25%。另一方面，运行 CPU 密集型逻辑（如解密和压缩）的 Zuul 集群没有显示出任何改进。
- en: Use reactive programming abstractions
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用响应式编程抽象
- en: As mentioned earlier, API composition consists of invoking multiple backend
    services. Some backend service requests depend entirely on the client request’s
    parameters. Others might depend on the results of other service requests. One
    approach is for an API endpoint handler method to call the services in the order
    determined by the dependencies. For example, the following listing shows the handler
    for the `findOrder()` request that’s written this way. It calls each of the four
    services, one after the other.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，API 组成包括调用多个后端服务。一些后端服务请求完全依赖于客户端请求的参数。其他可能依赖于其他服务请求的结果。一种方法是由 API 端点处理方法根据依赖关系调用服务。例如，以下列表显示了以这种方式编写的
    `findOrder()` 请求的处理程序。它依次调用每个服务。
- en: Listing 8.1\. Fetching the order details by calling the backend services sequentially
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 通过依次调用后端服务来获取订单详情
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The drawback of calling the services sequentially is that the response time
    is the sum of the service response times. In order to minimize response time,
    the composition logic should, whenever possible, invoke services concurrently.
    In this example, there are no dependencies between the service calls. All services
    should be invoked concurrently, which significantly reduces response time. The
    challenge is to write concurrent code that’s maintainable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序调用服务的缺点是响应时间是服务响应时间的总和。为了最小化响应时间，组成逻辑应尽可能并发调用服务。在这个例子中，服务调用之间没有依赖关系。所有服务都应并发调用，这显著减少了响应时间。挑战在于编写可维护的并发代码。
- en: This is because the traditional way to write scalable, concurrent code is to
    use callbacks. Asynchronous, event-driven I/O is inherently callback-based. Even
    a Servlet API-based API composer that invokes services concurrently typically
    uses callbacks. It could execute requests concurrently by calling `ExecutorService.submitCallable()`.
    The problem there is that this method returns a `Future`, which has a blocking
    API. A more scalable approach is for an API composer to call `ExecutorService.submit
    (Runnable)` and for each `Runnable` to invoke a callback with the outcome of the
    request. The callback accumulates results, and once all of them have been received
    it sends back the response to the client.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编写可扩展、并发代码的传统方式是使用回调。异步、事件驱动的I/O本质上基于回调。即使是基于Servlet API的API编曲器，在并发调用服务时通常也使用回调。它可以通过调用`ExecutorService.submitCallable()`来并发执行请求。问题在于，这个方法返回一个`Future`，它有一个阻塞的API。一个更可扩展的方法是API编曲器调用`ExecutorService.submit
    (Runnable)`，并为每个`Runnable`调用一个带有请求结果的回调。回调累积结果，一旦所有结果都接收完毕，它就向客户端发送响应。
- en: 'Writing API composition code using the traditional asynchronous callback approach
    quickly leads you to callback hell. The code will be tangled, difficult to understand,
    and error prone, especially when composition requires a mixture of parallel and
    sequential requests. A much better approach is to write API composition code in
    a declarative style using a reactive approach. Examples of reactive abstractions
    for the JVM include the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的异步回调方法编写API编曲代码会迅速将你带入回调地狱。代码会变得混乱，难以理解，且容易出错，尤其是在编曲需要并行和顺序请求混合时。一个更好的方法是使用声明式风格和响应式方法编写API编曲代码。JVM的响应式抽象示例包括以下内容：
- en: Java 8 `CompletableFutures`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 `CompletableFutures`
- en: Project Reactor `Monos`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Reactor `Monos`
- en: RxJava (Reactive Extensions for Java) `Observables`, created by Netflix specifically
    to solve this problem in its API gateway
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava (Java的响应式扩展) `Observables`，由Netflix专门为其API网关解决这个问题创建
- en: Scala `Futures`
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala `Futures`
- en: A NodeJS-based API gateway would use JavaScript promises or RxJS, which is reactive
    extensions for JavaScript. Using one of these reactive abstractions will enable
    you to write concurrent code that’s simple and easy to understand. Later in this
    chapter, I show an example of this style of coding using Project Reactor `Monos`
    and version 5 of the Spring Framework.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 基于NodeJS的API网关将使用JavaScript承诺或RxJS，这是JavaScript的响应式扩展。使用这些响应式抽象之一将使你能够编写简单且易于理解的并发代码。在本章的后面部分，我将使用Project
    Reactor `Monos`和Spring框架的版本5展示这种风格的代码示例。
- en: Handling partial failures
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理部分失败
- en: As well as being scalable, an API gateway must also be reliable. One way to
    achieve reliability is to run multiple instances of the gateway behind a load
    balancer. If one instance fails, the load balancer will route requests to the
    other instances.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可扩展性，API网关还必须是可靠的。实现可靠性的方法之一是在负载均衡器后面运行网关的多个实例。如果一个实例失败，负载均衡器将路由请求到其他实例。
- en: Another way to ensure that an API gateway is reliable is to properly handle
    failed requests and requests that have unacceptably high latency. When an API
    gateway invokes a service, there’s always a chance that the service is slow or
    unavailable. An API gateway may wait a very long time, perhaps indefinitely, for
    a response, which consumes resources and prevents it from sending a response to
    its client. An outstanding request to a failed service might even consume a limited,
    precious resource such as a thread and ultimately result in the API gateway being
    unable to handle any other requests. The solution, as described in [chapter 3](kindle_split_011.xhtml#ch03),
    is for an API gateway to use the Circuit breaker pattern when invoking services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保API网关可靠性的另一种方法是正确处理失败的请求和延迟过高的请求。当API网关调用服务时，服务可能会很慢或不可用。API网关可能会等待很长时间，可能是不确定的，以等待响应，这会消耗资源并阻止它向其客户端发送响应。对失败服务的未完成请求甚至可能消耗有限的、宝贵的资源，如线程，最终导致API网关无法处理任何其他请求。解决方案，如第3章所述，是在调用服务时API网关使用断路器模式。
- en: Being a good citizen in the architecture
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 成为架构中的良好公民
- en: In [chapter 3](kindle_split_011.xhtml#ch03) I described patterns for service
    discovery, and in [chapter 11](kindle_split_019.xhtml#ch11), I cover patterns
    for observability. The service discovery patterns enable a service client, such
    as an API gateway, to determine the network location of a service instance so
    that it can invoke it. The observability patterns enable developers to monitor
    the behavior of an application and troubleshoot problems. An API gateway, like
    other services in the architecture, must implement the patterns that have been
    selected for the architecture.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_011.xhtml#ch03)中，我描述了服务发现模式，在第11章[第11章](kindle_split_019.xhtml#ch11)中，我介绍了可观察性模式。服务发现模式使服务客户端，如API网关，能够确定服务实例的网络位置，以便它可以调用它。可观察性模式使开发者能够监控应用程序的行为并解决问题。API网关，就像架构中的其他服务一样，必须实现为架构所选的模式。
- en: 8.3\. Implementing an API gateway
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 实现API网关
- en: 'Let’s now look at how to implement an API gateway. As mentioned earlier, the
    responsibilities of an API gateway are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何实现API网关。如前所述，API网关的职责如下：
- en: '***Request routing*—** Routes requests to services using criteria such as HTTP
    request method and path. The API gateway must route using the HTTP request method
    when the application has one or more CQRS query services. As discussed in [chapter
    7](kindle_split_015.xhtml#ch07), in such an architecture commands and queries
    are handled by separate services.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***请求路由*—** 使用诸如HTTP请求方法和方法路径等标准将请求路由到服务。当应用程序有一个或多个CQRS查询服务时，API网关必须使用HTTP请求方法进行路由。如第7章[第7章](kindle_split_015.xhtml#ch07)中所述，在这种架构中，命令和查询由不同的服务处理。'
- en: '***API composition*—** Implements a `GET` REST endpoint using the API composition
    pattern, described in [chapter 7](kindle_split_015.xhtml#ch07). The request handler
    combines the results of invoking multiple services.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***API组合*—** 使用第7章[第7章](kindle_split_015.xhtml#ch07)中描述的API组合模式实现`GET` REST端点。请求处理器结合调用多个服务的结果。'
- en: '***Edge functions*—** Most notable among these is authentication.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***边缘函数*—** 其中最显著的是身份验证。'
- en: '***Protocol translation*—** Translates between client-friendly protocols and
    the client-unfriendly protocols used by services.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***协议转换*—** 在客户端友好的协议和客户端不友好的服务协议之间进行转换。'
- en: Being a good citizen in the application’s architecture.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为应用程序架构中的良好公民。
- en: 'There are a couple of different ways to implement an API gateway:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实现API网关有几种不同的方法：
- en: '***Using an off-the-shelf API gateway product/service*—** This option requires
    little or no development but is the least flexible. For example, an off-the-shelf
    API gateway typically does not support API composition'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***使用现成的API网关产品/服务*—** 此选项几乎不需要开发工作，但灵活性最低。例如，现成的API网关通常不支持API组合。'
- en: '***Developing your own API gateway using either an API gateway framework or
    a web framework as the starting point*—** This is the most flexible approach,
    though it requires some development effort.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***使用API网关框架或以Web框架作为起点自行开发API网关*—** 这是最灵活的方法，尽管它需要一些开发工作。'
- en: Let’s look at these options, starting with using an off-the-shelf API gateway
    product or service.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些选项，从使用现成的API网关产品或服务开始。
- en: 8.3.1\. Using an off-the-shelf API gateway product/service
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1. 使用现成的API网关产品/服务
- en: Several off-the-self services and products implement API gateway features. Let’s
    first look at a couple of services that are provided by AWS. After that, I’ll
    discuss some products that you can download, configure, and run yourself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 几种现成的服务和产品实现了API网关功能。让我们首先看看AWS提供的一些服务。之后，我将讨论一些您可以下载、配置和运行的产品。
- en: AWS API gateway
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AWS API网关
- en: The AWS API gateway, one of the many services provided by Amazon Web Services,
    is a service for deploying and managing APIs. An AWS API gateway API is a set
    of REST resources, each of which supports one or more HTTP methods. You configure
    the API gateway to route each `(Method, Resource)` to a backend service. A backend
    service is either an AWS Lambda Function, described later in [chapter 12](kindle_split_020.xhtml#ch12),
    an application-defined HTTP service, or an AWS service. If necessary, you can
    configure the API gateway to transform request and response using a template-based
    mechanism. The AWS API gateway can also authenticate requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: AWS API网关是亚马逊网络服务提供的许多服务之一，是一种用于部署和管理API的服务。AWS API网关API是一组REST资源，每个资源都支持一个或多个HTTP方法。您配置API网关将每个`(方法,
    资源)`路由到后端服务。后端服务可以是AWS Lambda函数，这在第12章中稍后描述，也可以是应用程序定义的HTTP服务或AWS服务。如果需要，您可以通过基于模板的机制配置API网关以转换请求和响应。AWS
    API网关还可以对请求进行身份验证。
- en: The AWS API gateway fulfills some of the requirements for an API gateway that
    I listed earlier. The API gateway is provided by AWS, so you’re not responsible
    for installation and operations. You configure the API gateway, and AWS handles
    everything else, including scaling.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: AWS API网关满足了我之前列出的API网关的一些要求。API网关由AWS提供，因此您不需要负责安装和运营。您配置API网关，AWS处理其他所有事情，包括扩展。
- en: Unfortunately, the AWS API gateway has several drawbacks and limitations that
    cause it to not fulfill other requirements. It doesn’t support API composition,
    so you’d need to implement API composition in the backend services. The AWS API
    gateway only supports HTTP(S) with a heavy emphasis on JSON. It only supports
    the Server-side discovery pattern, described in [chapter 3](kindle_split_011.xhtml#ch03).
    An application will typically use an AWS Elastic Load Balancer to load balance
    requests across a set of EC2 instances or ECS containers. Despite these limitations,
    unless you need API composition, the AWS API gateway is a good implementation
    of the API gateway pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，AWS API网关有几个缺点和限制，导致它无法满足其他要求。它不支持API组合，因此您需要在后端服务中实现API组合。AWS API网关仅支持HTTP(S)，并且对JSON有很高的依赖。它只支持在第3章中描述的服务器端发现模式。应用程序通常会使用AWS弹性负载均衡器来在一系列EC2实例或ECS容器之间进行请求负载均衡。尽管有这些限制，除非您需要API组合，否则AWS
    API网关是API网关模式的良好实现。
- en: AWS Application Load Balancer
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AWS应用程序负载均衡器
- en: Another AWS service that provides API gateway-like functionality is the AWS
    Application Load Balancer, which is a load balancer for HTTP, HTTPS, WebSocket,
    and HTTP/2 ([https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/](https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/)).
    When configuring an Application Load Balancer, you define routing rules that route
    requests to backend services, which must be running on AWS EC2 instances.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提供类似API网关功能的AWS服务是AWS应用程序负载均衡器，这是一个用于HTTP、HTTPS、WebSocket和HTTP/2的负载均衡器（[https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/](https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/））。当配置应用程序负载均衡器时，您定义路由规则，将请求路由到必须运行在AWS
    EC2实例上的后端服务。
- en: Like the AWS API gateway, the AWS Application Load Balancer meets some of the
    requirements for an API gateway. It implements basic routing functionality. It’s
    hosted, so you’re not responsible for installation or operations. Unfortunately,
    it’s quite limited. It doesn’t implement HTTP method-based routing. Nor does it
    implement API composition or authentication. As a result, the AWS Application
    Load Balancer doesn’t meet the requirements for an API gateway.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS API网关类似，AWS应用程序负载均衡器满足了一些API网关的要求。它实现了基本的路由功能。它是托管服务，因此您不需要负责安装或运营。不幸的是，它相当有限。它不实现基于HTTP方法的路由。也不实现API组合或身份验证。因此，AWS应用程序负载均衡器不满足API网关的要求。
- en: Using an API gateway product
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用API网关产品
- en: Another option is to use an API gateway product such as Kong or Traefik. These
    are open source packages that you install and operate yourself. Kong is based
    on the NGINX HTTP server, and Traefik is written in GoLang. Both products let
    you configure flexible routing rules that use the HTTP method, headers, and path
    to select the backend service. Kong lets you configure plugins that implement
    edge functions such as authentication. Traefik can even integrate with some service
    registries, described in [chapter 3](kindle_split_011.xhtml#ch03).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用 API 网关产品，如 Kong 或 Traefik。这些是您需要自行安装和操作的开源软件包。Kong 基于 NGINX HTTP 服务器，而
    Traefik 是用 GoLang 编写的。这两个产品都允许您配置灵活的路由规则，这些规则使用 HTTP 方法、头部和路径来选择后端服务。Kong 允许您配置实现边缘功能（如身份验证）的插件。Traefik
    甚至可以与某些服务注册表集成，这些注册表在第 3 章中有所描述。[第 3 章](kindle_split_011.xhtml#ch03)。
- en: Although these products implement edge functions and powerful routing capabilities,
    they have some drawbacks. You must install, configure, and operate them yourself.
    They don’t support API composition. And if you want the API gateway to perform
    API composition, you must develop your own API gateway.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些产品实现了边缘功能和强大的路由能力，但它们也有一些缺点。您必须自行安装、配置和操作它们。它们不支持 API 组合。如果您想使 API 网关执行
    API 组合，您必须开发自己的 API 网关。
- en: 8.3.2\. Developing your own API gateway
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 开发自己的 API 网关
- en: 'Developing an API gateway isn’t particularly difficult. It’s basically a web
    application that proxies requests to other services. You can build one using your
    favorite web framework. There are, however, two key design problems that you’ll
    need to solve:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 API 网关并不特别困难。它基本上是一个代理其他服务的 Web 应用程序。您可以使用您喜欢的 Web 框架来构建它。然而，您将需要解决两个关键的设计问题：
- en: Implementing a mechanism for defining routing rules in order to minimize the
    complex coding
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个机制来定义路由规则，以最小化复杂的编码
- en: Correctly implementing the HTTP proxying behavior, including how HTTP headers
    are handled
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确实现 HTTP 代理行为，包括如何处理 HTTP 头部信息
- en: Consequently, a better starting point for developing an API gateway is to use
    a framework designed for that purpose. Its built-in functionality significantly
    reduces the amount of code you need to write.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发 API 网关的更好起点是使用专为该目的设计的框架。其内置功能显著减少了您需要编写的代码量。
- en: We’ll take a look at Netflix Zuul, an open source project by Netflix, and then
    consider the Spring Cloud Gateway, an open source project from Pivotal.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨 Netflix Zuul，这是一个 Netflix 的开源项目，然后考虑 Spring Cloud Gateway，这是一个来自 Pivotal
    的开源项目。
- en: Using Netflix Zuul
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Netflix Zuul
- en: Netflix developed the Zuul framework to implement edge functions such as routing,
    rate limiting, and authentication ([https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)).
    The Zuul framework uses the concept of *filters*, reusable request interceptors
    that are similar to servlet filters or NodeJS Express middleware. Zuul handles
    an HTTP request by assembling a chain of applicable filters that then transform
    the request, invoke backend services, and transform the response before it’s sent
    back to the client. Although you can use Zuul directly, using Spring Cloud Zuul,
    an open source project from Pivotal, is far easier. Spring Cloud Zuul builds on
    Zuul and through convention-over-configuration makes developing a Zuul-based server
    remarkably easy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 开发了 Zuul 框架来实现边缘功能，如路由、速率限制和身份验证([https://github.com/Netflix/zuul](https://github.com/Netflix/zuul))。Zuul
    框架使用 *过滤器* 的概念，这些是可重用的请求拦截器，类似于 servlet 过滤器或 NodeJS Express 中间件。Zuul 通过组装一系列适用的过滤器来处理
    HTTP 请求，然后转换请求，调用后端服务，并在将其发送回客户端之前转换响应。虽然您可以直接使用 Zuul，但使用来自 Pivotal 的开源项目 Spring
    Cloud Zuul 要容易得多。Spring Cloud Zuul 基于 Zuul，通过约定优于配置，使得基于 Zuul 的服务器开发变得非常简单。
- en: Zuul handles the routing and edge functionality. You can extend Zuul by defining
    Spring MVC controllers that implement API composition. But a major limitation
    of Zuul is that it can only implement path-based routing. For example, it’s incapable
    of routing `GET /orders` to one service and `POST /orders` to a different service.
    Consequently, Zuul doesn’t support the query architecture described in [chapter
    7](kindle_split_015.xhtml#ch07).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul 处理路由和边缘功能。您可以通过定义实现 API 组合的 Spring MVC 控制器来扩展 Zuul。但 Zuul 的一个主要限制是它只能实现基于路径的路由。例如，它无法将
    `GET /orders` 路由到一个服务，而将 `POST /orders` 路由到另一个服务。因此，Zuul 不支持第 7 章中描述的查询架构。[第 7
    章](kindle_split_015.xhtml#ch07)。
- en: About Spring Cloud Gateway
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于 Spring Cloud Gateway
- en: None of the options I’ve described so far meet all the requirements. In fact,
    I had given up in my search for an API gateway framework and had started developing
    an API gateway based on Spring MVC. But then I discovered the Spring Cloud Gateway
    project ([https://cloud.spring.io/spring-cloud-gateway/](https://cloud.spring.io/spring-cloud-gateway/)).
    It’s an API gateway framework built on top of several frameworks, including Spring
    Framework 5, Spring Boot 2, and Spring Webflux, which is a reactive web framework
    that’s part of Spring Framework 5 and built on Project Reactor. Project Reactor
    is an NIO-based reactive framework for the JVM that provides the Mono abstraction
    used a little later in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前描述的选项中没有任何一个能满足所有要求。事实上，我在寻找API网关框架的过程中已经放弃了，并开始基于Spring MVC开发一个API网关。但后来我发现Spring
    Cloud Gateway项目([https://cloud.spring.io/spring-cloud-gateway/](https://cloud.spring.io/spring-cloud-gateway/))。它是一个基于多个框架之上的API网关框架，包括Spring
    Framework 5、Spring Boot 2和Spring Webflux，后者是Spring Framework 5的一部分，是一个基于Project
    Reactor的响应式Web框架。Project Reactor是一个基于NIO的响应式框架，用于JVM，它提供了稍后在本章中稍后使用的Mono抽象。
- en: 'Spring Cloud Gateway provides a simple yet comprehensive way to do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway提供了一种简单而全面的方式来执行以下操作：
- en: Route requests to backend services.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由请求转发到后端服务。
- en: Implement request handlers that perform API composition.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现执行API组合的请求处理器。
- en: Handle edge functions such as authentication.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理边缘函数，如身份验证。
- en: '[Figure 8.8](#ch08fig08) shows the key parts of an API gateway built using
    this framework.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8](#ch08fig08) 展示了使用此框架构建的API网关的关键部分。'
- en: Figure 8.8\. The architecture of an API gateway built using Spring Cloud Gateway
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8。使用Spring Cloud Gateway构建的API网关的架构
- en: '![](Images/08fig08_alt.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Images/08fig08_alt.jpg](Images/08fig08_alt.jpg)'
- en: 'The API gateway consists of the following packages:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: API网关由以下包组成：
- en: '`ApiGatewayMain` *package*—Defines the Main program for the API gateway.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApiGatewayMain` *包*—定义了API网关的主程序。'
- en: '*One or more API packages*—An API package implements a set of API endpoints.
    For example, the `Orders` package implements the `Order`-related API endpoints.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个或多个API包*—API包实现一组API端点。例如，`Orders`包实现了与`Order`相关的API端点。'
- en: '*Proxy package*—Consists of proxy classes that are used by the API packages
    to invoke the services.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代理包*—由API包使用的代理类组成，用于调用服务。'
- en: The `OrderConfiguration` class defines the Spring beans responsible for routing
    `Order`-related requests. A routing rule can match against some combination of
    the HTTP method, the headers, and the path. The `orderProxyRoutes @Bean` defines
    rules that map API operations to backend service URLs. For example, it routes
    paths beginning with `/orders` to the `Order Service`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderConfiguration`类定义了负责路由`Order`相关请求的Spring beans。一个路由规则可以匹配HTTP方法、头部和路径的一些组合。`orderProxyRoutes
    @Bean`定义了将API操作映射到后端服务URL的规则。例如，它将以`/orders`开头的路径路由到`Order Service`。'
- en: The `orderHandlers @Bean` defines rules that override those defined by `orderProxyRoutes`.
    These rules map API operations to handler methods, which are the Spring WebFlux
    equivalent of Spring MVC controller methods. For example, `orderHandlers` maps
    the operation `GET /orders/{orderId}` to the `OrderHandlers::getOrderDetails()`
    method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderHandlers @Bean`定义了覆盖`orderProxyRoutes`中定义的规则。这些规则将API操作映射到处理器方法，这是Spring
    WebFlux对Spring MVC控制器方法的等效。例如，`orderHandlers`将操作`GET /orders/{orderId}`映射到`OrderHandlers::getOrderDetails()`方法。'
- en: The `OrderHandlers` class implements various request handler methods, such as
    `OrderHandlers::getOrderDetails()`. This method uses API composition to fetch
    the order details (described earlier). The handle methods invoke backend services
    using remote proxy classes, such as `OrderService`. This class defines methods
    for invoking the `OrderService`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderHandlers`类实现了各种请求处理器方法，如`OrderHandlers::getOrderDetails()`。此方法使用API组合来获取订单详情（前面已描述）。处理方法使用远程代理类（如`OrderService`）调用后端服务。此类定义了调用`OrderService`的方法。'
- en: Let’s take a look at the code, starting with the `OrderConfiguration` class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码，从`OrderConfiguration`类开始。
- en: The OrderConfiguration class
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`OrderConfiguration` 类'
- en: The `OrderConfiguration` class, shown in [listing 8.2](#ch08ex02), is a Spring
    `@Configuration` class. It defines the Spring `@Beans` that implement the `/orders`
    endpoints. The `orderProxyRouting` and `orderHandlerRouting @Beans` use the Spring
    WebFlux routing DSL to define the request routing. The `orderHandlers @Bean` implements
    the request handlers that perform API composition.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.2](#ch08ex02) 中显示的 `OrderConfiguration` 类是一个 Spring `@Configuration`
    类。它定义了实现 `/orders` 端点的 Spring `@Beans`。`orderProxyRouting` 和 `orderHandlerRouting
    @Beans` 使用 Spring WebFlux 路由 DSL 定义请求路由。`orderHandlers @Bean` 实现执行 API 组合的请求处理器。
- en: Listing 8.2\. The Spring `@Beans` that implement the `/orders` endpoints
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. 实现 `/orders` 端点的 Spring `@Beans`
- en: '[PRE1]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* By default, route all requests whose path begins with /orders to the
    URL orderDestinations.orderServiceUrl.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认情况下，将所有以 /orders 开头的请求路由到 orderDestinations.orderServiceUrl。**'
- en: '***2* Route a GET /orders/{orderId} to orderHandlers::getOrderDetails.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 GET /orders/{orderId} 路由到 orderHandlers::getOrderDetails。**'
- en: '***3* The @Bean, which implements the custom request-handling logic**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现自定义请求处理逻辑的 @Bean**'
- en: '`OrderDestinations`, shown in the following listing, is a Spring `@ConfigurationProperties`
    class that enables the externalized configuration of backend service URLs.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderDestinations`，如以下列表所示，是一个 Spring `@ConfigurationProperties` 类，它允许外部化配置后端服务
    URL。'
- en: Listing 8.3\. The externalized configuration of backend service URLs
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 后端服务 URL 的外部化配置
- en: '[PRE2]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can, for example, specify the `URL` of the `Order Service` either as the
    `order.destinations.orderServiceUrl` property in a properties file or as an operating
    system environment variable, `ORDER_DESTINATIONS_ORDER_SERVICE_URL`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将 `Order Service` 的 `URL` 指定为一个属性文件中的 `order.destinations.orderServiceUrl`
    属性，或者指定为操作系统环境变量，`ORDER_DESTINATIONS_ORDER_SERVICE_URL`。
- en: The OrderHandlers class
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`OrderHandlers` 类'
- en: The `OrderHandlers` class, shown in the following listing, defines the request
    handler methods that implement custom behavior, including API composition. The
    `getOrderDetails()` method, for example, performs API composition to retrieve
    information about an order. This class is injected with several proxy classes
    that make requests to backend services.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中显示的 `OrderHandlers` 类定义了实现自定义行为的请求处理器方法，包括 API 组合。例如，`getOrderDetails()`
    方法执行 API 组合以检索有关订单的信息。此类注入了几个代理类，这些代理类向后端服务发送请求。
- en: Listing 8.4\. The `OrderHandlers` class implements custom request-handling logic.
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. `OrderHandlers` 类实现了自定义请求处理逻辑。
- en: '[PRE3]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Transform a TicketInfo into an Optional<TicketInfo>.**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 TicketInfo 转换为 Optional<TicketInfo>。**'
- en: '***2* If the service invocation failed, return Optional.empty().**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果服务调用失败，则返回 Optional.empty().**'
- en: '***3* Combine the four values into a single value, a Tuple4.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将四个值合并为一个单一值，即 Tuple4。**'
- en: '***4* Transform the Tuple4 into an OrderDetails.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 Tuple4 转换为 OrderDetails。**'
- en: '***5* Transform the OrderDetails into a ServerResponse.**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将 OrderDetails 转换为 ServerResponse。**'
- en: The `getOrderDetails()` method implements API composition to fetch the order
    details. It’s written in a scalable, reactive style using the `Mono` abstraction,
    which is provided by Project Reactor. A `Mono`, which is a richer kind of Java
    8 `CompletableFuture`, contains the outcome of an asynchronous operation that’s
    either a value or an exception. It has a rich API for transforming and combining
    the values returned by asynchronous operations. You can use `Monos` to write concurrent
    code in a style that’s simple and easy to understand. In this example, the `getOrderDetails()`
    method invokes the four services in parallel and combines the results to create
    an `OrderDetails` object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrderDetails()` 方法实现 API 组合以获取订单详情。它使用 Project Reactor 提供的 `Mono` 抽象以可扩展、响应式的方式编写，`Mono`
    是一种更丰富的 Java 8 `CompletableFuture`。它包含异步操作的结果，要么是一个值，要么是一个异常。它具有丰富的 API 用于转换和组合异步操作返回的值。您可以使用
    `Monos` 以简单易懂的方式编写并发代码。在此示例中，`getOrderDetails()` 方法并行调用四个服务，并将结果组合以创建一个 `OrderDetails`
    对象。'
- en: 'The `getOrderDetails()` method takes a `ServerRequest`, which is the Spring
    WebFlux representation of an HTTP request, as a parameter and does the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrderDetails()` 方法接受一个 `ServerRequest` 参数，这是 Spring WebFlux 对 HTTP 请求的表示，并执行以下操作：'
- en: It extracts the `orderId` from the path.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从路径中提取 `orderId`。
- en: It invokes the four services asynchronously via their proxies, which return
    `Monos`. In order to improve availability, `getOrderDetails()` treats the results
    of all services except the `OrderService` as optional. If a `Mono` returned by
    an optional service contains an exception, the call to `onErrorReturn()` transforms
    it into a `Mono` containing an empty `Optional`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过它们的代理异步调用四个服务，这些代理返回 `Monos`。为了提高可用性，`getOrderDetails()` 将除 `OrderService`
    之外的所有服务的返回结果视为可选的。如果一个可选服务返回的 `Mono` 包含异常，`onErrorReturn()` 调用将其转换为包含空 `Optional`
    的 `Mono`。
- en: It combines the results asynchronously using `Mono.when()`, which returns a
    `Mono<Tuple4>` containing the four values.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `Mono.when()` 异步组合结果，该方法返回一个包含四个值的 `Mono<Tuple4>`。
- en: It transforms the `Mono<Tuple4>` into a `Mono<OrderDetails>` by calling `OrderDetails::makeOrderDetails`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过调用 `OrderDetails::makeOrderDetails` 将 `Mono<Tuple4>` 转换为 `Mono<OrderDetails>`。
- en: It transforms the `OrderDetails` into a `ServerResponse`, which is the Spring
    WebFlux representation of the JSON/HTTP response.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将 `OrderDetails` 转换为 `ServerResponse`，这是 Spring WebFlux 对 JSON/HTTP 响应的表示。
- en: As you can see, because `getOrderDetails()` uses `Monos`, it concurrently invokes
    the services and combines the results without using messy, difficult-to-read callbacks.
    Let’s take a look at one of the service proxies that return the results of a service
    API call wrapped in a `Mono`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，因为 `getOrderDetails()` 使用 `Monos`，它并发调用服务并组合结果，而不使用混乱的、难以阅读的回调。让我们看看其中一个返回服务
    API 调用结果的 `Mono` 包装的服务代理。
- en: The OrderService class
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: The OrderService class
- en: The `OrderService` class, shown in the following listing, is a remote proxy
    for the `Order Service`. It invokes the `Order Service` using a `WebClient`, which
    is the Spring WebFlux reactive HTTP client.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的 `OrderService` 类是 `Order Service` 的远程代理。它使用 `WebClient` 调用 `Order
    Service`，`WebClient` 是 Spring WebFlux 反应式 HTTP 客户端。
- en: Listing 8.5\. `OrderService` class—a remote proxy for `Order Service`
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. `OrderService` 类——`Order Service` 的远程代理
- en: '[PRE4]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Invoke the service.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用服务。**'
- en: '***2* Convert the response body to an OrderInfo.**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将响应体转换为 OrderInfo。**'
- en: The `findOrder()` method retrieves the `OrderInfo` for an order. It uses the
    `WebClient` to make the HTTP request to the `Order Service` and deserializes the
    JSON response to an `OrderInfo`. `WebClient` has a reactive API, and the response
    is wrapped in a `Mono`. The `findOrder()` method uses `flatMap()` to transform
    the `Mono<ClientResponse>` into a `Mono<OrderInfo>`. As the name suggests, the
    `bodyToMono()` method returns the response body as a `Mono`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrder()` 方法检索订单的 `OrderInfo`。它使用 `WebClient` 向 `Order Service` 发送 HTTP
    请求并将 JSON 响应反序列化为 `OrderInfo`。`WebClient` 拥有反应式 API，响应被包装在 `Mono` 中。`findOrder()`
    方法使用 `flatMap()` 将 `Mono<ClientResponse>` 转换为 `Mono<OrderInfo>`。正如其名所示，`bodyToMono()`
    方法将响应体作为 `Mono` 返回。'
- en: The ApiGatewayApplication class
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: The ApiGatewayApplication class
- en: The `ApiGatewayApplication` class, shown in the following listing, implements
    the API gateway’s `main()` method. It’s a standard Spring Boot main class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的 `ApiGatewayApplication` 类实现了 API 网关的 `main()` 方法。它是一个标准的 Spring Boot
    主类。
- en: Listing 8.6\. The `main()` method for the API gateway
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. API 网关的 `main()` 方法
- en: '[PRE5]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@EnableGateway` annotation imports the Spring configuration for the Spring
    Cloud Gateway framework.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableGateway` 注解导入 Spring Cloud Gateway 框架的 Spring 配置。'
- en: 'Spring Cloud Gateway is an excellent framework for implementing an API gateway.
    It enables you to configure basic proxying using a simple, concise routing rules
    DSL. It’s also straightforward to route requests to handler methods that perform
    API composition and protocol translation. Spring Cloud Gateway is built using
    the scalable, reactive Spring Framework 5 and Project Reactor frameworks. But
    there’s another appealing option for developing your own API gateway: GraphQL,
    a framework that provides graph-based query language. Let’s look at how that works.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway 是实现 API 网关的出色框架。它允许您使用简单、简洁的路由规则 DSL 配置基本代理。将请求路由到执行 API
    组合和协议转换的处理程序方法也非常简单。Spring Cloud Gateway 是使用可扩展的、反应式的 Spring Framework 5 和 Project
    Reactor 框架构建的。但还有另一个吸引人的选项来开发自己的 API 网关：GraphQL，这是一个提供基于图查询语言的框架。让我们看看它是如何工作的。
- en: 8.3.3\. Implementing an API gateway using GraphQL
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 使用 GraphQL 实现一个 API 网关
- en: Imagine that you’re responsible for implementing the FTGO’s API Gateway’s `GET
    /orders/{orderId}` endpoint, which returns the order details. On the surface,
    implementing this endpoint might appear to be simple. But as described in [section
    8.1](#ch08lev1sec1), this endpoint retrieves data from multiple services. Consequently,
    you need to use the API composition pattern and write code that invokes the services
    and combines the results.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责实现FTGO的API网关的`GET /orders/{orderId}`端点，该端点返回订单详情。表面上，实现这个端点可能看起来很简单。但如[第8.1节](#ch08lev1sec1)所述，这个端点从多个服务中检索数据。因此，你需要使用API组合模式并编写调用服务并组合结果的代码。
- en: Another challenge, mentioned earlier, is that different clients need slightly
    different data. For example, unlike the mobile application, the desktop SPA application
    displays your rating for the order. One way to tailor the data returned by the
    endpoint, as described in [chapter 3](kindle_split_011.xhtml#ch03), is to give
    the client the ability to specify the data they need. An endpoint can, for example,
    support query parameters such as the `expand` parameter, which specifies the related
    resources to return, and the `field` parameter, which specifies the fields of
    each resource to return. The other option is to define multiple versions of this
    endpoint as part of applying the Backends for frontends pattern. This is a lot
    of work for just one of the many API endpoints that the FTGO’s API Gateway needs
    to implement.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战，如前所述，是不同的客户端需要稍微不同的数据。例如，与移动应用程序不同，桌面SPA应用程序显示你对订单的评分。如[第3章](kindle_split_011.xhtml#ch03)所述，调整端点返回的数据的一种方法，是给客户端提供指定所需数据的能力。例如，端点可以支持查询参数，如`expand`参数，它指定要返回的相关资源，以及`field`参数，它指定要返回的每个资源的字段。另一种选择是在应用前后端分离模式时定义此端点的多个版本。这对于FTGO的API网关需要实现的众多API端点之一来说，工作量很大。
- en: Implementing an API gateway with a REST API that supports a diverse set of clients
    well is time consuming. Consequently, you may want to consider using a graph-based
    API framework, such as GraphQL, that’s designed to support efficient data fetching.
    The key idea with graph-based API frameworks is that, as [figure 8.9](#ch08fig09)
    shows, the server’s API consists of a graph-based schema. The graph-based schema
    defines a set of *nodes* (types), which have *properties* (fields) and relationships
    with other nodes. The client retrieves data by executing a query that specifies
    the required data in terms of the graph’s nodes and their properties and relationships.
    As a result, a client can retrieve the data it needs in a single round-trip to
    the API gateway.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个支持多种客户端的REST API的API网关是耗时的。因此，你可能想要考虑使用一个基于图的API框架，如GraphQL，它旨在支持高效的数据检索。基于图API框架的关键思想是，如图8.9所示，服务器的API由一个基于图的架构组成。基于图的架构定义了一组*节点*（类型），它们具有*属性*（字段）与其他节点的关系。客户端通过执行一个查询来检索数据，该查询以图节点及其属性和关系为条件指定所需数据。因此，客户端可以在一次往返API网关中检索所需的数据。
- en: Figure 8.9\. The API gateway’s API consists of a graph-based schema that’s mapped
    to the services. A client issues a query that retrieves multiple graph nodes.
    The graph-based API framework executes the query by retrieving data from one or
    more services.
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.9。API网关的API由一个基于图的架构组成，该架构映射到服务上。客户端发出一个查询，检索多个图节点。基于图的API框架通过从一个或多个服务中检索数据来执行查询。
- en: '![](Images/08fig09_alt.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9的替代文本](Images/08fig09_alt.jpg)'
- en: Graph-based API technology has a couple of important benefits. It gives clients
    control over what data is returned. Consequently, developing a single API that’s
    flexible enough to support diverse clients becomes feasible. Another benefit is
    that even though the API is much more flexible, this approach significantly reduces
    the development effort. That’s because you write the server-side code using a
    query execution framework that’s designed to support API composition and projections.
    It’s as if, rather than force clients to retrieve data via stored procedures that
    you need to write and maintain, you let them execute queries against the underlying
    database.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的API技术有几个重要的好处。它使客户端能够控制返回哪些数据。因此，开发一个足够灵活的单个API以支持各种客户端变得可行。另一个好处是，尽管API更加灵活，但这种方法显著减少了开发工作量。这是因为你使用一个查询执行框架来编写服务器端代码，该框架旨在支持API组合和投影。这就像，而不是强迫客户端通过你需要编写和维护的存储过程来检索数据，你让他们对底层数据库执行查询。
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Schema-driven API technologies**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式驱动的API技术**'
- en: The two most popular graph-based API technologies are GraphQL ([http://graphql.org](http://graphql.org))
    and Netflix Falcor ([http://netflix.github.io/falcor/](http://netflix.github.io/falcor/)).
    Netflix Falcor models server-side data as a virtual JSON object graph. The Falcor
    client retrieves data from a Falcor server by executing a query that retrieves
    properties of that JSON object. The client can also update properties. In the
    Falcor server, the properties of the object graph are mapped to backend data sources,
    such as services with REST APIs. The server handles a request to set or get properties
    by invoking one or more backend data sources.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的基于图的API技术是GraphQL ([http://graphql.org](http://graphql.org)) 和Netflix Falcor
    ([http://netflix.github.io/falcor/](http://netflix.github.io/falcor/))。Netflix
    Falcor将服务器端数据建模为一个虚拟的JSON对象图。Falcor客户端通过执行查询来检索该JSON对象的属性来从Falcor服务器获取数据。客户端还可以更新属性。在Falcor服务器中，对象图的属性映射到后端数据源，例如具有REST
    API的服务。服务器通过调用一个或多个后端数据源来处理设置或获取属性的请求。
- en: GraphQL, developed by Facebook and released in 2015, is another popular graph-based
    API technology. It models the server-side data as a graph of objects that have
    fields and references to other objects. The object graph is mapped to backend
    data sources. GraphQL clients can execute queries that retrieve data and mutations
    that create and update data. Unlike Netflix Falcor, which is an implementation,
    GraphQL is a standard, with clients and servers available for a variety of languages,
    including NodeJS, Java, and Scala.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由Facebook开发并于2015年发布的GraphQL是另一种流行的基于图的API技术。它将服务器端数据建模为具有字段和指向其他对象的引用的对象图。对象图映射到后端数据源。GraphQL客户端可以执行查询以检索数据，以及创建和更新数据的突变。与Netflix
    Falcor不同，后者是一个实现，GraphQL是一个标准，它为包括NodeJS、Java和Scala在内的多种语言提供了客户端和服务器。
- en: Apollo GraphQL is a popular JavaScript/NodeJS implementation ([www.apollographql.com](http://www.apollographql.com)).
    It’s a platform that includes a GraphQL server and client. Apollo GraphQL implements
    some powerful extensions to the GraphQL specification, such as subscriptions that
    push changed data to the client.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo GraphQL是一个流行的JavaScript/NodeJS实现 ([www.apollographql.com](http://www.apollographql.com))。它是一个包含GraphQL服务器和客户端的平台。Apollo
    GraphQL实现了对GraphQL规范的某些强大扩展，例如将更改的数据推送到客户端的订阅。
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This section talks about how to develop an API gateway using Apollo GraphQL.
    I’m only going to cover a few of the key features of GraphQL and Apollo GraphQL.
    For more information, you should consult the GraphQL and Apollo GraphQL documentation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论如何使用Apollo GraphQL开发API网关。我只会介绍GraphQL和Apollo GraphQL的一些关键特性。更多详细信息，请参阅GraphQL和Apollo
    GraphQL文档。
- en: 'The GraphQL-based API gateway, shown in [figure 8.10](#ch08fig10), is written
    in JavaScript using the NodeJS Express web framework and the Apollo GraphQL server.
    The key parts of the design are as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 展示在[图8.10](#ch08fig10)中的基于GraphQL的API网关是用JavaScript和NodeJS Express Web框架以及Apollo
    GraphQL服务器编写的。设计的关键部分如下：
- en: '***GraphQL schema*—** The GraphQL schema defines the server-side data model
    and the queries it supports.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***GraphQL模式*—** GraphQL模式定义了服务器端数据模型及其支持的查询。'
- en: '***Resolver functions*—** The resolve functions map elements of the schema
    to the various backend services.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***解析函数*—** 解析函数将模式元素映射到各种后端服务。'
- en: '***Proxy classes*—** The proxy classes invoke the FTGO application’s services.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***代理类*—** 代理类调用FTGO应用程序的服务。'
- en: Figure 8.10\. The design of the GraphQL-based FTGO API Gateway
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10。基于GraphQL的FTGO API网关的设计
- en: '![](Images/08fig10_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig10_alt.jpg)'
- en: There’s also a small amount of glue code that integrates the GraphQL server
    with the Express web framework. Let’s look at each part, starting with the GraphQL
    schema.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些小的粘合代码，用于将GraphQL服务器与Express Web框架集成。让我们看看每个部分，从GraphQL模式开始。
- en: Defining a GraphQL schema
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义GraphQL模式
- en: 'A GraphQL API is centered around a *schema*, which consists of a collection
    of types that define the structure of the server-side data model and the operations,
    such as queries, that a client can perform. GraphQL has several different kinds
    of types. The example code in this section uses just two kinds of types: *object*
    types, which are the primary way of defining the data model, and *enums*, which
    are similar to Java enums. An object type has a name and a collection of typed,
    named fields. A *field* can be a scalar type, such as a number, string, or enum;
    a list of scalar types; a reference to another object type; or a collection of
    references to another object type. Despite resembling a field of a traditional
    object-oriented class, a GraphQL field is conceptually a function that returns
    a value. It can have arguments, which enable a GraphQL client to tailor the data
    the function returns.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 围绕一个 *schema*，它由一组类型组成，这些类型定义了服务器端数据模型的架构以及客户端可以执行的操作，如查询。GraphQL
    有几种不同类型的类型。本节中的示例代码只使用了两种类型的类型：*object* 类型，这是定义数据模型的主要方式，以及 *enums*，它们类似于 Java
    枚举。对象类型有一个名称和一组类型化的、命名的字段。*字段* 可以是标量类型，如数字、字符串或枚举；标量类型的列表；另一个对象类型的引用；或另一个对象类型的引用集合。尽管与传统面向对象类的字段相似，但
    GraphQL 字段在概念上是一个返回值的函数。它可以有参数，这使 GraphQL 客户端能够定制函数返回的数据。
- en: GraphQL also uses fields to define the queries supported by the schema. You
    define the schema’s queries by declaring an object type, which by convention is
    called `Query`. Each field of the `Query` object is a named query, which has an
    optional set of parameters, and a return type. I found this way of defining queries
    a little confusing when I first encountered it, but it helps to keep in mind that
    a GraphQL field is a function. It will become even clearer when we look at how
    fields are connected to the backend data sources.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 也使用字段来定义架构支持的查询。您通过声明一个对象类型来定义架构的查询，按照惯例称为 `Query`。`Query` 对象的每个字段都是一个命名查询，它有一个可选的参数集和一个返回类型。我发现当我第一次遇到这种方式定义查询时，有点困惑，但记住
    GraphQL 字段是一个函数会有所帮助。当我们查看字段如何连接到后端数据源时，这会变得更加清晰。
- en: The following listing shows part of the schema for the GraphQL-based FTGO API
    gateway. It defines several object types. Most of the object types correspond
    to the FTGO application’s `Consumer`, `Order`, and `Restaurant` entities. It also
    has a `Query` object type that defines the schema’s queries.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了基于 GraphQL 的 FTGO API 网关架构的一部分。它定义了几个对象类型。大多数对象类型对应于 FTGO 应用程序的 `Consumer`、`Order`
    和 `Restaurant` 实体。它还有一个 `Query` 对象类型，用于定义架构的查询。
- en: Listing 8.7\. The GraphQL schema for the FTGO API gateway
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. FTGO API 网关的 GraphQL 架构
- en: '[PRE6]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Defines the queries that a client can execute**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义客户端可以执行的查询***'
- en: '***2* The unique ID for a Consumer**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 消费者的唯一标识***'
- en: '***3* A consumer has a list of orders.**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 消费者有一系列订单。***'
- en: Despite having a different syntax, the `Consumer`, `Order`, `Restaurant`, and
    `DeliveryInfo` object types are structurally similar to the corresponding Java
    classes. One difference is the `ID` type, which represents a unique identifier.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语法不同，但 `Consumer`、`Order`、`Restaurant` 和 `DeliveryInfo` 对象类型在结构上与相应的 Java
    类相似。一个区别是 `ID` 类型，它代表一个唯一标识符。
- en: 'This schema defines three queries:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构定义了三个查询：
- en: '**`orders()`—** Returns the `Orders` for the specified `Consumer`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`orders()`—** 返回指定 `Consumer` 的 `Orders`'
- en: '**`order()`—** Returns the specified `Order`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`order()`—** 返回指定的 `Order`'
- en: '**`consumer()`—** Returns the specified `Consumer`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`consumer()`—** 返回指定的 `Consumer`'
- en: These queries may seem not different from the equivalent REST endpoints, but
    GraphQL gives the client tremendous control over the data that’s returned. To
    understand why, let’s look at how a client executes GraphQL queries.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询可能看起来与等效的 REST 端点没有太大区别，但 GraphQL 给客户端提供了对返回数据的巨大控制权。为了理解原因，让我们看看客户端是如何执行
    GraphQL 查询的。
- en: Executing GraphQL queries
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行 GraphQL 查询
- en: 'The principal benefit of using GraphQL is that its query language gives the
    client incredible control over the returned data. A client executes a query by
    making a request containing a query document to the server. In the simple case,
    a query document specifies the name of the query, the argument values, and the
    fields of the result object to return. Here’s a simple query that retrieves `firstName`
    and `lastName` of the consumer with a particular ID:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraphQL 的主要好处是其查询语言赋予客户端对返回数据的巨大控制权。客户端通过向服务器发送包含查询文档的请求来执行查询。在简单的情况下，查询文档指定查询的名称、参数值和要返回的结果对象字段。以下是一个检索具有特定
    ID 的消费者的 `firstName` 和 `lastName` 的简单查询：
- en: '[PRE7]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Specifies the query called consumer, which fetches a consumer**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定名为 consumer 的查询，该查询用于获取消费者**'
- en: '***2* The fields of the Consumer to return**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 要返回的 Consumer 字段**'
- en: This query returns those fields of the specified `Consumer`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回指定 `Consumer` 的那些字段。
- en: 'Here’s a more elaborate query that returns a consumer, their orders, and the
    ID and name of each order’s restaurant:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更复杂的查询，它返回消费者、他们的订单以及每个订单的餐厅的 ID 和名称：
- en: '[PRE8]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This query tells the server to return more than just the fields of the `Consumer`.
    It retrieves the consumer’s `Orders` and each `Order`’s restaurant. As you can
    see, a GraphQL client can specify exactly the data to return, including the fields
    of transitively related objects.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询指示服务器返回的不仅仅是 `Consumer` 的字段。它检索消费者的 `Orders` 以及每个 `Order` 的餐厅。如您所见，GraphQL
    客户端可以指定要返回的确切数据，包括传递相关对象的字段。
- en: 'The query language is more flexible than it might first appear. That’s because
    a query is a field of the `Query` object, and a query document specifies which
    of those fields the server should return. These simple examples retrieve a single
    field, but a query document can execute multiple queries by specifying multiple
    fields. For each field, the query document supplies the field’s arguments and
    specifies what fields of the result object it’s interested in. Here’s a query
    that retrieves two different consumers:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语言比乍看之下更灵活。这是因为查询是 `Query` 对象的一个字段，而查询文档指定了服务器应返回哪些字段。这些简单的示例检索单个字段，但查询文档可以通过指定多个字段来执行多个查询。对于每个字段，查询文档提供字段参数并指定它对结果对象中哪些字段感兴趣。以下是一个检索两个不同消费者的查询：
- en: '[PRE9]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this query document, `c1` and `c2` are what GraphQL calls *aliases*. They’re
    used to distinguish between the two `Consumers` in the result, which would otherwise
    both be called `consumer`. This example retrieves two objects of the same type,
    but a client could retrieve several objects of different types.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询文档中，`c1` 和 `c2` 是 GraphQL 所称的 *别名*。它们用于区分结果中的两个 `Consumers`，否则这两个都会被称作 `consumer`。此示例检索了相同类型的两个对象，但客户端可以检索不同类型的多个对象。
- en: A GraphQL schema defines the shape of the data and the supported queries. To
    be useful, it has to be connected to the source of the data. Let’s look at how
    to do that.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 模式定义了数据的形状和受支持的查询。为了有用，它必须连接到数据源。让我们看看如何做到这一点。
- en: Connecting the schema to the data
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将模式连接到数据
- en: When the GraphQL server executes a query, it must retrieve the requested data
    from one or more data stores. In the case of the FTGO application, the GraphQL
    server must invoke the APIs of the services that own the data. You associate a
    GraphQL schema with the data sources by attaching resolver functions to the fields
    of the object types defined by the schema. The GraphQL server implements the API
    composition pattern by invoking resolver functions to retrieve the data, first
    for the top-level query, and then recursively for the fields of the result object
    or objects.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GraphQL 服务器执行查询时，它必须从一个或多个数据存储中检索请求的数据。在 FTGO 应用程序的情况下，GraphQL 服务器必须调用拥有数据的服务的
    API。您通过将解析器函数附加到由模式定义的对象类型的字段来将 GraphQL 模式与数据源关联。GraphQL 服务器通过调用解析器函数来检索数据，首先为顶层查询，然后递归地为结果对象或对象的字段。
- en: The details of how resolver functions are associated with the schema depend
    on which GraphQL server you are using. [Listing 8.8](#ch08ex08) shows how to define
    the resolvers when using the Apollo GraphQL server. You create a doubly nested
    JavaScript object. Each top-level property corresponds to an object type, such
    as `Query` and `Order`. Each second-level property, such as `Order.consumer`,
    defines a field’s resolver function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器函数如何与模式关联的细节取决于你使用的 GraphQL 服务器。[列表 8.8](#ch08ex08) 展示了在使用 Apollo GraphQL
    服务器时如何定义解析器。你创建一个双层嵌套的 JavaScript 对象。每个顶层属性对应一个对象类型，例如 `Query` 和 `Order`。每个第二层属性，例如
    `Order.consumer`，定义了一个字段的解析器函数。
- en: Listing 8.8\. Attaching the resolver functions to fields of the GraphQL schema
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. 将解析器函数附加到 GraphQL 模式的字段
- en: '[PRE10]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The resolver for the orders query**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 查询的解析器***'
- en: '***2* The resolver for the consumer field of an Order**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 订单消费者字段的解析器**'
- en: 'A resolver function has three parameters:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器函数有三个参数：
- en: '***Object*—** For a top-level query field, such as `resolveOrders`, `object`
    is a root object that’s usually ignored by the resolver function. Otherwise, `object`
    is the value returned by the resolver for the parent object. For example, the
    resolver function for the `Order.consumer` field is passed the value returned
    by the `Order`’s resolver function.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***对象*—** 对于顶层查询字段，例如 `resolveOrders`，`object` 是一个根对象，通常解析器函数会忽略它。否则，`object`
    是解析器为父对象返回的值。例如，`Order.consumer` 字段的解析器函数接收 `Order` 解析器函数返回的值。'
- en: '***Query arguments*—** These are supplied by the query document.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***查询参数*—** 这些由查询文档提供。'
- en: '***Context*—** Global state of the query execution that’s accessible by all
    resolvers. It’s used, for example, to pass user information and dependencies to
    the resolvers.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***上下文*—** 查询执行的全局状态，所有解析器都可以访问。例如，它用于将用户信息和依赖项传递给解析器。'
- en: A resolver function might invoke a single service or it might implement the
    API composition pattern and retrieve data from multiple services. An Apollo GraphQL
    server resolver function returns a `Promise`, which is JavaScript’s version of
    Java’s `CompletableFuture`. The promise contains the object (or a list of objects)
    that the resolver function retrieved from the data store. GraphQL engine includes
    the return value in the result object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器函数可能调用单个服务，也可能实现 API 组合模式并从多个服务检索数据。Apollo GraphQL 服务器的解析器函数返回一个 `Promise`，这是
    JavaScript 的 `CompletableFuture` 版本。这个承诺包含解析器函数从数据存储中检索的对象（或对象列表）。GraphQL 引擎将返回值包含在结果对象中。
- en: 'Let’s look at a couple of examples. Here’s the `resolveOrders()` function,
    which is the resolver for the `orders` query:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子。这是 `resolveOrders()` 函数，它是 `orders` 查询的解析器：
- en: '[PRE11]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function obtains the `OrderServiceProxy` from the `context` and invokes
    it to fetch a consumer’s orders. It ignores its first parameter. It passes the
    `consumerId` argument, provided by the query document, to `OrderServiceProxy.findOrders()`.
    The `findOrders()` method retrieves the consumer’s orders from `OrderHistoryService`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从 `context` 获取 `OrderServiceProxy` 并调用它以获取消费者的订单。它忽略其第一个参数。它将查询文档提供的 `consumerId`
    参数传递给 `OrderServiceProxy.findOrders()`。`findOrders()` 方法从 `OrderHistoryService`
    检索消费者的订单。
- en: 'Here’s the `resolveOrderRestaurant()` function, which is the resolver for the
    `Order.restaurant` field that retrieves an order’s restaurant:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `resolveOrderRestaurant()` 函数，它是用于检索订单餐厅的 `Order.restaurant` 字段的解析器：
- en: '[PRE12]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Its first parameter is `Order`. It invokes `RestaurantServiceProxy.findRestaurant()`
    with the `Order`’s `restaurantId`, which was provided by `resolveOrders()`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个参数是 `Order`。它使用 `Order` 的 `restaurantId` 调用 `RestaurantServiceProxy.findRestaurant()`，这个
    `restaurantId` 是由 `resolveOrders()` 提供的。
- en: GraphQL uses a recursive algorithm to execute the resolver functions. First,
    it executes the resolver function for the top-level query specified by the Query
    document. Next, for each object returned by the query, it iterates through the
    fields specified in the Query document. If a field has a resolver, it invokes
    the resolver with the object and the arguments from the Query document. It then
    recurses on the object or objects returned by that resolver.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 使用递归算法来执行解析器函数。首先，它执行由查询文档指定的顶层查询的解析器函数。接下来，对于查询返回的每个对象，它遍历查询文档中指定的字段。如果一个字段有解析器，它将使用对象和查询文档中的参数调用解析器。然后，它递归处理该解析器返回的对象或对象。
- en: '[Figure 8.11](#ch08fig11) shows how this algorithm executes the query that
    retrieves a consumer’s orders and each order’s delivery information and restaurant.
    First, the GraphQL engine invokes `resolveConsumer()`, which retrieves `Consumer`.
    Next, it invokes `resolveConsumerOrders()`, which is the resolver for the `Consumer.orders`
    field that returns the consumer’s orders. The GraphQL engine then iterates through
    `Orders`, invoking the resolvers for the `Order.restaurant` and `Order.deliveryInfo`
    fields.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.11](#ch08fig11) 展示了该算法如何执行查询以检索消费者的订单以及每个订单的配送信息和餐厅。首先，GraphQL 引擎调用 `resolveConsumer()`，以检索
    `Consumer`。接下来，它调用 `resolveConsumerOrders()`，这是 `Consumer.orders` 字段的解析器，返回消费者的订单。然后，GraphQL
    引擎遍历 `Orders`，调用 `Order.restaurant` 和 `Order.deliveryInfo` 字段的解析器。'
- en: Figure 8.11\. GraphQL executes a query by recursively invoking the resolver
    functions for the fields specified in the Query document. First, it executes the
    resolver for the query, and then it recursively invokes the resolvers for the
    fields in the result object hierarchy.
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.11\. GraphQL 通过递归调用查询文档中指定的字段解析器来执行查询。首先，它执行查询的解析器，然后递归调用结果对象层次结构中的字段解析器。
- en: '![](Images/08fig11_alt.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig11_alt.jpg)'
- en: The result of executing the resolvers is a `Consumer` object populated with
    data retrieved from multiple services.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 执行解析器的结果是包含从多个服务检索到的数据的 `Consumer` 对象。
- en: Let’s now look at how to optimize the executing of resolvers by using batching
    and caching.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何通过使用批处理和缓存来优化解析器的执行。
- en: Optimizing loading using batching and caching
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用批处理和缓存优化加载
- en: GraphQL can potentially execute a large number of resolvers when executing a
    query. Because the GraphQL server executes each resolver independently, there’s
    a risk of poor performance due to excessive round-trips to the services. Consider,
    for example, a query that retrieves a consumer, their orders, and the orders’
    restaurants. If there are *N* orders, then a simplistic implementation would make
    one call to `Consumer Service`, one call to `Order History Service`, and then
    *N* calls to `Restaurant Service`. Even though the GraphQL engine will typically
    make the calls to `Restaurant Service` in parallel, there’s a risk of poor performance.
    Fortunately, you can use a few techniques to improve performance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行查询时，GraphQL 可能会执行大量解析器。由于 GraphQL 服务器独立执行每个解析器，因此存在因过度往返到服务而导致性能不佳的风险。例如，考虑一个检索消费者、他们的订单以及订单餐厅的查询。如果有
    *N* 个订单，那么简单的实现将向 `Consumer Service` 发起一次调用，向 `Order History Service` 发起一次调用，然后向
    `Restaurant Service` 发起 *N* 次调用。尽管 GraphQL 引擎通常会在并行调用 `Restaurant Service`，但仍然存在性能不佳的风险。幸运的是，您可以使用一些技术来提高性能。
- en: One important optimization is to use a combination of server-side batching and
    caching. *Batching* turns *N* calls to a service, such as `Restaurant Service`,
    into a single call that retrieves a batch of *N* objects. *Caching* reuses the
    result of a previous fetch of the same object to avoid making an unnecessary duplicate
    call. The combination of batching and caching significantly reduces the number
    of round-trips to backend services.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的优化是使用服务器端批处理和缓存的组合。*批处理* 将对服务（如 `Restaurant Service`）的 *N* 次调用转换为一个调用，该调用检索
    *N* 个对象。*缓存* 重新使用相同对象的先前获取结果，以避免进行不必要的重复调用。批处理和缓存的组合可以显著减少对后端服务的往返次数。
- en: A NodeJS-based GraphQL server can use the `DataLoader` module to implement batching
    and caching ([https://github.com/facebook/dataloader](https://github.com/facebook/dataloader)).
    It coalesces loads that occur within a single execution of the event loop and
    calls a batch loading function that you provide. It also caches calls to eliminate
    duplicate loads. The following listing shows how `RestaurantServiceProxy` can
    use `DataLoader`. The `findRestaurant()` method loads a `Restaurant` via `DataLoader`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 NodeJS 的 GraphQL 服务器可以使用 `DataLoader` 模块来实现批处理和缓存 ([https://github.com/facebook/dataloader](https://github.com/facebook/dataloader))。它将事件循环单次执行中发生的加载合并在一起，并调用您提供的批加载函数。它还会缓存调用以消除重复加载。以下列表显示了
    `RestaurantServiceProxy` 如何使用 `DataLoader`。`findRestaurant()` 方法通过 `DataLoader`
    加载 `Restaurant`。
- en: Listing 8.9\. Using a `DataLoader` to optimize calls to `Restaurant Service`
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 使用 `DataLoader` 优化对 `Restaurant Service` 的调用
- en: '[PRE13]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Create a DataLoader, which uses batchFindRestaurants() as the batch loading
    functions.**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个 DataLoader，使用 batchFindRestaurants() 作为批加载函数。**'
- en: '***2* Load the specified Restaurant via the DataLoader.**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过 DataLoader 加载指定的餐厅。**'
- en: '***3* Load a batch of Restaurants.**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 加载一批餐厅。**'
- en: '`RestaurantServiceProxy` and, hence, `DataLoader` are created for each request,
    so there’s no possibility of `DataLoader` mixing together different users’ data.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantServiceProxy`以及因此产生的`DataLoader`为每个请求创建，因此不存在`DataLoader`混合不同用户数据的可能性。'
- en: Let’s now look at how to integrate the GraphQL engine with a web framework so
    that it can be invoked by clients.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将GraphQL引擎与网络框架集成，以便客户端可以调用它。
- en: Integrating the Apollo GraphQL server with Express
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将Apollo GraphQL服务器与Express集成
- en: The Apollo GraphQL server executes GraphQL queries. In order for clients to
    invoke it, you need to integrate it with a web framework. Apollo GraphQL server
    supports several web frameworks, including Express, a popular NodeJS web framework.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo GraphQL服务器执行GraphQL查询。为了使客户端能够调用它，您需要将其与一个网络框架集成。Apollo GraphQL服务器支持多个网络框架，包括Express，这是一个流行的NodeJS网络框架。
- en: '[Listing 8.10](#ch08ex10) shows how to use the Apollo GraphQL server in an
    Express application. The key function is `graphqlExpress`, which is provided by
    the `apollo-server-express` module. It builds an Express request handler that
    executes GraphQL queries against a schema. This example configures Express to
    route requests to the `GET /graphql` and `POST /graphql` endpoints of this GraphQL
    request handler. It also creates a GraphQL context containing the proxies, which
    makes them available to the resolvers.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.10](#ch08ex10)展示了如何在Express应用程序中使用Apollo GraphQL服务器。关键函数是`graphqlExpress`，它由`apollo-server-express`模块提供。它构建了一个Express请求处理器，该处理器针对模式执行GraphQL查询。此示例配置Express将请求路由到此GraphQL请求处理器的`GET
    /graphql`和`POST /graphql`端点。它还创建了一个包含代理的GraphQL上下文，这使得它们对解析器可用。'
- en: Listing 8.10\. Integrating the GraphQL server with the Express web framework
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.10\. 将GraphQL服务器与Express网络框架集成
- en: '[PRE14]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Define the GraphQL schema.**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 定义GraphQL模式。**'
- en: '***2* Define the resolvers.**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 定义解析器。**'
- en: '***3* Combine the schema with the resolvers to create an executable schema.**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 将模式与解析器结合以创建可执行模式。**'
- en: '***4* Inject repositories into the context so they’re available to resolvers.**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4* 将仓库注入上下文中，以便它们对解析器可用。**'
- en: '***5* Make an express request handler that executes GraphQL queries against
    the executable schema.**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5* 创建一个Express请求处理器，用于执行针对可执行模式的GraphQL查询。**'
- en: '***6* Route POST /graphql and GET /graphql endpoints to the GraphQL server.**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6* 将POST /graphql和GET /graphql端点路由到GraphQL服务器。**'
- en: This example doesn’t handle concerns such as security, but those would be straightforward
    to implement. The API gateway could, for example, authenticate users using Passport,
    a NodeJS security framework described in [chapter 11](kindle_split_019.xhtml#ch11).
    The `makeContextWithDependencies()` function would pass the user information to
    each repository’s constructor so that they can propagate the user information
    to the services.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子没有处理诸如安全等问题，但这些问题的实现将非常直接。例如，API网关可以使用Passport，这是一个在[第11章](kindle_split_019.xhtml#ch11)中描述的NodeJS安全框架，来验证用户。`makeContextWithDependencies()`函数会将用户信息传递给每个仓库的构造函数，以便它们可以将用户信息传播到服务中。
- en: Let’s now look at how a client can invoke this server to execute GraphQL queries.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看客户端如何调用此服务器来执行GraphQL查询。
- en: Writing a GraphQL client
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写GraphQL客户端
- en: There are a couple of different ways a client application can invoke the GraphQL
    server. Because the GraphQL server has an HTTP-based API, a client application
    could use an HTTP library to make requests, such as `GET http://localhost:3000/graphql?query={orders(consumerId:1){orderId,restaurant{id}}}'`.
    It’s easier, though, to use a GraphQL client library, which takes care of properly
    formatting requests and typically provides features such as client-side caching.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序可以以几种不同的方式调用GraphQL服务器。因为GraphQL服务器有一个基于HTTP的API，客户端应用程序可以使用HTTP库来发送请求，例如`GET
    http://localhost:3000/graphql?query={orders(consumerId:1){orderId,restaurant{id}}}'`。然而，使用GraphQL客户端库更容易，它负责正确格式化请求，并通常提供客户端缓存等特性。
- en: The following listing shows the `FtgoGraphQLClient` class, which is a simple
    GraphQL-based client for the FTGO application. Its constructor instantiates `ApolloClient`,
    which is provided by the Apollo GraphQL client library. The `FtgoGraphQLClient`
    class defines a `findConsumer()` method that uses the client to retrieve the name
    of a consumer.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了`FtgoGraphQLClient`类，这是一个简单的基于GraphQL的FTGO应用程序客户端。它的构造函数实例化了`ApolloClient`，这是由Apollo
    GraphQL客户端库提供的。`FtgoGraphQLClient`类定义了一个`findConsumer()`方法，该方法使用客户端检索消费者的名称。
- en: Listing 8.11\. Using the Apollo GraphQL client to execute queries
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.11\. 使用Apollo GraphQL客户端执行查询
- en: '[PRE15]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Supply the value of the $cid.**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 提供值 $cid。'
- en: '***2* Define $cid as a variable of type Int.**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 定义 $cid 为 Int 类型的变量。'
- en: '***3* Set the value of query parameter consumerid to $cid.**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 将查询参数 consumerid 的值设置为 $cid。'
- en: The `FtgoGraphQLClient` class can define a variety of query methods, such as
    `findConsumer()`. Each one executes a query that retrieves exactly the data needed
    by the client.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`FtgoGraphQLClient` 类可以定义各种查询方法，例如 `findConsumer()`。每个方法都执行一个查询，精确地检索客户端所需的数据。'
- en: This section has barely scratched the surface of GraphQL’s capabilities. I hope
    I’ve demonstrated that GraphQL is a very appealing alternative to a more traditional,
    REST-based API gateway. It lets you implement an API that’s flexible enough to
    support a diverse set of clients. Consequently, you should consider using GraphQL
    to implement your API gateway.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节只是浅尝辄止地介绍了 GraphQL 的功能。我希望我已经证明 GraphQL 是一个非常有吸引力的替代方案，用于更传统的基于 REST 的 API
    网关。它允许您实现一个灵活的 API，足以支持多样化的客户端。因此，您应该考虑使用 GraphQL 来实现您的 API 网关。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Your application’s external clients usually access the application’s services
    via an API gateway. An API gateway provides each client with a custom API. It’s
    responsible for request routing, API composition, protocol translation, and implementation
    of edge functions such as authentication.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的外部客户端通常通过 API 网关访问应用程序的服务。API 网关为每个客户端提供定制的 API。它负责请求路由、API 组合、协议转换以及实现边缘功能，如身份验证。
- en: Your application can have a single API gateway or it can use the Backends for
    frontends pattern, which defines an API gateway for each type of client. The main
    advantage of the Backends for frontends pattern is that it gives the client teams
    greater autonomy, because they develop, deploy, and operate their own API gateway.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序可以有一个单独的 API 网关，或者可以使用前端后端模式，为每种类型的客户端定义一个 API 网关。前端后端模式的主要优势是它给予客户端团队更大的自主权，因为他们可以开发、部署和运行自己的
    API 网关。
- en: There are numerous technologies you can use to implement an API gateway, including
    off-the-shelf API gateway products. Alternatively, you can develop your own API
    gateway using a framework.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用多种技术来实现 API 网关，包括现成的 API 网关产品。或者，您可以使用框架开发自己的 API 网关。
- en: Spring Cloud Gateway is a good, easy-to-use framework for developing an API
    gateway. It routes requests using any request attribute, including the method
    and the path. Spring Cloud Gateway can route a request either directly to a backend
    service or to a custom handler method. It’s built using the scalable, reactive
    Spring Framework 5 and Project Reactor frameworks. You can write your custom request
    handlers in a reactive style using, for example, Project Reactor’s `Mono` abstraction.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway 是一个开发 API 网关的好用且易于使用的框架。它使用任何请求属性路由请求，包括方法和路径。Spring Cloud
    Gateway 可以将请求直接路由到后端服务或自定义处理方法。它是使用可扩展的、反应式的 Spring Framework 5 和 Project Reactor
    框架构建的。您可以使用 Project Reactor 的 `Mono` 抽象，以反应式风格编写自定义请求处理器。
- en: GraphQL, a framework that provides graph-based query language, is another excellent
    foundation for developing an API Gateway. You write a graph-oriented schema to
    describe the server-side data model and its supported queries. You then map that
    schema to your services by writing resolvers, which retrieve data. GraphQL-based
    clients execute queries against the schema that specify exactly the data that
    the server should return. As a result, a GraphQL-based API gateway can support
    diverse clients.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL，一个提供基于图查询语言的框架，是开发 API 网关的另一个优秀基础。您编写一个面向图的模式来描述服务器端数据模型及其支持的查询。然后通过编写解析器将此模式映射到您的服务上，解析器用于检索数据。基于
    GraphQL 的客户端针对指定服务器应返回的确切数据的模式执行查询。因此，基于 GraphQL 的 API 网关可以支持多样化的客户端。
