- en: 4 The DataFrame object
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 DataFrame 对象
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Instantiating `DataFrame` objects from dictionaries and NumPy `ndarrays`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字典和 NumPy `ndarrays` 实例化 `DataFrame` 对象
- en: Importing `DataFrame`s from CSV files with the `read_csv` function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `read_csv` 函数从 CSV 文件导入 `DataFrame`
- en: Sorting `DataFrame` columns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序 `DataFrame` 列
- en: Accessing rows and columns in a `DataFrame`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 `DataFrame` 中的行和列
- en: Setting and resetting a `DataFrame` index
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和重置 `DataFrame` 索引
- en: Renaming columns and index labels in a `DataFrame`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `DataFrame` 中重命名列和索引标签
- en: The pandas `DataFrame` is a two-dimensional table of data with rows and columns.
    As with a `Series`, pandas assigns an index label and an index position to each
    `DataFrame` row. Pandas also assigns a label and a position to each column. The
    `DataFrame` is two-dimensional because it requires two points of reference—a row
    and a column—to isolate a value from the data set. Figure 4.1 displays a visual
    example of a pandas `DataFrame`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的 `DataFrame` 是一个二维数据表，具有行和列。与 `Series` 一样，pandas 为每个 `DataFrame` 行分配一个索引标签和索引位置。Pandas
    还为每个列分配一个标签和位置。`DataFrame` 是二维的，因为它需要两个参考点——行和列——来从数据集中隔离一个值。图 4.1 显示了 pandas
    `DataFrame` 的视觉示例。
- en: '![](../Images/CH04_F01_Paskhaver.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F01_Paskhaver.png)'
- en: Figure 4.1 A visual representation of a pandas `DataFrame` with five rows and
    two columns
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 pandas `DataFrame` 的五行两列的视觉表示
- en: The `DataFrame` is the workhorse of the pandas library and the data structure
    you’ll be working with most on a daily basis, so we’ll be spending the remainder
    of this book exploring its vast features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame` 是 pandas 库中的工作马，是你每天都会大量使用的数据结构，因此我们将在这本书的剩余部分探索其丰富的功能。'
- en: 4.1 Overview of a DataFrame
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 DataFrame 概述
- en: 'As always, let’s spin up a new Jupyter Notebook and import pandas. We also
    need the NumPy library, which we’ll use in section 4.1.2 to generate random data.
    NumPy is usually assigned the alias `np`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，让我们启动一个新的 Jupyter Notebook 并导入 pandas。我们还需要 NumPy 库，我们将在 4.1.2 节中使用它来生成随机数据。NumPy
    通常被分配别名 `np`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `DataFrame` class constructor is available at the top level of pandas.
    The syntax for instantiating a `DataFrame` object is identical to the one for
    instantiating a `Series`. We access the `DataFrame` class and instantiate with
    a pair of parentheses: `pd.DataFrame``()`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame` 类构造函数位于 pandas 的顶层。实例化 `DataFrame` 对象的语法与实例化 `Series` 的语法相同。我们通过一对括号访问
    `DataFrame` 类并实例化：`pd.DataFrame()`。'
- en: 4.1.1 Creating a DataFrame from a dictionary
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 从字典创建 DataFrame
- en: 'The constructor’s first parameter, `data`, expects the data that will populate
    the `DataFrame`. One suitable input is a Python dictionary in which the keys are
    column names and the values are column values. The next example passes a dictionary
    of string keys and list values. Pandas returns a `DataFrame` with three columns.
    Each list element becomes a value in its respective column:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的第一个参数 `data` 期望填充 `DataFrame` 的数据。一个合适的输入是键为列名、值为列值的 Python 字典。下一个示例传递一个键为字符串、值为列表的字典。Pandas
    返回一个包含三个列的 `DataFrame`。每个列表元素成为其相应列的值：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We officially have a `DataFrame`! Notice that the data structure is rendered
    differently from a `Series`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正式拥有了一个 `DataFrame`！注意，数据结构与 `Series` 的渲染方式不同。
- en: '**A** `DataFrame` holds an index of row labels. We did not provide the constructor
    a custom index, so pandas generated a numeric one starting at 0\. The logic operates
    the same way it does on a `Series`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** `DataFrame` 包含行标签的索引。我们没有向构造函数提供自定义索引，因此 pandas 从 0 开始生成一个数字索引。逻辑操作与
    `Series` 上的操作相同。'
- en: A `DataFrame` can hold multiple columns of data. It’s helpful to think of the
    column headers as a second index. City, Country, and Population are three index
    labels on the column axis; pandas assigns them the index positions 0, 1, and 2,
    respectively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame` 可以包含多个数据列。将列标题视为第二个索引是有帮助的。City、Country 和 Population 是列轴上的三个索引标签；pandas
    分别将它们分配索引位置 0、1 和 2。'
- en: 'What if we wanted to swap the column headers with the index labels? Two options
    are available here. We can invoke the `transpose` method on the `DataFrame` or
    access its `T` attribute:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想交换列标题和索引标签呢？这里有两种选择。我们可以在 `DataFrame` 上调用 `transpose` 方法，或者访问其 `T` 属性：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous example serves as a reminder that pandas can store index labels
    of different data types. In the previous output, the columns use the same value
    for index labels and index positions. The rows have different labels (City, Country,
    Population) and positions (0, 1, and 2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子提醒我们，pandas 可以存储不同数据类型的索引标签。在上一个输出中，列使用相同的值作为索引标签和索引位置。行有不同的标签（城市、国家、人口）和位置（0、1
    和 2）。
- en: 4.1.2 Creating a DataFrame from a NumPy ndarray
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 从 NumPy ndarray 创建 DataFrame
- en: 'Let’s try one more example. The `DataFrame` constructor’s `data` parameter
    also accepts a NumPy `ndarray`. We can generate an `ndarray` of any size with
    the `randint` function in NumPy’s `random` module. The next example creates a
    3 x 5 `ndarray` of integers between 1 and 101 (exclusive):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个例子。`DataFrame` 构造函数的 `data` 参数也接受 NumPy 的 `ndarray`。我们可以使用 NumPy 的 `random`
    模块中的 `randint` 函数生成任何大小的 `ndarray`。下一个示例创建一个介于 1 和 101（不包括 101）之间的整数的 3 x 5 `ndarray`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you’d like more information on random data generation in NumPy, see appen-
    dix C.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 NumPy 中随机数据生成的信息，请参阅附录 C。
- en: 'Next, let’s pass our `ndarray` into the `DataFrame` constructor. The `ndarray`
    has neither row labels nor column labels. Thus, pandas uses a numeric index for
    both the row axis and column axis:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的 `ndarray` 传递给 `DataFrame` 构造函数。`ndarray` 没有行标签也没有列标签。因此，pandas 使用数字索引作为行轴和列轴：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can manually set the row labels with the `DataFrame` constructor’s `index`
    parameter, which accepts any iterable object, including a list, tuple, or `ndarray`.
    Note that the iterable’s length must be equal to the data set’s number of rows.
    We’re passing a 3 x 5 `ndarray`, so we must provide three row labels:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `DataFrame` 构造函数的 `index` 参数手动设置行标签，该参数接受任何迭代对象，包括列表、元组或 `ndarray`。请注意，迭代器的长度必须等于数据集的行数。我们传递一个
    3 x 5 的 `ndarray`，因此我们必须提供三个行标签：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can set the column names with the constructor’s `columns` parameter. The
    `ndarray` includes five columns, so we must pass an iterable with five items.
    The next example passes the column names in a tuple:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用构造函数的 `columns` 参数设置列名。`ndarray` 包含五个列，因此我们必须传递一个包含五个元素的迭代器。下一个示例通过元组传递列名：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pandas permits duplicates in the row and column indices. In the next example,
    `"Morning"` appears twice in the rows’ index labels, and `"Tuesday"` appears twice
    in the columns’ index labels:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 允许行和列索引有重复。在下一个示例中，`"Morning"` 在行索引标签中出现了两次，而 `"Tuesday"` 在列索引标签中出现了两次：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we mentioned in earlier chapters, it’s ideal to have unique indices when
    possible. If there are no duplicates, it is easier for pandas to extract a specific
    row or column.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，当可能时，拥有唯一的索引是理想的。如果没有重复，pandas 提取特定行或列会更容易。
- en: 4.2 Similarities between Series and DataFrames
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 Series 和 DataFrame 之间的相似性
- en: Many `Series` attributes and methods are also available on `DataFrames`. Their
    implementations can vary; pandas must account for multiple columns and two separate
    axes now.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 `Series` 属性和方法也适用于 `DataFrames`。它们的实现可能有所不同；pandas 必须现在考虑多列和两个独立的轴。
- en: 4.2.1 Importing a DataFrame with the read_csv function
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 使用 read_csv 函数导入 DataFrame
- en: The nba.csv data set is a list of professional basketball players in the National
    Basketball Association (NBA) during the 2019–20 season. Each row includes a player’s
    name, team, position, birthday, and salary. A good mix of data types is scattered
    throughout, making this data set excellent for exploring the basics of `DataFrames`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: nba.csv 数据集是 2019-20 赛季美国国家篮球协会（NBA）职业篮球运动员的列表。每一行包括一名球员的姓名、球队、位置、生日和薪水。数据类型的好组合散布在整个数据集中，这使得这个数据集非常适合探索
    `DataFrame` 的基础知识。
- en: 'Let’s use the `read_csv` function at the top level of pandas to import the
    file (we introduced this function in chapter 3). The function accepts a filename
    as its first argument and returns a `DataFrame` by default. Before you execute
    the following code, please make sure that the data set is in the same directory
    as your Jupyter Notebook:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 pandas 的顶级 `read_csv` 函数导入文件（我们在第 3 章介绍了这个函数）。该函数接受一个文件名作为其第一个参数，默认返回一个
    `DataFrame`。在执行以下代码之前，请确保数据集与你的 Jupyter Notebook 在同一目录下：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the bottom of the output, pandas informs us that the data has 450 rows and
    5 columns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的底部，pandas 通知我们数据有 450 行和 5 列。
- en: 'Before we assign the `DataFrame` to a variable, let’s make one optimization.
    Pandas imports the Birthday column values as strings rather than as datetimes,
    limiting the number of operations we can perform on them. We can use the `parse_dates`
    parameter to coerce the values into datetimes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 `DataFrame` 赋值给变量之前，让我们进行一个优化。Pandas 将生日列的值作为字符串而不是日期时间值导入，这限制了我们可以对这些值执行的操作数量。我们可以使用
    `parse_dates` 参数将值强制转换为日期时间：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Much better! Now we have a column of datetimes. Pandas displays the datetime
    values in conventional YYYY-MM-DD format. I’m happy with the import, so we can
    assign the `DataFrame` to a variable like `nba`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了！现在我们有一个日期时间列。Pandas 以传统的 YYYY-MM-DD 格式显示日期时间值。我很高兴导入成功，因此我们可以将 `DataFrame`
    赋值给变量，比如 `nba`：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s helpful to think of a `DataFrame` as being a collection of `Series` objects
    with a common index. In this example, the five columns in `nba` (Name, Team, Position,
    Birthday, and Salary) share the same row index. Let’s get to work exploring the
    `DataFrame`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `DataFrame` 想象成一系列具有公共索引的 `Series` 对象是有帮助的。在这个例子中，`nba` 中的五个列（姓名、球队、位置、生日和薪水）共享相同的行索引。让我们开始探索
    `DataFrame` 吧。
- en: 4.2.2 Shared and exclusive attributes of Series and DataFrames
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 `Series` 和 `DataFrames` 的共享和独有属性
- en: 'Attributes and methods may differ between `Series` and `DataFrames`, both in
    name and implementation. Here’s an example. A `Series` has a `dtype` attribute
    that reveals the data type of its values (see chapter 2). Notice that the `dtype`
    attribute is singular because a `Series` can store only one data type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 和 `DataFrames` 的属性和方法可能在名称和实现上有所不同。以下是一个例子。`Series` 有一个 `dtype` 属性，它揭示了其值的类型（见第
    2 章）。请注意，`dtype` 属性是单数的，因为 `Series` 只能存储一种数据类型：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By comparison, a `DataFrame` can hold heterogeneous data. *Heterogeneous* means
    mixed or varied. One column can hold integers, and another can hold strings. A
    `DataFrame` has a unique `dtypes` attribute. (Notice that the name is plural.)
    The attribute returns a `Series` with the `DataFrame`’s columns as the index labels
    and the columns’ data types as the values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`DataFrame` 可以存储异构数据。`异构` 意味着混合或不同。一列可以存储整数，另一列可以存储字符串。`DataFrame` 有一个独特的
    `dtypes` 属性。（注意名称是复数。）该属性返回一个以 `DataFrame` 的列作为索引标签，列的数据类型作为值的 `Series`：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Name, Team, and Position columns list `object` as their data type. The `object`
    data type is pandas’ lingo for complex objects including strings. Thus, the `nba`
    `DataFrame` has three string columns, one datetime column, and one integer column.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名、球队和位置列将 `object` 列为其数据类型。`object` 数据类型是 pandas 对复杂对象的术语，包括字符串。因此，`nba` `DataFrame`
    有三个字符串列，一个日期时间列和一个整数列。
- en: 'We can invoke the `value_counts` method on the `Series` to count the number
    of columns storing each data type:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Series` 上调用 `value_counts` 方法来计算存储每种数据类型的列数：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`dtype` versus `dtypes` is one example of the different attributes between
    `Series` and `DataFrames`. But the two data structures also have many attributes
    and methods in common.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype` 与 `dtypes` 是 `Series` 和 `DataFrames` 之间不同属性的一个例子。但这两个数据结构也有许多共同的属性和方法。'
- en: 'A `DataFrame` consists of several smaller objects: an index that holds the
    row labels, an index that holds the column labels, and a data container that holds
    the values. The `index` attribute exposes the index of the `DataFrame`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `DataFrame` 由几个较小的对象组成：一个包含行标签的索引，一个包含列标签的索引，以及一个包含值的值容器。`index` 属性暴露了 `DataFrame`
    的索引：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have a `RangeIndex`, an index optimized for storing a sequence of
    numeric values. A `RangeIndex` object includes three attributes: `start` (the
    inclusive lower bound), `stop` (the exclusive upper bound), and `step` (the interval
    or step sequence between every two values). The output above tells us that `nba`’s
    index starts counting at 0 and proceeds to 450 in increments of 1.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个 `RangeIndex`，这是一个优化存储一系列数值的索引。`RangeIndex` 对象包括三个属性：`start`（包含的下限），`stop`（排除的上限），和
    `step`（每两个值之间的间隔或步长）。上面的输出告诉我们 `nba` 的索引从 0 开始计数，以 1 为增量递增到 450。
- en: 'Pandas uses a separate index object to store a `DataFrame`’s columns. We can
    access it via the `columns` attribute:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 使用一个单独的索引对象来存储 `DataFrame` 的列。我们可以通过 `columns` 属性访问它：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This object is another type of index object: `Index`. Pandas uses this option
    when an index consists of text values.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象是另一种索引对象：`Index`。Pandas 在索引由文本值组成时使用此选项。
- en: The `index` attribute is an example of an attribute that a `DataFrame` shares
    with a `Series`. The `columns` attribute is an example of an attribute that is
    exclusive to a `DataFrame`. A `Series` has no concept of columns.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`属性是一个`DataFrame`与`Series`共享的属性的例子。`columns`属性是一个仅属于`DataFrame`的属性的例子。`Series`没有列的概念。'
- en: 'The `ndim` attribute returns the number of dimensions in a pandas object. A
    `DataFrame` has two:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndim`属性返回pandas对象中的维度数。`DataFrame`有两个：'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `shape` attribute returns the `DataFrame`’s dimensions in a tuple. The
    `nba` data set has 450 rows and 5 columns:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape`属性以元组的形式返回`DataFrame`的维度。`nba`数据集有450行和5列：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `size` attribute calculates the total number of values in the data set.
    Missing values (such as `NaNs`) are included in the count:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`属性计算数据集中的总值数。缺失值（如`NaNs`）包含在计数中：'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we want to exclude missing values, the `count` method returns a `Series`
    with the counts of present values per column:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要排除缺失值，`count`方法返回一个包含每列当前值计数的`Series`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can add all these `Series` values with the `sum` method to arrive at the
    number of non-null values in the `DataFrame`. The `nba` `DataFrame` data set holds
    no missing values, so the `size` attribute and the `sum` method return the same
    result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sum`方法将这些`Series`值相加，以得到`DataFrame`中非空值的数量。`nba` `DataFrame`数据集没有缺失值，所以`size`属性和`sum`方法返回相同的结果：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s an example illustrating the differences between the `size` attribute
    and the `count` method. Let’s create a `DataFrame` with a missing value. We can
    access `nan` as a top-level attribute on the NumPy package:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，说明了`size`属性和`count`方法之间的区别。让我们创建一个包含缺失值的`DataFrame`。我们可以将`nan`作为NumPy包的顶层属性访问：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `size` attribute returns `4` because the `DataFrame` has four cells:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`属性返回`4`，因为`DataFrame`有四个单元格：'
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By comparison, the `sum` method returns `3` because the `DataFrame` has three
    non-null values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`sum`方法返回`3`，因为`DataFrame`有三个非空值：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The A column has one present value, and the B column has two present values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: A列有一个当前值，B列有两个当前值。
- en: 4.2.3 Shared methods of Series and DataFrames
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 Series和DataFrame的共享方法
- en: '`DataFrame`s and `Series` have methods in common too. We can use the `head`
    method to extract rows from the top of a `DataFrame`, for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`和`Series`也有共同的方法。我们可以使用`head`方法从`DataFrame`的顶部提取行，例如：'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `tail` method returns rows from the bottom of the `DataFrame`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`方法返回`DataFrame`底部的行：'
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The two methods default to returning five rows when invoked without an argument:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法在没有参数的情况下默认返回五行：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `sample` method extracts random rows from the `DataFrame`. Its first parameter
    specifies the number of rows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample`方法从`DataFrame`中提取随机行。它的第一个参数指定了行数：'
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Suppose that we want to find out how many teams, salaries, and positions exist
    in this data set. In chapter 2, we used the `nunique` method to count the number
    of unique values in a `Series`. When we invoke the same method on a `DataFrame`,
    it returns a `Series` object with counts of unique values per column:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找出这个数据集中存在多少支队伍、薪资和职位。在第2章中，我们使用了`nunique`方法来计算`Series`中唯一值的数量。当我们对`DataFrame`调用相同的方法时，它返回一个包含每列唯一值计数的`Series`对象：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are 30 unique teams, 269 unique salaries, and 9 unique positions in `nba`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nba`中，有30个唯一的队伍，269个唯一的薪资和9个唯一的职位。
- en: 'You may also recall the `max` and `min` methods. On a `DataFrame`, the `max`
    method returns a `Series` with the maximum value from each column. The maximum
    value in a text column is the string closest to the end of the alphabet. The maximum
    value in a datetime column is the latest date in chronological order:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得`max`和`min`方法。在`DataFrame`上，`max`方法返回一个包含每列最大值的`Series`。文本列中的最大值是字母表中接近末尾的字符串。日期时间列中的最大值是按时间顺序最晚的日期：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `min` method returns a `Series` with the minimum value from each column
    (the smallest number, the string closest to the start of the alphabet, the earliest
    date, and so on):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`方法返回一个包含每列最小值的`Series`（最小的数字，字母表中接近开头的字符串，最早的日期，等等）：'
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What if we want to identify multiple max values, such as the four highest-paid
    players in the data set? The `nlargest` method retrieves a subset of rows in which
    a given column has the largest values in the `DataFrame`. We pass the number of
    rows to extract to its `n` parameter and the column to use for sorting to its
    `columns` parameter. The next example extracts the `DataFrame` rows that have
    the four largest values in the Salary column:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要识别多个最大值，例如数据集中的四位最高薪球员？`nlargest`方法可以检索具有`DataFrame`中给定列最大值的行子集。我们通过将其`n`参数传递要提取的行数，并通过其`columns`参数传递用于排序的列：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our next challenge is finding the three oldest players in the league. We can
    accomplish this task by getting the three earliest dates in the Birthday column.
    The `nsmallest` method can help us; it returns a subset of rows in which a given
    column has the smallest values in the data set. The smallest datetime values are
    those that occur earliest in chronological order. Note that the `nlargest` and
    `nsmallest` methods can be invoked only on numeric or datetime columns:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个挑战是找到联盟中最年长的三位球员。我们可以通过获取生日列中的三个最早日期来完成这项任务。`nsmallest`方法可以帮助我们；它返回具有数据集中给定列最小值的行子集。最小的日期时间值是那些在时间顺序中最早发生的。请注意，`nlargest`和`nsmallest`方法只能用于数值或日期时间列：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What if we want to calculate the sum of all NBA salaries? The `DataFrame` includes
    a `sum` method for this purpose:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要计算所有NBA球员的薪资总和呢？`DataFrame`包含一个`sum`方法用于此目的：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We do get the answer we want, but the output is a bit messy. By default, pandas
    adds the values in each column. For text columns, the library concatenates all
    strings into one. To limit the addition to numeric volumes, we can pass `True`
    to the `sum` method’s `numeric_only` parameter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实得到了我们想要的答案，但输出有点杂乱。默认情况下，pandas会在每个列中添加值。对于文本列，库将所有字符串连接成一个。要限制添加到数值总量，我们可以将`True`传递给`sum`方法的`numeric_only`参数：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The total combined salaries of these 450 NBA players is a whopping $3.4 billion.
    We can calculate the average salary with the `mean` method. The method accepts
    the same `numeric_only` parameter to target only numeric columns:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这450名NBA球员的总薪资高达34亿美元。我们可以使用`mean`方法来计算平均薪资。该方法接受相同的`numeric_only`参数，以仅针对数值列：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A `DataFrame` also includes methods for statistical calculations such as median,
    mode, and standard deviation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`还包括用于统计计算的诸如中位数、众数和标准差的方法：'
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For advanced statistical methods, check out the official `Series` documentation
    ([http://mng.bz/myDa](http://mng.bz/myDa)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级统计方法，请查看官方的`Series`文档([http://mng.bz/myDa](http://mng.bz/myDa))。
- en: 4.3 Sorting a DataFrame
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 对DataFrame进行排序
- en: Our data set’s rows arrived in jumbled, random order, but that’s no problem!
    We can sort a `DataFrame` by one or more columns by using the `sort_values` method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集行以混乱、随机的顺序到达，但这不是问题！我们可以通过使用`sort_values`方法按一个或多个列对`DataFrame`进行排序。
- en: 4.3.1 Sorting by a single column
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 按单列排序
- en: 'Let’s first sort our players in alphabetical order by name. The `sort_values`
    method’s first parameter, `by`, accepts the column that pandas should use to sort
    the `DataFrame`. Let’s pass in the Name column as a string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先按姓名的字母顺序对球员进行排序。`sort_values`方法的第一参数`by`接受pandas应使用的列以对`DataFrame`进行排序。让我们将名称列作为字符串传递：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `sort_values` method’s `ascending` parameter determines the sort order;
    it has a default argument of `True`. By default, pandas will sort a column of
    numbers in increasing order, a column of strings in alphabetical order, and a
    column of datetimes in chronological order.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_values`方法的`ascending`参数确定排序顺序；它有一个默认参数为`True`。默认情况下，pandas将按升序对数字列进行排序，对字符串列按字母顺序排序，对日期时间列按时间顺序排序。'
- en: 'If we wanted to sort the names in reverse alphabetical order, we could pass
    the `ascending` parameter a `False` instead:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要按逆字母顺序对名称进行排序，我们可以将`ascending`参数传递为`False`：
- en: '[PRE38]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s another example: what if we want to find the five youngest players in
    `nba` without using the `nsmallest` method? We could sort the Birthday column
    in reverse chronological order by using the `sort_values` method with `ascending`
    set to `False` and then take five rows off the top with the `head` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：如果我们想在不使用`nsmallest`方法的情况下找到`nba`中的五位最年轻球员怎么办？我们可以通过使用`sort_values`方法并将`ascending`设置为`False`来按逆时间顺序对生日列进行排序，然后使用`head`方法取前五行：
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The youngest player in `nba` appears first in the output. That player is Sekou
    Doumbouya, who was born December 23, 2000.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`nba` 中最年轻球员在输出中排在第一位。这位球员是 Sekou Doumbouya，他出生于 2000 年 12 月 23 日。'
- en: 4.3.2 Sorting by multiple columns
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 按多列排序
- en: 'We can sort multiple columns in a `DataFrame` by passing a list to the `sort_values`
    method’s `by` parameter. Pandas will sort the `DataFrame`’s columns consecutively
    in the order in which they appear in the list. The next example sorts the `nba`
    `DataFrame` first by the Team column and then by the Name column. Pandas defaults
    to ascending sorts for all columns:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将列表传递给 `sort_values` 方法的 `by` 参数来按多个列对 `DataFrame` 进行排序。Pandas 将按列表中出现的顺序依次对
    `DataFrame` 的列进行排序。下一个示例首先按 `Team` 列排序，然后按 `Name` 列排序。Pandas 默认对所有列进行升序排序：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here’s how you read the output. The Atlanta Hawks are the first team in the
    data set when we sort teams by alphabetical order. Within the Atlanta Hawks, Alex
    Len’s name comes first, followed by Allen Crabbe and Brandon Goodwin. Pandas repeats
    this sorting logic for the remaining teams and names.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您读取输出的方式。当按字母顺序对球队进行排序时，亚特兰大老鹰队是数据集中的第一个球队。在亚特兰大老鹰队中，Alex Len 的名字排在第一位，其次是
    Allen Crabbe 和 Brandon Goodwin。Pandas 对剩余的球队和名字重复此排序逻辑。
- en: 'We can pass a single Boolean to the `ascending` parameter to apply the same
    sort order to each column. The next example passes `False`, so pandas first sorts
    the Team column in descending order and then the Name column in descending order:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将单个布尔值传递给 `ascending` 参数，以将相同的排序顺序应用于每一列。下一个示例传递 `False`，因此 pandas 首先按降序排序
    `Team` 列，然后按降序排序 `Name` 列：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What if we want to sort each column in a different order? We might want to
    sort the teams in ascending order and then sort the salaries within those teams
    in descending order, for example. To accomplish this task, we can pass the `ascending`
    parameter a list of Boolean values. The lists passed to the `by` and `ascending`
    parameters must be equal in length. Pandas will use shared index positions between
    the two lists to match each column with its associated sort order. In the next
    example, the Team column occupies index position 0 in the `by` list; pandas matches
    it with the `True` at index position 0 in the `ascending` list, so it sorts the
    column in ascending order. Pandas applies the same logic to the Salary column
    and sorts it in descending order:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想按不同的顺序对每一列进行排序呢？例如，我们可能希望按升序对球队进行排序，然后按降序对那些球队中的薪水进行排序。为了完成这个任务，我们可以将布尔值列表传递给
    `ascending` 参数。传递给 `by` 和 `ascending` 参数的列表长度必须相等。Pandas 将使用两个列表之间的共享索引位置来匹配每一列与其关联的排序顺序。在下一个示例中，`Team`
    列在 `by` 列中占据索引位置 0；Pandas 将它与 `ascending` 列中索引位置 0 的 `True` 匹配，因此按升序排序该列。Pandas
    对 `Salary` 列应用相同的逻辑，并按降序排序：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The data looks good, so let’s make our sort permanent. The `sort_values` method
    supports the `inplace` parameter, but we’ll be explicit and reassign the returned
    `DataFrame` to the `nba` variable (see chapter 3 for a discussion of the imperfections
    of the `inplace` parameter):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来不错，所以让我们使排序永久化。`sort_values` 方法支持 `inplace` 参数，但我们将明确地将返回的 `DataFrame`
    重新赋值给 `nba` 变量（有关 `inplace` 参数的不足之处，请参阅第 3 章）：
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Hooray—we’ve sorted our `DataFrame` by the values in the Team and Salary columns.
    Now we can figure out which players on each team get paid the most.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼——我们已经按 `Team` 和 `Salary` 列的值对 `DataFrame` 进行了排序。现在我们可以找出每个球队中哪位球员的薪水最高。
- en: 4.4 Sorting by index
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 按索引排序
- en: 'With our permanent sort, our `DataFrame` is in a different order from when
    it arrived:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的永久排序中，`DataFrame` 的顺序与到达时不同：
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How can we return it to its original form?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将其恢复到原始形式？
- en: 4.4.1 Sorting by row index
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 按行索引排序
- en: 'Our `nba` `DataFrame` still has its numeric index. If we could sort the data
    set by index positions rather than by column values, we could return it to its
    original shape. The `sort_index` method does just that:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `nba` `DataFrame` 仍然具有其数值索引。如果我们能按索引位置而不是按列值对数据集进行排序，我们就可以将其恢复到原始形状。`sort_index`
    方法正是这样做的：
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also reverse the sort order by passing `False` to the method’s `ascending`
    parameter. The next example shows the greatest index positions first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将 `False` 传递给方法的 `ascending` 参数来反转排序顺序。下一个示例首先显示最大的索引位置：
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We’re back where we started, with the `DataFrame` sorted by index position.
    Let’s assign this `DataFrame` back to the `nba` variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了起点，`DataFrame` 已按索引位置排序。现在，让我们将这个 `DataFrame` 重新赋值给 `nba` 变量：
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next up, let’s explore how we can sort our `nba` on its other axis.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何按 `nba` 的其他轴进行排序。
- en: 4.4.2 Sorting by column index
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 按列索引排序
- en: 'A `DataFrame` is a two-dimensional data structure. We can sort an additional
    axis: the vertical axis.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame` 是一个二维数据结构。我们可以对额外的轴进行排序：垂直轴。'
- en: 'To sort the `DataFrame` columns in order, we’ll again rely on the `sort_index`
    method. This time, however, we’ll need to add an `axis` parameter and pass it
    an argument of `"columns"` or 1\. The next example sorts the columns in ascending
    order:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要按顺序对 `DataFrame` 列进行排序，我们再次依赖 `sort_index` 方法。然而，这次我们需要添加一个 `axis` 参数，并将其参数传递为
    `"columns"` 或 1。下一个示例按升序排序列：
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'How about sorting the columns in reverse alphabetical order? That task is a
    simple one: we can pass the `ascending` parameter an argument of `False`. The
    next example invokes the `sort_index` method, targets the columns with the `axis`
    parameter, and sorts in descending order with the `ascending` parameter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按照逆字母顺序排序列怎么样？这个任务很简单：我们可以将 `ascending` 参数的参数设置为 `False`。下一个示例调用 `sort_index`
    方法，使用 `axis` 参数指定列，并通过 `ascending` 参数按降序排序：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Let’s take a second to reflect on the power of pandas. With two methods and
    a few parameters, we were able to sort the `DataFrame` on both axes, by one column,
    by multiple columns, in ascending order, in descending order, or in multiple orders.
    Pandas is remarkably flexible. We only have to combine the right method with the
    right arguments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来反思 pandas 的强大功能。通过两种方法和几个参数，我们能够对 `DataFrame` 在两个轴上、按一列、按多列、按升序、按降序或按多顺序进行排序。pandas
    非常灵活。我们只需要将正确的方法与正确的参数结合起来。
- en: 4.5 Setting a new index
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 设置新的索引
- en: At its core, our data set is a collection of players. Therefore, it seems fitting
    to use the Name column’s values as the `DataFrame`’s index labels. Name also has
    the benefit of being the only column with unique values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，我们的数据集是玩家集合。因此，使用 Name 列的值作为 `DataFrame` 的索引标签似乎是合适的。Name 还有一个好处，即它是唯一具有唯一值的列。
- en: 'The `set_index` method returns a new `DataFrame` with a given column set as
    the index. Its first parameter, `keys`, accepts the column name as a string:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_index` 方法返回一个新的 `DataFrame`，其中指定的列被设置为索引。它的第一个参数 `keys` 接受列名作为字符串：'
- en: '[PRE50]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Looks good! Let’s overwrite our `nba` variable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！让我们覆盖我们的 `nba` 变量：
- en: '[PRE51]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As a side note, we can set the index when importing a data set. Pass the column
    name as a string to the `read_csv` function’s `index_col` parameter. The following
    code leads to the same `DataFrame`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们可以在导入数据集时设置索引。将列名作为字符串传递给 `read_csv` 函数的 `index_col` 参数。以下代码导致相同的 `DataFrame`：
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, we’ll talk about selecting rows and columns from our `DataFrame`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何从我们的 `DataFrame` 中选择行和列。
- en: 4.6 Selecting columns and rows from a DataFrame
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 从 DataFrame 中选择列和行
- en: A `DataFrame` is a collection of `Series` objects with a common index. Multiple
    syntax options are available to extract one or more of these `Series` from the
    `DataFrame`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame` 是具有共同索引的 `Series` 对象的集合。有多个语法选项可用于从 `DataFrame` 中提取一个或多个这些 `Series`。'
- en: 4.6.1 Selecting a single column from a DataFrame
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 从 DataFrame 中选择单个列
- en: 'Each `Series` column is available as an attribute on the `DataFrame`. We use
    dot syntax to access object attributes. We can extract the Salary column with
    `nba.Salary`, for example. Notice that the index carries over from the `DataFrame`
    to the `Series`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Series` 列都作为 `DataFrame` 的属性可用。我们使用点语法来访问对象属性。例如，我们可以使用 `nba.Salary` 提取
    Salary 列。注意，索引从 `DataFrame` 传递到 `Series`：
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also extract a column by passing its name in square brackets after the
    `DataFrame`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在 `DataFrame` 后方传递其名称来提取一个列，使用方括号：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The advantage of the square-bracket syntax is that it supports column names
    with spaces. If our column was named `"Player Position",` we could extract it
    only via square brackets:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号语法的优点是它支持有空格的列名。如果我们的列名为 `"Player Position"`，我们只能通过方括号提取它：
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The attribute syntax would raise an exception. Python has no way of knowing
    the significance of the space and would assume that we’re trying to access a Player
    column:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 属性语法会引发异常。Python 没有办法知道空格的意义，它会假设我们正在尝试访问一个 Player 列：
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Although opinions differ, I recommend using the square-bracket syntax for extraction.
    I like solutions that work 100% of the time, even if they require typing a few
    extra characters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然意见不同，但我建议使用方括号语法进行提取。我喜欢那种100%有效率的解决方案，即使它们需要多输入几个字符。
- en: 4.6.2 Selecting multiple columns from a DataFrame
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 从 DataFrame 中选择多个列
- en: 'To extract multiple `DataFrame` columns, declare a pair of opening and closing
    square brackets; then pass the column names in a list. The result will be a new
    `DataFrame` whose columns are in the same order as the list elements. The next
    example targets the Salary and Birthday columns:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取多个 `DataFrame` 列，声明一对开闭方括号；然后传递列名列表。结果将是一个新的 `DataFrame`，其列的顺序与列表元素相同。下一个示例目标是薪资和生日列：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Pandas will extract the columns based on their order in the list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 将根据列表中的顺序提取列：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can use the `select_dtypes` method to select columns based on their data
    types. The method accepts two parameters, `include` and `exclude`. The parameters
    accept a single string or a list, representing the column type(s) that pandas
    should keep or discard. As a reminder, you can access the `dtypes` attribute if
    you’d like to see each column’s datatype. The next example selects only string
    columns from `nba`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `select_dtypes` 方法根据数据类型选择列。该方法接受两个参数，`include` 和 `exclude`。这些参数接受单个字符串或列表，表示
    pandas 应该保留或丢弃的列类型。提醒一下，如果您想查看每列的数据类型，可以访问 `dtypes` 属性。下一个示例从 `nba` 中选择仅包含字符串列：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next example selects all columns except string and integer columns:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例选择除了字符串和整数列之外的所有列：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The Birthday column is the only column in `nba` that holds neither string nor
    integer values. To include or exclude datetime columns, we can pass an argument
    of `"datetime"` to the correct parameter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 生日列是 `nba` 中唯一一个既不包含字符串也不包含整数值的列。要包含或排除日期时间列，我们可以将 `"datetime"` 参数传递给正确的参数。
- en: 4.7 Selecting rows from a DataFrame
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 从 DataFrame 中选择行
- en: Now that we’ve practiced extracting columns, let’s learn how to extract `DataFrame`
    rows by index label or position.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经练习了提取列，让我们学习如何通过索引标签或位置提取 `DataFrame` 行。
- en: 4.7.1 Extracting rows by index label
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.1 通过索引标签提取行
- en: 'The `loc` attribute extracts a row by label. We call attributes such as `loc`
    accessors because they access a piece of data. Type a pair of square brackets
    immediately after `loc` and pass in the target index label. The next example extracts
    the `nba` row with an index label of `"LeBron James"`. Pandas returns the row’s
    values in a `Series`. As always, be mindful of case sensitivity:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`loc` 属性通过标签提取一行。我们称像 `loc` 这样的属性为访问器，因为它们可以访问数据的一部分。在 `loc` 后面立即输入一对方括号，并传递目标索引标签。下一个示例通过索引标签
    `"LeBron James"` 提取了 `nba` 行。Pandas 以 `Series` 的形式返回行的值。一如既往，请注意大小写敏感性：'
- en: '[PRE61]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can pass a list in between the square brackets to extract multiple rows.
    When the results set includes multiple records, pandas stores the results in a
    `DataFrame`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方括号之间传递一个列表来提取多行。当结果集包含多个记录时，pandas 将结果存储在一个 `DataFrame` 中：
- en: '[PRE62]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Pandas organizes the rows in the order in which their index labels appear in
    the list. The next example swaps the string order from the previous example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 按照索引标签在列表中出现的顺序组织行。下一个示例交换了上一个示例中的字符串顺序：
- en: '[PRE63]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We can use `loc` to extract a sequence of index labels. The syntax mirrors Python’s
    list slicing syntax. We provide the starting value, a colon, and the ending value.
    For extractions like this one, I strongly recommended sorting the index first,
    as it accelerates the speed with which pandas finds the value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `loc` 提取一系列索引标签。语法与 Python 的列表切片语法相似。我们提供起始值，一个冒号，以及结束值。对于此类提取，我强烈建议首先对索引进行排序，因为这可以加快
    pandas 查找值的速度。
- en: 'Let’s say we wanted to target all players between Otto Porter and Patrick Beverley.
    We can sort the `DataFrame` index to get the player names in alphabetical order
    and then provide the two player names to the `loc` accessor. `"Otto Porter"` represents
    our lower bound, and `"Patrick Beverley"` represents the upper bound:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定位在 Otto Porter 和 Patrick Beverley 之间的所有球员。我们可以对 `DataFrame` 的索引进行排序，以按字母顺序获取球员姓名，然后向
    `loc` 访问器提供这两个球员姓名。"Otto Porter" 代表我们的下限，而 "Patrick Beverley" 代表上限：
- en: '[PRE64]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that pandas’ `loc` accessor has some differences with Python’s list-slicing
    syntax. For one, the `loc` accessor includes the label at the upper bound, whereas
    Python’s list slicing syntax excludes the value at the upper bound.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，pandas 的 `loc` 访问器与 Python 的列表切片语法有一些不同。首先，`loc` 访问器包括上限的标签，而 Python 的列表切片语法不包括上限的值。
- en: 'Here’s a quick example to remind you. The next example uses list-slicing syntax
    to extract the elements from index 0 to index 2 in a list of three elements. Index
    2 (`"PJ Washington")` is exclusive, so Python leaves it out:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例来提醒你。下一个示例使用列表切片语法从包含三个元素的列表中提取索引0到索引2的元素。索引2（`"PJ Washington"`）是排他的，所以Python将其省略：
- en: '[PRE65]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can use `loc` to pull rows from the middle of the `DataFrame` to its end.
    Pass the square brackets the starting index label and a colon:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `loc` 从 `DataFrame` 的中间拉取行到其末尾。传递方括号起始索引标签和冒号：
- en: '[PRE66]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Turning in the other direction, we can use `loc` slicing to pull rows from
    the beginning of the `DataFrame` *to* a specific index label. Start with a colon
    and then enter the index label to extract to. The next example returns all players
    from the start to the data set up to Al Horford:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 向另一个方向转动，我们可以使用 `loc` 切片从 `DataFrame` 的开始处拉取行到特定的索引标签。从冒号开始，然后输入要提取到的索引标签。下一个示例返回从开始到数据集中的阿尔·霍福德的所有球员：
- en: '[PRE67]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Pandas will raise an exception if the index label does not exist in the `DataFrame`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引标签在 `DataFrame` 中不存在，Pandas 将引发异常：
- en: '[PRE68]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As its name suggests, the `KeyError` exception communicates that a key does
    not exist in a given data structure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`KeyError` 异常表示在给定的数据结构中不存在键。
- en: 4.7.2 Extracting rows by index position
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.2 通过索引位置提取行
- en: 'The `iloc` (index location) accessor extracts rows by index position, which
    is helpful when the position of our rows has significance in our data set. The
    syntax is similar to the one we used for `loc`. Enter a pair of square brackets
    after `iloc`, and pass in an integer. Pandas will extract the row at that index:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`iloc`（索引位置）访问器通过索引位置提取行，这在我们的数据集中行的位置有重要意义时很有用。语法与 `loc` 我们使用的语法相似。在 `iloc`
    后面输入一对方括号，并传递一个整数。Pandas 将提取该索引处的行：'
- en: '[PRE69]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `iloc` accessor also accepts a list of index positions to target multiple
    records. The next example pulls out the players at index positions 100, 200, 300,
    and 400:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`iloc` 访问器也接受一个索引位置的列表来针对多个记录。下一个示例从索引位置100、200、300和400提取球员：'
- en: '[PRE70]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can use list-slicing syntax with the `iloc` accessor as well. Note, however,
    that pandas excludes the index position after the colon. The next example passes
    a slice of `400:404`. Pandas includes the rows at index positions 400, 401, 402,
    and 403, and excludes the row at index 404:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用列表切片语法与 `iloc` 访问器一起使用。请注意，然而，pandas排除了冒号之后的索引位置。下一个示例传递 `400:404` 的切片。Pandas
    包括索引位置为400、401、402和403的行，并排除了索引404的行：
- en: '[PRE71]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can leave out the number before the colon to pull from the start of the
    `DataFrame`. Here, we target rows from the beginning of `nba` up to (but not including)
    index position 2:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以省略冒号前的数字，以从 `DataFrame` 的开始处拉取。在这里，我们针对从 `nba` 开始到（但不包括）索引位置2的行：
- en: '[PRE72]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Similarly, we can remove the number after the colon to pull to the end of the
    `DataFrame`. Here, we target the rows from index position 447 to the end of `nba`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以移除冒号后面的数字，以拉取到 `DataFrame` 的末尾。在这里，我们针对从索引位置447到 `nba` 末尾的行：
- en: '[PRE73]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can also pass negative numbers for either value or both values. The next
    example extracts rows from the 10th-to-last row up to (but not including) the
    sixth-to-last row:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递负数，无论是单个值还是两个值。下一个示例从倒数第10行提取到（但不包括）倒数第6行：
- en: '[PRE74]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can provide a third number inside the square brackets to create the step
    sequence, a gap between every two index positions. The next example pulls the
    first 10 `nba` rows in increments of 2\. The resulting `DataFrame` includes the
    rows with index positions 0, 2, 4, 6, and 8:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方括号内提供第三个数字来创建步进序列，在两个索引位置之间创建一个间隔。下一个示例以2的增量拉取前10个 `nba` 行。结果 `DataFrame`
    包含索引位置为0、2、4、6和8的行：
- en: '[PRE75]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This slicing technique is particularly effective when we want to pull out every
    other row.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要提取每隔一行时，这种切片技术特别有效。
- en: 4.7.3 Extracting values from specific columns
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.3 从特定列提取值
- en: 'Both the `loc` and `iloc` attributes accept a second argument representing
    the column(s) to extract. If we’re using `loc`, we have to provide the column
    name. If we’re using `iloc`, we have to provide the column position. The next
    example uses `loc` to pull the value at the intersection of the `"Giannis` `Antetokounmpo"`
    row and the Team column:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`loc` 和 `iloc` 属性都接受一个表示要提取的列（s）的第二个参数。如果我们使用 `loc`，我们必须提供列名。如果我们使用 `iloc`，我们必须提供列位置。下一个示例使用
    `loc` 从 `"Giannis Antetokounmpo"` 行和 Team 列的交点提取值：'
- en: '[PRE76]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To specify multiple values, we can pass a list for one or both of the arguments
    to the `loc` accessor. The next example extracts the row with a `"James Harden"`
    index label and the values from the Position and Birthday columns. Pandas returns
    a `Series`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定多个值，我们可以为`loc`访问器的其中一个或两个参数传递一个列表。下一个示例提取具有`"James Harden"`索引标签的行以及Position和Birthday列的值。Pandas返回一个`Series`：
- en: '[PRE77]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The next example provides multiple row labels and multiple columns:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例提供了多个行标签和多个列：
- en: '[PRE78]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can also use list-slicing syntax to extract multiple columns without explicitly
    writing out their names. We have four columns in our data set (Team, Position,
    Birthday, and Salary). Let’s extract all columns from Position to Salary. Pandas
    includes both endpoints in a `loc` slice:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用列表切片语法来提取多个列，而无需明确写出它们的名称。在我们的数据集中有四个列（Team、Position、Birthday和Salary）。让我们从Position到Salary提取所有列。Pandas在`loc`切片中包含两个端点：
- en: '[PRE79]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We must pass the column names in the order in which they appear in the `DataFrame`.
    The next example yields an empty result because the Salary column comes after
    the Position column. Pandas is unable to identify which columns to pull out:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以`DataFrame`中列出现的顺序传递列名。下一个示例返回一个空结果，因为Salary列在Position列之后。Pandas无法识别要提取哪些列：
- en: '[PRE80]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let’s say we wanted to target columns by their order rather than by their name.
    Remember that pandas assigns an index position to each `DataFrame` column. In
    `nba`, the Team column has an index of 0, Position has an index of 1, and so on.
    We can pass a column’s index as the second argument to `iloc`. The next example
    targets the value at the intersection of the row at index 57 and the column at
    index 3 (Salary):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过列的顺序而不是通过列名来定位列。记住，pandas会给每个`DataFrame`列分配一个索引位置。在`nba`中，Team列的索引为0，Position列的索引为1，以此类推。我们可以将列的索引作为`iloc`的第二个参数传递。下一个示例定位到索引为57的行和索引为3的列（Salary）的交叉值：
- en: '[PRE81]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can use list-slicing syntax here as well. The next example pulls all rows
    from index position 100 up to but not including index position 104\. It also includes
    all columns from the beginning of the columns up to but not including the column
    at index position 3 (Salary):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里使用列表切片语法。下一个示例从索引位置100提取所有行，直到但不包括索引位置104。它还包括从列的开始到但不包括索引位置3的列（Salary）的所有列：
- en: '[PRE82]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `iloc` and `loc` accessors are remarkably versatile. Their square brackets
    can accept a single value, a list of values, a list slice, and more. The disadvantage
    of this flexibility is that it demands extra overhead; pandas has to figure out
    what kind of input we’ve given to `iloc` or `loc`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`iloc`和`loc`访问器非常灵活。它们的方括号可以接受单个值、值列表、列表切片等。这种灵活性的缺点是它需要额外的开销；pandas必须确定我们给`iloc`或`loc`提供了什么类型的输入。'
- en: We can use two alternative attributes, `at` and `iat`, when we know that we
    want to extract a single value from a `DataFrame`. The two attributes are speedier
    because pandas can optimize its searching algorithms when looking for a single
    value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在知道要从`DataFrame`中提取单个值时使用两个可选属性，`at`和`iat`。这两个属性更快，因为pandas可以在寻找单个值时优化其搜索算法。
- en: 'The syntax is similar. The `at` attribute accepts row and column labels:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 语法类似。`at`属性接受行和列标签：
- en: '[PRE83]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `iat` attribute accepts row and column indices:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`iat`属性接受行和列索引：'
- en: '[PRE84]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Jupyter Notebook includes several magic methods to help enhance our developer
    experience. We declare magic methods with a `%%` prefix and enter them alongside
    our regular Python code. One example is `%%timeit`, which runs the code in a cell
    and calculates the average time it takes to execute. `%%timeit` sometimes runs
    the cell up to 100,000 times! The next examples use the magic method to compare
    the speed of the accessors we’ve explored so far:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebook包含几个魔法方法来帮助我们增强开发者体验。我们使用`%%`前缀声明魔法方法，并将它们与常规Python代码一起输入。一个例子是`%%timeit`，它在单元格中运行代码并计算执行的平均时间。`%%timeit`有时会运行单元格高达100,000次！下一个示例使用魔法方法来比较我们迄今为止探索的访问器的速度：
- en: '[PRE85]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The results are subject to some variance between different computers but show
    the clear speed advantage of `at` and `iat` over `loc` and `iloc`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在不同计算机之间可能会有所不同，但显示了`at`和`iat`相对于`loc`和`iloc`的明显速度优势。
- en: 4.8 Extracting values from Series
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 从Series中提取值
- en: 'The `loc`, `iloc`, `at`, and `iat` accessors are available on `Series` objects
    as well. We can practice on a sample `Series` from our `DataFrame`, such as Salary:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`loc`、`iloc`、`at`和`iat`访问器也适用于`Series`对象。我们可以在`DataFrame`的样本`Series`上练习，例如Salary：'
- en: '[PRE86]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Feel free to use whatever accessors work best for you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用最适合你的访问器。
- en: 4.9 Renaming columns or rows
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 重命名列或行
- en: 'Do you recall the `columns` attribute? It exposes the `Index` object that stores
    the `DataFrame`’s column names:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得`columns`属性吗？它暴露了存储`DataFrame`列名的`Index`对象：
- en: '[PRE87]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can rename any or all of a `DataFrame`’s columns by assigning a list of
    new names to the attribute. The next example changes the name of the Salary column
    to Pay:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将新名字的列表赋给属性来重命名`DataFrame`的任何或所有列。下一个例子将Salary列的名称更改为Pay：
- en: '[PRE88]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `rename` method is an alternative option that accomplishes the same result.
    We can pass to its `columns` parameter a dictionary in which the keys are the
    existing column names and the values are their new names. The next example alters
    the Date of Birth column’s name to Birthday:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename`方法是一个替代选项，可以完成相同的结果。我们可以将其`columns`参数传递一个字典，其中键是现有列名，值是它们的新名称。下一个例子将出生日期列的名称更改为Birthday：'
- en: '[PRE89]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let’s make the operation permanent by assigning the returned `DataFrame` to
    the `nba` variable:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将返回的`DataFrame`赋给`nba`变量来使操作永久化：
- en: '[PRE90]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can also rename index labels by passing a dictionary to the method’s `index`
    parameter. The same logic applies; the keys are the old labels, and the values
    are the new ones. The following example swaps `"Giannis` `Antetokounmpo"` with
    his popular nickname `"Greek` `Freak"`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过传递字典到方法的`index`参数来重命名索引标签。相同的逻辑适用；键是旧标签，值是新标签。以下示例将 `"Giannis"` `Antetokounmpo"`
    与他的昵称 `"Greek"` `Freak"` 交换：
- en: '[PRE91]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let’s try looking up the row by its new label:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过其新标签查找行：
- en: '[PRE92]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We’ve successfully changed the row label!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功更改了行标签！
- en: 4.10 Resetting an index
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 重置索引
- en: 'Sometimes, we want to set another column as the index of our `DataFrame`. Let’s
    say we wanted to make Team the index of `nba`. We could invoke the `set_index`
    method we introduced earlier in the chapter with a different column, but we would
    lose our current index of player names. Take a look at this example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们想要将另一列设置为`DataFrame`的索引。假设我们想要将Team设置为`nba`的索引。我们可以使用本章早些时候引入的`set_index`方法，但我们会失去当前球员名字的索引。看看这个例子：
- en: '[PRE93]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To preserve the players’ names, we must first reintegrate the existing index
    as a regular column in the `DataFrame`. The `reset_index` method moves the current
    index to a `DataFrame` column and replaces the former index with pandas’ numeric
    index:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留球员的名字，我们首先必须将现有的索引重新集成到`DataFrame`的常规列中。`reset_index`方法将当前索引移动到`DataFrame`列中，并用pandas的数字索引替换原来的索引：
- en: '[PRE94]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now we can use the `set_index` method to move the Team column to the index
    with no data loss:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`set_index`方法将Team列移动到索引，而不会丢失数据：
- en: '[PRE95]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'One advantage of avoiding the `inplace` parameter is that we can chain multiple
    method calls. Let’s chain the `reset_index` and `set_index` method calls and overwrite
    the `nba` variable with the result:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`inplace`参数的一个优点是我们可以链式调用多个方法。让我们链式调用`reset_index`和`set_index`方法，并用结果覆盖`nba`变量：
- en: '[PRE96]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: That’s all there is to cover. You’re now acquainted with the `DataFrame`, the
    core workhorse of the pandas library.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有需要涵盖的内容。你现在已经熟悉了`DataFrame`，它是pandas库的核心工作马。
- en: 4.11 Coding challenge
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 编程挑战
- en: Now that we’ve explored the NBA’s financials, let’s apply the chapter’s concepts
    in a different sports league.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了NBA的财务状况，让我们将本章的概念应用于不同的体育联盟。
- en: 4.11.1 Problems
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.1 问题
- en: 'The nfl.csv file contains a list of players in the National Football League
    with similar Name, Team, Position, Birthday, and Salary columns. See whether you
    can answer these questions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: nfl.csv文件包含了一份国家橄榄球联盟球员名单，其中包含类似的名字、球队、位置、生日和薪水列。看看你是否能回答这些问题：
- en: How can we import the nfl.csv file? What’s an effective way to convert the values
    in its Birthday column to datetimes?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何导入nfl.csv文件？有什么有效的方法将其生日列的值转换为日期时间？
- en: What are the two ways we can set the `DataFrame` index to store the player names?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用哪两种方式将`DataFrame`的索引设置为存储球员名字？
- en: How can we count the number of players per team in this data set?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何计算这个数据集中每个球队的球员数量？
- en: Who are the five highest-paid players?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁是收入最高的五位球员？
- en: How can we sort the data set first by teams in alphabetical order and then by
    salary in descending order?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何首先按球队字母顺序排序数据集，然后按薪水降序排序？
- en: Who is the oldest player on the New York Jets roster, and what is his birthday?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纽约喷气机队名单中最年长的球员是谁，他的生日是什么？
- en: 4.11.2 Solutions
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.2 解决方案
- en: 'Let’s walk through the challenges step by step:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地走过挑战：
- en: 'We can import the CSV with the `read_csv` function. To store the Birthday column
    values as datetimes, we’ll pass the column to the `parse_dates` parameter in a
    list:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `read_csv` 函数导入 CSV 文件。要将 Birthday 列的值存储为日期时间，我们将列传递给 `parse_dates` 参数的列表中：
- en: '[PRE97]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Our next challenge is setting the player names as the index labels. Our option
    is to invoke the `set_index` method and assign the new `DataFrame` to the `nfl`
    variable:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一个挑战是将球员名称设置为索引标签。我们的选择是调用 `set_index` 方法并将新的 `DataFrame` 赋值给 `nfl` 变量：
- en: '[PRE98]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Another option is to provide the `index_col` parameter to the `read_csv` function
    when importing the data set:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个选项是在导入数据集时向 `read_csv` 函数提供 `index_col` 参数：
- en: '[PRE99]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The result will be the same either way:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论哪种方式，结果都将相同：
- en: '[PRE100]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To count the number of players per team, we can invoke the `value_counts` method
    on the Team column. First, we need to extract the Team `Series` with dot syntax
    or square brackets:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算每个队伍的球员数量，我们可以在 Team 列上调用 `value_counts` 方法。首先，我们需要使用点语法或方括号提取 Team `Series`：
- en: '[PRE101]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To identify the five highest-paid players, we can use the `sort_values` method
    to sort the Salary column. To tell pandas to sort in descending order, we can
    pass the `ascending` parameter an argument of `False`. Another option is the `nlargest`
    method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要识别五位最高薪球员，我们可以使用 `sort_values` 方法对 Salary 列进行排序。要告诉 pandas 按降序排序，我们可以将 `ascending`
    参数传递 `False`。另一个选项是 `nlargest` 方法：
- en: '[PRE102]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To sort by multiple columns, we’ll have to pass arguments to both the `by`
    and `ascending` parameters of the `sort_values` method. The following code sorts
    the Team column in ascending order followed by the Salary column in descending
    order:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按多个列排序，我们需要将参数传递给 `sort_values` 方法的 `by` 和 `ascending` 参数。以下代码按升序排序 Team 列，然后按降序排序
    Salary 列：
- en: '[PRE103]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The final challenge is a tricky one: we have to find the oldest player on the
    New York Jets roster. Given the current tools at our disposal, we can set the
    Team column as the `DataFrame` index to allow for easy extraction of all Jets
    players. To preserve the player names currently in our index, we’ll first use
    the `reset_index` method to move them back into the `DataFrame` as a regular column:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个挑战是有点棘手的：我们必须找到纽约喷气机阵容中最老的球员。鉴于我们目前可用的工具，我们可以将 Team 列设置为 `DataFrame` 索引，以便轻松提取所有喷气机球员。为了保留我们索引中当前球员的名称，我们首先使用
    `reset_index` 方法将它们移回 `DataFrame` 作为常规列：
- en: '[PRE104]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we can use the `loc` attribute to isolate all players on the New York
    Jets:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `loc` 属性来隔离所有纽约喷气机球员：
- en: '[PRE105]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The last step is to sort the Birthday column and extract the top record. This
    sort is possible only because we converted the column’s values to datetimes:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是对 Birthday 列进行排序并提取最高记录。这种排序之所以可能，仅仅是因为我们将列的值转换为日期时间：
- en: '[PRE106]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The oldest player on the New York Jets in this data set is Ryan Kalil. His birthday
    was March 29, 1985.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据集中，纽约喷气机的最老球员是 Ryan Kalil。他的生日是 1985 年 3 月 29 日。
- en: Congratulations on completing the coding challenge!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成编码挑战！
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `DataFrame` is a two-dimensional data structure consisting of rows and columns.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame` 是由行和列组成的二维数据结构。'
- en: The `DataFrame` shares attributes and methods with the `Series`. Many of the
    attributes and methods operate differently due to the dimensional differences
    between the two objects.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame` 与 `Series` 共享属性和方法。由于这两个对象之间的维度差异，许多属性和方法操作方式不同。'
- en: The `sort_values` method sorts one or more `DataFrame` columns. We can assign
    each column a different sort order (ascending or descending).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_values` 方法对一或多个 `DataFrame` 列进行排序。我们可以为每个列分配不同的排序顺序（升序或降序）。'
- en: The `loc` attribute extracts rows or columns by index label. The `at` attribute
    is a convenient shortcut for targeting only one value.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loc` 属性通过索引标签提取行或列。`at` 属性是定位单个值的便捷快捷方式。'
- en: The `iloc` attribute extracts rows or columns by index position. The `iat` attribute
    is a convenient shortcut for targeting only one value.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iloc` 属性通过索引位置提取行或列。`iat` 属性是定位单个值的便捷快捷方式。'
- en: The `reset_index` method restores an index as a regular column in the `DataFrame`.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset_index` 方法将索引恢复为 `DataFrame` 中的常规列。'
- en: The `rename` method sets a different name for one or more columns or rows.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename` 方法为一个或多个列或行设置不同的名称。'
