- en: 9 Programming with channels
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 使用通道编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing communicating sequential processes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍通信顺序进程
- en: Reusing common channel patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用常见的通道模式
- en: Taking advantage of channels being first-class objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用通道作为一等对象的优势
- en: Working with channels requires a different way of programming than when using
    memory sharing. The idea is to have a set of goroutines, each with its own internal
    state, exchanging information with other goroutines by passing messages on Go’s
    channels. In this way, each goroutine’s state is isolated from direct interference
    by other executions, reducing the risk of race conditions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通道需要与使用内存共享不同的编程方式。想法是有一组goroutines，每个goroutine都有自己的内部状态，通过在Go的通道上传递消息与其他goroutines交换信息。这样，每个goroutine的状态就与来自其他执行的直接干扰隔离，从而降低了竞态条件的风险。
- en: Go’s own mantra is not to communicate by shared memory but to instead share
    memory by communicating. Since memory sharing is more prone to race conditions
    and requires complex synchronization techniques, we should avoid it when possible
    and instead use message passing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go的自身格言不是通过共享内存进行通信，而是通过通信来共享内存。由于内存共享更容易出现竞态条件并需要复杂的同步技术，因此我们应该尽可能避免它，而改用消息传递。
- en: In this chapter, we will start by discussing communicating sequential processes
    (CSP) and then move on to look at the common patterns used when using message
    passing with channels. We’ll finish this chapter by demonstrating the value of
    treating channels as first-class objects, meaning that we can pass channels as
    function arguments and receive them as function return types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论通信顺序进程（CSP），然后转向查看在使用通道进行消息传递时使用的常见模式。我们将通过展示将通道视为一等对象的价值来结束本章，这意味着我们可以将通道作为函数参数传递，并将它们作为函数返回类型接收。
- en: 9.1 Communicating sequential processes
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 通信顺序进程
- en: In previous chapters, we discussed a model of concurrency using goroutines,
    shared memory, and primitives, such as mutexes, condition variables, and semaphores.
    This is the classic way to model concurrency. The main criticism of this model
    is that for many applications, it is too low-level.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了使用goroutines、共享内存和互斥锁、条件变量、信号量等原语来建模并发性的模型。这是建模并发的经典方式。对这个模型的主要批评是，对于许多应用程序来说，它太低级了。
- en: The SRC model
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SRC模型
- en: Using shared memory with concurrent primitives, such as mutexes, is sometimes
    referred to as the *SRC model.* The name comes from a paper by Andrew D. Birrell
    titled “An Introduction to Programming with Threads” (Systems Research Center,
    1989). The paper is a popular introduction to concurrent programming, using threads
    with shared memory, and synchronizing with concurrency primitives.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享内存与并发原语，如互斥锁，有时被称为*SRC模型*。该名称来源于Andrew D. Birrell的一篇论文，标题为“使用线程进行编程的介绍”（系统研究中心，1989年）。这篇论文是关于并发编程的流行介绍，使用共享内存的线程，并使用并发原语进行同步。
- en: Programming with a low-level model of concurrency means that as programmers,
    we need to work harder to manage the complexity and reduce bugs in our software.
    We don’t know when a thread of execution will be scheduled by the operating system,
    and this creates a non-deterministic environment—instructions are interleaved
    without us knowing beforehand the order of execution. This non-determinism, combined
    with memory sharing, creates the potential for race conditions. To avoid these,
    we must keep track of which execution is accessing the memory at the same time
    as other executions, and we need to restrict this access using synchronization
    primitives such as mutexes or semaphores.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用低级并发模型进行编程意味着，作为程序员，我们需要更努力地管理复杂性并减少软件中的错误。我们不知道操作系统何时会调度执行线程，这创造了一个非确定性的环境——指令在没有事先知道执行顺序的情况下交错。这种非确定性，加上内存共享，创造了竞态条件的可能性。为了避免这些，我们必须跟踪哪些执行正在同时访问内存，并且我们需要使用互斥锁或信号量等同步原语来限制这种访问。
- en: Programming with such low-level tools for concurrency, when combined with modern
    software development teams and ever-increasing business complexity, leads to buggy,
    complex, and high-maintenance code. Software containing race conditions is difficult
    to debug because race conditions are tricky to reproduce and test. In some industries
    and applications, such as health and infrastructure software, code reliability
    is of critical importance (see figure 9.1). For these applications, it is hard
    to prove that concurrent code written in this manner is correct due to its non-deterministic
    nature.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种低级工具进行并发编程，当与现代软件开发团队和不断增长的业务复杂性相结合时，会导致存在错误、复杂且维护成本高的代码。包含竞态条件的软件难以调试，因为竞态条件难以重现和测试。在某些行业和应用中，如健康和基础设施软件，代码可靠性至关重要（见图
    9.1）。对于这些应用，由于其非确定性，很难证明以这种方式编写的并发代码是正确的。
- en: '![](../../OEBPS/Images/CH09_F01_Cutajar.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F01_Cutajar.png)'
- en: Figure 9.1 Proving that software is correct is important for critical applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 对于关键应用来说，证明软件的正确性非常重要。
- en: 9.1.1 Avoiding interference with immutability
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 避免与不可变性冲突
- en: One way to greatly reduce the risk of race conditions is to not allow our programming
    to modify the same memory from multiple concurrent executions. We can restrict
    this by making use of immutable concepts when we are sharing memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一种大大降低竞态条件风险的方法是不允许我们的程序从多个并发执行中修改相同的内存。我们可以通过在共享内存时使用不可变概念来限制这一点。
- en: Definition *Immutable* literally means *unchangeable*. In computer programming,
    we use immutability when we initialize structures without providing any way to
    modify them. When the programming requires changes to these structures, we create
    a new copy of the structure containing the required changes, leaving the old copy
    as it is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的定义字面意思是 *不可改变*。在计算机编程中，我们在初始化结构时使用不可变性，不提供任何修改它们的方式。当编程需要更改这些结构时，我们创建一个新的结构副本，包含所需的更改，而保留旧副本不变。
- en: If our threads of execution only share memory containing data that is never
    updated, we can rest assured that there are no data race conditions. After all,
    most race conditions happen because multiple executions write to the same memory
    locations at the same time. If an execution needs to modify shared data, such
    as a variable, it can instead create a separate, local copy with the updates needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的执行线程只共享包含永不更新的数据的内存，我们可以确信没有数据竞态条件。毕竟，大多数竞态条件发生是因为多个执行同时写入相同的内存位置。如果一个执行需要修改共享数据，例如一个变量，它可以创建一个包含所需更新的单独、局部副本，而保留旧副本不变。
- en: 'Creating a copy when we need to update shared data leaves us with a problem:
    How do we share the new, updated data that is now in a separate location in memory?
    We need a model for managing and sharing this new, modified data. This is where
    message passing and CSP come in handy.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更新共享数据时创建副本，这会给我们留下一个问题：我们如何共享现在位于内存中不同位置的新、更新后的数据？我们需要一个模型来管理和共享这种新、修改后的数据。这就是消息传递和
    CSP 发挥作用的地方。
- en: 9.1.2 Concurrent programming with CSP
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 使用 CSP 进行并发编程
- en: A different, higher-level model of concurrency was proposed by C.A.R Hoare in
    his 1978 article “Communicating Sequential Processes” ([https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)).
    CSP, short for *communicating sequential processes*, is a formal language used
    to describe concurrent systems. Instead of using memory sharing, it is based on
    message passing via channels. Ideas and concepts from CSP have been adopted for
    concurrency models in programming languages and frameworks such as Erlang, Occam,
    Go, Scala’s Akka framework, Clojure’s core.async, and many others.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C.A.R Hoare 在其 1978 年的文章“Communicating Sequential Processes”（[https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)）中提出了一个不同层次、更高级的并发模型。CSP，即
    *communicating sequential processes* 的缩写，是一种用于描述并发系统的形式化语言。它不是通过共享内存，而是基于通过通道的消息传递来实现。CSP
    的思想和概念已被用于 Erlang、Occam、Go、Scala 的 Akka 框架、Clojure 的 core.async 以及许多其他编程语言和框架中的并发模型。
- en: In CSP, processes communicate with each other by exchanging copies of values.
    Communication is done through named unbuffered channels. A CSP process is not
    to be confused with an OS process (the ones we discussed in chapter 2); rather,
    a CSP process is a sequential execution, which has its own isolated state, as
    shown in figure 9.2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSP（Communicating Sequential Processes）中，进程通过交换值的副本相互通信。通信是通过命名的不带缓冲的通道完成的。CSP进程不应与操作系统进程（我们在第2章中讨论过的）混淆；相反，CSP进程是一种顺序执行，它具有自己的独立状态，如图9.2所示。
- en: '![](../../OEBPS/Images/CH09_F02_Cutajar.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F02_Cutajar.png)'
- en: Figure 9.2 A sequential process communicating with others
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 一个顺序进程与其他进程通信
- en: The key difference when using the CSP model is that executions are not sharing
    memory. Instead, they pass copies of data to each other. Like when using immutability,
    if each execution is not modifying shared data, there is no risk of interference,
    and thus we avoid most race conditions. If each execution has its own isolated
    state, we can eliminate data race conditions without needing to use complex synchronization
    logic involving mutexes, semaphores, or condition variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSP模型时的关键区别在于执行不会共享内存。相反，它们相互传递数据的副本。就像使用不可变性一样，如果每个执行都没有修改共享数据，就没有干扰的风险，因此我们避免了大多数竞态条件。如果每个执行都有自己的独立状态，我们可以消除数据竞态条件，而无需使用涉及互斥锁、信号量或条件变量的复杂同步逻辑。
- en: Go implements this model with the use of goroutines and channels. Just like
    in the CSP model, Go’s channels are synchronized and unbuffered by default. One
    key difference between the CSP model and Go’s implementation is that in Go, channels
    are first-class objects, meaning we can pass them around in functions or even
    in other channels. This gives us more programming flexibility. Instead of creating
    a static topology of connected sequential processes, we can instead create and
    remove channels at runtime, depending on our logic needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过goroutines和通道实现此模型。就像在CSP模型中一样，Go的通道默认是同步且不带缓冲的。CSP模型与Go实现之间的一个关键区别是，在Go中，通道是一等对象，这意味着我们可以在函数或甚至在其他通道中传递它们。这为我们提供了更多的编程灵活性。我们不是创建连接的顺序进程的静态拓扑，而是可以根据我们的逻辑需求在运行时创建和删除通道。
- en: CSP in other languages
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中的CSP
- en: Many other languages implement some aspects of the CSP model. For example, in
    Erlang, processes communicate with each other by sending messages. However, in
    Erlang, there is no notion of a channel, and the messages sent are not synchronous.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他语言实现了CSP模型的一些方面。例如，在Erlang中，进程通过发送消息相互通信。然而，在Erlang中，没有通道的概念，发送的消息也不是同步的。
- en: In Java and Scala, the Akka framework uses an Actor model. This is a message-passing
    framework in which units of execution are called *actors*. Actors have their own
    isolated memory space and pass messages to each other. Unlike in CSP, there is
    no notion of channels, and message passing is not synchronous.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和Scala中，Akka框架使用Actor模型。这是一个执行单元被称为*actors*的消息传递框架。Actors有自己的独立内存空间，并相互传递消息。与CSP不同，没有通道的概念，消息传递也不是同步的。
- en: 9.2 Reusing common patterns with channels
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 使用通道重用常见模式
- en: 'When we use message passing with channels in Go, there are two main guidelines
    to follow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Go中使用通道进行消息传递时，有两个主要指南需要遵循：
- en: '*Try to only pass copies of data on channels*. This implies that you shouldn’t
    pass direct pointers on channels in most cases. Passing pointers can result in
    multiple goroutines sharing memory, which can create race conditions. If you have
    to pass pointer references, use data structures in an immutable fashion—create
    them once, and don’t update them. Alternatively, pass a reference via a channel,
    and then never use it again from the sender.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽量只在通道上传递数据的副本*。这暗示了在大多数情况下，你不应该在通道上传递直接指针。传递指针可能导致多个goroutines共享内存，从而产生竞态条件。如果你必须传递指针引用，以不可变的方式使用数据结构——一次性创建它们，并且不要更新它们。或者，通过通道传递一个引用，然后从发送者那里不再使用它。'
- en: '*As much as possible, try not to mix message passing* *patterns with memory
    sharing*. Using memory sharing together with message passing might create confusion
    as to the approach adopted in the solution.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能不要混合消息传递* *模式与内存共享*。将内存共享与消息传递结合使用可能会在解决方案采用的方法上造成混淆。'
- en: Let’s now look at some examples of common concurrency patterns, best practices,
    and reusable components to understand how we can apply some of the CSP ideas to
    our applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看一些常见的并发模式、最佳实践和可重用组件的例子，以了解我们如何将一些CSP思想应用到我们的应用程序中。
- en: 9.2.1 Quitting channels
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 关闭通道
- en: The first pattern we will examine is having a common channel that instructs
    goroutines to stop processing messages. In the previous chapter, we saw how we
    can use Go’s `close(channel)` call to notify a goroutine that no more messages
    are coming. The goroutine can then terminate its execution. But what should we
    do if our goroutine is consuming from more than one channel? Should we terminate
    execution when we receive the first `close()` call or when all the channels are
    closed?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个模式是有一个公共通道，指示 goroutine 停止处理消息。在前一章中，我们看到了如何使用 Go 的 `close(channel)`
    调用来通知 goroutine 没有更多的消息到来。然后 goroutine 可以终止其执行。但是，如果我们的 goroutine 从多个通道中消费数据，我们应该在收到第一个
    `close()` 调用还是所有通道都关闭时终止执行？
- en: One solution is to use a quit channel together with the `select` statement.
    Figure 9.3 shows an example of a goroutine that generates numbers until it is
    instructed to stop on another quit channel. The goroutine on the right receives
    10 of these numbers and then calls `close(channel)` on the quit channel, instructing
    the number generation to stop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用一个 `quit` 通道与 `select` 语句一起使用。图 9.3 展示了一个示例，其中 goroutine 生成数字，直到它被指示在另一个
    `quit` 通道上停止。右侧的 goroutine 接收这 10 个数字，然后在 `quit` 通道上调用 `close(channel)`，指示数字生成停止。
- en: '![](../../OEBPS/Images/CH09_F03_Cutajar.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F03_Cutajar.png)'
- en: Figure 9.3 Using the quit channel to stop a goroutine’s execution
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 使用 `quit` 通道停止 goroutine 的执行
- en: Let’s start by implementing the goroutine that receives and prints the numbers.
    Listing 9.1 shows a function accepting both an input `numbers` channel and a `quit`
    channel. The function simply takes 10 items from the `numbers` channel and then
    closes the `quit` channel. The data type we use for the `quit` channel does not
    really matter, since no data is ever sent on it except the close signal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一个 goroutine，它接收并打印数字。列表 9.1 展示了一个接受输入 `numbers` 通道和 `quit` 通道的函数。该函数简单地从
    `numbers` 通道中取出 10 个项目，然后关闭 `quit` 通道。我们使用的 `quit` 通道的数据类型并不重要，因为除了关闭信号外，永远不会在该通道上发送数据。
- en: Listing 9.1 Prints 10 numbers and then closes the `quit` channel
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 打印 10 个数字然后关闭 `quit` 通道
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Consumes 10 items from the numbers channel
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数字通道消费 10 个项目
- en: ❷ Closes the quit channel
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 关闭 `quit` 通道
- en: Next, let’s look at generating a stream of numbers on a channel to be consumed
    by our previous function. In our number stream, we can write the triangular number
    sequence shown in figure 9.4.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在通道上生成一个数字流，以便由我们之前的功能消费。在我们的数字流中，我们可以写入图 9.4 所示的三角数序列。
- en: '![](../../OEBPS/Images/CH09_F04_Cutajar.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F04_Cutajar.png)'
- en: Figure 9.4 Generating a triangular number sequence
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 生成三角数序列
- en: In listing 9.2, we have the `main()` goroutine creating the `numbers` and `quit`
    channels and calling the `printNumbers()` function. We can then continue generating
    the numbers and sending them on the `numbers` channel until the `select` statement
    tells us that the `quit` channel has unblocked. Once the `quit` channel has unblocked,
    we can terminate the `main()` goroutine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.2 中，`main()` goroutine 创建了 `numbers` 和 `quit` 通道，并调用了 `printNumbers()`
    函数。然后我们可以继续生成数字并将它们发送到 `numbers` 通道，直到 `select` 语句告诉我们 `quit` 通道已解除阻塞。一旦 `quit`
    通道解除阻塞，我们可以终止 `main()` goroutine。
- en: Listing 9.2 Generating numbers until the `quit` channel is closed
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 生成数字直到 `quit` 通道关闭
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates the numbers and quit channels
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建数字和 `quit` 通道
- en: ❷ Calls the printNumbers() function, passing the channels
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 `printNumbers()` 函数，传递通道
- en: ❸ Generates the next triangular number
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成下一个三角数
- en: ❹ Sends the number on the numbers channel
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在数字通道上发送数字
- en: ❺ When the quit channel is unblocked, outputs a message and terminates the execution
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当 `quit` 通道解除阻塞时，输出一条消息并终止执行
- en: Note We are passing copies of the numbers on the channel. We are not sharing
    any memory because the goroutine has its own isolated memory space.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们在通道上传递数字的副本。我们没有共享任何内存，因为 goroutine 有它自己的独立内存空间。
- en: 'None of the variables used in the goroutines are being shared. For example,
    in listing 9.2, the `next` variable stays local on the `main()` function’s stack.
    Running listings 9.1 and 9.2 together, we get the following result:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 goroutine 中使用的所有变量都没有被共享。例如，在列表 9.2 中，`next` 变量保持在 `main()` 函数的栈上本地。运行列表 9.1
    和 9.2，我们得到以下结果：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 9.2.2 Pipelining with channels and goroutines
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用通道和 goroutine 进行管道化
- en: Let’s now look at a pattern of connecting goroutines to form an execution pipeline.
    We can demonstrate this with an application that processes the text contents of
    web pages. In chapters 3 and 4, we used a concurrent memory-sharing application
    that downloaded text documents from the internet and counted the frequencies of
    characters. In the following section, we will develop a similar application that
    uses message passing via channels instead of memory sharing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下连接goroutine以形成一个执行管道的模式。我们可以通过一个处理网页文本内容的应用程序来演示这一点。在第3章和第4章中，我们使用了一个并发内存共享应用程序，从互联网下载文本文档并计算字符频率。在下一节中，我们将开发一个类似的应用程序，该应用程序使用通过通道的消息传递而不是内存共享。
- en: The first step in our application is to generate URLs of web pages that we can
    download later. We can have a goroutine generate several URLs and send them on
    a channel to be consumed (see figure 9.5). For starters, we can simply print out
    the URLs on the console from our `main()` goroutine. Once we’re done, the goroutine
    generating the URLs will close the output channel to notify the `main()` goroutine
    that there aren’t any more web pages to process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一步是生成我们可以稍后下载的网页URL。我们可以让一个goroutine生成几个URL，并将它们发送到通道以供消费（见图9.5）。一开始，我们可以在`main()`
    goroutine中简单地从控制台打印出URL。一旦我们完成，生成URL的goroutine将关闭输出通道以通知`main()` goroutine没有更多的网页需要处理。
- en: '![](../../OEBPS/Images/CH09_F05_Cutajar.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F05_Cutajar.png)'
- en: Figure 9.5 Generating URLs and printing them out
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5生成URL并打印它们
- en: Listing 9.3 shows an implementation of the `generateUrls()` function, which
    creates a goroutine that generates URL strings on an output channel. The output
    channel is returned by the function. The function also accepts a quit channel,
    which it listens to in case it needs to stop generating URLs earlier. We’ll adopt
    a common pattern where we pass the input channel as a function argument and return
    the output channel (the `generateUrls()` function doesn’t have any input channels).
    This allows us to easily plug these goroutines together in the form of a pipeline.
    In our implementation, just as in chapter 3, we’re using documents obtained from
    [https://rfc-editor.org](https://rfc-editor.org). This provides us with static
    online text documents that have predictable web addresses.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3展示了`generateUrls()`函数的实现，该函数创建一个goroutine，在输出通道上生成URL字符串。该函数返回输出通道。该函数还接受一个退出通道，它监听该通道以防止需要提前停止生成URL。我们将采用一个常见的模式，将输入通道作为函数参数传递，并返回输出通道（`generateUrls()`函数没有输入通道）。这使我们能够轻松地将这些goroutine以管道的形式连接起来。在我们的实现中，就像在第3章中一样，我们使用从[https://rfc-editor.org](https://rfc-editor.org)获得的文档。这为我们提供了具有可预测Web地址的静态在线文本文档。
- en: Listing 9.3 Generating URLs from a goroutine
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 从goroutine生成URL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Accepts the quit channel and returns the output channel
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接受退出通道并返回输出通道
- en: ❷ Creates the output channel
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建输出通道
- en: ❸ Once complete, closes the output channel
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 完成后，关闭输出通道
- en: ❹ Writes 50 URLs to the output channel
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将50个URL写入输出通道
- en: ❺ Returns the output channel
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回输出通道
- en: Next, let’s complete our simple application by writing the `main()` function,
    shown in listing 9.4\. In the `main()` function, we create the `quit` channel
    and then call `generateUrls()`, which returns the goroutine’s output channel (called
    `results` in this example). We then listen to both the output and the `quit` channel.
    We continue writing messages from the output channel to the console until the
    `quit` channel is closed, at which point we terminate the application by returning
    on the `main()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过编写`main()`函数来完成我们的简单应用程序，该函数如列表9.4所示。在`main()`函数中，我们创建`quit`通道，然后调用`generateUrls()`，该函数返回goroutine的输出通道（在这个例子中称为`results`）。然后我们监听输出和`quit`通道。我们继续从输出通道向控制台写入消息，直到`quit`通道关闭，此时我们通过在`main()`函数中返回来终止应用程序。
- en: Listing 9.4 `main()` function for printing output
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 打印输出的`main()`函数
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Creates the quit channel
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建退出通道
- en: ❷ Calls the function to start the goroutine returning URLs on the results channel
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用函数以启动返回URL的goroutine，这些URL在结果通道上
- en: ❸ Reads all the messages from the results channels
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 读取结果通道上的所有消息
- en: ❹ Prints the results
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 打印结果
- en: 'Running listings 8.7 and 8.8 together, we get the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表8.7和8.8一起运行，我们得到以下输出：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, let’s write the logic to download the contents of these pages. For this
    task, we just need a goroutine that accepts a stream of URLs and outputs the text
    contents into another output stream. This goroutine can be plugged into the output
    of the `generateUrls()` goroutine and the input of the `main()` goroutine, as
    shown in figure 9.6.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写下载这些页面内容的逻辑。为此任务，我们只需要一个接受URL流并输出文本内容的另一个输出流的goroutine。这个goroutine可以连接到`generateUrls()`goroutine的输出和`main()`goroutine的输入，如图9.6所示。
- en: '![](../../OEBPS/Images/CH09_F06_Cutajar.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F06_Cutajar.png)'
- en: Figure 9.6 Adding a goroutine that downloads web pages to our pipeline
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 向我们的管道添加下载网页的goroutine
- en: Listing 9.5 shows an implementation of the `downloadPages()` function. It accepts
    both the `quit` and `urls` channels and returns an output channel containing the
    downloaded pages. The function creates a goroutine that uses the `select` statement
    to download each page until the `urls` channel or the `quit` channel is closed.
    The goroutine checks to see whether the input channel is still open by reading
    the `moreData` Boolean flag that is returned when it reads the next message. When
    this returns `false`, meaning the channel has been closed, we stop iterating on
    the `select` statement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5展示了`downloadPages()`函数的实现。它接受`quit`和`urls`通道，并返回一个包含下载页面的输出通道。该函数创建一个goroutine，使用`select`语句下载每个页面，直到`urls`通道或`quit`通道关闭。goroutine通过读取读取下一个消息时返回的`moreData`布尔标志来检查输入通道是否仍然打开。当它返回`false`，意味着通道已被关闭时，我们停止在`select`语句上迭代。
- en: Listing 9.5 Goroutine to download pages (imports omitted for brevity)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 下载页面的Goroutine（省略了导入以节省篇幅）
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates the output channel, which will contain downloaded web pages
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建输出通道，该通道将包含下载的网页
- en: ❷ Closes the output channel when it’s finished
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 完成后关闭输出通道
- en: ❸ Continues selecting if there is more data on the input channel
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果输入通道上有更多数据，则继续选择
- en: ❹ Updates variables with a new message and flag to show whether there is more
    data
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用新消息和标志更新变量以显示是否有更多数据
- en: ❺ When a new URL message arrives, downloads the page and sends the text on the
    pages channel
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当收到新的URL消息时，下载页面并将页面上的文本发送到页面通道
- en: ❻ When a message arrives on the quit channel, terminates the goroutine
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当退出通道上收到消息时，终止goroutine
- en: ❼ Returns the output channel
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 返回输出通道
- en: WARNING In listing 9.5, we’re passing a copy of the web document on the channel.
    We can do this since the web pages are only a few KB in size. Using message passing
    for large objects, such as images or video, in this fashion might have a detrimental
    effect on performance. Using a memory-sharing architecture might be more suitable
    for applications sharing large amounts of data and requiring high performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 在列表9.5中，我们在通道上传递了网页文档的副本。我们可以这样做，因为网页的大小只有几KB。以这种方式使用消息传递来处理大型对象，如图片或视频，可能会对性能产生不利影响。使用内存共享架构可能更适合需要高性能且共享大量数据的应用程序。
- en: We can now connect this new goroutine to our pipeline easily since it accepts
    the same channel datatype as the output of the `generateUrls()` function. It also
    returns the same output channel datatype as the one that our `main()`goroutine
    can use. In the following listing, we change the `main()` function to also call
    the `downloadPages()` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它接受与`generateUrls()`函数输出相同的通道数据类型，我们可以轻松地将这个新的goroutine连接到我们的管道中。它还返回与我们的`main()`goroutine可以使用的相同输出通道数据类型。在下面的列表中，我们将`main()`函数修改为也调用`downloadPages()`函数。
- en: Listing 9.6 Modified `main()` function to call `downloadPages()`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 修改后的`main()`函数以调用`downloadPages()`
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Adds the new goroutine that downloads pages to our existing pipeline
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将新的下载页面goroutine添加到我们现有的管道中
- en: When we run the preceding `main()` function, we get the text from the web pages,
    and they are printed on the console. Printing out our text pages is not very useful,
    so instead we can add another goroutine on our pipeline to extract words from
    the downloaded text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的`main()`函数时，我们从网页中获取文本，并将它们打印在控制台上。打印我们的文本页面并不很有用，因此我们可以向我们的管道添加另一个goroutine来从下载的文本中提取单词。
- en: Following this pattern of accepting the input channel as a function input parameter
    and returning the output channel makes building pipelines easy. We just need to
    create a new goroutine that extracts the words and then connect it to our pipeline,
    as shown in figure 9.7.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接受输入通道作为函数输入参数并返回输出通道的模式，构建管道变得容易。我们只需要创建一个新的goroutine来提取单词，然后将其连接到我们的管道中，如图9.7所示。
- en: '![](../../OEBPS/Images/CH09_F07_Cutajar.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F07_Cutajar.png)'
- en: Figure 9.7 Adding a goroutine to extract words from pages
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 向页面添加goroutine以提取单词
- en: Listing 9.7 shows the implementation of the `extractWords()` function. The same
    pattern as for `downloadPages()` is used. The function accepts an input channel
    containing texts, and it returns an output channel containing all the words found
    in the received texts. It extracts the words from the document by using regular
    expres- sions (regex).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7显示了`extractWords()`函数的实现。与`downloadPages()`相同的模式被使用。该函数接受包含文本的输入通道，并返回包含在接收到的文本中找到的所有单词的输出通道。它通过使用正则表达式（regex）从文档中提取单词。
- en: Just like in listing 9.6, we continue reading from the input channel until we
    get a close on the input or on the `quit` channel. We do this by using the `select`
    statement and reading the `moreData` flag on the input channel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在列表9.6中一样，我们继续从输入通道中读取，直到从输入或`quit`通道接收到关闭信号。我们通过使用`select`语句和读取输入通道上的`moreData`标志来实现这一点。
- en: Listing 9.7 Extracting words from text pages (imports omitted for brevity)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 从文本页面中提取单词（为了简洁，省略了导入）
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates the output channel, which will contain extracted words
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建输出通道，其中将包含提取的单词
- en: ❷ Creates a regular expression to extract the words
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建正则表达式以提取单词
- en: ❸ Updates variables with a new message and flag to show whether there is more
    data
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用新的消息和标志更新变量以显示是否有更多数据
- en: ❹ When a new text page is received, extracts all words with the regex and sends
    them on the output channel
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当接收到新的文本页面时，使用正则表达式提取所有单词并发送到输出通道
- en: ❺ When a message arrives on the quit channel, terminates goroutine
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当quit通道上到达消息时，终止goroutine
- en: ❻ Returns the output channel
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回输出通道
- en: Again, we can modify our `main()` function to include this new goroutine in
    our pipeline, as shown in listing 9.8\. Each function in the pipeline is a goroutine
    that takes the `quit` channel and an input channel and returns an output channel
    that results are sent to. Using the `quit` channel will later allow us to control
    the flow of different parts of the pipeline.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以修改我们的`main()`函数，将这个新的goroutine包含到我们的管道中，如列表9.8所示。管道中的每个函数都是一个goroutine，它接受`quit`通道和一个输入通道，并返回一个输出通道，结果将发送到该通道。使用`quit`通道将允许我们控制管道不同部分的流程。
- en: Listing 9.8 Adding `extractWords()` to the pipeline
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 将`extractWords()`添加到管道中
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the previous listings with the new `extractWords()` in our pipeline,
    we get a list of words contained in the texts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管道中使用新的`extractWords()`运行前面的列表，我们得到包含在文本中的单词列表：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note This pipeline pattern gives us the ability to easily plug executions together.
    Each execution is represented by a function that starts a goroutine accepting
    input channels as arguments and returning the output channels as return values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这种管道模式使我们能够轻松地将执行连接起来。每个执行都由一个函数表示，该函数启动一个接受输入通道作为参数并返回输出通道作为返回值的goroutine。
- en: When running listing 9.8, the web pages are downloaded sequentially, one after
    the other, making execution quite slow. Ideally, we’ll want to speed this up and
    do the downloads concurrently. This is where the next pattern (fan-in and fan-out)
    comes in handy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行列表9.8时，网页是顺序下载的，一个接一个，使得执行速度相当慢。理想情况下，我们希望加快这个速度并实现并发下载。这正是下一个模式（扇入和扇出）发挥作用的地方。
- en: 9.2.3 Fanning in and out
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 扇入和扇出
- en: In our example application, if we want to speed things up, we can perform the
    downloads concurrently by load-balancing the URLs to multiple goroutines. We can
    create a fixed number of goroutines, each reading from the same URL input channel.
    Each one of the goroutines will receive a separate URL from the `generateUrls()`
    goroutine, and they can perform the downloads concurrently. The downloaded text
    pages can then be written on each goroutine’s own output channel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，如果我们想加快速度，可以通过负载均衡URL到多个goroutine来实现并发下载。我们可以创建一定数量的goroutine，每个goroutine从相同的URL输入通道中读取。每个goroutine将从`generateUrls()`goroutine接收一个单独的URL，并且它们可以并发地执行下载。然后，下载的文本页面可以写入每个goroutine自己的输出通道。
- en: Definition In Go, a *fan-out* concurrency pattern is when multiple goroutines
    read from the same channel. In this way, we can distribute the work among a set
    of goroutines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 在Go中，*扇出*并发模式是指多个goroutine从同一个通道读取。通过这种方式，我们可以在一组goroutine之间分配工作。
- en: Figure 9.8 shows how we can fan out the URLs to multiple `downloadPage()` goroutines,
    each doing a different download. In this example, the concurrent goroutines are
    load-balancing the URLs sent from the `generateUrls()` goroutine; when a `downloadPage()`
    goroutine is free, it will read the next URL from the shared input channel. This
    is similar to having multiple baristas serving customers from a single queue at
    your local coffee shop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8展示了我们如何将URL扇出到多个`downloadPage()` goroutine，每个goroutine执行不同的下载。在这个例子中，并发goroutine正在通过`generateUrls()`
    goroutine发送的URL进行负载均衡；当一个`downloadPage()` goroutine空闲时，它将从共享输入通道读取下一个URL。这类似于在你当地的咖啡馆中，多个咖啡师从同一个队列服务客户。
- en: '![](../../OEBPS/Images/CH09_F08_Cutajar.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F08_Cutajar.png)'
- en: Figure 9.8 Load-balancing requests by using a fan-out pattern with the connection
    to `extractWords()` missing
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 使用扇出模式进行负载均衡请求，但与`extractWords()`的连接缺失
- en: Note Since concurrent processing is non-deterministic, some messages will be
    processed quicker than others, resulting in messages being processed in an unpredictable
    order. The fan-out pattern makes sense only if we don’t care about the order of
    the incoming messages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 由于并发处理是非确定性的，一些消息的处理速度会比其他消息快，导致消息以不可预测的顺序处理。只有当我们不关心传入消息的顺序时，扇出模式才有意义。
- en: In our code, we can implement this simple fan-out pattern by creating a set
    of `downloadPages()` goroutines and setting the same channel as an input channel
    parameter. This is shown in the following listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们可以通过创建一组`downloadPages()` goroutine并将相同的通道作为输入通道参数来实现这个简单的扇出模式。如下所示。
- en: Listing 9.9 Fanning out to multiple `downloadPages()` goroutines
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 扇出到多个`downloadPages()` goroutine
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Creates a slice to store output channels from the download goroutines
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个切片以存储从下载goroutines输出的通道
- en: ❷ Creates 20 goroutines to download web pages and stores the output channels
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建20个goroutine下载网页并存储输出通道
- en: 'The fan-out pattern in our application has created a problem: the outputs of
    our download goroutines are in separate channels. How can we connect them to the
    single input channel of our next stage: the `extractWords()` goroutine?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的扇出模式创建了一个问题：我们的下载goroutine的输出在单独的通道中。我们如何将它们连接到下一阶段的单个输入通道：`extractWords()`
    goroutine？
- en: One solution is to change the `downloadPages()` goroutines and make them all
    output on the same channel. For this, we would have to pass the same output channel
    to each downloader. This would break our pattern of having easily pluggable units
    where each one accepts input channels as arguments and returns the output channels
    as return values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是更改`downloadPages()` goroutine，并让它们都输出到同一个通道。为此，我们必须将相同的输出通道传递给每个下载器。这将破坏我们易于插入单元的模式，其中每个单元接受输入通道作为参数，并返回输出通道作为返回值。
- en: To keep to this pattern, we need a mechanism that merges the output messages
    from the different channels into a single output channel. We can then plug the
    single output channel into the `extractWords()` goroutine. This is what is called
    the *fan-in* pattern.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持这种模式，我们需要一个机制将不同通道的输出消息合并到单个输出通道中。然后我们可以将单个输出通道连接到`extractWords()` goroutine。这就是所谓的*扇入*模式。
- en: Definition In Go, a *fan-in* concurrency pattern occurs when we merge the content
    from multiple channels into one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 在Go中，当我们将多个通道的内容合并到一个通道时，发生*扇入*并发模式。
- en: Since goroutines are very lightweight, we can implement this fan-in pattern
    as a single unit by creating a set of goroutines, one per output channel, and
    having each goroutine feed a common channel, as shown in figure 9.9\. Each goroutine
    listens to messages from the output channel, and when a message arrives, it simply
    forwards it to the common channel.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于goroutine非常轻量级，我们可以通过创建一组goroutine（每个输出通道一个）并将每个goroutine连接到一个公共通道来实现这种扇入模式，如图9.9所示。每个goroutine监听输出通道的消息，当消息到达时，它只需将其转发到公共通道。
- en: '![](../../OEBPS/Images/CH09_F09_Cutajar.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F09_Cutajar.png)'
- en: Figure 9.9 Merging channels by using a fan-in
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 通过使用扇入合并通道
- en: 'Having multiple goroutines all feeding into a single common channel creates
    a problem. When we have a one-to-one input-to-output channel goroutine, the channel-
    closing strategy is simple: close the output after the input channel has been
    closed. When we have a many-to-one fan-in scenario, we must make a decision about
    when to close the common channel. If we continue with the same approach of closing
    the channel when a goroutine notices that the channel it’s consuming from has
    been closed, we might end up closing the channel too soon. Another goroutine might
    still be outputting messages.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个goroutines都向单个公共通道提供数据时，会引发问题。当我们有一个一对一的输入到输出通道的goroutine时，通道关闭策略很简单：在输入通道关闭后关闭输出通道。当我们有一个多对一的扇入场景时，我们必须决定何时关闭公共通道。如果我们继续在goroutine注意到它消费的通道已被关闭时关闭通道的方法，我们可能会过早地关闭通道。另一个goroutine可能仍在输出消息。
- en: The solution is to only close the common channel when *all* the goroutines have
    noticed that the channels from which they are consuming have been closed. As shown
    in figure 9.9, we can use a waitgroup for this. Each goroutine in the fan-in group
    marks the waitgroup as done after it has sent its last message. We have a separate
    goroutine that calls `wait()` on this waitgroup, which will have the effect of
    suspending its execution until all the fan-in goroutines are done. Once this goroutine
    resumes, it will close the output channel. This technique is shown in the following
    listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是仅在**所有**goroutines都注意到它们消费的通道已被关闭时才关闭公共通道。如图9.9所示，我们可以使用一个waitgroup来实现这一点。扇入组中的每个goroutine在发送其最后一条消息后将其标记为完成。我们有一个单独的goroutine，它会在这个waitgroup上调用`wait()`，这将导致其执行暂停，直到所有扇入goroutine都完成。一旦这个goroutine恢复，它将关闭输出通道。这种技术在下述列表中展示。
- en: Listing 9.10 Implementing a fan-in function
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 实现扇入函数
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Creates a waitgroup, setting the size to be equal to the number of input channels
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个waitgroup，设置大小等于输入通道的数量
- en: ❷ Creates the output channel
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建输出通道
- en: ❸ Starts a goroutine for every input channel
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每个输入通道启动一个goroutine
- en: ❹ Once the goroutine terminates, marks the waitgroup as done
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一旦goroutine终止，将waitgroup标记为完成
- en: ❺ Forwards each received message to the shared output channel
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将接收到的每条消息转发到共享输出通道
- en: ❻ If quit channel is closed, terminates the goroutine
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果退出通道被关闭，终止goroutine
- en: ❼ Passes one input channel to the goroutine
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将一个输入通道传递给goroutine
- en: ❽ Waits for all the goroutines to finish and then closes the output channel
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 等待所有goroutine完成，然后关闭输出通道
- en: ❾ Returns the output channel
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 返回输出通道
- en: We can now connect our fan-in pattern to our application and include it in the
    pipeline. Listing 9.11 modifies our `main()` function to include the `fanIn()`
    function from listing 9.10\. The `fanIn()` function accepts the list of channels
    containing the web pages and returns a common aggregated channel, which we then
    feed into our `extractWords()` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的扇入模式连接到我们的应用程序，并将其包含在管道中。列表9.11修改了我们的`main()`函数，以包含列表9.10中的`fanIn()`函数。`fanIn()`函数接受包含网页的通道列表，并返回一个公共聚合通道，然后我们将其输入到我们的`extractWords()`函数中。
- en: Listing 9.11 Adding the `fanIn()` function to the pipeline
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 向管道添加`fanIn()`函数
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Joins all the pages channels into one channel using the fan-in pattern
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用扇入模式将所有页面通道合并为一个通道
- en: When we run our new implementation, it runs a lot faster because the downloads
    are being performed concurrently. As a side effect of doing the downloads together,
    the order of the extracted words is different every time we run the program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行新的实现时，它运行得更快，因为下载是并发执行的。作为一起执行下载的副作用，每次运行程序时提取单词的顺序都不同。
- en: 9.2.4 Flushing results on close
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 关闭时刷新结果
- en: We haven’t really done anything interesting with our URL download application,
    apart from extracting the words. What if we use the downloaded web pages for something
    useful? How about trying to find the 10 longest words in these text documents?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提取单词之外，我们的URL下载应用程序并没有真正做任何有趣的事情。如果我们用下载的网页做些有用的事情会怎样？比如尝试找出这些文本文档中的10个最长单词？
- en: This task is easy if we continue to follow our pipeline-building pattern. We
    just need to add a new goroutine that accepts an input channel and returns an
    output one. In figure 9.10, this new goroutine, called `longestWords()`, is inserted
    just after our `extractWords()` goroutine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续遵循我们的管道构建模式，这个任务就很简单了。我们只需要添加一个新的 goroutine，它接受一个输入通道并返回一个输出通道。在图 9.10
    中，这个新 goroutine，称为 `longestWords()`，被插入到我们的 `extractWords()` goroutine 之后。
- en: '![](../../OEBPS/Images/CH09_F10_Cutajar.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F10_Cutajar.png)'
- en: Figure 9.10 Adding the `longestWords()` goroutine to find the 10 longest words
    in our texts
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 向我们的文本添加 `longestWords()` goroutine 以找到 10 个最长单词
- en: This new `longestWords()` goroutine is slightly different from the other goroutines
    we have developed in our pipeline. It accumulates a set of unique words in its
    memory. Once it has read all the words from the web pages and receives the close
    message, it will review this set and output the 10 longest ones. Our `main()`
    goroutine will then print it on the console.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `longestWords()` goroutine 与我们在管道中开发的其它 goroutine 略有不同。它在内存中累积一组唯一单词。一旦它从网页中读取了所有单词并收到关闭消息，它将审查这个集合并输出最长的
    10 个单词。然后，我们的 `main()` goroutine 将在控制台上打印出来。
- en: The implementation of `longestWords()` is shown in listing 9.12\. In this function,
    we use a map to store the set of unique words. Since this map is isolated from
    our concurrent execution and only our `longestWords()` goroutine is accessing
    it, we do not need to worry about data race conditions. We also store the words
    in a separate slice to make sorting easier.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`longestWords()` 函数的实现展示在列表 9.12 中。在这个函数中，我们使用一个映射来存储唯一单词的集合。由于这个映射与我们的并发执行是隔离的，并且只有我们的
    `longestWords()` goroutine 访问它，所以我们不需要担心数据竞争条件。我们还将单词存储在单独的切片中，以便于后续排序。'
- en: Listing 9.12 Goroutine to output longest words (imports omitted for brevity)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 输出最长单词的 goroutine（为了简洁省略了导入）
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a map to store unique words
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个映射来存储唯一单词
- en: ❷ Creates slices to store the list of unique words for easy sorting later
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建切片来存储唯一单词列表，以便于后续排序
- en: ❸ If the channel is not closed and the word is a new one, adds the new word
    to the map and list
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果通道没有关闭且单词是新的，将新单词添加到映射和列表中
- en: ❹ Once the input channel is closed, sorts the unique words list by word length
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一旦输入通道关闭，就按单词长度对唯一单词列表进行排序
- en: ❺ Once the input channel is closed, sends a string with the 10 longest words
    on the output channel
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一旦输入通道关闭，就在输出通道上发送包含 10 个最长单词的字符串
- en: In listing 9.12, the goroutine stores all the unique words on a map and a list.
    Once the input channel closes, meaning there are no more messages, the goroutine
    sorts the list of unique words by length. Then, on the output channel, it sends
    the first 10 items on the list, which are the 10 longest words. In this way, we
    flush the results after we have collected all the data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.12 中，goroutine 将所有唯一单词存储在映射和列表中。一旦输入通道关闭，意味着没有更多消息，goroutine 将按长度对唯一单词列表进行排序。然后，在输出通道上，它发送列表上的前
    10 项，即最长的 10 个单词。这样，我们在收集所有数据后刷新结果。
- en: We can now connect this new component to our pipeline in the `main()` function.
    In the following listing, the `longestWords()` goroutine consumes from the output
    channel of `extractWords()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `main()` 函数中将这个新组件连接到我们的管道中。在下面的列表中，`longestWords()` goroutine 从 `extractWords()`
    的输出通道中消费数据。
- en: Listing 9.13 Adding `longestWords()` to our pipeline
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 向我们的管道添加 `longestWords()`
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Connects the longestWords() goroutine to the pipeline just after extractWords()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 extractWords() goroutine 之后将 longestWords() goroutine 连接到管道
- en: ❷ Prints the single message containing the longest words
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印包含最长单词的单条消息
- en: 'When we run the listings together, the pipeline will find the longest words
    on the downloaded documents and output them on the console. Here’s the output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这些列表时，管道将在下载的文档中找到最长的单词，并在控制台上输出。以下是输出：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 9.2.5 Broadcasting to multiple goroutines
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.5 向多个 goroutine 广播
- en: What if we want to find out more stats from our download pages? For this scenario,
    let’s say that in addition to finding the longest words, we want to find which
    words occur most frequently.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从下载的网页中获取更多统计数据呢？对于这种情况，假设除了找到最长的单词外，我们还想找出出现频率最高的单词。
- en: 'For this scenario, we’ll feed the output of `extractWords()` to two goroutines:
    the existing `longestWords()` and an additional one called `frequentWords()`.
    The pattern of the new function will be the same as that of `longestWords()`.
    It will store the frequency of each unique word, and when the input channel closes,
    it will output the top 10 most often-occurring words.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种场景，我们将`extractWords()`的输出传递给两个goroutine：现有的`longestWords()`和一个额外的名为`frequentWords()`的goroutine。新函数的模式将与`longestWords()`相同。它将存储每个唯一单词的频率，当输入通道关闭时，它将输出出现频率最高的前10个单词。
- en: In the previous section, we used the fan-out pattern when we needed to feed
    the output of one computation to multiple concurrent goroutines. We load-balanced
    the messages, with each goroutine receiving a distinct subset of the output data.
    That pattern will not work here, since we want to send a copy of each output message
    to both the `longestWords()` and `frequentWords()` goroutines.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当我们需要将一个计算的输出传递给多个并发goroutine时，我们使用了扇出模式。我们平衡了消息负载，每个goroutine接收输出数据的不同子集。这种模式在这里不适用，因为我们希望将每个输出消息的副本发送给`longestWords()`和`frequentWords()`
    goroutine。
- en: Instead of fan-out, we can use a broadcast pattern—one that replicates messages
    to a set of output channels. Figure 9.11 shows how we can use a separate goroutine
    that broadcasts to multiple channels. In our pipeline, we can connect the outputs
    of the broadcast to the inputs of both the `frequentWords()` and `longestWords()`
    goroutines.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是扇出模式，我们可以使用广播模式——一种将消息复制到一组输出通道的模式。图 9.11 显示了我们可以如何使用一个单独的goroutine来广播到多个通道。在我们的管道中，我们可以将广播的输出连接到`frequentWords()`和`longestWords()`
    goroutine的输入。
- en: '![](../../OEBPS/Images/CH09_F11_Cutajar.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F11_Cutajar.png)'
- en: Figure 9.11 Connecting a concurrent `frequentWords()` goroutine to our pipeline
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 将并发`frequentWords()` goroutine连接到我们的管道
- en: To implement this broadcast utility, we just need to create a list of output
    channels and then use a goroutine that writes every received message to each channel.
    In listing 9.14, the broadcast function accepts the input channel and an integer,
    `n`, specifying the number of outputs that are needed. The function then returns
    these `n` output channels in a slice. In this implementation, we’re using generics
    so that the broadcast can be used with any channel data type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个广播工具，我们只需要创建一个输出通道列表，然后使用一个goroutine将每个接收到的消息写入每个通道。在列表 9.14 中，广播函数接受输入通道和一个整数`n`，指定所需的输出数量。然后函数返回这些`n`个输出通道的切片。在这个实现中，我们使用了泛型，以便广播可以使用任何通道数据类型。
- en: Listing 9.14 Broadcasting to multiple output channels
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 向多个输出通道广播
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Creates n output channels of type K (see the next listing for the implementation)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建n个类型为K的输出通道（请参阅下一列表以获取实现方法）
- en: ❷ Once complete, closes all output channels (see the next listing for the implementation)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 完成后，关闭所有输出通道（请参阅下一列表以获取实现方法）
- en: ❸ Reads the next message from the input channel
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从输入通道读取下一个消息
- en: ❹ If the input channel hasn’t been closed, writes the message to each output
    channel
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果输入通道尚未关闭，则将消息写入每个输出通道
- en: ❺ Returns the set of output channels
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回输出通道集合
- en: NOTE In the broadcast implementation in listing 9.14, we read the next message
    only after the current message has been sent to all the channels. A slow consumer
    from this broadcast implementation would slow all consumers to the same rate.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在列表 9.14 中的广播实现中，我们只在当前消息被发送到所有通道之后才读取下一个消息。从这个广播实现中来的慢消费者会减慢所有消费者的速度。
- en: The previous listing makes use of two functions, `CreateAll()` and `CloseAll()`,
    that create and close a set of channels, respectively. The following listing shows
    their implementation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上一列表使用了两个函数，`CreateAll()`和`CloseAll()`，分别用于创建和关闭一组通道。以下列表显示了它们的实现。
- en: Listing 9.15 The `CreateAll()` and `CloseAll()` functions
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 `CreateAll()`和`CloseAll()`函数
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Creates n channels of type K
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建n个类型为K的通道
- en: ❷ Closes all the channels
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 关闭所有通道
- en: We can now write our `frequentWords()` function, which will identify the top
    10 most frequently occurring words in our downloaded pages. The implementation
    in the following listing is similar to the `longestWords()` function. This time,
    we’re using a map, called `mostFrequentWords`, to count each word’s occurrence.
    After the input channel is closed, we sort the word list by the occurrence count
    in the map.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写我们的`frequentWords()`函数，该函数将识别下载页面中频率最高的前10个单词。以下列表中的实现与`longestWords()`函数类似。这次，我们使用一个名为`mostFrequentWords`的映射来计数每个单词的出现次数。在输入通道关闭后，我们根据映射中的出现次数对单词列表进行排序。
- en: Listing 9.16 Finding the most frequent words (imports omitted for brevity)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 寻找最频繁的单词（省略了导入以节省空间）
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates a map to store the frequency occurrence of each unique word
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个映射来存储每个唯一单词的频率出现次数
- en: ❷ Creates a slice to store a list of unique words
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个切片来存储唯一单词列表
- en: ❸ Consumes the next message on the input channel
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 消费输入通道上的下一个消息
- en: ❹ If the message contains a new word, adds it to the slice of unique words
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果消息包含一个新单词，则将其添加到唯一单词的切片中
- en: ❺ Increments the count of the word
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 增加单词的计数
- en: ❻ Once all input messages are consumed, sorts the list of words by the occurrence
    count
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 一旦消耗完所有输入消息，就按出现次数对单词列表进行排序
- en: ❼ Writes the 10 most frequent words onto the output channel
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将10个最频繁的单词写入输出通道
- en: Now we can wire in the `frequentWords()` unit with the broadcast utility we
    developed previously. In the following listing, we call the `Broadcast()` function
    to create two output channels and make it consume from `extractWords()`. Then
    we use the two output channels from the broadcast as inputs for the `longestWords()`
    and `frequentWords()` goroutines.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们之前开发的广播实用程序将`frequentWords()`单元连接起来。在以下列表中，我们调用`Broadcast()`函数创建两个输出通道，并使其从`extractWords()`中消费。然后我们使用广播的两个输出通道作为`longestWords()`和`frequentWords()`
    goroutine的输入。
- en: Listing 9.17 Wiring in the broadcast pattern to find the most frequent and longest
    words
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 将广播模式连接到查找最频繁和最长的单词
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Creates a goroutine that will broadcast the contents of the words channel
    to two output channels
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个goroutine，该goroutine将向两个输出通道广播单词通道的内容
- en: ❷ Creates the goroutine to find the longest words from the input channel
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建goroutine以从输入通道中查找最长的单词
- en: ❸ Creates the goroutine to find the most frequently used words from the input
    channel
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建goroutine以从输入通道中查找最常用的单词
- en: ❹ Reads the result from the longestWords() goroutine and prints it
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从`longestWords()` goroutine读取结果并打印
- en: ❺ Reads the result from the mostFrequentWords() goroutine and prints it
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从`mostFrequentWords()` goroutine读取结果并打印
- en: 'Since both the `longestWords()` and `frequentWords()` goroutines output only
    one message containing the results, our `main()` function can just consume one
    message from each and print it on the console. The following snippet contains
    the output when we run the full pipeline. Not surprisingly, *the* is the most
    frequent word:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`longestWords()`和`frequentWords()` goroutine只输出包含结果的一个消息，因此我们的`main()`函数只需从每个goroutine中消费一个消息，并在控制台上打印它。以下片段包含运行完整管道时的输出。不出所料，*the*是最频繁的单词：
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 9.2.6 Closing channels after a condition
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.6 在满足条件后关闭通道
- en: So far, we haven’t really used the quit channels that we have wired into every
    goroutine in our application. These quit channels can be used to stop parts of
    the pipeline on certain conditions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有真正使用我们在应用程序中的每个goroutine中连接的退出通道。这些退出通道可以在某些条件下停止管道的部分。
- en: In our application, we are reading a fixed number of web pages and then processing
    them, but what if we wanted to process only the first 10,000 words that we download?
    The solution is to add another execution that stops a section of our pipeline
    after it has consumed a specified number of messages. If we insert this new goroutine,
    called `Take(n)`, just after the `extractWords()` goroutine, we can instruct it
    to close the `quit` channel after receiving a specified number of messages (see
    figure 9.12). The `Take(n)` goroutine will only terminate parts of the pipeline
    by calling `close()` on the `quit` channel. We can do this by wiring the left
    part of the pipeline, before the `take(n)` goroutine, with a separate `quit` channel.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们正在读取固定数量的网页并处理它们，但如果我们只想处理下载的前 10,000 个单词怎么办？解决方案是在我们的管道消耗了指定数量的消息后停止其一部分的执行。如果我们在这个新的goroutine（称为
    `Take(n)`）之后插入这个新的goroutine，我们就可以指示它在接收指定数量的消息后关闭 `quit` 通道（见图 9.12）。`Take(n)`
    goroutine 将通过在 `quit` 通道上调用 `close()` 来仅终止管道的一部分。我们可以通过将管道的左侧（在 `take(n)` goroutine
    之前）与一个单独的 `quit` 通道连接来实现这一点。
- en: '![](../../OEBPS/Images/CH09_F12_Cutajar.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F12_Cutajar.png)'
- en: Figure 9.12 Adding the `Take(n)` goroutine to our pipeline
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 将 `Take(n)` goroutine 添加到我们的管道中
- en: To implement `Take(n)`, we need a goroutine that simply forwards the messages
    received from the input to the output channel while keeping a countdown, with
    every message forwarded reducing the countdown by `1`. Once the countdown is `0`,
    the goroutine closes the `quit` and output channels. Listing 9.18 shows an implementation
    of `Take(n)`, where the countdown is represented by the variable `n`. The goroutine
    continues forwarding messages as long as there is more data, the countdown is
    greater than `0`, and the `quit` channel hasn’t been closed. It will close the
    `quit` channel only if the countdown hits `0`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `Take(n)`，我们需要一个goroutine，它简单地转发从输入接收到的消息到输出通道，同时进行倒计时，每次转发的消息都会使倒计时减少 `1`。一旦倒计时达到
    `0`，goroutine将关闭 `quit` 和输出通道。列表 9.18 展示了 `Take(n)` 的一个实现，其中倒计时由变量 `n` 表示。只要还有更多数据，倒计时大于
    `0`，并且 `quit` 通道未被关闭，goroutine就会继续转发消息。它只有在倒计时达到 `0` 时才会关闭 `quit` 通道。
- en: Listing 9.18 Implementing the `Take(n)` function
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 实现 `Take(n)` 函数
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Continues forwarding messages as long as there is more data and countdown
    n is greater than 0
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只要还有更多数据且倒计时 n 大于 0，就继续转发消息
- en: ❷ Reads the next message from the input
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从输入读取下一个消息
- en: ❸ Forwards the message to the output
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将消息转发到输出
- en: ❹ Reduces the countdown variable n by 1
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将倒计时变量 n 减少到 1
- en: ❺ Closes the quit channel if the countdown reaches 0
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果倒计时达到 0，则关闭 quit 通道
- en: We can now add this new component to our pipeline and make it stop the processing
    when it reaches a specific word count. The following listing shows how we can
    modify our `main()` function to include the `Take(n)` goroutine, configured to
    stop processing when it reaches the count of 10,000 words.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个新组件添加到我们的管道中，并在达到特定的单词计数时停止处理。以下列表显示了如何修改我们的 `main()` 函数以包括配置为在达到 10,000
    个单词计数时停止处理的 `Take(n)` goroutine。
- en: Listing 9.19 Wiring `Take(n)` into our pipeline
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 将 `Take(n)` 连接到我们的管道
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Creates a separate quit channel to be used before the Take(n) function
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 `Take(n)` 函数之前创建一个单独的 quit 通道
- en: ❷ Creates the Take(n) goroutine with a 10,000 countdown, feeding from the extractWords()
    output
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个带有 10,000 个倒计时的 `Take(n)` goroutine，从 `extractWords()` 输出中获取数据
- en: ❸ Uses a separate quit channel for the rest of the pipeline
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为管道的其余部分使用单独的 quit 通道
- en: 'Running listing 9.19 results in the word stats being processed only on the
    first 10,000 words downloaded. Since the downloads are done in parallel, the order
    of the downloaded pages cannot be predicted and might be different every time
    the application is run. Thus, the first 10,000 words encountered will vary, depending
    on which pages get downloaded first. Here’s the output of one such run:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 9.19 结果只处理下载的前 10,000 个单词。由于下载是并行进行的，下载的页面顺序无法预测，并且每次运行应用程序时可能都不同。因此，遇到的第一个
    10,000 个单词将根据首先下载的页面而变化。以下是此类运行的一个输出示例：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 9.2.7 Adopting channels as first-class objects
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.7 采用通道作为一等对象
- en: In his CSP language paper, C.A.R. Hoare uses an example of generating prime
    numbers up to 10,000 with a list of communicating sequential processes. The algorithm
    is based on the sieve of Eratosthenes, which is a simple method for checking whether
    a number is prime. The approach in the CSP paper uses a static linear pipeline
    where each process in the pipeline filters the multiple of a prime number and
    then passes it on to the next process. Because the pipeline is static (it doesn’t
    grow with the problem size), it will generate prime numbers only up to a fixed
    number.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的CSP语言论文中，C.A.R. Hoare使用了一个例子，即使用通信顺序进程列表生成1万以内的素数。该算法基于埃拉托斯特尼筛法，这是一种检查一个数是否为素数的简单方法。CSP论文中的方法使用了一个静态线性管道，其中管道中的每个进程都会过滤掉一个素数的倍数，并将其传递给下一个进程。因为管道是静态的（它不会随着问题规模的增长而增长），它只能生成到固定数量的素数。
- en: The improvement available in Go over the CSP language that was defined in the
    original paper is that channels are first-class objects. This means that a channel
    can be stored as a variable and passed around to other functions. In Go, a channel
    can also be passed on another channel. This allows us to improve on the original
    solution by using a dynamic linear pipeline, one that grows with the problem’s
    size and that allows us to generate up to `n` prime numbers, instead of up to
    a fixed number.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言相较于原始论文中定义的CSP语言可用的改进是，通道是一等对象。这意味着通道可以被存储为变量并传递给其他函数。在Go中，一个通道也可以传递给另一个通道。这允许我们通过使用动态线性管道来改进原始解决方案，这种管道随着问题规模的增长而增长，并且允许我们生成多达`n`个素数，而不是生成到固定数量的素数。
- en: Origins of the prime numbers pipeline algorithm
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 素数管道算法的起源
- en: Although the solution of using a pipeline to generate prime numbers was mentioned
    in the CSP paper, the original idea has been attributed to the mathematician and
    programmer Douglas McIlroy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用管道生成素数的解决方案在CSP论文中提到了，但原始的想法被归功于数学家和程序员Douglas McIlroy。
- en: Figure 9.13 shows how we can generate prime numbers using a concurrent pipeline.
    A number, `c`, is prime if `c` is not a multiple of all the prime numbers less
    than `c`. For example, to check whether 7 is a prime number, we need to ensure
    that 7 is not divisible by 2, 3, or 5\. Since 7 is not divisible by any of these,
    7 is a prime number. However, the number 9 is divisible by 3, so 9 is not a prime
    number.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13展示了我们如何使用并发管道生成素数。一个数`c`是素数，如果`c`不是小于`c`的所有素数的倍数。例如，要检查7是否为素数，我们需要确保7不能被2、3或5整除。由于7不能被这些数中的任何一个整除，所以7是一个素数。然而，数字9可以被3整除，所以9不是一个素数。
- en: '![](../../OEBPS/Images/CH09_F13_Cutajar.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13](../../OEBPS/Images/CH09_F13_Cutajar.png)'
- en: Figure 9.13 Checking to see whether a number is a prime by using a pipeline
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 通过管道检查一个数是否为素数
- en: Checking to see whether a number is prime
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个数是否为素数
- en: To check whether the number `c` is prime, we only need to check that `c` is
    not divisible by all primes less than the square root of `c`. However, for this
    section, we’re simplifying the requirements to keep the listings simpler and shorter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查数字`c`是否为素数，我们只需要检查`c`不能被小于`c`的平方根的所有素数整除。然而，在本节中，我们简化了要求以保持列表更简单、更短。
- en: For our prime-checking pipeline, we can have a goroutine generate candidate
    sequential numbers starting from 2\. The output of this goroutine will feed into
    a pipeline that consists of a chain of goroutines, each filtering out the multiples
    of a prime number. A goroutine in this chain is assigned a prime number, `p`,
    and it will discard numbers that are multiples of `p`. If a number is not discarded,
    it is passed on to the right side of the chain. If it survives all the way to
    the end, that means we have a new prime number, and a new goroutine is created
    with its `p` equal to the new prime. This process is shown in figure 9.14.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的素数检查管道，我们可以让一个goroutine从2开始生成候选的连续数字。这个goroutine的输出将输入到一个由goroutine链组成的管道中，每个goroutine都会过滤掉一个素数的倍数。这个链中的goroutine被分配一个素数`p`，它将丢弃所有是`p`的倍数的数字。如果一个数字没有被丢弃，它将被传递到链的右侧。如果它一路存活到链的末端，这意味着我们找到了一个新的素数，并且会创建一个新的goroutine，其`p`等于新的素数。这个过程在图9.14中展示。
- en: '![](../../OEBPS/Images/CH09_F14_Cutajar.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14](../../OEBPS/Images/CH09_F14_Cutajar.png)'
- en: Figure 9.14 When a new prime is found, we start a new goroutine that filters
    multiples of that new prime.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 当找到一个新素数时，我们启动一个新的goroutine来过滤该新素数的倍数。
- en: In our pipeline, when a number passes through all the existing goroutines and
    is not discarded, that means we have found a new prime number. The last goroutine
    in the pipeline will then initialize a new goroutine at the tail of the pipeline
    and connect to it. This new goroutine will become the new tail of the pipeline,
    and it will filter out the multiples of the newly found prime. In this way, the
    pipeline grows dynamically with the number of primes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管道中，当一个数字通过所有现有的goroutine并且没有被丢弃时，这意味着我们找到了一个新的素数。管道中的最后一个goroutine将在管道尾部初始化一个新的goroutine并将其连接。这个新的goroutine将成为管道的新尾部，并且它将过滤掉新找到的素数的倍数。这样，管道会随着素数的数量动态增长。
- en: Having this pipeline grow dynamically with the number of primes shows the advantage
    of treating channels as first-class objects, compared to the original channel
    in the CSP paper by C.A.R. Hoare. Go gives us the ability to treat channels like
    normal variables.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个管道随着素数的数量动态增长显示了将channel视为一等对象的优势，与C.A.R. Hoare在CSP论文中的原始channel相比。Go给了我们像普通变量一样处理channel的能力。
- en: Listing 9.20 implements this prime-filtering goroutine. Upon creation, the goroutine
    receives its first message on the channel containing the prime number, `p`, that
    will be used for the multiple filtering. Then it listens for new numbers on its
    input channel, and it checks to see whether any number received is a multiple
    of `p`. If it is, the goroutine simply discards it; otherwise, it passes the number
    on to its right channel. If the goroutine happens to be at the tail of the pipeline,
    it creates a new right channel and passes the channel to a newly created goroutine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20实现了这个素数过滤goroutine。创建时，goroutine在其channel上接收第一个消息，其中包含将要用于倍数过滤的素数`p`。然后它在其输入channel上监听新的数字，并检查接收到的任何数字是否是`p`的倍数。如果是，goroutine简单地丢弃它；否则，它将数字传递到其右边的channel。如果goroutine恰好是管道的尾部，它将创建一个新的右边的channel并将channel传递给一个新创建的goroutine。
- en: Listing 9.20 The `primeMultipleFilter()` goroutine
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20 `primeMultipleFilter()` goroutine
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Receives the first message containing the prime number p on the input channel
    and prints it
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在输入channel上接收包含素数p的第一个消息并打印它
- en: ❷ Reads the next number from the input channel
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从输入channel读取下一个数字
- en: ❸ Discards any received number that is a multiple of p
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 丢弃任何接收到的p的倍数
- en: ❹ If the current goroutine has no right, it starts a new goroutine and connects
    to it with a channel.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果当前goroutine没有权限，它将启动一个新的goroutine并通过一个channel连接到它。
- en: ❺ Passes the filtered number to the right channel
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将过滤后的数字传递到右边的channel
- en: ❻ Closes the quit channel if there are no more numbers to filter and the goroutine
    has no right channel
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果没有更多的数字要过滤并且goroutine没有右边的channel，关闭退出channel
- en: ❼ Otherwise, closes right channel
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 否则，关闭右边的channel
- en: All we need now is to connect our prime multiple filters to a sequential number
    generator. We can use the `main()` goroutine for this task. In listing 9.21, our
    `main()` function starts our first prime multiple filter goroutine with an input
    channel and then feeds it sequential numbers from 2 to 100,000\. After that, it
    closes the input channel and waits for the quit channel to close. In this way,
    we ensure that the last prime number is printed before we terminate the `main()`
    goroutine.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将我们的素数倍数过滤器连接到一个连续数字生成器。我们可以使用`main()` goroutine来完成这个任务。在列表9.21中，我们的`main()`函数使用输入channel启动我们的第一个素数倍数过滤器goroutine，然后从2到100,000连续地给它喂数字。之后，它关闭输入channel并等待退出channel关闭。这样，我们确保在终止`main()`
    goroutine之前打印出最后一个素数。
- en: Listing 9.21 The `main()` function feeding sequential numbers to the prime filters
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 `main()` 函数将连续数字喂给素数过滤器
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Creates an input channel that will feed the prime multiple filters
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个将喂给素数倍数过滤器的输入channel
- en: ❷ Creates a common quit channel
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个公共的退出channel
- en: ❸ Starts the first goroutine in the pipeline, passing the numbers and quit channels
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 启动管道中的第一个goroutine，传递数字和退出channel
- en: ❹ Feeds sequential numbers, starting from 2 up to 100,000, onto the input channel
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从2开始，将连续数字喂到输入channel，直到100,000
- en: ❺ Closes the input channel, signaling that there will be no more numbers
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 关闭输入channel，表示将没有更多的数字
- en: ❻ Waits for the quit channel to close
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 等待退出channel关闭
- en: 'Running listings 9.20 and 9.21 together gives us all the prime numbers less
    than 100,000:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表9.20和9.21一起运行，我们可以得到小于100,000的所有素数：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 9.3 Exercises
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 练习
- en: NOTE Visit [http://github.com/cutajarj/ConcurrentProgrammingWithGo](http://github.com/cutajarj/ConcurrentProgrammingWithGo)
    to see all the code solutions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：访问[http://github.com/cutajarj/ConcurrentProgrammingWithGo](http://github.com/cutajarj/ConcurrentProgrammingWithGo)以查看所有代码解决方案。
- en: 'Write a generator goroutine similar to listing 9.2 that, instead of generating
    URL strings, generates an infinite stream of square numbers (1, 4, 9, 16, 25 .
    . .) on an output channel. Here is the signature:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类似于列表9.2的生成器goroutine，它不是生成URL字符串，而是在输出通道上生成一个无限的平方数流（1, 4, 9, 16, 25 ...）。以下是函数签名：
- en: '[PRE28]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In listing 9.18, we developed a `take(n)` goroutine. Extend the functionality
    of this goroutine to implement `TakeUntil(f)`, where `f` is a function returning
    a Boolean. The goroutine needs to continue consuming and forwarding the messages
    on its input channel while the return value of `f` is `true`. Using generics ensures
    that we can reuse the `TakeUntil(f)` function and plug it into many other pipelines.
    Here’s the function signature:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表9.18中，我们开发了一个`take(n)` goroutine。扩展此goroutine的功能以实现`TakeUntil(f)`，其中`f`是一个返回布尔值的函数。当`f`的返回值为`true`时，goroutine需要继续消费和转发其输入通道上的消息。使用泛型确保我们可以重用`TakeUntil(f)`函数并将其插入到许多其他管道中。以下是函数签名：
- en: '[PRE29]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Write a goroutine that prints to the console the contents of any message it
    receives on a channel and then forwards the message to the output channel. Again,
    use generics so that the function can be reused in many situations:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个goroutine，它将打印接收到的任何消息的内容到控制台，然后将消息转发到输出通道。再次使用泛型，以便函数可以在许多情况下重用：
- en: '[PRE30]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Write a goroutine that drains the contents of its input channel without doing
    anything with them. The goroutine simply reads a message and throws it away:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个goroutine，它从其输入通道中读取内容但不对其进行任何操作。这个goroutine只是读取一个消息然后丢弃它：
- en: '[PRE31]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Connect the components developed in exercises 1 to 4 together in a `main()`
    function using the following pseudocode:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下伪代码，在`main()`函数中将练习1到4中开发的组件连接起来：
- en: '[PRE32]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Communicating sequential processes (CSP) is a formal language concurrency model
    that uses message passing through synchronized channels.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信顺序进程（CSP）是一种使用同步通道通过消息传递的并发模型。
- en: Executions in CSP have their own isolated state and do not share memory with
    other executions.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CSP中，每个执行都有自己的独立状态，并且不与其他执行共享内存。
- en: Go borrows core ideas from CSP, with the addition that it treats channels as
    first-class objects, which means we can pass channels around in function calls
    and even on other channels.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go借鉴了CSP的核心思想，并增加了将通道视为一等对象的处理，这意味着我们可以在函数调用和其他通道中传递通道。
- en: A quit channel pattern can be used to notify goroutines to stop their execution.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用退出通道模式来通知goroutines停止它们的执行。
- en: Having a common pattern where a goroutine accepts input channels and returns
    outputs allows us to easily connect various stages of a pipeline.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个共同的模式，即goroutine接受输入通道并返回输出，这使得我们能够轻松地将管道的各个阶段连接起来。
- en: A fan-in pattern merges multiple input channels into one. This merged channel
    is closed only after all input channels are closed.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇入模式将多个输入通道合并为一个。只有当所有输入通道都关闭后，合并的通道才会关闭。
- en: A fan-out pattern is where multiple goroutines read from the same channel. In
    this case, messages on the channel are load-balanced among the goroutines.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇出模式是指多个goroutines从同一个通道读取。在这种情况下，通道上的消息在goroutines之间进行负载均衡。
- en: The fan-out pattern makes sense only when the order of the messages is not important.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇出模式只有在消息的顺序不重要时才有意义。
- en: With the broadcast pattern, the contents of an input channel are replicated
    to multiple channels.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用广播模式，输入通道的内容会被复制到多个通道中。
- en: In Go, having channels behave as first-class objects means that we can modify
    the structure of our message-passing concurrent program dynamically while the
    program is executing.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中，让通道作为一等对象意味着我们可以在程序执行时动态地修改我们的消息传递并发程序的结构。
