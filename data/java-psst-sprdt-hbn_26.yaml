- en: 20 Testing Java persistence applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20 测试 Java 持久化应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the testing pyramid and examining persistence testing in its context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍测试金字塔并检查其上下文中的持久化测试
- en: Creating a persistence application to test using Spring Boot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于测试的持久化应用程序
- en: Using the Spring TestContext Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring TestContext 框架
- en: Working with Spring profiles to test Java persistence applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring 配置文件测试 Java 持久化应用程序
- en: Using execution listeners to test Java persistence applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行监听器测试 Java 持久化应用程序
- en: All code needs to be tested. During development, we code, compile, and run.
    When we run, we may sometimes test how our code works. Testing persistence applications
    involves more than this. In those cases, our code interacts with the external
    database, and how our program works may be dependent on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都需要进行测试。在开发过程中，我们编写代码、编译和运行。当我们运行时，我们有时会测试代码的工作方式。测试持久化应用程序涉及的内容不止这些。在这些情况下，我们的代码与外部数据库交互，我们的程序的工作方式可能依赖于它。
- en: 20.1 Introducing the test pyramid
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.1 介绍测试金字塔
- en: In previous chapters, we focused on developing code that interacts with a database.
    We examined different alternatives for doing this, and different frameworks, and
    we interacted with various databases. Now we need to make sure that our programs
    are safe and bug-free. We need to be able to introduce changes without creating
    bugs, add new features without affecting the old features, and refactor code without
    breaking existing functionality. That is the purpose of this final chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们专注于开发与数据库交互的代码。我们探讨了不同的替代方案，不同的框架，并与各种数据库进行了交互。现在我们需要确保我们的程序是安全和没有错误的。我们需要能够在不创建错误的情况下引入更改，在不影响旧功能的情况下添加新功能，以及在不破坏现有功能的情况下重构代码。这就是本章的目的。
- en: 'Applications can be tested manually, but nowadays most tests are executed automatically
    and they address different levels. The different levels of software tests for
    monolithic applications can be regarded as a pyramid, as shown in figure 20.1\.
    We can define the following levels of software testing (from lowest to highest):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以手动测试，但如今大多数测试都是自动执行的，并且针对不同的级别。单体应用程序的软件测试的不同级别可以被视为一个金字塔，如图 20.1 所示。我们可以定义以下软件测试级别（从低到高）：
- en: '*Unit testing*—Unit testing is at the foundation of the pyramid. It focuses
    on methods or classes (individual units) by testing each one in isolation to determine
    whether it works according to expectations.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*—单元测试是金字塔的基础。它通过在隔离状态下测试每个单元，以确定它是否按预期工作，来关注方法或类（单个单元）。'
- en: '*Integration testing*—Individual, verified software components are combined
    in larger aggregates and tested together.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试*—将单独验证的软件组件组合成更大的聚合体并一起测试。'
- en: '*System testing*—Testing is performed on a complete system, to evaluate its
    compliance with the specification. System testing requires no knowledge of the
    design or code but focuses on the functionality of the entire system.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统测试*—在完整的系统上执行测试，以评估其是否符合规范。系统测试不需要了解设计或代码，但关注整个系统的功能。'
- en: '*Acceptance testing*—Acceptance testing uses scenarios and test cases to check
    whether the application satisfies the expectations of the end user.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验收测试*—验收测试使用场景和测试用例来检查应用程序是否满足最终用户的期望。'
- en: '![](../../OEBPS/Images/CH20_F01_Tudose2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F01_Tudose2.png)'
- en: Figure 20.1 The testing pyramid has a larger bottom level (unit tests), while
    the higher testing levels are smaller. They start with checking individual units
    and go up to verifying how software addresses the user’s needs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1 测试金字塔的底部级别（单元测试）较大，而较高的测试级别较小。它们从检查单个单元开始，一直上升到验证软件如何满足用户需求。
- en: Testing persistence applications belongs to the integration level. We combine
    our code with the database interaction, and we are dependent on how the database
    works. We would like to keep the behavior of our tests consistent between repeated
    test executions and to keep the content of the database the same as it was before
    running the tests. We’ll examine the best ways to achieve these goals in the following
    sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试持久化应用程序属于集成层。我们将代码与数据库交互结合起来，并且依赖于数据库的工作方式。我们希望保持测试行为在重复执行测试之间的一致性，并保持数据库内容与运行测试之前相同。在接下来的章节中，我们将探讨实现这些目标的最佳方法。
- en: 20.2 Creating the persistence application to test
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.2 创建用于测试的持久化应用程序
- en: 'We’ll create a Spring Boot persistence application so we can test its functionality.
    To do this, go to the Spring Initializr website ([https://start.spring.io/](https://start.spring.io/))
    and create a new Spring Boot project (figure 20.2), having the following characteristics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Spring Boot持久化应用程序，以便我们可以测试其功能。为此，请访问Spring Initializr网站([https://start.spring.io/](https://start.spring.io/))并创建一个新的Spring
    Boot项目（图20.2），具有以下特性：
- en: 'Group: com.manning.javapersistence'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：com.manning.javapersistence
- en: 'Artifact: testing'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件：测试
- en: 'Description: Persistence Testing'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：持久化测试
- en: 'We’ll also add the following dependencies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加以下依赖项：
- en: Spring Data JPA (this will add `spring-boot-starter-data-jpa` in the Maven pom.xml
    file).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA（这将在Maven pom.xml文件中添加`spring-boot-starter-data-jpa`）。
- en: MySQL Driver (this will add `mysql-connector-java` in the Maven pom.xml file).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL驱动程序（这将在Maven pom.xml文件中添加`mysql-connector-java`）。
- en: Lombok (this will add `org.projectlombok,lombok` in the Maven pom.xml file).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lombok（这将在Maven pom.xml文件中添加`org.projectlombok,lombok`）。
- en: Bean Validation with Hibernate validator (this will add `spring-boot-starter-validation`
    in the Maven pom.xml file).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hibernate validator进行Bean验证（这将在Maven pom.xml文件中添加`spring-boot-starter-validation`）。
- en: The `spring-boot-starter-test` dependency will be automatically added.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-test`依赖项将被自动添加。'
- en: '![](../../OEBPS/Images/CH20_F02_Tudose2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F02_Tudose2.png)'
- en: Figure 20.2 Creating a new Spring Boot project that will use a MySQL database
    through Spring Data JPA
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2 创建一个将使用MySQL数据库的Spring Boot项目
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch20.sql script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，您首先需要运行Ch20.sql脚本。
- en: The pom.xml file in the following listing includes the dependencies that we
    added when we created the Spring Boot project. We’ll create a Spring persistence
    application that accesses a MySQL database, for which we’ll need the driver and
    we’ll also need to validate some fields.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的pom.xml文件包括我们在创建Spring Boot项目时添加的依赖项。我们将创建一个访问MySQL数据库的Spring持久化应用程序，我们需要驱动程序，我们还需要验证一些字段。
- en: Listing 20.1 The pom.xml Maven file
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.1 pom.xml Maven文件
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ⓐ `spring-boot-starter-data-jpa` is the starter dependency used by Spring Boot
    to connect to a relational database through Spring Data JPA.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `spring-boot-starter-data-jpa`是Spring Boot用于通过Spring Data JPA连接到关系型数据库的启动依赖项。
- en: Ⓑ `spring-boot-starter-validation` is the starter dependency for using Java
    Bean Validation with Hibernate Validator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `spring-boot-starter-validation`是用于使用Hibernate Validator进行Java Bean验证的启动依赖项。
- en: Ⓒ `mysql-connector-java` is the JDBC driver for MySQL. It’s a runtime dependency,
    so it’s needed in the classpath only at runtime.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `mysql-connector-java`是MySQL的JDBC驱动程序。它是一个运行时依赖项，因此仅在运行时需要在类路径中。
- en: Ⓓ `Lombok` will allow us to reduce the boilerplate code, relying on automatically
    generated constructors, getters, and setters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `Lombok`将允许我们减少样板代码，依靠自动生成的构造函数、获取器和设置器。
- en: Ⓔ `spring-boot-starter-test` is the starter for testing Spring Boot applications
    with libraries including JUnit 5.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `spring-boot-starter-test`是用于测试Spring Boot应用程序的启动依赖项，包括JUnit 5库。
- en: The next step is to fill in the Spring Boot application.properties file. This
    file can include various properties to be used by the application. Spring Boot
    will automatically find and load application.properties from the classpath; the
    src/main/resources folder is added by Maven to the classpath. For this chapter’s
    demonstration, the application.properties configuration file will look like listing
    20.2.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是填写Spring Boot应用程序的application.properties文件。此文件可以包含应用程序将使用的各种属性。Spring Boot将自动从类路径中查找并加载application.properties；Maven将src/main/resources文件夹添加到类路径中。对于本章的演示，application.properties配置文件将类似于列表20.2。
- en: Listing 20.2 The application.properties file
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.2 application.properties文件
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The URL of the database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 数据库的URL。
- en: Ⓑ The credentials to access the database. Replace them with the credentials
    on your machine, and use a password in real life.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 访问数据库的凭据。用您机器上的凭据替换它们，并在实际生活中使用密码。
- en: Ⓒ The dialect of the database, MySQL.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 数据库的方言，MySQL。
- en: Ⓓ Show the SQL queries while they are executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 在执行时显示SQL查询。
- en: Ⓔ Recreate the tables for each execution of the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 在应用程序的每次执行中重新创建表。
- en: Note There are several ways to provide parameters in a Spring Boot application,
    and the .properties file is just one of them. Among the alternatives, the parameters
    may come from the source code or as command-line arguments. Refer to the Spring
    Boot documentation for details.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Spring Boot应用程序中提供参数的方法有很多种，.properties文件只是其中之一。在替代方案中，参数可能来自源代码或作为命令行参数。有关详细信息，请参阅Spring
    Boot文档。
- en: The application that we’ll test will include two entities, `User` and `Log`.
    The `User` entity is shown in the following listing. It will have a generated
    `id` and a `name` field with length validation. The no-arguments constructor,
    getters, and setters will be generated by Lombok.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的应用程序将包括两个实体，`User`和`Log`。以下列表示例显示了`User`实体。它将有一个生成的`id`和一个带有长度验证的`name`字段。无参数构造函数、获取器和设置器将由Lombok生成。
- en: Listing 20.3 The `User` class
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.3 `User`类
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Log` entity is shown in the following listing. It will have a generated
    `id` and an `info` field with length validation. The no-arguments constructor,
    getters, and setters will be generated by Lombok.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表示例显示了`Log`实体。它将有一个生成的`id`和一个带有长度验证的`info`字段。无参数构造函数、获取器和设置器将由Lombok生成。
- en: Listing 20.4 The `Log` class
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.4 `Log`类
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To manage the two entities, we’ll create two repository interfaces to extend
    `JpaRepository`: `UserRepository` and `LogRepository`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这两个实体，我们将创建两个扩展`JpaRepository`的仓库接口：`UserRepository`和`LogRepository`：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 20.3 Using the Spring TestContext Framework
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.3 使用Spring TestContext框架
- en: The Spring TestContext Framework is designed to provide integration testing
    support, so it is ideal for testing the persistence layer. It is agnostic of the
    testing framework we use with it, and we’ll work with JUnit 5\. We’ll examine
    its essential classes and annotations, which belong to the `org.springframework.test.context`
    package.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Spring TestContext框架旨在提供集成测试支持，因此它非常适合测试持久层。它与我们一起使用的测试框架无关，我们将使用JUnit 5。我们将检查属于`org.springframework.test.context`包的其基本类和注解。
- en: The entry point into the Spring TestContext Framework is the `TestContextManager`
    class. Its goal is to manage a single `TestContext` and to send events to the
    registered listeners. We’ll examine listeners in detail in section 20.8.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Spring TestContext框架的入口点是`TestContextManager`类。它的目标是管理一个单一的`TestContext`并向注册的监听器发送事件。我们将在第20.8节中详细检查监听器。
- en: We’ll write a first test that will save a `User` entity to the database and
    retrieve it again, using an injected `UserRepository`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个测试，将`User`实体保存到数据库中，并使用注入的`UserRepository`再次检索它。
- en: Listing 20.5 The `SaveRetrieveUserTest` class
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.5 `SaveRetrieveUserTest`类
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we repeatedly run this test several times, it will always succeed, so we
    might try to modify it and annotate the `saveRetrieve` test method with the `@RepeatedTest(2)`
    JUnit 5 annotation. This will run it twice in one execution of the class. The
    modified test will look like the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反复运行这个测试几次，它总是会成功，所以我们可能会尝试修改它，并使用JUnit 5的`@RepeatedTest(2)`注解来注释`saveRetrieve`测试方法。这将在一个类执行中运行两次。修改后的测试将如下所示。
- en: Listing 20.6 The `SaveRetrieveUserTest` class using `@RepeatedTest`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.6 使用`@RepeatedTest`的`SaveRetrieveUserTest`类
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s run the modified test now. Surprising or not, it will succeed for the
    first execution and will fail for the second, getting two `User`s from the database
    instead of one (see figure 20.3).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行修改后的测试。出人意料还是不出人意料，它第一次执行会成功，第二次执行会失败，从数据库中获取两个`User`而不是一个（见图20.3）。
- en: '![](../../OEBPS/Images/CH20_F03_Tudose2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F03_Tudose2.png)'
- en: Figure 20.3 The `@RepeatedTest` will succeed the first time and will fail the
    second time, as the database was left dirty after the execution of the first test.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.3 `@RepeatedTest`第一次执行会成功，第二次执行会失败，因为第一次测试执行后数据库被留下脏数据。
- en: This happens because the row that was inserted by the execution of the first
    test was not removed, and the second test found it in the table, adding one more.
    We can follow the SQL commands that are executed when the class is run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况发生是因为第一次测试执行插入的行没有被删除，第二次测试在表中找到了它，并添加了一个。我们可以跟踪在类运行时执行的SQL命令。
- en: 'Before running the two tests, the SQL commands that are executed deal with
    the (re)creation of tables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行两个测试之前，执行的SQL命令处理表（重新）创建：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before running each test, the following SQL commands are executed, inserting
    a new row into the table:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个测试之前，以下SQL命令被执行，向表中插入一个新行：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The execution of the second test will find an existing row in the table, will
    add a new one, and so will fail because it expects to find a single row. We’ll
    have to look for alternatives to leave the content of the database at the end
    of each test the same as it was before running it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试的执行将在表中找到一个现有行，将添加一个新的行，因此会失败，因为它期望找到单个行。我们将不得不寻找替代方案，以确保在每个测试结束时数据库的内容与运行之前相同。
- en: 20.4 The @DirtiesContext annotation
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.4 @DirtiesContext 注解
- en: One alternative, provided by the Spring TestContext Framework, is to use the
    `@DirtiesContext` annotation. `@DirtiesContext` acknowledges that the test method
    or the test class changes the Spring context, and the Spring TestContext Framework
    will recreate it from scratch and provide it to the next test. The annotation
    can be applied to a method or a class. Its effects can be applied before or after
    the execution of each test method, or before or after the execution of the test
    class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring TestContext 框架提供的一个替代方案是使用 `@DirtiesContext` 注解。`@DirtiesContext` 注解承认测试方法或测试类会改变
    Spring 上下文，Spring TestContext 框架将从头开始重新创建它，并将其提供给下一个测试。该注解可以应用于方法或类。其效果可以在每个测试方法执行之前或之后应用，或者可以在测试类执行之前或之后应用。
- en: We’ll modify the test class as shown in the following listing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改测试类，如下所示。
- en: Listing 20.7 The `SaveRetrieveUserTest` class using `@DirtiesContext`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.7 使用 `@DirtiesContext` 的 `SaveRetrieveUserTest` 类
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ Recreate the Spring context after the execution of each test method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在每个测试方法执行后重新创建 Spring 上下文。
- en: If we run the modified test now, it will succeed for the first and second executions
    (see figure 20.4). This means that after running the first test, the execution
    of the second test will no longer encounter a dirtied database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行修改后的测试，它将在第一次和第二次执行中成功（见图 20.4）。这意味着在运行第一次测试之后，第二次测试的执行将不再遇到脏数据库。
- en: '![](../../OEBPS/Images/CH20_F04_Tudose2.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F04_Tudose2.png)'
- en: Figure 20.4 The `@DirtiesContext` annotated test will succeed both the first
    and second time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.4 `@DirtiesContext` 注解的测试将在第一次和第二次都成功。
- en: 'Before running each test, the SQL commands that are executed deal with both
    the (re)creation of tables and inserting a row in the table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个测试之前，执行的 SQL 命令处理表（重新）创建和在表中插入一行：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These commands are executed twice, once before each test. More than this, the
    Spring Boot banner (also displayed at the bottom of figure 20.4) will be shown
    twice as well—once each time the application is started.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令执行了两次，一次在每个测试之前。不仅如此，Spring Boot 标签（也在图 20.4 的底部显示）也将显示两次——每次应用程序启动时各一次。
- en: The functionality of the `@DirtiesContext` annotation at the method level is
    demonstrated in figure 20.5.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DirtiesContext` 注解在方法级别上的功能在图 20.5 中得到演示。'
- en: '![](../../OEBPS/Images/CH20_F05_Tudose2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F05_Tudose2.png)'
- en: Figure 20.5 The `@DirtiesContext` annotation at the method level will create
    the context and cache before the execution of each test method and will remove
    them after the execution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.5 在每个测试方法执行之前，`@DirtiesContext` 注解在方法级别上会创建上下文和缓存，并在执行后移除它们。
- en: This solution works, but it comes with a performance cost related to the recreation
    of tables and reinitialization of the application for each test execution. Let’s
    explore more alternatives.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案是可行的，但它带来了与每个测试执行中表重新创建和应用程序重新初始化相关的性能成本。让我们探索更多替代方案。
- en: 20.5 @Transactional execution
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.5 @Transactional 执行
- en: We examined transactions in detail in chapter 11\. Transactions control atomic
    groups of operations that either fully succeed or fully fail. Managing transactions
    with Spring and Spring Data and the `@Transactional` annotation were detailed
    in section 11.4\. The idea that we’ll apply now is to run each test transactionally
    and to roll back the transaction at the end of the execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 11 章中详细探讨了事务。事务控制原子操作组，要么完全成功，要么完全失败。使用 Spring 和 Spring Data 以及 `@Transactional`
    注解管理事务在第 11.4 节中进行了详细说明。我们现在要应用的想法是运行每个测试都是事务性的，并在执行结束时回滚事务。
- en: By default, when executing a test, our transactions will automatically be rolled
    back due to the `TransactionalTestExecutionListener`. We’ll deal in detail with
    listeners in section 20.8; for now, just note that they can provide some additional
    action at the execution of a test. The default behavior can be modified with the
    help of the `@Commit` and `@Rollback` annotations. So if we want a test to commit
    at the end of the execution, we can annotate it either with `@Commit` or with
    `@Rollback(false)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，由于`TransactionalTestExecutionListener`的存在，执行测试时我们的事务将自动回滚。我们将在第20.8节中详细讨论监听器；现在，只需注意它们可以在测试执行时提供一些额外的操作。默认行为可以通过`@Commit`和`@Rollback`注解进行修改。因此，如果我们想让测试在执行结束时提交，我们可以用`@Commit`或`@Rollback(false)`来注解它。
- en: To keep track of when a transaction is active during the execution of a test,
    we’ll use the `TransactionSynchronizationManager` class. This class manages resources
    and transaction synchronizations for a thread. Its `isActualTransactionActive()`
    method will check whether a `Transaction` object is currently active.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试执行过程中跟踪事务的活跃状态，我们将使用`TransactionSynchronizationManager`类。这个类负责管理线程的资源以及事务同步。它的`isActualTransactionActive()`方法将检查当前是否存在活跃的`Transaction`对象。
- en: In the following listing, we’ll create a test class, annotate it with `@Transactional`,
    and follow the status of the transaction inside the methods of the class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们将创建一个测试类，用`@Transactional`注解它，并跟踪类的方法中的事务状态。
- en: Listing 20.8 The `TransactionalTest` class
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.8 `TransactionalTest`类
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The log of the execution will tell us that the transaction is not active in
    the `@BeforeAll` and `@AfterAll` methods, but it is active in the `@BeforeEach`
    and `@AfterEach` methods and inside the test method itself. As previously stated,
    the transaction will be rolled back by default at the end of the test, so `@RepeatedTest`
    will succeed for all executions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行日志将告诉我们，在`@BeforeAll`和`@AfterAll`方法中事务不活跃，但在`@BeforeEach`和`@AfterEach`方法以及测试方法本身内部是活跃的。如前所述，默认情况下，事务将在测试结束时回滚，因此`@RepeatedTest`对所有执行都将成功：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is still a pitfall of this approach that we will demonstrate. We introduced
    a separate `UserService` class with a transactional method, as shown in the following
    listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仍然存在一个陷阱，我们将演示它。我们引入了一个单独的`UserService`类，其中包含一个事务方法，如下所示。
- en: Listing 20.9 The `UserService` class
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.9 `UserService`类
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll call this method from inside the `@RepeatedTest` from the `TransactionalTest`
    class, to persist a user in a transactional way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`TransactionalTest`类内部的`@RepeatedTest`中调用此方法，以以事务方式持久化用户。
- en: Listing 20.10 Calling the `saveTransactionally` method
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.10 调用`saveTransactionally`方法
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `saveTransactionally` method from `UserService` has the annotation `@Transactional`
    with no other argument. The default propagation is `REQUIRED` (see section 11.4).
    As there is already a transaction running for the test, the `saveTransactionally`
    method will execute within the same transaction, and everything will be rolled
    back at the end of the test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService`中的`saveTransactionally`方法具有没有其他参数的`@Transactional`注解。默认传播行为是`REQUIRED`（见第11.4节）。由于测试已经有一个正在运行的事务，`saveTransactionally`方法将在同一个事务中执行，并且所有内容将在测试结束时回滚。'
- en: We can change the `saveTransactionally` method annotation to be `@Transactional(propagation`
    `=` `Propagation.REQUIRES_NEW)`. This will suspend the transaction executed in
    the test, start a new transaction, and commit it, as figure 20.6 shows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`saveTransactionally`方法的注解更改为`@Transactional(propagation = Propagation.REQUIRES_NEW)`。这将挂起测试中执行的事务，启动一个新的事务，并提交它，如图20.6所示。
- en: '![](../../OEBPS/Images/CH20_F06_Tudose2.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH20_F06_Tudose2.png)'
- en: Figure 20.6 The transaction from the `saveTransactionally` method will be committed,
    and the transaction from the test method will be rolled back.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.6 `saveTransactionally`方法的事务将被提交，而测试方法的事务将被回滚。
- en: The transaction from `saveTransactionally` was committed. As a consequence,
    running the test for a second time will encounter an existing record in the database,
    and the test will fail (see figure 20.7).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveTransactionally`的事务已被提交。因此，再次运行测试时将遇到数据库中的现有记录，测试将失败（见图20.7）。'
- en: '![](../../OEBPS/Images/CH20_F07_Tudose2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH20_F07_Tudose2.png)'
- en: Figure 20.7 Running two tests in a row while the `saveTransactionally` method
    commits its transaction separately will make the second test fail.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.7 在`saveTransactionally`方法单独提交其事务的情况下连续运行两个测试将导致第二个测试失败。
- en: The conclusion is that even if you run your tests transactionally, beware of
    the pitfall of launching methods in separate transactions. It can lead to strange
    bugs. Also, debugging might be difficult with this approach.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，即使你以事务方式运行测试，也要注意启动单独事务中方法的陷阱。这可能导致奇怪的错误。此外，使用这种方法进行调试可能很困难。
- en: To make a performance comparison between using `@DirtiesContext` and using `@Transactional`,
    we executed a series of 10 tests, progressively increasing the number of records
    from 100 to 2,000\. The results on MySQL are provided in figure 20.8.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较使用 `@DirtiesContext` 和使用 `@Transactional` 的性能，我们执行了一系列 10 个测试，记录数从 100 逐步增加到
    2,000。MySQL 上的结果如图 20.8 所示。
- en: '![](../../OEBPS/Images/CH20_F08_Tudose2.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH20_F08_Tudose2.png)'
- en: Figure 20.8 The execution times (in ms) on MySQL using `@DirtiesContext` and
    `@Transactional` and varying the number of records from 100 to 2,000
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.8 使用 `@DirtiesContext` 和 `@Transactional` 在 MySQL 上执行时间（毫秒）以及记录数从 100 到
    2,000 的变化
- en: The results on H2 are provided in figure 20.9\. We executed the same series
    of 10 tests using this in-memory database, progressively increasing the number
    of records from 100 to 2,000.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: H2 上的结果如图 20.9 所示。我们使用这个内存数据库执行了相同的 10 个测试系列，记录数从 100 逐步增加到 2,000。
- en: '![](../../OEBPS/Images/CH20_F09_Tudose2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH20_F09_Tudose2.png)'
- en: Figure 20.9 The execution times (in ms) on H2 using `@DirtiesContext` and `@Transactional`
    and varying the number of records from 100 to 2,000
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.9 使用 `@DirtiesContext` 和 `@Transactional` 在 H2 上执行时间（毫秒）以及记录数从 100 到 2,000
    的变化
- en: Analyzing the results for both MySQL and H2, we can see that the difference
    between the execution with `@DirtiesContext` and with `@Transactional` is approximately
    constant. It does not depend on the number of records, but on the number of times
    the context is reinitialized. The conclusion is that you should use `@DirtiesContext`
    sparingly. Pushing tests with this annotation to the CI/CD (continuous integration/continuous
    development) environment will seriously increase the time of their execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 MySQL 和 H2 的结果，我们可以看到使用 `@DirtiesContext` 和 `@Transactional` 的执行时间差异大致是恒定的。它不依赖于记录数，而是依赖于上下文重新初始化的次数。结论是，你应该谨慎使用
    `@DirtiesContext`。将带有此注解的测试推送到 CI/CD（持续集成/持续开发）环境将严重增加它们的执行时间。
- en: 20.6 The @BeforeTransaction and @AfterTransaction annotations
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.6 @BeforeTransaction 和 @AfterTransaction 注解
- en: We’ll now examine the `@BeforeTransaction` and `@AfterTransaction` annotations.
    As their names suggest, they indicate methods to be executed before and after
    the execution of a transaction. For our analysis, we’ll check that, indeed, there
    is no transaction active inside such a method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查 `@BeforeTransaction` 和 `@AfterTransaction` 注解。正如它们的名称所暗示的，它们指示在事务执行前后要执行的方法。为了我们的分析，我们将检查确实在这些方法内部没有活跃的事务。
- en: Using the `Assumptions.assumeFalse` JUnit 5 method, we’ll indicate that a precondition
    for running the tests is that there is no transaction active at that moment; otherwise
    the tests will not run. So if an assumption is not met, the test will be aborted.
    If an assertion is not met, the test will fail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Assumptions.assumeFalse` JUnit 5 方法，我们将指示运行测试的一个先决条件是当时没有活跃的事务；否则测试将不会运行。所以如果假设未满足，测试将被终止。如果断言未满足，测试将失败。
- en: Listing 20.11 Using `@BeforeTransaction` and `@AfterTransaction`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.11 使用 `@BeforeTransaction` 和 `@AfterTransaction`
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is still one pitfall to avoid here: the possibility of persisting data
    in the `@BeforeTransaction` or `@AfterTransaction` methods. Because these are
    executed outside transactions, data will not be rolled back and will affect the
    content of the database. Even more, if we persist data that we do not check in
    the tests (for example, `Log` entities, while our tests verify `User` entities),
    our tests will always execute correctly but will leave committed data behind them,
    as happens in the following listing.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要避免的陷阱：在 `@BeforeTransaction` 或 `@AfterTransaction` 方法中持久化数据的可能性。因为这些是在事务外部执行的，数据将不会被回滚，并会影响数据库的内容。更严重的是，如果我们持久化了测试中没有检查的数据（例如，`Log`
    实体，而我们的测试验证的是 `User` 实体），我们的测试将始终执行正确，但会在它们后面留下已提交的数据，如下面的列表所示。
- en: Listing 20.12 Persisting entities in `@BeforeTransaction`/`@AfterTransaction`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.12 在 `@BeforeTransaction`/`@AfterTransaction` 中持久化实体
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 20.7 Working with Spring profiles
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.7 使用 Spring 配置文件
- en: By default, Spring Boot creates a main/resources/application.properties file
    to keep the configuration of the application. But there are frequent situations
    where we’ll need to differentiate between properties depending on a user’s profile.
    Spring Boot will allow us to separate the properties in this case, in files named,
    by default, main/resources/application-profilename.properties, and it will allow
    us to switch between profiles.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot创建一个main/resources/application.properties文件来保存应用程序的配置。但经常会有需要根据用户的配置文件区分属性的情况。Spring
    Boot将允许我们在这种情况下将属性分开，默认情况下在名为main/resources/application-profilename.properties的文件中，并允许我们在配置文件之间切换。
- en: A real-life use case would be when you have a profile for programmers, using
    an embedded database during development, and another profile for production, using
    a real database. Programmers would like to be able to quickly execute their tests,
    while in production the tests will run in the real environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实生活中的用例是当你有一个针对程序员的配置文件，在开发期间使用嵌入式数据库，以及另一个针对生产的配置文件，使用真实数据库。程序员希望能够快速执行他们的测试，而在生产环境中，测试将在真实环境中运行。
- en: The configuration for development is shown in the following listing. It addresses
    an H2 database and will display SQL queries during execution, because the programmer
    is interested in following them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 开发配置的详细信息如下所示。它针对H2数据库，并在执行期间显示SQL查询，因为程序员对跟踪它们感兴趣。
- en: Listing 20.13 The application-dev.properties file
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.13 application-dev.properties文件
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The configuration for production is shown in the following listing. It addresses
    a MySQL database and will not display the SQL queries during execution, as this
    would consume resources in production.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生产配置的详细信息如下所示。它针对MySQL数据库，并在执行期间不会显示SQL查询，因为这将在生产中消耗资源。
- en: Listing 20.14 The application-prod.properties file
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.14 application-prod.properties文件
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To run the tests on the H2 database during development, we’ll have to choose
    the `dev` profile. This can be done, for example, from within the application.properties
    file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要在开发期间在H2数据库上运行测试，我们必须选择`dev`配置文件。例如，这可以通过在application.properties文件中完成。
- en: Listing 20.15 The application.properties file with the dev profile
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.15 包含dev配置文件的application.properties文件
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To demonstrate how to easy it is to switch between profiles, we’ll run one test
    that will save and retrieve an entity from the database.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示在配置文件之间切换有多简单，我们将运行一个测试，该测试将保存并从数据库中检索一个实体。
- en: Listing 20.16 The `SpringProfilesTest` class
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.16 `SpringProfilesTest`类
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To successfully run this test, we’ll need to have the H2 driver dependency in
    the pom.xml file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行此测试，我们需要在pom.xml文件中包含H2驱动依赖项。
- en: Listing 20.17 The pom.xml file with the H2 driver dependency
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.17 包含H2驱动依赖项的pom.xml文件
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result of running the test on the `dev` profile is shown in figure 20.10:
    the `dev` profile uses the in-memory H2 database.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dev`配置文件上运行测试的结果显示在图20.10中：`dev`配置文件使用内存中的H2数据库。
- en: '![](../../OEBPS/Images/CH20_F10_Tudose2.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH20_F10_Tudose2.png)'
- en: Figure 20.10 The result of running the test on the `dev` profile, using an H2
    database and displaying the execution of the SQL queries
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.10 在`dev`配置文件上运行测试的结果，使用H2数据库并显示SQL查询的执行
- en: To run the tests on the MySQL database in production, we’ll have to choose the
    `prod` profile. This can be done, for example, from within the application.properties
    file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要在生产环境中在MySQL数据库上运行测试，我们必须选择`prod`配置文件。例如，这可以通过在application.properties文件中完成。
- en: Listing 20.18 The application.properties file with the prod profile
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.18 包含prod配置文件的application.properties文件
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As an alternative to modifying the active profile, we can use the `@ActiveProfiles`
    annotation at the level of the test, as shown in listing 20.19\. This annotation
    will override the profile that is set in application.properties, but it will require
    us to modify and recompile the code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为修改活动配置的替代方案，我们可以在测试级别使用`@ActiveProfiles`注解，如图20.19所示。此注解将覆盖在application.properties中设置的配置文件，但将需要我们修改和重新编译代码。
- en: Listing 20.19 The `SpringProfilesTest` class
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.19 `SpringProfilesTest`类
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To successfully run this test, we’ll need to have the MySQL driver dependency
    in the pom.xml file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行此测试，我们需要在pom.xml文件中包含MySQL驱动依赖项。
- en: Listing 20.20 The pom.xml file with the MySQL driver dependency
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.20 包含MySQL驱动依赖项的pom.xml文件
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The result of running the test on the `prod` profile is shown in figure 20.11\.
    Unlike the `dev` profile, this profile uses the MySQL database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `prod` 配置文件上运行测试的结果如图 20.11 所示。与 `dev` 配置文件不同，此配置文件使用 MySQL 数据库。
- en: '![](../../OEBPS/Images/CH20_F11_Tudose2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F11_Tudose2.png)'
- en: Figure 20.11 The result of running the test on the `prod` profile, using a MySQL
    database and not displaying the execution of the SQL queries
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.11 在 `prod` 配置文件上运行测试的结果，使用 MySQL 数据库且不显示 SQL 查询的执行
- en: 20.8 Working with test execution listeners
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.8 使用测试执行监听器
- en: 'One way to control the lifecycle of a test’s execution is to work with the
    JUnit 5 annotations: `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach`.
    This may be inconvenient in some situations. For example, if we need the same
    `@BeforeEach` and `@AfterEach` behavior for several tests, we would need to create
    a base class containing these methods and to create multiple subclasses that will
    inherit and execute them when running the tests. This has the inconvenience of
    hanging our tests in a hierarchy of classes. Alternatively, we can consider working
    with test execution listeners, with the `TestExecutionListener` interface, and
    with the `@TestExecutionListeners` annotation, thus separating the behavior that
    controls the lifecycle of the test.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 控制测试执行生命周期的 一种方式是使用 JUnit 5 注解：`@BeforeAll`、`@AfterAll`、`@BeforeEach` 和 `@AfterEach`。在某些情况下，这可能会不方便。例如，如果我们需要为多个测试使用相同的
    `@BeforeEach` 和 `@AfterEach` 行为，我们需要创建一个包含这些方法的基类，并创建多个子类，以便在运行测试时继承并执行它们。这会导致我们的测试挂在一个类层次结构中。或者，我们可以考虑使用测试执行监听器，使用
    `TestExecutionListener` 接口和 `@TestExecutionListeners` 注解，从而将控制测试生命周期的行为分离出来。
- en: By default, Spring provides some already implemented `TestExecutionListener`s
    for each test. The ones of most interest to us here are `DependencyInjectionTestExecutionListener`,
    which supports dependency injection for the test instance, and `TransactionalTestExecutionListener`,
    which supports the transactional execution of a test with rollback. We mentioned
    in section 20.3.2 that, by default, when executing a test, the transaction will
    automatically be rolled back due to the `TransactionalTestExecutionListener`—this
    is essential when testing persistence and striving to leave a clean database after
    executing the tests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring 为每个测试提供了一些已实现的 `TestExecutionListener`。对我们来说最有兴趣的是 `DependencyInjectionTestExecutionListener`，它支持测试实例的依赖注入，以及
    `TransactionalTestExecutionListener`，它支持测试的事务性执行和回滚。我们在 20.3.2 节中提到，默认情况下，由于 `TransactionalTestExecutionListener`，执行测试时事务将自动回滚——这对于测试持久性和在执行测试后留下干净数据库至关重要。
- en: The `TestExecutionListener` interface defines a series of empty default methods
    that are more fine-grained than the JUnit 5 lifecycle methods, and that are executed
    in the order shown in table 20.1.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestExecutionListener` 接口定义了一系列空默认方法，这些方法比 JUnit 5 生命周期方法更细粒度，并且按照表 20.1 所示的顺序执行。'
- en: Table 20.1 The default methods from the `TestExecutionListener` interface
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表 20.1 `TestExecutionListener` 接口中的默认方法
- en: '| Method | Description |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `beforeTestClass` | Executed before the `@BeforeAll` method of JUnit 5 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `beforeTestClass` | 在 JUnit 5 的 `@BeforeAll` 方法之前执行 |'
- en: '| `prepareTestInstance` | Prepares the test instance of the supplied test context
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `prepareTestInstance` | 准备提供的测试上下文的测试实例 |'
- en: '| `beforeTestMethod` | Executed before the `@BeforeEach` method of JUnit 5
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `beforeTestMethod` | 在 JUnit 5 的 `@BeforeEach` 方法之前执行 |'
- en: '| `beforeTestExecution` | Executed before the test method |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `beforeTestExecution` | 在测试方法之前执行 |'
- en: '| `afterTestExecution` | Executed after the test method |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `afterTestExecution` | 在测试方法之后执行 |'
- en: '| `afterTestMethod` | Executed after the `@AfterEach` method of JUnit 5 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `afterTestMethod` | 在 JUnit 5 的 `@AfterEach` 方法之后执行 |'
- en: '| `afterTestClass` | Executed after the `@AfterAll` method of JUnit 5 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `afterTestClass` | 在 JUnit 5 的 `@AfterAll` 方法之后执行 |'
- en: We’ll write our own listener that implements the `TestExecutionListener` interface,
    override all its methods, and print a message from each, so we can follow the
    execution of the test that we’ll annotate using this listener.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写自己的监听器，实现 `TestExecutionListener` 接口，覆盖所有方法，并从每个方法中打印一条消息，这样我们就可以跟踪使用此监听器注解的测试的执行。
- en: As in section 20.3.2, we’ll follow when a transaction is active during the execution
    of a test by using the `TransactionSynchronizationManager` class and its method
    `isActualTransactionActive()`, which will check if a `Transaction` object is currently
    active. Our listener is shown in the following listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如20.3.2节中所述，我们将通过使用`TransactionSynchronizationManager`类及其`isActualTransactionActive()`方法来跟踪测试执行期间活跃的事务，该方法将检查是否存在当前活跃的`Transaction`对象。我们的监听器如下所示。
- en: Listing 20.21 The `DatabaseOperationsListener` class
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.21 `DatabaseOperationsListener`类
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ll create our own test, annotate it to use the new `DatabaseOperationsListener`,
    and print messages from the lifecycle methods and the test itself, to follow its
    execution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的测试，将其注解为使用新的`DatabaseOperationsListener`，并打印生命周期方法和测试本身的消息，以跟踪其执行。
- en: Listing 20.22 The `ListenersTest` class
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.22 `ListenersTest`类
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we run this test now, it will fail with `NullPointerException`, as in figure
    20.12.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这个测试，它将因为`NullPointerException`而失败，如图20.12所示。
- en: '![](../../OEBPS/Images/CH20_F12_Tudose2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH20_F12_Tudose2.png)'
- en: Figure 20.12 The test initially annotated with our custom listener fails with
    `NullPointerException`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.12 初始注解了我们的自定义监听器的测试因`NullPointerException`而失败。
- en: If we examine what is happening, we’ll notice that the `userRepository` reference
    to the object that interacts with the database is `null`. As the messages from
    the console demonstrate, there is only one listener registered in the `TestContextManager`,
    our `DatabaseOperationsListener`. The previously needed `DependencyInjectionTestExecutionListener`,
    which supports dependency injection for the test instance, and consequently for
    the `userRepository`, is no longer registered. This is because, once we introduce
    our own listeners, the default listeners are no longer automatically registered.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查正在发生的事情，我们会注意到与数据库交互的对象的`userRepository`引用是`null`。正如控制台消息所展示的，在`TestContextManager`中只注册了一个监听器，即我们的`DatabaseOperationsListener`。之前需要的支持测试实例依赖注入的`DependencyInjectionTestExecutionListener`，以及因此对`userRepository`的依赖注入支持，现在不再注册。这是因为，一旦我们引入了自己的监听器，默认监听器就不再自动注册。
- en: To fix this, we’ll use the `MERGE_WITH_DEFAULTS` option as merge mode, as follows.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用`MERGE_WITH_DEFAULTS`选项作为合并模式，如下所示。
- en: Listing 20.23 Merging the default listeners with our custom listener
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.23 将默认监听器与我们的自定义监听器合并
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run the test again now, we’ll be able to follow the sequence of the methods’
    execution, both from the listener and from the lifecycle methods of JUnit 5\.
    We’ll also notice that the number of registered listeners is now 15, meaning 14
    default listeners and our custom listener:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行测试，我们将能够跟踪方法执行的顺序，无论是从监听器还是从JUnit 5的生命周期方法。我们还会注意到注册的监听器数量现在是15，这意味着有14个默认监听器和我们的自定义监听器：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Table 20.2 summarizes the most important annotations from the Spring TestContext
    Framework, to be used in testing persistence applications. You will be able to
    use these annotations from the Spring TestContext Framework for your persistence
    applications. This framework provides strong support for integration testing,
    to which persistence application testing belongs. On this base, you can continue
    to build system tests and acceptance tests, as we demonstrated at the beginning
    of this chapter when we introduced the testing pyramid. For more information about
    testing Java applications in general and about acceptance tests in particular,
    you can refer to my book *JUnit in Action*, third edition (Tudose, 2020).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表20.2总结了Spring TestContext框架中最重要的注解，这些注解用于测试持久化应用程序。您将能够使用Spring TestContext框架中的这些注解来测试您的持久化应用程序。该框架为集成测试提供了强大的支持，而持久化应用程序测试属于集成测试范畴。在此基础上，您可以继续构建系统测试和验收测试，正如我们在本章开头介绍测试金字塔时演示的那样。有关测试Java应用程序的一般信息和关于验收测试的特定信息，您可以参考我的书籍《JUnit
    in Action》，第三版（Tudose，2020）。
- en: Table 20.2 The most important Spring TestContext Framework annotations to be
    used in testing persistence applications
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表20.2 用于测试持久化应用程序的最重要的Spring TestContext框架注解
- en: '| Annotation | Description |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 描述 |'
- en: '| `@DirtiesContext` | The underlying Spring context was changed during the
    execution of a test and should be reinitialized. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `@DirtiesContext` | 测试执行期间底层Spring上下文发生了变化，应该重新初始化。|'
- en: '| `@BeforeTransaction` | The void method should be executed before any method
    having the Spring `@Transactional` annotation. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `@BeforeTransaction` | 应在具有Spring `@Transactional`注解的任何方法之前执行此空方法。|'
- en: '| `@AfterTransaction` | The void method should be executed after any method
    having the Spring `@Transactional` annotation. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterTransaction` | 应在具有 Spring `@Transactional` 注解的任何方法之后执行 void 方法。|'
- en: '| `@Rollback` | The transaction for a transactional test will be rolled back
    after the test completes. This is the default behavior and may be changed using
    `@Rollback(false)`or `@Commit`. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `@Rollback` | 对于事务性测试，测试完成后将回滚事务。这是默认行为，可以通过 `@Rollback(false)` 或 `@Commit`
    进行更改。|'
- en: '| `@Commit` | The transaction for a transactional test will be committed after
    the test completes. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `@Commit` | 对于事务性测试，测试完成后将提交事务。|'
- en: '| `@ActiveProfiles` | Specifies which configuration profiles will be active
    in the Spring context. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `@ActiveProfiles` | 指定在 Spring 上下文中哪些配置配置文件将处于活动状态。|'
- en: '| `@TestExecutionListeners` | Configures the test execution listeners to be
    registered with the `TestContextManager`. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `@TestExecutionListeners` | 配置要注册到 `TestContextManager` 的测试执行监听器。|'
- en: With predictable and safe tests that fail only when there are problems in your
    code and not due to external factors (such as inappropriate content in a dirtied
    database), your life as a programmer will be much better!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可预测和安全的测试，只有在代码中存在问题时才会失败，而不是由于外部因素（例如脏数据库中的不适当内容），您作为程序员的职业生涯将会更加美好！
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The testing pyramid consists of the unit, integration, system, and acceptance
    levels. Persistence testing can be classified at the integration level.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔由单元、集成、系统和验收级别组成。持久化测试可以在集成级别进行分类。
- en: You can create and configure a persistence application using Spring Boot and
    manage entities and repositories inside it.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Spring Boot 创建和配置持久化应用程序，并在其中管理实体和仓库。
- en: You can use the Spring TestContext Framework to create persistence tests and
    manage them using either `@DirtiesContext` or `@Transactional`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Spring 测试上下文框架创建持久化测试，并使用 `@DirtiesContext` 或 `@Transactional` 来管理它们。
- en: You can use Spring profiles to test Java persistence applications that access
    various databases and have different configurations.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Spring 配置文件来测试访问各种数据库并具有不同配置的 Java 持久化应用程序。
- en: You can create a custom test execution listener to follow the lifecycle of a
    test and work with it and with the default listeners.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建自定义测试执行监听器以跟踪测试的生命周期，并与它以及默认监听器一起工作。
