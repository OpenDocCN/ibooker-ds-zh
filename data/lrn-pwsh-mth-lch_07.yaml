- en: 7 Adding commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 添加命令
- en: One of PowerShell’s primary strengths is its extensibility. As Microsoft continues
    to invest in PowerShell, it develops more and more commands for products such
    as Azure compute (Virtual Machines), Azure SQL, Azure Virtual Network, Azure DNS,
    and so on. You typically manage these through the Azure portal. We will discuss
    how to install the Azure PowerShell modules later in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell的主要优势之一是其可扩展性。随着Microsoft继续投资PowerShell，它为Azure计算（虚拟机）、Azure SQL、Azure虚拟网络、Azure
    DNS等产品开发了越来越多的命令。您通常通过Azure门户来管理这些命令。我们将在本章后面讨论如何安装Azure PowerShell模块。
- en: 7.1 How one shell can do everything
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 一个shell如何做到一切
- en: How can one shell do everything? Let’s think about your smartphone. How do you
    add functionality to your phone without upgrading the operating system? You install
    an app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个shell如何做到一切？让我们思考一下你的智能手机。你是如何在不升级操作系统的情况下给你的手机添加功能？你安装了一个应用程序。
- en: When you install an app, it can add widgets or even add commands you can say
    to the voice assistant. Adding commands to the voice assistant is probably the
    most like the extension model of PowerShell. PowerShell provides ways of adding
    commands that you can use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装一个应用程序时，它可以添加小部件，甚至添加你可以对语音助手说的命令。向语音助手添加命令可能与PowerShell的扩展模型最相似。PowerShell提供了添加命令的方式，你可以使用。
- en: So, let’s say you installed an app called Ride Share. The app might add a voice
    command that lets you say, “Book me a ride to work with Ride Share.” The phone
    finds your work address and sends the command to the app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你安装了一个名为Ride Share的应用程序。该应用程序可能添加了一个语音命令，让你可以说，“用Ride Share为我预订去工作的车。”手机找到你的工作地址并将命令发送到应用程序。
- en: PowerShell works in a similar way. PowerShell calls its extensions *modules*.
    There are no widgets, but commands can be added. We will cover how to install
    modules later in the next section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell以类似的方式工作。PowerShell将其扩展称为*模块*。没有小部件，但可以添加命令。我们将在下一节中介绍如何安装模块。
- en: '7.2 Extensions: Finding and installing modules'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 扩展：查找和安装模块
- en: 'Before PowerShell 6.0, there were two kinds of extensions: modules and snap-ins.
    PowerShell v6 and newer support one type of extension called a *module*. Modules
    are designed to be more self-contained and easier to distribute.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell 6.0之前，有两种类型的扩展：模块和插件。PowerShell v6及更高版本支持一种称为*模块*的扩展类型。模块旨在更加独立且易于分发。
- en: Microsoft introduced a module called PowerShellGet, which makes it easier to
    search for, download, install, and update modules from online repositories. PowerShellGet
    is a lot like the package managers Linux admins love so much—rpm, yum, apt-get,
    and so on. Microsoft even runs an online *gallery*, or repository, called PowerShell
    Gallery ([http://powershellgallery.com](http://powershellgallery.com)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft引入了一个名为PowerShellGet的模块，它使得从在线仓库中搜索、下载、安装和更新模块变得更加容易。PowerShellGet与Linux管理员非常喜欢的包管理器类似——rpm、yum、apt-get等。Microsoft甚至运行一个在线*画廊*或仓库，称为PowerShell
    Gallery ([http://powershellgallery.com](http://powershellgallery.com))。
- en: WARning *Microsoft runs* doesn’t mean *Microsoft produces, verifies, and endorses*.
    The PowerShell Gallery contains community-contributed code, and you should use
    due caution before running someone else’s code in your environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WARning *Microsoft runs*并不意味着*Microsoft生产、验证和认可*。PowerShell Gallery包含社区贡献的代码，在您的环境中运行他人的代码之前，您应谨慎行事。
- en: You can search for modules like most search engines at [https://powershellgallery
    .com/](https://www.powershellgallery.com/). The module for Azure is called *Az*.
    Figure 7.1 shows an example of searching for that module.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://powershellgallery.com/](https://www.powershellgallery.com/)上搜索模块，就像大多数搜索引擎一样。Azure的模块称为*Az*。图7.1展示了搜索该模块的示例。
- en: '![](Images/CH07_F01_Plunk.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F01_Plunk.png)'
- en: Figure 7.1 Showing the search for Az in the PowerShell Gallery
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 展示了在PowerShell Gallery中搜索Az的过程
- en: If you click the Az module name, it will take you to more detail about the module.
    Under Package Details > PSEditions, you can check if the author has tested the
    module with PowerShell Core (figure 7.2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击Az模块名称，它将带你到有关该模块的更多详细信息。在“包详细信息”>“PSEditions”下，你可以检查作者是否已使用PowerShell
    Core测试了该模块（图7.2）。
- en: '![](Images/CH07_F02_Plunk.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F02_Plunk.png)'
- en: Figure 7.2 Showing that the module is Core compatible
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 展示模块与Core兼容
- en: Then look under Installation Options (figure 7.3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后查看安装选项（图7.3）。
- en: '![](Images/CH07_F03_Plunk.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F03_Plunk.png)'
- en: Figure 7.3 Showing installation command available via the PowerShell Gallery
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 展示通过PowerShell Gallery可用的安装命令
- en: 'Notice it says that at least PowerShell 5.1 is required to run the module,
    and it gives instructions on how to install the module. If we run the command
    `Install-Module -Name Az`, we can see what happens:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它指出至少需要 PowerShell 5.1 才能运行该模块，并提供了安装模块的说明。如果我们运行命令 `Install-Module -Name
    Az`，我们可以看到发生了什么：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It prompts you asking if you trust installing from the gallery, and if you
    say yes, then it installs the module. You can run the `Get-Module` command to
    verify it installed the module, but the `-ListAvailable` parameter is required
    because the module is not loaded:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它会提示你询问你是否信任从库中安装，如果你说“是”，那么它就会安装模块。你可以运行 `Get-Module` 命令来验证是否已安装模块，但需要 `-ListAvailable`
    参数，因为模块尚未加载：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The path and version will vary for you, but the output should be similar.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 路径和版本可能因你而异，但输出应该是类似的。
- en: More about getting modules from the internet
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于从互联网获取模块的信息
- en: 'The PowerShellGet module allows installing modules from [http://PowerShellGallery.com](http://PowerShellGallery.com).
    Using PowerShellGet is easy and can even be fun:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShellGet 模块允许从 [http://PowerShellGallery.com](http://PowerShellGallery.com)
    安装模块。使用 PowerShellGet 很简单，甚至可能很有趣：
- en: Run `Register-PSRepository` to add the URL of a repository. [http://PowerShellGallery.com](http://PowerShellGallery.com)
    is usually set up by default, but it’s even possible to set up your own “gallery”
    internally for private use, and you’d use `Register-PSRepository` to point to
    it.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `Register-PSRepository` 命令来添加存储库的 URL。[http://PowerShellGallery.com](http://PowerShellGallery.com)
    通常默认设置，但也可以在内部设置自己的“库”用于私人用途，并且你会使用 `Register-PSRepository` 来指向它。
- en: Use `Find-Module` to find modules in repositories. You can use wildcards (`*`)
    in names, specify tags, and have many other choices for narrowing the search results.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Find-Module` 命令在存储库中查找模块。你可以在名称中使用通配符 (`*`)，指定标签，并有许多其他选项来缩小搜索结果。
- en: Use `Install-Module` to download and install a module after you’ve found it.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Install-Module` 命令在找到模块后下载并安装它。
- en: Use `Update-Module` to make sure your local copy of a module is the latest version,
    and if it isn’t, download and install the latest.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Update-Module` 命令确保你的模块本地副本是最新的版本，如果不是，则下载并安装最新版本。
- en: PowerShellGet includes several other commands ([http://PowerShellGallery.com](http://PowerShellGallery.com)
    links to the documentation), but these are the ones you’ll start out using. For
    example, try installing the Azure PowerShell module, or Jeff Hicks’s PSScriptTools
    module from the PowerShell Gallery.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShellGet 包含其他几个命令（[http://PowerShellGallery.com](http://PowerShellGallery.com)
    链接到文档），但你将开始使用的是这些命令。例如，尝试从 PowerShell Gallery 安装 Azure PowerShell 模块或 Jeff Hicks
    的 PSScriptTools 模块。
- en: '7.3 Extensions: Finding and adding modules'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 扩展：查找和添加模块
- en: 'PowerShell automatically looks in a certain set of paths to find modules. The
    `PSModulePath` environment variable defines the paths where PowerShell expects
    modules to live:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 会自动在一系列路径中查找模块。`PSModulePath` 环境变量定义了 PowerShell 预期模块存在的路径：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Try it Now The preceding command was run on a macOS device. Run the command
    `(Get-Content` `Env:/PSModulePath)` `-split` `':'` and see what the results are
    for you. Note that they will be different, depending on what OS you are using.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。前面的命令是在 macOS 设备上运行的。运行命令 `(Get-Content `Env:/PSModulePath)` `-split`
    `':'` 并查看你的结果。请注意，这取决于你使用的操作系统，它们会有所不同。
- en: 'As you can see in this example, there are three default locations: one in the
    folder where PowerShell is installed, where system modules live; one in the local/share/
    folder, where you can put modules shared by all users; and one in the .local folder,
    where you can add any personal modules. If you’re running even later versions
    of PowerShell, you might see additional locations that Microsoft is now using.
    You can also add a module from any other location, provided you know its full
    path. On your Windows machine, you will see a similar layout where modules are
    installed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，有三个默认位置：一个在 PowerShell 安装文件夹中，系统模块就存储在这里；一个在 local/share/ 文件夹中，你可以放置所有用户共享的模块；还有一个在
    .local 文件夹中，你可以添加任何个人模块。如果你运行的是 PowerShell 的更晚版本，你可能会看到 Microsoft 现在使用的其他位置。你也可以从任何其他位置添加模块，只要你知道它的完整路径。在你的
    Windows 机器上，你会看到类似的布局，模块就是在这里安装的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The path is important in PowerShell. If you have modules located elsewhere,
    you should add their paths to the `PSModulePath` environment variable. You can
    do this in your profile with the following command (we’ll cover how to set up
    a profile later in this chapter):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，路径非常重要。如果您有位于其他位置的模块，您应该将它们的路径添加到 `PSModulePath` 环境变量中。您可以在您的配置文件中使用以下命令完成此操作（我们将在本章后面介绍如何设置配置文件）：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: NOTE There are a few things that we have not mentioned yet in the preceding
    example. But that’s okay. We promise we will get to them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在上面的示例中，我们还没有提到一些事情。但没关系。我们承诺我们将会提到它们。
- en: Why is the `PSModulePath` so important? Because with it, PowerShell can automatically
    locate all of the modules on your computer. After it finds your modules, PowerShell
    *autodiscovers* them. It will look to you as if all of your modules are loaded
    all of the time. Ask for help on a module, and you’ll get it, without having to
    load it. Run any command you’ve found, and PowerShell will automatically load
    the module containing that command. PowerShell’s `Update-Help` command also uses
    `PSModulePath` to discover what modules you have, and then it seeks updated help
    files for each one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `PSModulePath` 如此重要？因为它允许 PowerShell 自动定位您计算机上的所有模块。在找到您的模块后，PowerShell
    会自动发现它们。对您来说，这就像您的所有模块一直都被加载一样。请求模块的帮助，您就会得到它，而无需加载它。运行您找到的任何命令，PowerShell 会自动加载包含该命令的模块。PowerShell
    的 `Update-Help` 命令也使用 `PSModulePath` 来发现您拥有的模块，然后为每个模块寻找更新的帮助文件。
- en: 'For example, run `Get-Module | Remove-Module` to remove any loaded modules.
    This will remove almost all commands from the current session, so if you try this,
    close and reopen PowerShell. Then run the following command (your results may
    differ slightly, depending on your OS and what modules you have installed):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行 `Get-Module | Remove-Module` 来移除任何已加载的模块。这将移除当前会话中的几乎所有命令，因此如果您尝试这样做，请关闭并重新打开
    PowerShell。然后运行以下命令（您的结果可能略有不同，具体取决于您的操作系统和您安装的模块）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, PowerShell discovers several commands (of the `Cmdlet` variety)
    that have the word `storage` in their name (I used `storaget` to simplify the
    results in the example). You can then ask for help on one of these, even though
    you haven’t loaded the module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，PowerShell 发现了几个命令（属于 `Cmdlet` 类型），它们的名称中包含单词 `storage`（我在示例中使用了 `storaget`
    以简化结果）。您可以对其中之一请求帮助，即使您还没有加载该模块：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you want to, you can even run the command, and PowerShell will make sure
    the module is loaded for you. This autodiscovery and autoloading functionality
    is useful, helping you to find and use commands that aren’t even present in the
    shell when you start.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，甚至可以运行命令，PowerShell 会确保为您加载模块。这种自动发现和自动加载功能非常有用，可以帮助您找到并使用在您启动 shell 时甚至不存在的命令。
- en: PowerShell’s module autodiscovery enables the shell to complete command names
    (using Tab in the console or IntelliSense in the Visual Studio Code), display
    help, and run commands, even for modules you haven’t explicitly loaded into memory.
    These features make it worth the effort to keep `PSModulePath` as lean as possible
    (i.e., don’t put a lot of different locations in it) and keep your modules up
    to date.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的模块自动发现功能使得 shell 能够完成命令名称（在控制台中使用 Tab 键或 Visual Studio Code 中的 IntelliSense），显示帮助，并运行命令，即使对于您没有明确加载到内存中的模块也是如此。这些功能使得保持
    `PSModulePath` 尽可能精简（即不要在其中放置很多不同的位置）并保持模块更新变得值得努力。
- en: What if a module isn’t located in one of the paths referenced by `PSModulePath`?
    You’d need to run `Import-Module` and specify the complete path to the module,
    such as `C:\Scripts/myModules/myModule`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块不在 `PSModulePath` 引用的路径之一中，您需要运行 `Import-Module` 并指定模块的完整路径，例如 `C:\Scripts\myModules\myModule`。
- en: 'Modules can also add PowerShell providers. Running `Get-PSProvider` will get
    you a list of providers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还可以添加 PowerShell 提供程序。运行 `Get-PSProvider` 将会列出提供程序列表：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Google Cloud commands
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Google Cloud 命令
- en: 'Installing and adding the Google Cloud commands is a little different because
    they break a rule—they require input the first time you try to use the module.
    You install their commands at first just like other modules: `Install-Module -Name
    GoogleCloud`. But if you try to find the commands, it will fail. So, you need
    to run `Import-Module GoogleCloud -Force`. The `-Force` is in case PowerShell
    thinks the module is loaded; it will try to reload it. Now the module will prompt
    you to finish the installation (assuming it is still designed the same as it was
    when we wrote this book). Now we’ll run the commands to deal with Google Cloud
    SQL instances.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和添加 Google Cloud 命令有些不同，因为它们打破了规则——它们在第一次尝试使用模块时需要输入。你首先像其他模块一样安装它们的命令：`Install-Module
    -Name GoogleCloud`。但如果你尝试查找命令，它将会失败。因此，你需要运行 `Import-Module GoogleCloud -Force`。`-Force`
    是以防 PowerShell 认为模块已加载；它将尝试重新加载它。现在模块将提示你完成安装（假设它与我们编写本书时的设计相同）。现在我们将运行处理 Google
    Cloud SQL 实例的命令。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 7.4 Command conflicts and removing extensions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 命令冲突和移除扩展
- en: Take a close look at the commands we added for both Google Cloud SQL instances
    and Azure Table storage. Notice anything special about the commands’ names?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看我们为 Google Cloud SQL 实例和 Azure 表存储添加的命令。你注意到命令名称有什么特别之处吗？
- en: Most PowerShell extensions—Amazon Web Services being a notable exception—add
    a short prefix to the noun portion of their command names. `Get-GcSqlInstance`,
    for example, or `Get-AzStorageTable`. These prefixes may seem awkward, but they’re
    designed to prevent command conflicts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 PowerShell 扩展（Amazon Web Services 是一个显著的例外）会在其命令名称的名词部分添加一个简短的前缀。例如，`Get-GcSqlInstance`
    或 `Get-AzStorageTable`。这些前缀可能看起来有些别扭，但它们的设计目的是为了防止命令冲突。
- en: 'For example, suppose you load two modules that each contain a `Get-User` cmdlet.
    With two commands having the same name and being loaded at the same time, which
    one will PowerShell execute when you run `Get-User`? The last one loaded, as it
    turns out. But the other command with the same name isn’t inaccessible. To specifically
    run either command, you have to use a somewhat awkward naming convention that
    requires both the module name and the command name. If one `Get-User` comes from
    a module called MyCoolPowerShellModule, you have to run this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你加载了两个包含 `Get-User` cmdlet 的模块。当两个具有相同名称的命令同时加载时，当你运行 `Get-User` 时，PowerShell
    将执行哪一个？结果将是最后加载的那个。但具有相同名称的其他命令并不是不可访问的。要专门运行任一命令，你必须使用一种有些别扭的命名约定，该约定需要模块名称和命令名称。如果
    `Get-User` 中的一个来自名为 MyCoolPowerShellModule 的模块，你必须运行这个：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s a lot of typing, and it’s why Microsoft suggests adding a product-specific
    prefix, such as `Az` or `Gc`, to the noun of each command. Adding prefixes helps
    prevent a conflict and helps make commands easier to identify and use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要输入很多，这就是为什么 Microsoft 建议为每个命令的名词添加一个产品特定的前缀，例如 `Az` 或 `Gc`。添加前缀有助于防止冲突，并有助于使命令更容易识别和使用。
- en: Note The Amazon Web Services module does not use a prefix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Amazon Web Services 模块不使用前缀。
- en: If you do wind up with a conflict, you can always remove one of the conflicting
    modules. Run `Remove-Module`, along with the module name, to unload a module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的遇到了冲突，你总是可以移除其中一个冲突的模块。运行 `Remove-Module`，连同模块名称一起，以卸载一个模块。
- en: Note Add your own prefix to any module when you import the module. `Import-Module
    ModuleName -Prefix MyPrefix` will change `Get-OriginalCmdLet` to `Get-MyPrefixOriginalCommand`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在导入模块时，为任何模块添加自己的前缀。`Import-Module ModuleName -Prefix MyPrefix` 将 `Get-OriginalCmdLet`
    改为 `Get-MyPrefixOriginalCommand`。
- en: 7.5 Playing with a new module
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 玩转新模块
- en: Let’s put your newfound knowledge to use. We want you to follow along with the
    commands we present in this section. More important, we want you to follow the
    process and the thinking that we’ll explain, because this is how we teach ourselves
    to use new commands without rushing out and buying a new book for every product
    and feature that we run across. In the lab for this chapter, we’ll have you repeat
    this same process on your own, to learn a more in-depth task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用你新获得的知识。我们希望你能跟随本节中我们展示的命令。更重要的是，我们希望你能跟随我们将要解释的过程和思考，因为这是我们学习如何使用新命令而不急于购买每款产品和每个功能的新书的方法。在本章的实验室中，我们将让你自己重复这个过程，以学习更深入的任务。
- en: 'Our goal is to compress a file on our computer into a zip archive. We have
    no idea whether PowerShell can even do this, so we start by asking the help system
    for a clue:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将我们电脑上的文件压缩成 zip 归档。我们不知道 PowerShell 是否能做这件事，所以我们首先向帮助系统寻求线索：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Aha! As you can see, we have an entire `Microsoft.PowerShell.Archive` (the
    full name was truncated) module on our computer. The previous list shows the `Compress-Archive`
    command, but we’re curious about what other commands are available. To find out,
    we manually load the module and list its commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！正如你所见，我们电脑上有一个完整的 `Microsoft.PowerShell.Archive`（全名被截断）模块。前面的列表显示了 `Compress-Archive`
    命令，但我们很好奇还有哪些其他命令可用。为了找出答案，我们手动加载模块并列出其命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note We could have asked for help on `Compress-Archive` or even run the command
    directly. PowerShell would have loaded the Microsoft.PowerShell .Archive module
    for us in the background. But because we’re exploring, this approach lets us view
    the module’s complete list of commands.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们本可以请求 `Compress-Archive` 的帮助，甚至直接运行该命令。PowerShell 会为我们后台加载 Microsoft.PowerShell
    .Archive 模块。但因为我们正在探索，这种方法让我们可以查看模块的完整命令列表。
- en: 'This list of commands looks more or less the same as the earlier list. Fine,
    let’s see what the `Compress-Archive` command looks like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令列表看起来与之前的列表大致相同。好吧，让我们看看 `Compress-Archive` 命令的样子：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Seems straightforward, and only `-Path` and `-DestinationPath` are mandatory
    parameters. Let’s try creating a file and compressing it with the command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，并且只有 `-Path` 和 `-DestinationPath` 是必选参数。让我们尝试创建一个文件并用该命令压缩它：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Okay, no news is usually good news. Still, it’d be nice to see that the command
    did something. Let’s try this instead:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，没有消息通常是个好消息。然而，看到命令确实做了些事情会更好。让我们试试这个：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-Verbose` switch is available for all cmdlets and functions, although not
    all of these commands do anything with it. In this case, we get a message indicating
    what’s happening, which tells us the command did run. The `-Force` switch for
    this command says to overwrite the zip file we created the first time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Verbose` 开关对所有 cmdlet 和函数都可用，尽管并非所有这些命令都会使用它。在这种情况下，我们得到一条消息，表明正在发生的事情，这告诉我们命令确实已运行。该命令的
    `-Force` 开关表示要覆盖我们第一次创建的 zip 文件。'
- en: 7.6 Common points of confusion
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 常见混淆点
- en: 'PowerShell newcomers frequently do one thing incorrectly when they start working
    with modules: they don’t read the help. Specifically, they don’t use the `-Example`
    or `-Full` switches when asking for help.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 新手在开始使用模块时经常犯一个错误：他们不阅读帮助。具体来说，他们在请求帮助时没有使用 `-Example` 或 `-Full`
    开关。
- en: Frankly, looking at built-in examples is the best way to learn how to use a
    command. Yes, it can be a bit daunting to scroll through a list of hundreds of
    commands (the Az.* modules, for example, add well over 2,000 new commands), but
    using `Help` and `Get-Command` with wildcards should make it easier to narrow
    the list to whatever noun you think you’re after. From there, *read the* *help*!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，查看内置示例是学习如何使用命令的最佳方式。是的，浏览数百个命令的列表（例如，Az.* 模块添加了超过 2,000 个新命令）可能会有些令人畏惧，但使用
    `Help` 和 `Get-Command` 与通配符应该可以使你更容易缩小到你想找的任何名词。从那里开始，*阅读* *帮助*！
- en: 7.7 Lab
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 实验室
- en: 'As always, we’re assuming that you have the latest version of PowerShell on
    a computer or virtual machine to test with:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们假设你已经在计算机或虚拟机上安装了最新的 PowerShell 版本以进行测试：
- en: Browse the PowerShell Gallery. Find a module or two that you think sounds interesting
    and install it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览 PowerShell 画廊。找到一些你认为听起来很有趣的模块并安装它们。
- en: Browse the available commands for the module you just downloaded.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览你刚刚下载的模块可用的命令。
- en: Use the commands from section 7.2 to find and install (if needed) the latest-version
    module by Microsoft for working with archives that contain the command `Compress-Archive`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 7.2 节中的命令查找和安装（如果需要）Microsoft 为处理包含 `Compress-Archive` 命令的存档而提供的最新版本模块。
- en: Import the module you just installed.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你刚刚安装的模块。
- en: Create a Tests folder for the next step with 10 files in it, and name it ~/TestFolder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为下一步创建一个包含 10 个文件的 Tests 文件夹，并将其命名为 ~/TestFolder。
- en: Use `Compress-Archive` to create a zip of the contents of ~/TestFolder, and
    name the archive `TestFolder.zip`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Compress-Archive` 创建 ~/TestFolder 内容的 zip 文件，并将其命名为 `TestFolder.zip`。
- en: Expand the archive to ~/TestFolder2.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存档展开到 ~/TestFolder2。
- en: Use `Compare-Object` and `Select-Object` `-ExpandProperty` `Name` to compare
    just the names of the files in the folders to verify you have the same files.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Compare-Object` 和 `Select-Object` `-ExpandProperty` `Name` 来比较文件夹中的文件名，以验证你是否拥有相同的文件。
- en: 7.7 Lab answers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 实验室答案
- en: 'Here’s one way to approach this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种处理方法：
- en: '`Install-Module moduleyoufound`'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Install-Module moduleyoufound`'
- en: If you are on a Windows machine, we suggest the `import-excel` module.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows 机器，我们建议使用 `import-excel` 模块。
- en: '`Get-Command –module moduleyoufound`'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command –module moduleyoufound`'
- en: '`Get-command -module az`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-command -module az`'
- en: '`Find-Module -Command Compress-Archive | Install-Module -Force`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Find-Module -Command Compress-Archive | Install-Module -Force`'
- en: '`Import-Module Microsoft.PowerShell.Archive`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Import-Module Microsoft.PowerShell.Archive`'
- en: '`1..10` will create a collection of the numbers between 1 and 10\. If you did
    this another way, don’t worry.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1..10` 将创建介于 1 和 10 之间的数字集合。如果你用另一种方式做，不要担心。'
- en: '`New-Item ~/TestFolder -ItemType Directory`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-Item ~/TestFolder -ItemType Directory`'
- en: '`1..10 | ForEach-Object {New-Item "~/TestFolder/$_.txt" -ItemType File -Value
    $_}`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1..10 | ForEach-Object {New-Item "~/TestFolder/$_.txt" -ItemType File -Value
    $_}`'
- en: '`Compress-Archive ~/TestFolder/* -DestinationPath ~/TestFolder.zip`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Compress-Archive ~/TestFolder/* -DestinationPath ~/TestFolder.zip`'
- en: '`Expand-Archive ~/TestFolder.zip -DestinationPath ~/TestFolder2`'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Expand-Archive ~/TestFolder.zip -DestinationPath ~/TestFolder2`'
- en: This is a possible way. Remember, `dir` is an alias for `Get-ChildItem`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一种可能的方式。记住，`dir` 是 `Get-ChildItem` 的别名。
- en: '`$reference = Get-ChildItem ~/TestFolder| Select-Object -ExpandProperty name`'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$reference = Get-ChildItem ~/TestFolder| Select-Object -ExpandProperty name`'
- en: '`$difference = Get-ChildItem ~/TestFolder3| Select-Object -ExpandProperty name`'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$difference = Get-ChildItem ~/TestFolder3| Select-Object -ExpandProperty name`'
- en: '`Compare-Object -ReferenceObject $reference -DifferenceObject $difference`'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Compare-Object -ReferenceObject $reference -DifferenceObject $difference`'
