- en: 2 Baby steps with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 React 的初步步骤
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating a new React project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 React 项目
- en: Nesting elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素嵌套
- en: Creating a component class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件类
- en: Working with properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性工作
- en: This chapter will teach you how to create a new React project and how to create
    custom components to render HTML. Both of these concepts will serve as the basis
    for all future chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何创建一个新的 React 项目以及如何创建自定义组件来渲染 HTML。这两个概念都将作为所有未来章节的基础。
- en: First, we’ll examine how to create a new React project. While doing so, we’ll
    teach you both how to start your own React projects and how to utilize the React
    template system to quickly instantiate the examples and projects that we’ll work
    on in this book. It’s quite magical how in a single line you can get the code
    downloaded and ready to go with everything set up for you!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查如何创建一个新的 React 项目。在这个过程中，我们将教你如何启动自己的 React 项目，以及如何利用 React 模板系统快速实例化本书中我们将要工作的示例和项目。单行代码就能下载代码并准备好一切，这真是太神奇了！
- en: As we start our first React project, we’ll introduce several fundamental React
    concepts that you’ll use frequently, including elements, components, and properties.
    In a nutshell, elements are instances of components that can be passed properties.
    What are their use cases, and why do you use them? Hang tight for this information
    until section 2.3 because, right now, we’re going to discuss how to create a new
    React web application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始我们的第一个 React 项目时，我们将介绍几个你将经常使用的 React 基本概念，包括元素、组件和属性。简而言之，元素是组件的实例，可以传递属性。它们的使用案例是什么，为什么你会使用它们？请耐心等待，直到第
    2.3 节，因为现在我们将讨论如何创建一个新的 React 网络应用程序。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch02](https://rq2e.com/ch02).
    In section 2.2, however, you’ll learn that you don’t have to download anything
    manually. You can instantiate all the examples from this and subsequent chapters
    directly from the command line using a single command.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在 [https://rq2e.com/ch02](https://rq2e.com/ch02) 获取。然而，在第 2.2 节中，你将了解到你不必手动下载任何内容。你可以直接从命令行使用单个命令实例化本章节和后续章节的所有示例。
- en: 2.1 Creating a new React app
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 创建新的 React 应用程序
- en: In this section, we’ll introduce you to a magical command-line program that
    will make all your React setups go smoothly. In just three short commands and
    a couple of minutes, you’ll download a fully functioning dummy React web app,
    compile it, run it through a web server, and see it in your browser (see the overview
    in figure 2.1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你介绍一个神奇的命令行程序，它将使你的所有 React 设置顺利进行。只需三个简短的命令和几分钟，你就可以下载一个完全功能的虚拟 React
    网络应用程序，编译它，通过网络服务器运行它，并在你的浏览器中看到它（见图 2.1 的概述）。
- en: '![02-01](../Images/02-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](../Images/02-01.png)'
- en: Figure 2.1 Three commands that will take you from nothing to a working React
    application. From there, you can update the source files, and the system will
    automatically recompile and update your application in the browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 将你从无到有带到工作状态的三条命令。从那里，你可以更新源文件，系统将自动重新编译并在浏览器中更新你的应用程序。
- en: 'If you have a modern version of Node (and npm) installed as advised in the
    introduction, you should be able to write the following command in your terminal:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经按照引言中建议安装了现代版本的 Node（以及 npm），你应该能在你的终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note npx isn’t a typo. npx is a package runner tool that comes with npm. It
    allows us to run commands using packages only present inside this project folder
    and/or run commands that will be downloaded dynamically when needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：npx 不是一个打字错误。npx 是一个与 npm 一起提供的包运行器工具。它允许我们仅使用此项目文件夹内存在的包来运行命令，或者运行在需要时动态下载的命令。
- en: Run this command, and a new React application is set up for you! The first time
    you run this command, npm will ask for confirmation to download the create-react-app
    utility (just press Enter to confirm that). This refers to steps 1.a and 1.b in
    figure 2.1\. Every time you use the command after that, no questions will be asked.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令，一个新的 React 应用程序就会为你设置好！第一次运行此命令时，npm 将要求确认下载 create-react-app 工具（只需按 Enter
    键确认即可）。这指的是图 2.1 中的步骤 1.a 和 1.b。从那时起，每次使用该命令后都不会再提问。
- en: Note We’ll refer to the create-react-app tool as *CRA* in the following sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在接下来的章节中，我们将把 create-react-app 工具简称为 *CRA*。
- en: The command will create a new folder with the passed name, which is name-of-app
    in the preceding case. Inside this folder, the utility will initialize a new Git
    project, download the required resources for the application, and then download
    and locally install all the dependencies required by the project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个新文件夹，其名称由传递的名称指定，在先前的例子中是 name-of-app。在此文件夹内，实用程序将初始化一个新的 Git 项目，下载应用程序所需的资源，然后下载并本地安装项目所需的所有依赖项。
- en: 'The command will run for a short while, probably around 1-3 minutes depending
    on the project complexity and network conditions. Once the command is complete,
    you’ll see something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行一段时间，可能大约 1-3 分钟，具体取决于项目的复杂性和网络条件。一旦命令完成，您将看到类似以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ name-of-app and <folder> will be replaced by the actual name and folder location
    of your project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ name-of-app 和 <folder> 将被替换为您的项目的实际名称和文件夹位置。
- en: ❷ This is the first of four commands that you can run in your application (we’ll
    discuss what it does next).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是您可以在应用程序中运行的四个命令中的第一个（我们将在下一节讨论它的功能）。
- en: ❸ These three other commands will be discussed in the next subsection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 下一个子节将讨论这三个其他命令。
- en: ❹ This command changes the folder to the newly created project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此命令将文件夹更改为新创建的项目。
- en: ❺ Why, thank you—and may your hacking be forever white hat!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为什么，谢谢——愿您的黑客行为永远都是白帽！
- en: Uh, exciting. Note that if your output mentions a command called yarn rather
    than npm, don’t worry. See the sidebar for an explanation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，令人兴奋。请注意，如果您的输出提到的是 yarn 而不是 npm 命令，请不要担心。请参阅侧边栏以获取解释。
- en: npm alternatives
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: npm alternatives
- en: There are several popular package managers for JavaScript projects that work
    on the same package repository and structure, but with slightly different commands.
    The most used manager is npm by far, but alternatives include Yarn and pnpm. The
    popular choice, npm, comes preinstalled with Node and is the default manager that
    many people use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在相同包仓库和结构上工作的 JavaScript 项目，有几个流行的包管理器，但它们的命令略有不同。最常用的管理器是 npm，但还有 Yarn 和
    pnpm 等替代品。最受欢迎的选择 npm 随 Node 预装，并且是许多人使用的默认管理器。
- en: However, you can opt to install a different manager, which will have a slightly
    simpler command structure. For the purposes of this book, there’s no difference
    between using npm or an alternative, other than some slightly different syntax
    when typing commands. If you have Yarn or pnpm, you probably also have npm installed,
    so that will most likely always work for you.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以选择安装不同的管理器，这将具有稍微简单的命令结构。在本书的范围内，使用 npm 或替代品之间没有区别，除了在输入命令时有一些略微不同的语法。如果您有
    Yarn 或 pnpm，您可能也已经安装了 npm，因此这很可能总是适用于您。
- en: 'If you want to use one of these package managers, please check the documentation
    on how to run commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用这些包管理器之一，请检查有关如何运行命令的文档：
- en: 'Yarn: [https://classic.yarnpkg.com/lang/en/docs/cli/run/](https://classic.yarnpkg.com/lang/en/docs/cli/run/)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Yarn: [https://classic.yarnpkg.com/lang/en/docs/cli/run/](https://classic.yarnpkg.com/lang/en/docs/cli/run/)'
- en: 'pnpm: [https://pnpm.io/cli/run](https://pnpm.io/cli/run)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pnpm: [https://pnpm.io/cli/run](https://pnpm.io/cli/run)'
- en: 'Now, let’s follow the suggestion in the preceding code snippet and run those
    two commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们遵循前面代码片段中的建议并运行这两个命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now the third part of the magic happens. A React development server starts
    up, compiling all the files and resources used (action 3.a in figure 2.1) and
    spins up a local development web server (action 3.b in figure 2.1). After a few
    seconds, the command line will say something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在魔法的第三部分发生了。一个 React 开发服务器启动，编译所有使用的文件和资源（如图 2.1 中的动作 3.a），并启动一个本地开发 Web 服务器（如图
    2.1 中的动作 3.b）。几秒钟后，命令行将显示类似以下内容：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Moreover, the application will already have been launched in your browser, as
    the command also launches a browser window at the proper URL (action 3.c in figure
    2.1). If not, simply open localhost:3000 in your browser to see the application.
    This browser window will display a React application (as shown in figure 2.2)
    that’s been created for you by a template. This is the default template used for
    new React applications that don’t specify a specific template to use. We’ll discuss
    templates a bit later in section 2.1.3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应用程序已经在您的浏览器中启动了，因为该命令还在正确的 URL 上启动了一个浏览器窗口（如图 2.1 中的动作 3.c）。如果没有，只需在浏览器中打开
    localhost:3000 即可查看应用程序。此浏览器窗口将显示一个由模板为您创建的 React 应用程序（如图 2.2 所示）。这是为不指定特定模板的新
    React 应用程序默认使用的模板。我们将在 2.1.3 节中稍后讨论模板。
- en: '![02-02](../Images/02-02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](../Images/02-02.png)'
- en: Figure 2.2 The default React application launched by a new React project. Your
    application will most likely be in *dark mode* with white text on a dark background
    color. The brightness in this screenshot has been inverted for better print results.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 新建React项目启动的默认React应用程序。你的应用程序很可能是*暗色模式*，背景颜色为深色，文字为白色。为了更好的打印效果，此截图中的亮度已被反转。
- en: Note that this last command, npm start, is a continuously running command that
    stays active in the terminal. It will watch your source files, recompile the whole
    application when any source file changes, and even reload the browser with the
    updated application (actions 4-4.d in figure 2.1)! Now that is pure magic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个最后的命令npm start是一个持续运行的命令，它保持在终端中活跃。它将监视你的源文件，当任何源文件更改时，将重新编译整个应用程序，甚至用更新的应用程序重新加载浏览器（图2.1中的动作4-4.d）！这真是纯粹的魔法。
- en: If and when you want to abort this command, simply press Ctrl-C in your terminal,
    and you’ll be back to your regular terminal prompt. However, your application
    no longer works because you also stopped the local development web server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要终止这个命令，只需在终端中按Ctrl-C，你将回到正常的终端提示符。然而，你的应用程序不再工作，因为你同时也停止了本地开发Web服务器。
- en: 'You might have noticed that the previous output from creating our application
    listed not only the start command that we just used but also three other commands:
    build, test, and eject. We’ll go over all four of these commands in more detail
    in the next subsection.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，创建我们的应用程序的先前输出不仅列出了我们刚刚使用的start命令，还列出了其他三个命令：build、test和eject。我们将在下一小节中更详细地介绍这四个命令。
- en: 2.1.1 React project commands
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 React项目命令
- en: 'Now that you have this React application source code available on your system,
    you probably want to interact with it in several ways. The two primary things
    you want are to see what you’re developing as you’re developing it and to deploy
    your application to a web server. You also might want to run all tests in your
    application to verify that everything is still working as designed. Finally, you
    might want to escape the confines of CRA to tinker with the engine underneath.
    CRA abstracts some things away that you don’t need to worry about at first, but
    when applications get more advanced, you might want to access the innards of your
    application configuration. For these four purposes, a new React application created
    with CRA comes with these four commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将这个React应用程序源代码放在了你的系统上，你可能想以几种方式与之交互。你想要做的两件主要事情是看到你正在开发的内容，以及将你的应用程序部署到Web服务器上。你也可能想运行应用程序中的所有测试来验证一切是否仍然按设计工作。最后，你可能想摆脱CRA的限制，对底层的引擎进行修改。CRA抽象了一些你一开始不需要担心的事情，但当应用程序变得更加高级时，你可能想访问应用程序配置的内部。出于这四个目的，使用CRA创建的新React应用程序自带这四个命令：
- en: start—Launch a local development web server and continuously compile the project
    as it changes, serving it to any local browser.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: start—启动本地开发Web服务器，并在项目更改时持续编译项目，将其提供给任何本地浏览器。
- en: build—Compile all resources into a production-ready package deployable to the
    right web host.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: build—将所有资源编译成一个可用于部署到正确Web主机的生产就绪包。
- en: test—Launch a test runner that will run all unit tests defined in your project.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: test—启动一个测试运行器，它将运行你在项目中定义的所有单元测试。
- en: eject—Reveal the inner workings of the project and make it fully configurable.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eject—揭示项目的内部工作原理，并使其完全可配置。
- en: Let’s go over these one by one and discuss how and when to use them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍它们，并讨论如何以及何时使用它们。
- en: start
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: start
- en: The start command is your primary command, the one you use every time you start
    a new project or pick up an old project to start work on it again. At the beginning
    of your coding session, you’ll run the start command in a terminal, and then you’ll
    be ready to code in your editor while automatically being served the updated content
    in your browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: start命令是你的主要命令，每次你开始一个新项目或重新开始一个旧项目时都会使用它。在编码会话的开始，你将在终端中运行start命令，然后你就可以在编辑器中编码，同时浏览器会自动提供更新的内容。
- en: The start command will build your project in the background continuously using
    the development version of React and its utility libraries. This is distinct from
    the production version of React used in the build command. The development version
    of React includes much better error messages and warnings as well as options for
    debugging the application as it’s running in the browser. However, the development
    version of React is, for those reasons, also much larger in terms of sheer file
    size, so you don’t want to publish your application using this version. It will
    make your application unnecessarily large and hinder users trying to access it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: start 命令将在后台持续构建你的项目，使用的是 React 的开发版本及其实用库。这与 build 命令中使用的 React 生产版本是不同的。React
    的开发版本包含了更好的错误信息和警告，以及调试在浏览器中运行的应用程序时的选项。然而，由于这些原因，React 的开发版本在文件大小上也要大得多，因此你不希望使用这个版本发布你的应用程序。这将使你的应用程序变得不必要地大，并阻碍用户尝试访问它。
- en: The start command will also reload the application in the browser as it’s running,
    but in a much smarter way than just reloading the whole browser window. React
    will try to reload only the relevant bits of logic that have changed and otherwise
    leave the application as is. For instance, if you’ve clicked a button to collapse
    a section that would otherwise be open by default when the application launches,
    React will be able to inject updated code while keeping the state in the browser,
    so this section remains collapsed while the logic is otherwise updated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: start 命令也会在应用程序运行时在浏览器中重新加载应用程序，但比仅仅重新加载整个浏览器窗口要智能得多。React 将尝试只重新加载已更改的相关逻辑部分，而其他部分保持不变。例如，如果你点击了一个按钮来折叠一个在应用程序启动时默认打开的章节，React
    将能够在保持浏览器中的状态的同时注入更新后的代码，因此这个章节在逻辑更新时仍然保持折叠状态。
- en: build
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: build
- en: This is the command to run when you’re ready to see your application deployed
    to a real web server and have users try it out. When you run the build command,
    you’ll be using the production version of React, which is much leaner and optimized
    for deployment. The result of the build will be put in the /build folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当你准备好看到你的应用程序部署到真实的服务器并让用户尝试时运行的命令。当你运行 build 命令时，你将使用 React 的生产版本，它更加精简且针对部署进行了优化。构建的结果将被放入
    /build 文件夹中。
- en: By default, nothing else really happens, but you can set up direct deployment
    to your cloud web hosting solution in the build command as well if you want to.
    Check your cloud web hosting provider’s documentation for help on how to do this.
    We won’t be using this command in this book, as we’ll be using another template
    for deploying applications in the project where deployment to the cloud will be
    an option.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，实际上并没有发生什么，但如果你想在 build 命令中设置直接部署到你的云托管解决方案，也是可以的。请查阅你的云托管提供商的文档，以获取如何进行此操作的说明。我们在这本书中不会使用这个命令，因为我们将在项目中使用另一个模板来部署应用程序，其中将提供部署到云的选项。
- en: test
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: test
- en: If you want to run all unit tests defined in your project, run this command.
    You can do that on the empty default template as well because the default template
    even comes with a default test file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要运行项目中定义的所有单元测试，请运行此命令。你可以在空默认模板上这样做，因为默认模板甚至包含一个默认的测试文件。
- en: eject
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: eject
- en: This command can be a bit dangerous because it’s irreversible. If you eject
    your application, you’ll have access to a lot more configurable options inside
    the React setup than you do otherwise, but you also lose the option of automatically
    updating to newer versions of all the tools involved. We won’t cover ejecting
    your application in this book, but we’ll discuss it again briefly in section 2.1.4
    when examining the pros and cons.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令可能有点危险，因为它不可逆。如果你卸载了你的应用程序，你将能够访问比其他情况下更多的 React 设置配置选项，但你也会失去自动更新所有相关工具到新版本的选择。我们在这本书中不会介绍如何卸载应用程序，但我们在第
    2.1.4 节中会简要讨论其优缺点。
- en: 2.1.2 File structure
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 文件结构
- en: 'When you create a project with CRA, it almost always follows the same file
    structure. Custom templates can do things differently, but they rarely do. The
    structure includes these important elements:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 CRA 创建项目时，几乎总是遵循相同的文件结构。自定义模板可能会做不同的事情，但很少这样做。结构包括以下重要元素：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With these two folders and four files, you’re good to go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个文件夹和四个文件，你就准备就绪了。
- en: The public folder is for files that will be served directly via the web server.
    This includes the index.html file that serves your entire application as well
    as binary files that you don’t want to bundle inside your application, such as
    content required by the index.html file directly (e.g., favicon, Cascading Style
    Sheets [CSS], fonts, or images for sharing) and large files (e.g., videos and
    images).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 公共文件夹用于将通过Web服务器直接提供的服务文件。这包括提供整个应用程序的index.html文件以及您不希望在应用程序中捆绑的二进制文件，例如index.html文件直接需要的文件（例如，favicon、层叠样式表[CSS]、字体或用于分享的图片）以及大文件（例如，视频和图片）。
- en: The source (src) folder is where all your bundled JavaScript will go as well
    as any other content that you want to bundle as a single package. This is mostly
    just JavaScript, but could potentially also include CSS, icons, small images,
    JSON files, and more. The bundling starts at the index.js file inside the source
    folder. It’s commonplace to have the main application reside in a file named App.js
    or app.js, depending on personal preference, but otherwise, you are free to be
    flexible here. Some templates structure the content inside the src folder in subfolders,
    which is necessary to structure larger projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件夹（src）是所有捆绑的JavaScript以及您想要捆绑为单个包的任何其他内容将放置的地方。这主要是JavaScript，但可能还包括CSS、图标、小图片、JSON文件等。捆绑从源文件夹中的index.js文件开始。将主应用程序放在名为App.js或app.js的文件中是很常见的，这取决于个人偏好，但除此之外，您可以在这里灵活处理。一些模板在src文件夹内部使用子文件夹来结构化内容，这对于结构化更大的项目是必要的。
- en: The main configuration file for your project is package.json, as required by
    npm and Yarn. This is the starting file for your project and defines the dependencies
    as well as the commands that you can run, as covered in section 2.1.1.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您项目的配置文件主要是package.json，这是npm和Yarn所要求的。这是您项目的起始文件，它定义了依赖项以及您可以运行的命令，如第2.1.1节所述。
- en: The root folder will often contain a ton of other configuration files required
    for various libraries included in the project. It isn’t uncommon to see custom
    templates with 20+ other configuration files at the root of the project. Now let’s
    move on to cover what custom templates are and how they help you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录通常会包含项目所需的各种库的大量其他配置文件。在项目根目录看到20多个其他配置文件的定制模板并不罕见。现在让我们继续讨论定制模板是什么以及它们如何帮助您。
- en: 2.1.3 Templates
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 模板
- en: While the default application that we saw in figure 2.2 is pretty nice, it’s
    not always helpful. The default application sets you up to create a simple web
    app in the same style as that web app is created, but that might not be what you’re
    looking for. If you want to create a web app using a specific technology stack
    or using React in a particular way, you probably want to use a different starting
    template to set you up correctly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在图2.2中看到的默认应用程序相当不错，但并不总是有帮助。默认应用程序使您能够以与该应用程序创建相同的方式创建一个简单的Web应用程序，但这可能不是您想要的。如果您想使用特定的技术栈创建Web应用程序或以特定方式使用React，您可能需要使用不同的起始模板来正确设置。
- en: 'When you use CRA, you can specify a template to use. The default template is
    the one you saw previously with the (spinning) React logo. If you want to specify
    another template, you can do so as an argument:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用CRA时，您可以指定要使用的模板。默认模板是您之前看到的带有（旋转）React标志的模板。如果您想指定另一个模板，您可以通过参数来这样做：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can only use the name of a template that already exists; if it doesn’t
    exist, the application will abort. Often, people don’t bother with choosing a
    template at all and just work with the default one. But if you know that you want
    a specific setup or want to start your codebase at a certain state, you can use
    a template that sets you up for exactly that. Some commonly used templates include
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能使用已存在的模板名称；如果该模板不存在，应用程序将终止。通常，人们甚至懒得选择模板，直接使用默认模板。但如果您知道您需要一个特定的设置或希望从某个特定状态开始您的代码库，您可以使用一个正好满足您需求的模板。一些常用的模板包括以下几种：
- en: Minimal templates with even fewer features than the default one, for example,
    —template minimal. This one comes without images, CSS, tests, web vitals, and
    other minor niceness used in the default template.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化模板，比默认模板具有更少的功能，例如，—template minimal。这个模板不包含图片、CSS、测试、Web核心指标以及其他在默认模板中使用的其他小功能。
- en: Variants of the default or the minimal template using TypeScript, for example,
    --template typescript or --template minimal-typescript. This is useful for starting
    a new project using TypeScript.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TypeScript 的默认或最小模板的变体，例如，--template typescript 或 --template minimal-typescript。这对于使用
    TypeScript 开始一个新项目非常有用。
- en: Complex boilerplate setups created by other developers where you have a stack
    of certain dependencies already baked into your new application, for example,
    --template redux-typescript, which comes prepackaged with Redux and TypeScript,
    or --template rb, which is a popular React boilerplate (hence the *rb*), that
    comes prepackaged with a ton of reputable libraries, including Redux with Redux-Saga,
    styled components, ESLint, husky, and many more.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他开发者创建的复杂样板设置，其中你已经有了一堆特定的依赖项已经嵌入到你的新应用程序中，例如，--template redux-typescript，它预包装了
    Redux 和 TypeScript，或者 --template rb，这是一个流行的 React 样板（因此称为 *rb*），它预包装了大量值得信赖的库，包括
    Redux 和 Redux-Saga、styled components、ESLint、husky 以及更多。
- en: One of the very useful things about the template system for CRA is that it’s
    fully decentralized. Anyone can publish a package to npm and structure it in a
    way that allows you to use it as a base for your own applications. That is, of
    course, also one of the downsides. If you find a template on npm, there’s no saying
    whether it’s any good or even does what it says. Here, you should probably trust
    the wisdom of the crowd—if it’s popular, it’s probably good.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CRA 的模板系统的一个非常有用之处在于它是完全去中心化的。任何人都可以发布一个包到 npm，并以一种允许你将其用作自己应用程序基础的方式对其进行结构化。当然，这也是一个缺点。如果你在
    npm 上找到一个模板，你无法确定它是否好，甚至是否真的做了它所说的。在这里，你可能需要相信群众的智慧——如果它很受欢迎，那么它可能很好。
- en: One of the benefits of allowing just about any random developer to publish a
    template on npm is that this includes *us*, the authors of this book. We’ll be
    using custom React templates for all examples and projects in this book. We’ll
    get back to that in a second. First, we’ll discuss the advantages and drawbacks
    of using CRA.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 允许几乎任何随机开发者发布 npm 上的模板的好处之一是，这包括 *我们*，本书的作者。我们将使用定制的 React 模板来展示本书中的所有示例和项目。我们稍后再回到这一点。首先，我们将讨论使用
    CRA 的优点和缺点。
- en: 2.1.4 Pros and cons
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 优点和缺点
- en: 'There are a lot of advantages to using CRA to create a new React application,
    but, as always, such advantages have consequences. We’ve already discussed many
    advantages, but let’s list them here anyway:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CRA 创建新的 React 应用程序有很多优点，但正如往常一样，这些优点也有其后果。我们已经讨论了许多优点，但让我们还是在这里列出它们：
- en: '*Simplicity*—You have less to worry about when setting up a new application.
    You get JavaScript XML (JSX) transpiling, bundling, testing, automatic reloading,
    and more for free, without dealing with all the interdependencies.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单性*—在设置新应用程序时，你无需担心太多。你可以免费获得 JavaScript XML (JSX) 转换、打包、测试、自动重新加载等功能，无需处理所有依赖关系。'
- en: '*Upgradability*—You can easily upgrade to newer versions of React and all the
    other libraries used. We haven’t discussed how to do that, but it’s surprisingly
    simple. Just run npm install --exact react-scripts@VERSION to upgrade your entire
    project to the specific version of React scripts. Check the changelog for react-scripts
    for details.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可升级性*—你可以轻松升级到 React 及其他所有库的新版本。我们尚未讨论如何进行升级，但这个过程出奇地简单。只需运行 npm install --exact
    react-scripts@VERSION 即可将整个项目升级到特定的 React 脚本版本。查看 react-scripts 的变更日志以获取详细信息。'
- en: '*Community*—With the deluge of available CRA templates and the easy path to
    making more, you can likely always find a premade template with just the right
    combination of tools so that you don’t have to deal with mixing them correctly.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*社区*—随着可用的 CRA 模板如洪水般涌现，以及制作更多模板的简单途径，你很可能总能找到一个具有恰当工具组合的现成模板，这样你就不必担心正确混合它们。'
- en: '*Customization*—On top of a variety of templates, you still have the option
    of adding all the other plugins and libraries that you need for your project.
    Does your project interface with, for example, both Google Maps and Amazon Web
    Services (AWS)? Just add their libraries, and you should be good to go.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定制化*—除了各种模板之外，你还可以选择添加你项目所需的所有其他插件和库。例如，你的项目是否与 Google Maps 和 Amazon Web Services
    (AWS) 等接口？只需添加它们的库，你应该就可以顺利进行了。'
- en: 'However, there are also some drawbacks. Some of them can be ignored or glossed
    over, but, in some situations, you have to seek out other setups besides what
    CRA can provide. We’ll cover some of these situations here as well:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些缺点。其中一些可以忽略或略过，但在某些情况下，你必须寻找 CRA 提供之外的其他设置。我们也将在这里讨论一些这些情况：
- en: '*Understanding*—Without setting the whole project up from scratch, you won’t
    know all that goes into such an endeavor. If you find yourself in a position where
    you need a unique setup but have always relied on CRA, you might find yourself
    stranded quickly because you never really paid attention to it. But that’s the
    duality of all abstractions: you gain the benefit of not worrying at the cost
    of not knowing what’s going on underneath.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解*——如果不从头开始设置整个项目，你就不会知道所有这些努力都包含什么。如果你发现自己处于需要独特设置但一直依赖CRA的位置，你可能会很快发现自己陷入困境，因为你从未真正关注过它。但这是所有抽象的双重性：你通过不担心而获得好处，但代价是不知道下面发生了什么。'
- en: '*Control*—You do lose control over which libraries are used. CRA currently
    uses webpack and BabelJS for JSX bundling and transpiling, but they’re by no means
    the only players around. Recently, tools such as esbuild, Bun, SWC, and Rome have
    emerged that partially cover the same ground, but you can’t easily switch to one
    of those. You’re stuck with the technology stack that CRA currently has chosen
    for you. On the other hand, that’s also an advantage because when another tool
    becomes standard and maybe even superior to Babel, CRA will adapt and use that
    instead—without you having to worry about it. For the instances where you insist
    on using a specific stack, you do have to set your project up from scratch. Another
    option is to eject your application as described in section 2.1.1, which gives
    you extra configurability and control at the cost of losing upgradability.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制*——你将失去对使用哪些库的控制权。CRA目前使用webpack和BabelJS进行JSX捆绑和转译，但它们绝不是唯一的参与者。最近，出现了esbuild、Bun、SWC和Rome等工具，它们在某种程度上覆盖了相同的地盘，但你无法轻易切换到其中之一。你将陷入CRA目前为你选择的科技堆栈。另一方面，这也是一个优势，因为当另一个工具成为标准甚至可能优于Babel时，CRA将适应并使用它——而不必让你担心。对于你坚持使用特定堆栈的实例，你必须从头开始设置你的项目。另一个选择是按照2.1.1节中描述的方式将应用程序推出，这会给你额外的可配置性和控制权，但代价是失去了可升级性。'
- en: '*Integration*—If you want to integrate your application in a server-side setup,
    CRA currently can’t help you. For projects based on website frameworks as described
    in the first chapter, you have to use the setups provided by those frameworks
    rather than CRA.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成*——如果你想在服务器端设置中集成你的应用程序，CRA目前无法帮助你。对于基于第一章中描述的网站框架的项目，你必须使用那些框架提供的设置，而不是CRA。'
- en: After weighing the pros and cons just listed, we arrived at the conclusion that
    CRA is perfect for new developers. You get a lot of simplicity and fewer worries.
    Once you get more experience, you can start to experiment outside of CRA. That’s
    why we’ve used CRA for the examples and projects in this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在权衡了上述的利弊之后，我们得出结论，CRA（Create React App）非常适合新开发者。你将获得许多简洁性，并且减少了许多担忧。一旦你积累了更多经验，你就可以开始在CRA之外进行实验。这就是为什么我们在这本书的例子和项目中使用了CRA。
- en: 2.2 A note about the examples in this book
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 关于本书中示例的说明
- en: As mentioned, we’ll be using CRA for all projects and almost all examples in
    this book. The only exception is the first example you completed in the first
    chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在这本书的所有项目和几乎所有示例中使用CRA。唯一的例外是你在第一章中完成的第一例。
- en: 'All the templates that we’ve created for this book will be named according
    to this structure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这本书创建的所有模板都将按照以下结构命名：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, rq refers to *React Quickly*. The XX will be replaced with the chapter
    number, and the last bit will be a custom short name for each example. For every
    example and project using CRA, you’ll see the template name and how to use it
    in a sidebar like the following.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，rq指的是*React Quickly*。XX将被替换为章节编号，最后部分将是每个示例的定制简短名称。对于使用CRA的每个示例和项目，你都会看到模板名称以及如何在以下侧边栏中使用它。
- en: 'Repository: rq02-nesting'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-nesting
- en: 'This example can be seen in repository rq02-nesting. You can use that repository
    by creating a new web app based on the associated template:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq02-nesting仓库中看到。你可以通过创建一个基于相关模板的新Web应用程序来使用该仓库：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-nesting](https://rq2e.com/rq02-nesting)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-nesting](https://rq2e.com/rq02-nesting)'
- en: Sometimes, examples will contain multiple variants of the source code, and,
    in such cases, each variant will come with its own template as just shown. There
    are also examples that come with suggestions for extra homework. In those instances,
    a template will be specified as the starting point for that extra homework, and
    another template will contain *one* possible solution. You can use the solution
    template as either inspiration or to compare with your own solution. All such
    homework can have infinite solutions, so just because your work doesn’t match
    the template, that doesn’t mean it’s wrong—it’s just different.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，示例将包含多个源代码变体，在这种情况下，每个变体都将像刚才展示的那样带有自己的模板。还有一些示例提供了额外的作业建议。在这些情况下，模板将指定为该额外作业的起点，而另一个模板将包含*一个*可能的解决方案。你可以使用解决方案模板作为灵感或与你自己的解决方案进行比较。所有这样的作业都可以有无限种解决方案，所以如果你的工作与模板不匹配，并不意味着它是错误的——它只是不同。
- en: 'For ease of use, you can often use the template name as your application name
    as well. So, let’s say you want to start working on the next example in this book.
    The template name is rq02-nesting, so let’s use that as the web app name as well:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，你通常可以将模板名称用作你的应用程序名称。所以，假设你想要开始在这本书的下一个示例上工作。模板名称是rq02-nesting，那么我们也可以将其用作web应用名称：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just type that in your console, and you’re already up and running and ready
    to tackle the example to work on the problem along with us if you so desire. You
    can also just read the chapter and view the code in the listings in the book.
    If you find some things odd or need to get your fingers into the code to try some
    things out, you can then instantiate the templates and see the examples in action.
    Now let’s get on with this example, which seems to be about nesting something.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在控制台中输入这些内容，你就可以开始运行并准备好与我们一起解决示例中的问题。你也可以只阅读章节并查看书中的列表中的代码。如果你发现某些事情很奇怪或需要将手指伸入代码中尝试一些事情，那么你可以实例化模板并查看示例的实际效果。现在让我们继续这个示例，它似乎涉及到嵌套某个内容。
- en: 2.3 Nesting elements
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 嵌套元素
- en: 'Getting back to creating React applications, which is what we’ve set out to
    do in this book, let’s start making things slightly more complex than that instructive
    but oversimplified example we looked at in chapter 1\. In that chapter, you learned
    how to create a single React element. As a reminder, the method you use is React.createElement().
    For example, you can create a link element like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回到创建React应用程序，这是我们在这本书中要做的，让我们开始做一些比第一章中我们看到的那个指导性但过于简化的示例稍微复杂一点的事情。在那个章节中，你学习了如何创建单个React元素。作为提醒，你使用的方法是React.createElement()。例如，你可以创建一个链接元素如下：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is fine as long as we’re creating just a single element. The problem is
    that every website has more than one element; otherwise, how would you have any
    other information than just a single paragraph?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只创建单个元素时，这是可以的。问题是每个网站都有不止一个元素；否则，你怎么会有除了单个段落之外的其他信息呢？
- en: 'The solution to creating multi-element structures in a hierarchical manner
    is nesting elements. In the previous chapter, you implemented your first React
    code by creating a single React element and rendering it in the DOM with ReactDOM
    .createRoot().render():'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多元素结构的解决方案是以分层方式嵌套元素。在上一章中，你通过创建单个React元素并使用ReactDOM.createRoot().render()将其渲染到DOM中来实现你的第一个React代码：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s important to note that ReactDOM.createRoot().render() can only take a single
    (root) React element as an argument, which is reactElement in this example. The
    resulting application is shown in figure 2.3.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，ReactDOM.createRoot().render()只能接受一个（根）React元素作为参数，在这个例子中是reactElement。结果应用程序如图2.3所示。
- en: '![02-03](../Images/02-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![02-03](../Images/02-03.png)'
- en: Figure 2.3 Your browser rendering a single heading element. We’ve opened the
    developer tools here to show you the underlying HTML structure. Refer to your
    browser of choice for how to open developer tools, but it’s likely that Ctrl-Alt-I/Cmd-Opt-I
    might do the trick.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 浏览器渲染单个标题元素。我们在这里打开了开发者工具来展示底层的HTML结构。请参考你选择的浏览器如何打开开发者工具，但Ctrl-Alt-I/Cmd-Opt-I可能有效。
- en: 'Repository: rq02-nesting'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-nesting
- en: 'This example can be seen in repository rq02-nesting. You can use that repository
    by creating a new web app based on the associated template:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在rq02-nesting仓库中看到。你可以通过基于相关模板创建新的web应用来使用该仓库：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-nesting](https://rq2e.com/rq02-nesting)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-nesting](https://rq2e.com/rq02-nesting)'
- en: When you check out template rq02-nesting, you’ll have the preceding application,
    but this time using CRA instead of manually adding libraries and writing HTML
    as we did in chapter 1.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查rq02-nesting模板时，您将拥有前面的应用程序，但这次使用CRA而不是手动添加库和编写HTML，就像我们在第1章中所做的那样。
- en: Remember that when you use createElement, the third argument is the child of
    the element. In this case, we just supply simple text as the child. But that text
    is actually another element—at least in the resulting DOM. In React, it doesn’t
    have a specific element type, but it still functions as an element to some extent.
    We can show this relationship in a very simple diagram, as shown in figure 2.4.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当您使用createElement时，第三个参数是元素的子节点。在这种情况下，我们只提供了简单的文本作为子节点。但实际上，那文本实际上是一个元素——至少在生成的DOM中是这样。在React中，它没有特定的元素类型，但它仍然在某种程度上充当一个元素。我们可以在一个非常简单的图中展示这种关系，如图2.4所示。
- en: '![02-04](../Images/02-04.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![02-04](../Images/02-04.png)'
- en: Figure 2.4 The gray node is a real React element, whereas the white element
    is just a text element.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 灰色节点是一个真实的React元素，而白色元素只是一个文本元素。
- en: 2.3.1 Node hierarchy
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 节点层次结构
- en: Before we look at how we can create complex HTML structures, we need a bit of
    basic terminology in place first. The HTML document is often represented as an
    upside-down tree, as shown in figure 2.5\. Nodes in a tree are commonly described
    in a family-like fashion (parent, child, etc.).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨如何创建复杂的HTML结构之前，我们首先需要了解一些基本术语。HTML文档通常被表示为一个倒置的树，如图2.5所示。树中的节点通常以家族式的描述（父节点、子节点等）。
- en: '![02-05](../Images/02-05.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![02-05](../Images/02-05.png)'
- en: Figure 2.5 The upside-down tree structure of an HTML document, with each node
    related to the others in a family role, such as parent, child, and sibling
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 HTML文档的倒置树结构，每个节点以家族角色（如父节点、子节点和兄弟节点）相互关联
- en: 'The following terminology relates to the tree structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下术语与树结构相关：
- en: '*Node*—Any member in the tree is a node, including both HTML elements and text
    nodes. All the boxes in figure 2.5 are nodes. The two bottommost boxes are text
    nodes, and all the others are element nodes.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*节点*—树中的任何成员都是一个节点，包括HTML元素和文本节点。图2.5中的所有框都是节点。最底部的两个框是文本节点，其余的都是元素节点。'
- en: '*Root*—The first (topmost) node is the root of the tree. In figure 2.5, the
    <html> node is the root node.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*根*—树中的第一个（最顶部的）节点是树的根。在图2.5中，<html>节点是根节点。'
- en: '*Parent*—The node directly above a given node is its parent. Every node in
    a tree has only one parent. The node above that can be called the grandparent,
    and so on. In figure 2.5, the parent node of the <body> is the <html> node. The
    root node doesn’t have a parent, and it’s the only node in the tree without a
    parent.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*父节点*—直接位于给定节点之上的节点是其父节点。树中的每个节点只有一个父节点。那个节点之上的节点可以被称为祖父节点，依此类推。在图2.5中，<body>的父节点是<html>节点。根节点没有父节点，它是树中唯一没有父节点的节点。'
- en: '*Child*—Any node directly below a given node is a child of that node. A node
    can have multiple children. The <section> node’s children are the <h1>, <p>, and
    <img> nodes. Not all nodes have children. The <img> element doesn’t have children.
    Text nodes never have children.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*子节点*—任何直接位于给定节点下的节点是该节点的子节点。一个节点可以有多个子节点。<section>节点的子节点是<h1>、<p>和<img>节点。并非所有节点都有子节点。<img>元素没有子节点。文本节点永远不会有子节点。'
- en: '*Sibling*—Two nodes that have the same parent are considered sibling nodes.
    The <p> node has two sibling nodes: the <h1> and <img> nodes.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*兄弟节点*—具有相同父节点的两个节点被认为是兄弟节点。<p>节点有两个兄弟节点：<h1>和<img>节点。'
- en: '*Ascendants*—The parent of a node, its parent, its parent’s parent, and so
    on—all the way up to the root—are called the ascendants of a node. The <h1> node
    has three ascendants: the <section>, <body>, and <html> nodes.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*祖先节点*—一个节点的父节点，它的父节点，它的父节点的父节点，以此类推，一直到根节点，这些都被称为节点的祖先节点。<h1>节点有三个祖先节点：<section>、<body>和<html>节点。'
- en: '*Descendants*—The children of a node, all their children, all their children’s
    children, and so on are called the descendants of a node. The <section> node has
    five descendants: its three direct children as well as the two text nodes that
    are the grandchildren of the first two children.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后代*——一个节点的子节点，以及所有这些子节点的子节点，所有子节点的子节点的子节点，等等，都被称为节点的后代。`<section>`节点有五个后代：它的三个直接子节点以及前两个子节点的两个孙子文本节点。'
- en: '*Nesting*—Nesting is the process of organizing nodes in a tree and deciding
    which nodes will be the children of which other nodes, thus creating the document
    tree. In figure 2.5, we’ve decided to nest the <h1>, <p>, and <img> nodes inside
    the <section> node.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌套*——嵌套是组织树中的节点并决定哪些节点将成为其他节点的子节点的过程，从而创建文档树。在图2.5中，我们决定将`<h1>`、`<p>`和`<img>`节点嵌套在`<section>`节点内。'
- en: 2.3.2 Simple nesting
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 简单嵌套
- en: 'Let’s say you want to render the word *world* in italics in the string “Hello
    world!” but still put all of it in an h1 element. As shown in figure 2.6, you
    create an em element with the string "world" as a child and another h1 element
    with three children:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在字符串“Hello world!”中将单词*world*以斜体形式渲染，但仍然将其全部放在一个h1元素中。如图2.6所示，您创建一个包含字符串"world"的子元素的em元素，以及另一个包含三个子元素的h1元素：
- en: String "Hello " (note the space at the end)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串"Hello "（注意结尾的空格）
- en: em element from before
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前提到的em元素
- en: String "!"
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串"!"
- en: '![02-06](../Images/02-06.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![02-06](../Images/02-06.png)'
- en: Figure 2.6 The two React elements and three text elements needed to render our
    slightly emphasized welcome message
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 渲染我们稍微强调的欢迎信息所需的两个React元素和三个文本元素
- en: 'Using React.createElement, this becomes the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React.createElement，这变成了以下：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ createElement with three arguments
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用三个参数创建元素
- en: ❷ createElement with five arguments, the last three being its children
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用五个参数创建元素，最后三个是它的子元素
- en: 'As you can see here, we’re passing five arguments to createElement now: first,
    the element type, then the properties, and finally the children of the element.
    You can pass as many arguments as children to an element as you need. You can
    also pass the child elements as an array:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在向createElement传递了五个参数：首先，元素类型，然后是属性，最后是元素的子元素。您可以为元素传递任意数量的参数，就像子元素一样。您也可以将子元素作为数组传递：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, it doesn’t make sense to put the elements into an array before
    passing them as an argument, but if we already had an array of elements, we could
    just pass that as an argument by itself. Putting this all together (without using
    an array), the whole script becomes the following listing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在将元素作为参数传递之前将它们放入数组中是没有意义的，但如果我们已经有一个元素数组，我们只需将其作为参数传递即可。将所有这些放在一起（不使用数组），整个脚本就变成了以下列表。
- en: Listing 2.1 Emphatically greeting the world
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 强调问候世界
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we put this into action, we end up with our application looking like figure
    2.7 in the browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些应用到实际中，我们的应用程序在浏览器中看起来就像图2.7所示。
- en: '![02-07](../Images/02-07.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![02-07](../Images/02-07.png)'
- en: Figure 2.7 Emphasized greeting in the browser. Notice the underlying HTML structure
    in the developer tools.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 浏览器中的强调问候。注意开发者工具中的底层HTML结构。
- en: 'Repository: rq02-nesting-italic'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-nesting-italic
- en: 'This example can be seen in repository rq02-nesting-italic. You can use that
    repository by creating a new web app based on the associated template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库rq02-nesting-italic中看到。您可以通过创建基于相关模板的新Web应用程序来使用该仓库：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，直接在您的浏览器中查看应用程序，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-nesting-italic](https://rq2e.com/rq02-nesting-italic)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-nesting-italic](https://rq2e.com/rq02-nesting-italic)'
- en: But what if you wanted to put an element *after* the h1 and not just *inside*
    it? We’ll cover sibling elements in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您想在h1之后而不是仅仅在它内部放置一个元素呢？我们将在下一节中介绍兄弟元素。
- en: 2.3.3 Siblings
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 兄弟元素
- en: In many instances, you can only use a single React element at the top level.
    This goes for the ReactDOM.createRoot().render() method—only a single element
    can be rendered into the DOM as the root element. You’ll also see how custom components
    can only return a single element a bit later.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您只能在顶层使用单个React元素。这适用于ReactDOM.createRoot().render()方法——只能将单个元素渲染到DOM中作为根元素。您稍后还会看到自定义组件只能返回单个元素。
- en: But what if you wanted to show a headline *and* then a link after it in our
    example from before (see figure 2.8)? That would be two different elements next
    to each other, and you can’t render that directly using ReactDOM.createRoot().render().
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在之前的例子中显示一个标题*然后*在其后显示一个链接（见图2.8）怎么办？那将是两个相邻的不同元素，你不能直接使用ReactDOM.createRoot().render()来渲染。
- en: '![02-08](../Images/02-08.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![02-08](../Images/02-08.png)'
- en: Figure 2.8 Two sibling React elements to be rendered in the root
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 在根中渲染的两个兄弟React元素
- en: Instead, you have to wrap them in another element (something in place of the
    ? in figure 2.8). You have two different options here. One option is to use a
    neutral DOM element, which is easy, but would add a “physical” element to the
    output HTML. The alternative is to use a React Fragment element, which works like
    any other element, but doesn’t result in any output HTML itself. See the difference
    between these approaches in figure 2.9.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你必须将它们包裹在另一个元素中（如图2.8中的?所代表的内容）。这里你有两种不同的选择。一种选择是使用一个中性的DOM元素，这很简单，但会在输出HTML中添加一个“物理”元素。另一种选择是使用React
    Fragment元素，它像任何其他元素一样工作，但本身不会产生任何输出HTML。请参见图2.9中这些方法的区别。
- en: '![02-09](../Images/02-09.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![02-09](../Images/02-09.png)'
- en: Figure 2.9 Two different approaches to sibling elements with different outputs
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9展示了两种不同的处理具有不同输出的兄弟元素的方法
- en: If you want to use a neutral DOM element, you can, for instance, use a <div>
    to group them as shown in the next listing. This results in the HTML you see in
    figure 2.10.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用一个中性的DOM元素，例如，你可以使用一个<div>来将它们分组，如图2.10所示。这会产生你在图2.10中看到的HTML。
- en: '![02-10](../Images/02-10.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![02-10](../Images/02-10.png)'
- en: Figure 2.10 Title and link in a grouping element
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 分组元素中的标题和链接
- en: Listing 2.2 Two elements in a grouping container
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 分组容器中的两个元素
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Repository: rq02-siblings-div'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-siblings-div
- en: 'This example can be seen in repository rq02-siblings-div. You can use that
    repository by creating a new web app based on the associated template:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq02-siblings-div仓库中看到。你可以通过基于相关模板创建一个新的web应用来使用那个仓库：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-siblings-div](https://rq2e.com/rq02-siblings-div)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-siblings-div](https://rq2e.com/rq02-siblings-div)'
- en: The <div> container is usually a good choice for block-level content, and <span>
    is used for inline-level content. But you don’t have to use a “real” element.
    You can also create an empty React element, whose only purpose is to group multiple
    other elements and doesn’t output itself into the HTML on the page. This can be
    done with the magical component called React.Fragment, and it can be used as the
    grouping element type. Let’s do that in the next listing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <div>容器通常适用于块级内容，而<span>用于内联级内容。但你不一定要使用“真实”的元素。你还可以创建一个空的React元素，它的唯一目的是将多个其他元素分组，并且不会将自身输出到页面的HTML中。这可以通过被称为React.Fragment的神奇组件来完成，并且它可以作为分组元素类型使用。让我们在下一个列表中这样做。
- en: Listing 2.3 Two elements in a fragment
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 片段中的两个元素
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Notice the use of React.Fragment as the first argument to createElement.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意到React.Fragment被用作createElement的第一个参数。
- en: 'Repository: rq02-siblings-fragment'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-siblings-fragment
- en: 'This example can be seen in repository rq02-siblings-fragment. You can use
    that repository by creating a new web app based on the associated template:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq02-siblings-fragment仓库中看到。你可以通过基于相关模板创建一个新的web应用来使用那个仓库：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-siblings-fragment](https://rq2e.com/rq02-siblings-fragment)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-siblings-fragment](https://rq2e.com/rq02-siblings-fragment)'
- en: The output of this is shown in figure 2.11 in the browser.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，这种输出的显示如图2.11所示。
- en: '![02-11](../Images/02-11.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![02-11](../Images/02-11.png)'
- en: Figure 2.11 Title and link without a grouping element
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 没有分组元素的标题和链接
- en: 'You can also render the whole element in a single statement as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用单个语句渲染整个元素，如下所示：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is functionally equivalent to the previous code; it just uses less variables.
    Some would argue it becomes more obvious, whereas others would say that it becomes
    less readable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上与之前的代码等效；它只是使用了更少的变量。有些人可能会认为这使它更明显，而其他人可能会说这使它更难以阅读。
- en: 'So far, you’ve mostly provided string values as the first parameter of createElement().
    But the first parameter can have two types of input, as we just saw with the fragments:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要将字符串值作为createElement()的第一个参数提供。但第一个参数可以有两种类型的输入，正如我们刚才在片段中看到的那样：
- en: Standard HTML tag as a string, for example, "h1", "div", or "p" (without the
    angle brackets). The name is in lowercase.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为字符串的标准HTML标签，例如，“h1”、“div”或“p”（不带尖括号）。名称是小写的。
- en: React component as a reference (not a string). The name is normally capitalized.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为引用的React组件（而不是字符串）。名称通常是首字母大写的。
- en: The first approach renders standard HTML elements. You can use any string as
    an HTML tag name, regardless of whether it has a meaning in the browser by default.
    So, while you’ll mostly be using normal HTML elements, such as div, main, section,
    and so on, there is nothing stopping you from creating a tiny-horse element, which
    would render as <tiny-horse> in the browser. It has no meaning and no default
    styling, but it would work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法渲染标准HTML元素。你可以使用任何字符串作为HTML标签名，无论它是否在浏览器中默认有意义。因此，虽然你将主要使用正常的HTML元素，如div、main、section等，但没有任何阻止你创建一个tiny-horse元素，它在浏览器中会渲染为<tiny-horse>。它没有意义和默认样式，但它会工作。
- en: In the second approach just listed, we can supply a React component as a reference.
    By this, we don’t mean the name of a React component as a string, but a direct
    reference to the component in question. You already saw one instance of that by
    using React.Fragment. Now let’s look at how we can create our own custom components
    in the next section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚列出的第二种方法中，我们可以提供一个React组件作为引用。通过这种方式，我们并不是指React组件的名称作为字符串，而是直接引用所讨论的组件。你已经通过使用React.Fragment看到了一个这样的例子。现在让我们看看我们如何在下一节中创建自己的自定义组件。
- en: 2.4 Creating custom components
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 创建自定义组件
- en: 'After nesting elements with React, you’ll soon stumble across the next problem:
    there are a lot of elements with a lot of repetition. You need to use the component-based
    architecture (CBA) described in chapter 1, which lets you reuse code by separating
    the functionality into loosely coupled parts: meet component classes, or just
    components, as they’re often called for brevity (not to be confused with web components).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React嵌套元素之后，你很快就会遇到下一个问题：有很多重复的元素。你需要使用第1章中描述的基于组件的架构（CBA），它通过将功能分离成松散耦合的部分来允许代码的重用：遇见组件类，或者简称为组件，它们通常被简称为组件（不要与Web组件混淆）。
- en: Think of standard HTML tags as building blocks. You can use them to compose
    your own React components, which you can use to create custom elements (instances
    of components). By using custom elements, you can encapsulate and abstract logic
    in composable, reusable components. This abstraction allows teams to reuse user
    interfaces (UIs) in large, complex applications as well as in different projects.
    Examples include panels, inputs, buttons, menus, and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准HTML标签视为构建块。你可以使用它们来组合自己的React组件，你可以使用这些组件来创建自定义元素（组件的实例）。通过使用自定义元素，你可以将逻辑封装和抽象到可组合、可重用的组件中。这种抽象允许团队在大型、复杂的应用程序以及不同的项目中重用用户界面（UI）。例如包括面板、输入、按钮、菜单等。
- en: For this example, we want to create three identical links. It doesn’t make a
    whole lot of sense to create identical links, but, for now, we can’t customize
    them, so let’s just go with this scenario. We want to create three links, that
    all say “Read more about React” and link to the React website at [www.react.dev](http://www.react.dev).
    We also want to wrap each link in a paragraph, so they go on separate lines.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们想要创建三个相同的链接。创建相同的链接并没有太多意义，但，目前我们无法自定义它们，所以我们就按照这个场景来。我们想要创建三个链接，它们都写着“了解更多关于React”，并链接到React网站[www.react.dev](http://www.react.dev)。我们还希望将每个链接包裹在一个段落中，这样它们就会单独成行。
- en: There are two different approaches to this. We can do it the naive way by having
    three identical copies of elements, or we can do it the smart way by creating
    a reusable link component and then instantiating it three times, as illustrated
    in figure 2.12.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方法。我们可以通过有三个相同元素的副本来实现，或者我们可以通过创建一个可重用的链接组件，然后将其实例化三次来实现，如图2.12所示。
- en: '![02-12](../Images/02-12.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![02-12](../Images/02-12.png)'
- en: Figure 2.12 Two approaches to creating duplicate elements
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 创建重复元素的两种方法
- en: Let’s first look at the former approach, where we only use a single component
    with the copies manually duplicated. We want three independent links inside independent
    paragraphs, and we can do that in a fairly verbose way as in the following listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看第一种方法，其中我们只使用单个组件，并通过手动复制来创建副本。我们希望在独立的段落中包含三个独立的链接，我们可以以一种相当冗长的方式做到这一点，如下面的列表所示。
- en: Listing 2.4 Three links, one time each
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 三个链接，每个链接一次
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we open this in the browser, we have the result shown in figure 2.13, which
    is exactly what we wanted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开它，我们会得到图2.13中所示的结果，这正是我们想要的。
- en: '![02-13](../Images/02-13.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![02-13](../Images/02-13.png)'
- en: Figure 2.13 Three identical links in our application
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 我们应用程序中的三个相同链接
- en: But we’re repeating ourselves a lot in listing 2.4, which, of course, isn’t
    desirable. The whole point of React and similar frameworks is to stop repeating
    ourselves at all. This calls for a custom component!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但在列表2.4中，我们重复了很多次，这当然是不理想的。React和类似框架的全部意义就是停止重复。这就需要自定义组件！
- en: A custom component is a named object that contains other elements and component
    instances. So, in this case, we could create a single Link component that would
    render the link that we need in the correct way, and then we would include three
    instances of the Link component rather than the “raw” <p> and <a> elements with
    all their properties.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义组件是一个包含其他元素和组件实例的命名对象。因此，在这种情况下，我们可以创建一个单独的链接组件，以正确的方式渲染所需的链接，然后我们会包含三个链接组件的实例，而不是带有所有属性的“原始”<p>和<a>元素。
- en: You create a React component class by extending the React.Component class with
    class CHILD extends PARENT ES6 syntax. Let’s create a custom Link component class
    using class Link extends React.Component.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用class CHILD extends PARENT ES6语法扩展React.Component类来创建一个React组件类。让我们使用class
    Link extends React.Component创建一个自定义链接组件类。
- en: The one mandatory thing you must implement for this new class is the render()
    method. This method must return a single root element created using createElement(),
    which is created from another custom component class or an HTML tag. Either can
    have nested elements if you so desire as long as there is only one root element.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个新类，您必须实现的一个强制性方法是render()方法。此方法必须使用createElement()创建一个根元素返回，createElement()可以是从另一个自定义组件类或HTML标签创建的。如果需要，它们可以嵌套元素，只要只有一个根元素即可。
- en: Listing 2.5 Creating and rendering a React component class
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 创建和渲染React组件类
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Defines a React component class with the capitalized name Link
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用大写命名的Link定义一个React组件类
- en: ❷ Creates a render() method as an expression (function returning a single element)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个作为表达式的render()方法（返回单个元素的函数）
- en: ❸ Returns a new element with whatever we need for this component
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个包含我们所需此组件内容的新的元素
- en: ❹ Creates an instance of the new Link component
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建新的链接组件的一个实例
- en: 'Repository: rq02-custom-links'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-custom-links
- en: 'This example can be seen in repository rq02-custom-links. You can use that
    repository by creating a new web app based on the associated template:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq02-custom-links仓库中看到。您可以通过创建一个基于相关模板的新Web应用程序来使用该仓库：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在您的浏览器中查看应用程序，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-custom-links](https://rq2e.com/rq02-custom-links)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-custom-links](https://rq2e.com/rq02-custom-links)'
- en: By convention, the names of variables containing React components are capitalized.
    This isn’t required in regular JavaScript. You could use the lowercase class name
    someLink in the preceding code instead of Link, and it would still work. But because
    it’s necessary for JSX (which we’ll cover in the next chapter), we apply this
    convention here as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，包含React组件的变量名称应该大写。在常规JavaScript中这不是必需的。您可以在前面的代码中使用小写类名someLink而不是Link，它仍然可以工作。但是，由于它对于JSX（我们将在下一章中介绍）是必要的，所以我们在这里也遵循这个约定。
- en: Analogous to ReactDOM.createRoot().render(), the render() method in a class
    component can only return a single element. If you need to return multiple same-level
    elements, wrap them in a container component—either an HTML element or a React
    fragment. If we now run this code in the browser, we get the exact same HTML as
    before (refer to figure 2.13).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于ReactDOM.createRoot().render()，类组件中的render()方法只能返回一个元素。如果您需要返回多个同一级别的元素，请将它们包裹在一个容器组件中——可以是HTML元素或React片段。如果我们现在在浏览器中运行此代码，我们会得到与之前完全相同的HTML（参见图2.13）。
- en: This new code is much more compact. Unnecessary repetition is removed, and we’ve
    compartmentalized a part of the code that can be reused as much as we want. This
    is the power of component reusability! It leads to faster development and fewer
    bugs. Components also have properties, life cycle events, states, DOM events,
    and other features that let you make them interactive and self-contained; these
    topics are all covered in the following chapters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '这段新代码更加紧凑。去除了不必要的重复，并且我们将代码的一部分封装起来，可以尽可能多地重用。这就是组件可重用性的力量！它导致开发速度更快，错误更少。组件还具有属性、生命周期事件、状态、DOM事件和其他功能，使它们可以交互和自包含；这些主题都在接下来的章节中介绍。 '
- en: Right now, the links are all the same. Wouldn’t it be awesome if you could set
    element attributes and modify their content and/or behavior individually? You
    can do just that with properties, as we’ll discuss next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有链接都是相同的。如果可以设置元素属性并单独修改其内容和行为，那岂不是太棒了？您可以使用属性做到这一点，正如我们接下来将要讨论的。
- en: 2.5 Working with properties
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 与属性一起工作
- en: 'Properties are a cornerstone of the declarative style that React uses. Think
    of properties as unchangeable values within an element. They allow elements to
    have different variations if used in a view, such as changing a link URL by passing
    a new value for a property:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是React使用的声明式风格的基础。将属性视为元素内的不可变值。如果用于视图，它们允许元素有不同的变体，例如通过传递新值的属性来更改链接URL：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One thing to remember is that properties are immutable within their components.
    A parent assigns properties to its children upon their creation. The child element
    isn’t supposed to modify its properties. For instance, you can pass property PROPERTY_NAME
    with value VALUE to a component of type Link, like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，属性在其组件内部是不可变的。父组件在创建子组件时分配属性。子元素不应该修改其属性。例如，您可以将属性PROPERTY_NAME和值VALUE传递给类型为Link的组件，如下所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Properties closely resemble HTML attributes (as shown with the href in the
    link of the snippet at the beginning of this section). This is one of their purposes,
    but they also have another—you can use the properties of an element in your code
    as you wish for the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 属性与HTML属性（如本节开头代码片段中的href所示）非常相似。这是它们的目的之一，但它们还有另一个用途——您可以在代码中按需使用元素的属性：
- en: 'To render standard HTML attributes of an element: href, title, style, class,
    and so on'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要渲染元素的常规HTML属性：href、title、style、class等
- en: As custom instructions for components to make them render individually
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为为组件提供自定义指令以使其单独渲染
- en: The object of properties can be accessed inside a component using this.props.
    This object is a frozen (immutable) object, from which you can only read values,
    not set them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的对象可以通过使用this.props在组件内部访问。这个对象是一个冻结的（不可变的）对象，您只能读取其值，而不能设置它们。
- en: Frozen objects in JavaScript
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的冻结对象
- en: 'Internally, React uses Object.freeze(), which is a built-in function in JavaScript
    to make the this.props object immutable. To check whether an object is frozen,
    you can use the Object.isFrozen() method. For example, you can determine whether
    this statement will return true:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，React使用Object.freeze()，这是JavaScript中的一个内置函数，用于使this.props对象不可变。要检查一个对象是否被冻结，您可以使用Object.isFrozen()方法。例如，您可以确定以下语句是否会返回true：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The details of this are pretty complex, but for now, just know that you should
    never try to edit or add properties inside a component itself. That is something
    you do in the parent context.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的细节相当复杂，但到目前为止，只需知道您永远不应该尝试在组件内部编辑或添加属性。这是在父上下文中完成的事情。
- en: 2.5.1 A single property
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 单个属性
- en: Let’s start with a very simple example. We want the name of the framework in
    the links we created before to be customized. So, we can say “Read more about
    React” in one link, “Read more about Vue” in the second, and “Read more about
    Angular” in the third, as shown in figure 2.14.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始。我们希望在我们之前创建的链接中自定义框架的名称。因此，我们可以在一个链接中写“了解更多关于React”，在第二个链接中写“了解更多关于Vue”，在第三个链接中写“了解更多关于Angular”，如图2.14所示。
- en: '![02-14](../Images/02-14.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![02-14](../Images/02-14.png)'
- en: Figure 2.14 Passing a property to components and using the property inside the
    component
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 将属性传递给组件并在组件内部使用属性
- en: 'To do this, we need to do two things:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要做两件事：
- en: Pass a property to our component instances.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性传递给我们的组件实例。
- en: Use the property inside the component.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件内部使用属性。
- en: First, we need to pass a new property to the link instances. So, rather than
    just using
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将一个新属性传递给链接实例。所以，而不是仅仅使用
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'we’ll instead be supplying an object as the second argument with a single property:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供包含单个属性的对象作为第二个参数：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We used the variable name framework here. That is an arbitrary choice that we
    get to make as the component creator. We just need to make sure to use the same
    variable name in the second step.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了变量名 framework。这是一个我们作为组件创建者可以任意选择的名称。我们只需要确保在第二步中使用相同的变量名。
- en: We now need to use this passed property inside our class. Given that we called
    the variable framework, we’ll access it through this.props.framework. The following
    listing shows the overall code result.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的类中使用这个传递的属性。鉴于我们命名了变量为 framework，我们将通过 this.props.framework 来访问它。以下列表显示了整体代码结果。
- en: Listing 2.6 Link instances with different text
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 带有不同文本的链接实例
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ We render the text content of the link by combining this.props.framework with
    some static content. Note how backticks are used to compose a string with a variable.
    This is a feature of JavaScript, not React in particular.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们通过将 this.props.framework 与一些静态内容结合来渲染链接的文本内容。注意如何使用反引号来组合一个包含变量的字符串。这是 JavaScript
    的一个特性，而不是 React 特有的。
- en: ❷ The first instance of our link component uses "React" as the framework property.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们链接组件的第一个实例使用 "React" 作为框架属性。
- en: ❸ The second instance of our link component uses "Vue" as the framework property.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们链接组件的第二个实例使用 "Vue" 作为框架属性。
- en: ❹ The third instance of our link component uses "Angular" as the framework property.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们链接组件的第三个实例使用 "Angular" 作为框架属性。
- en: You can see this in action in the browser in figure 2.15.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 2.15 中看到这个功能在浏览器中的实际应用。
- en: '![02-15](../Images/02-15.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![02-15](../Images/02-15.png)'
- en: Figure 2.15 Three links with different text, each inside a paragraph
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 三个带有不同文本的链接，每个链接都在一个段落内
- en: 2.5.2 Multiple properties
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 多个属性
- en: You may have noticed that all the links still point to the same URL, which is
    the React website. That’s no good, of course, because we need the URLs to be different.
    Using the same approach, we simply invent a new property, url, and use it inside
    the component as well as in the component instances. You can see that illustrated
    in the diagram in figure 2.16 and implemented in the code in listing 2.7.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有链接仍然指向同一个网址，即 React 网站。这当然是不好的，因为我们需要不同的网址。使用相同的方法，我们简单地发明了一个新的属性，url，并在组件内部以及组件实例中使用它。你可以在图
    2.16 中的图中看到这一点，并在列表 2.7 中的代码中实现。
- en: '![02-16](../Images/02-16.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![02-16](../Images/02-16.png)'
- en: Figure 2.16 Two different properties are passed to our components.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 传递给我们的组件的两个不同属性
- en: Listing 2.7 Link instances with different text and URLs
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 带有不同文本和网址的链接实例
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Using the url property to set the href property on the <a> element
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 url 属性在 <a> 元素上设置 href 属性
- en: ❷ The URL for React is [https://react.dev](https://react.dev).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ React 的网址是 [https://react.dev](https://react.dev)。
- en: ❸ The URL for Vue is [https://vuejs.org](https://vuejs.org).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Vue 的网址是 [https://vuejs.org](https://vuejs.org)。
- en: ❹ The URL for Angular is [https://angular.io](https://angular.io).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Angular 的网址是 [https://angular.io](https://angular.io)。
- en: 'Repository: rq02-link-props'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-link-props
- en: 'This example can be seen in repository rq02-link-props. You can use that repository
    by creating a new web app based on the associated template:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq02-link-props 中看到。你可以通过创建一个基于相关模板的新 Web 应用来使用该仓库：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以访问这个网站来浏览代码，在你的浏览器中直接查看应用程序的实际应用，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq02-link-props](https://rq2e.com/rq02-link-props)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-link-props](https://rq2e.com/rq02-link-props)'
- en: You can see this in action in the browser in figure 2.17\. As you can see, we
    can use properties on both custom components (which are used inside the component
    to customize the returned structure) and HTML elements (which set HTML attributes).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 2.17 中看到这个功能在浏览器中的实际应用。如图所示，我们可以在自定义组件（在组件内部用于自定义返回的结构）和 HTML 元素（设置 HTML
    属性）上使用属性。
- en: '![02-17](../Images/02-17.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![02-17](../Images/02-17.png)'
- en: Figure 2.17 Three links with different text *and* different URLs
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 三个带有不同文本和不同网址的链接
- en: What happens if you mess up and set a custom property on an HTML element? React
    will render it anyway. Before React 16, invalid properties would be filtered out,
    but because modern web applications often use other third-party libraries that
    might rely on some custom properties, React 16 and onward will allow you to use
    whichever properties you choose.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个HTML元素上设置了一个自定义属性并搞错了会发生什么？React仍然会渲染它。在React 16之前，无效的属性会被过滤掉，但鉴于现代Web应用程序经常使用可能依赖于某些自定义属性的第三方库，React
    16及以后的版本将允许你使用你选择的任何属性。
- en: 'You can completely modify the rendered elements based on the value of a property.
    For example, we can examine the framework property and return a huge title with
    a link in case the framework name is "React":'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据属性的值完全修改渲染的元素。例如，我们可以检查框架属性，并在框架名称为"React"的情况下返回一个带有链接的大标题：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Creates a link element and stores it in a variable
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个链接元素并将其存储在一个变量中
- en: ❷ Checks if the framework matches "React"
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查框架是否匹配"React"
- en: ❸ If it matches, returns an h1 element with the link inside
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果匹配，返回一个包含链接的h1元素
- en: ❹ Otherwise, returns a paragraph element with the link inside
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，返回一个包含链接的段落元素
- en: This is also a great example of React elements being just plain old JavaScript.
    We can create an element and store it in a variable, and then later use that variable
    as we see fit. We can also create branching using regular JavaScript functionality.
    If we render this new component in the browser, suddenly the links aren’t identical
    anymore, as you can see in figure 2.18.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的例子，说明React元素仅仅是普通的JavaScript。我们可以创建一个元素并将其存储在一个变量中，然后稍后根据需要使用该变量。我们还可以使用常规JavaScript功能创建分支。如果我们在这个浏览器中渲染这个新组件，突然链接就不再相同了，如图2.18所示。
- en: '![02-18](../Images/02-18.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![02-18](../Images/02-18.png)'
- en: Figure 2.18 Three links are shown, but React stands out as a lot more important.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18显示了三个链接，但React因其重要性而突出。
- en: We’ve now covered several permutations of some very simple HTML that’s almost
    useless by itself. But by starting small, we’re building a solid foundation for
    future, more advanced topics. The truth is that you can achieve a lot of great
    things with custom components.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了一些非常简单的HTML的几种排列组合，这些HTML本身几乎毫无用处。但通过从小处着手，我们正在为未来的更高级主题建立一个坚实的基础。事实上，你可以通过自定义组件实现许多伟大的事情。
- en: It’s very important to know how React works in regular JavaScript if you (like
    many React developers) plan to use JSX. This is because, in the end, browsers
    will still run regular JavaScript, and you’ll need to understand the results of
    the JSX-to-JS transpiling from time to time. Going forward, we’ll be using JSX,
    which is covered in the next chapter. But before we get to that, we need to discuss
    a bit about the structure of a React application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你（像许多React开发者一样）计划使用JSX，那么了解React在常规JavaScript中的工作方式非常重要。这是因为，最终，浏览器仍然会运行常规JavaScript，你有时需要理解JSX到JS转换的结果。从现在开始，我们将使用JSX，这将在下一章中介绍。但在我们到达那里之前，我们需要讨论一下React应用程序的结构。
- en: '2.5.3 The special property: children'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 特殊属性：children
- en: React elements take a special property, children. This isn’t a property you
    specify in the normal way, but you do use it as any other property.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: React元素有一个特殊的属性，children。这不是你以常规方式指定的属性，但你确实像使用任何其他属性一样使用它。
- en: Let’s change our example a little bit and instead create a list of links where
    the text is just the framework name without the text “Read more about” before
    it, as shown in figure 2.19.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下我们的例子，创建一个只包含框架名称（没有“了解更多关于”这样的文本）的链接列表，如图2.19所示。
- en: '![02-19](../Images/02-19.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![02-19](../Images/02-19.png)'
- en: Figure 2.19 Our new structure with the links only containing the framework name
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19展示了我们新的结构，其中链接只包含框架名称
- en: 'Now let’s take this one step further. Let’s say we want the framework for React
    to be displayed in bold. We already know how to make a bold element—just wrap
    it in an element as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更进一步。假设我们想要将React的框架以粗体显示。我们已经知道如何创建一个粗体元素——只需将其包裹在元素中，如下所示：
- en: '[PRE33]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But how are we going to pass that in as a property? We can do this by creating
    the node for the React framework like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何将其作为一个属性传递呢？我们可以通过创建如下所示的React框架节点来完成：
- en: '[PRE34]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Creates a React element in the variable named boldReact
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在变量boldReact中创建一个React元素
- en: ❷ Passes that variable in as the property framework on the Link element
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将该变量作为属性框架传递给Link元素
- en: That’s a bit weird, though. We’re now creating elements, but passing them in
    as properties, which isn’t what we normally do. What if we instead could create
    an element and pass it in as a child element?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这有点奇怪。我们现在正在创建元素，但作为属性传递，这不是我们通常的做法。如果我们能够创建一个元素并将其作为子元素传递，会怎样呢？
- en: Remember how argument three and onward to React.createElement are the children
    of the element? We haven’t used that for custom components, but we can. All the
    nodes passed as the children to a custom element are accessible through this.props
    .children. That property is either a single node (if only passed one child element)
    or an array of nodes (if passed multiple child elements).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 记得React.createElement的第三个参数及其之后的参数是元素的子节点吗？我们还没有在自定义组件中使用它，但我们可以使用。传递给自定义元素的子节点都可以通过this.props.children访问。该属性要么是一个节点（如果只传递了一个子元素），要么是一个节点数组（如果传递了多个子元素）。
- en: So, let’s change our root component to contain three links, where link text
    isn’t passed in as a property named framework, but rather as a child node. For
    the first link, we still want to make the text bold, as shown in figure 2.20 and
    then implemented in listing 2.8.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的根组件更改为包含三个链接，其中链接文本不是作为名为framework的属性传递，而是作为子节点。对于第一个链接，我们仍然希望使文本加粗，如图2.20所示，并在列表2.8中实现。
- en: '![02-20](../Images/02-20.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![02-20](../Images/02-20.png)'
- en: Figure 2.20 The component tree when we pass the link text as a child node rather
    than as a regular property
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：当我们将链接文本作为子节点而不是常规属性传递时的组件树
- en: Listing 2.8 Links with text as child nodes
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8：作为子节点的文本链接
- en: '[PRE35]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Note how we use the property named children just as if it was any other property.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意我们如何像使用任何其他属性一样使用名为children的属性。
- en: ❷ We now only pass a single named property to each custom component, the url
    property. But now we also pass a child node, which will become the children property.
    For React, it’s a nested element.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们现在只向每个自定义组件传递一个命名属性，即url属性。但现在我们还传递了一个子节点，它将成为子节点属性。对于React，它是一个嵌套元素。
- en: ❸ We now only pass a single named property to each custom component, the url
    property. For Vue and Angular, the child node is just a regular text node.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们现在只向每个自定义组件传递一个命名属性，即url属性。对于Vue和Angular，子节点只是一个常规文本节点。
- en: 'Repository: rq02-links-children'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq02-links-children
- en: 'This example can be seen in repository rq02-links-children. You can use that
    repository by creating a new web app based on the associated template:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq02-links-children仓库中看到。您可以通过创建基于相关模板的新Web应用程序来使用该仓库：
- en: '[PRE36]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-links-children](https://rq2e.com/rq02-links-children)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-links-children](https://rq2e.com/rq02-links-children)'
- en: If you run this in the browser, you get the output displayed in figure 2.21\.
    The distinction between using a normal property and the children property might
    seem insignificant at this point, but in the next chapter, when we start using
    JSX, you’ll see how it starts to make a lot of sense when used correctly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在浏览器中运行此代码，您将得到图2.21所示的输出。使用正常属性和子节点属性之间的区别在此点可能看起来微不足道，但在下一章，当我们开始使用JSX时，您将看到当正确使用时它开始变得非常有意义。
- en: '![02-21](../Images/02-21.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![02-21](../Images/02-21.png)'
- en: Figure 2.21 Our link components using children properties where the first link
    is set in bold
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：使用children属性（第一个链接设置为加粗）的链接组件
- en: 2.6 Application structure
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 应用程序结构
- en: From the next chapter on, we’re going to structure our applications in the same
    organized way with similar patterns for easy recognition. We’ll also follow the
    standard structure that the default CRA template provides.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将以相同的方式、使用类似模式来组织我们的应用程序，以便于识别。我们还将遵循默认CRA模板提供的标准结构。
- en: In the previous examples in this chapter, we put our application directly into
    the index.js file inside the source folder. From now on, we’re going to use a
    custom App component as the root element of our applications, and we’ll render
    that as the single child to the browser. This means that we won’t have to touch
    src/index.js again at all. It will remain the same file for all future applications
    going forward that use CRA.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们将我们的应用程序直接放入源文件夹内的index.js文件中。从现在开始，我们将使用自定义的App组件作为我们应用程序的根元素，并将其作为浏览器下的单一子元素进行渲染。这意味着我们再也不需要触摸src/index.js了。对于所有未来使用CRA的应用程序，它都将保持相同的文件。
- en: For this purpose, we’ll rewrite our application with three links from before
    as two new components. One is the root App and the other is the Link component.
    We’ll use the latter three times in the former. Finally, we’ll destructure some
    properties from the React namespace to shorten our component definition slightly.
    We’ll place all this in src/App.js. See figure 2.22 and listing 2.9.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将用之前提到的三个链接重写我们的应用程序，将其分为两个新的组件。一个是根组件App，另一个是链接组件Link。我们将在前一个组件中使用后者的三次。最后，我们将从React命名空间中解构一些属性，以稍微缩短我们的组件定义。我们将所有这些放在src/App.js中。参见图2.22和列表2.9。
- en: '![02-22](../Images/02-22.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![02-22](../Images/02-22.png)'
- en: Figure 2.22 Our new file structure with our two components inside the App.js
    file
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 在App.js文件中的我们的新文件结构，包含两个组件
- en: Listing 2.9 Application that goes in src/App.js
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 放入src/App.js的应用程序
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Destructures the import of React to directly reference Fragment and Component
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解构React的导入，以便直接引用Fragment和Component
- en: ❷ The Link component exactly as in the previous listing
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 链接组件与之前的列表完全相同
- en: ❸ A new App component that renders the root of our application
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个新的App组件，用于渲染我们应用程序的根
- en: ❹ The App component returns a single element as all components must.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ App组件必须返回一个单一元素
- en: ❺ In App.js, we export the App component as the single accessible asset inside
    this file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在App.js中，我们将App组件导出为该文件中唯一的可访问资源。
- en: We then change src/index.js to import our App from App.js and render that into
    the root DOM element, as shown in listing 2.10.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将src/index.js更改为从App.js导入我们的App，并将其渲染到根DOM元素中，如列表2.10所示。
- en: Listing 2.10 src/index.js
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 src/index.js
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Imports our application from App.js and stores it in the local variable App
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从App.js导入我们的应用程序并将其存储在局部变量App中
- en: ❷ Creates a single root element from the HTML element with id="root"
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从具有id="root"的HTML元素创建一个单个根元素
- en: ❸ Renders the App component in that root
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在那个根元素中渲染App组件
- en: This new src/index.js file is now basically complete. We don’t ever need to
    edit it again; we only edit src/App.js to customize our future applications.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的src/index.js文件现在基本上已经完成。我们再也不需要编辑它了；我们只编辑src/App.js来自定义我们的未来应用程序。
- en: 'Repository: rq02-links-app'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq02-links-app
- en: 'This example can be seen in repository rq02-links-app. You can use that repository
    by creating a new web app based on the associated template:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq02-links-app存储库中看到。您可以通过创建基于相关模板的新Web应用程序来使用该存储库：
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，在您的浏览器中直接查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq02-links-app](https://rq2e.com/rq02-links-app)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-links-app](https://rq2e.com/rq02-links-app)'
- en: As our apps grow larger, we’ll grow out of including everything inside a single
    file in src/App.js. When we need to grow, we can just create new files and import
    those as needed. Although it’s customary to create a single file per component
    and name the file after the component (including the uppercase first letter),
    it isn’t a strict rule. If a component needs several other small components to
    function, you can freely decide whether you want to put it all in one file, as
    we did with Link and App in listing 2.10, or split it up into multiple files.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变大，我们将无法在src/App.js的单个文件中包含所有内容。当我们需要扩展时，我们只需创建新文件，并按需导入它们。虽然通常每个组件一个文件，并且文件名以组件命名（包括首字母大写），但这并不是一个严格的规定。如果一个组件需要几个其他的小组件来运行，你可以自由决定是否将它们全部放在一个文件中，就像我们在列表2.10中做的Link和App一样，或者将它们拆分成多个文件。
- en: Let’s see how we would create the same example with the App and Link components
    in separate files. Please refer to the diagram in figure 2.23\. We would also
    need to update src/App.js to import the Link component from src/Link.js, as shown
    in listing 2.11.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用单独的文件中的App和Link组件创建相同的示例。请参考图2.23中的图表。我们还需要更新src/App.js，以从src/Link.js导入链接组件，如列表2.11所示。
- en: '![02-23](../Images/02-23.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![02-23](../Images/02-23.png)'
- en: Figure 2.23 Using one file per component, our file structure looks like this.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 使用每个组件一个文件，我们的文件结构看起来是这样的。
- en: 'Listing 2.11 One component per file: src/App.js'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 每个文件一个组件：src/App.js
- en: '[PRE40]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Imports the Link component from another file
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从另一个文件导入链接组件
- en: Then, we must create the new src/Link.js with only the Link component and remember
    to export that at the end.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建新的src/Link.js，其中只包含链接组件，并记得在最后导出它。
- en: 'Listing 2.12 One component per file: src/Link.js'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 每个文件一个组件：src/Link.js
- en: '[PRE41]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ The Link component definition is now alone in this file.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 链接组件定义现在单独在这个文件中。
- en: ❷ Remember to export the component at the end.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记得在最后导出组件。
- en: 'Repository: rq02-links-app-alt'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq02-links-app-alt
- en: 'This example can be seen in repository rq02-links-app-alt. You can use that
    repository by creating a new web app based on the associated template:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在 rq02-links-app-alt 存储库中看到。您可以通过创建基于相关模板的新网络应用程序来使用该存储库：
- en: '[PRE42]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，在您的浏览器中直接查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq02-links-app-alt](https://rq2e.com/rq02-links-app-alt)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq02-links-app-alt](https://rq2e.com/rq02-links-app-alt)'
- en: We’ll be using both approaches throughout the book. In many of the upcoming
    chapters, our applications will be small and compact, so we’ll put everything
    inside src/App.js. But in later chapters, our applications grow larger, and we’ll
    outgrow a single file. We’ll also be creating files for other things than components.
    It could be files for commonly used functions or other shared functionality that
    we want to use in many files. We’ll also be using separate files for custom hooks
    when we get to that topic in chapter 10.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中使用这两种方法。在许多即将到来的章节中，我们的应用程序将很小且紧凑，所以我们将所有内容都放在 src/App.js 中。但在后面的章节中，我们的应用程序会变得更大，我们将超出单个文件的范围。我们还将为其他事物创建文件，比如常用函数或我们想在多个文件中使用的其他共享功能。当我们到达第
    10 章的钩子主题时，我们还将使用单独的文件来创建自定义钩子。
- en: When projects grow even larger, folder structures are introduced. There are
    no defined standards for how to use folders to structure a React project, so teams
    often come up with their own best practices.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目变得更大时，会引入文件夹结构。没有定义如何使用文件夹来结构化 React 项目的标准，因此团队通常会制定自己的最佳实践。
- en: 2.7 Quiz
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 小测验
- en: A custom React component can be created with which of the following statements?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下哪个语句创建自定义的 React 组件？
- en: const Name = React.createComponent()
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: const Name = React.createComponent()
- en: class Name extends React.Component
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: class Name extends React.Component
- en: const Name = React.createElement()
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: const Name = React.createElement()
- en: class Name extends React.Class
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: class Name extends React.Class
- en: The only mandatory member of a React component is which of the following?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 组件的唯一必需成员是以下哪个？
- en: function
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: function
- en: return
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: return
- en: name
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: name
- en: render
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: render
- en: class
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: class
- en: To access the url property inside a component, you use which of the following?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问组件内部的 url 属性，您使用以下哪个？
- en: this.properties.url
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: this.properties.url
- en: this.data.url
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: this.data.url
- en: this.props.url
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: this.props.url
- en: url
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: url
- en: React properties are immutable inside the component itself. *True* or *false*?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 组件内部的属性是不可变的。*正确*还是*错误*？
- en: React components allow developers to create reusable UIs. *True* or *false*?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 组件允许开发者创建可重用的 UI。*正确*还是*错误*？
- en: Quiz answers
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验答案
- en: class Name extends React.Component. In addition, there’s no React.Class nor
    React.createComponent, and React.createElement is used for creating component
    instances, not component definitions.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: class Name extends React.Component. 此外，没有 React.Class 也没有 React.createComponent，React.createElement
    用于创建组件实例，而不是组件定义。
- en: render() is the only required method. In addition, function, return, and class
    aren’t valid method names.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render() 是唯一必需的方法。此外，函数、返回和类不是有效的方法名称。
- en: this.props.url is correct because only this.props returns the properties object.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: this.props.url 是正确的，因为只有 this.props 返回属性对象。
- en: '*True*. It’s impossible to change a property inside the component itself.'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正确*。在组件内部本身不可能更改属性。'
- en: '*True*. Developers use components to create reusable UIs.'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正确*。开发者使用组件来创建可重用的 UI。'
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can create new React projects using the command-line program create-react-app.
    This allows you to get up and running with a great starter pack of valuable libraries
    in no time.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用命令行程序 create-react-app 创建新的 React 项目。这使您能够迅速使用一套宝贵的库入门。
- en: New React projects can be created from a specified template, and all examples
    in this book come with a template to allow you to see the example locally in three
    short commands without having to locate or download anything directly. We’ll also
    provide links to download the examples instead.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 React 项目可以从指定的模板创建，本书中的所有示例都附带模板，这样您只需执行三个简短的命令就可以在本地查看示例，而无需直接定位或下载任何内容。我们还将提供下载示例的链接。
- en: You can nest React elements by putting nested createElement() calls inside each
    other. You can compose sibling nodes by using third, fourth, and so on arguments
    in createElement().
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将嵌套的 createElement() 调用放在彼此内部来嵌套 React 元素。你可以通过使用 createElement() 中的第三个、第四个等参数来组合兄弟节点。
- en: You can create elements based on regular HTML node names by using the HTML node
    name as the first argument to createElement().
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将 HTML 节点名作为 createElement() 的第一个参数来创建基于常规 HTML 节点名元素。
- en: If you want to modify the resulting elements using properties, you can pass
    these in as an object as the second argument to createElement().
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要使用属性来修改生成的元素，你可以将这些属性作为一个对象传递给 createElement() 的第二个参数。
- en: To use a CBA (one of the features of React), you create custom components. Custom
    components can use properties internally through the this.props variable. Child
    nodes are received as the specially named children property.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 CBA（React 的一个特性），你需要创建自定义组件。自定义组件可以通过 this.props 变量内部使用属性。子节点作为特别命名的 children
    属性接收。
- en: Examples in this book will all follow a very simple file structure.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中的示例都将遵循一个非常简单的文件结构。
