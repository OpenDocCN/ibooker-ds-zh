- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Component basics
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组件基础知识
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The basics of components and their role
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的基础知识和它们的作用
- en: The `@Component` decorator and its most important properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component` 装饰器和它最重要的属性'
- en: Rendering a component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染组件
- en: Passing data into and out of a component using inputs and outputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入和输出将数据传递到组件中
- en: Customizing components with templates and styling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板和样式自定义组件
- en: Injecting content into a component using projection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用投影将内容注入到组件中
- en: Components are so central to how Angular applications are structured that almost
    every feature is somehow linked to them. It’s impossible to make an Angular application
    without a component, after all. This means being able to harness the capabilities
    of components is vital to any developer. They are so important, I’ve dedicated
    the next chapter to additional, more advanced topics involving components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 组件对于Angular应用程序的结构至关重要，几乎每个功能都以某种方式与它们相关联。毕竟，没有组件就无法创建Angular应用程序。这意味着能够利用组件的能力对任何开发者来说都是至关重要的。它们如此重要，以至于我在下一章中专门讨论了涉及组件的更多高级主题。
- en: You saw a couple of components in action in the chapter 2 examples, but in this
    chapter we’ll start with the basics of components to ensure that you have a clear
    overview of how they’re declared and designed. We’ll then look at some of the
    additional capabilities of components that you’ll use most frequently.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您在第二章的示例中看到了一些组件的实际应用，但在这章中，我们将从组件的基础知识开始，以确保您对它们的声明和设计有一个清晰的概述。然后，我们将探讨您最常使用的组件的一些附加功能。
- en: A component includes a template, which is the HTML markup used to describe its
    visual layout and behavior. We’ll look at how to make the most of these templates,
    understand how they’re rendered, and give them individual stylings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件包括一个模板，这是用于描述其视觉布局和行为的HTML标记。我们将探讨如何充分利用这些模板，了解它们是如何渲染的，以及如何为它们提供个性化的样式。
- en: A component also creates a view, which is the rendered result of a component
    that the user can interact with and is comprised of rendering the component template.
    Templates may include references to other components, which will trigger them
    to also be rendered as part of the rendering of the parent component. As discussed
    in chapter 3, an Angular application is a tree of components that all start with
    the App component.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还会创建一个视图，这是用户可以与之交互的组件的渲染结果，它由渲染组件模板组成。模板可能包含对其他组件的引用，这将触发它们在父组件的渲染过程中也被渲染。如第3章所述，Angular应用程序是一个以App组件为起点的组件树。
- en: During this chapter, we’ll build a realistic-looking dashboard that contains
    several components, and we’ll use mock data to simplify the implementation and
    focus purely on the components themselves. Let’s set up the example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个看起来逼真的仪表板，其中包含多个组件，我们将使用模拟数据来简化实现，并专注于组件本身。让我们设置这个示例。
- en: 4.1 Setting up the chapter example
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 设置本章示例
- en: We’ll be making a tree of components in this chapter, and the components will
    have various means by which they communicate and share information. In addition
    to the App component, we’ll create seven (yes, seven) other components. You can
    see the visual output of the application in [figure 4.1](#figure4.1), where each
    type of component is identified.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个组件树，这些组件将通过各种方式相互通信和共享信息。除了App组件外，我们还将创建七个（是的，七个）其他组件。您可以在[图4.1](#figure4.1)中看到应用程序的视觉输出，其中每种类型的组件都被识别出来。
- en: As you can see, this is a fictional dashboard for a data center, which shows
    two clusters (with three nodes each) at the bottom and the combined metrics of
    CPU and memory usage. All the data is generated randomly every 15 seconds, but
    it will also change color from green to red as usage reaches higher than desired
    levels. There is also a Reload button at the top right that will generate a new
    set of data so you can see the components update their behaviors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个虚构的数据中心仪表板，显示了底部的两个集群（每个集群有三个节点）以及CPU和内存使用的综合指标。所有数据每15秒随机生成一次，但当使用量超过预期水平时，颜色也会从绿色变为红色。右上角还有一个重载按钮，可以生成一组新的数据，以便您可以看到组件更新其行为。
- en: Because an Angular application is a tree of components, we can visualize the
    relationships of the components, as you see in [figure 4.2](#figure4.2). This
    is important to consider because although components are declared independently
    from one another, they build upon one another to create the overall application
    and experience for users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular应用程序是一个组件树，我们可以可视化组件之间的关系，正如你在[图4.2](#figure4.2)中看到的那样。这一点很重要，因为尽管组件是独立声明的，但它们相互构建以创建用户的整体应用程序和体验。
- en: This tree shows the relationship between the components, where a line points
    to a child component. Two components in this tree have dotted lines to them—they’re
    dynamically created in the page on demand and aren’t always present. The Nodes
    Detail component has six dotted lines, because any of the Nodes Row components
    can trigger it to display.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树显示了组件之间的关系，其中一条线指向子组件。这棵树中的两个组件有虚线——它们是按需动态创建在页面上的，并不总是存在。节点详情组件有六条虚线，因为任何节点行组件都可以触发它显示。
- en: We’ll look at parts of the component tree again later to see how the various
    components communicate. The way the HTML elements are nested is directly related
    to the way Angular will instantiate and render them, so it should be fairly natural
    for anyone who writes HTML to understand how this tree is built.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后还会查看组件树的部分，以了解各种组件是如何通信的。HTML元素的嵌套方式与Angular实例化和渲染它们的方式直接相关，因此对于任何编写HTML的人来说，理解这个树是如何构建的应该是相当自然的。
- en: '![c04-1.png](image_fi/293313c04/c04-1.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![c04-1.png](image_fi/293313c04/c04-1.png)'
- en: '[**Figure 4.1**](#figureanchor4.1) The completed application with the three
    component types noted'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.1**](#figureanchor4.1) 完成后的应用程序，其中标注了三种组件类型'
- en: '![c04-2.png](image_fi/293313c04/c04-2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![c04-2.png](image_fi/293313c04/c04-2.png)'
- en: '[**Figure 4.2**](#figureanchor4.2) Component tree showing relationships between
    instances of each component'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.2**](#figureanchor4.2) 组件树显示了每个组件实例之间的关系'
- en: 4.1.1 Getting the code
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 获取代码
- en: 'To get started, we’re going to get the code from GitHub so we can get the correct
    setup ready. You can clone the repo using `git` by running the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将从GitHub获取代码，以便我们准备好正确的设置。你可以通过运行以下命令使用`git`克隆仓库：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alternatively, you can download it from [https://github.com/angular-in-action/datacenter/archive/start.zip](https://github.com/angular-in-action/datacenter/archive/start.zip).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以从[https://github.com/angular-in-action/datacenter/archive/start.zip](https://github.com/angular-in-action/datacenter/archive/start.zip)下载它。
- en: Open the directory and make sure you run `npm` `install` to get all the dependencies.
    This may take a moment, but then you should be able to view the app by running
    `ng` `serve`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开目录并确保运行`npm install`以获取所有依赖项。这可能需要一点时间，但之后你应该可以通过运行`ng serve`来查看应用程序。
- en: This chapter will use the ng-bootstrap project, which can be found at [https://ng-bootstrap.github.io](https://ng-bootstrap.github.io).
    This is an implementation of the popular Bootstrap CSS and component framework
    with Angular. We’ll use only a small portion of the available UI library, but
    it’s a popular option and will give you insight into how it could be used for
    your own projects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用ng-bootstrap项目，该项目可在[https://ng-bootstrap.github.io](https://ng-bootstrap.github.io)找到。这是Angular的流行Bootstrap
    CSS和组件框架的实现。我们将仅使用可用UI库的一小部分，但它是一个流行的选项，并将让你了解它如何用于你自己的项目。
- en: We already have a rudimentary Navbar component that displays the top menu. When
    you view the app running, the result should be a gray navbar sticking to the top
    of the page like you see in [figure 4.3](#figure4.3).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个基本的Navbar组件，用于显示顶部菜单。当你查看运行中的应用程序时，结果应该是一个灰色navbar粘附在页面顶部，就像你在[图4.3](#figure4.3)中看到的那样。
- en: '![c04-3.png](image_fi/293313c04/c04-3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![c04-3.png](image_fi/293313c04/c04-3.png)'
- en: '[**Figure 4.3**](#figureanchor4.3) Navbar for the application with Reload button'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.3**](#figureanchor4.3) 带有重载按钮的应用程序Navbar'
- en: That gets us to the point where we have a basic functioning app with one component
    displaying. Let’s step back and talk a little bit about the lifecycle and role
    of components in our application before we build our next step.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们到了这样一个点，我们有一个基本功能的应用程序，只有一个组件在显示。在我们构建下一步之前，让我们回顾一下组件在我们应用程序中的生命周期和角色。
- en: 4.2 Composition and lifecycle of a component
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 组件的组成和生命周期
- en: Components have a lifecycle that begins with their initial instantiation, and
    continues with their rendering until they’re destroyed and removed from the application.
    Before we can understand the lifecycle, we should look more closely at what goes
    into a component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一个生命周期，从它们的初始实例化开始，一直持续到它们被销毁并从应用程序中移除。在我们理解生命周期之前，我们应该更仔细地看看组件中包含的内容。
- en: The composition of components is important to master over time to create more
    complex and efficient Angular applications. I have seen large, real-world Angular
    applications with hundreds to thousands of components, and the quality of those
    applications is largely a byproduct of how well the components are designed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，掌握组件的组成对于创建更复杂和高效的 Angular 应用程序至关重要。我见过拥有数百到数千个组件的大型、真实世界的 Angular 应用程序，这些应用程序的质量在很大程度上是组件设计得好的副产品。
- en: Components have several distinct parts that are combined to create the resulting
    UI that the user can interact with, displayed in [figure 4.4](#figure4.4).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有几个不同的部分组合在一起，创建出用户可以与之交互的最终 UI，如 [图 4.4](#figure4.4) 所示。
- en: '![c04-4.png](image_fi/293313c04/c04-4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![c04-4.png](image_fi/293313c04/c04-4.png)'
- en: '[**Figure 4.4**](#figureanchor4.4) Concepts that compose and influence a component’s
    behavior'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 4.4**](#figureanchor4.4) — 组成并影响组件行为的理念'
- en: 'When we generate a component with the CLI, it creates a set of files that contain
    assets that are combined during rendering. Here’s a list of the primary things
    that compose a component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 CLI 生成组件时，它会创建一组包含在渲染过程中组合的资源的文件。以下是组成组件的主要内容的列表：
- en: '*Component Metadata Decorator* —All components must be annotated with the `@Component()`
    decorator to properly register the component with Angular. The metadata contains
    numerous properties to help modify the way the component behaves or is rendered.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件元数据装饰器* — 所有组件都必须使用 `@Component()` 装饰器进行注解，以便正确地将组件注册到 Angular 中。元数据包含许多属性，有助于修改组件的行为或渲染方式。'
- en: '*Controller* —The controller is the class that is decorated with `@Component()`,
    and it contains all the properties and methods for the component. Most of the
    logic exists in the controller.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制器* — 控制器是带有 `@Component()` 装饰器的类，它包含组件的所有属性和方法。大部分逻辑都存在于控制器中。'
- en: '*Template* —A component isn’t a component without a template. The markup for
    a component defines the layout and content of the UI that a user can see, and
    the rendered version of the template will look at the values from the controller
    to bind any data.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模板* — 没有模板的组件就不是组件。组件的标记定义了用户可以看到的 UI 的布局和内容，模板的渲染版本将查看控制器中的值以绑定任何数据。'
- en: 'These three pieces must exist for any component to be valid. Additionally,
    there are some optional capabilities that can ride alongside components to enhance
    them in certain situations. The first two are concepts that inject values into
    the component, and the rest are concepts that modify the resulting component behavior,
    appearance, or interaction with other components:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的组件都必须存在这三个部分。此外，还有一些可选的功能可以与组件一起使用，以在某些情况下增强它们。前两个是向组件注入值的理念，其余的是修改结果组件行为、外观或与其他组件交互的理念：
- en: '*Providers and hosts* —Services can be injected directly into a component if
    they’re not already provided at the root module level. You also have some control
    over how these services are discovered and where they are made available.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供者和宿主* — 如果服务尚未在根模块级别提供，则可以直接将服务注入到组件中。您还可以控制这些服务的发现方式和它们可用的地方。'
- en: '*Inputs* —Components can accept data being passed to them using the component
    inputs, which make it possible for a parent component to bind data directly into
    a child component, which is a way to pass data down the component tree.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入* — 组件可以通过组件输入接受传递给它们的数据，这使得父组件能够直接将数据绑定到子组件中，这是向下传递组件树数据的一种方式。'
- en: '*Styles and encapsulation* —Optionally, components can include a set of CSS
    styles that are meant to apply only to the component. This provides a layer of
    encapsulation for the design of components, because component styles don’t have
    to be injected globally. Components can configure the way that styles are injected
    and encapsulated into the application.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式和封装* — 可选地，组件可以包含一组仅应用于组件的 CSS 样式。这为组件的设计提供了一层封装，因为组件样式不需要全局注入。组件可以配置样式注入和封装到应用程序中的方式。'
- en: '*Animations* —Angular provides an animation library that makes it easy to style
    component transitions and animations that plug into the template, and can define
    keyframes or animation states to toggle between.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画* —Angular 提供了一个动画库，使得对组件的过渡和动画进行样式化变得简单，并且可以定义关键帧或动画状态来切换。'
- en: '*Outputs* —Outputs are properties that are linked to events that can be used
    to listen for data changes or other events that a parent component might be interested
    in, and can also be used to share data up the component tree.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输出* —输出是与事件链接的属性，可以用来监听数据变化或其他父组件可能感兴趣的事件，也可以用来在组件树中共享数据。'
- en: '*Lifecycle hooks* —During the rendering and lifecycle of a component, you can
    use various hooks to trigger application logic to execute. For example, you can
    run initialization logic once during the instantiation of the component and tear
    down logic during the destruction. You can also use these hooks to bring data
    into the component, so lifecycle hooks work well with both inputs and outputs.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生命周期钩子* —在组件的渲染和生命周期中，你可以使用各种钩子来触发应用程序逻辑的执行。例如，你可以在组件实例化时运行初始化逻辑，并在销毁时运行清理逻辑。你还可以使用这些钩子将数据带入组件，因此生命周期钩子与输入和输出都很好地协同工作。'
- en: There are a few more capabilities that aren’t covered here, but you can always
    find them in the documentation, and we will use them in situations that call for
    them. You can find details by reviewing the additional `@Component` decorator
    properties in the documentation at [https://angular.io/api/core/Component](https://angular.io/api/core/Component).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些未涵盖的功能，但你总是可以在文档中找到它们，并且我们将在需要时使用它们。你可以通过查看[https://angular.io/api/core/Component](https://angular.io/api/core/Component)文档中额外的`@Component`装饰器属性来获取详细信息。
- en: Now that you know what comprises a component, we can more easily look at the
    lifecycle of a component and see how they’re rendered on the screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了组件的组成部分，我们可以更容易地查看组件的生命周期，并了解它们如何在屏幕上渲染。
- en: 4.2.1 Component lifecycle
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 组件生命周期
- en: Components have a lifecycle from creation to removal, and understanding that
    flow will help you design quality components. There can be slight variances in
    how a component’s lifecycle behaves depending on the build tooling used, but in
    most cases that tooling will be the Angular CLI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组件从创建到删除都有生命周期，理解这个流程将有助于你设计高质量的组件。组件的生命周期行为可能会因所使用的构建工具而略有不同，但在大多数情况下，该工具将是
    Angular CLI。
- en: In [figure 4.5](#figure4.5), you see the primary phases that happen during a
    component’s lifecycle. The first major action is that a component is registered
    with the App module. This usually happens because we declare a component as part
    of the NgModule metadata and occurs during application bootstrap, but components
    could also be registered dynamically on the fly later while the application is
    running. When the component is registered, it creates a component factory class
    and stores it for later use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4.5](#figure4.5)中，你可以看到组件生命周期中发生的主要阶段。第一个主要动作是将组件注册到 App 模块中。这通常是因为我们将组件声明为
    NgModule 元数据的一部分，并在应用程序引导期间发生，但组件也可以在应用程序运行时动态注册。当组件被注册时，它创建一个组件工厂类并将其存储以供以后使用。
- en: Then, during the application lifecycle, something will request the component.
    This is typically because the component was found in a template and the compiler
    needs the component, but sometimes components are also requested manually. At
    this point, an instance of the component needs to be loaded. There is a registry
    of components that belong to the module, and Angular will look up the component
    in question and retrieve its component factory, which is generated during the
    compilation using the CLI before the app is run. This special class knows how
    to instantiate a new instance of the component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在应用程序生命周期中，将会有某些东西请求该组件。这通常是因为组件在模板中被找到，编译器需要该组件，但有时组件也可能被手动请求。此时，需要加载组件的一个实例。有一个组件注册表，其中包含属于该模块的组件，Angular
    将查找相关的组件并检索其组件工厂，该工厂是在应用程序运行之前使用 CLI 在编译过程中生成的。这个特殊类知道如何实例化组件的新实例。
- en: As the component is instantiated, the metadata is read and the constructor method
    is fired. Any construction logic will run early in the component’s life, and you
    should be careful not to put anything that might depend on child components being
    available, because the template won’t have been parsed yet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件实例化时，会读取元数据并触发构造函数方法。任何构造逻辑都会在组件的生命早期运行，您应该小心不要放置任何可能依赖于子组件可用的逻辑，因为模板还没有被解析。
- en: '![c04-5.png](image_fi/293313c04/c04-5.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![c04-5.png](image_fi/293313c04/c04-5.png)'
- en: '[**Figure 4.5**](#figureanchor4.5) Component lifecycle while the application
    is running'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.5**](#figureanchor4.5) 应用运行期间的组件生命周期'
- en: The component metadata will then be fully processed by Angular, including the
    parsing of the component template, styles, and bindings. If the template contains
    any child components, those will kick off the same lifecycle for those components
    as well, but they won’t block this component from continuing to render.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 组件元数据将被Angular完全处理，包括解析组件模板、样式和绑定。如果模板包含任何子组件，这些子组件也将启动相同的生命周期，但它们不会阻止此组件继续渲染。
- en: At this point, we’ve initialized the component, and a cycle begins where the
    child components become fully rendered, application state changes, and components
    are updated. During this cycle, lifecycle hooks will fire to alert you to important
    times when you’ll know it’s safe to do certain actions. For example, there’s a
    lifecycle hook that lets you know when any of the inputs have changed; another
    lets you know when all the child components have fully resolved (in case you have
    logic that depends on them to run).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时刻，我们已经初始化了组件，开始了一个周期，其中子组件被完全渲染，应用程序状态发生变化，组件被更新。在这个周期中，生命周期钩子会触发，以提醒您在安全执行某些操作的重要时刻。例如，有一个生命周期钩子会告诉您任何输入是否已更改；另一个会告诉您所有子组件是否已完全解析（以防您有依赖于它们的逻辑）。
- en: At some point, the component may no longer be needed in the application. At
    that point, Angular will destroy the component (and all of its children). Any
    new instances will need to be recreated from the component factory class, as we
    saw earlier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，组件可能不再在应用程序中需要。在那个时刻，Angular将销毁组件（及其所有子组件）。任何新的实例都需要从组件工厂类中重新创建，就像我们之前看到的那样。
- en: 4.2.2 Lifecycle hooks
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 生命周期钩子
- en: During the application rendering process and reaction to user inputs, various
    hooks can be used to run code at various checkpoints. These hooks are useful when
    you need to know that certain conditions are true before executing the code, such
    as ensuring that child components have been initialized, or when changes are detected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序渲染过程和响应用户输入时，可以使用各种钩子在各个检查点运行代码。当您需要在执行代码之前知道某些条件为真时，这些钩子非常有用，例如确保子组件已初始化，或者当检测到变化时。
- en: In chapter 2, we saw the `OnInit` lifecycle hook in action. It runs early in
    the cycle but after all bindings have been resolved, so it’s safer to know that
    all data is available for the component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们看到了`OnInit`生命周期钩子的实际应用。它在周期早期运行，但在所有绑定都解析完毕之后，因此可以更安全地知道所有数据都对组件可用。
- en: Angular will only run a lifecycle hook if it’s defined in the component. Lifecycle
    hooks aren’t like event listeners—they’re special methods with specific names
    that are called during the component’s lifecycle if they’re defined.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当组件中定义了生命周期钩子时，Angular才会运行生命周期钩子。生命周期钩子不同于事件监听器——它们是具有特定名称的特殊方法，如果定义了，会在组件的生命周期中调用。
- en: The lifecycle hooks are all named as you see in [table 4.1](#table4.1), but
    when you implement the hook in your controllers, you prefix it with `ng` as well.
    `OnInit` needs to be implemented as the `ngOnInit()` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子的命名方式与您在[表4.1](#table4.1)中看到的一样，但您在控制器中实现钩子时，也需要以`ng`作为前缀。`OnInit`需要实现为`ngOnInit()`方法。
- en: '[**Table 4.1**](#tableanchor4.1) List of lifecycle hooks and their roles'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[**表4.1**](#tableanchor4.1) 生命周期钩子和它们的作用列表'
- en: '| **Lifecycle hook** | **Role** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期钩子** | **作用** |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OnChanges` | Fires any time the input bindings have changed. It will give
    you an object (`SimpleChange`) that includes the current and previous values so
    you can inspect what’s changed. This is most useful to read changes in binding
    values. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `OnChanges` | 任何输入绑定更改时都会触发。它将提供一个对象（`SimpleChange`），其中包含当前值和上一个值，以便您可以检查更改的内容。这主要用于读取绑定值的变化。
    |'
- en: '| `OnInit` | This runs once after the component has fully initialized (though
    not necessarily when all child components are ready), which is after the first
    `OnChanges` hook. This is the best place to do any initialization code, such as
    loading data from APIs. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `OnInit` | 这在组件完全初始化后运行一次（尽管不一定是在所有子组件都准备好之后），即在第一个 `OnChanges` 钩子之后。这是进行任何初始化代码的最佳位置，例如从API加载数据。|'
- en: '| `OnDestroy` | Before a component is completely removed, the `OnDestroy` hook
    allows you to run some logic. This is most useful if you need to stop listening
    for incoming data or clear a timer. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `OnDestroy` | 在组件完全移除之前，`OnDestroy` 钩子允许你运行一些逻辑。这在你需要停止监听传入的数据或清除计时器时非常有用。|'
- en: '| `DoCheck` | Any time that change detection runs to determine whether the
    application needs to be updated, the `DoCheck`lifecycle hook lets you implement
    your own type of change detection. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `DoCheck` | 每次变更检测运行以确定应用程序是否需要更新时，`DoCheck` 生命周期钩子允许你实现自己的变更检测类型。|'
- en: '| `AfterContentInit` | When any content children have been fully initialized,
    this hook will allow you to do any initial work necessary to finish setting up
    the content children components, such as if you need to verify whether content
    passed in was valid or not. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `AfterContentInit` | 当任何内容子组件已完全初始化后，此钩子将允许你执行完成设置内容子组件所需的任何初始工作，例如，如果你需要验证传入的内容是否有效。|'
- en: '| `AfterContentChecked` | Every time that Angular checks the content children,
    this can run so you can implement additional change detection logic. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `AfterContentChecked` | 每次Angular检查内容子组件时，都可以运行此钩子，这样你可以实现额外的变更检测逻辑。|'
- en: '| `AfterViewInit` | This hook lets you run logic after all View Children have
    been initially rendered. This lets you know when the whole component tree has
    fully initialized and can be manipulated. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `AfterViewInit` | 此钩子允许你在所有视图子组件已初始渲染后运行逻辑。这让你知道整个组件树已经完全初始化并且可以被操作。|'
- en: '| `AfterViewChecked` | When Angular checks the component view and any View
    Children have been checked, you can implement additional logic to determine whether
    changes occurred. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `AfterViewChecked` | 当Angular检查组件视图以及任何视图子组件已被检查时，你可以实现额外的逻辑来确定是否发生了变化。|'
- en: The `OnInit`, `OnChanges`, and `OnDestroy` hooks are the most commonly used
    lifecycle hooks. The `DoCheck`, `AfterContentChecked`, and `AfterViewChecked`
    hooks are most useful to keep track of logic that needs to run during any change
    detection process, and respond if necessary. The `OnInit`, `AfterContentInit`,
    and `AfterViewInit` hooks are primarily useful to run logic during the component’s
    initial rendering to set it up, and each one ensures a different level of component
    integrity (such as it’s ready or if the child components are also ready).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInit`、`OnChanges` 和 `OnDestroy` 钩子是最常用的生命周期钩子。`DoCheck`、`AfterContentChecked`
    和 `AfterViewChecked` 钩子最有用，可以跟踪在任意变更检测过程中需要运行的逻辑，并在必要时做出响应。`OnInit`、`AfterContentInit`
    和 `AfterViewInit` 钩子主要用于在组件的初始渲染期间运行逻辑以设置其状态，并且每个钩子确保了不同级别的组件完整性（例如，它是否已准备好或子组件是否也已准备好）。'
- en: You may be wondering about the differences between a Content Child and View
    Child. Let’s briefly talk about how components are nested and how that impacts
    the rendering of a component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道内容子组件和视图子组件之间的区别。让我们简要地谈谈组件是如何嵌套的以及这如何影响组件的渲染。
- en: 4.2.3 Nesting components
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 组件嵌套
- en: Because Angular is a tree of components, you’ll be nesting components inside
    one another. There are two ways to nest components and they’re named differently
    based on how they’re rendered. Take a look again at the chapter example in [figure
    4.1](#figure4.1), and you’ll see how components are nested inside one another
    to create a more complex interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Angular是一个组件树，你将在组件内部嵌套其他组件。有两种嵌套组件的方式，并且根据它们的渲染方式有不同的名称。再次查看[图4.1](#figure4.1)中的章节示例，你会看到组件是如何嵌套在一起以创建更复杂的界面的。
- en: Most often, components are nested by being declared in the template of another
    component. Any component that’s nested inside another’s template is called a *View
    Child*, so named because the template represents the view of the component and
    therefore is a child inside that view. A View Child is declared inside the component
    template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，组件通过在另一个组件的模板中声明来嵌套。任何嵌套在另一个模板内部的组件都称为 *视图子组件*，之所以这样命名是因为模板代表了组件的视图，因此在该视图中是一个子组件。视图子组件是在组件模板内部声明的。
- en: Occasionally a component accepts content to be inserted into its template, and
    this is known as a *Content Child*, so named because these components are inserted
    as content inside the component rather than being directly declared in the template.
    A Content Child is declared between the opening and closing tags when a component
    is used.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时组件会接受要插入其模板中的内容，这被称为 *内容子组件*，之所以这样命名，是因为这些组件作为内容插入到组件内部，而不是直接在模板中声明。当使用组件时，内容子组件是在开标签和闭标签之间声明的。
- en: 'Let’s take an example to be sure we can see the difference. Imagine we have
    a UserProfile component with the following template:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，以确保我们可以看到区别。想象我们有一个 UserProfile 组件，其模板如下：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first line is using a component, UserAvatar, which is a View Child. Notice
    how it’s declared in the template of the component. Then there’s this NgContent
    element—which I cover in more detail later, but suffice it to say it’s a place
    to render additional content. Any component passed in through NgContent would
    be considered a Content Child. When we use the UserProfile component, its use
    would look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用了一个组件 UserAvatar，它是一个视图子组件。注意它在组件模板中的声明方式。然后是 NgContent 元素——我将在后面更详细地介绍它，但简单来说，它是一个渲染额外内容的地方。通过
    NgContent 传递的任何组件都会被视为内容子组件。当我们使用 UserProfile 组件时，其使用方式可能如下所示：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we use the UserProfile component, we’re passing another component, User­Details,
    into the component by declaring it between the opening and closing tags. This
    is how a Content Child is passed into a component and then is put where the NgContent
    element sits in the UserProfile component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 UserProfile 组件时，我们通过在开标签和闭标签之间声明它，将另一个组件 User­Details 传递给该组件。这就是内容子组件如何传递给组件，并将其放置在
    UserProfile 组件中的 NgContent 元素所在的位置。
- en: In our example here, we had two nested components, UserAvatar as a View Child
    and UserDetails as a Content Child. The distinction is where they’re declared
    and has nothing to do with the component design themselves.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们有两个嵌套组件，UserAvatar 作为视图子组件，UserDetails 作为内容子组件。这种区别在于它们的声明位置，与组件本身的设计无关。
- en: Generally, the code of a single component should focus on its own business and
    not have to worry a lot about child components (of either type). But there are
    some use cases where you’ll build a component that needs to distinguish between
    these types of components and its children. The concern is always making components
    too coupled, but sometimes it’s unavoidable or even desirable (such as a Tabs
    and Tab component working together to make a tabbed interface), so this distinction
    can be important.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单个组件的代码应专注于其自身业务，而无需过多关注子组件（无论是哪种类型）。但有一些用例，你会构建一个需要区分这些类型组件及其子组件的组件。关注点始终是使组件过于耦合，但有时这是不可避免的，甚至可能是希望的（例如，Tabs
    和 Tab 组件一起工作以创建标签界面），因此这种区分可能很重要。
- en: Now that we’ve covered a lot of the high-level concepts behind components, we
    can get back to our example. The next step is to create our second component and
    get some data generated to display.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了组件背后的许多高级概念，我们可以回到我们的示例。下一步是创建我们的第二个组件，并生成一些数据以供显示。
- en: 4.3 Types of components
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 组件类型
- en: Fundamentally there’s only one type of component, but I like to think about
    components as four categories, based on their roles. All components are declared
    and function in fundamentally the same way, but they can be instantiated differently,
    may or may not contain state, or have coupling to other aspects of the application
    that make them distinct from other components.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上只有一种组件类型，但我喜欢根据它们的作用将其分为四个类别。所有组件都是声明并按基本相同的方式运行的，但它们可以以不同的方式实例化，可能包含或不包含状态，或者与其他应用方面的耦合使其与其他组件不同。
- en: 'I think these classifications are useful to describe the roles of components
    and give general guidance about how they should be designed. This shouldn’t be
    considered a rigid set of rules to follow—you’ll certainly build components that
    don’t fit perfectly into these guidelines, and that’s perfectly acceptable. Keep
    these ideas in the back of your mind, and I believe they will be helpful. Here
    are the four roles of components, and the names I’ve given them:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这些分类对于描述组件的作用和提供关于它们应该如何设计的总体指导是有用的。这不应被视为必须遵循的严格规则集——你肯定会构建不符合这些指南的组件，这是完全可以接受的。将这些想法放在心里，我相信它们会很有帮助。以下是组件的四个角色以及我给它们取的名字：
- en: '*App component* —This is the root app component, and you only get one of these
    per application.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*App 组件* — 这是根应用程序组件，每个应用程序只有一个这样的组件。'
- en: '*Display component* —This is a stateless component that reflects the values
    passed into it, making it highly reusable.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示组件* — 这是一个无状态的组件，它反映了传递给它的值，使其具有高度的复用性。'
- en: '*Data component* —This is a component that helps get data into the application
    by loading it from external sources.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据组件* — 这是一个通过从外部源加载数据来帮助将数据带入应用程序的组件。'
- en: '*Route component* —When using the router, each route will render a component,
    and this makes the component intrinsically linked to the route.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路由组件* — 当使用路由器时，每个路由都会渲染一个组件，这使得组件本质上与路由相关联。'
- en: Angular doesn’t provide a standard nomenclature like this for various roles
    of components, so you won’t be able to go searching for related content based
    on these names. The real value is in understanding that it’s typically best to
    give your components specific roles instead of trying to make them do too many
    things. Let’s take a closer look at these different roles and why they’re designated
    as separate groups.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 没有提供这样的标准命名法来表示组件的不同角色，因此您无法根据这些名称搜索相关内容。真正的价值在于理解，通常最好为您的组件指定特定的角色，而不是试图让它们做太多事情。让我们更详细地看看这些不同的角色以及为什么它们被指定为不同的组。
- en: App component
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: App 组件
- en: The App component is a special case component. As you know, every Angular application
    starts by rendering a component, and if you used the CLI it will be the AppComponent
    (but could be named anything if you changed it).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: App 组件是一个特殊案例组件。正如您所知，每个 Angular 应用程序都是从渲染一个组件开始的，如果您使用了 CLI，它将是 AppComponent（但如果您更改了名称，它可以是任何名称）。
- en: 'Here are the guidelines I recommend for your App component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我为您推荐的 App 组件的指导方针：
- en: '*Keep it simple* —If possible, don’t put any logic into the component. Think
    of it more like a container. It’s easier to reuse and optimize the rest of your
    components if the App component doesn’t have complex behaviors they depend upon.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保持简单* — 如果可能，不要在组件中放入任何逻辑。更像是容器。如果 App 组件没有复杂的依赖行为，那么更容易重用和优化其他组件。'
- en: '*Use for application layout scaffolding* —The template is the primary part
    of the component, and you’ll see later in this chapter how we create the primary
    application layout in this component.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用于应用程序布局脚手架* — 模板是组件的主要部分，您将在本章后面看到我们如何在这个组件中创建主要的应用程序布局。'
- en: '*Avoid loading data* —Usually you will avoid loading data in this component,
    because I like to load data closer to the component that uses that data. You might
    load some global data (perhaps something like a user session), though that could
    also be done separately. On less complex applications, you might load data because
    it’s more complicated to abstract it on smaller applications.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*避免加载数据* — 通常您会避免在这个组件中加载数据，因为我喜欢将数据加载得更接近使用该数据的组件。您可能需要加载一些全局数据（例如用户会话），尽管这也可以单独完成。在不太复杂的应用程序中，您可能需要加载数据，因为抽象化较小的应用程序可能更复杂。'
- en: In my opinion, the best rule is to keep the App component as simple as possible.
    Typically, I have only a template and an empty controller. The intention is to
    avoid doing too much “global”-type logic and configuration in the app controller
    to increase the modularity of your other components and keep the logic inside
    components that need it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，最好的规则是尽可能保持 App 组件的简单性。通常，我只有一个模板和一个空控制器。目的是避免在应用程序控制器中做太多的“全局”类型逻辑和配置，以增加其他组件的模块化，并保持逻辑在需要它的组件内部。
- en: Display component
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示组件
- en: The Display component role is likely to be the most common one that you create
    or consume as you build your Angular expertise. These are components that generally
    are useful for rendering out content and are typically given the necessary data
    to display. Most third-party components will be in this role because it’s the
    most decoupled type of component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显示组件的角色可能是您在构建 Angular 专业技能时最常见的一个。这些组件通常用于渲染内容，并且通常提供必要的数据来显示。大多数第三方组件都将扮演这个角色，因为它是最解耦的组件类型。
- en: 'Here are the primary guidelines I suggest for a Display component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是为 Display 组件建议的主要指导方针：
- en: '*Decouple* —Ensure that the component has no real coupling to other components,
    except that data may be passed into it as an input when requested.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解耦* — 确保组件与其他组件没有实际的耦合，除了在需要时可能作为输入传递数据到它。'
- en: '*Make it only as flexible as necessary* —Avoid making these components overly
    complex and adding a lot of configuration and options out of the box. Over time,
    you might enhance them, but I find it’s best to start simple and add later.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使其尽可能灵活* — 避免使这些组件过于复杂，并添加大量的配置和选项。随着时间的推移，你可能会增强它们，但我发现最好是从简单开始，然后逐步添加。'
- en: '*Don’t load data* —Always accept data through an input binding instead of loading
    data dynamically through HTTP or through a service.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要加载数据* — 总是通过输入绑定接受数据，而不是通过HTTP或服务动态加载数据。'
- en: '*Have a clean API* —Accept input bindings to obtain data into the component
    and emit events for any actions that need to be pushed back up to other components.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拥有干净的API* — 接受输入绑定以将数据输入组件，并发出任何需要推送到其他组件的动作的事件。'
- en: '*Optionally use a service for configuration* —Sometimes you may need to provide
    configuration defaults, and instead of having to declare the preferences with
    every use of the component, you can use a service that sets application defaults.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可选地使用服务进行配置* — 有时候你可能需要提供配置默认值，而不是在每次使用组件时都要声明首选项，你可以使用设置应用程序默认值的服务。'
- en: Sometimes it may feel like overkill to make your components more isolated and
    specific for displaying output. The more encapsulated and isolated the component
    is, the easier it will be to reuse.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，让你的组件更加隔离和具体以显示输出可能会感觉过度。组件越封装和隔离，就越容易重用。
- en: I often find that when I start to refactor some code, I begin by identifying
    individual aspects of my code that could be standalone display components. I might
    notice a lot of repeated snippets of code that mostly have the same capabilities
    and refactor them into a single component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现，当我开始重构一些代码时，我首先会识别出代码中可以独立显示的各个部分。我可能会注意到很多重复的代码片段，它们大多具有相同的功能，并将它们重构为一个单一组件。
- en: It’s also common for these components to have a template and little to no logic
    in the controller. That’s perfectly acceptable, because it allows you to easily
    reuse a template snippet across your application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件通常在控制器中有一个模板和很少的逻辑。这是完全可以接受的，因为它允许你轻松地在应用程序中重用模板片段。
- en: Data component
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据组件
- en: The Data component oversees loading or managing data. Most applications need
    data from some external source (HTTP or user input), and it’s best to contain
    that inside a Data component versus a Display component. I find that most developers
    build these first and eventually start to abstract out pieces into either route
    or display component types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据组件负责加载数据或管理数据。大多数应用程序需要从外部来源（HTTP或用户输入）获取数据，最好将其包含在数据组件中，而不是显示组件中。我发现大多数开发者首先构建这些组件，然后最终开始将部分抽象为路由或显示组件类型。
- en: 'Data components are primarily about handling, retrieving, or accepting data.
    Typically, they rely on a service to handle the loading of data, as we saw in
    chapter 2\. Here are some considerations for a Data component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数据组件主要关于处理、检索或接受数据。通常，它们依赖于服务来处理数据的加载，正如我们在第2章中看到的。以下是一些关于数据组件的考虑因素：
- en: '*Use appropriate lifecycle hooks* —To do the initial data loading, always leverage
    the best lifecycle hook for when to trigger the loading or persistence of data.
    We’ll look at this more later in this chapter.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用适当的生命周期钩子* — 为了进行初始数据加载，始终利用最佳的生命周期钩子来触发数据的加载或持久化。我们将在本章后面更详细地探讨这一点。'
- en: '*Don’t worry about reusability* —These components are not likely to be reused
    because they have a special role to manage data, which is difficult to decouple.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要担心可重用性* — 这些组件不太可能被重用，因为它们有特殊的作用来管理数据，这很难解耦。'
- en: '*Set up display components* —Think about how this component can load data needed
    by other display components and handle any data from user interactions.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置显示组件* — 考虑这个组件如何加载其他显示组件所需的数据，并处理来自用户交互的任何数据。'
- en: '*Isolate business logic inside* —This can be a great place to store your application
    business logic, because anytime you manage data, you’re likely dealing with a
    specialized implementation that works for a specific use case.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在内部隔离业务逻辑* — 这可以是一个存储应用程序业务逻辑的好地方，因为每次你管理数据时，你很可能会处理一个针对特定用例的特定实现。'
- en: I try to limit the number of components that deal with data so I can avoid making
    too many specialized components. Each application is different, and perhaps you
    also leverage a nice UI library and don’t need to make many of your own display
    components, so it’s possible that the code you write for an application may be
    weighted toward data components (while the overall application will still have
    a lot of display components provided by the third-party module).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图限制处理数据的组件数量，以避免创建太多的专用组件。每个应用程序都是不同的，也许你也利用了一个不错的UI库，不需要创建很多自己的显示组件，因此，你为应用程序编写的代码可能更侧重于数据组件（尽管整体应用程序仍将包含大量由第三方模块提供的显示组件）。
- en: Route component
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由组件
- en: The Route component is any component that’s linked directly to a route. These
    components aren’t very reusable and are typically created specifically for a specific
    route in an application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组件是直接链接到路由的任何组件。这些组件不太可重用，通常是为应用程序中的特定路由专门创建的。
- en: These components also often follow the principles of a Data component because
    routes often require loading more data for the new view. The reason I distinguish
    between them is that a single route could render out multiple data components,
    such as in a dashboard that has several components loading metric information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件也通常遵循数据组件的原则，因为路由通常需要为新视图加载更多数据。我区分它们的原因是，单个路由可能渲染出多个数据组件，例如在具有多个组件加载度量信息的仪表板中。
- en: 'A route component should primarily follow these guidelines:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组件应主要遵循以下指南：
- en: '*Template scaffolding for the route* —The route will render this component,
    so this is the most logical place to put the template that’s associated with the
    route.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路由模板脚手架* — 路由将渲染此组件，因此这是放置与路由关联的模板的最合逻辑的地方。'
- en: '*Load data or rely on data components* —Depending on the complexity of your
    route, the route component may load data for the route or rely on one or more
    data components to do that for it. If you’re unsure, I’d suggest loading data
    initially in the Route component and decoupling as your view gets more complex.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载数据或依赖数据组件* — 根据路由的复杂性，路由组件可能为路由加载数据或依赖一个或多个数据组件来完成这项工作。如果你不确定，我建议最初在路由组件中加载数据，并在视图变得更加复杂时解耦。'
- en: '*Handles route parameters* —As you navigate, there are likely to be router
    parameters (such as the ID of the content item being viewed), and this is the
    best place to handle those parameters, which often determine what content to load
    from the back end.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理路由参数* — 在导航过程中，很可能会遇到路由参数（例如正在查看的内容项的ID），这是处理这些参数的最佳位置，这些参数通常决定了从后端加载哪些内容。'
- en: Every route that you can navigate to is linked to a component, so the number
    of route components you create is directly linked to the number of routes you
    add into your application. You could route to the same component for different
    routes, but that isn’t common.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个你可以导航到的路由都链接到一个组件，因此你创建的路由组件数量直接关联到你添加到应用程序中的路由数量。你可以为不同的路由路由到相同的组件，但这并不常见。
- en: 4.4 Creating a Data component
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 创建数据组件
- en: We’re going to start by making a component that will help us manage data. This
    is a dashboard for a data center, so the data it provides is largely numeric values
    of various metrics that are important to determine the health of the data center.
    We’ll create a component, aptly named the Dashboard component, which will host
    our data and display it in the app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个组件，以帮助我们管理数据。这是一个数据中心仪表板，因此它提供的数据主要是对数据中心健康至关重要的各种度量值的数值。我们将创建一个名为“仪表板组件”的组件，它将托管我们的数据并在应用程序中显示它。
- en: We’ll have the raw data print to the screen for the moment until we create other
    components. At the end of this section your app should look like [figure 4.6](#figure4.6).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们将直接将原始数据打印到屏幕上，直到我们创建其他组件。在本节结束时，你的应用程序应该看起来像[图4.6](#figure4.6)。
- en: '![c04-6.png](image_fi/293313c04/c04-6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![c04-6.png](image_fi/293313c04/c04-6.png)'
- en: '[**Figure 4.6**](#figureanchor4.6) App with Dashboard component that generates
    a random data set and is displaying it raw'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.6**](#figureanchor4.6) 具有仪表板组件的应用程序，该组件生成随机数据集并显示原始数据'
- en: 'Start by generating a new component using the CLI. Then we’ll add the logic
    into the controller and see a few lifecycle hooks in action. This will be a good
    example of a Data component because it will handle the data for the entire application
    and not deal too much with the display of content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用CLI生成一个新的组件。然后我们将逻辑添加到控制器中，并看到几个生命周期钩子的实际应用。这将是一个很好的数据组件的例子，因为它将处理整个应用程序的数据，而不会过多地处理内容的显示：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now open the src/app/dashboard/dashboard.component.ts file and replace its contents
    with what you see in the following listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`src/app/dashboard/dashboard.component.ts`文件，并用以下列表中的内容替换其内容。
- en: '**Listing 4.1** Dashboard component controller'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4.1** Dashboard组件控制器'
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start by importing the `OnInit` and `OnDestroy` interfaces, which we use
    when we create our controller to add better intelligence to the TypeScript compiler
    about what constitutes a valid controller implementation. In this case, `OnInit`
    and `OnDestroy` are interfaces that tell TypeScript that it must implement the
    `ngOnInit` and `ngOnDestroy` methods, respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`OnInit`和`OnDestroy`接口，我们在创建控制器时使用这些接口来为TypeScript编译器提供更好的智能，以便了解什么构成了有效的控制器实现。在这种情况下，`OnInit`和`OnDestroy`是接口，它们告诉TypeScript必须分别实现`ngOnInit`和`ngOnDestroy`方法。
- en: For additional clarity, the `Metric` and `Node` interfaces describe the structures
    we’re using for our data. It’s optional, but I recommend leveraging interfaces
    for proper enforcement of code and because interfaces help over time with maintaining
    code. The component has five properties, four of which contain values for our
    dashboard and the last of which is used to maintain a reference to the interval
    so it can be cleared later.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加额外的清晰度，`Metric`和`Node`接口描述了我们用于数据的结构。这是可选的，但我建议利用接口来正确执行代码，因为接口有助于随着时间的推移维护代码。该组件有五个属性，其中四个包含仪表板的数据值，最后一个用于维护对间隔的引用，以便稍后可以清除它。
- en: Then we use the NgOnInit lifecycle hook to generate the data, and also set up
    the interval that will generate a new data set every 15 seconds. The NgOnDestroy
    lifecycle hook is also used then to clear the interval when the Dashboard component
    is removed from the application. Anytime you use an interval, you’ll want to be
    sure to clear the interval if you no longer need it, or you’ll create a memory
    leak over time because the interval would continue to exist even after navigating
    to another page.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`NgOnInit`生命周期钩子生成数据，并设置一个每15秒生成新数据集的间隔。当Dashboard组件从应用程序中移除时，也使用`NgOnDestroy`生命周期钩子来清除间隔。任何使用间隔的时候，你都会想要确保在不再需要它时清除间隔，否则随着时间的推移，你将创建内存泄漏，因为即使导航到另一个页面，间隔仍然会继续存在。
- en: The rest of the code is a set of methods used to generate the data, which I
    won’t go over in detail. It will generate memory and CPU metrics for six nodes
    across two clusters and aggregate the total utilization metrics as well. How this
    data is leveraged will be more obvious as we build the next few components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是一组用于生成数据的方法，我不会详细说明。它将为两个集群中的六个节点生成内存和CPU指标，并汇总总利用率指标。随着我们构建下一个几个组件，如何利用这些数据将变得更加明显。
- en: 'Now in the component template, which is found in the file src/app/dashboard/dashboard.component.html,
    let’s bind the raw data to the screen so we can see it as it’s generated. Replace
    the contents of that file with this single interpolation binding that will bind
    the data for one of the clusters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在组件模板中，该模板位于文件`src/app/dashboard/dashboard.component.html`中，我们将原始数据绑定到屏幕上，以便我们可以看到它是如何生成的。用以下单个插值绑定替换该文件的原始内容，该绑定将数据绑定到一个簇：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We haven’t added the dashboard to our application yet, so open up src/app/app.component.html
    and add the dashboard to the bottom of the template like so. It should look like
    what you saw in [figure 4.3](#figure4.3) earlier in this section:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有将仪表板添加到我们的应用程序中，所以打开`src/app/app.component.html`文件，并将仪表板添加到模板的底部，如下所示。它应该看起来像本节前面看到的[图4.3](#figure4.3)：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That’s it for the Dashboard component—for the moment. We’ll add more to the
    Dashboard later in this chapter as we build more components to handle the displaying
    of the data, starting with the next component, which will display the CPU and
    memory metrics and will accept data through an input.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，Dashboard组件的内容就到这里了——目前是这样。在本章的后面部分，当我们构建更多用于显示数据的组件时，我们将向Dashboard添加更多内容，从下一个组件开始，该组件将显示CPU和内存指标，并通过输入接受数据。
- en: 4.5 Using inputs with components
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 使用组件的输入
- en: When you create your own components, you can define properties that can accept
    input through property bindings. Any default HTML element properties can also
    be bound to a component, but you can define additional properties that the component
    can use to manage its lifecycle or display.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的组件时，你可以定义可以接受通过属性绑定输入的属性。任何默认HTML元素属性也可以绑定到组件，但你可以定义组件可以用来管理其生命周期或显示的附加属性。
- en: 'We saw this in chapter 2, and the following is a snippet we used to bind stock
    data into the Summary component. You see the brackets around the stock attribute
    to indicate that the value is binding to the data found in the stock property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章中看到了这一点，以下是我们用于将股票数据绑定到摘要组件的代码片段。你看到股票属性周围的方括号，表示值绑定到在股票属性中找到的数据：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By default, all properties of a component aren’t immediately bind-able, as you
    saw earlier. They must be declared as an input to allow the property to be bound.
    One reason is that we want encapsulation of our components, and it’s best not
    to automatically expose all properties. Another reason is that Angular needs to
    know which properties exist so it can properly handle the wiring of values into
    a component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，组件的所有属性都不是立即可绑定的，正如你之前看到的。它们必须声明为输入，以便允许属性进行绑定。一个原因是我们要封装我们的组件，最好不要自动公开所有属性。另一个原因是Angular需要知道哪些属性存在，以便它可以正确处理将值连接到组件的线路。
- en: In our application, we want to display some metric data of the entire data center.
    This is shown in [figure 4.7](#figure4.7), which is the result of the work we’ll
    do in this section. The role of these components is to display the CPU and Memory
    metric information of the entire data center. Because the only difference between
    these components is the data, we’ll make it reusable, using inputs to pass data
    into the component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们想显示整个数据中心的一些度量数据。这如图4.7所示，这是我们在本节中将要完成的工作的结果。这些组件的作用是显示整个数据中心的CPU和内存度量信息。因为这些组件之间唯一的区别是数据，我们将使其可重用，使用输入将数据传递到组件中。
- en: '![c04-7.png](image_fi/293313c04/c04-7.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![c04-7.png](image_fi/293313c04/c04-7.png)'
- en: '[**Figure 4.7**](#figureanchor4.7) Adding the metric components to the app
    that share the same display with different data'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.7**](#figureanchor4.7) 在与不同数据共享相同显示的应用中添加度量组件'
- en: 4.5.1 Input basics
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 输入基础
- en: 'Let’s build our component that has an input and see it in action before we
    dig into it further. Use the CLI to generate a new component like you see here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入研究之前，让我们构建一个具有输入的组件，并看看它的实际效果。使用CLI生成一个新组件，如下所示：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll start by looking at the component controller, so open the src/app/metric/metric.component.ts
    file and update it with what you see in the following listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看组件控制器，因此打开 src/app/metric/metric.component.ts 文件，并更新为以下列表中的内容。
- en: '**Listing 4.2** Metric component controller'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4.2** 度量组件控制器'
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Metric component first imports the `Input` decorator, which is used to decorate
    any property that you want to define as an input. In this case, we have four inputs
    declared, which means that all the properties of this component are made available
    for binding. Then we implement a simple method called `isDanger()` that will tell
    us whether the utilization is above 70% or not, so we can display the metric in
    a different way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 度量组件首先导入 `Input` 装饰器，该装饰器用于装饰任何你想定义为输入的属性。在这种情况下，我们声明了四个输入，这意味着该组件的所有属性都可用于绑定。然后我们实现了一个简单的
    `isDanger()` 方法，它将告诉我们利用率是否超过70%，因此我们可以以不同的方式显示度量。
- en: The first two properties are the `title` and `description`. The `Input` decorator
    sits in front and will make each of the properties available for binding based
    on the name of the property. Though I’ve declared a typing for each of the properties,
    it’s important to note that they don’t verify that the input matches that type
    at runtime. You’ll still need to sanitize the inputs or handle invalid values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个属性是 `title` 和 `description`。`Input` 装饰器位于前面，它将根据属性的名称使每个属性可用于绑定。尽管我为每个属性声明了类型，但重要的是要注意，它们在运行时并不验证输入是否与该类型匹配。你仍然需要清理输入或处理无效值。
- en: The last two properties pass an optional value into the `Input` decorator, which
    is a way to change the name of the property that’s used in the binding from the
    name used internally for the component. That allows us to alias the `used` attribute
    to the `value` property, and the `available` attribute to the `max` property.
    When you bind to the Metric component, you’ll use the binding like `[used]="node.used"`,
    but inside the component it will use the property `value`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个属性将可选值传递给`Input`装饰器，这是一种更改绑定中使用的属性名称的方法，从组件内部使用的名称。这允许我们将`used`属性别名到`value`属性，将`available`属性别名到`max`属性。当你绑定到度量组件时，你将使用绑定`[used]="node.used"`，但在组件内部它将使用属性`value`。
- en: You may hear some refer to the *component API*, and what they’re talking about
    is the component inputs. Because this is the primary way for passing data into
    a component, it’s much like a contract for how to consume the component in your
    application. Being able to rename the input can be beneficial for code clarity
    because it allows you to expose bindings differently from the internal implementation.
    But I recommend making the names consistent for simplicity and debugging.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会听到一些人提到*组件API*，他们谈论的是组件输入。因为这是将数据传递到组件中的主要方式，所以它就像一个如何在应用程序中消费组件的合同。能够重命名输入对于代码清晰度有益，因为它允许你以不同的方式暴露绑定，与内部实现不同。但我建议为了简单和调试，使名称保持一致。
- en: I also recommend that you ensure that your input bindings and property names
    are as clear as possible. Making your property names short to save characters
    is rarely worth it, because developers no longer know what that property is about
    without digging deeper into the code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议你确保你的输入绑定和属性名称尽可能清晰。为了节省字符而使属性名称短通常不值得，因为开发者如果不深入代码，就不知道该属性是关于什么的。
- en: As you build more components and work on larger projects, you’ll likely start
    to create components that are reused across projects and applications. This is
    a core principle of Angular as well—to enable easy reuse of components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你构建更多组件并在更大的项目上工作，你可能会开始创建在项目和应用程序之间重复使用的组件。这也是Angular的一个核心原则——使组件的重复使用变得容易。
- en: Now let’s set up the Metric component template, and we’ll even use the ng-bootstrap
    Progress Bar component as an example of how to consume another component that
    has inputs. Open the src/app/metric/metric.component.html file and update it to
    the contents of the following listing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置度量组件模板，并且我们将使用ng-bootstrap进度条组件作为如何消费具有输入的另一个组件的示例。打开`src/app/metric/metric.component.html`文件，并将其更新为以下列表的内容。
- en: '**Listing 4.3** Metric component template'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4.3** 度量组件模板'
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This template uses a lot of the template syntax capabilities of Angular in a
    short amount of space. First, we’re using the bootstrap CSS styling to create
    a card layout for the Metric component, so the card classes are from bootstrap.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板在很短的空间内使用了大量的Angular模板语法功能。首先，我们使用bootstrap CSS样式创建度量组件的卡片布局，因此卡片类来自bootstrap。
- en: All the bindings in this template will resolve to the four input properties
    that were defined in the controller, but notice that we’re using the property
    names and not any alias names passed to the `Input`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，所有绑定都将解析为在控制器中定义的四个输入属性，但请注意，我们使用的是属性名称，而不是传递给`Input`的任何别名名称。
- en: The `nav` element is used to create the top header bar that contains the title.
    Using NgClass, it will either apply the `bg-danger` or `bg-success` class based
    on how much of the overall value has been utilized.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`nav`元素用于创建包含标题的顶部标题栏。使用NgClass，它将根据整体值的使用量应用`bg-danger`或`bg-success`类。'
- en: There are a few basic interpolation bindings, such as the `title`, `value`,
    `max`, and `description`. We also have an example of a more complex interpolation
    expression that divides the `value` by `max` and formats it as a percentage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个基本的插值绑定，例如`title`、`value`、`max`和`description`。我们还有一个更复杂的插值表达式的示例，它将`value`除以`max`并将其格式化为百分比。
- en: Finally, we have a sample of using the ng-bootstrap Progress Bar component.
    Based on the documentation for the progress bar, it accepts the three bindings
    we declared to give it the bindings for `value`, `max`, and `type`. `value` and
    `max` are numbers, and `type` is the bootstrap class (such as `danger` or `success`)
    to use for coloring the bar.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个使用 ng-bootstrap 进度条组件的示例。根据进度条的文档，它接受我们声明的三个绑定，为 `value`、`max` 和 `type`
    提供绑定。`value` 和 `max` 是数字，而 `type` 是用于着色条形的引导类（如 `danger` 或 `success`）。
- en: The Progress Bar is a great example of a well-designed component. It has a clear
    set of input properties. It doesn’t require a lot of effort to consume and internalizes
    much of the logic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条是一个设计良好的组件的绝佳例子。它有一组清晰的输入属性。它不需要太多的努力来消费，并内部化了大部分逻辑。
- en: Because we added the ng-bootstrap module to our App module earlier, all the
    components provided by ng-bootstrap are available without having to make any special
    requests for them. Most third-party library experiences will be similar, and once
    you’ve added the third-party module to your app, your application can easily consume
    the values made available by the third party.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在之前将 ng-bootstrap 模块添加到我们的 App 模块中，所以所有由 ng-bootstrap 提供的组件都可以使用，而无需为它们做出任何特殊请求。大多数第三方库体验都将类似，一旦你将第三方模块添加到你的应用中，你的应用就可以轻松消费第三方提供的值。
- en: Let’s get this Metric component on the screen. Open up the src/app/dashboard/dashboard.component.html
    file and replace its contents with the code in the following listing. Remember,
    the Dashboard component contains the data that’s now able to be bound into the
    component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个指标组件显示在屏幕上。打开 src/app/dashboard/dashboard.component.html 文件，并用以下列表中的代码替换其内容。记住，仪表板组件包含现在可以绑定到组件中的数据。
- en: '**Listing 4.4** Using the metric components'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.4** 使用指标组件'
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we define a bit of markup for the bootstrap styling to create a new container
    and card block for display purposes. The really meaningful part is the use of
    the Metric component. Notice we’re still able to apply a class to the element
    because it’s treated like a regular HTML element when rendered.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些标记来为引导样式创建一个新的容器和用于显示的卡片块。真正有意义的是使用了指标组件。注意，我们仍然能够将一个类应用到元素上，因为它在渲染时被当作一个常规的
    HTML 元素处理。
- en: Each of the four properties we defined in our component is listed as an attribute
    with the binding syntax of brackets around it. Remember, this is the syntax to
    tell Angular to evaluate the expression against the parent component (the Dashboard
    component) and return its value to the child component (the Metric component).
    Because they were marked as inputs, we can bind values to those properties that
    aren’t standard HTML properties. For the `used` and `available` properties, we
    bind to the corresponding properties on the `cpu` and `mem` controller values.
    Then for the `title` and `description`, we provide a string literal, because they’re
    evaluated as an expression.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件中定义的四个属性被列为一个属性，并带有括号包围的绑定语法。记住，这是告诉 Angular 对父组件（仪表板组件）中的表达式进行评估并返回其值给子组件（指标组件）的语法。因为它们被标记为输入，我们可以将这些属性绑定到非标准
    HTML 属性上。对于 `used` 和 `available` 属性，我们将其绑定到 `cpu` 和 `mem` 控制器值上的相应属性。然后对于 `title`
    和 `description`，我们提供一个字符串字面量，因为它们被评估为一个表达式。
- en: Did you notice how this component is more generic? It accepts the four inputs
    that it needs to display, which even includes some text. We can easily use the
    same component more than once and have it display for each metric uniquely. This
    is usually preferred over making a lot of components that do nearly the same task.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这个组件更通用了吗？它接受它需要显示的四个输入，甚至包括一些文本。我们可以轻松地多次使用相同的组件，并为每个指标提供独特的显示。这通常比制作许多几乎执行相同任务的组件更受欢迎。
- en: 4.5.2 Intercepting inputs
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 截获输入
- en: We’re currently blindly accepting whatever values are passed into the component
    and using them without any kind of validation. It’s easy to forget to validate
    or sanitize data inputs, especially when you’re building the component tree and
    are confident about the types of data that are being passed along.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前盲目地接受传递给组件的任何值，并使用它们而不进行任何验证。很容易忘记验证或清理数据输入，尤其是在构建组件树并确信正在传递的数据类型时。
- en: The problem is as applications grow or as components get reused in new ways,
    it becomes harder to keep track of the inputs. It’s also good practice to try
    and validate inputs when possible to harden your components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，随着应用程序的增长或组件以新的方式被重用，跟踪输入变得更加困难。在可能的情况下尝试验证输入也是良好的实践，以加固你的组件。
- en: For instance, if we changed the value of a binding to a Metric component to
    give it the wrong type, the Metric component would have some issues. Try it out
    yourself. Change `[used]="cpu.used"` to `[used]="'fail'"`. This changes the binding
    to pass a string instead of a number. The Metric component will throw an error
    because eventually it will try to divide the string and a number, which isn’t
    valid.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将绑定到一个度量组件的值的类型更改错误，度量组件将会有一些问题。自己试一试。将 `[used]="cpu.used"` 改为 `[used]="'fail'"`。这会将绑定更改为传递一个字符串而不是一个数字。度量组件将抛出一个错误，因为最终它将尝试将字符串和数字相除，这是无效的。
- en: I like to use a method to intercept inputs that need validation by using getter
    and setter methods. This is a feature that has been in JavaScript for a while,
    but I haven’t seen it widely used until more recently.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用一个方法来拦截需要通过获取和设置方法进行验证的输入。这是一个 JavaScript 中已经存在了一段时间的功能，但我直到最近才看到它被广泛使用。
- en: The main idea here is that instead of having a property to bind to directly,
    you bind the input to the setter method, which stores the real value on a private
    property so you can protect it from direct access. The setter method is also where
    you can run any validation logic. Then you use the getter method to return the
    value of the private property anytime it’s requested.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是，而不是直接绑定到一个属性，你将输入绑定到设置方法，该方法将真实值存储在一个私有属性上，这样你就可以保护它免受直接访问。设置方法也是你运行任何验证逻辑的地方。然后你使用获取方法在任何请求时返回私有属性的值。
- en: Let’s modify our Metric component to use this approach to validate input values
    and protect our template from division errors with values that aren’t numbers.
    Open the src/app/metric/metric.component.ts file and change the class to what
    you see in the following listing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的度量组件，使用这种方法来验证输入值并保护我们的模板免受非数字值的除法错误。打开 `src/app/metric/metric.component.ts`
    文件，将其更改为以下列表中的内容。
- en: '**Listing 4.5**  Metric component intercepting inputs'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.5** 度量组件拦截输入'
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you haven’t used a getter or setter method before, they’re functions that
    are proceeded by the `get` or `set` keyword. The name of the method has to match
    the name of the property, so in this example `get` `value(){}` will be called
    anytime something requests the `this.value` property. Likewise, anytime something
    stores a new value to `this.value`, it will call the `set``value(value){}` method
    and pass the value that was stored.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过获取或设置方法，它们是前面带有 `get` 或 `set` 关键字的函数。方法的名字必须与属性的名称匹配，所以在这个例子中 `get`
    `value(){}` 将会在任何请求 `this.value` 属性时被调用。同样，任何将新值存储到 `this.value` 中的操作都会调用 `set`
    `value(value){}` 方法，并传递存储的值。
- en: We started by creating two new private properties, `_value` and `_max`. With
    the `private` keyword, TypeScript will ensure they’re not directly exposed in
    the controller so they can’t be mutated outside of this controller. The underscore
    before the name is a common convention to notify developers that a property is
    considered private.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了两个新的私有属性，`_value` 和 `_max`。使用 `private` 关键字，TypeScript 将确保它们不会直接暴露在控制器中，因此它们不能在这个控制器之外被修改。名称前的下划线是一个常见的约定，用来通知开发者该属性被认为是私有的。
- en: We implement the value setter method and also decorate it with the `Input` decorator.
    This registers a normal `input` property, but, instead, when the binding into
    the component happens, it will pass through this function. The function does a
    check to ensure that the value is a number—if not, it sets it to `0` and stores
    that value on the `_value` property. Then we implement the getter method to retrieve
    the `_value` property. We do the same basic thing for the `max` property, but
    set the default to `100` if the input is invalid.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了值设置方法，并使用 `Input` 装饰器对其进行装饰。这注册了一个普通的 `input` 属性，但在绑定到组件时，它将通过这个函数传递。该函数会检查值是否为数字——如果不是，它将将其设置为
    `0` 并将此值存储在 `_value` 属性上。然后我们实现了获取方法来检索 `_value` 属性。我们对 `max` 属性也做了同样的基本处理，但如果输入无效，则将其默认设置为
    `100`。
- en: We’ve now guarded our inputs against invalid values, but there are other scenarios
    where you may want to intercept values. You may want to format some values before
    they’re used, such as ensuring that words are capitalized.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经保护了输入，防止了无效值，但还有其他场景你可能想要拦截值。你可能想在它们被使用之前格式化一些值，例如确保单词首字母大写。
- en: The main problem with this approach is that every time you read the property
    using a getter method, it will run the logic inside the getter method. This probably
    isn’t a big deal in most cases, such as if you’re only returning a private property
    as we’re doing here, but if you have more complex logic, the functions might take
    a toll on rendering speed. Also, don’t do any mutation in the getter function!
    Doing so will cause unexpected behaviors because you can’t be sure how many times
    the getter function will be called.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是每次你使用getter方法读取属性时，它都会运行getter方法内的逻辑。在大多数情况下，这可能不是什么大问题，比如如果你只是返回一个私有属性，就像我们在这里做的那样，但如果你有更复杂的逻辑，这些函数可能会对渲染速度产生影响。另外，不要在getter函数中进行任何修改！这样做会导致意外的行为，因为你无法确定getter函数会被调用多少次。
- en: There’s one more way that we’ll intercept and modify inputs as they come into
    the component, but we’ll first take a look at how to project content inside your
    components.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一种方法来拦截和修改输入，当它们进入组件时，但首先我们将看看如何在组件内部进行内容投影。
- en: 4.6 Content projection
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 内容投影
- en: Imagine that you created a Card component and you wanted the card content area
    to be flexible to accept any kind of markup that a developer needed to insert.
    We can accomplish this using *content projection*, which allows us to declare
    the place to insert external content into our component.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你创建了一个Card组件，并且希望卡片内容区域能够灵活地接受开发者需要插入的任何类型的标记。我们可以通过使用*内容投影*来实现这一点，它允许我们声明将外部内容插入到我们的组件中的位置。
- en: Content projection is a concept Angular implements that comes from web components.
    If we think about the role of display components, the need to accept markup to
    display inside the component is fairly common. Tabs, cards, navbars, modals, dialogs,
    sidebars—the list goes on for types of UI elements that could accept a generic
    set of markups to display within the component.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影是Angular从Web组件中实现的一个概念。如果我们考虑显示组件的作用，接受标记以在组件内部显示的需求相当普遍。标签页、卡片、导航栏、模态框、对话框、侧边栏——可以接受通用一组标记以在组件内部显示的UI元素类型清单可以继续下去。
- en: Because we want to create reusable display components, content projection is
    a key capability that we’ll need to use. The good news is that it’s fairly simple
    to implement, so let’s go ahead and see it in action.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要创建可重用的显示组件，内容投影是我们需要使用的关键功能。好消息是它相对简单易实现，所以让我们看看它是如何发挥作用的。
- en: We’re going to build two components that help us create a table to display each
    of the nodes in a cluster of servers. If you think about it, a table already uses
    content projection because you create a table and then nest rows inside the headers,
    and then inside the rows you insert the cells. See [figure 4.8](#figure4.8).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建两个组件，帮助我们创建一个表格来显示服务器集群中的每个节点。如果你这么想，表格已经使用了内容投影，因为你创建了一个表格，然后在标题内嵌套行，然后在行内插入单元格。参见[图4.8](#figure4.8)。
- en: 'Using the CLI, generate two new components, one for the Nodes component and
    another for the Nodes Row component:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CLI生成两个新的组件，一个用于Nodes组件，另一个用于Nodes Row组件：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![c04-8.png](image_fi/293313c04/c04-8.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![c04-8.png](image_fi/293313c04/c04-8.png)'
- en: '[**Figure 4.8**](#figureanchor4.8) Nodes component uses content projection
    to display nodes row components'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图4.8**](#figureanchor4.8)　Nodes组件使用内容投影来显示节点行组件'
- en: We’ll start by getting the Nodes component up and running, and we’re only going
    to start with the template. The controller is empty, and for this use case we
    don’t need any controller logic to use content projection. Open src/app/nodes/nodes.component.html
    and replace its contents with the following listing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先让Nodes组件启动并运行，我们只从模板开始。控制器是空的，对于这个用例，我们不需要任何控制器逻辑来使用内容投影。打开src/app/nodes/nodes.component.html，并用以下列表替换其内容。
- en: '**Listing 4.6** Nodes component template'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4.6**　Nodes组件模板'
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can see this template has the markup for a table header. I want to point
    out the use of property binding to a non-standard name; in this case the attribute
    is `colspan`, but the property on the element is `colSpan`. The only benefit to
    using the binding here is that normally you need to bind to an expression instead
    of a static value, so you wouldn’t do this.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个模板包含表格标题的标记。我想指出的是，这里使用了属性绑定到一个非标准名称；在这种情况下，属性是 `colspan`，但元素上的属性是 `colSpan`。在这里使用绑定的唯一好处是，通常您需要绑定到一个表达式而不是一个静态值，所以您不会这样做。
- en: The really interesting aspect is the NgContent element, which tells Angular
    that this component has an insertion point for content. When someone uses this
    element and they nest additional markup inside the element, it will be placed
    where the NgContent element currently sits. That allows you to choose exactly
    where the content is inserted (hence the name *insertion point*).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的部分是 NgContent 元素，它告诉 Angular 这个组件有一个内容插入点。当有人使用这个元素并在元素内部嵌套额外的标记时，它将被放置在
    NgContent 元素当前所在的位置。这允许您精确地选择内容插入的位置（因此得名 *插入点*）。
- en: 'We’ll get to see how this works shortly, but we want to make one small change
    to the component decorator. Open the src/app/nodes/nodes.component.ts file and
    change the selector to the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到它是如何工作的，但我们需要对组件装饰器进行一个小小的修改。打开 `src/app/nodes/nodes.component.ts` 文件，将选择器更改为以下内容：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We’ve changed the selector here to say that it will look for the attribute `app-nodes`
    instead of an element called `app-nodes`. The selector can take any valid CSS
    selector. In this case, we use the attribute CSS selector to target an element
    with the `app-nodes` attribute. We do this so we can apply this component onto
    another element.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里更改选择器，使其查找属性 `app-nodes` 而不是名为 `app-nodes` 的元素。选择器可以接受任何有效的 CSS 选择器。在这种情况下，我们使用属性
    CSS 选择器来定位具有 `app-nodes` 属性的元素。我们这样做是为了能够将此组件应用到另一个元素上。
- en: The Nodes component creates our table header, and now we need to create a component
    that handles displaying the individual rows of content. Open the src/app/nodes-row/nodes-row.component.html
    file and replace its content with the code found in the following listing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 节点组件创建我们的表格标题，现在我们需要创建一个处理显示内容单个行的组件。打开 `src/app/nodes-row/nodes-row.component.html`
    文件，并用以下列表中的代码替换其内容。
- en: '**Listing 4.7** Nodes Row component template'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.7** 节点行组件模板'
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The template consists of a set of table cells that display various data. The
    data cells use the special `class` binding to conditionally apply the `table-danger`
    CSS class to a cell if the value is over the 70% threshold. It also contains a
    binding that divides the values to produce a percentage of utilization, and uses
    the Percent pipe to format the value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 模板由一组显示各种数据的表格单元格组成。数据单元格使用特殊的 `class` 绑定，如果值超过 70% 的阈值，则条件性地应用 `table-danger`
    CSS 类到单元格。它还包含一个绑定，将值分割以产生利用率百分比，并使用百分比管道格式化值。
- en: Now hopefully you’re thinking that the component must receive the `node` object
    via an input because, as we already discussed, the Dashboard component holds all
    the data. For that to work, we need to set up our component controller properly
    and also implement the `isDanger()` method that is called in this template. To
    do that, open the src/app/nodes-row/nodes-row.component.ts file and replace its
    contents with what you see in the following listing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可能正在想，组件必须通过输入接收 `node` 对象，因为，正如我们之前讨论的，仪表板组件持有所有数据。为了使其工作，我们需要正确设置我们的组件控制器，并实现在此模板中调用的
    `isDanger()` 方法。为此，打开 `src/app/nodes-row/nodes-row.component.ts` 文件，并用以下列表中的内容替换其内容。
- en: '**Listing 4.8** Nodes Row component controller'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.8** 节点行组件控制器'
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We want to use the attribute selector for this component as well, so update
    the selector accordingly. Then we set up the `node` property as an input so that
    we can bind values into this component, and implement the `isDanger()` method
    to calculate whether the usage exceeds the 70% threshold we’ve set.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想使用属性选择器来为这个组件，因此相应地更新选择器。然后我们设置 `node` 属性作为输入，以便我们可以将值绑定到这个组件中，并实现 `isDanger()`
    方法来计算使用是否超过我们设定的 70% 阈值。
- en: This component doesn’t have any content insertion, because it only describes
    a table row. But because we’ll use it more than once, it was prudent to abstract
    it into its own component. This makes it a perfect example of a Display component
    that modifies its own display based on the data that’s provided as an input.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件没有内容插入，因为它只描述了一个表格行。但由于我们会多次使用它，因此将其抽象成一个独立的组件是谨慎的。这使得它成为一个完美的例子，即一个显示组件根据提供的输入数据修改其显示。
- en: Now we can see these two components in action. Open the src/app/dashboard/dashboard.component.html
    file and add the code in the following listing to the bottom of the template (don’t
    remove anything—add it).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到这两个组件在行动中的效果。打开 `src/app/dashboard/dashboard.component.html` 文件，并将以下列表中的代码添加到模板的底部（不要删除任何内容——添加它）。
- en: '**Listing 4.9** Dashboard using the Nodes and Nodes Row components'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.9** 使用节点和节点行组件的仪表板'
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The dashboard now implements another section that contains the two cluster tables.
    Because we used the attribute selector for the Nodes component on the table element,
    it will apply the component template inside the table. That will insert the table
    head elements that are in the Nodes component template, but it also contains the
    NgContent insertion point.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板现在实现了另一个包含两个集群表格的部分。因为我们使用了属性选择器来定位表格元素上的节点组件，所以它将在表格内部应用组件模板。这将插入节点组件模板中的表格头元素，但它也包含
    NgContent 插入点。
- en: The table has a child element, the table row element, and the Nodes Row component
    is applied to that row. It also has `ngFor` to loop over all the nodes in a given
    cluster, so there will be three instances of it created per table. Finally, the
    table row also has a binding to capture the specific node value. The table rows
    show several distinct Angular capabilities working together to easily iterate
    over a list and display a table row that is abstracted into a component.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表格有一个子元素，即表格行元素，节点行组件应用于该行。它还有一个 `ngFor` 来遍历给定集群中的所有节点，因此每个表格将创建三个实例。最后，表格行还有一个绑定来捕获特定的节点值。表格行显示了几个不同的
    Angular 功能协同工作，以便轻松迭代列表并显示抽象为组件的表格行。
- en: We’ve injected content into one place, but what if we want to have multiple
    insertion points? We can do that too by naming our insertion points. To demonstrate,
    let’s replace the way we bind the title and description of the Metric component
    with child elements.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在一个地方注入了内容，但如果我们想有多个插入点怎么办？我们可以通过命名我们的插入点来实现这一点。为了演示，让我们用子元素替换我们绑定度量组件标题和描述的方式。
- en: Open src/app/metric/metric.component.html and update it to reflect the code
    in the following listing. We can use multiple NgContent elements by adding an
    attribute that has a CSS selector to use for targeting.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/metric/metric.component.html` 并更新它以反映以下列表中的代码。我们可以通过添加一个具有 CSS 选择器的属性来使用多个
    NgContent 元素，用于定位。
- en: '**Listing 4.10** Metric component template with content projection'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.10** 具有内容投影的度量组件模板'
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ve replaced the interpolation bindings with an NgContent element, and in
    both cases it has a `select` attribute. This is a CSS selector that Angular will
    look for while rendering to determine what content to insert where. In this case,
    we’re expecting to have two elements, `metric-title` and `metric-description`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用 NgContent 元素替换了插值绑定，在两种情况下它都有一个 `select` 属性。这是一个 CSS 选择器，Angular 在渲染时会查找它以确定要插入什么内容。在这种情况下，我们期望有两个元素，`metric-title`
    和 `metric-description`。
- en: That means the Metric component needs to have two child elements by those names
    to properly display that content, but if it’s missing, it will be blank. You could
    use other CSS selectors, and it would locate the elements based on those selectors,
    such as a class name or attribute.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着度量组件需要通过这些名称有两个子元素来正确显示该内容，但如果缺少这些子元素，它将显示为空白。您可以使用其他 CSS 选择器，并且它将根据这些选择器定位元素，例如类名或属性。
- en: 'We should also remove the title and description inputs from the component,
    so open src/app/metric/metric.component.ts and remove these two lines:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该从组件中移除标题和描述输入，因此打开 `src/app/metric/metric.component.ts` 并删除这两行：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we need to update our Dashboard component to use these new elements instead
    of binding directly to properties, because it will throw errors after removing
    them from the Metric component. Open src/app/dashboard/dashboard.component.html
    and modify the section, as you see in the following listing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的仪表板组件，使用这些新元素而不是直接绑定到属性，因为从度量组件中移除它们后，它将抛出错误。打开 src/app/dashboard/dashboard.component.html
    并修改部分，如下所示。
- en: '**Listing 4.11** Projecting metric information into the component'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4.11** 将度量信息投影到组件中'
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see here, we’ve replaced the `title` and `description` bindings with
    custom elements by the names we declared in our NgContent select attribute. The
    resulting UI appears the same, but it does put the elements in the insertion points
    as they are, so you could have nested more markup inside of the elements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，我们已经用我们通过 NgContent 选择属性声明的名称替换了 `title` 和 `description` 绑定，使用自定义元素。结果的用户界面看起来相同，但它确实将元素按照它们的位置插入，因此您可以在元素内部嵌套更多的标记。
- en: Now if you run the code, you’ll get a compilation error from Angular. It will
    try to parse these new elements, recognize that they’re not registered components,
    and throw an error. We can fix that by setting some configuration in the App module
    that tells Angular not to get upset about finding an element it doesn’t understand.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您运行代码，您将收到 Angular 的编译错误。它将尝试解析这些新元素，识别出它们不是已注册的组件，并抛出错误。我们可以通过在 App 模块中设置一些配置来修复这个问题，告诉
    Angular 不要对找到它不理解元素感到不安。
- en: 'Open the src/app/app.module.ts file and make two small changes. The first is
    to import the `NO_ERRORS_SCHEMA` object from `@angular/core`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/app/app.module.ts 文件并做两个小的修改。第一个是导入 `NO_ERRORS_SCHEMA` 对象从 `@angular/core`：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then you’ll add a new property to the NgModule definition called `schemas`.
    Add it after the `bootstrap` property, as you see here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将在 NgModule 定义中添加一个名为 `schemas` 的新属性。在 `bootstrap` 属性之后添加它，如下所示：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Angular will now disable throwing errors on unknown elements and allow you to
    create content insertion points based on element names. Alternatively, you could
    have used other CSS selectors for a class or attribute and it wouldn’t have required
    this schema fix. I find elements to be more accessible and clearer in many cases,
    so I still recommend doing this. You only lose the error handling of unknown component
    names, which usually helps to catch typos in your markup.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 现在将禁用对未知元素的错误抛出，并允许您根据元素名称创建内容插入点。或者，您可以使用其他 CSS 选择器（如类或属性）而不需要这个模式修复。我发现元素在许多情况下更易于访问且更清晰，所以我仍然建议这样做。您唯一失去的是未知组件名称的错误处理，这通常有助于捕获您的标记中的错误。
- en: Content projection is powerful and quite useful for components that fit the
    role of display components. As you saw, you can use named or unnamed content insertion
    points to include markup provided into your component template, all by using the
    NgContent element.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影功能强大且非常有用，适用于充当显示组件角色的组件。如您所见，您可以使用命名或未命名的内容插入点来包含提供给组件模板的标记，所有这些只需使用 NgContent
    元素即可。
- en: That wraps up the first chapter about components, and in the next chapter we’ll
    dig into more advanced topics, like how to optimize change detection and watch
    for changes in our inputs.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于组件的第一章，在下一章中，我们将深入探讨更高级的主题，例如如何优化变更检测并监视输入的变化。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first chapter on components, you’ve learned a lot about the foundations
    of components and many useful ways they can be constructed for different purposes.
    Components are the building blocks of any Angular application, and every other
    feature of Angular stems from them in some way. We’ve covered
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本关于组件的第一章中，您学到了很多关于组件基础和许多有用的构建不同目的组件的方法。组件是任何 Angular 应用程序的构建块，Angular 的其他每个功能都以某种方式源自它们。我们已经涵盖了
- en: Components are self-contained elements that include a component class, a template
    implemented in HTML, and associated CSS that styles the component.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是包含组件类、用 HTML 实现的模板以及与组件相关联的 CSS（用于设置组件样式）的独立元素。
- en: Components can play various roles inside an application. The roles are what
    I call app, display, data, and routing components. Although they’re not hard-and-fast
    rules, it’s best to design your components to tackle a single set of tasks to
    keep them focused.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可以在应用程序内部扮演各种角色。这些角色是我所说的应用程序、显示、数据和路由组件。尽管它们不是铁的规则，但最好设计您的组件以处理一组单独的任务，以保持它们的专注。
- en: The `@Component` decorator has a number of configuration capabilities, and though
    you won’t likely use them all in the same component, you’ll certainly need to
    harness most of them at some point.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component`装饰器具有多种配置能力，尽管你不太可能在同一个组件中使用它们全部，但你肯定会在某个时候需要利用其中大部分。'
- en: I talked about how to pass data into a component using input properties defined
    using the `Input` decorator or the `inputs` property. You also saw that input
    properties aren’t available in the component class’s constructor method, but are
    available in the NgOnInit component lifecycle event handler.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我谈到了如何使用`Input`装饰器或`inputs`属性定义的输入属性将数据传递给组件。你也看到了输入属性在组件类的构造方法中不可用，但在NgOnInit组件生命周期事件处理器中可用。
- en: Components sometimes need to accept additional markup and display it inside
    the component called *content projection*. You saw how to use NgContent to insert
    external content into your component.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件有时需要接受额外的标记并在组件内部显示它，这被称为*内容投影*。你看到了如何使用NgContent将外部内容插入到你的组件中。
