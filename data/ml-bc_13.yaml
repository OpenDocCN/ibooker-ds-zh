- en: Appendix D. Introduction to Pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 D. Pandas 简介
- en: We don’t expect any Pandas knowledge from the readers of this book. However,
    we use it extensively throughout the book. When we do, we try to explain the code,
    but it’s not always possible to cover everything in detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不期望本书的读者具备 Pandas 知识。然而，我们在整本书中广泛使用它。当我们这样做时，我们尝试解释代码，但并不总是能够详细涵盖所有内容。
- en: In this appendix, we give a more in-depth introduction to Pandas, covering all
    the features we use in the chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们更深入地介绍了 Pandas，涵盖了我们在章节中使用到的所有功能。
- en: D.1 Pandas
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.1 Pandas
- en: Pandas is a Python library for working with tabular data. It’s a popular and
    convenient tool for data manipulation. It’s especially useful when preparing data
    for training machine learning models.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 是一个用于处理表格数据的 Python 库。它是数据操作中流行且方便的工具。它在准备数据以训练机器学习模型时特别有用。
- en: 'If you use Anaconda, it already has Pandas preinstalled. If not, install it
    with `pip`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Anaconda，它已经预装了 Pandas。如果没有，请使用 `pip` 安装：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To experiment with Pandas, let’s create a notebook called appendix-d-pandas
    and use it for running the code from this appendix.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验 Pandas，让我们创建一个名为 appendix-d-pandas 的笔记本，并使用它来运行这个附录中的代码。
- en: 'First, we need to import it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入它：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like with NumPy, we follow a convention and use an alias, `pd`, instead of the
    full name.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NumPy 一样，我们遵循一个约定，并使用别名 `pd` 而不是全名。
- en: 'We start by exploring Pandas from its core data structures: DataFrames and
    Series.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Pandas 的核心数据结构开始探索：DataFrame 和 Series。
- en: D.1.1 DataFrame
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1.1 DataFrame
- en: 'In Pandas, a *DataFrame* is simply a table: a data structure with rows and
    columns (figure D.1).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pandas 中，*DataFrame* 简单来说就是一个表格：一个具有行和列的数据结构（图 D.1）。
- en: '![](../Images/D-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-01.png)'
- en: 'Figure D.1 A DataFrame in Pandas: a table with five rows and eight columns'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.1 Pandas 中的 DataFrame：一个包含五行八列的表格
- en: 'To create a DataFrame, we first need to create some data that we’ll put in
    the table. It can be a list of lists with some values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 DataFrame，我们首先需要创建一些我们将放入表中的数据。它可以是包含一些值的列表列表：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This data is taken from the price-prediction dataset we use in chapter 2: we
    have some car characteristics like model, make, year of manufacture, and transmission
    type.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据来自我们在第 2 章使用的价格预测数据集：我们有一些汽车特征，如型号、制造商、制造年份和变速类型。
- en: 'When creating a DataFrame, we need to know what each of the columns contains,
    so let’s create a list with column names:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 DataFrame 时，我们需要知道每一列包含什么，所以让我们创建一个包含列名的列表：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we’re ready to create a DataFrame from it. For that, we use `pd.DataFrame`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好从它创建一个 DataFrame。为此，我们使用 `pd.DataFrame`：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It creates a DataFrame with five rows and eight columns (figure D.1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个包含五行八列的 DataFrame（图 D.1）。
- en: 'The first thing we can do with a DataFrame is look at the first few rows in
    the data to get an idea of what’s inside. For that, we use the `head` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 DataFrame 做的第一件事是查看数据的前几行，以了解里面的内容。为此，我们使用 `head` 方法：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It shows the first two rows of the DataFrame. The number of rows to display
    is controlled by the `n` parameter (figure D.2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了 DataFrame 的前两行。显示的行数由 `n` 参数控制（图 D.2）。
- en: '![](../Images/D-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-02.png)'
- en: Figure D.2 Previewing the content of a DataFrame with `head`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.2 使用 `head` 预览 DataFrame 的内容
- en: 'Alternatively, we can use a list of dictionaries to create a DataFrame:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用字典列表来创建一个 DataFrame：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, we don’t need to specify column names: Pandas automatically takes
    them from the fields of the dictionaries.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要指定列名：Pandas 会自动从字典的字段中获取它们。
- en: D.1.2 Series
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1.2 Series
- en: Each column in a DataFrame is a *Series*—a special data structure for containing
    values of one type. In a way, it’s quite similar to one-dimensional NumPy arrays.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 中的每一列都是一个 *Series*——一个用于包含单一类型值的特殊数据结构。在某种程度上，它与一维 NumPy 数组非常相似。
- en: 'We can access the values of a column in two ways. First, we can use the dot
    notation (figure D.3, A):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式访问列的值。首先，我们可以使用点符号（图 D.3，A）：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The other way is to use brackets notation (figure D.3, B):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是使用括号符号（图 D.3，B）：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/D-03a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-03a.png)'
- en: (A) The dot notation
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 点符号
- en: '![](../Images/D-03b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-03b.png)'
- en: (B) The brackets notation
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 括号符号
- en: 'Figure D.3 Two ways of accessing a column of a DataFrame: (A) the dot notation
    and (B) the brackets notation'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.3 访问 DataFrame 列的两种方式：（A）点符号和（B）括号符号
- en: 'The result is exactly the same: a Pandas Series with the values from the Make
    column.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果完全相同：一个包含制造商列值的 Pandas Series。
- en: 'If a column name contains spaces or other special characters, then we can use
    only the brackets notation. For example, to access the Engine HP column, we can
    use only brackets:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列名包含空格或其他特殊字符，则我们只能使用方括号表示法。例如，要访问 Engine HP 列，我们只能使用方括号：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The bracket notation is also more flexible. We can keep the name of a column
    in a variable and use it to access its content:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示法也更加灵活。我们可以将列名保存在变量中，并使用它来访问其内容：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we need to select a subset of columns, we again use brackets but with a
    list of names instead of a single string:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要选择列的子集，我们再次使用方括号，但使用名称列表而不是单个字符串：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This returns a DataFrame with only three columns (figure D.4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个仅包含三个列的 DataFrame（图 D.4）。
- en: '![](../Images/D-04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-04.png)'
- en: Figure D.4 To select a subset of columns of a DataFrame, use brackets with a
    list of names.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.4 要选择 DataFrame 的列子集，请使用带有名称列表的方括号。
- en: 'To add a column to a DataFrame, we also use the brackets notation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 DataFrame 中添加列，我们同样使用方括号表示法：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have five rows in the DataFrame, so the list with values should also have
    five values. As a result, we have another column, id (figure D.5).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 中有五行，因此值列表也应该有五个值。结果，我们又有了一个新列，id（图 D.5）。
- en: '![](../Images/D-05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-05.png)'
- en: Figure D.5 To add a new column, use the brackets notation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.5 要添加新列，请使用方括号表示法。
- en: 'In this case, id didn’t exist, so we appended a new column to the end of the
    DataFrame. If id exists, then this code overwrites the existing values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，id 不存在，因此我们在 DataFrame 的末尾添加了一个新列。如果 id 存在，则此代码将覆盖现有值：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the content of the id column changes (figure D.6).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 id 列的内容发生了变化（图 D.6）。
- en: '![](../Images/D-06.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-06.png)'
- en: Figure D.6 To change the content of a column, use the brackets notation as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.6 要更改列的内容，也请使用方括号表示法。
- en: 'To delete a column, use the `del` operator:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除列，请使用 `del` 操作符：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After running it, this column disappears from the DataFrame.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，此列将从 DataFrame 中消失。
- en: D.1.3 Index
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1.3 索引
- en: Both DataFrame (figure D.7, A) and Series (figure D.7, B) have numbers on the
    left; these numbers are called an *index*. The index describes how we can access
    rows from a DataFrame (or a Series).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame（图 D.7，A）和 Series（图 D.7，B）的左侧都有数字；这些数字被称为*索引*。索引描述了如何从 DataFrame（或
    Series）中访问行。
- en: '![](../Images/D-07.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-07.png)'
- en: Figure D.7 Both DataFrame and Series have an index—the numbers on the left.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.7 DataFrame 和 Series 都有一个索引—左侧的数字。
- en: 'We can get the index of a DataFrame using the `index` property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `index` 属性来获取 DataFrame 的索引：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because we didn’t specify the index when creating a DataFrame, it uses the
    default one, a series of autoincrementing numbers starting from 0:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在创建 DataFrame 时没有指定索引，它使用了默认的索引，即从 0 开始的自动递增数字序列：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The index behaves in the same way as a Series object, so everything that works
    for Series also works for the index.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的行为与 Series 对象相同，因此适用于 Series 的所有操作也适用于索引。
- en: 'Although a Series has only one index, a DataFrame has two: one for accessing
    rows, and the other for accessing columns. We already used Index for columns,
    when selecting individual columns from the DataFrame:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个 Series 只有一个索引，但一个 DataFrame 有两个：一个用于访问行，另一个用于访问列。当我们从 DataFrame 中选择单个列时，我们已经使用了
    Index：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Uses the column index to get the Make column
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用列索引获取 Make 列
- en: 'To get the column names, we use the `columns` property (figure D.8):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取列名，我们使用 `columns` 属性（图 D.8）：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/D-08.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-08.png)'
- en: Figure D.8 The `columns` property contains the column names.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.8 `columns` 属性包含列名。
- en: D.1.4 Accessing rows
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1.4 访问行
- en: 'We can access rows in two ways: using `iloc` and `loc`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式访问行：使用 `iloc` 和 `loc`。
- en: 'First, let’s start with `iloc`. We use it to access the rows of a DataFrame
    using their positional numbers. For example, to access the first row of the DataFrame,
    use the index 0:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从 `iloc` 开始。我们使用它通过位置数字访问 DataFrame 的行。例如，要访问 DataFrame 的第一行，请使用索引 0：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns the content of the first row:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回第一行的内容：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To get a subset of rows, pass a list with integers—row numbers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取行子集，请传递一个包含整数的列表—行号：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The result is another DataFrame containing only the rows we need (figure D.9).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是另一个仅包含所需行的 DataFrame（图 D.9）。
- en: '![](../Images/D-09.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-09.png)'
- en: Figure D.9 Using `iloc` to access rows of a DataFrame
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.9 使用 `iloc` 访问 DataFrame 的行
- en: We can use `iloc` for shuffling the content of a DataFrame. In our DataFrame,
    we have five rows. So, we can create a list of integers from 0 to 4 and shuffle
    it. Then we can use the shuffled list in `iloc`; this way, we’ll get a DataFrame
    with all the rows shuffled.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`iloc`来洗牌DataFrame的内容。在我们的DataFrame中，我们有五行。因此，我们可以创建一个从0到4的整数列表并对其进行洗牌。然后我们可以使用洗牌后的列表在`iloc`中；这样，我们将得到一个所有行都洗牌的DataFrame。
- en: 'Let’s implement it. First, we create a range of size 5 using NumPy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现它。首先，我们使用NumPy创建一个大小为5的范围：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It creates an array with integers from 0 to 4:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个从0到4的整数数组：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can shuffle this array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对这个数组进行洗牌：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As a result, we get
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we use this array with `iloc` to get the rows in shuffled order:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用这个数组与`iloc`一起按洗牌顺序获取行：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the result, the rows are reordered according to the numbers in `idx` (figure
    D.10).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，行是按照`idx`中的数字重新排序的（图D.10）。
- en: '![](../Images/D-10.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-10.png)'
- en: Figure D.10 Using `iloc` to shuffle the rows of a DataFrame
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.10 使用`iloc`洗牌DataFrame的行
- en: 'This doesn’t change the DataFrame that we have in `df`. But we can reassign
    the `df` variable to the new DataFrame:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会改变我们`df`中已有的DataFrame。但我们可以将`df`变量重新赋值给新的DataFrame：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As a result, `df` now contains a shuffled DataFrame.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`df`现在包含了一个洗牌后的DataFrame。
- en: In this shuffled DataFrame, we can still use `iloc` to get rows by using their
    positional number. For example, if we pass `[0,` `1,` `2]` to `iloc`, we’ll get
    the first three rows (figure D.11).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个洗牌后的DataFrame中，我们仍然可以使用`iloc`通过它们的位号来获取行。例如，如果我们向`iloc`传递`[0, 1, 2]`，我们将得到前三行（图D.11）。
- en: '![](../Images/D-11.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-11.png)'
- en: Figure D.11 When using `iloc`, we get rows by their position.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.11 当使用`iloc`时，我们通过位置来获取行。
- en: 'However, you have probably noticed that the numbers on the left are not sequential
    anymore: when shuffling the DataFrame, we shuffled the index as well (figure D.12).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经注意到左边的数字不再连续了：当洗牌DataFrame时，我们也洗牌了索引（图D.12）。
- en: '![](../Images/D-12.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-12.png)'
- en: 'Figure D.12 When shuffling the rows of a DataFrame, we also change the index:
    it’s no longer sequential.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.12 当洗牌DataFrame的行时，我们也改变了索引：它不再连续。
- en: 'Let’s check the index:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查索引：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It’s different now:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它不同了：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use this index to access rows, we need `loc` instead of `iloc`. For example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此索引来访问行，我们需要`loc`而不是`iloc`。例如：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As a result, we get a DataFrame with rows indexed by 0 and 1—the last row and
    the row in the middle (Figure D.13).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个按0和1索引的DataFrame——最后一行和中间的行（图D.13）。
- en: '![](../Images/D-13.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-13.png)'
- en: Figure D.13 When using `loc`, we get rows using the index, not the position.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.13 当使用`loc`时，我们通过索引而不是位置来获取行。
- en: 'It’s quite different from `iloc`: `iloc` doesn’t use the index. Let’s compare
    them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它与`iloc`非常不同：`iloc`不使用索引。让我们比较一下：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, we also get a DataFrame with two rows, but these are the first
    two rows, indexed by 2 and 4 (figure D.14).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们也得到一个两行的DataFrame，但这些都是前两行，分别按2和4索引（图D.14）。
- en: '![](../Images/D-14.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-14.png)'
- en: Figure D.14 Unlike `loc`, `iloc` gets rows by the position, not index. In this
    case, we get rows at positions 0 and 1 (indexed by 2 and 4, respectively).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.14 与`loc`不同，`iloc`通过位置而不是索引来获取行。在这种情况下，我们获取位置为0和1的行（分别按2和4索引）。
- en: So, `iloc` doesn’t look at the index at all; it uses only the actual position.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`iloc`根本不查看索引；它只使用实际位置。
- en: 'It’s possible to replace the index and set it back to the default one. For
    that, we can use the `reset_index` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以替换索引并将其重置为默认值。为此，我们可以使用`reset_index`方法：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It creates a new DataFrame with a sequential index (figure D.15).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个具有连续索引的新DataFrame（图D.15）。
- en: '![](../Images/D-15.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-15.png)'
- en: Figure D.15 We can reset the index to sequential numbering by using `reset_index`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.15 我们可以通过使用`reset_index`来将索引重置为连续编号。
- en: D.1.5 Splitting a DataFrame
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1.5 分割DataFrame
- en: 'We can also use `iloc` to select subsets of a DataFrame. Suppose we want to
    split a DataFrame into three parts: train, validation, and test. We’ll use 60%
    of data for training (three rows), 20% for validation (one row), and 20% for testing
    (one row):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`iloc`来选择DataFrame的子集。假设我们想要将DataFrame分成三个部分：训练、验证和测试。我们将使用60%的数据进行训练（三行），20%用于验证（一行），20%用于测试（一行）：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For selecting a range of rows, we use the slicing operator (:). It works for
    DataFrames in the same way it works for lists.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择行范围时，我们使用切片操作符（:）。它在DataFrame中的工作方式与在列表中的工作方式相同。
- en: 'Thus, for splitting the DataFrame, we do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于分割DataFrame，我们执行以下操作：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Selects rows for train data
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 选择训练数据行
- en: ❷ Selects rows for validation data
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 选择验证数据行
- en: ❸ Selects rows for test data
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择测试数据行
- en: 'In ❶, we get the train set: `iloc[:n_train]` selects rows from the start of
    the DataFrame until the row before `n_train`. For `n_train=3`, it selects rows
    0, 1, and 2\. Row 3 is not included.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 中，我们得到训练集：`iloc[:n_train]` 从 DataFrame 的开始选择直到 `n_train` 前的行。对于 `n_train=3`，它选择行
    0、1 和 2。行 3 不包括在内。
- en: 'In ❷, we get the validation set: `iloc[n_train:n_train+n_val]` selects rows
    from 3 to 3 + 1 = 4\. It’s not inclusive, so it takes only row 3.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❷ 中，我们得到验证集：`iloc[n_train:n_train+n_val]` 从 3 到 3 + 1 = 4 选择行。它是不包含的，所以它只选择行
    3。
- en: 'In ❸, we get the test set: `iloc[n_train+n_val:]` selects rows from 3 + 1 =
    4 until the end of the DataFrame. In our case, it’s only row 4.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❸ 中，我们得到测试集：`iloc[n_train+n_val:]` 从 3 + 1 = 4 开始选择直到 DataFrame 的末尾。在我们的例子中，它只选择行
    4。
- en: As a result, we have three DataFrames (figure D.16).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个 DataFrame（图 D.16）。
- en: '![](../Images/D-16.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-16.png)'
- en: Figure D.16 Using `iloc` with the colon operator to split the DataFrame into
    train, validation, and test DataFrames
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.16 使用 `iloc` 和冒号运算符将 DataFrame 分割为训练、验证和测试 DataFrame
- en: For more information about slicing in Python, refer to appendix B.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 更多有关 Python 中切片的信息，请参阅附录 B。
- en: We’ve covered the basic Pandas data structures, so now let’s see what we can
    do with them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 Pandas 的基本数据结构，现在让我们看看我们可以用它们做什么。
- en: D.2 Operations
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.2 操作
- en: Pandas is a great tool for data manipulation, and it supports a wide variety
    of operations. We can group these operations into element-wise operations, summarizing
    operations, filtering, sorting, grouping, and more. In this section, we cover
    these operations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 是一个强大的数据处理工具，它支持各种操作。我们可以将这些操作分为逐元素操作、汇总操作、过滤、排序、分组等。在本节中，我们将介绍这些操作。
- en: D.2.1 Element-wise operations
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.1 逐元素操作
- en: In Pandas, Series support *element-wise* operations. Just as in NumPy, element-wise
    operations are applied to each element in a Series, and we get another Series
    as a result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pandas 中，Series 支持 *逐元素* 操作。就像在 NumPy 中一样，逐元素操作应用于 Series 中的每个元素，我们得到另一个 Series
    作为结果。
- en: 'All basic arithmetic operations are element-wise: addition (+), subtraction
    (–), multiplication (*), and division (/). For element-wise operations, we don’t
    need to write any loops: Pandas does it for us.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基本算术运算都是逐元素进行的：加法 (+)、减法 (–)、乘法 (*) 和除法 (/)。对于逐元素操作，我们不需要编写任何循环：Pandas 会为我们完成。
- en: 'For example, we can multiply each element of a Series by 2:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将 Series 的每个元素乘以 2：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The result is another Series with each element multiplied by 2 (figure D.17).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是另一个 Series，每个元素都乘以 2（图 D.17）。
- en: '![](../Images/D-17a.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-17a.png)'
- en: (A) Original Series
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 原始序列
- en: '![](../Images/D-17b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-17b.png)'
- en: (B) Result of multiplication
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 乘法结果
- en: Figure D.17 As with NumPy arrays, all basic arithmetic operations for Series
    are element-wise.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.17 与 NumPy 数组一样，Series 的所有基本算术运算都是逐元素进行的。
- en: 'As with arithmetic, logical operations are also element-wise:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与算术运算一样，逻辑运算也是逐元素进行的：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This expression returns a Boolean Series, with `True` for elements higher than
    2000 (figure D.18).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式返回一个布尔 Series，对于大于 2000 的元素返回 `True`（图 D.18）。
- en: '![](../Images/D-18a.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-18a.png)'
- en: (A) Original Series
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 原始序列
- en: '![](../Images/D-18b.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-18b.png)'
- en: (B) Result
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 结果
- en: 'Figure D.18 Logical operations are applied element-wise: in the results, we
    have `True` for all the elements that satisfy the condition.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.18 逻辑运算逐元素应用：在结果中，对于满足条件的所有元素，我们都有 `True`。
- en: 'We can combine multiple logical operations with logical and (&) or logical
    or (|):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个逻辑运算与逻辑与 (&) 或逻辑或 (|) 结合使用：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The result is also a Series. Logical operations are useful for filtering, which
    we cover next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果也是一个 Series。逻辑运算对于过滤非常有用，我们将在下一节中介绍。
- en: D.2.2 Filtering
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.2 过滤
- en: Often, we need to select a subset of rows according to some criteria. For that,
    we use Boolean operations together with the bracket notation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要根据某些标准选择行的一个子集。为此，我们使用布尔运算和括号表示法。
- en: 'For example, to select all Nissan cars, put the condition inside the brackets:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要选择所有尼桑汽车，将条件放在括号内：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As a result, we have another DataFrame that contains only Nissans (figure D.19).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还有一个只包含尼桑汽车的 DataFrame（图 D.19）。
- en: '![](../Images/D-19.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-19.png)'
- en: Figure D.19 To filter rows, put the condition for filtering inside brackets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.19 要过滤行，将过滤条件放在括号内。
- en: If we need a more complex selection condition, we combine multiple conditions
    with logical operators like and (&) and or (|).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更复杂的筛选条件，我们可以使用逻辑运算符如 and (&) 和 or (|) 组合多个条件。
- en: 'For example, to select cars made after 2000 with automatic transmission, we
    use and (figure D.20):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了选择 2000 年后制造的自动挡汽车，我们使用 and 运算符（图 D.20）：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](../Images/D-20.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-20.png](../Images/D-20.png)'
- en: Figure D.20 To use multiple selection criteria, combine them with logical and
    (&).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.20 要使用多个选择条件，使用逻辑与 (&) 将它们组合起来。
- en: D.2.3 String operations
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.3 字符串操作
- en: 'Although for NumPy arrays it’s possible to do only arithmetic and logical element-wise
    operations, Pandas supports string operations: lowercasing, replacing substrings,
    and all the other operations that we can do on string objects.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于 NumPy 数组来说，只能进行算术和逻辑元素级操作，但 Pandas 支持字符串操作：小写转换、替换子字符串以及所有可以在字符串对象上进行的其他操作。
- en: 'Let’s take a look at `Vehicle_Style`, which is one of the columns in the DataFrame.
    We see some inconsistencies in the data: sometimes names start with lowercase
    letters and sometimes with uppercase ones (figure D.21).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 DataFrame 中的 `Vehicle_Style` 列，它是其中的一个列。我们注意到数据中存在一些不一致性：有时名称以小写字母开头，有时以大写字母开头（图
    D.21）。
- en: '![](../Images/D-21.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-21.png](../Images/D-21.png)'
- en: Figure D.21 The Vehicle_Style column with some inconsistencies in the data
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.21 数据中存在一些不一致性的 Vehicle_Style 列
- en: 'To resolve this, we can make everything lowercase. For usual Python strings,
    we’d use the `lower` function and apply it to all the elements of the series.
    In Pandas, instead of writing a loop, we use the special `str` accessor—it makes
    string operations element-wise and lets us avoid writing a `for` loop explicitly:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以将所有内容转换为小写。对于常规 Python 字符串，我们会使用 `lower` 函数并将其应用于序列的所有元素。在 Pandas
    中，我们不是编写循环，而是使用特殊的 `str` 访问器——它使字符串操作元素级，并允许我们避免显式编写 `for` 循环：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The result is a new Series with all the strings styled in lowercase (figure
    D.22).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新 Series，其中所有字符串都转换为小写（图 D.22）。
- en: '![](../Images/D-22.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-22.png](../Images/D-22.png)'
- en: Figure D.22 To lowercase all strings of a Series, use `lower`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.22 要将 Series 中的所有字符串转换为小写，使用 `lower`。
- en: 'It’s also possible to chain several string operations by using the `str` accessor
    multiple times (figure D.23):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过多次使用 `str` 访问器链式执行多个字符串操作（图 D.23）：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](../Images/D-23.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-23.png](../Images/D-23.png)'
- en: Figure D.23 To replace characters in all strings of a Series, use the `replace`
    method. It’s possible to chain multiple methods together in one line.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.23 要替换 Series 中所有字符串中的字符，使用 `replace` 方法。在一行中可以链式调用多个方法。
- en: Here, we make everything lowercase and replace spaces with underscores, all
    at once.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们一次性将所有内容转换为小写并替换空格为下划线。
- en: 'The column names of our DataFrame are also not consistent: sometimes there
    are spaces, and sometimes there are underscores (figure D.24).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DataFrame 的列名也不一致：有时有空格，有时有下划线（图 D.24）。
- en: '![](../Images/D-24.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-24.png](../Images/D-24.png)'
- en: 'Figure D.24 The DataFrame: column names are not consistent.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.24 DataFrame：列名不一致。
- en: 'We can also use string operations to normalize the column names:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字符串操作来标准化列名：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This line of code returns new names, but it doesn’t change the column names
    of the DataFrame. To modify them, we need to assign the results back to `df.columns`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码返回新的名称，但它不会改变 DataFrame 的列名。要修改它们，我们需要将结果重新赋值给 `df.columns`：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we do so, the column names change (figure D.25).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，列名会改变（图 D.25）。
- en: '![](../Images/D-25.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-25.png](../Images/D-25.png)'
- en: Figure D.25 The DataFrame after we normalized the column names
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.25 标准化列名后的 DataFrame
- en: We can solve such inconsistency problems in all the columns of our DataFrame.
    For that, we need to select all the columns with strings and normalize them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 DataFrame 的所有列中解决这种不一致性问题。为此，我们需要选择所有包含字符串的列并将它们标准化。
- en: To select all strings, we can use the `dtype` property of a DataFrame (figure
    D.26).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有字符串，我们可以使用 DataFrame 的 `dtype` 属性（图 D.26）。
- en: '![](../Images/D-26.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-26.png](../Images/D-26.png)'
- en: Figure D.26 The `dtypes` property returns the types of each column of a DataFrame.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.26 `dtypes` 属性返回 DataFrame 每列的类型。
- en: 'All the strings columns have their dtype set to `object`. So, if we want to
    select them, we use filtering:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符串列的 `dtype` 都设置为 `object`。因此，如果我们想选择它们，我们使用过滤：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That gives us a Series with `object` dtype columns only (figure D.27).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个只包含 `object` 数据类型列的 Series（图 D.27）。
- en: '![](../Images/D-27.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片 D-27](../Images/D-27.png)'
- en: Figure D.27 To get only columns with strings, select the `object` dtype.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.27 要选择只有字符串的列，选择 `object` 数据类型。
- en: 'The actual names are stored in the index, so we need to get them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际名称存储在索引中，因此我们需要获取它们：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This gives us the following column names:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下列名：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can use this list to iterate over string columns and apply the normalization
    for each column separately:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用此列表遍历字符串列，并对每个列分别应用归一化：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is what we have after running it (figure D.28).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行后的结果（如图 D.28 所示）。
- en: '![](../Images/D-28.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-28.png)'
- en: 'Figure D.28 Both column names and values are normalized: names are lowercase,
    and spaces are replaced with underscores.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.28 列名和值都已归一化：名称为小写，空格被下划线替换。
- en: 'Next, we cover another type of operation: summarizing operations.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另一种类型的操作：汇总操作。
- en: D.2.4 Summarizing operations
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.4 汇总操作
- en: Just as we do in NumPy, in Pandas we have element-wise operations that produce
    another Series, as well as summarizing operations that produce a summary—one or
    multiple numbers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 NumPy 中所做的那样，在 Pandas 中我们也有逐元素操作，这些操作产生另一个 Series，以及产生汇总的汇总操作——一个或多个数字。
- en: 'Summarizing operations are quite useful for doing exploratory data analysis.
    For numerical fields, the operations are similar to what we have in NumPy. For
    example, to compute the average of all values in a column, we use the `mean` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 汇总操作对于进行探索性数据分析非常有用。对于数值字段，操作类似于我们在 NumPy 中所拥有的。例如，要计算列中所有值的平均值，我们使用 `mean`
    方法：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Other methods that we can use include
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用的其他方法包括
- en: '`sum`: Computes the sum of all values'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`: 计算所有值的总和'
- en: '`min`: Gets the smallest number in the Series'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`: 获取 Series 中的最小数字'
- en: '`max`: Gets the largest number in the Series'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`: 获取 Series 中的最大数字'
- en: '`std`: Computes the standard deviation'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std`: 计算标准差'
- en: 'Instead of checking these things separately, we can use `describe` to get all
    these values at once:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是单独检查这些内容，我们可以使用 `describe` 一次性获取所有这些值：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It creates a summary with the number of rows, mean, min, and max, as well as
    standard deviation and other characteristics:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个包含行数、平均值、最小值、最大值以及标准差和其他特性的汇总：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we invoke `mean` on the entire DataFrame, it computes the mean value for
    all the numerical columns:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对整个 DataFrame 调用 `mean` 时，它计算所有数值列的平均值：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In our case, we have four numerical columns, so we get the average for each:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有四个数值列，因此我们得到每个的平均值：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Likewise, we can use `describe` on a DataFrame:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在 DataFrame 上使用 `describe`：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Because `describe` already returns a Series, when we invoke it on a DataFrame,
    we get a DataFrame as well (figure D.29).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `describe` 已经返回一个 Series，当我们对 DataFrame 调用它时，我们也会得到一个 DataFrame（如图 D.29 所示）。
- en: '![](../Images/D-29.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-29.png)'
- en: Figure D.29 To get the summary statistics of all numerical features, use the
    `describe` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.29 要获取所有数值特征的汇总统计信息，请使用 `describe` 方法。
- en: D.2.5 Missing values
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.5 缺失值
- en: 'We didn’t focus on it previously, but we have a missing value in our data:
    we don’t know the value of engine_hp for row 2 (figure D.30).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有关注它，但我们的数据中有一个缺失值：我们不知道第 2 行的 engine_hp 值（如图 D.30 所示）。
- en: '![](../Images/D-30.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-30.png)'
- en: Figure D.30 There’s one missing value in our DataFrame.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.30 在我们的 DataFrame 中有一个缺失值。
- en: 'We can see which values are missing using the `isnull` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `isnull` 方法查看哪些值缺失：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method returns a new DataFrame where a cell is True if the corresponding
    value is missing in the original DataFrame (figure D.31).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个新的 DataFrame，其中如果对应的值在原始 DataFrame 中缺失，则单元格为 True（如图 D.31 所示）。
- en: '![](../Images/D-31.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-31.png)'
- en: Figure D.31 To find missing values, use the `isnull` method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.31 要查找缺失值，请使用 `isnull` 方法。
- en: 'However, when we have large DataFrames, looking at all the values is impractical.
    We can easily summarize them by running the `sum` method on the results:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们有大的 DataFrame 时，查看所有值是不切实际的。我们可以通过在结果上运行 `sum` 方法轻松地汇总它们：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It returns a Series with the number of missing values per column. In our case,
    only engine_hp has missing values; others don’t (figure D.32).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 Series，其中包含每列的缺失值数量。在我们的例子中，只有 engine_hp 有缺失值；其他没有（如图 D.32 所示）。
- en: '![](../Images/D-32.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/D-32.png)'
- en: Figure D.32 To find columns with missing values, use `isnull` followed by `sum`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.32 要查找具有缺失值的列，请使用 `isnull` 后跟 `sum`。
- en: 'To replace the missing values with some actual values, we use the `fillna`
    method. For example, we can fill the missing values with zero:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要用一些实际值替换缺失值，我们使用 `fillna` 方法。例如，我们可以用零填充缺失值：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As a result, we get a new Series where NaNs are replaced by 0:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个新的 Series，其中 NaN 被替换为 0：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Alternatively, we can replace it by getting the mean:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过获取平均值来替换它：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, the NaNs are replaced by the average:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，NaN 被平均值替换：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `fillna` method returns a new Series. Thus, if we need to remove the missing
    values from our DataFrame, we need to write the results back:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillna` 方法返回一个新的 Series。因此，如果我们需要从我们的 DataFrame 中删除缺失值，我们需要将结果写回：'
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now we get a DataFrame without missing values (figure D.33).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一个没有缺失值的 DataFrame（图 D.33）。
- en: '![](../Images/D-33.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-33.png)'
- en: Figure D.33 The DataFrame without missing values
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.33 无缺失值的 DataFrame
- en: D.2.6 Sorting
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.6 排序
- en: The operations we covered previously were mostly used for Series. We also can
    perform operations on DataFrames.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的操作主要用于 Series。我们也可以对 DataFrame 执行操作。
- en: 'Sorting is one of these operations: it rearranges the rows in a DataFrame such
    that they are sorted by the values of some column (or multiple columns).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是这些操作之一：它重新排列 DataFrame 中的行，使得它们按某些列（或多个列）的值进行排序。
- en: 'For example, let’s sort the DataFrame by MSRP. For that, we use the `sort_values`
    method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们按 MSRP 对 DataFrame 进行排序。为此，我们使用 `sort_values` 方法：
- en: '[PRE61]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The result is a new DataFrame where rows are sorted from the smallest MSRP (2000)
    to the largest (54990) (figure D.34).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新的 DataFrame，其中行按最小的 MSRP（2000）到最大的（54990）排序（图 D.34）。
- en: '![](../Images/D-34.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-34.png)'
- en: Figure D.34 To sort the rows of a DataFrame, use `sort_values`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.34 要对 DataFrame 的行进行排序，请使用 `sort_values`。
- en: 'If we want the largest values to appear first, we set the `ascending` parameter
    to `False`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望最大的值首先出现，我们将 `ascending` 参数设置为 `False`：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now we have the MSRP of 54990 in the first row and 2000 in the last (figure
    D.35).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有第一行的 MSRP 为 54990，最后一行为 2000（图 D.35）。
- en: '![](../Images/D-35.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-35.png)'
- en: Figure D.35 To sort the rows of a DataFrame in descending order, use `ascending=False`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.35 要按降序对 DataFrame 的行进行排序，请使用 `ascending=False`。
- en: D.2.7 Grouping
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.7 分组
- en: 'Pandas offers quite a few summarizing operations: sum, mean, and many others.
    We previously have seen how to apply them to calculate a summary over the entire
    DataFrame. Sometimes, however, we’d like to do it per group—for example, calculate
    the average price per transmission type.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 提供了许多汇总操作：求和、平均值以及许多其他操作。我们之前已经看到如何将它们应用于整个 DataFrame 的汇总计算。有时，我们可能希望按组进行操作——例如，计算每种变速器的平均价格。
- en: 'In SQL, we’d write something like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，我们会写类似的东西：
- en: '[PRE63]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In Pandas, we use the `groupby` method:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pandas 中，我们使用 `groupby` 方法：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The result is the average price per transmission type:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是每种变速器的平均价格：
- en: '[PRE65]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we’d like to also compute the number of records per each type along with
    the average price, in SQL, we’d add another statement in the `SELECT` clause:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想计算每种类型的记录数以及平均价格，在 SQL 中，我们会在 `SELECT` 子句中添加另一个语句：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In Pandas, we use `groupby` followed by `agg` (short for “aggregate”):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pandas 中，我们使用 `groupby` 后跟 `agg`（代表“聚合”）：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As a result, we get a DataFrame (figure D.36).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个新的 DataFrame（图 D.36）。
- en: '![](../Images/D-36.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/D-36.png)'
- en: Figure D.36 When grouping, we can apply multiple aggregate functions using the
    `agg` method.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.36 在分组时，我们可以使用 `agg` 方法应用多个聚合函数。
- en: Pandas is quite a powerful tool for data manipulation, and it’s often used to
    prepare data before training a machine learning model. With the information from
    this appendix, it should be easier for you to understand the code in this book.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 是一个相当强大的数据处理工具，它通常用于在训练机器学习模型之前准备数据。有了本附录的信息，你应该更容易理解本书中的代码。
