- en: 7 Getting to continuous delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 实现持续交付
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Deploying containers to your Kubernetes cluster
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器部署到您的 Kubernetes 集群
- en: Working with Terraform to configure Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 配置 Kubernetes
- en: Creating an automated deployment pipeline for your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建自动部署管道
- en: Using Bitbucket Pipelines for continuous delivery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bitbucket Pipelines 进行持续交付
- en: In this chapter, we bring an early version of our microservices application
    to production. Having just created an empty Kubernetes cluster in the previous
    chapter, we are now ready to deploy containers to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的微服务应用程序的早期版本部署到生产环境中。在前一章中刚刚创建了一个空的 Kubernetes 集群，我们现在准备好向其部署容器。
- en: 'First, we’ll deploy our MongoDB database and RabbitMQ servers. Then, we’ll
    deploy our first microservice to the Kubernetes cluster: the video-streaming microservice
    we created way back in chapter 2 (you’ve come such a long way since then).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将部署我们的 MongoDB 数据库和 RabbitMQ 服务器。然后，我们将部署我们的第一个微服务到 Kubernetes 集群：我们在第
    2 章中创建的视频流微服务（从那时起您已经走了很长的路）。
- en: After learning how to use Terraform to deploy containers to Kubernetes, we’ll
    wrap up our deployment process in an automated continuous delivery (CD) pipeline.
    At that point, updating our infrastructure and application will be achieved by
    pushing code changes to our hosted code repository. Exciting times!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用 Terraform 将容器部署到 Kubernetes 之后，我们将通过自动化的持续交付（CD）管道来总结我们的部署过程。到那时，通过将代码更改推送到我们的托管代码存储库来实现基础设施和应用程序的更新。令人兴奋的时刻！
- en: If you find this chapter difficult to follow, don’t worry. This chapter and
    the previous one are probably the most difficult chapters in the book, so please
    push through! Following along with the examples is the best way to gain experience.
    At the end of this chapter, your application will be *live* in production, and
    you need to know for yourself how good that feels!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得本章难以理解，请不要担心。本章和前一章可能是本书中最难的两章，所以请坚持下去！跟随示例是获得经验的最佳方式。在本章结束时，您的应用程序将在生产中*上线*，您需要亲自体验这种感觉！
- en: 7.1 New and familiar tools
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 新的和熟悉的工具
- en: This chapter revisits both Kubernetes and Terraform. But now, we’ll use Terraform
    to deploy containers and microservices to our Kubernetes cluster. We are also
    introduced to Bitbucket Pipelines, a hosted service we’ll use to create a CD pipeline
    for our microservices application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重新审视了 Kubernetes 和 Terraform。但现在，我们将使用 Terraform 将容器和微服务部署到我们的 Kubernetes
    集群。我们还介绍了 Bitbucket Pipelines，这是我们用于为微服务应用程序创建 CD 管道的托管服务。
- en: Table 7.1 New and familiar tools in chapter 7
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 第 7 章中的新和熟悉工具
- en: '| Tool | Version | Purpose |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 用途 |'
- en: '| Kubernetes | 1.18.6 | Kubernetes is the computing platform that we’ll use
    to host our microservices in production. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Kubernetes | 1.18.6 | Kubernetes 是我们将用于在生产中托管微服务的计算平台。|'
- en: '| Terraform | 0.12.29 | Terraform allows us to script the creation of cloud
    resources and application infrastructure. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Terraform | 0.12.29 | Terraform 允许我们编写脚本以创建云资源和应用程序基础设施。|'
- en: '| Bitbucket Pipelines | N/A | The hosted service from Atlassian that we’ll
    use for CD to automate the deployment of our application. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Bitbucket Pipelines | N/A | 我们将用于持续交付（CD）以自动化应用程序部署的 Atlassian 提供的托管服务。|'
- en: 7.2 Getting the code
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 获取代码
- en: To follow along with this chapter, you need to download the code or clone the
    repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，您需要下载代码或克隆存储库。
- en: 'Download a zip file of the code from here:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这里下载代码的 zip 文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-7](https://github.com/bootstrapping-microservices/chapter-7)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-7](https://github.com/bootstrapping-microservices/chapter-7)'
- en: 'You can clone the code using Git like this:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Git 如下克隆代码：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-7.git`'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-7.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装和使用 Git 的帮助，请参阅第 2 章。如果您在代码方面遇到问题，请在 GitHub 存储库中记录问题。
- en: 7.3 Continuing to evolve our infrastructure
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 持续演进我们的基础设施
- en: 'In the previous chapter, you had a choice for following along with the examples.
    It went like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您有选择跟随示例的机会。它是这样的：
- en: '*Iteratively evolve our infrastructure while following the examples in chapters
    6 and 7.* We started with chapter-6/example-1 and then progressively copied in
    the code from each new example.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在遵循第6章和第7章的示例的同时，迭代地演进我们的基础设施。* 我们从第6章的/example-1开始，然后逐步复制每个新示例中的代码。'
- en: '*Build fresh infrastructure for each example.* The examples in chapters 6 and
    7 can also be run standalone, so we can easily start our infrastructure from any
    point by jumping into any examples and invoking Terraform.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为每个示例构建新的基础设施。* 第6章和第7章中的示例也可以独立运行，因此我们可以通过跳入任何示例并调用Terraform来轻松地从任何点开始我们的基础设施。'
- en: You might have chosen to follow along using the iterative and evolutionary approach
    (the first option). If so, you can continue to do that in this chapter, where
    the examples are designed to follow on directly from the previous chapter. Continue
    to copy files from each new example into your working directory as you did in
    chapter 6\. If, instead, you are running each example by itself or jumping directly
    to particular examples that interest you (the second option), you can also continue
    to do that in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能选择了使用迭代和演进的方法（第一个选项）。如果是这样，你可以在本章继续这样做，其中示例被设计为直接从上一章继续。继续像在第6章中那样，将每个新示例中的文件复制到你的工作目录中。如果你选择单独运行每个示例或直接跳转到你感兴趣的特定示例（第二个选项），你也可以在本章继续这样做。
- en: Whichever way you work, be sure to change the value of the `app_name` variable
    at the top of variables.tf to a name that is unique to you. This must be unique!
    If you call your application FlixTube, it’s going to overlap with resources that
    myself or other readers of this book have created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种工作方式，请确保将variables.tf文件顶部的`app_name`变量的值更改为仅对你而言独特的名称。这必须是唯一的！如果你将你的应用程序命名为FlixTube，它将与我自己或其他本书读者的资源重叠。
- en: Figure 7.1 illustrates what we’ll implement in this chapter. We’ll create an
    automated deployment pipeline to deploy a MongoDB database server, to deploy a
    RabbitMQ server, and most importantly, to deploy our first microservice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 展示了本章我们将要实现的内容。我们将创建一个自动部署管道来部署一个MongoDB数据库服务器，部署一个RabbitMQ服务器，最重要的是，部署我们的第一个微服务。
- en: '![](../Images/CH07_F01_Davis4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 Davis4](../Images/CH07_F01_Davis4.png)'
- en: Figure 7.1 The continuous delivery (CD) pipeline and application we build in
    this chapter
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 本章构建的持续交付（CD）管道和应用程序
- en: 7.4 Continuous delivery (CD)
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 持续交付（CD）
- en: '*Continuous* *delivery* (CD) is a technique in software development where we
    do frequent automated deployments of our updated code to a production (or testing)
    environment. This is an important aspect of our application because it’s how we
    reliably and frequently deliver features into the hands of our customers. Getting
    feedback from customers is vital to building a product that’s relevant. CD allows
    us to quickly and safely get code changes into production and promotes a rapid
    pace of development.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续交付*（CD）是软件开发中的一种技术，我们频繁地将更新的代码自动部署到生产（或测试）环境中。这是我们应用程序的一个重要方面，因为这是我们可靠且频繁地将功能交付给客户手中的方式。从客户那里获得反馈对于构建相关产品至关重要。CD使我们能够快速且安全地将代码更改部署到生产环境中，并促进快速的开发节奏。'
- en: So far, we have managed to keep our entire deployment process scripted with
    Terraform. That won’t always be the case with more complex production systems,
    but it suffices for our example application and helps to keep things simple. It
    also makes it easier for us to instantiate our deployment process within the CD
    pipeline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设法将整个部署过程脚本化。对于更复杂的生产系统来说，这并不总是如此，但对于我们的示例应用程序来说足够了，并且有助于保持事情简单。它还使我们能够更容易地在CD管道中实例化我们的部署过程。
- en: Figure 7.2 shows you what our CD pipeline will look like by the end of this
    chapter. Pushing code changes to our Bitbucket code repository initiates automated
    deployment. This executes our Terraform code and updates our application that
    is hosted in the Kubernetes cluster.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2展示了到本章结束时我们的CD管道将看起来是什么样子。将代码更改推送到我们的Bitbucket代码仓库将启动自动部署。这执行我们的Terraform代码，并更新托管在Kubernetes集群中的应用程序。
- en: '![](../Images/CH07_F02_Davis4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 Davis4](../Images/CH07_F02_Davis4.png)'
- en: Figure 7.2 With infrastructure as code, we can use code to create our infrastructure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 使用基础设施即代码，我们可以使用代码来创建我们的基础设施。
- en: The Terraform code that we write must be simple and as bullet-proof as possible.
    That’s because, ultimately, it’s more difficult to debug code running in a hosted
    CD pipeline! This is why our deployment code should be simple, have minimal moving
    parts, and be well tested.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 Terraform 代码必须尽可能简单且无懈可击。这是因为，最终，在托管 CD 管道中运行代码的调试会更加困难！这就是为什么我们的部署代码应该是简单的，具有最少的移动部件，并且经过良好的测试。
- en: Like any other code, we’ll test our deployment code on our development workstation
    (or personal computer) before it goes to production. A large part of this chapter
    (and the previous chapter) consists of prototyping and testing our deployment
    pipeline before we get anywhere near CD.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他代码一样，在代码部署到生产环境之前，我们将在我们的开发工作站（或个人电脑）上测试我们的部署代码。本章（以及上一章）的大部分内容都包括在接近持续集成（CD）之前，原型设计和测试我们的部署管道。
- en: If CD in any way sounds complex or difficult, let me reassure you that it is
    not. Continuous delivery, in fact, is little more than the ability to host an
    automatically invoked shell script in the cloud. Our deployment shell script will
    be invoked automatically when we push code changes to our code repository.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CD 似乎很复杂或困难，请让我向你保证，它并不复杂。实际上，持续交付（Continuous Delivery）不过是能够在云中托管一个自动调用的
    shell 脚本的能力。我们的部署 shell 脚本将在我们向代码仓库推送代码更改时自动调用。
- en: Note If you can write a shell script (it’s not difficult), then you can build
    a CD pipeline. As mentioned, CD isn’t difficult; although, what you put in the
    shell script might be.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你能编写 shell 脚本（这并不困难），那么你可以构建一个 CD 管道。如前所述，CD 并不难；尽管如此，你在 shell 脚本中放入的内容可能就是难点。
- en: For the examples in this chapter, we’ll create a deployment shell script and
    invoke Terraform from it to do our deployment. Before we tackle creating the deployment
    shell script and moving it to our CD pipeline, we will first learn how to deploy
    containers to Kubernetes using Terraform. Once we are through that, setting up
    our CD pipeline will be relatively easy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，我们将创建一个部署 shell 脚本，并从中调用 Terraform 来进行部署。在我们着手创建部署 shell 脚本并将其移动到我们的
    CD 管道之前，我们将首先学习如何使用 Terraform 将容器部署到 Kubernetes。一旦我们完成了这一步，设置我们的 CD 管道将会相对容易。
- en: 7.5 Deploying containers with Terraform
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 使用 Terraform 部署容器
- en: In the previous chapter, we learned how to create infrastructure with Terraform.
    We created a private container registry and a Kubernetes cluster. In this chapter,
    we use Terraform again, but this time to deploy containers to our cluster. Before
    we can do that, we must first configure the Kubernetes provider for Terraform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Terraform 创建基础设施。我们创建了一个私有容器注册库和一个 Kubernetes 集群。在本章中，我们再次使用
    Terraform，但这次是为了将容器部署到我们的集群。在我们能够做到这一点之前，我们必须首先为 Terraform 配置 Kubernetes 提供程序。
- en: 7.5.1 Configuring the Kubernetes provider
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 配置 Kubernetes 提供程序
- en: We are now moving to example-1 in the chapter 7 code repository. Depending on
    how you were working in chapter 6 (see section 6.8.1), you can either update your
    working project with the new code or just start fresh with example-1 for this
    chapter. The following listing shows the new code we’ll add to providers.tf to
    configure the Kubernetes provider.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在将第 7 章代码库中的 example-1 作为示例。根据你在第 6 章中的工作方式（参见 6.8.1 节），你可以更新你的工作项目以包含新代码，或者只为本章从头开始使用
    example-1。以下列表显示了我们将添加到 providers.tf 中的新代码，以配置 Kubernetes 提供程序。
- en: Listing 7.1 Setting up the Kubernetes provider (extract from chapter-7/example-1/scripts/providers.tf)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 设置 Kubernetes 提供程序（摘自 chapter-7/example-1/scripts/providers.tf）
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Configures the Kubernetes provider
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ① 配置 Kubernetes 提供程序
- en: ② Fixes the version number of the provider
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ② 修复提供程序的版本号
- en: ③ Sets the connection and authentication details for our Kubernetes cluster
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置 Kubernetes 集群的连接和身份验证细节
- en: You might be interested to know that this is where we configure the connection
    and authentication details for our Kubernetes cluster. In this code file, those
    values are automatically pulled from the other Terraform code file that created
    our cluster (see kubernetes-cluster.tf).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，这就是我们配置 Kubernetes 集群连接和身份验证细节的地方。在这个代码文件中，这些值会自动从创建我们集群的其他 Terraform
    代码文件中提取（参见 kubernetes-cluster.tf）。
- en: You could just as easily replace these values with the details for a cluster
    that you created separately. For instance, you might have created your cluster
    manually in the Azure portal GUI or with the Azure CLI tool. You may have used
    a completely separate Terraform project to create your cluster as well. (We’ll
    talk about separating our code in this way in chapter 11.) Either way, as long
    as you have the connection details for your cluster (like the ones we noted in
    section 6.11.3), then you can use them here to connect to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以用您单独创建的集群的详细信息替换这些值。例如，您可能已经在 Azure 门户 GUI 或使用 Azure CLI 工具手动创建了您的集群。您也可能使用一个完全独立的
    Terraform 项目来创建您的集群。（我们将在第 11 章中讨论以这种方式分离我们的代码。）无论如何，只要您有您集群的连接详细信息（就像我们在第 6.11.3
    节中注意到的那些），您就可以在这里使用它们来连接到它。
- en: If you are following along, you now need to invoke `terraform init`. You need
    to do this regardless of whether you are evolving your working project or starting
    fresh with example-1\. We added a new provider to our Terraform project and the
    `init` command is what downloads the plugin for it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在跟随，您现在需要调用 `terraform init`。无论您是在演进您的工作项目还是从 example-1 开始全新，您都需要这样做。我们向我们的
    Terraform 项目添加了一个新的提供者，而 `init` 命令就是下载其插件的命令。
- en: 7.5.2 Deploying our database
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 部署我们的数据库
- en: The first container we’ll deploy to Kubernetes is for our MongoDB database server.
    Eventually, this is where we’ll host separate databases for each of our microservices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将部署到 Kubernetes 的第一个容器是为我们的 MongoDB 数据库服务器。最终，这将是我们为每个微服务托管单独数据库的地方。
- en: Listing 7.2 shows the Terraform code to deploy a database server to our cluster.
    This script creates a Kubernetes deployment that instantiates a container from
    the public Docker image for MongoDB. It then creates a Kubernetes service that
    makes the deployment accessible by other containers via DNS. This is how other
    containers can connect to our database. You can learn more about Kubernetes concepts
    like deployments and services in the Kubernetes documentation at [https://kubernetes.io/
    docs/concepts/](https://kubernetes.io/docs/concepts/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 显示了将数据库服务器部署到我们的集群的 Terraform 代码。此脚本创建了一个 Kubernetes 部署，从公共 Docker 映像实例化
    MongoDB 容器。然后创建了一个 Kubernetes 服务，通过 DNS 使部署对其他容器可访问。这就是其他容器如何连接到我们的数据库。您可以在 Kubernetes
    文档中了解更多关于 Kubernetes 概念，如部署和服务，[https://kubernetes.io/docs/concepts/](https://kubernetes.io/docs/concepts/)。
- en: Listing 7.2 Deploying your database (chapter-7/example-1/scripts/database.tf)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 部署您的数据库（第 7 章/示例-1/脚本/database.tf）
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Declares a Kubernetes deployment for our MongoDB database server, causing
    the MongoDB container to be instantiated into our Kubernetes cluster
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明一个 Kubernetes 部署用于我们的 MongoDB 数据库服务器，导致 MongoDB 容器在我们的 Kubernetes 集群中实例化
- en: ② Sets metadata for the deployment
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为部署设置元数据
- en: ③ Sets the name of the deployment
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置部署的名称
- en: ④ Labels the deployment
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 标记部署
- en: ⑤ Sets the number of replicas (or copies) to create for pods in this deployment
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 为此部署中的 pod 设置要创建的副本（或副本）数量
- en: ⑥ Attaches the deployment to its pods by matching labels
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 通过匹配标签将部署附加到其 pod
- en: ⑦ Template for pods that are created by this deployment
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 此部署创建的 pod 的模板
- en: ⑧ Sets metadata for each pod
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 为每个 pod 设置元数据
- en: ⑨ Labels the pod
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 标记 pod
- en: ⑩ Specifies details for the single container instantiated in the pod
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 指定在 pod 中实例化的单个容器的详细信息
- en: ⑪ Sets the image from which to instantiate the container
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 设置实例化容器的映像
- en: ⑫ Sets the name of the container
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 设置容器的名称
- en: ⑬ Shows the ports in the container to be exposed; in this case, the default
    port for MongoDB (optional, primarily informational)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 显示要公开的容器端口；在这种情况下，MongoDB 的默认端口（可选，主要用于信息）
- en: ⑭ Declares a Kubernetes service that creates a DNS record so the database is
    accessible by other containers within the cluster
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 声明一个 Kubernetes 服务，创建一个 DNS 记录，以便数据库可以被集群内的其他容器访问
- en: ⑮ Sets the name of the service
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 设置服务的名称
- en: ⑯ Attaches the service to the deployment by matching labels
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 通过匹配标签将服务附加到部署
- en: ⑰ Sets the port that is exposed by this service
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 设置此服务公开的端口
- en: ⑱ Exposes the service to the external world using an Azure load balancer. This
    allocates an externally accessible IP address for the database. We can use this
    to test our deployment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 使用 Azure 负载均衡器将服务暴露给外部世界。这为数据库分配了一个外部可访问的 IP 地址。我们可以使用它来测试我们的部署。
- en: You can see toward the end of listing 7.2 that we attached an Azure load balancer
    to the Kubernetes service to expose our database to the outside world. The real
    purpose of a load balancer is something we’ll talk about in chapters 10 and 11,
    but here, we simply use it to access the database in our cluster from our development
    workstation. This is something we couldn’t do if the container was hidden within
    the cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在列表7.2的末尾，我们将Azure负载均衡器附加到Kubernetes服务上，以便将我们的数据库公开给外界。负载均衡器的真正用途是我们将在第10章和第11章中讨论的，但在这里，我们只是用它来从我们的开发工作站访问集群中的数据库。这是如果我们把容器隐藏在集群内部，我们就无法做到的事情。
- en: From a security perspective, exposing our database like this is a big no-no.
    This means that anyone (including those with nefarious intent) could make changes
    to our database. Be assured that this situation is only temporary! We have only
    exposed our database for testing (which we’ll do in a moment) at this early stage
    in our infrastructure. After testing, we’ll lock it down so that it’s accessible
    only from within the cluster.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，以这种方式公开我们的数据库是绝对不允许的。这意味着任何人（包括那些有恶意意图的人）都可以更改我们的数据库。请放心，这种情况只是暂时的！我们只是在基础设施的早期阶段为了测试（我们将在下一刻进行）而公开了我们的数据库。测试后，我们将将其锁定，使其只能从集群内部访问。
- en: 7.5.3 Preparing for continuous delivery
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 准备持续交付
- en: We are in the middle of prototyping and testing our deployment code on our development
    workstation. In the process, we’ll prepare to run this code in our CD pipeline.
    That means we need our code to run in a fully automated fashion, so we should
    now factor out any human interaction.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发工作站上原型化和测试我们的部署代码。在这个过程中，我们将准备在CD管道中运行此代码。这意味着我们需要我们的代码以完全自动化的方式运行，因此我们现在应该消除任何人工交互。
- en: If you remember back to section 6.11.2, we created an Azure service principal
    that allows our Kubernetes cluster to authenticate with Azure. It needs this so
    that it can create load balancers for our services such as in listing 7.2, where
    we requested an external endpoint for our database service. Then, in section 6.11.3,
    when invoking `terraform apply`, we manually supplied values for the `client_id`
    and `client_secret` variables. For that, we typed in the values from the `appId`
    and `password` fields from our service principal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回想起第6.11.2节，我们创建了一个Azure服务主体，允许我们的Kubernetes集群通过Azure进行身份验证。它需要这样做，以便它可以为我们的服务（如列表7.2中所示）创建负载均衡器。然后，在第6.11.3节中，当调用`terraform
    apply`时，我们手动为`client_id`和`client_secret`变量提供了值。为此，我们输入了从服务主体的`appId`和`password`字段中的值。
- en: Manually typing in values like this doesn’t work in a CD pipeline. This has
    to be automated! It’s also kind of annoying having to constantly type these values
    while we are prototyping our Terraform code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 手动输入这样的值在CD管道中不起作用。这必须自动化！同时，在我们原型化Terraform代码时，不得不不断输入这些值也相当烦人。
- en: 'Now we will set these values through command-line arguments. First, though,
    you must remember the details for your service principal. If the one you created
    in section 6.11.2 is still operational, and you have the details noted down, you
    can reuse that. Otherwise, run through the instructions in section 6.11.2 again
    to create or update your service principal. Then take note of the `appId` and
    `password` fields. Now invoke `terraform apply` for example-1 while setting `client_id`
    and `client_secret` as command-line arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过命令行参数设置这些值。首先，您必须记住您的服务主体的详细信息。如果您在第6.11.2节中创建的服务主体仍然有效，并且您已经记下了这些详细信息，您可以重用它。否则，请再次按照第6.11.2节中的说明创建或更新您的服务主体。然后注意`appId`和`password`字段。现在，在设置`client_id`和`client_secret`为命令行参数的情况下，调用`terraform
    apply`示例-1：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just remember to *replace* the values for `client_id` and `client_secret` with
    the values for your own service principal according to this template:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住将`client_id`和`client_secret`的值替换为您自己的服务主体的值，根据以下模板：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see we also continue to use the `-auto-approve` command-line option
    that we started using in section 6.9.2\. Setting the variables and enabling automatic
    approval puts our Terraform project in a fully automatic mode. No human intervention
    is required, and this means we’ll be able to execute this code completely unattended
    in our CD pipeline.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们继续使用我们在第6.9.2节开始使用的`-auto-approve`命令行选项。设置变量并启用自动批准将我们的Terraform项目置于完全自动模式。无需人工干预，这意味着我们将在CD管道中完全无人值守地执行此代码。
- en: 7.5.4 Testing the new database server
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.4 测试新的数据库服务器
- en: After invoking `terraform apply` in the previous section, you should now have
    a database server running in your Kubernetes cluster. In order to test that our
    database is up, we have attached an Azure load balancer to it (as shown in listing
    7.2). This is a temporary measure so that we can make our database externally
    accessible and test it to be sure that it is working.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中调用 `terraform apply` 之后，你现在应该在你的 Kubernetes 集群中运行一个数据库服务器。为了测试我们的数据库是否启动，我们已将其附加了一个
    Azure 负载均衡器（如列表 7.2 所示）。这是一个临时措施，以便我们可以使我们的数据库对外可访问并测试它以确保其正常工作。
- en: Finding the external IP address
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查找外部 IP 地址
- en: 'To find out the external IP address that’s been allocated to the database service,
    we can either use the Kubernetes CLI tool (Kubectl) or the Kubernetes dashboard
    that we set up earlier (section 6.12). We can use Kubectl to list the services
    we have in our cluster:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出分配给数据库服务的那个外部 IP 地址，我们可以使用 Kubernetes CLI 工具（Kubectl）或我们之前设置的 Kubernetes
    仪表板（第 6.12 节）。我们可以使用 Kubectl 列出我们集群中的服务：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you have trouble using Kubectl and connecting to your cluster, refer back
    to section 6.12.1\. The output looks something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用 Kubectl 和连接到你的集群时遇到麻烦，请参阅第 6.12.1 节。输出看起来可能像这样：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pick out the database service (e.g., the name we gave it in listing 7.2) and
    note the IP address in the `EXTERNAL-IP` column. You can also see the MongoDB
    default port 27017 listed in the `PORT(S)` column. This is the IP address and
    port to access our database from outside the cluster. Alternatively, we can open
    the Kubernetes dashboard (as per section 6.12.3) and navigate to the Services
    section to find these details.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 挑选出数据库服务（例如，我们在列表 7.2 中为其命名的服务）并注意 `EXTERNAL-IP` 列中的 IP 地址。你还可以在 `PORT(S)` 列中看到
    MongoDB 默认端口 27017。这是从集群外部访问我们的数据库的 IP 地址和端口号。或者，我们可以打开 Kubernetes 仪表板（如第 6.12.3
    节所述）并导航到服务部分以找到这些详细信息。
- en: Testing the connection
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试连接
- en: Now using Robo 3T (like in section 4.5.2) or another database viewer, connect
    to your database server with the external IP address that you jotted down for
    it. Make sure you use port number 27017 to connect. If all is well, you should
    be able to connect to your database and view its default content (we haven’t added
    anything specific yet, however).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 Robo 3T（如第 4.5.2 节中所述）或另一个数据库查看器，使用你为其记下的外部 IP 地址连接到你的数据库服务器。确保你使用端口号 27017
    进行连接。如果一切顺利，你应该能够连接到你的数据库并查看其默认内容（然而，我们还没有添加任何特定内容）。
- en: 7.5.5 Deploying and testing RabbitMQ
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.5 部署和测试 RabbitMQ
- en: In the same way as with our database server, but with a slightly different configuration,
    we now move to example-2\. In that, we deploy a RabbitMQ server to our Kubernetes
    cluster.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的数据库服务器类似，但配置略有不同，我们现在转向 example-2。在那里，我们将 RabbitMQ 服务器部署到我们的 Kubernetes
    集群。
- en: Listing 7.3 is similar to listing 7.2\. It creates a Kubernetes deployment that
    instantiates a RabbitMQ server in a container. It creates a Kubernetes service
    that makes the container accessible via DNS within the cluster. Again, we attach
    an Azure load balancer to the Kubernetes service so that we can make it accessible
    from outside the cluster for testing. Then, we can use the RabbitMQ dashboard
    to check that RabbitMQ is functional.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 与列表 7.2 类似。它创建了一个 Kubernetes 部署，在容器中实例化 RabbitMQ 服务器。它创建了一个 Kubernetes
    服务，使容器在集群内部可通过 DNS 访问。同样，我们将 Azure 负载均衡器附加到 Kubernetes 服务上，以便我们可以从集群外部访问它进行测试。然后，我们可以使用
    RabbitMQ 仪表板来检查 RabbitMQ 是否正常工作。
- en: Listing 7.3 Deploying your RabbitMQ server (chapter-7/example-2/scripts/rabbit.tf)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 部署你的 RabbitMQ 服务器（chapter-7/example-2/scripts/rabbit.tf）
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Declares a Kubernetes deployment to deploy our RabbitMQ server. This is what
    instantiates the RabbitMQ container in our Kubernetes cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明一个 Kubernetes 部署以部署我们的 RabbitMQ 服务器。这就是在 Kubernetes 集群中实例化 RabbitMQ 容器的方式。
- en: ② Instantiates the container from the public RabbitMQ image
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从公共 RabbitMQ 镜像实例化容器
- en: ③ Declares a Kubernetes service that creates a DNS record so the RabbitMQ server
    is accessible by other containers within the cluster
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 声明一个 Kubernetes 服务，创建一个 DNS 记录，以便 RabbitMQ 服务器可以被集群内的其他容器访问
- en: ④ Creates an Azure load balancer for the service, which allocates an externally
    accessible IP address for the dashboard. We can use this to test the deployment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为服务创建一个 Azure 负载均衡器，为仪表板分配一个外部可访问的 IP 地址。我们可以使用它来测试部署。
- en: Now run `terraform apply` (with the same command-line arguments as earlier in
    section 7.5.3). Then deploy RabbitMQ to your Kubernetes cluster.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `terraform apply`（使用与第 7.5.3 节中相同的命令行参数）。然后将 RabbitMQ 部署到你的 Kubernetes
    集群。
- en: Again, we have configured our service (the service that exposes the RabbitMQ
    dashboard) to be externally accessible using an Azure load balancer. Now we can
    use Kubectl or the Kubernetes dashboard to find the external IP address that has
    been allocated. Refer back to section 7.5.4 to remember how we did this for our
    database. Take note of the external IP address, and use your browser to open the
    RabbitMQ management dashboard. You can login with the default user name *guest*
    and the default password *guest*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们已经配置了我们的服务（暴露 RabbitMQ 仪表盘的服务）可以通过 Azure 负载均衡器外部访问。现在我们可以使用 Kubectl 或 Kubernetes
    仪表盘来找到已分配的外部 IP 地址。回顾第 7.5.4 节以记住我们是如何为我们的数据库做这件事的。注意外部 IP 地址，并使用您的浏览器打开 RabbitMQ
    管理仪表盘。您可以使用默认用户名 *guest* 和默认密码 *guest* 登录。
- en: For example, if the IP address for your RabbitMQ dashboard is 40.112.161.104,
    then you would point your browser at http://40.112.161.104:15672/. The port number
    for the dashboard is 15672\. However, the IP address for your own service *will
    be different from mine*. Make sure you replace it with the one that was allocated
    to your RabbitMQ instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的 RabbitMQ 仪表盘的 IP 地址是 40.112.161.104，那么你应该将你的浏览器指向 http://40.112.161.104:15672/。仪表盘的端口号是
    15672。然而，你自己的服务的 IP 地址 *将不同于我的*。确保你将其替换为你分配给你的 RabbitMQ 实例的 IP 地址。
- en: 7.5.6 Tightening our security
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.6 加强我们的安全性
- en: 'We have tested our MongoDB and RabbitMQ servers through external endpoints.
    Exposing these servers to the world is like asking for trouble! Now that we have
    tested, let’s remove the external access and tighten our security. This is as
    simple as removing the following line from our scripts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过外部端点测试了我们的 MongoDB 和 RabbitMQ 服务器。将这些服务器暴露给世界就像是在寻找麻烦！现在我们已经测试过了，让我们移除外部访问并加强我们的安全性。这就像从我们的脚本中移除以下行一样简单：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s exactly what we’ll do from example-3 onward. When you update your working
    project with the example-3 code and next invoke `terraform apply`, external access
    to MongoDB and RabbitMQ will be removed, tightening the security for our application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们从 example-3 开始要做的。当你用 example-3 代码更新你的工作项目并接下来调用 `terraform apply` 时，MongoDB
    和 RabbitMQ 的外部访问将被移除，从而加强我们应用程序的安全性。
- en: 7.5.7 What have we achieved?
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.7 我们取得了什么成果？
- en: After creating our Kubernetes cluster in the previous chapter, in this chapter,
    we have now started populating it with containers. After setting up the Kubernetes
    provider for Terraform, we created new Terraform scripts to deploy a MongoDB database
    and a RabbitMQ server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章创建我们的 Kubernetes 集群之后，在这一章中，我们现在开始用容器填充它。在为 Terraform 设置 Kubernetes 提供者之后，我们创建了新的
    Terraform 脚本来部署 MongoDB 数据库和 RabbitMQ 服务器。
- en: We temporarily exposed our servers to the outside world for testing. After testing,
    we tightened our security by removing those external IPs-for security’s sake,
    we don’t want the outside world able to access our internal infrastructure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了测试暂时将服务器暴露给外界。测试完成后，我们通过移除那些外部 IP 地址来加强我们的安全性——出于安全考虑，我们不希望外界能够访问我们的内部基础设施。
- en: 7.6 Deploying our first microservice with Terraform
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 使用 Terraform 部署我们的第一个微服务
- en: We have already deployed some publicly available Docker images to our cluster
    (MongoDB and RabbitMQ). Now, let’s move on to example-3 and deploy our first microservice
    to the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一些公开可用的 Docker 镜像部署到了我们的集群中（MongoDB 和 RabbitMQ）。现在，让我们继续到 example-3 并将我们的第一个微服务部署到集群中。
- en: Although we are still deploying a container from a Docker image, this time the
    image is built from our own private code. Before we can deploy a container from
    it, we must be able to build an image and publish it (just like we practiced in
    chapter 3) to the private container registry that we created in section 6.9 of
    the previous chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们仍然从 Docker 镜像部署容器，但这次镜像是由我们自己的私有代码构建的。在我们能够从它部署容器之前，我们必须能够构建一个镜像并将其（就像我们在第
    3 章中练习的那样）发布到我们在上一章 6.9 节中创建的私有容器注册库。
- en: 7.6.1 Using local variables to compute configuration
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 使用局部变量计算配置
- en: To make things easier and to keep our Terraform code a bit more compact, we’ll
    make use of Terraform *local variables* to compose and share some common configuration
    values within our newest code file video-streaming.tf. This new file is responsible
    for building, publishing, and deploying our video-streaming microservice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情变得更容易，并使我们的 Terraform 代码更加紧凑，我们将使用 Terraform *局部变量* 来在我们的最新代码文件 video-streaming.tf
    中组合和共享一些常见的配置值。这个新文件负责构建、发布和部署我们的视频流微服务。
- en: The next listing is an extract from the new code file. It shows the declaration
    of multiple local variables that we’ll use in the rest of the script.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表是从新的代码文件中摘录的。它显示了我们将用于脚本其余部分的多个本地变量的声明。
- en: Listing 7.4 Using local variables for configuration (extract from chapter-7/example-3/scripts/video-streaming.tf)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 使用本地变量进行配置（摘自第7章/示例3/脚本/video-streaming.tf）
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Sets the name of this deployment service that we use throughout this code
    file
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置我们在这段代码文件中使用的部署服务的名称
- en: ② Sets the connection details for our private container registry. These details
    are pulled from the Terraform file that creates the registry.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置我们私有容器注册库的连接详情。这些详情是从创建注册库的Terraform文件中提取的。
- en: ③ Composes the tag for the video-streaming microservices’ Docker image
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 组合视频流微服务Docker镜像的标签
- en: Note how the `image_tag` local variable is composed of multiple other variables,
    especially the `app_version` variable, which we use to tag each successive image
    with a new version number. The `image_tag` variable is also how we tag our images
    to publish these to our container registry.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`image_tag`本地变量是如何由多个其他变量组成的，特别是`app_version`变量，我们使用它来为每个连续的镜像添加一个新的版本号。`image_tag`变量也是我们标记图像以发布到容器注册库的方式。
- en: 7.6.2 Building and publishing the Docker image
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 构建和发布Docker镜像
- en: 'Now, let’s look at the Terraform code that builds and publishes the Docker
    image for our video-streaming microservice. This code has three tasks:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构建并发布我们视频流微服务Docker镜像的Terraform代码。这段代码有三个任务：
- en: Building the image
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Logging into the container registry
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到容器注册库
- en: Pushing the image to the container registry
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像推送到容器注册库
- en: You learned how to do all these things in chapter 3\. Here, we’ll automate this
    with Terraform.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第三章学习了如何做所有这些事情。在这里，我们将使用Terraform来自动化这个过程。
- en: In listing 7.5, we continue to look at the code in video-streaming.tf. While
    there is a Docker provider available to use with Terraform, unfortunately, it
    doesn’t have the ability to do the tasks we need. That’s why we are making use
    of Terraform’s catch-all `null_resource` and its `local-exec` feature to invoke
    the Docker commands that we need.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7.5中，我们继续查看video-streaming.tf中的代码。虽然有一个Docker提供程序可以与Terraform一起使用，但不幸的是，它没有执行我们需要的任务的能力。这就是为什么我们使用Terraform的万能`null_resource`及其`local-exec`功能来调用我们需要的Docker命令。
- en: We can use `null_resource` to create Terraform resources that don’t have any
    particular resource type. We use `local-exec` to invoke commands on the local
    computer. If this listing looks like a big dirty hack, especially the use of `timestamp`
    to force the Docker image to build, well that’s because it is a big dirty hack!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`null_resource`来创建没有特定资源类型的Terraform资源。我们使用`local-exec`在本地计算机上调用命令。如果这个列表看起来像一个大杂烩，特别是使用`timestamp`来强制构建Docker镜像，那么确实是因为这是一个大杂烩！
- en: We are using this as a workaround to keep things simple and keep our entire
    deployment process in Terraform. Long term, we don’t want code like this in production.
    Eventually, we’ll migrate away from this hacky starting point and implement a
    much cleaner solution. But you’ll have to wait until chapter 11 to see what that
    looks like.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个作为权宜之计来简化事情，并保持我们的整个部署过程在Terraform中。从长远来看，我们不希望在生产环境中使用这样的代码。最终，我们将从这个权宜之计迁移出去，并实施一个更干净的解决方案。但你必须等到第11章才能看到那是什么样子。
- en: Listing 7.5 Build and publish a Docker image (extract from chapter-7/example-3/scripts/video-streaming.tf)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 构建和发布Docker镜像（摘自第7章/示例3/脚本/video-streaming.tf）
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Declares our Docker commands using Terraform’s null_resource
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用Terraform的null_resource声明我们的Docker命令
- en: ② Forces our commands to always be invoked
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ② 强制我们的命令始终被调用
- en: ③ Builds our Docker image
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 构建我们的Docker镜像
- en: ④ Sets a dependency on the previous command because we can’t publish our image
    until after we build it
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置对前一个命令的依赖，因为我们不能在构建镜像之后发布我们的镜像
- en: ⑤ Invokes a command to authenticate with our container registry
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 调用一个命令来对我们的容器注册库进行认证
- en: ⑥ Authenticates with our registry
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 使用我们的注册库进行认证
- en: ⑦ Pushes the image to our registry
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将镜像推送到我们的注册库
- en: I’ll be the first to admit that our use (some would say, abuse) of `null_resource`
    in listing 7.5 is not ideal. If only the Docker provider supported build and push
    operations directly (why doesn’t it?), we wouldn’t need this ugly code! Unfortunately,
    this is the way it is at the moment, but maybe in the future, there will be a
    more elegant solution. In chapter 11, we’ll talk about fixing this when we move
    away from the *mono-repo* (single code repository) structure towards a *multi-repo*
    (many code repositories) structure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我们在列表 7.5 中对 `null_resource` 的使用（有些人可能会说是滥用）并不理想。如果 Docker 提供商直接支持构建和推送操作（为什么它不支持？），我们就不需要这段丑陋的代码了！不幸的是，目前就是这样，但也许在将来，会有一个更优雅的解决方案。在第
    11 章中，我们将讨论当我们从 *mono-repo*（单个代码仓库）结构转向 *multi-repo*（多个代码仓库）结构时如何解决这个问题。
- en: 7.6.3 Authentication with the container registry
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.3 使用容器注册库进行认证
- en: After building and publishing the Docker image for our microservice, we must
    now give the cluster permission to pull the image from the container registry.
    You can see how this is accomplished in listing 7.6 as we continue to look at
    video-streaming.tf. In the listing, we create a Kubernetes secret to contain our
    Docker credentials. This is a secure way to store sensitive data in our cluster.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和发布我们的微服务的 Docker 镜像之后，我们必须现在授予集群从容器注册库拉取镜像的权限。您可以在列表 7.6 中看到这是如何完成的，我们继续查看
    video-streaming.tf。在列表中，我们创建了一个 Kubernetes 机密来包含我们的 Docker 凭据。这是在集群中存储敏感数据的一种安全方式。
- en: Listing 7.6 Authentication with the container registry (extract from chapter-7/example-3/scripts/video-streaming.tf)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 使用容器注册库进行认证（摘自第 7 章示例 3 脚本/video-streaming.tf）
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Defines more local variables for use in this code file
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义更多局部变量以供此代码文件使用
- en: ② Creates a variable that contains the authentication details for our container
    registry
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个包含我们的容器注册库认证详情的变量
- en: ③ Declares a Kubernetes secret to securely store our authentication credentials
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 声明一个 Kubernetes 机密以安全地存储我们的认证凭据
- en: ④ Sets the data for the secret
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置机密的数据
- en: ⑤ Sets the type of the secret
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置机密的类型
- en: Again, we have written code that feels rather awkward. It would be nice if the
    Docker providers had a more elegant way to express this, and maybe in the future,
    they will provide that.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们编写的代码感觉相当尴尬。如果 Docker 提供商有一个更优雅的方式来表达这一点，那会很好，也许在将来，他们会提供这样的解决方案。
- en: 7.6.4 Deploying the video-streaming microservice
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.4 部署视频流微服务
- en: We now have the Terraform code to build and publish our video-streaming microservice.
    We also have a Kubernetes secret that contains our registry credentials. Now we
    can write the code to deploy our microservice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构建和发布我们的视频流微服务的 Terraform 代码。我们还拥有包含我们的注册库凭据的 Kubernetes 机密。现在我们可以编写部署我们的微服务的代码了。
- en: Listing 7.7 shows the remainder of the code in video-streaming.tf. The rest
    of the file is similar to the code we saw in listings 7.2 and 7.3, which deploy
    containers for MongoDB and RabbitMQ. We have a Kubernetes deployment that instantiates
    a container for our video-streaming microservices and a Kubernetes service to
    make it accessible by DNS within the cluster. Also, yet again, we attach an Azure
    load balancer to the Kubernetes service to make it externally accessible so we
    can test our microservice in the cluster from our development workstation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 展示了 video-streaming.tf 中的剩余代码。文件的其他部分与我们在列表 7.2 和 7.3 中看到的代码类似，这些代码部署了
    MongoDB 和 RabbitMQ 的容器。我们有一个 Kubernetes 部署，它实例化了一个用于我们的视频流微服务的容器，以及一个 Kubernetes
    服务，使其在集群内部可通过 DNS 访问。此外，我们再次将 Azure 负载均衡器附加到 Kubernetes 服务上，以便使其外部可访问，这样我们就可以从我们的开发工作站测试集群中的微服务。
- en: The major difference here is that the image for our microservice is private
    and pulled from our own private container registry, whereas MongoDB and RabbitMQ
    are public images. To facilitate this, we have added an explicit dependency (using
    `depends_on` that you can see in the listing). This dependency causes our Docker
    image to be built and published prior to the creation of the Kubernetes deployment.
    Also, note how the registry credentials are provided via `image_pull_secrets`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是，我们的微服务的镜像私有，并从我们自己的私有容器注册库中拉取，而 MongoDB 和 RabbitMQ 是公共镜像。为了便于这样做，我们添加了一个显式的依赖项（使用列表中可以看到的
    `depends_on`）。这个依赖项导致我们的 Docker 镜像在创建 Kubernetes 部署之前被构建和发布。此外，请注意，注册库凭据是通过 `image_pull_secrets`
    提供的。
- en: Listing 7.7 Deploying the video-streaming microservice (extract from chapter-7/example-3/scripts/video-streaming.tf)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 部署视频流微服务（摘自第 7 章示例 3 脚本/video-streaming.tf）
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Declares a Kubernetes deployment to deploy our video-streaming microservice.
    This instantiates the container for the microservice into our Kubernetes cluster.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明了一个Kubernetes部署以部署我们的视频流微服务。这将在我们的Kubernetes集群中实例化微服务的容器。
- en: ② Creates a dependency that causes our Docker image to be built and published
    before the container is deployed
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建了一个依赖项，导致我们的Docker镜像在容器部署之前构建和发布
- en: ③ Uses local variables to share configuration across this code file
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用局部变量在此代码文件中共享配置
- en: ④ The image is pulled from our private container registry.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 图片是从我们的私有容器注册库中拉取的。
- en: ⑤ Specifies authentication credentials for our container registry so Kubernetes
    can pull the image
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 为我们的容器注册库指定了身份验证凭据，以便Kubernetes可以拉取镜像
- en: ⑥ Declares a Kubernetes service that creates a DNS record to make the microservice
    accessible within the cluster
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 声明了一个Kubernetes服务，创建一个DNS记录以在集群内使微服务可访问
- en: ⑦ Uses the Azure load balancer to create an external IP address for this service.
    We can use this to test that the deployed microservice is working.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用Azure负载均衡器为该服务创建一个外部IP地址。我们可以使用这个地址来测试已部署的微服务是否正常工作。
- en: At the end of listing 7.7, you can see that we have attached an Azure load balancer
    to the Kubernetes service to create an external endpoint. We have *temporarily*
    exposed a container to the outside world for testing purposes. This allows us
    to check our video-streaming microservice from the web browser to verify that
    it is functional. Be assured that the final FlixTube example application has restricted
    external endpoints! You’ll have to wait until chapter 9 to see that.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在7.7列表的末尾，你可以看到我们已经将Azure负载均衡器附加到Kubernetes服务上以创建外部端点。我们为了测试目的暂时将一个容器暴露给外部世界。这允许我们从网页浏览器中检查我们的视频流微服务以验证其功能。请放心，最终的FlixTube示例应用程序已限制外部端点！你将不得不等到第9章才能看到这一点。
- en: 7.6.5 Testing your microservice
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.5 测试你的微服务
- en: 'Let’s get this microservice deployed already! Invoke `terraform apply` and
    deploy the video-streaming microservice to your Kubernetes cluster:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个微服务部署起来吧！调用`terraform apply`并将视频流微服务部署到你的Kubernetes集群中：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we are now setting the `app_version` variable. We’ll set this to version
    1 initially and increment it each time we publish a new version of the image for
    our microservice. Remember to replace the values for `client_id` and `client_secret`
    with those for your own service principal as shown in sections 6.11.2 and 7.5.3.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在正在设置`app_version`变量。我们最初将其设置为版本1，并在发布微服务的新版本镜像时递增它。请记住用6.11.2和7.5.3节中所示的自定义服务主体的值替换`client_id`和`client_secret`的值。
- en: After this has completed, look up the external IP address for the video-streaming
    microservice as you did for the database service in section 7.5.4\. Now open your
    web browser at that IP address and navigate to the /video route. For example,
    if your IP address is 40.112.161.104, then point your browser at http://40.112.161.104/video.
    Just remember to use your own external IP address. You should now see the familiar
    video playing in your browser.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，查找视频流微服务的外部IP地址，就像在7.5.4节中为数据库服务所做的那样。现在打开你的网络浏览器并导航到该IP地址的/video路由。例如，如果你的IP地址是40.112.161.104，那么将你的浏览器指向http://40.112.161.104/video。只需记住使用你自己的外部IP地址。你现在应该能在浏览器中看到熟悉的视频播放。
- en: 7.6.6 What have we achieved?
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.6 我们取得了什么成果？
- en: After first deploying containers for MongoDB and RabbitMQ, we’ve now packaged,
    published, and deployed our first microservice! Along the way, we learned how
    to use Terraform local variables to compose and share configuration details for
    use in multiple places. This saved us from having to type in those details many
    times and will be convenient later, when we need to change these.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署MongoDB和RabbitMQ的容器之后，我们现在已经打包、发布并部署了我们的第一个微服务！在这个过程中，我们学习了如何使用Terraform局部变量来组合和共享配置细节，以便在多个地方使用。这使我们免去了多次输入这些细节的麻烦，并在以后需要更改这些配置时将变得方便。
- en: We used Docker to build and publish the image for our microservice. Authentication
    from the cluster to the container registry (to pull the image) was a bit tricky,
    but we created a Kubernetes secret to handle that.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Docker构建和发布了微服务的镜像。从集群到容器注册库的身份验证（以拉取镜像）有点棘手，但我们创建了一个Kubernetes密钥来处理这个问题。
- en: Ultimately, we deployed and tested our video-streaming microservice, and we
    finished prototyping our deployment pipeline. It’s now time to put the deployment
    process on automatic by creating our CD pipeline.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们部署并测试了我们的视频流微服务，并完成了我们的部署流程的原型设计。现在，是时候通过创建我们的CD管道来自动化部署流程了。
- en: 7.7 Continuous delivery with Bitbucket Pipelines
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 使用Bitbucket Pipelines进行持续交付
- en: Up until this point in chapters 6 and 7, we have manually invoked Terraform
    to execute our infrastructure code and build the infrastructure for our application.
    Doing this is a part of the normal process of prototyping our deployment code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在第6章和第7章的这一部分，我们手动调用了Terraform来执行我们的基础设施代码，并为我们的应用程序构建基础设施。这样做是原型化我们的部署代码的正常流程的一部分。
- en: Like any coding task, we need to develop and test our code locally before we
    can run that code in production. It’s especially important in this situation because
    this code runs in a hosted service, and it can be quite difficult to debug problems
    that occur there. We’d like this code to be as bulletproof as possible before
    it leaves our development workstation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何编码任务一样，在我们可以在生产环境中运行代码之前，我们需要在本地开发和测试我们的代码。在这种情况下，这尤其重要，因为这段代码运行在托管服务中，调试那里发生的问题可能相当困难。我们希望这段代码在我们离开开发工作站之前尽可能无懈可击。
- en: Running Terraform locally is also the best way to learn it and understand infrastructure
    as code. But the whole point of using Terraform and infrastructure as code is
    to automate our deployment pipeline. We don’t want to manually invoke Terraform
    for every change to our infrastructure or microservices. We’d like to deploy changes
    frequently, and we want it to be automated and streamlined so that we can spend
    the majority of our time building features rather than deploying our software.
    In addition, automation also greatly reduces the potential for human error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行Terraform也是学习和理解基础设施即代码的最佳方式。但使用Terraform和基础设施即代码的整个目的在于自动化我们的部署流程。我们不希望每次对基础设施或微服务的更改都手动调用Terraform。我们希望频繁地部署更改，并希望它是自动化和简化的，这样我们就可以把大部分时间花在构建功能上，而不是部署我们的软件。此外，自动化还可以大大减少人为错误的可能性。
- en: Now we’ll create our CD pipeline with Bitbucket Pipelines. This is a hosted
    service from Atlassian that we’ll use to run our deployment process in an automated
    fashion. It makes our deployment process as simple as a code push. Pushing code
    changes to our hosted code repository will automatically invoke our deployment
    pipeline.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Bitbucket Pipelines创建我们的CD管道。这是Atlassian提供的一项托管服务，我们将用它以自动化的方式运行我们的部署流程。它使我们的部署过程变得像代码推送一样简单。将代码更改推送到我们的托管代码仓库将自动调用我们的部署管道。
- en: 7.7.1 Why Bitbucket Pipelines?
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 为什么选择Bitbucket Pipelines？
- en: There are many good hosted services for CD, and these are all quite similar.
    If you learn one, you’ll find that the others aren’t that different.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多好的托管服务用于CD，它们都相当相似。如果你学会了其中一个，你会发现其他的并没有太大的不同。
- en: Bitbucket Pipelines is convenient because it’s included with Bitbucket from
    Atlassian so we can have our code and CD pipeline together. You can’t complain
    about the price! Atlassian provides a good starter tier with free private repositories
    and a limited amount of *free* *build minutes* per month to spend on your CD pipeline.
    This gives us some space to host a small build pipeline completely for free.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket Pipelines很方便，因为它包含在Atlassian的Bitbucket中，这样我们就可以将代码和CD管道放在一起。你无法抱怨价格！Atlassian提供了一个很好的入门级服务，包括免费的私有仓库和每月有限的*免费*
    *构建分钟数*，可以用于CD管道。这为我们提供了足够的空间，可以完全免费托管一个小型构建管道。
- en: Note It doesn’t really matter which hosted service we use. For example, GitHub
    and GitLab both offer similar services that are configured in a similar way. Bitbucket
    Pipelines appears in this book because it is what I currently use in production,
    even though I have used GitLab in the past, and I continue to use GitHub for most
    of my open source coding.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们使用哪种托管服务实际上并不重要。例如，GitHub和GitLab都提供类似的服务，配置方式也类似。Bitbucket Pipelines出现在这本书中，是因为我在生产环境中目前使用的是它，尽管我过去使用过GitLab，而且我继续在大多数开源编码中使用GitHub。
- en: I like to think of CD simply as a way to automatically run a shell script in
    the cloud. That’s a simplification of course, but it might help you understand
    that CD is not particularly complex or mysterious. Creating a shell script for
    our deployment is also useful because we can easily test it locally.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将CD简单地视为在云中自动运行shell脚本的一种方式。当然，这是一个简化，但它可能有助于你理解CD并不特别复杂或神秘。为我们的部署创建shell脚本也是有用的，因为我们可以在本地轻松测试它。
- en: 7.7.2 Importing the example code to Bitbucket
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.2 将示例代码导入 Bitbucket
- en: To use Bitbucket Pipelines, we must first have our code committed to a Bitbucket
    code repository. We’ll now move onto code example-4\. This is the same as example-3,
    but it includes the extra configuration we need for our CD pipeline.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Bitbucket Pipelines，我们首先必须将我们的代码提交到 Bitbucket 代码仓库。我们现在将转到代码示例-4。这与示例-3
    相同，但它包括了我们需要为我们的 CD 管道添加的额外配置。
- en: Also, at this point, you should destroy your previously created infrastructure
    with `terraform destroy` (if you haven’t done that already). The infrastructure
    you created previously was our *prototype* infrastructure. From here on in, we’ll
    use our CD pipeline to create *production* infrastructure, and we don’t want these
    to overlap.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个时候，你应该使用 `terraform destroy`（如果你还没有这样做）来销毁你之前创建的基础设施。你之前创建的基础设施是我们的 *原型*
    基础设施。从现在开始，我们将使用我们的 CD 管道来创建 *生产* 基础设施，我们不希望它们重叠。
- en: Signup for Bitbucket
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bitbucket 上注册
- en: 'To start, you need to sign up for a Bitbucket account, assuming you don’t have
    one already. Sign in or sign up here: [https://bitbucket.org](https://bitbucket.org).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要注册一个 Bitbucket 账户，假设你还没有。登录或注册请点击此处：[https://bitbucket.org](https://bitbucket.org)。
- en: Create the hosted code repository
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建托管代码仓库
- en: When signed into your account, click the button to create a new code repository.
    Choose a name for your new repo and fill out the details (an example is shown
    in figure 7.3).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你登录到你的账户时，点击按钮创建一个新的代码仓库。为你的新仓库选择一个名称并填写详细信息（如图 7.3 所示）。
- en: '![](../Images/CH07_F03_Davis4.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F03_Davis4.png)'
- en: Figure 7.3 Creating a new Bitbucket code repository
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 创建新的 Bitbucket 代码仓库
- en: After creating your code repository, you are presented with a page like figure
    7.4\. This gives instructions to get code into the repository. These are just
    standard Git commands, but it’s convenient that these give us the exact commands
    we need to import our code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你的代码仓库后，你会看到一个类似于图 7.4 的页面。这里提供了将代码放入仓库的说明。这些只是标准的 Git 命令，但很方便的是，这些命令给出了我们导入代码所需的精确命令。
- en: '![](../Images/CH07_F04_Davis4.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F04_Davis4.png)'
- en: Figure 7.4 Instructions from Bitbucket to get your code into the new repository
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 Bitbucket 提供的将你的代码放入新仓库的说明
- en: Create a local repository
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建本地仓库
- en: 'Before importing the example-4 code to our new repo, let’s make a fresh copy
    of it so that we don’t mess up the chapter-7 repo:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在将示例-4 代码导入我们的新仓库之前，让我们先创建一个全新的副本，这样我们就不至于弄乱第 7 章的仓库：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Go into the new directory and initialize a new empty Git repository:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 进入新目录并初始化一个新的空 Git 仓库：
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now commit all the files to the new repo:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有文件提交到新仓库：
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Push to the hosted repository
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 推送到托管仓库
- en: Now we can follow the instructions given by Bitbucket (as shown in figure 7.4).
    The commands that are given to you will be different because we have different
    Bitbucket accounts. The first command is to add the remote repo as the origin
    for the local one. For example
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以遵循 Bitbucket 提供的说明（如图 7.4 所示）。给出的命令将因我们拥有不同的 Bitbucket 账户而不同。第一个命令是将远程仓库作为本地仓库的源。例如
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remember to replace the URL for the remote repository with your own details.
    Here is the template you should use:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记得用你自己的详细信息替换远程仓库的 URL。以下是你应该使用的模板：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now push your code to your hosted repository:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的代码推送到你的托管仓库：
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, you need to enter your credentials. To avoid doing that for
    every push, I recommend that you set up an SSH key, which is fairly easy to do
    on every platform, following these instructions from Bitbucket Support:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你需要输入你的凭证。为了避免每次推送时都这样做，我建议你设置一个 SSH 密钥，这在每个平台上都相对容易完成，请按照 Bitbucket 支持的以下说明操作：
- en: '![](../Images/CH07_F05_Davis4.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F05_Davis4.png)'
- en: Figure 7.5 Navigating to the Pipelines page for your repository
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 导航到你的仓库的管道页面
- en: '[https://confluence.atlassian.com/bitbucket/set-up-an-ssh-key-728138079.html](https://confluence.atlassian.com/bitbucket/set-up-an-ssh-key-728138079.html)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置 SSH 密钥](https://confluence.atlassian.com/bitbucket/set-up-an-ssh-key-728138079.html)'
- en: 'In the future, you can push code changes with the shortened command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，你可以使用简短的命令来推送代码更改：
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Enabling Bitbucket Pipelines
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Bitbucket Pipelines
- en: We have created our hosted code repository and pushed the example code to it.
    Now, we can enable Bitbucket Pipelines for this repository. Navigate to the Pipelines
    page (as in figure 7.5).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了托管代码仓库并将示例代码推送到它。现在，我们可以为这个仓库启用 Bitbucket Pipelines。导航到管道页面（如图 7.5 所示）。
- en: The example code includes a bitbucket-pipelines.yaml configuration file. Bitbucket
    detects this file, and you can now click the Enable button (as shown in figure
    7.6), which enables Bitbucket Pipelines for this code repository. (Note that you
    may need to scroll down so you can see the Enable button.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码包含一个bitbucket-pipelines.yaml配置文件。Bitbucket会检测到这个文件，现在你可以点击启用按钮（如图7.6所示），这将启用此代码仓库的Bitbucket
    Pipelines。（注意，你可能需要向下滚动以便可以看到启用按钮。）
- en: '![](../Images/CH07_F06_Davis4.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F06_Davis4.png)'
- en: Figure 7.6 Click the Enable button to enable Bitbucket Pipelines
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 点击启用按钮以启用Bitbucket Pipelines
- en: 7.7.3 Creating a deployment shell script
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.3 创建部署shell脚本
- en: 'Most CD pipelines can be boiled down to a shell script with inputs provided
    by environment variables. Taking this approach is useful for two reasons:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CD管道都可以简化为一个由环境变量提供的输入的shell脚本。采用这种方法有两个原因：
- en: Our deployment pipeline is somewhat portable between CD providers.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的部署管道在CD提供者之间具有一定的可移植性。
- en: We can easily test our deployment pipeline locally by executing the shell script.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以很容易地通过执行shell脚本在本地测试我们的部署管道。
- en: Creating a deployment shell script gives us some freedom. That’s nice, but it’s
    also essential for local testing of our deployment pipeline. We need to make sure
    this code is bulletproof before we try to execute it unattended in the cloud.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部署shell脚本给我们一些自由。这很好，但这对我们部署管道的本地测试也是必不可少的。在我们尝试在云中无人执行之前，我们需要确保这段代码是坚不可摧的。
- en: We’ve spent most of this chapter prototyping and testing our deployment code,
    so we are already quite sure that it works. We just need to wrap it up in a shell
    script. The shell script included in example-4 is shown in the following listing.
    It’s simple, and that’s because we’ve been able to keep our deployment code entirely
    in Terraform. Our shell script simply invokes Terraform.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的大部分时间里都在原型设计和测试我们的部署代码，所以我们已经非常确信它的工作。我们只需要将其封装在一个shell脚本中。example-4中包含的shell脚本如下所示。它很简单，这是因为我们能够将我们的部署代码完全保持在Terraform中。我们的shell脚本只是调用Terraform。
- en: Listing 7.8 A shell script for deployment (chapter-7/example-4/scripts/deploy.sh)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 部署的shell脚本（chapter-7/example-4/scripts/deploy.sh）
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Checks that expected input environment variables are provided
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查是否提供了预期的输入环境变量
- en: ② Invokes Terraform from the directory that contains our deployment scripts
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从包含我们的部署脚本的目录中调用Terraform
- en: ③ Workaround for a problem with the Kubernetes provider (an explanation follows)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Kubernetes提供者的一个问题的工作方案（解释如下）
- en: ④ Initializes Terraform and download providers
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 初始化Terraform并下载提供者
- en: ⑤ Invokes Terraform apply
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 调用Terraform apply
- en: ⑥ Sets Terraform variables from environment variables
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 从环境变量设置Terraform变量
- en: One interesting thing to note in this script is how it checks for the input
    environment variables. These are the current version number for our application
    (used to tag our Docker images) and the authentication details for our Azure account.
    We’ll soon see where these variables come from.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中有一个有趣的事情需要注意，那就是它是如何检查输入环境变量的。这些是我们应用程序的当前版本号（用于标记我们的Docker镜像）和我们的Azure账户的认证详情。我们很快就会看到这些变量从哪里来。
- en: You are probably wondering why we are setting the KUBERNETES_SERVICE _HOST environment
    variable. This is a workaround for a problem that occurs when attempting to use
    the Kubernetes provider for Terraform within a Kubernetes pod. (Did I just short
    circuit your brain?) It appears that Bitbucket Pipelines quietly runs our CD pipeline
    in a pod within Bitbucket’s own Kubernetes cluster. This makes sense, and it’s
    an awesome use case for Kubernetes. The problem that results from this shouldn’t
    happen, but it does. We empty out the KUBERNETES_SERVICE_HOST environment variable
    to fool the Kubernetes provider and to avoid the issue.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们要设置KUBERNETES_SERVICE_HOST环境变量。这是在尝试在Kubernetes pod内使用Terraform的Kubernetes提供者时出现问题的解决方案。（我刚刚短路了你的大脑吗？）看起来Bitbucket
    Pipelines在Bitbucket自己的Kubernetes集群内的一个pod中悄悄地运行我们的CD管道。这很有意义，也是Kubernetes的一个很棒的使用案例。由此产生的问题不应该发生，但它确实发生了。我们清空KUBERNETES_SERVICE_HOST环境变量来欺骗Kubernetes提供者，以避免这个问题。
- en: 'We shouldn’t have to care about things like this, but sometimes working with
    early tools (Terraform is pre-version 1), we sometimes have to cope with unusual
    issues in Terraform or its provider plugins. Possibly, by the time you read this,
    the problem will have been corrected, and this workaround won’t be needed. If
    you are curious and want to learn more, you can read about it here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该关心这类事情，但有时在使用早期工具（Terraform 是在 1.0 版本之前），我们有时不得不应对 Terraform 或其提供者插件中的异常问题。可能在你阅读这段文字的时候，问题已经被修正，这个解决方案也就不再需要了。如果你好奇并想了解更多，你可以在这里阅读相关信息：
- en: '[https://github.com/terraform-providers/terraform-provider-kubernetes/issues/679](https://github.com/terraform-providers/terraform-provider-kubernetes/issues/679)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/terraform-providers/terraform-provider-kubernetes/issues/679](https://github.com/terraform-providers/terraform-provider-kubernetes/issues/679)'
- en: 7.7.4 Managing Terraform state
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.4 管理 Terraform 状态
- en: Now we return to the tricky issue of managing Terraform state. Cast your mind
    back to section 6.8.7 in the previous chapter. You’ll recall that Terraform has
    a state file so that it has a memory of the infrastructure it created.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到管理 Terraform 状态这个棘手的问题。回想一下前一章的 6.8.7 节。你会记得 Terraform 有一个状态文件，这样它就能记住它创建的基础设施。
- en: The question now is how do we persist the state file in our CD pipeline? The
    nature of CD pipelines is that each invocation happens in a fresh container instance.
    That’s why we must invoke `terraform init` in our deployment shell script for
    each and every deployment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何在我们的 CD 流水线中持久化状态文件？CD 流水线的特性是每次调用都在一个新的容器实例中发生。这就是为什么我们必须在我们的部署
    shell 脚本中对每一次部署调用 `terraform init`。
- en: How do we manage the Terraform state file? We must persist it between instances
    of the CD pipeline so that subsequent invocations of Terraform have a memory of
    what was created earlier. That’s so it isn’t blindly trying to recreate infrastructure
    that it already created. Terraform has a solution to this. We can provide external
    storage in which Terraform can store its state file. This allows the state file
    to be stored separately to the CD pipeline.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何管理 Terraform 状态文件？我们必须在 CD 流水线的实例之间持久化它，这样 Terraform 的后续调用就能记住之前创建的内容。这样它就不会盲目地尝试重新创建它已经创建的基础设施。Terraform
    有一个解决方案。我们可以提供外部存储，Terraform 可以在其中存储其状态文件。这使得状态文件可以单独存储在 CD 流水线之外。
- en: The following listing shows our configuration for the Azure backend. Through
    this configuration, we set an Azure storage account as the backend for the storage
    of our Terraform state.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了我们的 Azure 后端配置。通过这个配置，我们设置了一个 Azure 存储帐户作为存储 Terraform 状态的后端。
- en: Listing 7.9 Configuring backend storage (chapter-7/example-4/scripts/backend.tf)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 配置后端存储（第 7 章示例 4 的 scripts/backend.tf）
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Sets configuration for the Azure storage backend
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为 Azure 存储后端设置配置
- en: ② Sets the name of the resource group, storage account, and container for use
    by Terraform
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为 Terraform 设置资源组、存储帐户和容器的名称
- en: ③ Names the storage blob where the Terraform state is stored
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 指定存储 blob 的名称，其中存储 Terraform 状态
- en: Before Terraform will work in your CD pipeline, we have to create a separate
    Azure storage account for it to use. First, choose a name to use for your storage
    account. I have used the name `terraform` as you can see in listing 7.9\. Unfortunately,
    you can’t use that because the names of storage accounts must be globally unique
    (which is kind of annoying).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 在你的 CD 流水线中工作之前，我们必须为它创建一个单独的 Azure 存储帐户。首先，选择一个用于你的存储帐户的名称。正如你在列表
    7.9 中看到的那样，我使用了 `terraform` 这个名称。不幸的是，你不能使用这个名字，因为存储帐户的名称必须是全局唯一的（这有点令人烦恼）。
- en: Open the Azure portal in your browser and create a new storage account with
    the name you have chosen under a resource group with that same name. (See section
    4.4.1 in chapter 4 for a refresher on creating a storage account.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 Azure 门户，并在具有相同名称的资源组下创建一个新的存储帐户。（有关创建存储帐户的复习，请参阅第 4 章的 4.4.1 节。）
- en: In your new storage account, also create a container (a storage container, not
    a Docker container) with the same name. You can use any name you want for this
    (although, there are restrictions for names of storage accounts). I used the name
    `terraform` for the resource group, storage account, and container names. I used
    that name just to indicate that these are all purely for use by Terraform running
    in our CD pipeline. This new storage account isn’t otherwise used by our infrastructure
    or application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新存储帐户中，也创建一个具有相同名称的容器（一个存储容器，而不是 Docker 容器）。你可以为这个容器使用任何你想要的名称（尽管，存储帐户的名称有一些限制）。我使用了
    `terraform` 这个名称作为资源组、存储帐户和容器名称。我使用这个名称只是为了表明这些都是在我们的 CD 管道中运行的 Terraform 的纯使用。这个新的存储帐户在基础设施或应用程序中未作他用。
- en: Once you have created the storage account and container, edit backend.tf (shown
    in listing 7.9) and replace each instance of `terraform` with the name that you
    have selected. At this stage, you can commit these changes to your local code
    repository, but don’t push them to Bitbucket yet! We still have some configuration
    to do before our CD pipeline will work.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了存储帐户和容器，编辑 backend.tf（如列表 7.9 所示）并将每个 `terraform` 实例替换为你所选的名称。在这个阶段，你可以将这些更改提交到你的本地代码仓库，但不要将它们推送到
    Bitbucket！在我们 CD 管道工作之前，我们还有一些配置要做。
- en: 7.7.5 The Bitbucket Pipelines script
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.5 Bitbucket Pipelines 脚本
- en: The final piece of our CD pipeline is the bitbucket-pipelines.yaml configuration
    file. This YAML file is what we use to configure our CD pipeline. To use Bitbucket
    Pipelines, you must have this file in the root of your code repository. It simply
    doesn’t work without it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 CD 管道的最后一部分是 bitbucket-pipelines.yaml 配置文件。这个 YAML 文件是我们用来配置我们的 CD 管道的。要使用
    Bitbucket Pipelines，你必须在这个代码仓库的根目录中拥有此文件。没有它，它根本不起作用。
- en: Listing 7.10 shows bitbucket-pipelines.yaml from example-4\. You can see that
    we use this file simply as a wrapper for our shell script from listing 7.8\. There’s
    a bit more to it than this, of course, but not much! With Bitbucket Pipelines
    enabled for our Bitbucket code repository, this YAML file now invokes our deployment
    shell script when code is pushed to the hosted code repository.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 显示了 example-4 中的 bitbucket-pipelines.yaml。你可以看到我们只是将此文件用作列表 7.8 中 shell
    脚本的包装器。当然，这不仅仅是这样，但也没有多少！为我们的 Bitbucket 代码仓库启用 Bitbucket Pipelines 后，此 YAML 文件现在在代码推送到托管代码仓库时调用我们的部署
    shell 脚本。
- en: Listing 7.10 Configuring our Bitbucket Pipelines automated deployment pipeline
    (chapter-7/example-4/bitbucket-pipelines.yaml)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 配置我们的 Bitbucket Pipelines 自动部署管道（chapter-7/example-4/bitbucket-pipelines.yaml）
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Sets the base image for the container within which the CD pipeline is executed.
    We use the Terraform base image so that we have access to the Terraform tool within
    our CD pipeline.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为 CD 管道中运行的容器设置基本镜像。我们使用 Terraform 基本镜像，以便在我们的 CD 管道中访问 Terraform 工具。
- en: ② Configures the default pipeline for our repo. We can also have separate pipelines
    for each branch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置我们仓库的默认管道。我们也可以为每个分支有单独的管道。
- en: ③ Defines a step in our deployment pipeline (here, it’s only a single step)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在我们的部署管道中定义一个步骤（这里，只有一个步骤）
- en: ④ Enables the Docker service. This lets us use Docker from within our Terraform
    code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 启用 Docker 服务。这让我们可以在 Terraform 代码中使用 Docker。
- en: ⑤ Sets the VERSION environment variable to the Bitbucket build number
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将 VERSION 环境变量设置为 Bitbucket 构建号
- en: ⑥ Ensures that our deployment script is executable
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 确保我们的部署脚本可执行
- en: ⑦ Executes our deployment script. This is the core of our deployment pipeline.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 执行我们的部署脚本。这是我们部署管道的核心。
- en: 'Note in listing 7.10 how the first line of the file sets the base image for
    the CD pipeline’s container. Bitbucket instantiates a new container from this
    image each time our CD pipeline is triggered. We automatically have access to
    the Terraform tool because it’s pre-installed in the base image. If we weren’t
    using Terraform, we could select a different base image. Check out the following
    line of code from listing 7.10:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表 7.10 中的第一行如何设置 CD 管道容器的基镜像。每次我们的 CD 管道被触发时，Bitbucket 都会从这个镜像实例化一个新的容器。我们自动可以访问
    Terraform 工具，因为它在基镜像中预先安装。如果我们不使用 Terraform，我们可以选择不同的基镜像。查看列表 7.10 中的以下代码行：
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is one method of passing environment variables into our deployment shell
    script, and here we have set the version number for our application. We are setting
    this from Bitbucket Pipeline’s BITBUCKET_BUILD_NUMBER environment variable, which
    simply counts the number of times the CD pipeline has been triggered. This is
    a convenient way to generate version numbers for the images created within our
    CD pipeline. Bitbucket Pipelines also has many other built-in environment variables
    that can be useful. For more information, see
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将环境变量传递到我们的部署shell脚本的一种方法，在这里我们已设置了应用程序的版本号。我们是从Bitbucket Pipeline的`BITBUCKET_BUILD_NUMBER`环境变量中设置这个版本的，这个变量简单地计算了CD管道被触发的次数。这是为CD管道内创建的镜像生成版本号的一种方便方法。Bitbucket
    Pipelines还提供了许多其他内置环境变量，这些变量可能很有用。有关更多信息，请参阅
- en: '[https://confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html](https://confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html](https://confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html)'
- en: 7.7.6 Configuring environment variables
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6 配置环境变量
- en: In the previous section, you saw one example of how to input an environment
    variable to our deployment shell script. There are still other environment variables
    we have yet to provide.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了如何将环境变量输入到我们的部署shell脚本中的一个示例。我们还有其他一些尚未提供的环境变量。
- en: We could set these inline in bitbucket-pipelines.yaml as we did with the VERSION
    environment variable in listing 7.10, but we shouldn’t do that for our Azure credentials.
    These are sensitive, and for security reasons, we don’t want to include those
    in our code repository. Instead, we’ll configure these as *repository variables*
    through the Bitbucket GUI. Navigate to the Repository Variables page under the
    Settings option for your code repository (shown in fig-ure 7.7).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`bitbucket-pipelines.yaml`中设置这些变量，就像在7.10列表中设置`VERSION`环境变量一样，但对于我们的Azure凭证，我们不应该这样做。这些信息是敏感的，出于安全考虑，我们不希望将这些信息包含在我们的代码仓库中。相反，我们将通过Bitbucket
    GUI将这些变量配置为*仓库变量*。导航到代码仓库设置选项下的“仓库变量”页面（如图7.7所示）。
- en: '![](../Images/CH07_F07_Davis4.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 导航到代码仓库的仓库变量](../Images/CH07_F07_Davis4.png)'
- en: Figure 7.7 Navigating to Repository Variables for your code repository
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 导航到代码仓库的仓库变量
- en: Now create repository variables and enter their values as shown in figure 7.8\.
    Feel free to check the Secured option for an extra layer of security for these
    sensitive values. These values are passed to our CD pipeline as environment variables.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建仓库变量，并按照图7.8所示输入它们的值。你可以自由地选择“受保护”选项，为这些敏感值提供额外的安全层。这些值作为环境变量传递到我们的CD管道中。
- en: When creating these variables, you must enter authentication credentials for
    your own Azure account and Azure service principal. The values for ARM_ CLIENT_ID
    and ARM_CLIENT_SECRET are the `appId` and `password` fields from your service
    principal you created back in section 6.11.2\. The values for ARM_TENANT_ID and
    ARM_SUBSCRIPTION_ID are the details for your Azure account that you can see using
    the command `az account show` like we also did in section 6.11.2.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些变量时，你必须输入你自己的Azure账户和Azure服务主体的身份验证凭据。`ARM_CLIENT_ID`和`ARM_CLIENT_SECRET`的值是你创建服务主体时从`appId`和`password`字段中获取的。`ARM_TENANT_ID`和`ARM_SUBSCRIPTION_ID`的值是你Azure账户的详情，你可以使用`az
    account show`命令查看这些详情，就像我们在6.11.2节中做的那样。
- en: These authentication details must be set somewhere. If you recall, back in section
    6.6.2, we used the command `az login` on our development workstation to authenticate
    with Azure. This command doesn’t work in our CD pipeline because no human interaction
    is possible. To allow Terraform to authenticate with Azure to build and update
    our infrastructure, we must pass these authentication details into our pipeline.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些身份验证详情必须设置在某处。如果你还记得，在6.6.2节中，我们曾在我们的开发工作站上使用`az login`命令来与Azure进行身份验证。这个命令在我们的CD管道中不起作用，因为不可能有人工交互。为了允许Terraform使用Azure身份验证来构建和更新我们的基础设施，我们必须将这些身份验证详情传递到我们的管道中。
- en: '![](../Images/CH07_F08_Davis4.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 创建仓库变量以指定Azure身份验证凭据](../Images/CH07_F08_Davis4.png)'
- en: Figure 7.8 Creating repository variables to specify Azure authentication credentials
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 创建仓库变量以指定Azure身份验证凭据
- en: 7.7.7 Testing your deployment pipeline
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.7 测试你的部署管道
- en: OK, we are finally ready to test our CD pipeline! We have created a Bitbucket
    code repository and pushed to it a copy of the example-4 code. We have enabled
    and configured Bitbucket Pipelines for the repository, and we have a CD pipeline;
    we just need to trigger it!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们终于准备好测试我们的CD管道了！我们已经创建了一个Bitbucket代码仓库，并将example-4代码的副本推送到它。我们已经为该仓库启用了并配置了Bitbucket
    Pipelines，我们有一个CD管道；我们只需要触发它！
- en: 'We can trigger the pipeline simply by pushing code to it. You probably already
    have an unpushed code change ready to go. If you were following along, you committed
    changes to backend.tf earlier in section 7.7.4\. Go ahead now and push those changes:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地推送代码来触发管道。你可能已经有了一个未推送的代码更改准备就绪。如果你一直跟着做，你已经在7.7.4节中更早的时候提交了backend.tf的更改。现在就推这些更改吧：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you pushed those code changes earlier, that’s not a big deal. Make a simple
    change now (e.g., add a blank line to one of the code files) and then commit it
    and push it to trigger the CD pipeline. You can repeat this process as many times
    as you like while testing and debugging your CD pipeline.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前推送了这些代码更改，那并不是什么大问题。现在进行一个简单的更改（例如，在某个代码文件中添加一个空行）然后提交并推送到触发CD管道。在测试和调试你的CD管道时，你可以重复这个过程任意多次。
- en: You can monitor pipeline invocations in the Pipelines page under your Bitbucket
    repository (like that in figure 7.9). You can see in this example that my first
    pipeline invocation failed and that the second invocation has just started (denoted
    by the word “Pending”)*.*
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Bitbucket仓库的管道页面下监控管道调用（如图7.9所示）。你在这个例子中可以看到，我的第一次管道调用失败了，而第二次调用刚刚开始（用“挂起”一词表示）*。*
- en: '![](../Images/CH07_F09_Davis4.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10](../Images/CH07_F09_Davis4.png)'
- en: Figure 7.9 Monitoring pipeline invocations from the Pipelines page
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 从管道页面监控管道调用
- en: You can drill down into any of the pipeline invocations to find out what happened.
    Of course, you will need to do this in the future to find out what went wrong
    after it fails.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以深入到任何管道调用中，以了解发生了什么。当然，你将来需要这样做，以便在它失败后找出出了什么问题。
- en: As an example, I clicked down into my second invocation (the one that completed
    successfully). You can see what it looks like in figure 7.10\. You’ll note that
    the complete output from the deployment shell script is displayed here. This should
    be familiar to you by now because it’s the same output we saw earlier when testing
    our Terraform code locally.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我点击进入我的第二次调用（成功完成的那个）。你可以在图7.10中看到它的样子。你会注意到，部署shell脚本的完整输出在这里显示。现在你应该很熟悉了，因为它与我们之前在本地测试Terraform代码时看到的相同输出。
- en: '![](../Images/CH07_F10_Davis4.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8](../Images/CH07_F10_Davis4.png)'
- en: Figure 7.10 Viewing a successful CD pipeline invocation
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 查看成功的CD管道调用
- en: 7.7.8 Debugging your deployment pipeline
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.8 调试你的部署管道
- en: 'We now have a CD pipeline. Changing our infrastructure and deploying our application
    is now synonymous with changing our code: what we call *infrastructure as code**.*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个CD管道。改变我们的基础设施和部署我们的应用程序现在与改变我们的代码同义：我们称之为*基础设施即代码**。
- en: 'You probably have a new question now: how do I debug my deployment pipeline?
    You might be wondering about this after seeing my failed pipeline from figure
    7.9\. Or, possibly, because you might already have had your own failed pipeline!'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能有一个新的问题：我如何调试我的部署管道？你可能在我展示的图7.9中的失败管道后对此感到好奇。或者，可能是因为你可能已经有过自己的失败管道！
- en: The first step is to thoroughly test any changes to your deployment code locally
    on your own development workstation. Then, we can catch many issues before our
    deployment code gets to the CD pipeline.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在你自己的开发工作站上彻底测试你部署代码的任何更改。然后，我们可以在我们的部署代码到达CD管道之前捕捉到许多问题。
- en: When you do get a failed pipeline, you’ll need to drill down into it, read the
    output, and try to understand the problem. Understanding the problem is the hard
    bit; fixing the problem is usually easy once we know what it is.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到失败的管道时，你需要深入调查它，阅读输出，并尝试理解问题。理解问题是难点；一旦我们知道问题是什么，修复问题通常很容易。
- en: You can see an example of a problem in figure 7.11, when I drilled down to figure
    out why my first pipeline invocation failed. I read the error message here and
    realized it failed because I hadn’t provided the required environment variables.
    I had invoked this pipeline prior to configuring the repository variables as we
    did in section 7.7.6\. That’s an easy mistake to make, and you might have made
    it yourself if you were a bit too gung-ho in pushing the changes we made in section
    7.7.4.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图7.11中看到一个问题的例子，当我深入挖掘以找出我的第一个管道调用失败的原因时。我阅读了这里的错误信息，并意识到它失败是因为我没有提供所需的环境变量。我在配置存储库变量之前调用了这个管道，正如我们在7.7.6节中所做的那样。这是一个容易犯的错误，如果你在推动我们在7.7.4节中做出的更改时过于冲动，你可能已经犯了这个错误。
- en: '![](../Images/CH07_F11_Davis4.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F11_Davis4.png)'
- en: Figure 7.11 Viewing a failed CD pipeline and reading the error message
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 查看失败的CD管道和读取错误信息
- en: When debugging your pipeline, you should note that you can use any of the common
    commands to help you. Commands such as `cd`, `ls`, `pwd`, and `cat` can be used
    to navigate and inspect the filesystem within the CD pipeline’s container. This
    gives you a variety of ways to understand what’s going on in there. Hopefully,
    this small but invaluable tip will assist your future CD pipeline debugging!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试你的管道时，你应该注意你可以使用任何常见的命令来帮助你。例如`cd`、`ls`、`pwd`和`cat`等命令可以用来在CD管道的容器内导航和检查文件系统。这为你提供了多种理解那里发生的事情的方法。希望这个虽小但非常有价值的小贴士能帮助你未来的CD管道调试！
- en: 7.7.9 What have we achieved?
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.9 我们取得了什么成果？
- en: You just created your first CD pipeline, and you used it to deploy production
    infrastructure and containers. This is real progress!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了你的第一个CD管道，并使用它来部署生产基础设施和容器。这是真正的进步！
- en: There are many services for CD, but we used Bitbucket Pipelines from Atlassian.
    We created a repository on Bitbucket and imported the code from example-4\. We
    then created a shell script to wrap up our deployment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多CD服务，但我们使用了Atlassian的Bitbucket Pipelines。我们在Bitbucket上创建了一个存储库，并从example-4导入代码。然后我们创建了一个shell脚本来封装我们的部署。
- en: Although there are many vendors for CD, building a CD pipeline usually amounts
    to not much more than invoking a shell script. That’s useful because a shell script
    is something we can test locally before we try to run it in our CD pipeline. The
    deployment shell script we created is simple. That’s because our entire deployment
    process is in Terraform code, so we simply invoked Terraform to create our infrastructure
    and deploy our containers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CD有很多供应商，但构建CD管道通常不会比调用一个shell脚本多多少。这很有用，因为shell脚本是我们可以在尝试在我们的CD管道中运行它之前在本地测试的东西。我们创建的部署shell脚本很简单。这是因为我们的整个部署过程都在Terraform代码中，所以我们只是调用了Terraform来创建我们的基础设施并部署我们的容器。
- en: 7.8 Continue your learning
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 继续学习
- en: In this chapter, we deployed our fledgling microservices application to the
    Kubernetes cluster that we created in the previous chapter. In future chapters,
    we’ll continue to flesh out the FlixTube application into a complete application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们在上一章中创建的Kubernetes集群部署了我们的初出茅庐的微服务应用程序。在未来的章节中，我们将继续完善FlixTube应用程序，使其成为一个完整的应用程序。
- en: 'As always, there is so much more to be learned than we can cover here. As we
    get deeper into development, you will undoubtedly need to dive deeper while you
    are working. Here are the books that will help you do that:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有比我们能在这里涵盖的更多的东西要学习。随着我们深入开发，你无疑在工作过程中需要进一步深入。以下是一些将帮助你做到这一点的书籍：
- en: '*Core Kubernetes* by Jay Vyas and Chris Love (Manning, est. Summer 2021)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《核心Kubernetes》* by Jay Vyas and Chris Love (Manning, 预计2021年夏季)'
- en: '*Kubernetes in Action* by Marko Lukša (Manning, 2017)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Kubernetes实战》* by Marko Lukša (Manning, 2017)'
- en: '*Terraform in Action* by Scott Winkler (Manning, est. Spring 2021)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Terraform实战》* by Scott Winkler (Manning, 预计2021年春季)'
- en: '*GitOps and Kubernetes* by Billy Yuen, Alexander Matyushentsev, et. al. (Manning,
    est. Spring 2021)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《GitOps和Kubernetes》* by Billy Yuen, Alexander Matyushentsev, et. al. (Manning,
    预计2021年春季)'
- en: '*Kubernetes Quickly* by William Denniss (Manning, est. Summer 2021)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Kubernetes快速入门》* by William Denniss (Manning, 预计2021年夏季)'
- en: '*Learn Kubernetes in a Month of Lunches* by Elton Stoneman (Manning, est. February
    2021)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《一个月午餐学会Kubernetes》* by Elton Stoneman (Manning, 预计2021年2月)'
- en: 'To learn about Atlassian Bitbucket, see the Bitbucket website:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Atlassian Bitbucket，请访问Bitbucket网站：
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/](https://bitbucket.org/)'
- en: See the Bitbucket overview at
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下位置查看Bitbucket概述：
- en: '[https://bitbucket.org/product/guides/getting-started/overview](https://bitbucket.org/product/guides/getting-started/overview)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/product/guides/getting-started/overview](https://bitbucket.org/product/guides/getting-started/overview)'
- en: To learn more about CD with Bitbucket Pipelines, see
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用 Bitbucket Pipelines 的 CD 信息，请参阅
- en: '[https://bitbucket.org/product/features/pipelines](https://bitbucket.org/product/features/pipelines)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/product/features/pipelines](https://bitbucket.org/product/features/pipelines)'
- en: Learn more about Kubernetes concepts in the Kubernetes documentation at
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 文档中了解更多关于 Kubernetes 概念的信息
- en: '[https://kubernetes.io/docs/concepts/](https://kubernetes.io/docs/concepts/)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/concepts/](https://kubernetes.io/docs/concepts/)'
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Continuous delivery (CD) is a technique where production infrastructure and
    software are continuously updated as changes are made to the code.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付（CD）是一种技术，其中生产基础设施和软件在代码更改时持续更新。
- en: We used Terraform to script the configuration and deployment of multiple containers
    onto our Kubernetes cluster.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Terraform 脚本化配置和部署多个容器到我们的 Kubernetes 集群。
- en: We deployed a MongoDB database server and a RabbitMQ server for use by our microservices.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们部署了一个 MongoDB 数据库服务器和一个 RabbitMQ 服务器，供我们的微服务使用。
- en: We used Terraform to build and publish the Docker image for our first microservice,
    the video-streaming microservice, which we then deployed to our Kubernetes cluster.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Terraform 构建和发布了我们的第一个微服务（视频流微服务）的 Docker 镜像，然后将其部署到我们的 Kubernetes 集群。
- en: We created a shell script to wrap up our deployment pipeline.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 shell 脚本来封装我们的部署管道。
- en: We moved our code to a private Bitbucket code repository and configured Bitbucket
    Pipelines to create a CD pipeline for our application.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将代码移至私有 Bitbucket 代码仓库，并配置 Bitbucket Pipelines 为我们的应用程序创建 CD 管道。
- en: Our Bitbucket Pipelines file was simple; it only invoked our deployment shell
    script.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 Bitbucket Pipelines 文件很简单；它只调用了我们的部署 shell 脚本。
- en: Having the shell script is important because it allows us to test and debug
    our deployment pipeline on our development workstation. Doing testing and debugging
    within the CD pipeline is more difficult.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 shell 脚本很重要，因为它允许我们在开发工作站上测试和调试我们的部署管道。在 CD 管道中进行测试和调试更困难。
- en: We learned how to use the Bitbucket interface to configure environment variables
    as input to our deployment pipeline.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 Bitbucket 界面将环境变量配置为部署管道的输入。
- en: We learned how to persist Terraform state using Azure storage.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 Azure 存储持久化 Terraform 状态。
