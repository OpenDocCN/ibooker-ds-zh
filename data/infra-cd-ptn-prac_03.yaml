- en: 2 Writing infrastructure as code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 编写基础设施即代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How the current infrastructure state affects the reproducibility of infrastructure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前基础设施状态如何影响基础设施的可重复性
- en: Detecting and remediating infrastructure drift due to mutable changes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和修复由于可变更改导致的基础设施漂移
- en: Implementing best practices for writing reproducible infrastructure as code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施编写可重复基础设施即代码的最佳实践
- en: Imagine you’ve created a development environment for a hello-world application.
    You built it organically, adding new components as you needed them. Eventually,
    you need to reproduce the configuration for production use, which people can publicly
    access. You also need to scale production across three geographic regions for
    high availability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经为hello-world应用程序创建了一个开发环境。你有机地构建它，根据需要添加新组件。最终，你需要复制配置以供生产使用，人们可以公开访问。你还需要将生产扩展到三个地理区域以实现高可用性。
- en: To do this, you must create and update firewalls, load balancers, servers, and
    databases in new networks for the production environment. Figure 2.1 shows the
    complexity of the development environment with the firewall, load balancer, server,
    and database and the components you need to reproduce in production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你必须为生产环境创建和更新防火墙、负载均衡器、服务器和数据库，这些都在新的网络中。图2.1显示了开发环境中的防火墙、负载均衡器、服务器和数据库以及你需要在生产中复制的组件。
- en: The figure also outlines the differences between development and production.
    The production configuration needs three servers for high availability, expanded
    firewall rules to allow all HTTP traffic, and stricter firewall rules for the
    servers to connect to the database. After reviewing all of the differences, you
    might have a lot of questions about the best and easiest way to make the changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该图还概述了开发和生产之间的差异。生产配置需要三台服务器以实现高可用性，扩展的防火墙规则以允许所有HTTP流量，以及更严格的防火墙规则以供服务器连接到数据库。在审查所有差异后，你可能会对最佳和最简单的方法来做出这些更改有很多疑问。
- en: '![](../../OEBPS/Images/CH02_F01_Wang.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F01_Wang.png)'
- en: Figure 2.1 When you create a production environment based on the development,
    you must answer many questions about configurations for new infrastructure and
    reverse engineer the functionality of the development environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 当你基于开发创建生产环境时，你必须回答许多关于新基础设施配置的问题，并逆向工程开发环境的功能。
- en: You might wonder, for example, why the lack of infrastructure as code for the
    *development* environment affects your ability to create the *production* one.
    The first reason is that you cannot easily *reproduce* the infrastructure resources.
    You have to reverse engineer a weeks’ worth of manual configuration! With IaC,
    you can instead copy and paste some configuration and modify it for the production
    environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会想知道，为什么开发环境中缺乏基础设施即代码会影响你创建生产环境的能力。第一个原因是你不能轻松地*复制*基础设施资源。你必须逆向工程一周的手动配置！使用IaC，你可以复制并粘贴一些配置，并对其进行修改以适应生产环境。
- en: Second, you cannot easily *compose* the infrastructure resources with new ones.
    You need a pool of servers for production instead of a single server. If you built
    an infrastructure module, you could use that building block to create multiple
    servers without updating the configuration from scratch.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你无法轻松地将基础设施资源与新资源*组合*。你需要一个用于生产的服务器池而不是单个服务器。如果你构建了一个基础设施模块，你可以使用这个构建块来创建多个服务器，而无需从头开始更新配置。
- en: Finally, you cannot easily *evolve* the production environment with its specific
    requirements. The production environment requires some different infrastructure
    resources, like secure operating systems and a larger database. You’ll have to
    manually tweak configuration that you’ve never run in the development environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你无法轻松地根据其特定要求*进化*生产环境。生产环境需要一些不同的基础设施资源，如安全的操作系统和更大的数据库。你将不得不手动调整配置，这些配置你在开发环境中从未运行过。
- en: You can solve these challenges and improve reproducibility, composability, and
    evolvability in two ways. First, you need a way to migrate manually configured
    infrastructure to IaC. Second, you need to write clean IaC to promote reproducibility
    and evolvability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式解决这些挑战并提高可重复性、可组合性和可进化性。首先，你需要一种将手动配置的基础设施迁移到基础设施即代码（IaC）的方法。其次，你需要编写干净的IaC以促进可重复性和可进化性。
- en: The first part of this chapter outlines fundamental concepts for writing IaC
    and migrating existing infrastructure to code. The second part of this chapter
    applies code hygiene practices to infrastructure. The combination of these practices
    will help you write reproducible IaC and set the stage for future composition
    and evolution of your system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分概述了编写 IaC 和将现有基础设施迁移到代码的基本概念。本章的第二部分将代码卫生实践应用于基础设施。这些实践的组合将帮助您编写可重复的
    IaC，并为未来系统的组合和演变奠定基础。
- en: 2.1 Expressing infrastructure change
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 表达基础设施更改
- en: 'I mentioned in chapter 1 that IaC automates changes. It turns out that reproducing
    and automating many changes over time takes effort. For example, if you want to
    provision and manage a server on GCP, you’ll usually make the following changes
    over time:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第一章中提到，IaC 自动化更改。事实证明，随着时间的推移复制和自动化许多更改需要付出努力。例如，如果您想在 GCP 上配置和管理服务器，您通常会随着时间的推移进行以下更改：
- en: Create the server in GCP by using the console, terminal, or code.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用控制台、终端或代码在 GCP 中创建服务器。
- en: Read the server in GCP to check that you created the server with the correct
    specifications—for example, Ubuntu 18.04 as the operating system.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GCP 中读取服务器以检查您是否已使用正确的规格创建了服务器——例如，操作系统为 Ubuntu 18.04。
- en: Update the server in GCP with a publicly accessible network address to log into
    it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用公开可访问的网络地址更新 GCP 中的服务器以便登录。
- en: Delete the server in GCP because you no longer require it.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您不再需要它，请删除 GCP 中的服务器。
- en: 'To make more complex updates or reproduce the server in another environment,
    you take the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更复杂的更新或在另一个环境中复制服务器，您需要采取以下步骤：
- en: Create the server.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务器。
- en: Check if it exists by using a `read` command.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `read` 命令检查其是否存在。
- en: Update it if you need to log in.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要登录，请更新它。
- en: Delete the server if you no longer need it.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不再需要服务器，请删除它。
- en: No matter which resource you automate, you can always break down your changes
    to create, read, update, and delete (CRUD). You create an infrastructure resource,
    search for its metadata, update its properties, and delete it when you no longer
    need it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您自动化哪种资源，您都可以始终将您的更改分解为创建、读取、更新和删除（CRUD）。您创建一个基础设施资源，搜索其元数据，更新其属性，并在不再需要时删除它。
- en: Note You wouldn’t usually have a change record that explicitly states “read
    the server.” The record usually implies a read step to verify that a resource
    is created or updated.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您通常不会有明确表示“读取服务器”的更改记录。记录通常意味着读取步骤以验证资源是否已创建或更新。
- en: CRUD allows you to automate your infrastructure step-by-step in a specific order.
    This approach, called the *imperative style*, describes how to configure infrastructure.
    You can think of it as an instruction manual.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 允许您按照特定顺序逐步自动化您的基础设施。这种被称为 *命令式风格* 的方法描述了如何配置基础设施。您可以将它想象成一本操作手册。
- en: Definition The *imperative style* of IaC describes how to configure an infrastructure
    resource step-by-step.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 IaC 的 *命令式风格* 描述了如何逐步配置基础设施资源。
- en: While it seems intuitive, the imperative style does not scale as you make more
    changes to the system. I once had to create a new database environment based on
    a development environment. I started reconstructing the 200 change requests submitted
    to the development environment over two years. Each change request became a series
    of steps creating, updating, and deleting resources. It took me a month and a
    half to complete an environment that still didn’t match the existing development
    one!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来直观，但命令式风格在您对系统进行更多更改时无法扩展。我曾经不得不基于开发环境创建一个新的数据库环境。我开始重建过去两年中提交给开发环境的 200
    个更改请求。每个更改请求都变成了一系列创建、更新和删除资源的步骤。我花了整整一个月半的时间才完成了一个仍然与现有的开发环境不匹配的环境！
- en: Rather than painstakingly re-create every step, I wished I could just describe
    the new database environment based on the running state of the development environment
    and let a tool figure out how to achieve the state. With most IaC, you will find
    it easier to reproduce environments and make changes in the declarative style.
    The *declarative style* describes the desired end state of an infrastructure resource.
    The tool decides the steps it needs to take to configure the infrastructure resource.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是费力地重新创建每个步骤，我希望能够仅根据开发环境的运行状态描述新的数据库环境，并让工具找出如何达到该状态。在大多数基础设施即代码（IaC）中，您会发现以声明式风格复制环境和进行更改更容易。*声明式风格*
    描述了基础设施资源的期望最终状态。工具决定配置基础设施资源所需的步骤。
- en: Definition The *declarative style* of IaC describes the desired end state of
    an infrastructure resource. Automation and tooling decide how to achieve the end
    state without your knowledge.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 IaC 的 *声明式风格* 描述了基础设施资源的期望最终状态。自动化和工具决定如何实现最终状态，而不需要你的知识。
- en: This process with IaC takes a few steps. First, you need to search inventory
    sources for information on the database servers. Next, you get the database IP
    addresses. Finally, you write a configuration based on the information you’ve
    collected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IaC 的此过程需要几个步骤。首先，你需要搜索库存源以获取有关数据库服务器的信息。接下来，你获取数据库 IP 地址。最后，你根据收集到的信息编写配置。
- en: Your configuration in version control becomes the infrastructure *source of
    truth*. You declare the new database environment’s desired state instead of describing
    a set of steps that may not end in the same result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的配置在版本控制中成为基础设施的 *真相源*。你声明新的数据库环境的期望状态，而不是描述可能不会产生相同结果的步骤集。
- en: Definition An infrastructure *source of truth* structures information about
    the state of your infrastructure system consistently and singularly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 定义基础设施的 *真相源* 一致且唯一地结构化关于你的基础设施系统状态的信息。
- en: You make all changes on the infrastructure source of truth. However, even in
    ideal circumstances (such as with GitOps in chapter 7), you probably have some
    configuration drift from manual changes over time. If you use the declarative
    style and create a source of truth, you can use immutability to change infrastructure
    and lower the risk of failure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你在基础设施的真相源上进行所有更改。然而，即使在理想情况下（例如在第 7 章中提到的 GitOps），随着时间的推移，你可能会有些配置漂移来自手动更改。如果你使用声明式风格并创建真相源，你可以使用不可变性来更改基础设施并降低失败的风险。
- en: Exercise 2.1
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2.1
- en: Does the following use the imperative or declarative style of configuring infrastructure?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置基础设施是使用命令式还是声明式风格？
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: See appendix B for answers to exercises.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录 B 以获取练习的答案。
- en: 2.2 Understanding immutability
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 理解不可变性
- en: How do you prevent configuration drift and quickly reproduce your infrastructure?
    It starts with changing the way you think about change. Imagine you create a server
    with Python version 2\. You could update your scripts to log into the server and
    upgrade Python without restarting the server. You can treat the server as *mutable
    infrastructure* because you update the server in place without restarting it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何防止配置漂移并快速重建你的基础设施？这始于改变你对改变的看法。想象你用 Python 版本 2 创建了一个服务器。你可以更新你的脚本以登录服务器并升级
    Python 而无需重启服务器。你可以将服务器视为 *可变基础设施*，因为你更新服务器而不重启它。
- en: Definition *Mutable infrastructure* means that you can update the infrastructure
    resource in place without recreating or restarting it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *可变基础设施* 意味着你可以在不重新创建或重启的情况下更新基础设施资源。
- en: However, treating the server as mutable infrastructure raises an issue. Other
    packages on the server do not work with Python 3\. Rather than update every other
    package and break the server, you can change your update scripts to create a *new*
    server with Python version 3 and compatible dependencies. Then you can delete
    the old server with Python 2\. Figure 2.2 shows how to do this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将服务器视为可变基础设施会引发一个问题。服务器上的其他包不与 Python 3 兼容。与其更新每个其他包并破坏服务器，你还可以更改你的更新脚本以创建一个
    *新* 服务器，该服务器具有 Python 版本 3 和兼容的依赖项。然后你可以删除具有 Python 2 的旧服务器。图 2.2 展示了如何做到这一点。
- en: '![](../../OEBPS/Images/CH02_F02_Wang.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F02_Wang.png)'
- en: Figure 2.2 You treat the server mutably by logging in and updating the Python
    package version. By comparison, you treat the server immutably by replacing the
    old server with a new one upgraded to Python 3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 你通过登录和更新 Python 包版本来可变地处理服务器。相比之下，你通过用升级到 Python 3 的新服务器替换旧服务器来不可变地处理服务器。
- en: Your new scripts treat the server as *immutable infrastructure*, in which you
    can replace the existing infrastructure with changes. You do not update the infrastructure
    in place. Immutability means that after you create a resource, you do not change
    its configuration.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的脚本将服务器视为 *不可变基础设施*，在其中你可以用更改替换现有的基础设施。你不会更新现有的基础设施。不可变性意味着在你创建资源后，你不会更改其配置。
- en: Definition *Immutable* *infrastructure* means you must create a new resource
    for any changes to infrastructure configuration. You do not modify the resource
    after creating it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *不可变* *基础设施* 意味着你必须为任何基础设施配置的改变创建一个新的资源。你不会在创建资源后对其进行修改。
- en: Why treat the server’s update in two different ways? Some changes will break
    the resource if you do them mutably. To mitigate the risk of failure, you can
    create a whole new resource with the updates and remove the old one with immutability.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么以两种不同的方式对待服务器的更新？如果你以可变的方式执行某些更改，它们可能会破坏资源。为了减轻失败的风险，你可以创建一个全新的资源，包含更新，然后用不可变性移除旧的一个。
- en: Immutability relies on a series of creation and deletion changes. Creating a
    new resource alleviates drift (difference in actual versus expected configuration)
    because the new resource aligns with the IaC you use to create it. You can expand
    this beyond server resources to even serverless functions or entire infrastructure
    clusters. You choose to create a new resource with changes instead of updating
    the existing one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性依赖于一系列的创建和删除更改。创建新的资源可以缓解漂移（实际配置与预期配置之间的差异），因为新的资源与创建它的IaC相一致。你可以将此扩展到服务器资源，甚至到无服务器函数或整个基础设施集群。你选择通过创建新的资源来应用更改，而不是更新现有的资源。
- en: Note Machine image builders work with the concept of immutable infrastructure.
    Any updates to a server require a new machine image, which the builder generates
    and provides. Modifications to the server, such as IP address registration, should
    be passed as parameters to a startup script defined by the image builder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：机器镜像构建器与不可变基础设施的概念一起工作。对服务器的任何更新都需要一个新的机器镜像，构建器生成并提供这个镜像。对服务器的修改，如IP地址注册，应作为参数传递给由镜像构建器定义的启动脚本。
- en: The enforcement of immutability affects the way you make changes. Creating a
    new resource requires the principle of reproducibility. As a result, IaC lends
    well to enforcing immutability as you make changes. For example, you might create
    a new firewall each time you need to update it. The new firewall overrides any
    manual rules someone added outside of IaC, facilitating security and reducing
    drift.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的强制执行会影响你进行更改的方式。创建新的资源需要可重复性的原则。因此，IaC（基础设施即代码）在执行更改时很好地支持强制执行不可变性。例如，每次你需要更新防火墙时，你可能都会创建一个新的防火墙。新的防火墙会覆盖任何在IaC之外添加的手动规则，从而促进安全并减少漂移。
- en: Immutability also promotes system availability and mitigates any failures to
    mission-critical applications. Instead of updating an existing resource in place,
    creating a new one isolates changes to the new resource, limiting the blast radius
    if something goes wrong. I discuss more on this in chapter 9.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性还促进了系统可用性，并减轻了对关键任务应用程序的任何故障。而不是原地更新现有资源，创建一个新的资源可以将更改隔离到新的资源中，如果出现问题，可以限制影响范围。我在第9章中对此有更多讨论。
- en: However, immutability sometimes comes at the cost of time and effort. Figure
    2.3 compares the effect of mutable versus immutable infrastructure. When you treat
    the server as a mutable resource, you localize the effect of the Python in-place
    update. Updating Python affects a small part of the server’s overall state. When
    you treat a server immutably, you replace the *entire* server’s state, affecting
    any resources dependent on that server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不可变性有时是以时间和精力为代价的。图2.3比较了可变与不可变基础设施的影响。当你将服务器视为可变资源时，你将Python原地更新的影响局部化。更新Python只会影响服务器整体状态的一小部分。当你以不可变的方式对待服务器时，你会替换掉**整个**服务器的状态，影响任何依赖于该服务器的资源。
- en: Here, replacing the entire state for immutability can take *longer* than changing
    to mutable infrastructure! You cannot expect to treat all infrastructure immutably
    all the time. If you change tens of thousands of servers immutably, you spend
    a few days re-creating all of them. An in-place update may take only a day if
    you don’t break anything.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了不可变性而替换整个状态可能比改变为可变基础设施需要**更长**的时间！你不能期望一直以不可变的方式处理所有基础设施。如果你以不可变的方式更改成千上万的服务器，你可能需要花几天时间重新创建它们。如果一切顺利，原地更新可能只需要一天。
- en: '![](../../OEBPS/Images/CH02_F03_Wang.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F03_Wang.png)'
- en: Figure 2.3 Changes to mutable resources affect a small portion of the infrastructure
    state, while immutable resources replace the entire resource state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 对可变资源的更改影响基础设施状态的一小部分，而不可变资源则替换整个资源状态。
- en: You’ll find that you will switch between treating infrastructure as mutable
    *and* immutable, depending on the circumstance. Immutable infrastructure helps
    mitigate potential risk of failure across your system, while mutable infrastructure
    facilitates faster changes. You often treat infrastructure as mutable when you
    need to fix the system. How do you migrate between mutable and immutable infrastructure?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现，根据情况，您将在将基础设施视为可变和不可变之间切换。不可变基础设施有助于减轻系统潜在的故障风险，而可变基础设施则促进更快的变化。当您需要修复系统时，您通常将基础设施视为可变。您如何在这两种基础设施之间迁移？
- en: 2.2.1 Remediating out-of-band changes
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 修复带外更改
- en: You cannot expect to deploy a new resource every time you make a change. Sometimes
    changes might seem minor in scope and impact. As a result, you decide to make
    the change mutably.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能期望每次更改都部署新的资源。有时更改可能看起来范围和影响很小。因此，您决定以可变的方式做出更改。
- en: Imagine you and your friend meet at a coffee shop. Your friend orders a cappuccino
    with a nondairy alternative. However, the barista adds milk. The barista then
    needs to make a new cappuccino for your friend because the milk affects the whole
    cup. Your friend waits for another 5 to 10 minutes. You get a cup of coffee instead
    and add milk and sugar to taste. If you don’t have enough sugar, you just add
    more.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你和你的朋友在咖啡馆见面。你的朋友点了一杯不含乳制品的卡布奇诺。然而，咖啡师加了一些牛奶。咖啡师随后需要为你的朋友制作一杯新的卡布奇诺，因为牛奶影响了整杯咖啡。你的朋友等待了另外5到10分钟。你得到一杯咖啡，并根据自己的口味添加牛奶和糖。如果你没有足够的糖，你只需再加一些。
- en: You take less time to change your mutable coffee than your friend changing their
    immutable cappuccino. Similarly, it takes far less time, effort, and cost to execute
    changes to a mutable resource. When you temporarily treat infrastructure as a
    mutable resource, you make an *out-of-band* change.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您更改您可变咖啡的时间比您朋友更改他们不可变的卡布奇诺的时间要少。同样，对可变资源执行更改所需的时间、精力和成本要低得多。当您暂时将基础设施视为可变资源时，您进行了一次*带外*更改。
- en: Definition An *out-of-band change* is a quickly implemented change that temporarily
    treats immutable infrastructure as mutable infrastructure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*带外更改*是一种快速实施的变化，暂时将不可变基础设施视为可变基础设施。
- en: When you break immutability with an out-of-band change, you reduce the change
    time but increase the risk of affecting another change in the future. After you
    make the out-of-band change, you need to update your source of truth to return
    to immutable infrastructure. How do you start this remediation process?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过带外更改破坏不可变性时，您减少了更改时间，但增加了将来影响另一个更改的风险。在您进行带外更改后，您需要更新您的真相源以返回到不可变基础设施。您如何开始这个修复过程？
- en: You must reconcile the actual state and desired configuration when making an
    out-of-band change. Let’s apply this to my server example in figure 2.4\. First,
    you log into the server and upgrade Python to version 3\. Then, you change the
    configuration in version control, so new servers install Python version 3\. The
    configuration matches the server’s state with the source of truth in version control.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行带外更改时，您必须协调实际状态和所需配置。让我们将此应用于图2.4中的我的服务器示例。首先，您登录到服务器并将Python升级到版本3。然后，您在版本控制中更改配置，以便新服务器安装Python版本3。配置将服务器的状态与版本控制中的真相源相匹配。
- en: '![](../../OEBPS/Images/CH02_F04_Wang.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F04_Wang.png)'
- en: Figure 2.4 After updating a mutable resource, you need to update version control
    to account for the out-of-band change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 更新可变资源后，您需要更新版本控制以考虑带外更改。
- en: Why should you update IaC for the out-of-band change? Remember from chapter
    1 that manual changes may affect reproducibility. Making sure that you transition
    a change made to mutable infrastructure to future immutable infrastructure preserves
    reproducibility. After remediating the out-of-band change and adding it to IaC,
    you can redeploy changes repeatedly to my server, and nothing should change. This
    behavior conforms to idempotency!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您应该为带外更改更新IaC？记住，从第1章中，手动更改可能会影响可重复性。确保将针对可变基础设施所做的更改过渡到未来的不可变基础设施，以保持可重复性。在修复带外更改并将其添加到IaC后，您可以重复部署更改到我的服务器，而且不应该有任何变化。这种行为符合幂等性！
- en: You will continuously reconcile state and source of truth if you make many mutable
    changes. You should *prioritize immutability* to promote reproducibility. A barista
    can always replace a drink in my coffee example, even if you spill the sugar container
    into your mutable coffee. I recommend using your organization’s change procedures
    to limit out-of-band changes and ensure that the updates align with the configuration
    in IaC. You can always use the immutable infrastructure configuration to fix a
    failed mutable change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行许多可变更改，你将不断协调状态和事实来源。你应该*优先考虑不可变性*以促进可重复性。在我的咖啡例子中，即使你把糖罐洒在你的可变咖啡里，咖啡师也可以总是替换我的饮料。我建议使用你组织的变更程序来限制带外更改，并确保更新与IaC中的配置一致。你总是可以使用不可变的基础设施配置来修复失败的可变更改。
- en: Exercise 2.2
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.2
- en: Which of the following changes benefit from the principle of immutability? (Choose
    all that apply.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些更改受益于不可变性的原则？（选择所有适用的选项。）
- en: A) Reducing a network to have fewer IP addresses
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: A) 减少网络以拥有更少的IP地址
- en: B) Adding a column to a relational database
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: B) 向关系型数据库添加列
- en: C) Adding a new IP address to an existing DNS entry
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C) 向现有的DNS条目添加新的IP地址
- en: D) Updating a server’s packages to backward-incompatible versions
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: D) 将服务器的软件包更新为向后不兼容的版本
- en: E) Migrating infrastructure resources to another region
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: E) 将基础设施资源迁移到另一个区域
- en: See appendix B for answers to exercises.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录B以获取练习的答案。
- en: 2.2.2 Migrating to infrastructure as code
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 迁移到基础设施即代码
- en: Immutability through IaC allows version control to manage infrastructure configuration
    as a source of truth and facilitate future reproduction. In fact, conforming to
    immutability means that you create new resources all the time. It works well for
    *greenfield* environments, which do not have active resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IaC的不可变性，版本控制可以管理基础设施配置作为事实来源，并促进未来的复制。事实上，遵守不可变性意味着你一直在创建新的资源。这对于没有活动资源的*绿色地带*环境来说效果很好。
- en: However, most organizations have *brownfield* environments, an existing environment
    with active servers, load balancers, and networks. Recall that the chapter example
    includes a brownfield development environment called hello-world. You went into
    your infrastructure provider and manually created a set of resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数组织都有*棕色地带*环境，这是一个包含活动服务器、负载均衡器和网络的现有环境。回想一下，本章的示例包括一个名为hello-world的棕色地带开发环境。你进入你的基础设施提供商并手动创建了一系列资源。
- en: In general, a brownfield environment treats infrastructure as mutable. You need
    a way to change your practice of manually changing mutable infrastructure to automatically
    updating immutable IaC. How do you migrate the environment’s infrastructure resources
    to immutability?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，棕色地带环境将基础设施视为可变的。你需要一种方法来改变你手动更改可变基础设施的做法，以自动更新不可变的IaC。你如何将环境的基础设施资源迁移到不可变性？
- en: Let’s migrate the hello-world development environment to immutable IaC. Before
    you begin, you make a list of infrastructure resources in the environment. It
    contains networks, servers, load balancers, firewalls, and Domain Name System
    (DNS) entries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将hello-world开发环境迁移到不可变的IaC。在你开始之前，你列出环境中基础设施资源清单。它包括网络、服务器、负载均衡器、防火墙和域名系统（DNS）条目。
- en: Base infrastructure
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施
- en: To start, you find the base infrastructure resource that other resources need
    to use. For example, every infrastructure resource depends on the network in the
    development environment. You start writing IaC for the database and development
    networks because the server, load balancer, and database run on it. You cannot
    reconstruct any resources that run on the networks until the networks exist as
    code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你找到其他资源需要使用的基基础设施资源。例如，每个基础设施资源都依赖于开发环境中的网络。你开始编写数据库和开发网络的IaC，因为服务器、负载均衡器和数据库都运行在其上。除非网络以代码的形式存在，否则你无法重建运行在网络上任何资源。
- en: '![](../../OEBPS/Images/CH02_F05_Wang.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F05_Wang.png)'
- en: Figure 2.5 Reverse engineer the networks for the database and server first and
    write their configurations as code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 首先逆向工程数据库和服务器网络，并将它们的配置编写为代码。
- en: In figure 2.5, you use your terminal to access the infrastructure provider application
    programming interface (API). Your terminal command prints out the name and IP
    address range (classless inter-domain routing, or CIDR, block) of the development
    database and development networks. You reconstruct each network by copying the
    name and CIDR block of each network into IaC.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.5中，你使用你的终端来访问基础设施提供者应用程序编程接口（API）。你的终端命令打印出开发数据库和开发网络的名称和IP地址范围（无类别域间路由，或CIDR，块）。你通过将每个网络的名称和CIDR块复制到IaC中来重建每个网络。
- en: Why reverse engineer and reproduce the network in IaC? You must match the IaC
    with the network’s actual resource state exactly. If you have a mismatch, called
    *drift*, you’ll find that your IaC may break your network (and anything on it)
    by accident!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在IaC中逆向工程和再现网络？你必须使IaC与网络的实际资源状态完全匹配。如果你有差异，即所谓的*漂移*，你可能会意外地发现你的IaC可能会破坏你的网络（以及它上面的任何东西）！
- en: If possible, import the resource into an IaC state. The resource already exists,
    and you need your provisioning tool to recognize that. The import step migrates
    the existing resource to IaC management. To complete the network resource migration,
    run the IaC again and check that you don’t have drift.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，将资源导入到IaC状态。资源已经存在，你需要你的配置工具识别这一点。导入步骤将现有资源迁移到IaC管理。为了完成网络资源迁移，再次运行IaC并检查你没有漂移。
- en: Many provisioning tools have a function for importing resources. For example,
    CloudFormation uses the `resource import` command. Similarly, Terraform offers
    `terraform import`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 许多配置工具都有导入资源的函数。例如，CloudFormation使用`resource import`命令。同样，Terraform提供`terraform
    import`。
- en: If you write IaC without a provisioning tool, you do not need a direct import
    capability. Instead, you write code to create a new resource. Sometimes it’s easier
    to use reproducibility to create a whole new resource. If you cannot easily create
    a new resource, write code with conditional statements that check whether the
    resources exist.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用配置工具编写IaC，你不需要直接导入功能。相反，你编写代码来创建一个新的资源。有时使用可重复性来创建全新的资源更容易。如果你不能轻松创建新资源，编写带有条件语句的代码来检查资源是否存在。
- en: '![](../../OEBPS/Images/CH02_F06_Wang.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F06_Wang.png)'
- en: Figure 2.6 The decision workflow for migration helps you decide how to import
    your infrastructure with a provisioning tool, re-create a resource, or build conditional
    statements to check for resource existence. No matter which option, you must rerun
    your IaC and reconcile any drift.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 迁移决策流程帮助你决定如何使用配置工具导入你的基础设施，重新创建资源，或构建条件语句以检查资源是否存在。无论哪种选择，你都必须重新运行你的IaC并解决任何漂移。
- en: Figure 2.6 captures the entire decision workflow of reconstructing the network
    and whether you can use a provisioning tool to migrate your resource to immutability.
    The diagram includes the considerations for creating new resources or writing
    conditional statements for existing resources. As you migrate, you run your IaC
    multiple times to check for drift.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6捕捉了重建网络的全过程以及你是否可以使用配置工具将资源迁移到不可变性。该图包括创建新资源或为现有资源编写条件语句的考虑因素。在迁移过程中，你多次运行IaC以检查漂移。
- en: Why do you have so many decision workflows for migrating to immutability? All
    of these practices adhere to the principles of reproducibility, idempotency, and
    composability. You want to reproduce the resources in IaC as accurately as possible.
    If you can’t import the resource, you can at least reproduce a new one.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你有这么多迁移到不可变性决策流程？所有这些实践都遵循可重复性、幂等性和可组合性的原则。你希望尽可能准确地再现IaC中的资源。如果你无法导入资源，至少可以重新创建一个新的资源。
- en: Furthermore, rerunning the code uses the principle of idempotency, which ensures
    that you don’t re-create the resource (unless necessary). If you reconcile drift,
    idempotency should not change the active network. Similarly, composability allows
    you to migrate each resource separately to avoid disrupting the system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重新运行代码使用幂等性原则，这确保了你不会重新创建资源（除非必要）。如果你解决漂移，幂等性不应改变活动网络。同样，可组合性允许你分别迁移每个资源，以避免破坏系统。
- en: As you work on other resources, keep the decision workflow in mind. You can
    apply it to each resource you migrate to IaC until you complete the migration.
    You’ll revisit parts of this decision workflow when you refactor IaC in chapter
    10.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理其他资源时，请记住决策流程。你可以将其应用于你迁移到IaC的每个资源，直到完成迁移。当你第10章重构IaC时，你将重新访问这个决策流程的某些部分。
- en: Resources dependent on base infrastructure
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于基础基础设施的资源
- en: After reconstructing the base network infrastructure, you can work on the servers
    and other components. Once again, you use your terminal to print out attributes
    for the hello-world server. It runs in region A with an Ubuntu operating system
    and one CPU. You write the server specification in its configuration, making note
    of its dependency on the development network. Similarly, you use your terminal
    to learn that the database uses 10 GB of memory. You copy this into IaC and record
    its use of the development database network. Figure 2.7 shows the process of migrating
    the server and database to code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在重建基础网络基础设施之后，你可以开始处理服务器和其他组件。再次使用你的终端来打印出hello-world服务器的属性。它在区域A运行，使用Ubuntu操作系统和一颗CPU。你将服务器规范写入其配置中，并注意其依赖于开发网络。同样，你使用终端了解到数据库使用了10
    GB的内存。你将这个信息复制到IaC中，并记录其使用开发数据库网络。图2.7显示了将服务器和数据库迁移到代码的过程。
- en: You want to migrate the second set of resources that use the network. Use composability
    to isolate these infrastructure resources and make iterative updates. Small changes
    to next levels of infrastructure help prevent larger system failures. In chapter
    7, you’ll learn more about deploying small changes to infrastructure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要迁移使用网络的第二组资源。使用可组合性来隔离这些基础设施资源，并进行迭代更新。对下一层次基础设施的小幅改动有助于防止更大的系统故障。在第7章中，你将学习更多关于向基础设施部署小幅改动的内容。
- en: Before you move to the next set of resources, complete the cycle of migration
    by running your IaC and checking for drift. Ensure that the network, server, and
    database do not show changes in their IaC. After you reconcile any new drift,
    you can move onto the remaining resources (DNS, firewall rules, and load balancers).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移下一组资源之前，通过运行IaC并检查漂移来完成迁移周期。确保网络、服务器和数据库在其IaC中不显示任何变化。在解决任何新的漂移后，你可以继续迁移剩余的资源（DNS、防火墙规则和负载均衡器）。
- en: '![](../../OEBPS/Images/CH02_F07_Wang.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F07_Wang.png)'
- en: Figure 2.7 After migrating base infrastructure such as networks, migrate the
    server and database resources. They depend on base infrastructure but do not depend
    on each other.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 在迁移了基础基础设施，如网络之后，迁移服务器和数据库资源。它们依赖于基础基础设施，但彼此之间并不依赖。
- en: Finally, figure 2.8 rebuilds the remaining configuration for DNS, firewall rules,
    and load balancers. They depend on the existing configuration of servers and databases.
    No other resources depend on them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，图2.8重建了DNS、防火墙规则和负载均衡器的剩余配置。它们依赖于服务器和数据库的现有配置。没有其他资源依赖于它们。
- en: '![](../../OEBPS/Images/CH02_F08_Wang.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F08_Wang.png)'
- en: Figure 2.8 Finally, migrate resources with the fewest dependencies or require
    server and database configuration.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 最后，迁移依赖性最少或需要服务器和数据库配置的资源。
- en: Why go through the painstaking process of reconstructing various levels of infrastructure?
    Your brownfield environment did not have a consistent *source of truth*, so you
    need to build one. When you finish adding the infrastructure resources to the
    configuration, you reconstruct a source of truth for the environment. A source
    of truth with IaC allows you to treat the brownfield environment as immutable
    infrastructure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要经历重建各个层次基础设施的繁琐过程？你的棕色地带环境没有一个一致的*真相来源*，因此你需要建立一个。当你完成将基础设施资源添加到配置中后，你重建了环境的真相来源。IaC中的真相来源允许你将棕色地带环境视为不可变基础设施。
- en: Outside of the example, you’ll always migrate to immutability from base to top-level
    resources. Identify resources that others heavily depend upon when you start the
    migration. Write these low-level resources—such as networks, accounts or projects,
    and IAM—into IaC.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了示例之外，你总会从基础资源迁移到顶层资源的不可变性。在开始迁移时，识别出其他人高度依赖的资源。将这些低级资源——如网络、账户或项目以及IAM——写入IaC中。
- en: Next, choose resources such as servers, queues, or databases. Firewalls, load
    balancers, DNS, and alerts depend on the existence of servers, queues, and databases.
    You can migrate resources with the fewest dependencies at the end of the process.
    We’ll discuss more about infrastructure dependencies in chapter 4.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择服务器、队列或数据库等资源。防火墙、负载均衡器、DNS和警报依赖于服务器、队列和数据库的存在。你可以在过程结束时迁移依赖性最少的资源。我们将在第4章中讨论更多关于基础设施依赖的内容。
- en: Note A *dependency graph* represents the dependencies among infrastructure resources.
    IaC tools, such as Terraform, use this concept to apply changes in a structured
    way. When you migrate resources, you reconstruct the dependency graph. You can
    investigate tooling that will map the live infrastructure state for you and highlight
    dependencies to make this easier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：**依赖关系图**表示基础设施资源之间的依赖关系。例如，Terraform等IaC工具使用这个概念以结构化的方式应用更改。当您迁移资源时，您会重新构建依赖关系图。您可以调查工具，这些工具可以帮助您映射实时基础设施状态并突出显示依赖关系，从而使这更容易。
- en: Migration steps
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移步骤
- en: 'I usually follow general steps to assess dependencies and structure migrating
    existing resources to IaC:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常遵循以下一般步骤来评估依赖关系并将现有资源结构化迁移到IaC：
- en: Migrate *initial login, accounts, and provider resource isolation constructs*.
    For example, I write the configuration for a cloud provider’s account or project
    and my initial service account for automation.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移**初始登录、账户和提供者资源隔离结构**。例如，我为云提供商的账户或项目以及我的初始服务账户编写了自动化配置。
- en: Migrate *networks, subnetworks**, routing, and root DNS* *configuration*, if
    applicable. The root DNS configuration can include Secure Sockets Layer (SSL)
    certificates. For example, I created the root domain hello-world.net and its SSL
    certificate to prepare for subdomains such as dev.hello-world.net.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果适用，迁移**网络、子网络**、路由和**根DNS**配置。根DNS配置可以包括安全套接字层（SSL）证书。例如，我创建了根域名hello-world.net及其SSL证书，为dev.hello-world.net等子域做准备。
- en: Migrate *computing resources* such as application servers or databases.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移**计算资源**，例如应用程序服务器或数据库。
- en: Migrate the *compute orchestration platform and its components* if you use a
    compute orchestration platform. For example, I migrate my Kubernetes cluster to
    schedule workloads across servers.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用计算编排平台，则需要迁移**计算编排平台及其组件**。例如，我将我的Kubernetes集群迁移以跨服务器调度工作负载。
- en: If you use a compute orchestration platform, migrate the *application deployments
    to the compute orchestration platform*. For example, I backport the configuration
    of the hello-world application deployed on Kubernetes.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用计算编排平台，则需要将**应用程序部署迁移到计算编排平台**。例如，我将部署在Kubernetes上的hello-world应用程序的配置回滚。
- en: Migrate *messaging queues**, caches**, or event-streaming platforms*. These
    services have application dependencies before you can reconstruct them. For example,
    I write the configuration for a messaging queue to communicate between hello-world
    and another application.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移**消息队列**、**缓存**或**事件流平台**。在您能够重新构建它们之前，这些服务具有应用程序依赖项。例如，我为hello-world和另一个应用程序之间的通信编写了消息队列的配置。
- en: Migrate *DNS subdomains**, load balancers, and firewalls*. For example, I re-create
    a configuration for a firewall rule between my hello-world application and its
    database.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移**DNS子域**、**负载均衡器**和**防火墙**。例如，我为hello-world应用程序及其数据库之间的防火墙规则重新创建了一个配置。
- en: Migrate *alerts or monitoring* related to resources. For example, I reconstruct
    my configuration to notify me if the hello-world application fails.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移与资源相关的**警报或监控**。例如，我重构了我的配置，以便在hello-world应用程序失败时通知我。
- en: Finally, migrate *SaaS resources*, such as data processing or repositories,
    that do not depend on applications. For example, this could be a data transform
    job on GCP that has a singular dependency on a database.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，迁移**SaaS资源**，例如不依赖于应用程序的数据处理或存储库。例如，这可能是GCP上对数据库有单一依赖的数据转换作业。
- en: Between each step, make sure you *test* that you’ve correctly migrated the initial
    resources by rerunning the configuration. You rarely get all the parameters and
    dependencies you need on the first try.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤之间，确保您通过重新运行配置来**测试**您是否已正确迁移了初始资源。您很少能在第一次尝试时就获得所有所需的参数和依赖项。
- en: Note Rerunning the migrated configuration should *not* change existing infrastructure
    because of idempotency. You should reapply the configuration and check the dry
    run. Changes in your dry run mean your configuration has not accurately captured
    the actual state of the resource.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：重新运行迁移后的配置**不应**因为幂等性而更改现有基础设施。您应该重新应用配置并检查dry run。dry run中的更改意味着您的配置没有准确捕捉到资源的实际状态。
- en: If you run the configuration and it outputs changes, you must correct your configuration!
    The process requires trial and error. As a result, I recommend you test and verify
    each set of resources.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行配置并输出更改，您必须纠正您的配置！这个过程需要反复试验。因此，我建议您测试和验证每一组资源。
- en: Migrating to immutability becomes an exercise in reducing drift. This process
    shows an extreme circumstance where the configuration has drifted far from the
    state. You work to reconcile the source of truth by updating its configuration
    in version control. The process of importing existing resources to a new source
    of truth applies to refactoring IaC, something we’ll discuss in chapter 10.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到不可变性成为减少漂移的练习。这个过程展示了配置与状态相差甚远的极端情况。你通过在版本控制中更新其配置来努力调和真相来源。将现有资源导入新真相来源的过程适用于重构IaC，我们将在第10章中讨论这一点。
- en: 2.3 Writing clean infrastructure as code
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 编写干净的基础设施代码
- en: Besides using immutability, you can promote reproducibility by writing configuration
    cleanly. *Code hygiene* refers to a set of practices to enhance the readability
    and structure of code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用不可变性之外，通过干净地编写配置，你还可以通过以下方式促进可重复性：*代码卫生*指的是一套旨在提高代码可读性和结构的实践。
- en: Definition *Code hygiene* is a set of practices and styles to enhance the readability
    and maintainability of code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*代码卫生*是一套旨在提高代码可读性和可维护性的实践和风格。
- en: IaC hygiene helps save time when you need to reuse the configuration. I often
    find infrastructure configuration copied, pasted, and edited with hardcoded values.
    Hardcoded values reduce readability and reproducibility. While many of these practices
    come from software development, I suggest some practices specific to infrastructure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码的卫生有助于在需要重用配置时节省时间。我经常发现基础设施配置被复制、粘贴并使用硬编码的值进行编辑。硬编码的值降低了可读性和可重复性。虽然许多这些实践来自软件开发，但我建议一些特定于基础设施的实践。
- en: 2.3.1 Version control communicates context
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 版本控制传达上下文
- en: 'How do you use version control effectively to enable reproducibility? Structured
    practices around version control help you quickly reproduce configuration and
    make informed changes. For example, you might update a firewall rule in development
    that allows traffic from `app-network` to `shared-services-network`. You add the
    following commit message to describe why you added the allowance:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何有效地使用版本控制来实现可重复性？围绕版本控制的系统化实践可以帮助你快速重现配置并做出明智的更改。例如，你可能在开发中更新了防火墙规则，允许`app-network`网络流量访问`shared-services-network`。你添加以下提交信息来描述为什么添加了权限：
- en: '[PRE1]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A few weeks later, you reproduce the network in production. However, you forgot
    why you added the allowance. When you examine the commit history, you remember
    your descriptive message. You now have information that the application needs
    to access queues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 几周后，你在生产环境中重新创建了网络。然而，你忘记了为什么添加了权限。当你检查提交历史时，你记得你的描述性信息。你现在有了应用程序需要访问队列的信息。
- en: When you write commit messages for IaC, you do not need to explain the configuration.
    The change already captures what the configuration will be. Instead, use the commit
    message to explain *why* you want to make the change and *how* it will affect
    other infrastructure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为IaC编写提交信息时，你不需要解释配置。更改已经捕捉到了配置将是什么样子。相反，使用提交信息来解释你想要进行更改的原因以及它将如何影响其他基础设施。
- en: Note In this book, I address version control practices specific to IaC. To learn
    more about version control, check out the “Getting Started—About Version Control”
    Git tutorial at [http://mng.bz/pOBR](http://mng.bz/pOBR). For more on writing
    good commit messages, check out “Distributed Git—Contributing to a Project” at
    [http://mng.bz/OoMj](http://mng.bz/OoMj). Content for both is from *Pro Git* by
    Scott Chacon and Ben Straub (Apress, 2014).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我讨论了与基础设施即代码（IaC）相关的特定版本控制实践。要了解更多关于版本控制的信息，请查看“入门指南——关于版本控制”的Git教程，网址为[http://mng.bz/pOBR](http://mng.bz/pOBR)。有关编写良好的提交信息，请查看“分布式Git——为项目做贡献”的相关内容，网址为[http://mng.bz/OoMj](http://mng.bz/OoMj)。这两部分内容均来自Scott
    Chacon和Ben Straub所著的《Pro Git》（Apress，2014年）。
- en: 'You also might have an audit requirement to prefix an issue number or ticket
    number to the front of the commit message for traceability. For example, you might
    work on a ticket numbered TICKET-002\. It contains a request to allow traffic
    between the application and shared services. To correlate the ticket to your commit,
    you add the ticket to the start of the commit message:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还有审计要求，需要在提交信息的前面加上问题编号或工单编号以实现可追溯性。例如，你可能正在处理编号为TICKET-002的工单。它包含允许应用程序和共享服务之间流量请求。为了将工单与你的提交关联起来，你将工单添加到提交信息的开头：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding the work item or ticket information to commit messages makes it easier
    to track changes. Configuration becomes change documentation because it is the
    source of truth for infrastructure resources. Version control also becomes a mechanism
    for documenting changes. You can reconstruct the history of changes and reproduce
    environments by examining version control and configuration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作项或票据信息添加到提交信息中可以使跟踪更改变得更容易。配置成为变更文档，因为它是基础设施资源的真相来源。版本控制也变成了记录变更的机制。您可以通过检查版本控制和配置来重建变更历史并重现环境。
- en: 2.3.2 Linting and formatting
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 代码检查和格式化
- en: Before you commit your code, you want to lint it and format it. IaC often will
    not execute because you missed a space (or two) or used the wrong field name.
    The wrong field name could lead to an error. Misaligned code can often cause you
    to misread or skip a configuration line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交代码之前，您希望对其进行代码检查和格式化。IaC（基础设施即代码）通常不会执行，因为您遗漏了一个或两个空格，或者使用了错误的字段名称。错误的字段名称可能会导致错误。代码对齐不当通常会导致您误读或跳过配置行。
- en: Imagine you configure a server, and it needs a field called `ip_address`. Instead,
    you name the field `ip` and later realize you cannot create the server with your
    IaC. How can you make sure you’ve written the field as `ip_address`?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您配置了一个服务器，它需要一个名为`ip_address`的字段。相反，您将字段命名为`ip`，后来意识到您无法使用IaC创建该服务器。您如何确保您已将字段编写为`ip_address`？
- en: You can use *linting* to analyze your code and verify nonstandard or incorrect
    configurations. Most tools offer a way to lint the configuration or code. Linting
    for `ip_address` catches the wrong field name of `ip` early in development.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*代码检查*来分析您的代码并验证非标准或不正确的配置。大多数工具都提供了一种检查配置或代码的方法。对`ip_address`的代码检查可以在开发早期捕捉到`ip`字段名称的错误。
- en: Definition *Linting* automatically checks the style of your code for nonstandard
    configuration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *代码检查* 自动检查代码的非标准配置风格。
- en: Why check for nonstandard or incorrect configuration? You want to make sure
    you write the proper configuration and don’t miss critical syntax. If the tool
    does not have a linting feature, you can always find a community extension or
    write your own linting rules with a programming language. You should include linting
    rules that address security standards, such as no secrets committed to version
    control (chapter 8).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要检查非标准或不正确的配置？您希望确保您编写了正确的配置，并且没有遗漏关键的语法。如果工具没有代码检查功能，您总是可以找到一个社区扩展或使用编程语言编写自己的代码检查规则。您应该包括解决安全标准的代码检查规则，例如不要将秘密提交到版本控制（第8章）。
- en: Besides linting, you can use *formatting* to check for spacing and configuration
    formats. Formatting might seem obvious as a software development practice, but
    it becomes more critical in IaC.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码检查之外，您还可以使用*格式化*来检查空格和配置格式。格式化在软件开发实践中可能看起来很显然，但在IaC中变得更为关键。
- en: Definition *Formatting* automatically aligns your code for correct spacing and
    configuration formats.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *格式化* 自动对齐您的代码以正确设置空格和配置格式。
- en: Most tools use domain-specific languages (DSLs) that offer a higher level of
    abstraction for a programming language. A DSL provides a lower barrier to entry
    if you don’t know a programming language. These languages use YAML or JSON data
    formats with particular format requirements. Having tools to check formatting,
    such as whether you missed a space in your YAML file, is helpful!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工具使用特定于域的语言（DSLs），这为编程语言提供了更高层次的表达。如果您不了解编程语言，DSL提供了一个较低的入门门槛。这些语言使用具有特定格式要求的YAML或JSON数据格式。拥有检查格式的工具，例如检查您的YAML文件中是否遗漏了空格，是有帮助的！
- en: You can also add version control hooks to run formatting checks before committing
    your code. For example, you might create your infrastructure resources with CloudFormation
    in YAML data format. To validate the infrastructure resource fields and values,
    you use the AWS CloudFormation Linter ([http://mng.bz/YGrj](http://mng.bz/YGrj)).
    You also format the YAML file with the AWS CloudFormation Template Formatter ([http://mng.bz/GEVA](http://mng.bz/GEVA)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加版本控制钩子，在提交代码之前运行格式化检查。例如，您可能使用YAML数据格式使用CloudFormation创建您的基础设施资源。为了验证基础设施资源字段和值，您使用AWS
    CloudFormation Linter（[http://mng.bz/YGrj](http://mng.bz/YGrj)）。您还使用AWS CloudFormation
    Template Formatter（[http://mng.bz/GEVA](http://mng.bz/GEVA)）对YAML文件进行格式化。
- en: Rather than remember to type these commands each time, you can add the commands
    as a pre-commit Git hook. Each time you run `git` `commit`, the command checks
    for a proper configuration and format before pushing them to a repository. You
    can also add them to a continuous delivery workflow, which I cover in chapter
    7.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都记得输入这些命令，你可以将这些命令添加为预提交的 Git 钩。每次你运行 `git commit`，该命令都会在将它们推送到仓库之前检查配置和格式是否正确。你还可以将它们添加到持续交付工作流程中，这我在第
    7 章中有所介绍。
- en: 2.3.3 Naming resources
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 资源命名
- en: When your IaC becomes documentation, your resources, configuration, and variables
    need descriptive names. I once created a firewall rule to test something and called
    it `firewall-rule-1`. Two weeks later, when I wanted to reproduce it into production,
    I did not remember why I created the rule in development.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的基础设施即代码（IaC）成为文档时，你的资源、配置和变量需要具有描述性的名称。我曾经创建了一个防火墙规则来测试某些内容，并将其命名为 `firewall-rule-1`。两周后，当我想要将其复制到生产环境中时，我记不起为什么我在开发环境中创建了这个规则。
- en: In retrospect, I should have named the firewall rule something more descriptive.
    I spent another 30 minutes tracking down the rule’s IP addresses and allowances.
    Naming can affect the time you spend deciphering what the infrastructure does
    and how it differs in another environment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾起来，我应该给防火墙规则起一个更具描述性的名字。我花了另外 30 分钟追踪该规则的 IP 地址和权限。命名可能会影响你花费在解析基础设施做什么以及它在另一个环境中如何不同的时间。
- en: Resource names should include the *environment*, the infrastructure *resource
    type*, and its *purpose*. Figure 2.9 names the firewall rule `dev-firewall-rule-allow-hello-world-to-database`,
    which includes the environment (`dev`), the resource type (`firewall-rule`), and
    the purpose (`allow-hello-world-to-database`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 资源名称应包括*环境*、*基础设施资源类型*和其*用途*。图 2.9 将防火墙规则命名为 `dev-firewall-rule-allow-hello-world-to-database`，其中包括环境（`dev`）、资源类型（`firewall-rule`）和用途（`allow-hello-world-to-database`）。
- en: '![](../../OEBPS/Images/CH02_F09_Wang.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F09_Wang.png)'
- en: Figure 2.9 The resource name should include the environment, type, and purpose.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 资源名称应包括环境、类型和用途。
- en: Why should names involve so much detail? You want to identify the resource quickly
    for troubleshooting, sharing, and auditing. Noticing the environment at a glance
    ensures that you configure the right one (and not production by accident). The
    purpose tells others and reminds yourself what the resource does.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么名字需要包含这么多细节呢？你希望快速识别资源以进行故障排除、共享和审计。一眼就能识别环境可以确保你配置了正确的环境（而不是意外地配置了生产环境）。目的告诉其他人并提醒自己资源的作用。
- en: Optionally, you can include the resource type. I usually omit resource type
    from the name because I identify it from resource metadata. Omitting the resource
    type allows you to conform to your cloud provider’s character limit. If you want
    to include more information about the purpose or type of your resource, you can
    always include it in the resource’s tags (chapter 8).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以包括资源类型。我通常在名称中省略资源类型，因为我从资源元数据中识别它。省略资源类型可以使你符合云提供商的字符限制。如果你想包含更多关于资源用途或类型的信息，你总是可以在资源的标签（第
    8 章）中包含它。
- en: Describe the resource to someone else
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 向其他人描述资源
- en: When I name a resource, I try to describe it to someone else. If another person
    understands the resource based on the name, I know it is good. However, I know
    it needs more information if someone needs to ask additional questions about the
    environment or resource type.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为资源命名时，我会尝试向其他人描述它。如果其他人根据名称就能理解资源，我知道这是一个好名字。然而，如果有人需要就环境或资源类型提出更多问题，我知道它还需要更多信息。
- en: This exercise can make the names a little long, but I err on the side of being
    more descriptive. Recognizing the resource’s purpose based on its name saves valuable
    time reconstructing the environment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习可能会使名称变得稍微长一些，但我更倾向于更详细的描述。根据名称识别资源的用途可以节省宝贵的时间来重建环境。
- en: Besides resource names, you also want to make variables and configurations as
    descriptive as possible. Most infrastructure providers have specific resource
    attribute naming. AWS refers to a network’s IP address as the `CidrBlock`, while
    Azure refers to it as an `address_space`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了资源名称之外，你还希望变量和配置尽可能具有描述性。大多数基础设施提供商都有特定的资源属性命名。AWS 将网络的 IP 地址称为 `CidrBlock`，而
    Azure 则将其称为 `address_space`。
- en: I lean toward using the provider’s specific naming to facilitate looking up
    documentation for the provider for later changes and reproduction. If I rename
    the configuration for Azure to `cidr_block`, I have to remember to translate the
    parameter to `address_space` for Azure to consume it. You need to remember to
    translate a more generic field name for variables or configurations to another
    provider or environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于使用提供者的特定命名来方便查找提供者的文档，以便稍后进行更改和复制。如果我将 Azure 的配置重命名为 `cidr_block`，我必须记得将其参数转换为
    `address_space` 以供 Azure 使用。你需要记得将更通用的字段名称翻译为变量或配置的另一个提供者或环境。
- en: 2.3.4 Variables and constants
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 变量和常量
- en: Besides naming variables, how do you know which values should be variables?
    Let’s say the hello-world application always serves on port 8080\. You don’t plan
    on changing the port often, so you set it to `application_port = 8080` at the
    beginning of your configuration. However, you hardcode `hello-world` directly
    into the `name` attributes of your infrastructure resources.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命名变量，你如何知道哪些值应该作为变量？比如说，hello-world 应用程序始终在端口 8080 上提供服务。你并不打算经常更改端口，所以你在配置文件的开头将其设置为
    `application_port = 8080`。然而，你直接将 `hello-world` 编译到你的基础设施资源的 `name` 属性中。
- en: One year later, you reproduce the environment for a new version of hello-world
    on port 3000\. You want the new value of `name` as `hello-world-v2`. You update
    `application_port` at the beginning of your configuration to `3000`. Putting the
    port in a variable allows you to reference the `application_port` throughout your
    configuration and store the value in one place. You congratulate yourself on not
    needing to find and replace instances of 8080 in your configuration. However,
    you spend an hour searching for all instances of `hello-world` in your infrastructure
    configuration to change its name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一年后，你为 hello-world 的新版本在端口 3000 上重新创建了环境。你希望新的 `name` 值为 `hello-world-v2`。你将配置文件开头的
    `application_port` 更新为 `3000`。将端口放入变量中允许你在整个配置中引用 `application_port` 并将值存储在一个地方。你为自己不需要在配置中查找并替换
    8080 的实例而感到自豪。然而，你花了整整一个小时在基础设施配置中寻找所有 `hello-world` 的实例以更改其名称。
- en: In this example, you have two types of inputs. A *variable* stores a value referenced
    by infrastructure configuration. Most infrastructure values are best stored in
    variables and referenced by the configuration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你有两种类型的输入。一个 *变量* 存储一个由基础设施配置引用的值。大多数基础设施值最好存储在变量中并由配置引用。
- en: Definition A *variable* stores a value referenced by infrastructure configuration.
    You expect to change the value of a variable anytime you create a new resource
    or environment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *变量* 存储一个由基础设施配置引用的值。你期望在创建新资源或环境时随时更改变量的值。
- en: You should set the application’s name, `hello-world`, as a variable because
    it will change depending on the environment, version, or purpose. However, the
    port does not change based on environment or purpose. A *constant* variable sets
    a common value across a set of resources and rarely changes with environment or
    purpose.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将应用程序的名称 `hello-world` 设置为变量，因为它将根据环境、版本或目的而变化。然而，端口不会根据环境或目的而变化。一个 *常量*
    变量在一系列资源中设置一个共同的值，并且很少随着环境或目的而变化。
- en: Definition A *constant* variable establishes a common value across infrastructure
    configuration. You do not change constants often.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *常量* 变量在基础设施配置中建立了一个共同的值。你不会经常更改常量。
- en: When deciding when to make a configuration value a variable or constant, consider
    the impact and security implications of changing the value. The frequency of change
    matters less. If changing the value affects infrastructure dependencies or compromises
    sensitive information, set it as a variable. You should always set names or environments
    as variables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定何时将配置值设置为变量或常量时，考虑更改值的影响和安全影响。变化的频率并不重要。如果更改值会影响基础设施依赖项或泄露敏感信息，则将其设置为变量。你应该始终将名称或环境设置为变量。
- en: Unlike software development, which pushes for fewer constants, IaC *prioritizes
    constants over variables*. Avoid setting too many variables because they make
    the configuration challenging to maintain. Instead, you can set a constant by
    defining a local variable with a static configuration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与软件开发不同，软件开发倾向于使用更少的常量，IaC *更重视常量而非变量*。避免设置过多的变量，因为它们会使配置难以维护。相反，你可以通过定义具有静态配置的本地变量来设置常量。
- en: For example, Terraform uses local values ([www.terraform.io/docs/language/values/locals.xhtml](https://www.terraform.io/docs/language/values/locals.xhtml))
    to store constants. Commonly defined constants include operating systems, tags,
    account identifiers, or domain names. Standardized values on infrastructure providers
    such as `internal` or `external` to describe a type of network can also be constant.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Terraform使用本地值([www.terraform.io/docs/language/values/locals.xhtml](https://www.terraform.io/docs/language/values/locals.xhtml))来存储常量。常见定义的常量包括操作系统、标签、账户标识符或域名。在`internal`或`external`等基础设施提供商上标准化的值，用于描述网络类型，也可以是常量。
- en: 2.3.5 Parametrize dependencies
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 参数化依赖
- en: When you create a server, you need to specify the network it needs to use. You
    initially express this by hardcoding the name of the network you want, specifically
    `development`. When you read the configuration, you know precisely which network
    the server uses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建服务器时，你需要指定它需要使用的网络。你最初通过硬编码你想要的网络名称来表达这一点，特别是`development`。当你读取配置时，你确切地知道服务器使用的是哪个网络。
- en: However, you realize that when you have to reproduce this for production, you
    need to search and replace any reference of `development` with `production`. Problematically,
    you have multiple references to `development`! Your search-and-replace mission
    becomes a few tedious hours.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你需要为生产环境重现此操作时，你需要搜索并替换所有对`development`的引用。问题在于，你有多个对`development`的引用！你的搜索和替换任务变成了几个小时的繁琐工作。
- en: Code example
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例
- en: You decide to parametrize the GCP network as a variable so you can reproduce
    a server in another environment with a different network. When you pass the network
    name as a variable, you change the network for any server referencing it. Let’s
    pass the name of the network as a variable in code as follows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定将GCP网络参数化为变量，这样你就可以在另一个环境中使用不同的网络重现服务器。当你传递网络名称作为变量时，你更改了任何引用该网络的任何服务器的网络。让我们按照以下方式在代码中将网络名称作为变量传递。
- en: Listing 2.1 Parametrize the network as a variable
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 将网络作为变量参数化
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Passes the name and network as parameters to the configuration
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将名称和网络作为参数传递给配置
- en: ❷ Uses Terraform’s google_compute_instance resource to configure a server
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Terraform的google_compute_instance资源配置服务器
- en: ❸ Sets the network by using the “network” variable
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“network”变量设置网络
- en: ❹ Sets the network dependency as the default network when you run the script
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当你运行脚本时，将网络依赖设置为默认网络
- en: ❺ Creates a JSON file with the server object and runs it with Terraform
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建包含服务器对象的JSON文件，并使用Terraform运行它
- en: AWS and Azure equivalents
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure等效
- en: In AWS, you would use the `aws_instance` Terraform resource with a reference
    to the network you want to use ([http://mng.bz/z4j6](http://mng.bz/z4j6)). You
    can create this resource on the default virtual private cloud (VPC).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中，你会使用带有要使用网络引用的`aws_instance` Terraform资源([http://mng.bz/z4j6](http://mng.bz/z4j6))。你可以在默认的虚拟专用云(VPC)上创建此资源。
- en: In Azure, you would need to create a virtual network and subnets, then create
    the `azurerm_linux_virtual_machine` Terraform resource ([http://mng.bz/064E](http://mng.bz/064E))
    on the network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中，你需要创建虚拟网络和子网，然后在网络上创建`azurerm_linux_virtual_machine` Terraform资源([http://mng.bz/064E](http://mng.bz/064E))。
- en: Why pass the name and network as variables? You often change the name and network
    depending on the environment. Parametrizing these values helps with reproducibility
    and composability. You can create new resources on different networks *and* build
    multiple resources without worrying about conflicts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么传递名称和网络作为变量？你经常根据环境更改名称和网络。参数化这些值有助于可重复性和可组合性。你可以在不同的网络上创建新资源，并且可以构建多个资源而不用担心冲突。
- en: Running the example
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'I’ll run the example step-by-step to celebrate our first hello-world server.
    Refer to chapter 1 for more information on the tools required for the examples
    and appendix A for detailed usage instructions. Here are the steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐步运行示例，以庆祝我们的第一个hello-world服务器。有关示例所需的工具的更多信息，请参阅第1章，有关详细使用说明，请参阅附录A。以下是步骤：
- en: 'Run the script in Python by entering the command in the terminal:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中输入命令来使用Python运行脚本：
- en: '[PRE4]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The command creates a file with the extension *.tf.json. Terraform will automatically
    search for this file extension to create the resources.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令创建一个扩展名为*.tf.json的文件。Terraform将自动搜索此文件扩展名以创建资源。
- en: 'Check whether the file exists by listing files in the terminal:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中列出文件来检查文件是否存在：
- en: '[PRE5]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be as follows:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE6]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Authenticate to GCP in the terminal:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中验证GCP：
- en: '[PRE7]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Set the GCP project you want to use as the `CLOUDSDK_CORE_PROJECT` environment
    variable:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您想要使用的GCP项目设置为`CLOUDSDK_CORE_PROJECT`环境变量：
- en: '[PRE8]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Initialize Terraform to retrieve the GCP plugin in the terminal:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中初始化Terraform以检索GCP插件：
- en: '[PRE9]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should include the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应包括以下内容：
- en: '[PRE10]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Apply the Terraform configuration in the terminal. Ensure that you enter `yes`
    to apply the changes and create the instance:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中应用Terraform配置。确保您输入`yes`以应用更改并创建实例：
- en: '[PRE11]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Your output should include the configuration and name of the server instance:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的输出应包括服务器实例的配置和名称：
- en: '[PRE12]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note I do not go through all of the nuances of Terraform in this book. For detailed
    information on getting started with Terraform, check out the HashiCorp “Get Started”
    tutorial at [https://learn.hashicorp.com/terraform](https://learn.hashicorp.com/terraform).
    You can find additional documentation on how Terraform works with GCP at [http://mng.bz/Kx2g](http://mng.bz/Kx2g).
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我不会详细介绍Terraform的所有细微差别。有关开始使用Terraform的详细信息，请查看HashiCorp的“入门”教程[https://learn.hashicorp.com/terraform](https://learn.hashicorp.com/terraform)。您可以在[http://mng.bz/Kx2g](http://mng.bz/Kx2g)找到有关Terraform如何与GCP一起工作的附加文档。
- en: 'You can examine the GCP console for the server’s network and metadata. Otherwise,
    you can use the Cloud SDK command-line interface (CLI) to check the network in
    the terminal. Enter the command to filter out the hello-world server:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在GCP控制台中检查服务器的网络和元数据。否则，您可以使用Cloud SDK命令行界面（CLI）在终端中检查网络。输入命令以过滤出hello-world服务器：
- en: '[PRE13]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should include the GCP URL of the network:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应包括网络的GCP URL：
- en: '[PRE14]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The GCP server uses the `default` network, which you passed as a variable to
    the example. If you want to change the network, you update the new variable. Your
    IaC tooling will pick up the changes and create a new server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: GCP服务器使用`default`网络，您将其作为变量传递给示例。如果您想更改网络，请更新新变量。您的IaC工具将检测到更改并创建新的服务器。
- en: 'To destroy the server, you can use Terraform in the terminal. Make sure you
    enter `yes` to remove the server altogether:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁服务器，您可以在终端中使用Terraform。确保您输入`yes`以完全删除服务器：
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you define dependencies as variables, you loosely couple the two infrastructure
    resources. Chapter 4 covers specific patterns you can use to decouple infrastructure
    resources and dependencies further. If possible, you should avoid hardcoding dependencies
    and pass them in as parameters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将依赖项定义为变量时，您将两个基础设施资源松散耦合。第4章介绍了您可以用来进一步解耦基础设施资源和依赖项的具体模式。如果可能，您应该避免硬编码依赖项，并将它们作为参数传递。
- en: 2.3.6 Keeping it a secret
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 保持秘密
- en: IaC often needs to use *secrets* such as tokens, passwords, or keys to execute
    changes to a provider.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: IaC通常需要使用*密钥*，如令牌、密码或密钥来执行对提供者的更改。
- en: Definition A *secret* is a piece of sensitive information such as a password,
    token, or key.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A *密钥* 是像密码、令牌或密钥这样的敏感信息。
- en: When you create servers in GCP, you need a service account key or token that
    accesses the project and server resources. To ensure that you can create resources,
    you maintain the secrets as part of the infrastructure configuration. Secrets
    in configuration can be problematic. If someone can read my secret, they can use
    it to access my GCP account to create resources and access restricted data!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在GCP中创建服务器时，您需要一个访问项目和服务器资源的服务帐户密钥或令牌。为了确保您可以创建资源，您将密钥作为基础设施配置的一部分维护。配置中的密钥可能存在问题。如果有人可以读取我的密钥，他们可以使用它来访问我的GCP帐户以创建资源并访问受限制的数据！
- en: You might also need to pass secrets as part of the configuration. For example,
    you use IaC to set the SSL certificate for a load balancer. The SSL certificate
    expires in two years. You re-create the environment two years later. However,
    you discover that the encrypted string of the certificate has expired. You cannot
    decrypt it and must now issue a new certificate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要将密钥作为配置的一部分传递。例如，您使用IaC设置负载均衡器的SSL证书。SSL证书在两年后到期。两年后，您重新创建环境。然而，您发现证书的加密字符串已过期。您无法解密它，现在必须颁发新的证书。
- en: Figure 2.10 shows how to best secure your certificate but improve its evolvability
    in the future. You pass the certificate as an input variable to have different
    certificates for each environment. Then you put the new certificates in a secrets
    manager, which stores and manages the certificate for you.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10展示了如何最佳地保护你的证书，同时在未来提高其可扩展性。你将证书作为输入变量传递，以便为每个环境提供不同的证书。然后你将新的证书放入密钥管理器中，它为你存储和管理证书。
- en: '![](../../OEBPS/Images/CH02_F10_Wang.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F10_Wang.png)'
- en: Figure 2.10 Retrieve sensitive information from a secrets manager to change
    resources with an infrastructure provider.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 从密钥管理器检索敏感信息以使用基础设施提供者更改资源。
- en: Anytime the certificate changes, you update it in the secrets manager. Your
    IaC updates its configuration when it reads the certificate from the secrets manager.
    Separating concerns for certificate management from configuration mitigates any
    problems you have later with certificate expiration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每当证书发生变化时，你需要在密钥管理器中更新它。当基础设施即代码（IaC）从密钥管理器读取证书时，它会更新其配置。将证书管理的关注点与配置分离可以减轻你以后在证书过期时遇到的问题。
- en: Why store secrets outside of IaC? You just applied the principles of composability
    and evolvability to separating secrets from other infrastructure resources. This
    separation ensures that someone can’t examine your IaC to get a password or username.
    You also minimize the impact of failure when you rotate a secret by rerunning
    the IaC.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在IaC之外存储密钥？你刚刚应用了将密钥与其他基础设施资源分离的可组合性和可扩展性原则。这种分离确保了没有人可以通过检查你的IaC来获取密码或用户名。你还可以通过重新运行IaC来轮换密钥时最小化失败的影响。
- en: Always pass secrets as variables into IaC and use it in memory. These include
    Secure Shell Protocol (SSH) keys, certificates, private keys, API tokens, passwords,
    and other login information. A separate entity should store and manage sensitive
    authentication data, such as a secrets manager. Separate secrets management facilitates
    reproduction, especially when you want different passwords and tokens for each
    environment. You should never hardcode or commit secrets to version control in
    plaintext.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 总是将密钥作为变量传递到IaC中，并在内存中使用它。这包括安全外壳协议（SSH）密钥、证书、私钥、API令牌、密码以及其他登录信息。应有一个单独的实体来存储和管理敏感的认证数据，例如密钥管理器。分离密钥管理有助于重现，尤其是在你需要为每个环境提供不同的密码和令牌时。你绝不应该以明文形式硬编码或提交密钥到版本控制中。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Prioritizing immutability reduces configuration drift, maintains a source of
    truth, and improves reproducibility.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑不可变性可以减少配置漂移，维护一个真相来源，并提高可重复性。
- en: To conform to immutability, changes to a resource create an entirely new resource
    and replace its state.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了符合不可变性，对资源的更改将创建一个全新的资源并替换其状态。
- en: If you make mutable changes, you must reconcile the localized changes in the
    infrastructure state with your configuration.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你进行可变更改，你必须协调基础设施状态中的本地化更改与你的配置。
- en: When writing IaC, use commits in version control to communicate changes and
    context and format the code for readability.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写IaC时，使用版本控制中的提交来传达更改和上下文，并格式化代码以提高可读性。
- en: Parametrize names, environments, and dependencies to other infrastructure. If
    you scope the configuration attributes to a resource, you can set it as a constant.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对名称、环境和依赖其他基础设施进行参数化。如果你将配置属性范围限定在资源上，你可以将其设置为常量。
- en: Secrets should always be passed as variables and never hardcoded or committed
    to version control in plaintext.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥应始终作为变量传递，绝不能硬编码或以明文形式提交到版本控制中。
- en: When writing scripts, always simplify actions to create, read, update, and delete
    commands to reproduce resources.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写脚本时，始终简化创建、读取、更新和删除命令以重现资源。
