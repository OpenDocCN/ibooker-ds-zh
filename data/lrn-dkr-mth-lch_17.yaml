- en: 15 Configuring Docker for secure remote access and CI/CD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 配置Docker以实现安全的远程访问和CI/CD
- en: The Docker command line presents a seamless way of working with containers,
    and it’s easy to forget that the command line doesn’t really do anything itself--it
    just sends instructions to the API running on the Docker Engine. Separating the
    command line from the Engine has two major benefits--other tools can consume the
    Docker API, so the command line isn’t the only way to manage containers, and you
    can configure your local command line to work with a remote machine running Docker.
    It’s amazingly powerful that you can switch from running containers on your laptop
    to managing a cluster with dozens of nodes, using all the same Docker commands
    you’re used to, without leaving your desk.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令行提供了一个无缝的工作方式来处理容器，很容易忘记命令行本身并不真正做任何事情——它只是将指令发送到运行在Docker引擎上的API。将命令行与引擎分离有两个主要好处——其他工具可以消费Docker
    API，因此命令行并不是管理容器的唯一方式，你还可以配置你的本地命令行以与运行Docker的远程机器协同工作。你可以在不离开办公桌的情况下，从在笔记本电脑上运行容器切换到管理拥有数十个节点的集群，使用你习惯的所有Docker命令，这真是令人惊叹。
- en: Remote access is how you administer test environments or debug issues in production,
    and it’s also how you enable the continuous deployment part of your CI/CD pipeline.
    After the continuous integration stages of the pipeline have completed successfully,
    you’ll have a potentially releasable version of your app stored in a Docker registry.
    Continuous deployment is the next stage of the pipeline--connecting to a remote
    Docker Engine and deploying the new version of the app. That stage could be a
    test environment that goes on to run a suite of integration tests, and then the
    final stage could connect to the production cluster and deploy the app to the
    live environment. In this chapter you’ll learn how to expose the Docker API and
    keep it protected, and how to connect to remote Docker Engines from your machine
    and from a CI/CD pipeline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 远程访问是管理测试环境或调试生产中问题的方法，也是你启用CI/CD管道中持续部署部分的方法。在管道的持续集成阶段成功完成后，你将有一个可能发布的版本的应用存储在Docker注册库中。持续部署是管道的下一阶段——连接到远程Docker引擎并部署应用的新版本。这一阶段可能是一个测试环境，它将运行一系列集成测试，然后最终阶段可能连接到生产集群并将应用部署到实时环境中。在本章中，你将学习如何公开Docker
    API并保护它，以及如何从你的机器和CI/CD管道连接到远程Docker引擎。
- en: 15.1 Endpoint options for the Docker API
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 Docker API的端点选项
- en: When you install Docker you don’t need to configure the command line to talk
    to the API--the default setup is for the Engine to listen on a local channel,
    and for the command line to use that same channel. The local channel uses either
    Linux sockets or Windows named pipes, and those are both network technologies
    that restrict traffic to the local machine. If you want to enable remote access
    to your Docker Engine, you need to explicitly set it in the configuration. There
    are a few different options for setting up the channel for remote access, but
    the simplest is to allow plain, unsecured HTTP access.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Docker时，你不需要配置命令行来与API通信——默认设置是引擎监听本地通道，命令行使用相同的通道。本地通道使用Linux套接字或Windows命名管道，这两种都是限制流量到本地机器的网络技术。如果你想启用对Docker引擎的远程访问，你需要在配置中明确设置。有几种不同的选项可以设置远程访问的通道，但最简单的是允许未加密的HTTP访问。
- en: Enabling unencrypted HTTP access is a horribly bad idea. It sets your Docker
    API to listen on a normal HTTP endpoint, and anyone with access to your network
    can connect to your Docker Engine and manage containers--without any authentication.
    You might think that isn’t too bad on your dev laptop, but it opens up a nice,
    easy attack vector. A malicious website could craft a request to http:/ /localhost:2375,
    where your Docker API is listening, and start up a bitcoin mining container on
    your machine--you wouldn’t know until you wondered where all your CPU had gone.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 启用未加密的HTTP访问是一个糟糕的主意。它将Docker API设置为监听正常的HTTP端点，任何有权访问你网络的用户都可以连接到你的Docker引擎并管理容器——无需任何身份验证。你可能认为在你的开发笔记本电脑上这并不是太糟糕，但它打开了一个很好的、简单的攻击向量。一个恶意网站可以构造一个请求到http://localhost:2375，你的Docker
    API就在那里监听，并在你的机器上启动一个比特币挖矿容器——直到你好奇为什么你的CPU都去哪儿了，你才会知道。
- en: I’ll walk you through enabling plain HTTP access, but only if you promise not
    to do it again after this exercise. At the end of this section you’ll have a good
    understanding of how remote access works, so you can disable the HTTP option and
    move on to more secure choices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我将带你完成启用纯 HTTP 访问的步骤，但前提是你承诺在这次练习之后不再这样做。在本节结束时，你将很好地理解远程访问是如何工作的，因此你可以禁用 HTTP
    选项并转向更安全的选择。
- en: Try it now Remote access is an Engine configuration option. You can set it easily
    in Docker Desktop on Windows 10 or Mac by opening Settings from the whale menu
    and selecting Expose Daemon on tcp:/ /localhost:2375 Without TLS. Figure 15.1
    shows that option--once you save the setting, Docker will restart.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 远程访问是 Engine 的配置选项。你可以在 Windows 10 或 Mac 上的 Docker Desktop 中轻松设置它，通过鲸鱼菜单打开设置并选择在
    tcp:/ /localhost:2375 上暴露守护进程，不使用 TLS。图 15.1 显示了该选项——一旦保存设置，Docker 将重新启动。
- en: '![](../Images/15-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片 15-1](../Images/15-1.jpg)'
- en: Figure 15.1 Enabling plain HTTP access to the Docker API--you should try and
    forget you saw this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 显示了启用对 Docker API 的纯 HTTP 访问——你应该努力忘记你看到了这个。
- en: If you’re using Docker Engine on Linux or Windows Server, you’ll need to edit
    the config file instead. You’ll find it at `/etc/docker/daemon.json` on Linux,
    or on Windows at `C:\ProgramData\docker\config\daemon.json` . The field you need
    to add is `hosts` , which takes a list of endpoints to listen on. Listing 15.1
    shows the settings you need for unsecured HTTP access, using Docker’s conventional
    port, 2375.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Linux 或 Windows Server 上的 Docker Engine，你需要编辑配置文件。在 Linux 上，你可以在 `/etc/docker/daemon.json`
    找到它，或者在 Windows 上在 `C:\ProgramData\docker\config\daemon.json` 。你需要添加的字段是 `hosts`
    ，它包含要监听端点的列表。列表 15.1 展示了用于未加密 HTTP 访问的设置，使用 Docker 的传统端口 2375。
- en: Listing 15.1 Configuring plain HTTP access to the Docker Engine via daemon.json
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.1 通过 daemon.json 配置 Docker Engine 的纯 HTTP 访问
- en: '`{` `      "hosts": [` `      # enable remote access on port 2375:` `      "tcp://0.0.0.0:2375",`
    `      # and keep listening on the local channel - Windows pipe:` `      "npipe://"`
    `      # OR Linux socket:` `      "fd://"` `      ],` `      "insecure-registries":
    [` `                "registry.local:5000"` `      ]` ` }`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `      "hosts": [` `      # 在端口 2375 上启用远程访问：` `      "tcp://0.0.0.0:2375",`
    `      # 并且继续监听本地通道 - Windows 管道：` `      "npipe://"` `      # 或者 Linux 套接字：`
    `      "fd://"` `      ],` `      "insecure-registries": [` `                "registry.local:5000"`
    `      ]` ` }`'
- en: You can check that the Engine is configured for remote access by sending HTTP
    requests to the API, and by providing a TCP host address in the Docker CLI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 API 发送 HTTP 请求并使用 Docker CLI 中的 TCP 主机地址来检查 Engine 是否已配置为远程访问。
- en: 'Try it now The Docker command line can connect to a remote machine using the
    `host` argument. The remote machine could be the localhost, but via TCP rather
    than the local channel:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Docker 命令行可以使用 `host` 参数连接到远程机器。远程机器可以是 localhost，但通过 TCP 而不是本地通道：
- en: '`# connect to the local Engine over TCP:` `docker --host tcp://localhost:2375
    container ls`   `# and using the REST API over HTTP:` ` curl http://localhost:2375/containers/json`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 通过 TCP 连接到本地 Engine：` `docker --host tcp://localhost:2375 container ls`
    `# 使用 HTTP 通过 REST API：` `curl http://localhost:2375/containers/json`'
- en: The Docker and Docker Compose command lines both support a `host` parameter,
    which specifies the address of the Docker Engine where you want to send commands.
    If the Engine is configured to listen on the local address without security, the
    `host` parameter is all you need; there’s no authentication for users and no encryption
    of network traffic. You can see my output in figure 15.2--I can list containers
    using the Docker CLI or the API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Docker Compose 命令行都支持 `host` 参数，该参数指定了你想要发送命令的 Docker Engine 的地址。如果
    Engine 配置为监听无安全性的本地地址，则 `host` 参数就是你所需要的；用户无需认证，网络流量也不会加密。你可以在图 15.2 中看到我的输出——我可以用
    Docker CLI 或 API 列出容器。
- en: '![](../Images/15-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片 15-2](../Images/15-2.jpg)'
- en: Figure 15.2 When the Docker Engine is available over HTTP, anyone with the machine
    address can use it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 当 Docker Engine 通过 HTTP 可用时，任何拥有机器地址的人都可以使用它。
- en: Now imagine the horror of the ops team if you told them you wanted to manage
    a Docker server, so you needed them to enable remote access--and, by the way,
    that would let anyone do anything with Docker on that machine, with no security
    and no audit trail. Don’t underestimate how dangerous this is. Linux containers
    use the same user accounts as the host server, so if you run a container as the
    Linux admin account, `root` , you’ve pretty much got admin access to the server.
    Windows containers work slightly differently, so you don’t get unlimited server
    access from within a container, but you can still do unpleasant things.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果运营团队得知你想要管理一个Docker服务器，因此需要他们启用远程访问——顺便说一句，这将允许任何人在该机器上对Docker进行任何操作，没有任何安全性和审计记录。不要低估这有多么危险。Linux容器使用与主机服务器相同的用户账户，所以如果你以Linux管理员账户`root`运行容器，你几乎就有对服务器的管理员访问权限。Windows容器的工作方式略有不同，所以你不会从容器中获得无限的服务器访问权限，但你仍然可以做一些不愉快的事情。
- en: When you’re working with a remote Docker Engine, any commands you send work
    in the context of that machine. So if you run a container and mount a volume from
    the local disk, it’s the remote machine’s disk that the container sees. That can
    trip you up if you want to run a container on the test server that mounts the
    source code on your local machine. Either the command will fail because the directory
    you’re mounting doesn’t exist on the server (which will confuse you because you
    know it does exist on your machine), or worse, that path does exist on the server
    and you won’t understand why the files inside the container are different from
    your disk. It also provides a useful shortcut for someone to browse a remote server’s
    filesystem if they don’t have access to the server but they do have access to
    the Docker Engine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与远程Docker Engine一起工作时，你发送的任何命令都在该机器的上下文中执行。所以如果你运行一个容器并从本地磁盘挂载一个卷，容器看到的是远程机器的磁盘。如果你想在测试服务器上运行一个挂载本地机器源代码的容器，这可能会让你感到困惑。要么命令会失败，因为你要挂载的目录在服务器上不存在（这会令你困惑，因为你知道它在你的机器上确实存在），要么更糟糕的是，该路径在服务器上确实存在，但你不会理解为什么容器内的文件与你的磁盘不同。这也为那些没有服务器访问权限但有权访问Docker
    Engine的人提供了一个有用的快捷方式来浏览远程服务器的文件系统。
- en: 'Try it now Let’s see why unsecured access to the Docker Engine is so bad. Run
    a container that mounts the Docker machine’s disk, and you can browse around the
    host’s filesystem:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看，让我们看看为什么对Docker Engine的不安全访问如此糟糕。运行一个挂载Docker机器磁盘的容器，你就可以浏览主机的文件系统：
- en: '`# using Linux containers:` `docker --host tcp://localhost:2375 container run
    -it -v /:/host-drive diamol/base`  `# OR Windows containers:` `docker --host tcp://localhost:2375
    container run -it -v C:\:C:\host-drive diamol/base`  `# inside the container,
    browse the filesystem:` `ls` `ls host-drive`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 使用Linux容器：` `docker --host tcp://localhost:2375 container run -it -v /:/host-drive
    diamol/base`  `# 或者Windows容器：` `docker --host tcp://localhost:2375 container run
    -it -v C:\:C:\host-drive diamol/base`  `# 在容器内浏览文件系统：` `ls` `ls host-drive`'
- en: You can see my output in figure 15.3--the user who runs the container has complete
    access to read and write files on the host.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图15.3中看到我的输出——运行容器的用户对主机上的文件有完全的读写访问权限。
- en: '![](../Images/15-3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-3.jpg)'
- en: Figure 15.3 Having access to the Docker Engine means you can get access to the
    host’s filesystem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 拥有对Docker Engine的访问权限意味着你可以访问主机的文件系统。
- en: In this exercise you’re just connecting to your own machine, so you’re not really
    bypassing security. But if you find out the name or IP address of the server that
    runs your containerized payroll system, and that server has unsecured remote access
    to the Docker Engine--well, you might be able to make a few changes and roll up
    to work in that new Tesla sooner than you expected. This is why you should never
    enable unsecured access to the Docker Engine, except as a learning exercise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你只是连接到自己的机器，所以你实际上并没有绕过安全措施。但如果你发现运行你容器化工资系统的服务器的名称或IP地址，并且该服务器对Docker
    Engine有未受保护的外部访问——那么，你可能会在预期之前更快地做出一些更改，并开始在新特斯拉车上工作。这就是为什么你不应该启用对Docker Engine的不安全访问，除非作为学习练习。
- en: Before we go on, let’s get out of the dangerous situation we’ve created and
    go back to the private local channel for the Docker Engine. Either uncheck the
    localhost box in the settings for Docker Desktop, or revert the config change
    you made for the Docker daemon, and then we’ll go on to look at the more secure
    options for remote access.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们摆脱我们创建的危险情况，回到Docker Engine的私有本地通道。您可以在Docker Desktop的设置中取消勾选localhost复选框，或者撤销您为Docker守护进程所做的配置更改，然后我们将继续探讨远程访问的更安全选项。
- en: 15.2 Configuring Docker for secure remote access
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 配置Docker以实现安全远程访问
- en: Docker supports two other channels for the API to listen on, and both are secure.
    The first uses Transport Layer Security (TLS)--the same encryption technique based
    on digital certificates used by HTTPS websites. The Docker API uses mutual TLS,
    so the server has a certificate to identify itself and encrypt traffic, and the
    client also has a certificate to identify itself. The second option uses the Secure
    Shell (SSH) protocol, which is the standard way to connect to Linux servers, but
    it is also supported in Windows. SSH users can authenticate with username and
    password or with private keys.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持API监听的其他两个通道，并且两者都是安全的。第一个使用传输层安全性（TLS）——与HTTPS网站使用的基于数字证书的加密技术相同。Docker
    API使用相互TLS，因此服务器有一个证书来识别自己并加密流量，客户端也有一个证书来识别自己。第二个选项使用安全外壳（SSH）协议，这是连接到Linux服务器的标准方式，但它也支持Windows。SSH用户可以使用用户名和密码或使用私钥进行认证。
- en: The secure options give you different ways to control who has access to your
    cluster. Mutual TLS is the most widely used, but it comes with management overhead
    in generating and rotating the certificates. SSH requires you to have an SSH client
    on the machine you’re connecting from, but most modern operating systems do, and
    it gives you an easier way to manage who has access to your machines. Figure 15.4
    shows the different channels the Docker API supports.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安全选项为您提供了不同的方式来控制谁可以访问您的集群。相互TLS是最广泛使用的，但它需要在生成和轮换证书时承担管理开销。SSH要求您在连接的机器上有一个SSH客户端，但大多数现代操作系统都有，它为您提供了管理谁可以访问您的机器的更简单方式。图15.4显示了Docker
    API支持的不同通道。
- en: '![](../Images/15-4.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-4.jpg)'
- en: Figure 15.4 There are secure ways of exposing the Docker API, providing encryption
    and authentication.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 存在安全地暴露Docker API、提供加密和认证的方法。
- en: One important thing here--if you want to configure secure remote access to the
    Docker Engine, you need to have access to the machine running Docker. And you
    don’t get that with Docker Desktop, because Desktop actually runs Docker in a
    VM on your machine, and you can’t configure how that VM listens (except with the
    unsecured HTTP checkbox we’ve just used). Don’t try to follow the next exercises
    using Docker Desktop --you’ll either get an error telling you that certain settings
    can’t be adjusted, or, worse, it will let you adjust them and then everything
    will break and you’ll need to reinstall. For the rest of this section, the exercises
    use the Play with Docker (PWD) online playground, but if you have a remote machine
    running Docker (here’s where your Raspberry Pi earns its keep), there are details
    in the readme file for this chapter’s source code on how to do the same without
    PWD.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的事情——如果您想配置对Docker Engine的安全远程访问，您需要能够访问运行Docker的机器。您无法通过Docker Desktop获得这一点，因为桌面实际上在您的机器上的虚拟机中运行Docker，您无法配置该虚拟机的监听方式（除了我们刚刚使用的未加密的HTTP复选框）。不要尝试使用Docker
    Desktop执行下一个练习——您可能会收到一个错误，告诉您某些设置无法调整，或者更糟糕的是，它可能会让您调整它们，然后一切都会崩溃，您需要重新安装。在本节的其余部分，练习使用Play
    with Docker (PWD)在线游乐场，但如果您有一台运行Docker的远程机器（这里就是您的树莓派发挥作用的地方），您可以在本章源代码的readme文件中找到如何在不使用PWD的情况下执行相同操作的详细信息。
- en: We’ll start by making a remote Docker Engine accessible securely using mutual
    TLS. For that you need to generate certificate and key file pairs (the key file
    acts like a password for the certificate)--one for the Docker API and one for
    the client. Larger organizations will have an internal certificate authority (CA)
    and a team that owns the certs and can generate them for you. I’ve already done
    that, generating certs that work with PWD, so you can use those.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过使用相互TLS来安全地访问远程Docker Engine。为此，您需要生成证书和密钥文件对（密钥文件充当证书的密码）——一个用于Docker
    API，另一个用于客户端。大型组织将有一个内部证书颁发机构（CA）和一个拥有证书并可以为您生成它们的团队。我已经完成了这项工作，生成了与PWD兼容的证书，因此您可以使用这些证书。
- en: 'Try it now Sign in to Play with Docker at *[https://labs.play-with-docker.com](https://labs.play-with-docker.com)*
    and create a new node. In that session, run a container that will deploy the certs,
    and configure the Docker Engine on PWD to use the certs. Then restart Docker:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 在*[https://labs.play-with-docker.com](https://labs.play-with-docker.com)*上登录Play
    with Docker并创建一个新的节点。在那个会话中，运行一个容器来部署证书，并配置PWD中的Docker Engine使用证书。然后重新启动Docker：
- en: '`# create a directory for the certs:` `mkdir -p /diamol-certs`   `# run a container
    that sets up the certs & config:` `docker container run -v /diamol-certs:/certs
    -v /etc/docker:/docker diamol/pwd-tls:server`   `# kill docker & restart with
    new config` `pkill dockerd` `dockerd &>/docker.log &`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 创建证书目录：` `mkdir -p /diamol-certs` `# 运行设置证书和配置的容器：` `docker container run
    -v /diamol-certs:/certs -v /etc/docker:/docker diamol/pwd-tls:server` `# 杀死docker并使用新配置重启：`
    `pkill dockerd` `dockerd &>/docker.log &`'
- en: The container you ran mounted two volumes from the PWD node, and it copied the
    certs and a new `daemon.json` file from the container image onto the node. If
    you change the Docker Engine configuration, you need to restart it, which is what
    the `dockerd` commands are doing. You can see my output in figure 15.5--at this
    point the engine is listening on port 2376 (which is the convention for secure
    TCP access) using TLS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您运行的容器从PWD节点挂载了两个卷，并将证书和新的`daemon.json`文件从容器镜像复制到节点上。如果您更改Docker Engine配置，则需要重新启动它，这就是`dockerd`命令所做的事情。您可以在图15.5中看到我的输出--此时引擎正在端口2376上监听（这是安全TCP访问的惯例）使用TLS。
- en: '![](../Images/15-5.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-5.jpg)'
- en: Figure 15.5 Configuring a Play with Docker session so the engine listens using
    mutual TLS
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 配置Play with Docker会话，使引擎使用相互TLS监听
- en: There’s one last step before we can actually send traffic from the local machine
    into the PWD node. Click on the Open Port button and open port 2376\. A new tab
    will open showing an error message. Ignore the message, and copy the URL of that
    new tab to the clipboard. This is the unique PWD domain for your session. It will
    be something like `ip172-18-0-62-bo9pj8nad2eg008a76e0-2376.direct.labs.play-with-docker.com`
    , and you’ll use it to connect from your local machine to the Docker Engine in
    PWD. Figure 15.6 shows how you open the port.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际上从本地机器向PWD节点发送流量之前，还有最后一步。点击“打开端口”按钮并打开端口2376。将打开一个新标签页，显示一个错误消息。忽略该消息，并将该新标签页的URL复制到剪贴板。这是您会话的独特PWD域名。它可能类似于`ip172-18-0-62-bo9pj8nad2eg008a76e0-2376.direct.labs.play-with-docker.com`，您将使用它从您的本地机器连接到PWD中的Docker
    Engine。图15.6显示了如何打开端口。
- en: '![](../Images/15-6.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-6.jpg)'
- en: Figure 15.6 Opening ports in PWD lets you send external traffic into containers
    and the Docker Engine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 在PWD中打开端口，让您可以将外部流量发送到容器和Docker Engine。
- en: Your PWD instance is now available to be remotely managed. The certificates
    you’re using are ones I generated using the OpenSSH tool (running in a container--the
    Dockerfile is in the `images/cert-generator` folder if you’re interested in seeing
    how it works). I’m not going to go into detail on TLS certificates and OpenSSH
    because that’s a long detour neither of us would enjoy. But it is important to
    understand the relationship between the CA, the server cert, and the client cert.
    Figure 15.7 shows that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您的PWD实例现在可以远程管理。您使用的证书是我使用OpenSSH工具（在容器中运行--如果您想了解它是如何工作的，Dockerfile在`images/cert-generator`文件夹中）生成的。我不会详细介绍TLS证书和OpenSSH，因为这会是一个我们都不愿意的长篇大论。但是，了解CA、服务器证书和客户端证书之间的关系很重要。图15.7显示了这一点。
- en: '![](../Images/15-7.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-7.jpg)'
- en: Figure 15.7 A quick guide to mutual TLS--server certs and client certs identify
    the holder and share a CA.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 互信TLS快速指南--服务器证书和客户端证书标识持证人并共享CA。
- en: If you’re going to use TLS to secure your Docker Engines, you’ll be generating
    one CA, one server cert for each Engine you want to secure, and one client cert
    for each user you want to allow access. Certs are created with a lifespan, so
    you can make short-lived client certs to give temporary access to a remote Engine.
    All of that can be automated, but there’s still overhead in managing certificates.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用TLS来保护您的Docker Engine，您将为要保护的每个引擎生成一个CA、一个服务器证书，并为每个您希望允许访问的用户生成一个客户端证书。证书有有效期，因此您可以创建短期客户端证书，以便临时访问远程引擎。所有这些都可以自动化，但管理证书仍然有开销。
- en: When you configure the Docker Engine to use TLS, you need to specify the paths
    to the CA cert, and the server cert and key pair. Listing 15.2 shows the TLS setup
    that has been deployed on your PWD node.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你配置 Docker 引擎使用 TLS 时，你需要指定 CA 证书、服务器证书和密钥对的路径。列表 15.2 展示了已部署在 PWD 节点上的 TLS
    设置。
- en: Listing 15.2 The Docker daemon configuration to enable TLS access
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.2 启用 TLS 访问的 Docker 守护进程配置
- en: '`{` `    "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2376"],` `    "tls":
    true,` `    "tlscacert": "/diamol-certs/ca.pem",` `    "tlskey": "/diamol-certs/server-key.pem",`
    `    "tlscert": "/diamol-certs/server-cert.pem"` `}`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `    "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2376"],` `    "tls":
    true,` `    "tlscacert": "/diamol-certs/ca.pem",` `    "tlskey": "/diamol-certs/server-key.pem",`
    `    "tlscert": "/diamol-certs/server-cert.pem"` `}`'
- en: Now that your remote Docker Engine is secured, you can’t use the REST API with
    curl or send commands using the Docker CLI unless you provide the CA certificate,
    client certificate, and client key. The API won’t accept any old client cert either--it
    needs to have been generated using the same CA as the server. Attempts to use
    the API without client TLS are rejected by the Engine. You can use a variation
    of the image you ran on PWD to download the client certs on your local machine,
    and use those to connect.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在远程 Docker 引擎已加密，除非你提供 CA 证书、客户端证书和客户端密钥，否则你不能使用 curl 的 REST API 或通过 Docker
    CLI 发送命令。API 也不会接受任何旧的客户端证书——它需要使用与服务器相同的 CA 生成。尝试在没有客户端 TLS 的情况下使用 API 会被引擎拒绝。你可以使用你在
    PWD 上运行的镜像的变体来下载本地机器上的客户端证书，并使用这些证书进行连接。
- en: 'Try it now Make sure you have the URL for port 2376 access to PWD--that’s how
    you’ll connect from your local machine to the PWD session. Use the domain for
    your session that you copied earlier when you opened port 2376\. Try connecting
    to the PWD engine:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 确保你有访问 PWD 端口 2376 的 URL ——这就是你从本地机器连接到 PWD 会话的方式。使用你之前打开端口 2376 时复制的会话域名。尝试连接到
    PWD 引擎：
- en: '`# grab your PWD domain from the address bar - something like` `# ip172-18-0-62-bo9pj8nad2eg008a76e0-6379.direct.labs.play-with-`
    `# docker.com`   `# store your PWD domain in a variable - on Windows:` `$pwdDomain="<your-pwd-domain-from-the-address-bar>"`
    `# OR Linux:` `pwdDomain="<your-pwd-domain-goes-here>"`   `# try accessing the
    Docker API directly:` `curl "http://$pwdDomain/containers/json"`   `# now try
    with the command line:` `docker --host "tcp://$pwdDomain" container ls`   `# extract
    the PWD client certs onto your machine:` `mkdir -p /tmp/pwd-certs` `cd ./ch15/exercises`
    `tar -xvf pwd-client-certs -C /tmp/pwd-certs`   `# connect with the client certs:`
    `docker --host "tcp://$pwdDomain" --tlsverify --tlscacert /tmp/pwd-certs/ca.pem
    --tlscert /tmp/pwd-certs/client-cert.pem --tlskey /tmp/pwd-certs/client-key.pem
    container ls`   `# you can use any Docker CLI commands:` ` docker --host "tcp://$pwdDomain"
    --tlsverify --tlscacert /tmp/pwd-certs/ca.pem --tlscert /tmp/pwd-certs/client-cert.pem
    --tlskey /tmp/pwd-certs/client-key.pem container run -d -P diamol/apache`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 从地址栏获取你的 PWD 域名 - 类似于` `# ip172-18-0-62-bo9pj8nad2eg008a76e0-6379.direct.labs.play-with-`
    `# docker.com` `# 将你的 PWD 域名存储在一个变量中 - 在 Windows 上：` `$pwdDomain="<your-pwd-domain-from-the-address-bar>"`
    `# OR Linux:` `pwdDomain="<your-pwd-domain-goes-here>"` `# 尝试直接访问 Docker API：`
    `curl "http://$pwdDomain/containers/json"` `# 现在尝试使用命令行：` `docker --host "tcp://$pwdDomain"
    container ls` `# 将 PWD 客户端证书提取到你的机器上：` `mkdir -p /tmp/pwd-certs` `cd ./ch15/exercises`
    `tar -xvf pwd-client-certs -C /tmp/pwd-certs` `# 使用客户端证书连接：` `docker --host "tcp://$pwdDomain"
    --tlsverify --tlscacert /tmp/pwd-certs/ca.pem --tlscert /tmp/pwd-certs/client-cert.pem
    --tlskey /tmp/pwd-certs/client-key.pem container ls` `# 你可以使用任何 Docker CLI 命令：`
    ` docker --host "tcp://$pwdDomain" --tlsverify --tlscacert /tmp/pwd-certs/ca.pem
    --tlscert /tmp/pwd-certs/client-cert.pem --tlskey /tmp/pwd-certs/client-key.pem
    container run -d -P diamol/apache`'
- en: It’s a little cumbersome to pass the TLS parameters to every Docker command,
    but you can also capture them in environment variables. If you don’t provide the
    right client cert, you’ll get an error, and when you do provide the certs, you
    have complete control over your Docker Engine running in PWD from your local machine.
    You can see that in figure 15.8.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将 TLS 参数传递给每个 Docker 命令有点繁琐，但你也可以将它们捕获在环境变量中。如果你没有提供正确的客户端证书，你会得到一个错误，当你提供证书时，你可以完全控制从本地机器运行的
    PWD 中的 Docker 引擎。你可以在图 15.8 中看到这一点。
- en: '![](../Images/15-8.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-8.jpg)'
- en: Figure 15.8 You can only work with a TLS-secured Docker Engine if you have the
    client certs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.8 你只能在与 TLS 加密的 Docker 引擎一起工作时使用客户端证书。
- en: The other option for secure remote access is SSH; the advantage here is that
    the Docker CLI uses the standard SSH client, and there’s no need to make any config
    changes to the Docker Engine. There are no certificates to create or manage, as
    authentication is handled by the SSH server. On your Docker machine you need to
    create a system user for everyone you want to permit remote access; they use those
    credentials when they run any Docker commands against the remote machine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种安全远程访问的选项是SSH；这里的优势是Docker CLI使用标准的SSH客户端，并且不需要对Docker引擎进行任何配置更改。不需要创建或管理证书，因为认证由SSH服务器处理。在你的Docker机器上，你需要为每个你想允许远程访问的人创建一个系统用户；他们运行任何针对远程机器的Docker命令时使用这些凭据。
- en: 'Try it now Back in your PWD session, make a note of the IP address for node1,
    and then click to create another node. Run these commands to manage the Docker
    Engine that’s on node1 from the command line on node2 using SSH:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 在你的PWD会话中，记下node1的IP地址，然后点击创建另一个节点。运行以下命令，通过SSH从node2的命令行管理node1上的Docker引擎：
- en: '`# save the IP address of node1 in a variable:` `node1ip="<node1-ip-address-goes-here>"`
      `# open an SSH session to verify the connection:` `ssh root@$node1ip` `exit`
      `# list the local containers on node2:` `docker container ls`   `# and list
    the remote containers on node1:` ` docker -H ssh://root@$node1ip container ls`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 将node1的IP地址保存到变量中:` `node1ip="<node1-ip-address-goes-here>"`   '
- en: Play with Docker makes this very simple, because it provisions nodes with all
    they need to connect to each other. In a real environment you’d need to create
    users, and if you want to avoid typing passwords you’d also need to generate keys
    and distribute the public key to the server and the private key to the user. You
    can see from my output in figure 15.9 that this is all done in the Play with Docker
    session, and it works with no special setup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Play with Docker使这变得非常简单，因为它为节点提供了连接彼此所需的一切。在实际环境中，你需要创建用户，如果你想避免输入密码，你还需要生成密钥并将公钥分发到服务器，私钥分发给用户。你可以从图15.9中的我的输出中看到，所有这些都在Play
    with Docker会话中完成，并且无需特殊设置即可正常工作。
- en: '![](../Images/15-9.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-9.jpg)'
- en: Figure 15.9 Play with Docker configures the SSH client between nodes so you
    can use it with Docker.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 Play with Docker配置了节点之间的SSH客户端，以便你可以与Docker一起使用。
- en: Ops people will have mixed feelings about using Docker over SSH. On the one
    hand, it’s much easier than managing certificates, and if your organization has
    a lot of Linux admin experience, it’s nothing new. On the other hand, it means
    giving server access to anyone who needs Docker access, which might be more privilege
    than they need. If your organization is primarily Windows, you can install the
    OpenSSH server on Windows and use the same approach, but it’s very different from
    how admins typically manage Windows server access. TLS might be a better option
    in spite of the certificate overhead because it’s all handled within Docker and
    it doesn’t need an SSH server or client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员对于使用SSH通过Docker可能会有复杂的感受。一方面，它比管理证书要容易得多，如果你的组织有很多Linux管理员经验，这并不是什么新鲜事。另一方面，这意味着将服务器访问权限授予任何需要Docker访问的人，这可能是他们不需要的权限。如果你的组织主要是Windows，你可以在Windows上安装OpenSSH服务器并使用相同的方法，但这与管理员通常管理Windows服务器访问的方式非常不同。尽管有证书开销，TLS可能是一个更好的选择，因为所有操作都在Docker内部完成，并且不需要SSH服务器或客户端。
- en: Securing access to your Docker Engine with TLS or SSH gives you encryption (the
    traffic between the CLI and the API can’t be read on the network) and authentication
    (users have to prove their identity in order to connect). The security doesn’t
    provide authorization or auditing, so you can’t restrict what a user can do, and
    you don’t have any record of what they did do. That’s something you’ll need to
    be aware of when you consider who needs access to which environments. Users also
    need to be careful which environments they use--the Docker CLI makes it super-easy
    to switch to a remote engine, and it’s a simple mistake to delete volumes containing
    important test data because you thought you were connected to your laptop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TLS 或 SSH 保护对您的 Docker 引擎的访问提供了加密（CLI 和 API 之间的流量在网络中无法被读取）和身份验证（用户必须证明他们的身份才能连接）。这种安全性不提供授权或审计，因此您无法限制用户可以做什么，并且您没有他们做了什么的记录。在考虑谁需要访问哪些环境时，您需要意识到这一点。用户还需要小心使用哪些环境——Docker
    CLI 使切换到远程引擎变得非常容易，而且很容易因为误以为连接到笔记本电脑而删除包含重要测试数据的卷。
- en: 15.3 Using Docker Contexts to work with remote engines
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 使用 Docker 上下文与远程引擎一起工作
- en: You can point your local Docker CLI to a remote machine using the `host` parameter,
    along with all the TLS cert paths if you’re using a secured channel, but it’s
    awkward to do that for every command you run. Docker makes it easier to switch
    between Docker Engines using Contexts. You create a Docker Context using the CLI,
    specifying all the connection details for the Engine. You can create multiple
    contexts, and all the connection details for each context are stored on your local
    machine.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `host` 参数将本地 Docker CLI 指向远程机器，如果您使用的是安全通道，还可以包括所有 TLS 证书路径，但为每个命令这样做会很麻烦。Docker
    通过上下文使在 Docker 引擎之间切换变得更容易。您使用 CLI 创建 Docker 上下文，指定引擎的所有连接细节。您可以创建多个上下文，每个上下文的连接细节都存储在您的本地机器上。
- en: 'Try it now Create a context to use your remote TLS-enabled Docker Engine running
    in PWD:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 创建一个上下文来使用在当前工作目录 (PWD) 中运行的远程 TLS 启用的 Docker 引擎：
- en: '`# create a context using your PWD domain and certs:` `docker context create
    pwd-tls --docker "host=tcp://$pwdDomain,ca=/tmp/pwd-certs/ca.pem,cert=/tmp/pwd-certs/client-cert.pem,key=/tmp/pwd-certs/client-key.pem"`
      `# for SSH it would be:` `# docker context create local-tls --docker "host=ssh://user@server"`
      `# list contexts:` ` docker context ls`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 使用您的 PWD 域和证书创建上下文：` `docker context create pwd-tls --docker "host=tcp://$pwdDomain,ca=/tmp/pwd-certs/ca.pem,cert=/tmp/pwd-certs/client-cert.pem,key=/tmp/pwd-certs/client-key.pem"`
    `# 对于 SSH，将是：` `# docker context create local-tls --docker "host=ssh://user@server"`
    `# 列出上下文：` ` docker context ls`'
- en: You’ll see in your output that there’s a default context that points to your
    local Engine using the private channel. My output in figure 15.10 is from a Windows
    machine, so the default channel uses named pipes. You’ll also see that there’s
    a Kubernetes endpoint option--you can use Docker contexts to store the connection
    details for Kubernetes clusters too.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在输出中看到有一个默认上下文，它使用私有通道指向您的本地引擎。我的图 15.10 的输出来自一台 Windows 机器，因此默认通道使用命名管道。您还会看到有一个
    Kubernetes 端点选项——您还可以使用 Docker 上下文来存储 Kubernetes 集群的连接细节。
- en: '![](../Images/15-10.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-10.jpg)'
- en: Figure 15.10 Adding a new context by specifying the remote host name and the
    TLS certificate paths
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10 通过指定远程主机名和 TLS 证书路径添加新的上下文
- en: Contexts contain all the information you need to switch between local and remote
    Docker Engines. This exercise used a TLS-secured engine, but you can run the same
    command with an SSH-secured engine by replacing the host parameter and cert paths
    with your SSH connection string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文包含您在本地和远程 Docker 引擎之间切换所需的所有信息。本练习使用了 TLS 加密的引擎，但您可以通过替换主机参数和证书路径为您的 SSH
    连接字符串，使用 SSH 加密的引擎运行相同的命令。
- en: Contexts can connect your local CLI to other machines on your local network
    or on the public internet. There are two ways to switch contexts--you can do it
    temporarily for the duration of one terminal session, or you can do it permanently
    so it works across all terminal sessions until you switch again.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文可以将您的本地 CLI 连接到本地网络或公共互联网上的其他机器。有两种方式来切换上下文——您可以临时切换，在单个终端会话期间进行，或者永久切换，以便在您再次切换之前在所有终端会话中生效。
- en: 'Try it now When you switch contexts, your Docker commands are sent to the selected
    engine--you don’t need to specify host parameters. You can switch temporarily
    with an environment variable or permanently with the `context` `use` command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 当您切换上下文时，您的Docker命令会发送到选定的引擎——您不需要指定主机参数。您可以使用环境变量临时切换，或使用`context use`命令永久切换：
- en: '`# switch to a named context with an environment variable - this is the` `#
    preferred way to switch contexts, because it only lasts for this` `# session`
      `# on Windows:` `$env:DOCKER_CONTEXT=''pwd-tls''`   `# OR Linux:` `export DOCKER_CONTEXT=''pwd-tls''`
      `# show the selected context:` `docker context ls`   `# list containers on the
    active context:` `docker container ls`   `# switch back to the default context
    - switching contexts this way is` `# not recommended because it''s permanent across
    sessions:` `docker context use default`   `# list containers again:` `docker container
    ls`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 使用环境变量切换到命名上下文 - 这是切换上下文的` `# 建议方式，因为它只持续本次` `# 会话`   '
- en: The output is probably not what you expect, and you need to be careful with
    contexts because of these different ways of setting them. Figure 15.11 shows my
    output, with the context still set to the PWD connection, even though I’ve switched
    back to the default.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能不是您预期的，由于这些不同的设置方式，您需要小心处理上下文。图15.11显示了我的输出，尽管我已经切换回默认设置，但上下文仍然设置为PWD连接。
- en: '![](../Images/15-11.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-11.jpg)'
- en: Figure 15.11 There are two ways to switch contexts, and if you mix them you’ll
    get confused.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 有两种切换上下文的方式，如果您混合使用它们，您会感到困惑。
- en: The context you set with `docker` `context` `use` becomes the system-wide default.
    Any new terminal windows you open, or any batch process you have running Docker
    commands, will use that context. You can override that using the `DOCKER_CONTEXT`
    environment variable, which takes precedence over the selected context and only
    applies to the current terminal session. If you regularly switch between contexts,
    I find that it’s a good practice to always use the environment variable option
    and leave the default context as your local Docker Engine. Otherwise it’s easy
    to start the day by clearing out all your running containers, forgetting that
    yesterday you set your context to use the production server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker context use`设置的上下文成为系统默认。您打开的任何新终端窗口，或任何运行Docker命令的批处理进程，都将使用该上下文。您可以使用`DOCKER_CONTEXT`环境变量来覆盖它，它优先于选定的上下文，并且仅适用于当前终端会话。如果您经常在上下文之间切换，我发现始终使用环境变量选项并将默认上下文保留为您的本地Docker
    Engine是一个好习惯。否则，很容易在一天开始时清除所有正在运行的容器，忘记昨天您已经将上下文设置为使用生产服务器。
- en: Of course, you shouldn’t need to regularly access the production Docker servers.
    As you get further along your container journey, you’ll take more advantage of
    the easy automation Docker brings and get to a place where the only users with
    access to Docker are the uber-admins and the system account for the CI/CD pipeline.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不应该需要定期访问生产Docker服务器。随着您在容器之旅中不断前进，您将更多地利用Docker带来的便捷自动化，并达到一个只有超级管理员和CI/CD管道的系统账户可以访问Docker的地方。
- en: 15.4 Adding continuous deployment to your CI pipeline
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 将持续部署添加到您的CI管道中
- en: Now that we have a remote Docker machine with secure access configured, we can
    write a complete CI/CD pipeline, building on the work we did with Jenkins in chapter
    11\. That pipeline covered the continuous integration (CI) stages--building and
    testing the app in containers and pushing the built image to a Docker registry.
    The continuous Deployment (CD) stages add to that, deploying to a testing environment
    for final signoff and then to production.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了具有安全访问的远程Docker机器，我们可以编写一个完整的CI/CD管道，基于第11章中我们与Jenkins一起完成的工作。该管道涵盖了持续集成（CI）阶段——在容器中构建和测试应用程序，并将构建的镜像推送到Docker仓库。持续部署（CD）阶段在此基础上增加了部署到测试环境以进行最终确认，然后部署到生产环境。
- en: The difference between the CI stages and the CD stages is that the CI builds
    all happen locally using the Docker Engine on the build machine, but the deployment
    needs to happen with the remote Docker Engines. The pipeline can use the same
    approach we’ve taken in the exercises, using Docker and Docker Compose commands
    with a host argument pointing to the remote machine, and providing security credentials.
    Those credentials need to live somewhere, and it absolutely must not be in source
    control--the people who need to work with source code are not the same people
    who need to work with production servers, so the credentials for production shouldn’t
    be widely available. Most automation servers let you store secrets inside the
    build server and use them in pipeline jobs, and that separates credential management
    from source control.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CI阶段和CD阶段之间的区别在于，CI构建都是在构建机器上使用Docker Engine本地进行的，但部署需要通过远程Docker Engine进行。管道可以使用我们在练习中采取的相同方法，使用带有指向远程机器的主机参数的Docker和Docker
    Compose命令，并提供安全凭证。这些凭证需要存储在某个地方，绝对不能放在源代码控制中——需要与源代码工作的人与需要与生产服务器工作的人不是同一群人，因此生产凭证不应广泛可用。大多数自动化服务器都允许你在构建服务器内部存储机密，并在管道作业中使用它们，这样就将凭证管理从源代码控制中分离出来。
- en: 'Try it now We’ll spin up a local build infrastructure similar to chapter 11,
    with a local Git server, Docker registry, and Jenkins server all running in containers.
    There are scripts that run when this Jenkins container starts to create credentials
    from the PWD certificate files on your local machine, so the CD stages will deploy
    to PWD:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 我们将启动一个类似于第11章的本地构建基础设施，包括本地Git服务器、Docker注册中心和Jenkins服务器，所有这些都在容器中运行。有一些脚本会在Jenkins容器启动时运行，从您本地的PWD证书文件中创建凭证，因此CD阶段将部署到PWD：
- en: '`# switch to the folder with the Compose files:` `cd ch15/exercises/infrastructure`
      `# start the containers - using Windows containers:` `docker-compose -f ./docker-compose.yml
    -f ./docker-compose-windows.yml up -d`   `# OR with Linux containers:` `docker-compose
    -f ./docker-compose.yml -f ./docker-compose-linux.yml up -d`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 切换到包含Compose文件的文件夹：` `cd ch15/exercises/infrastructure`   `# 启动容器 - 使用Windows容器：`
    `docker-compose -f ./docker-compose.yml -f ./docker-compose-windows.yml up -d`   `#
    或者使用Linux容器：` `docker-compose -f ./docker-compose.yml -f ./docker-compose-linux.yml
    up -d`'
- en: When the containers are running, browse to Jenkins at http:/ /localhost:8080/credentials
    and log in with username `diamol` and password `diamol` . You’ll see that the
    certificates for the Docker CA and the client connection are already stored in
    Jenkins--they were loaded from the PWD certs on your machine, and they’re available
    to use in jobs. Figure 15.12 shows the certificates loaded as Jenkins credentials.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器运行时，浏览到Jenkins的http://localhost:8080/credentials，使用用户名`diamol`和密码`diamol`登录。您会看到Docker
    CA证书和客户端连接的证书已经存储在Jenkins中——它们是从您的机器上的PWD证书加载的，并且可以在作业中使用。图15.12显示了作为Jenkins凭证加载的证书。
- en: '![](../Images/15-12.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-12.jpg)'
- en: Figure 15.12 Using Jenkins credentials to provide TLS certs for pipelines to
    connect to Docker on PWD
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 使用Jenkins凭证为管道提供TLS证书以连接到PWD的Docker
- en: This is a fresh build infrastructure running in all-new containers. Jenkins
    is all configured and ready to go thanks to the automation scripts it uses, but
    the Git server needs some manual setup. You’ll need to browse to http:/ /localhost:3000
    and complete the installation, create a user called `diamol` , and then create
    a repository called `diamol` . If you need a refresher on that, you can flip back
    to chapter 11--figures 11.3, 11.4, and 11.5 show you what to do.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全新的构建基础设施，在全新的容器中运行。由于使用了自动化脚本，Jenkins已经配置完毕并准备就绪，但Git服务器需要一些手动设置。您需要浏览到http://localhost:3000并完成安装，创建一个名为`diamol`的用户，然后创建一个名为`diamol`的仓库。如果您需要复习，可以翻回到第11章——第11.3、11.4和11.5节会向您展示如何操作。
- en: The pipeline we’ll be running in this section builds a new version of the timecheck
    app from chapter 12, which just prints the local time every 10 seconds. The scripts
    are all ready to go in the source code for this chapter, but you need to make
    a change to the pipeline to add your own PWD domain name. Then when the build
    runs, it will run the CI stages and deploy from your local container to your PWD
    session. We’ll pretend PWD is both the user-acceptance test environment and production.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们将运行的管道将构建第 12 章中 timecheck 应用程序的新版本，该应用程序每 10 秒打印一次本地时间。该章节的源代码中已经准备好了所有脚本，但你需要对管道进行更改以添加自己的
    PWD 域名。然后当构建运行时，它将运行 CI 阶段并将从你的本地容器部署到你的 PWD 会话。我们将假装 PWD 既是用户验收测试环境也是生产环境。
- en: 'try it now Open up the pipeline definition file in the folder `ch15/exercises`
    --use `Jenkinsfile` if you’re running Linux containers and `Jenkinsfile.windows`
    if you’re using Windows containers. In the environment section there are variables
    for the Docker registry domain and the User Acceptance Testing (UAT) and production
    Docker Engines. Replace `pwd-domain` with your actual PWD domain, and be sure
    to include the port, `:80` , after the domain--PWD listens on port 80 externally,
    and it maps that to port 2376 in the session:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开文件夹 `ch15/exercises` 中的管道定义文件 -- 如果你在运行 Linux 容器，请使用 `Jenkinsfile`；如果你使用的是
    Windows 容器，请使用 `Jenkinsfile.windows`。在环境部分，有 Docker 注册域名和用户验收测试（UAT）以及生产 Docker
    引擎的变量。将 `pwd-domain` 替换为你的实际 PWD 域名，并确保在域名后包含端口号 `:80` -- PWD 在外部监听端口 80，并将其映射到会话中的端口
    2376：
- en: '`environment {` `      REGISTRY = "registry.local:5000"` `      UAT_ENGINE
    = "ip172-18-0-59-bngh3ebjagq000ddjbv0-2376.direct.labs.play-with-docker.com:80"`
    `      PROD_ENGINE = "ip172-18-0-59-bngh3ebjagq000ddjbv0-2376.direct.labs.play-with-docker.com:80"`
    `}`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment {` `      REGISTRY = "registry.local:5000"` `      UAT_ENGINE
    = "ip172-18-0-59-bngh3ebjagq000ddjbv0-2376.direct.labs.play-with-docker.com:80"`
    `      PROD_ENGINE = "ip172-18-0-59-bngh3ebjagq000ddjbv0-2376.direct.labs.play-with-docker.com:80"`
    `}`'
- en: 'Now you can push your changes to your local Git server:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将你的更改推送到你的本地 Git 服务器：
- en: '`git remote add ch15 http://localhost:3000/diamol/diamol.git`  `git commit
    -a -m ''Added PWD domains''`  `git push ch15`  `# Gogs will ask you to login -`
    `# use the diamol username and password you registered in Gogs`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`git remote add ch15 http://localhost:3000/diamol/diamol.git`  `git commit
    -a -m ''Added PWD domains''`  `git push ch15`  `# Gogs will ask you to login -`
    `# use the diamol username and password you registered in Gogs`'
- en: Now browse to Jenkins at http:/ /localhost:8080/job/diamol/ and click Build
    Now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览到 Jenkins，网址为 http://localhost:8080/job/diamol/，然后点击“立即构建”。
- en: 'This pipeline starts in the same way as the chapter 11 pipeline: fetching the
    code from Git, building the app with a multi-stage Dockerfile, running the app
    to test that it starts, and then pushing the image to the local registry. Then
    come the new deployment stages: first there’s a deployment to the remote UAT engine
    and then the pipeline stops, waiting for human approval to continue. This is a
    nice way to get started with CD, because every step is automated, but there’s
    still a manual quality gate, and that can be reassuring for organizations that
    aren’t comfortable with automatic deployments to production. You can see in figure
    15.13 that the build has passed up to the UAT stage, and now it’s stopped at Await
    Approval.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此管道的启动方式与第 11 章的管道相同：从 Git 获取代码，使用多阶段 Dockerfile 构建应用程序，运行应用程序以测试其启动，然后将镜像推送到本地注册库。然后是新部署阶段：首先是将应用程序部署到远程
    UAT 引擎，然后管道停止，等待人工批准以继续。这是一种很好的开始 CD 的方式，因为每一步都是自动化的，但仍然有一个手动质量关卡，这对于不习惯自动部署到生产环境的组织来说可能是个安慰。你可以在图
    15.13 中看到构建已通过到 UAT 阶段，现在它已停止在“等待批准”。
- en: '![](../Images/15-13.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-13.jpg)'
- en: Figure 15.13 The CI/CD pipeline in Jenkins has deployed to UAT and is awaiting
    approval to continue.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13 Jenkins 中的 CI/CD 管道已部署到 UAT 并正在等待批准以继续。
- en: Your manual approval stage could involve a whole day of testing with a dedicated
    team, or it could be a quick sanity check that the new deployment looks good in
    a production-like environment. When you’re happy with the deployment, you go back
    to Jenkins and signal your approval. Then it goes on to the final stage--deploying
    to the production environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的手动批准阶段可能涉及一个专门团队进行整整一天的性能测试，或者它可能只是对新的部署在类似生产环境中的外观进行快速检查。当你对部署满意时，返回 Jenkins
    并发出你的批准信号。然后它将继续到最后一个阶段--部署到生产环境。
- en: 'Try it now Back in your PWD session, check that the timecheck container is
    running and that it’s writing out the correct logs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 回到你的 PWD 会话中，检查 timecheck 容器是否正在运行，并且是否正在输出正确的日志：
- en: '`docker container ls` `docker container logs timecheck-uat_timecheck_1`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container ls` `docker container logs timecheck-uat_timecheck_1`'
- en: I’m sure everything will be fine, so back to Jenkins and click the blue box
    in the Await Approval stage. A window pops up asking for confirmation to deploy--click
    Do It! The pipeline will continue.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信一切都会顺利，所以回到 Jenkins 并点击“等待批准”阶段的蓝色框。一个窗口会弹出，要求确认部署——点击“执行”！管道将继续。
- en: It’s getting exciting now--we’re nearly there with our production deployment.
    You can see my output in figure 15.14, with the UAT test in the background and
    the approval stage in the foreground.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在越来越激动人心了——我们的生产部署几乎完成了。您可以在图 15.14 中看到我的输出，UAT 测试在背景中，批准阶段在前景中。
- en: '![](../Images/15-14.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-14.jpg)'
- en: Figure 15.14 The UAT deployment has worked correctly and the app is running
    in PWD. On to production!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.14 UAT 部署已正确完成，应用正在 PWD 中运行。接下来是生产环境！
- en: The CD stages of the pipeline don’t do anything more complex than the CI stages.
    There’s a script file for each stage that does the work using a single Docker
    Compose command, joining together the relevant override files (this could easily
    be a `docker` `stack` `deploy` command if the remote environment is a Swarm cluster).
    The deployment scripts expect the TLS certificate paths and Docker host domain
    to be provided in environment variables, and those variables are set up in the
    pipeline job.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的 CD 阶段并不比 CI 阶段复杂。每个阶段都有一个脚本文件，使用单个 Docker Compose 命令执行工作，将相关的覆盖文件连接起来（如果远程环境是一个
    Swarm 集群，这可以很容易地是一个 `docker` `stack` `deploy` 命令）。部署脚本期望 TLS 证书路径和 Docker 主机域名通过环境变量提供，这些变量在管道作业中已设置。
- en: It’s important to keep that separation between the actual work that’s done with
    the Docker and Docker Compose CLIs, and the organization of the work done in the
    pipeline. That reduces your dependency on a particular automation server and makes
    it easy to switch between them. Listing 15.3 shows part of the Jenkinsfile and
    the batch script that deploy to UAT.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Docker 和 Docker Compose CLIs 实际执行的工作与管道中完成的工作的组织之间保持分离是很重要的。这减少了您对特定自动化服务器的依赖，并使得在它们之间切换变得容易。列表
    15.3 显示了 Jenkinsfile 的一部分和部署到 UAT 的批处理脚本。
- en: Listing 15.3 Passing Docker TLS certs to the script file using Jenkins credentials
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.3 使用 Jenkins 凭据将 Docker TLS 证书传递到脚本文件
- en: '`# the deployment stage of the Jenkinsfile:`   `stage(''UAT'') {` `    steps
    {` `        withCredentials(` `            [file(credentialsId: ''docker-ca.pem'',
    variable: ''ca''),` `              file(credentialsId: ''docker-cert.pem'', variable:
    ''cert''),` `              file(credentialsId: ''docker-key.pem'', variable: ''key'')])
    {` `                  dir(''ch15/exercises'') {` `                      sh ''chmod
    +x ./ci/04-uat.bat''` `                      sh ''./ci/04-uat.bat''` `                      echo
    "Deployed to UAT"` `            }` `        }` `    }` `}`   `# and the actual
    script just uses Docker Compose:`   `docker-compose \` `    --host tcp://$UAT_ENGINE
    --tlsverify \` `    --tlscacert $ca --tlscert $cert --tlskey $key \` `    -p timecheck-uat
    -f docker-compose.yml -f docker-compose-uat.yml \` ` up -d`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`# Jenkinsfile 的部署阶段：` `stage(''UAT'') {` `    steps {` `        withCredentials(`
    `            [file(credentialsId: ''docker-ca.pem'', variable: ''ca''),` `              file(credentialsId:
    ''docker-cert.pem'', variable: ''cert''),` `              file(credentialsId:
    ''docker-key.pem'', variable: ''key'')]) {` `                  dir(''ch15/exercises'')
    {` `                      sh ''chmod +x ./ci/04-uat.bat''` `                      sh
    ''./ci/04-uat.bat''` `                      echo "Deployed to UAT"` `            }`
    `        }` `    }` `}` `# 实际的脚本仅使用 Docker Compose:` `docker-compose \` `    --host
    tcp://$UAT_ENGINE --tlsverify \` `    --tlscacert $ca --tlscert $cert --tlskey
    $key \` `    -p timecheck-uat -f docker-compose.yml -f docker-compose-uat.yml
    \` ` up -d`'
- en: Jenkins provides the TLS certs for the shell script from its own credentials.
    You could move this build to GitHub Actions and you’d just need to mimic the workflow
    using secrets stored in the GitHub repo--the build scripts themselves wouldn’t
    need to change. The production deployment stage is almost identical to UAT; it
    just uses a different set of Compose files to specify the environment settings.
    We’re using the same PWD environment for UAT and production, so when the job completes
    you’ll be able to see both deployments running.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 从其自己的凭据提供 TLS 证书给 shell 脚本。您可以将此构建移至 GitHub Actions，并只需使用存储在 GitHub
    仓库中的机密来模拟工作流程——构建脚本本身不需要更改。生产部署阶段几乎与 UAT 相同；它只是使用不同的 Compose 文件来指定环境设置。我们正在使用相同的
    PWD 环境进行 UAT 和生产，因此当作业完成时，您将能够看到两个部署都在运行。
- en: 'Try it now Back to the PWD session for one last time, and you can check that
    your local Jenkins build has correctly deployed to the UAT and production environments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 返回 PWD 会话，最后一次，您可以检查您的本地 Jenkins 构建是否已正确部署到 UAT 和生产环境：
- en: '`docker container ls`   `docker container logs timecheck-prod_timecheck_1`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container ls`   `docker container logs timecheck-prod_timecheck_1`'
- en: My output is in figure 15.15\. We have a successful CI/CD pipeline running from
    Jenkins in a local container and deploying to two remote Docker environments (which
    just happen to be the same one in this case).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出在图 15.15 中。我们有一个从 Jenkins 在本地容器中运行的成功的 CI/CD 流程，并部署到两个远程 Docker 环境（在这个例子中恰好是同一个）。
- en: '![](../Images/15-15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-15.jpg)'
- en: Figure 15.15 The deployment on PWD. To use a real cluster, I’d just change the
    domain name and certs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.15 PWD 的部署。要使用实际的集群，我只需更改域名和证书。
- en: This is amazingly powerful. It doesn’t take any more than a Docker server to
    run containers for different environments and a machine running Docker for the
    CI/CD infrastructure. You can prove this with a pipeline for your own app in a
    day (assuming you’ve already Dockerized the components), and the path to production
    just requires spinning up clusters and changing the deployment targets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大。运行不同环境的容器以及运行 CI/CD 基础设施机器不需要比 Docker 服务器更多的东西。您可以在一天内通过您自己的应用程序的流程来证明这一点（假设您已经将组件
    Docker 化了），而通往生产的路径只需要启动集群并更改部署目标。
- en: Before you plan out your production pipeline, however, there is one other thing
    to be aware of when you make your Docker Engine available remotely--even if it
    is secured. That’s the access model for Docker resources.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划您的生产流程之前，然而，当您将 Docker 引擎远程提供时，还有一件事需要您注意——即使它是受保护的。那就是 Docker 资源访问模型。
- en: 15.5 Understanding the access model for Docker
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5 理解 Docker 的访问模型
- en: 'This doesn’t really need a whole section because the access model for Docker
    resources is very simple, but it gets its own section to help it stand out. Securing
    your Engine is about two things: encrypting the traffic between the CLI and API,
    and authenticating to ensure the user is allowed access to the API. There’s no
    authorization--the access model is all or nothing. If you can’t connect to the
    API, you can’t do anything, and if you can connect to the API, you can do everything.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不需要一个完整的章节，因为 Docker 资源访问模型非常简单，但它有自己的章节来帮助它突出。保护您的引擎主要涉及两个方面：加密 CLI 和 API
    之间的流量，并验证以确保用户有权访问 API。没有授权——访问模型是全有或全无。如果您无法连接到 API，您将无法做任何事情，如果您可以连接到 API，您可以做任何事情。
- en: Whether that frightens you or not depends on your background, your infrastructure,
    and the maturity of your security model. You might be running internal clusters
    with no public access, using a separate network for your managers, with restricted
    IP access to that network, and you rotate the Docker CA every day. That gives
    you defense in depth, but there’s still an attack vector from your own employees
    to consider (yes, I know Stanley and Minerva are great team players, but are you
    really sure they aren’t crooks? Especially Stanley).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否感到恐惧取决于您的背景、您的基础设施以及您安全模型的成熟度。您可能正在运行没有公开访问的内部集群，为您的管理者使用单独的网络，并限制对该网络的 IP
    访问，您每天都会轮换 Docker CA。这为您提供了深度防御，但仍然需要考虑来自您自己的员工的攻击向量（是的，我知道 Stanley 和 Minerva
    是优秀的团队成员，但您真的确定他们不是骗子吗？特别是 Stanley）。
- en: There are alternatives, but they get complicated quickly. Kubernetes has a role-based
    access control model, as does Docker Enterprise, so you can restrict which users
    can access resources, and what they can do with those resources. Or there’s a
    GitOps approach that turns the CI/CD pipeline inside out, using a pull-based model
    so the cluster is aware when a new build has been approved, and the cluster deploys
    the update itself. Figure 15.16 shows that--there are no shared credentials here
    because nothing needs to connect to the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他选择，但它们很快就会变得复杂。Kubernetes 和 Docker Enterprise 都有基于角色的访问控制模型，因此您可以限制哪些用户可以访问资源，以及他们可以使用这些资源做什么。或者有一种
    GitOps 方法，它将 CI/CD 流程颠倒过来，使用基于拉的模型，以便集群在新的构建被批准时知道，并自行部署更新。图 15.16 展示了这一点——这里没有共享凭证，因为不需要任何东西连接到集群。
- en: '![](../Images/15-16.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-16.jpg)'
- en: Figure 15.16 The brave new world of GitOps--everything is stored in Git, and
    clusters start deployments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.16 GitOps 的勇敢新世界——一切都在 Git 中存储，集群开始部署。
- en: GitOps is a very interesting approach, because it makes everything repeatable
    and versioned--not just your application source code and the deployment YAML files,
    but the infrastructure setup scripts too. It gives you the single source of truth
    for your whole stack in Git, which you can easily audit and roll back. If the
    idea appeals to you but you’re starting from scratch--well, it will take you a
    chunk of time to get there, but you can start with the very simple CI/CD pipelines
    we’ve covered in this chapter and gradually evolve your processes and tools as
    you gain confidence.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps是一个非常有趣的方法，因为它使一切可重复且可版本化——不仅包括你的应用程序源代码和部署YAML文件，还包括基础设施设置脚本。它为你提供了整个堆栈的单个真相来源，Git，你可以轻松审计和回滚。如果你对这个想法感兴趣，但你是从零开始的——好吧，这将花费你一段时间才能达到那里，但你可以从本章中我们讨论的非常简单的CI/CD管道开始，随着你获得信心，逐渐发展和完善你的流程和工具。
- en: 15.6 Lab
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6 实验室
- en: If you followed along with the CD exercise in section 15.4, you may have wondered
    how the deployment worked, because the CI stage pushed the image to your local
    registry and PWD can’t access that registry. How did it pull the image to run
    the container? Well, it didn’t. I cheated. The deployment override files use a
    different image tag, one from Docker Hub that I built and pushed myself (sorry
    if you feel let down, but all the images from this book are built with Jenkins
    pipelines, so it’s the same thing really). In this lab you’re going to put that
    right.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随了第15.4节中的CD练习，你可能想知道部署是如何工作的，因为CI阶段将镜像推送到你的本地注册表，而PWD无法访问该注册表。它是如何将镜像拉取来运行容器的？好吧，它并没有。我作弊了。部署覆盖文件使用了一个不同的镜像标签，一个来自Docker
    Hub的标签，是我自己构建并推送的（如果你感到失望，我表示抱歉，但本书中的所有镜像都是使用Jenkins管道构建的，所以实际上是一样的）。在这个实验中，你将纠正这一点。
- en: 'The missing part of the build is in stage 3, which just pushes the image to
    the local registry. In a typical pipeline there would be a test stage on a local
    server that could access that image before pushing to the production registry,
    but we’ll skip that and just add another push to Docker Hub. This is the goal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构建中缺失的部分在第三阶段，它只是将镜像推送到本地注册表。在一个典型的管道中，会有一个在本地服务器上的测试阶段，可以在推送到生产注册表之前访问该镜像，但我们将跳过这一阶段，直接添加另一个推送到Docker
    Hub的操作。这是目标：
- en: Tag your CI image so it uses your account on Docker Hub and a simple “3.0” tag.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的CI镜像打上标签，使其使用Docker Hub上的你的账户和简单的“3.0”标签。
- en: Push the image to Docker Hub, keeping your Hub credentials secure.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像推送到Docker Hub，同时确保你的Hub凭证安全。
- en: Use your own Docker Hub image to deploy to the UAT and production environments.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你自己的Docker Hub镜像部署到UAT和生产环境。
- en: 'There are a few moving pieces here, but go through the existing pipeline carefully
    and you’ll see what you need to do. Two hints: First, you can create a username/
    password credential in Jenkins and make it available in your Jenkinsfile using
    the `withCredentials` block. Second, the open port to a PWD session sometimes
    stops listening, so you may need to start new sessions that will need new PWD
    domains in the Jenkinsfile.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要考虑的环节，但仔细查看现有的流程，你就会知道你需要做什么。两个提示：首先，你可以在Jenkins中创建一个用户名/密码凭证，并在Jenkinsfile中使用`withCredentials`块使其可用。其次，到PWD会话的开放端口有时会停止监听，因此你可能需要在Jenkinsfile中启动新的会话，这些会话将需要新的PWD域。
- en: 'My solution on GitHub started as a copy of the exercises folder, so if you
    want to see what I changed, you can compare the files as well as check the approach:
    *[https:// github.com/sixeyed/diamol/blob/master/ch15/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch15/lab/README.md)*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我在GitHub上的解决方案最初是复制了练习文件夹，所以如果你想看看我做了哪些更改，你可以比较文件，以及检查方法：*[https://github.com/sixeyed/diamol/blob/master/ch15/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch15/lab/README.md)*。
