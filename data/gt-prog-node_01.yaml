- en: Unit 1\. Getting started with Node.js
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 单元\. Node.js 入门
- en: 'Now that you’ve gone through [unit 0](../Text/kindle_split_010.html#part00)
    and have Node.js installed and running, it’s time to see it working. [Unit 1](#part01)
    is about building from the get-go. You begin by building a small web application
    in Node.js and gradually piece together the components that work behind the scenes.
    In this unit, you learn all you need to get a web server running on Node.js that
    serves some simple static content: HTML pages, pictures, and a stylesheet. Toward
    this goal, you look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经完成了 [第 0 单元](../Text/kindle_split_010.html#part00) 并安装并运行了 Node.js，现在是时候看看它的工作情况了。[第
    1 单元](#part01) 是关于从头开始构建。你首先在 Node.js 中构建一个小型网络应用程序，并逐渐拼凑起幕后工作的组件。在本单元中，你将学习所有必要的知识，以便在
    Node.js 上运行一个网络服务器，该服务器提供一些简单的静态内容：HTML 页面、图片和样式表。为了实现这一目标，你将查看以下主题：
- en: '[Lesson 3](../Text/kindle_split_015.html#ch03) introduces npm and discusses
    how to configure a new Node.js application. In this lesson, you build a Node.js
    module, and learn how packages and modules offer tools and support to your application.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 课](../Text/kindle_split_015.html#ch03) 介绍了 npm 并讨论了如何配置新的 Node.js 应用程序。在本课中，你将构建一个
    Node.js 模块，并了解包和模块如何为你的应用程序提供工具和支持。'
- en: '[Lesson 4](../Text/kindle_split_016.html#ch04) introduces the idea of a web
    server running on Node.js as a way to launch a simple website. You learn how to
    set up the server and write code to get your website content viewable.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 4 课](../Text/kindle_split_016.html#ch04) 介绍了在 Node.js 上运行的网络服务器作为启动简单网站的方法。你将学习如何设置服务器并编写代码，以便使你的网站内容可查看。'
- en: '[Lesson 5](../Text/kindle_split_017.html#ch05) builds on [lesson 2](../Text/kindle_split_013.html#ch02)
    by giving the app enough information to load web content based on different requests.
    In this lesson, you build your first application route—a system for connecting
    content to URLs in your application.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 5 课](../Text/kindle_split_017.html#ch05) 在 [第 2 课](../Text/kindle_split_013.html#ch02)
    的基础上，为应用程序提供足够的信息，以便根据不同的请求加载网络内容。在本课中，你构建了你的第一个应用程序路由——一个将内容与应用程序中的 URL 相连接的系统。'
- en: '[Lesson 6](../Text/kindle_split_018.html#ch06) teaches you how to serve different
    HTML files from your web server rather than simple responses. This lesson adds
    support for application assets: CSS, JavaScript that runs on the user’s device,
    and image loading. Together, these concepts enable you to organize and structure
    your application to handle more requests to your website with less code clutter.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 课](../Text/kindle_split_018.html#ch06) 教你如何从你的 web 服务器上提供不同的 HTML 文件，而不是简单的响应。本课增加了对应用程序资源的支持：CSS、在用户设备上运行的
    JavaScript 以及图像加载。这些概念共同使你能够以更少的代码杂乱来组织和结构化你的应用程序，以处理更多对网站的请求。'
- en: Finally, [lesson 7](../Text/kindle_split_019.html#ch07) shows you how to put
    everything together by building a complete multipage application. You start a
    new application from scratch; then you add three views, routes for the views and
    assets, and a public client folder.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[第 7 课](../Text/kindle_split_019.html#ch07) 通过构建一个完整的多页应用程序来展示如何将所有内容整合在一起。你从头开始创建一个新的应用程序；然后添加三个视图、视图的路由和资源，以及一个公共客户端文件夹。
- en: 'When you’re solid on how to build a static site from scratch, [unit 2](../Text/kindle_split_020.html#part02)
    takes you to the next step: using a framework to build your application faster.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你牢固掌握了如何从头开始构建静态网站，[第 2 单元](../Text/kindle_split_020.html#part02) 将带你进入下一步：使用框架更快地构建应用程序。
- en: Lesson 3\. Creating a Node.js module
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 课\. 创建 Node.js 模块
- en: In this lesson, you kick off Node.js application development by creating a Node.js
    module (JavaScript file). Then you introduce npm to the development workflow and
    learn about some common npm commands and tools for setting up a new application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你通过创建一个 Node.js 模块（JavaScript 文件）来启动 Node.js 应用程序开发。然后你将 npm 引入到开发工作流程中，并了解一些常见的
    npm 命令和工具，用于设置新的应用程序。
- en: This lesson covers
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖了
- en: Creating a Node.js module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Node.js 模块
- en: Constructing a Node.js application with npm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 npm 构建一个 Node.js 应用程序
- en: Installing a Node.js package with npm
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 npm 安装 Node.js 包
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You want to build an application to help people share food recipes and learn
    from one another. Through this application, users can subscribe, join online courses
    to practice cooking with the application’s recipes, and connect with other users.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你想构建一个应用程序，帮助人们分享食谱并相互学习。通过这个应用程序，用户可以订阅、加入在线课程，使用应用程序的食谱练习烹饪，并与其他用户建立联系。
- en: You plan to use Node.js to build this web application, and you want to start
    by verifying users’ ZIP codes to determine the locations and demographics of your
    audience. Will you need to build a tool for checking ZIP codes in addition to
    the application?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划使用 Node.js 来构建这个网络应用程序，并且你想要从验证用户的 ZIP 码开始，以确定你受众的位置和人口统计信息。除了应用程序之外，你还需要构建一个用于检查
    ZIP 码的工具吗？
- en: Luckily, you can use npm to install Node.js *packages*—libraries of code others
    have written that add specific features to your application. In fact, a package
    for verifying locations based on ZIP codes is available. You take a look at that
    package and how to install it in this lesson.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用 npm 来安装 Node.js **包**——其他人编写的代码库，这些代码库为你的应用程序添加了特定的功能。实际上，有一个基于 ZIP
    码验证位置的包可用。在本课中，你将查看该包以及如何安装它。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A Node.js application is made up of many JavaScript files. For your application
    to stay organized and efficient, these files need to have access to one another’s
    contents when necessary. Each JavaScript file or folder containing a code library
    is called a *module*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node.js 应用程序由许多 JavaScript 文件组成。为了使你的应用程序保持有序和高效，当需要时，这些文件需要能够访问彼此的内容。每个包含代码库的
    JavaScript 文件或文件夹都称为 **模块**。
- en: 'Suppose that you’re working on a recipe application using the positive messages
    from [unit 0](../Text/kindle_split_010.html#part00). You can create a file called
    messages.js with the following code: `let messages = [`“`You are great!`”`,` “`You
    can accomplish anything!`”`,` “`Success is in your future!`”`];`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用来自 [单元 0](../Text/kindle_split_010.html#part00) 的积极信息开发一个食谱应用程序。你可以创建一个名为
    messages.js 的文件，其中包含以下代码：`let messages = ["You are great!","You can accomplish
    anything!","Success is in your future!"];`。
- en: 'Keeping these messages separate from the code you’ll write to display them
    makes your code more organized. To manage these messages in another file, you
    need to change the `let` variable definition to use the `exports` object, like
    so: `exports.messages = [`“`You are great!`”`,` “`You can accomplish anything!`”`,`
    “`Success is in your future!`”`];`. As with other JavaScript objects, you’re adding
    a `messages` property to the Node.js `exports` object, and this property can be
    shared among modules.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些消息与你要编写的显示它们的代码分开，可以使你的代码更加有序。要在另一个文件中管理这些消息，你需要将 `let` 变量定义更改为使用 `exports`
    对象，如下所示：`exports.messages = ["You are great!","You can accomplish anything!","Success
    is in your future!"];`。与其他 JavaScript 对象一样，你正在向 Node.js 的 `exports` 对象添加一个 `messages`
    属性，并且这个属性可以在模块之间共享。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `exports` object is a property of the `module` object. `module` is both
    the name of the code files in Node.js and one of its global objects. `exports`
    is shorthand for `module .exports`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports` 对象是 `module` 对象的一个属性。`module` 既是 Node.js 中代码文件的名字，也是其全局对象之一。`exports`
    是 `module.exports` 的简写。'
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The module is ready to be required (imported) by another JavaScript file. You
    can test this module by creating another file called printMessages.js, the purpose
    of which is to loop through the messages and log them to your console with the
    code shown in the next listing. First, require the local module by using the `require`
    object and the module’s filename (with or without the .js extension). Then refer
    to the module’s array by the variable set up in printMessages.js, as shown in
    the next listing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模块已准备好被另一个 JavaScript 文件所需的（导入）。你可以通过创建另一个名为 printMessages.js 的文件来测试此模块，该文件的目的在于遍历消息并将它们通过下一列表中显示的代码记录到你的控制台。首先，使用
    `require` 对象和模块的文件名（带或不带 .js 扩展名）来引入本地模块。然后，如下一列表所示，通过在 printMessages.js 中设置的变量来引用模块的数组。
- en: Listing 3.1\. Log messages to console in printMessages.js
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 在 printMessages.js 中向控制台打印日志
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Require the local messages.js module.**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入本地的 messages.js 模块。**'
- en: '***2*** **Refer to the module’s array through messageModule.messages.**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **通过 messageModule.messages 引用模块的数组。**'
- en: '`require` is another Node.js global object used to locally introduce methods
    and objects from other modules. Node.js interprets `require(`“`./messages`”`)`
    to look for a module called `messages.js` within your project directory and allows
    code within `printMessages.js` to use any properties on the `exports` object in
    `messages.js`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 是另一个 Node.js 全局对象，用于在本地引入来自其他模块的方法和对象。Node.js 将 `require("messages")`
    解释为在项目目录中查找名为 `messages.js` 的模块，并允许 `printMessages.js` 中的代码使用 `messages.js` 中
    `exports` 对象上的任何属性。'
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using require**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 require**'
- en: To load libraries of code and modules in Node.js, use `require()`. This `require`
    function, like exports, comes from module.require, which means that the function
    lives on the global `module` object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node.js 中加载代码库和模块，请使用 `require()`。这个 `require` 函数，就像 `exports` 一样，来自 `module.require`，这意味着该函数存在于全局
    `module` 对象上。
- en: Node.js uses CommonJS, a tool that helps JavaScript run outside a browser by
    helping define how modules are used. For module loading, CommonJS specifies the
    `require` function. For exporting modules, CommonJS provides the `exports` object
    for each module. Much of the syntax and structure you use in this book results
    from CommonJS module designs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使用 CommonJS，这是一个帮助 JavaScript 在浏览器外运行的工具，它通过帮助定义模块的使用方式来实现。对于模块加载，CommonJS
    指定了 `require` 函数。对于导出模块，CommonJS 为每个模块提供了 `exports` 对象。您在这本书中使用的大部分语法和结构都源于 CommonJS
    模块设计。
- en: '`require` is responsible for loading code into your module, and it does this
    by attaching the loaded module to your module’s `exports` object. As a result,
    if the code you’re importing needs to be reused in any way, it doesn’t need to
    be reloaded each time.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 负责将代码加载到您的模块中，它通过将加载的模块附加到您的模块的 `exports` 对象上来完成此操作。因此，如果您导入的代码需要以任何方式重用，则无需每次都重新加载。'
- en: The Module class also performs some extra steps to cache and properly manage
    required libraries, but the important thing to remember here is that once a module
    is required, the same instance of that module is used throughout your application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块类还会执行一些额外的步骤来缓存和正确管理所需的库，但在这里要记住的重要事情是，一旦模块被 `require`，则在整个应用程序中都会使用该模块的同一实例。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, you use npm, another tool for adding modules to your project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将使用 npm，这是添加模块到您项目的另一个工具。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 3.1**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 3.1**'
- en: '**[Q1:](#ch03qa2q0a1)**'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch03qa2q0a1)**'
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What object is used to make functions or variables within one module available
    to others?
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于使一个模块内的函数或变量对其他模块可用的对象是什么？
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 3.1 answer**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 3.1 答案**'
- en: '**[1:](#ch03qa1q1)**'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch03qa1q1)**'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`exports` is used to share module properties and functionality within an application.
    `module.exports` can also be used in its place.'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`exports` 用于在应用程序内共享模块属性和功能。`module.exports` 也可以用来代替它。'
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)3.1\. Running npm commands'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)3.1\. 运行 npm 命令'
- en: With your installation of Node.js, you also got npm, a package manager for Node.js.
    npm is responsible for managing the external packages (modules that others built
    and made available online) in your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您安装 Node.js，您还获得了 npm，它是 Node.js 的包管理器。npm 负责管理您应用程序中的外部包（其他人构建并在网上提供的模块）。
- en: Throughout application development, you use npm to install, remove, and modify
    these packages. Entering `npm -l` in your terminal brings up a list of npm commands
    with brief explanations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用程序开发过程中，您使用 npm 来安装、删除和修改这些包。在终端中输入 `npm -l` 会显示一个包含简要说明的 npm 命令列表。
- en: You’ll want to know about the few npm commands listed in [table 3.1](#ch03table01).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解列在 [表 3.1](#ch03table01) 中的少数 npm 命令。
- en: Table 3.1\. npm commands to know
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. 您需要了解的 npm 命令
- en: '| npm command | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| npm 命令 | **描述** |'
- en: '| npm init | Initializes a Node.js application and creates a package.json file
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| npm init | 初始化 Node.js 应用程序并创建 package.json 文件 |'
- en: '| npm install <package> | Installs a Node.js package |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| npm install <package> | 安装 Node.js 包 |'
- en: '| npm publish | Saves and uploads a package you build to the npm package community
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| npm publish | 将您构建的包保存并上传到 npm 包社区 |'
- en: '| npm start | Runs your Node.js application (provided that the package.json
    file is set up to use this command) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| npm start | 运行您的 Node.js 应用程序（前提是 package.json 文件已设置为此命令）|'
- en: '| npm stop | Quits the running application |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| npm stop | 停止运行中的应用程序 |'
- en: '| npm docs <package> | Opens the likely documentation page (web page) for your
    specified package |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| npm docs <package> | 打开您指定包的可能文档页面（网页）|'
- en: When you use `npm install <package>`, appending `--save` to your command installs
    the package as a dependency for your application. Appending `--global` installs
    the package globally on your computer, to be used anywhere within terminal. These
    command extensions, called *flags*, have the shorthand forms `-S` and `-g`, respectively.
    `npm uninstall <package>` reverses the install action. In [unit 2](../Text/kindle_split_020.html#part02),
    you’ll use `npm install express -S` to install the Express.js framework for your
    project and `npm install express-generator -g` to install the Express.js generator
    for use as a command-line tool.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `npm install <package>` 时，将 `--save` 添加到你的命令会将包安装为应用程序的依赖项。将 `--global`
    添加到命令中会将包全局安装到你的电脑上，以便在终端的任何地方使用。这些命令扩展，称为 *标志*，分别有 `-S` 和 `-g` 的简写形式。`npm uninstall
    <package>` 会撤销安装操作。在 [单元 2](../Text/kindle_split_020.html#part02) 中，你将使用 `npm
    install express -S` 来安装 Express.js 框架用于你的项目，并使用 `npm install express-generator
    -g` 来安装 Express.js 生成器作为命令行工具。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By default, your package installations appear in your dependencies as production-ready
    packages, which means that these packages will be used when your application goes
    live online. To explicitly install packages for production, use the `--save-prod`
    flag. If the package is used only for development purposes, use the `--save-dev`
    flag. (As of NPM 5, the --save flag is no longer required.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你的包安装会显示在你的依赖项中作为生产就绪包，这意味着当你的应用程序上线时，将使用这些包。要明确安装用于生产的包，请使用 `--save-prod`
    标志。如果包仅用于开发目的，请使用 `--save-dev` 标志。（截至 NPM 5，`--save` 标志不再需要。）
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Later, when you prepare your application for production, making it available
    for the world to use, you may distinguish packages by using the `--production`
    flag.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在后来准备你的应用程序用于生产时，使其可供全世界使用，你可以使用 `--production` 标志来区分包。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Modules, packages, and dependencies**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块、包和依赖**'
- en: 'Throughout your development with Node.js, you’ll hear the terms *modules, packages*,
    and *dependencies* thrown around a lot. Here’s what you need to know:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用 Node.js 进行开发的过程中，您会经常听到 *模块*、*包* 和 *依赖* 这些术语。以下是你需要了解的内容：
- en: '*Modules* are individual JavaScript files containing code that pertains to
    a single concept, functionality, or library.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块* 是包含与单个概念、功能或库相关的代码的单独 JavaScript 文件。'
- en: '*Packages* may contain multiple modules or a single module. They’re used to
    group files offering relevant tools.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包* 可能包含多个模块或单个模块。它们用于将提供相关工具的文件分组。'
- en: '*Dependencies* are Node.js modules used by an application or another module.
    If a package is considered to be an application dependency, it must be installed
    (at the version specified by the application) before the application is expected
    to run successfully.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖* 是应用程序或另一个模块使用的 Node.js 模块。如果一个包被视为应用程序依赖项，那么在应用程序预期成功运行之前，必须安装该包（安装的版本由应用程序指定）。'
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you’d like to incorporate some functionality in your application, you can
    likely find a package that performs this task at [https://www.npmjs.com](https://www.npmjs.com).
    To your recipe application, add the ability to find where your users are located
    based on their ZIP codes. If you have this information, you can determine whether
    users live close enough together to cook with one another.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在应用程序中集成一些功能，你很可能会在 [https://www.npmjs.com](https://www.npmjs.com) 找到一个执行此任务的包。为你的食谱应用程序添加根据用户的邮政编码查找用户位置的功能。如果你有这些信息，你可以确定用户是否足够接近，可以一起烹饪。
- en: To add this feature, you need to install the cities package ([https://www.npmjs.com/package/cities](https://www.npmjs.com/package/cities)),
    which converts text addresses to location coordinates. But you still need one
    more thing for this project before you can install the package successfully. In
    the next section, you properly initialize a Node.js project and create a package.json
    file that npm will use to install `cities`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此功能，你需要安装 cities 包 ([https://www.npmjs.com/package/cities](https://www.npmjs.com/package/cities))，它将文本地址转换为位置坐标。但在你可以成功安装包之前，你还需要为这个项目做一件事。在下一节中，你将正确初始化一个
    Node.js 项目并创建一个 package.json 文件，npm 将使用它来安装 `cities`。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 3.2**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 3.2**'
- en: '**[Q1:](#ch03qa4q0a1)**'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch03qa4q0a1)**'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What flag do you use if you want to install a package globally on your computer?
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想在你的电脑上全局安装一个包，你使用什么标志？
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 3.2 answer**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 3.2 答案**'
- en: '**[1:](#ch03qa3q1)**'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch03qa3q1)**'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `--global` or `-g` flag installs a package for use as a command-line tool
    globally on your computer. The package can be accessible to other projects, not
    exclusively to the one you’re working on.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--global` 或 `-g` 标志将包安装为在您的计算机上全局使用的命令行工具。该包可以被其他项目访问，而不仅仅是您正在工作的项目。'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)3.2\. Initializing a Node.js application'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)3.2\. 初始化 Node.js 应用程序'
- en: Every Node.js application or module contains a package.json file to define the
    properties of that project. This file lives at the root level of your project.
    Typically, this file is where you specify the version of your current release,
    the name of your application, and the main application file. This file is important
    for npm to save any packages to the node community online.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Node.js应用程序或模块都包含一个 package.json 文件来定义该项目的属性。该文件位于项目的根目录级别。通常，此文件用于指定当前发布版本的版本号、应用程序的名称以及主应用程序文件。此文件对于
    npm 保存任何包到在线的 node 社区非常重要。
- en: To get started, create a folder called recipe_connection, navigate to your project
    directory in terminal, and use the `npm init` command to initialize your application.
    You’ll be prompted to fill out the name of your project, the application’s version,
    a short description, the name of the file from which you’ll start the app (entry
    point), test files, Git repositories, your name (author), and a license code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个名为 recipe_connection 的文件夹，在终端中导航到您的项目目录，并使用 `npm init` 命令初始化您的应用程序。您将被提示填写项目的名称、应用程序的版本、简短描述、您将从中启动应用程序的文件名（入口点）、测试文件、Git
    仓库、您的名字（作者）和许可证代码。
- en: For now, be sure to enter your name, use main.js as the entry point, and press
    Enter to accept all the default options. When you confirm all these changes, you
    should see a new package.json file in your project directory. This file should
    resemble the contents of the next listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请确保输入您的名字，使用 main.js 作为入口点，并按 Enter 键接受所有默认选项。当您确认所有这些更改后，您应该在项目目录中看到一个新创建的
    package.json 文件。这个文件的内容应该类似于下一条列表。
- en: Listing 3.2\. Result of package.json file in recipe_connection project in terminal
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 在终端 recipe_connection 项目中的 package.json 文件的结果
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Display contents of package.json, containing a name, version, description,
    starting file, custom scripts, author, and license.**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示 package.json 的内容，包含名称、版本、描述、起始文件、自定义脚本、作者和许可证。**'
- en: 'Now your application has a starting point for saving and managing application
    configurations and packages. You should be able to install `cities` by navigating
    to your project folder in terminal and running the following command: `npm install
    cities --save` ([figure 3.1](#ch03fig01)).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序有一个保存和管理应用程序配置和包的起点。您应该能够在终端导航到您的项目文件夹并运行以下命令来安装 `cities`：`npm install
    cities --save` ([图 3.1](#ch03fig01))。
- en: Figure 3.1\. Installing a package in terminal
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. 在终端中安装一个包
- en: '![](../Images/03fig01_alt.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig01_alt.jpg)'
- en: After you run this command, your package.json gains a new `dependencies` section
    with a reference to your `cities` package installation and its version, as shown
    in the following listing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您的 package.json 将获得一个新的 `dependencies` 部分，其中包含对您安装的 `cities` 包及其版本的引用，如下所示。
- en: Listing 3.3\. Result of your package.json file after package installation in
    terminal
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 在终端中安装包后您的 package.json 文件的结果
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Display dependencies section of package.json.**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示 package.json 的依赖项部分。**'
- en: Also, with this installation, your project folder gains a new folder called
    node_modules. Within this folder live the code contents of the `cities` package
    you installed ([figure 3.2](#ch03fig02)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过这次安装，您的项目文件夹将获得一个名为 node_modules 的新文件夹。在这个文件夹中，您将找到您安装的 `cities` 包的代码内容
    ([图 3.2](#ch03fig02))。
- en: Figure 3.2\. Node.js application structure with node_modules
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 包含 node_modules 的 Node.js 应用程序结构
- en: '![](../Images/03fig02_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig02_alt.jpg)'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You also see a package-lock.json file created at the root level of your project
    directory. This file is automatically created and used by npm to keep track of
    your package installations and to better manage the state and history of your
    project’s dependencies. You shouldn’t alter the contents of this file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会在项目目录的根级别看到一个名为 package-lock.json 的文件被创建。此文件由 npm 自动创建并使用，以跟踪您的包安装情况，并更好地管理项目依赖项的状态和历史。您不应修改此文件的内容。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `--save` flag saves the `cities` package as a dependency for this project.
    Check your package.json file now to see how the package is listed under `dependencies`.
    Because your node_modules folder will grow, I recommend that you don’t include
    it when you share the project code online. Anyone who downloads the project, however,
    can enter `npm install` to automatically install all the project dependencies
    listed in this file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save` 标志将 `cities` 包保存为该项目的依赖项。现在检查你的 package.json 文件，看看该包如何在 `dependencies`
    下列出。由于你的 node_modules 文件夹会增长，我建议你在在线分享项目代码时不要包含它。然而，任何下载项目的人都可以输入 `npm install`
    以自动安装此文件中列出的所有项目依赖项。'
- en: Test this new package by adding the lines in [listing 3.4](#ch03ex04) to main.js.
    Start by requiring the locally installed `cities` package, and make it available
    in this file. Then use the `zip_lookup` method from the `cities` package to find
    a city by that ZIP code. The result is stored in a variable called `myCity`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 [列表 3.4](#ch03ex04) 中的行添加到 main.js 中来测试这个新包。首先，引入本地安装的 `cities` 包，并在该文件中使其可用。然后使用
    `cities` 包中的 `zip_lookup` 方法通过该 ZIP 代码查找城市。结果存储在一个名为 `myCity` 的变量中。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’ll continue to use the `var` keyword for variable definitions where appropriate.
    Because `myCity` is a variable that could change value, I use `var` here. The
    `cities` variable represents a module, so I use `const`. I use the `let` variable
    when the scope of my code could specifically benefit from its use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续在适当的地方使用 `var` 关键字进行变量定义。因为 `myCity` 是一个可能改变值的变量，所以我在这里使用 `var`。`cities`
    变量代表一个模块，所以我使用 `const`。当我的代码的范围内可以特别受益于其使用时，我使用 `let` 变量。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 3.4\. Implementing the `cities` package in main.js
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 在 main.js 中实现 `cities` 包
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Require the cities package.**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入 `cities` 包。**'
- en: '***2*** **Assign the resulting city by using the zip_lookup method.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用 zip_lookup 方法分配结果城市。**'
- en: '***3*** **Log the results to your console.**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将结果记录到你的控制台。**'
- en: The resulting data from that ZIP code is printed to console as shown in the
    following listing. The `zip_lookup` method returns a JavaScript object with coordinates.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 ZIP 代码的结果数据将按以下列表所示打印到控制台。`zip_lookup` 方法返回一个包含坐标的 JavaScript 对象。
- en: Listing 3.5\. Sample result from running main.js in terminal
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. 在终端运行 main.js 的示例结果
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Display the results from the zip_lookup method.**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示 zip_lookup 方法的输出结果。**'
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 3.3**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 3.3**'
- en: '**[Q1:](#ch03qa6q0a1)**'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch03qa6q0a1)**'
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What terminal command initializes a Node.js application with a package.json
    file?
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么终端命令初始化一个带有 package.json 文件的 Node.js 应用程序？
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 3.3 answer**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 3.3 答案**'
- en: '**[1:](#ch03qa5q1)**'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch03qa5q1)**'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`npm init` initializes a Node.js app and prompts you to create a package.json
    file.'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`npm init` 初始化一个 Node.js 应用程序，并提示你创建一个 package.json 文件。'
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned about npm and how to use its array of tools to create
    a new Node.js application and install external packages. You built your own Node.js
    module and required it in your main application file. Last, you installed an external
    package and got it working in your sample app. The next step is integrating these
    tools into a web application. I discuss the first steps of building a web server
    in [lesson 4](../Text/kindle_split_016.html#ch04).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了 npm 以及如何使用其工具集创建新的 Node.js 应用程序和安装外部包。你构建了自己的 Node.js 模块，并在主应用程序文件中引入了它。最后，你安装了一个外部包，并在你的示例应用程序中使其工作。下一步是将这些工具集成到
    Web 应用程序中。我在 [第 4 课](../Text/kindle_split_016.html#ch04) 中讨论了构建 Web 服务器的第一步。
- en: '|  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Create a couple of new modules, and practice adding simple JavaScript objects
    and functions to the `exports` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建几个新的模块，并练习向 `exports` 对象添加简单的 JavaScript 对象和函数。
- en: You can add a function as shown in the following listing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加一个函数，如下面的列表所示。
- en: Listing 3.6\. Exporting a function
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 导出函数
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Export a function.**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导出一个函数。**'
- en: See what happens when you require modules from within another directory in your
    project folder.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当你从项目文件夹中的另一个目录中引入模块时会发生什么。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 4\. Building a simple web server in Node.js
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 课\. 在 Node.js 中构建简单的 Web 服务器
- en: This lesson covers some basic functions of the `http` module, a Node.js library
    of code used for handling requests over the internet. The tech community raves
    about Node.js and its use of JavaScript as a server-side language. In this lesson,
    you build your first web server. In a few short steps, you convert a couple of
    lines of JavaScript to an application with which you can communicate on your web
    browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖了`http`模块的一些基本功能，这是一个用于处理互联网请求的Node.js代码库。技术社区对Node.js及其将JavaScript用作服务器端语言的使用赞不绝口。在本课中，您将构建您的第一个Web服务器。在几个简短的步骤中，您将几行JavaScript代码转换为一个可以在您的Web浏览器中与之通信的应用程序。
- en: This lesson covers
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Generating a basic web server using Node.js and npm
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js和npm生成基本的Web服务器
- en: Writing code that processes requests from a browser and sends back a response
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写处理浏览器请求并发送响应的代码
- en: Running a web server in your browser
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中运行Web服务器
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You’re on your way to building your first web application. Before you deliver
    a complete application, the cooking community would like to see a simple site
    with the flexibility to improve and add features in the future. How long do you
    think it will take you to build a prototype?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在构建您的第一个Web应用的道路上。在您交付完整的应用之前，烹饪社区希望看到的是一个简单的网站，它具有未来改进和添加功能的灵活性。您认为构建原型需要多长时间？
- en: With Node.js, you can use the `http` module to get a web server with sufficient
    functionality built within hours.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js，您可以在几小时内使用`http`模块获得一个功能齐全的Web服务器。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)4.1\. Understanding web servers'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)4.1. 理解Web服务器'
- en: Web servers are the foundation of most Node.js web applications. They allow
    you to load images and HTML web pages to users of your app. Before you get started,
    I’ll discuss some important web server concepts. After all, the final product
    will look and feel a lot better if you have clear expectations of the result.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器是大多数Node.js Web应用的基础。它们允许您向您的应用用户加载图片和HTML网页。在您开始之前，我将讨论一些重要的Web服务器概念。毕竟，如果您对结果有清晰的预期，最终产品看起来和感觉会好得多。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Web servers and HTTP**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务器和HTTP**'
- en: A *web server* is software designed to respond to requests over the internet
    by loading or processing data. Think of a web server like a bank teller, whose
    job is to process your request to deposit, withdraw, or view money in your account.
    Just as the bank teller follows a protocol to ensure that they process your request
    correctly, web servers follow *Hypertext Transfer Protocol* (HTTP), a standardized
    system globally observed for the viewing of web pages and sending of data over
    the internet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web服务器*是一种软件，旨在通过加载或处理数据来响应互联网上的请求。想象一下Web服务器就像银行柜员，其工作是对您存钱、取钱或查看账户中金钱的请求进行处理。就像银行柜员遵循协议以确保正确处理您的请求一样，Web服务器遵循*超文本传输协议*（HTTP），这是一个全球范围内观察到的标准化系统，用于查看网页和通过互联网发送数据。'
- en: One way that a client (your computer) and server communicate is through HTTP
    verbs. These verbs indicate what type of request is being made, such as whether
    the user is trying to load a new web page or updating information in their profile
    page. The context of a user’s interaction with an application is an important
    part of the request-response cycle.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端（您的计算机）和服务器通过HTTP动词进行通信的一种方式。这些动词指示正在进行的请求类型，例如用户是否试图加载新的网页或更新其个人资料页面中的信息。用户与应用程序的交互上下文是请求-响应周期的一个重要部分。
- en: 'Here are the two most widely used HTTP methods you’ll encounter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您将遇到的最常用的两种HTTP方法：
- en: '`GET`—This method requests information from a server. Typically, a server responds
    with content that you can view back on your browser (such as by clicking a link
    to see the home page of a site).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`—此方法从服务器请求信息。通常，服务器会以您可以在浏览器中查看的内容（例如，通过点击链接查看网站的首页）响应。'
- en: '`POST`—This method sends information to the server. A server may respond with
    an HTML page or redirect you to another page in the application after processing
    your data (such as filling out and submitting a sign-up form).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`—此方法将信息发送到服务器。服务器在处理您的数据（例如填写并提交注册表单）后，可能会以HTML页面响应或重定向您到应用中的另一个页面。'
- en: I discuss a couple more methods in [lesson 18](../Text/kindle_split_033.html#ch18).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第18课](../Text/kindle_split_033.html#ch18)中讨论了更多方法。
- en: Most web applications have made changes to adopt *HTTP Secure* (HTTPS), in which
    transmission of data is encrypted. When your application is live on the internet,
    you’ll want to create a public key certificate signed by a trusted issuer of digital
    certificates. This key resides on your server and allows for encrypted communication
    with your client. Organizations such as [https://letsencrypt.org](https://letsencrypt.org)
    offer free certificates that must be renewed every 90 days. For more information
    about HTTPS, read the article at [https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https](https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序都进行了修改以采用 *HTTP 安全* (HTTPS)，其中数据传输是加密的。当您的应用程序在互联网上运行时，您将希望创建一个由受信任的数字证书颁发机构签发的公钥证书。此密钥位于您的服务器上，允许与客户端进行加密通信。例如，[https://letsencrypt.org](https://letsencrypt.org)
    这样的组织提供免费证书，这些证书每 90 天需要更新一次。有关 HTTPS 的更多信息，请阅读 [https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https](https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https)
    上的文章。
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When you visit [https://www.google.com](https://www.google.com), for example,
    behind the scenes you’re making a request to Google’s servers, which in turn send
    a response back to you, rendering the famous Google Search landing page. This
    request-response relationship allows for a channel of communication between the
    user and the application. In [figure 4.1](#ch04fig01), a bundle of data is sent
    to the application’s server in the form of a request, and when the server processes
    the request, it issues a bundle of data back in the form of a response. This process
    is how most of your interaction on the internet is facilitated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问例如 [https://www.google.com](https://www.google.com) 时，实际上您是在向 Google 的服务器发送请求，服务器随后将响应发送回您，渲染著名的
    Google 搜索登录页面。这种请求-响应关系允许用户与应用程序之间建立通信渠道。在 [图 4.1](#ch04fig01) 中，数据包以请求的形式发送到应用程序的服务器，当服务器处理请求时，它会以响应的形式发送回数据包。这个过程就是您在互联网上大部分交互得以实现的方式。
- en: Figure 4.1\. A web server sends your browser web pages, images, and other resources
    on request.
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 服务器根据请求发送网页、图片和其他资源到您的浏览器。
- en: '![](../Images/04fig01_alt.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig01_alt.jpg)'
- en: When you enter the URL you want to see in your browser, an HTTP request is sent
    to a physical computer elsewhere. This request contains some information indicating
    whether you want to load a web page or send information to that computer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中输入想要查看的 URL 时，会向另一处的物理计算机发送一个 HTTP 请求。此请求包含一些信息，指示您是否想要加载网页或向该计算机发送信息。
- en: You may build a fancy application with many bells and whistles, but at the core
    lies a web server to handle its communication on the internet. (These concepts
    will make more sense to you as I discuss them throughout the book.) In the next
    section, you start building your web server.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能可以构建一个功能丰富的应用程序，拥有许多花哨的功能，但核心是一个网络服务器来处理其在互联网上的通信。（随着我在本书中讨论这些概念，这些概念将更加有意义。）在下一节中，您将开始构建您的网络服务器。
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 4.1**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 4.1**'
- en: '**[Q1:](#ch04qa2q0a1)**'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch04qa2q0a1)**'
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does a web server receive from the client, and what does it send back?
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务器从客户端接收什么，又发送回什么？
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 4.1 answer**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 4.1 答案**'
- en: '**[1:](#ch04qa1q1)**'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch04qa1q1)**'
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The web server receives requests from the client and sends back responses.
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务器从客户端接收请求并发送响应。
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)4.2\. Initializing the application with npm'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)4.2\. 使用 npm 初始化应用程序'
- en: Before you get started with a Node.js web application, you need to initialize
    the project in your project folder in terminal. Open a terminal window, and create
    a new directory called simple_server with `mkdir`. You can initialize the project
    with `npm init`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Node.js 网络应用程序之前，您需要在终端中的项目文件夹中初始化项目。打开一个终端窗口，使用 `mkdir` 创建一个名为 simple_server
    的新目录。您可以使用 `npm init` 初始化项目。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: npm is Node.js’ package manager. Your Node.js projects rely on this tool to
    install and build applications. You can learn more about npm and how it’s used
    at [https://docs.npmjs.com](https://docs.npmjs.com).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: npm 是 Node.js 的包管理器。您的 Node.js 项目依赖于这个工具来安装和构建应用程序。您可以在 [https://docs.npmjs.com](https://docs.npmjs.com)
    上了解更多关于 npm 及其使用方法的信息。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Running the `npm init` command initiates a prompt to create a package.json file.
    As the prompt explains, you’ll walk through configuring the most basic settings
    of your Node.js application in this file. For now, you can add main.js as the
    entry point, along with a short description and your name as the author, and elect
    to use the default values offered by pressing the Enter key until you reach the
    end of the prompt
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm init` 命令将启动一个提示，创建一个 package.json 文件。正如提示所解释的，你将在这个文件中配置你的 Node.js 应用程序的最基本设置。现在，你可以将
    main.js 添加为入口点，包括一个简短的描述和你的名字作为作者，并选择按 Enter 键使用默认值，直到达到提示的末尾。
- en: Then you’re asked to confirm your settings with a preview of your package.json
    file. Press Enter to confirm and return to the regular terminal prompt.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将需要通过预览你的 package.json 文件来确认你的设置。按 Enter 键确认并返回常规终端提示符。
- en: '![](../Images/sectionFig.png)4.3\. Coding the application'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)4.3. 编写应用程序代码'
- en: When you installed Node.js, the core library was installed too. Within that
    library is a module called `http`. You’ll use this module to build your web server.
    In this section, you also use a package called `http-status-codes` to provide
    constants for use where HTTP status codes are needed in your application’s responses.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Node.js 时，核心库也一起安装了。在这个库中有一个名为 `http` 的模块。你将使用这个模块来构建你的 Web 服务器。在本节中，你还使用了一个名为
    `http-status-codes` 的包来提供在应用程序响应中需要使用 HTTP 状态码的常量。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Modules in Node.js are libraries of code that come packaged to offer specific
    functionality to your application. Here, the `http` module helps you communicate
    across the web by using HTTP.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 中的模块是代码库，打包以向你的应用程序提供特定的功能。在这里，`http` 模块帮助你通过 HTTP 进行网络通信。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In your text editor, create a new file called main.js, and save it in the project
    folder called simple_server containing the package.json file you created earlier.
    This file will serve as the core application file, where your application will
    serve web pages to your users. Within this project’s directory in terminal, run
    `npm i http-status-codes -S` to save the `http-status-codes` package as an application
    dependency.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中，创建一个名为 main.js 的新文件，并将其保存在包含你之前创建的 package.json 文件的 simple_server
    项目文件夹中。这个文件将作为核心应用程序文件，你的应用程序将在这个文件中为用户服务网页。在终端中，运行 `npm i http-status-codes -S`
    以将 `http-status-codes` 包保存为应用程序依赖项。
- en: 'Before I analyze every aspect of what you’re about to build, take a look at
    all the code in [listing 4.1](#ch04ex01). The first line of code assigns the port
    number you’ll use for this application: 3000.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我分析你即将构建的每个方面之前，先看看 [列表 4.1](#ch04ex01) 中的所有代码。代码的第一行将你将用于此应用程序的端口号设置为 3000。
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Port 3000 is generally used for web servers in development. This number has
    no significance, and you can customize it with a few exceptions. Ports 80 and
    443 usually are reserved for HTTP and HTTPS, respectively.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 端口 3000 通常用于开发中的 Web 服务器。这个数字没有意义，你可以通过一些例外来自定义它。端口 80 和 443 通常分别保留用于 HTTP 和
    HTTPS。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Then you use `require` to import a specific Node.js module called `http` and
    save it as a constant. This module is saved as a constant because you don’t plan
    on reassigning the variable. You also require the `http-status-codes` package
    to provide constants representing HTTP status codes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你使用 `require` 来导入一个名为 `http` 的特定 Node.js 模块并将其保存为一个常量。因为这个变量你不会重新赋值，所以将这个模块保存为常量。你还导入
    `http-status-codes` 包来提供代表 HTTP 状态码的常量。
- en: Next, you use the `http` variable as a reference to the HTTP module to create
    a server, using that module’s `createServer` function, and store the resulting
    server in a variable called `app`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用 `http` 变量作为 HTTP 模块的引用来创建一个服务器，使用该模块的 `createServer` 函数，并将生成的服务器存储在一个名为
    `app` 的变量中。
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using ES6 syntax, you structure callback functions with parameters in parentheses,
    followed by ⇒ instead of the `function` keyword.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 语法，你将带有参数的回调函数用括号括起来，然后用 ⇒ 替代 `function` 关键字。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `createServer` function generates a new instance of `http.Server`, a built-in
    Node.js class with tools for evaluating HTTP communication. With this newly created
    server instance, your app is prepared to receive HTTP requests and send HTTP responses.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer` 函数生成一个 `http.Server` 的新实例，这是一个内置的 Node.js 类，具有评估 HTTP 通信的工具。使用这个新创建的服务器实例，你的应用程序准备接收
    HTTP 请求并发送 HTTP 响应。'
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: These method names are case-sensitive. Using `createserver`, for example, will
    throw an error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法名是区分大小写的。例如，使用 `createserver` 将会引发错误。
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The argument in `createServer` is a callback function that’s invoked whenever
    some event occurs within the server. When the server is running and your application’s
    root URL (home page) is accessed, for example, an HTTP request event triggers
    this callback and allows you to run some custom code. In this case, the server
    returns a simple HTML response.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer`中的参数是一个回调函数，每当服务器内部发生某些事件时都会被调用。例如，当服务器正在运行并且你的应用程序的根URL（主页）被访问时，一个HTTP请求事件会触发这个回调，并允许你运行一些自定义代码。在这种情况下，服务器返回一个简单的HTML响应。'
- en: You log that a request was received from the client and use the `response` parameter
    in the callback function to send content back to the user, from whom you first
    received a request. The first line uses a `writeHead` method to define some basic
    properties of the response’s HTTP header. *HTTP headers* contain fields of information
    that describe the content being transferred in a request or response. Header fields
    may contain dates, tokens, information about the origins of the request and response,
    and data describing the type of connection.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你记录了客户端接收到的请求，并在回调函数中使用`response`参数将内容发送回用户，即你首先接收请求的用户。第一行使用`writeHead`方法来定义响应HTTP头的一些基本属性。*HTTP头*包含描述请求或响应中传输的内容的信息字段。头字段可能包含日期、令牌、关于请求和响应来源的信息，以及描述连接类型的描述性数据。
- en: In this case, you’re returning `httpStatus.OK`, which represents a `200` response
    code, and an HTML `content-type` to indicate that the server received a request
    successfully and will return content in the form of HTML. Following this block,
    you assign a local variable, `responseMessage`, with your response message in
    HTML.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，你返回了`httpStatus.OK`，这代表了一个`200`响应代码，并且指定了HTML`content-type`来表明服务器已成功接收请求，并将以HTML形式返回内容。在此代码块之后，你分配了一个局部变量`responseMessage`，其中包含你的HTML响应消息。
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`200` is the HTTP status code for OK, used to indicate that no issue occurred
    in returning content in an HTTP response header. To get a list of other HTTP status
    codes, enter `http.STATUS_CODES` in the Node.js REPL shell. Use `httpStatus.OK`
    in place of the explicit number.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`200`是表示OK的HTTP状态代码，用于指示在HTTP响应头中返回内容时没有发生问题。要获取其他HTTP状态代码的列表，请在Node.js REPL外壳中输入`http.STATUS_CODES`。使用`httpStatus.OK`代替显式的数字。'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Right below that line, you’re writing a line of HTML in the response with `write`
    and closing the response with `end`. You must end your response with `end` to
    tell the server that you’re no longer writing content. Not doing so leaves the
    connection with the client open, preventing the client from receiving the response.
    You also log your response at this point so you can see that a response was sent
    from the server itself.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在那行代码下面，你使用`write`写入一行HTML到响应中，并使用`end`关闭响应。你必须使用`end`来告诉服务器你不再写入内容。如果不这样做，将会使客户端与服务器之间的连接保持开放，阻止客户端接收响应。你也在此时记录了响应，以便你可以看到服务器本身发送了响应。
- en: The last line of code takes the server instance, `app`, and runs the `listen`
    method to indicate that the server is ready for incoming requests at port `3000`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行将服务器实例`app`传递给`listen`方法，以表明服务器已准备好在端口`3000`上接收传入的请求。
- en: Listing 4.1\. Simple web application code in main.js
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. main.js中的简单Web应用程序代码
- en: '[PRE6]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Require the http and http-status-codes modules.**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要引入http和http-status-codes模块。**'
- en: '***2*** **Create the server with request and response parameters.**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用请求和响应参数创建服务器。**'
- en: '***3*** **Write the response to the client.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **向客户端写入响应。**'
- en: '***4*** **Tell the application server to listen on port 3000.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **告诉应用程序服务器监听端口3000。**'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `response` object is used by Node.js and carried throughout the application
    as a way to pass information about the current client transaction from function
    to function. Some methods on the `response` object allow you to add data to or
    remove data from the object; `writeHead` and `write` are two such functions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`response`对象由Node.js使用，并在整个应用程序中携带，作为从函数到函数传递关于当前客户端事务信息的方式。`response`对象上的一些方法允许你向对象中添加或从对象中删除数据；`writeHead`和`write`是这类函数中的两个。'
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: There your application is, in all its glory! Not so terrible. In only a few
    lines of code, you’ll also build a web server this way.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序就在那里，所有这些都在它的荣耀之中！并不那么可怕。仅用几行代码，你也将以这种方式构建一个Web服务器。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t specify a port number, your operating system will choose a port
    for you. This port number is what you’ll soon use to confirm through your web
    browser that your web server is running.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定端口号，操作系统将为你选择一个端口号。这个端口号是你很快将通过浏览器确认你的网络服务器正在运行的那个端口号。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Callbacks in Node.js**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js中的回调**'
- en: Part of what makes Node.js so fast and efficient is its use of callbacks. Callbacks
    aren’t new to JavaScript, but they’re overwhelmingly used throughout Node.js and
    worth mentioning here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js之所以如此快速和高效的部分原因在于它使用了回调函数。回调函数在JavaScript中并不新鲜，但在Node.js中却被广泛使用，这里值得提一下。
- en: A *callback* is an anonymous function (a function without a name) that’s set
    up to be invoked as soon as another function completes. The benefit of using callbacks
    is that you don’t have to wait for the original function to complete processing
    before running other code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*回调*是一个匿名函数（一个没有名字的函数），它被设置为在另一个函数完成时立即调用。使用回调的好处是，你不必等待原始函数完成处理后再运行其他代码。
- en: Consider virtually depositing a check in your bank account by uploading a picture
    to your bank’s mobile app. A callback is equivalent to receiving a notification
    a couple of days later that the check was verified and deposited. In the meantime,
    you were able to go about your normal routine.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑通过上传图片到你的银行移动应用来在银行账户中虚拟存入一张支票。回调相当于几天后收到通知，说支票已被验证并存入。在此期间，你能够继续你的正常日常活动。
- en: 'In the `http` web server example, incoming requests from the client are received
    on a rolling basis and thereupon pass the request and response as JavaScript objects
    to a call-back function, as shown in the following figure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`http`网络服务器示例中，客户端的请求是滚动接收的，然后将其作为JavaScript对象传递给回调函数，如下面的图所示：
- en: '![](../Images/f046-01_alt.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f046-01_alt.jpg)'
- en: Callbacks on the server indicate when to respond to the client.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的回调表示何时响应客户端。
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this code in place, you’re ready to start your Node.js application from
    terminal.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里放置好代码后，你就可以从终端开始运行你的Node.js应用程序了。
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 4.2**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 4.2**'
- en: '**[Q1:](#ch04qa4q0a1)**'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch04qa4q0a1)**'
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why should you use `const` instead of `var` to store the HTTP server in your
    application?
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么你应该使用`const`而不是`var`来存储你的应用程序中的HTTP服务器？
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 4.2 answer**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 4.2 答案**'
- en: '**[1:](#ch04qa3q1)**'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch04qa3q1)**'
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because your server will continue to listen for communication from clients,
    it’s important not to reassign the variable representing the server. In ES6, it
    has become convention to mark these objects as constants, not reassignable variables.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为你的服务器将继续监听来自客户端的通信，所以不要重新分配表示服务器的变量非常重要。在ES6中，已经成为了惯例，将这些对象标记为常量，而不是可重新分配的变量。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)4.4\. Running the application'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)4.4\. 运行应用程序'
- en: 'The last step is an easy one. Navigate to your project’s directory with terminal,
    and run `node main` in your terminal window. Next, open any browser to the address
    `localhost: 3000`. You see a message indicating that the server has started. Your
    terminal window should resemble [figure 4.2](#ch04fig02).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一步很简单。使用终端导航到你的项目目录，并在终端窗口中运行`node main`。接下来，在任何浏览器中打开地址`localhost: 3000`。你应该会看到一个表示服务器已启动的消息。你的终端窗口应该类似于[图4.2](#ch04fig02)。'
- en: Figure 4.2\. Running the a basic Node.js server
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 运行基本的Node.js服务器
- en: '![](../Images/04fig02_alt.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig02_alt.jpg)'
- en: The browser window should greet you and the universe with salutations, as shown
    in [figure 4.3](#ch04fig03). Congratulations! Your first Node.js web application
    is complete. It’s big, and it’s about to get bigger and better.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器窗口应该用问候语问候你和你所在的宇宙，如图[图4.3](#ch04fig03)所示。恭喜！你的第一个Node.js网络应用程序已经完成。它很大，而且即将变得更大更好。
- en: Figure 4.3\. Display of your first web page
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3.你的第一个网页显示
- en: '![](../Images/04fig03_alt.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig03_alt.jpg)'
- en: To stop the application, press Ctrl-C in your terminal window. You can also
    close the terminal window, but you may risk not shutting down the application
    properly, in which case the application could continue to run behind the scenes
    (requiring more command-line magic to kill the process).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止应用程序，请在终端窗口中按Ctrl-C。你也可以关闭终端窗口，但可能会存在无法正确关闭应用程序的风险，在这种情况下，应用程序可能会在后台继续运行（需要更多的命令行技巧来终止进程）。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 4.3**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 4.3**'
- en: '**[Q1:](#ch04qa6q0a1)**'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch04qa6q0a1)**'
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you navigate to http://localhost:3000/ while your server is running, what
    type of HTTP request are you making?
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您的服务器正在运行时，您导航到http://localhost:3000/，您正在发起什么类型的HTTP请求？
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 4.3 answer**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 4.3 答案**'
- en: '**[1:](#ch04qa5q1)**'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch04qa5q1)**'
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nearly every request you can expect to make at this stage in the application’s
    development, including a request to http://localhost:300/, is an HTTP GET request.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在应用程序开发的这个阶段，您可以预见的几乎所有请求，包括对http://localhost:300/的请求，都是HTTP GET请求。
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned that Node.js has built-in functionality for creating
    web servers via the `http` module. You configured a new Node.js application via
    the package.json file. Using the `http` module and `createServer` method, with
    minimal effort you created a web server, which is a stepping stone to building
    robust applications with Node.js. Through terminal, you were able to run a web-server
    application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了Node.js通过 `http` 模块具有创建网络服务器的内置功能。您通过package.json文件配置了一个新的Node.js应用程序。使用
    `http` 模块和 `createServer` 方法，您以最小的努力创建了一个网络服务器，这是构建Node.js强大应用程序的垫脚石。通过终端，您能够运行一个网络服务器应用程序。
- en: Complete the “[Try this](#ch04sb10)” exercise to check your understanding.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 “[尝试这个](#ch04sb10)” 练习以检查您的理解。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: '`npm init` interactively generates a package.json file, although you could
    create this file on your own.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm init` 以交互方式生成一个package.json文件，尽管您也可以自己创建此文件。'
- en: Create a new package.json from scratch for the project in this lesson. Don’t
    use `npm init`; see whether you can construct a similar JSON-structured file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为本课的项目从头开始创建一个新的package.json文件。不要使用 `npm init`；看看您是否可以构建一个类似的JSON结构文件。
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 5\. Handling incoming data
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5课\. 处理传入的数据
- en: In [lesson 4](../Text/kindle_split_016.html#ch04), I introduced you to the web
    server and showed how you can create one with Node.js. Every time a user visits
    a URL that leads to your application, a request is made, and each request must
    be processed by the code you write. In this lesson, you learn how to gather and
    process some of the information in these requests. You also build application
    routes—code logic to match requests with appropriate responses.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4课](../Text/kindle_split_016.html#ch04)中，我向您介绍了网络服务器，并展示了如何使用Node.js创建一个服务器。每次用户访问指向您应用程序的URL时，都会发起一个请求，并且每个请求都必须由您编写的代码进行处理。在本课中，您将学习如何收集和处理这些请求中的某些信息。您还将构建应用程序路由——将请求与适当的响应匹配的代码逻辑。
- en: This lesson covers
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Collecting and processing request data
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集和处理请求数据
- en: Submitting a `POST` request with the `curl` command
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `curl` 命令提交 `POST` 请求
- en: Building a web application with basic routes
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本路由构建网络应用程序
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这个**'
- en: As you plan web pages for your recipe application, you realize that the basic
    web server you’ve built knows how to respond only with single lines of HTML. What
    if you want to show a complete home page and different HTML content for a contact
    page?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为您的食谱应用程序规划网页时，您意识到您构建的基本网络服务器只知道如何用单行HTML响应。如果您想展示一个完整的首页和不同内容的联系页面呢？
- en: Every web application uses routes alongside its web server to ensure that users
    get to see what they specifically requested. With Node.js, you can define these
    routes in as few steps as any conditional block.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络应用程序都会使用路由与它的网络服务器一起，以确保用户能看到他们具体请求的内容。使用Node.js，您可以以尽可能少的步骤定义这些路由。
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)5.1\. Reworking your server code'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)5.1\. 重新编写您的服务器代码'
- en: To start this lesson, rearrange the code from [lesson 4](../Text/kindle_split_016.html#ch04)
    to get a better idea of how the server is behaving. Create a new project called
    `second_server` within its own project directory, and inside, add a new main.js
    file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本课，重新排列[第4课](../Text/kindle_split_016.html#ch04)中的代码，以更好地了解服务器的行为。在它自己的项目目录中创建一个名为
    `second_server` 的新项目，并在其中添加一个新的main.js文件。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this lesson and following lessons, I expect you to initialize your Node.js
    application with `npm init` and to follow the guidance in [lesson 4](../Text/kindle_split_016.html#ch04)
    to create a package.json file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课及随后的课程中，我期望您使用 `npm init` 初始化您的Node.js应用程序，并遵循[第4课](../Text/kindle_split_016.html#ch04)中的指导创建一个package.json文件。
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In your code, you have a server object that has a callback function, `(req,
    res) ⇒ {}`, which is run every time a request is made to the server. With your
    server running, if you visit `localhost:3000` in your browser and refresh the
    page, that callback function is run twice—once on every refresh.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，您有一个服务器对象，它有一个回调函数 `(req, res) ⇒ {}`，该函数在每次向服务器发出请求时运行。当您的服务器正在运行时，如果您在浏览器中访问
    `localhost:3000` 并刷新页面，该回调函数将运行两次——每次刷新时运行一次。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`req` and `res` represent the HTTP request and response. You can use any variable
    names here. Keep the order in mind; request always comes before response in this
    method.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`req` 和 `res` 代表 HTTP 请求和响应。您可以使用任何变量名，但请注意顺序；在这个方法中，请求总是在响应之前。'
- en: '|  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In other words, upon receiving a request, the server passes a request and response
    object to a function where you can run your code. Another way to write the code
    for this server is shown in [listing 5.1](#ch05ex01). The server fires the code
    in a callback function when a `request` event is triggered. When a user visits
    your application’s web page, the code within the braces runs. Then the server
    prepares a response by assigning a response code of `200` and defines the type
    of content in the response as HTML. Last, the server sends the HTML content within
    the parentheses and simultaneously closes the connection with the client.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当服务器接收到请求时，它会将请求和响应对象传递给一个函数，您可以在该函数中运行您的代码。另一种为该服务器编写代码的方法请参阅[代码列表 5.1](#ch05ex01)。当触发
    `request` 事件时，服务器在回调函数中执行代码。当用户访问您的应用程序的网页时，花括号内的代码运行。然后服务器通过分配响应代码 `200` 并定义响应中的内容类型为
    HTML 来准备响应。最后，服务器发送括号内的 HTML 内容，并同时关闭与客户端的连接。
- en: Listing 5.1\. A simple server with a request event listener in main.js
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**代码列表 5.1\. 在 main.js 中的简单服务器和请求事件监听器**'
- en: '[PRE7]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Listen for requests.**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **监听请求。**'
- en: '***2*** **Prepare a response.**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **准备响应。**'
- en: '***3*** **Respond with HTML.**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **以 HTML 响应。**'
- en: Run `node main` in terminal and visit http://localhost:3000/ in your web browser
    to view the response containing one line of HTML on the screen.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行 `node main`，然后在您的网页浏览器中访问 http://localhost:3000/ 以查看包含一行 HTML 的响应。
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to reinstall the http-status-codes package again for this new project
    by runinng npm i http-status-codes -save-dev.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要重新安装 http-status-codes 包以用于此新项目，方法是通过运行 npm i http-status-codes -save-dev。
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s great to have some content on the screen, but you want to modify the content
    based on the type of request you get. If the user is visiting the contact page
    or submitting a form they filled out, for example, they’ll want to see different
    content on the screen. The first step is determining which HTTP method and URL
    were in the headers of the request. In the next section, you look at these request
    attributes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示一些内容是很好的，但您希望根据您收到的请求类型修改内容。例如，如果用户正在访问联系页面或提交他们填写过的表单，他们将在屏幕上看到不同的内容。第一步是确定请求头中的
    HTTP 方法以及 URL。在下一节中，您将查看这些请求属性。
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 5.1**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 5.1**'
- en: '**[Q1:](#ch05qa2q0a1)**'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch05qa2q0a1)**'
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the name of the function your server calls every time a request is received?
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务器每次接收到请求时调用的函数叫什么名字？
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 5.1 answer**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 5.1 答案**'
- en: '**[1:](#ch05qa1q1)**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch05qa1q1)**'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function that’s called after each request is received is a callback function.
    Because the function doesn’t have an identifying name, it’s also considered to
    be an anonymous function
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每次接收到请求后调用的函数是回调函数。因为该函数没有标识名称，所以它也被视为匿名函数。
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)5.2\. Analyzing request data'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)5.2. 分析请求数据'
- en: '*Routing* is a way for your application to determine how to respond to a requesting
    client. Some routes are designed by matching the URL in the request object. That
    method is how you’re going to build your routes in this lesson.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由* 是您的应用程序确定如何响应用户请求的一种方式。一些路由是通过匹配请求对象中的 URL 来设计的。您将在本课中通过这种方法构建您的路由。'
- en: Each request object has a `url` property. You can view which URL the client
    requested with `req.url`. Test this property and two other properties by logging
    them to your console. Add the code in the next listing to the `app.on(`“`request`”`)`
    code block.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求对象都有一个 `url` 属性。您可以使用 `req.url` 查看客户端请求的 URL。通过将它们记录到控制台来测试此属性和其他两个属性。将下一列表中的代码添加到
    `app.on(`“`request`”`)` 代码块中。
- en: Listing 5.2\. Logging request data in main.js
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**代码列表 5.2\. 在 main.js 中记录请求数据**'
- en: '[PRE8]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Log the HTTP method used.**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **记录使用的 HTTP 方法。**'
- en: '***2*** **Log the request URL.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **记录请求 URL。**'
- en: '***3*** **Log request headers.**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **记录请求头。**'
- en: 'Because some objects in the request can have within them other nested objects,
    convert the objects to more-readable strings by using `JSON.stringify` within
    your own custom wrapper function, `getJSONString`, as shown in [listing 5.3](#ch05ex03).
    This function takes a JavaScript object as an argument and returns a string. Now
    you can change your log statements to use this function. You can print the request
    method, for example, by using ``console.log (`Method: ${getJSONString(req.method)}`)``;.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '因为请求中的某些对象内部可能包含其他嵌套对象，你可以通过在自己的自定义包装函数 `getJSONString` 中使用 `JSON.stringify`
    来将这些对象转换为更易读的字符串，如 [列表 5.3](#ch05ex03) 所示。这个函数接受一个 JavaScript 对象作为参数，并返回一个字符串。现在你可以更改你的日志语句以使用这个函数。例如，你可以通过使用
    `console.log (`Method: ${getJSONString(req.method)}`)` 来打印请求方法。'
- en: Listing 5.3\. Logging request data in main.js
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 在 main.js 中记录请求数据
- en: '[PRE9]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Convert JavaScript object to string.**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 JavaScript 对象转换为字符串。**'
- en: 'When you restart your server, run main.js again, and access http://localhost:3000
    in your web browser, you’ll notice in your terminal window information indicating
    that a `GET` request was made to the `/` URL (the home page), followed by that
    request’s header data. Try entering a different URL, such as http://localhost:3000/testing
    or http://localhost: 3000/contact. Notice that you still get the same HTML text
    on the browser, but your console continues to log the URLs you type in the browser.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '当你重新启动你的服务器时，再次运行 main.js，并在你的网页浏览器中访问 http://localhost:3000，你会在终端窗口中注意到指示已向
    `/` URL（主页）发出 `GET` 请求的信息，随后是那个请求的头数据。尝试输入不同的 URL，例如 http://localhost:3000/testing
    或 http://localhost: 3000/contact。注意，你仍然在浏览器中看到相同的 HTML 文本，但你的控制台继续记录你在浏览器中输入的
    URL。'
- en: The types of requests you’re largely dealing with are `GET` requests. If you
    were building an application with forms for users to fill out, though, your server
    should be able to process that form data and respond to the user to let them know
    that the data has been received.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你主要处理的是 `GET` 请求类型。如果你正在构建一个用户需要填写表单的应用程序，那么你的服务器应该能够处理该表单数据并响应用户，让他们知道数据已被接收。
- en: The request object, like most objects in Node.js, can also listen for events,
    similarly to the server. If someone makes a `POST` request to the server (trying
    to send data to the server), the content of that `POST` lives in the request’s
    body. Because a server never knows how much data is being sent, posted data comes
    into the `http` server via chunks.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象，就像 Node.js 中的大多数对象一样，也可以监听事件，类似于服务器。如果有人向服务器发送 `POST` 请求（试图向服务器发送数据），那么那个
    `POST` 的内容就存在于请求的体中。因为服务器永远不知道正在发送多少数据，所以发布的数据通过数据块进入 `http` 服务器。
- en: '|  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Data chunks allow information to stream into and out of a server. Instead of
    waiting for a large set of information to arrive at the server, Node.js allows
    you to work with parts of that information as it arrives via the `ReadableStream`
    library.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 数据块允许信息流入和流出服务器。Node.js 允许你通过 `ReadableStream` 库在信息到达时处理信息的一部分，而不是等待大量信息到达服务器。
- en: '|  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To collect all the posted data with a server, you need to listen for each piece
    of data received and arrange the data yourself. Luckily, the request listens for
    a specific `data` event. `req.on(`“`data`”`)` is triggered when data is received
    for a specific request. You need to define a new array, `body`, outside this event
    handler and sequentially add the data chunks to it as they arrive at the server.
    Notice the exchange of posted data in [figure 5.1](#ch05fig01). When all the data
    chunks are received, they can be collected as a single data item.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集服务器上所有已发布的数据，你需要监听每条接收到的数据并自行整理这些数据。幸运的是，请求监听一个特定的 `data` 事件。当为特定请求接收到数据时，`req.on(`“`data`”`)`
    被触发。你需要在事件处理程序外部定义一个新的数组，`body`，并将数据块按顺序添加到其中，当它们到达服务器时。注意查看 [图 5.1](#ch05fig01)
    中发布的交换数据。当所有数据块都接收完毕后，它们可以作为一个单一的数据项收集。
- en: Figure 5.1\. A web server collects posted data and arranges it.
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. 一个网络服务器收集发布的数据并对其进行整理。
- en: '![](../Images/05fig01_alt.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig01_alt.jpg)'
- en: Within the `app.on(`“`request`”`)` code block, add the new request event handlers
    in [listing 5.4](#ch05ex04) to read incoming data. In this code example, every
    time a request is made to the server, you execute the code in the callback function.
    An array is created and referred to as `body`, and every time data from the request
    is received, you process it in another callback function. The received data is
    added to the `body` array. When the transmission of data is complete, you execute
    code in a third callback function. The `body` array is turned into a `String`
    of text, and the request’s contents are logged to your console.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.on(`“`request`”`)` 代码块中，添加新的请求事件处理器到 [列表 5.4](#ch05ex04) 以读取传入的数据。在此代码示例中，每次向服务器发出请求时，您都会执行回调函数中的代码。创建了一个数组并命名为
    `body`，每次接收到请求的数据时，您都会在另一个回调函数中处理它。接收到的数据被添加到 `body` 数组中。当数据传输完成时，您在第三个回调函数中执行代码。`body`
    数组被转换为文本字符串，请求的内容被记录到您的控制台。
- en: Listing 5.4\. Handling posted request data in main.js
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 在 main.js 中处理已发布的请求数据
- en: '[PRE10]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Listen for requests.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **监听请求。**'
- en: '***2*** **Create an array to hold chunk contents.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个数组来存储数据块内容。**'
- en: '***3*** **Process it in another callback function.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在另一个回调函数中处理它。**'
- en: '***4*** **Add received data to the body array.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将接收到的数据添加到体数组中。**'
- en: '***5*** **Run code when data transmission ends.**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **数据传输结束时运行代码。**'
- en: '***6*** **Convert the body array to a String of text.**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将数组体转换为文本字符串。**'
- en: '***7*** **Log the request’s contents to your console.**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **将请求的内容记录到您的控制台。**'
- en: With this added code, your application is prepared to receive posted data collected
    into an array and converted back to `String` format. When an event is triggered,
    indicating that some chunk of data reached the server, you handle that data by
    adding the chunk (represented as a Buffer object) to an array. When the event
    indicating the request’s connected has ended, you follow up by taking all the
    array’s contents and turn them into text you can read. To test this process, try
    sending a `POST` request to your server from terminal.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此代码后，您的应用程序已准备好接收收集到数组中的已发布数据并将其转换回 `String` 格式。当触发事件，表明某些数据块到达服务器时，您通过将数据块（表示为
    Buffer 对象）添加到数组中来处理该数据。当指示请求连接结束的事件结束时，您随后通过获取数组的全部内容并将它们转换为可读的文本来跟进。为了测试此过程，请尝试从终端向您的服务器发送
    `POST` 请求。
- en: 'Because you haven’t built a form yet, you can use a `curl` command. Follow
    these steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您还没有构建表单，所以可以使用 `curl` 命令。按照以下步骤操作：
- en: With your web server running in one terminal window, open a new terminal window.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端窗口中运行您的网络服务器时，打开一个新的终端窗口。
- en: 'In the new window. run the following command: `curl --data "username= Jon&password=secret"
    http://localhost:3000`'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，运行以下命令：`curl --data "username= Jon&password=secret" http://localhost:3000`
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: '`curl` is a simple way of mimicking a browser’s request to a server. Using
    the `curl` keyword, you can use different flags, such as `–data,` to send information
    to a server via a `POST` request.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 是模拟浏览器向服务器发送请求的一种简单方式。使用 `curl` 关键字，您可以使用不同的标志，例如 `–data,` 通过 `POST`
    请求将信息发送到服务器。'
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re a Windows user, before you install `curl` on your computer, install
    the software and package manager called Chocolatey ([https://chocolatey.org/install](https://chocolatey.org/install)).
    Then you can run `choco install curl` in your command line.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Windows 用户，在您的计算机上安装 `curl` 之前，请安装名为 Chocolatey 的软件和包管理器（[https://chocolatey.org/install](https://chocolatey.org/install)）。然后您可以在命令行中运行
    `choco install curl`。
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the first terminal window, you should see the contents of the request’s body
    logged to the screen, letting you know that a request was received and processed
    by your server ([figure 5.2](#ch05fig02)).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个终端窗口中，您应该看到请求体的内容已记录到屏幕上，这表明您的服务器已接收并处理了请求（[图 5.2](#ch05fig02)）。
- en: Figure 5.2\. Results of running a `curl` command
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 运行 `curl` 命令的结果
- en: '![](../Images/05fig02_alt.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig02_alt.jpg)'
- en: '|  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: For a more user-friendly interface for submitting data to your application,
    install Insomnia ([https://insomnia.rest/download/](https://insomnia.rest/download/)).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使向您的应用程序提交数据更加用户友好，请安装 Insomnia ([https://insomnia.rest/download/](https://insomnia.rest/download/))。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In [lesson 8](../Text/kindle_split_021.html#ch08), you learn about simpler ways
    to handle request contents. For now, try to control what type of response you
    write back to the client based on the URL and method in the request.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 课](../Text/kindle_split_021.html#ch08) 中，您将了解处理请求内容的一些更简单的方法。现在，尝试根据请求的
    URL 和方法控制您向客户端写回的响应类型。
- en: '|  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 5.2**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 5.2**'
- en: '**[Q1:](#ch05qa4q0a1)**'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch05qa4q0a1)**'
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: Every submitted form sends its full contents in a single chunk
    of data.'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正确或错误：每个提交的表单都将其全部内容以单个数据块的形式发送。
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 5.2 answer**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 5.2 答案**'
- en: '**[1:](#ch05qa3q1)**'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch05qa3q1)**'
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. Data is streamed to the server in chunks, which allows the server to
    respond based on part of the received data or even the size of the collected data.
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。数据以块的形式流式传输到服务器，这使得服务器可以根据接收到的部分数据或收集到的数据的大小进行响应。
- en: '|  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)5.3\. Adding routes to a web application'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)5.3\. 向 web 应用程序添加路由'
- en: A *route* is a way of determining how an application should respond to a request
    made to a specific URL. An application should route a request to the home page
    differently from a request to submit login information.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由* 是确定应用程序如何响应对特定 URL 的请求的一种方式。应用程序应该将请求路由到主页的方式与提交登录信息的请求不同。'
- en: You’ve established that a user can make a request to your web server; from there,
    you can evaluate the type of request and prompt an appropriate response. Consider
    your simple HTTP web server code, which so far has one response to any request.
    This example accepts any request made to the server (localhost) at port `3000`
    and responds with a line of HTML on the screen.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经确定用户可以向您的 web 服务器发出请求；从那里，您可以评估请求的类型，并给出适当的响应。考虑您简单的 HTTP web 服务器代码，到目前为止，它对任何请求只有一个响应。此示例接受对服务器（localhost）端口
    `3000` 的任何请求，并在屏幕上显示一行 HTML。
- en: Listing 5.5\. Simple server example in main.js
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. main.js 中的简单服务器示例
- en: '[PRE11]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Respond with HTML to every request.**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **对每个请求响应 HTML。**'
- en: As a first web application, this application is a great accomplishment, but
    you need to start building an application with more functionality. If this project
    were a legitimate application live on the internet, for example, you might want
    to show content based on what the user is looking for. If the user wants to see
    an information page, you may want them to find that information at the `/info`
    URL (http://localhost:3000/info). Right now, if users visit those URLs, they’ll
    be greeted by the same HTML welcome line.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个 web 应用程序，这个应用程序是一个巨大的成就，但您需要开始构建一个具有更多功能的应用程序。例如，如果这个项目是一个真正在互联网上运行的合法应用程序，您可能希望根据用户正在寻找的内容显示内容。如果用户想查看信息页面，您可能希望他们在
    `/info` URL（http://localhost:3000/info）中找到该信息。目前，如果用户访问这些 URL，他们将看到相同的 HTML 欢迎行。
- en: The next step is checking the client’s request and basing the response body
    on that request’s contents. This structure is otherwise known as *application
    routing*. Routes identify specific URL paths, which can be targeted in the application
    logic and which allow you to specify the information to be sent to the client.
    Creating these routes is necessary for a fully integrated application experience.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查客户端的请求，并根据该请求的内容确定响应体。这种结构通常被称为 *应用路由*。路由标识特定的 URL 路径，可以在应用程序逻辑中进行定位，并允许您指定要发送给客户端的信息。创建这些路由对于实现完全集成的应用程序体验是必要的。
- en: 'Duplicate the simple_server project folder with a new name: simple_routes.
    Then add a few routes to the main.js file, as shown in [listing 5.6](#ch05ex06).'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 将 simple_server 项目文件夹复制一份，并使用新名称：simple_routes。然后在 main.js 文件中添加一些路由，如 [列表 5.6](#ch05ex06)
    所示。
- en: You set up a mapping of routes to responses called `routeResponseMap`. When
    a request is made to http://localhost:3000/info, you check whether the request’s
    URL has a match in `routeResponseMap` and respond with an info page heading. When
    a request is made to http://localhost:3000/contact, you respond with a contact
    page heading. To all other requests, you respond with a generic greeting.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 您设置了一个名为 `routeResponseMap` 的路由到响应的映射。当请求 http://localhost:3000/info 时，您检查请求的
    URL 是否在 `routeResponseMap` 中有匹配项，并响应一个信息页面标题。当请求 http://localhost:3000/contact
    时，您响应一个联系页面标题。对于所有其他请求，您响应一个通用的问候语。
- en: Listing 5.6\. Simple routing in a web server in main.js
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. main.js 中的 web 服务器简单路由
- en: '[PRE12]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Define mapping of routes with responses.**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义带有响应的路由映射。**'
- en: '***2*** **Check whether a request route is defined in the map.**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查请求路由是否在映射中定义。**'
- en: '***3*** **Respond with default HTML.**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **响应默认HTML。**'
- en: With the additions to your code, you can differentiate between a couple of URLs
    and offer different content accordingly. You’re still not concerned with the HTTP
    method used in the request, but you can check whether the user was searching for
    the`/info` route or the `/contact` route. Users can more intuitively determine
    what URLs they need to type to get to that page’s expected content.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码添加后，你可以区分几个URL，并相应地提供不同的内容。你仍然不关心请求中使用的HTTP方法，但你可以检查用户是否正在搜索`/info`路由或`/contact`路由。用户可以更直观地确定他们需要输入哪些URL才能到达该页面的预期内容。
- en: 'Give the code a try. Save the code in [listing 5.6](#ch05ex06) in a project
    file called main.js, and run that file in terminal. Then try accessing http://localhost:3000/info
    or http://localhost: 3000/contact in your web browser. Any other URL should result
    in the original default welcome HTML line.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这段代码。将代码保存在名为main.js的项目文件中，并在终端中运行该文件。然后尝试在Web浏览器中访问http://localhost:3000/info或http://localhost:3000/contact。任何其他URL都应导致原始默认欢迎HTML行。
- en: To mimic heavy processing or external calls made by your server, you can add
    the code in the following listing to a route to manually delay your response to
    the client.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟服务器执行的重处理或外部调用，你可以在以下列表中添加代码到一个路由，以手动延迟对客户端的响应。
- en: Listing 5.7\. Route with a timer in main.js
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. main.js中的带定时器的路由
- en: '[PRE13]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Wrap a response with setTimeout to delay the response manually.**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用setTimeout手动延迟响应。**'
- en: 'If you run this file again, you’ll notice that the page’s load time is approximately
    two seconds longer. You have full control of what code is executed and what content
    is served to your user. Keep this fact in mind: as your application grows, your
    web pages’ response times will naturally be longer.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行此文件，你会注意到页面的加载时间大约长了两秒。你对执行什么代码以及向用户提供什么内容有完全的控制权。记住这个事实：随着你的应用程序增长，你的网页响应时间自然会变长。
- en: Look at the browser screenshot for the `/contact` URL in [figure 5.3](#ch05fig03).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图5.3](#ch05fig03)中`/contact` URL的浏览器截图。
- en: Figure 5.3\. Browser view for the /`contact` URL
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. `/contact` URL的浏览器视图
- en: '![](../Images/05fig03_alt.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig03_alt.jpg)'
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 5.3**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查5.3**'
- en: '**[Q1:](#ch05qa6q0a1)**'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch05qa6q0a1)**'
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With what URL do you route requests to the home page?
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用什么URL将请求路由到主页？
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 5.3 answer**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 5.3 答案**'
- en: '**[1:](#ch05qa5q1)**'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch05qa5q1)**'
- en: ''
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The / route represents the home page of the application.
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`/`路由代表应用程序的主页。'
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to handle request content, respond with viewable
    HTML, and build a server route. By identifying a request’s contents, you can process
    posted data from a request and separate response content based on targeted URLs.
    The creation of routes shapes your application logic. As a web application expands,
    its routes expand with it, and so do the types of content that it’s able to deliver.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何处理请求内容，以可查看的HTML进行响应，并构建服务器路由。通过识别请求的内容，你可以处理请求中的提交数据，并根据目标URL分离响应内容。路由的创建塑造了你的应用程序逻辑。随着Web应用程序的扩展，其路由也会随之扩展，它能够提供的内容类型也会增加。
- en: In the next lesson, I talk about serving individual HTML files, images, and
    web-page styles.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我将讨论服务单个HTML文件、图像和网页样式。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: 'Your simple web application is handling two path requests with routes you created
    for `/info` and `/contact`. A normal application will likely have more pages to
    visit. Add three more routes to the application for the following paths:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你的简单Web应用程序正在处理你为`/info`和`/contact`创建的两个路径请求。一个正常的应用程序可能需要访问更多的页面。为以下路径添加三个更多路由到应用程序中：
- en: '`/about`—When users access http:/localhost:3000/about, respond with a line
    of HTML stating `Learn More About Us`.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/about`—当用户访问http:/localhost:3000/about时，响应一行HTML，声明`了解更多关于我们的信息`。'
- en: '`/hello`—When users access http:/localhost:3000/hello, respond with a line
    of HTML stating `Say hello by emailing us here`. Include an anchor tag linked
    to your email around the word `here`.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/hello`—当用户访问http:/localhost:3000/hello时，响应一行HTML，声明`通过在此处给我们发邮件来打招呼`。在“这里”这个词周围包含一个链接到你的电子邮件的锚标签。'
- en: '`/error`—When users access http://localhost:3000/error, respond with a status
    code of `404` (indicating that no page was found) and a line of plain text stating
    `Sorry, the page you are looking for is not here`.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/error`—当用户访问 http://localhost:3000/error 时，以状态码 `404`（表示未找到页面）和一行纯文本“抱歉，您要查找的页面不在这里”响应。'
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Note
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Open multiple web browsers (such as Apple’s Safari, Google Chrome, and Mozilla
    Firefox), and visit different URLs in those browsers. Notice how the request headers
    change. You should see the same host but a different user-agent.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 打开多个网络浏览器（如 Apple 的 Safari、Google Chrome 和 Mozilla Firefox），并在这些浏览器中访问不同的 URL。注意请求头的变化。你应该看到相同的宿主但不同的用户代理。
- en: '|  |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 6\. Writing better routes and serving external files
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 课\. 编写更好的路由和提供外部文件
- en: In [lesson 5](../Text/kindle_split_017.html#ch05), you directed URL traffic
    with a routing system that matched request URLs to custom responses. In this lesson,
    you learn how to serve whole HTML files and assets such as client-side JavaScript,
    CSS, and images. Say goodbye to plain-text responses. At the end of the lesson,
    you improve your route code and place your logic in its own module for cleaner
    organization.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 课](../Text/kindle_split_017.html#ch05)中，你使用一个路由系统将 URL 流量导向，该系统将请求 URL
    与自定义响应匹配。在本课中，你将学习如何提供整个 HTML 文件和客户端 JavaScript、CSS 和图片等资产。告别纯文本响应。在本课结束时，你将改进你的路由代码，并将你的逻辑放在自己的模块中以实现更整洁的组织。
- en: This lesson covers
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Serving entire HTML files by using the `fs` module
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fs` 模块提供整个 HTML 文件
- en: Serving static assets
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态资产
- en: Creating a router module
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个路由模块
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: It’s time to build a basic recipe website. The site should have three static
    pages with some images and styling. You quickly realize that all the applications
    you’ve built so far respond only with individual lines of HTML. How do you respond
    with rich content for each page without cluttering your main application file?
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候构建一个基本的食谱网站了。该网站应该有三个静态页面，包含一些图片和样式。你很快就会意识到你迄今为止构建的所有应用程序都只响应单个 HTML 行。你如何在不使主应用程序文件杂乱的情况下为每个页面提供丰富内容？
- en: Using only the tools that came with your Node.js installation, you can serve
    HTML files from your project directory. You can create three individual pages
    with pure HTML and no longer need to place your HTML in main.js.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 Node.js 安装附带的工具，你可以从你的项目目录中提供 HTML 文件。你可以创建三个单独的页面，使用纯 HTML，而不再需要将你的 HTML
    放在 main.js 中。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)6.1\. Serving static files with the fs module'
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)6.1\. 使用 fs 模块提供静态文件'
- en: With the goal of building a three-page static site, using these HTML snippets
    can get cumbersome and clutter your main.js file. Instead, build an HTML file
    that you’ll use in future responses. This file lives within the same project directory
    as your server. See the project file structure in [figure 6.1](#ch06fig01). In
    this application structure, all content you want to show the user goes in the
    views folder, and all the code determining which content you show goes in the
    main.js file.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 以构建三个页面的静态网站为目标，使用这些 HTML 片段可能会变得繁琐，并使你的 main.js 文件杂乱。相反，创建一个你将在未来响应中使用的 HTML
    文件。此文件位于你的服务器相同的项目目录中。参见[图 6.1](#ch06fig01)。在这个应用结构中，你想要展示给用户的所有内容都放在 views 文件夹中，而确定显示哪些内容的所有代码都放在
    main.js 文件中。
- en: Figure 6.1\. Application structure with views
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 带有视图的应用结构
- en: '![](../Images/06fig01_alt.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig01_alt.jpg)'
- en: 'The reason you’re adding your HTML files to the views folder is twofold: All
    your HTML pages will be organized in one place. This convention is used by the
    web frameworks that you’ll learn about in [unit 2](../Text/kindle_split_020.html#part02).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 HTML 文件添加到 views 文件夹的原因有两个：所有你的 HTML 页面都将组织在一个地方。这个约定将在你将在第 2 单元中学习的 Web
    框架中使用。[图 6.1](#ch06fig01)。
- en: 'Follow these steps:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Create a new project folder called serve_html.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 serve_html 的新项目文件夹。
- en: Within that folder, create a blank main.js file.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中，创建一个空的 main.js 文件。
- en: Create another folder called views within serve_html.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 serve_html 中创建一个名为 views 的文件夹。
- en: Within views, create an index.html file.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 views 中创建一个 index.html 文件。
- en: Add the HTML boilerplate code in the next listing to main.html.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中添加 HTML 样板代码到 main.html。
- en: Listing 6.1\. Boilerplate HTML for the index.html page
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. index.html 页面的样板 HTML
- en: '[PRE14]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Add a basic HTML structure to your views.**'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在你的 views 中添加基本的 HTML 结构。**'
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This book isn’t about teaching HTML or CSS. For this example, I’ve provided
    some basic HTML to use, but for future examples, I won’t provide the HTML so that
    I can get to the important stuff more quickly.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是关于教授HTML或CSS的。对于这个例子，我提供了一些基本的HTML来使用，但对于未来的例子，我不会提供HTML，这样我可以更快地进入重要的内容。
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The client can see this page rendered in a browser only with the help of another
    Node.js core module: `fs`, which interacts with the filesystem on behalf of your
    application. Through the `fs` module, your server can access and read your index.html.
    You’re going to call the `fs.readFile` method within an `http` server in your
    project’s main.js file, as shown in [listing 6.2](#ch06ex02).'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端只能通过另一个Node.js核心模块`fs`的帮助在浏览器中看到这个页面的渲染，该模块代表你的应用程序与文件系统交互。通过`fs`模块，你的服务器可以访问并读取你的index.html文件。你将在项目的主.js文件中的http服务器内部调用`fs.readFile`方法，如[列表6.2](#ch06ex02)所示。
- en: First, require the `fs` module into a constant such as `http`. With the `fs`
    constant, you can specify a particular file in the relative directory (in this
    case, a file called index.html within the views folder). Then create a `routeMap`
    to pair routes with files on your server.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`fs`模块引入到一个常量中，例如`http`。有了`fs`常量，你可以在相对目录中指定一个特定的文件（在这个例子中，是views文件夹中的index.html文件）。然后创建一个`routeMap`来将路由与服务器上的文件配对。
- en: 'Next, locate and read the file contents of the file in your route mapping.
    `fs.readFile` returns any potential errors that may have occurred and the file’s
    contents in two separate parameters: `error` and `data`. Last, use that data value
    as the response body being returned to the client.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到并读取路由映射中的文件内容。`fs.readFile`返回可能发生的任何错误和文件内容，这两个参数分别是`error`和`data`。最后，使用该数据值作为返回给客户端的响应体。
- en: Listing 6.2\. Using the `fs` module in server responses in main.js
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 在main.js中的服务器响应中使用`fs`模块
- en: '[PRE15]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Require the fs module.**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入fs模块。**'
- en: '***2*** **Set up route mapping for HTML files.**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为HTML文件设置路由映射。**'
- en: '***3*** **Read the contents of the mapped file.**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **读取映射文件的內容。**'
- en: '***4*** **Respond with file contents.**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **以文件内容作为响应。**'
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When files on your computer are being read, the files could be corrupt, unreadable,
    or missing. Your code doesn’t necessarily know any of this before it executes,
    so if something goes wrong, you should expect an error as the first parameter
    in the callback function.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的电脑上的文件正在被读取时，文件可能会损坏、无法读取或丢失。在代码执行之前，你的代码并不一定知道这些情况，所以如果出现问题，你应该预期回调函数的第一个参数是一个错误。
- en: '|  |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Run this file by entering this project’s directory on your command line and
    entering `node main.js`. When you access http://localhost:3000, you should see
    your index.html page being rendered. Your simple route guides the response of
    any other URL extension requested to the `Sorry, not found` message.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中进入这个项目的目录并输入`node main.js`来运行这个文件。当你访问http://localhost:3000时，你应该能看到你的index.html页面被渲染。你的简单路由将任何其他请求的URL扩展的响应引导到`抱歉，未找到`信息。
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you don’t see the index.html file being rendered, make sure that all the
    files are in the correct folders. Also, don’t forget to spell-check!
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到index.html文件被渲染，请确保所有文件都在正确的文件夹中。另外，别忘了检查拼写！
- en: '|  |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the following example, you serve only the files specified in the URL of
    the request. If someone visits http://localhost:3000/sample.html, your code grabs
    the request’s URL, `/sample.html`, and appends it to `views` to create one string:
    `views/sample.html`. Routes designed this way can look for files dynamically based
    on the user’s request. Try rewriting your server to look like the code in [listing
    6.3](#ch06ex03). Create a new `getViewUrl` function to take the request’s URL
    and interpolate it into a view’s file path. If someone visits the `/index` path,
    for example, `getViewUrl` returns `views/index.html`. Next, replace the hardcoded
    filename in `fs.readFile` with the results from the call to `getViewUrl`. If the
    file doesn’t exist in the views folder, this command will fail, responding with
    an error message and `httpStatus.NOT_FOUND` code. If there is no error, you pass
    the data from the read file to the client.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您只为请求 URL 中指定的文件提供服务。如果有人访问 http://localhost:3000/sample.html，您的代码会获取请求的
    URL，`/sample.html`，并将其附加到 `views` 以创建一个字符串：`views/sample.html`。以这种方式设计的路由可以根据用户的请求动态查找文件。尝试将您的服务器重写为类似于
    [列表 6.3](#ch06ex03) 中的代码。创建一个新的 `getViewUrl` 函数，用于获取请求的 URL 并将其插入到视图的文件路径中。例如，如果有人访问
    `/index` 路径，则 `getViewUrl` 返回 `views/index.html`。接下来，将 `fs.readFile` 中的硬编码文件名替换为
    `getViewUrl` 调用的结果。如果文件在 views 文件夹中不存在，此命令将失败，返回错误消息和 `httpStatus.NOT_FOUND` 代码。如果没有错误，您将读取文件的数据传递给客户端。
- en: Listing 6.3\. Using `fs` and routing to dynamically read and serve files in
    main.js
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 在 main.js 中使用 `fs` 和路由动态读取和提供文件
- en: '[PRE16]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Create a function to interpolate the URL into the file path.**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个函数将 URL 插入到文件路径中。**'
- en: '***2*** **Get the file-path string.**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **获取文件路径字符串。**'
- en: '***3*** **Interpolate the request URL into your fs file search.**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将请求 URL 插入到 fs 文件搜索中。**'
- en: '***4*** **Handle errors with a 404 response code.**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用 404 响应代码处理错误。**'
- en: '***5*** **Respond with file contents.**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **响应文件内容。**'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: String interpolation in ES6 allows you to insert some text, number, or function
    results by using the `${}` syntax. Through this new syntax, you can more easily
    concatenate strings and other data types.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 中的字符串插值允许您使用 `${}` 语法插入一些文本、数字或函数结果。通过这种新语法，您可以更轻松地连接字符串和其他数据类型。
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you should be able to access http://localhost:3000/index, and your server
    will look for the URL at `views/index`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够访问 http://localhost:3000/index，并且您的服务器将在 `views/index` 中查找 URL。
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: You’ll need to handle any and all errors that may occur as requests come in,
    because there will likely be requests made for files that don’t exist.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要处理所有可能发生的错误，因为可能会请求不存在的文件。
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Add your new HTML files to your views folder, and try to access them by using
    their filenames as the URL. The problem now is that the index.html file isn’t
    the only file you want to serve. Because the response body depends heavily on
    the request, you also need better routing. By the end of this lesson, you’ll implement
    the design pattern laid out in [figure 6.2](#ch06fig02).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的新 HTML 文件添加到您的 views 文件夹中，并尝试使用它们的文件名作为 URL 来访问它们。现在的问题是 index.html 文件不是您想要提供的唯一文件。因为响应体高度依赖于请求，您还需要更好的路由。在本课结束时，您将实现
    [图 6.2](#ch06fig02) 中概述的设计模式。
- en: Figure 6.2\. Server routing logic to render views
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 服务器路由逻辑以渲染视图
- en: '![](../Images/06fig02_alt.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig02_alt.jpg)'
- en: '|  |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.1**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.1**'
- en: '**[Q1:](#ch06qa2q0a1)**'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa2q0a1)**'
- en: ''
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you try to read a file that doesn’t exist on your computer?
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您尝试读取计算机上不存在的文件，会发生什么？
- en: '|  |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.1 answer**'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.1 答案**'
- en: '**[1:](#ch06qa1q1)**'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa1q1)**'
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you try to read a file that doesn’t exist on your computer, the `fs` module
    passes an error in its callback. How you handle that error is up to you. You can
    have it crash your application or simply log it to your console.
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您尝试读取计算机上不存在的文件，`fs` 模块会在其回调中传递一个错误。您如何处理该错误取决于您。它可以崩溃您的应用程序或简单地将其记录到您的控制台。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)6.2\. Serving assets'
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)6.2\. 提供资源'
- en: Your application’s *assets* are the images, stylesheets, and JavaScript that
    work alongside your views on the client side. Like your HTML files, these file
    types, such as .jpg and .css, need their own routes to be served by your application.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序 *资源* 包括与客户端视图一起工作的图像、样式表和 JavaScript。像您的 HTML 文件一样，这些文件类型，如 .jpg 和 .css，需要它们自己的路由才能由您的应用程序提供。
- en: To start this process, create a public folder at your project’s root directory,
    and move all your assets there. Within the public folder, create a folder each
    for images, css, and js, and move each asset into its respective folder. By this
    point, your file structure should look like [figure 6.3](#ch06fig03).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个过程，在你的项目根目录中创建一个公共文件夹，并将所有资产移动到那里。在公共文件夹中，为图片、css和js创建各自的文件夹，并将每个资产移动到相应的文件夹中。到这一点，你的文件结构应该看起来像[图6.3](#ch06fig03)。
- en: Figure 6.3\. Arranging your assets so they’re easier to separate and serve
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 安排你的资产以便更容易分离和提供
- en: '![](../Images/06fig03_alt.png)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig03_alt.png)'
- en: Now that your application structure is organized, refine your routes to better
    match your goal in [listing 6.4](#ch06ex04). This code may appear to be overwhelming,
    but all you’re doing is moving the file-reading logic into its own function and
    adding `if` statements to handle specific file-type requests.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序结构已经组织好，请细化你的路由以更好地匹配[列表6.4](#ch06ex04)中的目标。这段代码可能看起来令人不知所措，但你所做的只是将文件读取逻辑移动到自己的函数中，并添加`if`语句来处理特定文件类型的请求。
- en: Upon receiving a request, save the request’s URL in a variable `url`. With each
    condition, check `url` to see whether it contains a file’s extension or mime type.
    Customize the response’s content type to reflect the file being served. Call your
    own `customReadFile` function at the bottom of main.js to reduce repeated code.
    The last function uses `fs.readFile` to look for a file by the name requested,
    writes a response with that file’s data, and logs any messages to your console.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到请求后，将请求的URL保存到变量`url`中。在每个条件下，检查`url`是否包含文件的扩展名或MIME类型。根据提供的文件自定义响应的内容类型。在main.js的底部调用你自己的`customReadFile`函数以减少重复代码。最后一个函数使用`fs.readFile`根据请求的名称查找文件，使用该文件的数据写入响应，并将任何消息记录到控制台。
- en: Notice that in the first route, you’re checking whether the URL contains .html;
    if it does, you try to read a file with the same name as the URL. You further
    abstract your routes by moving the code to read the file into its own `readFile`
    function. You need to check for specific file types, set the response headers,
    and pass the file path and response object to this method. With only a handful
    of dynamic routes, you’re now prepared to respond to multiple file types.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一个路由中，你正在检查URL是否包含.html；如果是，你将尝试读取与URL同名的文件。通过将读取文件的代码移动到自己的`readFile`函数中，你进一步抽象了你的路由。你需要检查特定的文件类型，设置响应头，并将文件路径和响应对象传递给此方法。仅使用少量动态路由，你现在就可以准备响应多种文件类型。
- en: Listing 6.4\. A web server with specific routes for each file in your project
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 为你的项目中的每个文件设置特定路由的Web服务器
- en: '[PRE17]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Create an error-handling function.**'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个错误处理函数。**'
- en: '***2*** **Store the request’s URL in a variable url.**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将请求的URL存储在变量url中。**'
- en: '***3*** **Check the URL to see whether it contains a file extension.**'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查URL是否包含文件扩展名。**'
- en: '***4*** **Customize the response’s content type.**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **自定义响应的内容类型。**'
- en: '***5*** **Call readFile to read file contents.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **调用readFile来读取文件内容。**'
- en: '***6*** **Look for a file by the name requested.**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **查找名为请求的文件。**'
- en: '***7*** **Check whether the file exists.**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **检查文件是否存在。**'
- en: 'Now your application can properly handle requests for files that don’t exist.
    You can visit http://localhost:3000/test.js.html or even http://localhost:3000/test
    to see the error message! To render the index page with these changes, append
    the file type to the URL: http://localhost:3000/index.html.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序可以正确处理对不存在的文件的请求。你可以访问http://localhost:3000/test.js.html，甚至http://localhost:3000/test来查看错误消息！要使用这些更改渲染索引页面，请将文件类型追加到URL：http://localhost:3000/index.html。
- en: The next section shows you how to further redefine your routing structure and
    give your routes their own module.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将向你展示如何进一步重新定义你的路由结构，并为你的路由提供它们自己的模块。
- en: '|  |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.2**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查6.2**'
- en: '**[Q1:](#ch06qa4q0a1)**'
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa4q0a1)**'
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be your default response if a route isn’t found?
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果找不到路由，你应该提供什么默认响应？
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.2 answer**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.2 答案**'
- en: '**[1:](#ch06qa3q1)**'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa3q1)**'
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If your application can’t find a route for some request, you should send back
    a 404 HTTP status code with a message indicating the page that the client was
    looking for can’t be found.
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的应用程序无法找到某些请求的路由，你应该返回一个带有消息的404 HTTP状态码，表明客户端正在寻找的页面找不到。
- en: '|  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)6.3\. Moving your routes to another file'
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)6.3\. 将你的路由移动到另一个文件'
- en: The goal of this section is to make it easier to manage and edit your routes.
    If all your routes are in an `if-else` block, when you decide to change or remove
    a route, that change might affect the others in the block. Also, as your list
    of routes grows, you’ll find it easier to separate routes based on the HTTP method
    used. If the `/contact` path can respond to `POST` and `GET` requests, for example,
    your code will route to the appropriate function as soon as the request’s method
    is identified.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是使管理和编辑你的路由更加容易。如果你的所有路由都在一个`if-else`块中，当你决定更改或删除一个路由时，这个更改可能会影响块中的其他路由。此外，随着你的路由列表的增长，你会发现根据使用的HTTP方法来分离路由会更加容易。例如，如果`/contact`路径可以响应`POST`和`GET`请求，那么你的代码将在识别请求的方法后立即路由到相应的函数。
- en: As the main.js file grows, your ability to filter through all the code you’ve
    written gets more complicated. You can easily find yourself with hundreds of lines
    of code representing routes alone!
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 随着main.js文件的增长，过滤你编写的所有代码的能力变得更加复杂。你很容易发现自己有成百上千行代码仅代表路由！
- en: To alleviate this problem, move your routes into a new file called router.js.
    Also restructure the way you store and handle your routes. Add the code in [listing
    6.5](#ch06ex05) to router.js. In the source code available at manning.com/books/get-programming-with-node-js,
    this code exists in a new project folder called better_routes.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，将你的路由移动到一个名为router.js的新文件中。同时重新构建存储和处理路由的方式。将[列表6.5](#ch06ex05)中的代码添加到router.js中。在manning.com/books/get-programming-with-node-js提供的源代码中，这段代码存在于一个名为better_routes的新项目文件夹中。
- en: In this file, you define a `routes` object to store routes mapped to `POST`
    and `GET` requests. As routes are created in your main.js, they’ll be added to
    this `routes` object according to their method type (`GET` or `POST`). This object
    doesn’t need to be accessed outside this file.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你定义一个`routes`对象来存储映射到`POST`和`GET`请求的路由。随着在main.js中创建路由，它们将根据其方法类型（`GET`或`POST`）添加到这个`routes`对象中。这个对象不需要在这个文件外部被访问。
- en: Next, create a function called `handle` to process the route’s callback function.
    This function accesses the `routes` object by the request’s HTTP method, using
    `routes[req.method]`, and then finds the corresponding callback function through
    the request’s target URL, using `[req.url]`. If you make a `GET` request for the
    `/index.html` URL path, for example, `routes["GET"]["/index.html"]` gives you
    the callback function predefined in your `routes` object. Last, whatever callback
    function is found in the `routes` object is called and passed the request and
    response so that you can properly respond to the client. If no route is found,
    respond with `httpStatus.NOT_FOUND`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`handle`的函数来处理路由的回调函数。该函数通过请求的HTTP方法访问`routes`对象，使用`routes[req.method]`，然后通过请求的目标URL找到相应的回调函数，使用`[req.url]`。例如，如果你对`/index.html`
    URL路径发出`GET`请求，`routes["GET"]["/index.html"]`将给你在`routes`对象中预定义的回调函数。最后，找到的任何回调函数都会在`routes`对象中被调用，并传递请求和响应，这样你就可以正确地响应用户。如果没有找到路由，则使用`httpStatus.NOT_FOUND`响应。
- en: The `handle` function checks whether an incoming request matches a route in
    the `routes` object by its HTTP method and URL; otherwise, it logs an error. Use
    `try-catch` to attempt to route the incoming request and handle the error where
    the application would otherwise crash.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`函数通过HTTP方法和URL检查传入的请求是否与`routes`对象中的路由匹配；否则，它会记录一个错误。使用`try-catch`尝试路由传入的请求并处理错误，否则应用程序可能会崩溃。'
- en: You also define `get` and `post` functions and add them to `exports` so that
    new routes can be registered from main.js. This way, in main.js you can add new
    callback associations, such as a /contact.html page, in the `routes` object by
    entering `get("contact.html", <callback function>)`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 你还定义了`get`和`post`函数并将它们添加到`exports`中，以便可以从main.js中注册新的路由。这样，在main.js中，你可以通过输入`get("contact.html",
    <回调函数>)`在`routes`对象中添加新的回调关联，例如一个/contact.html页面。
- en: Listing 6.5\. Adding functions to the module’s `exports` object in router.js
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. 在router.js模块的`exports`对象中添加函数
- en: '[PRE18]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Define a routes object to store routes mapped to POST and GET requests.**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义一个routes对象来存储映射到POST和GET请求的路由。**'
- en: '***2*** **Create a function called handle to process route callback functions.**'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个名为handle的函数来处理路由回调函数。**'
- en: '***3*** **Build get and post functions to register routes from main.js.**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在main.js中构建get和post函数以注册路由。**'
- en: '|  |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: More `HTTP` methods could go here, but you don’t need to worry about those methods
    until [unit 4](../Text/kindle_split_031.html#part04).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以添加更多的 `HTTP` 方法，但你不需要担心这些方法，直到 [第 4 单元](../Text/kindle_split_031.html#part04)。
- en: '|  |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When you call `get` or `post`, you need to pass the URL of the route and the
    function you want to execute when that route is reached. These functions register
    your routes by adding them to the `routes` object, where they can be reached and
    used by the handle function.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `get` 或 `post` 时，你需要传递路由的 URL 和当该路由被访问时要执行的功能。这些函数通过将它们添加到 `routes` 对象中来注册你的路由，这样它们就可以通过处理函数被访问和使用。
- en: Notice that in [figure 6.4](#ch06fig04), the `routes` object is used internally
    by the `handle`, `get`, and `post` functions, which are made accessible to other
    project files through the module’s `exports` object.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [图 6.4](#ch06fig04) 中，`routes` 对象由 `handle`、`get` 和 `post` 函数内部使用，这些函数通过模块的
    `exports` 对象对其他项目文件是可访问的。
- en: Figure 6.4\. The `exports` object gives other files access to specific functionality.
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4\. `exports` 对象为其他文件提供了对特定功能访问的权限。
- en: '![](../Images/06fig04_alt.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4](../Images/06fig04_alt.jpg)'
- en: The last step involves importing router.js into main.js. You complete this the
    same way you import other modules, with `require("./router")`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步涉及将 router.js 导入到 main.js 中。你将以导入其他模块相同的方式完成此操作，使用 `require("./router")`。
- en: You need to prepend `router` to every function call you make in main.js, as
    those functions now belong to the router. You can also import the `fs` module
    if you plan to serve assets and static HTML files as before. The code for your
    server should look like the code in [listing 6.6](#ch06ex06).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 main.js 中每个函数调用前加上 `router`，因为现在这些函数属于路由器。你也可以导入 `fs` 模块，如果你计划像以前一样提供资产和静态
    HTML 文件。你的服务器代码应该看起来像 [列表 6.6](#ch06ex06) 中的代码。
- en: With the creation of your server, every request is processed by the `handle`
    function in your `router` module, followed by a callback function. Now you can
    define your routes by using `router.get` or `router.post` to indicate the HTTP
    method you expect from requests to that route. The second argument is the callback
    you want to run when a request is received. Create a custom `readFile` function,
    called `customReadFile`, to make your code more reusable. In this function, you
    try to read the file passed in and respond with the file’s contents.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你的服务器后，每个请求都由你的 `router` 模块中的 `handle` 函数处理，然后是一个回调函数。现在你可以通过使用 `router.get`
    或 `router.post` 来定义你的路由，以指示你期望从该路由的请求中得到的 HTTP 方法。第二个参数是当收到请求时要运行的回调函数。创建一个自定义的
    `readFile` 函数，称为 `customReadFile`，以使你的代码更具可重用性。在这个函数中，你尝试读取传入的文件，并返回文件的内容。
- en: Listing 6.6\. Handling and managing your routes in main.js
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 在 main.js 中处理和管理你的路由
- en: '[PRE19]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Create a custom readFile function to reduce code repetition.**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个自定义的 readFile 函数以减少代码重复。**'
- en: '***2*** **Register routes with get and post.**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用 get 和 post 注册路由。**'
- en: '***3*** **Handle all requests through router.js.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **通过 router.js 处理所有请求。**'
- en: After adding these changes, restart your Node.js application, and try to access
    your home page or /index.html route. This project structure follows some of the
    design patterns used by application frameworks. In [unit 2](../Text/kindle_split_020.html#part02),
    you learn more about frameworks and see why this type of organization makes your
    code more efficient and readable.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加这些更改后，重新启动你的 Node.js 应用程序，并尝试访问你的主页或 /index.html 路由。此项目结构遵循了一些应用程序框架使用的某些设计模式。在
    [第 2 单元](../Text/kindle_split_020.html#part02) 中，你将了解更多关于框架的信息，并了解为什么这种组织方式可以使你的代码更高效和可读。
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 6.3**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.3**'
- en: '**[Q1:](#ch06qa6q0a1)**'
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa6q0a1)**'
- en: ''
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: functions and objects that aren’t added to their module’s `exports`
    object are still accessible by other files.'
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 真或假：没有被添加到其模块 `exports` 对象中的函数和对象仍然可以被其他文件访问。
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 6.3 answer**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.3 答案**'
- en: '**[1:](#ch06qa5q1)**'
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa5q1)**'
- en: ''
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. The `exports` object is intended to allow modules to share functions
    and objects. If an object isn’t added to a module’s `exports` object, it remains
    local to that module, as defined by CommonJS.
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。`exports` 对象的目的是允许模块共享函数和对象。如果一个对象没有被添加到模块的 `exports` 对象中，它将保持在该模块中本地，如 CommonJS
    所定义。
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节总结](../Images/sectionFig.png)总结'
- en: In this lesson, you learned how to serve individual files. First, you added
    the `fs` module to your application to look for HTML files in your `views` folder.
    Then you extended that functionality to application assets. You also learned how
    to apply your routing system to its own module and selectively register routes
    from your main application file. In [unit 2](../Text/kindle_split_020.html#part02),
    I talk about how you can use the application structure provided by Express.js,
    a Node.js web framework.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何服务单个文件。首先，你将`fs`模块添加到你的应用程序中，以便在`views`文件夹中查找HTML文件。然后你扩展了这一功能以应用于应用程序资源。你还学习了如何将你的路由系统应用于其自身的模块，并从主应用程序文件中选择性注册路由。在[第2单元](../Text/kindle_split_020.html#part02)中，我谈到了你可以如何使用Express.js提供的应用程序结构，这是一个Node.js网络框架。
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: You currently have one route set up to read an HTML file from this lesson’s
    examples. Try adding new routes in the style introduced in this lesson to load
    assets.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前设置了一个路由来从本节课的示例中读取HTML文件。尝试添加新的路由，以本节课介绍的风格加载资源。
- en: '|  |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lesson 7\. Capstone: Creating your first web application'
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7课. 终极项目：创建你的第一个网络应用程序
- en: When I first got into web development, I really wanted to build a website where
    people could go to view interesting recipes. Luckily for me, a local cooking school,
    Confetti Cuisine, wants me to build them a site with a landing page to reflect
    their course offerings, a page of recipes, and a place where prospective students
    can sign up.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次涉足网页开发时，我非常想建立一个人们可以前往查看有趣食谱的网站。幸运的是，一家当地的烹饪学校Confetti Cuisine希望我为他们建立一个网站，包括一个展示课程提供的着陆页、一个食谱页面，以及一个潜在学生可以注册的地方。
- en: As a cooking enthusiast, I thought this project would be a good one that I could
    use daily. What’s more, this site is going to be fun to build in Node.js. Piecing
    together all the preceding lessons into a complete multipage application, these
    steps should sufficiently prepare me to build a static site for Confetti Cuisine.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位烹饪爱好者，我认为这个项目是一个很好的日常使用项目。更重要的是，这个网站将很有趣，可以用Node.js来构建。将所有前面的课程整合成一个完整的多页面应用程序，这些步骤应该足以让我为Confetti
    Cuisine构建一个静态网站。
- en: I’ll start a new application from scratch and add three views, routes for the
    views and assets, and a public client folder. To start, I’ll build out the application
    logic with the goal of clean, nonrepetitive code. Then I’ll add some of the public-facing
    views and custom styling. At the end of this lesson, I’ll have a web server to
    handle requests to specific files and assets in the project. The final product
    is one that I can gradually build on and connect to a database at my client’s
    request.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从零开始创建一个新的应用程序，并添加三个视图、视图和资源的路由以及一个公共客户端文件夹。首先，我将构建应用程序逻辑，目标是编写干净、非重复的代码。然后我将添加一些面向公众的视图和自定义样式。在本节课结束时，我将有一个网络服务器来处理对项目中特定文件和资源的请求。最终产品是一个我可以逐步构建并在我客户的要求下连接到数据库的产品。
- en: 'To create this application, I use the following steps:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此应用程序，我将使用以下步骤：
- en: Initialize the application package.json.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化应用程序的package.json。
- en: Set up the project directory structure.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目目录结构。
- en: Create application logic in main.js.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在main.js中创建应用程序逻辑。
- en: 'Create three views, each of which should have a clickable image that can be
    served independently:'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建三个视图，每个视图都应该有一个可点击的图片，可以独立提供：
- en: Index (home)
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引（主页）
- en: Courses
  id: totrans-626
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 课程
- en: Contact
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系
- en: Thanks
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感谢
- en: Error
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Add custom assets.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义资源。
- en: Build the application’s router.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序的路由器。
- en: Handle application errors.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理应用程序错误。
- en: Run the application.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: I’m ready to get cracking.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备好大干一场了。
- en: '![](../Images/sectionFig.png)7.1\. Initializing the application'
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![7.1. 初始化应用程序](../Images/sectionFig.png)'
- en: 'To start, I use npm to create a package.json file with a summary of the application
    I’m developing. I navigate to a directory on my computer where I’d like to save
    this project and then create a new project folder, using the following commands
    in terminal: `mkdir confetti_cuisine && cd confetti_cuisine` and `npm init`.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我使用npm创建一个包含我正在开发的应用程序概要的package.json文件。我导航到电脑上我想保存此项目的目录，然后创建一个新的项目文件夹，使用以下终端命令：`mkdir
    confetti_cuisine && cd confetti_cuisine`和`npm init`。
- en: 'I follow the command-line instructions and accept all default values except
    the following:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我遵循命令行说明，除了以下内容外，我接受所有默认值：
- en: Use main.js as the entry point.
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用main.js作为入口点。
- en: Change the description to “A site for booking classes for cooking.”
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将描述更改为“一个预订烹饪课程的网站。”
- en: Add my name as the author.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我的名字作为作者。
- en: Next, I install the `http-status-codes` package by running `npm install http-status-codes
    --save` in the project’s terminal window. Within my confetti_cuisine folder, my
    package .json file should resemble the example in the next listing.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我在项目中运行 `npm install http-status-codes --save` 来安装 `http-status-codes` 包。在我的
    confetti_cuisine 文件夹中，我的 package.json 文件应该类似于下一列表中的示例。
- en: Listing 7.1\. Project package.json file contents
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 项目 package.json 文件内容
- en: '[PRE20]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Display my package.json in terminal.**'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在终端中显示我的 package.json**'
- en: From this point forward, I’ll be able to refer to this file as a summary of
    my application’s configurations.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我能够将此文件作为我应用程序配置的总结来引用。
- en: '![](../Images/sectionFig.png)7.2\. Understanding application directory structure'
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)7.2\. 理解应用程序目录结构'
- en: Before I continue with more code, I want to review the application’s directory
    structure. In the project structure, I want my main.js, package.json, and router.js
    files to live at the root level of my directory. Any HTML content will be represented
    as individual .html files, which will live in a views folder within my project
    folder. My complete application project directory will look like the structure
    in the following listing.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续编写更多代码之前，我想回顾一下应用程序的目录结构。在项目结构中，我希望我的 main.js、package.json 和 router.js 文件位于目录的根级别。任何
    HTML 内容都将表示为单独的 .html 文件，这些文件将位于项目文件夹中的 views 文件夹内。我的完整应用程序项目目录将类似于以下列表中的结构。
- en: Listing 7.2\. Project directory structure for confetti_cuisine
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. confetti_cuisine 的项目目录结构
- en: '[PRE21]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Display of directory tree from root folder**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从根目录显示目录树**'
- en: My application server will respond with HTML files in my views folder. The assets
    on which those files rely will live in a folder called public.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我的应用程序服务器将以我的 views 文件夹中的 HTML 文件响应。那些文件所依赖的资产将位于一个名为 public 的文件夹中。
- en: '|  |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: HTML files will be viewed by the client, but they’re not considered to be assets
    and don’t go in the public folder.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文件将由客户端查看，但它们不被视为资产，也不放入公共文件夹中。
- en: '|  |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The public folder contains an images, js, and css folder to hold the application’s
    client-facing assets. These files define the styles and JavaScript interactions
    between my application and its user. To add some quick styling to my application,
    I download bootstrap .css from [http://getbootstrap.com/docs/4.0/getting-started/download/](http://getbootstrap.com/docs/4.0/getting-started/download/)
    and add it to my css folder in public. I also create a confetti_cuisine.css file
    for any custom styling rules that I want to apply to this project.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 公共文件夹包含一个 images、js 和 css 文件夹，用于存放应用程序面向客户端的资产。这些文件定义了应用程序与其用户之间的样式和 JavaScript
    交互。为了给我的应用程序添加一些快速样式，我从 [http://getbootstrap.com/docs/4.0/getting-started/download/](http://getbootstrap.com/docs/4.0/getting-started/download/)
    下载了 bootstrap.css 并将其添加到公共文件夹中的 css 文件夹。我还创建了一个 confetti_cuisine.css 文件，用于应用任何我想为该项目添加的自定义样式规则。
- en: Next, I set up the application logic.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我在项目的终端窗口中运行 `npm install http-status-codes --save` 来安装 `http-status-codes`
    包。在我的 confetti_cuisine 文件夹中，我的 package.json 文件应该类似于下一列表中的示例。
- en: '![](../Images/sectionFig.png)7.3\. Creating main.js and router.js'
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)7.3\. 创建 main.js 和 router.js'
- en: Now that I’ve set up my folder structure and initialized the project, I need
    to add the main application logic to the site to get it serving files on port
    3000\. I’m going to keep the routes in a separate file, so I’ll need to require
    that file along with the `fs` module so that I can serve static files.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经设置了文件夹结构并初始化了项目，我需要向网站添加主应用程序逻辑，以便它在端口 3000 上提供服务。我将把路由保存在一个单独的文件中，所以我需要引入该文件以及
    `fs` 模块，以便我可以提供静态文件。
- en: I create a new file called main.js. Within that file, I assign my application’s
    port number, require the `http` and `http-status-codes` modules and the soon-to-be-built
    custom modules `router`, `contentTypes`, and `utils`, as shown in [listing 7.3](#ch07ex03).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为 main.js 的新文件。在该文件中，我分配了应用程序的端口号，并引入了 `http`、`http-status-codes` 模块以及即将构建的自定义模块
    `router`、`contentTypes` 和 `utils`，如 [列表 7.3](#ch07ex03) 所示。
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `contentTypes` and `utils` modules simply help me organize my variables
    within main.js.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`contentTypes` 和 `utils` 模块只是帮助我在 main.js 中组织变量。'
- en: '|  |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 7.3\. Contents of main.js with required modules
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. main.js 的内容以及所需的模块
- en: '[PRE22]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Import required modules.**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导入所需的模块。**'
- en: The application won’t start until I create my local modules, so I’ll start by
    creating contentTypes.js, using the code in the following listing. In this file,
    I’m exporting an object that maps file types to their header values for use in
    my responses. Later, I’ll access the HTML content type in main.js by using contentTypes.html.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建本地模块之前，应用程序不会启动，所以我将首先创建 contentTypes.js，使用以下列表中的代码。在这个文件中，我导出一个对象，该对象将文件类型映射到它们的头值，用于我的响应。稍后，我将通过在
    main.js 中使用 contentTypes.html 来访问 HTML 内容类型。
- en: Listing 7.4\. Object mapping in contentTypes.js
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. contentTypes.js 中的对象映射
- en: '[PRE23]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Export content type mapping object.**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导出内容类型映射对象。**'
- en: Next, I set up the function that I’ll use to read file contents in a new `utils`
    module. Within utils.js, I add the code in the next listing. In this module, I
    export an object containing a `getFile` function. This function looks for a file
    at the provided path. If a file doesn’t exist, I immediately return an error page.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我设置了一个新模块 `utils` 中的函数，该函数将用于读取文件内容。在 utils.js 中，我添加了下一个列表中的代码。在这个模块中，我导出一个包含
    `getFile` 函数的对象。这个函数在提供的路径中查找文件。如果文件不存在，我立即返回一个错误页面。
- en: Listing 7.5\. Utility functions in utils.js
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. utils.js 中的实用函数
- en: '[PRE24]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Import modules for use in getFile.**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导入在 getFile 中使用的模块。**'
- en: '***2*** **Export a function to read files and return a response.**'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **导出一个读取文件并返回响应的函数。**'
- en: 'Last, in a new file, I add the code in [listing 7.6](#ch07ex06). This router.js
    file requires the `http-status-codes` and my two custom modules: `contentTypes`
    and `utils`.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在新的文件中，我添加了 [列表 7.6](#ch07ex06) 中的代码。这个 router.js 文件需要 `http-status-codes`
    和我的两个自定义模块：`contentTypes` 和 `utils`。
- en: The `router` module includes a `routes` object that holds key-value pairs mapped
    to `GET` requests through my `get` function and `POST` requests through my `post`
    function. The `handle` function is the one referred to as the callback function
    to `createServer` in main.js. The `get` and `post` functions take a URL and callback
    function and then map them to each other in the `routes` object. If no route is
    found, I use my custom `getFile` function in the `utils` module to respond with
    an error page.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`router` 模块包含一个 `routes` 对象，该对象通过我的 `get` 函数映射到 `GET` 请求，通过我的 `post` 函数映射到
    `POST` 请求。`handle` 函数是 main.js 中 `createServer` 调用的回调函数。`get` 和 `post` 函数接受一个
    URL 和回调函数，然后在 `routes` 对象中将它们映射到对方。如果没有找到路由，我使用 `utils` 模块中的自定义 `getFile` 函数来响应错误页面。'
- en: Listing 7.6\. Handling routes in router.js
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 在 router.js 中处理路由
- en: '[PRE25]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Create a routes object to hold route functions.**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个包含路由函数的路由对象。**'
- en: '***2*** **Create the handle function to handle requests.**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建处理请求的 handle 函数。**'
- en: '***3*** **Create the get and post functions to map route functions.**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建获取和设置函数以映射路由函数。**'
- en: To get my application server to run, I need to set up the application’s routes
    and views.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我的应用程序服务器运行，我需要设置应用程序的路由和视图。
- en: '![](../Images/sectionFig.png)7.4\. Creating views'
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)7.4\. 创建视图'
- en: The views are client-facing and could make or break my user’s experience with
    the application. I’ll use a similar template for each page to reduce complexity
    in this application. The top of each HTML page should have some HTML layout, a
    head, a link to my soon-to-be-built custom stylesheet, and navigation. The home
    page for the Confetti Cuisine site will look like [figure 7.1](#ch07fig01), with
    links to my three views in the top-left corner.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是面向客户端的，可能会影响用户对应用程序的体验。我将为每个页面使用类似的模板，以减少应用程序的复杂性。每个 HTML 页面的顶部应该有一些 HTML
    布局、一个 head、一个链接到即将构建的自定义样式表，以及导航。Confetti Cuisine 网站的首页将类似于 [图 7.1](#ch07fig01)，在页面的右上角有链接到我的三个视图。
- en: Figure 7.1\. Example home page for Confetti Cuisine
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. Confetti Cuisine 的示例主页
- en: '![](../Images/07fig01_alt.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig01_alt.jpg)'
- en: For the home page, I’ll create a new view called index.html in my views folder
    and add the content specific to the index page. Because I’m using bootstrap.css,
    I need to link to that file from my HTML pages by adding `<link rel="stylesheet"
    href="/bootstrap.css">` to my HTML `head` tag. I’ll do the same for my custom
    stylesheet, `confetti_cuisine.css`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主页，我将在 views 文件夹中创建一个新的视图 index.html，并添加特定于索引页面的内容。因为我使用 bootstrap.css，所以我需要在
    HTML 页面的 head 标签中添加 `<link rel="stylesheet" href="/bootstrap.css">` 来链接到该文件。我将对自定义样式表
    `confetti_cuisine.css` 做同样的事情。
- en: Next, I create a courses.html file to show off a list of available cooking classes
    and a contact.html file with the following form. This form submits contact information
    via `POST` to the `/` route. The form’s code should resemble the code in the next
    listing.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建了一个courses.html文件来展示可用的烹饪课程列表，以及一个包含以下表单的contact.html文件。此表单通过`POST`将联系信息提交到`/`路由。表单的代码应类似于下一列表中的代码。
- en: Listing 7.7\. Example form that posts to the home-page route in contact.html
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7. contact.html中提交到主页路由的示例表单
- en: '[PRE26]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Build a form to submit a name to the the home page.**'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建一个表单，用于将姓名提交到主页。**'
- en: My site’s contact page will look like [figure 7.2](#ch07fig02).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我的网站联系页面将类似于[图7.2](#ch07fig02)。
- en: Figure 7.2\. Example contact page for Confetti Cuisine
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2. Confetti Cuisine的示例联系页面
- en: '![](../Images/07fig02_alt.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig02_alt.jpg)'
- en: Each page links to the others through a navigation bar. I need to make sure
    that all the assets I’m using in these files are accounted for when I create my
    routes. If any assets are missing, my application could crash when it tries to
    look for their corresponding files.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面都通过导航栏链接到其他页面。我需要确保在创建我的路由时，这些文件中使用的所有资源都已计入。如果缺少任何资源，当应用程序尝试查找其对应的文件时，可能会崩溃。
- en: I’ll add these assets so that my pages will have resources for richer content.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加这些资源，以便我的页面具有更丰富的内容。
- en: '![](../Images/sectionFig.png)7.5\. Adding assets'
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)7.5. 添加资源'
- en: For this application, I’ve created some custom styles to be used by each of
    the views. Any color, dimension, or placement changes I want to make in elements
    of my site will go in confetti_cuisine.css, which lives in public/css alongside
    bootstrap.css.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我创建了一些自定义样式，供每个视图使用。我想要在网站元素中进行的任何颜色、尺寸或位置更改都将放入public/css中的confetti_cuisine.css，它与bootstrap.css位于同一目录下。
- en: When this file is saved, my views will have colors and structure when loaded.
    If I decide to use any client-side JavaScript, I’ll need to create a .js file,
    add it to my public/js folder, and link to it within each file by using `<script>`
    tags. Last, I’ll add my images to `public/ images`. The names of these images
    should match the names I use within my HTML views.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个文件保存时，我的视图在加载时将具有颜色和结构。如果我想使用任何客户端JavaScript，我需要创建一个.js文件，将其添加到我的public/js文件夹中，并在每个文件中使用`<script>`标签链接到它。最后，我将我的图片添加到`public/images`。这些图片的名称应该与我在我HTML视图中使用的名称相匹配。
- en: The only step left is registering and handling my routes for each view and asset
    in my project.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一步骤是为我的项目中每个视图和资源注册路由和处理。
- en: '![](../Images/sectionFig.png)7.6\. Creating routes'
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)7.6. 创建路由'
- en: 'The last piece of the puzzle is an important one: routes. The routes of my
    application will determine which URLs are accessible to the client and which files
    I’ll serve.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的拼图碎片是路由。我的应用程序的路由将决定哪些URL可供客户端访问以及我将提供哪些文件。
- en: I’ve specifically created a router.js file to handle my routes, but I still
    need to register them. Registering my routes essentially means passing a URL and
    callback function to my `router.get` or `router.post` function, depending on which
    HTTP method I’m handling. Those functions add my routes to `router.routes`, a
    JavaScript object that maps my URLs to the callback functions to be invoked when
    that URL is accessed.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别创建了一个router.js文件来处理我的路由，但我仍然需要注册它们。注册我的路由基本上意味着将一个URL和回调函数传递给我的`router.get`或`router.post`函数，具体取决于我正在处理哪种HTTP方法。这些函数将我的路由添加到`router.routes`，这是一个JavaScript对象，它将我的URL映射到当访问该URL时要调用的回调函数。
- en: 'To recap, to register a route, I need to state the following:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，要注册一个路由，我需要声明以下内容：
- en: Whether the request is a `GET` or a `POST` request
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求是`GET`还是`POST`请求
- en: The URL’s path
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL的路径
- en: The name of the file to return
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要返回的文件名
- en: An HTTP status code
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: The type of the file being returned (as the content type)
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回文件的类型（作为内容类型）
- en: In each callback function, I need to indicate the content type that will go
    in the response and use the `fs` module to read the contents of my views and assets
    into the response. I add the routes and code in the next listing below the require
    lines in main.js.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个回调函数中，我需要指出将放入响应中的内容类型，并使用`fs`模块将我的视图和资源的内容读取到响应中。我在main.js中的require行下方添加路由和代码。
- en: Listing 7.8\. Registering individual routes with the `router` module in main.js
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8. 在main.js中使用`router`模块注册单个路由
- en: '[PRE27]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Add a series of routes for web pages and assets.**'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **为网页和资源添加一系列路由。**'
- en: '***2*** **Start the server.**'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **启动服务器。**'
- en: '|  |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the `POST` route, which will handle form submissions on the contact.html
    page. Instead of responding with another HTML page, this route responds with an
    HTML “thank you for supporting the product” page.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`POST`路由，它将处理contact.html页面上的表单提交。而不是响应另一个HTML页面，这个路由响应一个HTML“感谢您支持产品”页面。
- en: '|  |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'I should now be able to start my application with `node main` and navigate
    to http://localhost: 3000 to see my web application’s home page.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我应该能够使用`node main`启动我的应用程序，并通过访问http://localhost: 3000来查看我的网络应用程序的主页。'
- en: '|  |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I only create routes for the assets (images, js, and css) that I have represented
    as files within my project.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 我只为我在项目中表示为文件的资源（图像、js和css）创建路由。
- en: '|  |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this capstone exercise, I built a complete web application serving static
    web pages for Confetti Cuisine. To accomplish this task, I required my own router
    module into the main application file. Then I created a custom system for routing
    user requests to serve specific content. After building custom functions to register
    routes in an organized and systematic way, I created views and assets to be served
    from their respective directories.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，我构建了一个完整的网络应用程序，为Confetti Cuisine提供静态网页。为了完成这个任务，我需要在主应用程序文件中添加自己的路由模块。然后我创建了一个自定义系统来路由用户请求以提供特定内容。在构建用于以有组织、系统的方式注册路由的自定义函数后，我创建了从各自的目录中提供视图和资源的文件。
- en: A lot of code logic is going on here, and the code logic is on its way to a
    professional structure used by Node.js applications around the world.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里正在进行大量的代码逻辑处理，这些代码逻辑正朝着全球Node.js应用程序所使用的专业结构发展。
- en: In [unit 3](../Text/kindle_split_026.html#part03), I explore web frameworks
    and show you how they use this application structure and some scaffolding (prebuilt
    folders and structure) to accomplish the same application in fewer steps and with
    fewer headaches.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3单元](../Text/kindle_split_026.html#part03)中，我探讨了网络框架，并展示了它们如何使用这种应用程序结构和一些脚手架（预构建的文件夹和结构）以更少的步骤和更少的麻烦完成相同的应用程序。
