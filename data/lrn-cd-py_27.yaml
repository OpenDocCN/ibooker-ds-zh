- en: Lesson 22\. Advanced operations with functions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第22课。函数的高级操作
- en: After reading [lesson 22](#ch22), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读第22课（[lesson 22](#ch22)）之后，你将能够
- en: Pass functions (as an object) as a parameter to another function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数（作为一个对象）作为参数传递给另一个函数
- en: Return a function (as an object) from another function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个函数返回一个函数（作为一个对象）
- en: Understand which variables belong to which scope based on certain rules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些规则理解哪些变量属于哪个作用域
- en: 'Before formally learning about functions in [lesson 21](kindle_split_035.html#ch21),
    you saw and used functions in simple code. Here are some of the functions you’ve
    been using already:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式学习第21课（[lesson 21](kindle_split_035.html#ch21)）中的函数之前，你已经看到了并使用了简单的代码中的函数。以下是你已经使用过的一些函数：
- en: '`len()`—For example, `len("coffee")`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len()`—例如，`len("coffee")`'
- en: '`range()`—For example, `range(4)`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range()`—例如，`range(4)`'
- en: '`print()`—For example, `print("Witty message")`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()`—例如，`print("机智的信息")`'
- en: '`abs(),sum(),max(),min(),round(),pow()`—For example, `max(3,7,1)`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs(),sum(),max(),min(),round(),pow()`—例如，`max(3,7,1)`'
- en: '`str(),int(),float(),bool()`—For example, `int(4.5)`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str(),int(),float(),bool()`—例如，`int(4.5)`'
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: For each of the following function calls, how many parameters does the function
    take in, and what’s the value of type returned?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个函数调用，该函数接收多少个参数，返回值的类型是什么？
- en: '`len("How are you doing today?")`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len("How are you doing today?")`'
- en: '`max(len("please"), len("pass"), len("the"), len("salt"))`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max(len("please"), len("pass"), len("the"), len("salt"))`'
- en: '`str(525600)`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str(525600)`'
- en: '`sum((24, 7, 365))`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum((24, 7, 365))`'
- en: 'Answer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: Takes in one parameter, returns `24`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个参数，返回 `24`
- en: Takes in four parameters, returns `6`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收四个参数，返回 `6`
- en: Takes in one parameter, returns `"525600"`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个参数，返回 `"525600"`
- en: Takes in one parameter, returns `396`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个参数，返回 `396`
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 22.1\. Thinking about functions with two hats
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.1\. 考虑具有两个帽子的函数
- en: 'Recall that a function definition defines a series of commands that can be
    called later in a program with different inputs. Think of this idea like building
    a car and driving a car: someone has to build a car in the first place, but after
    they build it, the car sits in a garage until someone wants to use it. And someone
    who wants to use the car doesn’t need to know how to build one, and that person
    can use it more than once. It may help to think about functions from two perspectives:
    someone writing a function, and someone who wants to use a function. [Sections
    22.1.1](#ch22lev2sec1) and [22.1.2](#ch22lev2sec2) briefly review the main ideas
    you should have picked up in the previous lesson.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，函数定义定义了一系列可以在程序中用不同输入稍后调用的命令。将这个想法比作造车和开车：首先必须有人造车，但造好之后，车就停在车库中，直到有人想使用它。而想使用车的人不需要知道如何造车，这个人可以多次使用它。从两个角度思考函数可能会有所帮助：一个是编写函数的人，另一个是想要使用函数的人。[第22.1.1节](#ch22lev2sec1)和[22.1.2节](#ch22lev2sec2)简要回顾了你在前一课应该掌握的主要思想。
- en: 22.1.1\. Writer hat
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.1\. 作者帽子
- en: You write the function in a general way so that it can work with various values.
    You generalize the function by pretending that the inputs given are named variables.
    The inputs are called *formal parameters*. You do the operations inside the function,
    assuming you have values for these parameters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你以通用方式编写函数，使其能够与各种值一起工作。通过假设给定的输入是命名变量来泛化函数。输入被称为*形式参数*。你在函数内部执行操作，假设你为这些参数有值。
- en: Parameters and variables defined inside a function exist only in the scope (or
    environment) of the function. The function scope exists from the time that the
    function is called to the time that the function returns a value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部定义的参数和变量仅存在于函数的作用域（或环境）中。函数作用域从函数被调用到函数返回值的时间存在。
- en: The way you abstract a module is by a function specification, or *docstring*.
    A docstring is a multiline comment starting with triple quotes and ending with
    triple quotes, `"""`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过函数规范或*文档字符串*来抽象模块。文档字符串是一个以三引号开始的跨多行的注释，并以三引号结束，`"""`。
- en: Inside the docstring, you typically write (1) what inputs the function is supposed
    to take in and their type, (2) what the function is supposed to do, and (3) what
    the function returns. Assuming the inputs are according to the specification,
    the function is assumed to behave correctly and guaranteed to return a value according
    to the specification.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串中，你通常写（1）函数应该接收哪些输入及其类型，（2）函数应该做什么，以及（3）函数返回什么。假设输入符合规范，函数假定会按规范正确行为并保证返回一个值。
- en: 22.1.2\. User hat
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.2\. 用户帽子
- en: Using a function is easy. A function is called in another statement in your
    main program code. When you call a function, you call it with values. These values
    are the *actual parameters* and replace the function’s formal parameters. The
    function performs the operations it’s supposed to by using the actual parameter
    values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数很简单。在主程序代码中的另一个语句中调用函数。当你调用函数时，你用值来调用它。这些值是*实际参数*，并替换函数的形式参数。函数通过使用实际参数值执行其应有的操作。
- en: The output from the function is what the function returns. The function return
    is given back to whichever statement called the function. The expression for the
    function call is replaced with the value of the return.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出就是函数返回的内容。函数的返回值会被返回给调用函数的语句。函数调用的表达式会被替换为返回值。
- en: 22.2\. Function scope
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2\. 函数作用域
- en: The phrase “what happens in Vegas stays in Vegas” is an accurate representation
    of what happens behind the scenes during a function call; what happens in a function
    code block stays in a function code block. Function parameters exist only within
    the scope of the function. You can have the same name in different function scopes
    because they point to different objects. You get an error if you try to access
    a variable outside the function in which it’s defined. Python can be in only one
    scope at a time and knows only about variables whose scope it’s currently in.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “什么发生在拉斯维加斯就留在拉斯维加斯”这句话准确地描述了函数调用背后的场景；函数代码块中发生的事情就留在函数代码块中。函数参数只存在于函数的作用域内。你可以在不同的函数作用域中使用相同的名字，因为它们指向不同的对象。如果你尝试在定义它的函数外部访问变量，你会得到一个错误。Python一次只能在一个作用域内，并且只知道当前作用域内的变量。
- en: 22.2.1\. Simple scoping example
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.2.1\. 简单的作用域示例
- en: It’s possible for a function to create a variable with the same name as another
    variable in another function, or even in the main program. Python knows that these
    are separate objects; they just happen to have the same name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以创建一个与另一个函数或主程序中另一个变量同名的新变量。Python知道这些是不同的对象；它们只是碰巧有相同的名字。
- en: 'Suppose you’re reading two books, and each has a character named *Peter*. In
    each book, Peter is a different person, even though you’re using the same name.
    Take a look at [listing 22.1](#ch22ex01). The code prints two numbers. The first
    number is 5, and the second is 30\. In this code, you see two variables named
    `peter` defined. But these variables exist in different scopes: one in the scope
    of the function `fairy_tale`, and one in the main program scope.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在阅读两本书，每本书都有一个名为*彼得*的角色。在每本书中，彼得是不同的人，即使你使用了相同的名字。看看[列表22.1](#ch22ex01)。这段代码打印了两个数字。第一个数字是5，第二个是30。在这段代码中，你看到了两个名为`peter`的变量被定义。但这两个变量存在于不同的作用域中：一个在`fairy_tale`函数的作用域内，另一个在主程序作用域内。
- en: Listing 22.1\. Defining variables with the same name in different scopes
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表22.1\. 在不同作用域中定义同名变量
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Function definition**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数定义**'
- en: '***2* Variable inside function named peter with a value of 5**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数中名为peter的变量，其值为5**'
- en: '***3* Prints 5**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印5**'
- en: '***4* First line to execute inside main program, creates a variable named peter
    with a value of 30**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在主程序中首先执行的行，创建了一个名为peter的变量，其值为30**'
- en: '***5* Function call that creates a new scope, prints 5, then the call returns
    None and the scope ends**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建新作用域的函数调用，打印5，然后调用返回None，作用域结束**'
- en: '***6* Prints 30**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 打印30**'
- en: 22.2.2\. Scoping rules
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.2.2\. 作用域规则
- en: 'Here are the rules for deciding which variable to use (if you have more than
    one with the same name in your program):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是决定使用哪个变量的规则（如果你在程序中有多个同名变量）：
- en: Look in the current scope for a variable with that name. If it’s there, use
    that variable. If it’s not, look in the scope of whatever line called the function.
    It’s possible that another function called it.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前作用域中查找具有该名称的变量。如果存在，则使用该变量。如果不存在，则在调用函数的任何作用域中查找。可能另一个函数调用了它。
- en: If there’s a variable with that name in the caller’s scope, use that.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果调用者的作用域中存在同名变量，则使用该变量。
- en: Successively keep looking in outer scopes until you get to the main program
    scope, also called the *global scope*. You can’t look further outside of the global
    scope. All variables that exist in the global scope are called *global variables*.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依次在外部作用域中查找，直到到达主程序作用域，也称为*全局作用域*。你无法在全局作用域之外查找。在全局作用域中存在的所有变量都称为*全局变量*。
- en: If a variable with that name isn’t in the global scope, show an error that the
    variable doesn’t exist.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该名称的变量不在全局作用域中，将显示一个错误信息，指出变量不存在。
- en: 'The code in the next four listings show a few scenarios for variables with
    the same name in different scopes. There are a couple of interesting things to
    note:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的四个列表代码展示了不同作用域中具有相同名称的变量的几个场景。有几个有趣的事情需要注意：
- en: You can *access* a variable inside a function without defining it inside a function.
    As long as a variable with that name exists in the main program scope, you won’t
    get an error.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在函数内部访问一个没有在函数内部定义的变量。只要主程序作用域中存在该名称的变量，就不会出现错误。
- en: You can’t *assign* a value to a variable inside a function without defining
    it inside the function first.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在函数内部对一个没有首先在函数内部定义的变量进行赋值。
- en: In the following listing, function `e()` shows that you can create and access
    a new variable with the same name as a variable in your global scope.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，函数 `e()` 展示了你可以创建并访问一个与全局作用域中的变量同名的新变量。
- en: Listing 22.2\. A function that initializes a variable
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.2\. 初始化变量的函数
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Uses v from function**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用函数中的 v 变量**'
- en: '***2* Function call OK; uses v inside the function**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数调用正确；在函数内部使用 v 变量**'
- en: In the next listing, function `f()` shows that it’s OK to access a variable
    even if it’s not created inside the function, because a variable of that same
    name exists in the global scope.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，函数 `f()` 展示了访问一个即使不是在函数内部创建的变量也是可以的，因为全局作用域中存在同名变量。
- en: Listing 22.3\. A function that accesses a variable outside its scope
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.3\. 访问其作用域外变量的函数
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Access variables outside scope**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 访问作用域外的变量**'
- en: '***2* Function call OK; uses v from the program**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数调用正确；使用程序中的 v 变量**'
- en: In the following listing, function `g()` shows that it’s OK to do operations
    with variables not defined in the function, because you’re only accessing their
    values and not trying to change them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，函数 `g()` 展示了使用未在函数中定义的变量进行操作是可以的，因为你只是访问它们的值，而不是试图改变它们。
- en: Listing 22.4\. A function that accesses more than one variable outside its scope
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.4\. 访问其作用域外多个变量的函数
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Access only variables**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅访问变量**'
- en: '***2* Function call OK; uses v and x from the global scope**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数调用正确；使用全局作用域中的 v 和 x 变量**'
- en: In the following listing, function `h()` shows that you’re trying to add to
    the value to a variable inside the function without defining it first. This leads
    to an error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，函数 `h()` 展示了尝试在函数内部对一个未先定义的变量进行加值操作会导致错误。
- en: Listing 22.5\. A function that tries to modify a variable defined outside its
    scope
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.5\. 尝试修改其作用域外定义的变量的函数
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Performs an operation on variable v before defining it inside the function**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在定义函数内部的变量之前对变量 v 进行操作**'
- en: '***2* Function call gives an error**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数调用产生错误**'
- en: Functions are great because they break your problem into smaller chunks rather
    than having hundreds or thousands of lines to look at all at once. But functions
    also introduce scope; with this, you can have variables with the same name in
    different scopes without them interfering with each other. You need to be mindful
    of the scope you’re currently looking at.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数很棒，因为它们将问题分解成更小的部分，而不是一次查看数百或数千行代码。但函数也引入了作用域；有了这个，你可以在不同的作用域中拥有相同名称的变量，而它们不会相互干扰。你需要注意你当前正在查看的作用域。
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: You should start to get in the habit of *tracing* through a program. To trace
    through a program, you should go line by line, draw the scope you’re in, and write
    any variables and their values currently in the scope.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该开始养成*跟踪*程序的习惯。要跟踪程序，你应该逐行阅读，绘制当前的作用域，并写下当前作用域中任何变量及其值。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows a simple function definition and a couple of function
    calls. In the code, you have one function that returns `"odd"` if a number is
    odd, and `"even"` if it’s even. The code within the function doesn’t print anything,
    it only returns the result. The code starts running at the line `num = 4` because
    everything above it is a function definition. This variable is in the global scope.
    The function call `odd_or_even(num)` creates a scope and maps the value `4` to
    the formal parameter in the function definition. You do all the calculations and
    return `"even"` because the remainder when 4 is divided by 2 is 0\. `print(odd_or_even(num))`
    prints the returned value, `"even"`. After printing, you calculate `odd_or_even(5)`.
    The return from this function call isn’t used (isn’t printed), and no operations
    are performed on it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个简单的函数定义和一些函数调用。在代码中，您有一个函数，如果数字是奇数则返回 `"odd"`，如果是偶数则返回 `"even"`。函数内部的代码不打印任何内容，它只返回结果。代码从
    `num = 4` 行开始运行，因为上面的所有内容都是函数定义。这个变量在全局作用域中。函数调用 `odd_or_even(num)` 创建了一个作用域，并将值
    `4` 映射到函数定义中的形式参数。您进行所有计算并返回 `"even"`，因为4除以2的余数是0。`print(odd_or_even(num))` 打印返回的值，`"even"`。打印后，您计算
    `odd_or_even(5)`。这个函数调用的返回值没有被使用（没有打印），并且没有对其执行任何操作。
- en: Listing 22.6\. Functions showing different scoping rules
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表22.6\. 显示不同作用域规则的函数
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Function definition takes one parameter, num**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数定义接受一个参数，num**'
- en: '***2* Remainder when num is divided by 2**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* num除以2的余数**'
- en: '***3* Variable in global scope**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 全局作用域中的变量**'
- en: '***4* A function call that prints its return**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个打印其返回值的函数调用**'
- en: '***5* A function call that doesn’t do anything with its return**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 一个没有对其返回值进行任何操作的函数调用**'
- en: '[Figure 22.1](#ch22fig01) shows how you might draw a trace of a program. The
    one tricky thing is that you have two variables named `num`. But because they’re
    in different scopes, they don’t interfere with each other.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图22.1](#ch22fig01) 展示了您可能如何绘制一个程序的跟踪图。其中一件棘手的事情是您有两个名为 `num` 的变量。但由于它们在不同的作用域中，它们不会相互干扰。'
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 22.1**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查22.1**'
- en: For the following code, what will each line print?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下代码，每一行将打印什么？
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**[1](kindle_split_056.html#app01qa88q0a1)**'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa88q0a1)**'
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(f(x, y))`'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(f(x, y))`'
- en: '**[2](kindle_split_056.html#app01qa88q0a2)**'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa88q0a2)**'
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(f(a, b))`'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(f(a, b))`'
- en: '**[3](kindle_split_056.html#app01qa88q0a3)**'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa88q0a3)**'
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(f(x, a))`'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(f(x, a))`'
- en: '**[4](kindle_split_056.html#app01qa88q0a4)**'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa88q0a4)**'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(f(y, b))`'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(f(y, b))`'
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 22.1\. ![](images/b-1.jpg) A trace of a program that indicates whether
    a number is odd or even. At each line, you draw the scope you’re in along with
    all variables existing in that scope. In ![](images/b-1.jpg) you start the program
    and are at the line with the arrow. After that line executes, the scope of the
    program contains a function definition and a variable named `num`. In ![](images/b-2.jpg)
    you just made the function call `print(odd_or_even(num))`. You create a new scope.
    Notice that the global scope still exists but isn’t in focus right now. In the
    left panel of ![](images/b-2.jpg), you have the parameter `num` as a variable
    with the value `4`. In the middle panel of ![](images/b-2.jpg) you’re executing
    the line `num=num%2` inside the function call and reassign, only in the function
    call scope, the variable `num` to be `0`. In the right panel of ![](images/b-2.jpg)
    you make the decision and return `"even"`. In ![](images/b-3.jpg) the function
    returned `"even"` and the scope of the function call disappeared. You’re back
    in the global scope and perform the two prints. Printing the function call shows
    `"even"` and printing the `num` shows `4` because you’re using the `num` variable
    from the global scope.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图22.1\. ![](images/b-1.jpg) 一个指示数字是奇数还是偶数的程序跟踪图。在每一行，您绘制您所在的作用域以及该作用域中存在的所有变量。在
    ![](images/b-1.jpg) 中，您开始程序并处于带有箭头的行。在该行执行之后，程序的作用域包含一个函数定义和一个名为 `num` 的变量。在 ![](images/b-2.jpg)
    中，您刚刚调用了 `print(odd_or_even(num))` 函数。您创建了一个新的作用域。请注意，全局作用域仍然存在，但现在不是焦点。在 ![](images/b-2.jpg)
    的左侧面板中，您有一个参数 `num` 作为值为 `4` 的变量。在 ![](images/b-2.jpg) 的中间面板中，您正在执行函数调用内的 `num=num%2`
    行，并在函数调用作用域内重新分配，只在该函数调用作用域内将变量 `num` 赋值为 `0`。在 ![](images/b-2.jpg) 的右侧面板中，您做出决定并返回
    `"even"`。在 ![](images/b-3.jpg) 中，函数返回了 `"even"`，函数调用的作用域消失了。您回到了全局作用域并执行了两个打印操作。打印函数调用显示了
    `"even"`，打印 `num` 显示了 `4`，因为您正在使用全局作用域中的 `num` 变量。
- en: '![](images/22fig01_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](images/22fig01_alt.jpg)'
- en: 22.3\. Nesting functions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.3\. 函数嵌套
- en: Just as you can have nested loops, you can have nested functions. These are
    function definitions inside other functions. Python knows only about an inner
    function inside the scope of the outer function—and only when the outer function
    is being called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以有嵌套循环一样，你也可以有嵌套函数。这些是其他函数内部的函数定义。Python 只知道外函数作用域内的内函数——并且只有当外函数被调用时。
- en: '[Listing 22.7](#ch22ex07) shows a nested function `stop()` inside the function
    `sing()`. The global scope is the main program scope. It has one function definition
    for `sing()`. The function definition at this point is just some code. The function
    doesn’t execute until you make a function call. When you try to say `stop()` in
    the main program scope, you get an error.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 22.7](#ch22ex07) 展示了函数 `sing()` 内部的嵌套函数 `stop()`。全局作用域是主程序作用域。它有一个 `sing()`
    的函数定义。在这个点上，函数定义只是一些代码。函数不会执行，直到你进行函数调用。当你试图在主程序作用域中调用 `stop()` 时，你会得到一个错误。'
- en: Inside the definition of `sing()`, you define another function named `stop()`
    that also contains code. You don’t care what that code is until you make a function
    call. Inside `sing()`, the `stop()` call doesn’t cause an error because `stop()`
    is defined inside `sing()`. As far as the main program is concerned, only function
    `sing` is its scope.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sing()` 的定义内部，你定义了另一个名为 `stop()` 的函数，它也包含代码。你不需要关心那是什么代码，直到你进行函数调用。在 `sing()`
    内部，`stop()` 的调用不会导致错误，因为 `stop()` 在 `sing()` 内部定义。对于主程序来说，只有函数 `sing` 是其作用域。
- en: Listing 22.7\. Nesting functions
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.7\. 函数嵌套
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Function definition inside sing()**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* sing() 内部的函数定义**'
- en: '***2* Calls inside sing() to the stop function**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* sing() 内部对 stop 函数的调用**'
- en: '***3* Error because stop() doesn’t exist in the global scope**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 错误，因为全局范围内不存在 stop()**'
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 22.2**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 22.2**'
- en: For the following code, what will each line print?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下代码，每一行将打印什么？
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**[1](kindle_split_056.html#app01qa89q0a1)**'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa89q0a1)**'
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(add_one(x, y))`'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(add_one(x, y))`'
- en: '**[2](kindle_split_056.html#app01qa89q0a2)**'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa89q0a2)**'
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(add_one(a, b))`'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(add_one(a, b))`'
- en: '**[3](kindle_split_056.html#app01qa89q0a3)**'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa89q0a3)**'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(add_one(x, a))`'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(add_one(x, a))`'
- en: '**[4](kindle_split_056.html#app01qa89q0a4)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa89q0a4)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`print(add_one(y, b))`'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`print(add_one(y, b))`'
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 22.4\. Passing functions as parameters
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.4\. 将函数作为参数传递
- en: You’ve seen objects of type int, string, float, and Boolean. In Python, everything
    is an object, so any function you define is an object of type function. Any object
    can be passed around as a parameter to a function, even other functions!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过 int、string、float 和 Boolean 类型的对象。在 Python 中，一切都是对象，所以你定义的任何函数都是函数类型的对象。任何对象都可以作为函数的参数传递，甚至其他函数！
- en: You want to write code to make one of two sandwiches. A BLT sandwich tells you
    it has bacon, lettuce, and tomato in it. A breakfast sandwich tells you it has
    egg and cheese in it. In [listing 22.8](#ch22ex08), `blt` and `breakfast` are
    both functions that return a string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你想编写代码来制作两种三明治之一。BLT 三明治告诉你里面包含培根、生菜和番茄。早餐三明治告诉你里面包含鸡蛋和奶酪。在 [列表 22.8](#ch22ex08)
    中，`blt` 和 `breakfast` 都是返回字符串的函数。
- en: A function `sandwich` takes in a parameter named `kind_of_sandwich`. This parameter
    is a function object. Inside the `sandwich` function, you can call `kind_of_sandwich`
    as usual by adding parentheses after it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `sandwich` 接收一个名为 `kind_of_sandwich` 的参数。这个参数是一个函数对象。在 `sandwich` 函数内部，你可以像平常一样通过在其后添加括号来调用
    `kind_of_sandwich`。
- en: When you call the `sandwich` function, you call it with a function object as
    a parameter. You give it the name of a function for the sandwich you want to make.
    You don’t put parentheses after `blt` or `breakfast` as the argument because you
    want to pass the function object itself. If you use `blt()` or `breakfast()`,
    this will be a string object because this is a function call that returns a string
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `sandwich` 函数时，你用函数对象作为参数调用它。你给出你想要制作的三明治的函数名。你不在 `blt` 或 `breakfast` 后面放括号作为参数，因为你想传递函数对象本身。如果你使用
    `blt()` 或 `breakfast()`，这将是一个字符串对象，因为这是一个返回字符串的函数调用
- en: Listing 22.8\. Passing a function object as a parameter to another function
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.8\. 将函数对象作为参数传递给另一个函数
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* kind_of_sandwich is a parameter.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* kind_of_sandwich 是一个参数。**'
- en: '***2* kind_of_sandwich with parentheses indicates a function call.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* kind_of_sandwich 带括号表示函数调用。**'
- en: '***3* Uses the function name only (the object)**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 仅使用函数名（对象）**'
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 22.3**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 22.3**'
- en: '**[Q1:](kindle_split_056.html#app01qa90q0a1)**'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa90q0a1)**'
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw a trace of the program in [listing 22.8](#ch22ex08). At each line, decide
    the scope, what’s printed, the variables and their values, and what the function
    returns, if anything.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绘制 [列表 22.8](#ch22ex08) 中的程序跟踪。在每一行，决定作用域、打印的内容、变量及其值，以及如果有的话，函数返回的内容。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 22.5\. Returning a function
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.5\. 返回一个函数
- en: Because a function is an object, you can also have functions that return other
    functions. This is useful when you want to have specialized functions. You typically
    return functions when you have nested functions. To return a function object,
    you return only the function name. Recall that putting parentheses after the function
    name makes a function call, which you don’t want to do.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是一个对象，你也可以有返回其他函数的函数。当你想要有专门的函数时，这很有用。通常，当你有嵌套函数时，你会返回函数。为了返回一个函数对象，你只需返回函数名。回想一下，在函数名后加括号会进行函数调用，这是你不想做的。
- en: Returning a function is useful when you want to have specialized functions inside
    other functions. In [listing 22.9](#ch22ex09), you have a function named `grumpy`,
    and it prints a message. Inside the function `grumpy`, you have another function
    named `no_n_times`. It prints a message, and then inside that function you define
    another function, named `no_m_more_times`. The innermost function `no_m_more_times`
    prints a message and then prints `no n + m` times.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个函数在你想要在其他函数内部有专门的函数时很有用。在 [列表 22.9](#ch22ex09) 中，有一个名为 `grumpy` 的函数，它打印一条消息。在
    `grumpy` 函数内部，有一个名为 `no_n_times` 的另一个函数。它打印一条消息，然后在该函数内部定义另一个函数，名为 `no_m_more_times`。最内层的函数
    `no_m_more_times` 打印一条消息，然后打印 `no n + m` 次。
- en: You’re using the fact that `no_m_more_times` is nested inside `no_n_times` and
    therefore knows about the variable `n`, without having to send that variable in
    as a parameter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用 `no_m_more_times` 嵌套在 `no_n_times` 中的事实，因此它知道变量 `n`，而无需将那个变量作为参数发送。
- en: The function `no_n_times` returns the function `no_m_more_times` itself. The
    function `grumpy` returns the function `no_n_times`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `no_n_times` 返回函数 `no_m_more_times` 本身。函数 `grumpy` 返回函数 `no_n_times`。
- en: 'When you make a function call with `grumpy()(4)(2)`, you work from left to
    right and replace function calls as you go with whatever they return. Notice the
    following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `grumpy()(4)(2)` 进行函数调用时，你从左到右工作，并在过程中用它们返回的内容替换函数调用。注意以下内容：
- en: You don’t have to print the return of `grumpy` because you’re printing things
    inside the functions.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要打印 `grumpy` 的返回值，因为你在函数内部打印内容。
- en: A function call to `grumpy`() gets replaced with whatever `grumpy` returns,
    which is the function `no_n_times`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用 `grumpy()` 被替换为 `grumpy` 返回的内容，即函数 `no_n_times`。
- en: Now `no_n_times(4)` is replaced with whatever it returns, which is the function
    `no_m_more_times`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在 `no_n_times(4)` 被替换为它返回的内容，即函数 `no_m_more_times`。
- en: Finally, `no_m_more_times(2)` is the last function call, which prints out all
    the nos.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`no_m_more_times(2)` 是最后一个函数调用，它将打印出所有的数字。
- en: Listing 22.9\. Returning a function object from another function
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.9\. 从另一个函数返回函数对象
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Function definition**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数定义**'
- en: '***2* Nested function definition**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 嵌套函数定义**'
- en: '***3* Nested function definition**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 嵌套函数定义**'
- en: '***4* Loop to print the word “no” n + m times**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 循环打印单词“no” n + m 次**'
- en: '***5* Function no_n_times returns the function no_m_more_times**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 函数 no_n_times 返回函数 no_m_more_times**'
- en: '***6* Function grumpy returns the function no_n_times**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 函数 grumpy 返回函数 no_n_times**'
- en: '***7* Function call in main program**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 主程序中的函数调用**'
- en: This example shows that the function call is left-associative, so you replace
    the calls left to right with the functions they return. For example, you use `f()()()()`
    if you have four nested functions, each returning a function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明函数调用是左结合的，所以你从左到右用它们返回的函数替换调用。例如，如果你有四个嵌套函数，每个都返回一个函数，你会使用 `f()()()()`。
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 22.4**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 22.4**'
- en: '**[Q1:](kindle_split_056.html#app01qa91q0a1)**'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa91q0a1)**'
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw a trace of the program in [listing 22.9](#ch22ex09). At each line, decide
    the scope, what gets printed, the variables and their values, and what the function
    returns, if anything.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绘制 [列表 22.9](#ch22ex09) 中的程序跟踪。在每一行，决定作用域、打印的内容、变量及其值，以及如果有的话，函数返回的内容。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 22.6\. Summary
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.6\. 总结
- en: 'In this lesson, my objective was to teach you about the subtleties of functions.
    These ideas only begin to scratch the surface of what you can do with functions.
    You created functions that had variables with the same name and saw that they
    didn’t interfere with each other because of function scopes. You learned that
    functions are Python objects and that they can be passed in as parameters to or
    returned by other functions. Here are the major takeaways:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你关于函数的微妙之处。这些想法只是刚刚触及了你可以用函数做什么的表面。你创建了具有相同名称的变量的函数，并看到由于函数作用域，它们之间没有干扰。你了解到函数是Python对象，并且可以将它们作为参数传递给其他函数或由其他函数返回。以下是主要收获：
- en: You’ve been using built-in functions already, and now you understand why you
    wrote them in that way. They take parameters and return a value after doing a
    computation.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经使用过内置函数了，现在你理解了为什么你以那种方式编写它们。它们接受参数，并在执行计算后返回一个值。
- en: You can nest functions by defining them inside other functions. The nested functions
    exist only in the scope of the enclosing function.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在其他函数内部定义函数来嵌套函数。嵌套函数仅存在于封装函数的作用域内。
- en: You can pass around function objects like any other object. You can use them
    as parameters, and you can return them.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以像传递其他对象一样传递函数对象。你可以将它们用作参数，也可以返回它们。
- en: Let’s see if you got this...
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了...
- en: '**[Q22.1](kindle_split_056.html#app01qa92q0a1)**'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q22.1](kindle_split_056.html#app01qa92q0a1)**'
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fill the missing parts to the following code:'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 填写以下代码的缺失部分：
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a line to use `area()` to find the area of a circle with a radius of 10.
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一行代码使用 `area()` 来计算半径为10的圆的面积。
- en: Write a line to use `area()` to find the area of a square with sides of length
    5.
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一行代码使用 `area()` 来计算边长为5的正方形的面积。
- en: Write a line to use `area()` to find the area of a circle with diameter of length
    4.
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一行代码使用 `area()` 来计算直径为4的圆的面积。
- en: '**[Q22.2](kindle_split_056.html#app01qa92q0a2)**'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q22.2](kindle_split_056.html#app01qa92q0a2)**'
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fill the missing parts to the following code:'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 填写以下代码的缺失部分：
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, the function call
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，函数调用
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'should print this:'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该打印出以下内容：
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function call with age of `29`, major of `"CS"`, and vacation place
    of `"Japan"`.
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数调用，年龄为 `29`，专业为 `"CS"`，假期地点为 `"Japan"`。
- en: 'Write a function call so that the last line of its printout is as follows:
    `23 | "Law" | "Florida"`'
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数调用，使其打印输出的最后一行如下：`23 | "Law" | "Florida"`
