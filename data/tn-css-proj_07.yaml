- en: 7 Harnessing the full power of float
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 充分利用浮动的全部力量
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating a drop cap using float
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浮动创建首字母下沉
- en: Using float to wrap text around the image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浮动将文本环绕图像
- en: Using CSS shapes to make the text follow the floated image’s shape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS形状使文本跟随浮动图像的形状
- en: Grid and Flexbox have given us the ability to create layouts that once were
    incredibly difficult to realize, if not impossible. One of the most common examples
    is a three-column layout with all three columns the same height regardless of
    the contents. Another layout technique, which unlike its grid and flexbox counterparts
    has been around for quite some time, is float. Part of the CSS Logical Properties
    and Values Module, *float* is purpose-built to allow other content to wrap around
    the element being floated; as a result, it shines at manipulating images inside
    text and creating drop caps.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 网格和Flexbox使我们能够创建以前难以实现，甚至不可能实现的布局。最常见的一个例子是三列布局，其中所有三列的高度都相同，无论内容如何。另一种布局技术，与网格和Flexbox类似，已经存在了相当长的时间，就是浮动。作为CSS逻辑属性和值模块的一部分，*浮动*是专门为允许其他内容围绕被浮动的元素进行环绕而构建的；因此，它在处理文本中的图像和创建首字母下沉方面表现出色。
- en: '*Drop caps* are a way to style and add emphasis to text. They consist of creating
    a larger (sometimes more ornate) capital letter, usually at the beginning of a
    page or paragraph. Drop caps were often used in the illuminated manuscripts of
    the Middle Ages. The *F* at the beginning of the paragraph in figure 7.1 is an
    example of a drop cap in the Carmina Burana manuscript. Later, with the advent
    of the printing press, the concept carried over into print; printers created specialized
    glyphs and plates or simply used a larger font size. Drop caps are much rarer
    on the web, but they’re by no means impossible to create, and they’re a great
    way to make our online typography more interesting.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*首字母下沉*是一种用于样式化和强调文本的方法。它包括创建一个更大的（有时更华丽的）大写字母，通常位于页面或段落的开始处。在中世纪的装饰手稿中，首字母下沉经常被使用。图7.1段落开头的*F*就是Carmina
    Burana手稿中首字母下沉的一个例子。后来，随着印刷机的出现，这一概念被带到了印刷领域；印刷商创建了专门的符号和版面或简单地使用了更大的字体大小。在网络上，首字母下沉相对较少，但它们绝不是不可能创建的，而且它们是使我们的在线排版更加有趣的好方法。'
- en: '![](../Images/07-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-01.png)'
- en: Figure 7.1 Drop cap at the beginning of the paragraph in the Carmina Burana
    manuscript
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 Carmina Burana手稿中段落开头的首字母下沉
- en: Another way to make content more visually striking is to style our images to
    fit nicely in the text. When we add images to content, we often add our image
    element and maybe some margin, and don’t think about the process much more. Using
    CSS shapes in conjunction with float, however, we can make our text wrap in the
    actual shape of the image to create a much more striking effect. We can flow text
    around virtually any shapes we create, even curves.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使内容更具视觉冲击力的方法是调整我们的图像，使其在文本中看起来很合适。当我们向内容添加图像时，我们通常会添加我们的图像元素和可能的一些边距，而不会过多地考虑这个过程。然而，结合使用CSS形状和浮动，我们可以使文本围绕图像的实际形状进行环绕，从而创建一个更加引人注目的效果。我们可以将文本围绕我们创建的几乎任何形状进行环绕，甚至是曲线。
- en: In this chapter, we’ll take a close look at our typography and images to make
    our content more visually interesting while making sure to keep it accessible.
    We’ll start with an unstyled excerpt from *The Call of the Wild*, by Jack London
    ([http://mng.bz/61WR](http://mng.bz/61WR)). We’ll use float to add a drop cap
    to our first paragraph. Then we’ll wrap our text around our images (both raster
    and vector), following the content of those images. Figure 7.2 shows the starting
    point and the finished product.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仔细审视我们的排版和图像，使我们的内容更具视觉吸引力，同时确保其可访问性。我们将从一个未加样式的摘录开始，摘自杰克·伦敦的《野性的呼唤》([http://mng.bz/61WR](http://mng.bz/61WR))。我们将使用浮动为我们的第一段添加首字母下沉。然后我们将文本围绕我们的图像（栅格和矢量）进行环绕，遵循图像的内容。图7.2显示了起点和成品。
- en: '![](../Images/07-02.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-02.png)'
- en: Figure 7.2 The starting point (left) and finished product (right)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 起点（左）和成品（右）
- en: NOTE A *raster image* is created by using a grid of pixels, whereas a *vector
    image* is drawn with the help of mathematical formulas. For in-depth information
    about the difference between rasters and vectors, check out chapter 3.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：*栅格图像*是通过使用像素网格创建的，而*矢量图像*是通过数学公式绘制的。关于栅格和矢量之间差异的深入了解，请参阅第3章。
- en: Listing 7.1 and listing 7.2 contain the starting HTML and CSS, respectively,
    for the page we’ll build on in this chapter. To follow along as we style the page,
    you can download the starting code from the GitHub repository at [http://mng.bz/oJXD](http://mng.bz/oJXD)
    or from CodePen at [https://codepen.io/michaelgearon/pen/MWodXxM](https://codepen.io/michaelgearon/pen/MWodXxM).
    Our HTML consists of a `<main>` element inside which we have a header (`<h1>`),
    block quote (`<blockquote>`), three paragraphs (`<p>`), two images (`<img>`),
    and the source citation (`<cite>`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 和列表 7.2 分别包含我们将在此章节中构建的页面的起始 HTML 和 CSS。要跟随我们为页面添加样式的过程，您可以从 GitHub 仓库
    [http://mng.bz/oJXD](http://mng.bz/oJXD) 或 CodePen [https://codepen.io/michaelgearon/pen/MWodXxM](https://codepen.io/michaelgearon/pen/MWodXxM)
    下载起始代码。我们的 HTML 包含一个 `<main>` 元素，其中包含一个标题 (`<h1>`)、块引用 (`<blockquote>`)、三个段落 (`<p>`)、两个图像
    (`<img>`）和来源引用 (`<cite>`)。
- en: Listing 7.1 Starting HTML
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 起始 HTML
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Compass image
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ① 方位图像
- en: ② Dog image
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ② 狗图像
- en: Our CSS includes some base styles to set up our page, including `margin`, `padding`,
    and `background-color`. The `body`’s width is restricted to `78ch`, and margins
    center the content when the screen width exceeds our maximum value. We also set
    up the default font for the page, which is Times New Roman. Last, to ensure that
    the images don’t overflow on small screens, we give them a maximum width, which
    is set to `100%`. In other words, the images can’t be wider than their container.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 CSS 包含一些基础样式来设置我们的页面，包括 `margin`、`padding` 和 `background-color`。`body` 的宽度限制为
    `78ch`，并且当屏幕宽度超过最大值时，边距会居中内容。我们还设置了页面的默认字体，即 Times New Roman。最后，为了确保在小屏幕上图片不会溢出，我们给它们设置了最大宽度，设置为
    `100%`。换句话说，图片的宽度不能超过其容器。
- en: Note Notice that we use `ch` for our `max-width`. `ch` is a relative unit based
    on the font family being used. `1ch` is equal to the width of—or, more precisely,
    the horizontal amount of space occupied by—the glyph `0` (zero).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 注意到我们使用 `ch` 作为 `max-width`。`ch` 是一个基于所使用的字体家族的相对单位。`1ch` 等于或更准确地说，是符号 `0`（零）的宽度或水平占用空间。
- en: Listing 7.2 Starting CSS
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 起始 CSS
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Prevents our content from becoming excessively wide
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ① 防止我们的内容变得过于宽
- en: ② Centers the content
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ② 居中内容
- en: ③ Regardless of window size, the background covers the whole window.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 不论窗口大小，背景覆盖整个窗口。
- en: 7.1 Adding a drop cap
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 添加首字母下沉
- en: We have some base CSS to style the page, so now we’re going to turn our attention
    to the text. By virtue of the fact that the width of our body is capped at a width
    that works well for our text, we don’t need to worry about line length. But we
    do need to address the leading.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些基础 CSS 来设置页面样式，因此现在我们将关注文本。由于我们身体的宽度被限制在一个适合文本的宽度上，我们不需要担心行长。但我们确实需要处理行距。
- en: 7.1.1 Leading
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 行距
- en: '*Leading* (pronounced ’le-diŋ) is the amount of space between lines. The term
    comes from the days of the printing press when compositors used lead bars of various
    widths to adjust the spacing between lines of text. The CSS property we’re going
    to use to accomplish the same outcome is `line-height`. This property can take
    a number value (`line-height:` `2`) or a number with a unit (`line-height:` `5px`).
    The unit can be relative, such as ems, or fixed, such as pixels. Unless the unit
    is relative to the font size when we provide a unit (such as `em`), if the font
    is scaled or a child element has a different font size, the line height may not
    look correct and can negatively affect legibility. When we use a unitless number,
    the line height is automatically calculated relative to the font size of the element,
    eliminating this concern. Therefore, we’ll use a unitless `line-height`. We’ll
    set a `line-height` of `1.5` on all paragraphs by creating a rule specifically
    for the paragraph element and then applying the height as follows: `p` `{` `line-height:`
    `1.5;` `}`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*行距*（发音为’le-diŋ）是行与行之间的空间。这个术语来自印刷机时代，当时排版工人使用各种宽度的铅条来调整文本行之间的间距。我们将使用 `line-height`
    属性来实现相同的效果。这个属性可以接受一个数值（`line-height:` `2`）或一个带单位的数值（`line-height:` `5px`）。单位可以是相对的，如
    ems，也可以是固定的，如像素。除非我们提供的单位相对于字体大小（例如 `em`），如果字体被缩放或子元素有不同的字体大小，行高可能看起来不正确，并可能对可读性产生负面影响。当我们使用无单位的数值时，行高会自动相对于元素的字体大小计算，从而消除这种担忧。因此，我们将使用无单位的
    `line-height`。我们将通过创建一个专门针对段落元素的规则，并将高度设置为以下方式来设置所有段落的 `line-height`：`p` `{` `line-height:`
    `1.5;` `}`。'
- en: TIP Research shows that text with a `line-height` between `1.5` and `2` makes
    line tracking easier for people with cognitive disabilities ([https://www.w3.org/TR/WCAG20-TECHS/C21.html](https://www.w3.org/TR/WCAG20-TECHS/C21.html)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 研究表明，行高在 `1.5` 到 `2` 之间的文本对于认知障碍人士来说更容易进行行追踪（[https://www.w3.org/TR/WCAG20-TECHS/C21.html](https://www.w3.org/TR/WCAG20-TECHS/C21.html)）。
- en: 7.1.2 Justification
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 对齐
- en: For optimum effect when we have the text follow the image, we’re going to justify
    our text. *Justifying* the text means we’re going to make all our lines the same
    width—a technique often used in newspapers to make the right edge of a column
    on text straight rather than ragged.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本紧随图像时，为了达到最佳效果，我们将使文本对齐。*对齐*文本意味着我们将使所有行具有相同的宽度——这是一种常用于报纸上使文本列的右边缘整齐而不是参差不齐的技术。
- en: 'WARNING The Web Content Accessibility Guideline (WCAG) includes three levels
    of conformance that build on one another: A, AA, and AAA. A is the least restrictive,
    and AAA is the most stringent. Most often, websites aim for an AA level of conformance.
    But if we’re required to conform to AAA, it’s worth mentioning that justifying
    text goes against accessibility guideline 1.4.5, which is a requirement for AAA
    ([http://mng.bz/v1ja](http://mng.bz/v1ja)).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 网络内容可访问性指南（WCAG）包括三个相互依赖的符合级别：A、AA 和 AAA。A 是最不限制的，AAA 是最严格的。大多数情况下，网站的目标是达到
    AA 级别的符合。但如果我们必须符合 AAA，值得注意的是，对齐文本违反了可访问性指南 1.4.5，这是 AAA 的要求（[http://mng.bz/v1ja](http://mng.bz/v1ja)）。
- en: To justify our text, we’re going to use the `text-align` property, which can
    take a value of `left`, `right`, `center`, or `justify`. We’ll add `text-align:`
    `justify;` to our paragraph rule. Now that rule has two properties, `text-align`
    and `line-height`, that take care of styling the paragraph. The following listing
    shows the completed paragraph rule, and figure 7.3 shows the result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使文本对齐，我们将使用 `text-align` 属性，它可以接受 `left`、`right`、`center` 或 `justify` 的值。我们将向段落规则添加
    `text-align:` `justify;`。现在该规则有两个属性，`text-align` 和 `line-height`，负责段落样式。以下列表显示了完成的段落规则，图
    7.3 显示了结果。
- en: Listing 7.3 Completed paragraph rule
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 完成的段落规则
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../Images/07-03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-03.png)'
- en: Figure 7.3 Styled paragraphs
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 样式化段落
- en: With the paragraph taken care of, we can hone in on the first letter of the
    first paragraph to create our drop cap.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 段落处理完毕后，我们可以专注于第一段的第一字母来创建我们的首字母下沉。
- en: 7.1.3 First letter
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 第一字母
- en: We don’t need to add any elements to the HTML to select the first letter of
    our first paragraph. We can use the pseudo-class :`first-of-type` to select the
    first paragraph and then the pseudo-element `::first-letter` to get to the letter,
    in this case a *B*, both of which can be chained. In code, these selections translate
    to `p:first-of-type::first-letter` `{}`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要向 HTML 中添加任何元素来选择第一段的第一字母。我们可以使用伪类 :`first-of-type` 来选择第一段，然后使用伪元素 `::first-letter`
    来获取字母，在这种情况下是一个 *B*，这两个都可以链式使用。在代码中，这些选择器转换为 `p:first-of-type::first-letter` `{}`。
- en: Note A pseudo-class is added to a selector to target a specific state; a pseudo-element
    allows us to select part of the element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 伪类被添加到选择器中以针对特定状态；伪元素允许我们选择元素的一部分。
- en: With the letter selected, we can start styling it to make it look like a drop
    cap. To make it stand out from the rest of the text, we’re going to pick a more
    ornate typeface. In this case, we’ll import Passions Conflict ([http://mng.bz/X5vE](http://mng.bz/X5vE);
    figure 7.4) from Google Fonts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字母被选中后，我们可以开始对其进行样式设计，使其看起来像首字母下沉。为了使其从其余文本中脱颖而出，我们将选择一个更华丽的字体。在这种情况下，我们将从 Google
    Fonts 导入 Passions Conflict ([http://mng.bz/X5vE](http://mng.bz/X5vE)；图 7.4)。
- en: '![](../Images/07-04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-04.png)'
- en: Figure 7.4 Passions Conflict glyphs
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 激情冲突符号
- en: Because this typeface has particularly ornate capital letters, it’s well suited
    for use as our drop cap. We’ll also use it later in this chapter to style the
    quote at the beginning of the text. Using a beautiful typeface such as this one
    is a wonderful way to embellish a page—but only for short bits of content. Handwriting
    and display fonts can be quite difficult to read, so they’re not well suited for
    large blocks of text. For a drop cap, large header, or short quote, however, these
    fonts differentiate the element from the rest of the content and give the page
    some personality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种字体具有特别华丽的字母，它非常适合用作首字母。我们还将在此章的后面使用它来样式化文本开头处的引言。使用如此美丽的字体，如这一种，是装饰页面的一种美妙方式——但仅适用于短篇内容。手写体和显示字体可能很难阅读，因此它们不适合大块文本。然而，对于首字母、大标题或短引言，这些字体可以使元素与内容区分开来，并为页面增添一些个性。
- en: This particular font has glyphs that are quite a bit smaller than those of Times
    New Roman (the font we’re using for the rest of our content). Because we’re creating
    a drop cap, which by definition is larger than the rest of the text, we’re going
    to have to adjust the font size. We’re also going to adjust the line height of
    the letter to make it fit nicely with the text. Finally, we’re going to float
    our first letter to the left so that the text flows around the letter, accomplishing
    our desired effect.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体中的符号比我们用于其余内容的Times New Roman（字体）要小得多。由于我们正在创建首字母，根据定义，它比其余文本要大，因此我们需要调整字体大小。我们还将调整字母的行高，使其与文本很好地匹配。最后，我们将第一个字母向左浮动，以便文本围绕字母流动，达到我们期望的效果。
- en: The `float` property places an element to the right or left of its container
    based on the value passed to it. According to the Mozilla Developer Network, “The
    element is removed from the normal flow of the page, though still remaining a
    part of the flow” ([http://mng.bz/ydle](http://mng.bz/ydle)). Inline elements
    around it (our text) use the leftover space to wrap around the floated element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`属性根据传递给它的值将元素放置在其容器右侧或左侧。根据Mozilla开发者网络的说法，“元素从页面的正常流程中移除，尽管仍然属于流程的一部分”([http://mng.bz/ydle](http://mng.bz/ydle))。围绕它的内联元素（我们的文本）使用剩余的空间来围绕浮动元素包裹。'
- en: 'The `float` property can take one of three values: `left`, `right`, and `none`
    (element isn’t floated). Because our text is in English, which flows from left
    to right, we want to keep the letter *B* to the left, so we’re going to float
    the first letter of the first paragraph (*B*) to the left by adding `float:` `left;`
    to our rule. The following listing shows the completed CSS rule we create to style
    our drop cap, as well as the import of the Passions Conflict typeface.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`属性可以取三个值之一：`left`、`right`和`none`（元素不浮动）。由于我们的文本是英文，从左到右流动，我们希望将字母*B*保持在左边，因此我们将通过添加`float:`
    `left;`到我们的规则中来将第一段的第一字母(*B*)向左浮动。以下列表显示了我们所创建的用于样式化首字母的完整CSS规则，以及导入Passions Conflict字体的过程。'
- en: Listing 7.4 Styling and positioning the first letter of the first paragraph
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 样式化和定位第一段的第一字母
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Import of the Passions Conflict typeface
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入Passions Conflict字体
- en: ② Rule that styles the letter B at the beginning of our first paragraph
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ② 样式化我们第一段开头字母B的规则
- en: Notice that we altered the line height of the first letter to adjust the space
    below the *B*. By default, line height is proportional to font size. Because our
    letter is large, the line height it requires is tall, so we decrease it to make
    the text flow more naturally below the drop cap. Figure 7.5 shows the output generated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们调整了第一字母的行高以调整*B*下面的空间。默认情况下，行高与字体大小成比例。由于我们的字母很大，所需的行高很高，因此我们将其降低以使文本在首字母下方流动得更自然。图7.5显示了生成的输出。
- en: '![](../Images/07-05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-05.png)'
- en: Figure 7.5 Drop cap
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 首字母
- en: We use `em`s and a unitless `line-height` so that if we ever change the font
    size of the paragraph, the drop cap will scale accordingly. The value of `6em`
    is set based on the `font-size` of the parent element, which in this case is our
    paragraph tag.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`em`和无单位的`line-height`，这样如果以后我们更改段落的字体大小，首字母将相应地缩放。`6em`的值是基于父元素的`font-size`设置的，在这种情况下是段落标签。
- en: To reposition our *B* to fit well with the text, we edited the `line-height`
    of the letter. But we could have used another technique. We could have set the
    `position` of the *B* to `relative` and then used `top`, `bottom`, `left`, and
    `right` to alter its position relative to the rest of the text. With our drop
    cap created, we’re going to turn our attention to the quote at the start of the
    page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的 *B* 重新定位以更好地与文本匹配，我们编辑了字母的 `line-height`。但我们可以使用另一种技术。我们可以将 *B* 的 `position`
    设置为 `relative`，然后使用 `top`、`bottom`、`left` 和 `right` 来改变其相对于文本其余部分的位置。在我们创建好首字下沉后，我们将把注意力转向页面开头的引言。
- en: 7.2 Styling the quote
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 引言的样式
- en: The quote at the top of the page is rather drab at the moment and gets a little
    lost in the rest of the text. To make it stand out, we’re going to use the same
    font we used for our drop cap. Because of the previously mentioned differences
    in size and line height, we’re going to adjust those parameters so that the paragraphs
    and the quote are uniformly sized and spaced. Listing 7.5 shows the CSS we’ll
    add to accomplish this task, and figure 7.6 shows the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 页面顶部的引言目前相当单调，并且在与文本的其余部分中有些迷失。为了使其突出，我们将使用我们用于首字下沉的相同字体。由于之前提到的尺寸和行高差异，我们将调整这些参数，以便段落和引言具有统一的大小和间距。列表
    7.5 显示了我们将添加的 CSS 以完成此任务，图 7.6 显示了输出。
- en: Listing 7.5 `<blockquote>` formatting
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 `<blockquote>` 格式化
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/07-06.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-06.png)'
- en: Figure 7.6 Styled `<blockquote>`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 样式 `<blockquote>`
- en: Again, we use relative units so that if the rest of the content’s font size
    changes, so will the quote. You may have noticed that we used a `line-height`
    of `1` even though we stated earlier (section 7.1.1) that for optimal legibility,
    a line height of `1.5` to `2` is ideal. We make an exception here because by default
    the font already has a large line height; we don’t need to increase the size.
    Occasionally, we’ll encounter fonts that have naturally tall line heights by default,
    especially when we’re dealing with cursive or display fonts. When this happens,
    sometimes we have to make an exception to the line-height-legibility guidance
    due to the design of the font.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用相对单位，以便如果其余内容的字体大小发生变化，引言也会发生变化。你可能已经注意到，尽管我们之前（第 7.1.1 节）提到，为了最佳的可读性，行高应为
    `1.5` 到 `2`，但我们在这里使用了 `line-height` 的 `1`。我们在这里做出例外，因为默认情况下，字体已经具有很大的行高；我们不需要增加大小。偶尔，我们会遇到默认情况下具有自然高行高的字体，尤其是在我们处理手写体或显示字体时。在这种情况下，有时我们必须根据字体的设计对行高可读性指南做出例外。
- en: Now, with our text taken care of, we can focus on the images.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的文本已经处理好了，我们可以专注于图像。
- en: 7.3 Curving text around the compass
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 在指南针周围弯曲文本
- en: The first thing we need to do to make the text wrap around our compass image
    is float the compass to the right. Our compass is a PNG image, and because it’s
    a rectangular image, the text follows a rectangular path in wrapping around the
    image. Figure 7.7 shows the floated compass. A border has been applied to the
    image to expose its bounding box.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将指南针图像向右浮动，以便文本围绕它包裹。我们的指南针是一个 PNG 图像，因为它是一个矩形图像，所以文本在围绕图像包裹时遵循矩形路径。图
    7.7 显示了浮动的指南针。已经应用了边框来显示其边界框。
- en: '![](../Images/07-07.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-07.png)'
- en: Figure 7.7 Square compass
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 正方形指南针
- en: '7.3.1 Adding shape-outside: circle'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 添加 shape-outside：圆形
- en: 'To make the text follow the curve of the compass, we need to add a curve to
    the image for the text to wrap around. The property we’ll use is `shape-outside`.
    This property allows us to define a shape around which the adjacent text will
    flow. The shape doesn’t have to be rectangular; instead, it can be any of the
    following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使文本跟随指南针的曲线，我们需要在图像中添加一个曲线，以便文本可以围绕它包裹。我们将使用的属性是 `shape-outside`。这个属性允许我们定义一个形状，相邻的文本将围绕这个形状流动。形状不必是矩形的；相反，它可以下列形状中的任何一个：
- en: Circle or ellipse
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形或椭圆形
- en: Polygon
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形
- en: Derived from an image (uses the alpha channel [transparency] of the image to
    determine what the shape should be)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图像派生（使用图像的 alpha 通道 [透明度] 来确定形状应该是什么）
- en: Path (in the specification but not implemented in any browser at this writing;
    see [http://mng.bz/aMWX](http://mng.bz/aMWX))
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径（在规范中，但截至本文写作时，任何浏览器都没有实现；见 [http://mng.bz/aMWX](http://mng.bz/aMWX)）
- en: Box model values (`margin-box`, `content-box`, `border-box`, and `padding-box`)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒模型值（`margin-box`、`content-box`、`border-box` 和 `padding-box`）
- en: Linear gradient
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性渐变
- en: 'Because we have a circular graphic, the shape we’re going to aim for is a circle.
    This decision gives us a couple of options:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个圆形图形，我们想要的目标形状是一个圆。这个决定给我们提供了几个选择：
- en: Use CSS shapes ([http://mng.bz/aMWX](http://mng.bz/aMWX)).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS形状（[http://mng.bz/aMWX](http://mng.bz/aMWX)）。
- en: Use `border-radius`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `border-radius`。
- en: 'Let’s first take a look at using shapes. To define our circle, we’re going
    to use the `circle()` function, which takes an optional `radius` property and
    an optional `position` property to define where the center of the circle starts.
    If no `radius` is provided, the value defaults to `closest-side`. If the `position`
    property is omitted, the origin of the circle defaults to the center of the image:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用形状。为了定义我们的圆，我们将使用 `circle()` 函数，它接受一个可选的 `radius` 属性和一个可选的 `position`
    属性来定义圆的中心开始的位置。如果没有提供 `radius`，则默认值为 `closest-side`。如果省略了 `position` 属性，则圆的起点默认为图像的中心：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our case, we want the center of the circle to be the middle of the image,
    so we won’t pass a `position` property. We have to define a `radius`, however,
    and we’re going to set it to `50%`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望圆的中心位于图像的中间，所以我们不会传递一个 `position` 属性。然而，我们必须定义一个 `radius`，我们将将其设置为
    `50%`。
- en: How the math works
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数学原理
- en: 'We want the radius to equal half the width of our image, which under the covers
    will resolve to the square root of our width squared plus our height squared divided
    by the square root of 2:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望半径等于我们图像宽度的一半，这在底层将解析为宽度平方加高度平方的平方根除以2：
- en: '![](../Images/07-07-equation-7-1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![方程式7-1](../Images/07-07-equation-7-1.png)'
- en: Because our image is square and has a width of 175, when we pass a `radius`
    of `50%`, it’s logical that our radius would be 87.5\. But if the image were rectangular,
    understanding how a percentage-based radius is calculated is important for understanding
    what the resulting output will look like.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的图像是正方形，宽度为175，当我们传递一个 `radius` 为 `50%` 时，我们的半径为87.5是合乎逻辑的。但如果图像是矩形的，理解基于百分比的半径是如何计算的对于理解最终输出将是什么样子非常重要。
- en: 'If we had a landscape image of height `100px` and width `300px`, the radius
    needed to inscribe the circle when choosing a percentage-based value is much less
    obvious. We can use the following formula to calculate what the radius would be:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个高度为 `100px`、宽度为 `300px` 的风景图像，当选择基于百分比的值时，所需的半径需要更明显。我们可以使用以下公式来计算半径是多少：
- en: '![](../Images/07-07-equation-7-2.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![方程式7-2](../Images/07-07-equation-7-2.png)'
- en: Figure 7.8 shows how the radius would be applied to our square image versus
    a rectangular image when we use a value of `50%` in the `circle()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8显示了当我们使用 `circle()` 函数中的 `50%` 值时，半径将如何应用于我们的正方形图像与矩形图像。
- en: '![](../Images/07-08.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图像7-8](../Images/07-08.png)'
- en: Figure 7.8 Radius applied to a square versus a rectangular image
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 将半径应用于正方形图像与矩形图像
- en: Our image is square, so we use a `shape-outside` property with a value of `circle(50%)`
    for our image. Listing 7.6 shows the CSS rule. Our image is square, so it has
    an aspect ratio of 1 `(`width / height = 175 ÷ 175 = 1`)`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图像是正方形，所以我们使用一个值为 `circle(50%)` 的 `shape-outside` 属性来设置我们的图像。列表7.6显示了CSS规则。我们的图像是正方形，因此它的宽高比为1（宽度/高度
    = 175 ÷ 175 = 1）。
- en: DEFINITION The *aspect ratio* of an image is the proportional relationship of
    the image’s height and width calculated by dividing the width by the height.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 图像的**宽高比**是通过将宽度除以高度计算出的图像高度和宽度的比例关系。'
- en: Adding the aspect ratio isn’t strictly necessary to create our shape but helps
    reduce layout shifts on load.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 添加宽高比并不是严格必要的，但有助于减少加载时的布局偏移。
- en: DEFINITION When an element is added to the page or its size is changed, everything
    after the element moves to make room for the element or fill the void left behind.
    The movement of elements on the page is referred to as a *layout shift*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 当一个元素被添加到页面或其大小发生变化时，页面上的所有元素都会移动以腾出空间给元素或填充留下的空白。页面元素的运动被称为**布局偏移**。'
- en: When the image has a set height and width or has a defined aspect ratio, the
    browser can save room for the image while it’s being loaded, therefore reducing
    the layout shift. Accordingly, it’s good practice to define aspect ratios and/or
    height and width for our images.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像具有固定的高度和宽度或已定义的宽高比时，浏览器可以在加载图像时为其预留空间，从而减少布局偏移。因此，定义图像的宽高比和/或高度和宽度是一个好的实践。
- en: Listing 7.6 `shape-outside`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 `shape-outside`
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Aspect ratio
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ① 宽高比
- en: ② Floats the image to the right
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将图像浮动到右侧
- en: ③ Adds our circle with a value of 50%
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 添加一个值为50%的圆
- en: Figure 7.9 displays our output. The text wraps around the image and follows
    the curve, but the image isn’t clipped in any way. This effect works because our
    image has a transparent background.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9展示了我们的输出。文本围绕图像环绕并跟随曲线，但图像没有任何裁剪。这种效果之所以可行，是因为我们的图像有一个透明的背景。
- en: '![](../Images/07-09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-09.png)'
- en: Figure 7.9 Floated compass with curved text
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9浮动指南针，文本弯曲
- en: 7.3.2 Adding a clip-path
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 添加clip-path
- en: We’ve curved the text, but the image is still square. If we add a background
    to the image, this fact becomes obvious. To make the image appear to be truly
    circular, we need to add a `clip-path`. The `clip-path` property also takes a
    shape, so we’re going to pass it the same value we passed to `shape-outside`.
    We’re also going to add some margin to our image to add a little breathing room
    between it and the text. Listing 7.7 shows the complete CSS for our image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使文本弯曲，但图像仍然是方形的。如果我们给图像添加一个背景，这一点就会变得明显。要使图像看起来真正是圆形的，我们需要添加一个`clip-path`。`clip-path`属性也接受一个形状，所以我们将传递与传递给`shape-outside`相同的值。我们还将给我们的图像添加一些边距，以在图像和文本之间添加一些呼吸空间。列表7.7显示了我们的图像的完整CSS。
- en: Listing 7.7 `clip-path`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 `clip-path`
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We added a `clip-path` that matches our `shape-outside` and some margin to the
    left of the image to prevent the text from getting too close to the image, especially
    because the compass has arrows protruding from the circular outline that our `circle()`
    doesn’t create. Figure 7.10 shows the finished output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个与`shape-outside`匹配的`clip-path`，并在图像的左侧添加了一些边距，以防止文本离图像太近，特别是因为指南针有从圆形轮廓突出来的箭头，而我们的`circle()`没有创建这样的轮廓。图7.10显示了最终的输出。
- en: '![](../Images/07-10.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-10.png)'
- en: Figure 7.10 Round floated compass
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10圆形浮动指南针
- en: When we add the `clip-path`, we observe that now the image itself, including
    the background, appears to be round. The corners have been clipped, and the previously
    square background is circular. Also, the added margin moves the text around our
    compass arrow, making it look less crowded.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加`clip-path`时，我们会观察到现在图像本身，包括背景，看起来是圆形的。角落已经被裁剪，之前是方形的背景现在是圆形的。此外，增加的边距使文本围绕我们的指南针箭头移动，使其看起来不那么拥挤。
- en: We’ve demonstrated that we can create a circle by using CSS shapes. Now let’s
    look at how to make the circle by using `border-radius`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了我们可以通过使用CSS形状来创建圆形。现在让我们看看如何使用`border-radius`来创建圆形。
- en: 7.3.3 Creating a shape using border-radius
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用border-radius创建形状
- en: We can create a CSS shape from an element’s contours when we use `border-radius`
    to shape the element. We still use `shape-outside`, but instead of passing in
    a shape, we specify the level of the box model at which we want the shape to form.
    Our options are
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`border-radius`来塑造元素时，我们可以从元素的轮廓创建一个CSS形状。我们仍然使用`shape-outside`，但不是传递一个形状，而是指定我们想要形状形成的盒模型级别。我们的选项有
- en: '`margin-box`—Shape follows the margins.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin-box`—形状跟随边距。'
- en: '`border-box`—Shape follows the borders.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`border-box`—形状跟随边框。'
- en: '`padding-box`—Shape follows the padding.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding-box`—形状跟随填充。'
- en: '`content-box`—Shape follows the content.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-box`—形状跟随内容。'
- en: Let’s start with a clean slate, with our image floated to the right and some
    margin added to keep the text from crowding the image. Listing 7.8 contains our
    starting CSS, and figure 7.11 shows the current display.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一张干净的画布开始，将我们的图像浮动到右边，并添加一些边距以防止文本拥挤图像。列表7.8包含我们的起始CSS，图7.11显示了当前的显示。
- en: Listing 7.8 Starting point
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8起点
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/07-11.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-11.png)'
- en: Figure 7.11 Resetting to float and adding a margin
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11重置浮动并添加边距
- en: Now let’s add a `border-radius` of `50%`, which will make our image a circle.
    At this point, though, the text doesn’t follow the curve. We still need to add
    the `shape-outside` property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`border-radius`为`50%`，这将使我们的图像成为圆形。然而，在这个时候，文本并没有跟随曲线。我们仍然需要添加`shape-outside`属性。
- en: Our image has a margin that (ideally) we want the shape to respect, so we’re
    going to use the `margin-box` value. The next listing shows this concept applied
    in code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图像有一个边距，理想情况下我们希望形状尊重这个边距，因此我们将使用`margin-box`值。接下来的列表显示了这一概念在代码中的应用。
- en: Listing 7.9 Adding `border-radius` and `shape-outside`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 添加`border-radius`和`shape-outside`
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 7.12 shows the output with a white background and border added to emphasize
    the shape of the image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12显示了带有白色背景和边框的输出，以强调图像的形状。
- en: '![](../Images/07-12.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-12.png)'
- en: Figure 7.12 Compass shape with `border-radius` of `50%` and a `shape-outside`
    value of `margin-box`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12指南针形状，`border-radius`为`50%`，`shape-outside`值为`margin-box`
- en: Unlike when we used `shape-outside` with the `circle()` function, our image
    is already cropped into a circular shape, eliminating the need to use `clip-path`.
    This outcome is a direct result of using `border-radius`, which is doing the clipping
    for us.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用 `shape-outside` 和 `circle()` 函数时不同，我们的图像已经裁剪成圆形形状，消除了使用 `clip-path` 的需要。这个结果是我们使用
    `border-radius` 的直接结果，它为我们做了裁剪。
- en: We’ve seen two different ways to accomplish the same result. CSS offers more
    than one way to approach many problems, including this one. Neither option is
    particularly superior to the other. `border-radius` requires slightly less code,
    which gives it a slight edge, but in this case the choice is a matter of preference.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种实现相同结果的不同方法。CSS 提供了多种方法来处理许多问题，包括这个问题。这两种选项并没有特别优于对方。`border-radius`
    需要稍微少一点的代码，这给它带来了一丝优势，但在这个情况下，选择是一个个人偏好的问题。
- en: Now that we’ve handled the compass image, we’re going to move on to wrap the
    text around the dog.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了指南针图像，我们将继续将文本环绕在狗的周围。
- en: 7.4 Wrapping text around the dog
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 将文本环绕在狗的周围
- en: Unlike the compass, which is a standard shape, the dog has an irregular outline.
    This image is line art composed of a single path, so we might be tempted to grab
    the path from the SVG file and use the `path()` function to create our shape.
    As we’re about to see, however, although it’s defined in the CSS specification
    ([https://www.w3.org/TR/css-shapes](https://www.w3.org/TR/css-shapes)), this technique
    won’t work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准形状的指南针不同，狗有一个不规则的轮廓。这张图像是由单一路径组成的线条艺术，所以我们可能会想从 SVG 文件中抓取路径并使用 `path()` 函数来创建我们的形状。然而，正如我们即将看到的，尽管它在
    CSS 规范中定义了（[https://www.w3.org/TR/css-shapes](https://www.w3.org/TR/css-shapes)），这种技术不会起作用。
- en: 7.4.1 Using path() . . . or not yet
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 使用 path()...或者尚未
- en: Let’s open the image file in an editor to inspect the code. The following listing
    shows the image code redacted for brevity to highlight the important information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开图像文件并在编辑器中检查代码。以下列表显示了为了简洁而省略的图像代码，以突出重要信息。
- en: Listing 7.10 `dog.svg`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 `dog.svg`
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have the `<defs>` element, which includes the styles for the image. This
    part defines what the individual elements in the SVG will look like. Then we have
    a `<path>`, which is the element displaying the dog. This element is 1,988 characters
    long and quite complex, and when `shape-outside:` `path('M21.913...');` is pasted
    into the `path()` function, it doesn’t seem to do anything. The reason is that
    when this book was written, no browser fully implemented `path()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `<defs>` 元素，它包括图像的样式。这部分定义了 SVG 中的单个元素将看起来是什么样子。然后我们有一个 `<path>`，这是显示狗的元素。这个元素有
    1,988 个字符长，相当复杂，当 `shape-outside:` `path('M21.913...');` 被粘贴到 `path()` 函数中时，它似乎没有做任何事情。原因是当这本书被编写时，没有浏览器完全实现了
    `path()`。
- en: 'When this feature is implemented, creating our paths with a graphics editor
    and copying them to create our shapes will be a valuable technique. But this method
    will have a drawback: the paths can get quite long, making maintainability dubious.
    In the meantime, we have a couple of alternatives:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个功能实现时，使用图形编辑器创建我们的路径并将它们复制以创建我们的形状将是一种有价值的技巧。但这种方法有一个缺点：路径可能会相当长，使得维护变得可疑。与此同时，我们有一些替代方案：
- en: Creating a polygon shape that roughly matches our image, similar to the technique
    we used for the circle
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个大致匹配我们图像的多边形形状，类似于我们用于圆形的技术
- en: Using the `url()` function, which pulls in the image and bases the shape on
    the alpha channel
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `url()` 函数，它将图像拉入并基于 alpha 通道创建形状
- en: 'We’re going to go with the second option: the `url()` function.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择第二种选项：`url()` 函数。
- en: 7.4.2 Floating the image
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 浮动图像
- en: As we did when we handled the compass image (section 7.3), we’re going to start
    by floating the image, but this time we’ll float it to the left to break up the
    visual monotony of our page. Then, to create the shape, we’ll use the `url()`
    function and pass the path to the image to it. Listing 7.11 shows the CSS applied
    to the dog image.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在处理指南针图像时所做的（第 7.3 节），我们将首先浮动图像，但这次我们将将其浮动到左侧，以打破我们页面上的视觉单调性。然后，为了创建形状，我们将使用
    `url()` 函数并将图像路径传递给它。列表 7.11 展示了应用于狗图像的 CSS。
- en: Serving the image file
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提供图像文件
- en: When using URLs with `shape-outside`, we need to make sure we’re running our
    code through a server so that the image is getting fetched by the browser, not
    read directly from the file system. This approach is related to Cross-Origin Resource
    Sharing (CORS) and security policies set by the browser. You can find a detailed
    explanation in the CSS specification at [http://mng.bz/pdMw](http://mng.bz/pdMw).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`shape-outside`的URL时，我们需要确保我们的代码通过服务器运行，这样浏览器会获取图像，而不是直接从文件系统中读取。这种方法与跨源资源共享（CORS）和浏览器设置的安全策略相关。你可以在CSS规范中找到详细的解释，链接为[http://mng.bz/pdMw](http://mng.bz/pdMw)。
- en: To mitigate this problem, the sample code in the GitHub repository uses `http-server`,
    serving the files on `localhost:8080` to accomplish this task. Another option
    would be to reference the hosted file in GitHub by using `shape-outside:` `url("https:/
    /raw.githubusercontent.com/michaelgearon/Tiny-CSS-Projects/` `main/chapter-07/before/img/dog.svg")`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，GitHub仓库中的示例代码使用了`http-server`，在`localhost:8080`上提供文件服务以完成此任务。另一个选择是使用`shape-outside:`
    `url("https:/ /raw.githubusercontent.com/michaelgearon/Tiny-CSS-Projects/` `main/chapter-07/before/img/dog.svg")`引用GitHub上的托管文件。
- en: Listing 7.11 Dog floated left
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11 狗向左浮动
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We float the image left and then add our `shape-outside`, passing in a reference
    to the image itself. The browser will look at the transparency of the image and
    determine where to create the shape based on where the transparency ends. Figure
    7.13 shows our output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像向左浮动，然后添加我们的`shape-outside`，传递对图像本身的引用。浏览器将查看图像的透明度，并根据透明度结束的位置确定创建形状的位置。图7.13显示了我们的输出。
- en: '![](../Images/07-13.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-13.png)'
- en: Figure 7.13 Floated dog
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 浮动狗
- en: Because our image has an opaque line with a transparent background, the cutoff
    is straightforward. If our image had a gradient that went from opaque to transparent,
    we could tailor the cutoff by using the `shape-image-threshold` property. This
    property takes a value between `0` (fully transparent) and `1` (fully opaque).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的图像有一个不透明的线条和透明的背景，裁剪是直接的。如果我们的图像有一个从不透明到透明的渐变，我们可以通过使用`shape-image-threshold`属性来调整裁剪。该属性接受介于`0`（完全透明）和`1`（完全不透明）之间的值。
- en: 7.4.3 Adding shape-margin
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 添加shape-margin
- en: The next step is adding some margin to move the text away from the image because
    it looks rather crowded. We can’t simply add a margin to the image, as we did
    when we floated to the right; if we try, we’ll notice that the margin is ignored.
    Instead, we need to use `shape-margin`. The `shape-margin` property allows us
    to adjust the amount of space between our shape and the rest of the content. We’re
    going to add `1em` worth of space, as shown in the following listing and figure
    7.14.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加一些边距来将文本从图像推开，因为它看起来相当拥挤。我们不能简单地给图像添加边距，就像我们向右浮动时做的那样；如果我们尝试这样做，我们会注意到边距被忽略了。相反，我们需要使用`shape-margin`。`shape-margin`属性允许我们调整形状和其余内容之间的空间量。我们将添加`1em`的空间，如以下列表和图7.14所示。
- en: Listing 7.12 Adding `shape-margin` to our rule
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.12 将`shape-margin`添加到我们的规则中
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](../Images/07-14.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-14.png)'
- en: Figure 7.14 `shape-margin` applied to the image
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 应用到图像的`shape-margin`
- en: The text at the bottom of the image is still quite close. At this point, we
    can add some margin to increase the space as long as the margin added is less
    than or equal to the `shape-margin` amount. If the value is greater than the `shape-margin`
    amount, the margin will still take effect, but only as much as the `shape-margin`
    amount. Keeping this caveat in mind, we’ll add `1em` of margin to the right of
    the image. The next listing shows the completed CSS for the dog image.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图像底部的文字仍然相当接近。在这个时候，我们可以添加一些边距来增加空间，只要添加的边距小于或等于`shape-margin`的数量。如果值大于`shape-margin`的数量，边距仍然会生效，但只会生效到`shape-margin`的数量。记住这个注意事项，我们将向图像的右侧添加`1em`的边距。下一个列表显示了狗图像完成的CSS。
- en: Listing 7.13 Completed dog image
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.13 完成的狗图像
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The combination of `shape-margin` and `margin-right` pushes the text away from
    our image, creating the polished result we see in figure 7.15.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape-margin`和`margin-right`的组合将文本从我们的图像推开，形成了我们在图7.15中看到的精致结果。'
- en: '![](../Images/07-15.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-15.png)'
- en: Figure 7.15 Finished floated dog
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 完成的浮动狗
- en: With this last piece completed, we’ve finished styling our page (figure 7.16).
    We have a layout that’s visually appealing and much more interesting than the
    one we started with.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成最后这一部分后，我们已经完成了页面的样式设计（图7.16）。我们有一个视觉上吸引人且比我们开始时更有趣的布局。
- en: '![](../Images/07-16.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-16.png)'
- en: Figure 7.16 Finished layout
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 完成的布局
- en: We’ve created a layout made possible by the use of float. We couldn’t have achieved
    the same result by using Flex or Grid easily. Whether we use it on its own, as
    in our drop-cap example, or in conjunction with shapes (which, granted, are rather
    new as well), float continues to be a valuable asset for us to keep in our toolbox.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个由浮动的使用所实现的布局。如果我们使用 Flex 或 Grid，很难轻易地达到相同的效果。无论我们单独使用它，就像在我们的首字下沉示例中那样，还是与形状（虽然这些形状也相当新颖）结合使用，浮动继续是我们工具箱中的一个宝贵资产。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Leading, the amount of space between lines, is important for legibility.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行距，即行与行之间的空间，对于可读性很重要。
- en: Float can be used in conjunction with `::first-letter` to create drop caps.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将 `Float` 与 `::first-letter` 结合使用来创建首字下沉。
- en: Not all typefaces have the same size and line heights when given the same size
    value.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有字体在给定相同大小值时都具有相同的大小和行高。
- en: The `shape-outside` property uses CSS shapes to alter the shape of an element.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape-outside` 属性使用 CSS 形状来改变元素形状。'
- en: Circular shapes can be created with `border-radius`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `border-radius` 可以创建圆形形状。
- en: Inline content adjacent to a floated CSS shape will follow the shape.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与浮动的 CSS 形状相邻的内联内容将跟随形状。
- en: When we use `url()` with `shape-outside`, the image file must be fetched by
    the browser (hosted or via `http-server` or the equivalent).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用 `url()` 与 `shape-outside` 结合时，浏览器必须获取图像文件（托管或通过 `http-server` 或等效方式）。
- en: The `shape-margin` property sets the margin of a shape.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape-margin` 属性设置了形状的边距。'
- en: Some layouts can’t be created without the use of float.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些布局没有使用浮动是无法创建的。
