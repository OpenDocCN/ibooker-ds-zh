- en: Part 3\. Modeling data, consuming APIs, and testing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分。数据建模、API调用和测试
- en: As your Vue.js applications grow larger and more complicated, you’ll need to
    start thinking about a way to store data more efficiently in them. Luckily for
    us, Vuex offers an amazing solution that makes this process easy. We’ll learn
    that in greater detail in [chapter 10](kindle_split_022.html#ch10).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的Vue.js应用程序变得更大、更复杂，您将需要开始考虑一种更有效地在它们中存储数据的方法。幸运的是，Vuex提供了一个令人惊叹的解决方案，使这个过程变得简单。我们将在[第10章](kindle_split_022.html#ch10)中更详细地了解这一点。
- en: In [chapter 11](kindle_split_023.html#ch11), dovetailing nicely from [chapter
    10](kindle_split_022.html#ch10), we’ll look at communicating with a server. We’ll
    discuss talking to a backend system and processing data. We’ll then learn about
    server-side rendering, a new technology that will increase the speed of your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](kindle_split_023.html#ch11)中，紧接[第10章](kindle_split_022.html#ch10)之后，我们将探讨如何与服务器通信。我们将讨论与后端系统对话和处理数据。然后，我们将了解服务器端渲染，这是一种新技术，将提高您应用程序的速度。
- en: In [chapter 12](kindle_split_024.html#ch12), we’ll learn how to test. As a professional
    web developer, you’ll need to know how to test your application. Testing helps
    eliminates bugs, and your applications will be more stable. We’ll also take a
    peek at development operations, also known as DevOps. We’ll learn how it can benefit
    our development lifecycle when deploying our application and making sure everything
    is working properly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](kindle_split_024.html#ch12)中，我们将学习如何测试。作为一名专业的前端开发者，您需要知道如何测试您的应用程序。测试有助于消除错误，并且您的应用程序将更加稳定。我们还将简要了解开发运维，也称为DevOps。我们将了解它如何在我们部署应用程序并确保一切正常工作时，对我们的开发周期产生好处。
- en: Chapter 10\. Vuex
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章。Vuex
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解状态
- en: Using getters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用获取器
- en: Implementing mutations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现突变
- en: Adding actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加动作
- en: Working with Vuex helpers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vuex辅助工具
- en: Learning about project setup and modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解项目设置和模块
- en: In [chapter 9](kindle_split_020.html#ch09), we looked at ways we could extend
    Vue.js and reuse part of its functionality without repeating code. In this chapter,
    we’ll look at how we store data in our application and how that data is shared
    between components. One of the preferred ways of sharing data in an application
    is by using a library called *Vuex*. Vuex is a state-management library that helps
    create a centralized store that can be shared with all the components in the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](kindle_split_020.html#ch09)中，我们探讨了如何扩展Vue.js以及如何在不重复代码的情况下重用其功能的一部分。在本章中，我们将探讨如何在我们的应用程序中存储数据以及数据如何在组件之间共享。在应用程序中共享数据的一种首选方式是使用名为*Vuex*的库。Vuex是一个状态管理库，它帮助创建一个可以与应用程序中的所有组件共享的集中式存储。
- en: We’ll begin by looking at when we should use Vuex and when we shouldn’t. Certain
    applications benefit more from Vuex than others. Next, we’ll look at state and
    how we can centrally locate it. Afterward we’ll explore getters, mutations, and
    actions. All three allow us to keep track of state in our application. Then we’ll
    look at Vuex helpers, which will help us eliminate part of our boilerplate code.
    Last, we’ll see what type of directory structure we can use to fully take advantage
    of Vuex in larger applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探讨何时应该使用Vuex以及何时不应该使用Vuex开始。某些应用程序比其他应用程序更能从Vuex中受益。接下来，我们将探讨状态以及我们如何将其集中定位。之后，我们将探索获取器、突变和动作。这三个都允许我们在应用程序中跟踪状态。然后，我们将了解Vuex辅助工具，它将帮助我们消除部分样板代码。最后，我们将看到我们可以使用什么类型的目录结构来充分利用Vuex在大型应用程序中的功能。
- en: 10.1\. Vuex, what is it good for?
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. Vuex，它有什么好处？
- en: The Vuex state-management library mutates *state*. It stores state in a central
    location, which makes it easy for any component to interact with. State is the
    information or data that supports our application. This is important because we
    need to access that information in a reliable and understandable way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex状态管理库会修改*状态*。它将状态存储在中央位置，这使得任何组件都可以轻松与之交互。状态是支持我们应用程序的信息或数据。这很重要，因为我们需要以可靠和可理解的方式访问这些信息。
- en: If you’ve used other single-page frameworks, such as React, you may be already
    familiar with several of these concepts. React uses a similar state-management
    system called Redux. Both Redux and Vuex are inspired by a state-management system
    called Flux. Flux is an architecture that Facebook created to help build its client-side
    web applications. It promotes a unidirectional data flow from actions, to a dispatcher,
    to a store, to a view. This flow helps separate state from the rest of the application
    and it promotes synchronous updates. You can learn more about flux from the official
    documentation at [https://facebook.github.io/flux/docs/overview.html](https://facebook.github.io/flux/docs/overview.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过其他单页框架，例如 React，你可能已经熟悉了这些概念中的几个。React 使用一个类似的状态管理系统，称为 Redux。Redux 和
    Vuex 都受到了一个名为 Flux 的状态管理系统的启发。Flux 是 Facebook 创建的一个架构，用于帮助构建其客户端 Web 应用程序。它促进从动作到调度器，再到存储，再到视图的单向数据流。这种流有助于将状态与其他应用程序部分分离，并促进同步更新。你可以在官方文档中了解更多关于
    Flux 的信息：[https://facebook.github.io/flux/docs/overview.html](https://facebook.github.io/flux/docs/overview.html)。
- en: Vuex uses these principles to help mutate state in a predictable, synchronous
    way. Developers don’t have to worry about synchronous or asynchronous functions
    changing state in a way that we don’t expect. Let’s say we’re interacting with
    an API on the backend that delivers a JSON payload to the application. But at
    the same time a third-party library is changing this information. We don’t want
    a scenario where the third-party library mutates the data in an unpredictable
    way. Vuex helps protect us from this scenario by forcing all mutations to be synchronous.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 使用这些原则以可预测、同步的方式帮助修改状态。开发者不必担心同步或异步函数以我们意料之外的方式改变状态。假设我们正在与后端的一个 API 交互，该
    API 向应用发送 JSON 负载。但与此同时，一个第三方库正在更改这些信息。我们不希望出现第三方库以不可预测的方式修改数据的情况。Vuex 通过强制所有修改都是同步的来帮助我们避免这种场景。
- en: You may be wondering why we need Vuex at all. After all, Vue.js gives us ways
    to pass information to components. As we learned from the components chapters,
    we can pass data using props and custom events. You could even come up with an
    event bus to pass information around and facilitate cross-component communication.
    You can see in [figure 10.1](#ch10fig01) how this might look.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们真的需要 Vuex。毕竟，Vue.js 给我们提供了向组件传递信息的方法。正如我们在组件章节中学到的，我们可以使用 props 和自定义事件来传递数据。你甚至可以想出一个事件总线来传递信息并促进跨组件通信。你可以在[图
    10.1](#ch10fig01)中看到这可能是什么样子。
- en: Figure 10.1\. Simple example of using props and an event bus
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 使用 props 和事件总线的一个简单示例
- en: '![](10fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig01_alt.jpg)'
- en: This works well for smaller applications with only a handful of components.
    In that scenario, we have to pass information to only a few components. What if
    our application were larger, with more complexity and levels? You can imagine
    that inside a larger application, keeping straight all the callbacks, passed props,
    and the event bus would be difficult.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于只有少数组件的小型应用来说效果很好。在这种情况下，我们只需要将信息传递给少数几个组件。如果我们的应用更大，更复杂，层次更多呢？你可以想象在一个更大的应用中，保持所有回调、传递的
    props 和事件总线是困难的。
- en: This is where Vuex comes in. It introduces a more organized way to keep track
    of our state in one central store. Let’s imagine a scenario where you might consider
    Vuex. In this scenario we’re creating a blog, and inside that blog we have several
    components including post, comments, create, edit, and delete. We also have an
    admin interface where we can ban and add users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Vuex 发挥作用的地方。它引入了一种更组织化的方式来跟踪我们状态的一个中心存储。让我们想象一个你可能考虑使用 Vuex 的场景。在这个场景中，我们正在创建一个博客，在该博客中我们有几个组件，包括帖子、评论、创建、编辑和删除。我们还有一个管理员界面，我们可以禁止和添加用户。
- en: Let’s see how that would look with Vuex. As you can see in [figure 10.2](#ch10fig02),
    the Edit Bio component is nested under the admin component. The Edit Bio component
    needs to have access to the user information, so it can update it. When using
    a central store with Vuex, we can access the store, mutate the information, and
    commit it straight from the Edit Bio component. This is a significant improvement
    from having to pass the information down from the root vue.js instance to the
    admin component then finally to the `Edit Bio` component using props. Trying to
    keep the information straight from multiple places would be difficult.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 Vuex 会是什么样子。如图 10.2 所示，编辑生物组件嵌套在管理员组件下。编辑生物组件需要访问用户信息，以便更新它。当使用 Vuex
    的中央存储时，我们可以从编辑生物组件直接访问存储、突变信息并提交它。这比从根 vue.js 实例向下传递信息到管理员组件，然后最终使用 props 传递到
    `Edit Bio` 组件有了显著的改进。试图从多个地方直接保持信息的一致性将是困难的。
- en: Figure 10.2\. How a central store is used with Vuex
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. 使用 Vuex 的中央存储
- en: '![](10fig02_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig02_alt.jpg)'
- en: 'With all that said, there’s a price to pay with Vuex: adding Vuex will add
    more complexity and boilerplate code to your app. As I mentioned, you probably
    shouldn’t use Vuex for simple apps with only a few components. Vuex thrives in
    larger applications where state can be more complicated.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上面所说的，使用 Vuex 有一定的代价：添加 Vuex 将会增加应用程序的复杂性和样板代码。正如我提到的，你可能不应该在只有几个组件的简单应用程序中使用
    Vuex。Vuex 在更大的应用程序中茁壮成长，在这些应用程序中，状态可能更复杂。
- en: 10.2\. Vuex state and mutations
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. Vuex 状态和突变
- en: Vuex uses a single object that contains the state for your complete application.
    This is also sometimes referred to as the *single source of truth*. As the name
    suggests, all the data is stored in exactly one place and isn’t duplicated anywhere
    in the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 使用一个包含应用程序状态的单一对象。这有时也被称为*单一事实来源*。正如其名所示，所有数据都存储在一个确切的地方，并且在应用程序的任何地方都没有重复。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: It’s worth mentioning that even though we’re using Vuex, we don’t have to put
    all our state in Vuex. Individual components can still have their own local state.
    In certain situations, this might be preferable. For example, in your component
    you might have a local variable that’s only used in that component. That variable
    should stay local.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管我们使用了 Vuex，我们不必将所有状态都放在 Vuex 中。单个组件仍然可以有自己的本地状态。在某些情况下，这可能更可取。例如，在你的组件中，你可能有一个仅在该组件中使用的本地变量。这个变量应该保持本地化。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s create a simple example of using state with Vuex. For this example, we’ll
    use a single file. Later, we’ll see how we can add Vuex to a Vue-CLI application.
    Open a text editor and create a file called vuex-state.html. In this file we’ll
    display a message that’s stored in the central store and show a counter. When
    it’s all done it will look like [figure 10.3](#ch10fig03).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用 Vuex 状态的简单示例。对于这个示例，我们将使用一个单文件。稍后，我们将看到如何将 Vuex 添加到 Vue-CLI 应用程序中。打开一个文本编辑器，创建一个名为
    vuex-state.html 的文件。在这个文件中，我们将显示存储在中央存储中的消息，并显示一个计数器。完成所有操作后，它将看起来像[图 10.3](#ch10fig03)。
- en: Figure 10.3\. Creating a simple app using Vuex
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. 使用 Vuex 创建简单应用程序
- en: '![](10fig03_alt.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig03_alt.jpg)'
- en: We’ll first add a script tag CDN link to both Vue and Vuex. Next, we’ll add
    in the HTML. For our HTML we’ll use an `H1`, `H2`, `H3` and a `button` tag. The
    `h1` tag will display the `header`, which is a local variable defined in the Vue.js
    instance. The `welcome` and `counter` messages will be computed properties derived
    from our Vuex store. The button element will trigger an action called `increment`.
    Add the code in this listing to the top of the vuex-state.html file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 CDN 脚本标签添加到 Vue 和 Vuex。接下来，我们将添加 HTML。对于我们的 HTML，我们将使用 `H1`、`H2`、`H3`
    和一个 `button` 标签。`h1` 标签将显示 `header`，这是一个在 Vue.js 实例中定义的本地变量。`welcome` 和 `counter`
    消息将是来自我们的 Vuex 存储的计算属性。按钮元素将触发一个名为 `increment` 的动作。将此列表中的代码添加到 vuex-state.html
    文件的顶部。
- en: 'Listing 10.1\. Adding HTML to our Vuex app: chapter-10/vuex-html.html'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 向我们的 Vuex 应用程序添加 HTML：chapter-10/vuex-html.html
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Shows a CDN script tag for Vue**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示了 Vue 的 CDN 脚本标签**'
- en: '***2* Shows a CDN script tag for Vuex**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了 Vuex 的 CDN 脚本标签**'
- en: '***3* Denotes the header variable**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 指出标题变量**'
- en: '***4* Lists the welcome computed property**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 列出了欢迎计算属性**'
- en: '***5* Shows the counter computed property**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 展示了计数器的计算属性**'
- en: '***6* Notes the button with click action set to increment**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 指出设置了点击动作设置为增加的按钮**'
- en: Now that we have our HTML in place, let’s begin by adding in a Vuex store. The
    Vuex store will hold all our data for our example. This will include the `msg`
    and `count` properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 HTML，让我们首先添加 Vuex 存储。Vuex 存储将包含我们示例中的所有数据。这包括 `msg` 和 `count` 属性。
- en: To update the state, we’ll use something called *mutations*. You can think of
    mutations as setters in other programming languages. *Setters* set values; mutations
    are what we use to update the state of the application. In Vuex, mutations must
    be synchronous. In our example, the counter will be triggered only when the button
    is pressed, so we don’t have to worry about asynchronous code. (Later we’ll look
    at actions that can help solve the problem when you’re dealing with things that
    are asynchronous.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态，我们将使用称为 *mutations* 的东西。你可以将 mutations 视为其他编程语言中的设置器。*设置器* 设置值；mutations
    是我们用来更新应用程序状态的工具。在 Vuex 中，mutations 必须是同步的。在我们的例子中，计数器只有在按钮被按下时才会被触发，所以我们不必担心异步代码。（稍后我们将探讨可以解决处理异步事物时问题的
    actions。）
- en: Inside our mutations object we’ll add an increment function that increments
    state. Take the code in this listing and add it to the bottom of the vuex-state.html
    file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的突变对象中，我们将添加一个增加状态的函数。将此列表中的代码添加到 vuex-state.html 文件的底部。
- en: 'Listing 10.2\. Add our Vuex state and mutations: chapter-10/vuex-state-mut.html'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 添加我们的 Vuex 状态和突变：chapter-10/vuex-state-mut.html
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* The Vuex.Store holds state information.**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Vuex.Store 包含状态信息。**'
- en: '***2* Shows the mutations that increment the state**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了增加状态的突变**'
- en: We have our HTML and Vuex store in place, and we can now add the logic that
    connects everything. We want to make sure that our template displays the `msg`
    and `counter` from the Vuex state and that we can update that count.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了 HTML 和 Vuex 存储，现在我们可以添加连接一切的逻辑。我们想要确保我们的模板显示 Vuex 状态中的 `msg` 和 `counter`，并且我们可以更新那个计数。
- en: Create a Vue.js instance with a new data function. This will return the local
    header property that displays `Vuex App.` In the next section, we’ll add a computed
    property which will have two functions, `welcome` and `counter`. The `welcome`
    property will return `store.state.msg`. The `counter` will return `store.state.count`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有新数据函数的 Vue.js 实例。这将返回显示 `Vuex App.` 的本地头属性。在下一节中，我们将添加一个计算属性，它将有两个函数，`welcome`
    和 `counter`。`welcome` 属性将返回 `store.state.msg`。`counter` 将返回 `store.state.count`。
- en: Finally, we’ll need to create a method called `increment`. To update the store
    and access the mutations we set up in Vuex, we can’t call the mutation directly.
    We must use a special function called `commit`. This will tell Vuex to update
    the store and commit the change, so to speak. The `store.commit('increment')`
    does the commit to the mutation we created. Add the following code to the vuex-state.html
    file under the code you created in [listing 10.2](#ch10ex02).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个名为 `increment` 的方法。要更新存储并访问我们在 Vuex 中设置的突变，我们不能直接调用突变。我们必须使用一个特殊函数，称为
    `commit`。这将告诉 Vuex 更新存储并提交更改，换句话说。`store.commit('increment')` 执行对我们创建的突变的提交。将以下代码添加到在
    [列表 10.2](#ch10ex02) 中创建的代码下面的 vuex-state.html 文件中。
- en: 'Listing 10.3\. Adding our Vue.js instance: chapter-10/vuex-instance.html'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 添加我们的 Vue.js 实例：chapter-10/vuex-instance.html
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Shows the header property that displays the message**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示了显示消息的头属性**'
- en: '***2* The computed property returns the msg state.**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 计算属性返回 msg 状态。**'
- en: '***3* The computed property returns the counter state.**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 计算属性返回计数器状态。**'
- en: '***4* The increment method triggers the Vuex increment mutation.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 增量方法触发 Vuex 的增量突变。**'
- en: Now we have a fully functional app that uses Vuex! Click the button a few times,
    and you should see the counter increment by one after each button click.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的应用程序，它使用了 Vuex！点击按钮几次，你应该会在每次点击按钮后看到计数器增加一。
- en: 'Let’s update this application so that each button click updates the count by
    10\. If you look closely at the mutations `increment` function, it has only one
    argument: `state`. However, we can pass another argument to it: we’ll call it
    payload. This payload can be sent from the increment method we created in the
    root Vue.js instance.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新这个应用程序，以便每次按钮点击都使计数增加 10。如果你仔细查看 mutations `increment` 函数，它只有一个参数：`state`。然而，我们可以向它传递另一个参数：我们将称之为
    payload。这个 payload 可以从我们在根 Vue.js 实例中创建的增量方法发送。
- en: Take the vuex-state.html file and copy it into a new file called vuex-state-pass.html.
    This file will hold our new application, which shows how to pass in a payload.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将`vuex-state.html`文件复制到一个名为`vuex-state-pass.html`的新文件中。此文件将包含我们的新应用程序，展示如何传递负载。
- en: As you can see in [listing 10.4](#ch10ex04), we need to update only the mutations
    object and the `increment` method. Add another argument called `payload` to the
    increment mutation. The `payload` will be added to the `state.count`. Inside the
    `increment` method, add `10` as another argument to the `store.commit`. Update
    the vuex-state.html as shown here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[列表10.4](#ch10ex04)中看到的，我们只需要更新突变对象和`increment`方法。将另一个名为`payload`的参数添加到增量突变中。`payload`将被添加到`state.count`中。在`increment`方法内部，将`10`作为另一个参数添加到`store.commit`中。按照以下所示更新`vuex-state.html`。
- en: 'Listing 10.4\. Passing `payload` into a mutation: chapter-10/vuex-state-pass-1.html'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表10.4. 将`payload`传递给突变: chapter-10/vuex-state-pass-1.html'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The increment mutation accepts a payload and adds it to the count.**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 增量突变接受一个负载并将其添加到计数中。**'
- en: '***2* The increment method now passes 10 to the mutation.**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在的增量方法将10传递给突变。**'
- en: Save the vuex-state-pass.html file and reload your browser. After clicking the
    button, it should now increment by 10 instead of by 1\. If it’s not loading correctly,
    check your web browser’s console. Make sure you didn’t have any typos.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`vuex-state-pass.html`文件并重新加载您的浏览器。点击按钮后，现在应该增加10而不是1。如果它没有正确加载，请检查您的网络浏览器控制台。确保您没有打字错误。
- en: 10.3\. Getters and actions
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. Getters和actions
- en: In the previous example, we directly accessed the store from our computed properties.
    What if we had multiple components that needed to access these computed properties?
    What if we wanted to always display a welcome message in all caps? This is where
    getters can help us out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们直接从我们的计算属性中访问了存储。如果我们有多个组件需要访问这些计算属性怎么办？如果我们想始终以全部大写字母显示欢迎消息怎么办？这就是getters能帮我们解决问题的地方。
- en: Inside Vuex, we have something called *getters*. With getters, all components
    can access the state in the same way. Let’s continue with our example from [section
    10.2](#ch10lev1sec2). We’re going to update it with getters instead of directly
    accessing the state in our computed properties. In addition, we want the getter
    for `msg` to convert the message to all uppercase letters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vuex中，我们有一种称为*getters*的东西。使用getters，所有组件都可以以相同的方式访问状态。让我们继续我们的[第10.2节](#ch10lev1sec2)的例子。我们将用getters来更新它，而不是直接在我们的计算属性中访问状态。此外，我们希望`msg`的getter将消息转换为全部大写字母。
- en: Take the vuex-state-pass.html file from the previous example and copy it to
    vuex-state-getter-action.html. To make things simple, we’ll leave the HTML the
    way it was before. When it’s all done it should look like [figure 10.4](#ch10fig04).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个例子中的`vuex-state-pass.html`文件复制到`vuex-state-getter-action.html`。为了简化问题，我们将保持HTML不变。完成之后，它应该看起来像[图10.4](#ch10fig04)。
- en: Figure 10.4\. Hello World app using setters and actions
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4. 使用设置器和动作的Hello World应用程序
- en: '![](10fig04_alt.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig04_alt.jpg)'
- en: You can see that the Hello World message is now in capital letters. Clicking
    the Press Me button increments the counter as it did in the last example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，Hello World消息现在是大写字母。点击“按我”按钮，计数器会增加，就像上一个例子中一样。
- en: Inside your newly created vuex-state-getter-action.html file, look for the `Vuex.Store`
    below the `<script>` tag. Below the `mutations` object add a new object called
    getters. Inside getters we’ll create `msg` and `count` as you can see in [listing
    10.5](#ch10ex05). Both `msg` and `count` take one argument, `state`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您新创建的`vuex-state-getter-action.html`文件中，找到`<script>`标签下的`Vuex.Store`。在`mutations`对象下方添加一个名为`getters`的新对象。在`getters`中，我们将创建`msg`和`count`，如[列表10.5](#ch10ex05)所示。`msg`和`count`都接受一个参数，`state`。
- en: In our `msg` getter, we’ll return `state.msg.toUppercase()`. This will ensure
    that whenever we use the `msg` getter, it will return the value in all caps. For
    our `count` getter, it will return `state.count`. Update the vuex-state-getter-action.html
    with the new getters object under mutations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`msg` getter中，我们将返回`state.msg.toUppercase()`。这将确保每次我们使用`msg` getter时，它都会返回全部大写的值。对于我们的`count`
    getter，它将返回`state.count`。在`mutations`下更新`vuex-state-getter-action.html`中的新getters对象。
- en: 'Listing 10.5\. Adding new getters: chapter-10/vuex-state-getter-action1.html'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表10.5. 添加新的getters: chapter-10/vuex-state-getter-action1.html'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The new getters object defines getters for Vuex.**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 新的getters对象定义了Vuex的getters。**'
- en: '***2* The msg getter returns msg in all caps.**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `msg` getter返回全部大写的消息。**'
- en: '***3* Shows the count getter**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示计数getter**'
- en: Actions are another integral part of Vuex. I previously mentioned that mutations
    are synchronous. But what if we’re dealing with asynchronous code? How can we
    be sure that our asynchronous code will still affect state? That’s where actions
    in Vuex comes in.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是Vuex的另一个基本组成部分。我之前提到突变是同步的。但如果我们处理的是异步代码呢？我们如何确保我们的异步代码仍然会影响状态？这就是Vuex中的动作发挥作用的地方。
- en: Let’s imagine in our example that we are accessing a server, and we’re waiting
    for a response. This is an example of an asynchronous action. Unfortunately, mutations
    must be synchronous, so we can’t use that. Instead, we’ll add the asynchronous
    operation using a Vuex action.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设在我们的例子中，我们正在访问一个服务器，并且我们正在等待响应。这是一个异步动作的例子。不幸的是，突变必须是同步的，所以我们不能使用它。相反，我们将使用Vuex动作添加异步操作。
- en: In this example we’ll create a delay using a `setTimeout`. Open the vuex-state-getter-action.html
    file and add a new object called actions after the getter object we created. Inside
    that object, we’ll have our `increment` action that takes a `context` and `payload`.
    The `context` is what we’ll use to commit our changes. We’ll wrap our `context.commit`
    inside a `setTimeout`. This is so we can simulate a delay from a server. We can
    also pass a payload to the `context.commit`. This will get passed to the mutation.
    Update the code based on this listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`setTimeout`创建一个延迟。打开vuex-state-getter-action.html文件，在我们创建的getter对象之后添加一个新的对象，称为actions。在这个对象内部，我们将有一个名为`increment`的动作，它接受一个`context`和`payload`。`context`是我们将用来提交更改的部分。我们将把`context.commit`包裹在一个`setTimeout`中。这样我们就可以模拟来自服务器的延迟。我们还可以向`context.commit`传递一个有效负载。这将传递给突变。根据这个列表更新代码。
- en: 'Listing 10.6\. Adding actions: chapter-10/vuex-state-getter-action2.html'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 添加动作：chapter-10/vuex-state-getter-action2.html
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* The actions object is used for asynchronous and synchronous actions.**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 动作对象用于异步和同步动作。**'
- en: '***2* The increment function accepts a context and payload.**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 增加函数接受一个context和payload。**'
- en: '***3* This triggers the increment mutation and passes the payload to it.**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这触发了增加突变并将有效负载传递给它。**'
- en: Now that we’ve updated our Vuex.Store, we can move on to the root Vue.js instance.
    Instead of accessing the store directly, we’ll update the computed property to
    access the getters instead. We’ll also update the increment method. We’ll use
    the `store.dispatch('increment', 10)` to access the new Vuex action we created.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了Vuex.Store，我们可以继续到根Vue.js实例。我们不会直接访问存储，而是更新计算属性以访问getter。我们还将更新增加方法。我们将使用`store.dispatch('increment',
    10)`来访问我们创建的新Vuex动作。
- en: The first argument of `dispatch` is always the name of the action. The second
    argument is always the payload that will get passed into the action.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch`的第一个参数始终是动作的名称。第二个参数始终是传递给动作的有效负载。'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The payload can be a simple variable or even an object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载可以是一个简单的变量，甚至是一个对象。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Update the vuex-state-getter-action.html code with the new Vue.js instance from
    this listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本列表中的新Vue.js实例更新vuex-state-getter-action.html代码。
- en: 'Listing 10.7\. Updating the Vue.js instance: chapter-10/vuex-state-getter-action3.html'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. 更新Vue.js实例：chapter-10/vuex-state-getter-action3.html
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The computed property welcome returns the getters msg.**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计算属性welcome返回getter msg。**'
- en: '***2* The computer property counter returns the getters count.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 计算属性counter返回getter count。**'
- en: '***3* The method dispatches the increment action.**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 该方法调用了增加动作。**'
- en: Load the app and click the button a few times. You’ll notice a delay, but the
    counter will update by 10 after each press.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用并点击按钮几次。你会注意到有延迟，但每次点击后计数器会增加10。
- en: 10.4\. Adding Vuex to Vue-CLI with the pet store app
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 使用宠物店应用程序将Vuex添加到Vue-CLI
- en: Let’s return to the pet store application that we’ve been working on. If you
    remember the last time we worked on it, we added fancy animations and transitions.
    Now that we’ve learned the basics of Vuex, let’s add it to the mix.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们一直在工作的宠物店应用程序。如果你还记得我们上次工作的情况，我们添加了花哨的动画和过渡效果。现在我们已经学习了Vuex的基础知识，让我们把它加入到项目中。
- en: Let’s move the product data into the store. If you recall from the previous
    chapters, we initialized the store in the created hook of the Main component in
    the pet store application. Instead, we’ll have the create hook dispatch a new
    action that will initialize the store inside Vuex. We’ll also add a new `products`
    computed property that retrieves our products using a Vuex getter that we’ll set
    up. When all is done it will look and behave the same as it did before, as seen
    in the [figure 10.5](#ch10fig05).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将产品数据移动到商店中。如果你还记得前几章的内容，我们在宠物商店应用程序的Main组件的创建钩子中初始化了商店。相反，我们将让创建钩子分发一个新的动作，该动作将在Vuex内部初始化商店。我们还将添加一个新的`products`计算属性，它使用我们将设置的Vuex获取器检索我们的产品。当一切完成后，它看起来和表现将与之前相同，如[图10.5](#ch10fig05)所示。
- en: Figure 10.5\. Showing the completed pet store application
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. 展示完成的宠物商店应用程序
- en: '![](10fig05_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![10fig05_alt.jpg](10fig05_alt.jpg)'
- en: 10.4.1\. Vuex installation in Vue-CLI
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 在Vue-CLI中安装Vuex
- en: To begin, let’s install Vuex! This is straightforward. If you haven’t already,
    retrieve the latest version of the pet store application that we last worked on
    in [chapter 8](kindle_split_019.html#ch08). Or you can download the completed
    code for this chapter from GitHub at [https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装Vuex！这是直截了当的。如果你还没有做，获取我们在[第8章](kindle_split_019.html#ch08)中最后工作的宠物商店应用程序的最新版本。或者，你可以从GitHub下载本章的完整代码[https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode)。
- en: 'Open a terminal window and change directories into the root of the pet store
    application folder. Run the following command at the prompt to install the latest
    version of Vuex and save it into the package.json file in the pet store application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，切换到宠物商店应用程序文件夹的根目录。在提示符下运行以下命令以安装最新版本的Vuex并将其保存到宠物商店应用程序的`package.json`文件中：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we’ll need to add the store to the main.js file in the src folder. We
    haven’t created the store yet, but let’s import it anyway. By convention, the
    store is usually located in the src/store/store.js file. This is up to you, and
    different developers come up with different conventions. For now, this will work
    for us. Later in the chapter, we’ll discuss alternative folder structures with
    something called modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将商店添加到src文件夹中的main.js文件。我们还没有创建商店，但让我们无论如何导入它。按照惯例，商店通常位于`src/store/store.js`文件中。这取决于你，不同的开发者会有不同的惯例。现在，这对我们来说将有效。在本章的后面部分，我们将讨论使用名为模块的替代文件夹结构。
- en: 'Inside the root Vue.js instance, we need to add the store, as shown in the
    following listing. Add the store to the root instance under router. By the way,
    because we’re using ES6, we can use the shorthand `store`, instead of `store:
    store`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '在根Vue.js实例内部，我们需要添加商店，如下所示。将商店添加到根实例下的路由器中。顺便说一句，因为我们使用ES6，所以我们可以使用简写`store`，而不是`store:
    store`。'
- en: 'Listing 10.8\. Updating the main.js file: chapter-10/petstore/src/main.js'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 更新main.js文件：chapter-10/petstore/src/main.js
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Imports the store into the main.js file**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将商店导入到main.js文件中**'
- en: '***2* Adds it into the Vue.js instance**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将其添加到Vue.js实例中**'
- en: Now that we’ve added the store into the root instance, we can access it throughout
    the application. Create a file in src/store/store.js. This file will be our Vuex
    store and hold the information for the products in our pet store application.
    At the top of the file, add two import statements, one each for Vue and Vuex.
    Next, we’ll add a `Vue.use(Vuex).` This will connect everything.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将商店添加到根实例中，我们可以在整个应用程序中访问它。在`src/store/store.js`中创建一个文件。这个文件将是我们Vuex商店，并持有我们宠物商店应用程序中的产品信息。在文件的顶部，添加两个导入语句，每个分别用于Vue和Vuex。接下来，我们将添加`Vue.use(Vuex)`。这将连接一切。
- en: Inside the main.js file, we imported store from `./store/store`. We need to
    export a store object inside the store.js file, so that the main.js file can import
    it. As you can see in [listing 10.9](#ch10ex09), we export a `const store` of
    `Vuex.Store`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`文件中，我们从`./store/store`导入了store。我们需要在`store.js`文件中导出一个store对象，以便`main.js`文件可以导入它。正如你在[列表10.9](#ch10ex09)中看到的，我们导出了一个`const
    store`的`Vuex.Store`。
- en: We’ll first add our state and mutations objects. The state object will hold
    an empty object called products. We’ll load that using our `initStore` soon. Our
    mutations will be called `SET_STORE`. The mutation will take the passed-in products
    and assign it to `state.products`. Inside the newly create src/store/store.js
    file, add the code from this listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加我们的状态和突变对象。状态对象将包含一个名为 products 的空对象。我们将很快使用 `initStore` 来加载它。我们的突变将被称为
    `SET_STORE`。突变将接受传递的产品并将其分配给 `state.products`。在新建的 src/store/store.js 文件中，添加此列表中的代码。
- en: 'Listing 10.9\. Creating the main.js file: chapter-10/store-part1.html'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 创建 main.js 文件：chapter-10/store-part1.html
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Sets Vuex with Vue**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 Vue 设置 Vuex**'
- en: '***2* Exports Vuex.Store so it can be later used in the main.js file**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导出 Vuex.Store 以便在 main.js 文件中稍后使用**'
- en: '***3* The state object shows products.**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 状态对象显示产品。**'
- en: '***4* The mutations object shows our set store function.**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 突变对象显示了我们的 set store 函数。**'
- en: We need to add the `action` and `getter` to the store. The `getter` will return
    `products`. The `action` is a little more complicated. What we want to do is move
    the created hook code that uses Axios to read the static/products.json file to
    the actions object in Vuex.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `action` 和 `getter` 添加到 store 中。`getter` 将返回 `products`。`action` 要复杂一些。我们想要做的是将使用
    Axios 读取 static/products.json 文件的创建钩子代码移动到 Vuex 的 actions 对象中。
- en: Remember that I mentioned that mutations had to be synchronous and that only
    actions inside Vuex would accept asynchronous code? To get around this, we’ll
    put the Axios code inside a Vuex action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我提到突变必须是同步的，并且只有 Vuex 中的动作可以接受异步代码吗？为了解决这个问题，我们将 Axios 代码放在 Vuex 动作中。
- en: Create the actions object inside the store.js file and add `initStore`. Inside
    this action, copy and paste the created lifecycle hook from the components/Main.vue
    file. Instead of assigning the `response.data.products` to the products object,
    we’ll now use the commit function to trigger our mutation. We’ll pass in the `response.data.products`
    as the payload to `SET_STORE`. After all is done, it should look like this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 store.js 文件中创建 actions 对象并添加 `initStore`。在这个动作中，从 components/Main.vue 文件中复制并粘贴创建的生命周期钩子。现在，我们将使用
    commit 函数来触发我们的突变。我们将 `response.data.products` 作为有效载荷传递给 `SET_STORE`。完成后，它应该看起来像这样。
- en: 'Listing 10.10\. Adding actions and getters to store.js: chapter-10/store-part2.html'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 将动作和 getter 添加到 store.js：chapter-10/store-part2.html
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The actions object used for asynchronous code**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于异步代码的动作对象**'
- en: '***2* The initstore action commits the mutation.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* initstore action 提交突变。**'
- en: '***3* The products getter returns the store for products.**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 产品 getter 返回存储的产品。**'
- en: 'We’re getting close, and now all we need to do is update the Main.vue file
    so it uses the Vuex store instead of the local products object. Open the src/components/Main.vue
    file and look for the data function. Remove the line `products: {}`. We’ll now
    access it from a computed property that returns the store.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '我们越来越接近目标，现在我们只需要更新 Main.vue 文件，使其使用 Vuex store 而不是本地产品对象。打开 src/components/Main.vue
    文件并查找 data 函数。删除 `products: {}` 这一行。现在我们将从返回存储的计算属性中访问它。'
- en: Look for the computed properties after the methods inside Main.vue. You should
    see `cartItemCount` and `sortedProducts`. Add a new computed property called `products`
    and have it return the products `getter`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Main.vue 中的方法之后查找计算属性。你应该能看到 `cartItemCount` 和 `sortedProducts`。添加一个新的计算属性名为
    `products`，并让它返回产品 `getter`。
- en: Keep in mind that because we added the store to the root Vue.js instance in
    the main.js file, we don’t have to do any special imports. Also, the store is
    always accessed by `this.$store` when using Vue-CLI. Make sure to remember the
    dollar sign or you’ll get an error. Add the products computed property to the
    Main.vue file, as shown here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，因为我们已经在 main.js 文件中将 store 添加到根 Vue.js 实例中，所以我们不需要进行任何特殊的导入。此外，当使用 Vue-CLI
    时，store 总是通过 `this.$store` 访问。确保记住美元符号，否则你会得到一个错误。将产品计算属性添加到 Main.vue 文件中，如这里所示。
- en: 'Listing 10.11\. Adding product’s computed property: chapter-10/computed-petstore.html'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 添加产品的计算属性：chapter-10/computed-petstore.html
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* The computed property for the Main.vue file**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Main.vue 文件的计算属性**'
- en: '***2* The computed property for products returns getters for products.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 产品计算属性返回产品的 getter。**'
- en: Locate the created hook that initialized the products object. Delete the contents
    of that object and instead have it call the `initStore` action we created earlier
    in the Vuex store. As we did with our previous example, use `dispatch` to trigger
    the action. Update the created hook inside the Main.vue file so it triggers the
    Vuex `initStore` action, as shown in this listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到初始化产品对象所创建的钩子。删除该对象的内容，并改为调用我们在 Vuex 存储中之前创建的 `initStore` 动作。像我们之前的示例一样，使用
    `dispatch` 触发动作。更新 Main.vue 文件中的创建钩子，使其触发 Vuex 的 `initStore` 动作，如本列表所示。
- en: 'Listing 10.12\. Updating created hook: chapter-10/created-petstore.html'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. 更新创建钩子：chapter-10/created-petstore.html
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Dispatches the code to initialize the Vuex store**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 分发代码以初始化 Vuex 存储**'
- en: That should be it. Run `npm run dev` from the console and you should see a window
    open with the pet store application. Try adding items to the cart and verify that
    all is working. If things aren’t working, check the console for errors. It’s easy
    to accidentally type `Vuex.store` instead of `Vuex.Store` inside the src/store/store.js
    file. Beware of these problems!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应该就是这样了。从控制台运行 `npm run dev`，你应该会看到一个打开的窗口，其中包含宠物商店应用程序。尝试向购物车添加商品并验证一切是否正常工作。如果事情没有按预期进行，请检查控制台中的错误。很容易不小心在
    src/store/store.js 文件中将 `Vuex.store` 键入为 `Vuex.Store`。小心这些问题！
- en: 10.5\. Vuex helpers
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. Vuex 辅助函数
- en: Vuex gives us a handful of helpers that can be used to reduce the amount of
    verbosity and repetition when adding getters, setters, mutations, and actions
    to our application. You can find a full list of all the Vuex helpers in the official
    guides at [https://vuex.vuejs.org/en/core-concepts.html](https://vuex.vuejs.org/en/core-concepts.html).
    Let’s look at these helpers and see how they work.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 提供了一些辅助函数，可以用来减少在添加 getter、setter、mutations 和 actions 到我们的应用程序时的冗长和重复。您可以在官方指南中找到所有
    Vuex 辅助函数的完整列表，网址为 [https://vuex.vuejs.org/en/core-concepts.html](https://vuex.vuejs.org/en/core-concepts.html)。让我们来看看这些辅助函数，看看它们是如何工作的。
- en: The first helper you should know about is `mapGetters`. This helper is used
    to add all our getters to our computed properties, without having to type every
    one of them. To use `mapGetters` we’ll need to import it into our component first.
    Let’s look at our pet store application one more time and add in the `mapGetters`
    helper.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解的第一个辅助函数是 `mapGetters`。这个辅助函数用于将所有我们的 getter 添加到我们的计算属性中，而无需逐个输入它们。要使用
    `mapGetters`，我们首先需要将其导入到我们的组件中。让我们再次查看我们的宠物商店应用程序，并添加 `mapGetters` 辅助函数。
- en: Open the src/components/Main.vue file and look for the script tag. Inside that
    tag you should see an import for the header component. Right after that import,
    add in the `mapGetters` from Vuex as seen here.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/components/Main.vue 文件，查找 script 标签。在该标签内部，你应该看到一个对头部组件的导入。在那之后导入，添加
    Vuex 的 `mapGetters`，如这里所示。
- en: 'Listing 10.13\. Adding `mapGetters`: chapter-10/map-getter.html'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. 添加 `mapGetters`：chapter-10/map-getter.html
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Imports the mapGetters from Vuex**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 Vuex 导入 mapGetters**'
- en: Next, we’ll need to update our computed property. Look for the computed property
    for `products` that we added earlier. Delete it and add a new `mapGetters` object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的计算属性。寻找我们之前添加的 `products` 计算属性。删除它并添加一个新的 `mapGetters` 对象。
- en: The `mapGetters` object is unique and to add it correctly, we need to use the
    ES6 `spread` operator which expands our expression in places where zero or more
    arguments are expected. You can find more information on the ES6 spread syntax
    from the MDN docs at [http://mng.bz/b0J8](http://mng.bz/b0J8).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapGetters` 对象是独特的，为了正确添加它，我们需要使用 ES6 的 `spread` 操作符，该操作符在期望零个或多个参数的地方扩展我们的表达式。您可以在
    MDN 文档中找到有关 ES6 扩展语法的更多信息，网址为 [http://mng.bz/b0J8](http://mng.bz/b0J8)。'
- en: The `mapGetters` will make sure that all our getters will be added as if they
    were computed properties. As you can imagine, this syntax is much simpler and
    cleaner than having to write a computed property for each getter. Each getter
    is listed in an array inside `mapGetters`. Add the `mapGetters` to the Main.vue
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapGetters` 将确保所有我们的 getter 都会被添加，就像它们是计算属性一样。正如你可以想象的那样，这种语法比为每个 getter 编写一个计算属性要简单得多、干净得多。每个
    getter 都列在 `mapGetters` 内部的数组中。将 `mapGetters` 添加到 Main.vue 文件中。'
- en: 'Listing 10.14\. Adding `mapGetters` to computed properties: chapter-10/map-getter2.html'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 将 `mapGetters` 添加到计算属性：chapter-10/map-getter2.html
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Shows the mapGetters helper array**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示 mapGetters 辅助数组**'
- en: '***2* Shows the list of getters**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示 getter 列表**'
- en: If you run `npm run dev`, you’ll see that our pet store application runs normally.
    Using `mapGetters` in our application isn’t too useful, but as it grows and we
    add more getters, this will save us time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `npm run dev`，你会看到我们的宠物商店应用程序正常运行。在我们的应用程序中使用 `mapGetters` 并不是非常有用，但随着它的增长和更多
    getters 的添加，这将节省我们时间。
- en: The other three helpers you should know about are `mapState`, `mapMutations`,
    and `mapActions`. All three behave the same way and are useful to help reduce
    the amount of boilerplate code you need to write.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该了解的其他三个辅助函数是 `mapState`、`mapMutations` 和 `mapActions`。这三个函数的行为相同，并且有助于减少你需要编写的样板代码量。
- en: Let’s imagine you have several pieces of data in your store. In this instance,
    you don’t need any getters and you’ll be accessing the state directly from your
    component. In this case, you might use the `mapState` helper inside your computed
    properties.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你在你的 store 中有若干数据。在这个例子中，你不需要任何 getters，你将直接从你的组件中访问状态。在这种情况下，你可能会在你的计算属性中使用
    `mapState` 辅助函数。
- en: 'Listing 10.15\. `mapState` example: chapter-10/map-state.html'
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. `mapState` 示例：chapter-10/map-state.html
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Imports mapState from Vuex**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 Vuex 导入 mapState**'
- en: '***2* Uses the spread operator to define mapState and variables**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用展开运算符定义 mapState 和变量**'
- en: As with `mapState` and `mapGetters`, let’s say you also have several mutations
    you want access to in your component. You can use the `mapMutations` helper method
    to make this easy (shown in the following listing). The `mut1` in the listing
    maps `this.mut1()` to `'this.$store.commit('mut1')`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `mapState` 和 `mapGetters` 类似，假设你也在你的组件中想要访问几个 mutations。你可以使用 `mapMutations`
    辅助函数来简化这个过程（如下面的列表所示）。列表中的 `mut1` 将 `this.mut1()` 映射到 `'this.$store.commit('mut1')`。
- en: 'Listing 10.16\. `mapMutations` example: chapter-10/map-mut.html'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.16\. `mapMutations` 示例：chapter-10/map-mut.html
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Imports mapMutations from Vuex into component**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 mapMutations 从 Vuex 导入到组件中**'
- en: '***2* The mapMutations helper adds these methods.**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* mapMutations 辅助函数添加了这些方法。**'
- en: Finally, we’ll look at the `mapActions` helper. This helper maps actions to
    our app, so we don’t have to create every method and have it dispatch each action.
    Using the same example, let’s say this application also has some asynchronous
    operations. We can’t use mutations, so we must use actions instead. We created
    these in Vuex and now we need to access them in our component method object. Adding
    `mapActions` to our methods will take care of this. The `act1` maps `this.act1()`
    to `this.$store.dispatch('act1')`, as shown in [listing 10.17](#ch10ex17).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看 `mapActions` 辅助函数。这个辅助函数将 actions 映射到我们的应用中，这样我们就不需要创建每个方法并分别分发每个动作。使用相同的例子，假设这个应用程序也有一些异步操作。我们不能使用
    mutations，所以我们必须使用 actions。我们在 Vuex 中创建了这些，现在我们需要在我们的组件方法对象中访问它们。将 `mapActions`
    添加到我们的方法中会处理这个问题。`act1` 将 `this.act1()` 映射到 `this.$store.dispatch('act1')`，如[列表
    10.17](#ch10ex17)所示。
- en: 'Listing 10.17\. `mapActions` example: chapter-10/map-actions.html'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17\. `mapActions` 示例：chapter-10/map-actions.html
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Imports the mapActions from Vuex**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 Vuex 导入 mapActions**'
- en: '***2* The mapActions helper adds the act1, act2, and act3 methods.**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* mapActions 辅助函数添加了 act1、act2 和 act3 方法。**'
- en: These helpers will come in handy as your application grows, and it will cut
    down on the amount of code you need to write. Keep in mind that you’ll need to
    plan the names in your store because they’ll map out to the names in your components
    as you use these helpers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序增长时，这些辅助函数将非常有用，并且会减少你需要编写的代码量。请记住，你需要在你的 store 中规划名称，因为当你使用这些辅助函数时，它们会映射到你的组件中的名称。
- en: 10.6\. A quick look at modules
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6\. 模块快速浏览
- en: In the earlier sections of this chapter, we created a store.js file in the src/store
    directory for the pet store application. This worked well for our relatively small
    application. However, what if our application were much larger? The store.js file
    would quickly become bloated and it would be difficult to keep track of everything
    in it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们在 src/store 目录中为宠物商店应用程序创建了一个 store.js 文件。这对我们的相对较小的应用程序来说效果很好。然而，如果我们的应用程序更大呢？store.js
    文件会很快变得臃肿，并且很难跟踪其中的所有内容。
- en: The Vuex solution for this is *modules*. Modules allow us to divide our store
    into smaller pieces. Each module has its own state, mutations, actions, and getters,
    and you can even nest modules inside it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 的解决方案是 *模块*。模块允许我们将 store 划分为更小的部分。每个模块都有自己的状态、mutations、actions 和 getters，你甚至可以在其中嵌套模块。
- en: Let’s refactor our pet store application to use modules. First, we’ll need to
    keep our store.js file; however, we need to create a new folder named modules
    inside our store folder. Inside that folder create a file called products.js.
    The folder structure should look like [figure 10.6](#ch10fig06).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将宠物商店应用程序重构为使用模块。首先，我们需要保留 store.js 文件；然而，我们需要在 store 文件夹内创建一个名为 modules
    的新文件夹。在那个文件夹内创建一个名为 products.js 的文件。文件夹结构应该看起来像 [图 10.6](#ch10fig06)。
- en: Figure 10.6\. Folder structure for modules
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 模块文件夹结构
- en: '![](10fig06_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig06_alt.jpg)'
- en: 'Inside the products.js file, we’ll need to create four objects: state, getters,
    actions, and mutations. We’ll need to copy and paste each of the values from our
    store.js to the products.js file.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 products.js 文件中，我们需要创建四个对象：state、getters、actions 和 mutations。我们需要将 store.js
    中的每个值复制粘贴到 products.js 文件中。
- en: Open the src/store/store.js file and start copying over the code. When you’re
    done, your products.js file should look like the following listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/store/store.js 文件并开始复制代码。完成后，你的 products.js 文件应该看起来像以下列表。
- en: 'Listing 10.18\. Adding products modules: chapter-10/products-mod.js'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18\. 添加产品模块：chapter-10/products-mod.js
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Holds all the Vuex state**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含所有 Vuex 状态**'
- en: '***2* Holds all the Vuex getters**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含所有 Vuex getters**'
- en: '***3* Holds all the Vuex actions**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含所有 Vuex actions**'
- en: '***4* Holds all the Vuex mutations**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 包含所有 Vuex mutations**'
- en: After adding everything to the product.js file, we need to create an export.
    This will allow the file to be imported into the store.js file. At the bottom
    of the file, add an `export default`. This is an ES6 export command that allows
    you to import it from other files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有内容添加到 product.js 文件后，我们需要创建一个导出。这将允许文件被导入到 store.js 文件中。在文件底部添加 `export
    default`。这是一个 ES6 导出命令，允许你从其他文件导入它。
- en: At the bottom of product.js, add the `default export`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 product.js 的底部添加 `default export`。
- en: 'Listing 10.19\. Adding the export: chapter-10/products-export.js'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.19\. 添加导出：chapter-10/products-export.js
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Shows the ES6 export of everything**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示所有内容的 ES6 导出**'
- en: We’ll need to update the store.js file. In this file we’ll add a new module
    object, and in this object, we can list all the modules we added. Make sure to
    add an import to the modules/products file we created.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新 store.js 文件。在这个文件中，我们将添加一个新的模块对象，在这个对象中，我们可以列出我们添加的所有模块。确保添加对创建的 modules/products
    文件的导入。
- en: In our case, we have only one, so we’ll go ahead and add it into the module
    object. Make sure to delete everything in the `Vuex.Store` so it matches the following
    listing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只有一个，所以我们将继续将其添加到模块对象中。确保删除 `Vuex.Store` 中的所有内容，使其与以下列表匹配。
- en: 'Listing 10.20\. New store.js file: chapter-10/store-update.js'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.20\. 新的 store.js 文件：chapter-10/store-update.js
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Imports the products module**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入产品模块**'
- en: '***2* The modules object lists all modules.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模块对象列出所有模块。**'
- en: Once we have the modules imported, we’re ready to go. Refresh the application
    and it should behave as it always has.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了模块，我们就可以开始了。刷新应用程序，它应该像以前一样运行。
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Namespaces with Vuex**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Vuex 的命名空间**'
- en: In certain larger applications, breaking up your store into modules might present
    a problem. As the program grows and more modules are added, the names of your
    actions, getters, mutations, and state might collide. You might, for example,
    name two getters with the same name in two different files accidentally. Because
    everything in Vuex shares the same global namespace, you’ll get a duplicate getter
    key error in your console when this happens.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些较大的应用程序中，将 store 划分为模块可能会带来问题。随着程序的增长和更多模块的添加，你的 actions、getters、mutations
    和 state 的名称可能会冲突。例如，你可能会不小心在两个不同的文件中命名两个具有相同名称的 getters。由于 Vuex 中的所有内容都共享相同的全局命名空间，当这种情况发生时，你将在控制台中收到重复的
    getter 键错误。
- en: 'To alleviate this problem, you can use namespaces. By setting the `namespaced:
    true` at the top of your Vuex.store you can break up your modules per namespace.
    To learn more about namespaces and how to set this up in your file, please check
    out the Vuex official documentation at [https://vuex.vuejs.org/en/modules.html](https://vuex.vuejs.org/en/modules.html).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '为了解决这个问题，你可以使用命名空间。通过在 Vuex.store 的顶部设置 `namespaced: true`，你可以根据命名空间划分你的模块。要了解更多关于命名空间以及如何在文件中设置它，请查看
    Vuex 官方文档 [https://vuex.vuejs.org/en/modules.html](https://vuex.vuejs.org/en/modules.html)。'
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exercise
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer this question:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这个问题：
- en: What are several advantages of using Vuex over the normal data passing of a
    Vue.js application?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vuex 相比 Vue.js 应用程序的正常数据传递有哪些优点？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅附录B中的解决方案[appendix B](kindle_split_026.html#app02)。*'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can restructure your application to use centralized state management.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将你的应用程序重构为使用集中式状态管理。
- en: You can access the data store inside the application from anywhere.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从应用程序的任何地方访问数据存储。
- en: You can avoid problems with your application store getting out of sync by using
    mutations and actions with Vuex.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用Vuex中的mutations和actions来避免应用程序存储不同步的问题。
- en: You can use Vuex helpers to reduce the amount of boilerplate code needed.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Vuex助手来减少所需的样板代码量。
- en: In larger applications, you can use modules and namespaces to keep state more
    manageable.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型应用中，你可以使用模块和命名空间来使状态更易于管理。
- en: Chapter 11\. Communicating with a server
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章. 与服务器通信
- en: '*This chapter covers*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using Nuxt.js for server-side rendering
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nuxt.js进行服务器端渲染
- en: Retrieving third-party data with Axios
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Axios检索第三方数据
- en: Using VuexFire
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VuexFire
- en: Adding authentication
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: We’ve discussed Vuex and how state management can benefit our larger Vue.js
    applications. Now we’re going to look at communicating with a server. In this
    chapter, we’ll look at server-side rendering (SSR) and how we can use it to help
    improve our app’s responsiveness. We’ll use Axios to retrieve data from a third-party
    API. Then we’ll look at VuexFire. VuexFire is library that helps us communicate
    with Firebase, a backend service that helps with application development. Last,
    we’ll see how to add simple authentication to our VuexFire app.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Vuex以及状态管理如何使我们的Vue.js大型应用受益。现在我们将探讨与服务器通信。在本章中，我们将探讨服务器端渲染（SSR）以及我们如何使用它来帮助提高我们应用的响应速度。我们将使用Axios从第三方API检索数据。然后我们将探讨VuexFire。VuexFire是一个库，帮助我们与Firebase通信，这是一个帮助应用开发的后端服务。最后，我们将看到如何向我们的VuexFire应用添加简单的身份验证。
- en: Before we move on, let me preface this chapter by saying there are many ways
    to communicate with a server in Vue.js. We could use an `XMLHttpRequest` or use
    any number of AJAX libraries out there. In the past, Vue officially recommended
    the Vue resource library as the official AJAX library. Evan You, the creator of
    Vue, retired the library in late 2016 from official recommendation status. As
    far as the Vue community goes, you can use whatever library you like.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我先说明一下，在Vue.js中与服务器通信有许多方法。我们可以使用`XMLHttpRequest`或使用任何数量的AJAX库。在过去，Vue官方推荐Vue资源库作为官方AJAX库。Vue的创造者Evan
    You在2016年底将其从官方推荐状态中退役。至于Vue社区，你可以使用你喜欢的任何库。
- en: With all that said, I determined that Axios, Nuxt.js, and VuexFire are several
    of the most popular libraries that could help us communicate with a server in
    one way or another. They’re all different, however. Nuxt.js is a powerful framework
    for creating server-rendered apps, but Axios is a frontend HTTP client. VuexFire
    helps us communicate with Firebase. All three take different approaches to communication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我确定Axios、Nuxt.js和VuexFire是几个可以帮助我们以某种方式与服务器通信的最受欢迎的库。然而，它们各不相同。Nuxt.js是一个用于创建服务器端渲染应用的强大框架，而Axios是一个前端HTTP客户端。VuexFire帮助我们与Firebase通信。这三个库在通信方面采取了不同的方法。
- en: The purpose of this chapter is to give you working knowledge of all three of
    these libraries and frameworks. We’ll create examples for each, but we won’t go
    too deep. Each subject could warrant its own chapter—and in the case of Nuxt,
    its own book. Nevertheless, this will be a good primer for these topics, and I’ll
    include links to each resource, so you can dive in deeper.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是让你对这三个库和框架有实际的操作知识。我们将为每个库创建示例，但不会深入探讨。每个主题都值得单独成章——在Nuxt的情况下，甚至可以单独成书。尽管如此，这将是一个很好的入门，我还会包括每个资源的链接，以便你可以深入了解。
- en: 11.1\. Server-side rendering
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 服务器端渲染
- en: Vue.js is a single-page application framework that uses client-side rendering.
    The logic and routing of the application are written in JavaScript. When the browser
    connects to the server, the JavaScript is downloaded. The browser is then responsible
    for rendering the JavaScript and executing the Vue.js application. With larger
    applications, the time to download and render the application can be significant.
    You can see from [figure 11.1](#ch11fig01) how this might look.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js是一个使用客户端渲染的单页应用程序框架。应用程序的逻辑和路由是用JavaScript编写的。当浏览器连接到服务器时，JavaScript将被下载。然后浏览器负责渲染JavaScript并执行Vue.js应用。对于大型应用，下载和渲染应用的时间可能会很长。你可以从[图11.1](#ch11fig01)中看到这可能会是什么样子。
- en: Figure 11.1\. Client-side rendering
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. 客户端渲染
- en: '![](11fig01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig01.jpg)'
- en: Server-side rendering (SSR) with Vue.js is different. In this case, Vue.js reaches
    out to the server, which then sends over the HTML so the browser can display the
    page immediately. The user sees the page load quickly. The server then sends the
    JavaScript, and it loads in the background. It’s worth mentioning that even if
    the user sees the webpage, they may not interact with it until Vue is done executing
    ([figure 11.2](#ch11fig02)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中，服务器端渲染（SSR）有所不同。在这种情况下，Vue.js 会连接到服务器，然后服务器发送 HTML，以便浏览器可以立即显示页面。用户看到页面快速加载。然后服务器发送
    JavaScript，并在后台加载。值得一提的是，即使用户看到了网页，他们也可能直到 Vue 执行完毕才与之交互（[图 11.2](#ch11fig02)）。
- en: Figure 11.2\. Server-side rendering
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.2\. 服务器端渲染
- en: '![](11fig02.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig02.jpg)'
- en: Typically, SSR is a more pleasant experience for the user because the initial
    load is fast. Most users don’t have the patience to wait for slow apps to load.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，SSR（服务器端渲染）为用户提供了更愉悦的体验，因为初始加载速度快。大多数用户没有耐心等待缓慢的应用程序加载。
- en: SSR also has unique advantages for *search engine optimization* (SEO). SEO is
    a term that describes getting organic visibility (non-paid) on search-engine results.
    Although little is known of the precise methods Google and other search engines
    use when determining search-engine rankings, there’s a worry that search-engine
    robots have problems when crawling client-side rendered pages. This could cause
    issues with rankings. SSR helps prevent these problems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SSR 对于搜索引擎优化（SEO）也有独特的优势。SEO 是一个描述在搜索引擎结果中获得有机可见性（非付费）的术语。尽管对谷歌和其他搜索引擎在确定搜索引擎排名时使用的精确方法知之甚少，但存在一种担忧，即搜索引擎机器人爬取客户端渲染的页面时可能会出现问题。这可能会影响排名。SSR
    有助于防止这些问题。
- en: Vue.js doesn’t come with SSR by itself, but there are great libraries that make
    it easy to add SSR to our app. The two most popular are vue-server-renderer and
    Nuxt.js. You can find more information on SSR from the official SSR guides at
    [https://ssr.vuejs.org/](https://ssr.vuejs.org/). Instead. we’ll look at how we
    can create an SSR app using Nuxt.js.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 本身不包含 SSR，但有一些优秀的库可以轻松地将 SSR 添加到我们的应用程序中。其中最受欢迎的是 vue-server-renderer
    和 Nuxt.js。您可以在官方 SSR 指南 [https://ssr.vuejs.org/](https://ssr.vuejs.org/) 中找到更多关于
    SSR 的信息。相反，我们将探讨如何使用 Nuxt.js 创建一个 SSR 应用程序。
- en: 11.2\. Introducing Nuxt.js
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 介绍 Nuxt.js
- en: Nuxt.js is a higher-level framework built on top of the Vue ecosystem that helps
    create SSR applications without having to worry about all the aspects of delivering
    a production-ready, server-rendered app.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt.js 是建立在 Vue 生态系统之上的一个高级框架，它帮助创建 SSR 应用程序，无需担心交付一个生产就绪、服务器端渲染应用程序的所有方面。
- en: Nuxt focuses on UI rendering, and much of the client/server layer is abstracted
    away. It can act as a standalone project or an addition to a Node.js-based project.
    In addition, it has a built-in static generator that can be used to create Vue.js
    websites.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt 专注于 UI 渲染，并且大部分客户端/服务器层都被抽象化。它可以作为一个独立项目，也可以作为基于 Node.js 的项目的补充。此外，它还内置了一个静态生成器，可以用来创建
    Vue.js 网站。
- en: When you create a project with Nuxt, you get Vue 2, the Vue router, Vuex, vue-server-renderer,
    and vue-meta. Under the hood it uses Webpack to help put everything together.
    It’s an all-in-one package for getting up and running.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Nuxt 创建项目时，您将获得 Vue 2、Vue 路由、Vuex、vue-server-renderer 和 vue-meta。在底层，它使用
    Webpack 来帮助整合一切。这是一个一站式包，用于快速启动。
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Info
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: We can use Nuxt with an existing Node.js application but we won’t look at that
    today. If you want more information on creating a Nuxt app with an existing Node.js
    project, check the official documentation at [https://nuxtjs.org/guide/installation](https://nuxtjs.org/guide/installation).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Nuxt 与现有的 Node.js 应用程序一起使用，但今天我们不会探讨这一点。如果您想了解更多关于使用现有 Node.js 项目创建 Nuxt
    应用程序的信息，请查看官方文档 [https://nuxtjs.org/guide/installation](https://nuxtjs.org/guide/installation)。
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Nuxt provides a starter template to help us get started. This starter template
    can be downloaded from the official GitHub repository at [http://mng.bz/w0YV](http://mng.bz/w0YV).
    We can also create a project using the starter template with Vue-CLI. (If you
    haven’t installed Vue-CLI, see [appendix A](kindle_split_025.html#app01) for installation
    instructions.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt 提供了一个启动模板来帮助我们开始。这个启动模板可以从官方 GitHub 仓库下载，网址为 [http://mng.bz/w0YV](http://mng.bz/w0YV)。我们也可以使用
    Vue-CLI 通过启动模板创建一个项目。（如果您还没有安装 Vue-CLI，请参阅[附录 A](kindle_split_025.html#app01)中的安装说明。）
- en: If you’re using Nuxt, you’ll need Node. Nuxt requires version 8 or later to
    work. Otherwise, you’ll get async errors when you try to start the project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Nuxt，你需要 Node。Nuxt 需要 8 或更高版本才能工作。否则，当你尝试启动项目时，你会得到异步错误。
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Info
- en: The project listed in this chapter is working on Nuxt 1.0\. But as of this writing,
    Nuxt 2.0 is in development and in beta. This example should work on both but if
    you encounter any problems, check the official GitHub repository for this book
    at [https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode).
    This code will be maintained.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中列出的项目正在使用 Nuxt 1.0。但截至本文写作时，Nuxt 2.0 正在开发中，处于测试版。这个例子应该适用于两者，但如果遇到任何问题，请检查本书的官方
    GitHub 仓库：[https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode)。此代码将得到维护。
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'We’ll use the Vue-CLI to create a project. At the command prompt, run the following
    command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Vue-CLI 来创建项目。在命令提示符中，运行以下命令：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will create a new Nuxt project using the starter template. Next, you’ll
    need to change into the directory and install the dependencies with the following
    commands:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用启动模板创建一个新的 Nuxt 项目。接下来，你需要切换到目录并使用以下命令安装依赖项：
- en: '[PRE22]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To launch the project, run the `npm run dev` command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动项目，运行 `npm run dev` 命令：
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will start a new project on localhost port 3000\. If you open a web browser,
    you should see the welcome page ([figure 11.3](#ch11fig03)). If the welcome page
    isn’t displayed, double-check to make sure you didn’t skip the `npm install` step.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地主机端口 3000 上启动一个新的项目。如果你打开一个网页浏览器，你应该能看到欢迎页面（[图 11.3](#ch11fig03)）。如果欢迎页面没有显示，请再次检查以确保你没有跳过
    `npm install` 步骤。
- en: Figure 11.3\. Nuxt.js starter template page
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.3\. Nuxt.js 启动模板页面
- en: '![](11fig03_alt.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig03_alt.jpg)'
- en: Let’s look at how to use Nuxt.js in a real app.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在真实的应用程序中使用 Nuxt.js。
- en: 11.2.1\. Creating a music search app
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 创建音乐搜索应用程序
- en: Server-side rendered apps can be useful and powerful. Let’s look at what Nuxt.js
    can do for us. Let’s imagine you need to create an app that interacts with the
    iTunes API. The iTunes API has a list of millions of artists and albums. You want
    to search for any artist and display their discography.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的应用程序可以非常有用且强大。让我们看看 Nuxt.js 能为我们做什么。让我们想象你需要创建一个与 iTunes API 交互的应用程序。iTunes
    API 有数百万个艺术家和专辑。你想要搜索任何艺术家并显示他们的唱片目录。
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Note
- en: You can find more information on the iTunes API in the official documentation
    at [http://mng.bz/rm99](http://mng.bz/rm99).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到有关 iTunes API 的更多信息：[http://mng.bz/rm99](http://mng.bz/rm99)。
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In building our app, we’ll use two different routes. The first route will display
    an input box for searching the iTunes API. This page will look like [figure 11.4](#ch11fig04).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序时，我们将使用两个不同的路由。第一个路由将显示一个用于搜索 iTunes API 的输入框。这个页面看起来像 [图 11.4](#ch11fig04)。
- en: Figure 11.4\. Search page for the iTunes API
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4\. iTunes API 的搜索页面
- en: '![](11fig04_alt.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig04_alt.jpg)'
- en: The next route will display the artist’s album information.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个路由将显示艺术家的专辑信息。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Info
- en: To make things look nicer, we’ll use a material component framework called Vuetify.
    We’ll talk more about that later.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情看起来更美观，我们将使用一个名为 Vuetify 的材料组件框架。我们稍后会更多地讨论这一点。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To make things more interesting, we’ll pass information from our search route
    into the results route by using a parameter. After entering an artist’s name in
    the search box (Taylor Swift), the results page will be displayed ([figure 11.5](#ch11fig05)).
    You can see in the URL box at the top of the page that “Taylor%20Swift” has been
    passed in.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，我们将通过使用参数将搜索路由中的信息传递到结果路由。在搜索框中输入艺术家名称（泰勒·斯威夫特）后，结果页面将显示（[图 11.5](#ch11fig05)）。你可以在页面顶部的
    URL 框中看到“Taylor%20Swift”已被传递。
- en: Figure 11.5\. Search results page
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. 搜索结果页面
- en: '![](11fig05_alt.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig05_alt.jpg)'
- en: The search page will display all the albums associated with the artist. It will
    display the album name, artist name, and the cover art, and the card will link
    to the iTunes artist page. In this example we’ll also look at middleware, which
    will allow us to write code before the route is rendered. We’ll see how we can
    use the Axios library to communicate with the iTunes API. We’ll wrap everything
    up by looking at Vuex again.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索页面将显示与艺术家相关的所有专辑。它将显示专辑名称、艺术家名称和封面艺术，卡片将链接到 iTunes 艺术家页面。在这个例子中，我们还将看看中间件，这将允许我们在路由渲染之前编写代码。我们将看到如何使用
    Axios 库与 iTunes API 进行通信。我们将通过再次查看 Vuex 来总结一切。
- en: 11.2.2\. Creating a project and installing dependencies
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 创建项目和安装依赖项
- en: 'Let’s begin creating our music API app by using the Vue-CLI starter template.
    We’ll then install all our dependencies. Run the following command at the prompt:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 Vue-CLI 起始模板来开始创建我们的音乐 API 应用程序。然后我们将安装所有依赖项。在提示符下运行以下命令：
- en: '[PRE24]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the application is created, install Vuetify and Axios as an npm package
    using the `npm install` command. In addition, Vuetify requires both the stylus
    and stylus-loader so we can set up our stylus CSS that Vuetify uses.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建后，使用 `npm install` 命令安装 Vuetify 和 Axios 作为 npm 包。此外，Vuetify 需要 stylus
    和 stylus-loader，因此我们可以设置 Vuetify 使用的 stylus CSS。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Vuetify is a material component framework for Vue.js 2.0\. It adds many easy-to-use
    and beautifully crafted components. It has similarities to other UI frameworks,
    such as Bootstrap. You can find more about Vuetify at the official website at
    [https://vuetifyjs.com](https://vuetifyjs.com).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Vuetify 是 Vue.js 2.0 的一个材料组件框架。它添加了许多易于使用且美观的组件。它与其他 UI 框架（如 Bootstrap）有相似之处。您可以在官方网站
    [https://vuetifyjs.com](https://vuetifyjs.com) 上了解更多关于 Vuetify 的信息。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Run the following commands to install Vuetify, Axios, stylus, and stylus-loader:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 Vuetify、Axios、stylus 和 stylus-loader：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will install all the dependencies we need to get started, but to get these
    dependencies to work correctly, we’ll need a little more setup. We’re going to
    set up Axios and Vuetify in our vendor file, register Vuetify inside our app,
    set up the Vuetify plugin, and finally set up our CSS and fonts.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们开始所需的全部依赖项，但要使这些依赖项正常工作，我们还需要进行一些额外的设置。我们将在供应商文件中设置 Axios 和 Vuetify，在应用程序内部注册
    Vuetify，设置 Vuetify 插件，并最终设置我们的 CSS 和字体。
- en: The nuxt.config.js file is used to configure the Nuxt app, so navigate to the
    nuxt.config.js file in the root of the /itunes-search folder. Find the section
    that begins with `extend (config, ctx)`. This section is used to automatically
    run `ESLint` on our code every time we save. (`ESLint` is a pluggable linting
    utility that checks our code for style and formatting, among other things.) We
    could edit the .eslintrc.js file and change the default linting, but for the sake
    of simplicity, we’ll delete this section instead. This will turn off the automatic
    linting. Next add a new vendor option under `build`. We then need to add Axios
    and Vuetify to the vendor option, as seen in [listing 11.1](#ch11ex01).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: nuxt.config.js 文件用于配置 Nuxt 应用程序，因此请导航到 /itunes-search 文件夹根目录下的 nuxt.config.js
    文件。找到以 `extend (config, ctx)` 开头的部分。此部分用于在每次保存代码时自动运行 `ESLint`。（`ESLint` 是一个可插拔的代码检查工具，它检查我们的代码的样式和格式，以及其他方面。）我们可以编辑
    .eslintrc.js 文件并更改默认的代码检查，但为了简单起见，我们将删除此部分。这将关闭自动代码检查。接下来，在 `build` 下添加一个新的供应商选项。然后我们需要将
    Axios 和 Vuetify 添加到供应商选项中，如 [列表 11.1](#ch11ex01) 所示。
- en: Let me explain how this works. Every time we import a module in Nuxt.js, the
    code is added to a page bundle that Webpack creates. This is a part of something
    called code splitting. Webpack splits our code into bundles, which then can be
    loaded on demand or in parallel. When we add the vendor option it makes sure that
    the code is only added once to the vendor bundle file. Otherwise each import would
    add to each page bundle and increase the size of the project. It’s good practice
    to always add your modules to the vendor option so it won’t get duplicated in
    your project. (Nuxt 2.0 no longer requires the vendor option. This can be removed.)
    Update the package.json file in the root /itunes-search folder with the new vendor
    options.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下这是如何工作的。每次我们在 Nuxt.js 中导入一个模块时，代码就会被添加到 Webpack 创建的页面包中。这是代码拆分的一部分。Webpack
    将我们的代码拆分成包，然后可以根据需要或并行加载。当我们添加供应商选项时，它确保代码只添加一次到供应商包文件中。否则，每个导入都会添加到每个页面包中，并增加项目的尺寸。始终将模块添加到供应商选项中是一个好习惯，这样它就不会在项目中重复。
    (Nuxt 2.0 不再需要供应商选项。这可以删除。) 使用新供应商选项更新根目录 /itunes-search 文件夹中的 package.json 文件。
- en: 'Listing 11.1\. Removing `ESLint` from nuxt.config.js: chapter-11/itunes-search/nuxt.config.js'
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.1\. 从 nuxt.config.js 中移除 `ESLint`：chapter-11/itunes-search/nuxt.config.js
- en: '[PRE26]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Adds Axios and Vuetify to vendor bundle and removes linting.**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Axios 和 Vuetify 添加到供应商包中并移除代码检查。**'
- en: Although we’ve added Axios and Vuetify as vendors, we’re not done. Vuetify requires
    a little more setup. We’ll need to add a plugins section to the nuxt.config.js
    file and add the plugin to the /plugins folder.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经将 Axios 和 Vuetify 添加为供应商，但我们还没有完成。Vuetify 需要更多的设置。我们需要在 nuxt.config.js
    文件中添加一个插件部分，并将插件添加到 /plugins 文件夹中。
- en: Plugins in Nuxt.js are a way of adding external modules to your application;
    they require a little more setup. Plugins run before the root Vue.js instance
    is instantiated. Unlike adding a vendor option, a corresponding file runs in the
    /plugins folder.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt.js 中的插件是将外部模块添加到应用程序的一种方式；它们需要更多的设置。插件在根 Vue.js 实例实例化之前运行。与添加供应商选项不同，相应的文件在
    /plugins 文件夹中运行。
- en: The official documentation for Vuetify recommends that we import Vuetify and
    tell Vue to use it as a plugin. We’ll add this code to our plugin file. Add a
    new file in the plugins folder, and name it vuetify.js. Inside the file, register
    Vuetify with Vue, as shown here.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Vuetify 的官方文档建议我们导入 Vuetify 并告诉 Vue 使用它作为插件。我们将在插件文件中添加此代码。在插件文件夹中添加一个新文件，并将其命名为
    vuetify.js。在文件内部，如所示，将 Vuetify 注册到 Vue 中。
- en: 'Listing 11.2\. Adding the Vuetify plugin: chapter-11/itunes-search/plugins/vuetify.js'
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 添加 Vuetify 插件：chapter-11/itunes-search/plugins/vuetify.js
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Adds Vuetify to Vue app**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Vuetify 添加到 Vue 应用程序**'
- en: Next, we’ll need to add a reference to the plugin in the nuxt.config.js. Open
    the nuxt.config.js file in the root of the app folder and add the plugins.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 nuxt.config.js 中添加对插件的引用。打开应用程序文件夹根目录下的 nuxt.config.js 文件，并添加插件。
- en: 'Listing 11.3\. Adding plugins reference: chapter-11/itunes-search/nuxt.config.js'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 添加插件引用：chapter-11/itunes-search/nuxt.config.js
- en: '[PRE28]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Notes the reference to the plugins file**'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录对插件文件的引用**'
- en: The last thing we need to do to get Vuetify working is to add CSS. The official
    documentation recommends that you import the material design icons from Google
    and add a link to the Vuetify CSS file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Vuetify 正常工作，我们最后需要做的是添加 CSS。官方文档建议您从 Google 导入材料设计图标，并添加对 Vuetify CSS 文件的链接。
- en: Remember earlier when we imported the stylus loader? Well now we can add a link
    to our own stylus file in the nuxt.config.js file. In the CSS block at the top,
    delete the main.css file, if it exists, and add a link to the app.styl file that
    we’ll create in a moment. Also, add a stylesheet in the head section for the Google
    material design icons. The completed nuxt.config.js file should look like this.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前导入 stylus loader 吗？现在我们可以在 nuxt.config.js 文件中添加对我们自己的 stylus 文件的链接。在 CSS
    块的顶部，如果存在，删除 main.css 文件，并添加对即将创建的 app.styl 文件的链接。此外，在 head 部分添加一个样式表用于 Google
    材料设计图标。完成的 nuxt.config.js 文件应如下所示。
- en: 'Listing 11.4\. Adding CSS and fonts: chapter-11/itunes-search/nuxt.config.js'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 添加 CSS 和字体：chapter-11/itunes-search/nuxt.config.js
- en: '[PRE29]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Adds a link to material design icons**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加对材料设计图标的链接**'
- en: '***2* Removes main.css and adds in a link to app.styl**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 移除 main.css 并添加对 app.styl 的链接**'
- en: Now we need to create the assets/app.styl file, as shown in the following listing.
    This will import the Vuetify styles for the app.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建 assets/app.styl 文件，如下所示。这将导入应用程序的 Vuetify 样式。
- en: 'Listing 11.5\. Adding CSS stylus: chapter-11/itunes-search/assets/app.styl'
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 添加 CSS stylus：chapter-11/itunes-search/assets/app.styl
- en: '[PRE30]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Imports the main CSS**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入主 CSS**'
- en: After this is done, run the `npm run dev` command and verify that you don’t
    see any errors in the console. If you do, open the nuxt.config.js file and check
    for any missing commas or typos. Also, make sure you’ve installed all the dependencies,
    including stylus and stylus-loader. Those must be installed for Vuetify to work.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，运行 `npm run dev` 命令，并验证控制台是否没有错误。如果有错误，请打开 nuxt.config.js 文件并检查是否有缺失的逗号或拼写错误。同时，请确保您已安装所有依赖项，包括
    stylus 和 stylus-loader。这些必须安装才能使 Vuetify 正常工作。
- en: 11.2.3\. Creating our building blocks and components
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 创建我们的构建块和组件
- en: Components are our building blocks of our application. It’s where we can split
    our app into distinct parts that we can build back together. Before we build our
    routes, you may have noticed that there’s a components folder. This folder is
    where we can put all our normal, plain components.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是我们应用程序的构建块。这是我们可以将我们的应用程序分割成不同的部分，然后再将它们组合起来的地方。在我们构建路由之前，您可能已经注意到有一个组件文件夹。这个文件夹是我们存放所有正常、普通组件的地方。
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Nuxt.js gives us two different types of components. One is *supercharged* and
    the other is not. Supercharged components have access to special Nuxt-only configurations
    and are all located in the pages folder. These options let you access server-side
    data. The pages directory is also where we set up our routes and where our index
    component is located.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt.js 给我们两种不同类型的组件。一种是被“超级充电”的，另一种则不是。超级充电组件可以访问特殊的 Nuxt-only 配置，并且都位于 pages
    文件夹中。这些选项允许您访问服务器端数据。pages 目录也是我们设置路由和 index 组件所在的地方。
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In this section, we’ll discuss using the components in the components folder.
    We’ll create two components for our iTunes search application: `Card`, which will
    hold the information for each artist album that we find, and `Toolbar`. The `Toolbar`
    component will create a simple toolbar that will be displayed at the top of each
    route. We’ll use Vuetify to help create both components. I’ll show you the HTML
    and CSS for these using Vuetify, but we won’t go into much detail.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用组件文件夹中的组件。我们将为我们的 iTunes 搜索应用程序创建两个组件：`Card`，它将保存我们找到的每个艺术家专辑的信息，以及
    `Toolbar`。`Toolbar` 组件将创建一个简单的工具栏，它将显示在每个路由的顶部。我们将使用 Vuetify 来帮助创建这两个组件。我将使用 Vuetify
    展示这些组件的 HTML 和 CSS，但不会深入细节。
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’d like to explore all the options of Vuetify, I recommend you read through
    the quickstart guide at [https://vuetifyjs.com/vuetify/quick-start](https://vuetifyjs.com/vuetify/quick-start).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索 Vuetify 的所有选项，我建议你阅读 [https://vuetifyjs.com/vuetify/quick-start](https://vuetifyjs.com/vuetify/quick-start)
    中的快速入门指南。
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Create a file, Toolbar.vue, in the components folder. This file will hold our
    Toolbar template. Inside this template we’ll use several of Vuetify’s built-in
    components. We’ll also add scoped CSS to remove the text decorations on the links.
    When we’re done, the toolbar should look like [figure 11.6](#ch11fig06).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件文件夹中创建一个名为 Toolbar.vue 的文件。此文件将包含我们的工具栏模板。在这个模板中，我们将使用 Vuetify 的几个内置组件。我们还将添加作用域
    CSS 来移除链接上的文本装饰。完成时，工具栏应类似于 [图 11.6](#ch11fig06)。
- en: Figure 11.6\. iTunes search ToolBar.vue
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. iTunes 搜索 ToolBar.vue
- en: '![](11fig06_alt.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig06_alt.jpg)'
- en: In Vue.js, we normally use the `route-link` component to navigate inside the
    application, but this component doesn’t exist in Nuxt. To navigate between routes,
    we must use the `nuxt-link` component instead; it works exactly like the route-link.
    As you can see in [listing 11.6](#ch11ex06), we’ll use the `nuxt-link` component
    to create a link to the root of the application whenever someone clicks the iTunes
    Search text at the top. Add this code to the Toolbar.vue file.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中，我们通常使用 `route-link` 组件在应用程序内部进行导航，但在 Nuxt 中该组件不存在。为了在路由之间导航，我们必须使用
    `nuxt-link` 组件；它的工作方式与 route-link 完全相同。正如你在 [列表 11.6](#ch11ex06) 中可以看到的，我们将使用
    `nuxt-link` 组件在用户点击顶部的 iTunes 搜索文本时创建指向应用程序根目录的链接。将此代码添加到 Toolbar.vue 文件中。
- en: 'Listing 11.6\. Adding the `Toolbar` component: chapter-11/itunes-search/components/Toolbar.vue'
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 添加 `Toolbar` 组件：chapter-11/itunes-search/components/Toolbar.vue
- en: '[PRE31]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Adds the v-toolbar Vuetify component**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Adds the v-toolbar Vuetify component**'
- en: '***2* The nuxt-link component navigates to “/”.**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* The nuxt-link component navigates to “/”.**'
- en: '***3* Shows the scoped CSS for this component**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Shows the scoped CSS for this component**'
- en: The next component we need to create is the `Card` component. It will be used
    in the results route, and will display each album from the artist. Once again,
    we’ll use Vuetify to make this component look nice. When it’s all done, it should
    look like [figure 11.7](#ch11fig07).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个组件是 `Card` 组件。它将在结果路由中使用，并显示艺术家的每个专辑。再次，我们将使用 Vuetify 使此组件看起来很棒。完成时，它应类似于
    [图 11.7](#ch11fig07)。
- en: Figure 11.7\. Card.vue component with example text
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.7\. Card.vue 组件示例文本
- en: '![](11fig07_alt.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig07_alt.jpg)'
- en: In addition to Vuetify, we’ll also use `props`. The results route will be responsible
    for accessing the API and retrieving the album information. We’ll then pass that
    information into the component using `props`. We’ll pass in the `title`, `image`,
    `artistName`, `url`, and `color`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Vuetify 之外，我们还将使用 `props`。结果路由将负责访问 API 并检索专辑信息。然后，我们将使用 `props` 将该信息传递到组件中。我们将传递
    `title`、`image`、`artistName`、`url` 和 `color`。
- en: The `v-card` component accepts an `href` and a `color` attribute. We can use
    a `v-on` directive to bind our `props` to them. The `v-card-media` component accepts
    an `img` attribute. Our image prop will bind to it. Finally, the `artistName`
    and `title` will be displayed using a class. This will center the title and artist
    name in the card. Copy the code from this listing and create a file in the components
    folder named Card.vue.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-card` 组件接受 `href` 和 `color` 属性。我们可以使用 `v-on` 指令将我们的 `props` 绑定到它们。`v-card-media`
    组件接受 `img` 属性。我们的图像属性将绑定到它。最后，使用一个类来显示 `artistName` 和 `title`。这将使标题和艺术家名称在卡片中居中。从本列表中复制代码，并在组件文件夹中创建一个名为
    Card.vue 的文件。'
- en: 'Listing 11.7\. Adding the `Card` component: chapter-11/itunes-search/components/Card.vue'
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 添加 `Card` 组件：chapter-11/itunes-search/components/Card.vue
- en: '[PRE32]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* The Vuetify v-card component accepts an href and color attribute.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* The Vuetify v-card component accepts an href and color attribute.**'
- en: '***2* A div with a class of headline displays the title.**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个具有 headline 类的 div 显示标题。**'
- en: '***3* A div shows the artist name**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个 div 显示艺术家名称**'
- en: '***4* The Vuetify v-card-media component that accepts an src image.**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 接受 src 图片的 Vuetify v-card-media 组件。**'
- en: '***5* A list of props being passed into the component.**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 传递给组件的 props 列表。**'
- en: These components—`Toolbar` and `Card`—will come in handy later when we put together
    our pages and default layout.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件——`Toolbar` 和 `Card`——在我们组合页面和默认布局时将非常有用。
- en: 11.2.4\. Updating the default layout
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.4\. 更新默认布局
- en: Now that we have our components in place, we need to update our default layout
    in the layouts folder. As the name suggests, the default layout is a component
    that wraps every page in the application. Inside each layout is a `<nuxt/>` component.
    This is the entry point for each page. The file default.vue implements the default
    layout. This can be overridden inside any page component. We’ll look at the page
    structure in the next section. Pages are components that have special properties,
    and they help define the routing of the application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了组件，我们需要更新位于 layouts 文件夹中的默认布局。正如其名所示，默认布局是一个包裹应用程序中每个页面的组件。每个布局内部都有一个
    `<nuxt/>` 组件。这是每个页面的入口点。default.vue 文件实现了默认布局。这可以在任何页面组件内部被覆盖。我们将在下一节中查看页面结构。页面是具有特殊属性的组件，它们有助于定义应用程序的路由。
- en: For our simple app, we’ll update the default.vue file and make several minor
    changes. We want to add the Toolbar.vue file to the top of every route, so we
    don’t have to keep adding it to every page in our app. All we have to do is add
    it once to the default layout, and then it will appear on every page of our application.
    Update the default.vue file and add a new section element with a class named `container`.
    Import the `Toolbar` component in the `<script>` and add it to components. Then
    add the new <`ToolBar/>` component above the <`nuxt/>` component, in the following
    listing. Update the default.vue file in the /layouts folder so it matches this.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单应用，我们将更新默认.vue 文件并进行一些小的修改。我们希望将 Toolbar.vue 文件添加到每个路由的顶部，这样我们就不必在我们的应用程序的每个页面上都添加它。我们只需将其添加到默认布局中一次，然后它就会出现在我们应用程序的每一页上。更新
    default.vue 文件并添加一个具有 `container` 类的新部分元素。在 `<script>` 中导入 `Toolbar` 组件并将其添加到组件中。然后，在以下列表中，将新的
    `<ToolBar/>` 组件添加到 `<nuxt/>` 组件之上。更新位于 /layouts 文件夹中的 default.vue 文件，使其与此匹配。
- en: 'Listing 11.8\. Updating the default layout: chapter-11/itunes-search/layouts/default.vue'
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 更新默认布局：chapter-11/itunes-search/layouts/default.vue
- en: '[PRE33]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Shows the container for the section that surrounds div**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示围绕 div 的部分容器的容器**'
- en: '***2* Adds the Toolbar component to the template**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 Toolbar 组件添加到模板**'
- en: '***3* Imports the ToolBar component**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入 ToolBar 组件**'
- en: Now that we have the layout in place, let’s move on to Vuex.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了布局，让我们继续 Vuex。
- en: 11.2.5\. Adding a store using Vuex
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.5\. 使用 Vuex 添加存储
- en: The album information from the iTunes API will reside in the Vuex store. In
    Nuxt.js, Vuex stores can be accessed anywhere in the application including in
    the middleware. The middleware allows us to write code before the route loads.
    We’ll look at middleware in a later section.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iTunes API 获取的专辑信息将存储在 Vuex 存储中。在 Nuxt.js 中，Vuex 存储可以在应用程序的任何地方访问，包括在中间件中。中间件允许我们在路由加载之前编写代码。我们将在后面的部分中查看中间件。
- en: Using Vuex, we’ll create a simple store. It will have one property in the state,
    called `albums`, and it will have a mutation called `add`. The `add` will take
    the payload and assign it to the `state.albums` in the store/index.js file, as
    you can see in the following listing. Create a file in the store folder named
    index.js. Add this code to it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vuex，我们将创建一个简单的存储。它将在状态中有一个属性，称为 `albums`，并且它将有一个名为 `add` 的突变。`add` 将接受有效负载并将其分配给
    store/index.js 文件中的 `state.albums`，正如您在以下列表中可以看到的。在 store 文件夹中创建一个名为 index.js
    的文件。向其中添加此代码。
- en: 'Listing 11.9\. Adding a Vuex store: chapter-11/itunes-search/store/index.js'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 添加 Vuex 存储：chapter-11/itunes-search/store/index.js
- en: '[PRE34]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* The albums property is the only state in the Vuex store.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* albums 属性是 Vuex 存储中的唯一状态。**'
- en: '***2* Adds mutation that adds the payload to albums**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加突变以将有效负载添加到 albums**'
- en: Now that we have the store in place, we can have our middleware make a call
    to our API and save it in the store.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了存储，我们的中间件可以对我们的 API 进行调用并将其保存到存储中。
- en: 11.2.6\. Using middleware
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.6\. 使用中间件
- en: '*Middleware* is a term used in Node.js and Express to refer to a function that
    has access to a request object and a response object. In Nuxt.js, middleware is
    similar. It’s run on the server and client and can be set on any page in the application.
    It has access to both the request and response object and it’s run before the
    route is rendered.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*中间件* 是在 Node.js 和 Express 中用来指代一个可以访问请求对象和响应对象的函数的术语。在 Nuxt.js 中，中间件类似。它在服务器和客户端上运行，并且可以在应用程序的任何页面上设置。它可以访问请求和响应对象，并且在渲染路由之前运行。'
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Middleware and `asyncData`, which we’ll learn more about later, are run on the
    server and the client. What this means is when a route loads for the first time
    the `asyncData` and middleware are run from the server. However, every subsequent
    time the route loads it’s run on the client. In some instances, you may want to
    run code purely on the server and not the client. This is where the `serverMiddleware`
    property comes in handy. This property is configured in the nuxt.config.js and
    can be used to run application code on the server. For more information on `serverMiddleware`
    check out the official guides at [https://nuxtjs.org/api/configuration-servermiddleware/](https://nuxtjs.org/api/configuration-servermiddleware/).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件和 `asyncData`（我们稍后会了解更多），在服务器和客户端上运行。这意味着当路由首次加载时，`asyncData` 和中间件从服务器运行。然而，每次路由加载后续时间它都在客户端运行。在某些情况下，你可能只想在服务器上运行代码，而不是在客户端。这就是
    `serverMiddleware` 属性派上用场的地方。这个属性在 nuxt.config.js 中配置，可以用来在服务器上运行应用程序代码。有关 `serverMiddleware`
    的更多信息，请查看官方指南 [https://nuxtjs.org/api/configuration-servermiddleware/](https://nuxtjs.org/api/configuration-servermiddleware/)。
- en: '|  |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Middleware is created in the /middleware directory. Each middleware file has
    a function that has access to an object called `context`. `Context` has many different
    keys, including `request`, `response`, `store`, `params`, and `environment`. You
    can find the full listing of `context` object keys in the official documentation
    at [https://nuxtjs.org/api/context](https://nuxtjs.org/api/context).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是在 /middleware 目录中创建的。每个中间件文件都有一个可以访问名为 `context` 的对象的函数。`Context` 有许多不同的键，包括
    `request`、`response`、`store`、`params` 和 `environment`。你可以在官方文档 [https://nuxtjs.org/api/context](https://nuxtjs.org/api/context)
    中找到 `context` 对象键的完整列表。
- en: In our application, we want to send the name of the artist in a route parameter.
    This is accessible by using the `context.params` object. We can use that parameter
    to construct a request to the iTunes search API and retrieve a list of albums.
    We can then take that list and assign it to our albums property inside our Vuex
    store.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们想要在路由参数中发送艺术家的名称。这可以通过使用 `context.params` 对象来访问。我们可以使用该参数来构造一个请求到
    iTunes 搜索 API，并检索专辑列表。然后我们可以将这个列表分配给 Vuex 存储中的 albums 属性。
- en: To make a request to the server, we need to use a library that simplifies the
    process. Many libraries exist, but I like Axios, the HTTP library that we can
    use from the browser or Node.js to make HTTP requests. It transforms our JSON
    data automatically and it supports promises. To learn more about Axios, check
    out the official GitHub page at [https://github.com/axios/axios](https://github.com/axios/axios).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要向服务器发送请求，我们需要使用一个简化过程的库。存在许多库，但我喜欢 Axios，这是一个可以从浏览器或 Node.js 使用来发送 HTTP 请求的
    HTTP 库。它自动转换我们的 JSON 数据，并支持承诺。要了解更多关于 Axios 的信息，请查看官方 GitHub 页面 [https://github.com/axios/axios](https://github.com/axios/axios)。
- en: Create a file named search.js in the middleware folder. Add the code in [listing
    11.10](#ch11ex10). This code makes an HTTP GET request to the iTunes API and passes
    in the `params.id` as the search term in the request. When the promise returns,
    it calls the add mutation using the `store.commit` function. You may have noticed
    that we’re using the ES6 destructuring for `{params, store}`. Instead of passing
    in the context, we can use destructuring to pull out the keys we need.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件文件夹中创建一个名为 search.js 的文件。将 [列表 11.10](#ch11ex10) 中的代码添加进去。这段代码向 iTunes API
    发送一个 HTTP GET 请求，并将 `params.id` 作为请求中的搜索词。当承诺返回时，它使用 `store.commit` 函数调用添加突变。你可能已经注意到我们正在使用
    ES6 解构 `{params, store}`。我们不需要传递上下文，而是可以使用解构来提取我们需要的键。
- en: 'Listing 11.10\. Setting up middleware: chapter-11/itunes-search/middleware/search.js'
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 设置中间件：chapter-11/itunes-search/middleware/search.js
- en: '[PRE35]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Shows the default function that has access to the store and params**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示了具有对 store 和 params 访问权限的默认函数**'
- en: '***2* The response from the server request is added to the store.**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 服务器请求的响应被添加到 store 中。**'
- en: We have everything in place now, so we can look at pages and the route.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有内容，所以我们可以查看 pages 和路由。
- en: 11.2.7\. Generating routes using Nuxt.js
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.7\. 使用 Nuxt.js 生成路由
- en: Routing in Nuxt.js is a little different from what you see in a normal Vue.js
    application. You don’t have a `VueRouter` that you have to set up for all the
    routes. Instead, routes are derived by the file tree created under the pages directory.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt.js 中的路由与你在普通 Vue.js 应用程序中看到的不同。你不需要为所有路由设置 `VueRouter`。相反，路由是通过在 pages
    目录下创建的文件树派生出来的。
- en: Each directory is a route in your application. Each .vue file in that directory
    corresponds to the route as well. Let’s imagine you have a pages route and in
    that route you have a user route. To create these routes, your directory structure
    will look like [figure 11.8](#ch11fig08).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录都是你应用程序中的一个路由。该目录中的每个 .vue 文件都对应于该路由。让我们假设你有一个 pages 路由，在该路由中有一个 user 路由。要创建这些路由，你的目录结构将类似于
    [图 11.8](#ch11fig08)。
- en: Figure 11.8\. Directory structure to create routes
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.8\. 创建路由的目录结构
- en: '![](11fig08_alt.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig08_alt.jpg)'
- en: The directory structure in the pages folder will automatically generate the
    route shown in this listing.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 页面文件夹中的目录结构将自动生成此列表中显示的路由。
- en: Listing 11.11\. Automatically generated route structure
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.11\. 自动生成的路由结构
- en: '[PRE36]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Notes the pages 3index route**'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录 pages 3index 路由**'
- en: This is a quick example of the type of routing you can do. You can find more
    information on routing from the official guides at [https://nuxtjs.org/guide/routing](https://nuxtjs.org/guide/routing).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速示例，展示了你可以进行的路由类型。你可以在官方指南中找到更多关于路由的信息：[https://nuxtjs.org/guide/routing](https://nuxtjs.org/guide/routing)。
- en: For our app we’ll have something much simpler. We’ll only have two routes, and
    one of them will be dynamic. To define a dynamic route in Nuxt you must put an
    underscore before the name. As seen in [figure 11.9](#ch11fig09) the root of the
    pages folder has an index.vue file. This is the root component and will be loaded
    when the application starts. You’ll also see a README.md file. This file can be
    deleted; it’s only there to remind you what should be inside the directory. The
    `_id` route is dynamic. The ID will match the artist name and will be passed into
    the route.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将有一个更简单的结构。我们只有两个路由，其中一个将是动态的。要在 Nuxt 中定义动态路由，必须在名称前放置一个下划线。如 [图
    11.9](#ch11fig09) 所见，pages 文件夹的根目录有一个 index.vue 文件。这是根组件，将在应用程序启动时加载。你还会看到一个 README.md
    文件。此文件可以被删除；它只是为了提醒你目录中应该包含的内容。`_id` 路由是动态的。ID 将匹配艺术家名称，并将传递到路由中。
- en: Figure 11.9\. Directory structure of iTunes search app
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.9\. iTunes 搜索应用程序的目录结构
- en: '![](11fig09_alt.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig09_alt.jpg)'
- en: Inside the pages folder create a results directory. Then open the index.vue
    file. Delete everything and add the fairly simple code from [listing 11.12](#ch11ex12).
    We have a template at the top with an `<h1>` tag and a `<form>` element. A `v-on`
    directive is attached to the submit event on the form. We’ll also use the event
    modifier `prevent` to stop the form from submitting.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pages 文件夹中创建一个 results 目录。然后打开 index.vue 文件。删除所有内容并添加 [列表 11.12](#ch11ex12)
    中的相对简单的代码。我们在顶部有一个模板，其中包含 `<h1>` 标签和 `<form>` 元素。一个 `v-on` 指令附加到表单的提交事件上。我们还将使用事件修饰符
    `prevent` 来阻止表单提交。
- en: Inside the submit method, we’ll use `this.$router.push`. This will route the
    application over to the results/ page. We’ll pass the search results into the
    route as a parameter. Because we set up the `dynamic _id` route, the search results
    will show up as part of the URL. For example, if we search for Taylor Swift, the
    URL will be /results/taylor%20swift. Don’t worry about the %20, this is added
    in automatically and represents a space character.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交方法内部，我们将使用 `this.$router.push`。这将使应用程序路由到 results/ 页面。我们将搜索结果作为参数传递给路由。因为我们设置了
    `dynamic _id` 路由，所以搜索结果将作为 URL 的一部分显示。例如，如果我们搜索 Taylor Swift，URL 将是 /results/taylor%20swift。不用担心
    %20，这是自动添加的，代表空格字符。
- en: At the bottom of the page component, add a style tag, as shown in this listing.
    This will center the text and add a little padding.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面组件的底部添加一个样式标签，如本列表所示。这将使文本居中并添加一些填充。
- en: 'Listing 11.12\. Creating the index page: chapter-11/itunes-search/pages/index.vue'
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.12\. 创建索引页面：chapter-11/itunes-search/pages/index.vue
- en: '[PRE37]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Shows the form element with a v-on directive that triggers the submit
    method on submit**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示带有触发提交方法的 v-on 指令的表单元素**'
- en: '***2* Routes the app to the results page**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将应用程序路由到结果页面**'
- en: '***3* Centers and adds padding to the page.**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使页面居中并添加填充。**'
- en: The final piece to this app is the `_id` page that will display a card for each
    album in the result. It will also alternate the colors between blue and red on
    each card.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用的最后一部分是显示结果中每个专辑的卡片页面 `_id`。它还会在每个卡片上交替显示蓝色和红色。
- en: Earlier in this chapter, I mentioned that pages are supercharged components.
    In other words, they have certain Nuxt-only options available to them. These options
    include `fetch`, `scrollToTop`, `head`, `transition`, `layout`, and `validate`.
    We’ll look at two other options called `asyncData` and `middleware`. If you want
    to learn more about Nuxt options, check out the official documentation at [https://nuxtjs.org/guide/views](https://nuxtjs.org/guide/views).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我提到页面是超级组件。换句话说，它们有一些仅适用于 Nuxt 的选项。这些选项包括 `fetch`、`scrollToTop`、`head`、`transition`、`layout`
    和 `validate`。我们将探讨两个其他选项，即 `asyncData` 和 `middleware`。如果您想了解更多关于 Nuxt 选项的信息，请查看官方文档
    [https://nuxtjs.org/guide/views](https://nuxtjs.org/guide/views)。
- en: The `middleware` option allows us to define the middleware we want to use in
    our page. This middleware will run each time the component is loaded. You can
    see in [listing 11.13](#ch11ex13) that the _id.vue file is using the middleware
    search we created earlier.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`middleware` 选项允许我们定义在页面中要使用的中间件。每次组件加载时，都会运行此中间件。您可以在 [列表 11.13](#ch11ex13)
    中看到 `_id.vue` 文件正在使用我们之前创建的中间件搜索。'
- en: The other option is called `asyncData`. This is helpful because it allows us
    to retrieve data and pre-render it on the server without using a store. As you
    saw in the middleware section, we had to use the Vuex store to save our data so
    it could be accessed by our components. When using `asyncData`, you don’t have
    to do this. Let’s look first at how to access the data using middleware. Then
    we’ll refactor to use `asyncData`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项称为 `asyncData`。这很有用，因为它允许我们在服务器上检索数据并预渲染，而无需使用存储。如您在中间件部分所看到的，我们必须使用 Vuex
    存储来保存我们的数据，以便我们的组件可以访问它。当使用 `asyncData` 时，您不必这样做。让我们首先看看如何使用中间件访问数据。然后我们将重构以使用
    `asyncData`。
- en: Create a file in the pages/results folder called _id.vue. Inside that new component,
    add a `v-if` directive for `albumData`. This will guarantee the album data is
    loaded before being displayed. Next, create a `v-for` directive that iterates
    through the `albumData`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pages/results` 文件夹中创建一个名为 `_id.vue` 的文件。在这个新组件内部，添加一个 `v-if` 指令用于 `albumData`。这将确保在显示之前数据已被加载。接下来，创建一个
    `v-for` 指令，遍历 `albumData`。
- en: On each iteration, we’ll show a card and pass into it the album data for `title`,
    `image`, `artistName`, `url`, and `color`. The color will be calculated by a method
    called `picker`. It will alternate between red and blue based on the index value.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们将显示一个卡片，并将其 `title`、`image`、`artistName`、`url` 和 `color` 的专辑数据传递给它。颜色将通过名为
    `picker` 的方法计算得出，它将根据索引值在红色和蓝色之间交替。
- en: At the top of the file, we’ll access the `{{$route.params.id}}`. This is the
    parameter that’s passed in from the search results.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，我们将访问 `{{$route.params.id}}`。这是从搜索结果传入的参数。
- en: As you can see in the next listing, we’ll add a computed property called `albumData`.
    This will retrieve the data from the store. The store is populated by the middleware
    search that’s triggered as soon as the route loads, as shown here.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下一列表中看到的，我们将添加一个名为 `albumData` 的计算属性。这将从存储中检索数据。存储由触发路由加载时的中间件搜索填充，如此处所示。
- en: 'Listing 11.13\. Creating our dynamic route: chapter-11/itunes-search/pages/results/_id.vue'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.13\. 创建我们的动态路由：chapter-11/itunes-search/pages/results/_id.vue
- en: '[PRE38]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* The message displays the route parameter passed in from the search.**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 消息显示从搜索中传入的路由参数。**'
- en: '***2* The v-if directive that will only display if albumData is present.**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 只有在 `albumData` 存在时才会显示的 v-if 指令。**'
- en: '***3* The v-for directive that iterates through the albumData.**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 遍历专辑数据的 v-for 指令。**'
- en: '***4* The Card component that’s passed-in album information.**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 传入专辑信息的卡片组件。**'
- en: '***5* The picker method that returns red and blue alternately.**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回交替显示红色和蓝色的选择器方法。**'
- en: '***6* The computed property that returns the store property for albums.**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 返回存储中专辑属性的计算属性。**'
- en: '***7* Specifies which middleware to run for this route**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 指定为此路由运行的中间件**'
- en: Run the command `npm run dev` and open a web browser on localhost port 3000\.
    If you already have it running, make sure to close and restart. You should see
    the iTunes search app open. If not, look in the console for the error. Sometimes
    it’s as simple as a typo in the component name.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm run dev` 命令，并在本地主机端口 3000 上打开一个网络浏览器。如果你已经运行了它，请确保关闭并重新启动。你应该看到 iTunes
    搜索应用程序打开。如果没有，请在控制台中查找错误。有时错误可能只是组件名称中的一个拼写错误。
- en: Let’s do one more modification of our app. Like I said earlier, we have access
    to something called `asyncData`. This option is used to load data server side,
    on the initial load of the component. It’s similar to using a middleware, because
    we’ll have access to the context.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的应用程序进行最后一次修改。正如我之前所说的，我们有访问名为 `asyncData` 的东西。这个选项用于在组件初始加载时在服务器端加载数据。它类似于使用中间件，因为我们将能够访问上下文。
- en: When using `asyncData`, be cautious. You will not have access to the component
    through this option because it’s called before the component is initiated. However,
    it will merge the data you retrieve with the component so you don’t have to use
    Vuex. You can find more information on `asyncData` from the official documentation
    at [https://nuxtjs.org/guide/async-data](https://nuxtjs.org/guide/async-data).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `asyncData` 时要小心。你将无法通过此选项访问组件，因为它是在组件启动之前调用的。然而，它将合并你检索的数据与组件，因此你不需要使用 Vuex。你可以在官方文档
    [https://nuxtjs.org/guide/async-data](https://nuxtjs.org/guide/async-data) 中找到有关
    `asyncData` 的更多信息。
- en: Open the _id.vue file again and delete the `albumData` computed property. We
    won’t use it. Instead create an `asyncData` option, shown in [listing 11.14](#ch11ex14).
    Inside that option, we’ll do an HTTP GET request using Axios. Similar to middleware,
    `asyncData` also has access to the context object. We’ll use ES6 destructuring
    to retrieve the `params`, and then use them in the iTunes API call. In the response,
    we’ll set the `albumData` object. This object will be available to us after the
    component is initialized, as shown in [listing 11.14](#ch11ex14).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 _id.vue 文件，并删除 `albumData` 计算属性。我们不会使用它。相反，创建一个 `asyncData` 选项，如 [列表 11.14](#ch11ex14)
    所示。在这个选项内部，我们将使用 Axios 进行 HTTP GET 请求。类似于中间件，`asyncData` 也可以访问上下文对象。我们将使用 ES6
    解构来检索 `params`，然后在 iTunes API 调用中使用它们。在响应中，我们将设置 `albumData` 对象。这个对象将在组件初始化后对我们可用，如
    [列表 11.14](#ch11ex14) 所示。
- en: 'Listing 11.14\. The asyncData example: chapter-11/itunes-search/pages/results/_id.vue'
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.14\. asyncData 示例：chapter-11/itunes-search/pages/results/_id.vue
- en: '[PRE39]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* The asyncData option has access to the params key.**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* asyncData 选项可以访问 params 键。**'
- en: '***2* The iTunes response appears after passing in the params.id to the axios.get
    command.**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* iTunes 响应将在将 params.id 传递给 axios.get 命令后出现。**'
- en: '***3* This will return a new albumData property that can be accessed in the
    component.**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这将返回一个可以在组件中访问的新 albumData 属性。**'
- en: That should be it for `asyncData`. Save the file and run the `npm run dev` command
    again. You should see the page as it was before. As you can see, we have the same
    results, but we don’t have to use the Vuex store.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `asyncData`，这就足够了。保存文件，再次运行 `npm run dev` 命令。你应该看到页面和之前一样。正如你所看到的，我们有相同的结果，但我们不需要使用
    Vuex 存储。
- en: 11.3\. Communicating with a server using Firebase and VuexFire
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 使用 Firebase 和 VuexFire 与服务器通信
- en: Firebase is a Google product that helps you create apps quickly for mobile and
    desktop. It offers several services, including analytics, databases, messaging,
    crash reporting, cloud storage, hosting, and authentication. Firebase scales automatically
    and is easy to get up and running. You can find more information about all the
    Firebase services at the official home page at [https://firebase.google.com/](https://firebase.google.com/).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 是一个谷歌产品，可以帮助你快速为移动和桌面创建应用程序。它提供包括分析、数据库、消息传递、崩溃报告、云存储、托管和身份验证在内的多项服务。Firebase
    可以自动扩展，并且易于启动。你可以在官方主页 [https://firebase.google.com/](https://firebase.google.com/)
    上找到有关所有 Firebase 服务的更多信息。
- en: 'For our example in this section, we’ll use two of these services: authentication
    and the Realtime database. We’re going to take our existing pet store application
    and modify it to include these services.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节示例中，我们将使用这些服务中的两个：身份验证和实时数据库。我们将修改现有的宠物商店应用程序，以包含这些服务。
- en: Let’s imagine we were told that we needed to host our products for our pet store
    app in the cloud and add authentication. Recall from the previous chapter that
    our pet store application uses a flat file, products.json. We’ll need to move
    the products.json contents to Firebase’s Realtime database. We’ll then modify
    our application so it pulls from Firebase instead of the flat file.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们被告知需要将宠物商店应用程序的产品托管在云端并添加身份验证。回想一下上一章，我们的宠物商店应用程序使用一个平面文件，products.json。我们需要将
    products.json 的内容移动到 Firebase 的实时数据库中。然后我们将修改我们的应用程序，使其从 Firebase 而不是平面文件中获取数据。
- en: Another important aspect is to add simple authentication using one of Firebase’s
    built-in cloud providers. We’ll make a new button in our header to sign in and
    sign out, and we’ll see how we can save our session data into our Vuex store.
    When all is done, our app will look like [figure 11.10](#ch11fig10).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是使用 Firebase 内置的云提供商之一添加简单身份验证。我们将在页眉中添加一个新的按钮来登录和登出，并查看我们如何将会话数据保存到
    Vuex 存储中。一切完成后，我们的应用程序将看起来像 [图 11.10](#ch11fig10)。
- en: Figure 11.10\. Completed pet store application using Firebase
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.10\. 使用 Firebase 完成的宠物商店应用程序
- en: '![](11fig10_alt.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig10_alt.jpg)'
- en: 11.3.1\. Setting up Firebase
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 设置 Firebase
- en: If you have a Google account, you can go to [http://firebase.google.com](http://firebase.google.com)
    and log in. If you don’t have a Google account, head over to [http://accounts.google.com](http://accounts.google.com)
    and create one; it’s free. (Firebase is free for a certain number of transactions
    a month; after that you’ll have to pay.)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个谷歌账户，你可以访问 [http://firebase.google.com](http://firebase.google.com) 并登录。如果你没有谷歌账户，请转到
    [http://accounts.google.com](http://accounts.google.com) 创建一个；这是免费的。（Firebase
    每月有特定数量的免费交易；之后你将需要付费。）
- en: After logging in, you’ll be presented with the Welcome to Firebase page. You’ll
    then have an opportunity to create a project, as seen in [figure 11.11](#ch11fig11).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你会看到 Firebase 欢迎页面。然后你将有机会创建一个项目，如图 11.11 所示。
- en: Figure 11.11\. Creating a Firebase project
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.11\. 创建 Firebase 项目
- en: '![](11fig11_alt.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig11_alt.jpg)'
- en: After clicking Add project, you’ll need to type in a project name and country
    region. Click Create Project and you’ll see the Firebase console. This is where
    we’ll set up our database, authentication, and retrieve the keys we need to get
    started.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加项目后，你需要输入项目名称和国家/地区。点击创建项目，你将看到 Firebase 控制台。这是我们设置数据库、身份验证和检索我们开始所需密钥的地方。
- en: 'Click Database on the left side. You should see two options: Realtime Database
    and Cloud Firestore. We’re going to use the Realtime Database. Click Get Started
    ([figure 11.12](#ch11fig12)).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧点击数据库。你应该看到两个选项：实时数据库和云 Firestore。我们将使用实时数据库。点击开始 ([图 11.12](#ch11fig12))。
- en: Figure 11.12\. Database selection
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.12\. 数据库选择
- en: '![](11fig12_alt.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig12_alt.jpg)'
- en: At this point, we’ll add the products.json file into the Firebase database.
    We could import the JSON file, but we’ll add it manually so we can understand
    how everything works. Click the plus (+) symbol next to the name you gave the
    database. Add a Products child. Before clicking Add, click the plus symbol again.
    This will create another child. In the Name box, add a number. Click the plus
    symbol again and create seven children. These will be title, description, price,
    image, availableInventory, id, and rating. Fill in the information and repeat
    the process for another product. After you’re done, it should look like [figure
    11.13](#ch11fig13).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将把 products.json 文件添加到 Firebase 数据库中。我们可以导入 JSON 文件，但我们将手动添加它，这样我们可以理解一切是如何工作的。点击数据库旁边你给出的名称旁边的加号
    (+) 符号。添加一个“产品”子项。在点击添加之前，再次点击加号符号。这将创建另一个子项。在“名称”框中添加一个数字。再次点击加号符号并创建七个子项。这些将是标题、描述、价格、图片、可用库存、id
    和评分。填写信息，并为另一个产品重复此过程。完成后，它应该看起来像 [图 11.13](#ch11fig13)。
- en: Figure 11.13\. Firebase Realtime Database setup
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.13\. Firebase 实时数据库设置
- en: '![](11fig13_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig13_alt.jpg)'
- en: Click Add and you’ll see the two products in the database. Repeat this process
    and add a few more into it if you like.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加，你将在数据库中看到两个产品。如果你喜欢，重复此过程并添加更多。
- en: After this is done, we’ll need to set up authentication. Click Authentication
    in the console on the left side. You’ll see a window that has a button for SET
    UP SIGN-IN METHOD. Click that button, as you see in [figure 11.14](#ch11fig14).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们需要设置身份验证。在控制台的左侧点击身份验证。你会看到一个有“设置登录方法”按钮的窗口。点击该按钮，如图 11.14 所示。
- en: Figure 11.14\. Setting up authentication
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.14\. 设置身份验证
- en: '![](11fig14_alt.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig14_alt.jpg)'
- en: On the next page, choose Google. We’ll be using this for our authentication
    in our app. We could as easily set up Facebook or Twitter, but for this example
    we’ll assume that anyone who wants to log in to our app must also have a Google
    account. In the setup window, slide the Enable button and save your work, as shown
    in [figure 11.15](#ch11fig15). That should be it; that will enable us to sign
    in with Google.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页，选择 Google。我们将在我们的应用中使用它进行身份验证。我们同样可以设置 Facebook 或 Twitter，但在这个例子中，我们将假设任何想要登录我们应用的人都必须有一个
    Google 账户。在设置窗口中，滑动启用按钮并保存你的工作，如图 11.15 所示。这就完成了；这将使我们能够使用 Google 登录。
- en: Figure 11.15\. Enable Google sign-in.
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.15\. 启用 Google 登录。
- en: '![](11fig15_alt.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig15_alt.jpg)'
- en: Finally, we need to grab configuration information. Head back to the project
    overview console page by clicking Project Overview on the left side. You’ll see
    an Add Firebase to your web app button. Click this button and a window will open
    with your Firebase keys and initialization information. Record this information
    for later; we’ll need it when setting up Firebase in our app.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要获取配置信息。通过点击左侧的“项目概览”返回项目概览控制台页面。你会看到一个“将 Firebase 添加到你的 Web 应用”按钮。点击此按钮，将打开一个窗口，显示你的
    Firebase 密钥和初始化信息。记录这些信息以备后用；我们将在设置应用中的 Firebase 时需要它。
- en: 11.3.2\. Setting up our pet store app with Firebase
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 使用 Firebase 设置我们的宠物商店应用
- en: Now that we’ve set up Firebase, we need to update our pet store app to use it.
    The last time we used our pet store was in [chapter 10](kindle_split_022.html#ch10),
    when we added in Vuex. Copy the pet store app from the previous chapter or download
    the code for the chapter. We’ll use this code as a starting point.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Firebase，我们需要更新我们的宠物商店应用以使用它。我们上次使用宠物商店是在 [第 10 章](kindle_split_022.html#ch10)，当时我们添加了
    Vuex。复制上一章的宠物商店应用或下载该章节的代码。我们将以此代码作为起点。
- en: For Firebase to work correctly with Vue, we’ll need to use a library called
    VueFire. This will help us communicate with Firebase and set up the bindings we
    need. You can find more information on VueFire on their official GitHub page at
    [https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Firebase 能够正确地与 Vue 一起工作，我们需要使用一个名为 VueFire 的库。这将帮助我们与 Firebase 通信并设置我们需要的绑定。你可以在他们的官方
    GitHub 页面找到更多关于 VueFire 的信息，网址为 [https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire)。
- en: 'Open your console and change directories to the location of your pet store
    app. Install VueFire and Firebase with the following commands:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的控制台，更改目录到你的宠物商店应用的位置。使用以下命令安装 VueFire 和 Firebase：
- en: '[PRE40]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will install and save all the dependencies we need.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装并保存我们需要的所有依赖。
- en: Create a file named firebase.js in the src folder in the root of the pet store
    app. Remember when you copied the initialization information from the Firebase
    console? We’ll need that now. At the top of the file, write import `{initializeApp}`
    from Firebase. After the import, create a `const` variable named app and paste
    in the initialization information you recorded earlier.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在宠物商店应用的根目录下的 src 文件夹中创建一个名为 firebase.js 的文件。记得你从 Firebase 控制台复制初始化信息的时候吗？我们现在需要用到它。在文件顶部，写入
    `import {initializeApp} from Firebase`。导入之后，创建一个名为 `app` 的 `const` 变量，并将你之前记录的初始化信息粘贴进去。
- en: Create two exports, one called `db` and the other called `productsRef`. This
    will allow us to connect to the Firebase database and retrieve the product information
    we created earlier. If you’d like more information on the Firebase API, check
    the official API documentation at [https://firebase.google.com/docs/reference/js/](https://firebase.google.com/docs/reference/js/).
    Copy the code from [listing 11.15](#ch11ex15) into the src/firebase.js file.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个导出，一个名为 `db`，另一个名为 `productsRef`。这将使我们能够连接到 Firebase 数据库并检索我们之前创建的产品信息。如果你需要更多关于
    Firebase API 的信息，请查看官方 API 文档，网址为 [https://firebase.google.com/docs/reference/js/](https://firebase.google.com/docs/reference/js/)。将
    [列表 11.15](#ch11ex15) 中的代码复制到 src/firebase.js 文件中。
- en: 'Listing 11.15\. Setting up Firebase and initializing files: chapter-11/petstore/src/firebase.js'
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.15\. 设置 Firebase 和初始化文件：chapter-11/petstore/src/firebase.js
- en: '[PRE41]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Imports initializeApp into the file**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 initializeApp 导入到文件中**'
- en: '***2* Shows the keys for Firebase received from the Firebase console**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示从 Firebase 控制台接收到的 Firebase 密钥**'
- en: '***3* Uses ES6 export for the database**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 ES6 导出数据库**'
- en: '***4* Uses ES6 export for the products reference**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 ES6 导出产品引用**'
- en: We now need to set up our main.js file so it can see the `VueFire` library we
    installed earlier. We’ll also need to make sure we import Firebase and the firebase.js
    we created earlier. The `Vue.use(VueFire)` line will set `VueFire` as a plugin
    for the app. This is required by the VueFire installation. Update the src/main.js
    file with this code.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要设置我们的main.js文件，使其可以看到我们之前安装的`VueFire`库。我们还需要确保我们导入了Firebase和我们之前创建的firebase.js。`Vue.use(VueFire)`行将`VueFire`设置为应用程序的插件。这是VueFire安装所必需的。使用以下代码更新src/main.js文件。
- en: 'Listing 11.16\. Setting up main file: chapter-11/petstore/src/main.js'
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表11.16\. 设置主文件: chapter-11/petstore/src/main.js'
- en: '[PRE42]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Imports Firebase into the app**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将Firebase导入到应用程序中**'
- en: '***2* Imports the firebase.js file.**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入firebase.js文件。**'
- en: '***3* Imports vuefire.**'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入vuefire。**'
- en: '***4* Sets up vuefire as a plugin.**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将vuefire设置为插件。**'
- en: It’s a good idea at this point to make sure we don’t have any errors. Save all
    your files and run the `npm run dev` command in your console. This will start
    your server on localhost. Make sure you don’t see any errors in the console. It’s
    easy to forget an import, so make sure you didn’t forget any inside the main.js
    file. Because we have everything set up, let’s look at how to set up authentication
    in our app.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，确保我们没有任何错误是个好主意。保存所有文件，并在控制台中运行`npm run dev`命令。这将启动你的服务器在localhost上。确保你控制台中没有错误。很容易忘记一个导入，所以请确保在main.js文件中没有忘记任何导入。因为我们已经设置了一切，让我们看看如何在我们的应用程序中设置认证。
- en: 11.3.3\. Updating Vuex with authentication state
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. 更新Vuex中的认证状态
- en: Earlier I mentioned that we’ll use authentication in our app. To save this information,
    we’ll need to update the Vuex store. To make things easy, we’ll create a state
    property called `session`. After a user is authenticated, Firebase returns a user
    object which holds session information. It’s a good practice to save that information
    so it’s available anywhere in the app.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，我们将在我们的应用程序中使用认证。为了保存这些信息，我们需要更新Vuex存储。为了简化操作，我们将创建一个名为`session`的状态属性。在用户认证后，Firebase返回一个包含会话信息的用户对象。将此信息保存下来，以便在应用程序的任何地方都可以访问，这是一个好习惯。
- en: Open the store/modules/products.js file, and add a new session property in state.
    The same way we did in the last chapter, we’ll add in a `getter` and a `mutation`.
    We’ll name the `mutation` SET_SESSION. Update the store/modules/products.js file
    so it matches this listing.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 打开store/modules/products.js文件，并在状态中添加一个新的会话属性。就像我们在上一章中所做的那样，我们将添加一个`getter`和一个`mutation`。我们将`mutation`命名为SET_SESSION。更新store/modules/products.js文件，使其与这个列表匹配。
- en: 'Listing 11.17\. Updating Vuex: chapter-11/petstore/store/modules/products.js'
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表11.17\. 更新Vuex: chapter-11/petstore/store/modules/products.js'
- en: '[PRE43]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* The session state property defaults to false.**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 会话状态属性默认为false。**'
- en: '***2* The getter for the session**'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 会话的getter**'
- en: '***3* The mutation called SET_SESSION sets session data.**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用SET_SESSION的突变设置会话数据。**'
- en: Now that we have a place to set the session data in Vuex, we can add the code
    to retrieve it from Firebase.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了在Vuex中设置会话数据的地方，我们可以添加从Firebase检索它的代码。
- en: 11.3.4\. Updating the header component with authentication
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.4\. 更新页眉组件以包含认证
- en: Inside the header, we display the site name and Checkout button. Let’s update
    the header so it shows a Sign In and Sign Out button.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在页眉中，我们显示网站名称和结账按钮。让我们更新页眉，使其显示登录和登出按钮。
- en: When the header is complete, it will look like [figure 11.16](#ch11fig16) after
    someone is signed in. Notice how in [figure 11.16](#ch11fig16) a picture is shown
    next to the Sign Out text. This is retrieved from the user object from Firebase.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 页眉完成时，有人登录后看起来将像图11.16所示。注意在图11.16中，在“登出”文本旁边显示了一张图片。这是从Firebase的用户对象中检索的。
- en: Figure 11.16\. User is signed in.
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.16\. 用户已登录。
- en: '![](11fig16_alt.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig16_alt.jpg)'
- en: After the user signs out, the button changes to Sign In, as [figure 11.17](#ch11fig17)
    shows.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登出后，按钮将变为“登录”，如图11.17所示。
- en: Figure 11.17\. User is signed out.
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.17\. 用户已登出。
- en: '![](11fig17_alt.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig17_alt.jpg)'
- en: Open the src/components/Header.vue file. In this file, we’ll update the template
    with the new buttons. We’ll also need to add two new methods for signing in and
    out. Under the `navbar-header`, add a new `div` section for the sign in (see [listing
    11.18](#ch11ex18)). Below that, add another `div` section for sign out. Inside
    the sign out `div,` we’ll also add an image that will be retrieved from the `mySession`
    property.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/components/Header.vue` 文件。在这个文件中，我们将更新模板以包含新按钮。我们还需要添加两个用于登录和注销的新方法。在
    `navbar-header` 下添加一个新的 `div` 部分用于登录（见 [清单 11.18](#ch11ex18)）。下面添加另一个 `div` 部分用于注销。在注销
    `div` 内部，我们还将添加一个从 `mySession` 属性检索的图像。
- en: Surrounded by both `divs` will be a `v-if` directive. If the `mySession` property
    is `false` it will show the Sign In button. We’ll use a `v-else` directive to
    show the Sign Out button if `mySession` is `true`. If the session is signed in,
    we’ll see a Sign Out button; if the session is signed out, we’ll see a Sign In
    button.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 被 `divs` 包围的部分将有一个 `v-if` 指令。如果 `mySession` 属性为 `false`，它将显示登录按钮。如果 `mySession`
    为 `true`，我们将使用 `v-else` 指令显示注销按钮。如果会话已登录，我们将看到一个注销按钮；如果会话已注销，我们将看到一个登录按钮。
- en: Because the code for the header component is so large, I’ve broken it into three
    listings ([listing 11.18](#ch11ex18), [11.19](#ch11ex19), and [11.20](#ch11ex20)).
    Make sure to take each of these listings and combine them. Take the combined code
    from the listing and overwrite the file for src/components/Header.vue, as shown
    next.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 由于头部组件的代码非常庞大，我已经将其分为三个清单（[清单 11.18](#ch11ex18)、[11.19](#ch11ex19) 和 [11.20](#ch11ex20)）。确保将每个清单合并在一起。将清单中的合并代码覆盖到
    `src/components/Header.vue` 文件，如下所示。
- en: 'Listing 11.18\. Updating header component: chapter-11/header-temp.html'
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 11.18\. 更新头部组件：chapter-11/header-temp.html
- en: '[PRE44]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* The mySession property will display the Sign In button if it’s false.**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当 mySession 属性为 false 时，将显示登录按钮。**'
- en: '***2* Shows the button with the v-on directive for sign in**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 v-on 指令显示登录按钮**'
- en: '***3* If the mySession property is true, the Sign Out button will be displayed.**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果 mySession 属性为 true，将显示注销按钮。**'
- en: '***4* Displays an image from mySession**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示来自 mySession 的图像**'
- en: In the template, we created two methods, `signIn` and `signOut`. We also created
    a new property called `mySession`. Let’s go ahead and create the script section
    of our component with these new methods and a computed property. Make sure to
    import `firebase from 'firebase'` at the top of the script ([listing 11.19](#ch11ex19)).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们创建了两个方法，`signIn` 和 `signOut`。我们还创建了一个名为 `mySession` 的新属性。让我们继续创建组件的脚本部分，包括这些新方法和一个计算属性。确保在脚本顶部导入
    `firebase from 'firebase'` ([清单 11.19](#ch11ex19))。
- en: The first thing we need to do is add a lifecycle hook called `beforeCreate`.
    This hook fires before the component is created. In this hook, we want to set
    our Vuex store with the current session. Firebase conveniently has an observer
    that will do this called `onAuthStateChanged`. This observer is triggered whenever
    a user signs in or out. We can use this to update our store with the session information
    using `SET_STORE`. For more information on `onAuthStateChanged,` check out the
    official documentation at [http://mng.bz/4F31](http://mng.bz/4F31).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加一个生命周期钩子，称为 `beforeCreate`。这个钩子在组件创建之前触发。在这个钩子中，我们想要设置我们的 Vuex
    存储为当前会话。Firebase 便利地有一个名为 `onAuthStateChanged` 的观察者来完成这个任务。这个观察者会在用户登录或注销时被触发。我们可以使用它来使用
    `SET_STORE` 更新我们的存储会话信息。有关 `onAuthStateChanged` 的更多信息，请查看官方文档[http://mng.bz/4F31](http://mng.bz/4F31)。
- en: Now that we can track when a user signs in and out, we can create those methods.
    Create a method named `signIn`. Inside that method create a provider `firebase.auth.GoogleAuthProvider()`.
    Pass that provider into `firebase.auth().signInWithPopup`. This will create a
    popup asking the user to sign into their Google account. The `signInWithPopup`
    will create a promise. If the login is successful, we display “signed in” in the
    console. If it isn’t successful, we see “error” in the console.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以跟踪用户何时登录和注销，我们可以创建这些方法。创建一个名为 `signIn` 的方法。在该方法内部创建一个提供者 `firebase.auth.GoogleAuthProvider()`。将此提供者传递给
    `firebase.auth().signInWithPopup`。这将创建一个弹出窗口，提示用户登录其 Google 账户。`signInWithPopup`
    将创建一个承诺。如果登录成功，我们在控制台显示“已登录”。如果不成功，我们在控制台看到“错误”。
- en: Remember, because we set up an observer for `onAuthStateChanged` inside the
    `beforeCreate` hook, we don’t have to set up any other variable after a user logs
    in. The observer will update the store automatically after we sign in or sign
    out.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为我们已经在`beforeCreate`钩子中设置了`onAuthStateChanged`观察者，所以我们不必在用户登录后设置任何其他变量。在登录或注销后，观察者将自动更新存储。
- en: The `signOut` method works the same way. When the user signs out, a message
    “signed out” shows in the console. If there is an error, “error in sign out!”
    is displayed.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`signOut`方法的工作方式相同。当用户注销时，控制台会显示“已注销”消息。如果有错误，将显示“注销错误！”。'
- en: For our computed property `mySession`, we’ll return the Vuex getter for `session`.
    If the session doesn’t exist, it will be set to `false`. It’s worth mentioning
    that we could have used `mapGetters` with Vuex. This would automatically map the
    getters session with the name session in our component. However, because we’re
    dealing with one getter, I decided to return `this.$store.getters.session` instead.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的计算属性`mySession`，我们将返回`session`的Vuex获取器。如果会话不存在，它将被设置为`false`。值得一提的是，我们可以使用Vuex的`mapGetters`。这将自动将获取器session映射到我们的组件中的session名称。然而，因为我们只处理一个获取器，所以我决定返回`this.$store.getters.session`。
- en: Copy the code from the following listing and add it to the bottom of the new
    combined file that you’ll be using for src/components/Header.vue.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下列表中复制代码并将其添加到您将要用于src/components/Header.vue的新组合文件的底部。
- en: 'Listing 11.19\. Updating header component 2: chapter-11/header-script.js'
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.19\. 更新头部组件2：chapter-11/header-script.js
- en: '[PRE45]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* The onAuthStateChanged observer is set inside the beforeCreate hook.**'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在beforeCreate钩子中设置onAuthStateChanged观察者。**'
- en: '***2* The signIn method signs the user in.**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* signIn方法登录用户。**'
- en: '***3* The signOut method signs the user out.**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* signOut方法注销用户。**'
- en: '***4* The mySession computed property gets the session information.**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* mySession计算属性获取会话信息。**'
- en: Finally, we’ll need to add a new photo class to our CSS that will size the photo
    in our button. Take the code from the following listing and combine it with the
    previous listings to create the new Header.vue file in the src/components folder.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的CSS中添加一个新的照片类，以调整按钮中的照片大小。从以下列表中获取代码，并将其与前面的列表合并，以在src/components文件夹中创建新的Header.vue文件。
- en: 'Listing 11.20\. Updating header styles: chapter-11/header-style.html'
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.20\. 更新头部样式：chapter-11/header-style.html
- en: '[PRE46]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* The photo class that sets the width and height of image**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置图像宽度和高度的图片类**'
- en: After adding all the code for the new Header.vue file, make sure to run the
    `npm run dev` command and check for errors. It’s easy to make a mistake on the
    `onAuthStateChanged` observer and not commit it to the Vuex store. Look out for
    that.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了新的Header.vue文件的所有代码后，请确保运行`npm run dev`命令并检查错误。在`onAuthStateChanged`观察者上犯错并且没有将其提交到Vuex存储是很常见的。请注意这一点。
- en: 11.3.5\. Updating Main.vue to use Firebase Realtime database
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5\. 更新Main.vue以使用Firebase实时数据库
- en: With all the authentication out of the way, let’s start retrieving information
    from the database. By default, we left the database configuration in Firebase
    to read only. That will work for us.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有认证问题解决之后，让我们开始从数据库中检索信息。默认情况下，我们在Firebase中将数据库配置为只读。这对我们来说将有效。
- en: First, update the `mapGetters` in the src/components/Main.vue file. You’ll notice
    that we’re retrieving the `products` getter. Remove that and add the `session`
    getter. We won’t use this now, but it’s nice to know we can use the session inside
    the main component.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新src/components/Main.vue文件中的`mapGetters`。你会注意到我们正在检索`products`获取器。删除它并添加`session`获取器。我们现在不会使用它，但知道我们可以在主组件中使用会话是很好的。
- en: To use the Realtime database with Firebase, all we need to do is import the
    `productsRef` from the firebase.js file. Then we’ll need to create a Firebase
    object that maps `productsRef` to `products`. That should be it! All the other
    code in our Main.vue file can remain the same. Take the code in this listing and
    update the src/components/Main.vue file.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Firebase的实时数据库，我们只需要从firebase.js文件中导入`productsRef`。然后我们需要创建一个Firebase对象，将`productsRef`映射到`products`。这就足够了！我们Main.vue文件中的其他所有代码都可以保持不变。将此列表中的代码更新到src/components/Main.vue文件。
- en: 'Listing 11.21\. Updating Main.vue file: chapter-11/update-main.js'
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.21\. 更新Main.vue文件：chapter-11/update-main.js
- en: '[PRE47]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Imports the productsRef from firebase/.js file**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从firebase/.js文件导入productsRef**'
- en: '***2* Maps productsRef to products**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将productsRef映射到products**'
- en: '***3* Updates mapGetters that only retrieves session not products**'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新mapGetters，仅检索会话而非产品**'
- en: Save all the files and run `npm run dev`. Inside the browser, you’ll notice
    a slight delay before the products show up. This indicates the products are being
    downloaded from Firebase. You could always go into Firebase and add a new product,
    and it should show up on your list of products.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件并运行 `npm run dev`。在浏览器内部，你会在产品显示之前注意到轻微的延迟。这表明产品正在从 Firebase 下载。你总是可以进入
    Firebase 并添加一个新产品，它应该会出现在你的产品列表中。
- en: One thing you may wonder is what we could do next. With the session property,
    we could set up different sections of the app that are accessible only if a user
    is logged in. We could do this with the `v-if` directive or through the router.
    With the router we can add a meta tag to a route. Then we could use the `router.beforeEach`
    to navigate to certain routes if a user is logged in. This concept is called *navigation
    guards.* You can read up on the navigation guards section in the official documentation
    at [https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html).
    In the next chapter, we’ll look at testing and how we can use it to make sure
    our app is doing what we expect.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们接下来能做什么。通过会话属性，我们可以设置应用程序的不同部分，只有当用户登录时才能访问。我们可以使用 `v-if` 指令或通过路由器来实现这一点。通过路由器，我们可以给一个路由添加一个元标签。然后我们可以使用
    `router.beforeEach` 来在用户登录时导航到特定的路由。这个概念被称为 *导航守卫*。你可以在官方文档的导航守卫部分了解更多信息，网址为 [https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html)。在下一章中，我们将探讨测试以及我们如何使用它来确保我们的应用程序按预期工作。
- en: Exercise
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer the following question:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答以下问题：
- en: What’s one advantage of using `asycData` in your Nuxt apps versus using middleware?
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `asycData` 在你的 Nuxt 应用程序中与使用中间件相比，有什么优势？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅附录 B 中的解决方案（kindle_split_026.html#app02）。*'
- en: Summary
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: You can use libraries like Axios to talk to web APIs.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用像 Axios 这样的库与 Web API 通信。
- en: Fast-loading sites can be created with server-side rendered Nuxt.js apps.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用服务器端渲染的 Nuxt.js 应用程序创建快速加载的网站。
- en: You can grab information from an online datastore using Firebase.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Firebase 从在线数据存储中获取信息。
- en: Users can be authenticated inside your application.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在你的应用程序中进行身份验证。
- en: Chapter 12\. Testing
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章\. 测试
- en: '*This chapter covers*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding why we test
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们要进行测试
- en: Implementing unit tests
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单元测试
- en: Testing components
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Testing Vuex
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Vuex
- en: 'We’ve discussed many important topics in this book, but one often-neglected
    topic doesn’t get enough attention: testing. Testing is an extremely important
    aspect in any software development project. It ensures that the app behaves the
    way we expect it to—without bugs. In this chapter, we’ll discuss why you should
    create tests for your application. Then we’ll look at the fundamentals of unit
    testing. Next, we’ll look at component testing, both the output and the methods.
    Finally, we’ll see how to get started testing with Vuex.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中讨论了许多重要的话题，但一个经常被忽视的话题没有得到足够的关注：测试。测试是任何软件开发项目中极其重要的一个方面。它确保应用程序的行为符合我们的预期——没有错误。在本章中，我们将讨论为什么你应该为你的应用程序创建测试。然后我们将探讨单元测试的基础。接下来，我们将探讨组件测试，包括输出和方法。最后，我们将了解如何开始使用
    Vuex 进行测试。
- en: It’s worth mentioning before we start that testing is a huge subject. In this
    chapter, I’ll cover several of the most important aspects of testing with Vue.js.
    I strongly recommend you look over Edd Yerburgh’s *Testing Vue.js Applications*
    (Manning, 2018). In his book, Edd delves into much more detail on creating and
    developing tests. He also covers server-side rendering testing, snapshot testing,
    and testing mixins and filters.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，值得提一下，测试是一个很大的主题。在本章中，我将涵盖使用 Vue.js 进行测试的几个最重要的方面。我强烈推荐你阅读 Edd Yerburgh
    的 *Testing Vue.js Applications*（Manning，2018）。在他的书中，Edd 深入探讨了创建和开发测试的更多细节。他还涵盖了服务器端渲染测试、快照测试以及测试混合和过滤器。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Snapshot testing**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**快照测试**'
- en: Snapshot tests are useful tools when you want to ensure that the UI doesn’t
    change unexpectedly. In this chapter, I’ll use mocha-webpack, which doesn’t support
    snapshot testing as of this writing. However, if you want to learn more about
    snapshot testing, look over the official guides for more information on how to
    set up Jest with snapshot testing at [http://mng.bz/1Rur](http://mng.bz/1Rur).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试是在你想要确保用户界面不会意外改变时非常有用的工具。在本章中，我将使用mocha-webpack，截至写作时它不支持快照测试。然而，如果你想了解更多关于快照测试的信息，请查看官方指南，了解如何设置Jest与快照测试一起使用，更多信息请访问[http://mng.bz/1Rur](http://mng.bz/1Rur)。
- en: '|  |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 12.1\. Creating test cases
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 创建测试用例
- en: 'Typically, in the world of software development, there are two ways of testing
    code: manually and automated. Let’s talk about coding manually first.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在软件开发的世界里，有两种测试代码的方式：手动和自动化。让我们先谈谈手动编码。
- en: You probably started testing manually as soon as you started coding. For every
    line of code you’ve written, you’ve probably gone back and checked to make sure
    the output you expect is occurring. For example, in our pet store app we added
    a button that added a product to our cart. In the previous chapters we tested
    that manually by clicking the button and then checking the number of items in
    the cart.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从开始编码的那一刻起就开始手动测试了。对于你写的每一行代码，你可能都回去检查以确保你期望的输出正在发生。例如，在我们的宠物商店应用程序中，我们添加了一个按钮，可以将产品添加到购物车中。在前几章中，我们通过点击按钮然后检查购物车中的项目数量来手动测试了这一点。
- en: In our pet store app, we also added a button that routes to the checkout page.
    Once again, we can click that button and make sure that it redirects properly.
    Manual testing works fine for smaller apps where there isn’t much going on.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的宠物商店应用程序中，我们还添加了一个按钮，该按钮将路由到结账页面。再次点击该按钮，我们可以确保它正确地重定向。对于功能较少的应用程序，手动测试效果很好。
- en: Now let’s imagine a scenario where we’re working with a team of developers.
    We have an app in production and many developers are working on the code. Developers
    are pushing code throughout the day to the version control system. As you can
    imagine, relying on every developer to thoroughly test their code manually and
    verify they haven’t broken anything is impossible. Manual testing is a nightmare
    and bugs could certainly crop up.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一个场景，我们正在与一组开发者合作。我们有一个在生产中的应用程序，许多开发者正在编写代码。开发者整天都在将代码推送到版本控制系统。正如你可以想象的那样，依赖每个开发者手动彻底测试他们的代码并验证他们没有破坏任何东西是不可能的。手动测试是一场噩梦，错误肯定会出现。
- en: In certain organizations, a quality assurance department is responsible for
    manually testing code after the development department releases it. This helps
    reduce the chances of a bug reaching production but it slows down the whole process.
    In addition, many quality assurance developers don’t have the resources or time
    to run a complete *regression test* on the code.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些组织中，质量保证部门负责在开发部门发布代码后手动测试代码。这有助于减少错误达到生产的风险，但会减慢整个过程。此外，许多质量保证开发者没有资源或时间对代码进行完整的*回归测试*。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Regression testing* is a type of software testing that verifies that the application
    still performs the same way after it was updated.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '*回归测试*是一种软件测试类型，它验证在应用程序更新后，应用程序是否仍然以相同的方式运行。'
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: But automated testing can help solve several of the problems that manual testing
    runs into. In our imaginary scenario, we could create several automated tests
    that a developer could run before pushing their code to production. Automated
    tests run much quicker then manual testing and they’re more likely to catch bugs
    immediately. With many automated test cases, a developer can run a full regression
    on a code base and not worry about having to manually test everything, which is
    time-consuming.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 但自动化测试可以帮助解决手动测试遇到的一些问题。在我们的假设场景中，我们可以创建几个自动化测试，开发者可以在将代码推送到生产之前运行。自动化测试比手动测试运行得更快，并且更有可能立即捕获到错误。有了许多自动化测试用例，开发者可以在代码库上运行完整的回归测试，而不必担心手动测试每一件事，这会花费很多时间。
- en: Although automated testing has many benefits, it has its disadvantages. The
    one disadvantage that you must consider is the upfront cost. Writing test cases
    takes time, and although you’ll probably save time in the long run, you’ll spend
    a longer time writing test cases when compared with writing the code. After everything
    is set up though, processes such as continuous integration, delivery, and deployment
    can save time, as we’ll see in the next section.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动化测试有许多好处，但它也有其缺点。你必须考虑的一个缺点是前期成本。编写测试用例需要时间，虽然从长远来看你可能会节省时间，但与编写代码相比，编写测试用例会花费更多的时间。然而，一旦一切设置完成，持续集成、交付和部署等流程可以节省时间，正如我们将在下一节中看到的。
- en: 12.2\. Continuous integration, delivery, and deployment
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 持续集成、交付和部署
- en: Automated testing has the added benefit of enabling workflows such as continuous
    development. This workflow consists of continuous integration, delivery, and deployments.
    As the name suggests, these workflows are closely related. We’ll briefly discuss
    each one.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试除了能带来持续开发等工作流程的便利外，还有额外的优势。这个工作流程包括持续集成、交付和部署。正如其名所示，这些工作流程密切相关。我们将简要讨论每一个。
- en: Imagine we’re creating a basic app that connects to a database and retrieves
    information for a book website. We have a team of developers working on the code
    base, but the team is running into a number of issues. Most developers are having
    merge conflicts when they push their code into their version control system every
    few weeks. In addition, every Friday one person is responsible for manually creating
    a *staging environment* for the latest code. (A staging environment runs production
    code for testing purposes.) This increasingly has taken more time to do because
    the code base has gotten larger and more complicated. Pushing to production is
    no better. Half the time the production code won’t build correctly, and it takes
    hours to fix. The manager has decided to switch to continuous development to help
    fix these problems. The first step in that process is continuous integration.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在创建一个基本的连接数据库并检索书籍网站信息的应用程序。我们有一个开发团队在代码库上工作，但团队遇到了一些问题。大多数开发者在每隔几周将代码推送到版本控制系统时都会遇到合并冲突。此外，每周五有一个人负责手动创建最新的代码的*预发布环境*。（预发布环境用于测试目的，运行生产代码。）由于代码库变得更大、更复杂，这个过程越来越耗时。推送到生产环境的情况也好不到哪里去。一半的时间生产代码无法正确构建，修复它需要数小时。经理决定转向持续开发以帮助解决这些问题。这个过程的第一步是持续集成。
- en: 12.2.1\. Continuous integration
  id: totrans-574
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1\. 持续集成
- en: '*Continuous integration* (CI) is the practice of merging code into a *master
    branch* several times a day.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成*（CI）是指每天将代码合并到*主分支*的实践。'
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *master branch* is where the production code usually resides. A *branch* is
    a version-control term that describes a duplication of a code base so modifications
    can happen in parallel in both branches.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '*主分支*是生产代码通常存放的地方。*分支*是一个版本控制术语，它描述了代码库的副本，以便可以在两个分支中并行进行修改。'
- en: '|  |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The obvious benefit of CI is that it helps avoid merge conflicts. Merge conflicts
    happen when multiple developers try to merge or combine their code into a single
    branch. Merging code into a master branch several times a day helps avoid one
    developer’s work-in-progress breaking another developer’s code. Because the master
    branch is updated continuously, another developer working on the same project
    can easily pull the latest code down into their own development environment and
    be relatively sure it’s up to date.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: CI的明显好处是它有助于避免合并冲突。合并冲突发生在多个开发者试图将他们的代码合并或组合到单个分支时。每天将代码合并到主分支几次有助于避免一个开发者的工作进度破坏另一个开发者的代码。因为主分支是持续更新的，所以另一个在同一项目上工作的开发者可以轻松地将最新代码拉入自己的开发环境，并相对确信它是最新的。
- en: In our imaginary scenario, our manager decides to make the CI process smoother
    by implementing a service that helps run automated test cases before any developer
    can push their code. In version control systems like Git, developers can submit
    pull requests. Services such as Travis, CircleCI, and Jenkins can help check that
    the pull request passes all the test cases before the code can be merged. After
    the systems are in place, the team has seen fewer merge conflicts, but they still
    have problems with deployment.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的假设场景中，我们的经理决定通过实施一个在开发者推送代码之前帮助运行自动化测试用例的服务来使持续集成过程更加顺畅。在Git这样的版本控制系统中，开发者可以提交拉取请求。像Travis、CircleCI和Jenkins这样的服务可以帮助检查在代码合并之前拉取请求是否通过了所有测试用例。在系统就绪后，团队看到合并冲突减少了，但他们仍然在部署方面存在问题。
- en: 12.2.2\. Continuous delivery
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. 持续交付
- en: '*Continuous delivery* is a software-engineering approach that aims to build,
    test, and release software in a fast and frequent manner. The purpose is to create
    a fast and reliable deployment pipeline that’s guided by a set of checks that
    must pass before the code is released. For example, before the software is released,
    all test cases must pass and the build must pass without any errors or warnings.
    These types of checks help provide more dependable, consistent releases.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续交付* 是一种软件开发方法，旨在快速且频繁地构建、测试和发布软件。其目的是创建一个快速且可靠的部署管道，该管道由一系列必须通过的检查指导。例如，在软件发布之前，所有测试用例都必须通过，构建必须通过且没有任何错误或警告。这些类型的检查有助于提供更可靠、更一致的发布。'
- en: Typically, CI isn’t the responsibility of the development team. Usually a team
    of people known as DevOps or development operations is responsible for setting
    up and maintaining continuous delivery. It’s good to understand the basics of
    this process and how it relates to testing.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，持续集成不是开发团队的职责。通常，一个被称为DevOps或开发运维的团队负责设置和维护持续交付。了解这一过程的基本知识以及它与测试的关系是很好的。
- en: With continuous delivery, merging or committing code to the master branch triggers
    a build of the website. This can save time because it removes the manual step
    of deploying the website to the staging environment. It has the added benefit
    that it will deploy only if all test cases pass, so it’s less likely that the
    website will be broken.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持续交付，将代码合并或提交到主分支会触发网站的构建。这可以节省时间，因为它消除了将网站手动部署到预发布环境的手动步骤。它还有一个额外的优点，即只有当所有测试用例都通过时才会部署，因此网站出现故障的可能性较小。
- en: With continuous delivery, our team no longer needs to have someone waste hours
    creating and deploying a staging environment. Continuous delivery will make sure
    that it occurs daily. With that said, what does continuous deployment have to
    do with continuous delivery?
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持续交付，我们的团队不再需要有人浪费数小时来创建和部署预发布环境。持续交付将确保它每天都会发生。话虽如此，持续部署与持续交付有什么关系呢？
- en: 12.2.3\. Continuous deployment
  id: totrans-587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3\. 持续部署
- en: '*Continuous deployment* goes one step further than continuous delivery and
    deploys code directly to production on every single change. As with continuous
    delivery, developers can rest assured that all tests pass before the code is deployed
    to production.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续部署* 比持续交付更进一步，它会在每次更改时直接将代码部署到生产环境中。与持续交付一样，开发者可以放心，在代码部署到生产环境之前，所有测试都通过了。'
- en: As you can imagine, deploying to production after every change can be dangerous
    if the automated tests aren’t robust enough to check all parts of the app. The
    worst-case scenario is that a broken website gets deployed to production. At that
    point, a rollback or emergency fix is needed. Now that we’ve seen the way we can
    integrate testing into a workflow, let’s look into what type of tests are available
    and how we can use these test in Vue.js.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，如果自动化测试不足以检查应用程序的所有部分，那么每次更改后都将代码部署到生产环境可能会很危险。最坏的情况是，一个损坏的网站被部署到生产环境中。在这种情况下，需要进行回滚或紧急修复。现在我们已经看到了如何将测试集成到工作流程中，让我们来看看有哪些类型的测试可用以及我们如何在Vue.js中使用这些测试。
- en: 12.3\. Types of tests
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 测试类型
- en: In the world of testing, we can create several types of tests. In this chapter
    we’ll look at the most common, including unit and component testing.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的世界里，我们可以创建多种类型的测试。在本章中，我们将探讨最常见的一些，包括单元测试和组件测试。
- en: '*Unit tests* are tests against the smallest parts of our application. These
    are often functions in our apps, but not always. They can also be components.
    Let’s begin by creating a basic unit test to see how it works.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*是对我们应用程序最小部分的测试。这些通常是我们的应用程序中的函数，但并不总是。它们也可以是组件。让我们先创建一个基本的单元测试来看看它是如何工作的。'
- en: Unit tests have unique advantages. For one, they’re fast and run quickly. Because
    they only test a small piece of code, they can run fast. They can also act as
    documentation. They’re instructions on how the code should behave. Unit tests
    are also reliable because they only test a small part of the code. They can be
    run thousands of times and produce the same output. Unlike other tests that might
    have to rely on APIs that frequently fail, unit tests should never have this problem.
    Imagine a scenario where you’ve created an application that converts the temperature
    from Fahrenheit to Celsius. In this app, we have one function that does the conversion.
    We could easily create a unit test to verify that the amount returned was correct.
    You can see that in this listing.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试具有独特的优势。首先，它们运行速度快。因为它们只测试一小段代码，所以可以快速运行。它们还可以充当文档。它们是关于代码应该如何行为的说明。单元测试也是可靠的，因为它们只测试代码的一小部分。它们可以被运行数千次并产生相同的输出。与可能必须依赖经常失败的API的其他测试不同，单元测试不应该出现这种问题。想象一下这样一个场景，你创建了一个将华氏度转换为摄氏度的应用程序。在这个应用中，我们有一个执行转换的函数。我们可以轻松地创建一个单元测试来验证返回的数值是否正确。你可以在下面的列表中看到这一点。
- en: 'Listing 12.1\. A basic unit test: chapter-12/unit.js'
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1. 一个基本的单元测试：chapter-12/unit.js
- en: '[PRE48]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* A basic unit test that checks the convert function.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 检查转换函数的基本单元测试。**'
- en: The second type of tests we’re going to look at are *component tests*. These
    tests run against each component and verify how they should behave. They can be
    a little more complicated than unit tests because they test more of the application
    and they’re more difficult to debug. But they verify that the component meets
    its requirements and achieves its goal.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第二种测试类型是*组件测试*。这些测试针对每个组件运行并验证它们应该如何表现。它们可能比单元测试更复杂，因为它们测试了更多的应用程序，并且更难调试。但它们验证组件是否满足其要求并实现其目标。
- en: 12.4\. Setting up our environment
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 设置我们的环境
- en: Now that we have a good idea about the kinds of tests that are out there and
    why we should test, let’s set up our environment. Our pet store app could use
    several tests, so let’s add them.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对现有的测试类型和为什么我们应该进行测试有了很好的了解，让我们设置我们的环境。我们的宠物商店应用可能需要几个测试，所以让我们添加它们。
- en: In this section we’ll modify our pet store application so we can use the latest
    testing libraries recommended by Vue.js. As of this writing, the Vue-CLI didn’t
    have these libraries built in when we generated our project, so we’ll need to
    do a little setup. This will require us to install several packages and configure
    a few files.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改我们的宠物商店应用程序，以便我们可以使用Vue.js推荐的最新测试库。截至写作时，Vue-CLI在我们生成项目时并没有内置这些库，所以我们需要做一些设置。这需要我们安装几个包并配置一些文件。
- en: To begin our setup, we’ll need to get a copy of our pet store app. If you’ve
    been following along, feel free to use the app you’ve created. If not, copy the
    pet store app from [chapter 11](kindle_split_023.html#ch11) at [https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的设置，我们需要获取我们的宠物商店应用的副本。如果你一直在跟随，你可以自由使用你创建的应用。如果没有，请从[第11章](kindle_split_023.html#ch11)在[https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode)复制宠物商店应用。
- en: The vue-test-utils is the official unit-testing library for Vue.js. It makes
    testing Vue.js much easier and you should use it. We’ll cover the basics of the
    library in this chapter; if you’d like more information, you can read how it works
    in the official guides at [https://vue-test-utils.vuejs.org](https://vue-test-utils.vuejs.org).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: vue-test-utils是Vue.js的官方单元测试库。它使Vue.js的测试变得更容易，你应该使用它。我们将在本章中介绍库的基本知识；如果你需要更多信息，你可以在官方指南中阅读它是如何工作的，[https://vue-test-utils.vuejs.org](https://vue-test-utils.vuejs.org)。
- en: You may remember from [chapter 7](kindle_split_018.html#ch07), that when we
    created the pet store app we said yes to Nightwatch and Karma. This will work
    but at the time of writing, the Vue-CLI doesn’t support the vue-test-utils library
    out of the box. Because this library isn’t installed by default, we need to install
    it.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从[第7章](kindle_split_018.html#ch07)，当我们创建宠物商店应用时，我们选择了Nightwatch和Karma。这将工作，但在写作的时候，Vue-CLI默认不支持vue-test-utils库。因为这个库默认没有安装，我们需要安装它。
- en: We’ll also need to make a choice regarding which test-runner we want to use
    within the vue-test-utils library. A test-runner will pick up the unit tests that
    we create and execute them. When we first installed our pet store app, Mocha and
    Karma were our only test-runner choices. Karma works with vue-test-utils but it
    isn’t officially recommended. The vue-test-utils team recommends either Jest or
    mocha-webpack. Because we already have Mocha installed, we’ll go ahead and install
    mocha-webpack. Jest is also an excellent choice, but it won’t be covered in this
    book.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在vue-test-utils库中选择一个我们想要使用的测试运行器。测试运行器会抓取我们创建的单元测试并执行它们。当我们第一次安装我们的宠物商店应用时，Mocha和Karma是我们的唯一测试运行器选择。Karma与vue-test-utils兼容，但并不被官方推荐。vue-test-utils团队推荐使用Jest或mocha-webpack。因为我们已经安装了Mocha，我们将继续安装mocha-webpack。Jest也是一个很好的选择，但本书不会涉及它。
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that if you choose Jest, all the tests in this book will still
    work, but you’ll have a little different setup. You can find instructions on how
    to set up Jest at the official guides at [http://mng.bz/3Dch](http://mng.bz/3Dch).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你选择Jest，本书中的所有测试仍然会工作，但你会有一个稍微不同的设置。你可以在官方指南[http://mng.bz/3Dch](http://mng.bz/3Dch)中找到如何设置Jest的说明。
- en: '|  |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Because we’re going to use mocha-webpack as our test runner, we’ll need to install
    a few other things. To run tests, we’ll need a browser. We could run our tests
    in a real browser, such as Chrome or Firefox, but it’s not recommended because
    running in a browser can be slow and it’s not as flexible as using a headless
    browser. Instead we’ll use modules called jsdom and jsdom-global. These modules
    will simulate a browser for us; they’re *headless browsers* used to run our test
    cases.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用mocha-webpack作为测试运行器，所以我们需要安装一些其他的东西。为了运行测试，我们需要一个浏览器。我们可以在真实的浏览器中运行我们的测试，例如Chrome或Firefox，但这并不推荐，因为浏览器中的运行可能会很慢，而且不如使用无头浏览器灵活。相反，我们将使用名为jsdom和jsdom-global的模块。这些模块将为我们模拟浏览器；它们是用于运行我们的测试用例的**无头浏览器**。
- en: '|  |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *headless browser* doesn’t have a graphical user interface (GUI) and is used
    to facilitate automated control of a web page. The headless browser performs much
    the same as contemporary browsers, but interaction is typically accomplished through
    a CLI.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**无头浏览器**没有图形用户界面（GUI），用于简化网页的自动化控制。无头浏览器执行的功能与当代浏览器非常相似，但交互通常是通过命令行界面（CLI）完成的。
- en: '|  |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We’ll need to pick an assertion library, and Chai and Expect are popular choices.
    Assertion libraries are used to verify things are correct instead of relying on
    things like `if` statements. The vue-test-utils team recommends using Expect with
    mocha-webpack, so we’ll go ahead and install that. You can find more information
    on picking an assertion library at [http://mng.bz/g1yp](http://mng.bz/g1yp).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要选择一个断言库，Chai和Expect是流行的选择。断言库用于验证事物是否正确，而不是依赖于像`if`语句这样的东西。vue-test-utils团队推荐与mocha-webpack一起使用Expect，因此我们将继续安装它。你可以在[http://mng.bz/g1yp](http://mng.bz/g1yp)上找到有关选择断言库的更多信息。
- en: That last library we need to install is the webpack-node-externals. This will
    help us exclude certain npm dependencies from our test bundle.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要安装的库是webpack-node-externals。这将帮助我们排除测试包中的某些npm依赖项。
- en: Retrieve the latest version of the pet store app that’s included with this book.
    Beware, if you download the latest version of the pet store app from [chapter
    11](kindle_split_023.html#ch11) you’ll need to enter your Firebase configuration
    inside the firebase.js file in the src folder if you haven’t done so already.
    If you forget this step the application will not load!
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 获取本书包含的宠物商店应用的最新版本。请注意，如果你从[第11章](kindle_split_023.html#ch11)下载宠物商店应用的最新版本，如果你还没有这样做，你需要在src文件夹中的firebase.js文件内输入你的Firebase配置。如果你忘记这一步，应用程序将无法加载！
- en: 'After you retrieve the latest version of the pet store app, install these dependencies
    by running the following commands:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取宠物商店应用的最新版本后，通过运行以下命令安装这些依赖项：
- en: '[PRE49]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After the dependencies are installed, we’ll add configuration. Edit the webpack.base.conf.js
    file in the build folder of the pet store app. Copy and paste the code from the
    following listing at the bottom of the file to configure the webpack-node-externals
    and inline-cheap-module-source map. This is required by those modules for everything
    to work correctly.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了依赖项之后，我们将添加配置。编辑宠物商店应用构建文件夹中的webpack.base.conf.js文件。将以下列表中的代码复制并粘贴到文件底部以配置webpack-node-externals和inline-cheap-module-source
    map。这些模块需要这些配置才能正确工作。
- en: 'Listing 12.2\. Setting up source map and node externals: chapter-12/setup.js'
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 设置源映射和节点外部：chapter-12/setup.js
- en: '[PRE50]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Sets up the test environment**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置测试环境**'
- en: Inside the test folder you’ll notice the unit and e2e folders. We won’t use
    these folders, so feel free to delete them. Add a new file called setup.js inside
    the test folder. The setup.js file is where we’ll set the global variables for
    `jsdom-global` and `expect`. This will make it so we don’t have to import both
    modules into every single test case. Copy and paste the code from this listing
    into the test/setup.js file.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件夹中，你会注意到有 unit 和 e2e 文件夹。我们不会使用这些文件夹，所以你可以随意删除它们。在测试文件夹中添加一个名为 setup.js
    的新文件。setup.js 文件是我们设置 `jsdom-global` 和 `expect` 的全局变量的地方。这将使得我们不需要在每个测试用例中导入这两个模块。将此列表中的代码复制并粘贴到
    test/setup.js 文件中。
- en: 'Listing 12.3\. Setting up tests: chapter-12/petstore/setup.js'
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 设置测试：chapter-12/petstore/setup.js
- en: '[PRE51]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Sets up jsdom-globa**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置 jsdom-globa**'
- en: '***2* Sets expect inside app**'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 app 中设置 expect**'
- en: Next, we need to update the test script in the package.json file. This script
    will run the mocha-webpack test runner and our tests. For the sake of simplicity,
    all tests will have a `spec.js` file extension. Edit the package.json file and
    replace the scripts test section with this line.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 package.json 文件中的测试脚本。这个脚本将运行 mocha-webpack 测试运行器和我们的测试。为了简化，所有测试都将具有
    `spec.js` 文件扩展名。编辑 package.json 文件，并将脚本测试部分替换为以下行。
- en: 'Listing 12.4\. Updating package.json: chapter-12/testscript.js'
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. 更新 package.json：chapter-12/testscript.js
- en: '[PRE52]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Notes the test script inside package.json file**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录 package.json 文件中的测试脚本**'
- en: That is all the configuration we need for our setup. Now we can start creating
    test cases!
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有配置。现在我们可以开始创建测试用例了！
- en: 12.5\. Creating our first test case with vue-test-utils
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 使用 vue-test-utils 创建我们的第一个测试用例
- en: For our first test using vue-test-utils, let’s see if we can verify that our
    Form component works correctly after clicking the Order button. When you click
    the Order button on the form component, an alert box appears. We can test for
    an alert box, but it’s not easy with our setup and will require us to change our
    jsdom-global configuration. For the purposes of this test, we’ll create a property
    called `madeOrder`. This will be defaulted to `false`. After clicking the Order
    button, it will turn `true`.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们第一个使用 vue-test-utils 的测试，让我们看看我们是否可以验证在点击 Order 按钮后我们的 Form 组件是否正常工作。当你点击表单组件上的
    Order 按钮时，会出现一个警告框。我们可以测试警告框，但我们的设置并不容易，并且需要我们更改我们的 jsdom-global 配置。为了这个测试的目的，我们将创建一个名为
    `madeOrder` 的属性。它将默认为 `false`。点击 Order 按钮后，它将变为 `true`。
- en: The order form will be updated so it shows a message at the bottom that the
    order is complete ([figure 12.1](#ch12fig01)). When `madeOrder` is `true`, the
    text will appear. When it’s `false`, the text will not show up. We add this so
    we can get a little more feedback when the order button is clicked, because we’re
    no longer going to use the alert box.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 订单表单将被更新，以在底部显示完成订单的消息（[图 12.1](#ch12fig01)）。当 `madeOrder` 为 `true` 时，文本将出现。当它为
    `false` 时，文本将不会显示。我们添加这个是为了在点击订单按钮时获得更多反馈，因为我们不再使用警告框。
- en: Figure 12.1\. Pet depot checkout page that displays Ordered at the bottom
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.1\. 显示底部已订单的宠物仓库结账页面
- en: '![](12fig01_alt.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig01_alt.jpg)'
- en: To make this change, we need to update the src/components/Form.vue file Add
    a new property in the file called `madeOrder` in the data function. Edit the `submitForm`
    method and delete the alert box, then add `this.madeOrder = true`. This will guarantee
    that the property is set to `true` when the app starts up. Update the src/components/Form.vue
    with the code in this listing.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行此更改，我们需要更新 src/components/Form.vue 文件。在文件中的 data 函数中添加一个名为 `madeOrder` 的新属性。编辑
    `submitForm` 方法并删除警告框，然后添加 `this.madeOrder = true`。这将确保当应用启动时属性被设置为 `true`。使用此列表中的代码更新
    src/components/Form.vue。
- en: 'Listing 12.5\. Update to the `Form` component: chapter-12/form-update.js'
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.5\. 更新 `Form` 组件：chapter-12/form-update.js
- en: '[PRE53]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Adds a new property for madeOrder**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为 madeOrder 添加新属性**'
- en: '***2* Sets madeOrder to true**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 madeOrder 设置为 true**'
- en: We’re now ready to create our first test case. Let’s verify that after the Place
    Order button is clicked, the `madeOrder` property is set to true. To test this,
    we’ll use the vue-js-utils `shallow` function. The `shallow` function renders
    a Vue component and stubs out any child components it has. The other common function
    is `mount` which works the same as `shallow`, except it doesn’t stub the child
    component.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建我们的第一个测试用例了。让我们验证在点击“下单”按钮后，`madeOrder` 属性是否被设置为 `true`。为了测试这一点，我们将使用
    vue-js-utils 的 `shallow` 函数。`shallow` 函数渲染一个 Vue 组件并模拟其任何子组件。另一个常见的函数是 `mount`，它的工作方式与
    `shallow` 相同，只不过它不会模拟子组件。
- en: We’ll also need to import the `Form` component. We’ll pass this into the `shallow`
    function later to create a wrapper around it. Next, you’ll notice something called
    `describe`. The `describe` function is used to group similar tests together into
    a test suite. When we run the tests from the command line, we can see whether
    the test suite passed or failed.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入 `Form` 组件。稍后我们将将其传递给 `shallow` 函数以创建其包装。接下来，你会注意到一个名为 `describe` 的东西。`describe`
    函数用于将类似的测试组合成一个测试套件。当我们从命令行运行测试时，我们可以看到测试套件是否通过或失败。
- en: The `it` function is a test case. This will be our unit test that tests our
    button and verifies that it updated the `madeOrder` property correctly. We can
    have multiple test cases in each test suite.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`it` 函数是一个测试用例。这将是我们测试按钮并验证它是否正确更新了 `madeOrder` 属性的单元测试。我们可以在每个测试套件中拥有多个测试用例。'
- en: Because we’re using the expect assertion library, we’ll use it to make sure
    that the `madeOrder` property is set to `true`. In [listing 12.6](#ch12ex06) we’re
    using `wrapper.vm.madeOrder` to access the property. The wrapper object returned
    from the `shallow` function has several properties including one called `vm`.
    We can use the `vm` property to access any Vue instance methods or properties,
    allowing us to run any method or get any property inside the Vue component. This
    is handy.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 expect 断言库，我们将使用它来确保 `madeOrder` 属性被设置为 `true`。在 [列表 12.6](#ch12ex06)
    中，我们使用 `wrapper.vm.madeOrder` 来访问该属性。从 `shallow` 函数返回的包装对象有几个属性，包括一个名为 `vm` 的属性。我们可以使用
    `vm` 属性来访问任何 Vue 实例方法或属性，这允许我们在 Vue 组件内部运行任何方法或获取任何属性。这很方便。
- en: '`wrapper` also has a `find` function that accepts a selector. The `find` function
    can use any valid CSS selector, such as tag names, IDs, or classes. We can then
    use the `trigger` function to trigger the event—in this case, a click event on
    the button. Take the following listing and create a new Form.spec.js file.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper` 还有一个接受选择器的 `find` 函数。`find` 函数可以使用任何有效的 CSS 选择器，例如标签名、ID 或类。然后我们可以使用
    `trigger` 函数来触发事件——在这种情况下，按钮上的点击事件。根据以下列表创建一个新的 Form.spec.js 文件。'
- en: 'Listing 12.6\. Our first test case: chapter-12/petstore/test/Form.spec.js'
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. 我们的第一个测试用例：chapter-12/petstore/test/Form.spec.js
- en: '[PRE54]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Imports shallow to use in the test case**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在测试用例中导入 shallow**'
- en: '***2* Imports the form component**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入表单组件**'
- en: '***3* Assigns the wrapper to shallow version of component**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将包装器分配给组件的 shallow 版本**'
- en: '***4* Finds then triggers the button**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 查找并触发按钮**'
- en: '***5* Verifies madeOrder is true**'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 验证 madeOrder 是否为 true**'
- en: Let’s run our test cases. Make sure you’re in the pet store top-level directory
    and run the `npm test` command. This should run our test suite. If you see an
    error, make sure you installed all the dependencies that we discussed earlier
    and verify the package.json file has the test script inside it. [Figure 12.2](#ch12fig02)
    displays what we’ll see when all of our tests pass!
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试用例。确保你处于宠物商店顶级目录，并运行 `npm test` 命令。这应该会运行我们的测试套件。如果你看到错误，请确保你安装了之前讨论的所有依赖项，并验证
    package.json 文件中是否包含测试脚本。[图 12.2](#ch12fig02) 显示了当所有测试都通过时我们会看到的内容！
- en: Figure 12.2\. Checking our first test case, which is successful
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.2\. 检查我们的第一个测试用例，它是成功的
- en: '![](12fig02_alt.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig02_alt.jpg)'
- en: Because everything passed, a successful message is displayed. Let’s see what
    it looks like when it fails. Go back into the petstore/test/Form.spec.js file.
    Look for the `expect` statement and set the value to `false` instead of `true`.
    Run the command `npm test` again and it should fail. Notice from [figure 12.3](#ch12fig03)
    that the expected value and the received value are displayed in the output.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切通过，显示了一个成功消息。让我们看看它失败时是什么样子。回到 petstore/test/Form.spec.js 文件。查找 `expect`
    语句并将值设置为 `false` 而不是 `true`。再次运行 `npm test` 命令，它应该会失败。注意从 [图 12.3](#ch12fig03)
    中可以看到，预期的值和接收到的值在输出中显示。
- en: Figure 12.3\. The test case fails
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.3\. 测试用例失败
- en: '![](12fig03_alt.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig03_alt.jpg)'
- en: Now that we understand the basics of testing, let’s look at testing components.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了测试的基本知识，让我们来看看如何测试组件。
- en: 12.6\. Testing components
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6\. 测试组件
- en: Before we test our components, we need a general idea of our specifications.
    What should we expect the components to do? We’ll use our pet store app as an
    example.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试组件之前，我们需要对我们的规范有一个大致的了解。我们应该期望组件做什么？我们将使用我们的宠物商店应用作为例子。
- en: 'We have three components in our application: `Main`, `Header`, and `Form`.
    The `Header` component’s job is to display the number of items in the shopping
    cart and to show either a Sign In or a Sign Out button. The `Form` component’s
    responsibility is to show all our form inputs, and it gives us an option to order
    by clicking the Order button. `Main` is used to display all our products. It needs
    to render all the components from our Firebase store.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中有三个组件：`Main`、`Header` 和 `Form`。`Header` 组件的职责是显示购物车中的项目数量，并显示登录或注销按钮。`Form`
    组件的职责是显示所有表单输入，并提供通过点击订单按钮进行订购的选项。`Main` 用于显示所有产品。它需要渲染来自 Firebase 存储的所有组件。
- en: We won’t test every component, but it’s important to write down specifications
    for each component before creating any test cases. That way we’ll know what to
    test.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会测试每个组件，但在创建任何测试用例之前为每个组件写下规范是很重要的。这样我们就会知道要测试什么。
- en: 12.6.1\. Testing props
  id: totrans-666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.1\. 测试属性
- en: Many of our components will have props that are passed in to them. For example,
    in our pet store app, the `cartItemCount` is passed into our `Header` component
    and displayed in the top right corner. Let’s create a test case that verifies
    that this prop is passed in.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多组件都将有传入的属性。例如，在我们的宠物商店应用中，`cartItemCount` 被传递到我们的 `Header` 组件，并在右上角显示。让我们创建一个测试用例来验证这个属性是否被传递。
- en: Create a file in the petstore/test/ directory called Header.spec.js. This file
    will contain all our tests for the `Header` component. Before we can begin, we
    need to do a little setup.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在 petstore/test/ 目录中创建一个名为 Header.spec.js 的文件。这个文件将包含我们对 `Header` 组件的所有测试。在我们开始之前，我们需要做一些设置。
- en: If you look at the Header.vue file, you’ll notice that we’re using Firebase
    and Vuex. The `beforeCreate` hook calls a Firebase function and sets the value
    using a Vuex store command that commits the session. We won’t test Vuex or Firebase
    in this example, but we’ll need to import them, otherwise we’ll get an error.
    Make sure to import both `../src/firebase` and `../src/store/store` as seen in
    [listing 12.7](#ch12ex07).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Header.vue 文件，你会注意到我们正在使用 Firebase 和 Vuex。`beforeCreate` 钩子调用 Firebase
    函数并使用 Vuex 存储命令提交会话来设置值。在这个例子中，我们不会测试 Vuex 或 Firebase，但我们需要导入它们，否则我们会得到错误。确保导入
    `../src/firebase` 和 `../src/store/store`，如 [清单 12.7](#ch12ex07) 所示。
- en: At the top of the file, import `shallow` from the vue-test-utils library. In
    addition, import something called `createLocalVue`. We need this function so we
    can set up Vuex.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，从 vue-test-utils 库中导入 `shallow`。此外，导入一个名为 `createLocalVue` 的东西。我们需要这个函数来设置
    Vuex。
- en: Next, we’ll create a `localVue` variable and assign it to `createLocalVue()`.
    This function returns a `localVue` class. You can think of it as a photocopier
    that produces a photocopy version of Vue. We can use this to help set up Vuex
    for our testing.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `localVue` 变量并将其分配给 `createLocalVue()`。这个函数返回一个 `localVue` 类。你可以把它想象成一个复印机，它产生
    Vue 的复印件。我们可以使用这个来帮助我们为测试设置 Vuex。
- en: You can see from [listing 12.7](#ch12ex07) that we use the `shallow` function
    again, but it looks a little different than the unit test we created earlier.
    The `shallow` function can accept an optional second argument. This object holds
    more information that the component needs. Inside it, we can set the props data
    using `propsData` as well as `localVue` and `store`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [清单 12.7](#ch12ex07) 中看到我们再次使用了 `shallow` 函数，但它看起来与之前创建的单元测试略有不同。`shallow`
    函数可以接受一个可选的第二个参数。这个对象包含组件需要的更多信息。在其中，我们可以使用 `propsData` 以及 `localVue` 和 `store`
    来设置属性数据。
- en: To set the props, we must pass something in to it. The easiest way to do that
    is to add `cartItemCount`. We pass that variable into the `propsData`, and it
    will be set inside the `Header` component.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置属性，我们必须向其中传递一些内容。最简单的方法是添加 `cartItemCount`。我们将这个变量传递到 `propsData` 中，它将在 `Header`
    组件内部设置。
- en: The last thing we do is check that the `wrapper.vm.cartItemCount` matches the
    `cartItemCount` variable. If they’re the same, the test passes. Take the code
    in the next listing and copy it to the petstore/test/Header.spec.js file.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要检查的是 `wrapper.vm.cartItemCount` 是否与 `cartItemCount` 变量匹配。如果它们相同，测试通过。将下一列表中的代码复制到
    petstore/test/Header.spec.js 文件中。
- en: 'Listing 12.7\. Testing a prop: chapter-12/header-prop-test.js'
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. 测试属性：chapter-12/header-prop-test.js
- en: '[PRE55]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Imports Vuex into test case**'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Vuex 导入到测试用例中**'
- en: '***2* Imports Firebase into test case**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 Firebase 导入到测试用例中**'
- en: '***3* Imports Vuex store into test case**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 Vuex 存储导入到测试用例中**'
- en: '***4* The new wrapper const has a second argument.**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 新的包装器 const 有一个第二个参数。**'
- en: '***5* The props data is set to cartItemCount.**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 属性数据设置为 cartItemCount。**'
- en: '***6* Expect verifies that the cartItemCount matches from the passed-in prop.**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 期望验证传入的属性中 cartItemCount 是否匹配。**'
- en: Now that we can check props, let’s look at text.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够检查属性，让我们看看文本。
- en: 12.6.2\. Testing text
  id: totrans-684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.2\. 测试文本
- en: Sometimes you want to test if text is rendered somewhere in the component. It
    doesn’t matter what element renders the text, only that an element renders it.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想要测试文本是否在组件的某个地方渲染。无关紧要的是哪个元素渲染了文本，只要有一个元素渲染了它。
- en: Keep in mind when writing tests that each test case should test only one thing.
    It might be easy to create multiple assertions inside a test case that checks
    text, but it’s often better to take these types of tests and create multiple test
    cases out of them. We’ll follow this rule of creating a single assertion in a
    test case.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，请注意每个测试用例应只测试一个功能。在测试用例中创建多个断言以检查文本可能很容易，但通常最好将这些类型的测试拆分成多个测试用例。我们将遵循在测试用例中创建单个断言的规则。
- en: Open the petstore/test/Header.spec.js file and add a new test case. In our last
    test case, we verified that the `cartItemCount` prop was being passed correctly
    into the `Header` component. Now we want to verify whether the text from the prop
    is displayed properly inside the component in the span tag.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 petstore/test/Header.spec.js 文件并添加一个新的测试用例。在我们的上一个测试用例中，我们验证了 `cartItemCount`
    属性是否正确传递到 `Header` 组件中。现在我们想要验证属性中的文本是否在组件的 span 标签内正确显示。
- en: To do this, we’ll create another wrapper the way we did before. This time, we’ll
    use the `wrapper.find` function to look up the span. We can then use the `text()`
    function to extract the text inside the span, which is our `cartItemCount`. We
    then use the `toContain` function to verify that the contents match. Copy the
    code from the following listing into the pet/test/Header.spec.js as another test
    after the last test.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将像之前一样创建另一个包装器。这次我们将使用 `wrapper.find` 函数来查找 span。然后我们可以使用 `text()`
    函数提取 span 内部的文本，即我们的 `cartItemCount`。然后我们使用 `toContain` 函数来验证内容是否匹配。将下一列表中的代码复制到
    pet/test/Header.spec.js 文件中，作为最后一个测试之后的另一个测试。
- en: 'Listing 12.8\. Testing text: chapter-12/header-text-test.js'
  id: totrans-689
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. 测试文本：chapter-12/header-text-test.js
- en: '[PRE56]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* The wrapper finds the span tag.**'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包装器找到 span 标签。**'
- en: '***2* The assertion checks whether the text matches cartItemCount.**'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 断言检查文本是否与 cartItemCount 匹配。**'
- en: 12.6.3\. Testing CSS classes
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.3\. 测试 CSS 类
- en: When testing classes, we can use the method `classes`, which returns an array
    of classes attached to an element. Let’s add a quick check to verify whether the
    class on one of our `divs` is correct.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类时，我们可以使用 `classes` 方法，它返回一个包含附加到元素上的类的数组。让我们快速添加一个检查来验证我们其中一个 `div` 上的类是否正确。
- en: Inside the petstore/test/Header.spec.js file, add a new test case. In this test
    case we’ll create a new wrapper. This time we’ll use a `findAll` which will return
    all the `divs` in the component. We can use the `at(0)` to retrieve the first
    `div`. From there we can use our `expect` statement on `p.classes()` to retrieve
    all the classes attached to the first `div`. The `toContain` will return `true`
    if any of the classes match.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在 petstore/test/Header.spec.js 文件中，添加一个新的测试用例。在这个测试用例中，我们将创建一个新的包装器。这次我们将使用
    `findAll`，它将返回组件中的所有 `div`。我们可以使用 `at(0)` 来检索第一个 `div`。从那里我们可以使用我们的 `expect` 语句在
    `p.classes()` 上来检索附加到第一个 `div` 上的所有类。如果任何类匹配，`toContain` 将返回 `true`。
- en: If we look at the Header.vue file, we’ll notice that both `navbar` and `navbar-default`
    are attached to the first `div`. Because we’re looking for `navbar`, this test
    will pass.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 Header.vue 文件，我们会注意到 `navbar` 和 `navbar-default` 都附加到了第一个 `div` 上。因为我们正在寻找
    `navbar`，这个测试将会通过。
- en: 'Listing 12.9\. Testing classes: chapter-12/header-classes-test.js'
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. 测试类：chapter-12/header-classes-test.js
- en: '[PRE57]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* This looks for all the divs and returns the first one.**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这会查找所有的div并返回第一个。**'
- en: '***2* This checks the classes attached to see if navbar exists.**'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查附加的类以查看navbar是否存在。**'
- en: Before we get too much further, run `npm test` at the command prompt and verify
    that all the tests are passing ([figure 12.4](#ch12fig04)). If any are failing,
    double-check the `expect` statements and that you’re importing everything correctly
    at the top of the file.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入之前，在命令提示符下运行`npm test`并验证所有测试是否通过([图12.4](#ch12fig04))。如果有任何测试未通过，请仔细检查`expect`语句以及你是否在文件顶部正确导入了一切。
- en: Figure 12.4\. All tests are passing
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.4\. 所有测试都通过
- en: '![](12fig04_alt.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig04_alt.jpg)'
- en: All tests are passing, so let’s move on to Vuex.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过，因此让我们继续Vuex。
- en: 12.6.4\. Testing with a mocked Vuex
  id: totrans-705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.4\. 使用mocked Vuex进行测试
- en: The Vuex store is a central location where we can hold data for the application.
    In our pet store app, we used it to set the session data and hold our product
    info. When using Vuex, it’s a smart idea to test the store.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex store是一个中央位置，我们可以在这里保存应用程序的数据。在我们的宠物商店应用程序中，我们使用它来设置会话数据并保存我们的产品信息。当使用Vuex时，测试store是一个明智的选择。
- en: '|  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Vuex testing is complicated and has many moving parts. Unfortunately, I won’t
    cover them all here. To learn more about Vuex testing, start with the official
    Vuex testing guides at [https://vue-test-utils.vuejs.org/guides/using-with-vuex.html](https://vue-test-utils.vuejs.org/guides/using-with-vuex.html).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex测试很复杂，有很多组成部分。不幸的是，我无法在这里全部涵盖。要了解更多关于Vuex测试的信息，请从官方Vuex测试指南开始，见[https://vue-test-utils.vuejs.org/guides/using-with-vuex.html](https://vue-test-utils.vuejs.org/guides/using-with-vuex.html)。
- en: '|  |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For our test cases, we’ll test our `Header` component and how it works when
    the session is set to `true` or `false`. We want to verify that if the session
    exists, the Sign Out button displays and if the session doesn’t exist, the Sign
    Up button displays.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试用例，我们将测试我们的`Header`组件以及当会话设置为`true`或`false`时它的工作方式。我们想要验证如果会话存在，则显示注销按钮，如果会话不存在，则显示注册按钮。
- en: Earlier in this chapter, we imported the store directly into our test file.
    This was only a temporary workaround so we could create other test cases for the
    `Header` component. This won’t work for testing Vuex. To test our Vuex store,
    we’ll need to mock the store completely. This is much simpler than you think.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们直接将store导入到我们的测试文件中。这只是一个临时的解决方案，以便我们可以为`Header`组件创建其他测试用例。这对于测试Vuex是不行的。为了测试我们的Vuex
    store，我们需要完全mock store。这比你想象的要简单得多。
- en: 'At the top of the petstore/test/Header.spec.js file, you’ll see an import of
    the store. Delete this line. We’ll create a *mock* of the store. A mock is an
    object that has the same structure as a complex object that you cannot use in
    your test (similar to our Vuex store), but with an implementation that you can
    control. Beneath the `describe` statement, add the new variables: `store`, `getters`,
    and `mutations`, as shown in [listing 12.10](#ch12ex10). Then create a `beforeEach`
    function. The code inside the `beforeEach` runs before every test case. It’s a
    good place to put setup code.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在`petstore/test/Header.spec.js`文件顶部，你会看到一个对store的导入。删除这一行。我们将创建一个*mock*的store。mock是一个具有与无法在测试中使用（类似于我们的Vuex
    store）的复杂对象相同结构的对象，但具有你可以控制的实现。在`describe`语句下方，添加新的变量：`store`、`getters`和`mutations`，如[列表12.10](#ch12ex10)所示。然后创建一个`beforeEach`函数。`beforeEach`函数中的代码在每一个测试用例之前运行。这是一个放置设置代码的好地方。
- en: For the sake of simplicity, our store will be rudimentary. We’ll have a `getter`
    for `session` that returns `false`, and a `mutation` that returns an empty object.
    We can use `new Vuex.Store` to create the store (make sure you use a capital *S*
    in Store). Copy the code in the following listing into the top of the petstore/test/Header.spec.js
    file.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们的store将是基本的。我们将有一个返回`false`的`getter`用于`session`，以及一个返回空对象的`mutation`。我们可以使用`new
    Vuex.Store`来创建store（确保你在Store中使用大写*S*）。将以下列表中的代码复制到`petstore/test/Header.spec.js`文件的顶部。
- en: 'Listing 12.10\. Mocking Vuex: chapter-12/header-vuex-mock.js'
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表12.10\. Mocking Vuex: chapter-12/header-vuex-mock.js'
- en: '[PRE58]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Shows the store, getters, and mutations variables**'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示store、getters和mutations变量**'
- en: '***2* Runs before each test**'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在每个测试之前运行**'
- en: '***3* The session getter is set to false.**'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 会话getter设置为false。**'
- en: '***4* The mutation SET_SESSION returns an empty object.**'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 变更SET_SESSION返回一个空对象。**'
- en: '***5* A new store is created.**'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建了一个新的store。**'
- en: Now that we’ve mocked our Vuex store, we can use it in our test cases. We can
    assume if the `session` is set to `false,` the Sign In button will be displayed.
    If this is a little confusing, go to the Header.vue file in the src folder, where
    you’ll see a `v-if` directive that relies on a computed property called `mySession`.
    If `mySession` is `false`, the Sign In button is displayed. The `v-else` directive
    shows a Sign Out button if it’s `true`. Copy the code from this listing into the
    petstore/test/Header.js file.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经模拟了 Vuex 存储，我们可以在测试用例中使用它。我们可以假设如果 `session` 设置为 `false`，则登录按钮将显示。如果这有点令人困惑，请转到
    src 文件夹中的 Header.vue 文件，您将看到一个依赖于名为 `mySession` 的计算属性的 `v-if` 指令。如果 `mySession`
    为 `false`，则显示登录按钮。`v-else` 指令在 `mySession` 为 `true` 时显示注销按钮。将此列表中的代码复制到 petstore/test/Header.js
    文件中。
- en: 'Listing 12.11\. Testing Sign In: chapter-12/header-signin-test.js'
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 测试登录：chapter-12/header-signin-test.js
- en: '[PRE59]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* The assertion expect looks at the text of the button and verifies it’s
    Sign In.**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 断言期望检查按钮文本并验证其为“登录”**'
- en: Conversely, we should also check that, if the session is signed in, that the
    Sign Out button displays. You can do this a few ways, but one of the easiest is
    to create a store with a new `getter.session`. When we create the wrapper, the
    new store will be added, and the Header component will act as if the `session`
    were set to `true` instead of `false`. Copy the code from the following listing
    and add it as another test case in the petstore/test/Header.spec.js file.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们也应该检查，如果会话已登录，注销按钮是否显示。您可以通过几种方式来完成此操作，但其中一种最简单的方法是创建一个新的 `getter.session`
    存储。当我们创建包装器时，新的存储将被添加，Header 组件将表现得像 `session` 被设置为 `true` 而不是 `false`。将以下列表中的代码复制并添加到
    petstore/test/Header.spec.js 文件中的另一个测试用例中。
- en: 'Listing 12.12\. Testing Sign Out: chapter-12/header-signout-test.js'
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 测试注销：chapter-12/header-signout-test.js
- en: '[PRE60]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Checks if button text is Sign Out**'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 检查按钮文本是否为“注销”**'
- en: Run the test and they’ll all pass. These are all the tests we’re going to run
    for our pet store app. As an exercise, go into the Forms or Main component and
    add some test cases.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，它们都将通过。这些都是我们将为我们的宠物商店应用程序运行的测试。作为练习，进入表单或主组件并添加一些测试用例。
- en: 12.7\. Setting up the Chrome debugger
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7\. 设置 Chrome 调试器
- en: When you’re debugging tests, you often end up using the console.log to see what
    variables are doing during the execution of code. This works, but there is a better
    way. We can use the Chrome debugger to make our job much easier.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调试测试时，您通常会使用 console.log 来查看变量在代码执行过程中的行为。这可以工作，但有一个更好的方法。我们可以使用 Chrome 调试器来使我们的工作更加容易。
- en: Inside your test cases, you can add a debugger statement. Add the `debugger`
    keyword anywhere in the test. This will stop the execution of code as soon as
    the debugger statement is parsed. This will work only if you use the node inspector
    with the Chrome browser. The *node inspector* is a tool that is built into Node
    8.4.0 or later and helps with debugging with the Chrome browser. To run tests
    with the node inspector, we’ll need to run the following code. You can either
    run this from the command line or add it to your package.json file under scripts.
    Open your package.json file and add this line under the scripts section.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试用例中，您可以添加一个调试语句。在任何测试中添加 `debugger` 关键字。这将使代码在解析调试语句时立即停止执行。这仅当您使用 Chrome
    浏览器与 node inspector 一起使用时才有效。*node inspector* 是 Node 8.4.0 或更高版本中内置的工具，有助于使用 Chrome
    浏览器进行调试。要使用 node inspector 运行测试，我们需要运行以下代码。您可以从命令行运行此代码，或者将其添加到 package.json 文件中的
    scripts 部分。打开您的 package.json 文件，并在 scripts 部分下添加此行。
- en: 'Listing 12.13\. Adding inspect to the package.json file: chapter-12/petstore/package.json'
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. 将检查功能添加到 package.json 文件中：chapter-12/petstore/package.json
- en: '[PRE61]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Runs the script command to inspect the browser**'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 执行脚本命令以检查浏览器**'
- en: 'To run this command type in `npm run inspect` in the console. This will begin
    the node inspector. Alternatively, you can run this command from the command line:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此命令，请在控制台中输入 `npm run inspect`。这将启动节点检查器。或者，您也可以从命令行运行此命令：
- en: '[PRE62]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Either way, a new debugger on localhost 127.0.0.1 will start. You should see
    an output like this:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，都会在 localhost 127.0.0.1 上启动一个新的调试器。您应该看到如下输出：
- en: '[PRE63]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Open your Chrome browser and type the URL: chrome://inspect. This opens a Devices
    page ([figure 12.5](#ch12fig05)).'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 Chrome 浏览器并输入 URL：chrome://inspect。这将打开设备页面（[图 12.5](#ch12fig05)）。
- en: Figure 12.5\. Chrome Devices page
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.5\. Chrome 设备页面
- en: '![](12fig05_alt.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig05_alt.jpg)'
- en: After a few seconds, you should see a target at the bottom and a link that shows
    inspect. Click the Inspect button and a separate window opens. The Inspect window
    starts in the paused state. Click the arrow to start the debugger ([figure 12.6](#ch12fig06)).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你应该在底部看到一个目标和显示“检查”的链接。点击“检查”按钮，将打开一个单独的窗口。检查器窗口以暂停状态开始。点击箭头以启动调试器（[图12.6](#ch12fig06)）。
- en: Figure 12.6\. Chrome Inspect window
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6\. Chrome检查器窗口
- en: '![](12fig06_alt.jpg)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig06_alt.jpg)'
- en: After the debugger starts, it will stop at the place in our code where we added
    the debugger statement. From here, we can view the console, and look at variables,
    as you can see in [figure 12.7](#ch12fig07). For example, if you click the wrapper,
    then __proto__, and then __proto__ again, you’ll see all the wrapper methods.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器启动后，它将在我们代码中添加调试语句的地方停止。从这里，我们可以查看控制台，查看变量，如图12.7所示。例如，如果你点击包装器，然后是__proto__，再然后是__proto__，你会看到所有的包装方法。
- en: Figure 12.7\. Debugger statement showing all the wrapper methods.
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.7\. 显示所有包装方法的调试语句。
- en: '![](12fig07_alt.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig07_alt.jpg)'
- en: Use the Chrome inspector whenever you need to figure out a test, and you’re
    not sure what variables do.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要找出一个测试，并且不确定变量是什么时，请使用Chrome检查器。
- en: Exercise
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer the following questions:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答以下问题：
- en: Why is it important to test? What tool is made for Vue.js that can help with
    testing?
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么测试很重要？有什么工具是为Vue.js设计的，可以帮助进行测试？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[附录B](kindle_split_026.html#app02)中的解决方案。*'
- en: Summary
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit test cases test small units of functionality.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试用例测试功能的小单元。
- en: Writing tests allows you to test functions and verify they work as expected
    in the application.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试可以让你测试函数并验证它们在应用程序中是否按预期工作。
- en: You can debug your test cases in real-time using the Chrome browser.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Chrome浏览器实时调试你的测试用例。
