- en: Chapter 12\. Interactive Analysis in Jupyter Notebook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Jupyter Notebook中的交互分析
- en: With this chapter, we round out the experience of working in the cloud. We started
    out in [Chapter 4](ch04.xhtml#first_steps_in_the_cloud) running individual commands
    in a shell, and built up proficiency with GATK tools in [Chapter 5](ch05.xhtml#first_steps_with_gatk)
    through [Chapter 7](ch07.xhtml#gatk_best_practices_for_somatic_variant). Then,
    in [Chapter 8](ch08.xhtml#automating_analysis_execution_with_work), you learned
    about scripted workflows and discovered progressively better ways to run them
    in subsequent chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们完成了在云中工作的体验。我们在[第4章](ch04.xhtml#first_steps_in_the_cloud)从shell中运行单个命令开始，通过[第5章](ch05.xhtml#first_steps_with_gatk)到[第7章](ch07.xhtml#gatk_best_practices_for_somatic_variant)，逐步熟练使用GATK工具。然后，在[第8章](ch08.xhtml#automating_analysis_execution_with_work)中，您了解了脚本化工作流，并逐步发现了更好地运行它们的方法。
- en: Yet we’re now coming back to the inescapable fact that not everything in genomics
    can (or should) be done as a scripted workflow. Sometimes, you just want to interact
    directly with the data, maybe generate a couple of plots and determine what your
    next step should be based on what the plots look like. You might be in an early
    exploratory phase of your project, stuck midway through with some failed samples
    to troubleshoot, or moving on to digging into the genetics of a group of people.
    In any case, you need to be able to try out ideas quickly, keep track of what
    each attempt produces, and share your work with others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们现在回到一个不可避免的事实，即基因组学中并非所有事情都可以（或者应该）作为脚本化工作流来完成。有时，您只想直接与数据交互，也许生成几个图表，并根据图表的情况确定下一步该怎么做。您可能处于项目的早期探索阶段，卡在中途需要排查一些失败的样本，或者转向深入挖掘一组人的遗传学。无论如何，您需要能够快速尝试想法，跟踪每个尝试产生的结果，并与他人分享您的工作。
- en: In this chapter, we show you how to use Jupyter Notebook in Terra to achieve
    these objectives. We kick it off with a brief introduction to Jupyter, in case
    you’re not already familiar with the concept and tooling. We spend a bit more
    time on describing how Jupyter works in Terra, focusing on the capabilities and
    behaviors that are more specific to Terra and the cloud environment. Then, in
    the hands-on portion of this chapter, we guide you through an example notebook
    that demonstrates three types of interactive analyses, with direct connections
    to topics and exercises covered in earlier chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示如何在Terra中使用Jupyter Notebook实现这些目标。我们从简要介绍Jupyter开始，以防您对概念和工具不熟悉。我们花费了更多时间描述Jupyter在Terra中的工作方式，重点介绍更适合于Terra和云环境的功能和行为。然后，在本章的实际操作部分，我们将通过一个示例笔记本指导您进行三种类型的交互式分析，直接与前几章涵盖的主题和练习相关联。
- en: Introduction to Jupyter in Terra
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Terra中介绍Jupyter
- en: If you’re reading this book in its intended order, we introduced you to Terra
    in [Chapter 11](ch11.xhtml#running_many_workflows_conveniently_in), primarily
    so that you could experience working with its built-in Cromwell server to run
    workflows efficiently at scale. You learned to clone a workspace, read a workflow
    configuration, and launch the workflow on part or all of a preset dataset. However,
    Terra is not only built for running workflows, but also includes tooling for performing
    interactive analysis, including a Jupyter service. In this chapter, we’re going
    to show you how to use Jupyter in Terra to interact with data and perform analysis
    in real time. You’ll still work within the same workspace, but this time you’ll
    be going to the Notebooks tab instead of the Workflows tab.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照预定的顺序阅读本书，我们在[第11章](ch11.xhtml#running_many_workflows_conveniently_in)介绍了Terra，主要是让您能够使用其内置的Cromwell服务器以高效且规模化地运行工作流。您学会了克隆工作空间、读取工作流配置，并在预设数据集的一部分或全部上启动工作流。然而，Terra不仅适用于运行工作流，还包括用于进行交互式分析的工具，包括一个Jupyter服务。在本章中，我们将向您展示如何在Terra中使用Jupyter与数据交互，并实时进行分析。您仍然会在同一个工作空间中工作，但这一次您会进入“Notebooks”选项卡，而不是“Workflows”选项卡。
- en: In the first part of this introduction, we aim to provide enough context and
    fundamentals so that if you’ve never heard of Jupyter before, you’ll be able to
    complete the exercises that follow. If you’re already familiar with Jupyter, feel
    free to skip this part. In the second part, we talk specifically about how Jupyter
    works in Terra, focusing mostly on what is different compared to typical local
    installations. We strongly recommend that you read it even if you’re familiar
    with Jupyter, in general because it will help you to better understand key points
    of the exercises.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍的第一部分中，我们旨在提供足够的背景和基础知识，以便如果您以前从未听说过 Jupyter，也能完成接下来的练习。如果您已经熟悉 Jupyter，请随意跳过此部分。在第二部分中，我们具体讨论了
    Jupyter 在 Terra 中的工作原理，主要集中在与典型本地安装相比的不同之处。我们强烈建议您阅读它，即使您对 Jupyter 有一般的了解，因为它将帮助您更好地理解练习的关键点。
- en: Jupyter Notebooks in General
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jupyter Notebooks 概述
- en: In a nutshell, *Jupyter* is an application that creates a special kind of document
    that combines static content (like text and images) with executable code and even
    interactive elements. For example, the tutorial notebook that you’ll work with
    in this chapter has sections of plain text that explain briefly what’s going on
    as well as *code cells* that include fully functional tool commands (which you
    can execute to actually run GATK on real data). It includes an integrated IGV
    module that allows you to view the results of the commands. To run the contents
    of a code cell, you simply click the cell and then press Shift+Enter on your keyboard,
    or, on the menu bar, click the Run icon. As the command runs, the output log of
    the command appears directly below the code cell, as shown in [Figure 12-1](#a_screenshot_of_doc_textcomma_code_cell).
    When you send to collaborators a copy of a notebook with code cells that have
    been run, they can view your results embedded within the document.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*Jupyter* 是一个应用程序，可以创建一种特殊类型的文档，将静态内容（如文本和图片）与可执行代码甚至交互式元素结合在一起。例如，本章中您将使用的教程笔记本有纯文本部分简要解释正在进行的内容，还包括*代码单元格*，其中包含完全功能的工具命令（您可以执行以在真实数据上运行
    GATK）。它还包括一个集成的 IGV 模块，允许您查看命令的结果。要运行代码单元格的内容，您只需点击单元格，然后在键盘上按 Shift+Enter，或者在菜单栏上点击运行图标。命令运行时，命令的输出日志直接出现在代码单元格的下方，如[图 12-1](#a_screenshot_of_doc_textcomma_code_cell)所示。当您将运行了代码单元格的笔记本副本发送给合作者时，他们可以在文档中查看嵌入的结果。
- en: '![A screenshot of doc text, code cell, and execution output in a Jupyter Notebook.](Images/gitc_1201.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![一个 Jupyter Notebook 中文档文本、代码单元格和执行输出的截图。](Images/gitc_1201.png)'
- en: Figure 12-1\. Doc text, code cell, and execution output in a Jupyter notebook.
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. Jupyter 笔记本中的文档文本、代码单元格和执行输出的截图。
- en: The basic idea is to combine analysis methods and findings in a single place,
    in a form that anyone can easily distribute. In a way, this is a logical evolution
    of the traditional scientific paper, but much better because it dramatically shortens
    the path between reading how an analysis was done and actually being able to reproduce
    it. It’s difficult to overstate how powerful this concept is and what a dramatic
    impact it can have on the reusability and reproducibility of findings in the computational
    sciences.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是将分析方法和发现结合在一个地方，以任何人都可以轻松分发的形式呈现。在某种程度上，这是传统科学论文的逻辑演进，但更好，因为它大大缩短了阅读分析方法和实际重现分析之间的路径。难以估量这一概念有多强大以及它对计算科学中发现的可重复性和再利用性所产生的巨大影响。
- en: So what kind of code can you run in such an interactive notebook? The original
    concept had been developed under the name [IPython](https://ipython.org) to run
    Python code specifically. The Jupyter project came out of IPython with the goal
    of extending the concept to other languages, starting with Julia, Python, and
    R, which are reflected in the name Jupyter (hence, the *py* spelling of Jupyter,
    as opposed to Jupiter, the Roman god of thunder). There are now Jupyter *kernels*
    for [other popular languages](https://oreil.ly/Pf8Or), such as Ruby, for example.
    In this chapter’s exercises, we work with a Python kernel that supports including
    R code, as well as running pretty much anything you could run in a shell environment,
    thanks to a neat set of features called *Python magic methods*. In our opinion,
    it’s like having the best of both worlds, but for many worlds.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在这样一个交互式笔记本中，你可以运行什么样的代码呢？最初的概念是在名为[IPython](https://ipython.org)的环境下专门运行Python代码。Jupyter项目源于IPython，旨在将这一概念扩展到其他语言，首先是Julia、Python和R，这些也体现在Jupyter的命名中（因此，Jupyter的拼写中有*py*，而不是罗马神话中的Jupiter，即雷神）。现在Jupyter还有支持[其他流行语言](https://oreil.ly/Pf8Or)的*kernels*，例如Ruby。在本章的练习中，我们使用一个Python
    kernel，它支持包含R代码，并且通过称为*Python魔术方法*的一组精彩特性，几乎可以运行你能在Shell环境中运行的任何内容。在我们看来，这就像同时拥有多个世界的最好一面。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In general computing, the *kernel* is the program at the core of an operating
    system. In the Jupyter context, the kernel is the program that interprets code
    cells, passes those instructions to the actual operating system of the machine
    that the notebook is running on, and retrieves results to display them in the
    notebook.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用计算中，*kernel*是操作系统核心的程序。在Jupyter环境中，*kernel*是解释代码单元的程序，将这些指令传递给笔记本运行的实际操作系统，并检索结果以在笔记本中显示。
- en: Jupyter notebooks are backed by a server application that has fairly simple
    requirements and can be run on almost any kind of computing infrastructure, including
    your laptop. In addition, a Jupyter notebook enables researchers to encapsulate
    the information necessary to re-create the software environment used by the analysis
    that it describes, making it a great vector for distributing reproducible code.
    It’s also an increasingly popular teaching tool, for reasons that will hopefully
    become evident as you work through the exercises in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter笔记本由一个服务器应用程序支持，其需求非常简单，几乎可以在任何类型的计算基础设施上运行，包括您的笔记本电脑。此外，Jupyter笔记本使研究人员能够封装重现其描述的分析所使用的软件环境所需的信息，使其成为分发可重现代码的绝佳工具。它还是一种越来越受欢迎的教学工具，希望通过本章的练习，这一点将变得显而易见。
- en: The growing popularity of Jupyter has spawned a rich ecosystem of add-on tools
    and services. For example, GCP operates a service called [Colaboratory](https://oreil.ly/3Tr2r)
    that offers free access to cloud-based notebooks, with tutorial materials that
    are heavily geared toward machine learning applications. The Google Cloud AI Platform,
    meanwhile, offers a paid service that offers preconfigured VMs for running notebooks
    integrated with other Google Cloud services. Another example is [Binder](https://mybinder.org),
    an open source community-driven project that can take any Jupyter notebook in
    a GitHub repository and open it in an interactive environment. These free services
    usually have limitations on the amount of computing power associated with the
    environments they provide, but they can be extremely convenient nonetheless for
    sharing working code, tutorials, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter的日益流行催生了一个丰富的附加工具和服务生态系统。例如，GCP运营一个名为[Colaboratory](https://oreil.ly/3Tr2r)的服务，提供免费访问云端笔记本，并提供针对机器学习应用的教程材料。与此同时，Google
    Cloud AI平台提供的付费服务提供预配置的虚拟机，用于运行与其他Google Cloud服务集成的笔记本。另一个例子是[Binder](https://mybinder.org)，一个开源社区驱动的项目，可以接受GitHub存储库中的任何Jupyter笔记本，并在交互式环境中打开它们。这些免费服务通常在它们提供的环境的计算能力方面存在限制，但对于分享工作代码、教程等来说仍然非常方便。
- en: That being said, it’s practically impossible for a single tool to satisfy the
    full spectrum of needs and preferences of people in computational sciences, and
    we recognize that Jupyter notebooks do have some shortcomings that limit their
    appeal to certain audiences. For example, people with advanced programming experience
    typically criticize the lack of development features that are standard on most
    modern programming tools, like syntax highlighting and code introspection. In
    addition, data scientists who are used to exploratory analysis interfaces like
    [RStudio](https://oreil.ly/1M5Jh) tend to find the primary Jupyter interface too
    basic and lacking in assistive features. The [JupyterLab](https://oreil.ly/RCfhB)
    project aims to remedy that limitation by providing a richer interface that is
    closer in concept to RStudio. Given the surge in economic investment in data sciences
    that we’ve seen in recent years, we expect that the tooling options will only
    improve over time, and we look forward to seeing what the next generation of interfaces
    will look like.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，对于计算科学中的需求和偏好，单一工具实际上不可能满足全方位的需求和偏好，我们也意识到 Jupyter 笔记本确实存在一些局限性，这些局限性限制了它在特定受众中的吸引力。例如，有着高级编程经验的人通常批评缺乏像语法高亮和代码检查这样大多数现代编程工具上标准的开发功能。此外，习惯于像[RStudio](https://oreil.ly/1M5Jh)这样的探索性分析界面的数据科学家们倾向于认为主要的
    Jupyter 界面过于基础，缺乏辅助功能。[JupyterLab](https://oreil.ly/RCfhB)项目旨在通过提供更丰富的界面来解决这一局限性，这一界面概念更接近于
    RStudio。鉴于我们近年来在数据科学领域看到的经济投资激增，我们预计工具选择将随着时间的推移而不断改善，我们期待看到下一代界面会是什么样子。
- en: In the meantime, we choose to use Jupyter for its accessibility to newcomers
    and its as-yet unparalleled support of portability and reproducibility.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们选择使用 Jupyter 是因为它对新手友好，并且支持可移植性和再现性，目前尚无与之相匹敌的支持。
- en: How Jupyter Notebooks Work in Terra
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jupyter Notebooks 在 Terra 中的工作原理
- en: Before we get into the details, you should know that Terra uses a standard Jupyter
    server implementation, so the interface and core capabilities that you will be
    working with are all basically the same as those you would see in any other setting.
    As a result, you can take advantage of the wealth of documentation and tutorials
    available on the internet for learning how to use the various menu options, widgets,
    and so on that we’re not going to cover in detail here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，您应该知道 Terra 使用标准的 Jupyter 服务器实现，因此您将要使用的界面和核心功能基本上与其他设置中看到的一样。因此，您可以利用互联网上丰富的文档和教程来学习如何使用各种菜单选项、小部件等，这里我们不会详细介绍。
- en: The one thing that is truly different about how Jupyter notebooks work in Terra
    compared to typical local installations is the way the computing environment is
    set up. Let’s go over that now given that it will have important consequences
    for you on several fronts; for example, the amount of flexibility you have to
    customize the environment, and the way you will access data and then save your
    analysis results.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与 typcial 本地安装相比，Jupyter 笔记本在 Terra 中工作的一个真正不同之处是计算环境的设置方式。现在让我们详细讨论一下，因为这对您在多个方面的重要影响，例如，您定制环境的灵活性，以及访问数据和保存分析结果的方式。
- en: Overview
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In Terra, notebook documents live in your workspace’s storage bucket. When you
    open a notebook for the first time, Terra requests a VM in GCP, spins up a container
    with a Jupyter server on it, and loads your notebook within that container environment,
    as illustrated in [Figure 12-2](#an_overview_of_the_jupyter_notebooks_se).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terra 中，笔记本文档存储在您工作空间的存储桶中。当您首次打开笔记本时，Terra 会请求在 GCP 中创建一个 VM，启动一个带有 Jupyter
    服务器的容器，并在该容器环境中加载您的笔记本，如图 [12-2](#an_overview_of_the_jupyter_notebooks_se) 所示。
- en: '![An overview of the Jupyter service in Terra.](Images/gitc_1202.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![An overview of the Jupyter service in Terra.](Images/gitc_1202.png)'
- en: Figure 12-2\. An overview of the Jupyter service in Terra.
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-2\. 在 Terra 中 Jupyter 服务的概述。
- en: From that point on, any code that you run in the notebook will be executed in
    the container on that VM. You can even run commands that install software packages
    or load libraries on the VM to customize the environment on the fly. Conceptually,
    it’s similar to working with the VM you set up through the GCP console in [Chapter 4](ch04.xhtml#first_steps_in_the_cloud)
    and subsequently used in every chapter up through [Chapter 8](ch08.xhtml#automating_analysis_execution_with_work),
    except it is originally created by Terra, and it provides you with the Jupyter
    interface instead of the bare shell terminal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，在笔记本中运行的任何代码都将在该VM上的容器中执行。甚至可以在VM上运行安装软件包或加载库的命令，以即时自定义环境。从概念上讲，这与通过GCP控制台设置的VM类似，后续在每一章中使用，只是它最初是由Terra创建的，并且为您提供了Jupyter界面，而不是裸露的shell终端。
- en: It is possible to pull up a terminal interface to the notebook, which allows
    you to perform actions like listing files and installing packages without having
    to put these actions into code cells. However, we recommend using this capability
    sparingly, largely because it runs counter to the underlying purpose of Jupyter,
    which is to capture every meaningful action taken during an analysis. Listing
    directory contents might not be meaningful in that context, but installing a package
    or importing data, on the other hand, can play an essential role. Omitting such
    actions from the notebook record could create missing links that break the reproducibility
    of the work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以打开一个终端界面到笔记本，这使您能够执行动作，如列出文件和安装软件包，而无需将这些动作放入代码单元中。然而，我们建议谨慎使用此功能，主要是因为这与Jupyter的基本目的相悖，即在分析过程中捕获每一个有意义的操作。在这种情况下，列出目录内容可能并不具有意义，但安装软件包或导入数据则可能起到关键作用。在笔记本记录中省略此类操作可能导致工作的可重复性中断。
- en: The cost model is the same, as well; GCP will charge you for the amount of time
    that the VM is in a running state, even if it’s not actively doing anything. The
    good news is that Terra has an automatic feature to detect inactivity; more on
    that in a minute. The base rate depends on the VM configuration you choose to
    use; by default, Terra provides a basic configuration that accommodates common
    performance needs, but you can dial it up or down based on your specific needs.
    We get back to that shortly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 成本模型也是一样的；GCP会根据VM运行的时间收费，即使VM没有在执行任何操作。好消息是，Terra有自动功能来检测不活动状态；稍后详细讨论。基本费率取决于您选择使用的VM配置；默认情况下，Terra提供基本配置以满足常见的性能需求，但您可以根据特定需求调整配置。我们稍后回到这个话题。
- en: The overall computing environment constituted by the VM plus the container and
    all the software it contains is called the *notebook runtime*. It is strictly
    personal to you; no one else can access it even if you share your workspace with
    them. We talk about sharing and collaboration in the last section of this introduction,
    when you’ll have a better sense of how it all works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由VM加上容器及其包含的所有软件组成的整体计算环境称为*笔记本运行时*。它严格个人使用；即使您与他人共享工作区，其他人也无法访问它。在本介绍的最后部分，当您更好地理解它的工作原理时，我们会讨论分享和协作。
- en: Accessing data
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问数据
- en: 'Your notebook runtime comes equipped with local storage space. Cloud subtleties
    notwithstanding, it’s basically like a hard drive with a filesystem on it. You
    can interact with the filesystem through code cells in the notebook, via the Jupyter
    built-in graphical file explorer, or through the aforementioned terminal interface,
    which supports classic commands like `ls` and `cd`. This allows you to run commands
    in the notebook using regular file paths as you would on a regular local system,
    such as your laptop. In addition, there are a few ways to run commands on data
    without first copying it to the local filesystem. We’re not going to go through
    the laundry list of options for accessing data from a notebook, because that would
    be boring. Instead, here’s a list of those we use most commonly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您的笔记本运行时配备了本地存储空间。尽管存在云计算的细微差别，它基本上就像一个带有文件系统的硬盘。您可以通过笔记本中的代码单元与文件系统交互，通过Jupyter内置的图形文件浏览器，或通过上述支持经典命令如`ls`和`cd`的终端界面来操作。这使您可以在笔记本中使用常规文件路径运行命令，就像在您的笔记本电脑上一样。此外，有几种方法可以在不先将数据复制到本地文件系统的情况下运行命令。我们不会详细列出从笔记本访问数据的所有选项，因为那样会很无聊。相反，这里是我们最常用的几种方式的列表：
- en: Upload files from your desktop to your notebook’s local storage through the
    notebook’s graphical file explorer.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过笔记本的图形文件浏览器，将桌面上的文件上传到笔记本的本地存储。
- en: Copy data from a GCS bucket to your notebook’s local storage using `gsutil cp`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`gsutil cp`将数据从GCS存储桶复制到笔记本的本地存储。
- en: Run tools that support streaming (like GATK4) directly on files in GCS.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行支持流式处理（如GATK4）的工具直接在GCS中的文件上。
- en: Import tabular data from tables on the DATA tab of the workspace by using a
    programmatic interface (API).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用编程接口（API）从工作区数据选项卡上的数据表中导入表格数据。
- en: Import tabular data from Google’s BigQuery datastore service.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Google的BigQuery数据存储服务导入表格数据。
- en: We show you how to use the second and third options in practice in the next
    section, and we will provide pointers to additional resources for learning the
    fourth and fifth on the book’s companion blog.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节实践中向你展示如何使用第二和第三个选项，并将为学习第四和第五个选项提供附加资源的指引。
- en: Saving, stopping, and restarting
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存、停止和重新启动
- en: While you work in the notebook, the system will regularly save changes back
    to the original notebook document in your workspace bucket. However, aside from
    the notebook itself, Terra does not automatically save any files from the notebook’s
    local storage back to the workspace. For reasons that we discuss shortly, you
    can’t depend on the notebook runtime for permanent storage, so you must take action
    to save a copy of any output files you care about, preferably to the workspace
    storage bucket. We show you an easy way to do this in [“Setting Up a Sandbox and
    Saving Output Files to the Workspace Bucket”](#setting_up_a_sandbox_and_practice_savin).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用笔记本时，系统会定期将更改保存回工作区存储桶中原始的笔记本文档。然而，除了笔记本本身外，Terra不会自动将笔记本的本地存储中的任何文件保存回工作区。出于我们即将讨论的原因，你不能依赖笔记本运行时进行永久存储，因此你必须采取措施保存任何关心的输出文件的副本，最好保存到工作区存储桶中。我们将在[“设置沙盒并将输出文件保存到工作区存储桶”](#setting_up_a_sandbox_and_practice_savin)中展示一个简单的方法来做到这一点。
- en: 'When you’re done working and close the notebook, Terra instructs GCP to stop
    the notebook runtime but save its state, which includes the state of the Jupyter
    container, with any modifications that you might have made by installing packages,
    for example, and any files present on its local storage partition. That way, you
    can resume working at any time with minimal effort: when you reopen the notebook,
    Terra restarts the VM and restores the notebook runtime to its saved state. The
    restart process can take up to two minutes on the GCP side, but while you wait,
    Terra gives you a read-only view of the notebook contents based on the document’s
    latest saved state. Finally, as mentioned in the previous paragraph, Terra is
    able to detect when you are no longer actively working in your notebook (based
    on how long the VM has been idle) and will automatically save the notebook and
    stop the VM to limit your costs.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成工作并关闭笔记本时，Terra指示GCP停止笔记本的运行时，但保存其状态，包括Jupyter容器的状态，以及你可能通过安装软件包等方式进行的任何修改，以及其本地存储分区上存在的任何文件。这样，你可以随时以最小的努力恢复工作：当你重新打开笔记本时，Terra会重新启动虚拟机，并将笔记本的运行时恢复到其保存的状态。在GCP端，重新启动过程最多可能需要两分钟，但在此期间，Terra会根据文档的最新保存状态为你提供笔记本内容的只读视图。最后，正如前一段提到的，Terra能够检测到你不再活跃地使用笔记本（根据虚拟机空闲时间），并会自动保存笔记本并停止虚拟机，以限制你的成本。
- en: Customizing your notebook’s computing environment
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义你的笔记本计算环境
- en: 'You might want to customize your notebook runtime in two main ways: modify
    the VM resource allocations (how many CPUs, how much memory, etc.) and/or modify
    which software is preinstalled in the container.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望通过两种主要方式定制你的笔记本运行时：修改虚拟机资源分配（例如CPU数量、内存等）和/或修改容器中预安装的软件。
- en: As noted earlier in passing, you can readily modify the VM resources allocated
    to your notebook runtime; for example, if you need more CPUs or memory than is
    included in the default configuration, you can adjust the notebook runtime configuration
    accordingly. You can even request a Spark cluster instead of a single VM if you’re
    planning to use tools that are Spark enabled. Conveniently, Terra includes a notebook
    runtime configuration panel that is much simpler than the equivalent GCP interface,
    which you might remember from [Chapter 4](ch04.xhtml#first_steps_in_the_cloud).
    But what’s really cool is that you can do it at any time, even if you’ve already
    started working in the notebook. You’ll just pull up the configuration panel,
    specify what you want, and let the system regenerate your notebook runtime with
    the new specifications. As a result, you don’t need to try too hard to guess up
    front the kind of resources you’re going to need to do your work. You can start
    working with minimal settings and then dial them up if you run into limitations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前简要提到的，你可以轻松修改分配给笔记本运行时的虚拟机资源；例如，如果你需要比默认配置中包含的更多的CPU或内存，你可以相应地调整笔记本运行时的配置。甚至，如果你计划使用支持
    Spark 的工具，你可以请求一个 Spark 集群而不是单个虚拟机。方便的是，Terra 包含一个笔记本运行时配置面板，比起等价的 GCP 接口要简单得多，你可能还记得来自[第四章](ch04.xhtml#first_steps_in_the_cloud)的内容。但真正酷的是，你可以随时进行这些操作，即使你已经开始在笔记本中工作。你只需拉起配置面板，指定你想要的内容，让系统使用新的规格重新生成你的笔记本运行时。因此，你无需费力地预测你将需要的资源类型。你可以从最小设置开始工作，然后在遇到限制时再逐步调整。
- en: 'However—and this is a big caveat—the new runtime *will be a blank slate* because
    the regeneration process provisions a new VM with a fresh install of the original
    container image and an empty storage partition. If the work you’re doing in your
    notebook includes mostly short-running commands that don’t amount to much computation
    cost, this isn’t a big problem: the Jupyter menu includes an option to rerun all
    code cells (or all up to a certain point) so that you can simply regenerate the
    previous state. However, if some of your work involves massive computations that
    would not be trivial to rerun, you might need a better strategy. For example,
    you could explicitly save the outputs generated so far to the workspace bucket
    and then set your notebook to take those saved outputs as inputs for the next
    section of the work.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而——这是一个重要的警告——新的运行时 *将是一个空白*，因为再生过程会使用原始容器映像进行新虚拟机的配置，并且使用空存储分区。如果你的笔记本工作主要包括运行时间较短的命令，不涉及太多计算成本，这并不是一个大问题：Jupyter
    菜单中包含重新运行所有代码单元（或者到某一点之前的所有代码单元）的选项，因此你可以简单地再现先前的状态。然而，如果你的工作涉及到大量计算，重新运行可能并不轻松，这时你可能需要更好的策略。例如，你可以明确将到目前为止生成的输出保存到工作空间存储桶中，然后设置笔记本以便在下一部分工作中使用这些已保存的输出作为输入。
- en: 'The second customization point, modifying the software in the container when
    the notebook runtime is being generated, is a little more complicated but worth
    taking a few minutes to discuss. First, why would you want to do that? Suppose
    that your analysis is going to require software packages that are not part of
    the default notebook runtime configuration. You could start the notebook with
    some installation steps, but that can turn into a maintenance headache if you
    have multiple notebooks that require the same configuration commands. It would
    be much easier to move some of those software installation steps out of the notebooks
    and into the environment configuration proper. You can do exactly that in Terra
    in two ways: you can specify a setup script that Terra will run in the container
    when it is creating or regenerating the notebook runtime, or you can supply a
    custom container image to the runtime service. Or you can, in fact, combine both:
    specify a custom container and a startup script to modify its setup. [Figure 12-3](#options_for_customizing_the_software_in)
    illustrates the difference between these options.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个定制点是在生成笔记本运行时时修改容器中的软件，这有点复杂，但值得花几分钟来讨论。首先，为什么要这样做呢？假设您的分析需要一些不包括在默认笔记本运行时配置中的软件包。您可以开始笔记本并进行一些安装步骤，但如果有多个需要相同配置命令的笔记本，这可能会成为一个维护头痛。如果将其中一些软件安装步骤移出笔记本并放入环境配置中，将会更容易得多。在
    Terra 中，您可以通过两种方式实现这一点：您可以指定一个设置脚本，Terra 将在创建或重新生成笔记本运行时时在容器中运行它，或者您可以为运行时服务提供自定义容器镜像。或者您实际上可以结合两者：指定一个自定义容器和一个启动脚本来修改其设置。[图 12-3](#options_for_customizing_the_software_in)
    阐明了这些选项之间的区别。
- en: '![Options for customizing the software installed in the notebook runtime.](Images/gitc_1203.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![自定义笔记本运行时安装软件的选项。](Images/gitc_1203.png)'
- en: Figure 12-3\. Options for customizing the software installed in the notebook
    runtime.
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-3\. 自定义笔记本运行时安装软件的选项。
- en: 'In the upcoming exercises, we show you how to use the startup script option
    because it’s a good compromise of power and ease of use: it’s not difficult to
    make your own, and you can readily distribute the script for others who are also
    using the same kernel in Terra. The custom container image option is technically
    more powerful and more portable, but it’s a bit more complicated. If you’re interested
    in learning how that works, check out the [Terra documentation on custom containers](https://oreil.ly/R-Grd).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将进行的练习中，我们将向您展示如何使用启动脚本选项，因为这是功能与易用性的良好折衷：制作您自己的脚本并不困难，您可以轻松地为其他在 Terra 中使用相同内核的用户分发该脚本。自定义容器镜像选项在技术上更强大且更具可移植性，但更为复杂。如果您有兴趣了解其工作原理，请查看[Terra
    上关于自定义容器的文档](https://oreil.ly/R-Grd)。
- en: 'Now that you know how much power you have to customize your notebook runtime,
    we need to address a crucial question that we’ve been careful to avoid bringing
    up until now: how many notebook runtimes do you get to work with? Do you use the
    same runtime for everything, one per workspace, one per notebook, or can you create
    new runtimes willy-nilly like you can spin up VMs in the GCP console? To be frank,
    the answer is likely to evolve over time as the platform matures further and the
    product development team collects more data regarding what researchers actually
    want (so feel free to give them your opinion!).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道您可以定制笔记本运行时的强大功能后，我们需要解决一个关键问题，这是我们一直小心避免提到的：您可以使用多少个笔记本运行时？您是否为所有内容使用相同的运行时，每个工作区一个，每个笔记本一个，或者您可以像在
    GCP 控制台中创建 VM 实例那样随意创建新的运行时？坦率地说，答案可能会随着平台进一步成熟以及产品开发团队收集更多研究者实际需求的数据而发生变化（所以请随时提供您的意见！）。
- en: As of this writing, the Terra Notebooks service provides you with a single notebook
    runtime for all workspaces within a particular billing project. To be clear, this
    means that if you open or create another notebook in any workspace attached to
    the same billing project as your first notebook, the new notebook will open in
    the same runtime environment. This can be very convenient if you have a lot of
    overlap between the data, resources, and software that you plan to use in both
    notebooks. However, it can be a source of major complications if you are working
    on different projects with very different configuration needs. In that case, you
    might want to consider developing notebooks with incompatible requirements under
    different billing projects, because that will give you a completely separate notebook
    runtime for each one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Terra笔记本服务为特定计费项目内的所有工作空间提供单一笔记本运行时。明确地说，这意味着如果你在与第一个笔记本相同的计费项目中的任何工作空间中打开或创建另一个笔记本，新的笔记本将在相同的运行时环境中打开。如果你计划在两个笔记本中使用的数据、资源和软件有很大的重叠，这可能非常方便。然而，如果你正在处理配置需求完全不同的不同项目，这可能会带来主要的复杂性。在这种情况下，你可能需要考虑在不同的计费项目下开发具有不兼容要求的笔记本，因为这将为每个项目提供完全独立的笔记本运行时环境。
- en: Sharing and collaboration
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分享和协作
- en: 'With that, you’ve reached the last section of this introduction, and now it’s
    time to talk about how to play nice with others. As we noted earlier, the notebook
    runtime is personal to you: only you have access to that machine, container, and
    Jupyter server. If you share your workspace with a collaborator who then opens
    up the same notebook, it will open in their own runtime environment. As a result,
    any work they do in the notebook will not affect the state of your runtime environment.
    However, the system will automatically save any changes they make to the shared
    document in the workspace, so it’s important to set expectations clearly with
    your collaborators about whether it’s OK for them to modify the notebook or whether
    they should work in a separate copy.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经完成了这个介绍的最后一节，现在是时候谈谈如何与他人友好相处了。正如我们之前提到的，笔记本运行时是个人的：只有你能访问那台机器、容器和Jupyter服务器。如果你与合作者分享工作空间，他们打开相同的笔记本时，它将在他们自己的运行时环境中打开。因此，他们在笔记本中所做的任何工作都不会影响你的运行时环境的状态。然而，系统会自动保存他们对共享文档所做的任何更改，因此与合作者明确设置期望非常重要，他们是否可以修改笔记本，或者他们是否应该在单独的副本中工作。
- en: In addition, be aware that Terra will *lock* the notebook document in the workspace
    whenever someone is actively working with it, to avoid having multiple people
    making conflicting changes at the same time. When this happens, your collaborator
    can open the notebook in the read-only preview mode, or they can open it in a
    special *playground mode* that allows them to make changes and run code in their
    own runtime environment but does not save any changes to the original file, as
    illustrated in [Figure 12-4](#options_for_sharing_and_collaboration_a). This falls
    a bit short of the ideal collaborative experience that you could envision based
    on Google Docs, for example, but it provides a reasonable compromise given the
    constraints at play.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当有人正在使用笔记本文档时，Terra将会*锁定*它，以避免多人同时进行冲突更改。在这种情况下，你的合作者可以在只读预览模式下打开笔记本，或者他们可以在特殊的*游乐场模式*下打开笔记本，在这种模式下，他们可以在自己的运行时环境中进行更改和运行代码，但不会保存任何更改到原始文件中，如图[12-4](#options_for_sharing_and_collaboration_a)所示。这可能不完全符合你可以基于Google
    Docs设想的理想协作体验，但考虑到所涉及的限制，这提供了一个合理的折衷方案。
- en: '![Options for sharing and collaboration around notebooks in Terra.](Images/gitc_1204.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在Terra中分享和协作笔记本的选项。](Images/gitc_1204.png)'
- en: Figure 12-4\. Notebooks in shared workspaces are protected from overwriting
    when two people open them concurrently.
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-4\. 在共享工作空间中，当两个人同时打开笔记本时，可以防止覆盖。
- en: 'If you’re having a difficult time envisioning how this all works in practice,
    don’t worry! First, that’s totally OK; if anything is unclear, it’s our fault,
    not yours. Second, good news: you’ve reached the end of the wall of theory, and
    now it’s time to work through practical exercises in a real-life notebook.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在实践中对这一切如何运作感到困惑，不用担心！首先，这完全可以接受；如果有什么不清楚的地方，那是我们的错，而不是你的错。其次，好消息是：你已经到达了理论壁垒的尽头，现在是时候在真实的笔记本中进行实际练习了。
- en: Getting Started with Jupyter in Terra
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Terra中开始使用Jupyter
- en: We’re going to work with a prewritten notebook, so you’ll mostly just need to
    run cells, though whenever possible we tried to include hints for additional things
    that you can try in order to reinforce the learning. In [Chapter 13](ch13.xhtml#assembling_your_own_workspace_in_terra),
    we talk about creating your own notebooks from scratch or importing existing notebooks
    from external sources.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用预写的笔记本进行工作，因此您大多数时候只需运行单元格，尽管在可能的情况下，我们尝试包含一些额外的提示，以加强学习。在[第13章](ch13.xhtml#assembling_your_own_workspace_in_terra)中，我们讨论如何从头开始创建您自己的笔记本或从外部来源导入现有笔记本。
- en: 'To get started, go back to the workspace that you created by cloning the original
    book workspace in [Chapter 11](ch11.xhtml#running_many_workflows_conveniently_in).
    If you don’t have the URL on hand, you should be able to find it in [Your Workspaces](https://oreil.ly/bKWll);
    or if you deleted it, you can clone the original again by following the relevant
    instructions at the beginning of [Chapter 11](ch11.xhtml#running_many_workflows_conveniently_in).
    After you’ve found your workspace, open it and go to the Notebooks tab. There,
    you’ll see two notebooks listed, as shown in [Figure 12-5](#the_notebooks_tab_showing_two_copies_of).
    Those are actually two copies of the same notebook: one that has never been run,
    and the other where we ran everything so that you can see the expected output.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请返回到您通过克隆原始书籍工作区创建的工作区[第11章](ch11.xhtml#running_many_workflows_conveniently_in)。如果您手头没有
    URL，请在[您的工作区](https://oreil.ly/bKWll)中找到它；或者如果您已删除它，则可以按照[第11章](ch11.xhtml#running_many_workflows_conveniently_in)开头的相关说明再次克隆原始工作区。找到您的工作区后，打开它并转到笔记本选项卡。在那里，您将看到列出两个笔记本，如[图12-5](#the_notebooks_tab_showing_two_copies_of)所示。这实际上是同一个笔记本的两个副本：一个从未运行过，另一个我们已经运行了所有内容，以便您可以看到预期的输出。
- en: '![The NOTEBOOKS tab showing two copies of the notebook: one already executed
    and another without any previous results.](Images/gitc_1205.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![笔记本选项卡显示两个笔记本副本：一个已执行，另一个没有任何之前的结果。](Images/gitc_1205.png)'
- en: 'Figure 12-5\. The Notebooks tab showing two copies of the notebook: one already
    executed and another without any previous results.'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-5\. 笔记本选项卡显示两个笔记本副本：一个已执行，另一个没有任何之前的结果。
- en: We recommend that you open the second only in preview mode to preserve its contents
    as a reference in case you encounter anything surprising in the other one, which
    you will use to run through the upcoming exercise.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您仅以预览模式打开第二个，以便将其内容保留为参考，以防在另一个中遇到令人惊讶的内容，您将使用它来完成即将进行的练习。
- en: However, before you open anything, we’re going to walk you through customizing
    your runtime configuration. If you already started opening one of the notebooks,
    don’t panic; you’ll still be able to reconfigure the notebook runtime. We just
    want to save you a little bit of time given that it takes a few minutes to get
    a new runtime up and running, and we know that we’re going to want more than what
    the default configuration has to offer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在您打开任何内容之前，我们将指导您自定义运行时配置。如果您已经开始打开其中一个笔记本，请不要惊慌；您仍然可以重新配置笔记本运行时。我们只是想节省您一点时间，因为启动新的运行时需要几分钟时间，并且我们知道，我们将会需要比默认配置提供的更多内容。
- en: Inspecting and Customizing the Notebook Runtime Configuration
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查和自定义笔记本运行时配置
- en: As noted earlier, the runtime environment that Terra creates for you by default
    is set up with basic resource allocations and a set of standard software packages.
    You can view this configuration at any time without having to open a notebook,
    as long as you’re in a workspace under the appropriate billing project. To do
    so, look for the Notebook Runtime status widget, which, as of this writing, is
    displayed in the upper-right corner of almost all workspace pages, as demonstrated
    in [Figure 12-6](#the_notebook_runtime_status_widgetdot).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，默认情况下，Terra 为您创建的运行时环境设置了基本资源分配和一组标准软件包。只要您在适当的计费项目下的工作空间中，您可以随时查看此配置，而无需打开笔记本。要这样做，请查找笔记本运行时状态小部件，截至撰写本文时，几乎所有工作空间页面的右上角都显示了该小部件，如[图12-6](#the_notebook_runtime_status_widgetdot)所示。
- en: '![The Notebook Runtime status widget.](Images/gitc_1206.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![笔记本运行时状态小部件。](Images/gitc_1206.png)'
- en: Figure 12-6\. The Notebook Runtime status widget.
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-6\. 笔记本运行时状态小部件。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We have heard rumblings from the Terra product development team that the display
    of the Notebook Runtime status widget might change in the near future, in which
    case you’ll need to poke around to find it, or if that fails, consult the documentation
    in the book’s repository on [GitHub](https://oreil.ly/genomics-repo).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Terra产品开发团队听说过有关笔记本运行时状态小部件显示可能会在不久的将来发生变化的传言，如果情况如此，您将需要查找它，或者如果失败，可以在书的存储库中的[GitHub](https://oreil.ly/genomics-repo)上查阅相关文档。
- en: Click the gear icon on the right to bring up the runtime configuration page.
    If you haven’t made any customizations to the runtime under your current billing
    project, the form should display all default settings, as depicted in [Figure 12-7](#the_default_notebook_runtime_configurat).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单击右侧的齿轮图标可打开运行时配置页面。如果在当前计费项目下未对运行时进行任何自定义，则表单应显示所有默认设置，如[图 12-7](#the_default_notebook_runtime_configurat)所示。
- en: '![The default Notebook Runtime configuration settings.](Images/gitc_1207.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![默认笔记本运行时配置设置。](Images/gitc_1207.png)'
- en: Figure 12-7\. The default Notebook Runtime configuration settings.
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-7\. 默认笔记本运行时配置设置。
- en: You can see a small list of default environments to choose from, identified
    by the packages that are considered most important. For full details on what is
    installed on each, select the environment you’re interested in and click “What’s
    installed on this environment?” to bring up the detailed view. As shown in [Figure 12-8](#detailed_view_of_the_packages_installed),
    this detailed view is further broken into categories such as Python, R, and Tools.
    Selecting either Python or R brings up the full list of packages of the corresponding
    language that are included in the runtime environment. Selecting Tools will bring
    up the list of command-line executable tools also included in the runtime environment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到一个小列表，选择默认环境，其特征是被认为是最重要的软件包。要获取安装在每个环境上的完整详细信息，请选择您感兴趣的环境，然后点击“此环境中安装了什么？”以打开详细视图。如图[图 12-8](#detailed_view_of_the_packages_installed)所示，该详细视图进一步分为诸如Python、R和工具等类别。选择Python或R将显示相应语言的运行时环境中包含的完整软件包列表。选择工具将显示运行时环境中还包含的命令行可执行工具列表。
- en: In fact, if you select Tools, you’ll see that this default set actually includes
    GATK, which is a nice touch for those of us in the genomics field, considering
    Terra has a much wider audience than just genomics. That being said, for the purposes
    of this book, we are using a different version than the one included in the default
    configuration as of this writing, so we need to customize this. In addition, we’re
    going to want to use a Python library that (spoiler alert) makes it possible to
    embed an IGV browser window within the notebook (which is so cool). We could install
    both from within the notebook itself, but as noted in the introduction, we prefer
    to use a startup script that will install them in the Jupyter container during
    the notebook runtime creation process. We provide a closer look at the script
    in question in the accompanying sidebar in case you’re curious, but feel free
    to skip it if it’s not your cup of tea or if you’re eager to get started with
    the notebook itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果选择工具，您会发现这个默认设置实际上包括GATK，这对我们这些在基因组学领域工作的人来说是一个很好的选择，考虑到Terra不仅仅面向基因组学的更广泛的受众。也就是说，出于本书的目的，我们正在使用与默认配置版本不同的版本，因此我们需要进行定制。此外，我们还将要使用一个Python库（剧透警报），它可以在笔记本中嵌入IGV浏览器窗口（这太酷了）。我们可以在笔记本内部安装这两者，但正如介绍中所述，我们更喜欢使用启动脚本，在笔记本运行时创建过程中安装它们。如果您感兴趣，我们在附带的侧边栏中提供了有关所讨论脚本的更详细的内容，但如果您不感兴趣，或者您急于开始使用笔记本本身，则可以跳过它。
- en: '![Detailed view of the packages installed on the default runtime environment.](Images/gitc_1208.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![默认运行时环境中安装的软件包的详细视图。](Images/gitc_1208.png)'
- en: Figure 12-8\. Detailed view of the packages installed on the default runtime
    environment.
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-8\. 默认运行时环境中安装的软件包的详细视图。
- en: So where should we specify the startup script? You might be tempted to look
    in the environments menu on the notebook runtime customization page, maybe even
    select the Custom Environment option, and you would be so close to being right,
    conceptually—but in practice, you’d be wrong. That is where you would go to specify
    a custom Docker image to substitute for the built-in one. Instead, you need to
    look a little farther down at the Compute Power section (shown earlier in [Figure 12-7](#the_default_notebook_runtime_configurat)),
    which allows you to modify the VM resource allocations. This section includes
    a menu that allows you to choose from three preset configurations, designated
    as providing Moderate, Increased, or High computer power, or provide your own
    under the label Custom.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该在哪里指定启动脚本？你可能会想要在笔记本运行时自定义页面的环境菜单中查找，甚至选择自定义环境选项，这个概念上看似正确，但实际上是错误的。那里是你用来指定替换内置
    Docker 镜像的地方。相反，你需要向下看一点，到计算能力部分（在[图 12-7](#the_default_notebook_runtime_configurat)中显示），这里允许你修改虚拟机资源分配。该部分包括一个菜单，允许你从三个预设配置中选择，标记为提供中等、增加或高级计算能力，或者在自定义标签下提供你自己的配置。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To be frank, we wouldn’t be surprised if this part of the interface also evolved
    a bit in the near future because it’s not super logical to find a software customization
    option grouped with hardware allocations. Not to mention the names of the preset
    configurations, which are about as helpful as Starbucks cup sizes: once you get
    used to them, they kind of make sense, but the first time you set foot in a Starbucks,
    you’re just happy that the prices tell you which one is bigger.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白地说，如果这部分界面在不久的将来也有所发展，我们不会感到惊讶，因为将软件定制选项与硬件分配分组在一起并不是很合理。更不用说那些预设配置的命名了，它们就像星巴克杯子的大小名称一样不太有帮助：一旦你习惯了它们，它们看起来有点合理，但第一次踏进星巴克，你只是为了价格告诉你哪个更大而感到开心。
- en: 'Feel free to select each preset and look at how their respective resource allocations
    differ. When you’re ready to move on, select the Custom option to bring up an
    editable configuration window. You should see a new field named “Startup script”
    appear that wasn’t available earlier ([Figure 12-9](#the_compute_power_section_allows_you_to)).
    You can finally input the path to the startup script there, in the text box labeled
    URI (for [uniform resource identifier](https://oreil.ly/Ltao0), a close cousin
    of [URL](https://oreil.ly/jUtVr), the uniform resource locator). We included a
    copy of the script in the book bucket, so you can use this path:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随意选择每个预设配置，查看它们各自的资源分配方式。当你准备好继续时，选择自定义选项以打开可编辑的配置窗口。你会看到一个之前不可用的名为“启动脚本”的新字段出现（[图 12-9](#the_compute_power_section_allows_you_to)）。你最终可以在那里的
    URI 文本框中输入启动脚本的路径（对应统一资源标识符（[uniform resource identifier](https://oreil.ly/Ltao0)）的一种，是
    [URL](https://oreil.ly/jUtVr) 的近亲）。我们在书的存储桶中包含了脚本的副本，所以你可以使用这个路径：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The rest of the resource allocations will be fine with the default (Moderate)
    values of 4 CPUs, 15 GB of memory (RAM), and 50 GB of disk (storage space). [Figure 12-9](#the_compute_power_section_allows_you_to)
    demonstrates what this looks like.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的资源分配将会按默认值（中等）进行，包括 4 个 CPU、15 GB 内存（RAM）和 50 GB 硬盘空间。[图 12-9](#the_compute_power_section_allows_you_to)展示了这个配置的外观。
- en: As a reminder, this startup script installs GATK version 4.1.3.0 in the runtime
    environment, as well as an IGV integration module that will make it possible to
    view genomic data using IGV from within the notebook itself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这个启动脚本会在运行时环境中安装 GATK 版本 4.1.3.0，以及一个集成模块，使得你可以在笔记本内部使用 IGV 查看基因组数据。
- en: '![The COMPUTE POWER section allows you to specify a startup script if you choose
    the Custom profile.](Images/gitc_1209.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如果选择自定义配置，则“计算能力”部分允许您指定一个启动脚本。](Images/gitc_1209.png)'
- en: Figure 12-9\. The Compute Power section allows you to specify a startup script
    if you choose the Custom profile.
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-9\. 计算能力部分允许你在选择自定义配置时指定一个启动脚本。
- en: Click the Create button when you are done (labeled Replace if you had already
    created a runtime earlier), and Terra begins to create a new runtime environment
    with your settings. You can go grab yourself a cup of something nice or continue
    on to the next set of instructions, as you prefer. You will probably need to wait
    a few minutes in either case while Terra communicates with GCP to provision your
    shiny new runtime environment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时点击“创建”按钮（如果之前已创建过运行时，则标记为“替换”），Terra开始根据你的设置创建新的运行时环境。你可以去拿一杯喜欢的饮料或继续下一组指令，按你的喜好选择。在任何情况下，Terra与GCP通信以提供你闪亮新的运行时环境时，你可能需要等待几分钟。
- en: Opening Notebook in Edit Mode and Checking the Kernel
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开编辑模式的笔记本并检查内核
- en: 'You don’t need to wait for the runtime to be ready in order to take a peek
    at the notebook, so go ahead and open the never-been-run copy of the tutorial
    notebook. Whether your runtime is ready or not, Terra will initially open the
    notebook in preview mode, in which the notebook is read-only. As [Figure 12-10](#menu_on_the_notebook_preview_page_displ)
    illustrates, a menu at the top of the preview panel offers you the two options
    for opening the notebook in an interactive mode: Edit, to work with the notebook
    normally; or Playground Mode, to experiment without saving anything, as we briefly
    discussed in the introduction.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看笔记本，你不需要等待运行时准备就绪，所以请打开教程笔记本的未运行副本。无论你的运行时是否准备就绪，Terra最初会以预览模式打开笔记本，即笔记本是只读的。正如[图 12-10](#menu_on_the_notebook_preview_page_displ)所示，预览面板顶部的菜单提供两个选项，以交互方式打开笔记本：编辑，正常工作笔记本；或者游乐场模式，无需保存任何内容进行实验，正如我们在介绍中简要讨论的那样。
- en: '![Menu on the notebook preview page displaying the main options: Preview, Edit,
    and Playground Mode.](Images/gitc_1210.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![笔记本预览页面上的菜单显示主要选项：预览、编辑和游乐场模式。](Images/gitc_1210.png)'
- en: 'Figure 12-10\. Menu on the notebook preview page displaying the main options:
    Preview, Edit, and Playground Mode.'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-10\. 笔记本预览页面上显示的菜单，包括主要选项：预览、编辑和游乐场模式。
- en: Click Edit and wait for the runtime to be ready. You’ll recognize when the transition
    to Edit mode happens by the appearance of the standard Jupyter menu bar, shown
    in [Figure 12-11](#the_standard_jupyter_notebooks_menu_bar). A more subtle but
    also important sign is the little white box toward the right of the menu bar showing
    the label Edit Mode. If you had opened the notebook in Playground Mode by mistake,
    the Jupyter menu bar would also be displayed, but instead of the white Edit Mode
    label, you’d see an orange “Playground Mode (Edits not saved)” label.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“编辑”并等待运行时准备就绪。当转换为编辑模式时，你会注意到标准的 Jupyter 菜单栏的出现，如[图 12-11](#the_standard_jupyter_notebooks_menu_bar)所示。一个更微妙但同样重要的标志是菜单栏右侧的小白色框，显示“编辑模式”标签。如果你错误地打开了游乐场模式，Jupyter
    菜单栏也会显示，但是白色的“编辑模式”标签将被橙色的“游乐场模式（未保存编辑）”标签替代。
- en: '![The standard Jupyter menu bar.](Images/gitc_1211.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![标准的 Jupyter 菜单栏。](Images/gitc_1211.png)'
- en: Figure 12-11\. The standard Jupyter menu bar.
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-11\. 标准的 Jupyter 菜单栏。
- en: 'Further to the right in that area of the menu bar is the Python 3 label that
    identifies the active kernel as well as the Python logo. You might remember that
    the *kernel* of the notebook is the computational engine that interprets the code
    in the notebook and initiates execution of each cell that you run. For this particular
    notebook, we decided to use a Python 3 kernel so we can execute terminal commands
    (including to programs like `gsutil` and GATK) using Python magic methods—which
    is an actual technical term, we swear. You’ll see it in action shortly: it is
    truly magical.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜单栏区域的更右侧，是标识活动内核的Python 3标签以及Python标志。你可能还记得笔记本的*内核*是解释笔记本中代码并启动每个运行单元执行的计算引擎。对于这个特定的笔记本，我们决定使用Python
    3内核，以便使用Python魔术方法执行终端命令（包括像`gsutil`和GATK这样的程序）——这确实是一个技术术语，我们发誓。你很快就会看到它的神奇之处。
- en: In case you’re wondering, yes you can switch the kernel while the notebook is
    running using the Kernel menu, but we really don’t recommend doing that. It might
    sound useful in principle—for example, to run code in a different language in
    a subset of cells—but in practice it’s dangerous and can mess you up if you’re
    not careful. If you need to use both Python and R code within the same notebook,
    you’re much better off using the Python 3 kernel and magic methods commands as
    we demonstrate in this notebook.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道，是的，你可以在笔记本运行时使用Kernel菜单切换内核，但我们真的不建议这样做。原则上，这可能听起来很有用——例如，在子集单元格中运行不同语言的代码——但实际上却是危险的，如果不小心会造成混乱。如果你需要在同一个笔记本中使用Python和R代码，我们强烈建议使用Python
    3内核和魔术方法命令，正如我们在这个笔记本中展示的那样。
- en: And with that, it’s time to run some actual code cells!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行一些真实的代码单元格了！
- en: Running the Hello World Cells
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Hello World单元格
- en: Let’s run through a few simple examples so you can get a feel for what it’s
    like to work in a Jupyter notebook if you’ve never done so before. We’re going
    to run three types of commands to demonstrate the syntax for running Python code
    as well as R code and a command-line tool from the Python context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些简单的示例，这样你就能感受一下在Jupyter笔记本中工作的感觉，如果你以前没有这样做过的话。我们将运行三种类型的命令来演示运行Python代码、R代码以及Python环境下的命令行工具的语法。
- en: Python Hello World
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python Hello World
- en: 'This is the classic Hello World in Python, using the `print()` function and
    giving it the string `Hello World`. As you may recall from the Hello World we
    did in WDL in [Chapter 8](ch08.xhtml#automating_analysis_execution_with_work),
    this is the equivalent of the `echo "Hello World"` command that we used at the
    time. To run the cell, click anywhere in the gray area to select the cell and
    then press Shift+Enter on your keyboard, or, at the top of the page, on the toolbar,
    use the Run menu to run the cell:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是经典的Python Hello World示例，使用`print()`函数并给它传递字符串`Hello World`。你可能还记得在[第8章](ch08.xhtml#automating_analysis_execution_with_work)中我们在WDL中使用`echo
    "Hello World"`命令的情况。要运行该单元格，点击灰色区域中的任意位置选择单元格，然后按键盘上的Shift+Enter，或者在页面顶部的工具栏上使用“Run”菜单运行该单元格：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can use a variable for the greeting if you want to give yourself some flexibility.
    Double-click the cell to edit it and modify the code, as follows, and then run
    it again:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要给问候语增加一些灵活性，可以使用变量。双击单元格编辑并修改代码，如下所示，然后再次运行它：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Incidentally, this shows you that when you have a cell containing multiple lines,
    running it executes all the code in the cell. Sometimes, it makes sense to group
    multiple commands in a single cell because you’re always going to want to run
    them all. However, you could also choose to divide them into separate cells. Try
    doing that now. You can add a new cell to the notebook either by clicking the
    “+” icon on the toolbar at the top of the page or by going to the Insert menu.
    The former automatically creates the new cell below the one that is currently
    active, whereas the Insert menu gives you an explicit choice to add it either
    above or below the active cell.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这显示了当你有一个包含多行内容的单元格时，运行它会执行单元格中的所有代码。有时，将多个命令分组到一个单元格中是有意义的，因为你总是希望运行它们所有。但是，你也可以选择将它们分成多个单元格。现在试着做一下这个。你可以通过点击页面顶部工具栏上的“+”图标或者转到“Insert”菜单向笔记本添加新单元格。前者会自动在当前活动单元格下方创建新单元格，而“Insert”菜单则可以明确选择将其添加到当前活动单元格的上方或下方。
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This allows you to decouple the assignment of the variable and the execution
    of the task itself. In this simple example, it doesn’t make much difference, but
    when you are performing more complex operations, the choice of which commands
    to group versus which to break apart becomes more important.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这使你能够将变量的赋值与任务执行分开。在这个简单的例子中，这并没有太大的区别，但是当你执行更复杂的操作时，选择将哪些命令分组以及哪些命令分开变得更加重要。
- en: Now that you have the basic mechanics down, let’s have a look at how we can
    run some R code within this Python notebook.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了基本的操作技巧，让我们看看如何在这个Python笔记本中运行一些R代码。
- en: R Hello World using Python magic methods
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python魔术方法运行R Hello World
- en: 'This one requires a tiny bit of setup before we can dive into the Hello World
    exercise itself. Remember the startup script we used to customize the notebook
    runtime? One of the steps in that script installs the `rpy2` package, which handles
    the interpretation of R code within the Python notebook, into the runtime environment.
    It’s one of the magic methods features we mentioned earlier in the chapter. To
    activate it, you first need to import the `rpy` package and activate the corresponding
    notebook extension:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以深入进行Hello World练习之前，这需要一点设置。还记得我们用来自定义笔记本运行时的启动脚本吗？在该脚本中的一个步骤是安装`rpy2`包，该包处理Python笔记本中的R代码解释，是我们在本章前面提到的魔术方法功能之一。要激活它，您首先需要导入`rpy`包并激活相应的笔记本扩展：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This can take a few seconds, during which time the server displays an asterisk
    (`*`) in the brackets to the left of the cell to indicate that it’s working on
    it. After the package is loaded, you have two ways to invoke the magic methods:
    use `%R` for a single line of code or `%%R` for an entire cell.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几秒钟，此期间服务器在单元格左侧的括号中显示一个星号（`*`）以指示正在处理中。加载包后，您有两种调用魔术方法的方式：使用`%R`用于单行代码或`%%R`用于整个单元格。
- en: 'Here’s the same basic Hello World as we ran earlier but in R this time, using
    the single-line magic methods invocation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同样基本的Hello World示例，但这次是在R中运行的，使用单行魔术方法调用：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Yes, that’s the same code as we ran in the Python example, because R also has
    a `print()` function. You can recognize that it’s the R version because the output
    shows up as an array with the greeting as a single string element, whereas the
    Python version just returned the text of the greeting as a string by itself.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这与我们在Python示例中运行的代码相同，因为R也有一个`print()`函数。您可以通过输出显示它是R版本，因为输出显示为带有问候语作为单个字符串元素的数组，而Python版本只返回问候语的文本字符串本身。
- en: 'That being said, modifying it to use a variable assignment makes it a little
    more obvious that it’s R code as opposed to Python. This time, use `%%R` to apply
    the magic methods to the whole cell:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，将其修改为使用变量赋值会使其更加明显，说明它是R代码而不是Python代码。这次，使用`%%R`将魔术方法应用于整个单元格：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There you go: you’re running R code in a Python notebook. This is going to
    be really handy when we get to the “serious” exercises, because we need to use
    Python in order to embed an IGV browser (coming up real soon!), but we also want
    to use an existing R script later for plotting. Now we have access to the best
    of both worlds. Just remember that when you start using this in your own notebooks,
    you’ll need to include the cell that imports `rpy2` and activates the extension.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：您正在Python笔记本中运行R代码。当我们进行“严肃”的练习时，这将非常方便，因为我们需要使用Python来嵌入IGV浏览器（很快就会介绍！），但我们也希望稍后使用现有的R脚本进行绘图。现在我们可以同时享受最好的两个世界。只需记住，当您开始在自己的笔记本中使用它时，您需要包含导入`rpy2`并激活扩展的单元格。
- en: 'This brings us to the third type of command that we’re going to want to run
    in our notebook: command-line tools like `ls`, `gsutil`, and GATK.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到我们笔记本中要运行的第三种类型的命令：像`ls`、`gsutil`和GATK这样的命令行工具。
- en: Command-line tool Hello World using Python magic methods
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python魔术方法的命令行工具Hello World
- en: 'For this one, there’s nothing to load; the Hello World case works out of the
    box. We’ll use the classic `echo` command that we used in our WDL Hello World
    example. Simply prepend an exclamation mark to the command and then run the cell:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，没有什么需要加载的；Hello World案例可以直接使用。我们将使用在WDL Hello World示例中使用过的经典`echo`命令。只需在命令前面加上一个感叹号，然后运行该单元格：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can use all the classic shell commands in this way; for example, if you
    want to list the contents of the working directory, type `**! ls**` in a cell
    and run it. Similarly, you can run any command-line tool installed in the notebook
    runtime environment in this way. All preset environments available in Terra include
    the `gsutil` package, so you can use those tools in any Terra notebook. We walk
    you through specific examples of that in the next section. Later, we also run
    commands to run GATK, which our startup script installed, using the same basic
    syntax.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以这种方式使用所有经典的Shell命令；例如，如果您想列出工作目录的内容，请在单元格中键入`**! ls**`并运行它。类似地，您可以以此方式运行笔记本运行环境中安装的任何命令行工具。Terra中所有预设环境都包括`gsutil`包，因此您可以在任何Terra笔记本中使用这些工具。我们将在下一节中详细介绍具体示例。稍后，我们还会运行命令以运行我们的启动脚本安装的GATK，使用相同的基本语法。
- en: We’ve been focusing on code cells so far, but keep in mind all of the descriptive
    text cells are also editable, of course. Feel free to double-click a few and see
    how their appearance changes to show that they are in editing mode. Try making
    some edits and then, when you’re done, “run” the cell (just as you would run a
    code cell) to exit the text-editing mode. The descriptive text cells use a simple
    formatting markup language called *Markdown*, so you can set header levels, make
    bullet-point lists, and so on. For more on working with Markdown, see this helpful
    [page](https://oreil.ly/07KtL) in the Jupyter project documentation. When you
    create new cells in your notebook, the system makes them code cells by default,
    but you can switch them to Markdown via the Cell menu, by choosing Cell Type >
    Markdown.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于代码单元格，但请记住，所有描述性文本单元格也是可编辑的。当然，可以双击一些单元格，看看它们的外观如何变化以显示它们处于编辑模式。尝试进行一些编辑，然后完成后，“运行”单元格（就像运行代码单元格一样），退出文本编辑模式。描述性文本单元格使用一种简单的格式标记语言称为*Markdown*，因此您可以设置标题级别，制作项目列表等。有关使用Markdown的更多信息，请参阅Jupyter项目文档中这个有用的[页面](https://oreil.ly/07KtL)。创建笔记本中的新单元格时，默认情况下会将它们设置为代码单元格，但可以通过Cell菜单选择Cell
    Type > Markdown将它们切换为Markdown。
- en: Now that you have a firm grip on the fundamentals, it’s time to do some work
    that is more specific to the cloud environment and the genomics subject matter
    that interests us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对基础知识有了牢固的掌握，是时候做一些更具体于云环境和我们感兴趣的基因组学主题的工作了。
- en: Using gsutil to Interact with Google Cloud Storage Buckets
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gsutil与Google Cloud Storage桶交互
- en: 'Most of the time, the data we want to work with in the notebook resides in
    GCS buckets, so the first thing you need to learn is how to access that data.
    Here’s some good news: you can use `gsutil` commands to do all the same things
    we’ve previously shown you in [Chapter 4](ch04.xhtml#first_steps_in_the_cloud)
    and beyond. For example, use `gsutil ls` to list the contents of the book bucket:^([1](ch12.xhtml#idm45625613561112))'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中，我们想要处理的数据大多数时间存储在GCS桶中，因此您首先需要学习如何访问这些数据。好消息是：您可以使用`gsutil`命令来执行我们在[第4章](ch04.xhtml#first_steps_in_the_cloud)及以后展示的所有相同操作。例如，使用`gsutil
    ls`列出书桶的内容：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, you can use `gsutil cp` to *localize* files; that is, copy them
    from a bucket to the notebook’s local storage space. For example, use the following
    command to copy a file from the book bucket to the *sandbox* directory in the
    notebook runtime:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用`gsutil cp`来*本地化*文件；也就是说，将它们从桶复制到笔记本运行时的本地存储空间。例如，使用以下命令将文件从书桶复制到笔记本运行时的*sandbox*目录：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, you can run `cat` to read the contents of the localized file. You could
    write this in Python instead because this is a Python notebook, but it’s hard
    to beat the brevity of `cat`!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以运行`cat`来读取本地化文件的内容。您可以在Python中编写这个命令，因为这是一个Python笔记本，但是很难超越`cat`的简洁性！
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, these are essentially the same commands we used in [Chapter 4](ch04.xhtml#first_steps_in_the_cloud),
    except that we added the `!` in front to signal the Python interpreter to execute
    that line as a terminal command instead of reading it as Python code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些基本上是我们在[第4章](ch04.xhtml#first_steps_in_the_cloud)中使用的相同命令，只是我们在前面加了`!`来告诉Python解释器将该行作为终端命令执行，而不是作为Python代码读取。
- en: Setting Up a Variable Pointing to the Germline Data in the Book Bucket
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个变量指向书桶中的生殖系列数据
- en: 'The next few exercises are going to make use of the germline data that we provide
    in the book’s data bundle. Because the path to the example data is rather long,
    let’s set up a variable to store it in the notebook in a more concise form, much
    as we did with an environmental variable back in [Chapter 5](ch05.xhtml#first_steps_with_gatk):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个练习将使用我们在书的数据捆绑包中提供的生殖系列数据。由于示例数据的路径相当长，让我们设置一个变量以更简洁的形式将其存储在笔记本中，就像我们在[第5章](ch05.xhtml#first_steps_with_gatk)中使用环境变量一样：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a Python variable, so when you use it in a shell command, you’ll need
    to wrap it up in curly braces. For example, a command using `gsutil` to list the
    contents of that directory would look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Python变量，所以当您在shell命令中使用它时，您需要用大括号括起来。例如，使用`gsutil`命令列出该目录的内容如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Take a moment to think about how we’re using curly braces around this variable
    instead of calling it as `$GERM_DATA`, which you might have expected based on
    the Bash environment variables that we’ve been using quite a bit so far. The key
    point to remember here is that we set up the bucket shortcut as a Python variable,
    not a shell environment variable. It is possible to use shell environment variables
    in the notebook, but that’s a topic for another time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们在这个变量周围使用花括号而不是像您可能根据我们迄今使用过的Bash环境变量中那样调用它为`$GERM_DATA`的做法。这里需要记住的关键点是，我们将存储桶快捷方式设置为Python变量，而不是shell环境变量。在笔记本中可以使用shell环境变量，但这是另一个时间的话题。
- en: You can also compose paths based on this variable in order to list subdirectories;
    for example, to get a list of the BAM files, or perform operations on specific
    files. For each of the following commands, try to infer what its function is,
    then run it in the notebook and evaluate the result against your expectation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以基于这个变量来组合路径以列出子目录；例如，获取BAM文件列表或对特定文件执行操作。对于以下每个命令，请尝试推断其功能，然后在笔记本中运行它，并将结果与您的预期进行评估。
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Later in this chapter, we also show you how to use this same `GERM_DATA` variable
    in the context of some Python code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面，我们还向您展示了如何在一些Python代码的上下文中使用相同的`GERM_DATA`变量。
- en: Setting Up a Sandbox and Saving Output Files to the Workspace Bucket
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个沙盒并将输出文件保存到工作空间存储桶。
- en: When you run commands in the notebook that produce output files, by default
    those files will be saved on the notebook’s local storage space. However, the
    local storage associated with your notebook is temporary, so you’ll need to copy
    any outputs that you care about to a GCS bucket. You can use any bucket to which
    you have write access for that purpose, but we recommend using the workspace’s
    dedicated bucket.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在笔记本中运行生成输出文件的命令时，默认情况下这些文件将保存在笔记本的本地存储空间中。然而，与您的笔记本关联的本地存储是临时的，因此您需要将任何关心的输出复制到一个GCS存储桶中。您可以使用任何您有写入权限的存储桶来执行此操作，但我们建议使用工作空间专用的存储桶。
- en: 'To streamline the process of saving outputs to the bucket, we like to do two
    things: create a sandbox to house the output files that we’re going to produce,
    and set up a variable pointing to the workspace bucket.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化将输出保存到存储桶的过程，我们喜欢做两件事：创建一个沙盒来存放我们将要生成的输出文件，并设置一个指向工作空间存储桶的变量。
- en: 'Let’s begin with the *sandbox* directory; go ahead and create a new directory,
    and then move some files there for demonstration purposes. Once again, we include
    the commands here but don’t detail their purpose or results. We do provide additional
    detail in the notebook. Try to infer the function of each command before you look
    at its full description and run it in the notebook:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*sandbox*目录开始；创建一个新目录，并将一些文件移动到那里以进行演示。这里我们仅包含命令，但不详细说明其目的或结果。我们在笔记本中提供了更多细节。在查看完整描述并在笔记本中运行命令之前，请尝试推断每个命令的功能：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you have your sandbox ready, let’s tackle the workspace bucket. The workspace
    bucket name is a long machine-generated sequence of letters and numbers, which
    is annoying to work with. Fortunately, we can import it programmatically (rather
    than looking it up manually in the workspace dashboard) because Terra makes it
    available to the notebook as a system variable. And to make it even easier, we’re
    going to create a Python variable from that system variable as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的沙盒准备好后，让我们来处理工作空间存储桶。工作空间存储桶名称是一长串由字母和数字组成的机器生成序列，使用起来有些烦人。幸运的是，我们可以通过程序导入它（而不是手动在工作空间仪表板中查找），因为Terra将其作为系统变量提供给笔记本。为了更加简便，我们将按以下方式从该系统变量创建Python变量：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we use Python commands to set variables at the Python level. The `import
    os` command allows us to interact with the operating system from within Python
    code, and the `os.environ['WORKSPACE_BUCKET']` call uses that to access the value
    of the environment variable `'WORKSPACE_BUCKET'`, which was originally set for
    you by the Terra Notebooks service.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用Python命令在Python层级设置变量。`import os`命令允许我们在Python代码中与操作系统交互，而`os.environ['WORKSPACE_BUCKET']`调用则使用这一功能访问环境变量`'WORKSPACE_BUCKET'`的值，这个变量最初是由Terra笔记本服务为您设置的。
- en: 'From here on, you’ll be able to refer to the workspace bucket as `WS_BUCKET`.
    For example, you can use `gsutil ls` to list its contents:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，您可以将工作空间存储桶称为`WS_BUCKET`。例如，您可以使用`gsutil ls`列出其内容：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we wrapped the `WS_BUCKET` variable in curly braces, just as we
    did for the germline data variable in the previous section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们用花括号括起了`WS_BUCKET`变量，就像我们在前一节中对germline数据变量所做的那样。
- en: 'After that’s set up, you can simply run the same `gsutil cp` command on the
    *sandbox* directory whenever you want to save your outputs to the workspace bucket:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，每当你想把输出保存到工作空间存储桶时，只需在*sandbox*目录上运行相同的`gsutil cp`命令：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This copies the entire *sandbox* directory from the notebook’s local storage
    to the workspace bucket. Keep in mind that this approach might not scale very
    well if you’re producing many large files; in that case, you might want to consider
    dividing and managing your sandbox in separate subdirectories. It is admittedly
    not ideal that you must synchronize files manually to the bucket; we look forward
    to seeing improvements to the experience of using these tools as the technology
    develops further. At least the notebook file itself is saved automatically, as
    we discussed earlier.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将整个*sandbox*目录从笔记本的本地存储复制到工作空间存储桶。请记住，如果你生成了许多大文件，这种方法可能不会很好扩展；在这种情况下，你可能需要考虑将sandbox分成单独的子目录来管理。承认手动同步文件到存储桶并不理想；我们期待看到这些工具的体验随着技术的发展而改进。至少笔记本文件本身是自动保存的，正如我们之前讨论的那样。
- en: Visualizing Genomic Data in an Embedded IGV Window
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌入的IGV窗口中可视化基因组数据
- en: 'Now that our notebook is all set up and ready to roll,  let’s use it to try
    out a cool trick: visualizing genomic data with IGV within the context of the
    notebook. In previous chapters, we had you work with the desktop version of IGV,
    which you had set up to pull data from GCS. This time, we’re going to do something
    a little different: we’re going to use a special IGV package called *IGV.js* that
    allows us to embed an IGV browser in the notebook. This is especially convenient
    when you want to include the data visualization within a tutorial for students,
    or within a report to communicate results to collaborators, in such a way that
    they don’t need to resort to using a separate program.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的笔记本已经设置好并准备就绪，让我们试试一个酷炫的技巧：在笔记本的上下文中使用IGV来可视化基因组数据。在之前的章节中，我们让你使用桌面版IGV，并设置它从GCS获取数据。这一次，我们要做一些不同的事情：我们将使用一个称为*IGV.js*的特殊IGV包，在笔记本中嵌入IGV浏览器。当你希望将数据可视化包含在学生教程中或在报告中向合作者传达结果时，这是非常方便的，这样他们就不需要使用单独的程序。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *IGV.js* package has limitations that we describe further in just a moment.
    In a nutshell, it’s very cool when it works, so we do think it’s worth showing
    you how to use it in a Jupyter notebook, but it doesn’t always work seamlessly.
    If you experience any difficulties while using it, we recommend that you fall
    back to using Desktop IGV, as previously described.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*IGV.js*包有一些限制，我们稍后将进一步描述。简而言之，当它工作时非常酷，所以我们确实认为在Jupyter笔记本中展示如何使用它是值得的，但它并不总是无缝运行。如果你在使用过程中遇到任何困难，我们建议你回到使用桌面版IGV，如前所述。'
- en: 'In this exercise, we’re going to load two BAM files: the WGS mother sample,
    which has been our go-to test file for most of the book, and an exome sample from
    the same person for comparison. You might recall that in [Chapter 2](ch02.xhtml#genomics_in_a_nutshell_a_primer_for_new)
    (a lifetime ago), we touched on the differences between several library design
    strategies, including WGS and exome sequencing. In particular, we discussed how
    their coverage profiles have very different shapes: the WGS tends to look like
    a distant mountain range, whereas the exome sample looks more like a series of
    volcanic islands scattered in the ocean. This is an opportunity for you to see
    that for yourself, essentially replicating [Figure 2-18](ch02.xhtml#visual_appearance_of_whole_genome_seque)
    in an interactive form, while trying out the *IGV.js* integration.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将加载两个BAM文件：WGS母样本，这已经是本书大部分时间的测试文件，以及同一人的外显子样本进行比较。你可能还记得在[第2章](ch02.xhtml#genomics_in_a_nutshell_a_primer_for_new)（一辈子前），我们曾触及几种文库设计策略的区别，包括WGS和外显子测序。特别是，我们讨论了它们的覆盖率图的形状有很大不同：WGS倾向于看起来像远处的山脉，而外显子样本则更像是散布在海洋中的一系列火山岛屿。这是一个让你亲自看到的机会，本质上是复制[图2-18](ch02.xhtml#visual_appearance_of_whole_genome_seque)的交互形式，同时尝试*IGV.js*的集成。
- en: Setting Up the Embedded IGV Browser
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置嵌入式IGV浏览器
- en: 'The good news is that there’s not much you need to do here. Remember the startup
    script that you ran as part of the runtime environment customization? That included
    instructions to install all the prerequisite software to run *IGV.js*, which the
    system executed when it created your customized runtime environment. As a result,
    we just need to do a one-time import to activate the `igv` Python package. After
    that, it’s just a matter of creating an IGV browser wherever you want one to appear,
    as shown in the code cell that follows. This is all Python code that follows the
    guidelines documented by the IGV team in the [IGV-Jupyter repository](https://oreil.ly/JgOtt)
    on GitHub:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，在这里您不需要做太多事情。还记得您作为运行时环境定制的一部分运行的启动脚本吗？这包括安装运行 *IGV.js* 所需的所有先决条件的说明，系统在创建您的定制运行时环境时执行了这些说明。因此，我们只需执行一次导入来激活
    `igv` Python 包。之后，只需按照以下代码单元格中显示的方式创建需要显示的任意数量的 IGV 浏览器即可。以下所有内容都是 Python 代码，遵循
    IGV 团队在 GitHub 上 [IGV-Jupyter 仓库](https://oreil.ly/JgOtt) 中记录的指南：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The name we give the browser (here, `IGV_Explore`) is completely arbitrary.
    You could provide other parameters to initialize the browser, but the only one
    that is absolutely required is the genome reference; everything else is optional.
    That being said, we usually specify some coordinates (or the name of a gene of
    interest) for the browser to zoom in on straight away.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为浏览器起的名称（这里是`IGV_Explore`）完全是任意的。您可以提供其他参数来初始化浏览器，但唯一必需的是基因组参考；其他所有内容都是可选的。话虽如此，通常我们会为浏览器指定一些坐标（或感兴趣的基因名称），以便立即进行放大。
- en: When you run the cell, you should see an embedded IGV browser that includes
    the reference genome and a RefSeq gene track, but no actual data tracks, as shown
    in [Figure 12-12](#a_newly_created_igv_browserdot).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行该单元格时，应该会看到一个嵌入的 IGV 浏览器，其中包括参考基因组和 RefSeq 基因轨道，但没有实际的数据轨道，如 [Figure 12-12](#a_newly_created_igv_browserdot)
    所示。
- en: '![A newly created IGV browser.](Images/gitc_1212.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![新创建的 IGV 浏览器。](Images/gitc_1212.png)'
- en: Figure 12-12\. A newly created IGV browser.
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-12\. 新创建的 IGV 浏览器。
- en: Next, let’s add the two sample BAM files that we want to compare.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加我们想要比较的两个样本 BAM 文件。
- en: Adding Data to the IGV Browser
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据添加到 IGV 浏览器中
- en: 'For each track that we want to load, we need to provide this same set of metadata:
    a name for the track, the path to where the file lives in GCS, the format, and
    the path to the corresponding index file. We provide this information to IGV using
    the `load_track()` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要加载的每一个轨道，我们需要提供相同的元数据：轨道的名称、文件在 GCS 中的路径、格式以及相应索引文件的路径。我们使用 `load_track()`
    函数向 IGV 提供这些信息：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because this is all Python code, we can use the Python variable that we set
    up for the germline data simply by referring to its name, `GERM_DATA`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这都是 Python 代码，我们可以简单地通过引用其名称 `GERM_DATA` 来使用我们为生殖细胞数据设置的 Python 变量。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take a moment to note the Python syntax, which explicitly uses a `+` operator
    to concatenate the variable and the subdirectory strings in order to compose the
    full address pointing to where the data files reside. This is in contrast to the
    shell syntax that we used earlier in the `gsutil` command, `"{GERM_DATA}/bams"`,
    which is a more implicit instruction. If you’re not very familiar with Python,
    know that this exemplifies one of the cardinal rules of Python programming: explicit
    is better than implicit.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意一下 Python 语法，它明确使用 `+` 运算符来连接变量和子目录字符串，以便组成指向数据文件所在位置的完整地址。这与我们之前在 `gsutil`
    命令中使用的 shell 语法 `"{GERM_DATA}/bams"` 形成对比，后者是一种更为隐式的指令。如果您对 Python 不太熟悉，知道这体现了
    Python 编程的一个基本原则：显式优于隐式。
- en: 'After you’ve run both cells and each of them returns `OK` as a result, scroll
    up to the browser, where you should see spinning symbols that indicate the data
    is loading. When the spinners go away and the data displays, you should have two
    data tracks in your IGV browser: the WGS and exome versions of the mother sample,
    respectively, as shown in [Figure 12-13](#the_igv_browser_showing_the_two_sequenc).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行两个单元格，并且它们每一个都以 `OK` 作为结果返回后，请向上滚动到浏览器，您应该会看到旋转符号，表示数据正在加载。当旋转器消失并显示数据时，在您的
    IGV 浏览器中应该会有两个数据轨道：母体样本的全基因组测序和外显子版本，如 [Figure 12-13](#the_igv_browser_showing_the_two_sequenc)
    所示。
- en: '![The IGV browser showing the two sequence data tracks.](Images/gitc_1213.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![IGV 浏览器显示的两个序列数据轨道。](Images/gitc_1213.png)'
- en: Figure 12-13\. The IGV browser showing the two sequence data tracks.
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-13\. IGV 浏览器显示的两个序列数据轨道。
- en: Try zooming in and out, and drag the sequence left and right to pan the view
    and get a sense of how the data is distributed in these two samples. You’ll observe
    the classic “mountain range versus volcanic islands” difference in coverage profile,
    which you can use from here onward to identify the library design type of any
    sequencing sample on sight.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试缩放和拖动序列左右以查看视图，并对比这两个样本中数据分布的经典“山脉对火山岛屿”的覆盖率差异。从此开始，您可以直接通过视觉判断任何测序样本的文库设计类型。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is technically possible to load VCF and BAM files in the embedded IGV browser
    without specifying an index file. To do so, omit the `"indexURL"` line and replace
    it with `"indexed": False`. Be aware, however, that doing so will cause IGV to
    take much longer to load the data. It can take a couple of minutes for the data
    to load, and you might see a pop-up window stating that the page is unresponsive.
    If so, dismiss the alert and give it another minute. If it takes much longer than
    that, you might need to fall back to using the desktop version of IGV.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '在嵌入式IGV浏览器中加载VCF和BAM文件而不指定索引文件是可行的技术操作。为此，请省略 `"indexURL"` 行，并将其替换为 `"indexed":
    False`。但请注意，这样做会导致IGV加载数据的时间大大延长。数据加载可能需要几分钟，并且可能会看到一个弹出窗口提示页面无响应。如果出现此情况，请关闭警报并再等待一分钟。如果加载时间远远超过此时间，您可能需要回到使用IGV的桌面版本。'
- en: 'We hope you’ll agree this is a neat way to include a view of the genomic data
    within an analysis log or report, even though it suffers from a few limitations.
    One limitation is the lag that you might experience when you originally load the
    data; another is the fact that not all display customization options are available
    compared to the desktop version of IGV. Authentication can be a major stumbling
    block if you don’t have proper guidance: if you want to access data in private
    buckets (which includes your workspace bucket!), you need to jump through additional
    hoops that involve access credentials. You might recall that in [Chapter 4](ch04.xhtml#first_steps_in_the_cloud)
    you had to enable a Google login option in the desktop version of IGV in order
    to view files from a private bucket. Here, we’re going to do something similar,
    except instead of a point-and-click process, it will consist of a few lines of
    code.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您同意，这是一种不错的方式，可以在分析日志或报告中包含基因组数据的视图，尽管它存在一些限制。一个限制是在初始加载数据时可能遇到的延迟；另一个是与IGV桌面版本相比，不是所有的显示定制选项都可用。如果没有适当的指导，身份验证可能是一个主要障碍：如果您想访问私有存储桶中的数据（包括您的工作空间存储桶！），您需要跳过涉及访问凭据的额外步骤。您可能还记得，在[第4章](ch04.xhtml#first_steps_in_the_cloud)中，您必须在IGV桌面版本中启用Google登录选项，以便查看来自私有存储桶的文件。在这里，我们将做类似的事情，只是不是通过点点点的过程，而是通过几行代码来完成。
- en: Setting Up an Access Token to View Private Data
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置访问令牌以查看私有数据
- en: In the previous example, we were reading data from completely public buckets,
    so we didn’t need to do any authentication. However, you’ll eventually want to
    view files in private buckets. To do that, you need to set up an access token
    that IGV can use to access data in your private bucket.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们从完全公开的存储桶中读取数据，因此不需要进行任何身份验证。但是，您最终可能需要查看私有存储桶中的文件。为此，您需要设置一个访问令牌，IGV可以使用该令牌来访问您私有存储桶中的数据。
- en: 'First, let’s use `gcloud auth` to generate an access token and save it to a
    file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `gcloud auth` 生成访问令牌并将其保存到文件中：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As long as this file is saved only to your notebook’s local storage, it is secure
    because your runtime environment is strictly personal to you and cannot be accessed
    by others, even if you share your workspace or your notebook with them. But don’t
    save this file to your workspace bucket! Saving it to the bucket would make it
    visible to anyone with whom you share the workspace.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 只要此文件仅保存在笔记本的本地存储中，它就是安全的，因为您的运行环境严格个人化，其他人无法访问，即使您与他们分享工作空间或笔记本。但不要将此文件保存到您的工作空间存储桶中！保存到存储桶将使任何与您分享工作空间的人都能看到该文件。
- en: 'Next, read the contents of the token file into a Python variable. Because the
    token consists of a single line of text, we can use the `readline()` function,
    which reads the first line of a file into a string:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将令牌文件的内容读入Python变量中。由于令牌只包含一行文本，我们可以使用 `readline()` 函数，该函数将文件的第一行读入字符串中：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, you have the `token` variable stored and ready to use with IGV
    whenever you want to load a file that resides in a private bucket.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经将 `token` 变量存储并准备好在需要加载存储在私有存储桶中的文件时与IGV一起使用。
- en: 'For example, recall that in the previous section, we had you copy the *mother.bam*
    file and its index to your workspace bucket. Even though you own that bucket,
    the IGV process that is running in your notebook doesn’t “know” that you’re allowed
    to access it. You must instruct it explicitly by providing the token that you
    just set up when you make the call to `load_track()` function, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回想一下前一节中我们让你复制*mother.bam*文件及其索引到你的工作空间存储桶。即使你拥有那个存储桶，运行在你笔记本中的IGV进程也不知道你有权访问它。你必须明确地通过在调用`load_track()`函数时提供刚刚设置的令牌来指示它，如下所示：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we copied the same code we used earlier to load BAM files, except
    this time we provided the path to the files in the workspace bucket and added
    the token that we generated earlier. If you’re curious to see what would happen
    if you didn’t provide the token, feel free to try it out by deleting that line
    (as well as the comma that ends the previous line). Note that it is also possible
    to access data that resides in private buckets managed outside of Terra. As we’ll
    see in [Chapter 13](ch13.xhtml#assembling_your_own_workspace_in_terra), this requires
    giving access to the bucket to your proxy group service account.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们复制了之前用于加载BAM文件的相同代码，但这次我们提供了工作空间存储桶中文件的路径，并添加了先前生成的令牌。如果你好奇不提供令牌会发生什么，请随意尝试删除该行（以及前一行末尾的逗号）。请注意，也可以访问由Terra之外的管理私有存储桶中的数据。正如我们将在[第13章](ch13.xhtml#assembling_your_own_workspace_in_terra)中看到的那样，这需要将存储桶访问权限授予您的代理组服务帐户。
- en: If you were to have multiple private files to load in the IGV browser, you would
    include the token in each track definition. The [IGV documentation](https://oreil.ly/RWDqg)
    states that it is possible to set a global IGV configuration variable, `igv.setGoogleOauth​Token​(accessToken)`,
    that would apply to all tracks, but as of this writing, that did not work within
    our notebook.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个私有文件要加载到IGV浏览器中，你需要在每个轨迹定义中包含令牌。[IGV文档](https://oreil.ly/RWDqg)指出可以设置全局IGV配置变量，`igv.setGoogleOauth​Token​(accessToken)`，适用于所有轨迹，但截至撰写本文时，在我们的笔记本中这并不起作用。
- en: Running GATK Commands to Learn, Test, or Troubleshoot
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行GATK命令以学习、测试或排除故障
- en: It’s all well and good that we can visualize the sequencing data from within
    a notebook, but we were already able to achieve the equivalent result with the
    desktop version of IGV. What’s really cool about the notebook concept is that
    we can run analysis commands and then visualize the output, all within the same
    environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在笔记本中从可视化测序数据，但是我们已经能够通过桌面版的IGV实现了相当的结果。笔记本概念真正酷的地方在于，我们可以运行分析命令，然后在同一环境中可视化输出结果。
- en: What kind of analyses can you run, you ask? Well, just about anything you want.
    As you saw when we had you run `gsutil` commands, you’re not constrained to running
    only Python code in a Python notebook. You can run pretty much anything that you
    can install and run in the shell environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，你可以运行什么样的分析呢？好吧，几乎任何你想运行的东西。正如我们在让你运行`gsutil`命令时所看到的，你不仅限于在Python笔记本中运行Python代码。你几乎可以运行任何你可以安装并在shell环境中运行的东西。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Here we’re relying on the startup script that you used to initialize your notebook
    runtime environment at the start of this chapter’s exercises. That script includes
    instructions to download the GATK package and make it available for command-line
    invocation, which were executed when the environment was created for you, so you
    don’t need to do any of it yourself.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依赖于你在本章练习开始时用来初始化笔记本运行环境的启动脚本。该脚本包括下载GATK包并使其可用于命令行调用的说明，这些说明在为您创建环境时已执行，因此您无需自行操作。
- en: In this section, we show you how to run GATK commands and visualize the results
    in IGV, both from within the notebook. We find that this provides a much more
    integrated and seamless experience than the “split-screen” approach we took in
    earlier chapters in which we were running GATK commands in a VM and then visualizing
    results in the desktop version of IGV. We put you through all that because we’re
    sadists, and also because it gave you the opportunity to build up foundational
    skills. Through that process, you gained a measure of familiarity with the underlying
    components of cloud computing that should help you conceptualize what’s happening
    behind the scenes when you run a workflow or work in a notebook. And perhaps having
    gone through that will enhance your appreciation of the notebook-based approach,
    if only for purposes like teaching, testing, and troubleshooting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何在笔记本中运行 GATK 命令并在 IGV 中可视化结果。我们发现，与我们在较早的章节中采用的“分屏”方法相比，这提供了一种更加集成和无缝的体验，之前我们在虚拟机中运行
    GATK 命令，然后在桌面版 IGV 中可视化结果。我们让您经历了这一切，因为我们是虐待狂，而且这也为您提供了建立基础技能的机会。通过这个过程，您对云计算的基础组件有了一定的熟悉度，这应该有助于您在运行工作流程或在笔记本中工作时理解幕后发生的事情。也许通过这个经历，您对基于笔记本的方法有了更深的理解，即使只是用于教学、测试和故障排除等目的。
- en: To that end, we’re going to revisit exercises that you previously worked through
    in [Chapter 5](ch05.xhtml#first_steps_with_gatk) so you can focus your attention
    on *how* you are doing the work rather than what the analysis means.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将重新访问您在[第5章](ch05.xhtml#first_steps_with_gatk)中之前完成的练习，这样您可以将注意力集中在*如何*进行工作，而不是分析的含义是什么。
- en: 'Running a Basic GATK Command: HaplotypeCaller'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行基本的 GATK 命令：HaplotypeCaller
- en: 'Let’s begin by running the `HaplotypeCaller` tool on the same sample we’ve
    been using throughout the book. You should recognize this command, which we copied
    almost verbatim from [Chapter 5](ch05.xhtml#first_steps_with_gatk):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在整本书中都在使用的相同样本上运行`HaplotypeCaller`工具开始。您应该能够认出这个命令，我们几乎是直接从[第5章](ch05.xhtml#first_steps_with_gatk)中复制的：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What are the differences in this command compared to how we ran it in [Chapter 5](ch05.xhtml#first_steps_with_gatk)?
    By now you should recognize the `!` that precedes the GATK command as the signal
    to bypass the Python interpreter and run it as a shell command. The reference
    to the file path variable is also a little different since we’re using curly braces
    instead of `$`, as noted earlier. We’re also writing the output VCF file in the
    compressed *gzip* form, which is a requirement for IGV in the next step.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第5章](ch05.xhtml#first_steps_with_gatk)中运行它的方式相比，这个命令有什么不同？现在您应该能够认出`!`在
    GATK 命令之前的作用是绕过 Python 解释器并将其作为 shell 命令运行的信号。由于我们使用的是大括号而不是 `$`，因此对文件路径变量的引用也略有不同，正如前面提到的。我们还将输出的
    VCF 文件以压缩的*gzip*形式写入，这是下一步中 IGV 的要求。
- en: Another difference is a bit hidden by our use of a Python variable to store
    the common part of the input file paths, *gs://genomics-in-the-cloud/v1/data/germline*.
    This time, we’re using the paths to the files in GCS instead of pointing to a
    local copy. We can do that because, as we’ve noted several times by now, GATK
    tools are capable of streaming most types of file inputs directly from GCS. In
    practice this behavior kicks in whenever the GATK command-line parser identifies
    that an eligible input file path starts with *gs://*. This is great because it
    allows us to avoid localizing the relevant files to the notebook’s local storage.
    Incidentally, this also works for writing output files directly to GCS, though
    we don’t demonstrate it here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是我们使用 Python 变量来存储输入文件路径的公共部分，*gs://genomics-in-the-cloud/v1/data/germline*。这一次，我们使用
    GCS 中文件的路径而不是指向本地副本。我们之所以能够这样做，是因为正如我们之前多次提到的，GATK 工具能够直接从 GCS 流式传输大多数类型的文件输入。在实践中，每当
    GATK 命令行解析器识别到符合条件的输入文件路径以 *gs://* 开头时，就会发生这种行为。这很棒，因为它允许我们避免将相关文件本地化到笔记本的本地存储中。顺便说一句，这也适用于直接将输出文件写入
    GCS，尽管我们在这里没有演示。
- en: In [Chapter 5](ch05.xhtml#first_steps_with_gatk) through [Chapter 7](ch07.xhtml#gatk_best_practices_for_somatic_variant),
    we had you localize the full data bundle and run all GATK commands with local
    file inputs. We could have had you run most of the commands with the bucket paths
    instead and relied on GATK’s data streaming capabilities; it would have worked
    just fine on your VM. However, we felt that introducing those aspects so early
    would overcomplicate what might well be your first experience with the cloud.
    We chose instead to have you work with localized files in the hope that the ensuing
    experience would provide enough familiarity to make you feel more comfortable.
    We bring this up now in case you choose to go back to working in a VM environment,
    so that you know that you can still take advantage of the streaming feature. And,
    as you might remember from the discussion on optimizations in [Chapter 10](ch10.xhtml#running_single_workflows_at_scale_with),
    this also works in the context of WDL workflows.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第五章](ch05.xhtml#first_steps_with_gatk) 到 [第七章](ch07.xhtml#gatk_best_practices_for_somatic_variant)
    中，我们要求您定位完整的数据包并使用本地文件输入运行所有 GATK 命令。我们本可以让您使用存储桶路径运行大多数命令，并依赖 GATK 的数据流功能；在您的虚拟机上完全可以正常工作。但是，我们觉得在这么早就介绍这些方面会过于复杂化云端的第一次体验。相反，我们选择让您使用本地化文件，希望随后的体验能够提供足够的熟悉感让您感觉更舒适。我们现在提出这个问题，以防您选择回到虚拟机环境工作，这样您就知道您仍然可以利用流式传输功能。而且，正如您可能还记得在
    [第十章](ch10.xhtml#running_single_workflows_at_scale_with) 中对优化讨论中所提到的那样，在 WDL 工作流的背景下也是适用的。
- en: When you run the command, you should see the log output being written to the
    notebook below the cell. This is a really nice touch in terms of keeping all the
    information about the analysis together in a single place—it’s one of the key
    benefits of the Jupyter concept. On the downside, if you’re running a tool that’s
    particularly verbose (as GATK can occasionally be), you can end up with pages
    and pages of a log in the middle of your notebook. That’s where it really helps
    to use clear section headers in Markdown cells to demarcate the different parts
    of your analysis, especially in combination with the notebook widget that automatically
    creates a table of contents and sidebar navigation menu.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行该命令时，您应该看到日志输出被写入单元格下的笔记本。这在将分析的所有信息保持在一个地方方面非常好，这是 Jupyter 概念的主要优势之一。不过，如果您运行的工具输出特别冗长（如
    GATK 有时可能会出现的情况），您可能会在笔记本的中间得到几页几页的日志。这时，在 Markdown 单元格中使用清晰的节标题来划分分析的不同部分特别有帮助，尤其是结合自动生成目录和侧边导航菜单的笔记本小部件时。
- en: 'After the `HaplotypeCaller`’s run is complete, let’s list the sandbox contents
    to confirm that the command worked and that the VCF of variant calls was created
    as expected:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HaplotypeCaller` 运行完成后，让我们列出 sandbox 内容以确认命令是否正常工作，并且期望创建变异调用的 VCF：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Yep, there it is, along with its index file. Let’s look at it in IGV.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是它，还有它的索引文件。让我们在 IGV 中查看它。
- en: Loading the Data (BAM and VCF) into IGV
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数据（BAM 和 VCF）到 IGV
- en: Suppose that we want to open the output VCF with IGV in our notebook, mainly
    to do a visual check and compare it to the BAM file. We could use the IGV browser
    that we created earlier to look at the different BAM files, but because this is
    a separate exercise with a different purpose—and we’re too lazy to scroll up a
    bunch of pages—we’re going to create a new one.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在笔记本中用 IGV 打开输出的 VCF，主要是为了进行视觉检查并将其与 BAM 文件进行比较。我们可以使用之前创建的 IGV 浏览器查看不同的
    BAM 文件，但由于这是一个具有不同目的的单独练习——而且我们懒得向上滚动几页——我们将创建一个新的浏览器。
- en: 'The first bit of code is essentially the same as what we used earlier except
    that we’re using a different name for the browser object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分代码与之前使用的基本相同，只是我们为浏览器对象使用了不同的名称：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This creates a new browser below the cell, zoomed in on intervals of interest
    but without any data. So, let’s load the variant data from the VCF file that we
    produced with the `HaplotypeCaller` command, which resides in the *sandbox* directory
    on the notebook’s local storage space:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在单元格下创建一个新的浏览器，放大感兴趣的区间，但没有任何数据。因此，让我们从笔记本本地存储空间的 *sandbox* 目录中加载用 `HaplotypeCaller`
    命令生成的 VCF 文件中的变异数据：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is the same code that we used earlier to load BAM files, except this time
    we changed the track `format` property to `vcf` instead of `bam`, and the file
    paths (`url` and `indexURL`) are pointing to local files instead of pointing to
    locations in GCS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前用来加载BAM文件的相同代码，只是这次我们将跟踪的`format`属性更改为`vcf`而不是`bam`，文件路径（`url`和`indexURL`）指向本地文件而不是指向GCS中的位置。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Pay attention to those file paths: you should notice that they’re not exactly
    the file paths you would expect based on the directory structure of the notebook’s
    local storage space. Do you see it? The `files/` part does not refer to a real
    directory! It’s a prefix that we add for IGV’s benefit, as instructed in the [IGV-Jupyter
    project documentation](https://oreil.ly/JgOtt).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些文件路径：你应该注意到它们并不完全是基于笔记本本地存储空间目录结构所期望的文件路径。你看到了吗？`files/`部分并不指向一个真实的目录！这是我们为了IGV的利益而添加的前缀，正如[IGV-Jupyter项目文档](https://oreil.ly/JgOtt)中所述。
- en: Alternatively, you could run the `gsutil cp` command to copy the sandbox to
    the workspace bucket and then use the paths to the workspace bucket copy to load
    the VCF track. However, if you do that, don’t forget to include the access token
    as explained in the previous section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以运行`gsutil cp`命令将沙盒复制到工作空间存储桶中，然后使用工作空间存储桶副本的路径加载VCF跟踪。但是，如果你这样做，请不要忘记包括如前一节所述的访问令牌。
- en: 'Finally, let’s load the BAM file and its index from the original germline data
    bundle. These files are located in a public bucket and therefore do not require
    specifying the access token (but if you do include it, nothing bad will happen):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们加载原始配子数据包中的BAM文件及其索引。这些文件位于公共存储桶中，因此不需要指定访问令牌（但如果包括也没有什么坏处）：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The resulting view, shown in [Figure 12-14](#igvdotjs_rendering_of_the_sequencing_da),
    should look essentially the same as what you produced in [Chapter 5](ch05.xhtml#first_steps_with_gatk),
    with a few differences in appearance between the desktop version and the *IGV.js*
    version of the visual rendering.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 结果视图显示，与您在[第5章](ch05.xhtml#first_steps_with_gatk)中生成的内容基本相同，只是桌面版本与*IGV.js*版本的视觉渲染之间有一些外观上的差异。
- en: '![IGV.js rendering of the sequencing data ("Mother WGS" track) and output variants
    produced by HaplotypeCaller ("Mother variants" track).](Images/gitc_1214.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![IGV.js渲染的测序数据（“Mother WGS”跟踪）和由HaplotypeCaller生成的输出变异（“Mother variants”跟踪）](Images/gitc_1214.png)'
- en: Figure 12-14\. IGV.js rendering of the sequencing data (“Mother WGS” track)
    and output variants produced by HaplotypeCaller (“Mother variants” track).
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-14\. IGV.js渲染的测序数据（“Mother WGS”跟踪）和由HaplotypeCaller生成的输出变异（“Mother variants”跟踪）。
- en: You can click elements of data (e.g., reads or variants) in the viewer to bring
    up additional details, just as we did in [Chapter 5](ch05.xhtml#first_steps_with_gatk).
    The visual display is a little different, but it’s basically the same functionality,
    except that you can’t switch it to show details “on hover.”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 点击查看者中的数据元素（例如，阅读或变异）以获取更多详细信息，就像我们在[第5章](ch05.xhtml#first_steps_with_gatk)中所做的那样。视觉显示略有不同，但基本功能相同，只是不能切换为“悬停显示”详细信息。
- en: One difference that’s not obvious here is that the embedded IGV window organizes
    tracks a little differently compared to the way the desktop version of IGV does
    it. In the desktop version, variant tracks are automatically displayed above sequence
    data tracks, regardless of the order in which they are loaded. You could load
    a BAM file first and then a VCF file, yet the variant track will always be on
    top. In contrast, the embedded IGV window displays tracks in whatever order they
    are added. So, if you load the BAM file first, that’s what will be on top, even
    if you load a VCF file afterward.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不明显的一个区别是嵌入的IGV窗口在组织跟踪时与桌面版IGV的方式有些不同。在桌面版中，变异跟踪始终自动显示在序列数据跟踪之上，而不管它们加载的顺序如何。你可以先加载一个BAM文件，然后加载一个VCF文件，但变异跟踪始终会显示在顶部。相反，在嵌入的IGV窗口中，跟踪显示的顺序与它们添加的顺序一致。因此，如果您首先加载BAM文件，那么它将显示在顶部，即使随后加载VCF文件也是如此。
- en: Hopefully this gives you a good sense of how you can use the embedded IGV within
    a notebook. Let’s work through one more exercise from the original [Chapter 5](ch05.xhtml#first_steps_with_gatk)
    curriculum to practice using this tooling and cover a few more minor options.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能让您了解如何在笔记本中使用嵌入的IGV。让我们从原始的[第5章](ch05.xhtml#first_steps_with_gatk)课程中再进行一个练习，以练习使用这个工具并涵盖一些更小的选项。
- en: Troubleshooting a Questionable Variant Call in the Embedded IGV Browser
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内嵌的IGV浏览器中排除问题的可疑变异调用
- en: You might recall that in [Chapter 5](ch05.xhtml#first_steps_with_gatk) we took
    a closer look at the homozygous variant insertion of three T bases that appears
    in the variant track in this region. At first glance, we were skeptical of `HaplotypeCaller`’s
    decision because the call didn’t seem to be supported by the sequencing data.
    Do you remember the first thing we did to investigate? That’s right, we turned
    on the display of soft clips, those bits of sequence data tagged as “unusable”
    by the mapper that are normally hidden by default. Let’s do that now in the IGV
    window in the notebook.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，在[第5章](ch05.xhtml#first_steps_with_gatk)中，我们更仔细地查看了这一区域的变异轨道中出现的三个T碱基的同型变异插入。乍一看，我们对`HaplotypeCaller`的决定持怀疑态度，因为这个调用似乎并未得到测序数据的支持。您还记得我们进行调查的第一步是什么吗？没错，我们打开了软剪接的显示，这些被映射器标记为“不可用”的序列数据片段通常默认情况下是隐藏的。现在让我们在笔记本中的IGV窗口中执行此操作。
- en: As you can see in [Figure 12-15](#menu_of_display_options_for_the_quotmot),
    you can bring up track-viewing options by clicking on the gear icon to the right
    of the track of interest. Do that now for the Mother WGS sequence data track and
    select “Show soft clips;” then, in the upper-right corner of the menu, click the
    X to close it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[Figure 12-15](#menu_of_display_options_for_the_quotmot)中所看到的，您可以通过单击感兴趣的轨道右侧的齿轮图标来显示轨道查看选项。现在为Mother
    WGS序列数据轨道执行此操作，并选择“显示软剪接”；然后，在菜单的右上角，单击X关闭它。
- en: '![Menu of display options for the "Mother WGS" sequence data track.](Images/gitc_1215.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![“Mother WGS”序列数据轨道的显示选项菜单。](Images/gitc_1215.png)'
- en: Figure 12-15\. Menu of display options for the Mother WGS sequence data track.
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-15\. “Mother WGS”序列数据轨道的显示选项菜单。
- en: You should see the entire area light up in the bright glare of multitudes of
    mismatches, as shown in [Figure 12-16](#display_of_soft_clipsdot).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到整个区域因大量不匹配而明亮地闪烁，如[Figure 12-16](#display_of_soft_clipsdot)所示。
- en: '![Display of soft-clips.](Images/gitc_1216.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![显示软剪接。](Images/gitc_1216.png)'
- en: Figure 12-16\. Display of soft clips.
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-16\. 显示软剪接。
- en: 'You know what to do now, right? Questionable indel call, tons of soft clips…Yes,
    it’s time to generate a bamout to see what `HaplotypeCaller` was thinking when
    it made that call:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道该做什么了，对吧？可疑的插入缺失调用，大量软剪接…是的，是时候生成一个bamout来看看`HaplotypeCaller`在进行这个调用时是怎么想的了：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That should run very quickly and produce the key output we’re interested in,
    which is the BAM file that shows how `HaplotypeCaller` has realigned the read
    data, as explained in [Chapter 5](ch05.xhtml#first_steps_with_gatk). Let’s add
    that file to our IGV browser:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该运行得非常快，并产生我们感兴趣的关键输出，即显示`HaplotypeCaller`如何重新排列读取数据的BAM文件，正如在[第5章](ch05.xhtml#first_steps_with_gatk)中所解释的。让我们将该文件添加到我们的IGV浏览器中：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, this should produce a view that is equivalent, though not identical,
    to the one we encountered in [Chapter 5](ch05.xhtml#first_steps_with_gatk). As
    previously, we can conclude that `HaplotypeCaller`’s call of an indel was reasonable,
    given the realigned data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这应该产生一个视图，虽然不完全相同，但与我们在[第5章](ch05.xhtml#first_steps_with_gatk)中遇到的相似。与之前一样，我们可以得出结论，考虑到重新排列的数据，`HaplotypeCaller`对插入缺失的调用是合理的。
- en: 'Incidentally, you might notice that in this one we specified the height of
    the track with `"height": 500`. This can be useful when we’re trying to showcase
    a specific view of the data in a way that minimizes scrolling, for example. Feel
    free to experiment with setting the height of different tracks.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '顺便说一句，您可能注意到，在这个调用中，我们指定了轨道的高度为`"height": 500`。例如，当我们试图以减少滚动的方式展示数据的特定视图时，这可能非常有用。请随意尝试设置不同轨道的高度。'
- en: What do you think of this approach to running and examining GATK commands? We
    could continue mirroring all of the material that we covered in [Chapter 5](ch05.xhtml#first_steps_with_gatk)
    through [Chapter 7](ch07.xhtml#gatk_best_practices_for_somatic_variant) in this
    way, and in fact, there are several such GATK tutorial notebooks in public Terra
    workspaces, which the GATK team uses in its popular series of international workshops.
    We encourage you to check those out for further study.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为这种运行和检查GATK命令的方法如何？我们可以通过这种方式继续在这本书中镜像所有我们在[第5章](ch05.xhtml#first_steps_with_gatk)到[第7章](ch07.xhtml#gatk_best_practices_for_somatic_variant)中涵盖的材料，并且事实上，在公共Terra工作区中有几个这样的GATK教程笔记本，GATK团队在其流行的国际研讨会系列中使用。我们鼓励您进一步研究这些内容。
- en: However, for the purposes of this book, and this chapter in particular, we want
    to focus on covering the most useful aspects of Jupyter notebooks in relation
    to the types of interactions you would typically have with genomic data. We have
    a few more that we’re excited to show you, so we need to move on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于本书和特别是本章的目的，我们希望专注于涵盖Jupyter笔记本与基因组数据交互的最有用的方面。我们还有一些要向您展示的内容，所以我们需要继续前进。
- en: The next logical step is to plot variant data. There are many aspects of variant
    data that you might want to explore visually, but we can’t cover them all—in fact,
    we can really cover only one. So, let’s tackle the topic of visualizing how variant
    context annotation values are distributed, which can be helpful for understanding
    variant filtering methods, as we discussed in [Chapter 5](ch05.xhtml#first_steps_with_gatk).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是绘制变异数据。有许多变异数据的方面可能需要视觉探索，但我们无法覆盖所有——实际上，我们只能真正涵盖其中一个。因此，让我们来解决可视化变异上下文注释值分布的主题，这对于理解变异过滤方法很有帮助，正如我们在[第5章](ch05.xhtml#first_steps_with_gatk)中讨论的那样。
- en: Visualizing Variant Context Annotation Data
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化变异上下文注释数据
- en: You might recall that in [Chapter 5](ch05.xhtml#first_steps_with_gatk) we described
    using an annotation (`callsets`) derived from the GiaB truth set in order to understand
    how the distributions of variant context annotations can inform us about the quality
    of our variant calls. We used a visual approach to making that assessment, which
    involved plotting variant context annotation values in a couple of ways (density
    plots and scatter plots). If that doesn’t ring a bell or if you’re feeling fuzzy
    on the details, please take a few minutes to read through that section again to
    refresh your memory. At the time, we focused on the concepts and outlined the
    procedure only in general terms, so here we’re going to take the opportunity to
    show you how to apply key steps to reproduce the plots shown in [Figure 5-8](ch05.xhtml#aright_parenthesis_density_plot_of_qual)
    through [Figure 5-11](ch05.xhtml#a_scatter_plot_with_marginal_densities).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，在[第5章](ch05.xhtml#first_steps_with_gatk)中，我们描述了使用从GiaB真实数据集中派生的注释（`callsets`）来理解变异上下文注释分布如何帮助我们理解变异调用质量的方法。我们使用了一种视觉方法来进行评估，其中涉及以几种方式（密度图和散点图）绘制变异上下文注释值。如果这并没有让您想起什么，或者如果您对细节感到困惑，请花几分钟时间再次阅读该部分，以刷新您的记忆。当时，我们专注于概念并仅以一般术语概述了过程，因此在这里，我们将利用这个机会向您展示如何应用关键步骤来复现[图5-8](ch05.xhtml#aright_parenthesis_density_plot_of_qual)到[图5-11](ch05.xhtml#a_scatter_plot_with_marginal_densities)中显示的图表。
- en: Exporting Annotations of Interest with VariantsToTable
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VariantsToTable导出感兴趣的注释
- en: We start with the VCF of SNPs called from the Mother WGS sample that we’ve previously
    annotated with information for the GiaB truth set. For a tutorial showing how
    to perform the full procedure, including subsetting and annotation steps, see
    this [GATK tutorial workspace](https://oreil.ly/WGncb).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以前用GiaB真实数据集为Mother WGS样本调用的SNP的VCF文件开始，已经对其进行了注释。要查看如何执行完整过程的教程，包括子集和注释步骤，请参阅这个[GATK教程工作空间](https://oreil.ly/WGncb)。
- en: 'The VCF file format is rather painful to work with directly, so for this exercise,
    we’re going to make life easier on ourselves and export the information we care
    about from the VCF file into a tab-delimited table, to make it easier to parse
    in R. To that end, we run the GATK tool `VariantsToTable` on the annotated input
    VCF file, providing it with the list of annotations we’re interested in. We use
    the `-F` argument for INFO (site-level) annotations and `-GF` for FORMAT (sample-level)
    annotations, where the *F* stands for field, and *GF* for genotype field, respectively:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 直接操作VCF文件格式相当痛苦，因此在这个练习中，我们将简化操作，将我们关心的信息从VCF文件导出到一个制表符分隔的表格中，以便在R中更容易解析。为此，我们在注释过的输入VCF文件上运行GATK工具`VariantsToTable`，并提供我们感兴趣的注释列表。我们使用`-F`参数用于INFO（站点级）注释和`-GF`用于FORMAT（样本级）注释，其中*F*代表字段，*GF*代表基因型字段：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `VariantsToTable` command should run very quickly to produce the output
    file, *motherSNP.giab.txt*. This is a plain-text file, so we can view a snippet
    of it using `cat`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`VariantsToTable`命令应该非常快速地生成输出文件*motherSNP.giab.txt*。这是一个纯文本文件，所以我们可以使用`cat`查看它的片段：'
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, the tool produced a table in which each line represents a variant
    record from the VCF, and each column represents an annotation that we specified
    in the export command. Wherever a requested annotation was not present (for example,
    homozygous sites do not have `RankSum` annotations, because that annotation can
    be calculated only for heterozygous sites), the value was replaced by `NA`. With
    this plain-text table in hand, we can easily load the full set of variant calls
    and their annotation values into an R DataFrame.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该工具生成了一个表格，其中每一行表示来自VCF的变异记录，每一列表示我们在导出命令中指定的注释。无论请求的注释是否存在（例如，同源位点没有`RankSum`注释，因为该注释仅对杂合位点计算），值都被替换为`NA`。有了这个纯文本表格，我们可以轻松地将完整的变异调用集及其注释值加载到R
    DataFrame中。
- en: 'To load the table contents into an R DataFrame, we call the `readr` library
    and use its `read_delim` function to load the *motherSNP.giab.txt* table into
    the `motherSNP.giab` DataFrame object. Notice that the R command is preceded by
    the `%%R` symbol, which as we learned earlier instructs the notebook kernel that
    all of the code in this cell should be interpreted in R:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要将表格内容加载到R DataFrame中，我们调用`readr`库并使用其`read_delim`函数将*motherSNP.giab.txt*表格加载到`motherSNP.giab`
    DataFrame对象中。请注意，R命令前面有`%%R`符号，正如我们之前学到的，它指示笔记本内核应该解释本单元格中的所有代码为R代码：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When the DataFrame is ready, you can manipulate it using your favorite R functions.
    And, as it happens, we have some handy plotting functions all lined up for you.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当DataFrame准备好时，您可以使用您喜欢的R函数来操纵它。正如情况所发生的那样，我们已经为您准备了一些方便的绘图函数。
- en: Loading R Script to Make Plotting Functions Available
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载R脚本以使绘图函数可用
- en: We’re going to take advantage of an existing R script provided by the GATK support
    team. The script, which is available in the book repository and in the bucket,
    defines three plotting functions that utilize a fantastic R library called `ggplot2`
    to visualize the distribution of variant annotation values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用由GATK支持团队提供的现有R脚本。该脚本可在书籍存储库和存储桶中找到，定义了三个绘制函数，利用名为`ggplot2`的出色R库来可视化变异注释值的分布。
- en: 'To make these functions available in the notebook, we could simply copy the
    contents of the R script into a code cell and run it. However, because this is
    a script that we might want to run in multiple notebooks, and we don’t want to
    have to maintain separate copies, let’s use a smarter way to import the code.
    You’re going to copy the R script to the notebook’s local storage, and then use
    the `source()` function in R to load the R script code into the notebook:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要在笔记本中使这些函数可用，我们可以简单地将R脚本内容复制到代码单元格中并运行它。但是，由于这是一个我们可能想要在多个笔记本中运行的脚本，并且我们不想维护单独的副本，让我们使用更智能的方法来导入代码。您将把R脚本复制到笔记本的本地存储中，然后使用R中的`source()`函数将R脚本代码加载到笔记本中：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This outputs about a page’s worth of log, which we’re not showing here. The
    log output is displayed on a red background, which is a tad alarming, but don’t
    worry about it unless the next steps fail. If you do encounter issues, check whether
    your output is different from what is shown in the prerun copy of the notebook
    (which also contains solutions to the do-it-yourself exercises). If everything
    works as it should, you’ll now have a few new R packages installed and loaded,
    and the plotting functions will be available.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出大约一页的日志，这里我们不展示。日志输出显示为红色背景，有点令人担忧，但是除非下一步失败，否则不要担心。如果遇到问题，请检查您的输出是否与笔记本的预运行副本中显示的内容不同（该副本还包含自助练习的解决方案）。如果一切正常，您现在将安装并加载了几个新的R包，并且绘图函数将可用。
- en: Let’s try that out, shall we? First up, the density plot.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧，首先是密度图。
- en: Making Density Plots for QUAL by Using makeDensityPlot
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作QUAL的密度图使用makeDensityPlot
- en: 'The `makeDensityPlot` function takes a DataFrame and an annotation of interest
    to generate a density plot, which is basically a smoothed version of the histogram,
    representing the distribution of values for that annotation. Here’s how we can
    use it to reproduce Figures [5-8](ch05.xhtml#aright_parenthesis_density_plot_of_qual)
    and [5-9](ch05.xhtml#density_plot_of_qual_aright_parenthesis). In each of the
    following cells, the first line creates the plot and then the second line calling
    its name displays it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeDensityPlot` 函数接受一个 DataFrame 和一个感兴趣的注释，生成一个密度图，这基本上是直方图的平滑版本，表示该注释的值的分布。这是我们如何使用它来复现
    [第 5-8](ch05.xhtml#aright_parenthesis_density_plot_of_qual) 和 [第 5-9](ch05.xhtml#density_plot_of_qual_aright_parenthesis)
    图的方法。在以下每个单元格中，第一行创建图表，然后调用其名称显示它：'
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The QUAL distribution shown in [Figure 12-17](#qual_distributiondot) has a
    very long tail on the right, so let’s zoom in by restricting the x-axis to a reasonable
    maximum value by using the optional `xmax` argument, with the result presented
    in [Figure 12-18](#qual_density_plotdot):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-17](#qual_distributiondot) 中显示的 QUAL 分布在右侧有一个非常长的尾部，因此让我们通过使用可选的 `xmax`
    参数将 x 轴限制在合理的最大值上来进行放大，结果呈现在 [图 12-18](#qual_density_plotdot) 中：'
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![QUAL distribution.](Images/gitc_1217.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![QUAL 分布。](Images/gitc_1217.png)'
- en: Figure 12-17\. QUAL distribution.
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-17\. QUAL 分布。
- en: '![QUAL density plot.](Images/gitc_1218.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![QUAL 密度图。](Images/gitc_1218.png)'
- en: Figure 12-18\. QUAL density plot.
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-18\. QUAL 密度图。
- en: 'We can also specify an annotation to use for organizing the data into subsets
    and have the function generate a separate density curve for each subset of data.
    Here, we use the `giab.callsets` annotation, which refers to the number of callsets
    in the GiaB truth set called the same variant. The higher the number, the more
    we can trust the variant call:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定一个注释来将数据组织成子集，并让函数为每个数据子集生成一个单独的密度曲线。在这里，我们使用了 `giab.callsets` 注释，它指的是在
    GiaB 真值集中叫做同一变异的呼叫集数量。数字越高，我们对变异调用的信任度就越高：
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Figure 12-19](#qual_density_plots_by_callsets_from_gia) shows the result.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-19](#qual_density_plots_by_callsets_from_gia) 显示了结果。'
- en: '![QUAL density plots by callsets from GiaB.](Images/gitc_1219.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![GiaB 从呼叫集的 QUAL 密度图。](Images/gitc_1219.png)'
- en: Figure 12-19\. QUAL density plots by callsets from GiaB.
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-19\. GiaB 从呼叫集的 QUAL 密度图。
- en: After you have that working, try generating the same kind of plots for other
    annotations. As an example, we used similar commands to generate [Figure 5-10](ch05.xhtml#density_plot_of_qd_aright_parenthesis_a)
    for the `QualByDepth` (QD) annotation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成这个工作之后，尝试为其他注释生成相同类型的图。例如，我们使用类似的命令生成了 [第 5-10](ch05.xhtml#density_plot_of_qd_aright_parenthesis_a)
    图，用于 `QualByDepth` (QD) 注释。
- en: Now let’s try making scatter plots. Everyone loves a good scatter plot, right?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试制作散点图。每个人都喜欢一个好的散点图，对吧？
- en: Making a Scatter Plot of QUAL Versus DP
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作 QUAL 对 DP 的散点图
- en: 'The `makeScatterPlot` function takes a DataFrame and two annotations of interest
    to generate a 2D scatter plot of the two annotations in which each data point
    is an individual variant call. Here’s how we can use it to reproduce [Figure 5-8](ch05.xhtml#aright_parenthesis_density_plot_of_qual)
    from [Chapter 5](ch05.xhtml#first_steps_with_gatk), with [Figure 12-20](#scatter_plot_qual_versus_dpdot)
    displaying the result:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeScatterPlot` 函数接受一个 DataFrame 和两个感兴趣的注释，生成两个注释的 2D 散点图，其中每个数据点是一个单独的变异调用。这是我们如何使用它来复现
    [第 5-8](ch05.xhtml#aright_parenthesis_density_plot_of_qual) 图，同时 [第 12-20](#scatter_plot_qual_versus_dpdot)
    图显示结果的方法：'
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Scatter plot QUAL versus DP.](Images/gitc_1220.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![散点图 QUAL 对 DP。](Images/gitc_1220.png)'
- en: Figure 12-20\. Scatter plot QUAL versus DP.
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-20\. QUAL 对 DP 的散点图。
- en: This function accepts the same `xmax` argument as `makeDensityPlot` for limiting
    the range of values on the x-axis, and a new `ymax` argument to limit values on
    the y-axis. Feel free to experiment with these arguments to zoom in on subsets
    of data.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受与 `makeDensityPlot` 相同的 `xmax` 参数，用于限制 x 轴上的值范围，并且还有一个新的 `ymax` 参数来限制
    y 轴上的值。随时尝试使用这些参数来放大数据的子集。
- en: You can also use the same `split` argument for splitting the data into subsets,
    with the effect of coloring the points based on the subset they belong to. Try
    doing that now based on what you learned in the previous exercise and then try
    applying the same principles to plot other annotations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用相同的 `split` 参数将数据分割成子集，根据它们所属的子集对数据点进行着色。现在根据你在之前练习中学到的内容尝试这样做，然后尝试应用相同的原则来绘制其他注释。
- en: Finally, in our last plotting exercise, we’re going to combine both the scatter
    and the density plotting.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的最后一个绘图练习中，我们将同时结合散点图和密度图绘制。
- en: Making a Scatter Plot Flanked by Marginal Density Plots
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制由边缘密度图包围的散点图
- en: 'The `makeScatterPlotWithMarginalDensity` function takes a DataFrame and two
    annotations, combining the other two functions to generate a scatter plot flanked
    horizontally and vertically by the annotations’ respective density plots. Here’s
    how we can use it to reproduce [Figure 5-11](ch05.xhtml#a_scatter_plot_with_marginal_densities)
    from [Chapter 5](ch05.xhtml#first_steps_with_gatk), with the result shown in [Figure 12-21](#a_scatter_plot_along_with_density_plots):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeScatterPlotWithMarginalDensity`函数接受一个DataFrame和两个注释，结合其他两个函数生成横向和纵向由注释对应的密度图包围的散点图。以下是我们如何使用它来复制[第5章](ch05.xhtml#first_steps_with_gatk)中的[图5-11](ch05.xhtml#a_scatter_plot_with_marginal_densities)，结果显示在[图12-21](#a_scatter_plot_along_with_density_plots)中：'
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![A scatter plot along with density plots.](Images/gitc_1221.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![一张散点图和密度图。](Images/gitc_1221.png)'
- en: Figure 12-21\. A scatter plot along with density plots.
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-21. 一张散点图和密度图。
- en: As previously, we specify `giab.callsets` as the variable to use for splitting
    the variant data points into groups according to how much we trust them. We also
    set optional parameters (`xmax` and `ymax`) to limit the axes to display a subset
    of values, and we tweak the display of the data to optimize readability (`ptSize`
    and `ptAlpha`).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，我们将`giab.callsets`指定为要根据信任程度将变体数据点分组的变量。我们还设置了可选参数（`xmax`和`ymax`）以限制轴以显示数值的子集，并调整数据的显示以优化可读性（`ptSize`和`ptAlpha`）。
- en: Go ahead and try applying this to other pairs of annotations. Note that some
    annotations can have negative values, so be aware that the plotting functions
    also accept `xmin` and `ymin` arguments to limit the range of negative values
    to display.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 试着将其应用于其他注释对。请注意，某些注释可能具有负值，因此要注意，绘图函数还接受`xmin`和`ymin`参数以限制显示负值的范围。
- en: To be clear, there are a lot of other ways to manipulate and plot variant data
    from within a notebook. In fact, this particular method would not scale well for
    larger datasets, because it involves reading a potentially very large table directly
    into memory. We chose it for this tutorial because it has the advantage of being
    approachable for newcomers, and our primary goal was to give you a sense of the
    possibilities and familiarize you with the basic mechanics involved. However,
    for full-scale work, you’ll probably want to use more robust methods. We recommend
    checking out [Hail](https://hail.is), a Python-based, genetics-focused toolkit
    that is extraordinarily scalable and includes a suite of variant quality control
    functions, among other capabilities. Like some of the more recent GATK tools,
    Hail is capable of using Spark to parallelize analysis, and has been used to perform
    genome-wide analysis studies (GWAS) on massive datasets like the [UK Biobank](https://oreil.ly/mes1R).
    The Terra Library has a few workspaces that feature Hail, including a [set of
    tutorial notebooks](https://oreil.ly/-h7Zj) and a [complete GWAS example](https://oreil.ly/Q-LJD).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要清楚的是，在笔记本中操作和绘制变体数据的方法有很多种。实际上，这种特定的方法在处理较大数据集时不会很有效，因为它涉及直接将可能非常庞大的表格读入内存。我们之所以选择它作为本教程的一部分，是因为它对新手来说很容易理解，并且我们的主要目标是让您对可能性有所了解，并熟悉涉及的基本机制。但是，对于大规模工作，您可能会希望使用更健壮的方法。我们建议查看[Hail](https://hail.is)，这是一个基于Python的、专注于遗传学的工具包，具有极好的可扩展性，并包括一套变体质量控制功能等其他功能。像一些较新的GATK工具一样，Hail能够使用Spark并行化分析，并已用于进行像[英国生物银行](https://oreil.ly/mes1R)这样的大数据集的全基因组分析研究（GWAS）。Terra库中有一些功能Hail的工作区，包括一些[教程笔记本](https://oreil.ly/-h7Zj)和一个[完整的GWAS示例](https://oreil.ly/Q-LJD)。
- en: Wrap-Up and Next Steps
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结与下一步
- en: 'In this chapter, you learned how to use Jupyter in Terra to interact with your
    data. You began by learning the basic mechanics of using notebooks on the cloud,
    setting up your computing environment, opening an example notebook, and running
    code cells. With those foundations in place, you worked through three types of
    interactive analysis: visualizing genomic data in an embedded IGV browser, running
    and troubleshooting GATK commands, and plotting variant context annotation data
    in R.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在Terra中使用Jupyter与你的数据交互。你首先学习了在云端使用笔记本的基本机制，设置你的计算环境，打开示例笔记本并运行代码单元。有了这些基础，你进行了三种交互式分析：在嵌入的IGV浏览器中可视化基因组数据，运行和排除GATK命令以及在R中绘制变异上下文注释数据。
- en: 'This was by no means an exhaustive catalog of what you can do in this environment;
    if anything, we barely scratched the surface of what is possible. However, you
    now have enough grounding in the technology and tooling to start adapting your
    own analyses to work within the Terra framework. In [Chapter 13](ch13.xhtml#assembling_your_own_workspace_in_terra),
    we show you how to assemble your own workspaces from component elements: data,
    tools, and code from various origins.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是在这个环境中你可以做的所有事情的详尽目录；如果说有什么，我们只是勉强触及了可能性的表面。然而，你现在已经掌握了足够的技术和工具的基础，可以开始将自己的分析适应于Terra框架中运行。在[第13章](ch13.xhtml#assembling_your_own_workspace_in_terra)，我们向你展示了如何从组成元素（数据、工具和来自不同来源的代码）组装你自己的工作空间。
- en: ^([1](ch12.xhtml#idm45625613561112-marker)) From this point on, we don’t show
    the output of the cells. You can check your outputs against the copy of the notebook
    included in the Terra workspace. We also provide an html version of the pre-run
    notebook in the book’s [Github repository](https://oreil.ly/genomics-repo).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.xhtml#idm45625613561112-marker)) 从这一点开始，我们不再展示单元格的输出。你可以将输出与Terra工作空间中包含的笔记本副本进行比对。此外，我们还在书的[GitHub存储库](https://oreil.ly/genomics-repo)提供了预运行笔记本的html版本。
