- en: Chapter 4\. Arrays, slices, and maps
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章 数组、切片和映射
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容*'
- en: Array internals and fundamentals
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的内部结构和基本概念
- en: Managing collections of data with slices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切片管理数据集合
- en: Working with key/value pairs using maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射处理键/值对
- en: 'It’s difficult to write programs that don’t need to store and read collections
    of data. If you use databases or files, or access the web, you need a way to handle
    the data you receive and send. Go has three different data structures that allow
    you to manage collections of data: arrays, slices, and maps. These data structures
    are baked into the language and used throughout the standard library. Once you
    learn how these data structures work, programming in Go will become fun, fast,
    and flexible.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编写不需要存储和读取数据集合的程序是困难的。如果你使用数据库或文件，或访问网络，你需要一种处理接收和发送的数据的方法。Go有三种不同的数据结构，允许你管理数据集合：数组、切片和映射。这些数据结构内置于语言中，并在标准库中使用。一旦你了解了这些数据结构的工作原理，使用Go编程将变得有趣、快速且灵活。
- en: 4.1\. Array internals and fundamentals
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 数组的内部结构和基本概念
- en: It makes sense to start with arrays because they form the base data structure
    for both slices and maps. Understanding how arrays work will help you appreciate
    the elegance and power that slices and maps provide.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组开始是有意义的，因为它们是切片和映射的基础数据结构。了解数组的工作原理将帮助你欣赏切片和映射提供的优雅和强大。
- en: 4.1.1\. Internals
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1. 内部结构
- en: An array in Go is a fixed-length data type that contains a contiguous block
    of elements of the same type. This could be a built-in type such as integers and
    strings, or it can be a struct type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，数组是一种固定长度的数据类型，包含相同类型元素的连续块。这可以是内置类型，如整数和字符串，也可以是结构体类型。
- en: In [figure 4.1](#ch04fig01) you can see the representation of an array. The
    elements of the array are marked as a grey box and are connected in series to
    each other. Each element contains the same type, in this case an integer, and
    can be accessed through a unique index position.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4.1](#ch04fig01)中，你可以看到数组的表示。数组的元素被标记为灰色框，并依次连接。每个元素包含相同类型，在这种情况下是整数，并且可以通过唯一的索引位置访问。
- en: Figure 4.1\. Array internals
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1. 数组内部结构
- en: '![](04fig01_alt.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01_alt.jpg)'
- en: Arrays are valuable data structures because the memory is allocated sequentially.
    Having memory in a contiguous form can help to keep the memory you use stay loaded
    within CPU caches longer. Using index arithmetic, you can iterate through all
    the elements of an array quickly. The type information for the array provides
    the distance in memory you have to move to find each element. Since each element
    is of the same type and follows each other sequentially, moving through the array
    is consistent and fast.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是有价值的结构，因为内存是按顺序分配的。以连续形式存储内存可以帮助你使用的内存更长时间地保持在CPU缓存中。使用索引运算，你可以快速遍历数组的所有元素。数组类型信息提供了你找到每个元素所需的内存移动距离。由于每个元素都是同一类型并且依次排列，因此遍历数组是一致的且快速的。
- en: 4.1.2\. Declaring and initializing
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2. 声明和初始化
- en: An array is declared by specifying the type of data to be stored and the total
    number of elements required, also known as the array’s length.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 声明数组时，指定要存储的数据类型和所需的总元素数，也称为数组的长度。
- en: Listing 4.1\. Declaring an array set to its zero value
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1. 声明并初始化为零值的数组
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once an array is declared, neither the type of data being stored nor its length
    can be changed. If you need more elements, you need to create a new array with
    the length needed and then copy the values from one array to the other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了数组，存储的数据类型及其长度都不能更改。如果你需要更多元素，你需要创建一个新的数组，其长度为所需长度，然后将一个数组中的值复制到另一个数组中。
- en: When variables in Go are declared, they’re always initialized to their zero
    value for their respective type, and arrays are no different. When an array is
    initialized, each individual element that belongs to the array is initialized
    to its zero value. In [figure 4.2](#ch04fig02), you can see an array of integers
    with each element in the array initialized to 0, the zero value for integers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Go中声明变量时，它们总是初始化为其各自类型的零值，数组也不例外。当数组初始化时，属于数组的每个单独的元素都被初始化为其零值。在[图4.2](#ch04fig02)中，你可以看到一个整数数组，数组中的每个元素都被初始化为0，这是整数的零值。
- en: Figure 4.2\. Values of the array after the declaration of the array variable
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2. 数组变量声明后的数组值
- en: '![](04fig02_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig02_alt.jpg)'
- en: A fast and easy way to create and initialize arrays is to use an array literal.
    Array literals allow you to declare the number of elements you need and specify
    values for those elements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和初始化数组的一个快速简单的方法是使用数组字面量。数组字面量允许你声明所需的元素数量并指定这些元素的值。
- en: Listing 4.2\. Declaring an array using an array literal
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. 使用数组字面量声明数组
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the length is given as `...`, Go will identify the length of the array based
    on the number of elements that are initialized.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果长度以`...`给出，Go将根据初始化的元素数量确定数组的长度。
- en: Listing 4.3\. Declaring an array with Go calculating size
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3\. 使用Go计算大小的数组声明
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you know the length of the array you need, but are only ready to initialize
    specific elements, you can use this syntax.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已知所需数组的长度，但只准备初始化特定元素，你可以使用这种语法。
- en: Listing 4.4\. Declaring an array initializing specific elements
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. 声明并初始化特定元素的数组
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The values for the array declared in [listing 4.4](#ch04ex04) will look like
    [figure 4.3](#ch04fig03) after the array is declared and initialized.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明并初始化数组后，[列表4.4](#ch04ex04)中声明的数组的值将类似于[图4.3](#ch04fig03)。
- en: Figure 4.3\. Values of the array after the declaration of the array variable
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 声明数组变量后的数组值
- en: '![](04fig03_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig03_alt.jpg)'
- en: 4.1.3\. Working with arrays
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 使用数组
- en: As we talked about, arrays are efficient data structures because the memory
    is laid out in sequence. This gives arrays the advantage of being efficient when
    accessing individual elements. To access an individual element, use the `[ ]`
    operator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，数组是高效的数据结构，因为内存是按顺序排列的。这使得数组在访问单个元素时具有效率优势。要访问单个元素，请使用`[ ]`运算符。
- en: Listing 4.5\. Accessing array elements
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5\. 访问数组元素
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The values for the array declared in [listing 4.5](#ch04ex05) will look like
    [figure 4.4](#ch04fig04) after the array operations are complete.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成数组操作后，[列表4.5](#ch04ex05)中声明的数组的值将类似于[图4.4](#ch04fig04)。
- en: Figure 4.4\. Values of the array after changing the value of index 2
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. 改变索引2的值后数组的值
- en: '![](04fig04_alt.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig04_alt.jpg)'
- en: You can have an array of pointers. Like in [chapter 2](kindle_split_010.html#ch02),
    you use the `*` operator to access the value that each element pointer points
    to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有指针数组。就像在第2章中一样，你使用`*`运算符来访问每个元素指针指向的值。
- en: Listing 4.6\. Accessing array pointer elements
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. 访问数组指针元素
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values for the array declared in [listing 4.6](#ch04ex06) will look like
    [figure 4.5](#ch04fig05) after the array operations are complete.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成数组操作后，[列表4.6](#ch04ex06)中声明的数组的值将类似于[图4.5](#ch04fig05)。
- en: Figure 4.5\. An array of pointers that point to integers
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 指向整数的指针数组
- en: '![](04fig05_alt.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig05_alt.jpg)'
- en: An array is a value in Go. This means you can use it in an assignment operation.
    The variable name denotes the entire array and, therefore, an array can be assigned
    to other arrays of the same type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，数组是一个值。这意味着你可以在赋值操作中使用它。变量名表示整个数组，因此数组可以被赋值给相同类型的其他数组。
- en: Listing 4.7\. Assigning one array to another of the same type
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 将一个数组赋值给相同类型的另一个数组
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the copy, you have two arrays with identical values, as shown in [figure
    4.6](#ch04fig06).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 复制后，你将有两个具有相同值的数组，如图[图4.6](#ch04fig06)所示。
- en: Figure 4.6\. Both arrays after the copy
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 复制后的两个数组
- en: '![](04fig06_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig06_alt.jpg)'
- en: The type of an array variable includes both the length and the type of data
    that can be stored in each element. Only arrays of the same type can be assigned.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数组变量的类型包括长度和每个元素可以存储的数据类型。只有相同类型的数组才能被赋值。
- en: Listing 4.8\. Compiler error assigning arrays of different types
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. 分配不同类型的数组时的编译错误
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Copying an array of pointers copies the pointer values and not the values that
    the pointers are pointing to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 复制指针数组会复制指针值，而不是指针指向的值。
- en: Listing 4.9\. Assigning one array of pointers to another
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. 将一个指针数组赋值给另一个
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the copy, you have two arrays pointing to the same strings, as shown in
    [figure 4.7](#ch04fig07).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 复制后，你将有两个指向相同字符串的数组，如图[图4.7](#ch04fig07)所示。
- en: Figure 4.7\. Two arrays of pointers that point to the same strings
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7\. 指向相同字符串的两个指针数组
- en: '![](04fig07.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig07.jpg)'
- en: 4.1.4\. Multidimensional arrays
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 多维数组
- en: Arrays are always one-dimensional, but they can be composed to create multidimensional
    arrays. Multidimensional arrays come in handy when you need to manage data that
    may have parent/child relationships or is associated with a coordinate system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数组始终是一维的，但可以通过组合来创建多维数组。当需要管理可能具有父子关系或与坐标系相关联的数据时，多维数组非常有用。
- en: Listing 4.10\. Declaring two-dimensional arrays
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 声明二维数组
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Figure 4.8](#ch04fig08) shows the values each array contains after declaring
    and initializing these arrays.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.8](#ch04fig08) 展示了声明和初始化这些数组后每个数组包含的值。'
- en: Figure 4.8\. Two-dimensional arrays and their outer and inner values
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. 二维数组和它们的内外值
- en: '![](04fig08_alt.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08_alt.jpg)'
- en: To access an individual element, use the `[ ]` operator again and a bit of composition.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问单个元素，再次使用 `[ ]` 操作符和一些组合。
- en: Listing 4.11\. Accessing elements of a two-dimensional array
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 访问二维数组的元素
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can copy multidimensional arrays into each other as long as they have the
    same type. The type of a multidimensional array is based on the length of each
    dimension and the type of data that can be stored in each element.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只要多维数组具有相同的类型，就可以将它们相互复制。多维数组的类型基于每个维度的长度以及每个元素可以存储的数据类型。
- en: Listing 4.12\. Assigning multidimensional arrays of the same type
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 赋值相同类型的多维数组
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because an array is a value, you can copy individual dimensions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组是一个值，所以可以复制单个维度。
- en: Listing 4.13\. Assigning multidimensional arrays by index
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 通过索引赋值多维数组
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 4.1.5\. Passing arrays between functions
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5\. 在函数间传递数组
- en: Passing an array between functions can be an expensive operation in terms of
    memory and performance. When you pass variables between functions, they’re always
    passed by value. When your variable is an array, this means the entire array,
    regardless of its size, is copied and passed to the function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数间传递数组在内存和性能方面可能是一个昂贵的操作。当你将变量在函数间传递时，它们总是通过值传递。当你的变量是数组时，这意味着无论其大小如何，整个数组都会被复制并传递给函数。
- en: To see this in action, let’s create an array of one million elements of type
    `int`. On a 64-bit architecture, this would require eight million bytes, or eight
    megabytes, of memory. What happens when you declare an array of that size and
    pass it to a function?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个操作的实际效果，让我们创建一个包含一百万个 `int` 类型元素的数组。在 64 位架构上，这将需要八百万字节，即八兆字节，的内存。当你声明这样一个大小的数组并将其传递给函数时会发生什么？
- en: Listing 4.14\. Passing a large array by value between functions
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 在函数间通过值传递大数组
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Every time the function `foo` is called, eight megabytes of memory has to be
    allocated on the stack. Then the value of the array, all eight megabytes of memory,
    has to be copied into that allocation. Go can handle this copy operation, but
    there’s a better and more efficient way of doing this. You can pass a pointer
    to the array and only copy eight bytes, instead of eight megabytes of memory on
    the stack.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数 `foo` 时，必须在栈上分配八兆字节的内存。然后必须将数组的值，即所有八兆字节的内存，复制到这个分配中。Go 可以处理这种复制操作，但还有更好的、更有效的方法来做这件事。你可以传递数组的指针，只需复制八字节，而不是在栈上复制八兆字节的内存。
- en: Listing 4.15\. Passing a large array by pointer between functions
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15\. 在函数间通过指针传递大数组
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time the function `foo` takes a pointer to an array of one million elements
    of type integer. The function call now passes the address of the array, which
    only requires eight bytes of memory to be allocated on the stack for the pointer
    variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次函数 `foo` 接收一个指向一百万个整数元素的数组的指针。函数调用现在传递数组的地址，这只需要在栈上为指针变量分配八字节内存。
- en: This operation is much more efficient with memory and could yield better performance.
    You just need to be aware that because you’re now using a pointer, changing the
    value that the pointer points to will change the memory being shared. What is
    really awesome is that slices inherently take care of dealing with these types
    of issues, as you’ll see.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作在内存方面更有效率，并且可能带来更好的性能。你只需要意识到，因为你现在使用的是指针，改变指针指向的值将改变共享的内存。真正令人兴奋的是，切片天生就处理了这些类型的问题，正如你将看到的。
- en: 4.2\. Slice internals and fundamentals
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 切片内部和基础
- en: A *slice* is a data structure that provides a way for you to work with and manage
    collections of data. Slices are built around the concept of dynamic arrays that
    can grow and shrink as you see fit. They’re flexible in terms of growth because
    they have their own built-in function called `append`, which can grow a slice
    quickly with efficiency. You can also reduce the size of a slice by slicing out
    a part of the underlying memory. Slices give you all the benefits of indexing,
    iteration, and garbage collection optimizations because the underlying memory
    is allocated in contiguous blocks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片*是一种数据结构，它提供了一种方式，让您可以处理和管理数据集合。切片围绕动态数组的概念构建，可以根据您的需要增长和缩小。在增长方面，它们非常灵活，因为它们有自己的内置函数`append`，可以高效地快速增长切片。您还可以通过从底层内存中切出部分来减小切片的大小。切片为您提供了索引、迭代和垃圾回收优化的所有好处，因为底层内存是在连续块中分配的。'
- en: 4.2.1\. Internals
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 内部结构
- en: Slices are tiny objects that abstract and manipulate an underlying array. They’re
    three-field data structures that contain the metadata Go needs to manipulate the
    underlying arrays (see [figure 4.9](#ch04fig09)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是小型对象，它们抽象并操作底层数组。它们是包含 Go 需要操作底层数组的元数据的三个字段的数据结构（参见[图 4.9](#ch04fig09)）。
- en: Figure 4.9\. Slice internals with underlying array
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. 带底层数组的切片内部结构
- en: '![](04fig09_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig09_alt.jpg)'
- en: The three fields are a pointer to the underlying array, the length or the number
    of elements the slice has access to, and the capacity or the number of elements
    the slice has available for growth. The difference between length and capacity
    will make more sense in a bit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个字段是底层数组的指针、切片的长度或切片可以访问的元素数量，以及切片的容量或切片可以用于增长的元素数量。长度和容量之间的差异将在稍后变得更有意义。
- en: 4.2.2\. Creating and initializing
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 创建和初始化
- en: There are several ways to create and initialize slices in Go. Knowing the capacity
    you need ahead of time will usually determine how you go about creating your slice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中有几种创建和初始化切片的方法。提前知道您需要的容量通常将决定您如何创建您的切片。
- en: Make and slice literals
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: make 和切片字面量
- en: One way to create a slice is to use the built-in function `make`. When you use
    `make`, one option you have is to specify the length of the slice.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建切片的一种方法是通过内置函数`make`。当您使用`make`时，您可以选择指定切片的长度。
- en: Listing 4.16\. Declaring a slice of strings by length
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16\. 通过长度声明字符串切片
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you just specify the length, the capacity of the slice is the same. You
    can also specify the length and capacity separately.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只指定长度时，切片的容量相同。您也可以分别指定长度和容量。
- en: Listing 4.17\. Declaring a slice of integers by length and capacity
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17\. 通过长度和容量声明整数切片
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you specify the length and capacity separately, you can create a slice
    with available capacity in the underlying array that you don’t have access to
    initially. [Figure 4.9](#ch04fig09) depicts what the slice of integers declared
    in [listing 4.17](#ch04ex17) could look like after it’s initialized with some
    values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当您分别指定长度和容量时，您可以在底层数组中创建具有可用容量的切片，而您最初无法访问这些容量。[图 4.9](#ch04fig09) 描述了在[列表 4.17](#ch04ex17)中声明的整数切片在用一些值初始化后的可能样子。
- en: The slice in [listing 4.17](#ch04ex17) has access to three elements, but the
    underlying array has five elements. The two elements not associated with the length
    of the slice can be incorporated so the slice can use those elements as well.
    New slices can also be created to share this same underlying array and use any
    existing capacity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.17](#ch04ex17) 中的切片可以访问三个元素，但底层数组有五个元素。与切片长度不相关的两个元素可以合并，以便切片也可以使用这些元素。还可以创建新的切片来共享相同的底层数组并使用任何现有容量。'
- en: Trying to create a slice with a capacity that’s smaller than the length is not
    allowed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许创建容量小于长度的切片。
- en: Listing 4.18\. Compiler error setting capacity less than length
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18\. 设置容量小于长度的编译器错误
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An idiomatic way of creating a slice is to use a slice literal. It’s similar
    to creating an array, except you don’t specify a value inside of the `[ ]` operator.
    The initial length and capacity will be based on the number of elements you initialize.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建切片的一种惯用方法是使用切片字面量。它与创建数组类似，只是您不需要在`[ ]`操作符内指定值。初始长度和容量将基于您初始化的元素数量。
- en: Listing 4.19\. Declaring a slice with a slice literal
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19\. 使用切片字面量声明切片
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When using a slice literal, you can set the initial length and capacity. All
    you need to do is initialize the index that represents the length and capacity
    you need. The following syntax will create a slice with a length and capacity
    of 100 elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用切片字面量时，你可以设置初始长度和容量。你需要做的就是初始化代表所需长度和容量的索引。以下语法将创建一个长度和容量为 100 个元素的切片。
- en: Listing 4.20\. Declaring a slice with index positions
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.20\. 使用索引位置声明切片
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember, if you specify a value inside the `[ ]` operator, you’re creating
    an array. If you don’t specify a value, you’re creating a slice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在 `[ ]` 操作符内指定了一个值，你正在创建一个数组。如果你没有指定值，你正在创建一个切片。
- en: Listing 4.21\. Declaration differences between arrays and slices
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.21\. 数组和切片的声明差异
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: nil and empty slices
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`nil` 切片和空切片'
- en: Sometimes in your programs you may need to declare a `nil` slice. A `nil` slice
    is created by declaring a slice without any initialization.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在你的程序中你可能需要声明一个 `nil` 切片。一个 `nil` 切片是通过声明一个没有初始化的切片来创建的。
- en: Listing 4.22\. Declaring a `nil` slice
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.22\. 声明一个 `nil` 切片
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A `nil` slice is the most common way you create slices in Go. They can be used
    with many of the standard library and built-in functions that work with slices.
    They’re useful when you want to represent a slice that doesn’t exist, such as
    when an exception occurs in a function that returns a slice (see [figure 4.10](#ch04fig10)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `nil` 切片是你在 Go 中创建切片最常见的方式。它们可以与许多标准库和内置函数一起使用，这些函数与切片一起工作。当你想表示一个不存在的切片时，它们很有用，例如当函数返回一个切片时发生异常（参见
    [图 4.10](#ch04fig10)）。
- en: Figure 4.10\. The representation of a `nil` slice
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10\. `nil` 切片的表示
- en: '![](04fig10_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.10](04fig10_alt.jpg)'
- en: You can also create an empty slice by declaring a slice with initialization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过声明一个带有初始化的切片来创建一个空切片。
- en: Listing 4.23\. Declaring an empty slice
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.23\. 声明一个空切片
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An empty slice contains a zero-element underlying array that allocates no storage.
    Empty slices are useful when you want to represent an empty collection, such as
    when a database query returns zero results (see [figure 4.11](#ch04fig11)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空切片包含一个零元素底层数组，它不分配任何存储空间。空切片在你想要表示一个空集合时很有用，例如当数据库查询返回零结果时（参见 [图 4.11](#ch04fig11)）。
- en: Figure 4.11\. The representation of an empty slice
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.11\. 空切片的表示
- en: '![](04fig11_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.11](04fig11_alt.jpg)'
- en: Regardless of whether you’re using a `nil` slice or an empty slice, the built-in
    functions `append`, `len`, and `cap` work the same.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是使用 `nil` 切片还是空切片，内置函数 `append`、`len` 和 `cap` 的工作方式都是相同的。
- en: 4.2.3\. Working with slices
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 使用切片
- en: Now that you know what a slice is and how to create them, you can learn how
    to use them in your programs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了切片是什么以及如何创建它们，你可以学习如何在程序中使用它们。
- en: Assigning and slicing
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 赋值和切片
- en: Assigning a value to any specific index within a slice is identical to how you
    do this with arrays. To change the value of an individual element, use the `[
    ]` operator.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给切片中的任何特定索引与数组中的操作方式相同。要更改单个元素的值，请使用 `[ ]` 操作符。
- en: Listing 4.24\. Declaring an array using an array literal
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.24\. 使用数组字面量声明数组
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Slices are called such because you can slice a portion of the underlying array
    to create a new slice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 切片被称为切片，因为你可以从底层数组中切取一部分来创建一个新的切片。
- en: Listing 4.25\. Taking the slice of a slice
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.25\. 从切片中取切片
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the slicing operation performed in [listing 4.25](#ch04ex25), we have
    two slices that are sharing the same underlying array. However, each slice views
    the underlying array in a different way (see [figure 4.12](#ch04fig12)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.25](#ch04ex25) 中执行切片操作后，我们有两个共享相同底层数组的切片。然而，每个切片以不同的方式查看底层数组（参见 [图 4.12](#ch04fig12)）。
- en: Figure 4.12\. Two slices sharing the same underlying array
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.12\. 两个共享相同底层数组的切片
- en: '![](04fig12_alt.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.12](04fig12_alt.jpg)'
- en: The original `slice` views the underlying array as having a capacity of five
    elements, but the view of `newSlice` is different. For `newSlice`, the underlying
    array has a capacity of four elements. `newSlice` can’t access the elements of
    the underlying array that are prior to its pointer. As far as `newSlice` is concerned,
    those elements don’t even exist.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 `slice` 将底层数组视为具有五个元素的容量，但 `newSlice` 的视图不同。对于 `newSlice`，底层数组具有四个元素的容量。`newSlice`
    无法访问其指针之前的底层数组的元素。对 `newSlice` 来说，那些元素甚至不存在。
- en: Calculating the length and capacity for any new slice is performed using the
    following formula.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 计算任何新切片的长度和容量是通过以下公式完成的。
- en: Listing 4.26\. How length and capacity are calculated
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.26\. 长度和容量的计算方法
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you apply this formula to `newSlice` you get the following.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此公式应用于 `newSlice`，你将得到以下结果。
- en: Listing 4.27\. Calculating the new length and capacity
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.27\. 计算新的长度和容量
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another way to look at this is that the first value represents the starting
    index position of the element the new slice will start with—in this case, 1\.
    The second value represents the starting index position (1) plus the number of
    elements you want to include (2); 1 plus 2 is 3, so the second value is 3\. Capacity
    will be the total number of elements associated with the slice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，第一个值代表新切片将开始的元素起始索引位置——在这种情况下，是 1。第二个值代表起始索引位置（1）加上你想要包含的元素数量（2）；1
    加 2 等于 3，所以第二个值是 3。容量将是与切片相关的元素总数。
- en: You need to remember that you now have two slices sharing the same underlying
    array. Changes made to the shared section of the underlying array by one slice
    can be seen by the other slice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住，你现在有两个切片共享同一个底层数组。一个切片对底层数组共享部分的修改，另一个切片是可以看到的。
- en: Listing 4.28\. Potential consequence of making changes to a slice
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.28\. 修改切片的潜在后果
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After the number 35 is assigned to the second element of `newSlice`, that change
    can also be seen by the original `slice` in element 3 (see [figure 4.13](#ch04fig13)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数字 35 分配给 `newSlice` 的第二个元素后，这种变化也可以在原始 `slice` 的元素 3 中看到（参见 [图 4.13](#ch04fig13)）。
- en: Figure 4.13\. The underlying array after the assignment operation
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.13\. 分配操作后的底层数组
- en: '![](04fig13_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig13_alt.jpg)'
- en: A slice can only access indexes up to its length. Trying to access an element
    outside of its length will cause a runtime exception. The elements associated
    with a slice’s capacity are only available for growth. They must be incorporated
    into the slice’s length before they can be used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 切片只能访问其长度范围内的索引。尝试访问长度之外的元素将导致运行时异常。与切片容量相关的元素仅可用于增长。它们必须被纳入切片的长度中，才能被使用。
- en: Listing 4.29\. Runtime error showing index out of range
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.29\. 索引越界时的运行时错误
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Having capacity is great, but useless if you can’t incorporate it into your
    slice’s length. Luckily, Go makes this easy when you use the built-in function
    `append`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有容量是很好的，但如果不能将其融入切片的长度中，那就毫无用处。幸运的是，当你使用内置函数 `append` 时，Go 语言使这个过程变得简单。
- en: Growing slices
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切片增长
- en: One of the advantages of using a slice over using an array is that you can grow
    the capacity of your slice as needed. Go takes care of all the operational details
    when you use the built-in function `append`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片而不是数组的一个优点是，你可以根据需要增长切片的容量。当你使用内置函数 `append` 时，Go 语言会处理所有操作细节。
- en: To use `append`, you need a source slice and a value that is to be appended.
    When your `append` call returns, it provides you a new slice with the changes.
    The `append` function will always increase the length of the new slice. The capacity,
    on the other hand, may or may not be affected, depending on the available capacity
    of the source slice.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `append`，你需要一个源切片和一个要附加的值。当你的 `append` 调用返回时，它为你提供一个带有更改的新切片。`append` 函数总是会增加新切片的长度。另一方面，容量可能会受到影响，也可能不会受到影响，这取决于源切片的可用容量。
- en: Listing 4.30\. Using `append` to add an element to a slice
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.30\. 使用 `append` 向切片添加元素
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the `append` operation in [listing 4.30](#ch04ex30), the slices and the
    underlying array will look like [figure 4.14](#ch04fig14).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.30](#ch04ex30) 中的 `append` 操作之后，切片和底层数组将看起来像 [图 4.14](#ch04fig14)。
- en: Figure 4.14\. The underlying array after the append operation
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.14\. 附加操作后的底层数组
- en: '![](04fig14_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig14_alt.jpg)'
- en: Because there was available capacity in the underlying array for `newSlice`,
    the `append` operation incorporated the available element into the slice’s length
    and assigned the value. Since the original `slice` is sharing the underlying array,
    `slice` also sees the changes in index 3.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在底层数组中为 `newSlice` 有可用容量，所以 `append` 操作将可用元素纳入切片长度，并分配了值。由于原始 `slice` 是共享底层数组，所以
    `slice` 也会看到索引 3 的变化。
- en: When there’s no available capacity in the underlying array for a slice, the
    `append` function will create a new underlying array, copy the existing values
    that are being referenced, and assign the new value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当切片在底层数组中没有可用容量时，`append` 函数将创建一个新的底层数组，复制现有引用的值，并分配新值。
- en: Listing 4.31\. Using `append` to increase the length and capacity of a slice
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.31\. 使用 `append` 增加切片的长度和容量
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After this `append` operation, `newSlice` is given its own underlying array,
    and the capacity of the array is doubled from its original size (see [figure 4.15](#ch04fig15)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `append` 操作之后，`newSlice` 被赋予了它自己的底层数组，并且数组的容量从原始大小加倍（参见 [图 4.15](#ch04fig15)）。
- en: Figure 4.15\. The new underlying array after the append operation
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15\. `append` 操作后的新底层数组
- en: '![](04fig15.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.15](04fig15.jpg)'
- en: The `append` operation is clever when growing the capacity of the underlying
    array. Capacity is always doubled when the existing capacity of the slice is under
    1,000 elements. Once the number of elements goes over 1,000, the capacity is grown
    by a factor of 1.25, or 25%. This growth algorithm may change in the language
    over time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当切片的现有容量小于 1,000 个元素时，`append` 操作在增长底层数组的容量时非常巧妙。容量总是加倍。一旦元素数量超过 1,000，容量就增加
    1.25 倍，即 25%。这种增长算法可能会随着时间的推移而改变。
- en: Three index slices
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 三个索引切片
- en: There’s a third index option we haven’t mentioned yet that you can use when
    you’re slicing. This third index gives you control over the capacity of the new
    slice. The purpose is not to increase capacity, but to restrict the capacity.
    As you’ll see, being able to restrict the capacity of a new slice provides a level
    of protection to the underlying array and gives you more control over append operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片时，我们还没有提到的一个第三个索引选项，你可以使用。这个第三个索引让你可以控制新切片的容量。目的不是增加容量，而是限制容量。正如你将看到的，能够限制新切片的容量为底层数组提供了一定程度的保护，并让你对
    `append` 操作有更多的控制。
- en: Let’s start with a slice of five strings that contain fruit you can find in
    your local supermarket.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从包含你可以在当地超市找到的水果的五个字符串切片开始。
- en: Listing 4.32\. Declaring a slice of string using a slice literal
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.32\. 使用切片字面量声明字符串切片
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you inspect the values for this slice of fruit, it will look something like
    [figure 4.16](#ch04fig16).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查这个水果切片的值，它看起来可能像 [图 4.16](#ch04fig16)。
- en: Figure 4.16\. A representation of the slice of strings
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.16\. 字符串切片的表示
- en: '![](04fig16_alt.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.16 替代](04fig16_alt.jpg)'
- en: Now let’s use the third index option to perform a slicing operation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用第三个索引选项来执行一个切片操作。
- en: Listing 4.33\. Performing a three-index slice
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.33\. 执行三个索引切片
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After this slicing operation, we have a new slice that references one element
    from the underlying array and has a capacity of two elements. Specifically, the
    new slice references the `Plum` element and has capacity up to the `Banana` element,
    as shown in [figure 4.17](#ch04fig17).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个切片操作之后，我们有一个新的切片，它引用了底层数组中的一个元素，并且容量为两个元素。具体来说，新的切片引用了 `Plum` 元素，并且容量扩展到
    `Banana` 元素，如 [图 4.17](#ch04fig17) 所示。
- en: Figure 4.17\. A representation of the new slice after the operation
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.17\. 操作后的新切片表示
- en: '![](04fig17_alt.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.17 替代](04fig17_alt.jpg)'
- en: We can apply the same formula that we defined before to calculate the new slice’s
    length and capacity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用之前定义的相同公式来计算新切片的长度和容量。
- en: Listing 4.34\. How length and capacity are calculated
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.34\. 长度和容量是如何计算的
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, the first value represents the starting index position of the element
    the new slice will start with—in this case, 2. The second value represents the
    starting index position (2) plus the number of elements you want to include (1);
    2 plus 1 is 3, so the second value is 3\. For setting capacity, you take the starting
    index position of 2, plus the number of elements you want to include in the capacity
    (2), and you get the value of 4.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，第一个值代表新切片将开始的元素起始索引位置——在这种情况下，2。第二个值代表起始索引位置（2）加上你想要包含的元素数量（1）；2 加 1 等于 3，所以第二个值是
    3。对于设置容量，你取起始索引位置 2，加上你想要包含在容量中的元素数量（2），得到值为 4。
- en: If you attempt to set a capacity that’s larger than the available capacity,
    you’ll get a runtime error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试设置一个比可用容量更大的容量，你将得到一个运行时错误。
- en: Listing 4.35\. Runtime error setting capacity larger than existing capacity
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.35\. 设置大于现有容量的容量时的运行时错误
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we’ve discussed, the built-in function append will use any available capacity
    first. Once that capacity is reached, it will allocate a new underlying array.
    It’s easy to forget which slices are sharing the same underlying array. When this
    happens, making changes to a slice can result in random and odd-looking bugs.
    Suddenly changes appear on multiple slices out of nowhere.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，内置函数`append`会首先使用任何可用的容量。一旦达到这个容量，它将分配一个新的底层数组。很容易忘记哪些切片共享相同的底层数组。当这种情况发生时，对切片的更改可能会导致随机和奇怪的错误。突然之间，多个切片中出现了变化。
- en: By having the option to set the capacity of a new slice to be the same as the
    length, you can force the first append operation to detach the new slice from
    the underlying array. Detaching the new slice from its original source array makes
    it safe to change.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有选择地设置新切片的容量与长度相同，你可以强制第一次`append`操作将新切片从底层数组中分离出来。将新切片从其原始源数组中分离出来使其更改变得安全。
- en: Listing 4.36\. Benefits of setting length and capacity to be the same
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.36\. 设置长度和容量相同的优点
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Without this third index, appending `Kiwi` to our slice would’ve changed the
    value of `Banana` in index 3 of the underlying array, because all of the remaining
    capacity would still belong to the slice. But in [listing 4.36](#ch04ex36), we
    restricted the capacity of the slice to 1\. When we call `append` for the first
    time on the slice, it will create a new underlying array of two elements, copy
    the fruit `Plum`, add the new fruit `Kiwi`, and return a new slice that references
    this underlying array, as in [figure 4.18](#ch04fig18).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个第三个索引，将`Kiwi`添加到我们的切片中将会改变底层数组索引3处的`Banana`的值，因为所有剩余的容量仍然属于切片。但在[列表4.36](#ch04ex36)中，我们限制了切片的容量为1。当我们第一次在切片上调用`append`时，它将创建一个新的包含两个元素的底层数组，复制水果`Plum`，添加新的水果`Kiwi`，并返回一个新的切片，该切片引用这个底层数组，如[图4.18](#ch04fig18)所示。
- en: Figure 4.18\. A representation of the new slice after the append operation
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.18\. 在`append`操作之后的新切片的表示
- en: '![](04fig18_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig18_alt.jpg)'
- en: With the new slice now having its own underlying array, we’ve avoided potential
    problems. We can now continue to append fruit to our new slice without worrying
    if we’re changing fruit to other slices inappropriately. Also, allocating the
    new underlying array for the slice was easy and clean.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新切片现在有自己的底层数组，我们避免了潜在的问题。我们现在可以继续向我们的新切片添加水果，而不用担心是否不恰当地更改了其他切片中的水果。此外，为切片分配新的底层数组既简单又干净。
- en: The built-in function `append` is also a variadic function. This means you can
    pass multiple values to be appended in a single slice call. If you use the `...`
    operator, you can append all the elements of one slice into another.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`append`也是一个可变参数函数。这意味着你可以在单个切片调用中传递多个要添加的值。如果你使用`...`运算符，你可以将一个切片的所有元素添加到另一个切片中。
- en: Listing 4.37\. Appending to a slice from another slice
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.37\. 从另一个切片向切片中添加元素
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see by the output, all the values of slice `s2` have been appended
    to slice `s1`. The value of the new slice returned by the `append` function is
    then displayed by the call to `Printf`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，切片`s2`的所有值都已添加到切片`s1`中。然后通过`Printf`调用显示`append`函数返回的新切片的值。
- en: Iterating over slices
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 遍历切片
- en: Since a slice is a collection, you can iterate over the elements. Go has a special
    keyword called `range` that you use in conjunction with the keyword `for` to iterate
    over slices.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片是一个集合，你可以遍历其元素。Go有一个特殊的关键字`range`，你可以与`for`关键字一起使用来遍历切片。
- en: Listing 4.38\. Iterating over a slice using `for range`
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.38\. 使用`for range`遍历切片
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The keyword `range`, when iterating over a slice, will return two values. The
    first value is the index position and the second value is a copy of the value
    in that index position (see [figure 4.19](#ch04fig19)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历切片时，关键字`range`将返回两个值。第一个值是索引位置，第二个值是该索引位置值的副本（参见[图4.19](#ch04fig19)）。
- en: Figure 4.19\. Using `range` to iterate over a slice creates a copy of each element.
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.19\. 使用`range`遍历切片会复制每个元素。
- en: '![](04fig19.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig19.jpg)'
- en: It’s important to know that `range` is making a copy of the value, not returning
    a reference. If you use the address of the value variable as a pointer to each
    element, you’ll be making a mistake. Let’s see why.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道`range`正在复制值，而不是返回一个引用。如果你使用值变量的地址作为每个元素的指针，你将会犯一个错误。让我们看看为什么。
- en: Listing 4.39\. `range` provides a copy of each element
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.39\. `range`提供了每个元素的副本
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The address for the `value` variable is always the same because it’s a variable
    that contains a copy. The address of each individual element can be captured using
    the slice variable and the index value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 变量的地址始终相同，因为它是一个包含副本的变量。可以使用切片变量和索引值捕获每个单独元素的地址。'
- en: If you don’t need the index value, you can use the underscore character to discard
    the value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要索引值，你可以使用下划线字符来丢弃该值。
- en: Listing 4.40\. Using the blank identifier to ignore the index value
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.40\. 使用空白标识符忽略索引值
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The keyword `range` will always start iterating over a slice from the beginning.
    If you need more control iterating over a slice, you can always use a traditional
    `for` loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `range` 总是从切片的开始迭代。如果你需要更多控制地迭代切片，你总是可以使用传统的 `for` 循环。
- en: Listing 4.41\. Iterating over a slice using a traditional `for` loop
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.41\. 使用传统的 `for` 循环迭代切片
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are two special built-in functions called `len` and `cap` that work with
    arrays, slices, and channels. For slices, the `len` function returns the length
    of the slice, and the `cap` function returns the capacity. In [listing 4.41](#ch04ex41),
    we used the `len` function to determine when to stop iterating over the slice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的内置函数 `len` 和 `cap` 与数组、切片和通道一起工作。对于切片，`len` 函数返回切片的长度，而 `cap` 函数返回容量。在[列表
    4.41](#ch04ex41)中，我们使用了 `len` 函数来确定何时停止迭代切片。
- en: Now that you know how to create and work with slices, you can use them to compose
    and iterate over multidimensional slices.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建和使用切片，你可以使用它们来组合和迭代多维切片。
- en: 4.2.4\. Multidimensional slices
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 多维切片
- en: Like arrays, slices are one-dimensional, but they can be composed to create
    multidimensional slices for the same reasons we discussed earlier.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，切片是一维的，但它们可以组合起来创建多维切片，原因与之前讨论的相同。
- en: Listing 4.42\. Declaring a multidimensional slice
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.42\. 声明一个多维切片
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We now have an outer slice of two elements that contain an inner slice of integers.
    The values for our slice of a slice of integers will look like [figure 4.20](#ch04fig20).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含整数内部切片的外部切片，其切片的切片整数值看起来像[图 4.20](#ch04fig20)。
- en: Figure 4.20\. Values for our slice of a slice of integers
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.20\. 我们切片的切片整数的值
- en: '![](04fig20_alt.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig20_alt.jpg)'
- en: In [figure 4.20](#ch04fig20) you can see how composition is working to embed
    slices into slices. The outer slice contains two elements, each of which are slices.
    The slice in the first element is initialized with the single integer 10 and the
    slice in the second element contains two integers, 100 and 200.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4.20](#ch04fig20)中，你可以看到如何通过组合将切片嵌入到切片中。外部切片包含两个元素，每个元素都是切片。第一个元素中的切片初始化为单个整数
    10，第二个元素中的切片包含两个整数，100 和 200。
- en: Composition allows you to create very complex and powerful data structures.
    All of the rules you learned about the built-in function `append` still apply.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 组合允许你创建非常复杂和强大的数据结构。你学到的关于内置函数 `append` 的所有规则仍然适用。
- en: Listing 4.43\. Composing slices of slices
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.43\. 组合切片的切片
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `append` function and Go are elegant in how they handle growing and assigning
    the new slice of integers back into the first element of the outer slice. When
    the operation in [listing 4.43](#ch04ex43) is complete, an entire new slice of
    integers and a new underlying array is allocated and then copied back into index
    0 of the outer slice, as shown in [figure 4.21](#ch04fig21).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 函数和 Go 在处理增长并将新的整数切片分配回外部切片的第一个元素方面非常优雅。当[列表 4.43](#ch04ex43)中的操作完成时，将分配一个新的整数切片和一个新的底层数组，然后将其复制回外部切片的索引
    0，如图 4.21 所示。'
- en: Figure 4.21\. What index 0 of the outer slice looks like after the `append`
    operation
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.21\. 外部切片索引 0 在 `append` 操作后的样子
- en: '![](04fig21_alt.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig21_alt.jpg)'
- en: Even with this simple multidimensional slice, there are a lot of layers and
    values involved. Passing a data structure like this between functions could seem
    complicated. But slices are cheap and passing them between functions is trivial.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的多维切片中，也涉及许多层和值。在函数之间传递这样的数据结构可能会显得复杂。但切片成本低廉，在函数之间传递它们是微不足道的。
- en: 4.2.5\. Passing slices between functions
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.5\. 在函数之间传递切片
- en: Passing a slice between two functions requires nothing more than passing the
    slice by value. Since the size of a slice is small, it’s cheap to copy and pass
    between functions. Let’s create a large slice and pass that slice by value to
    our function called `foo`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个函数之间传递切片只需通过值传递切片。由于切片的大小很小，复制和传递到函数之间很便宜。让我们创建一个大的切片，并通过值将这个切片传递给我们的`foo`函数。
- en: Listing 4.44\. Passing slices between functions
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.44。在函数之间传递切片
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: On a 64-bit architecture, a slice requires 24 bytes of memory. The pointer field
    requires 8 bytes, and the length and capacity fields require 8 bytes respectively.
    Since the data associated with a slice is contained in the underlying array, there
    are no problems passing a copy of a slice to any function. Only the slice is being
    copied, not the underlying array (see [figure 4.22](#ch04fig22)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位架构上，切片需要24字节的内存。指针字段需要8字节，长度和容量字段分别需要8字节。由于与切片关联的数据包含在底层数组中，因此将切片的副本传递给任何函数时没有问题。只有切片被复制，而不是底层数组（见图4.22）。
- en: Figure 4.22\. Both slices pointing to the underlying array after the function
    call
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.22。函数调用后两个切片都指向底层数组
- en: '![](04fig22_alt.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig22_alt.jpg)'
- en: Passing the 24 bytes between functions is fast and easy. This is the beauty
    of slices. You don’t need to pass pointers around and deal with complicated syntax.
    You just create copies of your slices, make the changes you need, and then pass
    a new copy back.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数之间传递24字节是快速且简单的。这就是切片的美丽之处。您不需要传递指针并处理复杂的语法。您只需创建切片的副本，进行所需的更改，然后传递一个新的副本。
- en: 4.3\. Map internals and fundamentals
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3。映射的内部结构和基本原理
- en: A map is a data structure that provides you with an unordered collection of
    key/value pairs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种数据结构，它为您提供无序的键/值对集合。
- en: You store values into the map based on a key. [Figure 4.23](#ch04fig23) shows
    an example of a key/value pair you may store in your maps. The strength of a map
    is its ability to retrieve data quickly based on the key. A key works like an
    index, pointing to the value you associate with that key.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据键将值存储到映射中。[图4.23](#ch04fig23) 展示了您可能存储在映射中的键/值对示例。映射的强大之处在于它能够根据键快速检索数据。键就像一个索引，指向与该键关联的值。
- en: Figure 4.23\. Relationship of key/value pairs
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.23。键/值对的关系
- en: '![](04fig23_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig23_alt.jpg)'
- en: 4.3.1\. Internals
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1。内部结构
- en: Maps are collections, and you can iterate over them just like you do with arrays
    and slices. But maps are *unordered* collections, and there’s no way to predict
    the order in which the key/value pairs will be returned. Even if you store your
    key/value pairs in the same order, every iteration over a map could return a different
    order. This is because a map is implemented using a hash table, as shown in [figure
    4.24](#ch04fig24).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是集合，您可以像处理数组和切片一样遍历它们。但映射是无序集合，无法预测键/值对返回的顺序。即使您以相同的顺序存储键/值对，每次遍历映射都可能返回不同的顺序。这是因为映射是使用哈希表实现的，如图4.24所示。
- en: Figure 4.24\. Simple representation of the internal structure of a map
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.24。映射内部结构的简单表示
- en: '![](04fig24_alt.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig24_alt.jpg)'
- en: The map’s hash table contains a collection of buckets. When you’re storing,
    removing, or looking up a key/value pair, everything starts with selecting a bucket.
    This is performed by passing the key—specified in your map operation—to the map’s
    hash function. The purpose of the hash function is to generate an index that evenly
    distributes key/value pairs across all available buckets.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的哈希表包含一系列桶。当您存储、删除或查找键/值对时，一切从选择一个桶开始。这是通过将指定在映射操作中的键传递给映射的哈希函数来完成的。哈希函数的目的是生成一个索引，该索引将键/值对均匀分布在所有可用的桶中。
- en: The better the distribution, the quicker you can find your key/value pairs as
    the map grows. If you store 10,000 items in your map, you don’t want to ever look
    at 10,000 key/value pairs to find the one you want. You want to look at the least
    number of key/value pairs possible. Looking at only 8 key/value pairs in a map
    of 10,000 items is a good and balanced map. A balanced list of key/value pairs
    across the right number of buckets makes this possible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 分布越好，随着映射的增长，您查找键/值对的速度就越快。如果您在映射中存储了10,000个项，您不想查看10,000个键/值对来找到您想要的那个。您希望查看尽可能少的键/值对。在10,000个项的映射中只查看8个键/值对是一个良好且平衡的映射。在正确数量的桶中跨键/值对平衡的列表使这成为可能。
- en: The hash key that’s generated for a Go map is a bit longer than what you see
    in [figure 4.25](#ch04fig25), but it works the same way. In our example, the keys
    are strings that represents a color. Those strings are converted into a numeric
    value within the scope of the number of buckets we have available for storage.
    The numeric value is then used to select a bucket for storing or finding the specific
    key/value pair. In the case of a Go map, a portion of the generated hash key,
    specifically the *low order bits* (LOB), is used to select the bucket.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Go 映射生成的哈希键比你在[图 4.25](#ch04fig25)中看到的要长一些，但它的工作方式相同。在我们的例子中，键是表示颜色的字符串。这些字符串被转换成在可用存储桶数量范围内的数值。然后使用这个数值来选择一个桶以存储或查找特定的键/值对。在
    Go 映射的情况下，生成的哈希键的一部分，即 *低位位* (LOB)，用于选择桶。
- en: Figure 4.25\. Simple view of how hash functions work
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.25\. 哈希函数工作原理的简单视图
- en: '![](04fig25_alt.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.25 替代](04fig25_alt.jpg)'
- en: If you look at [figure 4.24](#ch04fig24) again, you can see what the internals
    of a bucket look like. There are two data structures that contain the data for
    the map. First, there’s an array with the top eight *high order bits* (HOB) from
    the same hash key that was used to select the bucket. This array distinguishes
    each individual key/value pair stored in the respective bucket. Second, there’s
    an array of bytes that stores the key/value pairs. The byte array packs all the
    keys and then all the values together for the respective bucket. The packing of
    the key/value pairs is implemented to minimize the memory required for each bucket.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看[图 4.24](#ch04fig24)，你可以看到桶的内部结构。有两个数据结构包含映射的数据。首先，有一个数组，包含用于选择桶的相同哈希键的前八个
    *高位位* (HOB)。这个数组区分了存储在相应桶中的每个单独的键/值对。其次，有一个字节数组，用于存储键/值对。字节数组将所有键打包在一起，然后为相应桶打包所有值。键/值对的打包是为了最小化每个桶所需的内存。
- en: 'There are a lot of other low-level implementation details about maps that are
    outside the scope of this chapter. You don’t need to understand all the internals
    to learn how to create and use maps. Just remember one thing: a map is an unordered
    collection of key/value pairs.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关于映射的许多其他低级实现细节超出了本章的范围。你不需要理解所有内部结构来学习如何创建和使用映射。只需记住一件事：映射是无序键/值对的集合。
- en: 4.3.2\. Creating and initializing
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 创建和初始化
- en: There are several ways you can create and initialize maps in Go. You can use
    the built-in function `make`, or you can use a map literal.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建和初始化映射有几种方法。你可以使用内置函数 `make`，或者你可以使用映射字面量。
- en: Listing 4.45\. Declaring a map using `make`
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.45\. 使用 `make` 声明映射
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using a map literal is the idiomatic way of creating a map. The initial length
    will be based on the number of key/value pairs you specify during initialization.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射字面量是创建映射的惯用方式。初始长度将基于初始化期间指定的键/值对数量。
- en: The map key can be a value from any built-in or struct type as long as the value
    can be used in an expression with the `==` operator. Slices, functions, and struct
    types that contain slices can’t be used as map keys. This will produce a compiler
    error.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 映射键可以是任何内置或结构体类型的值，只要该值可以用 `==` 操作符在表达式中使用。切片、函数以及包含切片的结构体类型不能用作映射键。这将产生编译器错误。
- en: Listing 4.46\. Declaring an empty map using a map literal
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.46\. 使用映射字面量声明一个空映射
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There’s nothing stopping you from using a slice as a map value. This can come
    in handy when you need a single map key to be associated with a collection of
    data.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么阻止你使用切片作为映射值。当你需要将单个映射键与一组数据相关联时，这可能会很有用。
- en: Listing 4.47\. Declaring a map that stores slices of strings
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.47\. 声明存储字符串切片的映射
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 4.3.3\. Working with maps
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. 与映射一起工作
- en: Assigning a key/value pair to a map is performed by specifying a key of the
    proper type and assigning a value to that key.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 向映射赋值是通过指定正确的键类型并将值分配给该键来执行的。
- en: Listing 4.48\. Assigning values to a map
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.48\. 向映射赋值
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can create a `nil` map by declaring a map without any initialization. A
    `nil` map can’t be used to store key/value pairs. Trying will produce a runtime
    error.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过声明一个没有初始化的映射来创建一个 `nil` 映射。`nil` 映射不能用于存储键/值对。尝试这样做将产生运行时错误。
- en: Listing 4.49\. Runtime error assigned to a `nil` map
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.49\. 将运行时错误分配给 `nil` 映射
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Testing if a map key exists is an important part of working with maps. It allows
    you to write logic that can determine if you’ve performed an operation or if you’ve
    cached some particular data in the map. It can also be used to compare two maps
    to identify what key/value pairs match or are missing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 测试映射键是否存在是处理映射的重要部分。它允许你编写逻辑，以确定你是否执行了操作或是否在映射中缓存了某些特定数据。它还可以用于比较两个映射，以确定哪些键/值对匹配或缺失。
- en: When retrieving a value from a map, you have two choices. You can retrieve the
    value and a flag that explicitly lets you know if the key exists.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当从映射中检索值时，你有两种选择。你可以检索值和一个标志，该标志明确地让你知道键是否存在。
- en: Listing 4.50\. Retrieving a value from a map and testing existence.
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.50\. 从映射中检索值并测试存在性。
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The other option is to just return the value and test for the zero value to
    determine if the key exists. This will only work if the zero value is not a valid
    value for the map.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是只返回值并测试零值以确定键是否存在。这仅当零值不是映射的有效值时才有效。
- en: Listing 4.51\. Retrieving a value from a map testing the value for existence
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.51\. 从映射中检索值并测试值的存在性
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When you index a map in Go, it will always return a value, even when the key
    doesn’t exist. In this case, the zero value for the value’s type is returned.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Go 中索引映射时，它总是会返回一个值，即使键不存在。在这种情况下，返回值类型的零值。
- en: Iterating over a map is identical to iterating over an array or slice. You use
    the keyword `range`; but when it comes to maps, you don’t get back the index/value,
    you get back the key/value pairs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历映射与遍历数组或切片相同。你使用关键字 `range`；但是当涉及到映射时，你不会得到索引/值，而是得到键/值对。
- en: Listing 4.52\. Iterating over a map using `for` range
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.52\. 使用 `for` 循环遍历映射
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you want to remove a key/value pair from the map, you use the built-in function
    `delete`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从映射中删除一个键/值对，请使用内置函数 `delete`。
- en: Listing 4.53\. Removing an item from a map
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.53\. 从映射中删除一个项
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This time when you iterate through the map, the color Coral would not be displayed
    on the screen.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当你遍历映射时，颜色珊瑚不会显示在屏幕上。
- en: 4.3.4\. Passing maps between functions
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.4\. 在函数之间传递映射
- en: Passing a map between two functions doesn’t make a copy of the map. In fact,
    you can pass a map to a function and make changes to the map, and the changes
    will be reflected by all references to the map.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个函数之间传递映射不会复制映射。实际上，你可以将映射传递给一个函数并修改映射，这些更改将通过映射的所有引用反映出来。
- en: Listing 4.54\. Passing maps between functions
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.54\. 在函数之间传递映射
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you run this program, you’ll get the following output.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会得到以下输出。
- en: Listing 4.55\. Output for [listing 4.54](#ch04ex54)
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.55\. [列表 4.54](#ch04ex54) 的输出
- en: '[PRE54]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can see that after the call to `removeColor` is complete, the color Coral
    is no longer present in the map referenced by `main`. Maps are designed to be
    cheap, similar to slices.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在调用 `removeColor` 完成后，颜色珊瑚不再出现在 `main` 引用的映射中。映射的设计与切片类似，成本低廉。
- en: 4.4\. Summary
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 摘要
- en: Arrays are the building blocks for both slices and maps.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是切片和映射的构建块。
- en: Slices are the idiomatic way in Go you work with collections of data. Maps are
    the way you work with key/value pairs of data.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中，切片是处理数据集合的惯用方式。映射是处理数据键/值对的途径。
- en: The built-in function `make` allows you to create slices and maps with initial
    length and capacity. Slice and map literals can be used as well and support setting
    initial values for use.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数 `make` 允许你创建具有初始长度和容量的切片和映射。也可以使用映射字面量，并支持为使用设置初始值。
- en: Slices have a capacity restriction, but can be extended using the built-in function
    `append`.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片有容量限制，但可以使用内置函数 `append` 来扩展。
- en: Maps don’t have a capacity or any restriction on growth.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射没有容量或对增长的任何限制。
- en: The built-in function `len` can be used to retrieve the length of a slice or
    map.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数 `len` 可以用来获取切片或映射的长度。
- en: The built-in function `cap` only works on slices.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数 `cap` 只适用于切片。
- en: Through the use of composition, you can create multidimensional arrays and slices.
    You can also create maps with values that are slices and other maps. A slice can’t
    be used as a map key.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合的使用，你可以创建多维数组切片。你还可以创建具有切片和其他映射值的映射。切片不能用作映射键。
- en: Passing a slice or map to a function is cheap and doesn’t make a copy of the
    underlying data structure.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将切片或映射传递给函数成本低廉，并且不会复制底层的数据结构。
