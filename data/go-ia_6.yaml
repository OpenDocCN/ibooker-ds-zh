- en: Chapter 7\. Concurrency patterns
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 并发模式
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中*'
- en: Control the lifetime of programs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制程序的生命周期
- en: Manage a pool of resources that can be reused
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理可重用资源池
- en: Create a pool of goroutines that can process work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以处理工作的 goroutine 池
- en: In [chapter 6](kindle_split_014.html#ch06) you learned what concurrency is and
    how channels behave, and reviewed code that showed concurrency in action. In this
    chapter you’ll extend that knowledge by reviewing more code. We’ll review three
    packages that implement different concurrency patterns that you can use in your
    own projects. Each package provides a practical perspective on the use of concurrency
    and channels and how they can make concurrent programs easier to write and reason
    about.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章（kindle_split_014.html#ch06）中，你学习了并发是什么以及通道是如何工作的，并回顾了展示并发操作的代码。在本章中，你将通过回顾更多代码来扩展这些知识。我们将回顾三个实现不同并发模式的包，你可以在自己的项目中使用这些模式。每个包都提供了关于并发和通道的使用以及它们如何使并发程序更容易编写和推理的实用视角。
- en: 7.1\. Runner
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. Runner
- en: The purpose of the runner package is to show how channels can be used to monitor
    the amount of time a program is running and terminate the program if it runs too
    long. This pattern is useful when developing a program that will be scheduled
    to run as a background task process. This could be a program that runs as a cron
    job, or in a worker-based cloud environment like Iron.io.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`runner` 包的目的是展示如何使用通道来监控程序运行的时间，并在程序运行时间过长时终止程序。当开发计划作为后台任务进程运行的程序时，这种模式很有用。这可能是一个作为
    cron 作业运行的程序，或者在基于工作者的云环境（如 Iron.io）中运行。 '
- en: Let’s take a look at the runner.go code file from the `runner` package.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `runner` 包中的 runner.go 代码文件。
- en: Listing 7.1\. `runner`/runner.go
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. `runner`/runner.go
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The program in [listing 7.1](#ch07ex01) shows a concurrency pattern for task-oriented
    programs that run unattended on a schedule. It’s designed with three possible
    termination points:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.1](#ch07ex01) 中的程序展示了面向任务的程序在计划中无人看管运行时的并发模式。它设计了三个可能的终止点：'
- en: The program can finish its work within the allotted amount of time and terminate
    normally.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序可以在规定的时间内完成其工作并正常终止。
- en: The program doesn’t finish in time and kills itself.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序未能按时完成并自行终止。
- en: An operating system interrupt event is received and the program attempts to
    immediately shut down cleanly.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到操作系统中断事件，程序尝试立即干净地关闭。
- en: Let’s walk through the code and see how each point has been implemented.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析代码，看看每个点是如何实现的。
- en: 'Listing 7.2\. `runner`/runner.go: lines 12–28'
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.2\. `runner`/runner.go: 行 12–28'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Listing 7.2](#ch07ex02) starts us off with the declaration of the struct named
    `Runner` on line 14\. This type declares three channels that help manage the lifecycle
    of the program and a slice of functions that represent the different tasks to
    run in series.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.2](#ch07ex02) 从第 14 行开始声明名为 `Runner` 的结构体。此类型声明了三个用于管理程序生命周期的通道和一个表示要按顺序运行的不同任务的函数切片。'
- en: The `interrupt` channel on line 17 sends and receives values of interface type
    `os.Signal` and is used to receive interrupt events from the host operating system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第 17 行的 `interrupt` 通道发送和接收 `os.Signal` 类型的接口值，并用于接收来自宿主操作系统的中断事件。
- en: Listing 7.3\. golang.org/pkg/os/#Signal
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. golang.org/pkg/os/#Signal
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The declaration of the `os.Signal` interface is presented in [listing 7.3](#ch07ex03).
    This interface abstracts specific implementations for trapping and reporting events
    from different operating systems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Signal` 接口的声明在 [列表 7.3](#ch07ex03) 中展示。此接口抽象了来自不同操作系统的捕获和报告事件的特定实现。'
- en: The second field is named `complete` and is a channel that sends and receives
    values of interface type `error`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段名为 `complete`，是一个发送和接收 `error` 类型的接口值的通道。
- en: 'Listing 7.4\. `runner`/runner.go: lines 19–20'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.4\. `runner`/runner.go: 行 19–20'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This channel is called `complete` because it’s used by the goroutine running
    the tasks to signal that the channel’s done. If an error occurs, it’s reported
    back via an `error` interface value sent through the channel. If no error occurs,
    the value of `nil` is sent as the error interface value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通道被称为 `complete`，因为它被运行任务的 goroutine 用于表示通道已完成。如果发生错误，它将通过通过通道发送的 `error`
    接口值返回。如果没有发生错误，则发送 `nil` 作为错误接口值。
- en: The third field is named `timeout` and receives `time.Time` values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段名为 `timeout`，接收 `time.Time` 类型的值。
- en: 'Listing 7.5\. `runner`/runner.go: lines 22–23'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.5\. `runner`/runner.go: 行 22–23'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This channel is used to manage the amount of time the process has to complete
    all its tasks. If a `time.Time` value is ever received on this channel, the program
    will attempt to shut itself down cleanly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通道用于管理进程完成所有任务所需的时间量。如果这个通道上收到了 `time.Time` 值，程序将尝试干净地关闭自己。
- en: The final field is named `tasks` and is a slice of function values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段被命名为 `tasks`，它是一个函数值的切片。
- en: 'Listing 7.6\. `runner`/runner.go: lines 25–27'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.6\. `runner`/runner.go: 行 25–27'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These function values represent functions that are run in series, one after
    the other. The execution of these functions happens on a single but separate goroutine
    from `main`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数值代表了一系列依次运行的函数。这些函数的执行在一个单独但独立的goroutine上从 `main` 进行。
- en: With the `Runner` type declared, next we have two `error` interface variables.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了 `Runner` 类型之后，接下来我们有两个 `error` 接口变量。
- en: 'Listing 7.7\. `runner`/runner.go: lines 30–34'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.7\. `runner`/runner.go: 行 30–34'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first `error` interface variable is named `ErrTimeout`. This error value
    is returned by the `Start` method when a timeout event is received. The second
    `error` interface variable is named `ErrInterrupt`. This error value is returned
    by the `Start` method when an operating system event is received.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `error` 接口变量被命名为 `ErrTimeout`。当接收到超时事件时，`Start` 方法返回这个错误值。第二个 `error` 接口变量被命名为
    `ErrInterrupt`。当接收到操作系统事件时，`Start` 方法返回这个错误值。
- en: Now we can look at how users can create values of type `Runner`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看用户如何创建 `Runner` 类型的值。
- en: 'Listing 7.8\. `runner`/runner.go: lines 36–43'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.8\. `runner`/runner.go: 行 36–43'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Listing 7.8](#ch07ex08) shows a factory function called `New`, which accepts
    a value of type `time.Duration` and returns a pointer of type `Runner`. The function
    creates a value of type `Runner` and initializes each of the channel fields. The
    `tasks` field is not explicitly initialized, since the zero value for this field
    is a `nil` slice. Each channel field has a unique initialization, so let’s explore
    each one in more detail.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.8](#ch07ex08) 展示了一个名为 `New` 的工厂函数，它接受一个 `time.Duration` 类型的值，并返回一个 `Runner`
    类型的指针。该函数创建一个 `Runner` 类型的值，并初始化每个通道字段。`tasks` 字段没有显式初始化，因为这个字段的零值是一个 `nil` 切片。每个通道字段都有一个独特的初始化，所以让我们更详细地探索每一个。'
- en: The `interrupt` channel is initialized as a buffered channel with a buffer of
    `1`. This guarantees at least one `os.Signal` value is received from the runtime.
    The runtime sends this event in a nonblocking way. If a goroutine isn’t ready
    to receive this value, the value is thrown away. As an example, if the user hits
    Ctrl+C repeatedly, the program will receive the event only when a buffer is available
    in the channel and all other events will be thrown away.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupt` 通道被初始化为一个带有 `1` 个缓冲的缓冲通道。这保证了至少会从运行时接收到一个 `os.Signal` 值。运行时将以非阻塞的方式发送这个事件。如果一个goroutine没有准备好接收这个值，这个值就会被丢弃。例如，如果用户反复按
    Ctrl+C，程序只有在通道中有缓冲并且所有其他事件都被丢弃时才会接收到这个事件。'
- en: The `complete` channel is initialized as an unbuffered channel. When the goroutine
    running the tasks is finished, it sends an `error` value or `nil error` value
    on this channel. Then it waits for `main` to receive it. Once `main` receives
    the `error` value, it’s safe for the goroutine to terminate.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`complete` 通道被初始化为一个无缓冲通道。当运行任务的goroutine完成时，它会通过这个通道发送一个 `error` 值或 `nil error`
    值。然后它等待 `main` 接收它。一旦 `main` 接收到 `error` 值，goroutine 就可以安全地终止。'
- en: The final channel, `timeout`, is initialized using the `After` function from
    the `time` package. The `After` function returns a channel of type `time.Time`.
    The runtime will send a `time.Time` value on this channel after the specified
    duration has elapsed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个通道，`timeout`，使用 `time` 包中的 `After` 函数初始化。`After` 函数返回一个 `time.Time` 类型的通道。运行时将在指定持续时间过后通过这个通道发送一个
    `time.Time` 值。
- en: Now that you’ve seen how a `Runner` value is created and initialized, we can
    look at the methods associated with the `Runner` type. The first method, `Add`,
    is used to capture the task functions to be executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何创建和初始化 `Runner` 值，我们可以看看与 `Runner` 类型相关的方法。第一个方法，`Add`，用于捕获要执行的函数任务。
- en: 'Listing 7.9\. `runner`/runner.go: lines 45–49'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.9\. `runner`/runner.go: 行 45–49'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Listing 7.9](#ch07ex09) shows the `Add` method, which is declared with a single
    varadic parameter named `tasks`. *Varadic parameters* can accept any number of
    values that are passed in. In this case the value must be a function that accepts
    a single integer value and returns nothing. The `tasks` parameter, once inside
    the code, becomes a slice of these function values.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.9](#ch07ex09)显示了`Add`方法，该方法使用一个名为`tasks`的单个可变参数声明。*可变参数*可以接受任何数量的传入值。在这种情况下，值必须是一个接受单个整数值并返回空值的函数。一旦进入代码，`tasks`参数就变成了这些函数值的切片。'
- en: Now let’s look at the `run` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`run`方法。
- en: 'Listing 7.10\. `runner`/runner.go: lines 72–85'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.10\. `runner`/runner.go: 第72-85行'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `run` method on line 73 in [listing 7.10](#ch07ex10) iterates over the `tasks`
    slice and executes each function in order. Before any function is executed on
    line 81, the `gotInterrupt` method is called on line 76 to see if there are any
    events to receive from the operating system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表7.10](#ch07ex10)的第73行上的`run`方法遍历`tasks`切片，并按顺序执行每个函数。在执行任何函数之前（第81行），在第76行调用`gotInterrupt`方法，以查看是否有来自操作系统的任何事件要接收。
- en: 'Listing 7.11\. `runner`/runner.go: lines 87–101'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.11\. `runner`/runner.go: 第87-101行'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `gotInterrupt` method in [listing 7.11](#ch07ex11) shows a classic use of
    the `select` statement with a `default` case. On line 91, the code attempts to
    receive on the `interrupt` channel. Normally that would block if there was nothing
    to receive, but we have a `default` case on line 98\. The `default` case turns
    the attempt to receive on the `interrupt` channel into a nonblocking call. If
    there’s an interrupt to receive, then it’s received and processed. If there’s
    nothing to receive, the `default` case is then executed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.11](#ch07ex11)中的`gotInterrupt`方法展示了带有`default`情况的`select`语句的经典用法。在第91行，代码尝试在`interrupt`通道上接收。通常如果没有要接收的内容，它会阻塞，但我们有第98行的`default`情况。`default`情况将尝试在`interrupt`通道上接收的操作转换为非阻塞调用。如果有中断要接收，则接收并处理它。如果没有要接收的内容，则执行`default`情况。'
- en: When an interrupt event is received, the code requests to stop receiving any
    future events by calling the `Stop` method on line 93\. Then the function returns
    `true`. If no interrupt event is received, the method returns false on line 99\.
    Essentially, the `gotInterrupt` method lets the goroutine peek for interrupt events
    and keep processing work if one has not been issued.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到中断事件时，代码通过在第93行调用`Stop`方法请求停止接收任何未来的事件。然后函数返回`true`。如果没有接收到中断事件，方法在第99行返回`false`。本质上，`gotInterrupt`方法允许goroutine检查中断事件，并在没有发出事件的情况下继续处理工作。
- en: The final method in the package is called `Start`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 包中的最后一个方法称为`Start`。
- en: 'Listing 7.12\. `runner`/runner.go: lines 51–70'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.12\. `runner`/runner.go: 第51-70行'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Start` method implements the main workflow for the program. In [listing
    7.12](#ch07ex12) on line 52, `Start` sets up the ability for the `gotInterrupt`
    method to receive interrupt events from the operating system. On lines 56 through
    59, an anonymous function is declared and created as a goroutine. This is the
    goroutine that executes the set of assigned tasks for the program. On line 58,
    inside this goroutine, the `run` method is called and the returned `error` interface
    value is sent on the `complete` channel. Once the `error` interface value is received,
    the goroutine returns that value to the caller.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`方法实现了程序的主要工作流程。在[列表7.12](#ch07ex12)的第52行，`Start`设置了`gotInterrupt`方法接收来自操作系统的中断事件的能力。在第56到59行，声明并创建了一个匿名函数作为goroutine。这是执行程序分配的任务集的goroutine。在第58行，在这个goroutine内部，调用了`run`方法，并将返回的`error`接口值发送到`complete`通道。一旦接收到`error`接口值，goroutine将返回该值给调用者。'
- en: With the goroutine created, `Start` enters into a `select` statement that blocks
    waiting for one of two events to occur. If an `error` interface value is received
    on the `complete` channel, then the goroutine either finished its work within
    the allotted amount of time or an operating system interrupt event was received.
    Regardless, the received `error` interface value is returned and the method terminates.
    If a `time.Time` value is received on the `timeout` channel, then the goroutine
    didn’t finish its work within the allotted amount of time. In this case, the program
    returns the `ErrTimeout` variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建goroutine后，`Start`进入一个`select`语句，阻塞等待两个事件之一发生。如果在`complete`通道上收到`error`接口值，则goroutine要么在分配的时间内完成了工作，要么收到了操作系统中断事件。无论如何，都会返回接收到的`error`接口值，方法终止。如果在`timeout`通道上收到`time.Time`值，则goroutine没有在分配的时间内完成工作。在这种情况下，程序返回`ErrTimeout`变量。
- en: Now that you’ve seen the code for the runner package and learned how it works,
    let’s review the test program in the main.go source code file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了`runner`包的代码，并了解了它是如何工作的，让我们回顾`main.go`源代码文件中的测试程序。
- en: Listing 7.13\. `runner`/main/main.go
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.13\. `runner`/main/main.go
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `main` function can be found on line 16 in [listing 7.13](#ch07ex13). On
    line 20 the timeout value is passed to the `New` function, and a pointer of type
    `Runner` is returned. Then the `createTask` function is added to the `Runner`
    several times on line 23\. The `createTask` function, declared on line 42, is
    a function that just pretends to perform some work for a specified amount of time.
    Once the functions have been added, the `Start` method is called on line 26 and
    the `main` function waits for `Start` to return.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数可以在[列表7.13](#ch07ex13)的第16行找到。在第20行，将超时值传递给`New`函数，并返回一个类型为`Runner`的指针。然后，在第23行多次将`createTask`函数添加到`Runner`中。在第42行声明的`createTask`函数是一个假装执行指定时间工作的函数。一旦添加了函数，就在第26行调用`Start`方法，`main`函数等待`Start`返回。'
- en: When `Start` returns the returned `error` interface value is checked. If an
    error did occur, the code uses the `error` interface variables to identify if
    the method terminated due to a timeout event or interrupt event. If there’s no
    error, then the tasks finished in time. On a timeout event, the program terminates
    with an error code of 1\. On an interrupt event, the program terminates with an
    error code of 2\. In all other cases, the program terminates normally with error
    code 0.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Start`返回时，会检查返回的`error`接口值。如果发生了错误，代码使用`error`接口变量来识别方法是否由于超时事件或中断事件而终止。如果没有错误，则任务按时完成。在超时事件中，程序以错误代码1终止。在中断事件中，程序以错误代码2终止。在其他所有情况下，程序以错误代码0正常终止。
- en: 7.2\. Pooling
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 池化
- en: The purpose of the `pool` package is to show how you can use a buffered channel
    to pool a set of resources that can be shared and individually used by any number
    of goroutines. This pattern is useful when you have a static set of resources
    to share, such as database connections or memory buffers. When a goroutine needs
    one of these resources from the pool, it can acquire the resource, use it, and
    then return it to the pool.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`pool`包的目的是展示如何使用缓冲通道来收集一组资源，这些资源可以被任何数量的goroutine共享和单独使用。当你有一组静态资源需要共享时，这种模式很有用，例如数据库连接或内存缓冲区。当一个goroutine需要从池中获取这些资源之一时，它可以获取资源，使用它，然后将其返回到池中。'
- en: Let’s take a look at the pool.go code file from the `pool` package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`pool`包中的`pool.go`代码文件。
- en: Listing 7.14\. `pool`/pool.go
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.14\. `pool`/pool.go
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code for the `pool` package in [listing 7.14](#ch07ex14) declares a struct
    named `Pool` that allows the caller to create as many different pools as needed.
    Each pool can manage any type of resource as long as the type implements the `io.Closer`
    interface. Let’s take a look at the declaration of the `Pool` struct.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.14](#ch07ex14)中的`pool`包的代码声明了一个名为`Pool`的结构体，允许调用者创建所需数量的不同池。只要类型实现了`io.Closer`接口，每个池都可以管理任何类型的资源。让我们看看`Pool`结构体的声明。'
- en: 'Listing 7.15\. `pool`/pool.go: lines 12–20'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.15\. `pool`/pool.go: 行12–20'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Pool` struct declares four fields, each of which helps manage the pool
    in a goroutine-safe way. On line 16 the struct starts off with a field of type
    `sync.Mutex`. This mutex is used to keep all the operations against a `Pool` value-safe
    for multigoroutine access. The second field is named `resources` and is declared
    as a channel of interface type `io.Closer`. This channel will be created as a
    buffered channel and will contain the resources being shared. Because an interface
    type is being used, the pool can manage any type of resource that implements the
    `io.Closer` interface.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool` 结构体声明了四个字段，每个字段都帮助以 goroutine 安全的方式管理池。在第 16 行，结构体开始于一个类型为 `sync.Mutex`
    的字段。这个互斥锁用于确保对 `Pool` 值的所有操作在多 goroutine 访问时是安全的。第二个字段名为 `resources`，声明为一个接口类型
    `io.Closer` 的通道。这个通道将被创建为一个带缓冲的通道，并将包含共享的资源。由于使用了接口类型，池可以管理任何实现了 `io.Closer` 接口的资源类型。'
- en: The `factory` field is of a function type. Any function that takes no parameters
    and returns an `io.Closer` and an `error` interface value can be assigned to this
    field. The purpose of this function is to create a new resource when the pool
    requires one. This functionality is an implementation detail beyond the scope
    of the `pool` package and needs to be implemented and supplied by the user using
    this package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`factory` 字段是一个函数类型。任何不接受参数并返回 `io.Closer` 和 `error` 接口值的函数都可以分配给此字段。此函数的目的是在池需要时创建一个新的资源。这种功能是
    `pool` 包范围之外的实施细节，需要由使用此包的用户实现和提供。'
- en: The final field on line 19 is the `closed` field. This field is a flag that
    indicates the `Pool` is being shut down or is already shut down. Now that you’ve
    seen the declaration of the `Pool` struct, let’s look at the `error` interface
    variable that’s declared on line 24.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19 行的最后一个字段是 `closed` 字段。此字段是一个标志，表示 `Pool` 正在关闭或已经关闭。现在你已经看到了 `Pool` 结构体的声明，让我们看看第
    24 行声明的 `error` 接口变量。
- en: 'Listing 7.16\. `pool`/pool.go: lines 22–24'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.16\. `pool`/pool.go: 行 22–24'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating `error` interface variables is a common practice in Go. This allows
    the caller to identify specific returned error values from any function or method
    within the package. The `error` interface variable in [listing 7.16](#ch07ex16)
    has been declared to report when the user calls the `Acquire` method and the `Pool`
    has been closed. Since the `Acquire` method can return multiple different errors,
    returning this error variable when the `Pool` is closed allows the caller to identify
    this specific error over others.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建 `error` 接口变量是一种常见做法。这允许调用者从包中的任何函数或方法中识别特定的返回错误值。在 [列表 7.16](#ch07ex16)
    中的 `error` 接口变量已被声明，用于报告当用户调用 `Acquire` 方法且 `Pool` 已关闭时的情况。由于 `Acquire` 方法可以返回多个不同的错误，当
    `Pool` 关闭时返回此错误变量允许调用者识别这个特定的错误而不是其他错误。
- en: With the `Pool` type and the `error` interface variable declared, we can start
    to look at the functions and methods that are declared in the `pool` package.
    Let’s start with the pool’s factory function, named `New`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了 `Pool` 类型和 `error` 接口变量之后，我们可以开始查看在 `pool` 包中声明的函数和方法。让我们从池的工厂函数 `New`
    开始。
- en: 'Listing 7.17\. `pool`/pool.go: lines 26–38'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.17\. `pool`/pool.go: 行 26–38'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `New` function in [listing 7.17](#ch07ex17) accepts two parameters and returns
    two values. The first parameter, `fn`, is declared as a function type that accepts
    no parameters and returns an `io.Closer` and an `error` interface value. The function
    parameter represents a factory function that creates values of the resource being
    managed by the pool. The second parameter, `size`, represents the size of the
    buffered channel created to hold the resources.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.17](#ch07ex17) 中的 `New` 函数接受两个参数并返回两个值。第一个参数 `fn` 被声明为一个不接受参数并返回 `io.Closer`
    和 `error` 接口值的函数类型。函数参数代表一个工厂函数，用于创建池管理的资源值。第二个参数 `size` 代表创建用于存储资源的带缓冲通道的大小。
- en: On line 30 the value of `size` is checked to make sure it’s not less than or
    equal to 0\. If it is, then the code returns `nil` for the returned `pool` pointer
    value and then creates an `error` interface value on the fly for the error. Since
    this is the only error being returned from this function, it’s not necessary to
    create and use an `error` interface variable for this error. If the size value
    is good, then a new `Pool` value is created and initialized. On line 35 the function
    parameter is assigned, and on line 36 the buffered channel is created using the
    size value. Everything can be created and initialized within the scope of the
    `return` statement. So a pointer to the new `Pool` value and the `error` interface
    value of `nil` are created and returned as the arguments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第30行，检查`size`的值以确保它不小于或等于0。如果是，则代码返回`nil`作为返回的`pool`指针值，并即时创建一个错误接口值。由于这是此函数返回的唯一错误，因此不需要为此错误创建和使用错误接口变量。如果大小值有效，则创建并初始化一个新的`Pool`值。在第35行，将函数参数赋值，在第36行使用大小值创建缓冲通道。所有创建和初始化都可以在`return`语句的作用域内完成。因此，创建并返回指向新`Pool`值的指针和`nil`的错误接口值作为参数。
- en: With the ability to create and initialize a `Pool` value, next let’s look at
    the `Acquire` method. This method allows the caller to acquire a resource from
    the pool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够创建和初始化`Pool`值之后，接下来让我们看看`Acquire`方法。此方法允许调用者从池中获取资源。
- en: 'Listing 7.18\. `pool`/pool.go: lines 40–56'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.18\. `pool`/pool.go: 第40–56行'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Listing 7.18](#ch07ex18) contains the code for the `Acquire` method. This
    method returns a resource from the pool if one is available, or creates a new
    one for the call. This implementation is accomplished by using a `select / case`
    statement to check if there’s a resource in the buffered channel. If there is,
    it’s received and then returned to the caller. This can be seen on lines 44 and
    49\. If there’s no resource in the buffered channel to receive, then the `default`
    case is executed. In this case, on line 54 the user’s factory function is executed
    and a new resource is created and returned.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.18](#ch07ex18)包含`Acquire`方法的代码。此方法如果池中有可用资源，则返回资源，或者为调用创建一个新的。此实现是通过使用`select
    / case`语句来检查缓冲通道中是否有资源来完成的。如果有，则接收并返回给调用者。这可以在第44行和第49行看到。如果没有资源在缓冲通道中接收，则执行`default`情况。在这种情况下，在第54行执行用户的工厂函数，创建一个新的资源并返回。'
- en: After a resource is acquired and no longer needed, it must be released back
    into the pool. This is where the `Release` method comes in. But to understand
    the mechanics behind the code in the `Release` method, we need to look at the
    `Close` method first.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取资源并且不再需要后，必须将其释放回池中。这就是`Release`方法发挥作用的地方。但要理解`Release`方法背后的代码机制，我们首先需要查看`Close`方法。
- en: 'Listing 7.19\. `pool`/pool.go: lines 82–104'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.19\. `pool`/pool.go: 第82–104行'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the program is finished with the pool, it should call the `Close` method.
    The code for the `Close` method is shown in [listing 7.19](#ch07ex19). The method
    closes and flushes the buffered channel on lines 98 and 101, closing any resources
    that exist until the channel is empty. All the code in this method must be executed
    by only one goroutine at a time. In fact, when this code is being executed, goroutines
    must also be prevented from executing code in the `Release` method. You’ll understand
    why this is important soon.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序完成对池的使用，它应该调用`Close`方法。`Close`方法的代码在[列表7.19](#ch07ex19)中显示。该方法在第98行和第101行关闭并清空缓冲通道，关闭任何存在的资源，直到通道为空。此方法中的所有代码必须一次只由一个goroutine执行。实际上，当此代码正在执行时，goroutine还必须防止在`Release`方法中执行代码。你很快就会明白为什么这很重要。
- en: On lines 85 and 86, the mutex is locked and then scheduled to be unlocked when
    the function returns. On line 89 the `closed` flag is checked to see if the pool
    is already closed. If it is, the method returns immediately, which releases the
    lock. If this is the first time the method is called, then the flag is set to
    `true` and the `resources` channel is closed and flushed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第85行和第86行，互斥锁被锁定，并在函数返回时计划解锁。在第89行，检查`closed`标志以查看池是否已经关闭。如果是，方法立即返回，从而释放锁。如果是第一次调用该方法，则将标志设置为`true`，并关闭并清空`resources`通道。
- en: Now we can look at the `Release` method and see how it works in coordination
    with the `Close` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看`Release`方法，并了解它是如何与`Close`方法协调工作的。
- en: 'Listing 7.20\. `pool`/pool.go: lines 58–80'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.20\. `pool`/pool.go: 第58–80行'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The implementation of the `Release` method can be found in [listing 7.20](#ch07ex20).
    The method starts out with the locking and unlocking of a mutex on lines 61 and
    62\. This is the same mutex as in the `Close` method. This is how both methods
    are prevented from being run at the same time by different goroutines. The use
    of the mutex serves two purposes. First, it protects the read on the `closed`
    flag on line 65 from happening at the same time as a write on this flag in the
    `Close` method. Second, we don’t want to attempt to send on a closed channel because
    this will cause a panic. When the `closed` field is `false`, we know the `resources`
    channel has been closed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Release` 方法的实现可以在 [代码列表 7.20](#ch07ex20) 中找到。该方法从第 61 和 62 行开始锁定和解锁互斥锁。这与
    `Close` 方法中的互斥锁相同。这就是如何通过不同的 goroutine 防止两种方法同时运行。互斥锁的使用有两个目的。首先，它保护第 65 行的 `closed`
    标志的读取不会与 `Close` 方法中此标志的写入同时发生。其次，我们不希望尝试向已关闭的通道发送数据，因为这会导致恐慌。当 `closed` 字段为 `false`
    时，我们知道 `resources` 通道已被关闭。'
- en: On line 66, the `Close` method on the resource is called directly when the pool
    is closed. This is because there’s no way to release the resource back into the
    pool. At this point the pool has been both closed and flushed. The reads and writes
    to the `closed` flag must be synchronized or else goroutines could be misled into
    thinking the pool is open and attempt to perform an invalid operation on the channel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 66 行，当池关闭时，直接调用资源上的 `Close` 方法。这是因为没有方法可以将资源释放回池中。此时，池已被关闭和刷新。对 `closed`
    标志的读写必须同步，否则 goroutine 可能会被误导，认为池是打开的，并尝试在通道上执行无效操作。
- en: Now that you’ve seen the pool code and learned how it works, let’s review the
    test program in the main.go source code file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了池代码并了解了它的工作原理，让我们回顾一下 main.go 源代码文件中的测试程序。
- en: Listing 7.21\. `pool`/`main`/main.go
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表 7.21\. `pool`/`main`/main.go
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code in main.go, shown in [listing 7.21](#ch07ex21), uses the `pool` package
    to manage a simulated pool of database connections. The code starts out declaring
    two constants, `maxGoroutines` and `pooledResources`, to set the number of goroutines
    and resources the program is going to use. The declaration of the resource and
    the implementation of the `io.Closer` interface follows.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main.go 中显示的代码，如 [代码列表 7.21](#ch07ex21)，使用 `pool` 包来管理模拟的数据库连接池。代码首先声明了两个常量
    `maxGoroutines` 和 `pooledResources`，以设置程序将要使用的 goroutine 和资源数量。接着声明了资源和实现了 `io.Closer`
    接口。
- en: 'Listing 7.22\. `pool`/`main`/main.go: lines 21–32'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '代码列表 7.22\. `pool`/`main`/main.go: 行 21–32'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Listing 7.22](#ch07ex22) shows the declaration of the `dbConnection` struct
    and its implementation of the `io.Closer` interface. The `dbConnection` type simulates
    a struct that’s managing a database connection and currently has one field, `ID`,
    that contains a unique ID for each connection. The `Close` method just reports
    that the connection is being closed and displays its ID.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码列表 7.22](#ch07ex22) 展示了 `dbConnection` 结构体的声明及其实现 `io.Closer` 接口。`dbConnection`
    类型模拟了一个管理数据库连接的结构体，目前有一个字段 `ID`，包含每个连接的唯一 ID。`Close` 方法只是报告连接正在关闭并显示其 ID。'
- en: Next we have the factory function that creates values of `dbConnection`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个工厂函数，用于创建 `dbConnection` 的值。
- en: 'Listing 7.23\. `pool`/`main`/main.go: lines 34–44'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '代码列表 7.23\. `pool`/`main`/main.go: 行 34–44'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Listing 7.23](#ch07ex23) shows the implementation of the `createConnection`
    function. The function generates a new and unique ID for the connection, displays
    that the connection is being created, and returns a pointer to a value of type
    `dbConnection` with this unique ID. The generation of the unique ID is performed
    with the `atomic.AddInt32` function. It’s used to safely increment the value of
    the package level variable `idCounter`. Now that we have our resource and the
    factory function, we can use it with the `pool` package.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码列表 7.23](#ch07ex23) 展示了 `createConnection` 函数的实现。该函数为连接生成一个新的唯一 ID，显示正在创建连接，并返回一个具有此唯一
    ID 的 `dbConnection` 类型的指针值。唯一 ID 的生成是通过 `atomic.AddInt32` 函数完成的。它用于安全地递增包级别变量
    `idCounter` 的值。现在我们有了资源和工厂函数，我们可以使用 `pool` 包来使用它。'
- en: Next, let’s look at the code inside the `main` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `main` 函数内部的代码。
- en: 'Listing 7.24\. `pool`/`main`/main.go: lines 48–55'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '代码列表 7.24\. `pool`/`main`/main.go: 行 48–55'
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `main` function starts out with declaring a `WaitGroup` on line 48 and setting
    the value of the `WaitGroup` to match the number of goroutines that will be created.
    The new `Pool` is created using the `New` function from the `pool` package. The
    factory function and the number of resources to manage are passed in. This returns
    a pointer to the `Pool` value and any possible error is checked. Now that we have
    a `Pool`, we can create goroutines that can share resources being managed by the
    pool.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数开始于第 48 行声明一个 `WaitGroup` 并将 `WaitGroup` 的值设置为将要创建的goroutine数量。使用
    `pool` 包的 `New` 函数创建一个新的 `Pool`。传入工厂函数和管理资源数量。这返回一个指向 `Pool` 值的指针，并检查任何可能的错误。现在我们有了
    `Pool`，我们可以创建可以共享池管理的资源的goroutine。'
- en: 'Listing 7.25\. `pool`/`main`/main.go: lines 57–66'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.25\. `pool`/`main`/main.go: 行 57–66'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A `for` loop is used in [listing 7.25](#ch07ex25) to create goroutines that
    will use the pool. Each goroutine calls the `performQueries` function once and
    then quits. The `performQueries` function is provided a unique ID for logging
    and the pointer to the `Pool`. Once all the goroutines are created, the `main`
    function then waits for the goroutines to complete.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.25](#ch07ex25) 中使用 `for` 循环创建将使用池的goroutine。每个goroutine调用一次 `performQueries`
    函数然后退出。`performQueries` 函数提供了一个唯一的ID用于日志记录，以及指向 `Pool` 的指针。一旦所有goroutine都创建完成，`main`
    函数等待goroutine完成。
- en: 'Listing 7.26\. `pool`/`main`/main.go: lines 68–73'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.26\. `pool`/`main`/main.go: 行 68–73'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In [listing 7.26](#ch07ex26), the `main` function waits on the `WaitGroup`.
    Once all the goroutines report they’re done, the `Pool` is closed and the program
    terminates. Next, let’s look at the `performQueries` function, which uses the
    pool’s `Acquire` and `Release` methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.26](#ch07ex26) 中，`main` 函数等待 `WaitGroup`。一旦所有goroutine报告已完成，关闭 `Pool`
    并终止程序。接下来，让我们看看 `performQueries` 函数，它使用了池的 `Acquire` 和 `Release` 方法。
- en: 'Listing 7.27\. `pool`/`main`/main.go: lines 76–91'
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.27\. `pool`/`main`/main.go: 行 76–91'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The implementation of the `performQueries` function in [listing 7.27](#ch07ex27)
    shows the use of the pool’s `Acquire` and `Release` methods. The function starts
    out by calling the `Acquire` method to retrieve a `dbConnection` from the pool.
    The returned `error` interface value is checked, and then on line 86 a defer is
    used to release the `dbConnection` back into the pool once the function returns.
    On lines 89 and 90 a random amount of sleep occurs to simulate work time using
    the `dbConnection`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.27](#ch07ex27) 中 `performQueries` 函数的实现展示了池的 `Acquire` 和 `Release` 方法的使用。函数开始时通过调用
    `Acquire` 方法从池中检索一个 `dbConnection`。检查返回的 `error` 接口值，然后在第 86 行使用 `defer` 将 `dbConnection`
    释放回池中。在第 89 和 90 行发生随机睡眠，以使用 `dbConnection` 模拟工作时间。'
- en: 7.3\. Work
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 工作
- en: The purpose of the `work` package is to show how you can use an unbuffered channel
    to create a pool of goroutines that will perform and control the amount of work
    that gets done concurrently. This is a better approach than using a buffered channel
    of some arbitrary static size that acts as a queue of work and throwing a bunch
    of goroutines at it. Unbuffered channels provide a guarantee that data has been
    exchanged between two goroutines. This approach of using an unbuffered channel
    allows the user to know when the pool is performing the work, and the channel
    pushes back when it can’t accept any more work because it’s busy. No work is ever
    lost or stuck in a queue that has no guarantee it will ever be worked on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`work` 包的目的是展示如何使用无缓冲通道创建一个goroutine池，该池将执行并控制并发完成的工作量。这种方法比使用任意静态大小的缓冲通道作为工作队列并将大量goroutine扔给它要好。无缓冲通道提供了一种保证，即两个goroutine之间已经交换了数据。使用无缓冲通道的方法允许用户知道池何时正在执行工作，当通道忙于处理更多工作而无法接受时，它会推回。永远不会丢失任何工作，也不会在工作队列中卡住，因为无法保证它将被处理。'
- en: Let’s take a look at the work.go code file from the `work` package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `work` 包中的 work.go 代码文件。
- en: Listing 7.28\. `work`/work.go
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.28\. `work`/work.go
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `work` package in [listing 7.28](#ch07ex28) starts off with the declaration
    of an interface named `Worker` and a struct named `Pool`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.28](#ch07ex28) 中的 `work` 包开始于一个名为 `Worker` 的接口和一个名为 `Pool` 的结构的声明。'
- en: 'Listing 7.29\. `work`/work.go: lines 07–18'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.29\. `work`/work.go: 行 07–18'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Worker` interface on line 09 in [listing 7.29](#ch07ex29) declares a single
    method called `Task`. On line 15 a struct named `Pool` is declared, which is the
    type that implements the pool of goroutines and will have methods that process
    the work. The type declares two fields, one named `work`, which is a channel of
    the `Worker` interface type, and a `sync.WaitGroup` named `wg`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.29](#ch07ex29) 的第 09 行上的 `Worker` 接口声明了一个名为 `Task` 的单个方法。在第 15 行声明了一个名为
    `Pool` 的结构体，这是实现 goroutines 池的类型，并将具有处理工作的方法。该类型声明了两个字段，一个名为 `work`，它是一个 `Worker`
    接口类型的通道，另一个名为 `wg` 的 `sync.WaitGroup`。
- en: Next let’s look at the factory function for the `work` package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看 `work` 包的工厂函数。
- en: 'Listing 7.30\. `work`/work.go: lines 20–37'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.30\. `work`/work.go: 行 20–37'
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Listing 7.30](#ch07ex30) shows the `New` function that’s used to create work
    pool that’s configured with a fixed number of goroutines. The number of goroutines
    is passed in as a parameter to the `New` function. On line 22 a value of type
    `Pool` is created, and the `work` field is initialized with an unbuffered channel.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.30](#ch07ex30) 展示了用于创建配置了固定数量 goroutines 的工作池的 `New` 函数。goroutines 的数量作为参数传递给
    `New` 函数。在第 22 行创建了一个类型为 `Pool` 的值，并将 `work` 字段初始化为一个无缓冲通道。'
- en: Then, on line 26, the `WaitGroup` is initialized, and on lines 27 through 34
    the same number of goroutines are created. The goroutines just receive interface
    values of type `Worker` and call the `Task` method on those values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第 26 行初始化了 `WaitGroup`，在第 27 行至 34 行创建了相同数量的 goroutines。这些 goroutines 只接收类型为
    `Worker` 的接口值，并调用这些值上的 `Task` 方法。
- en: 'Listing 7.31\. `work`/work.go: lines 28–33'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.31\. `work`/work.go: 行 28–33'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `for range` loop blocks until there’s a `Worker` interface value to receive
    on the `work` channel. When a value is received, the `Task` method is called.
    Once the `work` channel is closed, the `for range` loop ends and the call to `Done`
    on the `WaitGroup` is called. Then the goroutine terminates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`for range` 循环会阻塞，直到在 `work` 通道上有 `Worker` 接口值可以接收。当接收到值时，会调用 `Task` 方法。一旦
    `work` 通道关闭，`for range` 循环结束，并调用 `WaitGroup` 上的 `Done` 方法。然后 goroutine 终止。'
- en: Now that we can create a pool of goroutines that can wait for and execute work,
    let’s look at how work is submitted into the pool.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建一个可以等待并执行工作的 goroutines 池，让我们看看如何将工作提交到池中。
- en: 'Listing 7.32\. `work`/work.go: lines 39–42'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.32\. `work`/work.go: 行 39–42'
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Listing 7.32](#ch07ex32) shows the `Run` method. This method is used to submit
    work into the pool. It accepts an interface value of type `Worker` and sends that
    value through the `work` channel. Since the `work` channel is an unbuffered channel,
    the caller must wait for a goroutine from the pool to receive it. This is what
    we want, because the caller needs the guarantee that the work being submitted
    is being worked on once the call to `Run` returns.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.32](#ch07ex32) 展示了 `Run` 方法。此方法用于将工作提交到池中。它接受一个类型为 `Worker` 的接口值，并通过
    `work` 通道发送该值。由于 `work` 通道是一个无缓冲通道，调用者必须等待池中的某个 goroutine 接收它。这正是我们想要的，因为调用者需要保证在
    `Run` 调用返回后，提交的工作正在被处理。'
- en: At some point, the work pool needs to be shut down. This is where the `Shutdown`
    method comes in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，工作池需要关闭。这就是 `Shutdown` 方法发挥作用的地方。
- en: 'Listing 7.33\. `work`/work.go: lines 44–48'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.33\. `work`/work.go: 行 44–48'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Shutdown` method in [listing 7.33](#ch07ex33) does two things. First, it
    closes the `work` channel, which causes all of the goroutines in the pool to shut
    down and call the `Done` method on the `WaitGroup`. Then the `Shutdown` method
    calls the `Wait` method on the `WaitGroup`, which causes the `Shutdown` method
    to wait for all the goroutines to report they have terminated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.33](#ch07ex33) 中的 `Shutdown` 方法做了两件事。首先，它关闭了 `work` 通道，这导致池中的所有 goroutines
    关闭并调用 `WaitGroup` 上的 `Done` 方法。然后 `Shutdown` 方法调用 `WaitGroup` 上的 `Wait` 方法，这导致
    `Shutdown` 方法等待所有 goroutines 报告它们已经终止。
- en: Now that you’ve seen the code for the work package and learned how it works,
    let’s review the test program in the main.go source code file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了工作包的代码，并了解了它是如何工作的，让我们回顾一下 `main.go` 源代码文件中的测试程序。
- en: Listing 7.34\. `work`/`main`/main.go
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.34\. `work`/`main`/main.go
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Listing 7.34](#ch07ex34) shows the test program that uses the `work` package
    to perform the displaying of names. The code starts out on line 14 with the declaration
    of a package level variable named `names`, which is declared as a slice of strings.
    The slice is also initialized with five names. Then a type named `namePrinter`
    is declared.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.34](#ch07ex34)显示了使用`work`包执行名称显示的测试程序。代码从第14行开始，声明了一个名为`names`的包级变量，它被声明为一个字符串切片。该切片还初始化了五个名称。然后声明了一个名为`namePrinter`的类型。'
- en: 'Listing 7.35\. `work`/`main`/main.go: lines 22–31'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.35. `work`/`main`/main.go: 第22–31行'
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On line 23 in [listing 7.35](#ch07ex35), the `namePrinter` type is declared
    and the implementation of the `Worker` interface follows. The purpose of the work
    is to display names to the screen. The type contains a single field, `name`, that
    will contain the name to display. The implementation of the `Worker` interface
    uses the `log.Println` function to display the name and then waits a second before
    returning. The second wait is just to slow the test program down so you can see
    the concurrency is action.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表7.35](#ch07ex35)的第23行，声明了`namePrinter`类型，并跟随`Worker`接口的实现。工作的目的是在屏幕上显示名称。该类型包含一个字段`name`，它将包含要显示的名称。`Worker`接口的实现使用`log.Println`函数来显示名称，然后等待一秒后返回。第二次等待只是为了减慢测试程序的速度，以便你可以看到并发操作的效果。
- en: With the implementation of the `Worker` interface, we can look at the code inside
    the `main` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`Worker`接口，我们可以查看`main`函数内部的代码。
- en: 'Listing 7.36\. `work`/`main`/main.go: lines 33–64'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.36. `work`/`main`/main.go: 第33–64行'
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: On line 36 in [listing 7.36](#ch07ex36), the `New` function from the `work`
    package is called to create the work pool. The number 2 is passed into the call,
    indicating the pool should only contain two goroutines. On lines 38 and 39 a `WaitGroup`
    is declared and initialized to each goroutine that will be created. In this case,
    a goroutine for each name in the `names` slice will be created 100 times. This
    is to create a lot of goroutines competing to submit work to the pool.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表7.36](#ch07ex36)的第36行，从`work`包中调用了`New`函数来创建工作池。调用中传入了数字2，表示池中只应包含两个goroutine。在第38和39行，声明并初始化了一个`WaitGroup`，用于每个将被创建的goroutine。在这种情况下，将为`names`切片中的每个名称创建100个goroutine。这是为了创建大量的goroutine，它们将竞争向池提交工作。
- en: On lines 41 and 43 inner and outer `for` loops are declared to create all the
    goroutines. Inside each iteration of the inner loop, a value of type `namePrinter`
    is created and provided with a name to print. Then, on line 50, an anonymous function
    is declared and created as a goroutine. The goroutine calls the `Run` method against
    the work pool to submit the `namePrinter` value to the pool. Once a goroutine
    from the work pool receives the value, the call to `Run` returns. This in turn
    causes the goroutine to decrement the `WaitGroup` count and terminate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第41和43行声明了内部和外部`for`循环来创建所有goroutine。在内循环的每次迭代中，创建一个类型为`namePrinter`的值，并提供一个要打印的名称。然后，在第50行，声明并创建了一个匿名函数，作为一个goroutine。该goroutine调用工作池的`Run`方法来提交`namePrinter`值到池中。一旦工作池中的goroutine接收到了值，`Run`的调用就会返回。这反过来导致goroutine减少`WaitGroup`计数并终止。
- en: Once all the goroutines are created, the `main` function calls `Wait` on the
    `WaitGroup`. The function will wait until all the goroutines that were created
    submit their work. Once `Wait` returns, the work pool is shut down by calling
    the `Shutdown` method. This method won’t return until all the work is complete.
    In our case, there would be only two outstanding pieces of work by this time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了所有goroutine，`main`函数就会在`WaitGroup`上调用`Wait`。该函数将等待所有创建的goroutine提交它们的工作。一旦`Wait`返回，通过调用`Shutdown`方法关闭工作池。此方法不会返回，直到所有工作都完成。在我们的例子中，此时会有两个未完成的工作项。
- en: 7.4\. Summary
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 摘要
- en: You can use channels to control the lifetime of programs.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用通道来控制程序的生存期。
- en: A `select` statement with a default case can be used to attempt a nonblocking
    send or receive on a channel.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用带有默认情况的`select`语句来尝试在通道上进行非阻塞的发送或接收。
- en: Buffered channels can be used to manage a pool of resources that can be reused.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲通道可以用来管理一个可重用的资源池。
- en: The coordination and synchronization of channels is taken care of by the runtime.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道的协调和同步由运行时处理。
- en: Create a pool of goroutines to perform work using unbuffered channels.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无缓冲通道创建一个goroutine池来执行工作。
- en: Any time an unbuffered channel can be used to exchange data between two goroutines,
    you have guarantees you can count on.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可以使用未缓冲通道在两个goroutine之间交换数据的时候，你都有可以信赖的保证。
