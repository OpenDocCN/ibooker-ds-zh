- en: 13 Testing fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 测试基础
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why we test
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们要进行测试
- en: How we test
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何进行测试
- en: Test-driven development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Test doubles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试替身
- en: From JUnit 4 to 5
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从JUnit 4到5
- en: Recent years in programming have seen a growing acceptance of automated testing
    as an expected part of the development process. Tests are run both locally by
    developers and in build and continuous integration environments to ensure our
    systems are behaving. Along with that has come an explosion of different tools,
    approaches, and philosophies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，编程领域越来越接受自动化测试作为开发过程的一个预期部分。测试由开发者在本地运行，并在构建和持续集成环境中运行，以确保我们的系统表现良好。随之而来的是各种工具、方法和哲学的爆炸式增长。
- en: As with any technology, there are no silver bullets—no approach to testing will
    cover every possible situation. Given this, it’s important to understand *why*
    you are testing so that you can determine best *how* to test.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何技术一样，没有一劳永逸的解决方案——没有一种测试方法能涵盖所有可能的情况。鉴于这种情况，了解你为什么要测试非常重要，这样你才能确定最佳的测试方法。
- en: 13.1 Why we test
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 为什么我们要进行测试
- en: 'In fact, that word *test* hides a multitude of possible reasons we’re examining
    our code’s behavior. A non-exhaustive (and occasionally overlapping) list to consider
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个词“测试”隐藏了我们检查代码行为可能存在的许多原因。以下是一个非详尽（有时重叠）的考虑列表：
- en: Confirming the logic of an individual method is correct
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认单个方法的逻辑是正确的
- en: Confirming the interaction between two objects within your code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认代码中两个对象之间的交互
- en: Confirming a library or other external dependency behaves as expected
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认库或其他外部依赖按预期行为
- en: Confirming data produced or consumed by a part of the system is valid
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认系统某部分产生或消耗的数据是有效的
- en: Confirming a system works correctly with an external component (such as a database)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认系统与外部组件（如数据库）正确工作
- en: Confirming a system’s end-to-end behavior fulfills important business scenarios
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认系统的端到端行为满足重要的业务场景
- en: Documenting assumptions for later maintainers (because tests don’t get out of
    sync the same way comments and documentation can)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后来的维护者记录假设（因为测试不会像注释和文档那样同步）
- en: Influencing your system design by exposing tight coupling and object responsibilities
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过暴露紧密耦合和对象职责来影响系统设计
- en: Automating post release checklists that a human would otherwise execute
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化发布后清单，这些清单通常由人工执行
- en: Finding unexpected corner cases in code via randomized inputs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过随机输入在代码中找到意外的边缘情况
- en: 'Even this short list of testing motivations shows that the simple idea of “testing
    your code” isn’t necessarily so simple. So, when we approach testing, we need
    to ask ourselves the following questions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个简短的测试动机列表也表明，“测试你的代码”这个简单的想法并不一定那么简单。因此，当我们接近测试时，我们需要问自己以下问题：
- en: What is my motivation in testing this piece of code?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我测试这段代码的动机是什么？
- en: Which techniques let me fulfill that goal most accurately and cleanly?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些技术能让我最准确、最干净地实现这个目标？
- en: 13.2 How we test
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 我们如何进行测试
- en: One of the most common tools in discussing different types of testing is the
    Testing Pyramid, shown in figure 13.1\. Originally from Mike Cohn’s book *Succeeding
    with Agile* (Addison-Wesley Professional, 2009), the pyramid expresses one way
    of balancing the costs of different types of testing to maximize the aid they
    give us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论不同类型测试时最常用的工具之一是测试金字塔，如图13.1所示。它最初来自迈克·科恩的书籍《成功实施敏捷》（Addison-Wesley Professional，2009年），金字塔表达了一种平衡不同类型测试成本的方法，以最大化它们为我们提供的帮助。
- en: '![](../Images/CH13_F01_Evans2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F01_Evans2.png)'
- en: Figure 13.1 The Testing Pyramid
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 测试金字塔
- en: Although arguments rage on the internet about the exact boundaries between these
    types of testing, the central ideas are quite useful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管互联网上关于这些测试类型之间确切边界的争论激烈，但核心思想非常有用。
- en: Note These types of tests are *not* defined by the tool you use—you aren’t writing
    a unit test just because you are using JUnit, and using a specification library
    doesn’t guarantee you’re actually creating usable acceptance tests your stakeholders
    will benefit from. These types of tests are about what we want to exercise and
    prove.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些类型的测试不是由你使用的工具定义的——你使用JUnit并不意味着你只是在编写单元测试，使用规范库也不能保证你实际上创建了对利益相关者有益的可用的验收测试。这些类型的测试是关于我们想要练习和证明的内容。
- en: '*Unit tests* form the base of the pyramid. These are focused tests that exercise
    one aspect of a system. What do we mean, though, by “one aspect?” The easiest
    part is how the code under test relates to external dependencies. If your test
    calls the database before doing some logic on the result, that’s no longer “one”
    thing you’re testing—you’re now testing the database retrieval *and* that your
    logic works. Such external dependencies may also commonly include network services
    or files.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*构成了金字塔的基础。这些是专注于测试系统某一方面的测试。我们所说的“一方面”是什么意思呢？最容易的部分是测试代码与外部依赖项的关系。如果你的测试在逻辑处理结果之前调用数据库，那么这不再是“一个”你要测试的事物——你现在正在测试数据库检索*以及*你的逻辑是否正确。这些外部依赖项也可能包括网络服务或文件。'
- en: A common approach to avoid violating that single focus is to use *test doubles*—for
    example, having our unit test talk to a fake object instead of the real database.
    We’ll discuss this in detail in the next section, but the basic idea is that this
    fakery has many flavors and we need to consider many necessary things if it is
    to be done well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 避免违反单一关注点的一种常见方法是用*测试替身*——例如，让我们的单元测试与一个假对象通信而不是与真实的数据库通信。我们将在下一节中详细讨论这一点，但基本思想是这种欺骗有许多风味，如果要做好，我们需要考虑许多必要的事情。
- en: 'Unit tests are attractive for a number of reasons, hence their traditional
    placement as the largest segment in the testing pyramid. These reasons include
    the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试因其多个原因而具有吸引力，因此它们在测试金字塔中的传统位置是最大的部分。这些原因包括以下内容：
- en: '*Fast*—If a test has no external dependencies, it shouldn’t take long to execute.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速*——如果一个测试没有外部依赖项，它的执行时间不应该很长。'
- en: '*Focused*—By talking only about one “unit” of code, it’s often clearer what
    the test is expressing than in larger, more setup-laden tests.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*专注*——通过只讨论一个“单元”的代码，测试所表达的内容通常比在更大、设置更复杂的测试中更清晰。'
- en: '*Reliable failure*—Minimizing external dependencies, especially dependencies
    on external state, helps make unit tests more deterministic.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可靠的失败*——最小化外部依赖项，特别是对外部状态的依赖，有助于使单元测试更加确定。'
- en: 'This all sounds great, so why don’t we write only unit tests all the time?
    The truth is that unit tests have limitations that prevent them from being useful
    at every scale that we need to test at. The issues include the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都听起来很棒，那么为什么我们不是一直只写单元测试呢？事实是，单元测试有其局限性，这阻止了它们在需要测试的每个规模上都有用。问题包括以下内容：
- en: '*Tight coupling*—Because unit tests are by definition closely related to their
    implementation, they are also prone to binding too tightly to those implementation
    choices. It’s not uncommon for a whole suite of unit tests to be invalidated when
    the underlying implementation changes.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*紧密耦合*——由于单元测试本质上与其实现紧密相关，它们也容易过于紧密地绑定到那些实现选择上。当底层实现发生变化时，整个单元测试套件失效的情况并不少见。'
- en: '*Missing meaningful interactions*—Although it’s attractive to think about our
    code as a fleet of objects all just minding their own business, the reality is
    that the real work of a program includes interaction between those dependent pieces,
    which unit tests will miss.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺失有意义的交互*——虽然将我们的代码视为一队只关心自己事务的对象很有吸引力，但现实是程序的真正工作包括这些依赖部分之间的交互，而单元测试可能会错过这些交互。'
- en: '*Inwardly focused*—Often the goal of testing is showing that the end users
    of our software get the right results. Rarely does a single method’s correctness
    actually translate to happy users.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内部关注*——测试的目标通常是证明我们的软件最终用户得到了正确的结果。很少有一个方法的正确性实际上会转化为满意的用户。'
- en: '*Integration tests*, the next step up the pyramid, break free from the constraint
    of unit tests about talking to dependencies. Integration tests cross those boundaries
    and may in fact focus on ensuring different pieces of the system integrate seamlessly.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*，金字塔的下一步，摆脱了单元测试中与依赖项通信的限制。集成测试跨越这些边界，实际上可能专注于确保系统的不同部分能够无缝集成。'
- en: As with unit tests, integration tests may also pick and choose only parts of
    the system to exercise. Some dependencies, such as external services, may still
    be replaced by test doubles, whereas others, such as databases, are in bounds
    for testing. What’s key is that the tests reach out beyond a single “unit” of
    code in their scope.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试一样，集成测试也可以选择只测试系统的部分。一些依赖项，如外部服务，可能仍然可以用测试替身来替换，而其他依赖项，如数据库，则适合进行测试。关键在于，测试的范围超出了单个“单元”代码。
- en: 'The exact line between unit and integration tests can be blurry. Here are some
    examples, though, which clearly step over the line into integration testing territory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和集成测试之间的确切界限可能很模糊。尽管如此，以下是一些明显跨越界限进入集成测试领域的例子：
- en: You need a database instance and make calls to your data access code.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个数据库实例，并调用你的数据访问代码。
- en: You spin up a special in-process HTTP server and test requests against it.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你启动一个特殊的进程内HTTP服务器，并对其发起测试请求。
- en: You make actual calls against another service (whether or not a testing environment).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会对另一个服务进行实际调用（无论是否在测试环境中）。
- en: 'Integration tests come with a lot of nice properties, such as the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试具有许多不错的特性，如下所示：
- en: '*Broader coverage*—An integration test necessarily works more of your code
    and the code of the libraries you depend on.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更广泛的覆盖范围*——集成测试必然需要测试更多的代码以及你依赖的库的代码。'
- en: '*More validation*—Certain types of errors may be detectable only when using
    real dependencies. For instance, a syntax error in a SQL statement will be difficult
    to find without calling an actual database.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更多验证*——某些类型的错误可能只有在使用真实依赖项时才能检测到。例如，SQL语句中的语法错误在没有调用实际数据库的情况下很难找到。'
- en: 'Of course, no choice is without its trade-offs. Integration tests can be a
    source of significant pain if not managed correctly for reasons such as the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有选择是没有权衡的。如果管理不当，集成测试可能会成为痛苦之源，原因如下：
- en: '*Slow tests*—Going to a real database instead of reading a value from memory
    is drastically slower. Multiply that by hundreds or thousands of tests, and you
    may find yourself waiting... a lot.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*慢速测试*——访问真实数据库而不是从内存中读取值要慢得多。将这一点乘以数百或数千次测试，你可能会发现自己等待……很长时间。'
- en: '*Nondeterministic results*—External dependencies increase the chances that
    important state may change between test runs. For instance, records left over
    in a database might alter what comes back from a SQL statement.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非确定性结果*——外部依赖增加了重要状态可能在测试运行之间发生变化的可能性。例如，数据库中留下的记录可能会改变SQL语句返回的内容。'
- en: '*False confidence*—Integration tests sometimes use dependencies that differ
    subtly from those of the main system. For instance, if the test database is a
    different version than production, the integration test may incorrectly suggest
    everything is good when it isn’t.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚假信心*——集成测试有时使用与主系统略有不同的依赖项。例如，如果测试数据库的版本与生产不同，集成测试可能会错误地建议一切正常，而实际上并非如此。'
- en: For all those difficulties, integration testing is a critical part of the testing
    landscape.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些困难，集成测试是测试领域的一个关键部分。
- en: '*End-to-end tests* push beyond integration tests with the aim of duplicating
    the full user experience of a system. This may mean programmatically driving a
    web browser or other application, or exercising a fully deployed instance of a
    service in a testing environment. End-to-end testing brings the following advantages
    that are difficult to duplicate at lower levels of our systems:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*端到端测试*超越了集成测试，目的是复制系统的完整用户体验。这可能意味着通过程序驱动网络浏览器或其他应用程序，或者在测试环境中操作服务的完全部署实例。端到端测试带来了以下难以在系统较低级别复制的优势：'
- en: '*The “real” user experience*—A good end-to-end test is close to what users
    see. This lets us validate the users’ high-level expectations directly.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*“真实”用户体验*——一个好的端到端测试接近用户所看到的内容。这让我们能够直接验证用户的高层次期望。'
- en: '*A “real” environment*—Many end-to-end tests run against test, staging, or
    even production environments. This validates that our code works outside of our
    comfortable, carefully managed build environment.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*“真实”环境*——许多端到端测试是在测试、预发布或甚至生产环境中运行的。这验证了我们的代码在舒适、精心管理的构建环境之外也能正常工作。'
- en: '*UI available*—Many end-to-end testing approaches, such as those that drive
    web browsers, can see aspects of the system (e.g., was the button rendered, so
    it can be clicked) that may be difficult to validate anywhere else.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UI可用性*——许多端到端测试方法，如驱动网络浏览器的那些，可以查看系统的某些方面（例如，按钮是否渲染，因此可以点击），这些在其他地方可能很难验证。'
- en: 'But this greater reality in our end-to-end tests comes with the next stark
    list of difficulties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种在我们端到端测试中的更大现实也伴随着下一个严峻的困难列表：
- en: '*Even slower testing*—Where many unit tests run almost instantly and even integration
    tests can often be sub-second, an end-to-end test controlling a web browser to
    walk through a site will necessarily take much longer to run.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更慢的测试*—在许多单元测试几乎瞬间运行，甚至集成测试通常也能在几秒内完成的情况下，控制网络浏览器遍历网站的全链路测试必然需要更长的时间来运行。'
- en: '*Flaky tests*—Historically, the tools for end-to-end testing, particularly
    of UIs, have been prone to flakiness, requiring retries and long timeouts to avoid
    unnecessary failures.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不稳定的测试*—从历史上看，端到端测试的工具，尤其是UI测试，容易出问题，需要重试和长时间的超时来避免不必要的失败。'
- en: '*Brittle tests*—Because end-to-end tests live at the top of the pyramid, changes
    at any level below can cause failure. Seemingly innocuous text changes can unintentionally
    break these sprawling tests.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*脆弱的测试*—因为端到端测试位于金字塔的顶部，任何低于这一级别的更改都可能导致失败。看似无害的文本更改可能会无意中破坏这些庞大的测试。'
- en: '*Harder debugging*—Because end-to-end testing often introduces another layer
    that drives the tests, figuring out what went wrong is often a chore.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更难的调试*—因为端到端测试通常引入了另一个驱动测试的层，找出什么出了问题通常是一项繁琐的工作。'
- en: With this pyramid in hand, you may be tempted to ask, “What’s the right ratio
    of tests between the layers?” The truth is that there is no single answer. The
    needs of every project and system are different. But the pyramid can help guide
    you in the pluses and minuses of how you choose to exercise each bit of functionality
    in your system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个金字塔，你可能会想问，“层与层之间正确的测试比例是多少？”事实是，没有唯一的答案。每个项目和系统的需求都不同。但金字塔可以帮助你指导你在选择如何测试系统中的每个功能部分时的利弊。
- en: Although certainly not the only way, the well-grounded developer may find that
    test-driven development helps in keeping these different levels of testing clear
    as systems evolve.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这肯定不是唯一的方法，但经验丰富的开发者可能会发现，随着系统的演变，测试驱动开发有助于保持不同级别测试的清晰。
- en: 13.3 Test-driven development
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 测试驱动开发
- en: Test-driven development (TDD) has been part of the software development industry
    for quite some time. Its basic premise is that you write tests during your implementation
    rather than afterward, and those tests influence the design of your code. A commonly
    recommended approach to TDD, known as test first, is to actually write a failing
    test before providing an implementation, then refactoring as needed. For example,
    to write an implementation of concatenating two string objects (`"foo"` and `"bar"`),
    you’d write the test first (testing the result must equal `"foobar"`) to ensure
    that you know your implementation is correct. Though many developers write tests,
    more often than not, they’re writing them after the implementation and losing
    some major benefits of TDD.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）已经软件开发生业中存在了一段时间。其基本前提是在实现过程中编写测试，而不是之后，这些测试会影响代码的设计。一个常见的TDD方法，称为测试先行，是实际编写一个失败的测试，然后再提供实现，根据需要重构。例如，要编写两个字符串对象（`"foo"`和`"bar"`）的连接实现，你首先编写测试（测试结果必须等于`"foobar"`），以确保你知道你的实现是正确的。尽管许多开发者编写测试，但往往是在实现之后，从而失去了TDD的一些主要好处。
- en: Despite its seeming pervasiveness, many developers don’t understand why they
    should be doing TDD. The question for many developers remains, “Why write test-driven
    code? What’s the benefit?”
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看似无处不在，但许多开发者并不理解为什么他们应该进行测试驱动开发。许多开发者的疑问仍然是，“为什么编写测试驱动代码？有什么好处？”
- en: 'We believe that *eliminating fear and uncertainty* is the overriding reason
    you should write test-driven code. Kent Beck (co-inventor of the JUnit testing
    framework) also sums this up nicely in his book, *Test-Driven Development: By
    Example* (Addison-Wesley Professional, 2002):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信，*消除恐惧和不确定性*是你应该编写测试驱动代码的压倒性原因。Kent Beck（JUnit测试框架的共同发明者）也在他的书中很好地总结了这一点，*测试驱动开发：通过示例*（Addison-Wesley
    Professional，2002）：
- en: Fear makes you tentative.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恐惧会让你变得犹豫不决。
- en: Fear makes you want to communicate less.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恐惧会让你想要减少沟通。
- en: Fear makes you shy away from feedback.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恐惧会让你回避反馈。
- en: Fear makes you grumpy.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恐惧会让你变得易怒。
- en: 'TDD takes away the fear, making the well-grounded Java developer a more confident,
    communicative, receptive, and happier developer. In other words, TDD helps you
    break free from the mind-set that leads to statements like these:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TDD消除了恐惧，使经验丰富的Java开发者变得更加自信、善于沟通、乐于接受并更快乐。换句话说，TDD帮助你摆脱了导致这些陈述的心态：
- en: When starting a new piece of work, “I don’t know where to start, so I’ll just
    start hacking.”
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开始一项新的工作时，“我不知道从哪里开始，所以我只会开始乱搞。”
- en: When changing existing code, “I don’t know how the existing code is going to
    behave, so I’m secretly too scared to change it.”
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当更改现有代码时，“我不知道现有代码会如何表现，所以我秘密地太害怕去更改它。”
- en: 'TDD brings many other benefits that aren’t always immediately obvious, such
    as the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: TDD带来了许多其他好处，这些好处并不总是立即明显，如下所示：
- en: '*Cleaner code*—You write only the code you need.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更干净的代码*—您只编写所需的代码。'
- en: '*Better design*—Some developers call TDD *test-driven design*.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更好的设计*—一些开发者称TDD为*测试驱动设计*。'
- en: '*Better APIs*—Your tests serve as an additional client to the implementation,
    revealing rough spots early.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更好的API*—您的测试充当实现的一个额外客户端，可以提前揭示粗糙之处。'
- en: '*Greater flexibility*—TDD encourages coding to interfaces.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更大的灵活性*—TDD鼓励编写接口代码。'
- en: '*Documentation through tests*—Because you don’t write code without a test,
    everything has example usage in the tests.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过测试进行文档化*—因为您不会在没有测试的情况下编写代码，所以所有内容都在测试中有示例用法。'
- en: '*Fast feedback*—You learn about bugs *now*, not in production.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速反馈*—您现在就了解有关错误的信息，而不是在生产中。'
- en: One barrier for developers who are just getting started is that TDD can sometimes
    be viewed as a technique that isn’t used by “ordinary” developers. The perception
    can be that only practitioners of some imaginary “Church of Agile” or other esoteric
    movement use TDD, and that every TDD principle must be followed strictly to gain
    the benefits. This perception is completely false, as we’ll demonstrate. TDD is
    a technique for every developer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始接触的开发者来说，一个障碍是TDD有时可能被视为“普通”开发者不使用的技巧。这种看法可能是，只有某些想象中的“敏捷教会”或其他神秘运动的实践者使用TDD，并且必须严格遵循每个TDD原则才能获得好处。这种看法是完全错误的，我们将证明这一点。TDD是每个开发者的技巧。
- en: 13.3.1 TDD in a nutshell
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 TDD概述
- en: TDD is easiest at the unit-testing level, and if you’re unfamiliar with TDD,
    this is a good place to start. We’ll start there, but proceed to show how TDD
    works, in particular on the boundary of unit and integration testing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在单元测试级别上最容易，如果您不熟悉TDD，这是一个好的起点。我们将从这里开始，但会展示TDD是如何工作的，特别是在单元测试和集成测试的边界上。
- en: Note Dealing with existing code that has very few or no tests can be a daunting
    task. It’s almost impossible to retroactively fill in all of the tests. Instead,
    you should simply add tests for each new bit of functionality that you add. See
    Michael Feathers’s excellent book *Working Effectively with Legacy Code* (Prentice
    Hall, 2004) for further help.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意处理具有非常少或没有测试的现有代码可能是一项艰巨的任务。几乎不可能事后填充所有测试。相反，您应该为添加的每个新功能添加测试。有关进一步的帮助，请参阅Michael
    Feathers的杰出著作《与遗留代码有效工作》（Prentice Hall，2004）。
- en: We’ll start with brief coverage of the red-green-refactor premise behind TDD,
    using JUnit to test-drive code for calculating sales revenue for selling theater
    tickets. If the JUnit framework is unfamiliar, we recommend the online user guides
    (see [https://junit.org/junit5/docs/current/user-guide](https://junit.org/junit5/docs/current/user-guide))
    or, for more detail, *JUnit in Action* by Cătălin Tudose (Manning, 2020; [http://mng.bz/gwOR](http://mng.bz/gwOR)).
    Let’s start with a working example of the three basic steps of TDD—the red-green-refactor
    loop—by calculating the revenue when selling theater tickets.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对TDD背后的红-绿-重构前提的简要覆盖开始，使用JUnit来测试驱动计算售票销售收入的代码。如果JUnit框架不熟悉，我们建议查看在线用户指南（见[https://junit.org/junit5/docs/current/user-guide](https://junit.org/junit5/docs/current/user-guide)）或，如需更详细的信息，请参阅Cătălin
    Tudose的《JUnit实战》（Manning，2020；[http://mng.bz/gwOR](http://mng.bz/gwOR)）。让我们从一个TDD三个基本步骤的工作示例——红-绿-重构循环——开始，通过计算售票收入来计算收入。
- en: 13.3.2 A TDD example with a single use case
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 单个用例的TDD示例
- en: 'If you’re an experienced TDD practitioner, you may want to skip this small
    example, although we’ll offer insights that may be new. Suppose you’ve been asked
    to write a rock-solid method to calculate the revenue generated by selling a number
    of theater tickets. The initial business rules from the theater company’s accountant
    are simple, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是经验丰富的TDD实践者，您可能想跳过这个小型示例，尽管我们还会提供可能的新见解。假设您被要求编写一个坚如磐石的方法来计算销售一定数量戏院票所产生收入。剧院公司会计的初始业务规则很简单，如下所示：
- en: The baseline price of a ticket is $30.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 票的基准价格是30美元。
- en: Total revenue = number of tickets sold * price.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总收入 = 售出票数 * 价格。
- en: The theater seats = 100 people.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 戏院座位 = 100人。
- en: Because the theater doesn’t have very good point-of-sale software, the user
    currently has to manually enter the number of tickets sold.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于戏院没有非常好的销售点软件，用户目前必须手动输入售出的票数。
- en: 'If you have practiced TDD, you’ll be familiar with the three basic steps of
    TDD: red, green, refactor. If you’re new to TDD or are looking for a little refresher,
    let’s take a look at Kent Beck’s definition of those steps, from *Test-Driven
    Development: By Example* :'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经实践过TDD，你将熟悉TDD的三个基本步骤：红色、绿色、重构。如果你是TDD的新手或者需要一点复习，让我们来看看Kent Beck在《测试驱动开发：通过示例》中对这些步骤的定义：
- en: '*Red*—Write a little test that doesn’t work (failing test).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*红色*—编写一个不起作用的测试（失败的测试）。'
- en: '*Green*—Make that test pass as quickly as possible (*passing test*).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绿色*—尽可能快地使测试通过（*通过测试*）。'
- en: '*Refactor*—Eliminate the duplication (*refined passing test*).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构*—消除重复（*精炼通过测试*）。'
- en: 'To give you an idea of the `TicketRevenue` implementation that we’re trying
    to achieve, here is some pseudocode you might have in your head:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个我们试图实现的`TicketRevenue`实现的思路，这里有一些你可能在脑海中的一些伪代码：
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that it’s important that you don’t think too deeply about this. The tests
    will end up driving your design and partly your implementation, too.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不必对此想得太深。测试将最终驱动你的设计和部分实现。
- en: Writing a failing test (red)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编写失败的测试（红色）
- en: The point in this step is to start with a test that fails. In fact, the test
    won’t even compile, because you haven’t even written a `TicketRevenue` class yet!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中的目的是从一个失败的测试开始。事实上，测试甚至无法编译，因为你还没有编写一个`TicketRevenue`类！
- en: 'After a brief whiteboard session with the accountant, you realize that you’ll
    want to write tests for five cases: ticket sales that are negative, `0`, `1`,
    `2–100`, and `> 100`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在与会计简短的白板会议后，你意识到你将需要为以下五种情况编写测试：负数的票销售、`0`、`1`、`2–100`和`> 100`。
- en: Note A good rule of thumb when writing tests (especially involving numbers)
    is to think of the zero/`null` case, the one case, and the many (*N*) case. A
    step beyond that is to think about other constraints on *N*, such as a negative
    amount or an amount beyond a maximum limit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 写测试时（尤其是涉及数字时）的一个好规则是考虑零/`null`情况、一个情况以及许多（*N*）情况。在这一点上更进一步是考虑对*N*的其他约束，例如负数或超过最大限制的金额。
- en: 'To begin, you decide to write a test that covers the revenue received from
    one ticket sale. Your JUnit test would look similar to the following code (remember
    we’re not writing a perfect, passing test at this stage):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你决定编写一个测试，覆盖一张票销售所收到的收入。你的JUnit测试将类似于以下代码（记住我们在这个阶段不是在编写一个完美的、通过测试）：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ One sold case
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个已售出的案例
- en: As you can see from the code, the test quite clearly expects the revenue from
    one ticket sale to equal 30 in revenue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码中的测试非常清楚地期望一张票的销售收入等于30。
- en: 'But as it stands, this test won’t compile, because you haven’t written a `TicketRevenue`
    class with the `estimateTotalRevenue(int numberOfTicketsSold)` method. To make
    the compilation error go away so that you can run the test, you can add a random
    implementation so that the test will compile, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但就目前而言，这个测试无法编译，因为你还没有编写一个包含`estimateTotalRevenue(int numberOfTicketsSold)`方法的`TicketRevenue`类。为了消除编译错误以便运行测试，你可以添加一个随机实现，使测试能够编译，如下所示：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may also find it a bit odd that the test extracts a mutable `venueRevenue`
    field when our general advice has been to favor immutability. The reasoning behind
    this is that the shared field allows us to express a common setup between our
    (soon-to-arrive) different test cases. Our tests don’t need the same protections
    as our production code, and the increased clarity of highlighting which bits are
    the same between all the test cases is a win overall.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得测试提取一个可变的`venueRevenue`字段有点奇怪，因为我们的一般建议是优先考虑不可变性。背后的理由是，共享字段允许我们在（即将到来的）不同的测试用例之间表达一个共同的设置。我们的测试不需要与我们的生产代码相同的保护，而且突出显示所有测试用例之间相同的部分，提高了整体的可读性。
- en: Now that the test compiles, you can run it from your favorite IDE or the command
    line. For the command-line test, our typical options of Gradle and Maven both
    provide easy ways to run tests (`gradle test` or `mvn test`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试可以编译了，你可以从你喜欢的IDE或命令行运行它。对于命令行测试，Gradle和Maven都提供了运行测试的简单方法（`gradle test`或`mvn
    test`）。
- en: Note IDEs also have their own individual ways of running JUnit tests, but generally
    speaking, they all allow you to right-click on the test class for a Run Test option.
    Once you do that, the IDE will display a window or section that informs you that
    your test has failed, because the expected value of 30 was not returned by the
    call to `estimateTotalRevenue(1)`; instead, 0 was returned.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：IDEs也有它们自己运行JUnit测试的独特方式，但一般来说，它们都允许你右键单击测试类以获取运行测试选项。一旦你这样做，IDE将显示一个窗口或部分，告诉你你的测试失败了，因为调用`estimateTotalRevenue(1)`没有返回预期的30，而是返回了0。
- en: Now that you have a failing test, the next step is to make the test pass (go
    green).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个失败的测试，下一步是让测试通过（变为绿色）。
- en: Writing a passing test (green)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编写通过测试（绿色）
- en: The point in this step is to make the test pass, but the implementation doesn’t
    have to be perfect. By providing the `TicketRevenue` class with a better implementation
    of `estimateTotalRevenue()` (an implementation that doesn’t just return 0), you’ll
    make the test pass (go green).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的目的就是让测试通过，但实现不一定要完美。通过为`TicketRevenue`类提供一个更好的`estimateTotalRevenue()`实现（一个不仅仅返回0的实现），你会让测试通过（变为绿色）。
- en: 'Remember, at this stage, you’re trying to make the test pass without necessarily
    writing perfect code. Your initial solution might look something like the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在这个阶段，你试图让测试通过，而不一定需要编写完美的代码。你的初始解决方案可能看起来像以下代码：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ An implementation that passes the test
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过测试的实现
- en: When you now run the test, it will pass, and in most IDEs, that will be indicated
    with a green bar or tick. Even our command lines give us a friendly green message
    to let us know all is well with the code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行测试时，它将通过，在大多数IDE中，这将以绿色条或勾号表示。即使是我们的命令行也会给我们一个友好的绿色消息，让我们知道代码一切正常。
- en: The next question is, should you then say “I’m done!” and move on to the next
    bit of work? The resounding answer here should be “No!” Like us, you’ll be itching
    to tidy up the previous code listing, so let’s get into that right now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是你是否可以说“我完成了！”然后继续下一项工作？响亮的答案应该是“不！”像我们一样，你可能会迫不及待地整理之前的代码列表，所以让我们现在就着手做吧。
- en: Refactoring the test
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重构测试
- en: The point of this step is to look at the quick implementation you wrote to pass
    the test and make sure that you’re following accepted practice. Clearly the code
    isn’t as clean and tidy as it could be. You can certainly refactor it and improve
    life for yourself and others in the future.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的目的就是查看你为了通过测试而编写的快速实现，并确保你遵循了公认的实践。显然，代码并不像它本可以的那样干净整洁。你当然可以重构它，并为将来自己和他人改善生活。
- en: Remember, now that you have a passing test, you can *refactor without fear*.
    There’s no chance of losing sight of the business logic that you’ve implemented
    so far.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，现在你已经通过了考试，你可以*无惧重构*。你不会失去迄今为止所实现的企业逻辑的视线。
- en: tip Another benefit that you’ve given yourself and the broader team by writing
    the initial passing test is a faster overall development process. The rest of
    the team can immediately take this first version of the code and begin to test
    it alongside the larger codebase (for integration tests and beyond).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：通过编写初始通过测试，你已经给自己和更广泛的团队带来了一个好处，那就是更快的整体开发过程。其他团队成员可以立即使用这个代码的第一个版本，并开始与更大的代码库一起测试它（用于集成测试等）。
- en: 'In this example, you don’t want to be using magic numbers—you want to make
    sure that the ticket price of 30 is a named concept in the code—so we write the
    following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你不想使用魔法数字——你想要确保30元的票价在代码中是一个命名的概念——所以我们编写以下代码：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ No magic number
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 没有魔法数字
- en: ❷ Refactored calculation
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重构后的计算
- en: The refactoring has improved the code, but clearly it doesn’t cover all potential
    use cases (e.g., negative, `0`, `2–100`, and `> 100` ticket sales).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重构改进了代码，但显然它没有涵盖所有潜在用例（例如，负数、`0`、`2–100`和`> 100`张票的销售）。
- en: Instead of trying to guess what the implementation should look like for the
    other use cases, you should have further tests drive the design and the implementation.
    The next section follows test-driven design by taking you through more use cases
    in this ticket revenue example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图猜测其他用例的实现应该是什么样子，你应该让进一步的测试来驱动设计和实现。下一节通过在这个票据收入示例中展示更多用例，遵循测试驱动设计。
- en: A TDD example with multiple use cases
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多种用例的TDD示例
- en: One particular style of TDD would continue to add one test at a time for the
    negative, `0`, `2–100`, and `> 100` ticket sale test cases we presented before.
    But it’s entirely valid to write a set of test cases up front, especially if they’re
    related to the original test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特定的TDD风格会持续地一次添加一个测试用例，针对我们之前提出的负数、`0`、`2–100`和`> 100`的票务销售测试用例。但提前编写一组测试用例是完全有效的，尤其是如果它们与原始测试相关。
- en: 'Note that it’s still very important to follow the red-green-refactor lifecycle
    here. After adding all of these use cases, you might end up with a test class
    with failing tests (red) as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里遵循红-绿-重构生命周期仍然非常重要。在添加所有这些用例后，你可能会得到一个有失败测试（红色）的测试类，如下所示：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Negative sold case
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 负数售出情况
- en: ❷ 0 sold case
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 未售出0张票的情况
- en: ❸ 1 sold case
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 售出1张票的情况
- en: ❹ N sold case
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 售出N张票的情况
- en: ❺ > 100 sold case
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 售出超过100张票的情况
- en: 'The initial basic implementation to pass all of those tests (green) would then
    look something like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通过所有这些测试（绿色）的初始基本实现可能看起来如下：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Exceptional cases
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 异常情况
- en: ❷ Exceptional cases
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 异常情况
- en: ❸ N sold case
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 已售N张票的情况
- en: With the implementation just completed, you now have passing tests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚完成实现后，你现在有了通过的所有测试。
- en: 'Again, by following the TDD lifecycle, you’ll now refactor that implementation.
    For example, you could combine the illegal `numberOfTicketsSold` cases (< 0 or
    > 100) into one `if` statement and use a formula (`TICKET_PRICE * numberOfTicketsSold`)
    to return the revenue for all other legal values of `numberOfTicketsSold`. The
    following code should be similar to what you would come up with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，通过遵循TDD生命周期，你现在将重构该实现。例如，你可以将非法的`numberOfTicketsSold`情况（小于0或大于100）合并为一个`if`语句，并使用公式（`TICKET_PRICE
    * numberOfTicketsSold`）来返回所有其他合法`numberOfTicketsSold`值的收入。以下代码应类似于你可能会想到的：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Exceptional case
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 异常情况
- en: ❷ All other cases
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有其他情况
- en: The `TicketRevenue` class is now far more compact and yet still passes all of
    the tests! You’ve completed the full red-green-refactor cycle and can confidently
    move on to your next piece of business logic. Alternatively, you can start the
    cycle again, should you (or the accountant) spot any edge cases you’ve missed,
    such as having a variable ticket price.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`TicketRevenue`类现在更加紧凑，但仍通过所有测试！你已经完成了完整的红-绿-重构周期，可以自信地继续你的下一部分业务逻辑。或者，如果你（或会计）发现了任何遗漏的边缘情况，例如可变票价，你可以再次开始这个周期。'
- en: 13.4 Test doubles
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 测试替身
- en: As you continue to write code in a TDD style, you’ll quickly run into the situation
    where your code references some (often third-party) dependency or subsystem. In
    this situation, you’ll typically want to ensure that the code under test is isolated
    from that dependency to ensure that you’re writing test code only against what
    you’re actually building. You’ll also want the tests to run as quickly as possible,
    especially if you’re aiming to write unit rather than integration tests. Invoking
    a third-party dependency or subsystem, such as a database, can take a lot of time,
    which means you lose the fast feedback benefit of TDD. *Test doubles* are the
    solution to this problem.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续以TDD风格编写代码时，你很快会遇到代码引用某些（通常是第三方）依赖或子系统的情形。在这种情况下，你通常会想确保正在测试的代码与该依赖项隔离，以确保你只编写针对你实际构建内容的测试代码。你还会希望测试尽可能快地运行，特别是如果你旨在编写单元测试而不是集成测试。调用第三方依赖或子系统，如数据库，可能需要很长时间，这意味着你失去了TDD的快速反馈优势。*测试替身*是解决这个问题的方案。
- en: In this section, you’ll learn how a test double can help you to effectively
    isolate dependencies and subsystems. You’ll work through examples that use the
    four types of test double (dummy, stub, fake, and mock). We’ll also look at some
    of the perils and difficulties test doubles bring alongside their benefits.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解测试替身如何帮助你有效地隔离依赖和子系统。你将通过使用四种测试替身类型（模拟、存根、伪造和模拟）的示例来操作。我们还将探讨测试替身带来的风险和困难，以及它们的优点。
- en: 'We like Gerard Meszaros’s simple explanation of a test double in his *xUnit
    Test Patterns* book (Addison-Wesley Professional, 2007), so we’ll gladly quote
    him here: “A *Test Double* (think Stunt Double) is the generic term for any kind
    of pretend object used in place of a real object for testing purposes.”'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢Gerard Meszaros在他的《xUnit Test Patterns》一书中对测试替身的简单解释（Addison-Wesley Professional,
    2007），所以我们很乐意在这里引用他：“*测试替身*（想想特技替身）是任何用于测试目的而代替真实对象的虚拟对象的通用术语。”
- en: Meszaros defines four kinds of test doubles, which are outlined in table 13.1.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Meszaros定义了四种测试替身类型，这些类型在表13.1中概述。
- en: Table 13.1 The four types of test doubles
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.1 四种测试双胞胎类型
- en: '| Type | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Dummy | An object that is passed around but never used; typically used to
    fulfill the parameter list of a method |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟对象 | 一个被传递但从未使用的对象；通常用于满足方法参数列表 |'
- en: '| Stub | An object that always returns the same canned response; may also hold
    some dummy state |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 存根 | 总是返回相同预定义响应的对象；也可能持有一些虚拟状态 |'
- en: '| Fake | An actual working implementation (not of production quality or configuration)
    that can replace the real implementation |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 一个实际工作的实现（不是生产质量或配置），可以替换真实实现 |'
- en: '| Mock | An object that represents a series of expectations and provides canned
    responses |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 代表一系列期望并提供预定义响应的对象 |'
- en: The four types of test doubles are far easier to understand when you work through
    code examples that use them. Let’s go do that now, starting with the dummy object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过使用它们的代码示例来理解四种测试双胞胎类型时，它们就变得容易理解得多。现在让我们开始做，从虚拟对象开始。
- en: 13.4.1 Dummy object
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 虚拟对象
- en: A *dummy* object is the easiest of the four test double types to use. Remember,
    it’s designed to help fill parameter lists or fulfill some mandatory field requirements
    where you know the object will never get used. In many cases, you can even pass
    in an empty object (or even `null`, although this is not guaranteed to be safe).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*虚拟*对象是四种测试双胞胎类型中最容易使用的。记住，它被设计用来帮助填充参数列表或满足你知道对象永远不会被使用的某些强制字段要求。在许多情况下，你甚至可以传递一个空对象（甚至`null`，尽管这并不保证是安全的）。
- en: Let’s go back to the theater tickets scenario. It’s all very good having an
    estimate of the revenue coming in from your single kiosk, but the owners of the
    theater have started to think a bit bigger. Better modeling of the tickets sold
    and the revenue expected is needed, and you hear murmurings of more requirements
    and complexity coming down the pipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到剧院票的情景。对你单一售票亭的收入进行估计是非常好的，但剧院的所有者已经开始考虑得更大一些。需要更好地建模已售出的票和预期的收入，你听到更多要求和复杂性的低语。
- en: 'You’ve been asked to keep track of the tickets sold, and to allow for a 10%
    discounted price on some tickets. It looks like you’re going to need a `Ticket`
    class that provides a discounted price method. You start the familiar TDD cycle
    with a failing test, focusing on a new `getDiscountPrice()` method. You also know
    that there will need to be a couple of constructors: one for a regular-priced
    ticket, and one where the face value of the ticket may vary. The `Ticket` object
    will ultimately expect the following two arguments:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求跟踪已售出的票，并允许某些票享受10%的折扣价格。看起来你需要一个`Ticket`类来提供折扣价格方法。你从熟悉的TDD周期开始，用一个失败的测试，专注于新的`getDiscountPrice()`方法。你还知道将需要几个构造函数：一个用于普通价格的票，另一个票面价值可能不同。`Ticket`对象最终将期望以下两个参数：
- en: '*The client name*—A `String` that won’t be referenced at all for this test'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端名称*——一个在此测试中根本不会被引用的`String`'
- en: '*The normal price*—A `BigDecimal` that will get used for this test'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正常价格*——一个将用于此测试的`BigDecimal`'
- en: 'You’re pretty sure that the client name won’t be referenced in the `getDiscountPrice()`
    method. This means you can pass the constructor a dummy object (in this case,
    the arbitrary string `"Riley"`), as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你相当确定客户端名称在`getDiscountPrice()`方法中不会被引用。这意味着你可以向构造函数传递一个虚拟对象（在这种情况下，任意的字符串`"Riley"`），如下面的代码所示：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates a dummy object
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个虚拟对象
- en: ❷ Passes in a dummy object
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 传递一个虚拟对象
- en: As you can see, the concept of a dummy object is trivial.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，虚拟对象的概念是微不足道的。
- en: 'To make the concept extremely clear, the code in the following snippet has
    a partial implementation of the `Ticket` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使概念非常清晰，以下代码片段中有一个`Ticket`类的部分实现：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The default price
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 默认价格
- en: ❷ The default discount
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 默认折扣
- en: 'Some developers become confused by dummy objects—they look for complexity that
    doesn’t exist. Dummy objects are very straightforward: they’re any old object
    used to avoid `NullPointerException` and to get the code to run.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者被虚拟对象搞糊涂了——他们寻找并不存在的复杂性。虚拟对象非常简单：它们是任何旧对象，用于避免`NullPointerException`并使代码运行。
- en: Let’s move on to the next type of test double. The next step up (in terms of
    complexity) is the stub object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一种测试双胞胎类型。在复杂性方面，下一步是存根对象。
- en: 13.4.2 Stub object
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 存根对象
- en: You typically use a *stub* object when you want to replace a real implementation
    with an object that will return the same response every time. Let’s return to
    our theater ticket pricing example to see this in action.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要用一个每次都会返回相同响应的对象替换真实实现时，通常使用 *存根* 对象。让我们回到我们的剧院票价定价示例，看看它是如何发挥作用的。
- en: You’ve come back from a well-deserved holiday after implementing the `Ticket`
    class, and the first thing in your inbox is a bug report stating that your `tenPercentDiscount()`
    test is now failing intermittently. When you look into the codebase, you see that
    the `Ticket` class is now using a concrete `HttpPrice` class that implements a
    newly introduced `Price` interface. As the name suggests, `HttpPrice` contacts
    an external website and can return different values—or fail—at any point.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你在实现了 `Ticket` 类之后，从一次应得的假期中回来，你的收件箱中的第一件事是一份错误报告，指出你的 `tenPercentDiscount()`
    测试现在间歇性地失败。当你查看代码库时，你会发现 `Ticket` 类现在使用一个具体的 `HttpPrice` 类，该类实现了新引入的 `Price` 接口。正如其名所示，`HttpPrice`
    会联系外部网站，并可能在任何时刻返回不同的值或失败。
- en: This is making the test fail, but further has polluted the purpose of our test.
    Remember, all you wanted was to unit-test calculating the 10% discount!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试失败，但进一步污染了我们的测试目的。记住，你只是想单元测试计算 10% 折扣！
- en: Note Calling a third-party pricing site is certainly not part of this test’s
    responsibility. Separate integration tests should cover the `HttpPrice` class
    and its third-party `HttpPricingService`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：调用第三方定价网站绝对不是本测试的责任。应该有单独的集成测试来覆盖 `HttpPrice` 类及其第三方 `HttpPricingService`。
- en: 'To get our test back to a consistent, stable point, we will replace the `HttpPrice`
    class with a stub instead. First, let’s take a look at the current state of the
    code, as shown in the three following code snippets:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的测试回到一致、稳定的状态，我们将用存根替换 `HttpPrice` 类。首先，让我们看看当前代码的状态，如下面的三个代码片段所示：
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ HttpPrice implements Price.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ HttpPrice 实现 Price 接口。
- en: ❷ Creates Ticket
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建票据
- en: ❸ The test can fail.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试可能会失败。
- en: 'The next snippet shows the new implementation of `Ticket`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个片段显示了 `Ticket` 的新实现：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The altered constructor
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 改变的构造函数
- en: ❷ The new getInitialPrice call
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新的 getInitialPrice 调用
- en: ❸ The unchanged calculation
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 未改变的计算
- en: 'Providing a full implementation of the `HttpPrice` class would take us too
    far afield, so let’s just suppose that it calls out to another class, `HttpPricingService`,
    as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 提供完整的 `HttpPrice` 类实现会让我们偏离太远，所以让我们假设它调用另一个类，`HttpPricingService`，如下所示：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Returns random results
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回随机结果
- en: Now that we’ve surveyed the damage, let’s think about what we intended to test.
    Our goal was to show the multiplication in the `Ticket` class’s `getDiscountPrice()`
    method works as expected. No external websites are required for proving that.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调查了损害情况，让我们考虑我们原本想要测试的内容。我们的目标是展示 `Ticket` 类的 `getDiscountPrice()` 方法中的乘法按预期工作。证明这一点不需要外部网站。
- en: 'The `Price` interfaces gives us the seam we need to replace our touchy `HttpPrice`
    instance with a consistent `StubPrice` implementation, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Price` 接口为我们提供了替换我们敏感的 `HttpPrice` 实例与一致的 `StubPrice` 实现所需的接口，如下所示：'
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The StubPrice stub
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ StubPrice 存根
- en: ❷ Creates a Ticket
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个票据
- en: ❸ Checks the price
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查价格
- en: 'The `StubPrice` class is a simple little class that consistently returns the
    initial price of 10, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`StubPrice` 类是一个简单的类，它始终返回初始价格 10，如下所示：'
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Returns a consistent price
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回一致的价格
- en: Phew! Now the test passes again, and, equally important, you can look at refactoring
    the rest of the implementation details without fear.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '呼吁！现在测试再次通过，同样重要的是，你可以放心地重构其余的实现细节。 '
- en: Stubs are a useful type of test double, but sometimes it’s desirable to have
    the stub perform some real work that’s closer to the production system. For that,
    you use a fake object as your test double.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 存根是有用的测试双胞胎类型，但有时我们希望存根执行一些更接近生产系统的实际工作。为此，你使用模拟对象作为你的测试双胞胎。
- en: 13.4.3 Fake object
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 模拟对象
- en: A *fake* object can be seen as an enhanced stub that almost does the same work
    as your production code, but that takes a few shortcuts to fulfill your testing
    requirements. Fakes are especially useful when you’d like your code to run against
    something that’s very close to the real third-party subsystem or dependency that
    you’ll use in the live implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*假*对象可以被视为一个增强的存根，它几乎与您的生产代码做相同的工作，但为了满足您的测试要求而采取了一些捷径。当您希望您的代码针对与您在实时实现中使用的真实第三方子系统或依赖非常接近的东西运行时，假对象特别有用。
- en: 'For our ticketing application, let’s imagine that our database layer provides
    us with a simple interface for working with tickets, shown next:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的票务应用程序，让我们假设我们的数据库层提供了一个用于处理票务的简单接口，如下所示：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our class for managing an individual show needs to work with this database
    interface and manage features such as checking we haven’t oversold like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于管理单个演出的类需要与这个数据库接口一起工作，并管理诸如检查我们是否像这样过度销售等功能：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We’d like to unit test `addTicket` without relying on a fully instance of our
    relational database. Such a test might look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在不需要完全实例化我们的关系数据库的情况下对`addTicket`进行单元测试。这样的测试可能看起来像这样：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ FakeTicketDatabase doesn’t exist, but in the spirit of TDD, we’ll write the
    code we want to pass.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `FakeTicketDatabase`不存在，但本着TDD的精神，我们将编写我们想要通过的代码。
- en: Although we could accomplish this via stubbing, it would have major drawbacks.
    We’d have to stub out the methods `count` and `insert` on the database, which
    aren’t even visible in the test, cluttering it up with lower-level details and
    distracting from its actual purpose. But the difficulties go deeper still—each
    test must ensure the relationship between `count` and the number of calls to `insert`
    are aligned. Even worse, our final call to `findByName`, which is meant to ensure
    our data was saved, would also need to be stubbed. But that very stubbing means
    the assertion is useless—it would pass whether or not our implementation code
    was correct! Stubs fall short of letting us accurately validate this set of tightly
    related actions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过存根（stubbing）来实现这一点，但这会有很大的缺点。我们不得不对数据库的`count`和`insert`方法进行存根处理，而这些方法在测试中甚至都不可见，这会让测试变得杂乱无章，并分散了测试的实际目的。但困难还远不止于此——每个测试都必须确保`count`和`insert`调用次数之间的关系是一致的。更糟糕的是，我们最后的`findByName`调用，其目的是确保我们的数据已被保存，也需要进行存根处理。但正是这种存根意味着断言变得毫无用处——无论实现代码是否正确，它都会通过！存根不足以让我们准确验证这一系列紧密相关的操作。
- en: 'A fake object provides an alternative by having a real but simplified, implementation.
    The provided interface, shown next, is easy to serve with a wrapper around a simple
    `HashMap`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一个假对象通过提供一个真实但简化的实现来提供另一种选择。提供的接口，如下所示，可以通过围绕简单的`HashMap`的包装来轻松提供：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Our map takes the place of a database for the lifetime of our unit test.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的地图在单元测试的生命周期中取代了数据库的位置。
- en: ❷ We have to replicate features such as databases autoincrementing IDs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们必须复制诸如数据库自动递增ID等特性。
- en: Fake objects, especially when shared throughout a project with strong interfaces,
    can be a nice solution for supporting unit tests. They aren’t appropriate everywhere—if
    our database interface allowed us to pass SQL clauses for additional filtering,
    this would quickly get beyond our fake’s ability to handle—but they’re a useful
    tool to have. Just keep an eye out that the implementation doesn’t get too large
    or complex, because every line of code we write is a possible source of bugs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假对象，尤其是在具有强大接口的项目中共享时，可以是为支持单元测试提供的一种很好的解决方案。它们并不适用于所有地方——如果我们的数据库接口允许我们传递SQL子句进行额外的过滤，这很快就会超出我们假对象处理的能力——但它们是一个有用的工具。只需注意，实现不要变得太大或太复杂，因为我们写的每一行代码都可能是bug的来源。
- en: 13.4.4 Mock object
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.4 模拟对象
- en: '*Mock* objects are related to the stub test doubles that you’ve already met,
    but stub objects are usually pretty dumb beasts. For example, stubs typically
    fake out methods to always give the same result. This doesn’t provide any way
    to model state-dependent behavior.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mock*对象与您已经遇到的存根测试双胞胎有关，但存根对象通常是相当愚蠢的生物。例如，存根通常会模拟方法以始终给出相同的结果。这并不提供任何方式来模拟状态相关行为。'
- en: 'As an example: you’re trying to follow TDD, and you’re writing a text analysis
    system. One of your unit tests instructs the text analysis classes to count the
    number of occurrences of the phrase “Java11” for a particular blog post. But because
    the blog post is a third-party resource, a number of possible failure scenarios
    exist that have very little to do with the counting algorithm you’re writing.
    In other words, the code under test isn’t isolated, and calling the third-party
    resource could be time-consuming. Here are some common failure scenarios:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：你正在尝试遵循TDD（测试驱动开发），并且你正在编写一个文本分析系统。你其中一个单元测试指示文本分析类对一个特定的博客文章计算“Java11”短语出现的次数。但由于博客文章是第三方资源，存在许多可能的失败场景，这些场景与你要编写的计数算法关系甚微。换句话说，被测试的代码没有隔离，调用第三方资源可能会很耗时。以下是一些常见的失败场景：
- en: Your code might not be able to go out to the internet to query the blog post,
    due to firewall restrictions in your organization.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你所在组织的防火墙限制，你的代码可能无法上网查询博客文章。
- en: The blog post may have been moved with no redirect.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客文章可能已经被移动，但没有重定向。
- en: The blog post might be edited to increase or decrease the number of times “Java11”
    appears.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客文章可能被编辑以增加或减少“Java11”出现的次数。
- en: 'Using stubs, this test would be almost impossible to write, and it would be
    incredibly verbose for each test case. Enter the *mock object*. This is a special
    kind of test double, which you can think of as a programmable stub. Using the
    mock object is very simple: when you’re preparing the mock for use, you tell it
    the sequence of calls to expect and how it should respond to each one.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用桩，这个测试几乎不可能编写，并且对于每个测试用例来说都会非常冗长。这时就出现了*模拟对象*。这是一种特殊的测试双胞胎，你可以将其视为可编程的桩。使用模拟对象非常简单：当你准备模拟对象使用时，你告诉它预期的调用序列以及它应该如何对每个调用做出响应。
- en: 'Let’s see this in action by looking at a simple example for the theater tickets
    use case. We’ll be using the popular mocking library, Mockito ([https://site.mockito.org](https://site.mockito.org)).
    The following snippet shows how to use it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个简单的示例来观察这个行为，这个示例是关于剧院票用例的。我们将使用流行的模拟库Mockito ([https://site.mockito.org](https://site.mockito.org))。以下代码片段展示了如何使用它：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates a mock
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建模拟
- en: ❷ Programs the mock for testing
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为测试编程模拟
- en: To create a mock object, you call the static `mock()` method with the class
    object of the type you want to mock up. Then you “record” the behavior that you
    want your mock to display by calling the `when()` method to indicate which method
    to record, and `thenReturn()` to specify the expected result. Last, you verify
    that you’ve called the expected methods on the mocked object. This ensures that
    you didn’t get to the correct result via an incorrect path.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模拟对象，你调用静态的`mock()`方法，并传入你想要模拟的类型的类对象。然后，通过调用`when()`方法来指示要记录哪个方法，以及通过调用`thenReturn()`来指定预期的结果来“记录”你希望模拟对象显示的行为。最后，你验证在模拟对象上是否调用了预期的方法。这确保你没有通过错误路径得到正确的结果。
- en: This verification captures the big difference between a stub and a mock. With
    a stub, your primary focus is returning canned values. With a mock, the intent
    is *verifying behavior*, such as the exact calls actually made. In practice, Mockito’s
    richly featured `mock()` method can be used easily to create stubs if we ignore
    verification, but it’s important that you as the programmer be aware of what you’re
    intending to test.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个验证捕捉了桩（stub）和模拟（mock）之间的重大差异。使用桩时，你的主要关注点是返回预设值。使用模拟时，目的是*验证行为*，例如实际做出的精确调用。在实践中，如果我们忽略验证，Mockito丰富的`mock()`方法可以很容易地用来创建桩，但重要的是，作为程序员，你必须清楚你打算测试什么。
- en: You can use the mock just like a regular object and pass it to your call to
    the `Ticket` constructor without any further ceremony. This makes mock objects
    a very powerful tool for TDD. Some practitioners don’t really use the other types
    of test doubles, preferring to do almost everything with mocks. But as with many
    powerful tools, mocking comes with sharp edges to be aware of.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模拟对象就像使用普通对象一样，并将其传递给`Ticket`构造函数的调用，无需任何额外的仪式。这使得模拟对象成为TDD（测试驱动开发）中一个非常强大的工具。一些实践者实际上并不使用其他类型的测试双胞胎，而是几乎用模拟对象做所有事情。但正如许多强大的工具一样，模拟也伴随着需要注意的锋利边缘。
- en: 13.4.5 Problems with mocking
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.5 模拟的问题
- en: One of the largest difficulties with test doubles is precisely that they are
    fake, so their behavior can diverge from the actual production system. Unfortunately,
    this can happen while still leaving you with the warm, comforting sense that your
    tests have you fully covered—until reality bites.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身（test doubles）最大的困难之一正是它们是假的，因此它们的行为可能会与实际的生产系统有所不同。不幸的是，这种情况可能会在你仍然感到温暖、安慰地认为你的测试已经全面覆盖了所有内容时发生——直到现实打破这种幻想。
- en: 'These behavior differences can come in a number of flavors. Common ones include
    the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为差异可以有多种形式。常见的一些包括以下内容：
- en: Differences in returned payloads, particularly with complex nested objects
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回负载的差异，尤其是与复杂嵌套对象相关
- en: Serialization/deserialization differences from testing data
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化/反序列化测试数据的差异
- en: Ordering of items in collections
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合中项目的顺序
- en: Responses to error conditions—either failing to throw, or throwing different
    exception types
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对错误条件的响应——要么是未能抛出异常，要么是抛出不同的异常类型
- en: Although there’s no blanket solution, these problems can often be spotted when
    we step up a level to integration tests. Again, if we keep firmly in mind *what*
    we’re testing in each set of tests, we can focus our unit tests on localized logic
    and use integration testing elsewhere to cover interactions with our dependencies.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有一劳永逸的解决方案，但这些问题通常可以在我们提升到集成测试级别时被发现。再次强调，如果我们始终牢记每套测试中我们在测试什么，我们就可以将单元测试集中在局部逻辑上，并在其他地方使用集成测试来覆盖与我们的依赖项的交互。
- en: Solid design of our interfaces also helps our test doubles. Rather than a service
    class returning a raw contents string from an HTTP call, returning a specific
    object gives our test doubles less room to vary. Having precise subclasses for
    the exceptions your class raises, wrapping more primitive exception types, not
    only makes your code more expressive but also easier to mock accurately.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接口的稳固设计也有助于我们的测试替身。而不是服务类从HTTP调用返回原始内容字符串，返回一个特定对象让我们的测试替身有更少的变动空间。为你的类抛出的异常提供精确的子类，包装更原始的异常类型，不仅使你的代码更具表现力，而且更容易准确模拟。
- en: Mocking, if used everywhere, can also lead to our tests too closely mimicking
    our production code. When this happens, each line in your actual code has a mirroring
    line in test configuration, restating the precise expected call. Such tests are
    extremely brittle, often leading to huge swathes of seemingly unrelated changes
    when altering code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在所有地方都使用模拟（mocking），也可能导致我们的测试过于紧密地模仿我们的生产代码。当这种情况发生时，你的实际代码中的每一行在测试配置中都有一个对应的行，重申了精确的预期调用。这样的测试非常脆弱，通常在修改代码时会导致大量看似无关的更改。
- en: This brittleness when mocking extends down to the level of individual arguments.
    Although the frameworks make it easy to be extremely precise about the values
    being passed, consider whether your test truly needs to verify that argument.
    As we saw with dummy objects, for some test cases, a given value might not matter.
    Mocking frameworks provide mechanisms for effectively allowing statements like
    “any integer,” and if the value doesn’t matter, such statements both clarify what
    your test cares about and allows room for the production code to evolve more easily.
    Give your tests room to breathe!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟时，这种脆弱性甚至延伸到单个参数的级别。尽管框架使你能够非常精确地指定传递的值，但请考虑你的测试是否真的需要验证该参数。正如我们通过哑对象（dummy
    objects）所看到的，对于某些测试用例，给定的值可能并不重要。模拟框架提供了允许类似“任何整数”这样的语句的机制，如果值不重要，这些语句既明确了你的测试关心什么，又为生产代码的更容易演变留出了空间。给你的测试留出呼吸的空间！
- en: Tests can also surface issues when they require large amounts of intricate setup
    before running. Mocking, particularly when paired with dependency injection, can
    make it easy to pile up dependencies in a class without taking much notice. If
    your test setup is longer than the code needed to execute and verify your results,
    that’s a hint your classes may be overly complex and ripe for refactoring. Test
    setup is also a great way to watch for violations of the Law of Demeter, which
    suggests objects should have knowledge only of their direct neighbors. If your
    test setup needs to muck about with objects many levels removed from itself, your
    objects might be reaching too far outside themselves.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试在运行前需要大量复杂的设置时，测试也可以暴露问题。特别是当与依赖注入结合使用时，模拟（Mocking）可以使在类中堆积依赖变得容易，而不会引起太多注意。如果你的测试设置比执行和验证结果的代码还要长，那么这可能是一个提示，表明你的类可能过于复杂，需要重构。测试设置也是观察违反迪米特法则（Law
    of Demeter）的绝佳方式，该法则建议对象只应了解其直接邻居。如果你的测试设置需要与自身多级之外的物体打交道，那么你的对象可能已经超出了自己的范围。
- en: Test doubles are a valuable tool for the well-grounded developer. We’ve demonstrated
    a little bit of JUnit in our discussion so far, but we have not explored it in
    depth yet. Let’s look a little closer at it and take the opportunity to see what’s
    new with JUnit 5, the most recent major version.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 测试双倍（Test doubles）是经验丰富的开发者的一项宝贵工具。到目前为止，我们在讨论中已经稍微介绍了一些JUnit，但还没有深入探讨。让我们更仔细地看看它，并借此机会看看JUnit
    5，最新主要版本的新特性。
- en: 13.5 From JUnit 4 to 5
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 从JUnit 4到JUnit 5
- en: JUnit is a JVM-based implementation of the xUnit style of test framework, developed
    initially by Kent Beck and Erich Gamma. This flavor of unit testing has proven
    versatile and easy to use, placing JUnit among the most commonly used libraries
    in the JVM ecosystem.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是基于JVM的xUnit风格测试框架的实现，最初由Kent Beck和Erich Gamma开发。这种单元测试风格已被证明是灵活且易于使用的，使JUnit成为JVM生态系统中最常用的库之一。
- en: This long history and broad usage brings many constraints as well. JUnit 4,
    initially released in 2006, couldn’t use features like lambda expressions without
    breaking compatibility. In 2017, JUnit 5 was released, using the opportunity afforded
    by the major version change to introduce significant changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这段悠久的历史和广泛的使用也带来了许多限制。JUnit 4最初于2006年发布，不能使用lambda表达式等特性而不破坏兼容性。2017年，JUnit
    5发布，利用主要版本变更的机会引入了重大变化。
- en: Note The next chapter will focus plenty of time on other tools and techniques,
    but the well-grounded Java developer will almost certainly encounter JUnit code
    that’s worth moving to the most modern versions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：下一章将花费大量时间介绍其他工具和技术，但经验丰富的Java开发者几乎肯定会遇到值得迁移到最新版本的JUnit代码。
- en: One of the biggest changes with JUnit 5 is its packaging. Where prior versions
    were monolithic, containing both the API for authoring tests and the support for
    running and reporting on those tests, JUnit 5 breaks things down into more focused
    packages. JUnit 5 also steps away from the external dependency on Hamcrest that
    came with JUnit 4.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5最大的变化之一是其打包方式。之前的版本是单体式的，包含编写测试的API以及运行和报告这些测试的支持，而JUnit 5将事物分解为更专注的包。JUnit
    5还摆脱了JUnit 4附带的外部依赖项Hamcrest。
- en: JUnit 5 lives in an entirely new package—`org.junit.jupiter`—which means both
    version can coexist during migration. We’ll look more at the mechanics of that
    in a moment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5位于一个全新的包中—`org.junit.jupiter`—这意味着在迁移期间两个版本可以共存。我们稍后会更详细地探讨这一点。
- en: 'JUnit 5’s primary two dependencies follow:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5的主要两个依赖项如下：
- en: '`org.junit.jupiter.junit-jupiter-api`—This is referenced from your testing
    code to provide all the necessary annotations and helpers to author tests.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.junit.jupiter.junit-jupiter-api`—这是从你的测试代码中引用的，以提供编写测试所需的所有必要的注解和辅助工具。'
- en: '`org.junit.jupiter.junit-jupiter-engine`—This is the default engine for running
    JUnit 5 tests. It is only needed as a runtime, not compile-time, dependency and
    can be augmented or swapped out for other test runners.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.junit.jupiter.junit-jupiter-engine`—这是运行JUnit 5测试的默认引擎。它仅作为运行时依赖项，不是编译时依赖项，并且可以被增强或替换为其他测试运行器。'
- en: 'In Gradle, that would look like this, along with a hint to tell Gradle to use
    the new JUnit bits when running tests:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中，这看起来是这样的，同时还有一个提示告诉Gradle在运行测试时使用新的JUnit组件：
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The equivalent for Maven would be as follows. The Maven `surefire` and `failsafe`
    plugins know how to work automatically with JUnit 5, as long as you have a new-enough
    version (2.22 or greater is recommended):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 的等效项如下。Maven 的 `surefire` 和 `failsafe` 插件知道如何与 JUnit 5 自动工作，只要你有一个足够新的版本（建议使用
    2.22 或更高版本）：
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you add these to a JUnit 4 project and simply run the tests, you’ll find
    an odd outcome—the suite will likely pass—but if you look more closely at the
    reports, *no tests actually ran!* This is because the actual annotation to mark
    test cases changed with JUnit 5.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些添加到 JUnit 4 项目中并简单地运行测试，你会发现一个奇怪的结果——套件可能会通过，但如果仔细查看报告，*实际上没有测试运行过!* 这是因为实际的标记测试用例的注解随着
    JUnit 5 的变化而变化。
- en: Note JUnit 5 brings its own `@Test` annotation in the package `org.junit .jupiter.api`.
    It won’t recognize existing tests marked with the older `org .junit` version of
    `@Test` by default!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JUnit 5 在包 `org.junit.jupiter.api` 中带来了自己的 `@Test` 注解。默认情况下，它不会识别用较旧的 `org.junit`
    版本的 `@Test` 标记的现有测试！
- en: There are two paths to take from this point. The first is to change over each
    place where you’re importing the old annotations to use the new version. Class
    by class, your test suite will start running under JUnit 5\. These conversions
    may require other work we’ll discuss shortly.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，有两种路径可以选择。第一种是更改所有导入旧注解的地方，使用新版本。逐个类地，你的测试套件将开始在 JUnit 5 下运行。这些转换可能需要我们稍后讨论的其他工作。
- en: An alternative is to pull in an additional runtime dependency on the `junit-vintage-engine`.
    This package uses JUnit 5’s richer ability to plug in different runners and support
    classes to allow for backward compatibility with JUnit 4 (and even 3) tests.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是引入对 `junit-vintage-engine` 的额外运行时依赖。这个包使用 JUnit 5 更丰富的能力来插入不同的运行器和支持类，以允许与
    JUnit 4（甚至 3）测试的向后兼容性。
- en: 'In Gradle:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 中：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Maven:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maven 中：
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Support for running JUnit 4 tests alongside JUnit 5
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 支持在 JUnit 5 中运行 JUnit 4 测试
- en: ❷ Our main JUnit 5 dependencies, api and engine
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们主要的 JUnit 5 依赖项，api 和 engine
- en: This support can allow for an easier transition as you can enable JUnit 5, then
    convert test by test over time, rather than requiring everything to move at once.
    It’s worth noting, though, that the vintage support does have some limitations,
    which are well documented in the JUnit users guide at [http://mng.bz/5Q61](http://mng.bz/5Q61).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种支持可以允许更容易的过渡，因为你可以启用 JUnit 5，然后随着时间的推移逐个转换测试，而不是要求一次性迁移所有内容。不过，值得注意的是，旧版支持确实有一些限制，这些限制在
    JUnit 用户指南中有很好的文档记录，可在 [http://mng.bz/5Q61](http://mng.bz/5Q61) 查阅。
- en: 'Along with the new packaging, a variety of classes have been renamed to make
    them clearer and more accurate about their usage, shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的打包方式，还重命名了各种类，使它们更清晰、更准确地反映其用法，如下所示：
- en: '`@Before` changed to `@BeforeEach`.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before` 改为 `@BeforeEach`.'
- en: '`@After` changed to `@AfterEach`.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@After` 改为 `@AfterEach`.'
- en: '`@BeforeClass` changed to `@BeforeAll`.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeClass` 改为 `@BeforeAll`.'
- en: '`@AfterClass` changed to `@AfterAll`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterClass` 改为 `@AfterAll`.'
- en: '`@Category` changed to `@Tag`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Category` 改为 `@Tag`.'
- en: '`@Ignored` changed to `@Disabled` (or may be handled with `ExecutionCondition`
    in the new extension model).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Ignored` 改为 `@Disabled`（或者在新扩展模型中可能通过 `ExecutionCondition` 处理）。'
- en: '`@RunWith`, `@Rule` and `@ClassRule` are replaced by the new extension model.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith`、`@Rule` 和 `@ClassRule` 被新的扩展模型所取代。'
- en: As the final couple of points allude to, a big feature of JUnit 5 is a new extension
    model that covers a variety of separate features in earlier versions of JUnit.
    These features let you share behavior between classes—steps like test setup, teardown,
    and expectation setting—but didn’t all fit together cohesively.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如最后几点所暗示的，JUnit 5 的一个重要特性是新的扩展模型，它涵盖了 JUnit 早期版本中的各种单独特性。这些特性允许你在类之间共享行为——例如测试设置、清理和期望设置——但它们并没有很好地结合在一起。
- en: 'As an example, here’s a basic JUnit 4 test that needs to start up a server
    before tests can run. It uses the `ExternalResource` class, along with a `@Rule`
    annotation to ask that it be called at the right points in the lifecycle:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个基本的 JUnit 4 测试，在测试运行之前需要启动服务器。它使用了 `ExternalResource` 类，以及一个 `@Rule`
    注解来要求在生命周期中的正确点调用：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ @Rule requests that this be applied before/after each test.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `@Rule` 要求在每个测试之前/之后应用。
- en: ❷ ExternalResource is provided by JUnit specifically for such custom setup/teardown
    scenarios.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `ExternalResource` 是由 JUnit 特别为这样的自定义设置/清理场景提供的。
- en: Our overrides on `ExternalResource` could easily be pulled into another location
    and shared between our tests.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `ExternalResource` 的覆盖可以轻松地拉入另一个位置，并在我们的测试之间共享。
- en: 'JUnit 5 instead breaks down the testing lifecycle into smaller interfaces that
    you implement. These extensions can then be applied at the class or test-method
    level, as shown next:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5 将测试生命周期分解为更小的接口，您需要实现。然后，这些扩展可以像下面展示的那样应用于类或测试方法级别：
- en: '[PRE25]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ We implement AfterEachCallback and BeforeEachCallback to get called as we
    did before for each test method. AfterAllCallback and BeforeAllCallback exist
    as well to replace @ClassRule functionality.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们实现了 AfterEachCallback 和 BeforeEachCallback，以便在每个测试方法中像以前一样被调用。同样存在 AfterAllCallback
    和 BeforeAllCallback，用于替代 @ClassRule 功能。
- en: ❷ Because our extension worked with a field on the test class, we need to have
    that passed on construction.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 因为我们的扩展与测试类上的字段一起工作，我们需要在构造时传递它。
- en: ❸ Callbacks proceed as before to do the setup/teardown work.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 回调按之前的方式进行，以执行设置/清理工作。
- en: 'With this class in hand, we can apply it in our test as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个类后，我们可以在测试中如下应用它：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ @RegisterExtension allows us to instantiate our extension for the test.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ @RegisterExtension 允许我们为测试实例化扩展。
- en: ❷ The field on the test class must be public to work with @RegisterExtension.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试类上的字段必须是公共的，才能与 @RegisterExtension 一起工作。
- en: 'If an extension doesn’t require parameters on construction, it can also be
    applied to the class or method definition using `@ExtendWith`, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扩展在构造时不需要参数，它也可以使用 `@ExtendWith` 应用于类或方法定义，如下所示：
- en: '[PRE27]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'JUnit 5’s move to require more recent JDK versions also tidied up some corners
    where rules used to be a standard approach. Checking whether a test method raised
    an exception could take the following two forms in JUnit 4 and earlier:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5 要求使用更近期的 JDK 版本，这也清理了一些角落，其中规则曾经是标准方法。在 JUnit 4 及更早版本中，检查测试方法是否抛出异常可以采取以下两种形式：
- en: '[PRE28]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ A rule-based exception checking on a test method
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在测试方法上的基于规则的异常检查
- en: ❷ The @Test annotation configuration of the excepted exception
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试注解中期望异常的配置
- en: 'Lambda expressions open up a new way of expressing this that looks more like
    our typical assertions, like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式提供了一种新的表达方式，看起来更像我们的典型断言，如下所示：
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`assertThrows` is preferable to the old `expected` argument on our test annotations
    or the `ExpectedException` rule for a couple of reasons. First, the assertion
    is more direct, located right where the code we’re actually testing is found instead
    of earlier in the method. Also, `assertThrows` returns the exception without us
    needing to scaffold a `try`/`catch` in place, so we can more easily do typical
    assertions about what happened without special plumbing. Although JUnit 4’s legacy
    across the ecosystem means it’ll still be around—and maintained—for a long while,
    if you’re using JUnit, it’s worth looking at what the new version offers.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertThrows` 相比于我们测试注解中的旧 `expected` 参数或 `ExpectedException` 规则，有几个原因更可取。首先，断言更加直接，位于我们实际测试的代码所在的位置，而不是方法的开头。此外，`assertThrows`
    在我们不需要设置 `try`/`catch` 的情况下返回异常，因此我们可以更轻松地执行关于发生了什么的典型断言，而不需要特殊配置。尽管 JUnit 4 在生态系统中的遗留问题意味着它还将存在并维护一段时间，但如果你在使用
    JUnit，了解新版本提供的内容是值得的。'
- en: Our test libraries are only part of the picture, though, especially once we’re
    writing integration tests. The next chapter will delve into some helpful tools
    in approaching the long-standing hassles of testing with external dependencies.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的测试库只是其中的一部分，尤其是当我们编写集成测试时。下一章将深入探讨一些有助于解决使用外部依赖的长期难题的有用工具。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve discussed the motivations and types of testing, and how it’s critical
    to know the answers to what we’re testing for to decide on an approach.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了测试的动机和类型，以及了解我们正在测试的内容的答案对于决定方法至关重要。
- en: We took a walk through test-driven development, seeing how it allows us to evolve
    a design with confidence in a step-by-step fashion.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了测试驱动开发，看到它如何以逐步的方式让我们有信心地演进设计。
- en: We’ve examined the wide variety of test doubles, what they’re useful for, and,
    more important, where they’ll cause trouble if misused.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查了各种测试替身，它们有什么用，更重要的是，如果误用，它们会在哪里引起麻烦。
- en: After many years, a new version of JUnit is out that addresses long-standing
    design problems, often constraints from long-deprecated JDKs. We looked briefly
    at moving to this latest version for the basics of our testing.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过多年，JUnit 的新版本发布，解决了长期的设计问题，通常是来自长期废弃的 JDK 的限制。我们简要地探讨了将测试的基本知识迁移到这个最新版本。
