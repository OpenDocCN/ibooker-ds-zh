- en: appendix C Â Linear algebra refresher
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é™„å½•C  çº¿æ€§ä»£æ•°å¤ä¹ 
- en: In this appendix, our goal is to quickly cover some of the linear algebra skills
    that are useful for this book. Weâ€™ll discuss what vectors and matrices are, how
    to work with vectors and matrices to represent linear functions, and how to use
    Python and NumPy to work with vectors and matrices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé™„å½•ä¸­ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯å¿«é€Ÿè¦†ç›–ä¸€äº›å¯¹è¿™æœ¬ä¹¦æœ‰ç”¨çš„çº¿æ€§ä»£æ•°æŠ€èƒ½ã€‚æˆ‘ä»¬å°†è®¨è®ºä»€ä¹ˆæ˜¯å‘é‡çŸ©é˜µï¼Œå¦‚ä½•ä½¿ç”¨å‘é‡å’ŒçŸ©é˜µæ¥è¡¨ç¤ºçº¿æ€§å‡½æ•°ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨Pythonå’ŒNumPyæ¥å¤„ç†å‘é‡å’ŒçŸ©é˜µã€‚
- en: C.1 Approaching vectors
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 æ¥è¿‘å‘é‡
- en: Before we can get to what qubits are, we need to understand the concept of a
    *vector*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬èƒ½å¤Ÿäº†è§£é‡å­ä½ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç†è§£*å‘é‡*çš„æ¦‚å¿µã€‚
- en: '*Suppose a friend of ours is having people over to celebrate that they fixed
    their doorbell, and weâ€™d very much like to find their house and celebrate the
    occasion with them. How can our friend help us find their home*?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*å‡è®¾æˆ‘ä»¬çš„ä¸€ä¸ªæœ‹å‹è¦é‚€è¯·äººæ¥åº†ç¥ä»–ä»¬ä¿®å¥½äº†é—¨é“ƒï¼Œè€Œæˆ‘ä»¬éå¸¸æƒ³æ‰¾åˆ°ä»–ä»¬çš„æˆ¿å­ï¼Œå’Œä»–ä»¬ä¸€èµ·åº†ç¥è¿™ä¸ªæ—¶åˆ»ã€‚æˆ‘ä»¬çš„æœ‹å‹å¦‚ä½•å¸®åŠ©æˆ‘ä»¬æ‰¾åˆ°ä»–ä»¬çš„å®¶*ï¼Ÿ'
- en: 'You can see a sketch of our direction dilemma in figure C.1\. Vectors are a
    mathematical tool that can be used to represent a variety of different conceptsâ€”basically,
    anything that we can record by making an ordered list of numbers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥åœ¨å›¾C.1ä¸­çœ‹åˆ°æˆ‘ä»¬çš„æ–¹å‘å›°å¢ƒçš„è‰å›¾ã€‚å‘é‡æ˜¯ä¸€ç§æ•°å­¦å·¥å…·ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºå„ç§ä¸åŒçš„æ¦‚å¿µâ€”â€”åŸºæœ¬ä¸Šï¼Œä»»ä½•æˆ‘ä»¬å¯ä»¥é€šè¿‡æŒ‰é¡ºåºåˆ—å‡ºæ•°å­—æ¥è®°å½•çš„ä¸œè¥¿ï¼š
- en: Points on a map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ°å›¾ä¸Šçš„ç‚¹
- en: Colors of pixels in a display
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ˜¾ç¤ºå™¨ä¸­åƒç´ çš„é¢œè‰²
- en: Damage elements in a computer game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¡ç®—æœºæ¸¸æˆä¸­çš„ä¼¤å®³å…ƒç´ 
- en: Velocity of an airplane
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é£æœºçš„é€Ÿåº¦
- en: Orientation of a gyroscope
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é™€èºä»ªçš„æ–¹å‘
- en: For instance, if weâ€™re lost in an unfamiliar city, someone can tell us where
    to go by giving us a vector that instructs us to go *a* blocks east and then *b*
    blocks north (weâ€™ll set aside the problem of routing around buildings). We write
    these instructions with the vector `[[a], [b]]` (figure C.2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ä¸€ä¸ªä¸ç†Ÿæ‚‰çš„åŸå¸‚è¿·è·¯ï¼Œæœ‰äººå¯ä»¥é€šè¿‡ç»™æˆ‘ä»¬ä¸€ä¸ªæŒ‡ç¤ºæˆ‘ä»¬å‘ä¸œèµ°*a*ä¸ªè¡—åŒºç„¶åå‘åŒ—èµ°*b*ä¸ªè¡—åŒºçš„å‘é‡æ¥å‘Šè¯‰æˆ‘ä»¬å»å“ªé‡Œï¼ˆæˆ‘ä»¬å°†å¿½ç•¥ç»•å»ºç­‘ç‰©è¡Œè¿›çš„é—®é¢˜ï¼‰ã€‚æˆ‘ä»¬ç”¨å‘é‡
    `[[a], [b]]`ï¼ˆå›¾C.2ï¼‰æ¥å†™è¿™äº›æŒ‡ç¤ºã€‚
- en: '![](../Images/C-1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-1.png)'
- en: Figure C.1 Looking for our friendâ€™s house party
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.1 å¯»æ‰¾æˆ‘ä»¬çš„æœ‹å‹çš„å®¶èšä¼š
- en: '![](../Images/C-2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-2.png)'
- en: Figure C.2 Vectors as coordinates
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.2 å‘é‡ä½œä¸ºåæ ‡
- en: Like ordinary numbers, we can add different vectors together.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒæ™®é€šæ•°å­—ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸åŒçš„å‘é‡ç›¸åŠ ã€‚
- en: Note An ordinary number is often called a *scalar* to distinguish it from a
    vector.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ ä¸€ä¸ªæ™®é€šæ•°å­—é€šå¸¸è¢«ç§°ä¸º*æ ‡é‡*ï¼Œä»¥åŒºåˆ«äºå‘é‡ã€‚
- en: Using this way of thinking about vectors, we can think of addition between vectors
    as being defined element-wise. That is, we interpret `[[a], [b]] + [[c], [d]]`
    as being instructions to go `a` blocks east, `b` blocks north, `c` blocks east,
    then finally `d` blocks north. Since it doesnâ€™t matter what order we step in,
    this is equivalent to taking `a + c` blocks east, then `b + d` blocks north, so
    we write that `[[*a*], [*b*]] + [[c], [d]]` is `[[a + c], [b + d]]` (figure C.3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§å…³äºå‘é‡çš„æ€è€ƒæ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥å°†å‘é‡ä¹‹é—´çš„åŠ æ³•å®šä¹‰ä¸ºé€å…ƒç´ å®šä¹‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°† `[[a], [b]] + [[c], [d]]` è§£é‡Šä¸ºå‘ä¸œèµ°*a*ä¸ªè¡—åŒºï¼Œå‘åŒ—èµ°*b*ä¸ªè¡—åŒºï¼Œç„¶åå‘ä¸œèµ°*c*ä¸ªè¡—åŒºï¼Œæœ€åå‘åŒ—èµ°*d*ä¸ªè¡—åŒºã€‚ç”±äºæˆ‘ä»¬èµ°æ­¥çš„é¡ºåºæ— å…³ç´§è¦ï¼Œè¿™ç›¸å½“äºå…ˆå‘ä¸œèµ°*a
    + c*ä¸ªè¡—åŒºï¼Œç„¶åå‘åŒ—èµ°*b + d*ä¸ªè¡—åŒºï¼Œæ‰€ä»¥æˆ‘ä»¬å†™ `[[*a*], [*b*]] + [[c], [d]]` ä¸º `[[a + c], [b +
    d]]`ï¼ˆå›¾C.3ï¼‰ã€‚
- en: '![](../Images/C-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-3.png)'
- en: Figure C.3 Adding vectors to find a party
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.3 é€šè¿‡åŠ æ³•å‘é‡æ‰¾åˆ°èšä¼š
- en: A vector ![](../Images/AR_v.png) in *d* dimensions can be written as a list
    of *d* numbers. For instance, ![](../Images/AR_v.png) = [[2], [3]] is a vector
    in two dimensions (figure C.4).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨*d*ç»´åº¦çš„å‘é‡å¯ä»¥è¡¨ç¤ºä¸º*d*ä¸ªæ•°å­—çš„åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼Œ![](../Images/AR_v.png) = [[2], [3]] æ˜¯ä¸€ä¸ªäºŒç»´å‘é‡ï¼ˆå›¾C.4ï¼‰ã€‚
- en: '![](../Images/C-4.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-4.png)'
- en: Figure C.4 Drawn vectors have the same information as a list of directions or
    column of numbers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.4 ç»˜åˆ¶çš„å‘é‡ä¸ä¸€ç³»åˆ—æ–¹å‘æˆ–æ•°å­—åˆ—å…·æœ‰ç›¸åŒçš„ä¿¡æ¯ã€‚
- en: Similarly, we can multiply vectors by ordinary numbers to transform vectors.
    We may be lost not just in any city, for example, but a city that uses meters
    instead of the feet like weâ€™re used to. To transform a vector given in meters
    to a vector in feet, we need to multiply each element of our vector by about 3.28\.
    Letâ€™s do this using a Python library called *NumPy* to help us manage how we represent
    vectors in a computer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¹˜ä»¥æ™®é€šæ•°å­—æ¥ä¹˜ä»¥å‘é‡ä»¥è½¬æ¢å‘é‡ã€‚æˆ‘ä»¬å¯èƒ½ä¼šè¿·è·¯ï¼Œæ¯”å¦‚åœ¨ä¸€ä¸ªä½¿ç”¨ç±³è€Œä¸æ˜¯æˆ‘ä»¬ä¹ æƒ¯çš„è‹±å°ºçš„åŸå¸‚é‡Œã€‚è¦å°†ä»¥ç±³ä¸ºå•ä½çš„å‘é‡è½¬æ¢ä¸ºä»¥è‹±å°ºä¸ºå•ä½çš„å‘é‡ï¼Œæˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„å‘é‡çš„æ¯ä¸ªå…ƒç´ ä¹˜ä»¥å¤§çº¦3.28ã€‚è®©æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªåä¸º*NumPy*çš„Pythonåº“æ¥å¸®åŠ©æˆ‘ä»¬ç®¡ç†å¦‚ä½•åœ¨è®¡ç®—æœºä¸­è¡¨ç¤ºå‘é‡ã€‚
- en: Tip Full installation instructions are provided in appendix A.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤º å®Œæ•´çš„å®‰è£…è¯´æ˜è¯·å‚é˜…é™„å½•Aã€‚
- en: Listing C.1 Representing vectors in Python with NumPy
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨C.1 ä½¿ç”¨NumPyåœ¨Pythonä¸­è¡¨ç¤ºå‘é‡
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: â¶ Vectors are a special case of NumPy arrays. We create arrays using the â€œarrayâ€
    function, passing a list of the rows in our vector. Each row is then a list of
    the columnsâ€”for vectors, we only ever have one column per row, but weâ€™ll have
    examples in the book where this isnâ€™t true.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å‘é‡æ˜¯NumPyæ•°ç»„çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚æˆ‘ä»¬ä½¿ç”¨â€œarrayâ€å‡½æ•°åˆ›å»ºæ•°ç»„ï¼Œä¼ é€’ä¸€ä¸ªåŒ…å«æˆ‘ä»¬å‘é‡è¡Œçš„åˆ—è¡¨ã€‚ç„¶åï¼Œæ¯ä¸€è¡Œéƒ½æ˜¯ä¸€ä¸ªåˆ—çš„åˆ—è¡¨â€”â€”å¯¹äºå‘é‡ï¼Œæˆ‘ä»¬æ¯è¡Œåªæœ‰ä¸€ä¸ªåˆ—ï¼Œä½†ä¹¦ä¸­ä¼šæœ‰ä¸€äº›ä¾‹å­è¯´æ˜è¿™ä¸æ˜¯çœŸçš„ã€‚
- en: â· Starts with an example of going 30 meters east and then 50 meters north
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: â· ä»ä¸€ä¸ªå‘ä¸œèµ°30ç±³ç„¶åå‘åŒ—èµ°50ç±³çš„ä¾‹å­å¼€å§‹
- en: â¸ NumPy represents multiplication between scalars and vectors with the Python
    multiplication operator *.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ NumPyä½¿ç”¨Pythonä¹˜æ³•è¿ç®—ç¬¦*è¡¨ç¤ºæ ‡é‡å’Œå‘é‡ä¹‹é—´çš„ä¹˜æ³•ã€‚
- en: â¹ Prints the result of multiplying. We need to go 98.4 feet east and then 164
    feet north.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ æ‰“å°ä¹˜æ³•çš„ç»“æœã€‚æˆ‘ä»¬éœ€è¦å‘ä¸œèµ°98.4è‹±å°ºï¼Œç„¶åå‘åŒ—èµ°164è‹±å°ºã€‚
- en: 'Exercise C.1: Unit conversion'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ C.1ï¼šå•ä½è½¬æ¢
- en: What are 25 meters west and 110 meters north in feet?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 25ç±³å‘è¥¿å’Œ110ç±³å‘åŒ—æ¢ç®—æˆè‹±å°ºæ˜¯å¤šå°‘ï¼Ÿ
- en: Exercise solutions
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ è§£ç­”
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦æ‰€æœ‰ç»ƒä¹ çš„è§£ç­”éƒ½å¯ä»¥åœ¨é…å¥—ä»£ç ä»“åº“ä¸­æ‰¾åˆ°ï¼š[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)ã€‚åªéœ€è¿›å…¥ä½ æ‰€åœ¨ç« èŠ‚çš„æ–‡ä»¶å¤¹ï¼Œæ‰“å¼€åä¸ºç»ƒä¹ è§£ç­”çš„Jupyterç¬”è®°æœ¬ã€‚
- en: This structure makes it easier to communicate directions. If we didnâ€™t use vectors,
    then each scalar would need its own direction, and it would be critical to keep
    the directions and scalars together.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç»“æ„ä½¿å¾—ä¼ è¾¾æ–¹å‘å˜å¾—æ›´å®¹æ˜“ã€‚å¦‚æœæˆ‘ä»¬ä¸ä½¿ç”¨å‘é‡ï¼Œé‚£ä¹ˆæ¯ä¸ªæ ‡é‡éƒ½éœ€è¦è‡ªå·±çš„æ–¹å‘ï¼Œå¹¶ä¸”ä¿æŒæ–¹å‘å’Œæ ‡é‡åœ¨ä¸€èµ·æ˜¯è‡³å…³é‡è¦çš„ã€‚
- en: C.2 Seeing the matrix for ourselves
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 æˆ‘ä»¬è‡ªå·±çœ‹çŸ©é˜µ
- en: As weâ€™ll see shortly, we can describe how qubits transform as we apply instructions
    to them in the same way that we describe transforming vectors, using a concept
    from linear algebra called a *matrix*. This is especially important as we consider
    transformations of vectors that are more complicated than adding or rescaling.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬å¾ˆå¿«å°†çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ€§ä»£æ•°ä¸­çš„ä¸€ä¸ªæ¦‚å¿µâ€”â€”**çŸ©é˜µ**â€”â€”æ¥æè¿°æˆ‘ä»¬åœ¨é‡å­æ¯”ç‰¹ä¸Šåº”ç”¨æŒ‡ä»¤æ—¶é‡å­æ¯”ç‰¹çš„è½¬æ¢ï¼Œå°±åƒæˆ‘ä»¬æè¿°å‘é‡çš„è½¬æ¢ä¸€æ ·ã€‚å½“æˆ‘ä»¬è€ƒè™‘æ¯”åŠ æ³•æˆ–ç¼©æ”¾æ›´å¤æ‚çš„å‘é‡è½¬æ¢æ—¶ï¼Œè¿™ä¸€ç‚¹å°¤ä¸ºé‡è¦ã€‚
- en: To see how to use matrices, letâ€™s return to the problem of finding the partyâ€”that
    doorbell isnâ€™t going to ring itself, after all! Until now, weâ€™ve simply assumed
    that each vectorâ€™s first component means east and the second means north, but
    someone could well have chosen another convention. Without a way of reconciling
    the transformation between these two conventions, weâ€™ll never find the party.
    Fortunately, not only will matrices help us model qubits later on in this appendix,
    but they can also help us find our way to our friends.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: è¦äº†è§£å¦‚ä½•ä½¿ç”¨çŸ©é˜µï¼Œè®©æˆ‘ä»¬å›åˆ°å¯»æ‰¾æ´¾å¯¹çš„é—®é¢˜â€”â€”æ¯•ç«Ÿï¼Œé—¨é“ƒä¸ä¼šè‡ªå·±å“ï¼åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯å‡è®¾æ¯ä¸ªå‘é‡çš„ç¬¬ä¸€ä¸ªåˆ†é‡ä»£è¡¨ä¸œï¼Œç¬¬äºŒä¸ªåˆ†é‡ä»£è¡¨åŒ—ï¼Œä½†æœ‰äººå¯èƒ½ä¼šé€‰æ‹©å¦ä¸€ç§æƒ¯ä¾‹ã€‚å¦‚æœæ²¡æœ‰ä¸€ç§æ–¹æ³•æ¥åè°ƒè¿™ä¸¤ç§æƒ¯ä¾‹ä¹‹é—´çš„è½¬æ¢ï¼Œæˆ‘ä»¬å°±æ°¸è¿œæ‰¾ä¸åˆ°æ´¾å¯¹ã€‚å¹¸è¿çš„æ˜¯ï¼Œä¸ä»…çŸ©é˜µå°†å¸®åŠ©æˆ‘ä»¬åœ¨è¿™ä¸ªé™„å½•çš„åé¢éƒ¨åˆ†æ¨¡æ‹Ÿé‡å­æ¯”ç‰¹ï¼Œè€Œä¸”å®ƒä»¬è¿˜å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ‰¾åˆ°é€šå¾€æœ‹å‹çš„è·¯ã€‚
- en: 'Happily, the transformation between listing north first and listing east first
    is simple to implement: we swap the coordinates `[[a], [b]]` to obtain `[[b],
    [a]]`. Suppose that this swap is implemented by a function `swap`. Then `swap`
    plays nicely with the vector addition that we saw previously, in that `swap(v
    + w)` is always the same as `swap(v) + swap(w)`. Similarly, if we stretch a vector
    and then swap (that is, scalar multiplication), thatâ€™s the same as if we had swapped
    and then stretched: `swap(a * v) = a * swap(v)`. Any function that has these two
    properties is a *linear* function.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œä»å…ˆåˆ—å‡ºåŒ—åˆ°å…ˆåˆ—å‡ºä¸œçš„è½¬æ¢ç®€å•æ˜“è¡Œï¼šæˆ‘ä»¬å°†åæ ‡`[[a], [b]]`äº¤æ¢ä¸º`[[b], [a]]`ã€‚å‡è®¾è¿™ä¸ªäº¤æ¢æ˜¯é€šè¿‡ä¸€ä¸ªåä¸º`swap`çš„å‡½æ•°å®ç°çš„ã€‚é‚£ä¹ˆ`swap`ä¸ä¹‹å‰çœ‹åˆ°çš„å‘é‡åŠ æ³•å¾ˆå¥½åœ°é…åˆï¼Œå³`swap(v
    + w)`å§‹ç»ˆä¸`swap(v) + swap(w)`ç›¸åŒã€‚åŒæ ·ï¼Œå¦‚æœæˆ‘ä»¬æ‹‰ä¼¸ä¸€ä¸ªå‘é‡ç„¶åäº¤æ¢ï¼ˆå³æ ‡é‡ä¹˜æ³•ï¼‰ï¼Œè¿™å°±åƒæˆ‘ä»¬å…ˆäº¤æ¢ç„¶åæ‹‰ä¼¸ä¸€æ ·ï¼š`swap(a
    * v) = a * swap(v)`ã€‚ä»»ä½•å…·æœ‰è¿™ä¸¤ä¸ªç‰¹æ€§çš„å‡½æ•°éƒ½æ˜¯**çº¿æ€§**å‡½æ•°ã€‚
- en: A *linear function* is a function *f* such that *f*(*ax* + *by*) = *af*(*x*)
    + *bf*(*y*) for all scalars *a* and *b* and all vectors *x* and *y*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ª**çº¿æ€§å‡½æ•°**æ˜¯ä¸€ä¸ªå‡½æ•°**f**ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰æ ‡é‡**a**å’Œ**b**ä»¥åŠæ‰€æœ‰å‘é‡**x**å’Œ**y**ï¼Œæœ‰**f**(ax + by) =
    af(x) + bf(y)ã€‚
- en: 'Exercise C.2: Linearity check'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ C.2ï¼šçº¿æ€§æ£€æŸ¥
- en: Which of the following functions are linear?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å“ªä¸ªå‡½æ•°æ˜¯çº¿æ€§çš„ï¼Ÿ
- en: '*f*(*x*) = 2^(*x*)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f**(x) = 2^x'
- en: '*f*(*x*) = *x*Â²'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f**(x) = xÂ²'
- en: '*f*(*x*) = 2*x*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f**(x) = 2x'
- en: Linear functions are common in computer graphics and machine learning, as they
    include a variety of different ways of transforming vectors of numbers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿æ€§å‡½æ•°åœ¨è®¡ç®—æœºå›¾å½¢å­¦å’Œæœºå™¨å­¦ä¹ ä¸­å¾ˆå¸¸è§ï¼Œå› ä¸ºå®ƒä»¬åŒ…æ‹¬å°†æ•°å­—å‘é‡è¿›è¡Œå„ç§å˜æ¢çš„ä¸åŒæ–¹å¼ã€‚
- en: 'These are some examples of linear functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯çº¿æ€§å‡½æ•°çš„ä¸€äº›ä¾‹å­ï¼š
- en: Rotations
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ—‹è½¬
- en: Scaling and stretching
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¼©æ”¾å’Œæ‹‰ä¼¸
- en: Reflections
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åå°„
- en: All of these linear functions have in common that we can break them apart and
    understand them piece by piece. Thinking again of the map, if weâ€™re trying to
    find our way to the party (hopefully thereâ€™s still some punch left) and the map
    weâ€™ve been given has been stretched by 10% in the north-south direction and flipped
    in the east-west direction, thatâ€™s not too hard to figure out. Since both the
    stretching and flipping are linear functions, someone can set us on the right
    path by telling us what happened to the north-south direction and the east-west
    direction separately. In fact, we just did that at the beginning of this paragraph!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›çº¿æ€§å‡½æ•°éƒ½æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯æˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬æ‹†åˆ†å¹¶é€ä¸ªç†è§£ã€‚å†æ¬¡æƒ³åˆ°åœ°å›¾ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾æ‰¾åˆ°æ´¾å¯¹çš„è·¯çº¿ï¼ˆå¸Œæœ›è¿˜æœ‰ä¸€äº›æœæ±å‰©ä¸‹ï¼‰ï¼Œè€Œæˆ‘ä»¬å¾—åˆ°çš„åœ°å›¾åœ¨å—åŒ—æ–¹å‘ä¸Šæ‹‰ä¼¸äº†10%ï¼Œåœ¨ä¸œè¥¿æ–¹å‘ä¸Šç¿»è½¬äº†ï¼Œè¿™å¹¶ä¸éš¾ç†è§£ã€‚ç”±äºæ‹‰ä¼¸å’Œç¿»è½¬éƒ½æ˜¯çº¿æ€§å‡½æ•°ï¼Œæœ‰äººå¯ä»¥é€šè¿‡åˆ†åˆ«å‘Šè¯‰æˆ‘ä»¬å—åŒ—æ–¹å‘å’Œä¸œè¥¿æ–¹å‘å‘ç”Ÿäº†ä»€ä¹ˆæ¥å¼•å¯¼æˆ‘ä»¬èµ°ä¸Šæ­£ç¡®çš„é“è·¯ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬åœ¨æœ¬æ®µçš„å¼€å¤´å°±åšäº†è¿™æ ·çš„äº‹æƒ…ï¼
- en: Tip If you learn just one thing from this book, the most important takeaway
    we have to offer is that you can understand linear functions and thus quantum
    operations by *breaking them into components*. Weâ€™ll see in the rest of the book
    that, since operations in quantum computing are described by linear functions,
    we can understand quantum algorithms by breaking them apart in the same way as
    we broke up our map example. Donâ€™t worry if that doesnâ€™t make a lot of sense at
    the momentâ€”itâ€™s a way of thinking that takes some getting used to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å°è´´å£«ï¼šå¦‚æœä½ ä»è¿™æœ¬ä¹¦ä¸­å­¦åˆ°äº†ä¸€ä»¶äº‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ€é‡è¦çš„æ”¶è·å°±æ˜¯ä½ å¯ä»¥é€šè¿‡å°†å®ƒä»¬åˆ†è§£æˆç»„ä»¶æ¥ç†è§£çº¿æ€§å‡½æ•°ä»¥åŠé‡å­æ“ä½œã€‚åœ¨æœ¬ä¹¦çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ï¼Œç”±äºé‡å­è®¡ç®—ä¸­çš„æ“ä½œç”±çº¿æ€§å‡½æ•°æè¿°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†å®ƒä»¬æ‹†åˆ†çš„æ–¹å¼æ¥ç†è§£é‡å­ç®—æ³•ã€‚ä¸è¦æ‹…å¿ƒè¿™ç›®å‰å¬èµ·æ¥ä¸å¤ªæ˜ç™½â€”â€”è¿™æ˜¯ä¸€ç§éœ€è¦ä¸€æ®µæ—¶é—´é€‚åº”çš„æ€ç»´æ–¹å¼ã€‚
- en: 'This is because once we understand what happens to the north vector (letâ€™s
    call it `[[1], [0]]` as before) and the west vector (letâ€™s call it `[[0], [1]]`),
    we can figure out what happens to *all* vectors by using the linearity property.
    For example, if we are told thereâ€™s a really pretty sight three blocks north and
    four blocks west of us, and we want to figure out where that is on our map, we
    can do so piece by piece:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å› ä¸ºä¸€æ—¦æˆ‘ä»¬äº†è§£äº†åŒ—å‘é‡ï¼ˆè®©æˆ‘ä»¬åƒä¹‹å‰ä¸€æ ·ç§°ä¹‹ä¸º`[[1], [0]]`ï¼‰å’Œè¥¿å‘é‡ï¼ˆè®©æˆ‘ä»¬ç§°ä¹‹ä¸º`[[0], [1]]`ï¼‰å‘ç”Ÿäº†ä»€ä¹ˆï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä½¿ç”¨çº¿æ€§æ€§è´¨æ¥æ‰¾å‡ºæ‰€æœ‰å‘é‡å‘ç”Ÿäº†ä»€ä¹ˆã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬è¢«å‘ŠçŸ¥åœ¨æˆ‘ä»¬åŒ—è¾¹ä¸‰å—åœ°æ–¹å’Œè¥¿è¾¹å››å—åœ°æ–¹æœ‰ä¸€ä¸ªéå¸¸æ¼‚äº®çš„æ™¯è‰²ï¼Œè€Œæˆ‘ä»¬æƒ³æ‰¾å‡ºè¿™åœ¨åœ°å›¾ä¸Šçš„ä½ç½®ï¼Œæˆ‘ä»¬å¯ä»¥é€ä¸ªéƒ¨åˆ†åœ°è¿™æ ·åšï¼š
- en: We need to stretch the north vector by 10% and multiply it by 3, getting `[[3.3],
    [0]]`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦å°†åŒ—å‘é‡æ‹‰ä¼¸10%ï¼Œç„¶åä¹˜ä»¥3ï¼Œå¾—åˆ°`[[3.3], [0]]`ã€‚
- en: We need to flip the west vector and multiply it by 4, getting `[[0], [-4]]`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ç¿»è½¬è¥¿å‘é‡å¹¶å°†å…¶ä¹˜ä»¥4ï¼Œå¾—åˆ°`[[0], [-4]]`ã€‚
- en: We finish by adding what happens to each direction, getting `[[3.3], [-4]]`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡æ·»åŠ æ¯ä¸ªæ–¹å‘å‘ç”Ÿçš„äº‹æƒ…æ¥å®Œæˆï¼Œå¾—åˆ°`[[3.3], [-4]]`ã€‚
- en: Linear functions are pretty special! ğŸ’–
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿æ€§å‡½æ•°éå¸¸ç‰¹åˆ«ï¼ğŸ’–
- en: In the previous example, we were able to stretch our vectors using a linear
    function. This is because linear functions arenâ€™t sensitive to scale. Swapping
    northâ€“south and eastâ€“west does the same thing to vectors, whether theyâ€™re represented
    in steps, blocks, miles, furlongs, or parsecs. Thatâ€™s not true of most functions,
    though. Consider a function that squares its input, *f*(*x*) = *x*Â². The larger
    *x* is, the more it gets stretched.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨çº¿æ€§å‡½æ•°æ‹‰ä¼¸æˆ‘ä»¬çš„å‘é‡ã€‚è¿™æ˜¯å› ä¸ºçº¿æ€§å‡½æ•°å¯¹å°ºåº¦ä¸æ•æ„Ÿã€‚äº¤æ¢å—åŒ—å’Œä¸œè¥¿å¯¹å‘é‡æ‰€åšçš„åŒæ ·çš„äº‹æƒ…ï¼Œæ— è®ºå®ƒä»¬æ˜¯ä»¥æ­¥ã€åŒºå—ã€è‹±é‡Œã€è‹±å¯»è¿˜æ˜¯ç§’å·®è·æ¥è¡¨ç¤ºã€‚ç„¶è€Œï¼Œå¤§å¤šæ•°å‡½æ•°å¹¶ä¸æ˜¯è¿™æ ·ã€‚è€ƒè™‘ä¸€ä¸ªå¹³æ–¹å…¶è¾“å…¥çš„å‡½æ•°ï¼Œ*f*(*x*)
    = *x*Â²ã€‚*x*è¶Šå¤§ï¼Œæ‹‰ä¼¸å¾—è¶Šå¤šã€‚
- en: 'Linear functions work the same way no matter how large or small their inputs
    are, which is precisely what lets us break them down piece by piece: once we know
    how a linear function works at *any* scale, we know how it works at *all* scales.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿æ€§å‡½æ•°æ— è®ºå…¶è¾“å…¥å¤§å°å¦‚ä½•éƒ½æŒ‰ç›¸åŒçš„æ–¹å¼å·¥ä½œï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬èƒ½å¤Ÿé€ä¸ªéƒ¨åˆ†åœ°åˆ†è§£å®ƒä»¬çš„åŸå› ï¼šä¸€æ—¦æˆ‘ä»¬çŸ¥é“çº¿æ€§å‡½æ•°åœ¨*ä»»ä½•*å°ºåº¦ä¸Šçš„å·¥ä½œæ–¹å¼ï¼Œæˆ‘ä»¬å°±çŸ¥é“å®ƒåœ¨*æ‰€æœ‰*å°ºåº¦ä¸Šçš„å·¥ä½œæ–¹å¼ã€‚
- en: Thus, we need to look 3.3 blocks north and 4 blocks east on our map.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦åœ¨åœ°å›¾ä¸Šå‘åŒ—çœ‹3.3ä¸ªåŒºå—ï¼Œå‘ä¸œçœ‹4ä¸ªåŒºå—ã€‚
- en: Later, weâ€™ll see how the bits â€œ0â€ and â€œ1â€ can be thought of as directions or
    vectors, not too different from north or east. In the same way that north and
    east arenâ€™t the best vectors to help you understand Minneapolis, weâ€™ll find that
    â€œ0â€ and â€œ1â€ arenâ€™t always the best vectors to help understand quantum computing
    (figure C.5).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹åï¼Œæˆ‘ä»¬å°†çœ‹åˆ°â€œ0â€å’Œâ€œ1â€ä½å¯ä»¥è¢«è§†ä¸ºæ–¹å‘æˆ–å‘é‡ï¼Œä¸åŒ—æˆ–ä¸œå¹¶ä¸å¤ªä¸åŒã€‚æ­£å¦‚åŒ—å’Œä¸œä¸æ˜¯å¸®åŠ©ç†è§£æ˜å°¼é˜¿æ³¢åˆ©æ–¯çš„æœ€ä½³å‘é‡ä¸€æ ·ï¼Œæˆ‘ä»¬å°†å‘ç°â€œ0â€å’Œâ€œ1â€å¹¶ä¸æ€»æ˜¯å¸®åŠ©ç†è§£é‡å­è®¡ç®—çš„æœ€ä½³å‘é‡ï¼ˆè§å›¾C.5ï¼‰ã€‚
- en: '![](../Images/C-5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-5.png)'
- en: Figure C.5 North and west arenâ€™t always the best directions to use if we want
    to understand where weâ€™re going. In this map of downtown Minneapolis, a large
    section of the downtown grid is rotated to match the bend in the Mississippi River.
    Photo by davecito.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.5 å¦‚æœæˆ‘ä»¬æƒ³è¦äº†è§£å»å“ªé‡Œï¼ŒåŒ—å’Œè¥¿å¹¶ä¸æ€»æ˜¯æœ€ä½³çš„æ–¹å‘ã€‚åœ¨è¿™å¼ æ˜å°¼é˜¿æ³¢åˆ©æ–¯å¸‚ä¸­å¿ƒçš„åœ°å›¾ä¸Šï¼Œå¸‚ä¸­å¿ƒç½‘æ ¼çš„ä¸€ä¸ªå¤§åŒºåŸŸè¢«æ—‹è½¬ä»¥åŒ¹é…å¯†è¥¿è¥¿æ¯”æ²³çš„å¼¯æ›²ã€‚ç…§ç‰‡ç”±davecitoæ‹æ‘„ã€‚
- en: This way of understanding linear functions by breaking them apart piece by piece
    works for rotations, too. If our map has the compass rotated by 45Â° clockwise
    (wow, we need a serious lesson in cartography), so that north becomes northeast
    and west becomes northwest, we can still figure out where things are piece by
    piece. Using the same example, the north vector is now mapped to approximately
    `[[0.707], [0.707]]` on the map, and the west vector is mapped to `[[-0.707],
    [0.707]]`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡é€éƒ¨åˆ†åˆ†è§£çº¿æ€§å‡½æ•°æ¥ç†è§£çº¿æ€§å‡½æ•°çš„æ–¹æ³•ä¹Ÿé€‚ç”¨äºæ—‹è½¬ã€‚å¦‚æœæˆ‘ä»¬çš„æ˜ å°„å°†æŒ‡å—é’ˆé¡ºæ—¶é’ˆæ—‹è½¬45Â°ï¼ˆå“‡ï¼Œæˆ‘ä»¬éœ€è¦ä¸Šä¸€å ‚ä¸¥è‚ƒçš„åˆ¶å›¾è¯¾ï¼‰ï¼Œä½¿å¾—åŒ—æ–¹å˜ä¸ºä¸œåŒ—æ–¹ï¼Œè¥¿æ–¹å˜ä¸ºè¥¿åŒ—æ–¹ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥é€éƒ¨åˆ†åœ°æ‰¾å‡ºäº‹ç‰©çš„ä½ç½®ã€‚ä½¿ç”¨ç›¸åŒçš„ä¾‹å­ï¼ŒåŒ—å‘é‡ç°åœ¨åœ¨åœ°å›¾ä¸Šè¢«æ˜ å°„åˆ°å¤§çº¦`[[0.707],
    [0.707]]`ï¼Œè€Œè¥¿å‘é‡è¢«æ˜ å°„åˆ°`[[-0.707], [0.707]]`ã€‚
- en: When we sum up what happens in the example, we get `3 * [[0.707], [0.707]] +
    4 * [[-0.707], [0.707]]`, which is equal to `(3 - 4) * [[0.707], [0]] + (3 + 4)
    [[0], [0.707]]`, giving us `[[-0.707], [4.95]]`. It might seem that this has less
    to do with linearity and more to do with north and west being somehow special.
    However, we could have run through *exactly* the same argument but writing southwest
    as `[[1], [0]]` and northwest as `[[0], [1]]`. This works because southwest and
    northwest are perpendicular to each other, allowing us to break down any other
    direction as a combination of northwest and southwest. Other than ease of reading
    a compass that we buy off a shelf, thereâ€™s nothing that makes north or west special.
    If youâ€™ve ever tried to drive around downtown Minneapolis (see figure C.5), it
    quickly becomes apparent that north and west arenâ€™t always the best way to understand
    directions!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å°†ä¾‹å­ä¸­çš„æ‰€æœ‰æƒ…å†µåŠ æ€»èµ·æ¥ï¼Œæˆ‘ä»¬å¾—åˆ°`3 * [[0.707], [0.707]] + 4 * [[-0.707], [0.707]]`ï¼Œè¿™ç­‰äº`(3
    - 4) * [[0.707], [0]] + (3 + 4) [[0], [0.707]]`ï¼Œç»“æœæ˜¯`[[-0.707], [4.95]]`ã€‚è¿™ä¼¼ä¹ä¸çº¿æ€§å…³ç³»è¾ƒå°‘ï¼Œè€Œä¸åŒ—å’Œè¥¿åœ¨æŸäº›æ–¹é¢æ˜¯ç‰¹æ®Šçš„æœ‰å…³ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å®Œå…¨ç›¸åŒçš„è®ºè¯ï¼Œå°†è¥¿å—å†™ä½œ`[[1],
    [0]]`ï¼Œè¥¿åŒ—å†™ä½œ`[[0], [1]]`ã€‚è¿™æ˜¯å› ä¸ºè¥¿å—å’Œè¥¿åŒ—ç›¸äº’å‚ç›´ï¼Œå…è®¸æˆ‘ä»¬å°†ä»»ä½•å…¶ä»–æ–¹å‘åˆ†è§£ä¸ºè¥¿åŒ—å’Œè¥¿å—çš„ç»„åˆã€‚é™¤äº†æˆ‘ä»¬ä¹°çš„æŒ‡å—é’ˆæ˜“äºé˜…è¯»ä¹‹å¤–ï¼Œæ²¡æœ‰å…¶ä»–ä¸œè¥¿ä½¿åŒ—æˆ–è¥¿å˜å¾—ç‰¹æ®Šã€‚å¦‚æœä½ æ›¾ç»è¯•å›¾åœ¨æ˜å°¼é˜¿æ³¢åˆ©æ–¯å¸‚ä¸­å¿ƒï¼ˆè§å›¾C.5ï¼‰å¼€è½¦ï¼Œå¾ˆå¿«å°±ä¼šå˜å¾—æ˜æ˜¾ï¼ŒåŒ—å’Œè¥¿å¹¶ä¸æ€»æ˜¯ç†è§£æ–¹å‘çš„æœ€ä½³æ–¹å¼ï¼
- en: Formally, any set of vectors that lets us understand directions by breaking
    them apart piece by piece this way is called a *basis*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å½¢å¼ä¸Šï¼Œä»»ä½•ä¸€ç»„é€šè¿‡è¿™ç§æ–¹å¼é€éƒ¨åˆ†åˆ†è§£æ¥ç†è§£æ–¹å‘çš„å‘é‡é›†åˆè¢«ç§°ä¸º**åŸº**ã€‚
- en: Note Technically, weâ€™re concerned here with what mathematicians call an *orthonormal
    basis*, as thatâ€™s most often useful in quantum computing. All that means is that
    the vectors in a basis are perpendicular to all the other basis vectors and have
    a length of 1.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: æŠ€æœ¯ä¸Šï¼Œæˆ‘ä»¬è¿™é‡Œå…³æ³¨çš„æ˜¯æ•°å­¦å®¶æ‰€è¯´çš„**æ­£äº¤å½’ä¸€åŸº**ï¼Œå› ä¸ºåœ¨é‡å­è®¡ç®—ä¸­è¿™é€šå¸¸æœ€æœ‰ç”¨ã€‚è¿™æ„å‘³ç€åŸºä¸­çš„å‘é‡ä¸æ‰€æœ‰å…¶ä»–åŸºå‘é‡å‚ç›´ï¼Œå¹¶ä¸”é•¿åº¦ä¸º1ã€‚
- en: Letâ€™s try an example of writing a vector in terms of a basis. The vector ![](../Images/AR_v.png)
    = [[2], [3]] can be written as 2![](../Images/AR_b.png)[0] + 3![](../Images/AR_b.png)[1]
    using the basis ![](../Images/AR_b.png)[0] = [[1], [0]] and ![](../Images/AR_b.png)[1]
    = [[0], [1]]].
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•ä¸€ä¸ªç”¨åŸºè¡¨ç¤ºå‘é‡çš„ä¾‹å­ã€‚å‘é‡![](../Images/AR_v.png) = [[2], [3]]å¯ä»¥ç”¨åŸº![](../Images/AR_b.png)[0]
    = [[1], [0]]å’Œ![](../Images/AR_b.png)[1] = [[0], [1]]è¡¨ç¤ºä¸º2![](../Images/AR_b.png)[0]
    + 3![](../Images/AR_b.png)[1]ã€‚
- en: Basis If any vector ![](../Images/AR_v.png) in *d* dimensions can be written
    as a sum of multiples of ![](../Images/AR_b.png)[0], ![](../Images/AR_b.png)[1],
    ...., ![](../Images/AR_b.png)[*d*â€“1], we say that ![](../Images/AR_b.png)[0],
    ![](../Images/AR_b.png)[1], ..., ![](../Images/AR_b.png)[*d*â€“1] are a *basis*.
    In two dimensions, one common basis is horizontal and vertical.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºç¡€ å¦‚æœä»»ä½• *d* ç»´å‘é‡ ![](../Images/AR_v.png) å¯ä»¥è¡¨ç¤ºä¸º ![](../Images/AR_b.png)[0]ã€![](../Images/AR_b.png)[1]ã€....ã€![](../Images/AR_b.png)[*d*â€“1]
    çš„å€æ•°ä¹‹å’Œï¼Œæˆ‘ä»¬ç§° ![](../Images/AR_b.png)[0]ã€![](../Images/AR_b.png)[1]ã€..., ![](../Images/AR_b.png)[*d*â€“1]
    ä¸ºä¸€ä¸ª *åŸº*ã€‚åœ¨äºŒç»´ç©ºé—´ä¸­ï¼Œä¸€ä¸ªå¸¸è§çš„åŸºæ˜¯æ°´å¹³å’Œå‚ç›´æ–¹å‘ã€‚
- en: More generally, if we know the output of a function *f* for each vector in a
    basis, we can compute *f* for any input. This is similar to how we use truth tables
    to describe a classical operation by listing the outputs of an operation for each
    possible input.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´ä¸€èˆ¬åœ°ï¼Œå¦‚æœæˆ‘ä»¬çŸ¥é“å‡½æ•° *f* å¯¹åŸºä¸­æ¯ä¸ªå‘é‡çš„è¾“å‡ºï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ä»»ä½•è¾“å…¥çš„ *f*ã€‚è¿™ä¸æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨çœŸå€¼è¡¨é€šè¿‡åˆ—å‡ºæ¯ä¸ªå¯èƒ½è¾“å…¥çš„æ“ä½œè¾“å‡ºæ¥æè¿°ç»å…¸æ“ä½œç±»ä¼¼ã€‚
- en: Problem solving with linearity
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨çº¿æ€§æ–¹æ³•è§£å†³é—®é¢˜
- en: Letâ€™s say `f` is a linear function that represents how our map is stretched
    and twisted. How can we find where we need to go? We want to compute the value
    `f(np .array([[2], [3]]))` (a somewhat arbitrary value) given our basis `f(np.array
    ([[1], [0]]))` (horizontal) and `f(np.array([[0], [1]]))` (vertical). We also
    know from looking at parts of the map legend that the map warps the horizontal
    direction to `np.array([[1], [1]])` and the vertical direction to `np.array([[1],
    [-1]])`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ `f` æ˜¯ä¸€ä¸ªçº¿æ€§å‡½æ•°ï¼Œå®ƒè¡¨ç¤ºæˆ‘ä»¬çš„æ˜ å°„æ˜¯å¦‚ä½•æ‹‰ä¼¸å’Œæ‰­æ›²çš„ã€‚æˆ‘ä»¬å¦‚ä½•æ‰¾åˆ°æˆ‘ä»¬éœ€è¦å»çš„åœ°æ–¹ï¼Ÿæˆ‘ä»¬æƒ³è¦è®¡ç®—å€¼ `f(np .array([[2], [3]]))`ï¼ˆä¸€ä¸ªæœ‰äº›ä»»æ„çš„å€¼ï¼‰ï¼Œç»™å®šæˆ‘ä»¬çš„åŸº
    `f(np.array ([[1], [0]]))`ï¼ˆæ°´å¹³ï¼‰å’Œ `f(np.array([[0], [1]]))`ï¼ˆå‚ç›´ï¼‰ã€‚æˆ‘ä»¬è¿˜ä»æŸ¥çœ‹åœ°å›¾å›¾ä¾‹çš„éƒ¨åˆ†çŸ¥é“ï¼Œåœ°å›¾å°†æ°´å¹³æ–¹å‘æ‰­æ›²ä¸º
    `np.array([[1], [1]])`ï¼Œå°†å‚ç›´æ–¹å‘æ‰­æ›²ä¸º `np.array([[1], [â€“1]])`ã€‚
- en: 'The steps to compute `f(np.array([[2], [3]]))` are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—å‡½æ•° `f(np.array([[2], [3]]))` çš„æ­¥éª¤å¦‚ä¸‹ï¼š
- en: We use our basis, `np.array([[1], [0]])` and `np.array([[0], [1]])`, to write
    that `np.array([[2], [3]])` is equal to `2 * np.array([[1], [0]]) + 3 * np.array([[0],
    [1]])`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬çš„åŸºï¼Œ`np.array([[1], [0]])` å’Œ `np.array([[0], [1]])`ï¼Œæ¥è¡¨ç¤º `np.array([[2],
    [3]])` ç­‰äº `2 * np.array([[1], [0]]) + 3 * np.array([[0], [1]])`ã€‚
- en: Using this new way to write our input to the function, we want to compute `f(2
    * np.array([[1], [0]]) + 3 * np.array([[0], [1]]))`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§æ–°çš„æ–¹æ³•æ¥è¡¨ç¤ºæˆ‘ä»¬çš„å‡½æ•°è¾“å…¥ï¼Œæˆ‘ä»¬æƒ³è¦è®¡ç®— `f(2 * np.array([[1], [0]]) + 3 * np.array([[0], [1]]))`ã€‚
- en: 'We use that `f` is linear to write `f(2 * np.array([[1], [0]]) + 3 * np.array([[0],
    [1]]))` as `2 * f(np.array([[1], [0]])) + 3 * f(np.array([[0], [1]]))`:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆ©ç”¨ `f` æ˜¯çº¿æ€§çš„æ€§è´¨ï¼Œå°† `f(2 * np.array([[1], [0]]) + 3 * np.array([[0], [1]]))` å†™ä½œ
    `2 * f(np.array([[1], [0]])) + 3 * f(np.array([[0], [1]]))`ï¼š
- en: '[PRE1]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: â¶ Defines variables horizontal and vertical to represent the basis we will use
    to represent [[2], [3]]
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â¶ å®šä¹‰å˜é‡ horizontal å’Œ vertical æ¥è¡¨ç¤ºæˆ‘ä»¬å°†ç”¨æ¥è¡¨ç¤º [[2], [3]] çš„åŸº
- en: â· We can write [[2], [3]] by adding multiples of horizontal and vertical.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â· æˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ  horizontal å’Œ vertical çš„å€æ•°æ¥å†™å‡º [[2], [3]]ã€‚
- en: â¸ Defines how f acts on horizontal and vertical by introducing new variables
    f_horizontal and f_vertical to represent f(horizontal) and f(vertical), respectively
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â¸ é€šè¿‡å¼•å…¥æ–°å˜é‡ f_horizontal å’Œ f_vertical æ¥è¡¨ç¤º f(horizontal) å’Œ f(vertical)ï¼Œåˆ†åˆ«å®šä¹‰ f å¯¹
    horizontal å’Œ vertical çš„ä½œç”¨
- en: â¹ Because f is linear, we can define how it works for [[2], [3]] by replacing
    horizontal and vertical by the outputs f_horizontal and f_vertical.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â¹ å› ä¸º f æ˜¯çº¿æ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ°´å¹³å’Œå‚ç›´æ›¿æ¢ä¸º f_horizontal å’Œ f_vertical æ¥å®šä¹‰å®ƒå¯¹ [[2], [3]] çš„ä½œç”¨ã€‚
- en: 'Exercise C.3: Computing linear functions'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹  C.3ï¼šè®¡ç®—çº¿æ€§å‡½æ•°
- en: Suppose that you have a linear function *É¡* such that *É¡*([[1], [0]]) = [[2.3],
    [â€“3.1]] and *É¡*([[0], [1]]) = [[â€“5.2], [0.7]]. Compute *É¡*([[2], [â€“2]]).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æœ‰ä¸€ä¸ªçº¿æ€§å‡½æ•° *É¡*ï¼Œä½¿å¾— *É¡*([[1], [0]]) = [[2.3], [â€“3.1]] å’Œ *É¡*([[0], [1]]) = [[â€“5.2],
    [0.7]]ã€‚è®¡ç®— *É¡*([[2], [â€“2]])ã€‚
- en: 'Using this insight, we can make a table of how a linear function transforms
    each of its inputs. These tables are called *matrices* and are complete descriptions
    of linear functions. If we tell you the matrix for a linear function, then you
    can compute that function for *any* vector. For example, the transformation from
    the north/east convention to the east/north convention for map directions transforms
    the instruction â€œgo one unit northâ€ from being written as `[[1], [0]]` to being
    written as `[[0], [1]]]`. Similarly, the instruction â€œgo one unit eastâ€ goes from
    being written as `[[0], [1]]` to being written as `[[1], [0]]`. If we stack up
    the outputs for both sets of instructions, we get the following matrix:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ©ç”¨è¿™ä¸ªæ´å¯ŸåŠ›ï¼Œæˆ‘ä»¬å¯ä»¥åˆ¶ä½œä¸€ä¸ªè¡¨æ ¼ï¼Œå±•ç¤ºçº¿æ€§å‡½æ•°å¦‚ä½•è½¬æ¢å…¶æ¯ä¸ªè¾“å…¥ã€‚è¿™äº›è¡¨æ ¼è¢«ç§°ä¸º*çŸ©é˜µ*ï¼Œæ˜¯çº¿æ€§å‡½æ•°çš„å®Œæ•´æè¿°ã€‚å¦‚æœæˆ‘ä»¬å‘Šè¯‰ä½ ä¸€ä¸ªçº¿æ€§å‡½æ•°çš„çŸ©é˜µï¼Œé‚£ä¹ˆä½ å¯ä»¥ä¸º*ä»»ä½•*å‘é‡è®¡ç®—è¯¥å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œä»åŒ—/ä¸œæƒ¯ä¾‹åˆ°ä¸œ/åŒ—æƒ¯ä¾‹çš„åœ°å›¾æ–¹å‘è½¬æ¢ï¼Œå°†æŒ‡ä»¤â€œå‘åŒ—ç§»åŠ¨ä¸€ä¸ªå•ä½â€ä»å†™æˆ`[[1],
    [0]]`è½¬æ¢ä¸ºå†™æˆ`[[0], [1]]]`ã€‚åŒæ ·ï¼ŒæŒ‡ä»¤â€œå‘ä¸œç§»åŠ¨ä¸€ä¸ªå•ä½â€ä»å†™æˆ`[[0], [1]]`è½¬æ¢ä¸ºå†™æˆ`[[1], [0]]`ã€‚å¦‚æœæˆ‘ä»¬å †å è¿™ä¸¤ç»„æŒ‡ä»¤çš„è¾“å‡ºï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹çŸ©é˜µï¼š
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip This is a very important matrix in quantum computing as well! Weâ€™ll see
    much more of this matrix throughout the book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤ºï¼šè¿™åœ¨é‡å­è®¡ç®—ä¸­ä¹Ÿæ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„çŸ©é˜µï¼åœ¨æ•´ä¸ªä¹¦ä¸­ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°è¿™ä¸ªçŸ©é˜µçš„å¾ˆå¤šåº”ç”¨ã€‚
- en: To apply the linear function represented by a matrix to a particular vector,
    we multiply the matrix and the vector, as illustrated in figure C.6.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å°†çŸ©é˜µè¡¨ç¤ºçš„çº¿æ€§å‡½æ•°åº”ç”¨äºç‰¹å®šçš„å‘é‡ï¼Œæˆ‘ä»¬éœ€è¦å°†çŸ©é˜µå’Œå‘é‡ç›¸ä¹˜ï¼Œå¦‚å›¾C.6æ‰€ç¤ºã€‚
- en: '![](../Images/C-6.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-6.png)'
- en: Figure C.6 How to multiply a matrix by a vector. In this example, the matrix
    for *f* tells us that *f*([[1], [0], [0]]) is [[1], [2], [9]].
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.6 å¦‚ä½•å°†çŸ©é˜µä¹˜ä»¥å‘é‡ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ*f*çš„çŸ©é˜µå‘Šè¯‰æˆ‘ä»¬*f*([[1], [0], [0]])æ˜¯[[1], [2], [9]]ã€‚
- en: Warning While the order in which we add vectors doesnâ€™t matter, the order in
    which we multiply matrices matters quite a lot. If we rotate our map by 90Â° and
    then look at it in the mirror, we get a very different picture than if we rotate
    what we see in the mirror by 90Â°. Both rotation and flipping are linear functions,
    so we can write a matrix for each; letâ€™s call them *r* and *f*, respectively.
    If we flip a vector ![](../Images/AR_x.png), we get *f* ![](../Images/AR_x.png).
    Rotating the output gives us *RF* ![](../Images/AR_x.png), a very different vector
    than if we rotated first, *FR*![](../Images/AR_x.png).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: è­¦å‘Šï¼šè™½ç„¶æˆ‘ä»¬æ·»åŠ å‘é‡çš„é¡ºåºä¸é‡è¦ï¼Œä½†æˆ‘ä»¬ä¹˜ä»¥çŸ©é˜µçš„é¡ºåºéå¸¸é‡è¦ã€‚å¦‚æœæˆ‘ä»¬å°†åœ°å›¾æ—‹è½¬90Â°ç„¶åé€šè¿‡é•œå­çœ‹å®ƒï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªéå¸¸ä¸åŒçš„å›¾åƒï¼Œå¦‚æœæˆ‘ä»¬å…ˆæ—‹è½¬é•œå­ä¸­çš„å›¾åƒ90Â°ï¼Œç»“æœä¼šå®Œå…¨ä¸åŒã€‚æ—‹è½¬å’Œç¿»è½¬éƒ½æ˜¯çº¿æ€§å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸ªå‡½æ•°å†™ä¸€ä¸ªçŸ©é˜µï¼›è®©æˆ‘ä»¬åˆ†åˆ«ç§°å®ƒä»¬ä¸º*r*å’Œ*f*ã€‚å¦‚æœæˆ‘ä»¬ç¿»è½¬å‘é‡
    ![](../Images/AR_x.png)ï¼Œæˆ‘ä»¬å¾—åˆ°*f* ![](../Images/AR_x.png)ã€‚æ—‹è½¬è¾“å‡ºç»™æˆ‘ä»¬*RF* ![](../Images/AR_x.png)ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸å…ˆæ—‹è½¬å†ç¿»è½¬çš„*FR*![](../Images/AR_x.png)éå¸¸ä¸åŒçš„å‘é‡ã€‚
- en: Matrix multiplication formalizes the way we computed `f` given its outputs for
    a particular set of inputs by â€œstackingâ€ the outputs of `f` for vectors like `[[1],
    [0], [0]]` and `[[0], [1], [0]]`, as illustrated in figure C.6\. While the actual
    sizes of the matrices and vectors may change, this idea that a matrix can describe
    a linear transformation stays the same. For the rest of this appendix, weâ€™ll look
    at linear transformations on vectors of length 2\. We can think of each row (the
    outermost index in NumPy) of a matrix as how the function acts on a particular
    input.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µä¹˜æ³•å½¢å¼åŒ–äº†æˆ‘ä»¬åœ¨ç»™å®šç‰¹å®šè¾“å…¥çš„è¾“å‡ºæ—¶è®¡ç®—`f`çš„æ–¹å¼ï¼Œé€šè¿‡â€œå †å â€`f`å¯¹äºå‘é‡å¦‚`[[1], [0], [0]]`å’Œ`[[0], [1], [0]]`çš„è¾“å‡ºï¼Œå¦‚å›¾C.6æ‰€ç¤ºã€‚è™½ç„¶çŸ©é˜µå’Œå‘é‡çš„å®é™…å¤§å°å¯èƒ½ä¼šæ”¹å˜ï¼Œä½†çŸ©é˜µå¯ä»¥æè¿°çº¿æ€§å˜æ¢è¿™ä¸€æƒ³æ³•ä¿æŒä¸å˜ã€‚åœ¨æœ¬é™„å½•çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹é•¿åº¦ä¸º2çš„å‘é‡çš„çº¿æ€§å˜æ¢ã€‚æˆ‘ä»¬å¯ä»¥å°†çŸ©é˜µçš„æ¯ä¸€è¡Œï¼ˆNumPyçš„å¤–å±‚ç´¢å¼•ï¼‰è§†ä¸ºå‡½æ•°å¯¹ç‰¹å®šè¾“å…¥çš„ä½œç”¨ã€‚
- en: 'DEEP DIVE: Why do we multiply functions?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: æ·±å…¥æ¢è®¨ï¼šä¸ºä»€ä¹ˆæˆ‘ä»¬è¦ä¹˜ä»¥å‡½æ•°ï¼Ÿ
- en: When we multiply a matrix by a vector (or even by a matrix by a matrix), weâ€™re
    doing something that seems a bit odd at first. After all, matrices are another
    way of representing linear functions, so what does it mean to multiply a function
    by its input, let alone by another function?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å°†ä¸€ä¸ªçŸ©é˜µä¹˜ä»¥ä¸€ä¸ªå‘é‡ï¼ˆç”šè‡³æ˜¯ä¸€ä¸ªçŸ©é˜µä¹˜ä»¥å¦ä¸€ä¸ªçŸ©é˜µï¼‰æ—¶ï¼Œä¸€å¼€å§‹è¿™ä¼¼ä¹æœ‰ç‚¹å¥‡æ€ªã€‚æ¯•ç«Ÿï¼ŒçŸ©é˜µæ˜¯è¡¨ç¤ºçº¿æ€§å‡½æ•°çš„å¦ä¸€ç§æ–¹å¼ï¼Œé‚£ä¹ˆä¹˜ä»¥å‡½æ•°çš„è¾“å…¥ï¼Œæ›´ä¸ç”¨è¯´ä¹˜ä»¥å¦ä¸€ä¸ªå‡½æ•°ï¼Œæ„å‘³ç€ä»€ä¹ˆå‘¢ï¼Ÿ
- en: To answer this, itâ€™s helpful to go back to ordinary algebra for a moment, where
    for any variables *a*, *b*, and *c*, *a*(*b* + *c*) = *ab* *+* *ac*. This property,
    known as the *distributive property*, is fundamental to how multiplication and
    addition interact with each other. In fact, itâ€™s so fundamental that the distributive
    property is one of the key ways we define what multiplication isâ€”in number theory
    and other, more abstract, parts of math, researchers often work with objects known
    as *rings*, where all we really know about multiplication is that it distributes
    over addition. Although posed as an abstract concept, the study of rings and other
    similar algebraic objects has broad applications, especially in cryptography and
    error correction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å›ç­”è¿™ä¸ªé—®é¢˜ï¼Œæš‚æ—¶å›åˆ°æ™®é€šçš„ä»£æ•°æ˜¯æœ‰å¸®åŠ©çš„ï¼Œåœ¨é‚£é‡Œå¯¹äºä»»ä½•å˜é‡ *a*ã€*b* å’Œ *c*ï¼Œæœ‰ *a*(*b* + *c*) = *ab* *+* *ac*ã€‚è¿™ä¸ªæ€§è´¨è¢«ç§°ä¸º
    *åˆ†é…å¾‹*ï¼Œæ˜¯ä¹˜æ³•å’ŒåŠ æ³•ç›¸äº’ä½œç”¨çš„åŸºç¡€ã€‚äº‹å®ä¸Šï¼Œå®ƒå¦‚æ­¤åŸºç¡€ï¼Œä»¥è‡³äºåˆ†é…å¾‹æ˜¯æˆ‘ä»¬å®šä¹‰ä¹˜æ³•çš„å…³é”®æ–¹å¼ä¹‹ä¸€â€”â€”åœ¨æ•°è®ºå’Œå…¶ä»–æ›´æŠ½è±¡çš„æ•°å­¦éƒ¨åˆ†ï¼Œç ”ç©¶äººå‘˜ç»å¸¸ä½¿ç”¨ç§°ä¸º
    *ç¯* çš„å¯¹è±¡ï¼Œæˆ‘ä»¬çœŸæ­£äº†è§£çš„ä¹˜æ³•åªæ˜¯å®ƒå¯¹åŠ æ³•è¿›è¡Œåˆ†é…ã€‚å°½ç®¡è¿™æ˜¯ä¸€ä¸ªæŠ½è±¡çš„æ¦‚å¿µï¼Œä½†ç¯å’Œå…¶ä»–ç±»ä¼¼ä»£æ•°å¯¹è±¡çš„ç ”ç©¶æœ‰å¹¿æ³›çš„åº”ç”¨ï¼Œå°¤å…¶æ˜¯åœ¨å¯†ç å­¦å’Œé”™è¯¯çº æ­£ä¸­ã€‚
- en: The distributive property looks very similar to the linearity property, though,
    that *f*(*x* + *y*) = *f*(*x*) + *f*(*y*). If we think of *f* as being a part
    of a ring, then the distributive property is identical to the linearity property.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†é…å¾‹çœ‹èµ·æ¥ä¸çº¿æ€§æ€§è´¨éå¸¸ç›¸ä¼¼ï¼Œå³ *f*(*x* + *y*) = *f*(*x*) + *f*(*y*)ã€‚å¦‚æœæˆ‘ä»¬æŠŠ *f* è§†ä¸ºä¸€ä¸ªç¯çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆåˆ†é…å¾‹ä¸çº¿æ€§æ€§è´¨æ˜¯ç›¸åŒçš„ã€‚
- en: Put differently, just as programmers like to reuse code, mathematicians like
    to reuse *concepts*. Thinking of multiplying matrices together lets us treat linear
    functions in many of the same ways weâ€™re used to from algebra.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œå°±åƒç¨‹åºå‘˜å–œæ¬¢é‡ç”¨ä»£ç ä¸€æ ·ï¼Œæ•°å­¦å®¶å–œæ¬¢é‡ç”¨ *æ¦‚å¿µ*ã€‚è€ƒè™‘çŸ©é˜µç›¸ä¹˜çš„æƒ³æ³•è®©æˆ‘ä»¬èƒ½å¤Ÿä»¥æˆ‘ä»¬ä¹ æƒ¯çš„ä»£æ•°æ–¹å¼å¤„ç†çº¿æ€§å‡½æ•°ã€‚
- en: Thus, if we want to know the *i*th element of a vector ![](../Images/AR_x.png)
    that has been rotated by a matrix *M*, we can find the output of *M* for each
    element in ![](../Images/AR_x.png), sum the resulting vectors, and take the `i`th
    element. In NumPy, matrix multiplication is represented by the `@` operator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³çŸ¥é“ä¸€ä¸ªç»è¿‡çŸ©é˜µ *M* æ—‹è½¬çš„å‘é‡ ![](../Images/AR_x.png) çš„ *i* ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ° *M* å¯¹ ![](../Images/AR_x.png)
    ä¸­æ¯ä¸ªå…ƒç´ çš„è¾“å‡ºï¼Œå°†è¿™äº›ç»“æœå‘é‡ç›¸åŠ ï¼Œå¹¶å–ç¬¬ `i` ä¸ªå…ƒç´ ã€‚åœ¨ NumPy ä¸­ï¼ŒçŸ©é˜µä¹˜æ³•ç”± `@` è¿ç®—ç¬¦è¡¨ç¤ºã€‚
- en: Note The following code sample only works in Python 3.5 or later.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šä»¥ä¸‹ä»£ç ç¤ºä¾‹ä»…åœ¨ Python 3.5 æˆ–æ›´é«˜ç‰ˆæœ¬ä¸­æœ‰æ•ˆã€‚
- en: Listing C.2 Matrix multiplication with the `@` operator
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ C.2 ä½¿ç”¨ `@` è¿ç®—ç¬¦è¿›è¡ŒçŸ©é˜µä¹˜æ³•
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Exercise C.4: Matrix multiplication'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹  C.4ï¼šçŸ©é˜µä¹˜æ³•
- en: Let *X* be the matrix [[0, 1], [1, 0]], and let ![](../Images/AR_y.png) be the
    vector [[2], [3]]. Using NumPy, compute *X*![](../Images/AR_y.png) and *XX*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ *X* ä¸ºçŸ©é˜µ [[0, 1], [1, 0]]ï¼Œè®¾ ![](../Images/AR_y.png) ä¸ºå‘é‡ [[2], [3]]ã€‚ä½¿ç”¨ NumPy
    è®¡ç®— *X*![](../Images/AR_y.png) å’Œ *XX*ã€‚
- en: Why NumPy?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé€‰æ‹© NumPyï¼Ÿ
- en: We could have written all of the previous matrix multiplication by hand, but
    there are a few reasons itâ€™s very nice to work with NumPy instead. Most of the
    core of NumPy uses constant-time indexing and is implemented in native code so
    it can take advantage of built-in processor instructions for fast linear algebra.
    Thus, NumPy is often much, much faster than manipulating lists by hand. In listing
    C.3, we show an example where NumPy can speed up multiplying even very small matrices
    by 10Ã—. When we look at larger matrices in chapters 4 and later, using NumPy versus
    doing things by hand gives us even more of an advantage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨å†™å‡ºæ‰€æœ‰çš„çŸ©é˜µä¹˜æ³•ï¼Œä½†æœ‰å‡ ä¸ªåŸå› ä½¿å¾—ä½¿ç”¨ NumPy éå¸¸æ–¹ä¾¿ã€‚NumPy çš„æ ¸å¿ƒå¤§éƒ¨åˆ†ä½¿ç”¨å¸¸æ•°æ—¶é—´ç´¢å¼•ï¼Œå¹¶ä¸”æ˜¯ç”¨åŸç”Ÿä»£ç å®ç°çš„ï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨å†…ç½®å¤„ç†å™¨çš„æŒ‡ä»¤è¿›è¡Œå¿«é€Ÿçº¿æ€§ä»£æ•°ã€‚å› æ­¤ï¼ŒNumPy
    é€šå¸¸æ¯”æ‰‹åŠ¨æ“ä½œåˆ—è¡¨å¿«å¾—å¤šã€‚åœ¨åˆ—è¡¨ C.3 ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº† NumPy å¯ä»¥å°†éå¸¸å°çš„çŸ©é˜µçš„ä¹˜æ³•é€Ÿåº¦æé«˜ 10 å€ã€‚å½“æˆ‘ä»¬æŸ¥çœ‹ç¬¬ 4 ç« åŠä»¥åçš„è¾ƒå¤§çŸ©é˜µæ—¶ï¼Œä½¿ç”¨
    NumPy è€Œä¸æ˜¯æ‰‹åŠ¨æ“ä½œç»™æˆ‘ä»¬å¸¦æ¥äº†æ›´å¤§çš„ä¼˜åŠ¿ã€‚
- en: Listing C.3 Timing NumPy evaluation for matrix multiplication
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ C.3 NumPy çŸ©é˜µä¹˜æ³•è¯„ä¼°è®¡æ—¶
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: â¶ This time, we use the IPython interpreter for Python, as it provides a few
    extra tools that are helpful in this example. See appendix A for instructions
    on how to install IPython.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ è¿™æ¬¡ï¼Œæˆ‘ä»¬ä½¿ç”¨ Python çš„ IPython è§£é‡Šå™¨ï¼Œå› ä¸ºå®ƒæä¾›äº†å‡ ä¸ªåœ¨è¿™ä¸ªä¾‹å­ä¸­æœ‰ç”¨çš„é¢å¤–å·¥å…·ã€‚æœ‰å…³å¦‚ä½•å®‰è£… IPython çš„è¯´æ˜ï¼Œè¯·å‚é˜…é™„å½•
    Aã€‚
- en: â· Finds the sizes of each matrix that we need to multiply. If weâ€™re representing
    matrices by lists of lists, then each element of the outer list is a row. That
    is, an *n* Ã— *m* matrix has n rows and m columns when written out this way.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: â· æ‰¾å‡ºæˆ‘ä»¬éœ€è¦ç›¸ä¹˜çš„æ¯ä¸ªçŸ©é˜µçš„å¤§å°ã€‚å¦‚æœæˆ‘ä»¬ç”¨åˆ—è¡¨çš„åˆ—è¡¨æ¥è¡¨ç¤ºçŸ©é˜µï¼Œé‚£ä¹ˆå¤–å±‚åˆ—è¡¨çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ª *n* Ã— *m* çŸ©é˜µåœ¨è¿™æ ·å†™å‡ºæ¥æ—¶æœ‰
    n è¡Œå’Œ m åˆ—ã€‚
- en: â¸ The inner dimensions of both matrices need to agree in order for matrix multiplication
    to make sense. Thinking of each matrix as representing a linear function, the
    first index (the number of rows) tells us how large each output is, while the
    second index (the number of columns) tells us how large each input is. Thus we
    need the outputs from the first function to be applied (the one on the right)
    to be of the same size as the inputs to the second function. This line checks
    that condition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ä¸ºäº†ä½¿çŸ©é˜µä¹˜æ³•æœ‰æ„ä¹‰ï¼Œä¸¤ä¸ªçŸ©é˜µçš„å†…ç»´å¿…é¡»ä¸€è‡´ã€‚å°†æ¯ä¸ªçŸ©é˜µè§†ä¸ºè¡¨ç¤ºä¸€ä¸ªçº¿æ€§å‡½æ•°ï¼Œç¬¬ä¸€ä¸ªç´¢å¼•ï¼ˆè¡Œæ•°ï¼‰å‘Šè¯‰æˆ‘ä»¬æ¯ä¸ªè¾“å‡ºæœ‰å¤šå¤§ï¼Œè€Œç¬¬äºŒä¸ªç´¢å¼•ï¼ˆåˆ—æ•°ï¼‰å‘Šè¯‰æˆ‘ä»¬æ¯ä¸ªè¾“å…¥æœ‰å¤šå¤§ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ç¬¬ä¸€ä¸ªå‡½æ•°çš„è¾“å‡ºï¼ˆå³ä¾§çš„é‚£ä¸ªï¼‰ä¸ç¬¬äºŒä¸ªå‡½æ•°çš„è¾“å…¥å¤§å°ç›¸åŒã€‚è¿™ä¸€è¡Œæ£€æŸ¥äº†è¿™ä¸ªæ¡ä»¶ã€‚
- en: â¹ To actually compute the matrix product of A and B, we need to compute each
    element in the product and pack them into a list of lists.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ è¦å®é™…è®¡ç®—çŸ©é˜µAå’ŒBçš„ä¹˜ç§¯ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—ä¹˜ç§¯ä¸­çš„æ¯ä¸ªå…ƒç´ å¹¶å°†å®ƒä»¬æ‰“åŒ…æˆä¸€ä¸ªåˆ—è¡¨çš„åˆ—è¡¨ã€‚
- en: âº We can find each element by summing over where the output from B is passed
    as input to A, similar to how we represented the product of a matrix with a vector
    in figure C.6.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: âº æˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹Bçš„è¾“å‡ºä¼ é€’ç»™Aä½œä¸ºè¾“å…¥çš„åœ°æ–¹è¿›è¡Œæ±‚å’Œæ¥æ‰¾åˆ°æ¯ä¸ªå…ƒç´ ï¼Œè¿™ä¸æˆ‘ä»¬åœ¨å›¾C.6ä¸­è¡¨ç¤ºçŸ©é˜µä¸å‘é‡çš„ä¹˜ç§¯çš„æ–¹å¼ç±»ä¼¼ã€‚
- en: â» For comparison, we can import NumPy, which provides us with a matrix multiplication
    implementation that uses modern processor instructions to accelerate the computation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: â» ä¸ºäº†è¿›è¡Œæ¯”è¾ƒï¼Œæˆ‘ä»¬å¯ä»¥å¯¼å…¥NumPyï¼Œå®ƒä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªä½¿ç”¨ç°ä»£å¤„ç†å™¨æŒ‡ä»¤åŠ é€Ÿè®¡ç®—çš„çŸ©é˜µä¹˜æ³•å®ç°ã€‚
- en: â¼ Initializes two matrices as NumPy arrays as test cases. Weâ€™ll see much more
    about these two particular matrices throughout the book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ åˆå§‹åŒ–ä¸¤ä¸ªNumPyæ•°ç»„ä½œä¸ºæµ‹è¯•ç”¨ä¾‹ã€‚æˆ‘ä»¬å°†åœ¨æ•´æœ¬ä¹¦ä¸­çœ‹åˆ°è¿™ä¸¤ä¸ªç‰¹å®šçŸ©é˜µçš„æ›´å¤šå†…å®¹ã€‚
- en: â½ Matrix multiplication in NumPy is represented by the @ operator in Python
    3.5 and later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: â½ åœ¨Python 3.5åŠä»¥åçš„ç‰ˆæœ¬ä¸­ï¼ŒNumPyä¸­çš„çŸ©é˜µä¹˜æ³•ç”±@è¿ç®—ç¬¦è¡¨ç¤ºã€‚
- en: â¾ The %timeit â€œmagic commandâ€ tells IPython to run a small piece of Python code
    many times and report the average amount of time that it takes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: â¾ â€œ%timeitâ€é­”æ³•å‘½ä»¤å‘Šè¯‰IPythonè¿è¡Œä¸€å°æ®µPythonä»£ç å¤šæ¬¡ï¼Œå¹¶æŠ¥å‘Šå¹³å‡æ‰€éœ€æ—¶é—´ã€‚
- en: C.2.1 Party with inner products
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.1 å…·æœ‰å†…ç§¯çš„æ´¾å¯¹
- en: 'Thereâ€™s one last thing we need to worry about to find the party. Earlier, we
    said we were ignoring the problem of whether there was a road that would let us
    go in the direction we needed to, but this is a really bad idea when wandering
    through an unfamiliar city. To make our way around, we need a way to evaluate
    how far we should walk along a given road to get where weâ€™re going. Fortunately,
    linear algebra gives us a tool to do just that: the *inner product* (figure C.7).
    Inner products are a way of projecting one vector ![](../Images/AR_v.png) onto
    another vector ![](../Images/AR_w.png), telling us how much of a â€œshadowâ€ ![](../Images/AR_v.png)
    casts on ![](../Images/AR_w.png).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¯»æ‰¾æ´¾å¯¹æ—¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è€ƒè™‘æœ€åä¸€ä»¶äº‹ã€‚ä¹‹å‰ï¼Œæˆ‘ä»¬è¯´è¿‡æˆ‘ä»¬å¿½ç•¥äº†æ˜¯å¦å­˜åœ¨ä¸€æ¡é“è·¯å¯ä»¥è®©æˆ‘ä»¬æœæ‰€éœ€çš„æ–¹å‘å‰è¿›çš„é—®é¢˜ï¼Œä½†åœ¨ä¸€ä¸ªä¸ç†Ÿæ‚‰çš„åŸå¸‚ä¸­æ¼«æ­¥æ—¶ï¼Œè¿™çœŸæ˜¯ä¸€ä¸ªç³Ÿç³•çš„æƒ³æ³•ã€‚ä¸ºäº†æ‰¾åˆ°æˆ‘ä»¬çš„è·¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥è¯„ä¼°æˆ‘ä»¬åº”è¯¥æ²¿ç€ç»™å®šé“è·¯èµ°å¤šè¿œæ‰èƒ½åˆ°è¾¾ç›®çš„åœ°ã€‚å¹¸è¿çš„æ˜¯ï¼Œçº¿æ€§ä»£æ•°ä¸ºæˆ‘ä»¬æä¾›äº†è¿™æ ·ä¸€ä¸ªå·¥å…·ï¼š*å†…ç§¯*ï¼ˆå›¾C.7ï¼‰ã€‚å†…ç§¯æ˜¯ä¸€ç§å°†ä¸€ä¸ªå‘é‡![](../Images/AR_v.png)æŠ•å½±åˆ°å¦ä¸€ä¸ªå‘é‡![](../Images/AR_w.png)ä¸Šçš„æ–¹æ³•ï¼Œå‘Šè¯‰æˆ‘ä»¬å‘é‡![](../Images/AR_v.png)åœ¨![](../Images/AR_w.png)ä¸ŠæŠ•ä¸‹çš„â€œå½±å­â€æœ‰å¤šå¤§ã€‚
- en: '![](../Images/C-7.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-7.png)'
- en: Figure C.7 How to find a party with inner products
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾C.7 å¦‚ä½•é€šè¿‡å†…ç§¯æ‰¾åˆ°æ´¾å¯¹
- en: We can compute the inner product of two vectors by multiplying their respective
    elements and summing the result. Note that this multiply-and-sum recipe is the
    same as what we do in matrix multiplication! Multiplying a matrix that has a single
    row with a matrix that has a single column does exactly what we need. Thus, to
    find the projection of ![](../Images/AR_v.png) onto ![](../Images/AR_w.png), we
    need to turn ![](../Images/AR_v.png) into a row vector by taking its *transpose*,
    written ![](../Images/AR_v.png)^(*T*).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†ä¸¤ä¸ªå‘é‡çš„ç›¸åº”å…ƒç´ ç›¸ä¹˜å¹¶æ±‚å’Œæ¥è®¡ç®—ä¸¤ä¸ªå‘é‡çš„å†…ç§¯ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸ªä¹˜æ³•å’Œæ±‚å’Œçš„é…æ–¹ä¸æˆ‘ä»¬åœ¨çŸ©é˜µä¹˜æ³•ä¸­åšçš„æ˜¯ä¸€æ ·çš„ï¼å°†ä¸€ä¸ªåªæœ‰ä¸€è¡Œçš„çŸ©é˜µä¸ä¸€ä¸ªåªæœ‰ä¸€åˆ—çš„çŸ©é˜µç›¸ä¹˜æ­£å¥½æ˜¯æˆ‘ä»¬éœ€è¦çš„ã€‚å› æ­¤ï¼Œä¸ºäº†æ‰¾åˆ°å‘é‡![](../Images/AR_v.png)åœ¨![](../Images/AR_w.png)ä¸Šçš„æŠ•å½±ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡å–å…¶*è½¬ç½®*å°†å…¶è½¬æ¢ä¸ºè¡Œå‘é‡ï¼Œè¡¨ç¤ºä¸º![](../Images/AR_v.png)^(*T*)ã€‚
- en: Example
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹
- en: The transpose of ![](../Images/C-7_E1.png).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/C-7_E1.png)çš„è½¬ç½®ã€‚'
- en: Note In chapter 3, weâ€™ll see that we also need to take the complex conjugate
    of each element, but weâ€™ll set that aside for now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šåœ¨ç¬¬3ç« ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°æˆ‘ä»¬è¿˜éœ€è¦å–æ¯ä¸ªå…ƒç´ çš„å¤å…±è½­ï¼Œä½†ç°åœ¨æˆ‘ä»¬å…ˆä¸è€ƒè™‘è¿™ä¸€ç‚¹ã€‚
- en: In particular, the matrix product of ![](../Images/AR_v.png)^(*T*) (the transpose
    of ![](../Images/AR_v.png)) with ![](../Images/AR_w.png) gives us a 1 Ã— 1 matrix
    containing the inner product we want. Suppose we need to go two blocks south and
    three blocks east, but we can only go on a road that points more south-southeast.
    Since we still need to travel south, this road helps us get where we need to go.
    But how far should we walk before this road stops helping?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯çŸ©é˜µä¹˜ç§¯ ![](../Images/AR_v.png)^(*T*)ï¼ˆ![](../Images/AR_v.png)çš„è½¬ç½®ï¼‰ä¸![](../Images/AR_w.png)ç›¸ä¹˜ï¼Œç»™æˆ‘ä»¬ä¸€ä¸ªåŒ…å«æˆ‘ä»¬æƒ³è¦çš„å†…ç§¯çš„1
    Ã— 1çŸ©é˜µã€‚å‡è®¾æˆ‘ä»¬éœ€è¦å‘å—èµ°ä¸¤ä¸ªè¡—åŒºï¼Œå‘ä¸œèµ°ä¸‰ä¸ªè¡—åŒºï¼Œä½†æˆ‘ä»¬åªèƒ½æ²¿ç€æŒ‡å‘æ›´å—ä¸œå—çš„é“è·¯èµ°ã€‚ç”±äºæˆ‘ä»¬ä»ç„¶éœ€è¦å‘å—èµ°ï¼Œè¿™æ¡é“è·¯å¸®åŠ©æˆ‘ä»¬åˆ°è¾¾ç›®çš„åœ°ã€‚ä½†æˆ‘ä»¬åœ¨è¿™æ¡é“è·¯åœæ­¢å¸®åŠ©æˆ‘ä»¬ä¹‹å‰åº”è¯¥èµ°å¤šè¿œï¼Ÿ
- en: Listing C.4Â Computing vector dot products with NumPy
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨C.4 ä½¿ç”¨NumPyè®¡ç®—å‘é‡ç‚¹ç§¯
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'â¶ In this case, ![](../Images/AR_v.png) is the vector describing where we need
    to go: two blocks north and three blocks east.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ![](../Images/AR_v.png)æ˜¯æè¿°æˆ‘ä»¬éœ€è¦å»çš„åœ°æ–¹çš„å‘é‡ï¼šå‘åŒ—èµ°ä¸¤ä¸ªè¡—åŒºï¼Œå‘ä¸œèµ°ä¸‰ä¸ªè¡—åŒºã€‚
- en: â· If the road available points southeast, then it goes one block south for every
    block east.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: â· å¦‚æœå¯ç”¨çš„é“è·¯æŒ‡å‘ä¸œå—ï¼Œé‚£ä¹ˆå®ƒæ¯å‘ä¸œèµ°ä¸€ä¸ªè¡—åŒºå°±å‘å—èµ°ä¸€ä¸ªè¡—åŒºã€‚
- en: â¸ We can find the length of a vector using Pythagoreasâ€™ theorem by taking the
    sum of the absolute values of each element and then taking the square root. In
    NumPy, this is done with the np.linalg.norm function, as the length of a vector
    is sometimes also called its norm.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¯•è¾¾å“¥æ‹‰æ–¯å®šç†é€šè¿‡å–æ¯ä¸ªå…ƒç´ çš„ç»å¯¹å€¼ä¹‹å’Œç„¶åå¼€å¹³æ–¹æ¥æ‰¾åˆ°å‘é‡çš„é•¿åº¦ã€‚åœ¨NumPyä¸­ï¼Œè¿™æ˜¯é€šè¿‡np.linalg.normå‡½æ•°å®Œæˆçš„ï¼Œå› ä¸ºå‘é‡çš„é•¿åº¦æœ‰æ—¶ä¹Ÿè¢«ç§°ä¸ºå…¶èŒƒæ•°ã€‚
- en: â¹ When we define ![](../Images/AR_w.png) to be the direction southeast, we need
    to divide by âˆš2.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ å½“æˆ‘ä»¬å°†![](../Images/AR_w.png)å®šä¹‰ä¸ºä¸œå—æ–¹å‘æ—¶ï¼Œæˆ‘ä»¬éœ€è¦é™¤ä»¥âˆš2ã€‚
- en: âº The length of [[1], [â€“1]] is thus ![](../Images/equation_C-1.png) = âˆš2 â‰ˆ 1.4142.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: âº å› æ­¤ï¼Œ[[1], [â€“1]]çš„é•¿åº¦æ˜¯![](../Images/equation_C-1.png) = âˆš2 â‰ˆ 1.4142ã€‚
- en: â» Checking, we see that the length of ![](../Images/AR_w.png) is now approximately
    1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: â» æ£€æŸ¥åï¼Œæˆ‘ä»¬å‘ç°![](../Images/AR_w.png)çš„é•¿åº¦ç°åœ¨å¤§çº¦ä¸º1ã€‚
- en: â¼ The transpose turns ![](../Images/AR_v.png) = [[â€“2], [â€“3]] into the â€œrowâ€
    [[â€“2, â€“3]].
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ è½¬ç½®å°†![](../Images/AR_v.png) = [[â€“2], [â€“3]]è½¬æ¢ä¸ºâ€œè¡Œâ€[[â€“2, â€“3]]ã€‚
- en: â½ We can then multiply the transpose of ![](../Images/AR_v.png) with ![](../Images/AR_w.png)
    the same way we multiplied matrices with vectors earlier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: â½ æˆ‘ä»¬å¯ä»¥åƒä¹‹å‰ç”¨çŸ©é˜µä¸å‘é‡ç›¸ä¹˜ä¸€æ ·ï¼Œç”¨![](../Images/AR_v.png)çš„è½¬ç½®ä¹˜ä»¥![](../Images/AR_w.png)ã€‚
- en: â¾ We need to walk 1 / âˆš2 â‰ˆ 0.707 blocks along this road before it stops helping
    us get to the party.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: â¾ åœ¨è¿™æ¡é“è·¯åœæ­¢å¸®åŠ©æˆ‘ä»¬åˆ°è¾¾æ´¾å¯¹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ²¿ç€è¿™æ¡é“è·¯èµ°1 / âˆš2 â‰ˆ 0.707ä¸ªè¡—åŒºã€‚
- en: 'Exercise C.5: Vector normalization'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ C.5ï¼šå‘é‡å½’ä¸€åŒ–
- en: Given a vector [[2], [3]], find a vector that points in the same direction but
    with length 1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå‘é‡ [[2], [3]]ï¼Œæ‰¾åˆ°ä¸€ä¸ªæŒ‡å‘ç›¸åŒæ–¹å‘ä½†é•¿åº¦ä¸º1çš„å‘é‡ã€‚
- en: '*Hint*: You can do this by using either an inner product or the `np.linalg.norm`
    function.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*æç¤º*ï¼šä½ å¯ä»¥é€šè¿‡ä½¿ç”¨å†…ç§¯æˆ–`np.linalg.norm`å‡½æ•°æ¥å®Œæˆè¿™ä¸ªæ“ä½œã€‚'
- en: Finally, we have made it to the party (only slightly late) and are ready to
    try out that new doorbell!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ç»ˆäºåˆ°è¾¾äº†æ´¾å¯¹ï¼ˆåªæ˜¯ç¨å¾®æ™šäº†ç‚¹ï¼‰å¹¶å‡†å¤‡å¥½å°è¯•é‚£ä¸ªæ–°é—¨é“ƒï¼
- en: Square roots and lengths
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: å¹³æ–¹æ ¹å’Œé•¿åº¦
- en: The square root of a number *x* is a number *y* = âˆš2 such that we get *x* back
    when we square *y*, *y*Â² = *x*. We use square roots a lot throughout the book,
    as they are essential for finding the length of vectors. For instance, in computer
    graphics, quickly finding the lengths of vectors is essential for making games
    work (see [https://en.wikipedia.org/wiki/Fast_inverse_square_root](https://en.wikipedia.org/wiki/Fast_inverse_square_root)
    for some fun history about how square roots are used in gaming).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ•° *x* çš„å¹³æ–¹æ ¹æ˜¯ä¸€ä¸ªæ•° *y* = âˆš2ï¼Œå½“æˆ‘ä»¬å¹³æ–¹ *y* æ—¶ï¼Œæˆ‘ä»¬å¾—åˆ° *x*ï¼Œå³ *y*Â² = *x*ã€‚æˆ‘ä»¬åœ¨æ•´æœ¬ä¹¦ä¸­å¤§é‡ä½¿ç”¨å¹³æ–¹æ ¹ï¼Œå› ä¸ºå®ƒä»¬å¯¹äºæ‰¾åˆ°å‘é‡çš„é•¿åº¦æ˜¯å¿…ä¸å¯å°‘çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨è®¡ç®—æœºå›¾å½¢å­¦ä¸­ï¼Œå¿«é€Ÿæ‰¾åˆ°å‘é‡çš„é•¿åº¦å¯¹äºä½¿æ¸¸æˆå·¥ä½œè‡³å…³é‡è¦ï¼ˆæœ‰å…³å¹³æ–¹æ ¹åœ¨æ¸¸æˆä¸­çš„åº”ç”¨çš„ä¸€äº›æœ‰è¶£å†å²ï¼Œè¯·å‚é˜…[https://en.wikipedia.org/wiki/Fast_inverse_square_root](https://en.wikipedia.org/wiki/Fast_inverse_square_root)ï¼‰ã€‚
- en: Whether vectors describe how we get to parties or those vectors describe the
    information that a quantum bit represents, we use square roots to reason about
    their lengths.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºè¿™äº›å‘é‡æè¿°çš„æ˜¯æˆ‘ä»¬å»æ´¾å¯¹çš„è·¯çº¿è¿˜æ˜¯è¿™äº›å‘é‡æè¿°çš„é‡å­æ¯”ç‰¹ä»£è¡¨çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬éƒ½ç”¨å¹³æ–¹æ ¹æ¥æ¨ç†å®ƒä»¬çš„é•¿åº¦ã€‚
