- en: 11 Working with strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 å¤„ç†å­—ç¬¦ä¸²
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ¶µç›–
- en: Understanding the relationships between Unicode, code points, and UTF-8 encoding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç†è§£ Unicodeã€ç ç‚¹å’Œ UTF-8 ç¼–ç ä¹‹é—´çš„å…³ç³»
- en: Comparing strings, converting them to lowercase, and performing other string
    operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯”è¾ƒå­—ç¬¦ä¸²ï¼Œå°†å®ƒä»¬è½¬æ¢ä¸ºå°å†™ï¼Œä»¥åŠæ‰§è¡Œå…¶ä»–å­—ç¬¦ä¸²æ“ä½œ
- en: When and how to use raw strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½•æ—¶ä»¥åŠå¦‚ä½•ä½¿ç”¨åŸå§‹å­—ç¬¦ä¸²
- en: Learning about different kinds of string literals, including regular expressions,
    MIME types, and BigInt literals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº†è§£ä¸åŒç±»å‹çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼ŒåŒ…æ‹¬æ­£åˆ™è¡¨è¾¾å¼ã€MIME ç±»å‹ä»¥åŠ BigInt å­—é¢é‡
- en: Youâ€™ve already had some hands-on experience working with strings in earlier
    chapters; however, Iâ€™ll cover many more details that will help you correctly use
    text strings in this chapter. In this chapter you will examine these details more
    closely. As long as you are working with the letters A-Z, things will be simple.
    However, there are a multitude of languages in the world with their own unique
    set of characters that Julia needs to be able to deal with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å·²ç»åœ¨å‰é¢ç« èŠ‚ä¸­æœ‰äº†å¤„ç†å­—ç¬¦ä¸²çš„ä¸€äº›å®é™…ç»éªŒï¼›ç„¶è€Œï¼Œæˆ‘å°†åœ¨æœ¬ç« ä¸­æ¶µç›–æ›´å¤šç»†èŠ‚ï¼Œè¿™å°†å¸®åŠ©ä½ æ­£ç¡®ä½¿ç”¨æ–‡æœ¬å­—ç¬¦ä¸²ã€‚åœ¨æœ¬ç« ä¸­ï¼Œä½ å°†æ›´ä»”ç»†åœ°æ£€æŸ¥è¿™äº›ç»†èŠ‚ã€‚åªè¦ä½ åœ¨å¤„ç†
    A-Z çš„å­—æ¯ï¼Œäº‹æƒ…å°±ä¼šå¾ˆç®€å•ã€‚ç„¶è€Œï¼Œä¸–ç•Œä¸Šæœ‰æ— æ•°ç§è¯­è¨€ï¼Œå®ƒä»¬éƒ½æœ‰è‡ªå·±çš„ç‹¬ç‰¹å­—ç¬¦é›†ï¼Œè€Œ Julia éœ€è¦èƒ½å¤Ÿå¤„ç†è¿™äº›å­—ç¬¦é›†ã€‚
- en: That means the minimal required knowledge for working effectively with Julia
    strings includes some knowledge of *Unicode*. Unicode is the international standard
    for mapping numbers (code points) to characters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æœ‰æ•ˆä½¿ç”¨ Julia å­—ç¬¦ä¸²æ‰€éœ€çš„æœ€å°çŸ¥è¯†åŒ…æ‹¬ä¸€äº›å…³äº *Unicode* çš„çŸ¥è¯†ã€‚Unicode æ˜¯å°†æ•°å­—ï¼ˆç ç‚¹ï¼‰æ˜ å°„åˆ°å­—ç¬¦çš„å›½é™…æ ‡å‡†ã€‚
- en: Julia also has support for special string literals to aid in performing a variety
    of tasks. For example, there are special strings called *regular expressions*
    that allow you to check whether another string matches a particular pattern, such
    as an email address, IP address, or zip code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Julia è¿˜æ”¯æŒç‰¹æ®Šå­—ç¬¦ä¸²å­—é¢é‡ï¼Œä»¥å¸®åŠ©æ‰§è¡Œå„ç§ä»»åŠ¡ã€‚ä¾‹å¦‚ï¼Œæœ‰ä¸€äº›ç§°ä¸º *æ­£åˆ™è¡¨è¾¾å¼* çš„ç‰¹æ®Šå­—ç¬¦ä¸²ï¼Œå…è®¸ä½ æ£€æŸ¥å¦ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ç‰¹å®šæ¨¡å¼åŒ¹é…ï¼Œä¾‹å¦‚ç”µå­é‚®ä»¶åœ°å€ã€IP
    åœ°å€æˆ–é‚®æ”¿ç¼–ç ã€‚
- en: 11.1 UTF-8 and Unicode
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 UTF-8 å’Œ Unicode
- en: Text strings in Julia are Unicode, encoded in UTF-8 format. But what does that
    mean, and why should you care? Iâ€™ll walk you through a simple example illustrating
    the importance of understanding Unicode better.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Julia ä¸­çš„æ–‡æœ¬å­—ç¬¦ä¸²æ˜¯ Unicodeï¼Œä»¥ UTF-8 æ ¼å¼ç¼–ç ã€‚ä½†è¿™æ„å‘³ç€ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆä½ åº”è¯¥å…³å¿ƒï¼Ÿæˆ‘å°†é€šè¿‡ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥å¼•å¯¼ä½ ï¼Œè¯´æ˜æ›´å¥½åœ°ç†è§£
    Unicode çš„é‡è¦æ€§ã€‚
- en: '*Ã†ser* is the plural of *norse gods* in Norwegian. It is a four-letter word,
    as confirmed with the length function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ã†ser* æ˜¯æŒªå¨è¯­ä¸­ *norse gods* çš„å¤æ•°å½¢å¼ã€‚å®ƒæ˜¯ä¸€ä¸ªå››ä¸ªå­—æ¯çš„å•è¯ï¼Œæ­£å¦‚é•¿åº¦å‡½æ•°æ‰€ç¡®è®¤çš„é‚£æ ·ï¼š'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But when attempting to access individual characters in the word, you will notice
    something strange:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼Œå½“å°è¯•è®¿é—®å•è¯ä¸­çš„å•ä¸ªå­—ç¬¦æ—¶ï¼Œä½ ä¼šæ³¨æ„åˆ°ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…ï¼š
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: â¶ Works as expected
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æ­£å¦‚é¢„æœŸçš„é‚£æ ·å·¥ä½œ
- en: â· You get an exception. Trying to access the character s at index 2 apparently
    doesnâ€™t work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: â· ä½ ä¼šå¾—åˆ°ä¸€ä¸ªå¼‚å¸¸ã€‚å°è¯•åœ¨ç´¢å¼• 2 å¤„è®¿é—®å­—ç¬¦ s æ˜æ˜¾ä¸èµ·ä½œç”¨ã€‚
- en: â¸ Instead, the second character is at index 3\. Does this seem strange?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ç›¸åï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä½äºç´¢å¼• 3ã€‚è¿™çœ‹èµ·æ¥å¥‡æ€ªå—ï¼Ÿ
- en: 'How about another word? *ÃrÃºÃ°vangr* is the name of the realm of the Norse god
    Thor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¥ä¸€ä¸ªå•è¯ï¼Ÿ*ÃrÃºÃ°vangr* æ˜¯åŒ—æ¬§ç¥æ‰˜å°”é¢†åŸŸçš„åå­—ï¼š
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a nine-character word, but the character at index 9 is the sixth character,
    ''a''. What is going on here? To understand, you need to understand Unicode and
    how Julia strings support it through the UTF-8 encoding:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªä¹ä¸ªå­—ç¬¦çš„å•è¯ï¼Œä½†ç´¢å¼• 9 çš„å­—ç¬¦æ˜¯ç¬¬å…­ä¸ªå­—ç¬¦ï¼Œ'a'ã€‚è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿä¸ºäº†ç†è§£è¿™ä¸€ç‚¹ï¼Œä½ éœ€è¦äº†è§£ Unicode ä»¥åŠ Julia å­—ç¬¦ä¸²å¦‚ä½•é€šè¿‡
    UTF-8 ç¼–ç æ¥æ”¯æŒå®ƒï¼š
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: â¶ Ã†ser is encoded with 5 bytes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ Ã†ser ä½¿ç”¨ 5 ä¸ªå­—èŠ‚è¿›è¡Œç¼–ç ã€‚
- en: â· ÃrÃºÃ°vangr is encoded with 12 bytes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: â· ÃrÃºÃ°vangr ä½¿ç”¨ 12 ä¸ªå­—èŠ‚è¿›è¡Œç¼–ç ã€‚
- en: In UTF-8, every character is encoded into one to 4 bytes. Normal letters, such
    as A, B, and C, will take just 1 byte, while letters such as Ã†, Ã, and Ã°, which
    are not used in the English language, will typically require more than 1 byte
    to encode. However, before I delve further into how Julia deals with this, it
    is useful to understand some key concepts in Unicode that are not specific to
    the Julia programming language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ UTF-8 ä¸­ï¼Œæ¯ä¸ªå­—ç¬¦è¢«ç¼–ç ä¸º 1 åˆ° 4 ä¸ªå­—èŠ‚ã€‚æ­£å¸¸çš„å­—æ¯ï¼Œå¦‚ Aã€B å’Œ Cï¼Œåªéœ€ 1 ä¸ªå­—èŠ‚ï¼Œè€Œåƒ Ã†ã€Ã å’Œ Ã° è¿™æ ·çš„å­—æ¯ï¼Œè¿™äº›å­—æ¯åœ¨è‹±è¯­ä¸­ä¸å¸¸ç”¨ï¼Œé€šå¸¸éœ€è¦è¶…è¿‡
    1 ä¸ªå­—èŠ‚æ¥ç¼–ç ã€‚ç„¶è€Œï¼Œåœ¨æˆ‘è¿›ä¸€æ­¥æ¢è®¨ Julia å¦‚ä½•å¤„ç†è¿™ä¸ªé—®é¢˜ä¹‹å‰ï¼Œäº†è§£ä¸€äº› Unicode çš„å…³é”®æ¦‚å¿µæ˜¯æœ‰ç”¨çš„ï¼Œè¿™äº›æ¦‚å¿µå¹¶ä¸ç‰¹å®šäº Julia ç¼–ç¨‹è¯­è¨€ã€‚
- en: 11.1.1 Understanding the relation between code points and code units
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 ç†è§£ç ç‚¹å’Œç å•å…ƒä¹‹é—´çš„å…³ç³»
- en: Unicode and character encodings are complex topics many developers will struggle
    with at some point. Understanding the history of why Unicode and UTF-8 exist will
    provide important context for understanding.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unicodeå’Œå­—ç¬¦ç¼–ç æ˜¯è®¸å¤šå¼€å‘è€…å¯èƒ½ä¼šåœ¨æŸä¸€ç‚¹ä¸Šé‡åˆ°å¤æ‚è¯é¢˜ã€‚äº†è§£Unicodeå’ŒUTF-8å­˜åœ¨çš„å†å²åŸå› å°†ä¸ºç†è§£æä¾›é‡è¦èƒŒæ™¯ã€‚
- en: 'Both standards evolved from the older ASCII standard, which encoded every character
    as 8 bit. Numbers 65 to 90 would encode letters from A-Z, and numbers 97 to 122
    would encode lowercase letters a-z. You can explore the relation between ASCII
    codes and their corresponding characters in the Julia REPL using the constructor
    for the Char type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ç§æ ‡å‡†éƒ½æºè‡ªè¾ƒè€çš„ASCIIæ ‡å‡†ï¼Œè¯¥æ ‡å‡†å°†æ¯ä¸ªå­—ç¬¦ç¼–ç ä¸º8ä½ã€‚æ•°å­—65åˆ°90å°†ç¼–ç å­—æ¯A-Zï¼Œè€Œæ•°å­—97åˆ°122å°†ç¼–ç å°å†™å­—æ¯a-zã€‚æ‚¨å¯ä»¥ä½¿ç”¨Charç±»å‹çš„æ„é€ å‡½æ•°åœ¨Julia
    REPLä¸­æ¢ç´¢ASCIIç ä¸å…¶å¯¹åº”å­—ç¬¦ä¹‹é—´çš„å…³ç³»ï¼š
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To deal with different languages, one would need to operate with different interpretations
    of these numbers from 1 to 255\. However, this quickly became impractical. You
    could not, for example, mix text written using different alphabets on the same
    page. The solution was Unicode, which aimed to give a unique number to every character
    in the worldâ€”not just those in the Latin alphabet but also for Cyrillic, Chinese,
    Thai, and all the Japanese character sets.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¤„ç†ä¸åŒçš„è¯­è¨€ï¼Œäººä»¬éœ€è¦æ“ä½œä»1åˆ°255çš„ä¸åŒæ•°å­—è§£é‡Šã€‚ç„¶è€Œï¼Œè¿™å¾ˆå¿«å˜å¾—ä¸åˆ‡å®é™…ã€‚ä¾‹å¦‚ï¼Œæ‚¨ä¸èƒ½åœ¨åŒä¸€é¡µé¢ä¸Šæ··åˆä½¿ç”¨ä¸åŒå­—æ¯è¡¨ç¼–å†™çš„æ–‡æœ¬ã€‚è§£å†³æ–¹æ¡ˆæ˜¯Unicodeï¼Œå®ƒæ—¨åœ¨ä¸ºä¸–ç•Œä¸Šæ¯ä¸ªå­—ç¬¦èµ‹äºˆä¸€ä¸ªå”¯ä¸€çš„æ•°å­—â€”â€”ä¸ä»…é™äºæ‹‰ä¸å­—æ¯ï¼Œè¿˜åŒ…æ‹¬è¥¿é‡Œå°”å­—æ¯ã€ä¸­æ–‡ã€æ³°è¯­ä»¥åŠæ‰€æœ‰æ—¥æ–‡å­—ç¬¦é›†ã€‚
- en: The number given to each character is called a *code point* in Unicode terminology
    ([https://www.unicode.org/glossary/#code_point](https://www.unicode.org/glossary/#code_point)).
    Originally, it was believed 16 bits would be enough to store every Unicode code
    point. 16 bits gives 216 - 1 = 65,535 unique numbers. Thus, one of the first Unicode
    encodings, UCS, used 16 bits (2 bytes) to encode every Unicode code point ([https://www.unicode.org/glossary/#UCS](https://www.unicode.org/glossary/#UCS)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†é…ç»™æ¯ä¸ªå­—ç¬¦çš„æ•°å­—åœ¨Unicodeæœ¯è¯­ä¸­ç§°ä¸º*ç ç‚¹*([https://www.unicode.org/glossary/#code_point](https://www.unicode.org/glossary/#code_point))ã€‚æœ€åˆï¼Œäººä»¬è®¤ä¸º16ä½è¶³ä»¥å­˜å‚¨æ¯ä¸ªUnicodeç ç‚¹ã€‚16ä½æä¾›äº†216
    - 1 = 65,535ä¸ªå”¯ä¸€çš„æ•°å­—ã€‚å› æ­¤ï¼ŒUnicodeçš„ç¬¬ä¸€ä¸ªç¼–ç ä¹‹ä¸€ï¼ŒUCSï¼Œä½¿ç”¨16ä½ï¼ˆ2å­—èŠ‚ï¼‰æ¥ç¼–ç æ¯ä¸ªUnicodeç ç‚¹([https://www.unicode.org/glossary/#UCS](https://www.unicode.org/glossary/#UCS))).
- en: 'Later it was determined that this would not be enough, and there would need
    to be 4 bytes (32 bits) to encode every possible Unicode character. At this point
    the UCS approach started to look flawed for the following reasons:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: åæ¥äººä»¬ç¡®å®šè¿™è¿˜ä¸å¤Ÿï¼Œéœ€è¦4ä¸ªå­—èŠ‚ï¼ˆ32ä½ï¼‰æ¥ç¼–ç æ¯ä¸ªå¯èƒ½çš„Unicodeå­—ç¬¦ã€‚åœ¨è¿™ä¸ªæ—¶å€™ï¼ŒUCSæ–¹æ³•å¼€å§‹æ˜¾å¾—æœ‰ç¼ºé™·ï¼ŒåŸå› å¦‚ä¸‹ï¼š
- en: UCS was already incompatible with 8-bit ASCII code.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UCSå·²ç»ä¸8ä½ASCIIç ä¸å…¼å®¹ã€‚
- en: A total of 4 bytes for every character would consume a lot of space.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå­—ç¬¦æ€»å…±éœ€è¦4ä¸ªå­—èŠ‚å°†æ¶ˆè€—å¤§é‡ç©ºé—´ã€‚
- en: UTF-8 encoding solved these problems by using a variable number of bytes per
    character ([https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt)).
    That way, frequently used characters could be encoded with a single byte, saving
    space. The 1-byte characters were intentionally made backward compatible with
    ASCII.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8ç¼–ç é€šè¿‡æ¯ä¸ªå­—ç¬¦ä½¿ç”¨å¯å˜æ•°é‡çš„å­—èŠ‚è§£å†³äº†è¿™äº›é—®é¢˜([https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt))ã€‚è¿™æ ·ï¼Œå¸¸ç”¨å­—ç¬¦å¯ä»¥ç”¨å•ä¸ªå­—èŠ‚ç¼–ç ï¼ŒèŠ‚çœç©ºé—´ã€‚1å­—èŠ‚å­—ç¬¦æœ‰æ„ä¸ASCIIå‘åå…¼å®¹ã€‚
- en: With variable length character encoding a distinction between the *code point*
    of a character and the *code units* required to encode the character needs to
    be made. Every Unicode character has one number, the code point, that identifies
    it. Code units are used to store these code points in memory. UTF-8 requires a
    variable number of code units to do that (figure 11.1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¯å˜é•¿åº¦å­—ç¬¦ç¼–ç ä¸­ï¼Œéœ€è¦åŒºåˆ†å­—ç¬¦çš„*ç ç‚¹*å’Œç¼–ç è¯¥å­—ç¬¦æ‰€éœ€çš„*ç å•å…ƒ*ã€‚æ¯ä¸ªUnicodeå­—ç¬¦éƒ½æœ‰ä¸€ä¸ªæ•°å­—ï¼Œå³ç ç‚¹ï¼Œç”¨äºæ ‡è¯†å®ƒã€‚ç å•å…ƒç”¨äºåœ¨å†…å­˜ä¸­å­˜å‚¨è¿™äº›ç ç‚¹ã€‚UTF-8éœ€è¦å¯å˜æ•°é‡çš„ç å•å…ƒæ¥å®Œæˆè¿™é¡¹å·¥ä½œï¼ˆå›¾11.1ï¼‰ã€‚
- en: '![11-01](../Images/11-01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![11-01](../Images/11-01.png)'
- en: Figure 11.1 Unicode code points encoded to UTF-8 code units (not every index
    is shown)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾11.1 Unicodeç ç‚¹ç¼–ç ä¸ºUTF-8ç å•å…ƒï¼ˆå¹¶éæ¯ä¸ªç´¢å¼•éƒ½æ˜¾ç¤ºï¼‰
- en: 'UCS, in contrast, has fixed-sized code units. Each UCS code unit is 16 bit.
    Figure 11.1 illustrates the relationship between characters, code points, and
    code units. Every gray block for the code points represents 4 bytes. A variable
    number of code units are required for each character. Therefore they have been
    stacked to show which bytes are related to the same character. The black balls
    give the byte index of some of the code units making up the characters. To help
    clarify these concepts, you will engage in some hands-on experimentation with
    Unicode characters in the Julia REPL:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼ŒUCSå…·æœ‰å›ºå®šå¤§å°çš„ä»£ç å•å…ƒã€‚æ¯ä¸ªUCSä»£ç å•å…ƒæ˜¯16ä½ã€‚å›¾11.1è¯´æ˜äº†å­—ç¬¦ã€ç ç‚¹å’Œä»£ç å•å…ƒä¹‹é—´çš„å…³ç³»ã€‚æ¯ä¸ªç°è‰²çš„ç ç‚¹å—ä»£è¡¨4ä¸ªå­—èŠ‚ã€‚æ¯ä¸ªå­—ç¬¦éœ€è¦å¤šä¸ªä»£ç å•å…ƒã€‚å› æ­¤ï¼Œå®ƒä»¬è¢«å †å èµ·æ¥ä»¥æ˜¾ç¤ºå“ªäº›å­—èŠ‚ä¸åŒä¸€å­—ç¬¦ç›¸å…³ã€‚é»‘è‰²çš„å°çƒç»™å‡ºäº†ç»„æˆå­—ç¬¦çš„ä¸€äº›ä»£ç å•å…ƒçš„å­—èŠ‚ç´¢å¼•ã€‚ä¸ºäº†å¸®åŠ©é˜æ˜è¿™äº›æ¦‚å¿µï¼Œä½ å°†åœ¨Julia
    REPLä¸­è¿›è¡Œä¸€äº›å…³äºUnicodeå­—ç¬¦çš„åŠ¨æ‰‹å®éªŒï¼š
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: â¶ Get the code point of the letter A in hexadecimal form.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ä»¥åå…­è¿›åˆ¶å½¢å¼è·å–å­—æ¯Açš„ç ç‚¹ã€‚
- en: â· The code point of A as a decimal number
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: â· Açš„åè¿›åˆ¶ç ç‚¹
- en: â¸ The number of code units required to encode the code point for the letter
    A
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ç¼–ç å­—æ¯Açš„ç ç‚¹æ‰€éœ€çš„ä»£ç å•å…ƒæ•°é‡
- en: â¹ Is this letter part of the original ASCII standard?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ è¿™ä¸ªå­—æ¯æ˜¯å¦æ˜¯åŸå§‹ASCIIæ ‡å‡†çš„ä¸€éƒ¨åˆ†ï¼Ÿ
- en: 'Letâ€™s explore characters that are not part of the original ASCII standard.
    They should have more than one code unit and not return true when isascii() is
    called:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¢ç´¢ä¸æ˜¯åŸå§‹ASCIIæ ‡å‡†ä¸€éƒ¨åˆ†çš„å­—ç¬¦ã€‚å®ƒä»¬åº”è¯¥æœ‰å¤šä¸ªä»£ç å•å…ƒï¼Œå¹¶ä¸”åœ¨è°ƒç”¨isascii()æ—¶ä¸ä¼šè¿”å›trueï¼š
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: â¶ You need 2 bytes to encode an Ã† character in the UTF-8 standard used by Julia.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ åœ¨Juliaä½¿ç”¨çš„UTF-8æ ‡å‡†ä¸­ï¼Œç¼–ç Ã†å­—ç¬¦éœ€è¦2ä¸ªå­—èŠ‚ã€‚
- en: â· Ã† is not part of the original ASCII standard.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: â· Ã†ä¸æ˜¯åŸå§‹ASCIIæ ‡å‡†çš„ä¸€éƒ¨åˆ†ã€‚
- en: â¸ Code point for a smiley
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ è¡¨æƒ…çš„ç ç‚¹
- en: â¹ A smiley emoji requires 4 bytes to encode.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ ä¸€ä¸ªè¡¨æƒ…ç¬¦å·emojiéœ€è¦4ä¸ªå­—èŠ‚æ¥ç¼–ç ã€‚
- en: There is no isUnicode function because every Julia character is a Unicode character.
    isascii is simply a way to test whether a given Unicode character is also part
    of the original ASCII standard.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰isUnicodeå‡½æ•°ï¼Œå› ä¸ºJuliaçš„æ¯ä¸ªå­—ç¬¦éƒ½æ˜¯Unicodeå­—ç¬¦ã€‚isasciiåªæ˜¯æ£€æŸ¥ç»™å®šUnicodeå­—ç¬¦æ˜¯å¦ä¹Ÿæ˜¯åŸå§‹ASCIIæ ‡å‡†çš„ä¸€éƒ¨åˆ†çš„ä¸€ç§æ–¹å¼ã€‚
- en: 'Just typing letters at the REPL will also give you useful information when
    the character literal is evaluated:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨REPLä¸­ç›´æ¥è¾“å…¥å­—æ¯ä¹Ÿä¼šåœ¨å­—ç¬¦å­—é¢é‡è¢«è¯„ä¼°æ—¶æä¾›æœ‰ç”¨çš„ä¿¡æ¯ï¼š
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how this tells you what the Unicode code point number is.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™å‘Šè¯‰ä½ Unicodeç ç‚¹çš„æ•°å­—æ˜¯å¤šå°‘ã€‚
- en: 'Tip You can use backslash \ and the Tab key to easily write unusual characters
    not present on your keyboard. For instance, to write ğŸ˜, type \:smirk: in the Julia
    REPL, and press Tab, to get a completion.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°è´´å£«ï¼šä½ å¯ä»¥ä½¿ç”¨åæ–œæ  \ å’ŒTabé”®è½»æ¾åœ°å†™å…¥é”®ç›˜ä¸Šæ²¡æœ‰çš„ä¸å¯»å¸¸å­—ç¬¦ã€‚ä¾‹å¦‚ï¼Œè¦åœ¨Julia REPLä¸­å†™å…¥ ğŸ˜ï¼Œè¯·è¾“å…¥ \:smirk: å¹¶æŒ‰Tabé”®ï¼Œä»¥è·å–å®Œæˆã€‚'
- en: 'You can even press Tab after writing just \: to get a full list of possible
    emojis. Norwegian letters such as Ã†Ã˜Ã…, which I occasionally use in my examples,
    can easily be written on a Mac by simply holding down the option key and entering
    character O, A, or '' (English keyboard layout). For other operating systems,
    switch to Norwegian keyboard layout or copy the letters.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä½ ç”šè‡³å¯ä»¥åœ¨å†™ä¸‹ \: ä¹‹åæŒ‰Tabé”®ï¼Œä»¥è·å–å¯èƒ½çš„å…¨éƒ¨è¡¨æƒ…ç¬¦å·åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼ŒæŒªå¨å­—æ¯å¦‚ Ã†Ã˜Ã…ï¼Œæˆ‘åœ¨ç¤ºä¾‹ä¸­å¶å°”ä½¿ç”¨ï¼Œå¯ä»¥åœ¨Macä¸Šé€šè¿‡ç®€å•åœ°æŒ‰ä½é€‰é¡¹é”®å¹¶è¾“å…¥å­—ç¬¦Oã€Aæˆ–''ï¼ˆè‹±æ–‡é”®ç›˜å¸ƒå±€ï¼‰æ¥è½»æ¾è¾“å…¥ã€‚å¯¹äºå…¶ä»–æ“ä½œç³»ç»Ÿï¼Œåˆ‡æ¢åˆ°æŒªå¨é”®ç›˜å¸ƒå±€æˆ–å¤åˆ¶å­—æ¯ã€‚'
- en: 'Unicode code points can be written explicitly in Julia in various ways:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Juliaä¸­ï¼ŒUnicodeç ç‚¹å¯ä»¥ç”¨å¤šç§æ–¹å¼æ˜¾å¼è¡¨ç¤ºï¼š
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can combine these with map to create various ranges. For instance a range
    does not need to be merely written as numbers. ''A'':''F'', for example, is a
    perfectly valid range:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥å°†è¿™äº›ä¸mapç»“åˆä½¿ç”¨æ¥åˆ›å»ºå„ç§èŒƒå›´ã€‚ä¾‹å¦‚ï¼ŒèŒƒå›´ä¸å¿…ä»…ä»…ç”¨æ•°å­—æ¥è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œ'A':'F'æ˜¯ä¸€ä¸ªå®Œå…¨æœ‰æ•ˆçš„èŒƒå›´ï¼š
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And you can, of course, go the opposite direction as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥é€‰æ‹©ç›¸åçš„æ–¹å‘ï¼š
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Given that the number of a character and its index is not entirely correlated,
    you must take care when working with strings and indices. You should use the lastindex
    and nextind functions, which also work for non-strings, as demonstrated with the
    following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå­—ç¬¦çš„æ•°é‡å’Œå®ƒçš„ç´¢å¼•å¹¶ä¸å®Œå…¨ç›¸å…³ï¼Œæ‰€ä»¥åœ¨å¤„ç†å­—ç¬¦ä¸²å’Œç´¢å¼•æ—¶å¿…é¡»å°å¿ƒã€‚ä½ åº”è¯¥ä½¿ç”¨lastindexå’Œnextindå‡½æ•°ï¼Œè¿™äº›å‡½æ•°ä¹Ÿé€‚ç”¨äºéå­—ç¬¦ä¸²ï¼Œå¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºï¼š
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: â¶ Get the index of the first element. Thus, you donâ€™t have to assume the first
    element is at index 1\. You can make Julia arrays with different start indices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ è·å–ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ã€‚å› æ­¤ï¼Œä½ ä¸å¿…å‡è®¾ç¬¬ä¸€ä¸ªå…ƒç´ åœ¨ç´¢å¼•1ã€‚ä½ å¯ä»¥åˆ›å»ºå…·æœ‰ä¸åŒèµ·å§‹ç´¢å¼•çš„Juliaæ•°ç»„ã€‚
- en: â· Check if you have reached the last index.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: â· æ£€æŸ¥ä½ æ˜¯å¦å·²ç»åˆ°è¾¾æœ€åä¸€ä¸ªç´¢å¼•ã€‚
- en: â¸ Finds the index of the element following index i in array xs
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ åœ¨æ•°ç»„xsä¸­æ‰¾åˆ°ç´¢å¼•iä¹‹åçš„å…ƒç´ çš„ç´¢å¼•
- en: In the following listing you can see if you do this with a string, the logic
    is entirely the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹é¢çš„åˆ—è¡¨ä¸­ï¼Œä½ å¯ä»¥çœ‹åˆ°å¦‚æœä½ ç”¨å­—ç¬¦ä¸²è¿™æ ·åšï¼Œé€»è¾‘æ˜¯å®Œå…¨ç›¸åŒçš„ã€‚
- en: Listing 11.1 Iterating over characters in a string using a while loop
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.1 ä½¿ç”¨ while å¾ªç¯éå†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: â¶ Notice you skip from index 1 to 3, going from Ã to r.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æ³¨æ„ä½ ä»ç´¢å¼• 1 è·³åˆ° 3ï¼Œä» Ã åˆ° rã€‚
- en: â· Going from Ã° to v requires skipping index 7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: â· ä» Ã° è·³è¿‡ç´¢å¼• 7 åˆ° vã€‚
- en: 'By using these functions, you abstract away the difference between strings
    and regular arrays. You can see this in how, for example, nextind is implemented
    in the standard library. For arrays it is just a simple increment:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ä½¿ç”¨è¿™äº›å‡½æ•°ï¼Œä½ å¯ä»¥æŠ½è±¡å‡ºå­—ç¬¦ä¸²å’Œå¸¸è§„æ•°ç»„ä¹‹é—´çš„å·®å¼‚ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥çœ‹åˆ°åœ¨æ ‡å‡†åº“ä¸­ nextind æ˜¯å¦‚ä½•å®ç°çš„ã€‚å¯¹äºæ•°ç»„æ¥è¯´ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªç®€å•çš„é€’å¢ï¼š
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For strings this is a much more complex operation. I will only show parts of
    the implementation, edited for clarity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå­—ç¬¦ä¸²æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªæ›´å¤æ‚çš„æ“ä½œã€‚æˆ‘å°†åªå±•ç¤ºå®ç°çš„éƒ¨åˆ†ï¼Œä»¥ç¼–è¾‘æ¸…æ™°åº¦ã€‚
- en: Listing 11.2 Excerpt of the base implementation of nextind for strings
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.2 å­—ç¬¦ä¸² nextind åŸºæœ¬å®ç°çš„æ‘˜å½•
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For normal code, you donâ€™t need to deal with nextind and lastindex. Instead,
    you use for loops, since they will automatically fetch a whole character on each
    iteration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¸¸è§„ä»£ç ï¼Œä½ ä¸éœ€è¦å¤„ç† nextind å’Œ lastindexã€‚ç›¸åï¼Œä½ ä½¿ç”¨ for å¾ªç¯ï¼Œå› ä¸ºå®ƒä»¬å°†åœ¨æ¯æ¬¡è¿­ä»£æ—¶è‡ªåŠ¨è·å–æ•´ä¸ªå­—ç¬¦ï¼š
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you need the indices of each character, use the eachindex function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ éœ€è¦æ¯ä¸ªå­—ç¬¦çš„ç´¢å¼•ï¼Œè¯·ä½¿ç”¨ eachindex å‡½æ•°ï¼š
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 11.2 String operations
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 å­—ç¬¦ä¸²æ“ä½œ
- en: Working with text is such a common thing to do that it pays to be aware of the
    possibilities that exist in the language. My intention is not to show every single
    string operation that exists but to give an idea of what is possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: å¤„ç†æ–‡æœ¬æ˜¯ä¸€ä»¶éå¸¸å¸¸è§çš„äº‹æƒ…ï¼Œå› æ­¤äº†è§£è¯­è¨€ä¸­å­˜åœ¨çš„å¯èƒ½æ€§æ˜¯å€¼å¾—çš„ã€‚æˆ‘çš„æ„å›¾ä¸æ˜¯å±•ç¤ºæ¯ä¸ªå­˜åœ¨çš„å­—ç¬¦ä¸²æ“ä½œï¼Œè€Œæ˜¯ç»™å‡ºä¸€ä¸ªå¯èƒ½æ€§çš„æ¦‚å¿µã€‚
- en: 'I tend to frequently use Julia as an assistant when working with other programming
    languages. I use Julia for transforming code in different ways. Iâ€™ll walk you
    through an example. In many programming languages it is common to see these sorts
    of variations in text formatting of identifiers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä¸å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€èµ·å·¥ä½œæ—¶ï¼Œæˆ‘ç»å¸¸ä½¿ç”¨ Julia ä½œä¸ºåŠ©æ‰‹ã€‚æˆ‘ä½¿ç”¨ Julia ä»¥ä¸åŒçš„æ–¹å¼è½¬æ¢ä»£ç ã€‚æˆ‘å°†é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥å¼•å¯¼ä½ ã€‚åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ ‡è¯†ç¬¦çš„æ–‡æœ¬æ ¼å¼å˜åŒ–æ˜¯å¸¸è§çš„ï¼š
- en: FooBarâ€”Pascal case (upper camel case); it is a frequently used style for types
    or classes. It is sometimes used for constants.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FooBarâ€”å¸•æ–¯å¡å¼ï¼ˆå¤§é©¼å³°å¼ï¼‰ï¼›è¿™æ˜¯ä¸€ç§å¸¸ç”¨äºç±»å‹æˆ–ç±»çš„é£æ ¼ã€‚æœ‰æ—¶ä¹Ÿç”¨äºå¸¸é‡ã€‚
- en: foo_barâ€”Snake case; it is often used for the name of variables, methods and
    functions.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foo_barâ€”è›‡å½¢æ¡ˆä¾‹ï¼›å®ƒé€šå¸¸ç”¨äºå˜é‡ã€æ–¹æ³•å’Œå‡½æ•°çš„åç§°ã€‚
- en: fooBarâ€”Camel case (lower camel case); it is frequently used for methods and
    variable names.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fooBarâ€”é©¼å³°å¼ï¼ˆå°é©¼å³°å¼ï¼‰ï¼›å®ƒé€šå¸¸ç”¨äºæ–¹æ³•å’Œå˜é‡åã€‚
- en: FOO_BARâ€”Upper snake case; it is often used for constants and enum values.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FOO_BARâ€”å¤§è›‡å½¢æ¡ˆä¾‹ï¼›å®ƒé€šå¸¸ç”¨äºå¸¸é‡å’Œæšä¸¾å€¼ã€‚
- en: foo-barâ€”Kebab case; you will find this in LISP programs and configuration files.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foo-barâ€”çŸ­æ¨ªçº¿æ¡ˆä¾‹ï¼›ä½ å¯ä»¥åœ¨ LISP ç¨‹åºå’Œé…ç½®æ–‡ä»¶ä¸­æ‰¾åˆ°å®ƒã€‚
- en: I will demonstrate several ways of converting between these styles and how you
    can turn them into handy utility functions for aiding your programming.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†æ¼”ç¤ºå‡ ç§åœ¨è¿™äº›é£æ ¼ä¹‹é—´è½¬æ¢çš„æ–¹æ³•ï¼Œä»¥åŠå¦‚ä½•å°†å®ƒä»¬å˜æˆæœ‰ç”¨çš„å®ç”¨å‡½æ•°ï¼Œä»¥å¸®åŠ©ä½ çš„ç¼–ç¨‹ã€‚
- en: 'The following is my typical process for developing a simple function to do
    something: Since I am not certain about how an unfamiliar function works, I first
    try it out. Then I gradually combine it with more function calls to get what I
    want. Eventually, I have enough to implement my function.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯æˆ‘å¼€å‘ä¸€ä¸ªç®€å•å‡½æ•°çš„å…¸å‹è¿‡ç¨‹ï¼Œç”¨äºæ‰§è¡ŒæŸäº›æ“ä½œï¼šç”±äºæˆ‘å¯¹ä¸€ä¸ªä¸ç†Ÿæ‚‰çš„å‡½æ•°çš„å·¥ä½œæ–¹å¼ä¸ç¡®å®šï¼Œæˆ‘é¦–å…ˆå°è¯•å®ƒã€‚ç„¶åæˆ‘é€æ¸å°†å…¶ä¸æ›´å¤šçš„å‡½æ•°è°ƒç”¨ç»“åˆèµ·æ¥ï¼Œä»¥è·å¾—æˆ‘æƒ³è¦çš„ç»“æœã€‚æœ€ç»ˆï¼Œæˆ‘æœ‰äº†è¶³å¤Ÿçš„ä»£ç æ¥å®ç°æˆ‘çš„å‡½æ•°ã€‚
- en: Listing 11.3 Iterative development of a camel case function
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.3 éª†é©¼å³°å¼å‡½æ•°çš„è¿­ä»£å¼€å‘
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now you have a function that will do the conversion, but often you want to be
    able to do this quickly. Select some text in your code editor that is in snake
    case and which you want to turn into camel case and paste back in.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ æœ‰ä¸€ä¸ªå¯ä»¥è¿›è¡Œè½¬æ¢çš„å‡½æ•°ï¼Œä½†é€šå¸¸ä½ å¸Œæœ›èƒ½å¤Ÿå¿«é€Ÿå®Œæˆè¿™ä¸ªæ“ä½œã€‚åœ¨ä½ çš„ä»£ç ç¼–è¾‘å™¨ä¸­é€‰æ‹©ä¸€äº›è›‡å½¢æ¡ˆä¾‹çš„æ–‡æœ¬ï¼Œå¹¶å°†å…¶ç²˜è´´å›é©¼å³°å¼ã€‚
- en: This is where Juliaâ€™s clipboard() function comes in handy. It can both read
    from and write to the clipboard. The clipboard is the place where everything you
    copy resides.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ Julia çš„ clipboard() å‡½æ•°æ´¾ä¸Šç”¨åœºçš„åœ°æ–¹ã€‚å®ƒå¯ä»¥è¯»å–å’Œå†™å…¥å‰ªè´´æ¿ã€‚å‰ªè´´æ¿æ˜¯æ‰€æœ‰ä½ å¤åˆ¶çš„å†…å®¹æ‰€åœ¨çš„åœ°æ–¹ã€‚
- en: 'Warning On Linux the clipboard function will not work unless you have the xsel
    or xclip commands installed. On Debian or Ubuntu you can install these with the
    following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: è­¦å‘Š åœ¨ Linux ä¸Šï¼Œé™¤éä½ å®‰è£…äº† xsel æˆ– xclip å‘½ä»¤ï¼Œå¦åˆ™å‰ªè´´æ¿å‡½æ•°å°†ä¸èµ·ä½œç”¨ã€‚åœ¨ Debian æˆ– Ubuntu ä¸Šï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£…è¿™äº›å‘½ä»¤ï¼š
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Red Hat or Fedora Linux you can them install with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Red Hat æˆ– Fedora Linux ä¸Šï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£…ï¼š
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In listing 11.4, a method is added to the camel_case function, which does not
    take any string arguments but, instead, reads the clipboard. Just mark some text
    and copy it before running clipboard(). I marked the first part of this paragraph.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åˆ—è¡¨ 11.4 ä¸­ï¼Œå‘ camel_case å‡½æ•°æ·»åŠ äº†ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒä¸æ¥å—ä»»ä½•å­—ç¬¦ä¸²å‚æ•°ï¼Œè€Œæ˜¯è¯»å–å‰ªè´´æ¿ã€‚åœ¨è¿è¡Œ clipboard() ä¹‹å‰ï¼Œæˆ‘æ ‡è®°äº†è¿™æ®µæ–‡å­—çš„ç¬¬ä¸€éƒ¨åˆ†ã€‚
- en: Listing 11.4 Turn text in the clipboard into camel case
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.4 å°†å‰ªè´´æ¿ä¸­çš„æ–‡æœ¬è½¬æ¢ä¸ºé©¼å³°å¼
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'clipboard() gets the contents of the clipboard, while clipboard(s) stores the
    content of s on the clipboard. Whenever you are coding and want to change a snake
    case text to camel case, you can follow these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: clipboard() è·å–å‰ªè´´æ¿çš„å†…å®¹ï¼Œè€Œ clipboard(s) å°† s çš„å†…å®¹å­˜å‚¨åœ¨å‰ªè´´æ¿ä¸Šã€‚æ¯æ¬¡ä½ ç¼–ç å¹¶æƒ³è¦å°†è›‡å½¢æ–‡æœ¬è½¬æ¢ä¸ºé©¼å³°å¼æ—¶ï¼Œä½ å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š
- en: Copy the text.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¤åˆ¶æ–‡æœ¬ã€‚
- en: Switch to your open Julia REPL.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ‡æ¢åˆ°ä½ çš„ Julia REPLã€‚
- en: Start typing came..., and press the up-arrow key. This should complete to camel_case()
    if you called it before. Alternatively, press Tab.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¼€å§‹è¾“å…¥ came...ï¼Œç„¶åæŒ‰ä¸Šç®­å¤´é”®ã€‚å¦‚æœä¹‹å‰è°ƒç”¨è¿‡å®ƒï¼Œåº”è¯¥ä¼šå®Œæˆåˆ° camel_case()ã€‚æˆ–è€…æŒ‰ Tab é”®ã€‚
- en: Go back to the editor, and paste the result.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿”å›åˆ°ç¼–è¾‘å™¨ï¼Œå¹¶ç²˜è´´ç»“æœã€‚
- en: Using the Julia REPL more efficiently
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´é«˜æ•ˆåœ°ä½¿ç”¨ Julia REPL
- en: To work quickly with Julia it is important to become accustomed to all the hotkeys.
    The up-arrow key is used to quickly search through your history. If you start
    writing a few letters it will filter that history to only match history beginning
    with those first letters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å¿«é€Ÿä½¿ç”¨ Juliaï¼Œé‡è¦çš„æ˜¯è¦ä¹ æƒ¯æ‰€æœ‰å¿«æ·é”®ã€‚ä¸Šç®­å¤´é”®ç”¨äºå¿«é€Ÿæœç´¢ä½ çš„å†å²è®°å½•ã€‚å¦‚æœä½ å¼€å§‹è¾“å…¥å‡ ä¸ªå­—æ¯ï¼Œå®ƒå°†è¿‡æ»¤å†å²è®°å½•ï¼ŒåªåŒ¹é…ä»¥é‚£äº›å­—æ¯å¼€å¤´çš„å†å²è®°å½•ã€‚
- en: The Tab key is used to complete a word matching a function Julia knows about.
    That could be a built-in one or one you have defined yourself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Tab é”®ç”¨äºå®Œæˆ Julia å·²çŸ¥çš„å‡½æ•°åŒ¹é…ã€‚è¿™å¯èƒ½æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•°æˆ–ä½ è‡ªå·±å®šä¹‰çš„å‡½æ•°ã€‚
- en: Ctrl-A and Ctrl-E are used to jump to the beginning and end of a line in the
    Julia REPL. Say you just wrote
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ctrl-A å’Œ Ctrl-E ç”¨äºåœ¨ Julia REPL ä¸­è·³è½¬åˆ°è¡Œçš„å¼€å§‹å’Œç»“æŸã€‚å‡è®¾ä½ åˆšåˆšå†™äº†
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may want to alter this to
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½æƒ³è¦ä¿®æ”¹ä¸º
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Press up arrow to get back the line you just wrote. Press Ctrl-A, to jump to
    the beginning of the line. Write join(. Finally, press Ctrl-E to jump to the end,
    and write).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ä¸Šç®­å¤´é”®è¿”å›ä½ åˆšåˆšå†™çš„è¡Œã€‚æŒ‰ Ctrl-A è·³åˆ°è¡Œçš„å¼€å¤´ã€‚å†™ join(ã€‚æœ€åï¼ŒæŒ‰ Ctrl-E è·³åˆ°è¡Œçš„æœ«å°¾ï¼Œå†™)ã€‚
- en: 11.2.1 Converting from camel case to snake case
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 ä»é©¼å³°å¼è½¬æ¢ä¸ºè›‡å½¢
- en: 'Letâ€™s look at code for going the other direction. In this case using the split
    function will not work, but why? In this case you cannot split on a specific character;
    however, split can take functions instead of characters to decide where to split.
    To split on whitespace, use split(s, isspace), so you could try to use the isuppercase
    function. It checks whether a character is uppercase. That is useful, since you
    split where characters are uppercase:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•åå‘æ“ä½œçš„ä»£ç ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨ split å‡½æ•°å°†ä¸èµ·ä½œç”¨ï¼Œä½†ä¸ºä»€ä¹ˆï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ æ— æ³•åœ¨ç‰¹å®šå­—ç¬¦ä¸Šåˆ†å‰²ï¼›ç„¶è€Œï¼Œsplit å¯ä»¥æ¥å—å‡½æ•°è€Œä¸æ˜¯å­—ç¬¦æ¥å†³å®šåˆ†å‰²çš„ä½ç½®ã€‚è¦æŒ‰ç©ºç™½åˆ†å‰²ï¼Œä½¿ç”¨
    split(s, isspace)ï¼Œå› æ­¤ä½ å¯ä»¥å°è¯•ä½¿ç”¨ isuppercase å‡½æ•°ã€‚å®ƒæ£€æŸ¥ä¸€ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºå¤§å†™ã€‚è¿™å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºä½ åœ¨å­—ç¬¦å¤§å†™çš„åœ°æ–¹åˆ†å‰²ï¼š
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, this approach does not work because split strips away the character
    you use for splitting. Instead, you will use one of Juliaâ€™s many find functions.
    If you write find in the REPL and press Tab, you will see a number of possible
    choices:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€è§ï¼Œè¿™ç§æ–¹æ³•ä¸èµ·ä½œç”¨ï¼Œå› ä¸º split ä¼šç§»é™¤ä½ ç”¨äºåˆ†å‰²çš„å­—ç¬¦ã€‚ç›¸åï¼Œä½ å°†ä½¿ç”¨ Julia çš„è®¸å¤š find å‡½æ•°ä¹‹ä¸€ã€‚å¦‚æœä½ åœ¨ REPL ä¸­å†™å…¥
    find å¹¶æŒ‰ Tab é”®ï¼Œä½ ä¼šçœ‹åˆ°è®¸å¤šå¯èƒ½çš„é€‰æ‹©ï¼š
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'findfirst finds the first occurrence of a match, while findall finds all occurrences.
    Letâ€™s look at an example to clarify:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: findfirst æŸ¥æ‰¾åŒ¹é…é¡¹çš„ç¬¬ä¸€ä¸ªå‡ºç°ï¼Œè€Œ findall æŸ¥æ‰¾æ‰€æœ‰å‡ºç°ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç¤ºä¾‹æ¥æ¾„æ¸…ï¼š
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can loop over all the indices of the uppercase letters and capture the substrings
    using ranges.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥éå†æ‰€æœ‰å¤§å†™å­—æ¯çš„ç´¢å¼•ï¼Œå¹¶ä½¿ç”¨èŒƒå›´æ•è·å­å­—ç¬¦ä¸²ã€‚
- en: Listing 11.5 Print out each capitalized word
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.5 æ‰“å°å‡ºæ¯ä¸ªå¤§å†™å•è¯
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11.5 is just a demonstration of how to gradually develop the function.
    In this case println will ensure the correct output. Here, the ranges i:j-1 will
    extract a substring:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.5 åªæ˜¯ä¸€ä¸ªæ¼”ç¤ºï¼Œè¯´æ˜å¦‚ä½•é€æ­¥å¼€å‘å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ println å°†ç¡®ä¿æ­£ç¡®çš„è¾“å‡ºã€‚åœ¨è¿™é‡Œï¼ŒèŒƒå›´ i:j-1 å°†æå–å­å­—ç¬¦ä¸²ï¼š
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The following listing shows a complete example. You have removed the println
    and added an array of strings called words to store each individual capitalized
    word.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹åˆ—è¡¨å±•ç¤ºäº†ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ã€‚ä½ å·²ç»ç§»é™¤äº† println å¹¶æ·»åŠ äº†ä¸€ä¸ªåä¸º words çš„å­—ç¬¦ä¸²æ•°ç»„æ¥å­˜å‚¨æ¯ä¸ªå•ç‹¬çš„å¤§å†™å•è¯ã€‚
- en: Listing 11.6 Turning a camel-case string into a snake-case string
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.6 å°†é©¼å³°å¼å­—ç¬¦ä¸²è½¬æ¢ä¸ºè›‡å½¢å­—ç¬¦ä¸²
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once you have collected the words in the array, join them into one string using
    join(words, '_'). The second argument, '_', causes each word to be joined, with
    _ as a separator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ä½ æ”¶é›†äº†æ•°ç»„ä¸­çš„å•è¯ï¼Œä½¿ç”¨join(words, '_')å°†å®ƒä»¬è¿æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ç¬¬äºŒä¸ªå‚æ•°'_'å¯¼è‡´æ¯ä¸ªå•è¯ä»¥'_'ä½œä¸ºåˆ†éš”ç¬¦è¿æ¥ã€‚
- en: 11.2.2 Converting between numbers and strings
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 ä»‹äºæ•°å­—å’Œå­—ç¬¦ä¸²ä¹‹é—´çš„è½¬æ¢
- en: 'Chapter 5 covered reading input from the user. Whether input comes from the
    keyboard or a file, it usually comes in the form of text strings; however you
    may need the input numbers. In that chapter you looked at the parse function to
    deal with this; letâ€™s look at it again in greater detail. Provide a type object
    as first argument to specify what type of number type you want to parse to. This
    could be anything from different types of integers to floating-point numbers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬5ç« ä»‹ç»äº†ä»ç”¨æˆ·è¯»å–è¾“å…¥ã€‚æ— è®ºè¾“å…¥æ¥è‡ªé”®ç›˜è¿˜æ˜¯æ–‡ä»¶ï¼Œå®ƒé€šå¸¸ä»¥æ–‡æœ¬å­—ç¬¦ä¸²çš„å½¢å¼å‡ºç°ï¼›ç„¶è€Œï¼Œä½ å¯èƒ½éœ€è¦è¾“å…¥æ•°å­—ã€‚åœ¨ç¬¬5ç« ä¸­ï¼Œä½ ç ”ç©¶äº†parseå‡½æ•°æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼›è®©æˆ‘ä»¬æ›´è¯¦ç»†åœ°å†æ¬¡çœ‹çœ‹å®ƒã€‚å°†ç±»å‹å¯¹è±¡ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°æä¾›ï¼Œä»¥æŒ‡å®šä½ æƒ³è¦è§£æåˆ°çš„æ•°å­—ç±»å‹ã€‚è¿™å¯ä»¥æ˜¯ä»»ä½•ä»ä¸åŒç±»å‹çš„æ•´æ•°åˆ°æµ®ç‚¹æ•°ï¼š
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: â¶ 42 in hexadecimal form (see chapter 2)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ åå…­è¿›åˆ¶å½¢å¼çš„42ï¼ˆè§ç¬¬2ç« ï¼‰
- en: 'You can even specify the base. Julia assumes base 10 by default when parsing
    numbers, which refers to digits running from 0 to 9\. However, you could parse
    the numbers as if they were binary, base 2, if you wanted. That assumes you only
    have the digits 0 and 1 to form numbers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ç”šè‡³å¯ä»¥æŒ‡å®šåŸºæ•°ã€‚Juliaåœ¨è§£ææ•°å­—æ—¶é»˜è®¤å‡è®¾åŸºæ•°ä¸º10ï¼Œè¿™æŒ‡çš„æ˜¯ä»0åˆ°9çš„æ•°å­—ã€‚ç„¶è€Œï¼Œå¦‚æœä½ æƒ³å°†æ•°å­—è§£æä¸ºäºŒè¿›åˆ¶ï¼ŒåŸºæ•°2ï¼Œä½ å¯ä»¥è¿™æ ·åšã€‚è¿™å‡è®¾ä½ åªæœ‰0å’Œ1è¿™ä¸¤ä¸ªæ•°å­—æ¥å½¢æˆæ•°å­—ï¼š
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: â¶ Interpret the string 101 as a decimal number.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å°†å­—ç¬¦ä¸²101è§£æä¸ºåè¿›åˆ¶æ•°ã€‚
- en: â· As a binary number (base 2)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: â· ä½œä¸ºäºŒè¿›åˆ¶æ•°ï¼ˆåŸºæ•°2ï¼‰
- en: â¸ Parse 101 as if it represents a hexadecimal number.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ å°†101è§£æä¸ºä¸€ä¸ªåå…­è¿›åˆ¶æ•°ã€‚
- en: 'These conversions can also be done in reverse. You can take a number and decide
    what base you want to use when converting to a text string:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›è½¬æ¢ä¹Ÿå¯ä»¥åå‘è¿›è¡Œã€‚ä½ å¯ä»¥å–ä¸€ä¸ªæ•°å­—ï¼Œå¹¶å†³å®šåœ¨è½¬æ¢ä¸ºæ–‡æœ¬å­—ç¬¦ä¸²æ—¶ä½¿ç”¨ä»€ä¹ˆåŸºæ•°ï¼š
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: â¶ Create a text string with binary number digits from decimal number 5.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ä½¿ç”¨åè¿›åˆ¶æ•°5çš„äºŒè¿›åˆ¶æ•°ä½åˆ›å»ºä¸€ä¸ªæ–‡æœ¬å­—ç¬¦ä¸²ã€‚
- en: â· Turn decimal number 17 into a string in hexadecimal form.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: â· å°†åè¿›åˆ¶æ•°17è½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²ã€‚
- en: â¸ Convert to a string using the decimal number system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ä½¿ç”¨åè¿›åˆ¶æ•°ç³»ç»Ÿè½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚
- en: From the previous string chapter you may remember the named argument color=:green.
    Here you have another named argument base=2. This is a typical case of named argument
    usage because you are specifying something that only occasionally needs to be
    specified. Sticking with the rocket theme, I will now cover some string manipulations
    involving the RD-180 rocket engine made by Energomash (figure 11.2).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¹‹å‰çš„å­—ç¬¦ä¸²ç« èŠ‚ä¸­ï¼Œä½ å¯èƒ½è¿˜è®°å¾—color=:greenè¿™æ ·çš„å‘½åå‚æ•°ã€‚è¿™é‡Œä½ è¿˜æœ‰ä¸€ä¸ªå‘½åå‚æ•°base=2ã€‚è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„å‘½åå‚æ•°ä½¿ç”¨æ¡ˆä¾‹ï¼Œå› ä¸ºä½ æŒ‡å®šçš„æ˜¯å¶å°”éœ€è¦æŒ‡å®šçš„äº‹æƒ…ã€‚ç»§ç»­ç«ç®­ä¸»é¢˜ï¼Œæˆ‘ç°åœ¨å°†ä»‹ç»ä¸€äº›æ¶‰åŠç”±Energomashåˆ¶é€ çš„RD-180ç«ç®­å‘åŠ¨æœºçš„å­—ç¬¦ä¸²æ“ä½œï¼ˆè§å›¾11.2ï¼‰ã€‚
- en: '![11-02](../Images/11-02.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![11-02](../Images/11-02.png)'
- en: Figure 11.2 Energomash RD-180 rocket engine
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾11.2 Energomash RD-180ç«ç®­å‘åŠ¨æœº
- en: 11.2.3 String interpolation and concatenation
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 å­—ç¬¦ä¸²æ’å€¼å’Œè¿æ¥
- en: 'Strings can be combined in myriad ways in Julia; I will compare some different
    ways of doing it. Often you have objects, such as numbers, you want to turn into
    text strings. The following code defines some variables of different types to
    use in the string examples:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Juliaä¸­ï¼Œå­—ç¬¦ä¸²å¯ä»¥é€šè¿‡å¤šç§æ–¹å¼ç»„åˆï¼›æˆ‘å°†æ¯”è¾ƒå®ç°å®ƒçš„ä¸åŒæ–¹æ³•ã€‚é€šå¸¸ï¼Œä½ ä¼šæœ‰ä¸€äº›å¯¹è±¡ï¼Œæ¯”å¦‚æ•°å­—ï¼Œä½ æƒ³å°†å…¶è½¬æ¢ä¸ºæ–‡æœ¬å­—ç¬¦ä¸²ã€‚ä»¥ä¸‹ä»£ç å®šä¹‰äº†ä¸€äº›ä¸åŒç±»å‹çš„å˜é‡ï¼Œç”¨äºå­—ç¬¦ä¸²ç¤ºä¾‹ï¼š
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code used the string() function to perform concatenation of strings
    and to convert non-strings to strings. Alternatively, one could use the string
    concatenation operator *. If you come from other languages you may be more familiar
    with + operator being used for string concatenation. Julia has instead opted for
    the operator commonly used to denote concatenation in mathematical notation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä»£ç ä½¿ç”¨äº†string()å‡½æ•°æ¥æ‰§è¡Œå­—ç¬¦ä¸²è¿æ¥ï¼Œå¹¶å°†éå­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚æˆ–è€…ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å­—ç¬¦ä¸²è¿æ¥è¿ç®—ç¬¦*ã€‚å¦‚æœä½ æ¥è‡ªå…¶ä»–è¯­è¨€ï¼Œä½ å¯èƒ½æ›´ç†Ÿæ‚‰ä½¿ç”¨+è¿ç®—ç¬¦è¿›è¡Œå­—ç¬¦ä¸²è¿æ¥ã€‚Juliaé€‰æ‹©äº†åœ¨æ•°å­¦ç¬¦å·ä¸­é€šå¸¸ç”¨æ¥è¡¨ç¤ºè¿æ¥çš„è¿ç®—ç¬¦ï¼š
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When dealing with lots of variables it is usually better to use string interpolation.
    String interpolation is done with the $ sign:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å¤„ç†å¤§é‡å˜é‡æ—¶ï¼Œé€šå¸¸æœ€å¥½ä½¿ç”¨å­—ç¬¦ä¸²æ’å€¼ã€‚å­—ç¬¦ä¸²æ’å€¼ä½¿ç”¨$ç¬¦å·è¿›è¡Œï¼š
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Observe that you often need to use $(variable) instead of $variable when there
    is no whitespace that can clearly distinguish the variable name from the surrounding
    text. The same applies if you are trying to interpolate an expression rather than
    a variable. For instance, consider a case when you want to write 3830kN without
    the space:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå½“æ²¡æœ‰ç©ºç™½å¯ä»¥æ¸…æ¥šåœ°åŒºåˆ†å˜é‡åå’Œå‘¨å›´æ–‡æœ¬æ—¶ï¼Œä½ é€šå¸¸éœ€è¦ä½¿ç”¨ $(variable) è€Œä¸æ˜¯ $variableã€‚å¦‚æœä½ è¯•å›¾æ’å€¼ä¸€ä¸ªè¡¨è¾¾å¼è€Œä¸æ˜¯å˜é‡ï¼Œè¿™ä¹Ÿé€‚ç”¨ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹æƒ…å†µï¼Œå½“ä½ æƒ³å†™å‡º
    3830kN è€Œä¸å¸¦ç©ºæ ¼æ—¶ï¼š
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: â¶ You cannot interpolate the thrust variable this way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ä½ ä¸èƒ½è¿™æ ·æ’å€¼æ¨åŠ›å˜é‡ã€‚
- en: â· Correct way to do string interpolation when there is no surrounding whitespace
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: â· å½“æ²¡æœ‰å‘¨å›´ç©ºç™½æ—¶è¿›è¡Œå­—ç¬¦ä¸²æ’å€¼çš„æ­£ç¡®æ–¹æ³•
- en: â¸ String interpolation of an expression
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ è¡¨è¾¾å¼çš„å­—ç¬¦ä¸²æ’å€¼
- en: 11.2.4 sprintf formatting
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 sprintf æ ¼å¼åŒ–
- en: If you are familiar with C programming you may be familiar with the printf and
    sprintf functions. Julia has macros called @printf and @sprintf, which mimic these
    functions. Unlike string interpolation, these macros allow you to specify how
    a variable should be displayed in greater detail.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ç†Ÿæ‚‰ C ç¼–ç¨‹ï¼Œä½ å¯èƒ½ç†Ÿæ‚‰ printf å’Œ sprintf å‡½æ•°ã€‚Julia æœ‰åä¸º @printf å’Œ @sprintf çš„å®ï¼Œè¿™äº›å®æ¨¡ä»¿äº†è¿™äº›å‡½æ•°ã€‚ä¸å­—ç¬¦ä¸²æ’å€¼ä¸åŒï¼Œè¿™äº›å®å…è®¸ä½ æ›´è¯¦ç»†åœ°æŒ‡å®šå˜é‡åº”è¯¥å¦‚ä½•æ˜¾ç¤ºã€‚
- en: Note Macros are distinguished from Julia functions with the @ prefix. A macro
    is akin to a code generator; the call site of a macro gets replaced with other
    code. Macros allow advanced metaprogramming this book will not cover.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå®ä¸ Julia å‡½æ•°é€šè¿‡ @ å‰ç¼€åŒºåˆ†ã€‚å®ç±»ä¼¼äºä»£ç ç”Ÿæˆå™¨ï¼›å®çš„è°ƒç”¨ä½ç½®å°†è¢«å…¶ä»–ä»£ç æ›¿æ¢ã€‚å®å…è®¸è¿›è¡Œé«˜çº§å…ƒç¼–ç¨‹ï¼Œæœ¬ä¹¦å°†ä¸ä¼šæ¶‰åŠã€‚
- en: 'For instance you can specify the number of digits that should be used when
    printing a decimal number. @printf outputs the result to the console, but @sprintf
    and @printf are not in the Julia base module that is always loaded. Thus to use
    these macros you need to include the Printf module, which explains the first line:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œä½ å¯ä»¥æŒ‡å®šæ‰“å°åè¿›åˆ¶æ•°æ—¶åº”ä½¿ç”¨çš„æ•°å­—ä½æ•°ã€‚@printf å°†ç»“æœè¾“å‡ºåˆ°æ§åˆ¶å°ï¼Œä½† @sprintf å’Œ @printf ä¸åœ¨å§‹ç»ˆåŠ è½½çš„ Julia
    åŸºç¡€æ¨¡å—ä¸­ã€‚å› æ­¤ï¼Œè¦ä½¿ç”¨è¿™äº›å®ï¼Œä½ éœ€è¦åŒ…å« Printf æ¨¡å—ï¼Œè¿™è§£é‡Šäº†ç¬¬ä¸€è¡Œï¼š
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is a short overview of some common formatting options:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§æ ¼å¼åŒ–é€‰é¡¹çš„ç®€è¦æ¦‚è¿°ï¼š
- en: '%dâ€”integer numbers'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%dâ€”æ•´æ•°'
- en: '%fâ€”floating point numbers'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%fâ€”æµ®ç‚¹æ•°'
- en: '%xâ€”integers shown in hexadecimal notation'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%xâ€”ä»¥åå…­è¿›åˆ¶è¡¨ç¤ºæ³•æ˜¾ç¤ºçš„æ•´æ•°'
- en: '%sâ€”shows arguments as a string'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%sâ€”ä»¥å­—ç¬¦ä¸²å½¢å¼æ˜¾ç¤ºå‚æ•°'
- en: 'With each of these formatting options you can specify things like number of
    digits, decimals, or padding. First letâ€™s go over some examples of the base formatting
    options:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™äº›æ ¼å¼åŒ–é€‰é¡¹ä¸­çš„æ¯ä¸€ä¸ªï¼Œä½ å¯ä»¥æŒ‡å®šè¯¸å¦‚æ•°å­—ä½æ•°ã€å°æ•°ä½æ•°æˆ–å¡«å……ç­‰ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€äº›åŸºæœ¬æ ¼å¼åŒ–é€‰é¡¹çš„ç¤ºä¾‹ï¼š
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Iâ€™ve included bars in front of and behind the numbers, so the following padding
    examples are easier to read:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åœ¨æ•°å­—å‰åæ·»åŠ äº†æ¨ªçº¿ï¼Œå› æ­¤ä»¥ä¸‹å¡«å……ç¤ºä¾‹æ›´å®¹æ˜“é˜…è¯»ï¼š
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice padding can be applied to either the right or left side. Right padding
    is achieved by adding a hyphen. Padding is useful if you want to display columns
    of numbers you want aligned. You can add padding as zeros instead of space by
    prefixing the padding number with 0:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¡«å……å¯ä»¥åº”ç”¨äºå³ä¾§æˆ–å·¦ä¾§ã€‚é€šè¿‡æ·»åŠ è¿å­—ç¬¦å®ç°å³å¡«å……ã€‚å¦‚æœä½ æƒ³è¦æ˜¾ç¤ºå¯¹é½çš„æ•°å­—åˆ—ï¼Œå¡«å……å¾ˆæœ‰ç”¨ã€‚ä½ å¯ä»¥é€šè¿‡åœ¨å¡«å……æ•°å­—å‰åŠ  0 æ¥ä½¿ç”¨é›¶è€Œä¸æ˜¯ç©ºæ ¼ä½œä¸ºå¡«å……ï¼š
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The padding doesnâ€™t say how many spaces or zeros to add but rather how many
    characters the numbers should fill in total. If the padding is two and the number
    has two digits, then nothing will happen. However, if the padding is four, two
    spaces are added, resulting in a total of four characters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: å¡«å……å¹¶ä¸æŒ‡å®šè¦æ·»åŠ å¤šå°‘ä¸ªç©ºæ ¼æˆ–é›¶ï¼Œè€Œæ˜¯æŒ‡å®šæ•°å­—åº”è¯¥å¡«å……çš„æ€»å­—ç¬¦æ•°ã€‚å¦‚æœå¡«å……ä¸ºä¸¤ä¸ªä¸”æ•°å­—ä¸ºä¸¤ä½æ•°ï¼Œåˆ™ä¸ä¼šå‘ç”Ÿä»»ä½•å˜åŒ–ã€‚ç„¶è€Œï¼Œå¦‚æœå¡«å……ä¸ºå››ä¸ªï¼Œåˆ™æ·»åŠ ä¸¤ä¸ªç©ºæ ¼ï¼Œæ€»å…±ä¸ºå››ä¸ªå­—ç¬¦ã€‚
- en: 11.3 Using string interpolation to generate code
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 ä½¿ç”¨å­—ç¬¦ä¸²æ’å€¼ç”Ÿæˆä»£ç 
- en: You can create small utility functions with what you just learned. This example
    will cover generating C++ code. Julia may not be your primary work language; instead
    you could be using a more verbose language, such as C++ or Java at work, but Julia
    can be used as a companion to make your job easier. Next youâ€™ll review an example
    of how a C++ developer could simplify their work by taking advantage of the Julia
    programming language.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ä½¿ç”¨ä½ åˆšåˆšå­¦åˆ°çš„çŸ¥è¯†åˆ›å»ºå°çš„å®ç”¨å‡½æ•°ã€‚è¿™ä¸ªä¾‹å­å°†æ¶µç›–ç”Ÿæˆ C++ ä»£ç ã€‚Julia å¯èƒ½ä¸æ˜¯ä½ çš„ä¸»è¦å·¥ä½œè¯­è¨€ï¼›ç›¸åï¼Œä½ å¯èƒ½åœ¨å·¥ä½œä¸­ä½¿ç”¨æ›´å†—é•¿çš„è¯­è¨€ï¼Œå¦‚
    C++ æˆ– Javaï¼Œä½† Julia å¯ä»¥ä½œä¸ºè¾…åŠ©å·¥å…·ä½¿ä½ çš„å·¥ä½œæ›´è½»æ¾ã€‚æ¥ä¸‹æ¥ï¼Œä½ å°†å›é¡¾ä¸€ä¸ª C++ å¼€å‘è€…å¦‚ä½•é€šè¿‡åˆ©ç”¨ Julia ç¼–ç¨‹è¯­è¨€æ¥ç®€åŒ–å…¶å·¥ä½œçš„ç¤ºä¾‹ã€‚
- en: The Visualization Toolkit (VTK; [https://vtk.org](https://vtk.org)) is an amazing
    C++ library for visualizing scientific data. You can use it to create visualizations
    like the one in figure 11.3.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: å¯è§†åŒ–å·¥å…·åŒ…ï¼ˆVTKï¼›[https://vtk.org](https://vtk.org)ï¼‰æ˜¯ä¸€ä¸ªç”¨äºå¯è§†åŒ–ç§‘å­¦æ•°æ®çš„æƒŠäººçš„ C++ åº“ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºå¦‚å›¾
    11.3 æ‰€ç¤ºçš„è§†è§‰è¡¨ç¤ºã€‚
- en: '![11-03](../Images/11-03.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![11-03](../Images/11-03.png)'
- en: Figure 11.3 Visualization in VTK
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 11.3 VTK ä¸­çš„å¯è§†åŒ–
- en: Unfortunately, writing VTK C++ code is tedious, due to all the typical boilerplate
    needed in C++. The following is an example of some of the C++ code used in VTK
    to define a geometric line. It is not important to understand what the code in
    the listing does; it has been edited to remove unnecessary details from the example
    code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆé—æ†¾ï¼Œç”±äº C++ ä¸­éœ€è¦æ‰€æœ‰å…¸å‹çš„æ ·æ¿ä»£ç ï¼Œç¼–å†™ VTK C++ ä»£ç å¾ˆç¹çã€‚ä»¥ä¸‹æ˜¯ä¸€äº›åœ¨ VTK ä¸­ç”¨äºå®šä¹‰å‡ ä½•çº¿çš„ C++ ä»£ç ç¤ºä¾‹ã€‚äº†è§£åˆ—è¡¨ä¸­çš„ä»£ç åšä»€ä¹ˆå¹¶ä¸é‡è¦ï¼›å®ƒå·²è¢«ç¼–è¾‘ä»¥ä»ç¤ºä¾‹ä»£ç ä¸­åˆ é™¤ä¸å¿…è¦çš„ç»†èŠ‚ã€‚
- en: Listing 11.7 Line class in the VTK
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.7 VTK ä¸­çš„ Line ç±»
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Compare this code to the next block of code in listing 11.8 for defining a polygon;
    you will notice a lot of repetition. This goes for all VTK code written to define
    geometric primitives.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç ä¸åˆ—è¡¨ 11.8 ä¸­å®šä¹‰å¤šè¾¹å½¢çš„ä¸‹ä¸€å—ä»£ç è¿›è¡Œæ¯”è¾ƒï¼›ä½ ä¼šæ³¨æ„åˆ°æœ‰å¾ˆå¤šé‡å¤ã€‚è¿™é€‚ç”¨äºæ‰€æœ‰ç”¨äºå®šä¹‰å‡ ä½•åŸå‹çš„ VTK ä»£ç ã€‚
- en: Listing 11.8 Polygon class in the VTK
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.8 VTK ä¸­çš„ Polygon ç±»
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Imagine you frequently write new C++ classes (types) like this for different
    geometric types; it would be tedious to repeat all this boilerplate. Fortunately,
    you can make small Julia utility functions to help (listing 11.9).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä½ ç»å¸¸ä¸ºä¸åŒçš„å‡ ä½•ç±»å‹ç¼–å†™æ–°çš„ C++ ç±»ï¼ˆç±»å‹ï¼‰ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼›é‡å¤æ‰€æœ‰è¿™äº›æ ·æ¿ä»£ç ä¼šå¾ˆç¹çã€‚å¹¸è¿çš„æ˜¯ï¼Œä½ å¯ä»¥åˆ›å»ºå°çš„ Julia å·¥å…·å‡½æ•°æ¥å¸®åŠ©ï¼ˆåˆ—è¡¨
    11.9ï¼‰ã€‚
- en: 'When generating text consisting of multiple lines it is practical to use triple
    quotation marks: """. This allows you to write strings across multiple lines.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç”Ÿæˆç”±å¤šè¡Œç»„æˆçš„æ–‡æœ¬æ—¶ï¼Œä½¿ç”¨ä¸‰å¼•å·ï¼š`"""` æ˜¯å®ç”¨çš„ã€‚è¿™å…è®¸ä½ è·¨å¤šè¡Œç¼–å†™å­—ç¬¦ä¸²ã€‚
- en: Listing 11.9 VTK C++ code generator in Julia code
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.9 Julia ä»£ç ä¸­çš„ VTK C++ ä»£ç ç”Ÿæˆå™¨
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: â¶ Make it easy to paste generated source code for the class into a code editor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ä½¿å°†ç”Ÿæˆçš„ç±»æºä»£ç ç²˜è´´åˆ°ä»£ç ç¼–è¾‘å™¨ä¸­å˜å¾—å®¹æ˜“ã€‚
- en: The following is an example of using this utility function to create a Hexagon
    class. Notice in the two preceding lines that the generated code is also stored
    on the clipboard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨æ­¤å®ç”¨å‡½æ•°åˆ›å»º Hexagon ç±»çš„ç¤ºä¾‹ã€‚æ³¨æ„åœ¨å‰ä¸¤è¡Œä¸­ï¼Œç”Ÿæˆçš„ä»£ç ä¹Ÿå­˜å‚¨åœ¨å‰ªè´´æ¿ä¸Šã€‚
- en: Listing 11.10 Use Julia to generate a C++ Hexagon class
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.10 ä½¿ç”¨ Julia ç”Ÿæˆ C++ Hexagon ç±»
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 11.4 Working with nonstandard string literals
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 ä½¿ç”¨éæ ‡å‡†å­—ç¬¦ä¸²å­—é¢é‡
- en: 'In many programming languages there are useful objects, such as dates, regular
    expressions, MIME types, and numbers, that start their life as strings. For instance,
    you cannot express very large numbers as number literals in Julia, so you have
    to express them as a string that gets parsed. For example, floating-point number
    literals are 64 bit in Julia, and that is not enough to hold a number such as
    1.4e600. There are types in Julia, such as BigInt and BigFloat, which can hold
    arbitrarily large numbers. But how do you create such a number when number literals
    are limited to 64-bit floating-point values? The solution is parsing a string
    containing the number definition:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæœ‰ä¸€äº›æœ‰ç”¨çš„å¯¹è±¡ï¼Œä¾‹å¦‚æ—¥æœŸã€æ­£åˆ™è¡¨è¾¾å¼ã€MIME ç±»å‹ä»¥åŠæ•°å­—ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸå§‹äºå­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼Œåœ¨ Julia ä¸­ï¼Œä½ ä¸èƒ½å°†éå¸¸å¤§çš„æ•°å­—ä½œä¸ºæ•°å­—å­—é¢é‡è¡¨è¾¾ï¼Œæ‰€ä»¥ä½ å¿…é¡»å°†å®ƒä»¬ä½œä¸ºå­—ç¬¦ä¸²æ¥è§£æã€‚ä¾‹å¦‚ï¼Œæµ®ç‚¹æ•°å­—é¢é‡åœ¨
    Julia ä¸­æ˜¯ 64 ä½ï¼Œè¿™ä¸è¶³ä»¥å®¹çº³åƒ 1.4e600 è¿™æ ·çš„æ•°å­—ã€‚Julia ä¸­æœ‰ BigInt å’Œ BigFloat è¿™æ ·çš„ç±»å‹ï¼Œå¯ä»¥å­˜å‚¨ä»»æ„å¤§çš„æ•°å­—ã€‚ä½†æ˜¯ï¼Œå½“æ•°å­—å­—é¢é‡é™åˆ¶ä¸º
    64 ä½æµ®ç‚¹å€¼æ—¶ï¼Œå¦‚ä½•åˆ›å»ºè¿™æ ·çš„æ•°å­—å‘¢ï¼Ÿè§£å†³æ–¹æ¡ˆæ˜¯è§£æåŒ…å«æ•°å­—å®šä¹‰çš„å­—ç¬¦ä¸²ï¼š
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another example can be shown when working with dates. Take a scenario in which
    you are reading a number of dates from a file and you want to parse them. To do
    that, specify a date format, such as yyyy-mm-dd. This date format indicates that
    years come first and days last and that each component is separated by a hyphen:
    -. The following is an example of converting from one date format to another (date
    formatting options will be covered later).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å¤„ç†æ—¥æœŸæ—¶ï¼Œè¿˜å¯ä»¥å±•ç¤ºå¦ä¸€ä¸ªç¤ºä¾‹ã€‚å‡è®¾ä½ æ­£åœ¨ä»æ–‡ä»¶ä¸­è¯»å–å¤šä¸ªæ—¥æœŸï¼Œå¹¶å¸Œæœ›è§£æå®ƒä»¬ã€‚ä¸ºæ­¤ï¼ŒæŒ‡å®šä¸€ä¸ªæ—¥æœŸæ ¼å¼ï¼Œä¾‹å¦‚ yyyy-mm-ddã€‚è¿™ç§æ—¥æœŸæ ¼å¼è¡¨ç¤ºå¹´ä»½åœ¨å‰ï¼Œæ—¥æœŸåœ¨åï¼Œå¹¶ä¸”æ¯ä¸ªç»„ä»¶ç”±è¿å­—ç¬¦åˆ†éš”ï¼š-ã€‚ä»¥ä¸‹æ˜¯å°†ä¸€ç§æ—¥æœŸæ ¼å¼è½¬æ¢ä¸ºå¦ä¸€ç§æ ¼å¼çš„ç¤ºä¾‹ï¼ˆç¨åå°†ä¼šä»‹ç»æ—¥æœŸæ ¼å¼åŒ–é€‰é¡¹ï¼‰ã€‚
- en: Listing 11.11 Converting from one data format to another
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.11 å°†ä¸€ç§æ•°æ®æ ¼å¼è½¬æ¢ä¸ºå¦ä¸€ç§æ ¼å¼
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you run this code you will get the following output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿è¡Œæ­¤ä»£ç ï¼Œä½ å°†å¾—åˆ°ä»¥ä¸‹è¾“å‡ºï¼š
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This date formatting code illustrates a problem with all objects derived from
    strings. If you write the code in a natural fashion you end up parsing the same
    string over and over again. On every loop iteration you parse the strings "dd/mm"
    and "E-u", but this should not be necessary. Those strings are the same on every
    iteration; only the date strings themselves change. To avoid having to parse strings
    to create objects such as BigFloat and DateFormat, Julia provides special string
    literals such as big"1.4e600" and dateformat"dd/mm".
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µæ—¥æœŸæ ¼å¼åŒ–ä»£ç è¯´æ˜äº†æ‰€æœ‰ä»å­—ç¬¦ä¸²æ´¾ç”Ÿçš„å¯¹è±¡å­˜åœ¨çš„é—®é¢˜ã€‚å¦‚æœä½ ä»¥è‡ªç„¶çš„æ–¹å¼ç¼–å†™ä»£ç ï¼Œä½ å°†åå¤è§£æç›¸åŒçš„å­—ç¬¦ä¸²ã€‚åœ¨æ¯æ¬¡å¾ªç¯è¿­ä»£ä¸­ï¼Œä½ éƒ½ä¼šè§£æå­—ç¬¦ä¸² "dd/mm"
    å’Œ "E-u"ï¼Œä½†è¿™å¹¶ä¸æ˜¯å¿…è¦çš„ã€‚è¿™äº›å­—ç¬¦ä¸²åœ¨æ¯æ¬¡è¿­ä»£ä¸­éƒ½æ˜¯ç›¸åŒçš„ï¼›åªæœ‰æ—¥æœŸå­—ç¬¦ä¸²æœ¬èº«ä¼šæ”¹å˜ã€‚ä¸ºäº†é¿å…è§£æå­—ç¬¦ä¸²æ¥åˆ›å»º BigFloat å’Œ DateFormat
    ç­‰å¯¹è±¡ï¼ŒJulia æä¾›äº†ç‰¹æ®Šçš„å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå¦‚ big"1.4e600" å’Œ dateformat"dd/mm"ã€‚
- en: When the Julia parses your program code and encounters these strings it does
    not create String objects but rather BigInt, BigFloat, or DateFormat objects.
    The benefit of this approach is that objects are created when the code is parsed
    and not when it is run.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ Julia è§£æä½ çš„ç¨‹åºä»£ç å¹¶é‡åˆ°è¿™äº›å­—ç¬¦ä¸²æ—¶ï¼Œå®ƒä¸ä¼šåˆ›å»º String å¯¹è±¡ï¼Œè€Œæ˜¯åˆ›å»º BigIntã€BigFloat æˆ– DateFormat
    å¯¹è±¡ã€‚è¿™ç§æ–¹æ³•çš„ä¼˜ç‚¹æ˜¯å¯¹è±¡æ˜¯åœ¨ä»£ç è§£ææ—¶åˆ›å»ºçš„ï¼Œè€Œä¸æ˜¯åœ¨è¿è¡Œæ—¶åˆ›å»ºçš„ã€‚
- en: That may sound like a geeky detail of no significance; however, this does make
    a significant difference. Julia will parse the code for a for loop in your program
    once. But it will potentially execute the code inside the loop many times. Thus,
    by creating objects such as DateFormat at parse time rather than runtime, you
    improve performance.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½å¬èµ·æ¥åƒæ˜¯ä¸€ä¸ªå¾®ä¸è¶³é“çš„ç»†èŠ‚ï¼Œç„¶è€Œï¼Œè¿™ç¡®å®æœ‰æ˜¾è‘—çš„åŒºåˆ«ã€‚Julia å°†åªè§£æç¨‹åºä¸­ for å¾ªç¯çš„ä»£ç ä¸€æ¬¡ã€‚ä½†å®ƒå¯èƒ½ä¼šåœ¨å¾ªç¯å†…éƒ¨æ‰§è¡Œä»£ç å¤šæ¬¡ã€‚å› æ­¤ï¼Œé€šè¿‡åœ¨è§£ææ—¶è€Œä¸æ˜¯åœ¨è¿è¡Œæ—¶åˆ›å»ºå¦‚
    DateFormat è¿™æ ·çš„å¯¹è±¡ï¼Œä½ å¯ä»¥æé«˜æ€§èƒ½ã€‚
- en: I will cover each nonstandard string literal in turn in separate sections. By
    reading through these sections it will become clearer what this strategy implies.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†ä¾æ¬¡ä»‹ç»æ¯ä¸ªéæ ‡å‡†å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå¹¶åœ¨å•ç‹¬çš„ç« èŠ‚ä¸­è¿›è¡Œè¯´æ˜ã€‚é€šè¿‡é˜…è¯»è¿™äº›ç« èŠ‚ï¼Œå°†å˜å¾—æ¸…æ¥šè¿™ç§ç­–ç•¥çš„å«ä¹‰ã€‚
- en: 11.4.1 DateFormat strings
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 DateFormat å­—ç¬¦ä¸²
- en: Letâ€™s revisit the DateFormat example. In other programming languages, if you
    want to avoid the performance overhead of parsing DateFormat strings multiple
    times, you might restructure the code, as in the following listing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ DateFormat çš„ä¾‹å­ã€‚åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå¦‚æœä½ æƒ³é¿å…è§£æ DateFormat å­—ç¬¦ä¸²å¤šæ¬¡çš„æ€§èƒ½å¼€é”€ï¼Œä½ å¯èƒ½éœ€è¦é‡æ„ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: Listing 11.12 Optimized but less-readable date formatting code
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.12 ä¼˜åŒ–ä½†å¯è¯»æ€§è¾ƒå·®çš„æ—¥æœŸæ ¼å¼åŒ–ä»£ç 
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: From a performance perspective, this works. The problem is that the code becomes
    less clear. Glancing at the lines parsing and formatting the dates, you cannot
    immediately see what kind of format is used. For readability it is much nicer
    to be able to put the date format definition right where it is used. With the
    dateformat string literal you can do just that, as shown in the following listing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ€§èƒ½çš„è§’åº¦æ¥çœ‹ï¼Œè¿™æ˜¯å¯è¡Œçš„ã€‚é—®é¢˜æ˜¯ä»£ç çš„å¯è¯»æ€§é™ä½äº†ã€‚æµè§ˆè§£æå’Œæ ¼å¼åŒ–æ—¥æœŸçš„è¡Œï¼Œä½ æ— æ³•ç«‹å³çœ‹åˆ°ä½¿ç”¨äº†å“ªç§æ ¼å¼ã€‚ä¸ºäº†å¯è¯»æ€§ï¼Œæœ€å¥½èƒ½å¤Ÿå°†æ—¥æœŸæ ¼å¼å®šä¹‰æ”¾åœ¨ä½¿ç”¨çš„åœ°æ–¹ã€‚ä½¿ç”¨
    dateformat å­—ç¬¦ä¸²å­—é¢é‡ï¼Œä½ å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: Listing 11.13 Optimized and readable date formatting code
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.13 ä¼˜åŒ–ä¸”å¯è¯»çš„æ—¥æœŸæ ¼å¼åŒ–ä»£ç 
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I havenâ€™t yet covered exactly how to specify a date format string. Fortunately,
    the Julia online help system gives a great overview; just go into helpmode (?),
    and write DateFormat, which will provide you with a list of all the letters you
    can use and what they mean. Basically, you use letters such as y, m, and d to
    represent year, month, and day. If you want to write years as four digits, you
    specify that as yyyy. A few code examples in the REPL should give you a sense
    of how this works:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è¿˜æ²¡æœ‰è¯¦ç»†è¯´æ˜å¦‚ä½•æŒ‡å®šæ—¥æœŸæ ¼å¼å­—ç¬¦ä¸²ã€‚å¹¸è¿çš„æ˜¯ï¼ŒJulia åœ¨çº¿å¸®åŠ©ç³»ç»Ÿæä¾›äº†ä¸€ä¸ªå¾ˆå¥½çš„æ¦‚è¿°ï¼›åªéœ€è¿›å…¥å¸®åŠ©æ¨¡å¼ (?), è¾“å…¥ DateFormatï¼Œå®ƒå°†ä¸ºä½ æä¾›ä¸€ä¸ªæ‰€æœ‰å¯ç”¨å­—æ¯åŠå…¶å«ä¹‰çš„åˆ—è¡¨ã€‚åŸºæœ¬ä¸Šï¼Œä½ ä½¿ç”¨å­—æ¯å¦‚
    yã€m å’Œ d æ¥è¡¨ç¤ºå¹´ã€æœˆå’Œæ—¥ã€‚å¦‚æœä½ æƒ³å°†å¹´ä»½å†™æˆå››ä½æ•°å­—ï¼Œä½ å¯ä»¥æŒ‡å®šä¸º yyyyã€‚åœ¨ REPL ä¸­çš„ä¸€äº›ä»£ç ç¤ºä¾‹åº”è¯¥èƒ½è®©ä½ äº†è§£è¿™æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Not all formats deal with numbers. u and U give the name of the month, such
    as January and February. e and E give the name of the day, such as Monday and
    Tuesday:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶éæ‰€æœ‰æ ¼å¼éƒ½å¤„ç†æ•°å­—ã€‚u å’Œ U æä¾›æœˆä»½çš„åç§°ï¼Œä¾‹å¦‚ä¸€æœˆå’ŒäºŒæœˆã€‚e å’Œ E æä¾›æ˜ŸæœŸçš„åç§°ï¼Œä¾‹å¦‚æ˜ŸæœŸä¸€å’Œæ˜ŸæœŸäºŒï¼š
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 11.4.2 Raw strings
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 åŸå§‹å­—ç¬¦ä¸²
- en: 'One issue with regular Julia strings is that characters such as $ and \n have
    special meaning. For particular kinds of text this can be cumbersome. You can
    solve it by using the escape character, \\; thus $ would be written as \$ and
    \n as \\n. However, if you donâ€™t want to do that and donâ€™t need string interpolation,
    you can use raw strings:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œåƒ$å’Œ\nè¿™æ ·çš„å­—ç¬¦å…·æœ‰ç‰¹æ®Šå«ä¹‰ã€‚å¯¹äºæŸäº›ç±»å‹çš„æ–‡æœ¬ï¼Œè¿™å¯èƒ½ä¼šå¾ˆéº»çƒ¦ã€‚ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨è½¬ä¹‰å­—ç¬¦\\æ¥è§£å†³å®ƒï¼›å› æ­¤ï¼Œ$å°†è¢«å†™ä½œ\$ï¼Œ\nå°†è¢«å†™ä½œ\\nã€‚ç„¶è€Œï¼Œå¦‚æœä½ ä¸æƒ³è¿™æ ·åšï¼Œä¹Ÿä¸éœ€è¦å­—ç¬¦ä¸²æ’å€¼ï¼Œä½ å¯ä»¥ä½¿ç”¨åŸå§‹å­—ç¬¦ä¸²ï¼š
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this case the nonstandard string literal doesnâ€™t create a new type of object.
    Instead, it interprets the contents of the string literal differently when constructing
    a string object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œéæ ‡å‡†å­—ç¬¦ä¸²å­—é¢é‡ä¸ä¼šåˆ›å»ºæ–°çš„å¯¹è±¡ç±»å‹ã€‚ç›¸åï¼Œå®ƒåœ¨æ„å»ºå­—ç¬¦ä¸²å¯¹è±¡æ—¶ä»¥ä¸åŒçš„æ–¹å¼è§£é‡Šå­—ç¬¦ä¸²å­—é¢é‡çš„å†…å®¹ã€‚
- en: 11.4.3 Using regular expressions to match text
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ–‡æœ¬
- en: Regular expressions are a kind of miniature language you can use to specify
    text to match. Regular expressions are widely used in Unix text processing tools
    and in many coding editors. For example, you can use regular expressions to search
    for a particular text string in your code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åˆ™è¡¨è¾¾å¼æ˜¯ä¸€ç§ä½ å¯ä»¥ç”¨æ¥æŒ‡å®šè¦åŒ¹é…çš„æ–‡æœ¬çš„å¾®å‹è¯­è¨€ã€‚æ­£åˆ™è¡¨è¾¾å¼åœ¨Unixæ–‡æœ¬å¤„ç†å·¥å…·å’Œè®¸å¤šç¼–ç ç¼–è¾‘å™¨ä¸­å¹¿æ³›ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åœ¨ä»£ç ä¸­æœç´¢ç‰¹å®šçš„æ–‡æœ¬å­—ç¬¦ä¸²ã€‚
- en: 'In this example, you have some Julia source code stored in the variable s.
    You have decided you want to change the name of the Rocket type to SpaceCraft.
    You can use the function replace to locate some text to replace:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ æœ‰ä¸€äº›å­˜å‚¨åœ¨å˜é‡sä¸­çš„Juliaæºä»£ç ã€‚ä½ å·²ç»å†³å®šä½ æƒ³å°†Rocketç±»å‹çš„åç§°æ›´æ”¹ä¸ºSpaceCraftã€‚ä½ å¯ä»¥ä½¿ç”¨replaceå‡½æ•°å®šä½è¦æ›¿æ¢çš„æ–‡æœ¬ï¼š
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: â¶ Some source code text in which you imagine a string substitution is needed
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ åœ¨è¿™æ®µæºä»£ç æ–‡æœ¬ä¸­ï¼Œä½ æƒ³è±¡éœ€è¦è¿›è¡Œå­—ç¬¦ä¸²æ›¿æ¢
- en: â· Replace the occurrence of Rocket with SpaceCraft.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: â· å°†Rocketçš„å‡ºç°æ›¿æ¢ä¸ºSpaceCraftã€‚
- en: As you remember from chapter 6, you use the => operator to create a pair; this
    was used to create key-value pairs to store in the dictionary. In this case the
    pair represents text to find and substitution text. So "Rocket"=>"SpaceCraft"
    means locate "Rocket", and replace it with "SpaceCraft".
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ ä»ç¬¬6ç« æ‰€è®°å¾—çš„ï¼Œä½ ä½¿ç”¨=>è¿ç®—ç¬¦æ¥åˆ›å»ºä¸€ä¸ªå¯¹ï¼›è¿™è¢«ç”¨æ¥åˆ›å»ºé”®å€¼å¯¹ä»¥å­˜å‚¨åœ¨å­—å…¸ä¸­ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå¯¹ä»£è¡¨è¦æŸ¥æ‰¾çš„æ–‡æœ¬å’Œæ›¿æ¢æ–‡æœ¬ã€‚æ‰€ä»¥â€œRocket"=>"SpaceCraftâ€æ„å‘³ç€å®šä½â€œRocketâ€ï¼Œå¹¶å°†å…¶æ›¿æ¢ä¸ºâ€œSpaceCraftâ€ã€‚
- en: However, as you can see from the example, this does not do exactly what you
    would have expected. "RocketEngine" also gets replaced with "SpaceCraftEngine".
    However, in this case, you only want the Rocket type to be changed. With regular
    expressions it is easier to be more specific about what you are looking for.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ­£å¦‚ä½ ä»ä¾‹å­ä¸­çœ‹åˆ°çš„ï¼Œè¿™å¹¶æ²¡æœ‰å®Œå…¨è¾¾åˆ°ä½ çš„é¢„æœŸã€‚â€œRocketEngineâ€ä¹Ÿè¢«æ›¿æ¢ä¸ºâ€œSpaceCraftEngineâ€ã€‚ç„¶è€Œï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ åªæƒ³æ›´æ”¹Rocketç±»å‹ã€‚ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å¯ä»¥æ›´å®¹æ˜“åœ°æ›´å…·ä½“åœ°è¯´æ˜ä½ è¦æ‰¾çš„æ˜¯ä»€ä¹ˆã€‚
- en: In regular expressions "." means any character; [A-D] means any character from
    A to D; and writing [^A-D] means any character *not* in the range A to D. So "Rocket[^A-Za-z]"
    would mean finding the word *Rocket* and where the first succeeding character
    is *not* a letter, as follows.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ­£åˆ™è¡¨è¾¾å¼ä¸­ï¼Œ"."è¡¨ç¤ºä»»ä½•å­—ç¬¦ï¼›â€œ[A-D]â€è¡¨ç¤ºä»Aåˆ°Dçš„ä»»ä½•å­—ç¬¦ï¼›è€Œå†™ä½œâ€œ[^A-D]â€è¡¨ç¤ºä¸åœ¨Aåˆ°DèŒƒå›´å†…çš„ä»»ä½•å­—ç¬¦ã€‚å› æ­¤ï¼Œâ€œRocket[^A-Za-z]â€æ„å‘³ç€æ‰¾åˆ°å•è¯â€œRocketâ€ï¼Œå¹¶ä¸”ç¬¬ä¸€ä¸ªåç»­å­—ç¬¦ä¸æ˜¯å­—æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: Listing 11.14 Text substitution using regular expressions
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨11.14 ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ–‡æœ¬æ›¿æ¢
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this example, you turn the string you are searching for into a regular expression
    by prefixing it with a r. That means it will not be a string object. This can
    be demonstrated in the REPL:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ é€šè¿‡åœ¨å‰é¢åŠ ä¸Šrå°†ä½ è¦æœç´¢çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼ã€‚è¿™æ„å‘³ç€å®ƒå°†ä¸æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å¯¹è±¡ã€‚è¿™å¯ä»¥åœ¨REPLä¸­æ¼”ç¤ºï¼š
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This regular expression object is created during parsing, not at runtime. Thus,
    just like with DateFormat, you avoid parsing the same regular expression multiple
    times during runtime.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡æ˜¯åœ¨è§£ææ—¶åˆ›å»ºçš„ï¼Œè€Œä¸æ˜¯åœ¨è¿è¡Œæ—¶ã€‚å› æ­¤ï¼Œå°±åƒDateFormatä¸€æ ·ï¼Œä½ é¿å…äº†åœ¨è¿è¡Œæ—¶å¤šæ¬¡è§£æç›¸åŒçš„æ­£åˆ™è¡¨è¾¾å¼ã€‚ '
- en: 'There is a lot of good documentation on regular expression syntax, so I will
    only provide an overview of the most basic characters used in regular expressions.
    The following is a list of what are called *character classes*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºæ­£åˆ™è¡¨è¾¾å¼è¯­æ³•çš„è‰¯å¥½æ–‡æ¡£æœ‰å¾ˆå¤šï¼Œæ‰€ä»¥æˆ‘å°†åªæ¦‚è¿°æ­£åˆ™è¡¨è¾¾å¼ä¸­ä½¿ç”¨çš„åŸºæœ¬å­—ç¬¦ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ‰€è°“çš„*å­—ç¬¦ç±»*çš„åˆ—è¡¨ï¼š
- en: '| Character | Meaning | Example |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| å­—ç¬¦ | å«ä¹‰ | ç¤ºä¾‹ |'
- en: '| \d | Match any digit | "387543" |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| \d | åŒ¹é…ä»»ä½•æ•°å­— | "387543" |'
- en: '| \w | Match any alphanumeric word with underscore | "foo_bar_42" |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| \w | åŒ¹é…ä»»ä½•åŒ…å«ä¸‹åˆ’çº¿çš„å­—æ¯æ•°å­—è¯ | "foo_bar_42" |'
- en: '| \s | Match any whitespace, tabs, linefeed, space | " " |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| \s | åŒ¹é…ä»»ä½•ç©ºç™½å­—ç¬¦ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦ã€ç©ºæ ¼ | " " |'
- en: '| . | Match any character | "aA ;%4t" |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| . | åŒ¹é…ä»»ä½•å­—ç¬¦ | "aA ;%4t" |'
- en: 'You also have special characters, which influence how the matching of character
    classes is done; these are called *quantifiers*. They can show how many times
    a character class should be repeated:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è¿˜æœ‰ç‰¹æ®Šå­—ç¬¦ï¼Œå®ƒä»¬ä¼šå½±å“å­—ç¬¦ç±»åŒ¹é…çš„æ–¹å¼ï¼›è¿™äº›è¢«ç§°ä¸º*é‡è¯*ã€‚å®ƒä»¬å¯ä»¥æ˜¾ç¤ºå­—ç¬¦ç±»åº”è¯¥é‡å¤å¤šå°‘æ¬¡ï¼š
- en: '| Character | Meaning |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| å­—ç¬¦ | å«ä¹‰ |'
- en: '| * | Repeat character 0 or more times |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| * | é‡å¤å­—ç¬¦0æ¬¡æˆ–å¤šæ¬¡ |'
- en: '| + | Repeat one or more times |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| + | é‡å¤ä¸€æ¬¡æˆ–å¤šæ¬¡ |'
- en: '| ? | Zero or one time |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| ? | é›¶æ¬¡æˆ–ä¸€æ¬¡ |'
- en: 'More complex interaction with the Julia regular expression system would involve
    working with RegexMatch objects. In this example, you want to pick out a number
    with multiple digits, \d+, and a word composed of multiple letters, \w+. You can
    do this with the match function, which will return a RegexMatch object containing
    all the matches:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ Julia æ­£åˆ™è¡¨è¾¾å¼ç³»ç»Ÿçš„æ›´å¤æ‚äº¤äº’å°†æ¶‰åŠä½¿ç”¨ RegexMatch å¯¹è±¡ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ æƒ³è¦æŒ‘é€‰å‡ºä¸€ä¸ªå¤šä½æ•°ï¼Œ\d+ï¼Œå’Œä¸€ä¸ªç”±å¤šä¸ªå­—æ¯ç»„æˆçš„å•è¯ï¼Œ\w+ã€‚ä½ å¯ä»¥ä½¿ç”¨
    match å‡½æ•°æ¥å®Œæˆï¼Œå®ƒå°†è¿”å›ä¸€ä¸ªåŒ…å«æ‰€æœ‰åŒ¹é…çš„ RegexMatch å¯¹è±¡ï¼š
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: â¶ Define a regular expression.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å®šä¹‰ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ã€‚
- en: â· Match regex against a string.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: â· å°†æ­£åˆ™è¡¨è¾¾å¼ä¸å­—ç¬¦ä¸²åŒ¹é…ã€‚
- en: â¸ Access the first and second match.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ è®¿é—®ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªåŒ¹é…ã€‚
- en: Notice how some parts of the regular expression contain parentheses; these capture
    that part of the string. You have set up your regular expression object rx to
    capture a number and a word. You can access these captures through integer indices,
    such as m[1] and m[2].
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æ­£åˆ™è¡¨è¾¾å¼ä¸­ä¸€äº›éƒ¨åˆ†åŒ…å«æ‹¬å·ï¼›è¿™äº›æ‹¬å·æ•è·äº†å­—ç¬¦ä¸²çš„è¿™éƒ¨åˆ†ã€‚ä½ å·²ç»è®¾ç½®äº†ä½ çš„æ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡ rx æ¥æ•è·ä¸€ä¸ªæ•°å­—å’Œä¸€ä¸ªå•è¯ã€‚ä½ å¯ä»¥é€šè¿‡æ•´æ•°ç´¢å¼•è®¿é—®è¿™äº›æ•è·ï¼Œä¾‹å¦‚
    m[1] å’Œ m[2]ã€‚
- en: 'For more complex regular expressions it can be difficult to keep track of the
    position of each capture. Fortunately, regular expressions allow you to name your
    captures. Say you want to capture hours and minutes from the string 11:30. You
    could use the regular expression r"(\d+):(\d+)", but instead you will name each
    match using ?<s>, where s is the name of the capture:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ›´å¤æ‚çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¾ˆéš¾è·Ÿè¸ªæ¯ä¸ªæ•è·çš„ä½ç½®ã€‚å¹¸è¿çš„æ˜¯ï¼Œæ­£åˆ™è¡¨è¾¾å¼å…è®¸ä½ å‘½åä½ çš„æ•è·ã€‚æ¯”å¦‚è¯´ï¼Œä½ æƒ³ä»å­—ç¬¦ä¸² 11:30 ä¸­æ•è·å°æ—¶å’Œåˆ†é’Ÿã€‚ä½ å¯ä»¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼
    r"(\d+):(\d+)"ï¼Œä½†ä½ å¯ä»¥ä½¿ç”¨ ?<s> å‘½åæ¯ä¸ªåŒ¹é…ï¼Œå…¶ä¸­ s æ˜¯æ•è·çš„åç§°ï¼š
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'RegexMatch objects act a lot like Julia collections, so you can iterate over
    a RegexMatch object with a for loop. When naming your regular expression captures,
    the RegexMatch object works with many of the same functions applicable to dictionaries:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: RegexMatch å¯¹è±¡åœ¨å¾ˆå¤šæ–¹é¢éƒ½ç±»ä¼¼äº Julia é›†åˆï¼Œå› æ­¤ä½ å¯ä»¥ä½¿ç”¨ for å¾ªç¯è¿­ä»£ RegexMatch å¯¹è±¡ã€‚å½“å‘½åä½ çš„æ­£åˆ™è¡¨è¾¾å¼æ•è·æ—¶ï¼ŒRegexMatch
    å¯¹è±¡ä¸å­—å…¸ä¸­å¯ç”¨çš„è®¸å¤šç›¸åŒå‡½æ•°ä¸€èµ·å·¥ä½œï¼š
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While regular expressions are extremely powerful and versatile, it is easy to
    end up overusing them. Rob Pike, one of the creators of the Go, Plan 9, UTF-8,
    and many other popular technologies in systems programming, has repeatedly warned
    against the overuse of regular expressions. They can get complex and difficult
    to modify as new requirements arise.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æ­£åˆ™è¡¨è¾¾å¼éå¸¸å¼ºå¤§ä¸”çµæ´»ï¼Œä½†è¿‡åº¦ä½¿ç”¨å®ƒä»¬å¾ˆå®¹æ˜“ã€‚Goã€Plan 9ã€UTF-8 ä»¥åŠè®¸å¤šå…¶ä»–ç³»ç»Ÿç¼–ç¨‹ä¸­æµè¡Œçš„æŠ€æœ¯çš„åˆ›é€ è€…ä¹‹ä¸€ Rob Pike ä¸€ç›´è­¦å‘Šè¿‡åº¦ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ã€‚éšç€æ–°éœ€æ±‚çš„æå‡ºï¼Œå®ƒä»¬å¯èƒ½ä¼šå˜å¾—å¤æ‚ä¸”éš¾ä»¥ä¿®æ”¹ã€‚
- en: Personally, I rarely use them. In Julia you get very far with basic string and
    character functions, such as split, endswith, startswith, isdigit, isletter, and
    isuppercase.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ªäººæ¥è¯´ï¼Œæˆ‘å¾ˆå°‘ä½¿ç”¨å®ƒä»¬ã€‚åœ¨ Julia ä¸­ï¼Œä½ å¯ä»¥é€šè¿‡åŸºæœ¬çš„å­—ç¬¦ä¸²å’Œå­—ç¬¦å‡½æ•°ï¼ˆå¦‚ splitã€endswithã€startswithã€isdigitã€isletter
    å’Œ isuppercaseï¼‰èµ°å¾—å¾ˆè¿œã€‚
- en: 11.4.4 Making large integers with BigInt
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4 ä½¿ç”¨ BigInt åˆ›å»ºå¤§æ•´æ•°
- en: 'A literal syntax exists for most number types, as shown in these examples:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°æ•°å­—ç±»å‹éƒ½å­˜åœ¨å­—é¢é‡è¯­æ³•ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the cases it does not exist, you can do a conversion like this Int8(42),
    which takes a 64-bit signed integer and turns it into an 8-bit signed integer.
    When writing integers of arbitrary precision (any number of digits) you can do
    this as well by writing BigInt(42); however, this may cause some inefficiency.
    Everywhere this is encountered an integer has to be converted to a big int. Instead,
    if you write big"42", the big integer is created when the program is parsedâ€”not
    each time it is run.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥è¿›è¡Œå¦‚ä¸‹è½¬æ¢ï¼šInt8(42)ï¼Œå®ƒå°†ä¸€ä¸ª64ä½æœ‰ç¬¦å·æ•´æ•°è½¬æ¢ä¸º8ä½æœ‰ç¬¦å·æ•´æ•°ã€‚å½“ç¼–å†™ä»»æ„ç²¾åº¦çš„æ•´æ•°ï¼ˆä»»æ„æ•°é‡çš„æ•°å­—ï¼‰æ—¶ï¼Œä½ ä¹Ÿå¯ä»¥è¿™æ ·åšï¼Œé€šè¿‡ç¼–å†™BigInt(42)ï¼›ç„¶è€Œï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›ä½æ•ˆã€‚åœ¨é‡åˆ°è¿™ç§æƒ…å†µæ—¶ï¼Œå¿…é¡»å°†æ•´æ•°è½¬æ¢ä¸ºå¤§æ•´æ•°ã€‚ç›¸åï¼Œå¦‚æœä½ å†™big"42"ï¼Œå¤§æ•´æ•°å°†åœ¨ç¨‹åºè§£ææ—¶åˆ›å»ºâ€”â€”è€Œä¸æ˜¯æ¯æ¬¡è¿è¡Œæ—¶éƒ½åˆ›å»ºã€‚
- en: This isnâ€™t built into the language. Anyone can define a number literal. The
    following is an example of adding support for writing int8"42" to create 42 at
    parse time as a signed 8-bit integer. You can use this as an example to also demonstrate
    that macros, unlike functions, only get called once.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸æ˜¯è¯­è¨€å†…ç½®çš„ã€‚ä»»ä½•äººéƒ½å¯ä»¥å®šä¹‰ä¸€ä¸ªæ•°å­—å­—é¢é‡ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œæ·»åŠ å¯¹å†™å…¥ int8"42" ä»¥åœ¨è§£ææ—¶åˆ›å»º 42 ä½œä¸ºæœ‰ç¬¦å· 8 ä½æ•´æ•°çš„æ”¯æŒã€‚ä½ å¯ä»¥ç”¨è¿™ä¸ªä¾‹å­æ¥å±•ç¤ºå®ä¸å‡½æ•°ä¸åŒï¼Œå®åªè°ƒç”¨ä¸€æ¬¡ã€‚
- en: Listing 11.15 Defining string literals for an 8-bit signed integer
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 11.15 å®šä¹‰ 8 ä½æœ‰ç¬¦å·æ•´æ•°çš„å­—ç¬¦ä¸²å­—é¢é‡
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: â¶ For a string literal with the prefix foo, such as foo"42", write foo_str.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å¯¹äºå…·æœ‰å‰ç¼€ foo çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼Œä¾‹å¦‚ foo"42"ï¼Œå†™å…¥ foo_strã€‚
- en: â· By writing out a message each time the macro is called, you can see how often
    it is called.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: â· é€šè¿‡åœ¨æ¯æ¬¡å®è°ƒç”¨æ—¶è¾“å‡ºä¸€æ¡æ¶ˆæ¯ï¼Œä½ å¯ä»¥çœ‹åˆ°å®ƒè¢«è°ƒç”¨çš„é¢‘ç‡ã€‚
- en: â¸ Parsing the number string and returning an 8-bit number
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ è§£ææ•°å­—å­—ç¬¦ä¸²å¹¶è¿”å› 8 ä½æ•°å­—
- en: 'Now you can try it out in a loop. If macros work like functions you should
    get a function call each time you add to the total in the loop:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ å¯ä»¥åœ¨å¾ªç¯ä¸­å°è¯•å®ƒã€‚å¦‚æœå®åƒå‡½æ•°ä¸€æ ·å·¥ä½œï¼Œé‚£ä¹ˆä½ åº”è¯¥åœ¨å¾ªç¯ä¸­æ¯æ¬¡å¢åŠ æ€»æ•°æ—¶éƒ½å¾—åˆ°ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼š
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, you only see hello written once, instead of four times. That is all
    I will say about macros, as it is a too big topic to cover in a beginner-level
    textbook. However, it is useful to be aware of some of the more powerful features
    that exist in Julia, even if you will be unlikely to need them for your first
    Julia programs.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä½ åªçœ‹åˆ° hello å†™äº†ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯å››æ¬¡ã€‚è¿™å°±æ˜¯æˆ‘è¦è¯´çš„å…³äºå®çš„æ‰€æœ‰å†…å®¹ï¼Œå› ä¸ºè¿™ä¸ªè¯é¢˜å¤ªå¤§ï¼Œä¸é€‚åˆåœ¨å…¥é—¨çº§æ•™ç§‘ä¹¦ä¸­æ¶µç›–ã€‚ç„¶è€Œï¼Œäº†è§£ Julia
    ä¸­å­˜åœ¨çš„ä¸€äº›æ›´å¼ºå¤§çš„åŠŸèƒ½æ˜¯æœ‰ç”¨çš„ï¼Œå³ä½¿ä½ ä¸å¤ªå¯èƒ½åœ¨ä½ æœ€åˆçš„ Julia ç¨‹åºä¸­éœ€è¦å®ƒä»¬ã€‚
- en: 11.4.5 MIME types
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.5 MIME ç±»å‹
- en: Various operating systems have different systems for keeping track of the type
    of its files. For example, Windows famously uses a three-letter filename extension
    to indicate the type of a file. The original macOS stored the file type in special
    attributes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸åŒçš„æ“ä½œç³»ç»Ÿæœ‰ä¸åŒçš„ç³»ç»Ÿæ¥è·Ÿè¸ªå…¶æ–‡ä»¶ç±»å‹ã€‚ä¾‹å¦‚ï¼ŒWindows é—»ååœ°ä½¿ç”¨ä¸‰ä¸ªå­—æ¯çš„æ–‡ä»¶æ‰©å±•åæ¥æŒ‡ç¤ºæ–‡ä»¶ç±»å‹ã€‚åŸå§‹çš„ macOS å°†æ–‡ä»¶ç±»å‹å­˜å‚¨åœ¨ç‰¹æ®Šå±æ€§ä¸­ã€‚
- en: 'However, to send files of different types between computers on the internet,
    one needs a common standard to identify the file types; this is what MIME types
    are. They are typically described as a type and subtype separated by a slash.
    HTML pages are denoted as text/html, while JPEG images are denoted as image/jpeg.
    A PNG file type would be written as image/png and so on. You can create a MIME
    type object in Julia with the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸ºäº†åœ¨äº’è”ç½‘ä¸Šçš„è®¡ç®—æœºä¹‹é—´å‘é€ä¸åŒç±»å‹çš„æ–‡ä»¶ï¼Œéœ€è¦ä¸€ä¸ªå…±åŒçš„æ ‡å‡†æ¥è¯†åˆ«æ–‡ä»¶ç±»å‹ï¼›è¿™å°±æ˜¯ MIME ç±»å‹çš„ç”¨é€”ã€‚å®ƒä»¬é€šå¸¸è¢«æè¿°ä¸ºç”¨æ–œæ åˆ†éš”çš„ç±»å‹å’Œå­ç±»å‹ã€‚HTML
    é¡µé¢è¡¨ç¤ºä¸º text/htmlï¼Œè€Œ JPEG å›¾åƒè¡¨ç¤ºä¸º image/jpegã€‚PNG æ–‡ä»¶ç±»å‹å°†å†™ä½œ image/png ç­‰ç­‰ã€‚ä½ å¯ä»¥åœ¨ Julia ä¸­ä½¿ç”¨ä»¥ä¸‹æ–¹å¼åˆ›å»º
    MIME ç±»å‹å¯¹è±¡ï¼š
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: So a MIME type object MIME("foo/bar") would have the type MIME{Symbol{"foo/bar"}}.
    This will look somewhat cryptic until I cover parametric types in chapter 18\.
    MIME{Symbol{"foo/bar"}} is long and cumbersome to write, which is why Julia offers
    the shortcut MIME"foo/bar".
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒMIME ç±»å‹å¯¹è±¡ MIME("foo/bar") å°†å…·æœ‰ç±»å‹ MIME{Symbol{"foo/bar"}}ã€‚è¿™å°†åœ¨æˆ‘ä»‹ç»ç¬¬ 18 ç« çš„å‚æ•°åŒ–ç±»å‹ä¹‹å‰çœ‹èµ·æ¥æœ‰äº›æ™¦æ¶©ã€‚MIME{Symbol{"foo/bar"}}
    å†™èµ·æ¥æ—¢é•¿åˆç¹çï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆ Julia æä¾›äº† MIME"foo/bar" çš„å¿«æ·æ–¹å¼ã€‚
- en: 'This is easy to mix up. MIME("foo/bar") and MIME"foo/bar" are *not* the same
    thing. The first case is an object, while the latter is the object type. The following
    is a simple example of how you could use this to create methods giving different
    outputs for different MIME types:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆå®¹æ˜“æ··æ·†ã€‚MIME("foo/bar") å’Œ MIME"foo/bar" å¹¶ä¸ç›¸åŒã€‚å‰è€…æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè€Œåè€…æ˜¯å¯¹è±¡ç±»å‹ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•ç¤ºä¾‹ï¼Œè¯´æ˜ä½ å¯ä»¥å¦‚ä½•ä½¿ç”¨å®ƒä¸ºä¸åŒçš„
    MIME ç±»å‹åˆ›å»ºæä¾›ä¸åŒè¾“å‡ºç»“æœçš„æ–¹æ³•ï¼š
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is useful because it allows you to define functions in Julia, which can
    provide different formatted textual outputs for different contexts:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºå®ƒå…è®¸ä½ åœ¨ Julia ä¸­å®šä¹‰å‡½æ•°ï¼Œä¸ºä¸åŒçš„ä¸Šä¸‹æ–‡æä¾›ä¸åŒæ ¼å¼çš„æ–‡æœ¬è¾“å‡ºï¼š
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Julia code executing in a graphical notebook style environment, such as Jupyter
    ([https://jupyter.org](https://jupyter.org)), would get passed an HTML MIME type,
    so graphs and tables can be rendered as HTML.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å›¾å½¢ç¬”è®°æœ¬é£æ ¼çš„ç¯å¢ƒä¸­æ‰§è¡Œ Julia ä»£ç ï¼Œä¾‹å¦‚ Jupyter ([https://jupyter.org](https://jupyter.org))ï¼Œä¼šä¼ é€’ä¸€ä¸ª
    HTML MIME ç±»å‹ï¼Œå› æ­¤å›¾è¡¨å’Œè¡¨æ ¼å¯ä»¥ä»¥ HTML æ ¼å¼æ¸²æŸ“ã€‚
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: Julia strings are encoded in UTF-8, which means each code point is encoded as
    a variable number of code units.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia å­—ç¬¦ä¸²ä»¥ UTF-8 ç¼–ç ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªç ç‚¹è¢«ç¼–ç ä¸ºä¸€ä¸ªå¯å˜æ•°é‡çš„ç å•å…ƒã€‚
- en: parse is used to convert strings to other types, such as numbers.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: parse ç”¨äºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå…¶ä»–ç±»å‹ï¼Œä¾‹å¦‚æ•°å­—ã€‚
- en: string can be used to convert numbers into strings.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: string å¯ä»¥ç”¨æ¥å°†æ•°å­—è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚
- en: Julia strings can be combined with other object types using either the string
    interpolation with the $ symbol or string function with a variable number of arguments.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia å­—ç¬¦ä¸²å¯ä»¥é€šè¿‡ä½¿ç”¨ $ ç¬¦å·è¿›è¡Œå­—ç¬¦ä¸²æ’å€¼æˆ–ä½¿ç”¨å…·æœ‰å¯å˜æ•°é‡å‚æ•°çš„å­—ç¬¦ä¸²å‡½æ•°ä¸å…¶ä»–å¯¹è±¡ç±»å‹ç»“åˆã€‚
- en: Strings can be concatenated with the multiplication operator *.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­—ç¬¦ä¸²å¯ä»¥ä½¿ç”¨ä¹˜æ³•è¿ç®—ç¬¦ * è¿›è¡Œè¿æ¥ã€‚
- en: Formatted output to stdout is achieved using the @printf macro. Use @sprintf
    to get a string value returned instead. Both are in the Printf module.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ @printf å®å¯ä»¥åœ¨æ ‡å‡†è¾“å‡ºï¼ˆstdoutï¼‰ä¸Šå®ç°æ ¼å¼åŒ–è¾“å‡ºã€‚ä½¿ç”¨ @sprintf è·å–è¿”å›çš„å­—ç¬¦ä¸²å€¼ã€‚è¿™ä¸¤ä¸ªéƒ½åœ¨ Printf æ¨¡å—ä¸­ã€‚
- en: 'String literals in Julia are extendible, but it comes with several built-in
    ones: raw strings, big integers, and regular expressions.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia ä¸­çš„å­—ç¬¦ä¸²æ˜¯å¯æ‰©å±•çš„ï¼Œä½†å®ƒè‡ªå¸¦äº†ä¸€äº›å†…ç½®ç±»å‹ï¼šåŸå§‹å­—ç¬¦ä¸²ã€å¤§æ•´æ•°å’Œæ­£åˆ™è¡¨è¾¾å¼ã€‚
