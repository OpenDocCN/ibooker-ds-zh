- en: 2 Designing a layout using CSS Grid
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 使用CSS Grid设计布局
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Exploring grid tracks and arranging our grids
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索网格轨道并排列我们的网格
- en: Using the `minmax` and `repeat` functions in CSS Grid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CSS网格中使用`minmax`和`repeat`函数
- en: Working with the fraction unit, which is unique to CSS Grid
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS Grid独特的分数单位
- en: Creating template areas and placing items in the areas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板区域并将项目放置在区域中
- en: Considering accessibility when using grids
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格时考虑可访问性
- en: Creating gutters between columns and rows within grids
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格中创建列和行之间的间隙
- en: Now that we have a basic understanding of how CSS works, we can begin exploring
    our options for laying out HTML content. In this chapter, we’ll focus on layout
    with grids.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对CSS的工作原理有了基本的了解，我们可以开始探索布局HTML内容的选项。在本章中，我们将专注于使用网格进行布局。
- en: 2.1 CSS Grid
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 CSS Grid
- en: A *grid*, in this sense, is a network of lines that cross to form a series of
    squares or rectangles. Now supported by all major browsers, CSS Grid has become
    a popular layout technique.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，*网格*是由交叉形成一系列正方形或矩形的线条网络。现在所有主流浏览器都支持CSS Grid，它已成为一种流行的布局技术。
- en: Essentially, a grid is made up of columns and rows. We’ll create our grid and
    then assign positions to our items much as we place boats on a grid when playing
    the board game Battleship.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，网格由列和行组成。我们将创建我们的网格，然后为我们的项目分配位置，就像我们在玩棋盘游戏“战舰”时在网格上放置船只一样。
- en: Although grid layouts are sometimes compared with tables, they have different
    uses and fulfill different needs. Grids are for layouts, whereas tables are for
    tabular data. If the content being styled is appropriate for a Microsoft Excel
    sheet, it’s tabular data and should be placed in a table.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网格布局有时与表格相比较，但它们有不同的用途和满足不同的需求。网格用于布局，而表格用于表格数据。如果正在设计的样式内容适合Microsoft Excel表格，那么它是表格数据，应该放在表格中。
- en: In the mid-2000s, we used tables for layouts, and sometimes we still need to.
    (Emails, for example, sometimes require the use of tables for layout, as they
    support only a subset of CSS styles.) On the web, however, this technique is considered
    to be bad practice because it leads to poor accessibility and lack of semantics.
    Now we can use a grid instead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代中期，我们使用表格进行布局，有时我们仍然需要这样做。（例如，电子邮件有时需要使用表格进行布局，因为它们只支持CSS样式的一个子集。）然而，在网络上，这种技术被认为是不良实践，因为它会导致可访问性差和语义缺失。现在我们可以使用网格代替。
- en: CSS Grid empowers us to be creative, to produce a range of layouts, and to adapt
    those layouts for different conditions in conjunction with media queries. We’ll
    use a grid to style our project, and by the end of the chapter, our layout will
    look like figure 2.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Grid赋予我们创造力，可以制作各种布局，并配合媒体查询适应不同条件。我们将使用网格来设计我们的项目，到本章结束时，我们的布局将看起来像图2.1。
- en: '![](../Images/02-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-01.png)'
- en: Figure 2.1 Final output
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 最终输出
- en: Our starting HTML, in the chapter-02 folder of the GitHub repository ([https://github.com/michaelgearon/Tiny-CSS-Projects](https://github.com/michaelgearon/Tiny-CSS-Projects))
    or in CodePen ([https://codepen.io/michaelgearon/pen/eYRKXqv](https://codepen.io/michaelgearon/pen/eYRKXqv)),
    looks like the following listing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在GitHub仓库的chapter-02文件夹中（[https://github.com/michaelgearon/Tiny-CSS-Projects](https://github.com/michaelgearon/Tiny-CSS-Projects)）或CodePen（[https://codepen.io/michaelgearon/pen/eYRKXqv](https://codepen.io/michaelgearon/pen/eYRKXqv)）的起始HTML，看起来如下所示。
- en: Listing 2.1 Project HTML
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 项目HTML
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① The container for our project
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们项目的容器
- en: ② The child items within our container
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们容器内的子元素
- en: We also have some starting CSS (listing 2.2) to guide us as we start to place
    our HTML elements in a grid format. We won’t worry about these preset styles (such
    as margin, padding, colors, typography, and borders) in this chapter. Those concepts
    are covered in other parts of the book because we want to focus on the layout
    for this project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些起始CSS（列表2.2），以指导我们在开始将HTML元素放置在网格格式时。在本章中，我们不会担心这些预设样式（如边距、填充、颜色、字体和边框）。这些概念在其他部分的书中有详细说明，因为我们想专注于本项目的布局。
- en: Listing 2.2 Starting CSS
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 起始CSS
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① The background covers the whole page even when the window is longer than the
    content.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ① 背景覆盖整个页面，即使窗口比内容长。
- en: ② Allows text to wrap around the image
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ② 允许文本围绕图像换行
- en: ③ Asterisk and child combinator selects any and all immediate children of main.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 星号和子组合选择主元素的所有直接子元素。
- en: ④ border points out sections to be positioned via a grid.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 边框指出通过网格定位的章节。
- en: ⑤ Prevents images from bleeding out of their containers
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 防止图像从其容器中溢出
- en: ⑥ Indents the last two lines of the sonnet
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 缩进十四行诗的最后两行
- en: ⑦ Indents the list; otherwise, bullets are right up against the image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 缩进列表；否则，项目符号会紧挨着图像。
- en: We change the font from `serif` to `sans-serif`, and we increase the margin
    between the boundary of the browser window and the container by using `margin`.
    We also float images to the left and adjust the line heights, typography, and
    padding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字体从`serif`改为`sans-serif`，并使用`margin`增加浏览器窗口边界和容器之间的间距。我们还使图像左浮动，并调整行高、字体和填充。
- en: Note that we added a border and some padding to the immediate children of the
    `main` element to help us define our layout. We’ll remove those elements later
    in the project. Our starting point looks like figure 2.2.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`main`元素的直接子项上添加了边框和一些填充，以帮助我们定义布局。我们将在项目的后期移除这些元素。我们的起始点看起来像图2.2。
- en: '![](../Images/02-02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-02.png)'
- en: Figure 2.2 Starting point
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 起始点
- en: 'CSS grids are a way to place items on a 2D layout: horizontal (x-axis) and
    vertical (y-axis). By contrast, the flexbox (covered in chapter 6) is single-axis-oriented.
    It operates only on the x- or y-axis, depending on its configuration.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CSS网格是一种在2D布局上放置项的方法：水平（x轴）和垂直（y轴）。相比之下，flexbox（在第6章中介绍）是单轴导向的。它仅在其配置的x轴或y轴上操作。
- en: We can use both CSS Flexbox and CSS Grid to align and lay out items on a web
    page. But as we go through the chapter, we’ll find that one of the benefits of
    Grid over Flexbox is that it allows us to divide a page into regions and create
    complex layouts with relative ease.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CSS Flexbox和CSS Grid在网页上对齐和布局项。但随着我们进入本章，我们会发现Grid相对于Flexbox的一个好处是，它允许我们轻松地将页面划分为区域并创建复杂的布局。
- en: First, we’ll set up our grid. Then we’ll look at ways to alter how our grid
    behaves based on window size.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置我们的网格。然后我们将探讨根据窗口大小如何改变网格的行为。
- en: 2.2 Display grid
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 显示网格
- en: 'The first part of arranging a grid is setting the `display` value to `grid`
    on the parent container item. When creating a grid layout, we can use one of two
    values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安排网格的第一步是将父容器项的`display`值设置为`grid`。在创建网格布局时，我们可以使用两个值之一：
- en: '`grid`—Used when we want the browser to display the grid in a block-level box.
    The grid takes the full width of the container and sets itself on a new line.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid`—当我们希望浏览器在块级框中显示网格时使用。网格占据容器的全部宽度，并自行在新行上设置。'
- en: '`inline-grid`—Used when we want the grid to be an inline-level box. The grid
    sets itself inline with the previous content, much like a `<span>`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inline-grid`—当我们希望网格成为内联级框时使用。网格将自己设置为与之前内容的内联，就像一个`<span>`。'
- en: We’ll use the value `grid` for our layout, as shown in listing 2.3.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用列表2.3中显示的`grid`值进行布局。
- en: Difference between block-level and inline-level box
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 块级和内联级框的区别
- en: In HTML, every element is a box. A block-level box says that an element’s box
    should use the entire horizontal space of its parent element, therefore preventing
    any other element from being on the same horizontal line by default. By contrast,
    inline elements can allow other inline elements to be on the same horizontal line,
    depending on the remaining space.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，每个元素都是一个框。块级框表示一个元素的框应该使用其父元素的整个水平空间，因此默认情况下阻止任何其他元素位于同一水平线上。相比之下，内联元素允许其他内联元素位于同一水平线上，具体取决于剩余空间。
- en: Listing 2.3 Setting the display to `grid`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 设置显示为`grid`
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we preview this code in the browser, we notice that nothing has changed visually
    because the browser by default displays the direct child items in one column.
    Then the browser generates enough rows for all of the child elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中预览此代码，我们会注意到视觉上没有任何变化，因为浏览器默认情况下将直接子项显示在一列中。然后浏览器为所有子元素生成足够的行。
- en: 'Using the developer tools in our browser (figure 2.3), we see that, programmatically,
    the grid has been created even though the layout has not changed visually. To
    view the underlying grid in most browsers, we can right-click the web page and
    choose Inspect from the contextual menu. In the Inspect window in Mozilla Firefox,
    when we select the parent container, we see two things to indicate the layout
    is now a grid:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们浏览器中的开发者工具（图2.3），我们看到，尽管布局在视觉上没有改变，但网格已经被创建。要在大多数浏览器中查看底层网格，我们可以右键点击网页，并在上下文菜单中选择“检查”。在Mozilla
    Firefox的检查窗口中，当我们选择父容器时，我们看到两个指示布局现在是网格的东西：
- en: Purple lines around each direct child item.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个直接子项周围都有紫色线条。
- en: In the HTML, an icon called grid in the `<main>` element. When we click the
    grid icon next to `<main>`, the layout panel shows us our grid structure.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML中，`<main>`元素中有一个名为grid的图标。当我们点击`<main>`旁边的网格图标时，布局面板会显示我们的网格结构。
- en: '![](../Images/02-03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-03.png)'
- en: Figure 2.3 Development tools in Firefox
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 Firefox的开发工具
- en: We can follow similar steps in Google Chrome or Apple’s Safari.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Google Chrome或Apple的Safari中遵循类似的步骤。
- en: 2.3 Grid tracks and lines
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 网格轨道和线
- en: When the CSS Grid Layout Module was introduced, it brought in new terminology
    to describe laying out items. The first of those terms is *grid lines.* Lines
    run horizontally and vertically, and they’re numbered starting from 1 in the top-left
    corner. On the opposite side to the positive numbers are the negative numbers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当CSS网格布局模块被引入时，它引入了新的术语来描述布局项。这些术语中的第一个是*网格线*。网格线水平垂直排列，并从左上角开始编号为1。在正数对面的是负数。
- en: Writing mode and script direction
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 书写模式和脚本方向
- en: The number assigned to each line depends on the writing mode (whether lines
    of text are laid out horizontally or vertically) and the script direction of the
    component. If the writing mode is English, for example, the first line on the
    left is numbered 1\. If the language direction is set to right-to-left because
    of the language, for example, Arabic (which is written from right to left), line
    1 would be the farthest line to the right.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行分配的数字取决于书写模式（文本行是水平还是垂直排列）以及组件的脚本方向。例如，如果书写模式是英语，那么左边的第一行编号为1。如果由于语言而将语言方向设置为从右到左，例如阿拉伯语（从右到左书写），则第1行将是最右侧的行。
- en: The spaces between the grid lines are known as *grid tracks,* and they’re made
    up of columns and rows. Columns go from left to right, and rows go from top to
    bottom. A *track* is the space between any two lines on a grid. In figure 2.4,
    the highlighted track is the first row track in our grid. A column track would
    be the space between two vertical lines.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 网格线之间的空间被称为*网格轨道*，它们由列和行组成。列从左到右排列，行从上到下排列。*轨道*是网格上任意两条线之间的空间。在图2.4中，高亮的轨道是我们网格中的第一行轨道。列轨道将是两条垂直线之间的空间。
- en: '![](../Images/02-04.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-04.png)'
- en: Figure 2.4 Grid structure based on English as the writing mode, with the direction
    set to left-to-right
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 基于英语书写模式，方向设置为从左到右的网格结构
- en: Within each track are grid cells. A *cell* is the intersection of a grid row
    and a grid column.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轨道中都有网格单元格。*单元格*是网格行和网格列的交点。
- en: We can use the `grid-template-columns` and `grid-template-rows` properties to
    lay out our grid. These properties specify, as a space-separated track list, the
    line names and track sizing functions of the grid. The `grid-template-columns`
    property specifies the track list for the grid’s columns, and `grid-template-rows`
    specifies the track list for the grid’s rows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`grid-template-columns`和`grid-template-rows`属性来布局我们的网格。这些属性指定了一个以空格分隔的轨道列表，包括网格的线名和轨道尺寸函数。`grid-template-columns`属性指定了网格列的轨道列表，而`grid-template-rows`指定了网格行的轨道列表。
- en: Before we set our columns, we need to understand a few concepts that are specific
    to CSS Grid.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置列之前，我们需要了解一些CSS网格特有的概念。
- en: 2.3.1 Repeating columns
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 重复列
- en: To save repetition in your code, you can use the `repeat()` function to specify
    how many columns or rows you need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中避免重复，您可以使用`repeat()`函数来指定您需要的列数或行数。
- en: DEFINITION A *function* is a self-contained, reusable piece of code that has
    a specific role. Functions exist in other programming languages, such as JavaScript.
    Sometimes, we can pass one or more values to the function; these values are referred
    to as *parameters*. To pass values to a function, we place them in parentheses.
    We can’t create our own functions in CSS; instead, we use the built-in functions
    that CSS offers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*函数*是一个自包含的、可重用的代码片段，具有特定的角色。函数存在于其他编程语言中，如JavaScript。有时，我们可以向函数传递一个或多个值；这些值被称为*参数*。向函数传递值时，我们将它们放在括号中。我们无法在CSS中创建自己的函数；相反，我们使用CSS提供的内置函数。
- en: The `repeat()` function needs two values that are comma-separated. The first
    value indicates how many columns or rows to create. The second value is the sizing
    of each column or row.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`函数需要两个以逗号分隔的值。第一个值表示要创建多少列或行。第二个值是每列或每行的尺寸。'
- en: For our project, we’ll specify that we want two columns, and for the sizing
    of each column, we’ll use the `minmax()` function. Our column definition, therefore,
    will be `grid-template-columns:` `repeat(2,` `minmax(auto,` `1fr))` `250px;`.
    If we were defining the height of our rows, we’d use `repeat()` with `grid-template-rows`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将指定我们想要两列，并且对于每列的大小，我们将使用 `minmax()` 函数。因此，我们的列定义将是 `grid-template-columns:`
    `repeat(2,` `minmax(auto,` `1fr))` `250px;`。如果我们正在定义行的高度，我们将使用 `repeat()` 与 `grid-template-rows`。
- en: This declaration produces three columns, two of equal width using the fraction
    unit and one of 250 pixels. Let’s look at this declaration a bit further. Notice
    that inside the `repeat()` function, we use the `minmax()` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明生成了三列，其中两列使用分数单位具有相同宽度，一列为 250 像素。让我们进一步看看这个声明。注意在 `repeat()` 函数内部，我们使用了
    `minmax()` 函数。
- en: 2.3.2 The minmax() function
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 minmax() 函数
- en: 'The `minmax(min,` `max)` function is made up of two arguments: the minimum
    and maximum range of the grid track. The World Wide Web Consortium (W3C) specification
    states that the `minmax` function “defines a size range greater than or equal
    to `min` and less than or equal to `max`” ([https://www.w3.org/TR/css-grid-2](https://www.w3.org/TR/css-grid-2)).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`minmax(min,` `max)` 函数由两个参数组成：网格轨道的最小和最大范围。万维网联盟（W3C）规范指出，`minmax` 函数“定义了一个大于或等于
    `min` 且小于或等于 `max` 的大小范围”([https://www.w3.org/TR/css-grid-2](https://www.w3.org/TR/css-grid-2))。'
- en: Note To make the function valid, the `min` value (the first argument) needs
    to be smaller than the `max` value. Otherwise, the browser ignores `max`, and
    the function relies only on the `min` value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了使函数有效，`min` 值（第一个参数）需要小于 `max` 值。否则，浏览器会忽略 `max`，函数仅依赖于 `min` 值。
- en: For our project, we set the `min` value to `auto` and the `max` value to `2`.
    Let’s look at what `auto` means.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将 `min` 值设置为 `auto`，将 `max` 值设置为 `2`。让我们看看 `auto` 的含义。
- en: 2.3.3 The auto keyword
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 自动关键字
- en: The `auto` keyword can be used for either the minimum or maximum value within
    the function. When the keyword `auto` is used for the maximum value, it’s treated
    the same as the `max-content` keyword. The row’s or column’s dimensions will be
    equal to the amount of room that the content within the row or column requires.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 关键字可以在函数的最低或最高值中使用。当 `auto` 关键字用于最大值时，它被处理成与 `max-content` 关键字相同。行或列的尺寸将与行或列内内容所需的空间相等。'
- en: Although we don’t use it in our project, a common use case for the `auto` keyword
    is making layouts that include fixed headers and footers. When we assign overflow
    to the area for which `auto` was set, the area shrinks and grows with the window
    size, as shown in figure 2.5.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有在我们的项目中使用它，但 `auto` 关键字的一个常见用例是创建包含固定页眉和页脚的布局。当我们为设置为 `auto` 的区域分配溢出时，该区域会随着窗口大小而收缩和扩展，如图
    2.5 所示。
- en: '![](../Images/02-05.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2-5](../Images/02-05.png)'
- en: Figure 2.5 Examples of using the `auto` keyword
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 使用 `auto` 关键字的示例
- en: For our use case, in the statement `grid-template-columns:` `repeat(2,` `minmax(auto,`
    `1fr))` `250px;`, the `auto` keyword dictates that for our first two columns,
    the column should be, at minimum, as wide as the element it contains. Let’s take
    a look at the flexible length unit (`fr`) used to set our maximum width.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，在声明 `grid-template-columns:` `repeat(2,` `minmax(auto,` `1fr))` `250px;`
    中，`auto` 关键字规定，对于我们的前两列，列的最小宽度应与包含的元素宽度相同。让我们看看用来设置最大宽度的灵活长度单位（`fr`）。
- en: 2.3.4 The fractions (fr) unit
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 分数（fr）单位
- en: The fractions (`fr`) unit was introduced in the CSS Grid Layout Module. The
    `fr` unit, which is unique to Grid, tells the browser how much room an HTML element
    should have compared with other elements by distributing the leftover space after
    the minimums have been applied. CSS distributes the available space equally among
    the `fr` units, so the value of `1fr` is equal to the available space divided
    by the total number of `fr` units specified.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 分数单位（`fr`）是在 CSS 网格布局模块中引入的。`fr` 单位是网格特有的，它告诉浏览器一个 HTML 元素应该有多少空间，与其他元素相比，这是通过在应用最小值之后分配剩余空间来实现的。CSS
    将可用空间平均分配给 `fr` 单位，因此 `1fr` 的值等于可用空间除以指定的 `fr` 单位总数。
- en: Let’s explore what a fraction is through the tasty cake diagrams shown in figure
    2.6\. (Sorry if this figure makes you crave a slice of cake.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过图 2.6 中显示的美味蛋糕图解来探索分数的含义。（如果这个图让你想吃一块蛋糕，那很抱歉。）
- en: '![](../Images/02-06.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2-6](../Images/02-06.png)'
- en: Figure 2.6 Fractions values
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 分数值
- en: If you had a whole cake, it would equal 100%. From a CSS perspective, if we
    decided to eat all the cake, that would be 1 fraction. In our CSS, that would
    be the same as `grid-template-columns:` `1fr`, which would be 100% of the column.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个完整的蛋糕，它等于100%。从CSS的角度来看，如果我们决定吃掉所有的蛋糕，那将是1个分数。在我们的CSS中，这将是`grid-template-columns:`
    `1fr`，这将等于列的100%。
- en: But we’re friendly, so we decide to give some of our cake to four friends. We
    need to determine how many slices of our cake each person is going to have.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们是友好的，所以我们决定把一些蛋糕分给四个朋友。我们需要确定每个人将有多少份蛋糕。
- en: If we’re fair, we can say that our cake can be divided into four equal slices.
    In our CSS, this would be the same as `grid-template-columns:` `1fr` `1fr` `1fr`
    `1fr`. We’re telling the browser to give each HTML element an equal slice of the
    whole thing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们公平的话，可以说我们的蛋糕可以分成四等份。在我们的CSS中，这将是`grid-template-columns:` `1fr` `1fr` `1fr`
    `1fr`。我们告诉浏览器给每个HTML元素一个相等的整体份额。
- en: 'But what if we decided to be sneaky and keep a larger slice for ourselves?
    After all, we baked the cake. We decide to take half of the cake for ourselves
    and divide the remaining half into three slices. To do this, we need six fractions:
    three fractions for our 50% of the cake and then one fraction three times to divide
    the other 50% of the cake.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们决定偷偷地多留一些给自己呢？毕竟，是我们烤的蛋糕。我们决定拿走一半的蛋糕，然后把剩下的另一半分成三份。为了做到这一点，我们需要六个分数：三个分数代表我们50%的蛋糕，然后对剩下的50%再分三次。
- en: Our CSS would be `grid-template-columns:` `3fr` `1fr` `1fr` `1fr`. So we’re
    saying that there are six fractions total; the first column gets three of them
    (or 50% of the total), and then the remaining 50% should be divided equally among
    the other three columns. We can use the `fr` unit with the `repeat()` function
    to make this value easier to read, which would be `grid-template-columns:` `3fr`
    `repeat(3,` `1fr)`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CSS将是`grid-template-columns:` `3fr` `1fr` `1fr` `1fr`。所以我们在说总共有六个分数；第一列得到三个（或者说总量的50%），然后剩下的50%应该平均分配给其他三个列。我们可以使用`fr`单位和`repeat()`函数来使这个值更容易阅读，这将`grid-template-columns:`
    `3fr` `repeat(3,` `1fr`)。
- en: For our project we’ll create our grid lines for the columns by adding the code
    in the following listing to our `main` rule.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将通过在以下列表中添加代码到`main`规则中来创建列的网格线。
- en: Listing 2.4 Setting the amount of columns
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 设置列的数量
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When previewed in the browser (figure 2.7), we see that now our grid has numbers
    set across each line. What we can do with this information is explicitly choose
    where to place our HTML elements within the grid based on the grid line number.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中预览时（图2.7），我们看到现在我们的网格在每个线上都设置了数字。我们可以利用这些信息，明确选择在网格中放置我们的HTML元素的位置，基于网格线的编号。
- en: '![](../Images/02-07.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-07.png)'
- en: Figure 2.7 Firefox browser preview showing the grid lines and associated numbers
    for each line
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 Firefox浏览器预览显示的网格线和每行的相关数字
- en: We also notice that the browser assumed that we want to place our HTML elements
    within each grid cell. Rather than stacking the elements vertically, the browser
    filled each column cell until it ran out, created a new row, and filled in those
    columns. The automatic creation of extra grid cells is also known as *an implicit
    grid*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，浏览器假设我们想要在每个网格单元内放置我们的HTML元素。而不是垂直堆叠元素，浏览器会填充每个列单元，直到填满，然后创建一个新的行，并填充那些列。自动创建额外的网格单元也被称为*隐式网格*。
- en: Explicit versus implicit grid
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显式网格与隐式网格
- en: When we use `grid-template-columns` or `grid-template-rows`, we’re creating
    an explicit grid. We’re clearly stating to the browser the exact amount of columns
    and rows this grid should have.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`grid-template-columns`或`grid-template-rows`时，我们正在创建一个显式网格。我们明确地告诉浏览器这个网格应该有多少列和行。
- en: The implicit parts (for both rows and columns) are those that the browser creates
    automatically, which can happen when there are more child items than grid cells.
    In this case, the browser implicitly adds cells to our grid to make sure that
    all elements have a grid cell.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式部分（对于行和列）是浏览器自动创建的部分，这发生在子项多于网格单元的情况下。在这种情况下，浏览器隐式地向我们的网格添加单元格，以确保所有元素都有一个网格单元。
- en: We can control implicit behavior through `grid-auto-flow`, `grid-auto-columns`,
    and `grid-auto-rows`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`grid-auto-flow`、`grid-auto-columns`和`grid-auto-rows`来控制隐式行为。
- en: At this juncture, we’ve created a grid containing three columns. Two of those
    columns use `minmax()`, and our third column has a fixed value of `250px`. These
    settings give us a three-column layout. We want to distribute the main content
    in the first two columns and use the third one for less important content, which
    is why we give it less visual real estate. (On most screens, the third column
    will be narrower than the first two columns.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经创建了一个包含三列的网格。其中两列使用 `minmax()`，我们的第三列有一个固定的值 `250px`。这些设置给我们一个三列布局。我们希望将主要内容分布在第一列和第二列中，并使用第三列来显示不太重要的内容，这就是为什么我们给它较少的视觉空间。（在大多数屏幕上，第三列将比前两列窄。）
- en: 2.4 Grid template areas
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 网格模板区域
- en: 'If we want to set an element explicitly on a particular row and column of our
    grid, we have two options. First, we can use the line numbers and dictate the
    position of the child as follows: `grid-column:` `1` `/` `4`. In this syntax,
    the first number represents where the element starts, and the second represents
    where it ends (figure 2.8). This example places the element in the first column,
    spanning the second and third. If only one number is provided, the element spans
    only one row or column.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在网格的特定行和列上显式设置一个元素，我们有两种选择。首先，我们可以使用行号并指定子元素的如下位置：`grid-column:` `1` `/`
    `4`。在这个语法中，第一个数字表示元素开始的位置，第二个数字表示元素结束的位置（图 2.8）。这个例子将元素放置在第一列，跨越第二列和第三列。如果只提供一个数字，则元素只跨越一行或一列。
- en: '![](../Images/02-08.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2-08](../Images/02-08.png)'
- en: Figure 2.8 Example `grid-column` and `grid-row` syntax
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 示例 `grid-column` 和 `grid-row` 语法
- en: To define the row, we would use the same syntax as for columns with the `grid-row`
    property. To place an element so that it starts on the third row and spans two
    rows, we would write `grid-row:` `3` `/` `5`. The `grid-column` and `grid-row`
    properties are shorthand for `grid-column-start`, `grid-column-end`, `grid-row-start`,
    and `grid-row-end`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义行，我们会使用与列相同的语法，通过 `grid-row` 属性。为了放置一个元素，使其从第三行开始并跨越两行，我们会写 `grid-row:` `3`
    `/` `5`。`grid-column` 和 `grid-row` 属性是 `grid-column-start`、`grid-column-end`、`grid-row-start`
    和 `grid-row-end` 的缩写。
- en: Rather than deal with numbers, we can use named areas to be referenced when
    we explicitly place elements on the grid. To do this, we use the `grid-template-areas`
    property, which allows us to define how we want the web page to be laid out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用处理数字，而使用命名区域来引用，当我们明确地将元素放置在网格上时。为此，我们使用 `grid-template-areas` 属性，它允许我们定义我们希望网页如何布局。
- en: The `grid-template-areas` property takes multiple strings, each composed of
    the names of the areas they describe. Each string represents a row in the layout,
    as shown in figure 2.8\. Each name represents a column within the row. If two
    adjacent cells have the same name (horizontally or vertically), the two cells
    are treated as one area. A grid area can be a single cell, such as the area defined
    as `plays` in figure 2.9, but if it’s more than one cell, the cells must create
    a rectangular shape with all cells of the same name being adjacent. You wouldn’t
    be able to make an L shape, for example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid-template-areas` 属性接受多个字符串，每个字符串由它们描述的区域的名称组成。每个字符串代表布局中的一行，如图 2.8 所示。每个名称代表行内的一个列。如果两个相邻的单元格具有相同的名称（水平或垂直），则这两个单元格被视为一个区域。网格区域可以是一个单独的单元格，例如图
    2.9 中定义的 `plays` 区域，但如果它包含多个单元格，则这些单元格必须创建一个矩形形状，并且所有具有相同名称的单元格必须是相邻的。例如，您无法创建一个
    L 形状。'
- en: '![](../Images/02-09.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2-09](../Images/02-09.png)'
- en: Figure 2.9 Syntax of the `grid-template-areas` property
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 `grid-template-areas` 属性的语法
- en: The benefit of named areas is in the visualization of the final outcome. We’ll
    define our `grid-template-areas` as shown in listing 2.5\. Notice the dot (`.`)
    in the fourth row in figure 2.9\. The dot is used to define a cell that we intend
    to keep empty. Because that cell doesn’t have a name, content can’t be assigned
    to it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 命名区域的优点在于最终结果的可视化。我们将定义我们的 `grid-template-areas`，如列表 2.5 所示。注意图 2.9 中第四行的点（`.`）。点用于定义我们打算保持为空的单元格。因为那个单元格没有名称，所以内容不能分配给它。
- en: Listing 2.5 Creating our template areas
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 创建我们的模板区域
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although we’ve defined areas, the content still implicitly positions itself
    in each available cell, ignoring the areas we defined (figure 2.10). We need to
    assign our content to each of these areas.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经定义了区域，但内容仍然隐式地定位在每个可用的单元格中，忽略了我们定义的区域（图 2.10）。我们需要将这些内容分配给这些区域的每一个。
- en: '![](../Images/02-10.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2-10](../Images/02-10.png)'
- en: Figure 2.10 Defined grid areas shown in Firefox
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 Firefox 中显示的已定义网格区域
- en: 2.4.1 The grid-area property
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 `grid-area` 属性
- en: To place an element in a defined area, we use the `grid-area` property. Its
    value is the name we assigned in the `grid-template-areas` property. If we want
    the `<header>` element to be placed inside the area we defined as `header`, for
    example, we would define `header` `{` `grid-area:` `header;` `}`. For our project,
    we set our elements on our grid as shown in the following listing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '为了将元素放置在定义的区域中，我们使用 `grid-area` 属性。它的值是在 `grid-template-areas` 属性中分配的名称。如果我们想将
    `<header>` 元素放置在我们定义为 `header` 的区域内部，例如，我们将定义 `header { grid-area: header; }`。对于我们的项目，我们按照以下列表所示在我们的网格上设置元素。'
- en: Listing 2.6 Assigning content to the grid area
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 将内容分配给网格区域
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we’ve explicitly defined where the content should go, the content falls
    into place (figure 2.11).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明确定义了内容应该放置的位置，内容就会落到位（图 2.11）。
- en: '![](../Images/02-11.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-11.png)'
- en: Figure 2.11 Content explicitly placed on the grid
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 明确放置在网格上的内容
- en: With the layout setup, let’s remove some of the styles we added for the purpose
    of understanding what our layout was doing. As shown in the following listing,
    we remove the padding and borders of our content sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局设置中，让我们移除一些为了理解我们的布局做了什么而添加的样式。如下所示列表中，我们移除了内容部分的填充和边框。
- en: Listing 2.7 Removing debugging styles
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 移除调试样式
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With those styles removed and the screen width narrowed (figure 2.12), the content
    in adjacent columns or rows appears to be closer together.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 移除这些样式并缩小屏幕宽度（图 2.12）后，相邻列或行中的内容看起来更靠近。
- en: '![](../Images/02-12.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-12.png)'
- en: Figure 2.12 Narrow screen width
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 窄屏幕宽度
- en: Let’s add space between the areas. To accomplish this task, we will use the
    `gap` property.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在区域之间添加空间。为了完成这个任务，我们将使用 `gap` 属性。
- en: 2.4.2 The gap property
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 gap 属性
- en: The `gap` property is shorthand for the `row-gap` and `column-gap` properties.
    By setting the row and column gaps, we’re defining the gutters between rows and
    columns. *Gutters* is a term from print design, defining the gap between columns.
    By default, the gap between columns and rows is the keyword `normal`. This value
    equates to `0px` in all contexts except when it’s used with the CSS Multi-Column
    Module, which equates it to `1em`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`gap` 属性是 `row-gap` 和 `column-gap` 属性的简写。通过设置行和列的间隙，我们定义了行和列之间的空白。*空白*是来自印刷设计的术语，定义了列之间的间隙。默认情况下，列和行之间的间隙是关键字
    `normal`。这个值在所有上下文中都等于 `0px`，除非它与 CSS 多列模块一起使用，这时它等于 `1em`。'
- en: When we use the `gap` property, the extra space applies only between the tracks
    of the grid. No gutters are applied before the first track or after the last track.
    To set space around the grid, we use padding and margin properties.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `gap` 属性时，额外的空间仅应用于网格的轨道之间。在第一个轨道之前或最后一个轨道之后不应用空白。为了设置网格周围的空间，我们使用填充和边距属性。
- en: gap vs. grid-gap
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: gap 与 grid-gap 的比较
- en: As CSS Grid was being defined, the specification for this property was called
    the `grid-gap` property, but now `gap` is recommended. We may see `grid-gap` in
    older projects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CSS Grid 正在被定义时，这个属性的规范被称为 `grid-gap` 属性，但现在推荐使用 `gap`。我们可能在旧项目中看到 `grid-gap`。
- en: The `gap` property can have up to two positive values. The first value sets
    the `row-gap`, and the second is for the `column-gap`. If only one value is declared,
    it’s applied to both the `row-gap` and `column-gap` properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`gap` 属性可以有最多两个正值。第一个值设置 `row-gap`，第二个值用于 `column-gap`。如果只声明了一个值，它将应用于 `row-gap`
    和 `column-gap` 属性。'
- en: For our project, we’ll set a `20px` gap between our rows and columns by adding
    `gap:` `20px` to our `main` rule. Figure 2.13 shows the gaps added to our layout.
    With the gaps added, let’s switch our focus to adjusting our layout based on screen
    size.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '对于我们的项目，我们将通过在 `main` 规则中添加 `gap: 20px` 来设置行和列之间的 `20px` 间隙。图 2.13 显示了添加到布局中的间隙。添加了间隙后，让我们将注意力转向根据屏幕大小调整布局。'
- en: '![](../Images/02-13.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-13.png)'
- en: Figure 2.13 Grid layout with added gap
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 添加了间隙的网格布局
- en: 2.5 Media queries
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 媒体查询
- en: 'CSS allows us to apply styles to our layout conditionally. One type of condition
    is screen size. Media queries are *at-rules*: they start with the at (`@`) symbol
    and define the condition under which the styles they contain should be applied.
    If we look at our current layout on a wide screen (figure 2.14), we notice a large
    amount of space in the center of the page that could be put to better use.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CSS允许我们根据条件应用样式。一种条件是屏幕大小。媒体查询是*规则*：它们以`@`符号开头，并定义了包含它们的样式应在何种条件下应用。如果我们查看宽屏上的当前布局（图2.14），我们会注意到页面中心有大量空间可以更好地利用。
- en: '![](../Images/02-14.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-14.png)'
- en: Figure 2.14 Our layout on a wide screen
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 宽屏上的布局
- en: Let’s create a media query that targets screens wider than `955px`. The query
    is `@media` `(min-width:` `955px)` `{` `}`. All the rules we place inside the
    curly braces (`{}`) will be applied only if the screen size is greater than or
    equal to `955px`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个针对宽度大于`955px`的屏幕的媒体查询。查询是`@media` `(min-width:` `955px)` `{` `}`。我们放在大括号`{}`内的所有规则仅在屏幕大小大于或等于`955px`时应用。
- en: Listing 2.8 shows our media query. We redefine our `grid-template-areas` to
    have a different configuration if the media-query condition is met. We also update
    the column sizes so that the columns have equal widths.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8显示了我们的媒体查询。如果满足媒体查询条件，我们重新定义`grid-template-areas`以具有不同的配置。我们还更新了列的大小，以便列具有相等的宽度。
- en: Listing 2.8 Creating our template areas with media queries
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 使用媒体查询创建我们的模板区域
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① The at-rule along with media feature
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ① 与媒体特性一起的at规则
- en: ② Redefines the column sizes
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ② 重新定义列的大小
- en: ③ Reconfigures where the content should be placed
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 重新配置内容应放置的位置
- en: Now our layout looks like figure 2.15 and figure 2.16.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局看起来像图2.15和图2.16。
- en: '![](../Images/02-15.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-15.png)'
- en: Figure 2.15 Narrow screen uses the original layout.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 窄屏使用原始布局。
- en: Using `grid-template-areas` in conjunction with media queries allows us to reconfigure
    our layout with minimal code. But we must avoid some accessibility pitfalls.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将`grid-template-areas`与媒体查询结合使用，我们可以用最少的代码重新配置我们的布局。但我们必须避免一些可访问性的陷阱。
- en: '![](../Images/02-16.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02-16.png)'
- en: Figure 2.16 Wide screen uses the layout from the media query.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 宽屏使用媒体查询的布局。
- en: 2.6 Accessibility considerations
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 可访问性考虑
- en: 'When we placed our items in the grid area, we mostly kept the elements in the
    order in which they appeared in the HTML: the header stayed at the top, footer
    remained at the bottom, and the content was in a logical visual order. But what
    if the HTML order and the visual display order were different?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将项目放置在网格区域内时，我们主要保持了它们在HTML中出现的顺序：页眉保持在顶部，页脚保持在底部，内容以逻辑的视觉顺序排列。但如果HTML顺序和视觉显示顺序不同怎么办？
- en: 'If a user is following along with a screen reader or navigating the page via
    the keyboard, and the programmatic order doesn’t match what’s being displayed,
    the behavior will seem to be random. This randomness will make it difficult for
    the user to navigate the page and to comprehend what’s going on with it. Visually
    changing the location of a piece of content by using a grid won’t affect the order
    in which assistive technology presents the information to the user. The W3 Grid
    Layout Module Recommendations states the following about this case ([http://mng.bz/xdD7](http://mng.bz/xdD7)):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户正在使用屏幕阅读器跟随或通过键盘导航页面，并且程序性顺序与显示的内容不匹配，那么行为看起来将是随机的。这种随机性将使用户难以导航页面并理解其内容。通过使用网格改变内容的位置的视觉变化不会影响辅助技术向用户呈现信息的顺序。W3网格布局模块建议如下关于这种情况（[http://mng.bz/xdD7](http://mng.bz/xdD7)）：
- en: Authors must use order and the *grid-placement* properties only for visual,
    not logical, reordering of content. Style sheets that use these features to perform
    logical reordering are non-conforming.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作者必须仅使用顺序和*网格放置*属性进行视觉上的内容重新排序，而不是逻辑上的重新排序。使用这些功能进行逻辑重新排序的样式表是不符合规范的。
- en: The solution is to keep the source code and the visual experience the same,
    or at least in a sensible order. This approach gives you both the most accessible
    web document and a good structure to work from. For English, this means that content
    and HTML should follow the same order, from top left to bottom right.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是保持源代码和视觉体验相同，或者至少在合理的顺序上。这种方法既提供了最可访问的Web文档，又提供了一个良好的工作结构。对于英语来说，这意味着内容和HTML应该遵循相同的顺序，从左上角到右下角。
- en: After assigning our elements to their respective areas of the grid, we should
    always test our page to ensure that regardless of how the user accesses the page,
    the order will be logical. One way to do this is to visit our page with a screen
    reader and tab through the elements to make sure that the tab order still works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的元素分配到网格的相应区域后，我们应该始终测试我们的页面，以确保无论用户如何访问页面，顺序都是合理的。一种方法是使用屏幕阅读器访问我们的页面，并通过标签顺序来确保标签顺序仍然有效。
- en: Some tools and extensions can help with visualizing tab order. In Firefox DevTools,
    for example, we can select the Accessibility tab and check the Show Tabbing Order
    check box, which outlines and numbers focusable elements as shown in figure 2.17\.
    We can see that our tab order is logical and unlikely to confuse the user, so
    we’re good to go.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具和扩展可以帮助可视化标签顺序。例如，在 Firefox DevTools 中，我们可以选择“无障碍性”选项卡并勾选“显示标签顺序”复选框，如图
    2.17 所示，它会突出显示并编号可聚焦元素。我们可以看到我们的标签顺序是合理的，不太可能让用户感到困惑，所以我们可以继续前进。
- en: '![](../Images/02-17.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-17.png)'
- en: Figure 2.17 Tabbing order of HTML exposed in Firefox DevTools
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 Firefox DevTools 中暴露的 HTML 标签顺序
- en: Now our project is complete (figure 2.18).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目已经完成（图 2.18）。
- en: Future of Grid
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的未来
- en: In this chapter, we used the CSS Grid Layout Module to create a layout that’s
    responsive depending on the browser width. Many aspects of the grid are still
    being developed and iterated, most notably subgrids, which would allow for grids
    within grids.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了 CSS 网格布局模块来创建一个根据浏览器宽度做出响应的布局。网格的许多方面仍在开发和迭代中，最值得注意的是子网格，这将允许网格中有网格。
- en: Although you can set a grid within a grid now, subgrids have the benefit of
    being more closely related to their parent grid. To keep an eye on future enhancements
    and development, check out the grid specification at [https://www.w3.org/TR/css-grid](https://www.w3.org/TR/css-grid).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你现在可以在网格内设置网格，但子网格的好处是它们与其父网格更紧密相关。为了关注未来的增强和发展，请查看网格规范[https://www.w3.org/TR/css-grid](https://www.w3.org/TR/css-grid)。
- en: '![](../Images/02-18.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02-18.png)'
- en: Figure 2.18 Final product on wide screen
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 宽屏上的最终产品
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A grid is a network of lines that cross to form a series of squares or rectangles.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格是由交叉形成一系列正方形或矩形的线条网络。
- en: The `display` property with a value of `grid` allows us to place items on a
    grid layout.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为 `grid` 的 `display` 属性允许我们在网格布局上放置项目。
- en: The `display` property is applied to the parent item that contains the child
    elements that are to be placed on the grid.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display` 属性应用于包含要放置在网格上的子元素的父项。'
- en: The `grid-template-columns` and `grid-template-rows` properties are used to
    explicitly define the quantity and size of the columns and rows the grid should
    contain.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid-template-columns` 和 `grid-template-rows` 属性用于显式定义网格应包含的列和行的数量和大小。'
- en: The flexible length (`fr`) unit is a unit of measurement that was formed as
    part of CSS Grid as an alternative way to set the dimension of items.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩长度 (`fr`) 单位是 CSS 网格作为设置项目维度的一种替代方式而形成的测量单位。
- en: We can use the `repeat()` function to improve code efficiency where one or more
    rows or columns are the same size.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `repeat()` 函数提高代码效率，其中一行或多列具有相同的大小。
- en: 'The `minmax()` function allows us to set two arguments: the minimum width a
    column should be and the maximum width a column should be.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minmax()` 函数允许我们设置两个参数：列应具有的最小宽度和最大宽度。'
- en: The `grid-template-areas` property allows us to define what each grid area is
    called. Then we can use the `grid-area` property on the child items to assign
    them to those named locations.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid-template-areas` 属性允许我们定义每个网格区域被称为什么。然后我们可以使用子项上的 `grid-area` 属性将它们分配到那些命名位置。'
- en: The `gap` property adds spacing (creates gutters) between grid cells.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gap` 属性在网格单元之间添加间距（创建边距）。'
- en: The source code and the visual experience need to stay in the same logical order.
    When in doubt, we can use browser developer tools to check the tabbing order.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码和视觉体验需要保持相同的逻辑顺序。如有疑问，我们可以使用浏览器开发者工具来检查标签顺序。
