- en: Appendix B. Arming with testing and debugging
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B. 带上测试和调试的武装
- en: '*This appendix covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本附录涵盖*'
- en: Tools for debugging JavaScript code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试JavaScript代码的工具
- en: Techniques for generating tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成测试的技术
- en: Building a test suite
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试套件
- en: Surveying some of the popular testing frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述一些流行的测试框架
- en: 'This appendix presents some fundamental techniques in developing client-side
    web applications: debugging and testing. Constructing effective test suites for
    our code is always important. After all, if we don’t test our code, how do we
    know that it does what we intend? Testing gives us a means to ensure that our
    code not only runs, but runs *correctly*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录介绍了开发客户端网络应用的一些基本技术：调试和测试。构建有效的测试套件对于我们的代码始终很重要。毕竟，如果我们不测试我们的代码，我们怎么知道它是否按我们的意图运行呢？测试为我们提供了一种确保我们的代码不仅能够运行，而且能够正确运行的手段。
- en: Moreover, as important as a solid testing strategy is for *all* code, it can
    be crucial when external factors have the potential to affect the operation of
    our code, which is *exactly* the case we’re faced with in cross-browser JavaScript
    development. Not only do we have the typical problems of ensuring the quality
    of the code (especially when dealing with multiple developers working on a single
    code base) and guarding against regressions that could break portions of an API
    (generic problems that all programmers need to deal with), but we also have the
    problem of determining whether our code works in all the browsers that we choose
    to support.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管一个坚实的测试策略对于所有代码来说都很重要，但在外部因素有可能影响我们代码操作的情况下，它可能是至关重要的，这正是我们在跨浏览器JavaScript开发中所面临的情况。我们不仅面临着确保代码质量（尤其是在处理多个开发者共同维护的单一代码库时）的典型问题，还要防范可能导致API部分失效的回归（所有程序员都需要处理的通用问题），而且我们还有确定我们的代码在我们选择支持的浏览器中是否都能正常工作的问题。
- en: In this chapter, we’ll look at tools and techniques for debugging JavaScript
    code, generating tests based on those results, and constructing a test suite to
    reliably run those tests. Let’s get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨调试JavaScript代码的工具和技术，基于这些结果生成测试，并构建一个可靠的测试套件来运行这些测试。让我们开始吧。
- en: Web developer tools
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络开发者工具
- en: For a long time, the development of JavaScript applications was hindered by
    the lack of a basic debugging infrastructure. The only way to debug JavaScript
    code was to scatter `alert` statements that would notify us about the value of
    the alerted expression, all around the code that was acting strangely. As you
    might imagine, this made debugging (hardly ever a fun activity) even more difficult.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间，JavaScript应用程序的开发受到了缺乏基本调试基础设施的限制。调试JavaScript代码的唯一方法是在代码中散布`alert`语句，这些语句会通知我们有关被警告表达式的值，这些语句散布在表现异常的代码周围。正如你可能想象的那样，这使得调试（几乎从来不是一项有趣的活动）变得更加困难。
- en: 'Luckily, Firebug, an extension to Firefox, was developed in 2007\. Firebug
    holds a special place in the hearts of many web developers, because it was the
    first tool that provided a debugging experience that closely matched debugging
    in state-of-the-art integrated development environments (IDEs), such as Visual
    Studio or Eclipse. In addition, Firebug has inspired the development of similar
    developer tools for all major browsers: F12 Developer Tools, included in Internet
    Explorer and Microsoft Edge; WebKit Inspector, included in Safari; Firefox Developer
    Tools, included in Firefox; and Chrome DevTools included in Chrome and Opera.
    Let’s explore them a bit.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Firefox的一个扩展——Firebug，在2007年被开发出来。Firebug在许多网络开发者心中占有特殊的位置，因为它是最早提供与最先进的集成开发环境（IDE）中的调试体验相匹配的工具之一，如Visual
    Studio或Eclipse。此外，Firebug还激发了为所有主要浏览器开发类似开发者工具的进程：包含在Internet Explorer和Microsoft
    Edge中的F12开发者工具；包含在Safari中的WebKit Inspector；包含在Firefox中的Firefox开发者工具；以及包含在Chrome和Opera中的Chrome
    DevTools。让我们稍微探索一下它们。
- en: Firebug
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Firebug
- en: Firebug, the first advanced web application debugging tool, is available exclusively
    for Firefox, and is accessed by pressing the F12 key (or by right-clicking anywhere
    on the page and selecting Inspect Element with Firebug). You can install Firebug
    by opening the page in Firefox ([https://getfirebug.com/](https://getfirebug.com/))
    and following the instructions. [Figure B.1](#app02fig01) shows Firebug.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Firebug，第一个高级网络应用调试工具，仅适用于Firefox，可以通过按F12键（或在页面上任何位置右键单击并选择带有Firebug的“检查元素”）访问。您可以通过在Firefox中打开页面（[https://getfirebug.com/](https://getfirebug.com/)）并按照说明来安装Firebug。[图B.1](#app02fig01)展示了Firebug。
- en: Figure B.1\. Firebug, available only in Firefox, was the first advanced debugging
    tool for web applications.
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.1\. 仅在 Firefox 中可用的 Firebug 是第一个针对网络应用的高级调试工具。
- en: '![](b0fig01_alt.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig01_alt.jpg)'
- en: Firebug offers advanced debugging functionalities, some of which it has even
    pioneered. For example, we can easily explore the current state of the DOM by
    using the HTML pane (the pane shown in [figure B.1](#app02fig01)), run custom
    JavaScript code within the context of the current page by using the console (the
    bottom of [figure B.1](#app02fig01)), explore the state of our JavaScript code
    by using the Script pane, and even explore network communications from the Net
    pane.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Firebug 提供了高级调试功能，其中一些功能甚至是由它首创的。例如，我们可以通过使用 HTML 选项卡（如图 B.1 所示的选项卡）轻松地探索 DOM
    的当前状态，通过控制台（如图 B.1 底部所示）在当前页面的上下文中运行自定义 JavaScript 代码，通过脚本选项卡探索我们的 JavaScript
    代码的状态，甚至可以通过网络选项卡探索网络通信。
- en: Firefox Developer Tools
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Firefox 开发者工具
- en: In addition to Firebug, if you’re a Firefox user, you can use the built-in Firefox
    DevTools, shown in [figure B.2](#app02fig02). As you can see, the general look
    and feel of Firefox developer tools is similar to Firebug (apart from some minor
    layout and label differences; for example, the HTML pane from Firebug is called
    Inspector in Firefox developer tools).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Firebug 之外，如果你是 Firefox 用户，你可以使用内置的 Firefox DevTools，如图 B.2 所示。正如你所看到的，Firefox
    开发者工具的外观和感觉与 Firebug 类似（除了某些细微的布局和标签差异；例如，Firebug 中的 HTML 选项卡在 Firefox 开发者工具中被称为检查器）。
- en: Figure B.2\. Firefox developer tools, built into Firefox, offer all the Firebug
    features and then some.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.2\. 内置于 Firefox 的 Firefox 开发者工具提供了所有 Firebug 功能以及更多。
- en: '![](b0fig02_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig02_alt.jpg)'
- en: Firefox developer tools are built by the Mozilla team, which has taken advantage
    of this close integration with Firefox by bringing in some additional useful features.
    The Performance pane, for instance, provides detailed insight about the performance
    of our web applications. In addition, Firefox developer tools are built with the
    modern web in mind. For example, they offer Responsive Design mode, which helps
    us explore the look and feel of our web applications across different screen sizes—which
    is something we have to be careful about, because nowadays users access web applications
    not only from their PCs, but also from mobile devices, tablets, and even TVs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 开发者工具是由 Mozilla 团队构建的，他们通过引入一些额外的有用功能，利用了与 Firefox 的紧密集成。例如，性能选项卡提供了关于我们网络应用性能的详细洞察。此外，Firefox
    开发者工具是以现代网络为设计理念的。例如，它们提供了响应式设计模式，这有助于我们探索不同屏幕尺寸下网络应用的外观和感觉——这是我们必须小心注意的，因为如今用户不仅从他们的电脑，还从移动设备、平板电脑甚至电视访问网络应用。
- en: F12 Developer Tools
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: F12 开发者工具
- en: If you’re in the Internet Explorer (IE) camp, you’ll be happy to know that IE
    and Microsoft Edge (the successor to IE) offer their own developer tools, the
    F12 developer tools. (Quickly, try to guess which key toggles them on and off.)
    These tools are shown in [figure B.3](#app02fig03).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你属于 Internet Explorer (IE) 阵营，你可能会很高兴地知道 IE 和 Microsoft Edge（IE 的继任者）提供了他们自己的开发者工具，即
    F12 开发者工具。（快速猜测一下哪个键可以切换它们的开和关。）这些工具如图 B.3 所示。
- en: Figure B.3\. F12 developer tools (toggled by pressing F12) are available in
    Internet Explorer and Edge.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.3\. 通过按 F12 键切换的 F12 开发者工具（在 Internet Explorer 和 Edge 中可用）。
- en: '![](b0fig03_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig03_alt.jpg)'
- en: Again, notice the similarities between the F12 developer tools and Firefox’s
    developer tools (with only slight differences in labels). The F12 tools also enable
    us to explore the current state of the DOM (the DOM Explorer pane, [figure B.3](#app02fig03)),
    run custom JavaScript code through the console, debug our JavaScript code (the
    Debugger pane), analyze the network traffic (Network), deal with responsive design
    (UI Responsiveness), and analyze performance and memory consumption (Profiler
    and Memory).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意 F12 开发者工具和 Firefox 开发者工具之间的相似性（标签只有细微的差异）。F12 工具还使我们能够探索 DOM 的当前状态（DOM
    探索器选项卡，图 B.3），通过控制台运行自定义 JavaScript 代码，调试我们的 JavaScript 代码（调试器选项卡），分析网络流量（网络），处理响应式设计（UI
    响应性），以及分析性能和内存消耗（性能分析器和内存）。
- en: WebKit inspector
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WebKit 检查器
- en: If you’re an OS X user, you can use WebKit Inspector, which is offered by Safari,
    as shown in [figure B.4](#app02fig04). Although the UI of Safari’s WebKit Inspector
    is slightly different
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 OS X 用户，你可以使用 Safari 提供的 WebKit 检查器，如图 B.4 所示。尽管 Safari 的 WebKit 检查器的用户界面略有不同
- en: Figure B.4\. WebKit Inspector, available in Safari
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.4\. 仅在 Safari 中可用的 WebKit 检查器
- en: '![](b0fig04_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig04_alt.jpg)'
- en: from that of F12 developer tools or Firefox’s developer tools, rest assured
    that the WebKit Inspector also supports all important debugging features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与 F12 开发者工具或 Firefox 的开发者工具相比，请放心，WebKit 检查器也支持所有重要的调试功能。
- en: Chrome DevTools
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Chrome DevTools
- en: We’ll complete our little survey of developer tools with Chrome DevTools—in
    our opinion, the current flagship of web application developer tools that’s been
    driving a lot of innovations lately. As you can see in [figure B.5](#app02fig05),
    the basic UI and features are similar to the rest of the developer tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 Chrome DevTools 完成我们对开发者工具的小调查——在我们看来，这是目前推动了许多创新的网络应用开发者工具的旗舰产品。如图 B.5（#app02fig05）所示，其基本用户界面和功能与其他开发者工具类似。
- en: Figure B.5\. Chrome DevTools, available in Chrome and Opera
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.5\. 可在 Chrome 和 Opera 中使用的 Chrome DevTools
- en: '![](b0fig05_alt.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig05_alt.jpg)'
- en: Throughout this book, we’ve used Chrome DevTools, for the sake of convention.
    But as you’ve seen throughout this section, most developer tools offer similar
    features (and if one of them offers something new, the others catch up quickly).
    You can just as easily use the developer tools offered by your browser of choice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们为了保持一致性，使用了 Chrome DevTools。但如您在本节中看到的，大多数开发者工具都提供了类似的功能（如果其中之一提供了新的功能，其他工具也会很快跟进）。您同样可以轻松地使用您选择的浏览器的开发者工具。
- en: Now that you’ve had an introduction to the tools you can use for debugging code,
    let’s explore some debugging techniques.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了可用于调试代码的工具，让我们来探索一些调试技术。
- en: Debugging code
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试代码
- en: A significant portion of time developing software is spent on removing annoying
    bugs. Although this can sometimes be interesting, almost like solving a whodunit
    mystery, typically we’ll want our code working correctly and bug-free as soon
    as possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发过程中，很大一部分时间都花在移除烦人的错误上。虽然这有时可能很有趣，几乎像解决一个悬疑故事一样，但通常我们希望代码尽快正确无误且无错误。
- en: 'Debugging JavaScript has two important aspects:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 JavaScript 有两个重要的方面：
- en: '*Logging*, which prints out what’s going on as our code is running'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记录*，它打印出代码运行时的状态'
- en: '*Breakpoints*, which allow us to temporarily pause the execution of our code
    and explore the current state of the application'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*断点*，它允许我们暂时暂停代码的执行并探索应用程序的当前状态'
- en: They’re both useful for answering the important question, “What’s going on in
    my code?” but each tackles it from a different angle. Let’s start by looking at
    logging.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都用于回答重要的问题，“我的代码中发生了什么？”但每个都从不同的角度着手。让我们先从记录开始看。
- en: Logging
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 记录
- en: '*Logging* statements are used for outputting messages during program execution,
    without impeding the normal flow of the program. When we add logging statements
    to our code (for example, by using the `console.log` method), we benefit from
    seeing messages in the browser’s console. For example, if we want to know the
    value of a variable named `x` at certain points of program execution, we might
    write something like the following listing.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*语句用于在程序执行期间输出消息，而不会干扰程序的正常流程。当我们向代码中添加记录语句时（例如，使用 `console.log` 方法），我们可以在浏览器的控制台中看到消息。例如，如果我们想了解在程序执行的某些点上变量
    `x` 的值，我们可能会编写如下列表。'
- en: Listing B.1\. Logging the value of variable x at various points of program execution
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.1\. 在程序执行的各个点上记录变量 x 的值
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure B.6](#app02fig06) shows the result of executing this code in the Chrome
    browser with the JavaScript console enabled.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 B.6](#app02fig06) 展示了在启用 JavaScript 控制台的情况下，在 Chrome 浏览器中执行此代码的结果。'
- en: Figure B.6\. Logging lets us see the state of our code as it’s running. In this
    case, we can see that the value of 213 is logged from line 6, and the value of
    “Hello World” from line 9 of listing B.1\. All developer tools, including Chrome
    DevTools shown here, have a Console tab for logging purposes.
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.6\. 记录使我们能够看到代码运行时的状态。在这种情况下，我们可以看到从列表 B.1 的第 6 行记录了 213 的值，以及从第 9 行记录了“Hello
    World”。所有开发者工具，包括此处展示的 Chrome DevTools，都有一个用于记录的“控制台”标签页。
- en: '![](b0fig06_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig06_alt.jpg)'
- en: As you can see, the browser logs the messages directly to the JavaScript console,
    showing both the logged message and the line in which the message was logged.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，浏览器将消息直接记录到 JavaScript 控制台，显示了记录的消息及其所在的行。
- en: This is a simple example of logging a value of a variable at different points
    of program execution. But in general, you can use logging to explore various facets
    of your running applications, such as the execution of important functions, the
    change of an important object property, or the occurrence of a particular event.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在程序执行的不同点记录变量值的简单示例。但通常，你可以使用日志记录来探索运行中的应用程序的各个方面，例如重要函数的执行、重要对象属性的更改或特定事件的发生。
- en: Logging is all well and good for seeing the state of things while the code is
    running, but sometimes we’ll want to stop the action and take a look around. That’s
    where breakpoints come in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时，日志记录对于查看事物的状态是很好，但有时我们可能想要停止动作并四处看看。这就是断点的作用。
- en: Breakpoints
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断点
- en: 'Using *breakpoints* can be more complex than logging, but they possess a notable
    advantage: They halt the execution of a script at a specific line of code, pausing
    the browser. This allows us to leisurely investigate the state of all sorts of
    things at the point of the break.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *断点* 可能比日志记录更复杂，但它们有一个显著的优势：它们会在特定的代码行处暂停脚本的执行，使浏览器暂停。这允许我们在断点处悠闲地调查各种事物的状态。
- en: Let’s say that we have a page that logs a greeting to a famous ninja, as shown
    in the following listing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个页面，它记录了对一位著名忍者的问候，如下所示。
- en: Listing B.2\. A simple “greet a ninja” page
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.2\. 一个简单的“问候忍者”页面
- en: '![](398fig01_alt.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](398fig01_alt.jpg)'
- en: Say we set a breakpoint by using the Chrome DevTools on the annotated line that
    calls the `logGreeting` function in listing B.2 (by clicking the line number gutter
    in the Debugger pane) and refresh the page to cause the code to execute. The debugger
    would then stop the execution at that line and show us the display in [figure
    B.7](#app02fig07).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过在列表 B.2 中调用 `logGreeting` 函数的注释行上使用 Chrome DevTools 设置断点（通过在调试器面板中点击行号空白处）并刷新页面来执行代码。然后调试器会在该行停止执行并显示
    [图 B.7](#app02fig07) 中的显示。
- en: Figure B.7\. When we set a breakpoint on a line of code (by clicking the line
    gutter) and load the page, the browser will stop executing JavaScript code before
    that line is executed. Then you can leisurely explore the current state of the
    application in the pane on the right.
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.7\. 当我们通过点击行空白处设置代码行的断点并加载页面时，浏览器会在执行该行之前停止执行 JavaScript 代码。然后你可以在右侧的面板中悠闲地探索应用程序的当前状态。
- en: '![](b0fig07_alt.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig07_alt.jpg)'
- en: The pane on the right shows the state of the application within which our code
    is running, including the value of the `ninja` variable (`Hattori Hanzo`). The
    debugger breaks on a line *before* the breakpointed line is executed; in this
    example, the call to the `logGreeting` function has yet to be executed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的面板显示了我们的代码正在运行的应用程序的状态，包括 `ninja` 变量的值（`Hattori Hanzo`）。调试器在断点之前的行上中断；在这个例子中，调用
    `logGreeting` 函数尚未执行。
- en: Stepping into a function
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进入函数
- en: If we’re trying to debug a problem with our `logGreeting` function, we might
    want to *step into* that function to see what’s going on inside it. While our
    execution is paused on the `logGreeting` call (with a breakpoint that we’ve previously
    set), we click the Step Into button (shown as an arrow pointing to a dot in most
    debuggers) or press F11, which will cause the debugger to execute up to the first
    line of our `logGreeting` function. [Figure B.8](#app02fig08) shows the result.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在尝试调试 `logGreeting` 函数的问题，我们可能想要 *进入* 该函数以查看其内部的情况。当我们的执行在 `logGreeting`
    调用处暂停（我们之前设置的断点）时，我们点击 Step Into 按钮（在大多数调试器中显示为指向点的箭头）或按 F11，这将导致调试器执行到我们的 `logGreeting`
    函数的第一行。[图 B.8](#app02fig08) 显示了结果。
- en: Figure B.8\. Stepping into a function lets us see the new state in which the
    function is executed. We can explore the current position by studying the Call
    Stack and the current values of local variables.
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.8\. 进入函数让我们看到函数执行的新状态。我们可以通过研究调用堆栈和局部变量的当前值来探索当前位置。
- en: '![](b0fig08_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig08_alt.jpg)'
- en: Note that the look of Chrome DevTools has changed a bit (when compared to [figure
    B.7](#app02fig07)) to allow us to poke around the application state in which the
    `logGreeting` function executes. For example, now we can easily explore the local
    variables of our `logGreeting` function and see that we have a `name` variable
    with the value `Hattori Hanzo` (the variable values are even shown inline, with
    the source code on the left). Also notice that in the upper-right corner is a
    Call Stack pane, which shows that we’re currently within the `logGreeting` function,
    which was called by global code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Chrome DevTools 的外观略有变化（与[图 B.7](#app02fig07) 相比）以允许我们探索 `logGreeting` 函数执行的应用程序状态。例如，现在我们可以轻松地探索
    `logGreeting` 函数的局部变量，并看到我们有一个值为 `Hattori Hanzo` 的 `name` 变量（变量值甚至以内联方式显示，源代码在左侧）。此外，请注意右上角有一个调用堆栈面板，显示我们目前处于由全局代码调用的
    `logGreeting` 函数中。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Step Over and Step Out**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**单步执行和跳出**'
- en: In addition to the Step Into command, we can use Step Over and Step Out.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“进入”命令外，我们还可以使用“单步执行”和“跳出”。
- en: The Step Over command executes our code line by line. If the code in the executed
    line contains a function call, the debugger steps over the function (the function
    will be executed, but the debugger won’t jump into its code).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “单步执行”命令逐行执行我们的代码。如果执行行中的代码包含函数调用，调试器将跳过该函数（函数将被执行，但调试器不会跳入其代码）。
- en: If we’ve paused the execution of a function, clicking the Step Out button will
    execute the code to the end of the function, and the debugger will again pause
    right after the execution has left that function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们暂停了函数的执行，点击“跳出”按钮将执行函数中的代码直到结束，然后调试器将在执行离开该函数后再次暂停。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Conditional breakpoints
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件断点
- en: Standard breakpoints cause the debugger to stop the application execution every
    time a debugger reaches that particular point in program execution. In certain
    cases, this can be tiring. Consider the following listing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标准断点会在调试器每次达到程序执行中的特定点时停止应用程序执行。在某些情况下，这可能会很累。考虑以下列表。
- en: Listing B.3\. Counting Ninjas and conditional breakpoints
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.3\. 计数忍者与条件断点
- en: '![](401fig01_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](401fig01_alt.jpg)'
- en: Imagine that we want to explore the state of the application when counting the
    50th ninja. How tiring would it be to have to visit all 49 ninjas before finally
    reaching the one we want?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要探索在计数第50个忍者的应用程序状态。在最终到达我们想要的忍者之前，访问所有49个忍者会有多累？
- en: Welcome to conditional breakpoints! Unlike traditional breakpoints, which halt
    every time the breakpointed line is executed, a *conditional breakpoints* causes
    the debugger to break only if an expression associated with the conditional breakpoints
    is satisfied. You can set a conditional breakpoint by right-clicking in the line-number
    gutter and choosing Add (see [figure B.9](#app02fig09) for how it’s done in Chrome).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用条件断点！与传统断点不同，每次断点所在的行被执行时，断点都会停止，而*条件断点*仅在关联的条件表达式满足时才会导致调试器中断。您可以通过在行号凹槽中右键单击并选择添加来设置条件断点（有关如何在
    Chrome 中执行的操作，请参阅[图 B.9](#app02fig09)）。
- en: Figure B.9\. Right-click in the line-number margin to set a breakpoint as conditional;
    notice that these are shown in a different color, usually orange.
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.9\. 在行号边缘右键单击以设置条件断点；注意这些断点以不同的颜色显示，通常是橙色。
- en: '![](b0fig09_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig09_alt.jpg)'
- en: 'By associating the expression: `i == 49` with a conditional breakpoint, the
    debugger will halt only when that condition is satisfied. In that way, we can
    jump immediately to the point in the application execution that we’re interested
    in, and ignore the less interesting ones.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将表达式：`i == 49` 与条件断点关联，调试器只有在满足该条件时才会停止。这样，我们可以立即跳转到我们感兴趣的应用程序执行点，而忽略那些不太有趣的点。
- en: So far, you’ve seen how to use various developer tools from different browsers
    in order to debug our code with logging and breakpoints. These are all great tools
    that help us locate specific bugs and achieve a better understanding of the execution
    of a particular application. But in addition to this, we want to have an infrastructure
    in place that will help us detect bugs as soon as possible. This can be achieved
    with testing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何使用不同浏览器的各种开发者工具来通过日志和断点调试我们的代码。这些都是伟大的工具，帮助我们定位特定的错误，并更好地理解特定应用程序的执行。但除此之外，我们还想建立一个基础设施，以便我们能够尽快检测到错误。这可以通过测试来实现。
- en: Creating tests
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建测试
- en: Robert Frost wrote that “good fences make good neighbors,” but in the world
    of web applications, and indeed any programming discipline, good tests make good
    code. Note the emphasis on the word *good*. It’s possible to have an extensive
    test suite that doesn’t help the quality of our code one iota if the tests are
    poorly constructed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·弗罗斯特写道：“好的篱笆能成为好的邻居”，但在网络应用的世界里，实际上在任何编程领域，好的测试能产生好的代码。注意对“好”这个词的强调。如果测试构建得不好，即使有一个庞大的测试套件，也可能对我们的代码质量毫无帮助。
- en: 'Good tests exhibit three important characteristics:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好的测试表现出三个重要的特征：
- en: '***Repeatability—*** Our test results should be highly reproducible. Tests
    that run repeatedly should always produce the exact same results. If test results
    are nondeterministic, how would we know which results are valid and which are
    invalid? Additionally, reproducibility ensures that our tests aren’t dependent
    on external factors, such as network or CPU loads.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可重复性—*** 我们测试的结果应该高度可重复。重复运行的测试应该始终产生完全相同的结果。如果测试结果是不确定的，我们如何知道哪些结果是有效的，哪些是无效的？此外，可重复性确保我们的测试不依赖于外部因素，例如网络或CPU负载。'
- en: '***Simplicity—*** Our tests should focus on testing *one* thing. We should
    strive to remove as much HTML markup, CSS, or JavaScript as we can without disrupting
    the intent of the test case. The more we remove, the greater the likelihood that
    the test case will be influenced by only the specific code that we’re testing.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***简洁性—*** 我们的测试应该专注于测试**一个**事物。我们应该努力去除尽可能多的HTML标记、CSS或JavaScript，而不破坏测试用例的意图。我们去除的越多，测试用例受我们测试的具体代码影响的可能性就越大。'
- en: '***Independence—*** Our tests should execute in isolation. We must avoid making
    the results from one test dependent on another. Breaking tests into the smallest
    possible units will help us determine the exact source of a bug when an error
    occurs.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***独立性—*** 我们的测试应该独立执行。我们必须避免使一个测试的结果依赖于另一个测试。将测试分解成尽可能小的单元将有助于我们在发生错误时确定错误的准确来源。'
- en: 'We can use various approaches to construct tests. The two primary approaches
    are deconstructive and constructive:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种方法来构建测试。两种主要的方法是分解法和构建法：
- en: '***Deconstructive test cases—*** Existing code is whittled down (deconstructed)
    to isolate a problem, eliminating anything that’s not germane to the issue. This
    helps achieve the three characteristics listed previously. We might start with
    a complete website, but after removing extra markup, CSS, and JavaScript, we’ll
    arrive at a smaller case that reproduces the problem.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***分解测试用例—*** 现有代码被削减（分解）以隔离问题，消除与问题无关的任何内容。这有助于实现之前列出的三个特征。我们可能从一个完整的网站开始，但在去除额外的标记、CSS和JavaScript之后，我们将到达一个较小的案例，可以重现问题。'
- en: '***Constructive test cases—*** We start from a known good, reduced case and
    build up until we’re able to reproduce the bug in question. To use this style
    of testing, we’ll need a couple of simple test files from which to build up tests,
    and a way to generate these new tests with a clean copy of our code.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***构建测试用例—*** 我们从一个已知的好、简化的案例开始，直到我们能够重现所讨论的bug。要使用这种测试风格，我们需要几个简单的测试文件来构建测试，以及一种使用我们代码的干净副本生成这些新测试的方法。'
- en: Let’s look at an example of constructive testing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构建测试的一个例子。
- en: When creating reduced test cases, we can start with a few HTML files with minimum
    functionality already included in them. We might even have different starting
    files for various functional areas; for example, one for DOM manipulation, one
    for Ajax tests, one for animations, and so on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建简化测试用例时，我们可以从包含最小功能的一些HTML文件开始。我们甚至可能为不同的功能区域有不同的起始文件；例如，一个用于DOM操作，一个用于Ajax测试，一个用于动画，等等。
- en: For example, the following listing shows a simple DOM test case used to test
    jQuery.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下列表显示了一个简单的DOM测试用例，用于测试jQuery。
- en: Listing B.4\. A reduced DOM test case for jQuery
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.4\. jQuery的简化DOM测试用例
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another alternative is to use a prebuilt service designed for creating simple
    test cases, for example JSFiddle ([http://jsfiddle.net/](http://jsfiddle.net/)),
    CodePen ([http://codepen.io/](http://codepen.io/)), or JS Bin ([http://jsbin.com/](http://jsbin.com/)).
    All have similar functionality; they allow us to build test cases that become
    available at a unique URL. (And you can even include copies of popular libraries.)
    An example in JSFiddle is shown in [figure B.10](#app02fig10).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用为创建简单测试用例而设计的预构建服务，例如 JSFiddle ([http://jsfiddle.net/](http://jsfiddle.net/))、CodePen
    ([http://codepen.io/](http://codepen.io/)) 或 JS Bin ([http://jsbin.com/](http://jsbin.com/))。它们都具有类似的功能；它们允许我们构建测试用例，这些测试用例在唯一的
    URL 上可用。（你甚至可以包含流行库的副本。）JSFiddle 中的一个示例在 [图 B.10](#app02fig10) 中显示。
- en: Figure B.10\. JSFiddle enables us to test combinations of HTML, CSS, and JavaScript
    snippets in a sandbox to see if everything works as intended.
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.10\. JSFiddle 允许我们在沙盒中测试 HTML、CSS 和 JavaScript 片段的组合，以查看是否按预期工作。
- en: '![](b0fig10_alt.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![b0fig10_alt.jpg](b0fig10_alt.jpg)'
- en: Using JSFiddle (or similar tools) is all nice and practical when we have to
    do a quick test of a certain concept, especially because you can easily share
    it with other people, and maybe even get some useful feedback. Unfortunately,
    running such tests requires that you manually open the test and check its result,
    which might be fine if you have only a couple of tests, but normally we should
    have lots and lots of tests that check every nook and cranny of our code. For
    this reason, we want to automate our tests as much as possible. Let’s look at
    how to achieve that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要快速测试某个概念时，使用 JSFiddle（或类似工具）既方便又实用，尤其是因为你可以轻松地与他人分享，甚至可能得到一些有用的反馈。不幸的是，运行此类测试需要你手动打开测试并检查其结果，如果你只有几个测试，这可能还不错，但通常我们应该有很多很多测试，检查我们代码的每一个角落和缝隙。因此，我们希望尽可能自动化我们的测试。让我们看看如何实现这一点。
- en: The fundamentals of a testing framework
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试框架的基本原理
- en: The primary purpose of a testing framework is to allow us to specify individual
    tests that can be wrapped into a single unit, so that they can be run in bulk,
    providing a single resource that can be run easily and repeatedly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架的主要目的是让我们能够指定可以封装成单个单元的单独测试，以便它们可以批量运行，提供一个可以轻松且重复运行的单一资源。
- en: To better understand how a testing framework works, it makes sense to look at
    how it’s constructed. Perhaps surprisingly, JavaScript testing frameworks are
    easy to construct.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解测试框架是如何工作的，查看它是如何构建的很有意义。也许令人惊讶的是，JavaScript 测试框架很容易构建。
- en: You’d have to ask, though, “Why would I want to build a new testing framework?”
    For most cases, writing your own JavaScript testing framework isn’t necessary,
    because many good-quality ones are already available (as you’ll soon see). But
    building your own test framework can serve as a good learning experience.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会问，“我为什么要构建一个新的测试框架？” 对于大多数情况，编写自己的 JavaScript 测试框架并不是必要的，因为已经有很多高质量的框架可用（你很快就会看到）。但构建自己的测试框架可以作为一个很好的学习经历。
- en: The assertion
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言
- en: The core of a unit-testing framework is its assertion method, customarily named
    `assert`. This method usually takes a *value*—an expression whose premise is *asserted*—and
    a description of the purpose of the assertion. If the value evaluates to `true,`
    the assertion passes; otherwise, it’s considered a failure. The associated message
    is usually logged with an appropriate pass/fail indicator.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试框架的核心是其断言方法，通常命名为 `assert`。此方法通常接受一个 *值*——一个前提被 *断言* 的表达式——以及断言目的的描述。如果该值评估为
    `true`，则断言通过；否则，被视为失败。相关的消息通常与适当的通过/失败指示器一起记录。
- en: A simple implementation of this concept can be seen in the following listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的一个简单实现可以在以下列表中看到。
- en: Listing B.5\. A simple implementation of a JavaScript assertion
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.5\. 一个简单的 JavaScript 断言实现
- en: '![](404fig01_alt.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![404fig01_alt.jpg](404fig01_alt.jpg)'
- en: The function named `assert` is almost surprisingly straightforward. It creates
    a new `<li>` element containing the description, assigns a class named `pass`
    or `fail`, depending on the value of the assertion parameter (`value`), and appends
    the new element to a list element in the document body.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `assert` 的函数几乎出奇地简单。它创建一个新的 `<li>` 元素，包含描述，根据断言参数（`value`）的值分配一个名为 `pass`
    或 `fail` 的类，并将新元素附加到文档体中的列表元素。
- en: 'The test suite consists of two trivial tests: one that will always succeed,
    and one that will always fail:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件由两个简单的测试组成：一个总是成功，另一个总是失败：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Style rules for the `pass` and `fail` classes visually indicate success or failure
    using colors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `pass` 和 `fail` 类的样式规则使用颜色直观地表示成功或失败。
- en: The result of running our test suite in Chrome is shown in [figure B.11](#app02fig11).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 中运行我们的测试套件的结果显示在[图 B.11](#app02fig11)中。
- en: Figure B.11\. The result of running our first test suite
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.11\. 我们第一个测试套件运行的结果
- en: '![](b0fig11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](b0fig11.jpg)'
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re looking for something quick, you can use the built-in `console.assert()`
    method (see [figure B.12](#app02fig12)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速的方法，可以使用内置的 `console.assert()` 方法（见[图 B.12](#app02fig12)）。
- en: Figure B.12\. You can use the built-in `console.assert` as a quick way to test
    code. The fail message is logged to the console only if an assertion fails.
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.12\. 你可以使用内置的 `console.assert` 作为测试代码的快捷方式。只有当断言失败时，失败信息才会记录到控制台。
- en: '![](b0fig12_alt.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](b0fig12_alt.jpg)'
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that we’ve built our own rudimentary testing framework, let’s meet some
    of the widely available, more popular testing frameworks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了自己的基础测试框架，让我们来认识一些广泛可用且更受欢迎的测试框架。
- en: Popular testing frameworks
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流行的测试框架
- en: 'A test framework should be a fundamental part of your development workflow,
    so you should pick a framework that works particularly well for your coding style
    and your code base. A JavaScript testing framework should serve a single need:
    displaying the results of the tests, and making it easy to determine which tests
    have passed or failed. Testing frameworks can help us reach that goal without
    having to worry about anything other than creating the tests and organizing them
    into collections called *test suites*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试框架应该是你开发工作流程的基本部分，因此你应该选择一个特别适合你的编码风格和代码库的框架。一个 JavaScript 测试框架应该满足单一需求：显示测试结果，并使确定哪些测试通过或失败变得容易。测试框架可以帮助我们达到这个目标，而无需担心除了创建测试并将它们组织成称为
    *test suites* 的集合之外的其他任何事情。
- en: 'There are several features that we might want to look for in a JavaScript unit-testing
    framework, depending on the needs of the tests. Some of these features include
    the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据测试的需求，我们可能在 JavaScript 单元测试框架中寻找几个功能。以下是一些可能的功能：
- en: The ability to simulate browser behavior (clicks, key presses, and so on)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够模拟浏览器行为（点击、按键等）
- en: Interactive control of tests (pausing and resuming tests)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的交互式控制（暂停和恢复测试）
- en: Handling asynchronous test time-outs
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步测试超时
- en: The ability to filter which tests are to be executed
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够过滤要执行哪些测试
- en: 'Let’s meet the two currently most popular testing frameworks: QUnit and Jasmine.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来认识目前最流行的两个测试框架：QUnit 和 Jasmine。
- en: QUnit
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUnit
- en: 'QUnit is the unit-testing framework originally built to test jQuery. It has
    since expanded beyond its initial goals and is now a standalone unit-testing framework.
    QUnit is primarily designed to be a simple solution to unit testing, providing
    a minimal but easy-to-use API. QUnit’s distinguishing features are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit 是最初为测试 jQuery 而构建的单元测试框架。它已经超越了最初的目标，现在是一个独立的单元测试框架。QUnit 主要设计为一个简单的单元测试解决方案，提供最小但易于使用的
    API。QUnit 的独特特性如下：
- en: Simple API
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 API
- en: Supports asynchronous testing
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持异步测试
- en: Not limited to jQuery or jQuery-using code
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅限于 jQuery 或使用 jQuery 的代码
- en: Especially well-suited for regression testing
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别适合回归测试
- en: Let’s look at a QUnit test example in the following listing that tests whether
    we’ve developed a function that accurately says “Hi” to a ninja.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下列表中的 QUnit 测试示例，该示例测试我们是否开发了一个能够准确地对忍者说“Hi”的函数。
- en: Listing B.6\. QUnit test example
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.6\. QUnit 测试示例
- en: '![](407fig01_alt.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](407fig01_alt.jpg)'
- en: When you open this example in a browser, you should get the results shown in
    [figure B.13](#app02fig13), with one passing assertion from executing the line
    `sayHiToNinja("Hatori")`, and one failing assertion from `assert.ok(false, "Failed")`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中打开此示例时，你应该得到[图 B.13](#app02fig13)中显示的结果，其中有一个通过断言来自执行 `sayHiToNinja("Hatori")`
    行，还有一个失败的断言来自 `assert.ok(false, "Failed")`。
- en: Figure B.13\. An example of a QUnit test run. As a part of our test, we have
    one passing and one failing assertion (one assertion of two passed, one failed.)
    The displayed results put a much bigger emphasis on the failing test, to make
    sure we fix it as soon as possible.
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.13\. QUnit 测试运行的一个示例。作为我们测试的一部分，我们有一个通过和一个失败的断言（两个断言中有一个通过，一个失败。）显示的结果对失败的测试给予了更大的关注，以确保我们尽快修复它。
- en: '![](b0fig13_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](b0fig13_alt.jpg)'
- en: More information on QUnit can be found at [http://qunitjs.com/](http://qunitjs.com/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 QUnit 的更多信息可以在 [http://qunitjs.com/](http://qunitjs.com/) 找到。
- en: Jasmine
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Jasmine
- en: 'Jasmine is another popular testing framework, built on slightly different foundations
    than QUnit. The principal parts of the framework are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是另一个流行的测试框架，其构建基础与 QUnit 略有不同。框架的主要部分如下：
- en: The `describe` function, which describes test suites
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe` 函数，用于描述测试套件'
- en: The `it` function, which specifies individual tests
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it` 函数，用于指定单个测试'
- en: The `expect` function, which checks individual assertions
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect` 函数，用于检查单个断言'
- en: The combination and naming of these functions are geared toward making the test
    suite almost conversational in nature. For example, the following listing shows
    how to test the `sayHiToNinja` function using Jasmine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的组合和命名旨在使测试套件几乎具有对话性质。例如，以下列表展示了如何使用 Jasmine 测试 `sayHiToNinja` 函数。
- en: Listing B.7\. Jasmine test example
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.7\. Jasmine 测试示例
- en: '![](app0bex07-0.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](app0bex07-0.jpg)'
- en: '![](app0bex07-1.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](app0bex07-1.jpg)'
- en: The result of running this Jasmine test suite in the browser is shown in [figure
    B.14](#app02fig14).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行此 Jasmine 测试套件的结果如图 B.14 所示。
- en: 'Figure B.14\. The result of running a Jasmine test suite in the browser. We
    have two tests: one passing and one failing (two specs, one failure).'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.14\. 在浏览器中运行 Jasmine 测试套件的结果。我们有两个测试：一个通过和一个失败（两个规范，一个失败）。
- en: '![](b0fig14_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](b0fig14_alt.jpg)'
- en: More information on Jasmine can be found at [http://jasmine.github.io/](http://jasmine.github.io/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Jasmine 的更多信息可以在 [http://jasmine.github.io/](http://jasmine.github.io/) 找到。
- en: Measuring code coverage
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测量代码覆盖率
- en: It’s difficult to say what makes a particular test suite *good*. Ideally, we
    should test all possible execution paths of our programs. Unfortunately, except
    for the most trivial cases, this isn’t possible. A step in the right direction
    is trying to test as much code as we can, and a metric that tells us the degree
    to which a test suite covers our code is called *code coverage*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要说清楚什么使一个特定的测试套件**良好**是很困难的。理想情况下，我们应该测试我们程序的所有可能的执行路径。不幸的是，除了最简单的情况外，这是不可能的。朝着正确方向迈出的一步是尝试测试尽可能多的代码，而衡量测试套件覆盖我们代码程度的指标被称为**代码覆盖率**。
- en: For example, saying that a test suite has 80% code coverage means that 80% of
    our program code is executed by the test suite, whereas 20% of our code isn’t.
    Although we can’t be entirely sure that this 80% of code doesn’t contain bugs
    (we might have missed an execution path that leads to one), we’re completely in
    the dark about the 20% that wasn’t even executed. This is why we should measure
    the code coverage of our test suites.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个测试套件的代码覆盖率是 80%，这意味着我们的程序代码中有 80% 被测试套件执行，而 20% 的代码没有被执行。尽管我们无法完全确定这
    80% 的代码中没有错误（我们可能遗漏了导致错误的执行路径），但我们对于那 20% 没有被执行的代码一无所知。这就是为什么我们应该衡量测试套件的代码覆盖率。
- en: In JavaScript development, we can use several libraries to measure the coverage
    of our test suites, most notably Blanket.js ([https://github.com/alex-seville/blanket](https://github.com/alex-seville/blanket))
    and Istanbul ([https://github.com/gotwarlost/istanbul](https://github.com/gotwarlost/istanbul)).
    Setting up these libraries goes beyond the scope of this book, but their respective
    web pages offer all the info we might need on properly setting them up.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 开发中，我们可以使用几个库来测量测试套件的覆盖率，最著名的是 Blanket.js ([https://github.com/alex-seville/blanket](https://github.com/alex-seville/blanket))
    和 Istanbul ([https://github.com/gotwarlost/istanbul](https://github.com/gotwarlost/istanbul))。设置这些库超出了本书的范围，但它们的相应网页提供了我们可能需要的所有关于正确设置它们的信息。
