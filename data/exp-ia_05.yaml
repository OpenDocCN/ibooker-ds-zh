- en: 6  Building APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6  构建API
- en: Friends, gather round. This chapter marks a new beginning. Today, we exit the
    abstract but critical "core Express" and enter the real world. For the rest of
    this book, we'll be building much more real systems atop Express. We'll start
    with APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 朋友们，围坐在一起。本章标志着一个新的开始。今天，我们离开了抽象但关键的“核心Express”，进入了现实世界。在这本书的剩余部分，我们将在Express之上构建更多真实系统。我们将从API开始。
- en: '"API" is a pretty broad term.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '"API"是一个相当宽泛的术语。'
- en: It stands for "Application Programming Interface", which doesn't demystify the
    term much. If it were up to me (and it isn't), I'd rename it to something like
    "Software Interface". Where a user interface is meant to be consumed by human
    users, a software interface is meant to be consumed by code. At some level, all
    user interfaces sit on top of software interfaces—all user interfaces sit on top
    of some APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表“应用程序编程接口”，这并没有多少神秘感。如果由我来决定（实际上并不是），我会将其重命名为类似“软件接口”的东西。用户界面是为了被人类用户消费而设计的，而软件接口是为了被代码消费而设计的。在某种程度上，所有用户界面都建立在软件接口之上——所有用户界面都建立在某些API之上。
- en: At a high level, APIs are just ways for one piece of code to talk to another
    piece of code. This could mean a computer talking to itself or a computer talking
    to another computer over a network. For example, a video game might consume an
    API that allows the code to draw graphics to the screen. We've seen a few methods
    available in the Express API, like `app.use` or `app.get`. These are just interfaces
    that you as a programmer can use to "talk to" other code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，API只是代码与代码之间交流的一种方式。这可能意味着一台计算机在自言自语，或者一台计算机通过网络与另一台计算机交流。例如，一个视频游戏可能会使用一个API，允许代码在屏幕上绘制图形。我们已经看到了Express
    API中的一些方法，比如`app.use`或`app.get`。这些只是你可以作为程序员用来“与”其他代码“交流”的接口。
- en: There are also computer-to-computer APIs. These happen over a network, and usually
    over the Internet. These computers may be running different programming languages
    and/or different operating systems, so they've developed common ways to communicate.
    Some simply send plain text, while others might choose JSON or XML. They might
    send things over HTTP or over another protocol like FTP. Either way, both parties
    have to agree that they're going to send data a certain way. In this chapter,
    the APIs we create will use JSON.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 还有计算机到计算机的API。这些通过网络进行，通常通过互联网。这些计算机可能运行着不同的编程语言和/或不同的操作系统，因此它们已经发展出了通用的通信方式。有些只是发送纯文本，而有些可能会选择JSON或XML。它们可能会通过HTTP或通过FTP等协议发送数据。无论如何，双方都必须同意将以某种方式发送数据。在本章中，我们创建的API将使用JSON。
- en: We'll talk about APIs that interact you can build with Express. These APIs will
    take HTTP requests and respond with JSON data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论你可以用Express构建的交互式API。这些API将接受HTTP请求并以JSON数据响应。
- en: By the end of this chapter, programmers will be able to build applications that
    consume JSON APIs of your creation. We'll also aim to design good APIs. The core
    principle behind good API design is to do what developers consuming your API expect.
    Most of these expectations can be met by following the HTTP specification. Rather
    than instruct you to read a long, dry (but very interesting) specification document,
    I'll tell you the parts you need to know so that you can write a good API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，程序员将能够构建使用你创建的JSON API的应用程序。我们还将致力于设计良好的API。良好API设计的核心原则是做消费你API的开发者期望的事情。这些期望中的大部分可以通过遵循HTTP规范来实现。而不是让你阅读一份冗长、枯燥（但非常有趣）的规范文档，我会告诉你你需要知道的部分，这样你就可以编写一个好的API。
- en: 'Just like the nebulous concepts of "good code" versus "bad code", there aren''t
    a lot of hard lines in the sand here. A lot of this is open to your interpretation.
    You could come up with many examples where you might want to deviate from these
    established best practices, but remember: the goal is to do what other developers
    expect.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“好代码”与“坏代码”这样的模糊概念一样，这里并没有很多明确的界限。很多都是开放的，供你解释。你可以想出很多例子，你可能想要偏离这些既定的最佳实践，但请记住：目标是做其他开发者期望的事情。
- en: 'In this chapter, we''ll learn:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: ·  What an API is and isn't
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ·  API是什么以及不是什么
- en: ·  The fundamentals of building an API with Express
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用Express构建API的基本原理
- en: ·  HTTP methods and how they relate to common application actions
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ·  HTTP方法和它们与常见应用操作的关系
- en: ·  How to create different versions of your API and why you want to do it
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何创建API的不同版本以及为什么你想这么做
- en: ·  How to properly use HTTP status codes
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何正确使用HTTP状态码
- en: Let's get started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 6.1     A basic JSON API example
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1     一个基本的JSON API示例
- en: Let's talk about a simple JSON API and how it could be used so that we see a
    concrete example of the kind of thing we'll be building.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个简单的JSON API及其用途，以便我们能够看到我们将要构建的具体示例。
- en: Let's imagine a simple API that takes a timezone string like `"America/Los_Angeles"` or `"Europe/London"` and
    returns a string that represents the current time in that timezone (like `"2015-04-07T20:09:58-07:00"`).
    Notice that these strings aren't things that a human would naturally type or be
    able to easily read—they're for a computer to understand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个简单的API，它接收一个时区字符串，如`"America/Los_Angeles"`或`"Europe/London"`，并返回一个表示该时区当前时间的字符串（如`"2015-04-07T20:09:58-07:00"`）。请注意，这些字符串不是人类会自然输入或容易阅读的东西——它们是为了让计算机理解。
- en: 'Our API might accept an HTTP request to this URL:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API可能接受对以下URL的HTTP请求：
- en: '`/timezone?tz=America+Los_Angeles`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`/timezone?tz=America+Los_Angeles`'
- en: 'And our API server might respond with JSON, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API服务器可能会以JSON的形式响应，如下所示：
- en: '`{` `  "time": "2015-06-09T16:20:00+01:00",` `  "zone": "America/Los_Angeles"``}`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "time": "2015-06-09T16:20:00+01:00",` `  "zone": "America/Los_Angeles"``}`'
- en: One could imagine writing simple applications that used this API. These applications
    could run on a variety of platforms, and as long as they communicated with this
    API and could parse JSON (which most platforms can), they can build whatever they
    want!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象编写使用此API的简单应用程序。这些应用程序可以在各种平台上运行，只要它们与这个API通信并且能够解析JSON（大多数平台都可以），它们就可以构建他们想要的任何东西！
- en: You could build a simple webpage that consumed this API, as shown in Figure
    6.1\. It might send AJAX requests to your server, parse the JSON, and display
    it in the HTML.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建一个简单的网页来消费此API，如图6.1所示。它可能会向您的服务器发送AJAX请求，解析JSON，并在HTML中显示它。
- en: '![](../Images/06_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_01.png)'
- en: Figure 6.1 A website that consumes our JSON API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 消费我们JSON API的网站。
- en: You could also build a mobile application, like Figure 6.2\. It would make a
    request to our API server, parse the JSON, and display the results on the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以构建一个如图6.2所示的移动应用。它将向我们的API服务器发送请求，解析JSON，并在屏幕上显示结果。
- en: '![](../Images/06_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_02.png)'
- en: Figure 6.2 A mobile app that uses your API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 使用您API的移动应用。
- en: You could even build a command-line tool that runs in the terminal, like in
    Figure 6.3\. Once again, it'd make a request to the API server, parse the JSON,
    and display the results for humans in the terminal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以构建一个在终端中运行的命令行工具，如图6.3所示。再次，它将向API服务器发送请求，解析JSON，并在终端中向人类显示结果。
- en: '![](../Images/06_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_03.png)'
- en: Figure 6.3 Even terminal-based applications can consume a JSON API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 即使是基于终端的应用程序也可以消费JSON API。
- en: 'The point is this: if you make an API that takes requests from computers and
    spits out responses for computers (not humans!), you can build user interfaces
    atop that API. We did this in the previous chapter with the weather app—it used
    an API to get weather data and display it to the user.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重点在于：如果您创建了一个从计算机接收请求并向计算机（而不是人类）发送响应的API，您可以在该API之上构建用户界面。我们在上一章的天气应用中就是这样做的——它使用API获取天气数据并将其显示给用户。
- en: 6.2     A simple Express-powered JSON API
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2     一个简单的Express驱动的JSON API
- en: Now that we know what an API is, let's build a simple one with Express.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了API是什么，让我们用Express构建一个简单的API。
- en: 'The fundamentals of an Express API are pretty straightforward: take a request,
    parse it, and respond with a JSON object and an HTTP status code. We''ll use middleware
    and routing to take requests and parse them, and we''ll use Express''s conveniences
    to respond to requests.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Express API的基本原理相当简单：接收请求，解析它，并以JSON对象和HTTP状态码的形式响应。我们将使用中间件和路由来接收和解析请求，并使用Express的便利性来响应请求。
- en: NOTE Technically, APIs don't have to use JSON—they can use other data interchange
    formats like XML or plain text. JSON has the best Express integration, plays nicely
    with browser-based JavaScript, and is one of the most popular API choices, so
    we'll use it here. You can use other formats if you want to!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从技术上讲，API不必使用JSON——它们可以使用其他数据交换格式，如XML或纯文本。JSON与Express的集成最佳，与基于浏览器的JavaScript配合良好，并且是最受欢迎的API选择之一，所以我们在这里使用它。如果您想使用其他格式，也可以！
- en: Let's build a simple API that generates random integers. This might seem a bit
    of a contrived example, but we might want a consistent random number generator
    across multiple platforms (iOS, Android, web, and more) and we don't want to write
    the same code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的API，它可以生成随机整数。这可能会显得有些牵强，但我们可能需要在多个平台（iOS、Android、Web等）上有一个一致的随机数生成器，而且我们不希望编写相同的代码。
- en: ·  Anyone who requests the API must send a minimum value and a maximum value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ·  任何请求API的人都必须发送最小值和最大值。
- en: ·  We'll parse those values, calculate our random number, and send it back as
    JSON.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ·  我们将解析这些值，计算随机数，并将其作为JSON发送回去。
- en: You might think that JSON is overkill for this situation—why not stick to plain
    text?—but it'll help us learn how to do it and make it easy to expand our functionality
    later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为JSON对于这种情况来说有点过度——为什么不坚持使用纯文本呢？——但它将帮助我们学习如何做到这一点，并使以后扩展我们的功能变得容易。
- en: 'To build this project, we will:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个项目，我们将：
- en: 1.  Create a `package.json` to describe the metadata of our app
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 创建一个`package.json`文件来描述我们应用的元数据
- en: 2.  Create a file called `app.js` which will contain all of our code
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建一个名为`app.js`的文件，它将包含我们所有的代码
- en: 3.  In `app.js`, we'll create an Express application and attach a single route
    that gives a random number
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在`app.js`中，我们将创建一个Express应用并附加一个提供随机数的单一路由
- en: Let's get started.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'As usual, to start a project, make a new folder and create a package.json.
    You can create this file by running `npm init` or you can just manually type out
    the file. In any case, you''ll want to create it and install Express. Your package.json
    should look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，为了启动一个项目，创建一个新的文件夹并创建一个package.json文件。你可以通过运行`npm init`来创建这个文件，或者你可以手动输入文件内容。无论如何，你都需要创建它并安装Express。你的package.json应该看起来像这样：
- en: Listing 6.1 package.json for our random number project
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 我们随机数项目的package.json
- en: '`{` `  "name": "random-number-api",` `  "private": true,` `  "scripts": {`
    `    "start": "node app"` `  },` `  "dependencies": {` `    "express": "^4.12.3"      
    #A` `  }``}`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "random-number-api",` `  "private": true,` `  "scripts": {`
    `    "start": "node app"` `  },` `  "dependencies": {` `    "express": "^4.12.3"      
    #A` `  }``}`'
- en: '#A As always, your package version numbers may vary.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 总是如此，你的包版本号可能会有所不同。'
- en: 'Next, we''ll want to create app.js. Create it in the root of your project and
    put the following inside:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建app.js。在项目的根目录中创建它，并放入以下内容：
- en: Listing 6.2 Our random number app
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 我们的随机数应用
- en: '`var express = require("express");`   `var app = express();`   `app.get("/random/:min/:max",
    function(req, res) {` `  var min = parseInt(req.params.min);  #A` `  var max =
    parseInt(req.params.max);  #A`   `  if (isNaN(min) || isNaN(max)) {                    
    #B` `    res.status(400);                                  #B` `    res.json({
    error: "Bad request." });              #B` `    return;                                          
    #B` `  }                                                   #B`   `  var result
    = Math.round((Math.random() * (max - min)) + min);  #C`   `  res.json({ result:
    result });   #C` `});`   `app.listen(3000, function() {` `  console.log("App started
    on port 3000");``});`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `app.get("/random/:min/:max",
    function(req, res) {` `  var min = parseInt(req.params.min);  #A` `  var max =
    parseInt(req.params.max);  #A`   `  if (isNaN(min) || isNaN(max)) {                    
    #B` `    res.status(400);                                  #B` `    res.json({
    error: "Bad request." });              #B` `    return;                                          
    #B` `  }                                                   #B`   `  var result
    = Math.round((Math.random() * (max - min)) + min);  #C`   `  res.json({ result:
    result });   #C` `});` `app.listen(3000, function() {` `  console.log("App started
    on port 3000");``});`'
- en: '#A We pass two parameters in the URL of the request: min and max.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们在请求的URL中传递两个参数：最小值和最大值。'
- en: '#B Do some error checking. If either of the numbers are malformed, we respond
    with an error.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 执行一些错误检查。如果任一数字格式不正确，我们返回一个错误。'
- en: '#C Calculate and send the result as JSON.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 计算并发送结果作为JSON。'
- en: 'If you start this app and visit [http://localhost:3000/random/10/100](http://localhost:3000/random/10/100),
    you''ll see a JSON response with a random number between 10 and 100\. It will
    look something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动这个应用并访问[http://localhost:3000/random/10/100](http://localhost:3000/random/10/100)，你将看到一个包含10到100之间随机数的JSON响应。它看起来可能像这样：
- en: '![](../Images/06_04.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_04.png)'
- en: Figure 6.4 Testing your API in your browser. Try refreshing and you'll see different
    numbers!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 在浏览器中测试你的API。尝试刷新，你会看到不同的数字！
- en: Let's step through this code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码。
- en: The first two lines simply require Express and create a new Express application
    as we've seen before.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行简单地引入Express并创建一个新的Express应用，就像我们之前看到的那样。
- en: Next, we create a route handler for GET requests. This will take requests like
    /random/10/100, or /random/50/52, but it will also handle requests like /random/foo/bar.
    We'll have to make sure that both fields are numbers, and we'll do that soon.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个用于GET请求的路由处理器。这将处理像/random/10/100或/random/50/52这样的请求，但它也会处理像/random/foo/bar这样的请求。我们必须确保这两个字段都是数字，我们很快就会做到这一点。
- en: Next, we parse out the numbers using the built-into-JavaScript parseInt function.
    This function either returns a number or NaN. If either of the values are NaN,
    we show an error to the user. Let's look at these five lines in detail, because
    they're pretty important.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用内置在 JavaScript 中的 parseInt 函数解析数字。这个函数要么返回一个数字，要么返回 NaN。如果任一值是 NaN，我们向用户显示错误。让我们详细看看这五行，因为它们非常重要。
- en: Listing 6.3 Drilling down into the error handler
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 深入错误处理器
- en: '`if (isNaN(min) || isNaN(max)) {` `  res.status(400);` `  res.json({ error:
    "Bad request." });` `  return;``}`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (isNaN(min) || isNaN(max)) {` `  res.status(400);` `  res.json({ error:
    "Bad request." });` `  return;``}`'
- en: 'The first line shouldn''t be too new to you: it just checks if either of the
    numbers are NaN, meaning they''re badly-formatted. If they are, we do three things:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行对你来说不应该太陌生：它只是检查两个数字中的任何一个是否是 NaN，这意味着它们格式不正确。如果是，我们做三件事：
- en: '1.  Set the HTTP status code to 400\. If you''ve ever seen a 404 error, this
    is just a variant: it signals that something about the user''s request was bad.
    We''ll talk about it more later in this chapter.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将 HTTP 状态码设置为 400。如果你曾经见过 404 错误，这只是一个变体：它表示用户请求中存在问题。我们将在本章后面更多地讨论它。
- en: 2.  Send a JSON object. In this case, we send an object that has the error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 发送一个 JSON 对象。在这种情况下，我们发送一个包含错误的对象。
- en: 3.  Return. If we didn't return, we'd continue onto the rest of the function
    and we'd send the request twice and Express would start throwing nasty errors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 返回。如果我们不返回，我们会继续执行函数的其余部分，我们会发送两次请求，Express 会开始抛出讨厌的错误。
- en: Finally, we calculate the result and send it as JSON!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算结果并将其作为 JSON 发送！
- en: 'This is a pretty basic API, but it shows the fundamentals of building an API
    with Express: parsing requests, setting HTTP status codes, and sending JSON!'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当基本的 API，但它展示了使用 Express 构建API的基础：解析请求、设置 HTTP 状态码和发送 JSON！
- en: Now that we know the fundamentals, we can start learning more about building
    bigger, better APIs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，我们可以开始学习更多关于构建更大、更好的 API 的内容。
- en: 6.3     "Create, Read, Update, Delete" APIs
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表 6.3 深入错误处理器
- en: 'There''s a common application pattern: Create, Read, Update, and Delete. It''s
    shortened to CRUD, which is a fun word.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 中没有内置任何东西来阻止它定义任何你想要的方法，但 Web 应用程序通常使用以下四种：
- en: 'Lots of applications use CRUD. For example, imagine a photo-sharing app that
    has no user accounts; anyone can upload photos. Here''s how you might envision
    that in CRUD style:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序使用 CRUD。例如，想象一个没有用户账户的照片分享应用程序；任何人都可以上传照片。以下是您可能以 CRUD 风格设想的方式：
- en: ·  Users can upload photos; this is the create step.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: · 用户可以上传照片；这是创建步骤。
- en: ·  Users can browse photos; this is the read part.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: · 用户可以浏览照片；这是读取部分。
- en: ·  Users can update photos, perhaps by giving them different filters or changing
    captions; this would be an update.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: · 用户可以更新照片，可能通过给他们不同的过滤器或更改标题；这将是一个更新。
- en: ·  Users can delete photos from the website. This would be, well, a delete.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: · 用户可以从网站上删除照片。这将是，嗯，删除。
- en: You could imagine lots of your favorite applications fitting into this model,
    from photo sharing to social networks to file storage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象许多你喜欢的应用程序都符合这个模型，从照片分享到社交网络到文件存储。
- en: Before we can talk about how CRUD fits into APIs, we need to talk about something
    called HTTP methods, also known as HTTP verbs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论 CRUD 如何融入 API 之前，我们需要先谈谈一种叫做 HTTP 方法的东西，也称为 HTTP 动词。
- en: 6.3.1  HTTP verbs (also known as HTTP methods)
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 HTTP 动词（也称为 HTTP 方法）
- en: 'The HTTP spec defines methods like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 规范定义方法如下：
- en: The Method token indicates the method to be performed on the resource identified
    by the Request-URI. The method is case-sensitive.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 方法令牌表示要对由 Request-URI 标识的资源执行的操作。方法是区分大小写的。
- en: Ugh, that's hard to read.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，这很难读。
- en: 'A human might understand it this way: a client sends an HTTP request to the
    server with a method. They can choose any method they want, but there are really
    only a handful that you use. The server sees that method and responds accordingly.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 人类可能会这样理解：客户端向服务器发送一个带有方法的 HTTP 请求。他们可以选择他们想要的任何方法，但实际上只有少数几种是你使用的。服务器看到这个方法并相应地做出响应。
- en: 'There''s nothing baked into HTTP that prevents it from defining any method
    you want, but web applications typically use the following four:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'There''s nothing baked into HTTP that prevents it from defining any method
    you want, but web applications typically use the following four:'
- en: 1.  GET is probably the most common HTTP method anyone uses. As the name suggests,
    it gets resources. When you load someone's homepage, you GET it. When you load
    an image, you GET it. GET methods shouldn't change the state of your app; the
    other methods do that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 1. GET 可能是任何人使用最普遍的 HTTP 方法。正如其名所示，它获取资源。当你加载某人的主页时，你 GET 它。当你加载一张图片时，你 GET
    它。GET 方法不应该改变你的应用程序状态；其他方法会这样做。
- en: Idempotence is important to GET requests. "Idempotent" is a fancy word that
    means "doing it once should be no different than doing it many times". If you
    GET an image once and then refresh 500 times, the image shouldn't ever change.
    That's not to say that the response can never change—a page could change based
    on a changing stock price or a new time of day—but GETs shouldn't cause that change.
    That's idempotent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性对 GET 请求很重要。“幂等”是一个华丽的词，意思是“做一次应该和做多次没有区别”。如果你 GET 了一张图片一次，然后刷新500次，图片不应该有任何变化。这并不是说响应永远不会改变——页面可能会根据变化的股票价格或新的时间而改变——但
    GET 请求不应该引起这种变化。这就是幂等的。
- en: 2.  POST is another common one, and is generally used to request a change to
    the state of the server. You POST a blog entry; you POST a photo to your favorite
    social network; you POST when you sign up for a new account on a website. POST
    is used to create records on servers, not modify existing records -- that's what
    PUT and DELETE are for, as discussed below.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 2. POST 是另一个常见的，通常用于请求更改服务器状态。你 POST 一篇博客文章；你 POST 一张照片到你的社交网络；你 POST 当你在网站上注册新账户时。POST
    用于在服务器上创建记录，而不是修改现有记录——这就是 PUT 和 DELETE 的用途，如下文所述。
- en: POST is also used for actions, like "buy this item".
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: POST 也用于动作，比如“购买此商品”。
- en: POST, unlike GET, is non-idempotent. That means that the state will change the
    first time you POST, and the second time, and the third time, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GET 不同，POST 是非幂等的。这意味着第一次 POST 时状态会改变，第二次，第三次，以此类推。
- en: 3.  PUT has the worst name of the four, in my opinion; I think a name like "update"
    or "change" would suit it better. If I've published (POSTed) a job profile online
    and later want to update it, I would PUT those changes. I could PUT changes to
    a document, or to a blog entry, or something else. (We don't use PUT to delete
    entries, though; that's what DELETE is for, as we'll see next.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在我看来，PUT 这四个方法中名字最糟糕；我认为像“更新”或“更改”这样的名字更适合它。如果我已经在网上发布了（POSTed）一份工作简介，后来想更新它，我会使用
    PUT 来进行这些更改。我可以对文档、博客条目或其他内容进行 PUT 更改。（我们不会使用 PUT 来删除条目；那是 DELETE 的用途，我们将在下一节中看到。）
- en: PUT has another interesting part; if you try to PUT changes to a record that
    doesn't exist, the server can (but doesn't have to) create that record. You probably
    wouldn't want to update a profile that doesn't exist, but you might want to update
    a page on a personal website whether it exists or not.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: PUT 另一个有趣的部分是；如果你尝试对不存在的记录进行 PUT 更改，服务器可以（但不一定）创建该记录。你可能不想更新一个不存在的个人资料，但你可能想在个人网站上更新页面，无论它是否存在。
- en: PUT is idempotent, which wasn't immediately intuitive to me, but it eventually
    made sense. Let's say I'm "Evan Hahn" on a website but I want to change it to
    "Max Fightmaster". I don't PUT "change name from Evan Hahn to Max Fightmaster";
    I PUT "change my name to Max Fightmaster; I don't care what it was before". This
    allows it to be idempotent. I could do this once or 500 times, and my name would
    still be Max Fightmaster. It is idempotent in this way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: PUT 是幂等的，这对我来说一开始并不直观，但最终我明白了。假设我在一个网站上叫“Evan Hahn”，但我想改为“Max Fightmaster”。我不会
    PUT “将名字从 Evan Hahn 更改为 Max Fightmaster”；我会 PUT “将我的名字改为 Max Fightmaster；我不在乎之前是什么”。这样就可以保证幂等性。我可以做一次或500次，我的名字仍然是
    Max Fightmaster。它就是这样幂等的。
- en: 4.  DELETE is probably the easiest to describe. Like PUT, you basically specify
    "DELETE record 123". You could DELETE a blog entry, or DELETE a photo, or DELETE
    a comment. That's it!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 4. DELETE 可能是最容易描述的。和 PUT 一样，你基本上指定“DELETE 记录 123”。你可以 DELETE 一篇博客文章，或 DELETE
    一张照片，或 DELETE 一条评论。就是这样！
- en: DELETE is idempotent in the same way that PUT is. Let's say I've accidentally
    published (POSTed) an embarrassing photo of me wearing a lampshade over my head.
    If I don't want it on there, I can DELETE it. Now it's gone! It doesn't matter
    whether I ask for it to be deleted once or 500 times; it's going to be gone. (Phew!)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 和 PUT 一样是幂等的。假设我意外地发布（POSTed）了一张我戴着灯罩的尴尬照片。如果我不想让它在那里，我可以 DELETE 它。现在它消失了！无论我要求删除一次还是500次，它都会消失。（谢天谢地！）
- en: There's nothing that strictly enforces these constraints -- you could theoretically
    use GET requests to do what POST requests should do, for example -- but it's bad
    practice and against the HTTP specification. It's not what people expect. Many
    browsers also have different behaviors depending on the type of HTTP request,
    so you always make an effort to use the right ones.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么严格地强制执行这些约束——理论上你可以使用 GET 请求来做 POST 请求应该做的事情，例如——但这是一种不良的做法，并且违反了 HTTP 规范。这不是人们所期望的。许多浏览器也会根据
    HTTP 请求的类型有不同的行为，所以你总是要努力使用正确的请求。
- en: HTTP specifies a number of other verbs, but I've never had a need to stray very
    far from those four.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 规范了其他一些动词，但我从未有远离那四个动词的需求。
- en: '"VERBS" OR "METHODS"? The specification for HTTP 1.0 and 1.1 uses the word
    "method" when describing this concept, so I suppose that''s technically correct.
    "Verb" is also used. For our purposes, I''ll mostly call them "verbs" because
    that''s what the Express documentation says. Know that you can use both (and that
    the nitpicky should call them "methods").'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"动词" 或 "方法" ? HTTP 1.0 和 1.1 的规范在描述这个概念时使用的是“方法”这个词，所以我猜这在技术上是对的。“动词”也被使用了。为了我们的目的，我主要会称它们为“动词”，因为
    Express 文档就是这样说的。要知道你可以使用两者（并且那些吹毛求疵的人应该称它们为“方法”）。'
- en: 'In Express, you''ve already seen how to handle different HTTP methods. To refresh
    your memory, here''s a simple application that responds to each different method
    with a little message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，你已经看到了如何处理不同的 HTTP 方法。为了刷新你的记忆，这里有一个简单的应用程序，它会针对每种不同的方法响应一条简短的消息：
- en: Listing 6.4 Handling different HTTP verbs
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 处理不同的 HTTP 动词
- en: '`var express = require("express");`   `var app = express();`   `app.get("/",
    function(req, res) {` `  res.send("you just sent a GET request, friend");` `});`
      `app.post("/", function(req, res) {` `  res.send("a POST request? nice");` `});`
      `app.put("/", function(req, res) {` `  res.send("i don''t see a lot of PUT requests
    anymore");` `});`   `app.delete("/", function(req, res) {` `  res.send("oh my,
    a DELETE??");` `});`   `app.listen(3000, function() {` `  console.log("App is
    listening on port 3000");``});`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `app.get("/", function(req,
    res) {` `  res.send("你刚刚发送了一个 GET 请求，朋友");` `});` `app.post("/", function(req,
    res) {` `  res.send("一个 POST 请求？很好");` `});` `app.put("/", function(req, res)
    {` `  res.send("我不再看到很多 PUT 请求了");` `});` `app.delete("/", function(req, res)
    {` `  res.send("哦我的，一个 DELETE??");` `});` `app.listen(3000, function() {` `  console.log("应用程序正在监听端口
    3000");``});`'
- en: If you start this application (if it's saved as `app.js`, run `node app.js`),
    you can use the handy cURL command-line tool to try sending different requests.
    cURL sends GET requests by default, but you can use its `-X` argument to send
    other verbs. For example, `curl -X PUT` [http://localhost:3000](http://localhost:3000) will
    send a PUT request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动这个应用程序（如果它保存为 `app.js`，则运行 `node app.js`），你可以使用方便的 cURL 命令行工具尝试发送不同的请求。cURL
    默认发送 GET 请求，但你可以使用其 `-X` 参数发送其他动词。例如， `curl -X PUT` [http://localhost:3000](http://localhost:3000) 将发送一个
    PUT 请求。
- en: '![](../Images/06_05.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_05.png)'
- en: Figure 6.5 Using the cURL tool to send different requests to our server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 使用 cURL 工具向我们的服务器发送不同的请求。
- en: 'This should all be review from previous chapters: you can handle different
    HTTP methods with different handlers.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该都是之前章节中的复习内容：你可以使用不同的处理程序来处理不同的 HTTP 方法。
- en: 6.3.2  CRUD applications with HTTP methods
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2  使用 HTTP 方法的 CRUD 应用程序
- en: 'Let''s recall our photo-sharing app. Here''s how you might envision that in
    CRUD style:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的照片分享应用。以下是您可能以 CRUD 风格想象它的方式：
- en: ·  Users can upload photos; this is the create step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ·  用户可以上传照片；这是创建步骤。
- en: ·  Users can browse photos; this is the read part.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ·  用户可以浏览照片；这是读取部分。
- en: ·  Users can update photos, perhaps by giving them different filters or changing
    captions; this would be an update.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ·  用户可以更新照片，可能通过给他们不同的过滤器或更改标题；这将是一个更新。
- en: ·  Users can delete photos from the website.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ·  用户可以从网站上删除照片。
- en: 'If you''re like me, you didn''t immediately see the connection between CRUD
    and the four main HTTP verbs I listed above. But if GET is for reading resources,
    and POST is for creating resources...woah! We see the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你可能没有立即看到 CRUD 和我上面列出的四个主要 HTTP 动词之间的联系。但如果 GET 是用于读取资源，而 POST 是用于创建资源……哇！我们看到了以下内容：
- en: ·  Create = POST
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ·  创建 = POST
- en: ·  Read = GET
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ·  读取 = GET
- en: ·  Update = PUT
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ·  更新 = PUT
- en: ·  Delete = DELETE
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ·  删除 = DELETE
- en: The four main HTTP methods lend themselves pretty well to CRUD-style applications,
    which are very common on the web.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 四个主要的 HTTP 方法非常适合 CRUD 风格的应用程序，这在网络上非常常见。
- en: POST versus PUT
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: POST 与 PUT
- en: There's a little bit of debate about which HTTP verbs correspond to which CRUD
    operations. Most people agree that Read == GET and Delete == DELETE, but Create
    and Update are a little murkier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪些HTTP动词对应于哪些CRUD操作有一些争议。大多数人同意Read == GET和Delete == DELETE，但Create和Update则有些模糊。
- en: Because PUT can create records just like POST can, one could say that PUT better
    corresponds to Create. PUT can both Create and Update records, so why not put
    it in both spots?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为PUT可以创建记录，就像POST可以一样，所以可以说PUT更好地对应于Create。PUT可以创建和更新记录，所以为什么不在两个地方都放它呢？
- en: Similarly, the PATCH method (which we haven't yet mentioned) sometimes takes
    the Update role. To quote the specification, "the PUT method is already defined
    to overwrite a resource with a complete new body, and cannot be reused to do partial
    changes." PATCH allows you to partially overwrite a resource. PATCH was only formally
    defined in 2010, so it's relatively new on the HTTP scene, which is why it's less
    used. In any case, some people think PATCH is better suited to Update than PUT.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，PATCH方法（我们尚未提及）有时扮演更新角色。引用规范，“PUT方法已经定义为用完整的新主体覆盖资源，并且不能被重新用于执行部分更改。”PATCH允许你部分覆盖资源。PATCH直到2010年才正式定义，所以在HTTP场景中相对较新，这就是为什么它使用较少。无论如何，有些人认为PATCH比PUT更适合更新。
- en: Because HTTP doesn't specify this stuff too strictly, it's up to you to decide
    what you want to do. In this book, we'll be using the convention above, but know
    that the expectations are a little murky here.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为HTTP没有对此类内容做出过于严格的规范，所以这取决于你决定做什么。在这本书中，我们将使用上述约定，但要知道这里的期望有些模糊。
- en: 6.4     API versioning
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 API版本控制
- en: Let me walk you through a scenario.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带你通过一个场景。
- en: You design a public API for your time zone app and it becomes a big hit. People
    all over the world are using it. People are using it to find times all across
    the globe. It's working well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你为你的时区应用程序设计了一个公共API，它变得非常受欢迎。世界各地的人们都在使用它。人们用它来查找全球各地的时间。它运行得很好。
- en: 'But, after a few years, you want to update your API. You''ve decided you want
    to change something, but there''s a problem: if you change it, all of the people
    using your API will have to update their code. At this point, you might feel kind
    of stuck. What do you do? Do you make the changes you want to make and break old
    users, or does your API stagnate and never stay up-to-date?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，几年后，你想更新你的API。你已经决定要改变一些东西，但有一个问题：如果你改变它，所有使用你的API的人都将不得不更新他们的代码。在这个时候，你可能感到有些束手无策。你该怎么办？你是做出你想要的改变并破坏旧用户，还是让你的API停滞不前，永远无法保持更新？
- en: 'There''s a solution to all of this: version your API.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些问题，有一个解决方案：对API进行版本控制。
- en: 'All you have to do is add some version information to your API. So a request
    that comes into this URL might be for version 1 of your API:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是给你的API添加一些版本信息。所以一个进入这个URL的请求可能是你的API的版本1：
- en: '`/v1/timezone`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`/v1/timezone`'
- en: 'And a request coming into version 2 of your API might visit this URL:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 而进入API版本2的请求可能会访问这个URL：
- en: '`/v2/timezone`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`/v2/timezone`'
- en: This allows you to make changes to your API by simply making a new version!
    Now, if someone wants to upgrade to version 2, they'll do it by consciously changing
    their code, not having a version pulled out from under them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你通过简单地创建一个新版本来更改你的API！现在，如果有人想要升级到版本2，他们将通过有意识地更改他们的代码来完成，而不是版本被从他们手中夺走。
- en: Express makes this kind of separation pretty easy through its use of routers,
    which we saw in the previous chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Express 通过使用我们在上一章中看到的路由器，使这种分离变得非常容易。
- en: 'To create version 1 of your API, you can create a router that handles version
    1 exclusively. The file might be called api1.js and look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的API的版本1，你可以创建一个仅处理版本1的路由器。文件可能被称为api1.js，看起来像这样：
- en: Listing 6.5 Version 1 of your API, in api1.js
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 API的版本1，在api1.js中
- en: '`var express = require("express");`   `var api = express.Router();   #A`  
    `api.get("/timezone", function(req, res) {      #B` `  res.send("Sample response
    for /timezone");` `});`   `api.get("/all_timezones", function(req, res) { #B`
    `  res.send("Sample response for /all_timezones");` `});`  `module.exports = api; 
    #C`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var api = express.Router();   #A` `api.get("/timezone",
    function(req, res) {      #B` `  res.send("Sample response for /timezone");` `});`
    `api.get("/all_timezones", function(req, res) { #B` `  res.send("Sample response
    for /all_timezones");` `});` `module.exports = api;  #C`'
- en: '#A Create a new Router, a mini-application.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 创建一个新的路由器，一个迷你应用程序。'
- en: '#B These are just some example routes. You can add whatever routes or middleware
    you want to these routers.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这些只是一些示例路由。你可以向这些路由器添加任何你想要的路由或中间件。'
- en: '#C Export the router so that other files can use it.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 导出路由器，以便其他文件可以使用它。'
- en: Notice that "v1" doesn't appear anywhere in the routes. To use this router in
    your app, you'll create a full application and use the router from your main app
    code. It might look like Listing 6.6.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“v1”在路由中任何地方都没有出现。为了在你的应用中使用这个路由器，你需要创建一个完整的应用程序，并从主应用代码中使用路由器。它可能看起来像列表
    6.6。
- en: Listing 6.6 The main app code in app.js
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 app.js 中的主应用代码
- en: '`var express = require("express");`   `var apiVersion1 = require("./api1.js");  
    #A`   `var app = express();`   `app.use("/v1", apiVersion1);  #A`   `app.listen(3000,
    function() {` `  console.log("App started on port 3000");``});`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var apiVersion1 = require("./api1.js");  
    #A` `var app = express();` `app.use("/v1", apiVersion1);  #A` `app.listen(3000,
    function() {` `  console.log("App started on port 3000");``});`'
- en: '#A Require and use the router, like we saw in the previous chapter.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如前一章所示，需要并使用路由器。'
- en: Then, many moons later, you decide to implement version 2 of your API. It might
    live in api2.js. It'd also be a router, just like api1.js. It might look like
    Listing 6.7.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，过了很多个月后，你决定实现API的版本2。它可能位于 api2.js 中。它也会是一个路由器，就像 api1.js 一样。它可能看起来像列表 6.7。
- en: Listing 6.7 Version 2 of your API, in api2.js
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 API的版本2，在 api2.js 中
- en: '`var express = require("express");`   `var api = express.Router();`   `api.get("/timezone",
    function(req, res) {      #A` `  res.send("API 2: super cool new response for
    /timezone");` `});`  `module.exports = api;`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var api = express.Router();` `api.get("/timezone",
    function(req, res) {      #A` `  res.send("API 2: super cool new response for
    /timezone");` `});` `module.exports = api;`'
- en: '#A Once again, notice that these are just some example routes.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 再次注意，这些只是一些示例路由。'
- en: 'Now, to add version 2 of your API to the app, simply require and use it just
    like version 1:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将你的API的版本2添加到应用中，只需像版本1一样需要并使用它即可：
- en: Listing 6.8 The main app code in app.js
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 app.js 中的主应用代码
- en: '`var express = require("express");`   `var apiVersion1 = require("./api1.js");`
    `var apiVersion2 = require("./api2.js");   #A`   `var app = express();`   `app.use("/v1",
    apiVersion1);` `app.use("/v2", apiVersion2);  #A`   `app.listen(3000, function()
    {` `  console.log("App started on port 3000");``});`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var apiVersion1 = require("./api1.js");`
    `var apiVersion2 = require("./api2.js");   #A` `var app = express();` `app.use("/v1",
    apiVersion1);` `app.use("/v2", apiVersion2);  #A` `app.listen(3000, function()
    {` `  console.log("App started on port 3000");``});`'
- en: '#A Note the two new lines. It''s just like using version 1 of the router!'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意这两行新内容。这就像使用版本1的路由器！'
- en: You can try visiting these new URLs in your browser to make sure that the versioned
    API works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试在浏览器中访问这些新的URL，以确保版本化API工作。
- en: '![](../Images/06_04.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_04.png)'
- en: Figure 6.6 Testing the two API versions in your browser.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 在浏览器中测试你的两个API版本。
- en: You can also use the cURL tool to test your app at the command line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用cURL工具在命令行测试你的应用。
- en: '![](../Images/06_07.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_07.png)'
- en: Figure 6.7 Testing your versioned API using the cURL command-line tool.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 使用cURL命令行工具测试你的版本化API。
- en: As we saw in the previous chapter, routers let you segment different routes
    into different files. Versioned APIs are a great example of the utility of routers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，路由器允许你将不同的路由分割到不同的文件中。版本化API是路由器用途的一个很好的例子。
- en: 6.5     Setting HTTP status codes
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 设置HTTP状态码
- en: Every HTTP response comes with an HTTP status code. The most famous one is 404,
    which stands for "Resource Not Found". You've likely seen 404 errors when visiting
    a URL that the server can't find—maybe you've clicked an expired link or typed
    a URL wrong.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP响应都伴随着一个HTTP状态码。最著名的一个是404，代表“资源未找到”。当你访问服务器找不到的URL时，你很可能看到404错误——也许你点击了一个过期的链接或者输入了错误的URL。
- en: While 404 is the most famous, 200 is perhaps the most common, which is simply
    defined as "OK". Unlike 404, you don't usually see the text "200" on the webpage
    when you're browsing the web. Every time you successfully load a webpage or an
    image or a JSON response, you'll probably get a status code of 200.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然404是最著名的，但200可能是最常见的，它简单地定义为“OK”。与404不同，当你浏览网页时，你通常不会在网页上看到“200”文本。每次你成功加载一个网页、一个图片或一个JSON响应时，你可能会得到一个状态码200。
- en: It turns out that there are a lot more HTTP status codes than 404 and 200, each
    with a different meaning. There are a handful of 100 codes (like 100 and 101),
    several in the 200s, 300s, 400s, and 500s. The ranges aren't "filled"--that is,
    the first four codes are 100, 101, 102, and then it skips all the way to 200.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，HTTP 状态码比 404 和 200 多得多，每个都有不同的含义。有一小部分 100 码（如 100 和 101），以及 200s、300s、400s
    和 500s 中的几个。这些范围并不是“填满”的——也就是说，前四个码是 100、101、102，然后跳过所有码直接到 200。
- en: 'Each range has a certain theme. Steve Losh sent a great tweet that summarizes
    them (which I had to paraphrase a bit), as told from the perspective of the server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每个范围都有一个特定的主题。Steve Losh 发了一条很好的推文来总结它们（我不得不稍作改写），从服务器的角度讲述：
- en: 'HTTP status ranges in a nutshell:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码概述：
- en: '1xx: hold on'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 1xx：稍等
- en: '2xx: here you go'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 2xx：给你
- en: '3xx: go away'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx：走开
- en: '4xx: you messed up'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 4xx：你搞砸了
- en: '5xx: I messed up'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 5xx：我搞砸了
- en: '@stevelosh, https://twitter.com/stevelosh/status/372740571749572610'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '@stevelosh, https://twitter.com/stevelosh/status/372740571749572610'
- en: I love that summary. (The real one is a little more vulgar.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个总结。（真正的总结稍微有点粗俗。）
- en: 'Beyond the sixty-or-so codes in the specification (at [https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6) ),
    HTTP doesn''t define any more. You can specify your own—HTTP allows it—but it
    typically isn''t done. Remember the first principle of good API design: defining
    your own HTTP status codes wouldn''t be what people expect. People expect you
    to stick to the usual suspects.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范中的六十多个码（在 [https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6)）之外，HTTP
    没有定义更多。你可以指定自己的——HTTP 允许这样做——但通常不会这样做。记住好的 API 设计的第一个原则：定义自己的 HTTP 状态码不会是人们所期望的。人们期望你坚持使用常规的候选者。
- en: Wikipedia has a great list of every standard (and some nonstandard) HTTP response
    code at https://en.wikipedia.org/wiki/List_of_HTTP_status_codes, but there are
    a few that really pertain to building an API with Express. We'll go through each
    range (the 100s, then the 200s, etc) and explain some common HTTP codes you should
    be setting in your applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科有一个非常好的列表，列出了每个标准（以及一些非标准）的 HTTP 响应码，在 https://en.wikipedia.org/wiki/List_of_HTTP_status_codes，但有一些确实与使用
    Express 构建API有关。我们将逐一解释每个范围（100s，然后是 200s 等）以及你应在应用程序中设置的一些常见 HTTP 码。
- en: WHAT ABOUT HTTP 2? Most HTTP requests are HTTP 1.1 requests, with a handful
    of them still using version 1.0\. HTTP 2, the next version of the standard, is
    slowly being implemented and rolled out across the web. Luckily for us, most of
    the changes happen at a low level and you don't have to deal with them. It does
    define one new status code—421—but that shouldn't affect you much.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 2 怎么样？大多数 HTTP 请求都是 HTTP 1.1 请求，其中一小部分仍在使用版本 1.0。HTTP 2，这个标准的下一个版本，正在逐渐被实施并在互联网上推广。幸运的是，对我们来说，大多数变化都在底层发生，你不必处理它们。它确实定义了一个新的状态码——421，但这不会对你产生太大影响。
- en: But first, how do you set HTTP status codes in Express?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你如何在 Express 中设置 HTTP 状态码？
- en: 6.5.1  Setting HTTP status codes
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 设置 HTTP 状态码
- en: By default, the status code is 200\. If someone visits a URL where no resource
    is found and you don't have a handler for it, Express will send a 404 error. If
    you have some other error in your server, Express will send a 500 error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，状态码是 200。如果有人访问了一个找不到资源的 URL，而你又没有为其设置处理器，Express 将发送一个 404 错误。如果你服务器上有些其他错误，Express
    将发送一个 500 错误。
- en: But you want to have control of what status code you get, so Express gives it
    to you. Express adds a method called `status` to the HTTP response object. All
    you have to do is call it with the number of your status code and you'll be in
    business.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但你想要控制你得到的状态码，所以 Express 给了你这个功能。Express 向 HTTP 响应对象添加了一个名为 `status` 的方法。你只需要用你的状态码数字调用它，你就可以开始了。
- en: 'This method might be called like this inside of a request handler:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能在请求处理器内部被这样调用：
- en: Listing 6.9 Setting the HTTP status code in Express
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 在 Express 中设置 HTTP 状态码
- en: '`// …`   `res.status(404);`  `// …`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `res.status(404);` `// …`'
- en: This method is "chainable", so you can pair it with things like the `json` to
    set the status code and send some JSON in one line, as shown in Listing 6.10.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是可以“链式调用”的，所以你可以将它与像 `json` 这样的东西配对，以设置状态码并在一行中发送一些 JSON，如列表 6.10 所示。
- en: Listing 6.10 Setting the HTTP status code and sending some JSON
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 设置 HTTP 状态码和发送一些 JSON
- en: '`res.status(404).json({ error: "Resource not found!" });`   `// This is equivalent
    to:` `res.status(404);``res.json({ error: "Resource not found!" });`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(404).json({ error: "Resource not found!" });` `// 这相当于：` `res.status(404);`
    `res.json({ error: "Resource not found!" });`'
- en: The API isn't too complicated!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: API并不太复杂！
- en: 'Express extends the "raw" HTTP response object that Node gives you. While you
    should use the Express way when you''re using Express, you might be reading some
    code that sets the status code this way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Express扩展了Node提供的“原始”HTTP响应对象。当你使用Express时，你应该使用Express的方式，但你可能会看到一些这样设置状态码的代码：
- en: Listing 6.11 Setting the status code the "raw" way
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11以“原始”方式设置状态码
- en: '`res.statusCode = 404;`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.statusCode = 404;`'
- en: You sometimes see this code when reading through middleware, or when someone
    is using the "raw" Node APIs instead of the Express ones.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会在阅读中间件时看到这个代码，或者当有人使用“原始”Node API而不是Express API时。
- en: 6.5.2  The 100 range
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 100范围
- en: The 100 range is weird.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 100范围很奇怪。
- en: 'There are only two official status codes in the 100 range: 100 ("Continue")
    and 101 ("Switching Protocols"). You will likely never deal with these yourself.
    If you do, check the specification or the list on Wikipedia.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 100范围内的官方状态码只有两个：100（“继续”）和101（“切换协议”）。你很可能自己永远不会处理这些。如果你确实遇到了，请检查规范或维基百科上的列表。
- en: Look at that! Already one-fifth of the way through the status codes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看看！已经完成了状态码的五分之一。
- en: 6.5.3  The 200 range
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 200范围
- en: Steve Losh summarized the 200 range as "here you go". The HTTP spec defines
    several status codes in the 200 range, but four of them are by the most common.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Losh将200范围总结为“给你”。HTTP规范在200范围内定义了几个状态码，但最常见的有四个。
- en: '200: "OK"'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '200: “OK”'
- en: '200 is the most common HTTP status code on the web by a long shot. HTTP calls
    status code 200 "OK", and that''s pretty much what it means: everything about
    this request and response went through just fine.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 200是网络上最常见的HTTP状态码。HTTP将状态码200称为“OK”，这基本上就是它的意思：这个请求和响应的每一部分都进行得很顺利。
- en: Generally, if you're sending the whole response just fine and there aren't any
    errors or and redirects (which we'll see in the 300s section), then you'll send
    a 200 code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你发送整个响应都很顺利，没有错误或重定向（我们将在300s部分看到），那么你会发送200状态码。
- en: '201: "CREATED"'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '201: “已创建”'
- en: Code 201 is very similar to 200, but it's for a slightly different use case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码201与200非常相似，但它适用于稍微不同的用例。
- en: It's common for a request to create a resource (usually with a POST or a PUT
    request). This might be creating a blog post, sending a message, or uploading
    a photo. If the creation succeeds and everything's fine, and you'll want to send
    a 201 code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请求创建资源（通常是通过POST或PUT请求）是很常见的。这可能是在创建博客文章、发送消息或上传照片。如果创建成功且一切正常，你将想要发送201状态码。
- en: This is a little bit nuanced, but it's typically the correct status code for
    the situation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点微妙，但通常是这种情况的正确状态码。
- en: '202: "ACCEPTED"'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '202: “已接受”'
- en: Just like 201 is a variant on 200, 202 is a variant of 201.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像201是200的一个变体一样，202是201的一个变体。
- en: 'I hope I''ve beaten it into your head by now: asynchronousity is a big part
    of Node and Express. Sometimes, you''ll asynchronously queue a resource for creation
    but it won''t be created yet.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我现在已经把异步性是Node和Express的一个重要部分深深地印在你的脑海里了。有时，你会异步地排队创建资源，但资源可能还没有被创建。
- en: If you're pretty sure that the request is requesting to create a valid resource
    (perhaps you've checked that the data is valid) but you haven't created it yet,
    you can send a 202 status code. It effectively tells the client, "hey, you're
    all good, but I haven't made the resource yet."
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你相当确定请求是要求创建一个有效的资源（也许你已经检查了数据的有效性），但你还没有创建它，你可以发送202状态码。这实际上告诉客户端，“嘿，一切正常，但我还没有创建资源。”
- en: Sometimes you'll want to send 201 codes and other times you'll want to send
    202; it depends on the situation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你会想发送201状态码，而有时候你会想发送202状态码；这取决于具体情况。
- en: '204: "NO CONTENT"'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '204: “无内容”'
- en: 204 is the delete version of 201\. When you create a resource, you typically
    send a 201 or a 202 message. When you delete something, you often don't have anything
    to respond with other than "yeah, this was deleted". That's when you typically
    send a 204 code. There are a few other times when you don't need to send any kind
    of response back, but deletion is the most common use case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 204是201的删除版本。当你创建资源时，通常发送201或202消息。当你删除某些内容时，通常除了“是的，这已经被删除了”之外没有其他可以响应的内容。这就是你通常会发送204代码的时候。还有一些其他时候你不需要发送任何类型的响应，但删除是最常见的用例。
- en: 6.5.4  The 300 range
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4 300范围
- en: There are several status codes in the 300 range, but you'll really only set
    three of them, and they both involve redirects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 300范围内有几个状态码，但你实际上只会设置其中的三个，而且它们都涉及重定向。
- en: '301: "MOVED PERMANENTLY"'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '301: “永久移动”'
- en: HTTP status code 301 means "don't visit this URL any more; see another URL".
    301 responses are accompanied with an HTTP header called `Location`, so you know
    where to redirect to.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码301表示“不要访问这个URL anymore；查看另一个URL”。301响应伴随着一个名为`Location`的HTTP头，这样你知道要重定向到哪里。
- en: You've probably been browsing the web and have been redirected in your life—this
    probably happened because of a 301 code. This is usually because the page has
    moved.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在网上浏览过，并且在生活中被重定向过——这很可能是由于301代码。这通常是因为页面已移动。
- en: '303: "SEE OTHER"'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '303: “查看其他”'
- en: HTTP status code 303 is also a redirect, but it's a little bit different. Just
    like code 200 is for "regular" requests and 201 is for requests where a resource
    is created, 301 is for "regular" requests and 303 is for requests where a resource
    is created and you want to redirect to a new page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码303也是一个重定向，但它略有不同。就像200代码用于“常规”请求，201代码用于创建资源的请求一样，301代码用于“常规”请求，而303代码用于创建资源且希望重定向到新页面的请求。
- en: '307: "Temporary Redirect"'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '307: “临时重定向”'
- en: 'There''s one last redirect status code: 307\. Like the 301 code above, you''ve
    probably been browsing the web and been redirected because of a 307 code. They''re
    similar, but they have an important distinction.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一个重定向状态码：307。就像上面的301代码一样，你可能在网上浏览时被重定向过，这可能是由于307代码。它们很相似，但有一个重要的区别。
- en: Where 301 signals "don't visit this URL ever again; see another URL", 307 signals
    "see another URL just for now". This might be used for temporary maintenance on
    a URL.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当301信号表示“永远不要访问这个URL；查看另一个URL”时，307信号表示“暂时查看另一个URL”。这可能会用于对URL的临时维护。
- en: 6.5.5  The 400 range
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.5  400范围
- en: The 400 range is the largest, and it generally means that something about the
    request was bad. In other words, the client screwed something up and it's not
    the server's fault. There are a lot of different errors here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 400范围是最大的，通常意味着请求中有些东西是错误的。换句话说，客户端搞砸了，这不是服务器的错。这里有各种各样的错误。
- en: 401 AND 403 AUTHENTICATION ERRORS
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 401和403认证错误
- en: There are two different errors for failed client authentication, and they're
    401 ("Unauthorized") and 403 ("Forbidden"). The words "unauthorized" and "forbidden"
    sound pretty similar—what's the difference between those two?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于失败的客户端认证，有两种不同的错误，它们是401（“未授权”）和403（“禁止”）。这两个词“未授权”和“禁止”听起来很相似——这两个之间有什么区别？
- en: In short, a 401 error is when the user isn't logged in at all. A 403 error is
    when the user is logged in as a valid user, but they don't have permissions to
    do what they're trying to do.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，401错误是当用户根本未登录时。403错误是当用户以有效用户身份登录，但他们没有权限执行他们试图做的事情时。
- en: For example, imagine a website where you couldn’t see any of it unless you logged
    in. This website also has an administrator panel, but not all users can administer
    the site. Until you logged in, you'd see 401 errors. Once you logged in, you would
    stop seeing 401 errors. If you tried to visit the administrator panel as a non-admin
    user, you'd see 403 errors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个网站，除非你登录，否则你什么也看不到。这个网站还有一个管理员面板，但不是所有用户都可以管理网站。在你登录之前，你会看到401错误。一旦你登录，你就不会再看到401错误。如果你以非管理员用户身份尝试访问管理员面板，你会看到403错误。
- en: Send these response codes when the user isn't authorized to do whatever they're
    doing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户无权执行他们正在做的事情时，发送这些响应代码。
- en: '404: "NOT FOUND"'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '404: “未找到”'
- en: I don't think I have to tell you much about 404—you've probably run into it
    when browsing the web. One thing I found a little surprising about 404 errors
    is that you can visit a valid route but still get a 404 error.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我不用多说什么关于404——你可能在浏览网页时遇到过。我发现404错误有一点令人惊讶的是，你可以访问一个有效的路由，但仍然得到404错误。
- en: 'For example, let''s say you want to visit a user''s page. The homepage for
    User #123 is at /users/123\. But if you mistype and visit /users/1234 and no user
    exists with ID 1234, then you''d get a 404 error.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想访问一个用户的页面。用户#123的主页在/users/123。但如果你打错了，访问了/users/1234，并且没有ID为1234的用户，那么你会得到一个404错误。
- en: OTHER ERRORS
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其他错误
- en: There are a lot of other client errors you can run into—far too many to enumerate
    here. Visit the list of status codes at [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to
    find the right status code for you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到很多其他的客户端错误——太多以至于无法在这里一一列举。访问[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)的状态码列表，以找到适合你的正确状态码。
- en: When in doubt, though, send a 400 "Bad Request" error. It's a generic response
    to any kind of bad request, and encompasses anything. Typically, it means that
    the request has malformed input—a missing parameter, for example. While there
    might be a status code that better describes the client error, 400 will do the
    trick when you're not sure which one to choose.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不确定，发送一个 400 “错误请求”错误。它是对任何类型错误请求的通用响应，包括任何内容。通常，这意味着请求有格式错误的输入——例如缺少参数。虽然可能有一个更好地描述客户端错误的状态码，但在你不确定选择哪个时，400
    会是一个不错的选择。
- en: 6.5.6  The 500 range
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6  500 范围
- en: 'The final range in the HTTP specification is the 500 range, and while there
    are several errors in here, the most important one is 500: "Internal Server Error".
    Unlike 400 errors, which are the client''s fault, 500 errors are the server''s fault.
    This can be any number of things, from an exception to a broken connection to
    a database.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 规范中的最后一个范围是 500 范围，虽然这里有几个错误，但最重要的是 500：“内部服务器错误”。与 400 错误不同，那是客户端的责任，500
    错误是服务器的责任。这可能包括任何问题，从异常到数据库的断开连接。
- en: Ideally, you should never be able to cause a 500 error from the client—that
    means that your client can cause bugs in your server.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你永远不应该能够从客户端引起 500 错误——这意味着你的客户端可以导致你的服务器出现错误。
- en: If you catch an error and it really does seem to be your fault, then you can
    respond with a 500 error. Unlike the rest of the status codes where you want to
    be as descriptive as possible, it's often better to be vague and say "Internal
    Server Error", that way hackers can't know where the weaknesses in your system
    lie. We'll talk much more about this in Chapter 9 when we talk about security.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你捕获到一个错误，并且它确实看起来是你的责任，那么你可以响应一个 500 错误。与你想尽可能详细描述的其他状态码不同，通常最好是含糊其辞，说“内部服务器错误”，这样黑客就无法知道你系统中存在的弱点。我们将在第
    9 章讨论安全问题时更多地讨论这一点。
- en: 6.6     Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6     总结
- en: 'In this chapter, you learned:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: '·  How to use Express to build an API: parsing responses with routing and route
    parameters, choosing status codes with `res.status`, and sending JSON with `res.json`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Express 构建 API：使用路由和路由参数解析响应，使用 `res.status` 选择状态码，以及使用 `res.json` 发送
    JSON。
- en: ·  The HTTP methods and how they respond to common CRUD operations (Create =
    POST, Read = GET, Update = PUT, Delete = DELETE).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ·  HTTP 方法及其如何响应常见的 CRUD 操作（创建 = POST，读取 = GET，更新 = PUT，删除 = DELETE）。
- en: '·  How to version your API using Express''s routers: create routers for each
    API version and then `use` them in your main application'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Express 的路由器来版本化你的 API：为每个 API 版本创建路由器，然后在你的主应用程序中使用它们
- en: '·  What HTTP status codes are and what they mean. Remember Steve Losh''s tweet:
    100 means "hold on", 200 is "here you go", 300 is "go away", 400 is "you messed
    up", and 500 is "I messed up".'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ·  HTTP 状态码是什么以及它们的含义。记住史蒂夫·洛什的推文：100 表示“稍等”，200 表示“给你”，300 表示“走开”，400 表示“你搞砸了”，500
    表示“我搞砸了”。
