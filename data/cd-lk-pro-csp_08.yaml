- en: 5 Setting up a project and database with Entity Framework Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Entity Framework Core 设置项目和数据库
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Refactoring a legacy codebase to be clean and secure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构遗留代码库以使其整洁和安全
- en: Using Entity Framework Core to query a database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Entity Framework Core 查询数据库
- en: Implementing the repository/service pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现存储库/服务模式
- en: Creating a new .NET 5 solution and project using the command line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行创建新的 .NET 5 解决方案和项目
- en: 'The time has finally come. You are probably eager to fix some of the issues
    we saw in chapters 3 and 4, and now we’ll get to do that. First things first,
    let’s come up with a game plan on how to tackle this refactoring. We already know
    a couple of things that we need to do differently:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 时机终于到了。你可能急于修复第 3 章和第 4 章中我们看到的一些问题，现在我们将着手解决这些问题。首先，让我们制定一个如何处理这个重构的计划。我们已经知道我们需要做一些不同的事情：
- en: In chapter 3 we were told to use .NET 5 instead of the .NET Framework for the
    new version of the Flying Dutchman Airlines service.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 3 章中，我们被告知使用 .NET 5 而不是 .NET 框架来创建飞荷兰人航空公司服务的新版本。
- en: We need to rewrite the endpoints to be clean code (in particular, adhering to
    the DRY principle).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要重写端点以实现整洁的代码（特别是遵守 DRY 原则）。
- en: We need to fix the security vulnerability—a hardcoded connection string.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要修复安全漏洞——硬编码的连接字符串。
- en: The object names do not match the database column names. We should fix that
    to ensure a perfect isomorphic relationship between the codebase and the database.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象名称与数据库列名称不匹配。我们应该修复这个问题，以确保代码库和数据库之间完美的同构关系。
- en: We need to adhere to the OpenAPI file discussed in chapter 3 and shown in appendix
    D.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要遵守第 3 章中讨论的 OpenAPI 文件和附录 D 中展示的。
- en: 'Although not necessarily part of the requirements, we would like to include
    some additional deliverables to improve the quality of the job, thus ensuring
    a job well done:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不一定属于需求的一部分，但我们希望包含一些额外的可交付成果以提高工作质量，从而确保工作做得很好：
- en: We want to use test-driven development to write unit tests that back the codebase.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望使用测试驱动开发来编写支持代码库的单元测试。
- en: We want to use Entity Framework Core to revamp the database layer by reverse-engineering
    the deployed database.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望使用 Entity Framework Core 通过逆向工程已部署的数据库来翻新数据库层。
- en: We want to autogenerate an updated OpenAPI file on the launch of the service
    to compare against the provided OpenAPI from FlyTomorrow.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望在服务启动时自动生成更新的 OpenAPI 文件，以便与提供的来自 FlyTomorrow 的 OpenAPI 进行比较。
- en: 'Of course, we will do much more than just these improvements, but it is good
    to have some general broad strokes in mind. We are also in a very interesting
    position: we are stuck somewhere in the middle of having to keep the old codebase
    alive and working and greenfield development.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将做更多的工作，但有一些一般性的大致方向是好的。我们还处于一个非常有趣的位置：我们被困在必须保持旧代码库活跃和工作的中间，同时进行绿色场开发。
- en: DEFINITION *Greenfield development* means that we are working on a project that
    isn’t held back by any previous design decisions or old code. In practice, this
    usually means a brand-new project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *绿色场开发* 意味着我们正在处理一个不受任何先前设计决策或旧代码限制的项目。在实践中，这通常意味着一个全新的项目。
- en: We have set requirements and an old codebase that we need to mimic (where appropriate
    and possible), but we also start with an empty project. In the real world, you
    will often encounter this scenario. You no doubt have had the experience of trying
    to create a new version of an existing product—a “next-gen” version, if you will.
    Figure 5.1 shows where we are in the scheme of the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设定了要求和一个旧代码库，我们需要模仿（在适当和可能的情况下），但我们也是从一个空项目开始的。在现实世界中，你经常会遇到这种情况。毫无疑问，你有过尝试创建现有产品新版本的体验——如果你愿意，可以称之为“下一代”版本。图
    5.1 展示了我们在本书方案中的位置。
- en: '![](../Images/05_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05_01.png)'
- en: Figure 5.1 In this chapter, we’ll start the process of reimplementing the Flying
    Dutchman Airlines codebase. We’ll start with the database access layer. In the
    following chapters, we’ll look at the repository layer, service layer, and controller
    layer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 在本章中，我们将开始重新实现飞荷兰人航空公司代码库的过程。我们将从数据库访问层开始。在接下来的章节中，我们将查看存储库层、服务层和控制层。
- en: Our first order of business is to create a new .NET 5 solution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是创建一个新的 .NET 5 解决方案。
- en: 5.1 Creating a .NET 5 solution and project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 创建 .NET 5 解决方案和项目
- en: 'In this section, we’ll create a new .NET 5 solution and project. We’ll also
    look at what predefined solution and project templates exist for .NET 5\. You
    have the following two ways to create a new .NET 5 solution:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的.NET 5解决方案和项目。我们还将查看.NET 5中存在哪些预定义的解决方案和项目模板。您有以下两种创建新的.NET 5解决方案的方法：
- en: You can use a command line, be it the Windows command line or a macOS/ Linux
    terminal.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用命令行，无论是Windows命令行还是macOS/Linux终端。
- en: You can use an IDE like Visual Studio. Using Visual Studio automates the process
    somewhat. Most things you can do in a command line or terminal with C# you can
    also do in Visual Studio with a couple of clicks.[¹](#pgfId-1182607)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用像Visual Studio这样的IDE。使用Visual Studio可以在一定程度上自动化这个过程。您可以在命令行或终端中用C#做的几乎所有事情，您也可以在Visual
    Studio中通过几个点击来完成。[¹](#pgfId-1182607)
- en: 'The outcome of using either route is the same: you end up with a new .NET 5
    solution. We’ll be using the command line. Creating a new, empty .NET 5 solution
    or project is very simple, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种途径的结果是相同的：您最终会得到一个新的.NET 5解决方案。我们将使用命令行。创建一个新的空.NET 5解决方案或项目非常简单，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: NOTE Before you attempt to create a .NET 5 project, please make sure you have
    installed the latest .NET 5 SDK and runtime. Installation instructions are in
    appendix C.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在尝试创建.NET 5项目之前，请确保您已安装最新的.NET 5 SDK和运行时。安装说明见附录C。
- en: 'We can use a variety of templates. Some of the more common ones are `web`,
    `webapp`, `mvc`, and `webapi`. For our purposes, we use perhaps two of the most
    popular of all: `sln` and `console`. The `dotnet new sln` command creates a new
    solution, whereas `dotnet new console` creates a new project and a “hello, world”
    source file. As discussed in section 3.3.2, C# uses solutions and projects to
    organize its codebases. A solution is the top-level entity and contains multiple
    projects. We write our logic within the projects. Projects can be thought of as
    different modules, packages, or libraries, depending on our language of preference.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种模板。其中一些更常见的有`web`、`webapp`、`mvc`和`webapi`。就我们的目的而言，我们使用可能是最受欢迎的两个：`sln`和`console`。`dotnet
    new sln`命令创建一个新的解决方案，而`dotnet new console`则创建一个新的项目和“hello, world”源文件。如第3.3.2节所述，C#使用解决方案和项目来组织其代码库。解决方案是顶级实体，包含多个项目。我们在项目中编写我们的逻辑。项目可以被视为不同模块、包或库，具体取决于我们偏好的语言。
- en: '![](../Images/05_01_UN01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05_01_UN01.png)'
- en: We also pass the `-n` flag along with the creation command. This allows us to
    specify a name for our solution and project. If we do not explicitly specify a
    name for our solution, the name of our project or solution defaults to the name
    of the folder in which we create the files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过创建命令传递了`-n`标志。这允许我们为我们的解决方案和项目指定一个名称。如果我们没有明确指定解决方案的名称，我们的项目或解决方案的名称将默认为创建文件的文件夹名称。
- en: To create our starting point, run the following command. Note that the command-line
    tool does not let you create a new solution folder when creating a new solution.
    If you want to do this, you can either use Visual Studio (which does allow for
    it) or create the folder first and then run the following command in the solution
    folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的起点，请运行以下命令。请注意，命令行工具在创建新解决方案时不允许您创建新的解决方案文件夹。如果您想这样做，您可以使用Visual Studio（它允许这样做）或首先创建文件夹，然后在解决方案文件夹中运行以下命令。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The command creates only one thing: a solution file called `FlyingDutchmanAirlinesNextGen.sln`,
    shown in figure 5.2\. We could open this solution file in Visual Studio, but we
    cannot do much without a project.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令只创建了一件事：一个名为`FlyingDutchmanAirlinesNextGen.sln`的解决方案文件，如图5.2所示。我们可以在这个解决方案文件中打开Visual
    Studio，但没有项目我们无法做很多事情。
- en: '![](../Images/05_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05_02.png)'
- en: Figure 5.2 After running the command to create a new .NET solution, the command
    line lets us know that the operation was successful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 运行创建新的.NET解决方案的命令后，命令行会告诉我们操作已成功。
- en: Now that we have a solution file, we should create a project called FlyingDutchmanAirlines.
    To create a new project, we use the `console` template, as shown next. This creates
    a .NET 5 console application, which we’ll then change to be a web service.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了解决方案文件，我们应该创建一个名为FlyingDutchmanAirlines的项目。要创建一个新的项目，我们使用`console`模板，如下所示。这会创建一个.NET
    5控制台应用程序，然后我们将将其更改为一个网络服务。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After running the command, we are greeted by a message saying that “`Restore
    succeeded.`” A restore is a process that the .NET CLI performs before the creation
    of a new project and before compiling after a “clean” operation (“clean” deletes
    all local executable files, including dependencies) or first compilation, to gather
    required dependencies. We can also run this command on its own by saying
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们会看到一个消息说“`Restore succeeded.`”。恢复是.NET CLI在创建新项目之前以及在“clean”操作（“clean”删除所有本地可执行文件，包括依赖项）之后编译之前执行的过程（“clean”删除所有本地可执行文件，包括依赖项）或第一次编译，以收集所需的依赖项。我们也可以通过以下方式单独运行此命令：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A restore can come in handy when dealing with dependency troubles. The `restore`
    command also creates a new folder next to our solution file called FlyingDutchmanAirlines
    (the same as the project name we passed in), as shown in figure 5.3\. When we
    enter the folder, we see another folder called obj. The obj folder contains configuration
    files for NuGet and its packages. Back in the root folder for the project, we
    have a project file and a C# source file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理依赖问题的时候，恢复操作可能会很有用。`restore`命令还会在我们解决方案文件旁边创建一个新的文件夹，名为FlyingDutchmanAirlines（与传递给我们的项目名称相同），如图5.3所示。当我们进入文件夹时，我们会看到一个名为obj的文件夹。obj文件夹包含NuGet及其包的配置文件。回到项目的根目录，我们有一个项目文件和一个C#源文件。
- en: '![](../Images/05_03.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3](../Images/05_03.png)'
- en: Figure 5.3 The folder structure after running the command-line commands to create
    a solution and project. The FlyingDutchmanAirlines folder was created using the
    command to create a project, whereas the FlyingDutchmanAirlinesNextGen.sln file
    was created using the command to create a new solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 运行创建解决方案和项目的命令行命令后的文件夹结构。FlyingDutchmanAirlines文件夹是通过创建项目的命令创建的，而FlyingDutchmanAirlinesNextGen.sln文件是通过创建新解决方案的命令创建的。
- en: 'Our project is created, but we still need to add it to the solution. When you
    create a project, `dotnet` does not scan any subdirectories looking for a contained
    solution. To add a project to a solution, use the “solution add” command as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经创建，但我们还需要将其添加到解决方案中。当您创建一个项目时，`dotnet`不会扫描任何子目录以查找包含的解决方案。要向解决方案添加项目，请使用以下“solution
    add”命令：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `[SOLUTION PATH]` points to the path of the solution file to which you want
    to add a project. The `[PROJECT PATH]`, similarly, points to a csproj file to
    be added to the solution. You can add multiple projects at the same time by adding
    multiple `[PROJECT PATH]` arguments to the command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`[SOLUTION PATH]`指向您想要添加项目的解决方案文件的路径。同样地，`[PROJECT PATH]`指向要添加到解决方案中的csproj文件。您可以通过向命令添加多个`[PROJECT
    PATH]`参数来同时添加多个项目。'
- en: '![](../Images/05_03_UN02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3](../Images/05_03_UN02.png)'
- en: 'In our situation, running from the root FlyingDutchmanAirlinesNextGen folder,
    the command takes just the one csproj into account, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，从根目录FlyingDutchmanAirlinesNextGen运行，命令只考虑了一个csproj，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The terminal lets us know with a message—``Project `FlyingDutchmanAirlines\
    FlyingDutchmanAirlines.csproj` added to the solution``.—that we were successful
    in our effort. If we open up the FlyingDutchmanAirlinesNextGen.sln file in a text
    editor, we see a reference to the FlyingDutchmanAirlines.csproj file as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 终端通过一条消息——“`Project `FlyingDutchmanAirlines\ FlyingDutchmanAirlines.csproj`
    added to the solution`”——告诉我们我们的努力是成功的。如果我们用文本编辑器打开FlyingDutchmanAirlinesNextGen.sln文件，我们会看到如下所示的FlyingDutchmanAirlines.csproj文件的引用：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the reference added by the `solution add` command. The reference tells
    an IDE and the compiler that there is a project with the name FlyingDutchmanAirlines
    as part of this solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`solution add`命令添加的引用。该引用告诉IDE和编译器，在这个解决方案中有一个名为FlyingDutchmanAirlines的项目。
- en: 5.2 Setting up and configuring a web service
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 设置和配置一个网络服务
- en: In section 5.1 we created a new solution and project to use for the next-gen
    version of the Flying Dutchman Airlines service. In this section, we’ll look at
    the source code generated as a result of the actions we took in section 5.1 and
    configure the console application to function as a web service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.1节中，我们创建了一个新的解决方案和项目，用于使用飞荷兰人航空公司服务的下一代版本。在本节中，我们将查看5.1节中采取行动生成的源代码，并配置控制台应用程序以作为网络服务运行。
- en: The only source file in the solution (and project) at this point is Program.cs,
    shown in the next listing. This file is automatically generated through the `console`
    template we used in section 5.1 to create a new project. It contains the entry
    point for the program—a `static` method called `Main`—which returns nothing. Here,
    it also accepts a string array called `args`. This array contains any command-line
    arguments passed in on launch.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，解决方案（和项目）中只有一个源文件，即 Program.cs，如下一列表所示。此文件是通过我们在第 5.1 节中创建新项目时使用的 `console`
    模板自动生成的。它包含程序的入口点——一个返回无值的 `static` 方法，称为 `Main`——它接受一个名为 `args` 的字符串数组。此数组包含在启动时传递的任何命令行参数。
- en: Listing 5.1 Program.cs with the `Main` method
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 包含 `Main` 方法的 Program.cs
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ A static void Main is the default entry point for a C# console application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `static void Main` 是 C# 控制台应用程序的默认入口点。
- en: 'Using the command line to run the FlyingDutchmanAirlinesNextGen project, it
    outputs “Hello World!” to the console. Let’s remove the `"Hello World!"` string
    from the code. This puts us in a good spot to change the console application to
    something more functional: a web service.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行运行 FlyingDutchmanAirlinesNextGen 项目，它会在控制台输出“Hello World！”让我们从代码中移除 `"Hello
    World!"` 字符串。这使我们处于一个很好的位置，可以将控制台应用程序更改为更实用的东西：一个 Web 服务。
- en: 5.2.1 Configuring a .NET 5 web service
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 配置 .NET 5 Web 服务
- en: We need to configure our brand-new .NET 5 app to accept HTTP requests and route
    them to the endpoints we’ll implement. To do this, we also need to set up `Host`,
    which is the underlying process that runs the web service and interacts with the
    CLR. Our application lives inside the `Host`, which in turn lives inside the CLR.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置我们的全新 .NET 5 应用程序以接受 HTTP 请求并将它们路由到我们将要实现的端点。为此，我们还需要设置 `Host`，这是运行 Web
    服务并与 CLR 交互的底层进程。我们的应用程序位于 `Host` 内，而 `Host` 又位于 CLR 内。
- en: NOTE We can draw similarities between web containers (such as IIS) and Tomcat.
    To put it in Java terms, .NET 5 is your JVM and Spring, whereas `Host` is your
    Tomcat.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可以将 Web 容器（如 IIS）与 Tomcat 进行比较。用 Java 术语来说，.NET 5 是你的 JVM 和 Spring，而 `Host`
    是你的 Tomcat。
- en: We configure `Host` to launch a “host process” that is responsible for app startup
    and lifetime management. We also tell `Host` that we want to use `WebHostDefaults`.
    This allows us to use `Host` for a web service, as shown in figure 5.4\. At a
    minimum, the host configures the server and request-processing pipeline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置 `Host` 以启动一个负责应用程序启动和生命周期管理的“宿主进程”。我们还告诉 `Host` 我们想使用 `WebHostDefaults`。这允许我们使用
    `Host` 来实现 Web 服务，如图 5.4 所示。至少，宿主配置了服务器和请求处理管道。
- en: '![](../Images/05_04.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05_04.png)'
- en: Figure 5.4 A web service runs inside the `Host`, which runs inside the CLR.
    This model allows the CLR to spin up a `Host` that can execute our web service.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 一个 Web 服务在 `Host` 内运行，而 `Host` 又在 CLR 内运行。这种模型允许 CLR 启动一个可以执行我们的 Web 服务的
    `Host`。
- en: 'My preferred way of configuring the `Host` in .NET 5\. is to follow these three
    steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 .NET 5 中配置 `Host` 的首选方法是遵循以下三个步骤：
- en: Use the `CreateDefaultBuilder` method on the static `Host` class (part of the
    `Microsoft.Extensions.Hosting` namespace) to create a builder.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态 `Host` 类（`Microsoft.Extensions.Hosting` 命名空间的一部分）上的 `CreateDefaultBuilder`
    方法来创建一个构建器。
- en: Configure the `Host` builder by telling it we want to use `WebHostDefaults`
    and set a startup class and a startup URL with a port specified.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过告诉 `Host` 构建器我们想使用 `WebHostDefaults` 并设置一个带有指定端口的启动类和启动 URL 来配置 `Host`。
- en: Build and run the built `Host` instance.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行构建的 `Host` 实例。
- en: 'When we try to configure a startup class for our builder’s returned `Host`
    instance, we have to use the `UseStartup` class. This comes as part of ASP.NET,
    which is not installed through .NET 5 by default. To access this functionality
    (and anything in ASP.NET), we need to add the `ASP.NET` package to the FlyingDutchmanAirlines
    project. We can do this through the NuGet package manager in Visual Studio or
    through our trusty command line when we are inside the project folder, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试为构建器返回的 `Host` 实例配置启动类时，我们必须使用 `UseStartup` 类。这作为 ASP.NET 的一部分，默认情况下不是通过
    .NET 5 安装的。为了访问此功能（以及 ASP.NET 中的任何内容），我们需要将 `ASP.NET` 包添加到 FlyingDutchmanAirlines
    项目中。我们可以通过 Visual Studio 中的 NuGet 包管理器或在我们处于项目文件夹内时通过我们信任的命令行来完成此操作，如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After executing the command, the command line lets you know that the package
    was successfully added to the project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，命令行会通知您已成功将包添加到项目中。
- en: NOTE The command also executes a `restore` action. For more details on `restore`,
    see section 5.1.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：该命令还执行了一个 `restore` 操作。有关 `restore` 的更多详细信息，请参阅第 5.1 节。
- en: 'If we try to build the project now, we get a warning saying that we should
    be using a framework reference instead of a package reference. This is due to
    some shuffling that went on with .NET namespaces in the last couple of years.
    This warning doesn’t prohibit us from using the code as it is now, but we can
    get rid of it pretty easily. In a text editor such as Notepad++ or (for the brave)
    Vim, open the FlyingDutchmanAirlines.csproj file. In that file, add the boldface
    code and remove the package reference to ASP.NET:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试构建项目，我们会收到一个警告，说我们应该使用框架引用而不是包引用。这是由于在过去的几年中.NET命名空间发生的一些变动。这个警告不会阻止我们使用当前的代码，但我们可以很容易地消除它。在一个文本编辑器，如Notepad++或（对于勇敢者）Vim中，打开FlyingDutchmanAirlines.csproj文件。在那个文件中，添加粗体代码并移除对ASP.NET的包引用：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that the `Microsoft.AspNetCore` package is installed (as a framework reference),
    and we got rid of the compiler warning, we can use ASP.NET functionality. The
    first thing we want to do is tell the compiler we want to use the `AspNetCore.Hosting`
    namespace, as shown in the next listing. In this book, the namespace imports are
    often omitted from code listings. This is done because they take up precious space
    and can be autopopulated in most IDEs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Microsoft.AspNetCore` 包已安装（作为框架引用），并且我们消除了编译器警告，我们可以使用ASP.NET功能。我们首先想告诉编译器我们想要使用
    `AspNetCore.Hosting` 命名空间，如下一列表所示。在这本书中，命名空间导入通常从代码列表中省略。这样做是因为它们占用宝贵的空间，并且可以在大多数IDE中自动填充。
- en: Listing 5.2 Program.cs with no `“Hello,` `World!”` output
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 Program.cs 无“Hello, World!”输出
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ We use the Microsoft.AspNetCore.Hosting namespace.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用 Microsoft.AspNetCore.Hosting 命名空间。
- en: ❷ We no longer output “Hello, World!” to the console.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们不再将“Hello, World!”输出到控制台。
- en: 5.2.2 Creating and using HostBuilder
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 创建和使用 HostBuilder
- en: In this section, we’ll
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将
- en: Create an instance of `HostBuilder`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `HostBuilder` 的实例。
- en: Say we want to use the `Host` as a web service.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想将 `Host` 作为Web服务使用。
- en: Set the startup URL to be [http://0.0.0.0:8080](http://0.0.0.0:8080)`.`
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将启动URL设置为 [http://0.0.0.0:8080](http://0.0.0.0:8080)`。
- en: Build an instance of `Host` using `HostBuilder`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `HostBuilder` 构建 `Host` 的实例。
- en: Run the `Host`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `Host`。
- en: '![](../Images/05_04_UN03.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05_04_UN03.png)'
- en: 'In the program’s `Main` method, we add a call to `Host.CreateDefaultBuilder`.
    This call returns a `HostBuilder,` with some defaults already. We then tell the
    resulting builder we want to use a specific URL and port by calling `UseUrls`.
    Then we call `Build` to build and return the actual `Host`. We assign the output
    to a variable of type `IHost`. We assign our new `Host` to an explicitly typed
    variable of type `IHost`. Finally, the code starts the `Host` by calling `host.Run()`,
    as shown next:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的 `Main` 方法中，我们添加了对 `Host.CreateDefaultBuilder` 的调用。这个调用返回一个带有一些默认设置的 `HostBuilder`。然后我们通过调用
    `UseUrls` 告诉结果构建器我们想要使用特定的URL和端口。然后我们调用 `Build` 来构建并返回实际的 `Host`。我们将输出分配给一个类型为
    `IHost` 的变量。我们将我们的新 `Host` 分配给一个显式类型为 `IHost` 的变量。最后，代码通过调用 `host.Run()` 启动 `Host`，如下所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you try to compile and run the service in this state, the service launches
    but then terminates with an `InvalidOperationException`. This exception tells
    us we do not have a `Startup` class configured and tied to the `Host`. But before
    we create this `Startup` class, let’s leave the `Program` class in the best shape
    possible. We have our `Host` creation and call to `Run` in the `Main` method,
    but should it really be in there?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试以当前状态编译和运行该服务，服务会启动然后以 `InvalidOperationException` 异常终止。这个异常告诉我们我们没有配置并绑定到
    `Host` 的 `Startup` 类。但在我们创建这个 `Startup` 类之前，让我们让 `Program` 类保持最佳状态。我们在 `Main`
    方法中有 `Host` 的创建和调用 `Run` 的操作，但它真的应该在那里吗？
- en: 'In section 1.4, we discussed the importance of writing methods that read like
    a narrative. If I am a new developer, looking at a public method (in this case
    `Main`), I probably do not care about implementation details. Instead, I want
    to get an understanding of the broad strokes of what the method does. To that
    end, we can extract the initialization and assignment of `host` and the call to
    `host.Run` into a separate, private method as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4节中，我们讨论了编写像叙事一样阅读的方法的重要性。如果我是新开发者，看到公开的方法（在这种情况下是 `Main`），我可能不会关心实现细节。相反，我想了解这个方法的大致功能。为此，我们可以将
    `host` 的初始化和赋值以及调用 `host.Run` 的操作提取到一个单独的私有方法中，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Having extracted the `Host` creation logic into a separate method is a good
    step, but we can do just a bit more. We should consider two other things. First,
    we don’t need to store the result of the `HostBuilder` in a variable, because
    we use it only to call `Run`. Why don’t we just call `Run` directly after `Build`
    and avoid the unnecessary memory assignment, as shown next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Host`创建逻辑提取到单独的方法中是一个好步骤，但我们还可以做更多。我们应该考虑两件事。首先，我们不需要将`HostBuilder`的结果存储在变量中，因为我们只使用它来调用`Run`。为什么我们不在`Build`之后直接调用`Run`，以避免不必要的内存分配，如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| ![](../Images/LightBulb.png)   | The second thing we should consider is changing
    the method to an “expression” method, as shown next. Similar to a lambda expression,
    an expression method uses `=>` notation to indicate that the method will evaluate
    the expression to the right of the => and return its result. You can think of
    the `=>` operator as a combination of assignment and evaluation algebraically
    (`=`) and a return statement (`>`). Lambda expressions may look a bit funny at
    first, but the more you see them, the more you want to use them. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 我们应该考虑的第二件事是将方法更改为“表达式”方法，如下所示。类似于lambda表达式，表达式方法使用`=>`符号来表示该方法将评估`=>`右侧的表达式并返回其结果。您可以将`=>`运算符视为赋值和评估代数（`=`）以及返回语句（`>`）的组合。Lambda表达式一开始可能看起来有点奇怪，但随着您看到的越来越多，您就越想使用它们。|'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'How does this impact our `Main` method? Not much. All we have to do is call
    the `InitializeHost` method as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们`Main`方法有什么影响？不大。我们只需按照以下方式调用`InitializeHost`方法：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our code is clean and readable, but we still have that runtime exception to
    deal with. Clean code is nice, but if it doesn’t have the required functionality,
    it isn’t good enough. The exception said that we need to register a `Startup`
    class with the `HostBuilder` before we build and run the resulting `IHost`. I
    guess we have no choice but to make that our next item of work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码干净且易于阅读，但我们仍然需要处理那个运行时异常。干净的代码很好，但如果它没有所需的功能，那就不够好了。异常表示我们在构建和运行生成的`IHost`之前需要使用`HostBuilder`注册一个`Startup`类。我想我们别无选择，只能将其作为我们下一个工作项目。
- en: 5.2.3 Implementing the Startup class
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 实现Startup类
- en: 'We do not have a `Startup` class yet, but we can remedy that by creating a
    file called Startup.cs (in the project’s root folder is fine for this purpose)
    as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有`Startup`类，但我们可以通过创建一个名为Startup.cs的文件（在项目的根文件夹中即可）来解决这个问题，如下所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To configure our `Startup` class, create a `Configure` method in the `Startup`
    class. This method is called by the `HostBuilder` and contains a crucial configuration
    option, shown in the next listing, which allows us to use controllers and endpoints.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的`Startup`类，在`Startup`类中创建一个`Configure`方法。该方法由`HostBuilder`调用，并包含一个关键的配置选项，如下一列表所示，它允许我们使用控制器和端点。
- en: Listing 5.3 Startup.cs `Configure` method
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 Startup.cs `Configure`方法
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Uses routing and makes routing decisions for the service in this class
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用路由并在此类中为服务做出路由决策
- en: ❷ Uses an endpoint pattern for routing web requests. MapControllers scans and
    maps all the controllers in our service.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用端点模式进行路由Web请求。MapControllers扫描并映射我们服务中的所有控制器。
- en: 'The small method in listing 5.3 is the core of our configuration code. When
    `UseRouting` is called, we tell the runtime that certain routing decisions for
    the service are made in this class. If we did not have the call to `UseRouting`,
    we would not be able to hit any endpoint. `UseEndpoints` does what it says it
    does: it allows us to use and specify endpoints. It takes in an argument of a
    type we have not encountered before: `Action`. This is an instance of a delegate.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3中的小方法是我们的配置代码的核心。当调用`UseRouting`时，我们告诉运行时，某些服务路由决策是在这个类中做出的。如果我们没有调用`UseRouting`，我们就无法访问任何端点。`UseEndpoints`做的是它所说的：它允许我们使用和指定端点。它接受一个我们之前未遇到的类型作为参数：`Action`。这是一个代理的实例。
- en: Delegates and anonymous methods
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代理和匿名方法
- en: A delegate provides a way to reference a method. It is also type-safe, so it
    can point only to a method with a given signature. The delegate can be passed
    around to other methods and classes and then invoked when wanted. They are often
    used as callbacks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代理提供了一种引用方法的方式。它也是类型安全的，因此它只能指向具有给定签名的某个方法。代理可以被传递到其他方法和类中，然后在需要时调用。它们通常用作回调。
- en: 'You can create delegates in one of the following three ways:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下三种方式之一创建代理：
- en: Using the `delegate` keyword
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`delegate`关键字
- en: Using an anonymous method
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名方法
- en: Using a lambda expression
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: 'The oldest way of creating them is by explicitly declaring a type of `delegate`
    and creating a new instance of that delegate by assigning a method to the delegate
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建它们的最早方式是显式声明一个`delegate`类型，并通过将方法分配给委托来创建该委托的新实例，如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code is readable but a bit clumsy. As C# matured, new ways were introduced
    to work with delegates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可读性较好，但略显笨拙。随着C#的成熟，引入了新的方法来处理委托。
- en: 'The second option is to use an anonymous method. To create a delegate with
    an anonymous method, we specify the method return type and body inside a new delegate
    instantiation, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用匿名方法。要使用匿名方法创建委托，我们指定方法返回类型和主体，在新的委托实例化中，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice the difference between the original and anonymous ways of creating a
    delegate. An anonymous method can clean up your code tremendously but comes with
    a big warning: you should use an anonymous method only if you are required to
    do so or if you are confident that you can adhere to the DRY principle. If you
    need to execute the same logic somewhere else in your codebase and you are not
    passing in the delegate to that location, use a normal method instead and call
    it from both places.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意创建委托的原始方式和匿名方式之间的区别。匿名方法可以极大地清理您的代码，但有一个大警告：您应该只在需要这样做或您确信自己可以遵守DRY原则的情况下使用匿名方法。如果您需要在代码库的另一个地方执行相同的逻辑，并且没有将委托传递到该位置，请使用普通方法，并从两个地方调用它。
- en: 'The third, and current, evolution of this process is a fairly easy step to
    reach from the anonymous method: lambda expressions, shown next:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第三次，也是当前的一次进化，是从匿名方法到lambda表达式，如下所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We simply determine what we want the input to be in our anonymous method (`beans`)
    and what logic we want to perform and return (`beans++)`. Additionally, you can
    add and subtract methods from a delegate by using the addition (`+`) and subtraction
    (`-`) operators. If you have multiple methods tied to the same delegate, the delegate
    becomes a multicast delegate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在匿名方法（`beans`）中确定我们想要的输入是什么，以及我们想要执行并返回的逻辑（`beans++`）。此外，您可以通过使用加法（`+`）和减法（`-`）运算符从委托中添加和删除方法。如果您有多个与同一委托相关联的方法，则该委托成为多播委托。
- en: Finally, to use a delegate, call the `Invoke` method, shown next. This invokes
    the underlying `Action`, executing whatever code you have attached to it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要使用委托，请调用下面的`Invoke`方法。这将调用底层的`Action`，执行您附加到其上的任何代码。
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We pass in a lambda expression, which when executed will configure the app’s
    endpoints by calling `MapControllers`. A handy method, `MapControllers` scans
    our codebase for any controllers and generates the appropriate routes to the endpoints
    in our controllers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个lambda表达式，当执行时，将通过调用`MapControllers`来配置应用程序的端点。一个方便的方法，`MapControllers`扫描我们的代码库中的任何控制器，并为我们的控制器中的端点生成适当的路由。
- en: The only thing remaining to do before registering our `Startup` class with the
    `Host` is to create a `ConfigureServices` method and call `AddControllers` on
    the passed-in `IServiceCollection`, as shown in the next code sample. The `IServiceCollection`
    interface allows us to add functionalities to the service, such as support for
    controllers or dependency-injected types. These functionalities get added to an
    internal service collection.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的`Startup`类注册到`Host`之前，唯一剩下的事情是创建一个`ConfigureServices`方法，并在传入的`IServiceCollection`上调用`AddControllers`，如下面的代码示例所示。`IServiceCollection`接口允许我们向服务添加功能，例如支持控制器或依赖注入的类型。这些功能被添加到内部服务集合中。
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why do we need to add controller support to the service collection? Didn’t we
    just scan for the controllers and add routes to the `RouteTable`? At runtime,
    `Host` first calls `ConfigureServices`, giving us a chance to register any services
    we want to use in our app (in this case, our controllers). If we skipped this
    step, `MapControllers` would not find any controllers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要将控制器支持添加到服务集合中？我们不是刚刚扫描了控制器并添加了路由到`RouteTable`吗？在运行时，`Host`首先调用`ConfigureServices`，这给了我们机会注册我们想要在应用程序中使用（在这种情况下，我们的控制器）的任何服务。如果我们跳过了这一步，`MapControllers`将找不到任何控制器。
- en: To use `IServiceCollection`, we need to use the `Microsoft.Extensions .DependencyInjection`
    namespace, shown in the next code snippet. Dependency injection is used by the
    runtime to provide the current, up-to-date `ServiceCollection`. You can find more
    information about dependency injection in section 6.2.9.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `IServiceCollection`，我们需要使用 `Microsoft.Extensions.DependencyInjection` 命名空间，如下面的代码片段所示。依赖注入由运行时用来提供当前的、最新的
    `ServiceCollection`。你可以在第 6.2.9 节中找到更多关于依赖注入的信息。
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are done with the `Startup` class. Now, let’s configure it to be used by
    the `HostBuilder`. We do this by going back to Program.cs and adding a call to
    `UseStartup <Startup>()` to the `HostBuilder`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `Startup` 类。现在，让我们配置它以便由 `HostBuilder` 使用。我们通过回到 Program.cs 并向 `HostBuilder`
    添加对 `UseStartup<Startup>()` 的调用来实现这一点：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now when we launch the application, we get a console window telling us that
    the service is running and listening on [http://0.0.0.0:8080](http://0.0.0.0:8080).
    This code looks slightly different from what the autogenerated template would
    give us. The functionality remains the same, and both are good jumping-off points.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们启动应用程序时，我们得到一个控制台窗口告诉我们服务正在运行并监听 [http://0.0.0.0:8080](http://0.0.0.0:8080)。这段代码看起来与自动生成的模板给出的代码略有不同。功能保持不变，两者都是很好的起点。
- en: Now that we have the prerequisites out of the way, we can start adding some
    logic to our service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了先决条件，我们可以开始向我们的服务添加一些逻辑。
- en: 5.2.4 Using the repository/service pattern for our web service architecture
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 使用存储库/服务模式为我们网络服务架构
- en: 'The architectural paradigm we plan to use for the Flying Dutchman Airlines
    next-gen service is the repository/service pattern. With this pattern, we use
    an upside-down development strategy, where we work from the bottom up: first implement
    the low-level database calls, then work our way up to creating the endpoints.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划为飞荷兰人航空公司下一代服务使用的架构范式是存储库/服务模式。使用这种模式，我们采用自下而上的开发策略，从底层开始工作：首先实现低级数据库调用，然后逐步向上创建端点。
- en: 'Our service architecture comprises the following four layers:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务架构由以下四个层组成：
- en: The database access layer
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库访问层
- en: The repository layer
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储库层
- en: The service layer
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务层
- en: The controller layer
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器层
- en: '![](../Images/05_05.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_05.png)'
- en: Figure 5.5 The repository pattern used in FlyingDutchmanAirlinesNextGen.sln.
    Data and user queries flow from the controller to the service to the repository
    to the database. This pattern allows us to easily separate concerns between layers
    and do incremental development.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 在 FlyingDutchmanAirlinesNextGen.sln 中使用的存储库模式。数据和用户查询从控制器流向服务，再到存储库，最后到数据库。这种模式使我们能够轻松地在层之间分离关注点并进行增量开发。
- en: The benefit we get by working from the bottom up is that the code complexity
    grows organically. Typically, that would be a very bad thing. But in this case,
    we have the tools to control this growth and keep it in check.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从底部开始工作的好处是代码复杂性会自然增长。通常，那会是一件非常糟糕的事情。但在这个案例中，我们有工具来控制这种增长并使其保持在可控范围内。
- en: We can examine the data flow of our architecture (figure 5.5) by taking any
    endpoint and walking through the required steps to satisfy the requirements. For
    example, let’s take `POST /Booking/{flightNumber}`. First, an HTTP request enters
    the `Booking` controller. That would have an instance of a `BookingService` (every
    entity will have its own service and repository), which would call the `BookingRepository`
    and any other services it needs for any entity it may need to interact with. Then
    the `BookingRepository` calls any appropriate database methods. At that point,
    the flow is reversed, and we go back up the chain to return the result value to
    the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择任何端点并逐步执行满足要求的步骤来检查我们架构的数据流（图 5.5）。例如，让我们以 `POST /Booking/{flightNumber}`
    为例。首先，一个 HTTP 请求进入 `Booking` 控制器。这将有一个 `BookingService` 的实例（每个实体都将有自己的服务和存储库），它将调用
    `BookingRepository` 和它可能需要与之交互的任何其他服务。然后 `BookingRepository` 调用任何适当的数据库方法。在那个点上，流程逆转，我们回到链的顶部，将结果值返回给用户。
- en: As mentioned before and shown in figure 5.6, all entities have their own set
    of service and repository classes. If there is a need for an operation on another
    entity, the initial service makes the call to that entity’s service to request
    the operation to be performed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并在图 5.6 中所示，所有实体都有自己的服务类和存储库类。如果需要对另一个实体进行操作，初始服务将调用该实体的服务以请求执行该操作。
- en: '![](../Images/05_06.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_06.png)'
- en: Figure 5.6 The repository pattern applied to the database entities. The FlightController
    holds instances of a service for every entity it needs to operate on. An entity’s
    service holds (at least) an instance of the respective entities’ repositories.
    Services can call other repositories, if necessary. This graphic traces the dependencies
    flow for Airport (the colored boxes).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 将仓储模式应用于数据库实体。FlightController 持有它需要操作的每个实体的服务实例。一个实体的服务持有（至少）相应实体的存储库实例。如果需要，服务可以调用其他存储库。此图形追踪了机场（彩色框）的依赖关系流。
- en: 5.3 Implementing the database access layer
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 实现数据库访问层
- en: 'If we look back at chapter 4, we are reminded of the curious way that database
    access was handled in the previous version of the application. The connection
    string was hardcoded into the class itself and no ORM was used. To refresh our
    minds: an object-relational mapping tool is used to map code against a database,
    ensuring a good match (or isomorphic relationship). Our two major goals in this
    section are to'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾第 4 章，我们会想起在应用程序的前一个版本中处理数据库访问的奇特方式。连接字符串被硬编码到类本身中，并且没有使用 ORM。为了刷新我们的记忆：对象关系映射工具用于将代码映射到数据库，确保良好的匹配（或同构关系）。本节的两个主要目标是
- en: Set up Entity Framework Core and “reverse-engineer” the deployed database.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Entity Framework Core 并“逆向工程”已部署的数据库。
- en: Store the connection string securely through the use of an environment variable.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用环境变量安全地存储连接字符串。
- en: One of the most powerful features of Entity Framework Core is the ability to
    “reverse-engineer” a deployed database. Reverse-engineering means that Entity
    Framework Core autogenerates all the models in your codebase from a deployed database,
    saving you a lot of time. Reverse-engineering also guarantees that your models
    work with the database and are mapped correctly to the schema. In chapter 3, we
    discussed the need for a correct isomorphic relationship between model and schema,
    and using an ORM tool to reverse-engineer models is a way to achieve that.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core 最强大的功能之一是能够“逆向工程”已部署的数据库。逆向工程意味着 Entity Framework Core
    从已部署的数据库自动生成代码库中的所有模型，为您节省了大量时间。逆向工程还保证了您的模型与数据库兼容，并且正确映射到模式。在第 3 章中，我们讨论了模型与模式之间正确同构关系的需求，使用
    ORM 工具逆向工程模型是实现这一目标的方法。
- en: 5.3.1 Entity Framework Core and reverse-engineering
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 Entity Framework Core 和逆向工程
- en: In this section, we’ll learn how to use Entity Framework Core to reverse-engineer
    the deployed database and automatically create models to match the database’s
    tables. Because we reverse-engineer the database, we can be assured that we are
    working with compatible code to query the database.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Entity Framework Core 来逆向工程已部署的数据库，并自动创建与数据库表相匹配的模型。由于我们逆向工程数据库，我们可以确信我们正在使用兼容的代码来查询数据库。
- en: To reverse-engineer our database, we first need to install Entity Framework
    Core by running the `dotnet install` command, as shown next. Entity Framework
    Core (EF Core) does not come automatically installed with .NET 5 as it is a separate
    project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要逆向工程我们的数据库，我们首先需要通过运行 `dotnet install` 命令来安装 Entity Framework Core，如下所示。Entity
    Framework Core（EF Core）不是随 .NET 5 自动安装的，因为它是一个独立的项目。
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On success, the command line lets you know that you can invoke the tool by using
    the `dotnet-ef` command and which version you just installed. Entity Framework
    Core can connect to many different types of databases. Most databases (SQL, NoSQL,
    Redis) have packages (also called database drivers) that allow Entity Framework
    Core to connect to them. Because our database is a SQL Server, we install the
    respective driver. We also need to add the Entity Framework Core Design package.
    These packages contain the functionality we need to connect to a SQL Server database
    (the `SqlServer` namespace) and reverse-engineer the models (the `Design` namespace).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 成功后，命令行会通知您可以使用 `dotnet-ef` 命令调用工具，以及您刚刚安装的版本。Entity Framework Core 可以连接到许多不同类型的数据库。大多数数据库（SQL、NoSQL、Redis）都有包（也称为数据库驱动程序），允许
    Entity Framework Core 连接到它们。因为我们的数据库是 SQL Server，我们安装相应的驱动程序。我们还需要添加 Entity Framework
    Core 设计包。这些包包含我们连接到 SQL Server 数据库（`SqlServer` 命名空间）和逆向工程模型（`Design` 命名空间）所需的功能。
- en: 'Make sure you run the following commands from your project’s root folder (FlyingDutchmanAirlines,
    not the solution’s root folder, FlyingDutchmanAirlinesNextGen):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您从项目的根目录（FlyingDutchmanAirlines，而不是解决方案的根目录，FlyingDutchmanAirlinesNextGen）运行以下命令：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The commands install all required packages and dependencies for connecting to
    a SQL Server with the help of Entity Framework Core.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令会安装连接到使用 Entity Framework Core 的 SQL Server 所需的所有软件包和依赖项。
- en: 'We can now reverse-engineer the database by using the next command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令来逆向工程数据库：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The command contains two unfamiliar terms—`dbcontext` and `scaffold`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 命令中包含两个不熟悉的术语——`dbcontext` 和 `scaffold`：
- en: '`dbcontext` refers to the creation of a class of type `DbContext`. A `dbcontext`
    is the main class we use to set up our database connection in the code.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbcontext` 指的是创建一个类型为 `DbContext` 的类。`dbcontext` 是我们在代码中设置数据库连接的主要类。'
- en: '`scaffold` instructs Entity Framework Core to create models for all database
    entities in the database we are connected to. Much like real-life scaffolding,
    it creates a sort of wrap around the original item (a house or a building) that
    we can use to modify the said item. In our case, it puts a scaffold around the
    deployed SQL database.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaffold` 指示 Entity Framework Core 为我们连接到的数据库中的所有数据库实体创建模型。就像现实生活中的脚手架一样，它为原始项目（房屋或建筑物）创建了一个类似包裹的结构，我们可以用它来修改该项目。在我们的情况下，它将脚手架放在已部署的
    SQL 数据库周围。'
- en: 'We can use flags to specify the folder of the generated models and `dbContext`.
    We’ll save these into a dedicated folder as follows, to avoid having a bunch of
    model files in our project root folder:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标志来指定生成的模型和 `dbContext` 的文件夹。我们将将这些保存到一个专用文件夹中，如下所示，以避免在项目根文件夹中有许多模型文件：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you run into issues running the command, please double-check all spaces,
    line breaks (there should be none), and flags. The command starts by building
    the current project. Then, it tries to connect to the database with the given
    connection string. Finally, it generates the `dbContext` class (FlyingDutchmanAirlinesContext.cs)
    and the appropriate models. Let’s examine the created `FlyingDutchmanAirlinesContext`
    class. A generated `DatabaseContext` has the following four major pieces:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行命令时遇到问题，请仔细检查所有空格、换行符（不应该有）和标志。命令首先构建当前项目。然后，它尝试使用给定的连接字符串连接到数据库。最后，它生成
    `dbContext` 类（FlyingDutchmanAirlinesContext.cs）和适当的模型。让我们检查创建的 `FlyingDutchmanAirlinesContext`
    类。一个生成的 `DatabaseContext` 包含以下四个主要部分：
- en: Constructors
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Collections of type `DbSet` containing entities
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含实体的 `DbSet` 集合
- en: Configuration methods
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置方法
- en: Model-creation options
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型创建选项
- en: 'But before we look at these items, there is something peculiar in the class
    declaration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这些项目之前，类声明中有一个特别之处：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What is this `partial` business?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这 `partial` 是什么意思？
- en: '| ![](../Images/LightBulb.png)   |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   |'
- en: Partial classes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类
- en: You can use the `partial` keyword to break up the definition of a class across
    multiple files. In general, it creates a bit of a readability mess but can be
    useful. Partial classes are especially useful for automatic code generators (like
    Entity Framework Core), because the generator can put code in partial classes,
    thus allowing the developer to enrich the class’s implementation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `partial` 关键字将类的定义拆分到多个文件中。通常，这会稍微降低可读性，但可能很有用。部分类对于自动代码生成器（如 Entity Framework
    Core）特别有用，因为生成器可以将代码放在部分类中，从而允许开发者丰富类的实现。
- en: That said, we know we are not going to be providing more functionality to `FlyingDutchmanAirlinesContext`
    in a different file, so we can remove the `partial` keyword from the class. This
    is a good example of making sure that the code that is automatically generated
    is exactly how you want it. Just because a generator or template did it a certain
    way does not mean you cannot edit it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们知道我们不会在另一个文件中为 `FlyingDutchmanAirlinesContext` 提供更多功能，因此我们可以从类中移除 `partial`
    关键字。这是一个确保自动生成的代码正好符合您期望的好例子。仅仅因为生成器或模板以某种方式完成了它，并不意味着您不能编辑它。
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that this change is optional.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个更改是可选的。
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you look at the generated class, you’ll notice it has two different constructors.
    By default, in C#, if you do not provide a constructor, the compiler generates
    a parameterless constructor for you under the hood. This constructor is called
    the default constructor, or the implicit constructor. C# creates the default constructor
    whenever there is no explicit constructor so you can instantiate a new instance
    of the said class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看生成的类，您会注意到它有两个不同的构造函数。在 C# 中，如果您不提供构造函数，编译器会在幕后为您生成一个无参数的构造函数。这个构造函数被称为默认构造函数或隐式构造函数。C#
    在没有显式构造函数的情况下创建默认构造函数，以便您可以实例化该类的新实例。
- en: As seen in listing 5.4, both constructors can create an instance of `FlyingDutchmanAirlinesContext`.
    In the case of `FlyingDutchmanAirlines`, you can create a new instance with or
    without passing in an instance of type `DbContextOptions`. If you do pass that
    instance into the constructor, it invokes the constructor of its base class (`DbContext`
    in this case).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 5.4 所示，这两个构造函数都可以创建一个 `FlyingDutchmanAirlinesContext` 的实例。在 `FlyingDutchmanAirlines`
    的情况下，你可以创建一个带有或不带有 `DbContextOptions` 类型实例的新实例。如果你确实将那个实例传递给构造函数，它将调用其基类的构造函数（在这种情况下是
    `DbContext`）。
- en: Listing 5.4 `FlyingDutchmanAirlinesContext` constructors
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 `FlyingDutchmanAirlinesContext` 构造函数
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ An explicit default constructor
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显式默认构造函数
- en: ❷ An overloaded constructor with a parameter that calls the base constructor
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 带有调用基构造函数的参数的重载构造函数
- en: For more information on method and constructor overloading, see chapter 4.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有关方法构造函数重载的更多信息，请参阅第 4 章。
- en: 5.3.2 DbSet and the Entity Framework Core workflow
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 DbSet 和 Entity Framework Core 工作流程
- en: In this section, we’ll discuss the `DbSet` type as well as the general workflow
    when using Entity Framework Core. Looking past the constructors, we see four collections
    of type `DbSet`, each holding one of our database models. The `DbSet` types are
    collections that we consider part of the internals of EF Core. Entity Framework
    Core uses the `DbSet<Entity>` collections to store and maintain an accurate copy
    of the database tables and their contents.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 `DbSet` 类型以及使用 Entity Framework Core 时的通用工作流程。超越构造函数，我们看到四个 `DbSet`
    类型的集合，每个集合都包含我们的一个数据库模型。`DbSet` 类型是我们认为属于 EF Core 内部集合的一部分。Entity Framework Core
    使用 `DbSet<Entity>` 集合来存储和维护数据库表及其内容的准确副本。
- en: 'We also see a familiar concept: auto-properties. The collections are `public`,
    but they are also virtual, as shown next:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一个熟悉的概念：自动属性。集合是 `public` 的，但它们也是虚拟的，如下所示：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When you declare something `virtual`, you tell the compiler that you allow the
    property or method to be overridden in a derived class. If you do not declare
    something as `virtual`, you cannot override it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明某个属性或方法为 `virtual` 时，你告诉编译器你允许在派生类中覆盖该属性或方法。如果你没有将某个属性或方法声明为 `virtual`，则不能覆盖它。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/ThumbsUp.png)   |'
- en: Hiding parent properties and methods/sealing classes
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏父属性和方法/密封类
- en: In a world where you have a class that implements a base class containing properties
    or methods not declared as `virtual`, we cannot override the implementation of
    said properties and methods. What to do? Well, we have a workaround for this problem.
    We can “hide” the properties and methods of the parent by inserting the `new`
    keyword into the method or property signature, as shown in the next code. This
    keyword tells the compiler that, instead of providing a new implementation to
    the existing parent method, we just want to call this brand-new method that happens
    to have the same name. In practice, it allows you to “override” nonvirtual properties
    and methods.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类实现了包含未声明为 `virtual` 的属性或方法的基础类的情况下，我们无法覆盖这些属性和方法的具体实现。怎么办呢？嗯，我们有一个解决这个问题的工作区。我们可以通过在方法或属性签名中插入
    `new` 关键字来“隐藏”父类的属性和方法，如下面的代码所示。这个关键字告诉编译器，我们不是要为现有的父方法提供一个新的实现，而是只想调用这个恰好有相同名称的新方法。在实践中，它允许你“覆盖”非虚拟属性和方法。
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Be warned, however, that hiding is frowned on. In an ideal world, the developer
    of the original class has the know-how to predict which properties and methods
    to declare as `virtual`. If you need to do things outside of the system (using
    a workaround to perform unexpected and uncontrolled overrides), think twice before
    hitting that commit code button. The original developer did not expect you to
    do this, nor did they want you to override it in the first place (if they did,
    they would have provided you with a `virtual` property or method).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，隐藏是不受欢迎的。在一个理想的世界里，原始类的开发者有足够的知识来预测哪些属性和方法应该声明为 `virtual`。如果你需要在系统之外做事（使用工作区来执行意外和不受控制的覆盖），在点击提交代码按钮之前三思。原始开发者没有预料到你这样做，他们最初也不想让你覆盖它（如果他们想，他们就会提供一个
    `virtual` 属性或方法）。
- en: 'From the perspective of the developer of the base class, how can you prevent
    your nonvirtual methods and properties from being hidden in a derived class? Unfortunately,
    there is no atomic way of specifying this per property or method. We do have,
    however, a more nuclear option: the `sealed` keyword. You can declare a class
    sealed with the `sealed` keyword, as shown next. This is a good option to safeguard
    your classes because you cannot create a derived class based on a sealed class.
    Because inheritance is off the table, so is overriding or hiding anything.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从基类开发者的角度来看，你该如何防止你的非虚方法或属性在派生类中被隐藏？遗憾的是，没有一种原子方式可以针对每个属性或方法进行指定。然而，我们确实有一个更核心的选项：`sealed`
    关键字。你可以使用 `sealed` 关键字声明一个密封类，如下所示。这是一个很好的选项来保护你的类，因为基于密封类的派生类无法创建。由于继承被排除在外，因此重写或隐藏任何内容也是不可能的。
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Like many other ORM tools, Entity Framework Core often behaves unintuitively
    at first. All operations you would normally make directly against the database
    are done against an in-memory model before they are saved to the database. To
    do this, Entity Framework Core stores most available database records in the `DbSet`.
    This means that if you have added a `Flight` entity with a primary key of `192`
    in the database, you also have that particular entity loaded into memory during
    runtime. Having access to the database contents from memory at runtime allows
    you to easily manipulate objects and abstract away that you are using a database
    at all. The drawback is performance. Keeping lots of records in memory can become
    quite the resource hog, depending on how large your database is (or becomes).
    As shown in figure 5.7, the normal workflow for operating on an entity through
    Entity Framework Core follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他 ORM 工具一样，Entity Framework Core 在一开始往往表现得不够直观。所有通常直接对数据库进行的操作都是在保存到数据库之前，先对内存中的模型进行操作。为此，Entity
    Framework Core 存储了大多数可用的数据库记录在 `DbSet` 中。这意味着，如果你在数据库中添加了一个主键为 `192` 的 `Flight`
    实体，那么在运行时也会将该特定实体加载到内存中。在运行时从内存中访问数据库内容允许你轻松地操作对象，并抽象出你实际上是在使用数据库。缺点是性能。根据你的数据库大小（或成为的大小），在内存中保留大量记录可能会变得非常消耗资源。如图
    5.7 所示，通过 Entity Framework Core 操作实体的正常工作流程如下：
- en: Query the appropriate `DbSet` for the object you want to manipulate (not needed
    for `INSERT`/`ADD` operations).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询你想要操作的对象的适当 `DbSet`（对于 `INSERT`/`ADD` 操作不需要）。
- en: Manipulate the object (not needed for `READ` operations).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作对象（对于 `READ` 操作不需要）。
- en: Change the `DbSet` appropriately (not needed for `READ` operations).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适当地更改 `DbSet`（对于 `READ` 操作不需要）。
- en: '![](../Images/05_07.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_07.png)'
- en: 'Figure 5.7 The three general steps to make changes to a database through Entity
    Framework Core: query the `DbSet`, manipulate the object, and then change the
    `DbSet`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 通过 Entity Framework Core 更改数据库的三个一般步骤：查询 `DbSet`，操作对象，然后更改 `DbSet`。
- en: It is good to keep in mind that just because changes have been made in a `DbSet`,
    they are not necessarily made in the database yet. Entity Framework Core still
    needs to commit these changes to the database, and we’ll explore how to do that
    further in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，尽管在 `DbSet` 中已经进行了更改，但这些更改并不一定已经应用到数据库中。Entity Framework Core 仍然需要将这些更改提交到数据库中，我们将在本章中进一步探讨如何做到这一点。
- en: 5.3.3 Configuration methods and environment variables
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 配置方法和环境变量
- en: 'The third building block of the `FlyingDutchmanAirlinesContext class` comprises
    two configuration methods: `OnConfiguring` and `OnModelCreating`, shown in the
    next code. `OnConfiguring` is called on the configuration of the `DbContext`,
    which is done automatically at launch, whereas `OnModelCreating` is called during
    model creation (at runtime, during launch).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlyingDutchmanAirlinesContext` 类的第三个构建块包括两个配置方法：`OnConfiguring` 和 `OnModelCreating`，如下代码所示。`OnConfiguring`
    在 `DbContext` 的配置时被调用，这是在启动时自动完成的，而 `OnModelCreating` 在模型创建期间（在启动时的运行时）被调用。'
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `OnConfiguring` method takes in an argument of type `DbContextOptionsBuilder`.
    The `OnConfiguring` method is called by the runtime automatically on the configuration
    of the `DbContext` and uses dependency injection to provide the `DbContextOptionsBuilder`.
    Here, we should configure any settings related to how we connect to the database.
    Therefore, we need to provide a connection string.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnConfiguring` 方法接受一个类型为 `DbContextOptionsBuilder` 的参数。`OnConfiguring` 方法由运行时自动在
    `DbContext` 的配置时调用，并使用依赖注入提供 `DbContextOptionsBuilder`。在这里，我们应该配置任何与如何连接到数据库相关的设置。因此，我们需要提供一个连接字符串。'
- en: But, unfortunately, the hardcoded connection string rears its ugly head once
    more. Surely there must be a better way to do this. I propose we use environment
    variables for this. An environment variable is a key-value pair, {*K*, *V* },
    which we set at the operating system level. We can retrieve environment variables
    at run time, making them excellent for providing variables that either change
    per system or deployment or values that we do not want hardcoded in our codebase.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但，不幸的是，硬编码的连接字符串再次露出了它丑陋的真相。肯定有更好的方法来做这件事。我建议我们使用环境变量。环境变量是一个键值对，{*K*，*V*}，我们在操作系统级别设置它。我们可以在运行时检索环境变量，这使得它们非常适合提供随系统或部署而变化的变量，或者我们不希望在代码库中硬编码的值。
- en: NOTE Environment variables are often used for web services deployed through
    containerized orchestration systems such as Kubernetes. If you do not want to
    (or cannot) set an environment variable on the operating system level, you can
    instead use cloud solutions such as Azure Key Vault and Amazon AWS Key Management
    Service. For more information on Kubernetes, see Ashley David’s *Bootstrapping
    Microservices with Docker, Kubernetes, and Terraform* (Manning, 2021) or Marko
    Lukša’s *Kubernetes in Action* (2nd edition; Manning, 2021).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 环境变量通常用于通过容器编排系统（如 Kubernetes）部署的 Web 服务。如果您不想（或不能）在操作系统级别设置环境变量，您可以使用云解决方案，如
    Azure Key Vault 和 Amazon AWS 密钥管理服务。有关 Kubernetes 的更多信息，请参阅 Ashley David 的 *使用
    Docker、Kubernetes 和 Terraform 启动微服务*（Manning，2021）或 Marko Lukša 的 *Kubernetes
    in Action*（第 2 版；Manning，2021）。
- en: 'Every operating system does environment variables slightly differently—we’ll
    discuss the practical differences between Windows and macOS in a moment. The way
    we retrieve an environment variable in C# does not change based on the operating
    system, however. In the `System.IO` namespace is a method called `GetEnvironmentVariable`
    that we can use for that exact purpose, as shown here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统对环境变量的处理方式都略有不同——我们稍后将讨论 Windows 和 macOS 之间的实际差异。然而，我们在 C# 中检索环境变量的方式不会根据操作系统而改变。在
    `System.IO` 命名空间中有一个名为 `GetEnvironmentVariable` 的方法，我们可以用它来完成这个特定的目的，如下所示：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You just pass it in the key of the environment variable you want to retrieve
    (`ENVIRONMENT VARIABLE KEY`), and the method does so for you. If the environment
    variable does not exist, it returns a null value without throwing an exception,
    so you need to do some validation based on that null value. What would your environment
    variable look like? Because it is a key-value pair, and because environment variables
    cannot contain any spaces, you can do something like {`FlyingDutchmanAirlines_Database_Connection_
    String, [Connection String]}`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需传递您想要检索的环境变量的键（`ENVIRONMENT VARIABLE KEY`），该方法就会为您完成。如果环境变量不存在，它将返回一个空值而不抛出异常，因此您需要根据该空值进行一些验证。您的环境变量看起来会是什么样子？因为它是一个键值对，并且因为环境变量不能包含任何空格，您可以这样做：{`FlyingDutchmanAirlines_Database_Connection_String,
    [Connection String]}`。
- en: TIP Because environment variables are system wide, you cannot have environment
    variables with duplicate keys. Keep this in mind when choosing a value for the
    key.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 因为环境变量是系统范围的，所以不能有重复键的环境变量。在选择键的值时，请记住这一点。
- en: 5.3.4 Setting an environment variable on Windows
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 在 Windows 上设置环境变量
- en: 'The process of setting environment variables differs slightly from operating
    system to operating system. In Windows, you set an environment variable through
    the Windows command line, using the `setx` command, followed by the desired key-value
    pair, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量的过程因操作系统而异。在 Windows 上，您可以通过 Windows 命令行使用 `setx` 命令来设置环境变量，后跟所需的键值对，如下所示：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If successful, the command line reports that the value was saved successfully
    (`SUCCESS: Specified value was saved.`). To verify that the environment variable
    was saved, launch a new command line (newly set environment variables do not show
    up in active command-line sessions), and run the `echo` command for the environment
    variable. If you do not see the environment variable show up, as shown next, you
    may have to reboot your machine:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '如果成功，命令行会报告值已成功保存（`SUCCESS: Specified value was saved.`）。要验证环境变量已保存，请启动一个新的命令行（新设置的环境变量不会在活动命令行会话中显示），并运行环境变量的
    `echo` 命令。如果您没有看到环境变量如以下所示出现，您可能需要重新启动您的机器：'
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If everything went all right, the `echo` command should return the value of
    the environment variable (in this case, our connection string). We can now use
    this environment variable in our service!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，`echo`命令应该返回环境变量的值（在这种情况下，我们的连接字符串）。现在我们可以在我们的服务中使用这个环境变量了！
- en: 5.3.5 Setting an environment variable on macOS
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 在macOS上设置环境变量
- en: 'Like Windows, we use a command-line environment to set environment variables
    on macOS: the macOS terminal. Setting an environment variable is just as easy
    on macOS as it is on Windows, as shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows一样，我们在macOS上使用命令行环境设置环境变量：macOS终端。在macOS上设置环境变量与在Windows上一样简单，如下所示：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And you can verify by using `echo` on macOS as well, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在macOS上使用`echo`来验证，如下所示：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On macOS, things are somewhat trickier when we run the service and try to grab
    the environment variables when debugging a codebase through Visual Studio. In
    macOS, environment variables defined through the command line do not automatically
    become available to GUI applications such as Visual Studio. The workaround is
    to launch Visual Studio through the macOS terminal or to add the environment variables
    in Visual Studio as part of the runtime configurations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，当我们运行服务并尝试在通过Visual Studio调试代码库时获取环境变量时，事情变得有些复杂。在macOS上，通过命令行定义的环境变量不会自动对Visual
    Studio等GUI应用程序可用。解决方案是使用macOS终端启动Visual Studio，或者将环境变量添加到Visual Studio的运行时配置中。
- en: 5.3.6 Retrieving environment variables at run time in your code
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.6 在运行时在您的代码中检索环境变量
- en: 'Having set the environment variable, we can now grab it in our code. We want
    to grab it in the `OnConfigure` method instead of hardcoding the connection string.
    We can use the `Environment.GetEnvironmentVariable` method for this. Because the
    `Environment.GetEnvironmentVariable` returns a null value if it cannot find the
    environment variable, we use the null coalescing operator (`??`) to set it to
    an empty string in that case, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量后，我们现在可以在代码中获取它。我们希望在`OnConfigure`方法中获取它，而不是硬编码连接字符串。我们可以使用`Environment.GetEnvironmentVariable`方法来完成这个任务。因为`Environment.GetEnvironmentVariable`如果找不到环境变量会返回null值，所以我们使用空合并运算符（`??`）将其设置为空字符串，如下所示：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We could have handled the `null` case in a couple of different ways (most notably
    by using either a conditional or by inlining the `GetEnvironmentVariable` call
    along with the null coalescing operator into the `UseSqlServer` method), but this
    is my preferred way. It is readable yet succinct. By doing this little trick,
    we increased the security of our application tenfold, especially when you consider
    the problems caused by a hard-coded connection string committed to a source control
    management system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种不同的方式处理`null`情况（最显著的是通过使用条件语句或将`GetEnvironmentVariable`调用与空合并运算符内联到`UseSqlServer`方法中），但这是我的首选方式。它既易于阅读又简洁。通过这个小技巧，我们提高了应用程序的安全性十倍，尤其是当你考虑到硬编码的连接字符串提交到源代码管理系统中可能引起的问题。
- en: The remaining code we have not touched on yet in the `FlyingDutchmanAirlinesContext`
    are the `OnModelCreating` methods, shown in the next listing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未在`FlyingDutchmanAirlinesContext`中涉及到的代码是`OnModelCreating`方法，如下一列表所示。
- en: Listing 5.5 `FlyingDutchmanAirlinesContext` `OnModelCreating`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 `FlyingDutchmanAirlinesContext` `OnModelCreating`
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Overrides the base’s OnModelCreating method
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 覆盖基类的`OnModelCreating`方法
- en: ❷ Prepares the EF Core to use the Airport model
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 准备EF Core使用`Airport`模型
- en: ❸ Prepares the EF Core to use the Booking model
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 准备EF Core使用`Booking`模型
- en: ❹ Prepares the EF Core to use the Customer model
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 准备EF Core使用`Customer`模型
- en: ❺ Prepares the EF Core to use the Flight model
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 准备EF Core使用`Flight`模型
- en: ❻ Calls the partial OnModelCreatingPartial method
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 调用部分`OnModelCreatingPartial`方法
- en: ❼ Defines the partial OnModelCreatingPartial method
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 定义部分`OnModelCreatingPartial`方法
- en: Note that the exact constraint names may differ on your system, because they
    are autogenerated. The `OnModelCreating` method sets up the entities internally
    for Entity Framework Core, along with the key constraints defined in the database
    schema. This allows us to operate on the entities without directly messing with
    the database (which is the whole idea of Entity Framework Core). A generated method
    (and a call to it) is also called `OnModelCreatingPartial`. The Entity Framework
    Core console toolset generated the `OnModelCreatingPartial` method, so you can
    execute additional logic as part of the model-creation process. We are not going
    to do that, so we can remove the `OnModelCreatingPartial` method and the call
    to it. Do be aware that if you have to rerun the reverse-engineering process (or
    any other code-generator tool), your changes will be overwritten again.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于它们是自动生成的，系统上的确切约束名称可能会有所不同。`OnModelCreating`方法在内部为 Entity Framework Core
    设置实体，包括在数据库架构中定义的关键约束。这允许我们在不直接与数据库交互的情况下操作实体（这正是 Entity Framework Core 的整个想法）。生成的（以及对其的调用）方法也称为`OnModelCreatingPartial`。Entity
    Framework Core 控制台工具集生成了`OnModelCreatingPartial`方法，因此您可以在模型创建过程中执行额外的逻辑。我们不会这样做，因此我们可以删除`OnModelCreatingPartial`方法和对其的调用。但请注意，如果您必须重新运行反向工程过程（或任何其他代码生成工具），您的更改将被覆盖。
- en: Exercises
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 5.1
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.1
- en: If we want to prevent somebody from deriving from a class, what keyword do we
    need to attach to the class?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止某人从类中派生，我们需要将哪个关键字附加到类上？
- en: a. `Virtual`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a. `虚拟的`
- en: b. `Sealed`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b. `密封的`
- en: c. `Protected`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: c. `受保护的`
- en: Exercise 5.2
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.2
- en: If we want to allow somebody to override a property or method, what keyword
    do we attach?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要允许某人重写属性或方法，我们应该附加哪个关键字？
- en: a. `Virtual`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: a. `虚拟的`
- en: b. `Sealed`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: b. `密封的`
- en: c. `Protected`
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: c. `受保护的`
- en: Exercise 5.3
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.3
- en: 'Fill in the blanks: “A __________ is the underlying process that runs the web
    service. It, in turn, lives inside the __________.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 填空题：“一个 __________ 是运行 Web 服务的底层进程。它反过来又存在于 __________ 内。”
- en: a. host
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: a. host
- en: b. Tomcat
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: b. Tomcat
- en: c. JVM
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: c. JVM
- en: d. CLR
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: d. CLR
- en: Exercise 5.4
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.4
- en: True or false? When using a `Startup` class, you need to register it with the
    `Host`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？在使用`Startup`类时，您需要将其注册到`Host`。
- en: Exercise 5.5
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.5
- en: 'Try it yourself: Write an expression-body-style method that accepts two integers
    and returns their product. This should be a one-line solution. Hint: Think about
    lambda.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己来做：编写一个表达式体风格的方法，接受两个整数并返回它们的乘积。这是一个单行解决方案。提示：考虑 lambda。
- en: Exercise 5.6
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.6
- en: Within the context of a repository/service pattern, how many controller, service,
    and repository layers should there be?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库/服务模式的情况下，应该有多少个控制器、服务和仓库层？
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can create .NET 5 solutions and projects by using predefined templates in
    the command line such as `console` and `mvc`. Templates are ways to easily create
    common flavors of solutions and projects.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用命令行中的预定义模板（如`console`和`mvc`）来创建 .NET 5 解决方案和项目。模板是轻松创建常见解决方案和项目风味的方法。
- en: A `restore` is an operation that gets all necessary dependencies for a project
    to compile.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restore`操作是获取项目编译所需的所有必要依赖项的操作。'
- en: We can add a project to a solution by using the `dotnet sln [SOLUTION] add [PROJECT]`
    command.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`dotnet sln [SOLUTION] add [PROJECT]`命令将一个项目添加到解决方案中。
- en: A `Host` is a process living inside the CLR that runs a web application, providing
    an interface between the CLR and the user.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host` 是一个在 CLR 内运行的进程，它运行 Web 应用程序，提供 CLR 和用户之间的接口。'
- en: Methods that just return the value of an expression can be written succinctly
    using a syntax similar to lambda expressions. This is called an expression-bodied
    method and can make our code more readable.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用类似于 lambda 表达式的语法简洁地编写仅返回表达式值的函数。这被称为表达式体方法，可以使我们的代码更易读。
- en: In a `Startup` class, we can set up routes and allow for the use of controllers
    and endpoints. This is important for MVC web applications because it allows us
    to call endpoints and use the concept of controllers.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Startup`类中，我们可以设置路由并允许使用控制器和端点。这对于 MVC 网络应用程序来说很重要，因为它允许我们调用端点并使用控制器概念。
- en: The repository/service pattern comprises multiple repositories, services, and
    controllers (one per entity). This easy-to-follow paradigm helps us control the
    flow of data.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库/服务模式包含多个仓库、服务和控制器（每个实体一个）。这个易于遵循的范例帮助我们控制数据流。
- en: Entity Framework Core is a powerful object-relational mapping tool that can
    reverse-engineer deployed databases by scaffolding them. This saves the developer
    a lot of time and allows for a near-perfect isomorphic relationship between the
    database and the codebase.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core 是一种强大的对象关系映射工具，可以通过构建脚本来逆向工程已部署的数据库。这为开发者节省了大量时间，并允许数据库和代码库之间实现近乎完美的同构关系。
- en: Use the `partial` keyword to define classes and methods that have their implementation
    spread across multiple fields. The `partial` keyword is often used by automatic
    code generators.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `partial` 关键字来定义实现分散在多个字段中的类和方法。`partial` 关键字通常被自动代码生成器使用。
- en: When declaring something as `virtual`, you say that this property, field, or
    method can be overridden safely. This is useful when balancing the needs for the
    extensibility and the sanctity of your codebase.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当声明某个属性、字段或方法为 `virtual` 时，你表示这个属性、字段或方法可以被安全地重写。这在平衡扩展性和代码库的纯洁性需求时非常有用。
- en: You can “hide” nonvirtual properties and methods by adding the `new` keyword
    to a method or property signature.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在方法或属性签名中添加 `new` 关键字，你可以“隐藏”非虚拟属性和方法。
- en: When a class is sealed, you cannot inherit from it. In effect, sealing a class
    stops any class from deriving from it. Sealing classes becomes useful when you
    know for a fact that your class is the lowest level of inheritance there is and
    you want to prevent tampering with your code.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个类被密封时，你不能从它继承。实际上，密封一个类阻止了任何类从它继承。当你确信你的类是继承链的最低级别，并且你想要防止对代码的篡改时，密封类变得很有用。
- en: Environment variables are key-value pairs that can be set in an operating system.
    They can store sensitive data such as connection strings or passwords.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量是在操作系统中设置的键值对。它们可以存储敏感数据，例如连接字符串或密码。
- en: '* * *'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)Installation instructions for Visual Studio can be found in appendix C.
    If you want to learn more about Visual Studio, see Bruce Johnson’s *Professional
    Visual Studio 2017* (Wrox, 2017) and Johnson’s *Essential Visual Studio 2019*
    (Apress, 2020). Disclaimer: The author was the technical reviewer for *Essential
    Visual Studio 2019: Boosting Development Productivity with Containers, Git, and
    Azure Tools.*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '^ (1.) Visual Studio 的安装说明可以在附录 C 中找到。如果你想了解更多关于 Visual Studio 的信息，请参阅 Bruce
    Johnson 的 *Professional Visual Studio 2017* (Wrox, 2017) 和 Johnson 的 *Essential
    Visual Studio 2019* (Apress, 2020)。免责声明：作者曾是 *Essential Visual Studio 2019: Boosting
    Development Productivity with Containers, Git, and Azure Tools.* 的技术审稿人。'
