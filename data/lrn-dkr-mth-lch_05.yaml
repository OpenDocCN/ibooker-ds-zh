- en: 5 Sharing images with Docker Hub and other registries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用 Docker Hub 和其他注册表共享镜像
- en: You’ve spent the last few chapters getting a good understanding of the build
    and run parts of the Docker workflow--now it’s time for share. Sharing is all
    about taking the images you’ve built on your local machine and making them available
    for other people to use. I really think this is the most important part of the
    Docker equation. Packaging your software along with all its dependencies means
    anyone can use it easily, on any machine--there are no gaps between environments,
    so there are no more days wasted setting up software or tracking down bugs that
    are actually deployment problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，你已经对 Docker 工作流程的构建和运行部分有了很好的理解——现在是时候分享你的成果了。分享就是将你在本地机器上构建的镜像提供给其他人使用。我真的认为这是
    Docker 公式中最重要的一部分。将你的软件及其所有依赖项打包在一起意味着任何人都可以轻松地在任何机器上使用它——环境之间没有差距，因此不再有浪费在设置软件或追踪实际上是部署问题的错误的日子。
- en: 5.1 Working with registries, repositories, and image tags
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 与注册表、存储库和镜像标签一起工作
- en: Software distribution is built into the Docker platform. You’ve already seen
    that you can run a container from an image, and if you don’t have that image locally,
    Docker will download it. The server that stores images centrally is called a Docker
    registry. Docker Hub is the most popular image registry, hosting hundreds of thousands
    of images, which are downloaded billions of times every month. It’s also the default
    registry for the Docker Engine, which means it’s the first place Docker looks
    for images that aren’t available locally.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件分发是 Docker 平台内置的功能。你已经看到你可以从一个镜像运行容器，如果你本地没有这个镜像，Docker 会下载它。存储镜像的中央服务器称为
    Docker 注册表。Docker Hub 是最受欢迎的镜像注册表，每月托管数十万个镜像，这些镜像被下载数十亿次。它也是 Docker 引擎的默认注册表，这意味着它是
    Docker 首先查找本地不可用镜像的地方。
- en: 'Docker images need a name, and that name contains enough information for Docker
    to find the exact image you’re looking for. So far we’ve used very simple names
    with one or two parts, like `image-gallery` or `diamol/golang` . There are actually
    four parts to a full image name (which is properly called the image reference).
    Figure 5.1 shows all those parts in the full reference for `diamol/golang` :'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像需要一个名称，并且这个名称包含足够的信息，以便 Docker 能够找到你正在寻找的确切镜像。到目前为止，我们使用的是非常简单的名称，通常由一到两个部分组成，例如
    `image-gallery` 或 `diamol/golang`。实际上，一个完整的镜像名称由四个部分组成（通常称为镜像引用）。图 5.1 展示了 `diamol/golang`
    的完整引用中的所有这些部分：
- en: '![](../Images/5-1.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-1.jpg)'
- en: Figure 5.1 Anatomy of a Docker image reference
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 Docker 镜像引用的解剖结构
- en: You’ll be making use of all the parts of an image reference when you start managing
    your own application images. On your local machine you can name images anything
    you like, but when you want to share them on a registry, you’ll need to add some
    more details, because the image reference is a unique identifier for one specific
    image on a registry.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始管理自己的应用程序镜像时，你将使用到镜像引用的所有部分。在你的本地机器上，你可以随意命名镜像，但当你想在注册表上共享它们时，你需要添加更多细节，因为镜像引用是注册表上特定镜像的唯一标识符。
- en: Docker uses a couple of defaults if you don’t provide values for parts of the
    image reference. The default registry is Docker Hub, and the default tag is `latest`
    . Docker Hub’s domain is `docker.io` so my image, `diamol/golang` , is a short
    version of `docker.io/diamol/golang:latest` . You can use either of those references.
    The `diamol` account is an organization on Docker Hub, and `golang` is a repository
    within that organization. It’s a public repository, so anyone can pull the image,
    but you need to be a member of the `diamol` organization to push images.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为镜像引用的部分提供值，Docker 会使用一些默认值。默认注册表是 Docker Hub，默认标签是 `latest`。Docker Hub
    的域名是 `docker.io`，因此我的镜像 `diamol/golang` 是 `docker.io/diamol/golang:latest` 的简写版本。你可以使用这两种引用中的任何一种。`diamol`
    账户是 Docker Hub 上的一个组织，而 `golang` 是该组织内的一个存储库。这是一个公开的存储库，因此任何人都可以拉取镜像，但你需要成为 `diamol`
    组织的成员才能推送镜像。
- en: Large companies usually have their own Docker registry in their own cloud environment
    or their local network. You target your own registry by including the domain name
    in the first part of the reference, so Docker knows not to use Docker Hub. If
    I hosted my own registry at `r.sixeyed.com` , my image could be stored at `r.sixeyed
    .com/diamol/golang` . That’s all pretty simple, but the most important part of
    the image reference is the tag.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大型公司通常在自己的云环境或本地网络中拥有自己的Docker注册表。你通过在引用的第一部分包含域名来针对自己的注册表，这样Docker就知道不要使用Docker
    Hub。如果我在 `r.sixeyed.com` 上托管自己的注册表，我的图像可以存储在 `r.sixeyed .com/diamol/golang` 。这一切都很简单，但图像引用最重要的部分是标签。
- en: You haven’t used image tags so far because it’s simpler to get started without
    them, but when you start building your own application images, you should always
    tag them. Tags are used to identify different versions of the same application.
    The official Docker OpenJDK image has hundreds of tags-- `openjdk:13` is the latest
    release, `openjdk:8u212-jdk` is a specific release of Java 8, and there are more
    for different Linux distributions and Windows versions. If you don’t specify a
    tag when you create an image, Docker uses the default tag `latest` . That's a
    misleading name, because the image tagged “latest” might not actually be the most
    recent image version. When you push your own images, you should always tag them
    with explicit versions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有使用图像标签，因为没有它们开始起来更简单，但当你开始构建自己的应用程序图像时，你应该始终为它们添加标签。标签用于识别同一应用程序的不同版本。官方Docker
    OpenJDK图像有数百个标签-- `openjdk:13` 是最新版本，`openjdk:8u212-jdk` 是Java 8的一个特定版本，还有更多针对不同的Linux发行版和Windows版本。如果你在创建图像时没有指定标签，Docker将使用默认标签
    `latest` 。这个名字可能会误导，因为标记为“latest”的图像可能实际上并不是最新的图像版本。当你推送自己的图像时，你应该始终使用明确的版本进行标记。
- en: 5.2 Pushing your own images to Docker Hub
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 推送自己的图像到Docker Hub
- en: We’ll get started by pushing one of the images you built in chapter 4 up to
    Docker Hub. You’ll need a Docker Hub account for that--if you don’t have one,
    browse to *[https://hub.docker.com](https://hub.docker.com)* and follow the link
    to sign up for an account (it’s free and it won’t get you a ton of spam in your
    inbox).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始推送第4章中构建的一个图像到Docker Hub。你需要一个Docker Hub账户来做到这一点--如果你还没有，请浏览到 *[https://hub.docker.com](https://hub.docker.com)*
    并点击链接注册一个账户（它是免费的，并且不会让你的邮箱收到大量的垃圾邮件）。
- en: You need to do two things to push an image to a registry. First you need to
    log in to the registry with the Docker command line, so Docker can check that
    your user account is authorized to push images. Then you need to give your image
    a reference that includes the name of an account where you have permission to
    push.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像推送到注册表，你需要做两件事。首先，你需要使用Docker命令行登录到注册表，这样Docker就可以检查你的用户账户是否有权推送图像。然后，你需要给你的图像提供一个包含你有权限推送的账户名称的引用。
- en: Every reader will have their own Docker Hub username, so to make it easier to
    follow along with the exercises, let’s start by capturing your own Docker ID in
    a variable in your terminal session. After this, you’ll be able to copy and paste
    the rest of this chapter’s commands.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个读者都会有自己的Docker Hub用户名，为了更容易地跟随练习，让我们首先在你的终端会话中捕获你的Docker ID。之后，你将能够复制粘贴本章剩余的命令。
- en: 'Try it now Open a terminal session and save your Docker Hub ID in a variable.
    Your Docker ID is your username, not your email address. This is one command that
    is different on Windows and Linux, so you’ll need to choose the right option:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 打开一个终端会话并将你的Docker Hub ID保存在一个变量中。你的Docker ID是你的用户名，而不是你的电子邮件地址。这是一条在Windows和Linux上不同的命令，所以你需要选择正确的选项：
- en: '` # using PowerShell on Windows` ` $dockerId="<your-docker-id-goes-here>"`
     ` # using Bash on Linux or Mac` ` export dockerId="<your-docker-id-goes-here>"`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 在Windows上使用PowerShell` ` $dockerId="<your-docker-id-goes-here>"`  ` # 在Linux或Mac上使用Bash`
    ` export dockerId="<your-docker-id-goes-here>"`'
- en: I’m running Windows at the moment, and my Docker Hub username is `sixeyed` ,
    so the command I run is `$dockerId="sixeyed"` ; on Linux I would run `dockerId="sixeyed"`
    . On any system, you can run `echo` `$dockerId` and you should see your username
    displayed. From now on, you can copy the commands in the exercises and they’ll
    use your Docker ID.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前运行的是Windows，我的Docker Hub用户名是 `sixeyed` ，所以我运行的命令是 `$dockerId="sixeyed"` ；在Linux上我会运行
    `dockerId="sixeyed"` 。在任何系统上，你都可以运行 `echo` `$dockerId` 并应该看到你的用户名显示。从现在开始，你可以复制练习中的命令，它们将使用你的Docker
    ID。
- en: Start by logging in to Docker Hub. It’s actually the Docker Engine that pushes
    and pulls images, but you authenticate using the Docker command line--when you
    run the `login` command, it will ask for your password, which is your Docker Hub
    password.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先登录到Docker Hub。实际上，是Docker Engine推送和拉取镜像，但你使用Docker命令行进行认证——当你运行`login`命令时，它会要求你的密码，这是你的Docker
    Hub密码。
- en: 'Try it now Log in to Docker Hub. Hub is the default registry, so you don’t
    need to specify a domain name:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看，登录到Docker Hub。Hub是默认的仓库，所以你不需要指定域名：
- en: '` docker login --username $dockerId`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker login --username $dockerId`'
- en: You’ll see output like mine in figure 5.2--sensibly, Docker doesn’t show the
    password when you type it in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在图5.2中看到类似我的输出——合乎逻辑地，当你输入密码时，Docker不会显示它。
- en: Now that you’re logged in, you can push images to your own account or to any
    organizations you have access to. I don’t know you, but if I wanted your help
    looking after the images for this book, I could add your account to the `diamol`
    organization, and you would be able to push images that start with `diamol/` .
    If you’re not a member of any organizations, you can only push images to repositories
    in your own account.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经登录，你可以将镜像推送到你自己的账户或你能够访问的任何组织。我不认识你，但如果我想请你帮忙照看这本书的镜像，我可以将你的账户添加到`diamol`组织，你将能够推送以`diamol/`开头的镜像。如果你不是任何组织的成员，你只能将镜像推送到你自己的账户中的仓库。
- en: '![](../Images/5-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-2.jpg)'
- en: Figure 5.2 Logging in to Docker Hub
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 登录到Docker Hub
- en: You built a Docker image called `image-gallery` in chapter 4\. That image reference
    doesn’t have an account name, so you can’t push it to any registries. You don’t
    need to rebuild the image to give it a new reference though--images can have several
    references.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你构建了一个名为`image-gallery`的Docker镜像。这个镜像引用没有账户名，所以你不能将其推送到任何仓库。不过，你不需要重新构建镜像来给它一个新的引用——镜像可以有多个引用。
- en: 'Try it now Create a new reference for your existing image, tagging it as version
    1:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看，为你的现有镜像创建一个新的引用，将其标记为版本1：
- en: '` docker image tag image-gallery $dockerId/image-gallery:v1`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image tag image-gallery $dockerId/image-gallery:v1`'
- en: Now you have two references; one has an account and version number, but both
    references point to the same image. Images also have a unique ID, and you can
    see when you list them if a single image ID has multiple references.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个引用；一个有账户和版本号，但两个引用都指向同一个镜像。镜像也有一个唯一的ID，当你列出它们时，你可以看到单个镜像ID是否有多个引用。
- en: 'Try it now List the `image-gallery` image references:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看，列出`image-gallery`镜像引用：
- en: '` docker image ls --filter reference=image-gallery --filter reference=''*/image-gallery''`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image ls --filter reference=image-gallery --filter reference=''*/image-gallery''`'
- en: You’ll see similar output to mine in figure 5.3, except your tagged image will
    show your Docker Hub username instead of `sixeyed` .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在图5.3中看到与我类似的输出，但你的标记镜像将显示你的Docker Hub用户名而不是`sixeyed`。
- en: '![](../Images/5-3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-3.jpg)'
- en: Figure 5.3 One image with two references
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 一个镜像有两个引用
- en: You now have an image reference with your Docker ID in the account name, and
    you’re logged in to Docker Hub, so you’re ready to share your image! The `docker`
    `image` `push` command is the counterpart of the `pull` command; it uploads your
    local image layers to the registry.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个包含你的Docker ID的账户名的镜像引用，你已经登录到Docker Hub，所以你准备好分享你的镜像了！`docker image push`命令是`pull`命令的对应命令；它将你的本地镜像层上传到仓库。
- en: 'Try it now List the `image-gallery` image references:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看，列出`image-gallery`镜像引用：
- en: '` docker image push $dockerId/image-gallery:v1`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image push $dockerId/image-gallery:v1`'
- en: 'Docker registries work at the level of image layers in the same way as the
    local Docker Engine. You push an image, but Docker actually uploads the image
    layers. In the output you’ll see a list of layer IDs and their upload progress.
    In my (abbreviated) output, you can see the layers being pushed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker仓库在镜像层级别上工作，与本地Docker Engine的方式相同。你推送一个镜像，但Docker实际上上传的是镜像层。在输出中，你会看到一个层ID列表及其上传进度。在我的（缩略的）输出中，你可以看到正在推送的层：
- en: '` The push refers to repository [docker.io/sixeyed/image-gallery]` ` c8c60e5dbe37:
    Pushed` ` 2caab880bb11: Pushed` ` 3fcd399f2c98: Pushed` ` ...` ` v1: digest: sha256:127d0ed6f7a8d1...
    size: 2296`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '` The push refers to repository [docker.io/sixeyed/image-gallery]` ` c8c60e5dbe37:
    Pushed` ` 2caab880bb11: Pushed` ` 3fcd399f2c98: Pushed` ` ...` ` v1: digest: sha256:127d0ed6f7a8d1...
    size: 2296`'
- en: The fact that registries work with image layers is another reason why you need
    to spend time optimizing your Dockerfiles. Layers are only physically uploaded
    to the registry if there isn’t an existing match for that layer’s hash. It’s like
    your local Docker Engine cache, but applied across all images on the registry.
    If you optimize to the point where 90% of layers come from the cache when you
    build, 90% of those layers will already be in the registry when you push. Optimized
    Dockerfiles reduce build time, disk space, and network bandwidth.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表与镜像层协同工作的事实是你需要花时间优化你的 Dockerfile 的另一个原因。只有当该层的哈希值没有现有匹配时，层才会物理上传到注册表。这就像你的本地
    Docker Engine 缓存，但应用于注册表上的所有镜像。如果你优化到在构建时 90% 的层来自缓存，那么在推送时，90% 的这些层已经存在于注册表中。优化的
    Dockerfile 可以减少构建时间、磁盘空间和网络带宽。
- en: You can browse to Docker Hub now and check your image. The Docker Hub UI uses
    the same repository name format as image references, so you can work out the URL
    of your image from your account name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以浏览到 Docker Hub 并检查你的镜像。Docker Hub UI 使用与镜像引用相同的仓库名称格式，因此你可以从你的账户名称中确定你镜像的
    URL。
- en: 'Try it now This little script writes the URL to your image’s page on Docker
    Hub:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试这个小程序，它会将你的镜像页面的 URL 写入：
- en: '` echo "https://hub.docker.com/r/$dockerId/image-gallery/tags"`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo "https://hub.docker.com/r/$dockerId/image-gallery/tags"`'
- en: When you browse to that URL, you’ll see something like figure 5.4, showing the
    tags for your image and the last update time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览到该 URL 时，你会看到类似于图 5.4 的内容，显示你的镜像标签和最后更新时间。
- en: '![](../Images/5-4.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 5-4](../Images/5-4.jpg)'
- en: Figure 5.4 Image listings on Docker Hub
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 Docker Hub 上的镜像列表
- en: That’s all there is to pushing images. Docker Hub creates a new repository for
    an image if it doesn’t already exist, and by default that repository has public
    read rights. Now anyone can find, pull, and use your `image-gallery` application.
    They’d need to work out themselves how to use it, but you can put documentation
    on Docker Hub too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 推送镜像就这么简单。如果镜像不存在，Docker Hub 会为它创建一个新的仓库，默认情况下，该仓库具有公共读权限。现在任何人都可以找到、拉取和使用你的
    `image-gallery` 应用程序。他们需要自己找出如何使用它，但你也可以在 Docker Hub 上放置文档。
- en: Docker Hub is the easiest registry to get started with, and it gives you a huge
    amount of functionality for zero cost--although you can pay a monthly subscription
    for extra features, like private repositories. There are lots of alternative registries
    too. The registry is an open API spec, and the core registry server is an open
    source product from Docker. All the clouds have their own registry services, and
    you can manage your own registry in the datacenter with commercial products like
    Docker Trusted Registry or you can run a simple registry in a container.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是最容易开始的注册表，并且它以零成本提供大量功能——尽管你可以支付每月订阅费以获得额外功能，如私有仓库。还有很多替代的注册表。注册表是一个开放的
    API 规范，核心注册表服务器是 Docker 的开源产品。所有云服务提供商都有自己的注册表服务，你可以使用像 Docker Trusted Registry
    这样的商业产品在数据中心管理自己的注册表，或者在一个容器中运行一个简单的注册表。
- en: 5.3 Running and using your own Docker registry
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 运行和使用自己的 Docker 注册表
- en: It’s useful to run your own registry on your local network. It cuts down on
    bandwidth use and transfer times, and it lets you own the data in your environment.
    Even if you’re not concerned about that, it’s still good to know that you can
    spin up a local registry quickly, which you can use as a backup option if your
    main registry goes offline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地网络中运行自己的注册表很有用。它可以减少带宽使用和传输时间，并让你拥有环境中自己的数据。即使你不关心这一点，了解你可以快速启动本地注册表也是好的，这样你就可以在主注册表离线时将其用作备份选项。
- en: Docker maintains the core registry server on GitHub in the source code repository
    `docker/distribution` . It gives you the basic functionality to push and pull
    images, and it uses the same layer cache system as Docker Hub, but it doesn’t
    give you the web UI you get with Hub. It’s a super-lightweight server that I’ve
    packaged into a `diamol` image, so you can run it in a container.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在 GitHub 上的源代码仓库 `docker/distribution` 中维护核心注册表服务器。它为你提供了推送和拉取镜像的基本功能，并使用与
    Docker Hub 相同的层缓存系统，但它不提供 Hub 上的 Web UI。这是一个超级轻量级的服务器，我已经将其打包到 `diamol` 镜像中，因此你可以在容器中运行它。
- en: 'Try it now Run the Docker registry in a container, using my image:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 Docker 注册表容器，使用我的镜像：
- en: '` # run the registry with a restart flag so the container gets` ` # restarted
    whenever you restart Docker:` ` docker container run -d -p 5000:5000 --restart
    always diamol/registry`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 运行注册表时带有重启标志，这样容器在重启 Docker 时也会重启:` ` docker container run -d -p 5000:5000
    --restart always diamol/registry`'
- en: You now have a registry server on your local machine. The default port for the
    server is `5000` , which this command publishes. You can tag images with the domain
    `localhost:5000` and push them to this registry, but that’s not really useful--you
    can only use the registry on your local machine. Instead, it’s better to give
    your machine an alias so you can use a proper domain name for your registry.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在在你的本地机器上有一个注册表服务器。服务器的默认端口是 `5000`，这个命令会发布它。你可以使用域名 `localhost:5000` 对镜像进行打标签并将它们推送到这个注册表，但这并不是很有用——你只能在你的本地机器上使用注册表。相反，最好给你的机器一个别名，这样你就可以为你的注册表使用一个合适的域名。
- en: This next command creates that alias. It will give your computer the name `registry.local`
    , in addition to any other network names it has. It does this by writing to the
    computer’s `hosts` file, which is a simple text file that links network names
    to IP addresses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令会创建这个别名。它会给你的电脑一个 `registry.local` 的名字，以及它可能拥有的任何其他网络名字。它是通过写入电脑的 `hosts`
    文件来做到这一点的，这是一个简单的文本文件，它将网络名字链接到 IP 地址。
- en: 'Try it now Windows, Linux, and Mac machines all use the same hosts file format,
    but the file paths are different. The command is also different on Windows, so
    you’ll need to choose the right one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Windows、Linux 和 Mac 机器都使用相同的 hosts 文件格式，但文件路径不同。Windows 上的命令也不同，所以你需要选择正确的一个：
- en: '` # using PowerShell on Windows` ` Add-Content -Value "127.0.0.1 registry.local"
    -Path /windows/system32/drivers/etc/hosts`  ` # using Bash on Linux or Mac` ` echo
    $''\n127.0.0.1 registry.local'' | sudo tee -a /etc/hosts`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 在 Windows 上使用 PowerShell` ` Add-Content -Value "127.0.0.1 registry.local"
    -Path /windows/system32/drivers/etc/hosts`  ` # 在 Linux 或 Mac 上使用 Bash` `echo
    $''\n127.0.0.1 registry.local'' | sudo tee -a /etc/hosts`'
- en: If you get a permissions error from that command, you’ll need to be logged in
    with administrator privileges in an elevated PowerShell session on Windows, or
    use `sudo` on Linux or Mac. When you’ve run the command successfully, you should
    be able to run `ping` `registry.local` and see a response from your computer’s
    home IP address, 127.0.0.1, as in figure 5.5.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这个命令中得到权限错误，你需要在 Windows 上的提升 PowerShell 会话中用管理员权限登录，或者在 Linux 或 Mac 上使用
    `sudo`。当你成功运行了命令后，你应该能够运行 `ping registry.local` 并看到来自你电脑的本地 IP 地址 127.0.0.1 的响应，如图
    5.5 所示。
- en: '![](../Images/5-5.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-5.jpg)'
- en: Figure 5.5 Adding a new network alias for your computer
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 为你的电脑添加新的网络别名
- en: Now you can use the domain name `registry.local:5000` in your image references
    to use your registry. Adding the domain name to an image involves the same process
    of tagging that you’ve already done for Docker Hub. This time you just include
    the registry domain in the new image reference.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在你的镜像引用中使用域名 `registry.local:5000` 来使用你的注册表。将域名添加到镜像涉及的过程与你在 Docker Hub
    上已经执行过的打标签过程相同。这次你只需在新的镜像引用中包含注册表域名即可。
- en: 'Try it now Tag your `image-gallery` image with your registry domain:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下给你的 `image-gallery` 镜像打上你的注册表域名标签：
- en: '` docker image tag image-gallery registry.local:5000/gallery/ui:v1`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image tag image-gallery registry.local:5000/gallery/ui:v1`'
- en: 'Your local registry doesn’t have any authentication or authorization set up.
    That’s obviously not production quality, but it might work for a small team, and
    it does let you use your own image-naming schemes. Three containers make up the
    NASA image-of-the-day app in chapter 4--you could tag all the images to group
    them together using `gallery` as the project name:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你本地的注册表没有设置任何认证或授权。这显然不是生产质量，但它可能适用于一个小团队，并且它确实让你可以使用自己的镜像命名方案。第 4 章中的 NASA
    每日图像应用由三个容器组成——你可以使用 `gallery` 作为项目名称来对所有的镜像进行打标签，以将它们分组在一起：
- en: '`registry.local:5000/gallery/ui:v1` --The Go web UI'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry.local:5000/gallery/ui:v1` -- Go 网页 UI'
- en: '`registry.local:5000/gallery/api:v1` --The Java API'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry.local:5000/gallery/api:v1` -- Java API'
- en: '`registry.local:5000/gallery/logs:v1` --The Node.js API'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry.local:5000/gallery/logs:v1` -- Node.js API'
- en: There’s one more thing you need to do before you can push this image to your
    local registry. The registry container is using plain-text HTTP rather than encrypted
    HTTPS to push and pull images. Docker won’t communicate with an unencrypted registry
    by default, because it’s not secure. You need to explicitly add your registry
    domain to a list of permitted insecure registries before Docker will let you use
    it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以将此镜像推送到本地注册表之前，您还需要做一件事。注册表容器正在使用纯文本 HTTP 而不是加密的 HTTPS 来推送和拉取镜像。默认情况下，Docker
    不会与未加密的注册表通信，因为它不安全。在 Docker 允许您使用它之前，您需要明确将您的注册表域名添加到允许的非安全注册表列表中。
- en: This brings us to configuring Docker. The Docker Engine uses a JSON configuration
    file for all sorts of settings, including where Docker stores the image layers
    on disk, where the Docker API listens for connections, and which insecure registries
    are permitted. The file is called `daemon.json` and it usually lives in the folder
    `C:\ProgramData\docker\config` on Windows Server, and `/etc/docker` on Linux.
    You can edit that file directly, but if you’re using Docker Desktop on Mac or
    Windows, you’ll need use the UI, where you can change the main configuration settings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了配置 Docker 的问题。Docker 引擎使用 JSON 配置文件来设置各种配置，包括 Docker 在磁盘上存储镜像层的位置、Docker
    API 监听连接的位置以及哪些非安全注册表被允许。该文件名为 `daemon.json`，通常位于 Windows Server 的 `C:\ProgramData\docker\config`
    文件夹中，以及 Linux 的 `/etc/docker` 文件夹中。您可以直接编辑该文件，但如果您在 Mac 或 Windows 上使用 Docker Desktop，您将需要使用
    UI，在那里您可以更改主要配置设置。
- en: Try it now Right-click the Docker whale icon in your taskbar, and select Settings
    (or Preferences on the Mac). Then open the Daemon tab and enter `registry.local:5000`
    in the insecure registries list--you can see my settings in figure 5.6.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：在任务栏中右键单击 Docker 鲸鱼图标，选择设置（或在 Mac 上选择首选项）。然后打开守护进程选项卡，并在非安全注册表列表中输入 `registry.local:5000`--您可以在图
    5.6 中看到我的设置。
- en: '![](../Images/5-6.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-6.jpg)'
- en: Figure 5.6 Allowing an insecure registry to be used in Docker Desktop
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 允许 Docker Desktop 使用非安全注册表
- en: The Docker Engine needs to be restarted to load any new configuration settings,
    and Docker Desktop does that for you when you apply changes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎需要重新启动以加载任何新的配置设置，当您应用更改时，Docker Desktop 会为您完成此操作。
- en: 'If you’re not running Docker Desktop, you’ll need to do this manually. Start
    by opening the `daemon.json` file in a text editor--or create it if it doesn’t
    exist--and add the insecure registry details in JSON format. The configuration
    settings will look like this--but if you’re editing an existing file, be sure
    to leave the original settings in there too:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有运行 Docker Desktop，您将需要手动进行此操作。首先，在文本编辑器中打开 `daemon.json` 文件--如果它不存在，则创建它--并以
    JSON 格式添加非安全注册表详情。配置设置看起来像这样--但如果您正在编辑现有文件，请确保保留原始设置：
- en: '` {` `       "insecure-registries": [` `               "registry.local:5000"`
    `       ]` ` }`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '` {` `       "insecure-registries": [` `               "registry.local:5000"`
    `       ]` ` }`'
- en: Then restart Docker using `Restart-Service` `docker` on Windows Server, or `service`
    `docker` `restart` on Linux. You can check which insecure registries your Docker
    Engine allows, along with a stack of other information, using the `info` command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 Windows Server 上使用 `Restart-Service docker` 或在 Linux 上使用 `service docker
    restart` 重新启动 Docker。您可以使用 `info` 命令检查 Docker 引擎允许的非安全注册表以及其他信息。
- en: 'Try it now List the information about your Docker Engine and check your registry
    is in the insecure registries list:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：列出 Docker 引擎的信息并检查您的注册表是否在非安全注册表列表中：
- en: '` docker info`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker info`'
- en: At the end of the output, you’ll see the registry configuration, which should
    include your insecure registry--you can see mine in figure 5.7.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出末尾，您将看到注册表配置，其中应包括您的非安全注册表--您可以在图 5.7 中看到我的配置。
- en: '![](../Images/5-7.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-7.jpg)'
- en: Figure 5.7 Insecure registries allowed for Docker to use
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 允许 Docker 使用的非安全注册表
- en: You should be careful about adding insecure registries to your Docker configuration.
    Your connection could be compromised, and attackers could read layers when you
    push images. Or worse, they could inject their own data when you pull images.
    All the commercial registry servers run on HTTPS, and you can also configure Docker’s
    open source registry to use HTTPS. For demonstrating with a local server, however,
    it’s an acceptable risk.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该小心地将非安全注册表添加到 Docker 配置中。您的连接可能会被破坏，攻击者可以在您推送镜像时读取层。更糟糕的是，他们可以在您拉取镜像时注入自己的数据。所有商业注册表服务器都运行在
    HTTPS 上，您也可以配置 Docker 的开源注册表使用 HTTPS。然而，为了在本地服务器上进行演示，这是一个可接受的风险。
- en: You can now push your tagged image to your own registry. The registry domain
    is part of the image reference, so Docker knows to use something other than Docker
    Hub, and your HTTP registry running in a container is cleared in the list of insecure
    registries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将你的标记过的镜像推送到你自己的注册表。注册表域名是图像引用的一部分，所以 Docker 知道要使用除 Docker Hub 之外的东西，并且你的在容器中运行的
    HTTP 注册表已从不安全注册表列表中清除。
- en: 'Try it now Push your tagged image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 Push 你的标记过的镜像：
- en: '` docker image push registry.local:5000/gallery/ui:v1`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image push registry.local:5000/gallery/ui:v1`'
- en: Your registry is completely empty when you run the first push, so you’ll see
    all the layers being uploaded. If you then repeat the `push` command, you’ll see
    that all the layers already exist and nothing gets uploaded. That’s all you need
    to do to run your own Docker registry in a container. You could share it on your
    network using your machine’s IP address or the real domain name.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行 `push` 命令时，你的注册表是空的，所以你会看到所有层正在上传。如果你然后重复 `push` 命令，你会看到所有层已经存在，没有任何内容被上传。这就是你需要在容器中运行自己的
    Docker 注册表所需要做的全部。你可以通过你的机器的 IP 地址或真实域名来在你的网络上共享它。
- en: 5.4 Using image tags effectively
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 有效使用图像标签
- en: You can put any string into a Docker image tag, and as you’ve already seen,
    you can have multiple tags for the same image. You’ll use that to version the
    software in your images and let users make informed choices about what they want
    to use--and to make your own informed choices when you use other people’s images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何字符串放入 Docker 图像标签中，正如你之前看到的，你可以为同一镜像拥有多个标签。你将使用它来对图像中的软件进行版本控制，并让用户了解他们想要使用的内容——以及当你使用他人的图像时，你可以做出自己的明智选择。
- en: Many software projects use a numeric versioning scheme with decimal points to
    indicate how big a change there is between versions, and you can do that with
    your image tags. The basic idea is something like `[major].[minor].[patch]` ,
    which has some implicit guarantees. A release that only increments the patch number
    might have bug fixes, but it should have the same features as the last version;
    a release that increments the minor version might add features but shouldn’t remove
    any; and a major release could have completely different features.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件项目使用带有小数点的数字版本控制方案来表示版本之间的变化有多大，你可以在你的图像标签中这样做。基本想法类似于 `[major].[minor].[patch]`，它有一些隐含的保证。仅增加补丁号的发布可能包含错误修复，但它应该与上一个版本具有相同的功能；增加次要版本的发布可能添加功能，但不应该删除任何功能；而主要发布可能具有完全不同的功能。
- en: If you use the same approach with your image tags, you can let users choose
    whether to stick to a major version or a minor version, or just always have the
    latest release.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用相同的方法处理你的图像标签，你可以让用户选择是否坚持使用主版本或次要版本，或者总是拥有最新的发布版本。
- en: 'Try it now Create a few new tags for the Go application you have packaged in
    the image to indicate the major, minor, and patch release versions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 为你打包在镜像中的 Go 应用程序创建一些新的标签，以表示主要、次要和补丁发布版本：
- en: '` docker image tag image-gallery registry.local:5000/gallery/ui:latest` ` docker
    image tag image-gallery registry.local:5000/gallery/ui:2` ` docker image tag image-gallery
    registry.local:5000/gallery/ui:2.1` ` docker image tag image-gallery registry.local:5000/gallery/ui:2.1.106`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image tag image-gallery registry.local:5000/gallery/ui:latest` ` docker
    image tag image-gallery registry.local:5000/gallery/ui:2` ` docker image tag image-gallery
    registry.local:5000/gallery/ui:2.1` ` docker image tag image-gallery registry.local:5000/gallery/ui:2.1.106`'
- en: Now imagine that an application has monthly releases, which increment the version
    numbers. Figure 5.8 shows how the image tags might evolve over releases from July
    to October.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个应用程序每月发布，版本号递增。图 5.8 展示了从 7 月到 10 月发布过程中图像标签可能如何演变。
- en: You can see that some of these image tags are a moving target. `gallery/ui:2.1`
    is an alias for the 2.1.106 release in July, but in August the same 2.1 tag is
    an alias for the 2.1.114 release. `gallery/ui:2` is also an alias for 2.1.106
    in July, but by September the 2 tag is an alias for the 2.2.11 release. The latest
    tag has the most movement--in July `gallery/ui` is an alias for 2.1.106, but in
    October it’s an alias for 3.0.42.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这些图像标签中的一些是移动的目标。`gallery/ui:2.1` 是 7 月份 2.1.106 版本的别名，但在 8 月份，相同的 2.1
    标签是 2.1.114 版本的别名。`gallery/ui:2` 也是 7 月份 2.1.106 版本的别名，但到了 9 月，2 标签是 2.2.11 版本的别名。最新的标签变动最大——7
    月份 `gallery/ui` 是 2.1.106 版本的别名，但在 10 月份它变成了 3.0.42 版本的别名。
- en: This is a typical versioning scheme you’ll see for Docker images. It’s one you
    should adopt yourself, because it lets users of your image choose how current
    they want to be. They can pin to a specific patch version in their image pull
    commands, or in the `FROM` instruction in their Dockerfiles, and be sure that
    the image they use will always be the same. The 2.1.106 tag in this example is
    the same image from July through October. If they want to get patch updates, they
    can use the 2.1 tag, and if they want to get minor releases they can use the 2
    tag.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将看到的典型的Docker图像版本方案。您应该自己采用这个方案，因为它允许您的图像用户选择他们想要保持的当前程度。他们可以在他们的图像拉取命令中固定到特定的补丁版本，或者在他们的Dockerfile中的`FROM`指令中，并确保他们使用的图像始终相同。在这个例子中的2.1.106标签是从7月到10月的相同图像。如果他们想要获取补丁更新，他们可以使用2.1标签，如果他们想要获取小版本发布，他们可以使用2标签。
- en: '![](../Images/5-8.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图5-8](../Images/5-8.jpg)'
- en: Figure 5.8 The evolution of image tags during software releases
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 软件发布期间图像标签的演变
- en: Any of those choices is fine; it’s just a case of balancing risk--using a specific
    patch version means the application will be the same whenever you use it, but
    you won’t get security fixes. Using a major version means you’ll get all the latest
    fixes, but there might be unexpected feature changes down the line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些选择都是可以的；这只是平衡风险的问题——使用特定的补丁版本意味着应用程序每次使用时都将保持相同，但您不会获得安全修复。使用主要版本意味着您将获得所有最新的修复，但可能会有意外的功能更改。
- en: It’s especially important to use specific image tags for the base images in
    your own Dockerfiles. It’s great to use the product team’s build tools image to
    build your apps and their runtime image to package your apps, but if you don’t
    specify versions in the tags, you’re setting yourself up for trouble in the future.
    A new release of the build image could break your Docker build. Or worse, a new
    release of the runtime could break your application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Dockerfile中使用特定的图像标签对于基础图像尤为重要。使用产品团队的构建工具图像来构建您的应用程序以及它们的运行时图像来打包您的应用程序是很好的，但如果您在标签中不指定版本，您将来可能会遇到麻烦。构建图像的新版本可能会破坏您的Docker构建。或者更糟的是，运行时的新版本可能会破坏您的应用程序。
- en: 5.5 Turning official images into golden images
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 将官方图像转换为黄金图像
- en: 'There’s one last thing to understand when you’re looking at Docker Hub and
    other registries: can you trust the images you find there? Anyone can push an
    image to Docker Hub and make it publicly available. For hackers, that’s a nice
    way to distribute malware; you just need to give your image an innocent name and
    a fake description, and wait for people to start using it. Docker Hub solves that
    problem with verified publishers and official images.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看Docker Hub和其他注册表时，还有最后一件事需要理解：您能否信任您在那里找到的图像？任何人都可以将图像推送到Docker Hub并使其公开可用。对于黑客来说，这是一种很好的分发恶意软件的方式；您只需给您的图像一个无辜的名称和虚假的描述，然后等待人们开始使用它。Docker
    Hub通过验证发布者和官方图像来解决这个问题。
- en: Verified publishers are companies like Microsoft, Oracle, and IBM, who publish
    images on Docker Hub. Their images go through an approval process that includes
    security scanning for vulnerabilities; they may also be certified, which means
    they have the backing of Docker and the publisher. If you want to run off-the-shelf
    software in containers, certified images from verified publishers are the best
    bet.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 验证发布者是像微软、甲骨文和IBM这样的公司，他们在Docker Hub上发布图像。他们的图像经过一个包括漏洞安全扫描的审批流程；它们也可能获得认证，这意味着它们得到了Docker和发布者的支持。如果您想在容器中运行现成的软件，来自验证发布者的认证图像是最佳选择。
- en: Official images are something different--they’re usually open source projects,
    maintained jointly by the project team and Docker. They’re security scanned and
    regularly updated, and they conform to Dockerfile best practices. All the content
    for the official images is open source, so you can see the Dockerfiles on GitHub.
    Most people start using official images as the base for their own images but at
    some point find they need more control. Then they introduce their own preferred
    base images, called golden images--figure 5.9 shows you how it works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 官方图像是不同的事物——它们通常是开源项目，由项目团队和Docker共同维护。它们经过安全扫描并定期更新，并符合Dockerfile最佳实践。所有官方图像的内容都是开源的，因此您可以在GitHub上查看Dockerfile。大多数人开始使用官方图像作为他们自己图像的基础，但最终发现他们需要更多的控制。然后他们引入他们自己的首选基础图像，称为黄金图像——图5.9展示了它是如何工作的。
- en: '![](../Images/5-9.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图5-9](../Images/5-9.jpg)'
- en: Figure 5.9 Using a golden image to encapsulate an official image
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 使用黄金图像封装官方图像
- en: Golden images use an official image as the base and then add in whatever custom
    setup they need, such as installing security certificates or configuring default
    environment settings. The golden image lives in the company’s repositories on
    Docker Hub or in their own registry, and all application images are based on the
    golden image. This approach offers the benefits of the official image--with the
    best-practice setup by the project team--but with the extra config you need.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金镜像以官方镜像为基础，然后添加它们需要的任何自定义设置，例如安装安全证书或配置默认环境设置。黄金镜像位于公司的Docker Hub仓库或他们自己的仓库中，所有应用程序镜像都基于黄金镜像。这种方法提供了官方镜像的好处——由项目团队通过最佳实践设置——但增加了你需要额外配置。
- en: 'Try it now There are two Dockerfiles in the source code for this chapter that
    can be built as golden images for .NET Core apps. Browse to each folder and build
    the image:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。本章源代码中有两个Dockerfile，可以作为.NET Core应用程序的黄金镜像构建。浏览到每个文件夹并构建镜像：
- en: '` cd ch05/exercises/dotnet-sdk` ` docker image build -t golden/dotnetcore-sdk:3.0
    .`  ` cd ../aspnet-runtime` ` docker image build -t golden/aspnet-core:3.0 .`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch05/exercises/dotnet-sdk` ` docker image build -t golden/dotnetcore-sdk:3.0
    .`  ` cd ../aspnet-runtime` ` docker image build -t golden/aspnet-core:3.0 .`'
- en: There’s nothing special about golden images. They start with a Dockerfile, and
    that builds an image with your own reference and naming scheme. If you look at
    the Dockerfiles you’ve built, you’ll see that they add some metadata to the image
    using the `LABEL` instruction, and they set up some common configuration. Now
    you can use those images in a multi-stage Dockerfile for a .NET Core application,
    which would look something like listing 5.1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金镜像并没有什么特别之处。它们从一个Dockerfile开始，并使用你自己的参考和命名方案构建一个镜像。如果你查看你构建的Dockerfile，你会发现它们使用`LABEL`指令向镜像添加了一些元数据，并设置了一些常见配置。现在你可以在一个多阶段Dockerfile中使用这些镜像来构建.NET
    Core应用程序，这看起来可能像列表5.1。
- en: Listing 5.1 A multi-stage Dockerfile using .NET Core golden images
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 使用.NET Core黄金镜像的多阶段Dockerfile
- en: '` FROM golden/dotnetcore-sdk:3.0 AS builder` ` COPY . .` ` RUN dotnet publish
    -o /out/app app.csproj`  ` FROM golden/aspnet-core:3.0` ` COPY --from=builder
    /out /app` ` CMD ["dotnet", "/app/app.dll"]`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM golden/dotnetcore-sdk:3.0 AS builder` ` COPY . .` ` RUN dotnet publish
    -o /out/app app.csproj`  ` FROM golden/aspnet-core:3.0` ` COPY --from=builder
    /out /app` ` CMD ["dotnet", "/app/app.dll"]`'
- en: 'The application Dockerfile has the same format as any multi-stage build, but
    now you own the base images. The official images may have a new release every
    month, but you can choose to restrict your golden images to quarterly updates.
    And golden images open up one other possibility--you can enforce their use with
    tools in your continuous integration (CI) pipeline: Dockerfiles can be scanned,
    and if someone tries to build an app without using golden images, that build fails.
    It’s a good way of locking down the source images teams can use.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的应用格式与任何多阶段构建相同，但现在你拥有基础镜像。官方镜像可能每月都会有一个新版本发布，但你可以选择将你的黄金镜像限制为每季度更新一次。黄金镜像还打开了一种其他可能性——你可以通过持续集成（CI）管道中的工具强制使用它们：Dockerfile可以被扫描，如果有人尝试构建一个不使用黄金镜像的应用程序，那么构建将失败。这是一种锁定团队可以使用源镜像的好方法。
- en: 5.6 Lab
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 实验室
- en: This lab is going to take some detective work, but it will be worth it in the
    end. You’re going to need to dig around the Docker Registry API v2 specification
    ( *[https://docs .docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/)*
    ), because the REST API is the only way you can interact with your local Docker
    registry--you can’t search or delete images using the Docker CLI (yet).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验室需要一些侦探工作，但最终会值得。你需要深入研究Docker Registry API v2规范（*[https://docs.docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/)*），因为REST
    API是唯一你可以与你的本地Docker仓库交互的方式——你无法使用Docker CLI（目前）搜索或删除镜像。
- en: 'The goal for this lab is to push all the tags for your `gallery/ui` image to
    your local registry, check that they’re all there, and then delete them all and
    check that they’re gone. We won’t include the `gallery/api` or `gallery/logs`
    images because this lab focuses on images with multiple tags, and we have those
    for `gallery/ui` . Here are a few hints:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验的目标是将你的`gallery/ui`镜像的所有标签推送到本地仓库，检查它们是否都在那里，然后删除它们并检查它们是否已消失。我们不会包括`gallery/api`或`gallery/logs`镜像，因为本实验专注于具有多个标签的镜像，而我们已经有`gallery/ui`的这些镜像。以下是一些提示：
- en: You can use a single `image` `push` command to push all these tags.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用单个`image` `push`命令推送所有这些标签。
- en: The URL for your local registry API is *[http://registry.local:5000/v2](http://registry.local:5000/v2)*
    .
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你本地注册表的API URL是*[http://registry.local:5000/v2](http://registry.local:5000/v2)*。
- en: Start by listing the image tags for the repository.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先列出存储库的镜像标签。
- en: Then you’ll need to get the image manifest.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后你需要获取镜像清单。
- en: You can delete images through the API, but you need to use the manifest.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过API删除镜像，但你需要使用清单。
- en: Read the docs--there’s a specific request header you need to use in your HEAD
    request.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文档——在你的HEAD请求中需要使用特定的请求头。
- en: 'The solution is on the book’s GitHub repository, and this is a rare case where
    it’s OK to cheat a little. The first couple of steps should be straightforward
    for you to work out, but then it gets a little awkward, so don’t feel too bad
    if you end up heading here: *[https://github.com/sixeyed/diamol/tree/master/ch05/lab](https://github.com/sixeyed/diamol/tree/master/ch05/lab)*
    .'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在书的GitHub仓库中，这是一个可以稍微作弊的罕见案例。前几个步骤应该对你来说很容易解决，但之后会变得有些尴尬，所以如果你最终来到这里：*[https://github.com/sixeyed/diamol/tree/master/ch05/lab](https://github.com/sixeyed/diamol/tree/master/ch05/lab)*，请不要感到太难过。
- en: Good luck. And remember to read the docs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运。并且记得阅读文档。
