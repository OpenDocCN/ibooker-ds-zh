- en: 1 Meeting React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 了解 React
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding what React is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 React 是什么
- en: Solving problems with React
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 解决问题
- en: Fitting React into your web applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 React 集成到您的 Web 应用程序中
- en: 'Writing your first React web app: Hello World'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个 React Web 应用程序：Hello World
- en: React is the groundbreaking tool that web developers may not even know they
    need, but can’t let go of once they’ve tried. This is definitely true for the
    two authors of this book, as well as for many other enthusiastic web developers
    out there. React is immensely popular—and for good reason.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个突破性的工具，Web 开发者可能甚至不知道他们需要它，但一旦尝试过，就无法放弃。这对本书的两个作者以及许多其他热情的 Web 开发者来说绝对是正确的。React
    非常受欢迎——而且有很好的理由。
- en: If you were doing web development in the early 2000s, all you needed was some
    HTML and a server-side language such as Perl or PHP. Ah, the good old days of
    putting in alert() boxes just to debug your frontend code. The internet has evolved
    a lot since then, and the complexity of building websites has increased dramatically.
    Websites have become web applications with complex user interfaces (UIs), business
    logic, and data layers that require changes and updates over time—and often in
    real time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 2000 年代初进行 Web 开发，您只需要一些 HTML 和一种服务器端语言，例如 Perl 或 PHP。啊，那些美好的日子，只是为了调试前端代码而放入
    alert() 框。从那时起，互联网已经发生了很大的变化，构建网站的复杂性急剧增加。网站已经变成了具有复杂用户界面（UI）、业务逻辑和数据层的 Web 应用程序，这些应用程序需要随着时间的推移进行更改和更新——通常是实时更新。
- en: Many JavaScript template libraries have been written to try to solve the problems
    of complex UIs. But they still require developers to adhere to the old separation
    of concerns—which splits style (Cascading Style Sheets [CSS]), data and structure
    (HTML), and dynamic interactions (JavaScript)—and they don’t meet modern-day needs
    (remember DHTML?).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 已经编写了许多 JavaScript 模板库来尝试解决复杂 UI 的问题。但它们仍然要求开发者遵守旧的职责分离——将样式（层叠样式表 [CSS]）、数据和结构（HTML）以及动态交互（JavaScript）分开——并且它们不能满足现代需求（还记得
    DHTML 吗？）。
- en: In contrast, React offers a new approach, which, when used correctly, streamlines
    frontend web development. React is a powerful UI library offering an alternative
    that many big firms such as Facebook, Netflix, and Airbnb have adopted and see
    as the way forward. Instead of defining a one-off template for your UIs, React
    allows you to create reusable UI components in JavaScript that you can use again
    and again on your sites.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，React 提供了一种新的方法，当正确使用时，可以简化前端 Web 开发。React 是一个强大的 UI 库，提供了一种许多大公司（如 Facebook、Netflix
    和 Airbnb）已经采用并视为前进方向的选择。React 允许您在 JavaScript 中创建可重用的 UI 组件，您可以在网站上反复使用这些组件，而不是为您的
    UI 定义一次性的模板。
- en: 'Do you need a captcha control or date picker? Use React to define a <Captcha
    /> or <DatePicker /> component that you can add to your form: a simple drop-in
    component with all the functionality and logic to communicate with the backend.
    Do you need an autocomplete box that asynchronously queries a database once the
    user has typed four or more letters? Define an <Autocomplete charNum="4"/> component
    to make that asynchronous query. You can choose whether it has a text box UI or
    has no UI and instead uses another custom form element—perhaps <Autocomplete textbox="..."
    />.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要验证码控制或日期选择器吗？使用 React 定义一个 <Captcha /> 或 <DatePicker /> 组件，您可以将它添加到您的表单中：一个简单的即插即用组件，具有所有功能性和逻辑，以便与后端通信。您需要一个在用户输入四个或更多字母后异步查询数据库的自动完成框吗？定义一个
    <Autocomplete charNum="4"/> 组件来执行该异步查询。您可以选择它是否具有文本框 UI 或没有 UI，而是使用另一个自定义表单元素——可能是
    <Autocomplete textbox="..." />。
- en: This approach isn’t new. Creating composable UIs has been around for a long
    time, but React is the first to use pure JavaScript without templates to make
    this possible. And this approach has proven easier to maintain, reuse, and extend.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不新颖。创建可组合的 UI 已经存在很长时间了，但 React 是第一个使用纯 JavaScript 而不使用模板来实现这一点的。这种方法已被证明更容易维护、重用和扩展。
- en: React is a great library for building UIs, and it should be part of your frontend
    web toolkit, but it isn’t a complete solution for all frontend web development.
    We’ll spend part of this chapter looking at the pros and cons of using React in
    your applications and how React might fit into your existing web development stack.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个构建 UI 的优秀库，它应该是您的前端 Web 工具包的一部分，但它并不是所有前端 Web 开发的完整解决方案。我们将在本章中部分探讨在您的应用程序中使用
    React 的优缺点，以及 React 可能如何融入您现有的 Web 开发堆栈。
- en: In this book, we’ll cover the basics of React and no more, providing readers
    with a solid foundation in the core concepts and principles of the React library
    without delving into any external or advanced topics. By focusing solely on React,
    readers will gain a comprehensive understanding of its capabilities and be well
    equipped to apply their knowledge to a wide range of web development projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将介绍React的基础知识，不再深入，为读者提供一个坚实的React库的核心概念和原则的基础，而不涉及任何外部或高级主题。通过专注于React，读者将全面了解其功能，并准备好将他们的知识应用到广泛的Web开发项目中。
- en: Note The source code for the example in this chapter is available at [https://rq2e.com/ch01](https://rq2e.com/ch01).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在[https://rq2e.com/ch01](https://rq2e.com/ch01)找到。
- en: 1.1 Benefits of using React
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 使用React的优点
- en: 'Every new library or framework claims to be better than its predecessors in
    some respect. In the beginning, we had jQuery, and it was leaps and bounds better
    for writing cross-browser code in native JavaScript. If you remember JavaScript
    from the old days, a single server request would take many lines of code, as it
    had to account for Internet Explorer and WebKit-like browsers. With jQuery, this
    took only a single line: $.ajax(), for example. Back in the day, jQuery was in
    some respects known as a framework—but not anymore! Now a framework is something
    bigger and more powerful.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的库或框架都声称在某些方面优于其前辈。最初，我们有jQuery，它在用原生JavaScript编写跨浏览器代码方面有飞跃性的改进。如果你还记得旧时的JavaScript，一个单独的服务器请求就需要很多行代码，因为它必须考虑到Internet
    Explorer和WebKit-like浏览器。有了jQuery，这只需要一行：例如，$.ajax()。在那些日子里，jQuery在某些方面被称为框架——但不再是了！现在，框架是更大、更强大的东西。
- en: Similarly, with Backbone and then Angular, each new generation of JavaScript
    frameworks has brought something new to the table. React isn’t unique in this.
    What is new is that React challenges some of the core concepts used by most popular
    frontend frameworks, for example, the idea that you need to have templates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Backbone和Angular的每一代新JavaScript框架都为桌面带来了新的东西。React在这方面并不独特。新的地方在于React挑战了大多数流行前端框架使用的某些核心概念，例如，你需要有模板的想法。
- en: 'The following list highlights some of the benefits of React versus other libraries
    and frameworks that existed at the time React emerged:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表突出了React与其他当时存在的库和框架相比的一些优点：
- en: '*Simpler web apps*—React uses a component-based architecture (CBA) with pure
    JavaScript; a declarative style; and powerful, developer-friendly Document Object
    Model (DOM) abstractions (and not just DOM, but also iOS, Android, etc.).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更简单的Web应用*—React使用基于组件的架构（CBA），纯JavaScript；声明式风格；以及强大的、开发者友好的文档对象模型（DOM）抽象（不仅仅是DOM，还有iOS、Android等）。'
- en: '*Fast UIs*—React provides outstanding performance thanks to its virtual DOM
    and smart reconciliation algorithm, which, as a side benefit, lets you perform
    testing without spinning up (starting) a headless browser.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速的用户界面*—React凭借其虚拟DOM和智能 reconciliation 算法提供了卓越的性能，这作为一个额外的好处，让你可以在不启动（启动）无头浏览器的情况下进行测试。'
- en: '*Less code to write*—React’s great community and vast ecosystem of components
    provide developers with a variety of libraries and components. This is important
    when you’re considering what framework to use for development.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更少的代码要写*—React的庞大社区和丰富的组件生态系统为开发者提供了各种库和组件。当你考虑使用哪个框架进行开发时，这一点很重要。'
- en: Many features made React simpler to work with than most other frontend frameworks
    available in its infancy. However, many new frameworks have spawned since React
    came around. Partially due to the popularity of React, some of these new frameworks
    have been developed with similar benefits or thoughts, each slightly altered in
    different ways. Some other frameworks might just be inspired by the overall idea,
    but work completely differently, whereas others are very similar to React, just
    with a smaller feature set requiring you to sometimes write more code, but other
    times end up with a much smaller application codebase.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多特性使得React比当时大多数其他前端框架更容易使用。然而，自从React出现以来，已经产生了许多新的框架。部分原因是React的流行，其中一些新框架被开发出来，具有类似的好处或思想，但以不同的方式稍作修改。有些其他框架可能只是受到整体想法的启发，但工作方式完全不同，而有些则与React非常相似，只是功能集较小，有时需要你写更多的代码，但有时最终会得到一个更小的应用程序代码库。
- en: We’ll consider the benefits that make React popular. These are the main selling
    points of React*,* and they made the framework unique at its introduction, although
    other modern frameworks have similar benefits today. Let’s start to unpack these
    benefits one by one, starting with how wonderfully simple React is to use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将考虑使React流行的优势。这些都是React的主要卖点，它们使该框架在推出时独一无二，尽管今天其他现代框架也有类似的优势。让我们逐一分析这些优势，从React如何简单易用开始。 '
- en: 1.1.1 Simplicity
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 简洁性
- en: The concept of simplicity in computer science is highly valued by developers
    and users, but it doesn’t equate to ease of use. Something simple can be hard
    to implement, but in the end, it will be more elegant and efficient. And often,
    an easy thing will end up being complex. Simplicity is closely related to the
    KISS principle (keep it simple, stupid). The gist is that simpler systems work
    better.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的简洁性概念受到开发者和用户的极高重视，但它并不等同于易用性。简单的东西可能难以实现，但最终将更加优雅和高效。而且，往往简单的事情最终会变得复杂。简洁性与KISS原则（保持简单，傻瓜）密切相关。其核心思想是，更简单的系统工作得更好。
- en: React’s approach allows for simpler solutions via a dramatically better web
    development experience for software engineers. When we began working with React,
    it was a considerable shift in a positive direction that reminded us of switching
    from using plain, no-framework JavaScript to jQuery.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React的方法允许通过为软件工程师提供更好的Web开发体验来实现更简单的解决方案。当我们开始使用React时，这是一个积极的转变，让我们想起了从使用纯无框架JavaScript切换到jQuery。
- en: 'In React, this simplicity is achieved with the following features:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，这种简洁性是通过以下特性实现的：
- en: '*Declarative over imperative* *style*—React embraces declarative style over
    imperative by updating views automatically.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明式优于命令式* *风格*—React通过自动更新视图来拥抱声明式风格。'
- en: '*CBA using pure JavaScript*—React doesn’t use domain-specific languages (DSLs)
    for its components, just pure JavaScript. And there’s no separation when working
    on the same functionality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纯JavaScript使用CBA*—React不为其组件使用领域特定语言（DSLs），而是使用纯JavaScript。并且在实现相同功能时没有分离。'
- en: '*Powerful abstractions*—React has a simplified way of interacting with the
    DOM, allowing you to normalize event handling and other interfaces that work similarly
    across browsers.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强大的抽象*—React提供了一种简化的方式与DOM交互，允许你标准化跨浏览器中工作方式相似的事件处理和其他接口。'
- en: Let’s cover these features one by one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍这些特性。
- en: Declarative over imperative style
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式优于命令式风格
- en: Declarative style means developers write *how it should be*, not *what to do*,
    step by step (imperative). But why is the declarative style a better choice? The
    benefit is that the declarative style reduces complexity and makes your code easier
    to read and understand.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式风格意味着开发者编写的是“应该是怎样的”，而不是“要做什么”，一步一步（命令式）。但为什么声明式风格是一个更好的选择呢？好处是声明式风格减少了复杂性，并使你的代码更容易阅读和理解。
- en: 'The distinction between imperative and declarative coding styles can quickly
    become academic to some extent. When taken to the extreme, declarative programming
    can become really complex to read unless you understand some fairly complex concepts
    well, such as monads and functors. Here are a few different ways to describe the
    difference between the two styles:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式和声明式编程风格的区别可能会迅速变得学术化。当被推向极端时，除非你很好地理解了一些相当复杂的概念，如单子（monads）和函子（functors），否则声明式编程可能真的很难阅读。以下是一些描述两种风格之间差异的不同方法：
- en: '*Statements versus expressions*—Imperative-style programming often works with
    independent statements that individually advance the program state, while declarative
    programming uses expressions that build upon each other to progress the flow of
    logic.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语句与表达式*—命令式编程通常与独立的语句一起工作，这些语句各自推进程序状态，而声明式编程则使用相互构建的表达式来推进逻辑流程。'
- en: '*Reserved word usage*—Imperative-style programming often uses many reserved
    words such as for, while, switch, if, and else, while declarative-style programming
    uses array methods, arrow functions, object access, Boolean expressions, and ternary
    operators to achieve the same results.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保留字使用*—命令式编程通常使用许多保留字，如for、while、switch、if和else，而声明式编程则使用数组方法、箭头函数、对象访问、布尔表达式和三元运算符来实现相同的结果。'
- en: '*Function composition*—Imperative-style programming often uses independent
    function calls and method invocations, while declarative-style programming uses
    function composition to build upon the previous expression and make small generalized
    pieces of logic that, when composed, achieve the desired result.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数组合*—命令式编程通常使用独立的函数调用和方法调用，而声明式编程使用函数组合来构建在先前表达式之上，并创建小的通用逻辑块，当组合时，可以达到期望的结果。'
- en: '*Mutability*—Imperative-style programming often uses mutable objects and manipulates
    existing structures, while declarative-style programming uses immutable data and
    creates new structures from old ones rather than editing existing ones.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可变性*—命令式编程通常使用可变对象并操作现有结构，而声明式编程使用不可变数据，并从旧结构中创建新结构，而不是编辑现有结构。'
- en: Let’s create a simple example to illustrate these different points. The goal
    of this task is to create a function, countGoodPasswords, that, given a list of
    passwords, will return how many of the passwords are *good*. Here, we’ll define
    a *good* password as any password at least nine characters long.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的例子来说明这些不同的点。这个任务的目的是创建一个函数，countGoodPasswords，它给定一个密码列表，将返回有多少密码是*好的*。在这里，我们将*好的*密码定义为任何至少九个字符长的密码。
- en: This is a great simple task that can be solved in any programming language in
    a multitude of ways. Some programming languages inherently make one style more
    natural to reach for, but JavaScript is a bit special, as it’s a member of both
    worlds. You can solve this task either imperatively or declaratively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的简单任务，可以用任何编程语言以多种方式解决。一些编程语言天生使一种风格更自然，但JavaScript有点特别，因为它属于两个世界。你可以用命令式或声明式来解决这个任务。
- en: 'Let’s start with a (very) naive imperative solution:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从（非常）天真的命令式解决方案开始：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ New statement changes the program state
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新语句改变程序状态
- en: ❷ Reserved word controls program flow
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 保留字控制程序流程
- en: ❸ Mutates an existing object
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 修改现有对象
- en: This is, of course, partially taken to an extreme, and even under a fully imperative
    programming paradigm, this could be much shorter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一部分被推向极端，即使在完全命令式编程范式中，这也可能更短。
- en: 'Let’s implement this same example using a declarative programming mindset:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用声明式编程的心态实现这个相同的例子：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We arrive directly at the goal in a single statement by manipulating an object
    in several steps, using function composition to arrive at the target. We filter
    the original array to arrive at a temporary value, which is the array of only
    good passwords. However, we never store this array anywhere; we go directly to
    the next step of taking the length of that array.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在几个步骤中操作一个对象，我们可以用单条语句直接达到目标，使用函数组合达到目标。我们过滤原始数组以得到一个临时值，即仅包含良好密码的数组。然而，我们从未在任何地方存储这个数组；我们直接进入下一步，即获取该数组的长度。
- en: That was just some generic JavaScript code. How does this relate to React? React
    takes the same declarative approach when you compose UIs. First, React developers
    describe UI elements in a declarative style. Then, when there are changes to views
    generated by those UI elements, React takes care of the updates. Yay!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一些通用的JavaScript代码。这与React有什么关系？当组合UI时，React采用相同的声明式方法。首先，React开发者以声明式风格描述UI元素。然后，当由这些UI元素生成的视图发生变化时，React负责更新。太棒了！
- en: The convenience of React’s declarative style fully shines when you need to make
    changes to the view. Those are called changes of the *internal state*. When the
    state changes, React updates the view accordingly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要更改视图时，React的声明式风格的便利性完全显现出来。这些被称为*内部状态*的变化。当状态发生变化时，React相应地更新视图。
- en: Note We’ll cover how states work in chapter 5.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在第5章中介绍状态的工作原理。
- en: Component-based architecture using pure JavaScript
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯JavaScript的基于组件的架构
- en: CBA existed before React came on the scene. Separation of concerns, loose coupling,
    and code reuse are at the heart of this approach because it provides many benefits;
    software engineers, including web developers, love CBA. A building block of CBA
    in React is the component class. As with other CBAs, it has many benefits, with
    code reuse being the main one (you can write less code!).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CBA在React出现之前就已经存在。关注点分离、松耦合和代码复用是这种方法的核心，因为它提供了许多好处；软件工程师，包括Web开发者，都喜欢CBA。在React中，CBA的一个构建块是组件类。与其他CBAs一样，它有许多好处，其中代码复用是主要的好处（你可以写更少的代码！）。
- en: What was lacking before React was a pure JavaScript implementation of this architecture.
    When you’re working with Angular, Backbone, Ember, or most of the other Model-View-Controller
    (MVC)-like frontend frameworks, you have one file for JavaScript and another for
    the template. (Angular uses the term *directives* for components.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在React出现之前，缺少的是对这个架构的纯JavaScript实现。当您使用Angular、Backbone、Ember或大多数其他类似Model-View-Controller（MVC）的前端框架时，您有一个JavaScript文件和一个模板文件。（Angular使用术语*directives*来表示组件。）
- en: There are a few problems with having two languages (and two or more files) for
    a single component. The HTML and JavaScript separation worked well when you had
    to render HTML on the server, and JavaScript was only used to make your text blink.
    Now, *single-page applications* (SPAs) handle complex user input and perform rendering
    on the browser. This means HTML and JavaScript are closely coupled functionally.
    For developers, it makes more sense not to require separation of HTML and JavaScript
    when working on a piece of a project (component).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个组件使用两种语言（以及两个或更多文件）存在一些问题。当您需要在服务器上渲染HTML，而JavaScript仅用于使文本闪烁时，HTML和JavaScript的分离工作得很好。现在，*单页应用*（SPAs）处理复杂的用户输入并在浏览器上执行渲染。这意味着HTML和JavaScript在功能上紧密耦合。对于开发者来说，在处理项目（组件）的一部分时，不要求HTML和JavaScript分离更有意义。
- en: Under the hood, React uses a *virtual DOM* to find differences (the delta) between
    what’s already in the browser and the new view. This process is called *DOM diffing*
    or *reconciliation* *of state and view* (bringing them back to similarity). This
    means developers don’t need to worry about explicitly changing the view; all they
    need to do is update the state, and the view will be updated automatically as
    needed. You’ll see us implicitly using this concept over and over in the book.
    We never do DOM manipulation directly; we let React do that work for us.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，React使用*虚拟DOM*来查找浏览器中现有内容和新视图之间的差异（delta）。这个过程被称为*DOM diffing*或*状态和视图的协调*（将它们恢复到相似性）。这意味着开发者不需要担心显式地更改视图；他们只需要更新状态，视图将根据需要自动更新。您将在本书中反复看到我们隐式地使用这个概念。我们从不直接进行DOM操作；我们让React为我们做这项工作。
- en: Conversely, with jQuery, you’d need to implement updates imperatively. By manipulating
    the DOM, developers can programmatically modify parts of the web page without
    re-rendering the entire page. DOM manipulation is what you do when you invoke
    jQuery methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用jQuery，您需要以命令式的方式实现更新。通过操作DOM，开发者可以编程修改网页的部分，而无需重新渲染整个页面。DOM操作就是您调用jQuery方法时所做的事情。
- en: Think of the help provided by the underlying framework on a scale as shown in
    figure 1.1\. At one end of the scale, you have a “framework” that doesn’t actually
    help you at all. If you built your application in plain JavaScript, you would
    be at this extreme. Using jQuery would make it easier to manipulate the DOM, but
    you would still have no help from the framework when things update. You would
    have to manually make sure that your jQuery views update when your jQuery data
    updates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下底层框架提供的帮助，如图1.1所示。在这个尺度的一个端点，您有一个“框架”，实际上根本帮不了您。如果您用纯JavaScript构建了您的应用程序，您就会处于这个极端。使用jQuery可以使DOM操作更容易，但更新时您仍然没有框架的帮助。您必须手动确保当jQuery数据更新时，您的jQuery视图也更新。
- en: '![01-01](../Images/01-01.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![01-01](../Images/01-01.png)'
- en: Figure 1.1 How much does the framework help you? jQuery does nothing; Angular
    does it all. For some, React hits the sweet spot in between.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 框架能帮您多少？jQuery什么也不做；Angular做所有的事情。对于一些人来说，React在中间找到了一个甜蜜点。
- en: At the other end of the scale, we have frameworks such as Angular, which is
    another very popular framework and comparable to React in every way. However,
    Angular works in a fundamentally different way with a lot more “magic” happening
    behind the scenes. You often merely described how your components fit together,
    and Angular will try to connect things correctly behind the scenes. The problem
    with Angular is that you often lose the desired fine-grained control if things
    don’t work correctly. Many things are hidden from you, which makes things unnecessarily
    complex.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个尺度的另一端，我们有像Angular这样的框架，这是一个非常流行的框架，在各个方面都与React相当。然而，Angular以一种根本不同的方式工作，幕后发生了很多“魔法”。您通常只是描述了组件如何组合在一起，Angular会尝试在幕后正确连接事物。Angular的问题在于，如果事情没有正确工作，您通常会失去期望的精细控制。许多事情都隐藏起来，这使得事情变得不必要地复杂。
- en: React strikes that happy medium, where the framework helps you with a lot of
    the tedious work of connecting various things behind the scenes, but without locking
    you out of the fine-grained control required to make complex web applications.
    This is obviously a subjective opinion, but we’re not alone in feeling that way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: React 找到了一个快乐的平衡点，框架帮助你在幕后连接各种事物的大量繁琐工作，但又不至于让你失去制作复杂网络应用所需的精细控制。这显然是一个主观的观点，但我们并不孤单，我们也有这样的感觉。
- en: Powerful abstractions
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的抽象
- en: 'React comes with the following great abstractions that make life as a React
    developer easier:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了以下出色的抽象，使 React 开发者的生活更加轻松：
- en: Synthetic events abstracting out browser differences in native events
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成事件抽象出原生事件在浏览器中的差异
- en: JavaScript XML (JSX) abstracting out the JS DOM
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript XML (JSX) 抽象出 JS DOM
- en: Browser independence allowing rendering in nonbrowser environments (e.g., on
    the server)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器独立性，允许在非浏览器环境中渲染（例如，在服务器上）
- en: React has a powerful abstraction of the browser event model. In other words,
    it hides the underlying interfaces and provides normalized/synthesized methods
    and properties. For example, when you create an onClick event in React, instead
    of the event handler receiving a native browser-specific event object, it receives
    a synthetic event object that’s a wrapper around native event objects. You can
    expect the same behavior from synthetic events regardless of the browser in which
    you run the code. React also has a set of synthetic events for touch events, which
    are great for building web apps for mobile devices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React 对浏览器事件模型有一个强大的抽象。换句话说，它隐藏了底层接口，并提供了标准化/合成的方法和属性。例如，当你创建一个 React 中的 onClick
    事件时，事件处理程序接收到的不是原生浏览器特定的事件对象，而是一个包装在原生事件对象周围的合成事件对象。你可以期望无论在哪个浏览器中运行代码，合成事件都会表现出相同的行为。React
    还有一套合成事件用于触摸事件，这对于构建移动设备的网络应用非常出色。
- en: Then there’s JSX, which is one of the more controversial elements of React.
    For some, the abstraction of JSX is a strong argument *for* using React, while
    JSX has been a stumbling block or even a deterrent for others.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 JSX，它是 React 中更具争议性的元素之一。对于一些人来说，JSX 的抽象是使用 React 的一个强有力的论据，而对于其他人来说，JSX
    成为了一个障碍，甚至是一个阻碍。
- en: If you’re familiar with Angular, then you’ve already had to write a lot of JavaScript
    in your template code because, in modern web development, plain HTML is too static
    and is hardly any use by itself. Our advice is to give React the benefit of the
    doubt and give JSX a fair run.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Angular，那么你已经在模板代码中写了很多 JavaScript，因为在现代网络开发中，纯 HTML 太过静态，本身几乎没有什么用处。我们的建议是给
    React 一个机会，并公正地尝试 JSX。
- en: 'JSX is a bit of *syntactic sugar* on top of JavaScript for writing React elements
    in JavaScript using HTML-like notation with <>. React pairs nicely with JSX because
    developers can better implement and read the code. Think of JSX as a mini-language
    that’s compiled into native JavaScript. So, JSX isn’t run on the browser but is
    used as the source code for compilation. Here’s a compact snippet written in JSX:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是在 JavaScript 之上的一点点语法糖，使用 HTML 类似的符号 <> 在 JavaScript 中编写 React 元素。React
    与 JSX 配合得很好，因为开发者可以更好地实现和阅读代码。将 JSX 视为一个编译成原生 JavaScript 的迷你语言。因此，JSX 并不在浏览器上运行，而是用作编译的源代码。以下是一个用
    JSX 编写的紧凑片段：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even if you load a JSX file in your browser with the runtime transformer library
    that compiles JSX into native JavaScript on the run, you still don’t run the JSX;
    you run JavaScript instead. In this sense, JSX is akin to CoffeeScript. You compile
    these languages into native JavaScript to get better syntax and features than
    that provided by regular JavaScript.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在浏览器中使用运行时转换库加载 JSX 文件，将 JSX 编译成原生 JavaScript，你仍然没有运行 JSX；你运行的是 JavaScript。从这个意义上说，JSX
    类似于 CoffeeScript。你将这些语言编译成原生 JavaScript，以获得比常规 JavaScript 更好的语法和功能。
- en: We know that to some of you, it looks bizarre to have HTML interspersed within
    JavaScript code. It takes every new React developer (including us) a while to
    adjust because we’re expecting an avalanche of syntax error messages. And yes,
    using JSX is optional. For these two reasons, we aren’t covering JSX until chapter
    3\. Trust us, though—it’s very powerful and even addictive once you get familiar
    with it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，对于你们中的一些人来说，HTML 代码中穿插 JavaScript 代码看起来很奇怪。每个新的 React 开发者（包括我们）都需要一段时间来适应，因为我们预期会有大量的语法错误信息。是的，使用
    JSX 是可选的。出于这两个原因，我们直到第 3 章才介绍 JSX。但请相信我们——一旦熟悉了它，它非常强大，甚至会上瘾。
- en: Another example of React’s DOM abstraction is that you can render React elements
    on the server. This can be handy for better search engine optimization (SEO) and
    improving performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: React的DOM抽象的另一个例子是您可以在服务器上渲染React元素。这有助于更好的搜索引擎优化（SEO）和性能提升。
- en: There are many options when it comes to rendering React components in both DOM
    and HTML strings on the server. You can even use hybrid approaches where your
    templates are rendered with some content on the server and later rehydrated with
    live data in the browser. We’ll talk a lot more about this in section 1.3\. And,
    speaking of the DOM, one of the most sought-after benefits of React is its splendid
    performance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上渲染React组件时，无论是DOM还是HTML字符串，都有许多选项。您甚至可以使用混合方法，其中模板在服务器上渲染一些内容，然后在浏览器中使用实时数据重新激活。我们将在第1.3节中详细讨论这一点。说到DOM，React最被追求的好处之一就是其出色的性能。
- en: 1.1.2 Speed and testability
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 速度和可测试性
- en: In addition to the necessary DOM updates, your framework may perform unnecessary
    updates, which makes the performance of complex UIs even worse. This becomes especially
    noticeable and painful for users when you have a lot of dynamic UI elements on
    your web page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必要的DOM更新之外，您的框架可能还会执行不必要的更新，这使得复杂UI的性能变得更差。当您的网页上有许多动态UI元素时，这一点对用户来说尤其明显且痛苦。
- en: On the other hand, React’s virtual DOM exists only in the JavaScript memory.
    Every time there’s a data change, React first compares the differences using its
    virtual DOM; only when the library knows there has been a change in the rendering
    will it update the actual DOM. Figure 1.2 shows a high-level overview of how React’s
    virtual DOM works when there are data changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，React的虚拟DOM仅存在于JavaScript内存中。每次数据发生变化时，React首先使用其虚拟DOM比较差异；只有当库知道渲染有变化时，它才会更新实际的DOM。图1.2展示了当有数据变化时React的虚拟DOM如何工作的概览。
- en: '![01-02](../Images/01-02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![01-02](../Images/01-02.png)'
- en: Figure 1.2 Once a component has been rendered, if its state changes, it’s compared
    to the in-memory virtual DOM and re-rendered if necessary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 一旦组件被渲染，如果其状态发生变化，它将与内存中的虚拟DOM进行比较，并在必要时重新渲染。
- en: Ultimately, React updates only those parts that are necessary so that the internal
    state (virtual DOM) and the view (real DOM) are the same. For example, if there’s
    a <p> element, and you augment the text via the state of the component, only the
    text will be updated (i.e., innerHTML), not the element itself. This results in
    increased performance compared to re-rendering entire sets of elements or, even
    more so, entire pages (server-side rendering).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，React只更新必要的部分，以便内部状态（虚拟DOM）和视图（真实DOM）保持一致。例如，如果有<p>元素，并且您通过组件的状态增加文本，只有文本将被更新（即innerHTML），而不是元素本身。这比重新渲染整个元素集或整个页面（服务器端渲染）提高了性能。
- en: The geeky details of reconciliation
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调和的细节
- en: 'If you like to geek out on algorithms and Big O notation, these two articles
    do a great job of explaining how the React team managed to turn an O(n³) problem
    into an O(n) one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢在算法和大O符号上深入研究，这两篇文章很好地解释了React团队如何将O(n³)问题转化为O(n)问题：
- en: “Reconciliation,” on the React website ([http://mng.bz/PQ9X](http://mng.bz/PQ9X))
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “调和”，在React网站上（[http://mng.bz/PQ9X](http://mng.bz/PQ9X)）
- en: “React’s Diff Algorithm” by Christopher Chedeau ([http://mng.bz/68L4](http://mng.bz/68L4))
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Christopher Chedeau的《React的Diff算法》（[http://mng.bz/68L4](http://mng.bz/68L4)）
- en: The added benefit of the virtual DOM is that you can do unit testing without
    headless browsers such as PhantomJS ([http://phantomjs.org](http://phantomjs.org)).
    There are several libraries out there, including Jest and React Testing Library,
    that allow you to test your components directly from the command line. We’ll obsess
    quite a bit more on unit testing React components and hooks in later chapters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM的附加好处是，您可以在没有PhantomJS（[http://phantomjs.org](http://phantomjs.org)）等无头浏览器的情况下进行单元测试。现在有几个库，包括Jest和React
    Testing Library，允许您直接从命令行测试您的组件。我们将在后面的章节中更多地关注React组件和钩子的单元测试。
- en: 1.1.3 Ecosystem and community
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 生态系统和社区
- en: Last, but not least, React is supported by the developers of the juggernaut
    web application called Facebook, as well as by their peers at Instagram. As with
    Angular and some other libraries, having a big company behind the technology provides
    a sound testing ground (it’s deployed to millions of browsers), reassurance about
    the future, and an increase in contribution velocity. This is, of course, also
    a risk because if Facebook suddenly wants to take React in a new direction, you
    might get stranded if you don’t like that direction, so weigh your options carefully.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，React 由被称为Facebook的巨无霸网络应用的开发者支持，以及他们的Instagram同行。与Angular和其他一些库一样，有一个大公司支持这项技术提供了一个可靠的测试平台（它部署到数百万个浏览器上），对未来有了保障，并且增加了贡献速度。当然，这也存在风险，因为如果Facebook突然想要将React引向新的方向，而你不喜欢这个方向，你可能会陷入困境，所以请仔细权衡你的选择。
- en: A lot of great content already exists that has been created for React by the
    community. You’ll find that when you need some kind of component or interface,
    you can just search the web for “react [name-of-component]”, and more than 95%
    of the time, you’ll find something worthwhile.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 社区已经为React创建了大量的优秀内容。你会发现，当你需要某种组件或界面时，你只需在网上搜索“react [组件名称]”，超过95%的情况下，你都会找到有价值的东西。
- en: The history of open source software clearly shows that the marketing of open
    source projects is as important to its wide adoption and success as the code itself.
    By that, we mean that if a project has a poor website, lacks documentation and
    examples, or has an ugly logo, most developers won’t take it seriously—especially
    now, when there are so many JavaScript libraries. Developers are picky, and they
    won’t use an ugly duckling library.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件的历史清楚地表明，开源项目的营销与其广泛采用和成功一样重要，就像代码本身一样。这意味着，如果一个项目有一个糟糕的网站，缺乏文档和示例，或者有一个丑陋的标志，大多数开发者都不会认真对待它——尤其是在现在，JavaScript库如此之多的情况下。开发者很挑剔，他们不会使用一个丑陋的鸭子库。
- en: As the saying goes, “Don’t judge a book by its cover*.*” This might sound controversial,
    but, sadly, most people, including software engineers, are prone to biases such
    as good branding. Luckily, React has a great engineering reputation backing it.
    And, speaking of book covers, we hope you didn’t buy this book just for its cover!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如俗话所说，“不要以貌取人*。” 这可能听起来有些争议，但遗憾的是，包括软件工程师在内的大多数人，都容易受到良好品牌等偏见的影响。幸运的是，React有一个很好的工程声誉作为支撑。至于书封面，我们希望你不是仅仅因为封面才买这本书的！
- en: 1.2 Disadvantages of React
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 React的缺点
- en: 'Of course, almost everything has its drawbacks. This is true with React, but
    the full list of cons depends on whom you ask. Some of the differences, such as
    declarative versus imperative, are highly subjective. They can be both pros and
    cons depending on your personal preference. Here’s our list of React’s disadvantages
    (as with any such list, it may be biased):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，几乎每件事都有其缺点。这与React一样，但完整的缺点列表取决于你问谁。一些差异，如声明式与命令式，非常主观。它们可以是优点也可以是缺点，这取决于你的个人偏好。以下是我们的React缺点列表（正如任何此类列表一样，它可能存在偏见）：
- en: '*React isn’t a full-blown, Swiss Army knife-type of framework.* Developers
    need to pair it with a library such as Redux or XState to achieve functionality
    comparable to Angular or Ember. This can also be an advantage if you need a minimalistic
    UI library to integrate with your existing stack.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React不是一个功能齐全的瑞士军刀式框架*。开发者需要将其与Redux或XState等库配对，才能实现与Angular或Ember相当的功能。如果你需要一个简约的UI库来与现有的堆栈集成，这也可以是一个优势。'
- en: '*React stacks require maintenance and continuous package management.* Because
    you never use React only on its own, but almost always combine it with several
    other packages, you need to constantly maintain your dependencies and make sure
    you’re using the correct versions of various packages. In larger projects, this
    can become a significant source of extraneous tasks.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React堆栈需要维护和持续包管理*。因为你几乎不会单独使用React，而是几乎总是将其与几个其他包结合使用，你需要不断维护你的依赖关系，并确保你正在使用各种包的正确版本。在更大的项目中，这可能会成为一项重要的额外任务来源。'
- en: '*React uses a somewhat new approach to web development, and JSX and functional
    programming can be intimidating to beginners.* Especially in the early days, there
    was a lack of best practices, good books, courses, and resources available for
    mastering React and similar frameworks. We’ll discuss JSX in much more detail
    in chapter 3.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React采用了一种相对较新的Web开发方法，JSX和函数式编程可能会让初学者感到害怕。* 尤其是在早期，对于掌握React和类似框架的最佳实践、好书、课程和资源都存在缺乏。我们将在第3章中更详细地讨论JSX。'
- en: '*React only has a one-way binding.* Although one-way binding is better for
    complex web apps and removes a lot of complexity, some developers (especially
    Angular developers) who got used to a two-way binding will find themselves writing
    a bit more code. We’ll explain how React’s one-way binding works compared to Angular’s
    two-way binding in chapter 9, which covers working with form data.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React 只具有单向绑定功能。* 虽然单向绑定对于复杂的Web应用来说更好，并且可以消除很多复杂性，但一些习惯了双向绑定的开发者（尤其是Angular开发者）会发现他们需要编写更多的代码。我们将在第9章中解释React的单向绑定是如何与Angular的双向绑定相比的，该章节涵盖了处理表单数据的内容。'
- en: '*React isn’t reactive (as in reactive programming and architecture, which are
    more event-driven, resilient, and responsive) out of the box*. Developers need
    to use other libraries, such as the React Query library, to make their applications
    integrate with external content seamlessly and responsively. This also requires
    developers to use a different mindset when developing React applications, or terribly
    coded applications will result from attempting to force a round React into a square
    architecture.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React本身不是响应式的（如响应式编程和架构，它们更注重事件驱动、弹性、响应性）*。开发者需要使用其他库，例如React Query库，以便使他们的应用程序能够无缝且响应式地集成外部内容。这也要求开发者以不同的心态开发React应用程序，否则在尝试将圆形的React强行塞入方形架构时，可能会产生糟糕的代码。'
- en: To continue with this introduction to React, let’s look at how it fits into
    a web application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续介绍React，让我们看看它是如何融入Web应用程序的。
- en: 1.3 How React can fit into your website
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 React如何融入您的网站
- en: Websites come in many variants, and React can be used to create interactive
    content in many types of websites, either as a replacement for other technologies
    or as a way to add new functionality to your website. React can be used on both
    “classic” websites that are mostly rendered by a server as well as client-side
    web applications, also known as single-page applications (SPAs), as mentioned
    earlier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 网站有多种变体，React可以用于创建多种类型网站中的交互式内容，无论是作为其他技术的替代品，还是作为向您的网站添加新功能的方式。React可以用于“经典”网站，这些网站主要是由服务器渲染的，以及客户端Web应用程序，也称为单页应用程序（SPAs），如前所述。
- en: The React core library is a UI library first and foremost. The core library
    alone is comparable to other UI libraries, but not directly comparable to more
    full-fledged web application frameworks such as Angular. However, combined with
    other libraries, either developed by the React team or other parties (e.g., React
    Router and Redux), React can be a full competitor to any web application framework.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: React核心库首先是一个UI库。仅核心库本身就可以与其他UI库相媲美，但并不能直接与其他更全面的Web应用程序框架（如Angular）相提并论。然而，结合其他库，无论是React团队开发的还是其他方（例如React
    Router和Redux）开发的，React可以成为任何Web应用程序框架的强大竞争对手。
- en: If you’re using another SPA framework (e.g., Angular, Vue, Ember, Backbone,
    etc.) to render your web application today, you’ll probably need to replace the
    entire thing with a React-based stack. It’s very difficult and bordering on impossible
    to create a hybrid SPA with some parts rendered by, for example, Angular, and
    others by React.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您今天正在使用其他SPA框架（例如Angular、Vue、Ember、Backbone等）来渲染您的Web应用程序，您可能需要用基于React的堆栈来替换整个系统。创建一个混合SPA，其中一些部分由Angular渲染，而其他部分由React渲染，是非常困难且几乎不可能的。
- en: You can use React for just part of your UI if you have a website with smaller
    interactive UI elements (or *widgets*). In such a case, you can replace your widgets
    one by one with small React applications, without changing everything else. These
    existing widgets might be written in plain JavaScript, jQuery, or even Angular
    or similar frameworks. As you go along converting widgets to React, you can evaluate
    the best fit for your organization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网站具有较小的交互式UI元素（或*小部件*），您可以使用React来处理UI的一部分。在这种情况下，您可以逐个用小的React应用程序替换您的widget，而不改变其他所有内容。这些现有的widget可能是用纯JavaScript、jQuery，甚至是Angular或类似的框架编写的。随着您将widget转换为React的过程，您可以评估最适合您组织的方案。
- en: React is backend agnostic for frontend development. In other words, you don’t
    have to rely on a JavaScript-based backend (Node or Deno) to use React. It’s fine
    to use React with any other backend technology, such as Java, Ruby, Go, or Python.
    React is a UI library, after all. You can integrate it with any backend and any
    frontend data library (Backbone, Angular, Meteor, etc.).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: React 对于前端开发来说后端无关。换句话说，你不需要依赖于基于 JavaScript 的后端（Node 或 Deno）来使用 React。使用 React
    与任何其他后端技术（如 Java、Ruby、Go 或 Python）配合都是可以的。毕竟，React 是一个 UI 库。你可以将其与任何后端和任何前端数据库（Backbone、Angular、Meteor
    等）集成。
- en: Another popular use case for React is for static site generators. In such a
    setup, React is used to define your website locally on your environment, but when
    deployed to the live server, it’s rendered “down” to a plain HTML website with
    JavaScript only doing a minimal bit of work to add interactivity. All your templates,
    and so on, will have been resolved. Initially, this was mostly popular for smaller
    websites, such as blogs, which don’t update too frequently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React 的另一个流行用途是用于静态站点生成器。在这种配置中，React 用于在本地环境中定义你的网站，但当部署到实时服务器时，它被渲染成仅包含 JavaScript
    的纯 HTML 网站，JavaScript 只做最小的工作来增加交互性。所有模板等都将得到解决。最初，这种方法主要适用于较小的网站，如博客，这些网站更新不太频繁。
- en: Recent advances in server-side React rendering have made this pre-rendered approach
    more and more popular even for larger SPAs that update often. You can do this
    with popular frameworks built on top of React, such as Next.js or Remix. These
    are considered *partially server-rendered web applications*, where your React
    code runs on both the server and in the client. You might, for example, pre-render
    a list on the server and add interactive filtering and sorting options in the
    client. This can sound a bit daunting, but newer frameworks such as Next.js and
    Remix make it relatively easy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端 React 渲染技术的最新进展使得这种预渲染方法在经常更新的大型 SPA 中也越来越受欢迎。你可以使用基于 React 的流行框架来实现这一点，例如
    Next.js 或 Remix。这些被认为是*部分服务器端渲染的 Web 应用程序*，其中你的 React 代码在服务器和客户端上同时运行。例如，你可以在服务器上预渲染一个列表，并在客户端添加交互式过滤和排序选项。这听起来可能有点令人畏惧，但像
    Next.js 和 Remix 这样的新框架使得这个过程相对容易。
- en: 'To summarize how React fits into a website, it’s most often used in these scenarios:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结 React 如何融入网站，它最常用于以下场景：
- en: As a UI library in an SPA, such as React+React Router+Redux
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为单页应用（SPA）中的 UI 库，例如 React+React Router+Redux
- en: As a drop-in widget in any frontend stack, such as a React autocomplete input
    component in a website built using any other combination of technologies
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为任何前端堆栈中的嵌入式小部件，例如在采用任何其他技术组合构建的网站中使用 React 自动完成输入组件
- en: As a static website rendered on deployment to serve infrequently updated content
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为在部署时渲染的静态网站，用于提供不经常更新的内容
- en: As a partially server-side-rendered website or SPA built on top of a more powerful
    framework potentially fed content by an external CMS, such as WordPress or Contentful
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为基于更强大框架构建的、可能由外部 CMS（如 WordPress 或 Contentful）提供内容的部分服务器端渲染网站或 SPA
- en: As a UI library in mobile apps using React Native, or desktop apps using Electron
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为使用 React Native 的移动应用程序或使用 Electron 的桌面应用程序中的 UI 库
- en: React works nicely with some frontend technologies, but it’s mostly used as
    a part of SPAs. We cover how React fits into an SPA in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'React 与一些前端技术配合得很好，但它主要被用作 SPA 的一部分。我们将在下一节中介绍 React 如何融入 SPA。 '
- en: 1.3.1 Single-page applications and React
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 单页应用与 React
- en: SPAs are a subset of websites in general. A website is considered an SPA if
    it has a lot of functionality directly available in the browser and not just information.
    Examples include Facebook, Google Docs, Gmail, and so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 是一般网站的一个子集。如果一个网站在浏览器中有大量直接可用的功能，而不仅仅是信息，那么它就被认为是 SPA。例如，Facebook、Google
    Docs、Gmail 等都是例子。
- en: SPAs are built using a multitude of technologies, of which React is only one
    potential part in the stack. You can’t even use React alone; at least a few other
    technologies are needed for React to be usable as a standalone application. In
    this section, we’ll establish what an SPA is in general and then point out how
    React fits into this structure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 是由多种技术构建的，其中 React 只是堆栈中可能的一部分。你甚至不能单独使用 React；至少还需要其他几种技术才能使 React 作为独立应用程序可用。在本节中，我们将介绍
    SPA 的一般概念，然后指出 React 如何融入这个结构。
- en: SPAs are also known as *thick clients* because the browser, being a client,
    holds more logic and performs functions such as rendering of the HTML, validation,
    UI changes, and so on. Contrast this with a thin client, where the browser client
    is only used to display information that has been pre-rendered by a server. In
    a thin client, the browser does very little work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SPA也被称为*胖客户端*，因为浏览器作为客户端，持有更多的逻辑并执行诸如HTML渲染、验证、UI更改等功能。与此相对的是瘦客户端，其中浏览器客户端仅用于显示由服务器预先渲染的信息。在瘦客户端中，浏览器的工作非常少。
- en: Figure 1.3 is a very high-level example of a generic SPA regardless of the technology
    used. It shows a bird’s-eye view of a typical architecture with a user, a browser,
    and a server. The figure depicts a user making a request, and the input actions
    of clicking a button, dragging and dropping, mouse hovering, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3是一个非常高级的通用SPA示例，无论使用什么技术。它展示了用户、浏览器和服务器组成的典型架构的鸟瞰图。图示了用户发起请求，以及点击按钮、拖放、鼠标悬停等输入操作。
- en: '![01-03](../Images/01-03.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![01-03](../Images/01-03.png)'
- en: Figure 1.3 A generic SPA architecture
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 通用SPA架构
- en: 'Let’s walk through this typical end-to-end process, following the numbered
    steps in figure 1.3:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照图1.3中的编号步骤，逐步走过这个典型的端到端过程：
- en: The user types a URL in the browser to open a new page.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在浏览器中输入URL以打开新页面。
- en: The browser sends a URL request to the server.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器向服务器发送URL请求。
- en: The server responds with static assets such as HTML, CSS, and JavaScript. In
    most cases, the HTML is bare-bones; that is, it has only a skeleton of the web
    page. Usually, there’s a “Loading . . . ” message and/or rotating spinner GIF.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应以静态资源，如HTML、CSS和JavaScript。在大多数情况下，HTML是骨架式的；也就是说，它只有网页的骨架。通常会有“加载……”消息和/或旋转的GIF。
- en: The static assets include the JavaScript code for the application. When loaded,
    this code makes additional requests for data.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态资源包括应用程序的JavaScript代码。当加载时，此代码会请求额外的数据。
- en: The data comes back in JSON, XML, or any other format.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据以JSON、XML或其他格式返回。
- en: Once the application receives the data, it can render missing HTML (the User
    Interface block in the figure). To put it differently, the process of rendering
    the UI occurs within the browser as the application injects data into pre-rendered
    templates, also known as *hydration*.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序接收到数据，它可以渲染缺失的HTML（图中的用户界面块）。换句话说，渲染UI的过程发生在浏览器中，因为应用程序将数据注入到预渲染的模板中，也称为*活化*。
- en: Once the browser rendering is finished, the browser updates the displayed content,
    and the user can work with the application.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦浏览器渲染完成，浏览器更新显示的内容，用户就可以与应用程序交互。
- en: The user sees a beautiful web page. The user may interact with the page (Inputs
    in the figure), triggering new requests from the application to the server, and
    the cycle of steps 2-6 continues. At this stage, browser routing may happen if
    the application implements it, meaning navigation to a new URL will trigger not
    a new page reload from the server, but rather an application re-render in the
    browser.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户看到一个漂亮的网页。用户可能与此页面交互（图中的输入），触发应用程序从服务器发送新的请求，并且步骤2-6的循环继续。在此阶段，如果应用程序实现了浏览器路由，则可能发生浏览器路由，这意味着导航到新的URL将不会触发从服务器的新页面重新加载，而是触发浏览器中的应用程序重新渲染。
- en: To summarize, in an SPA, most rendering for UIs happens in the browser. Only
    data travels to and from the browser. Contrast that with a “classic” website,
    which is not an SPA, where all the rendering happens on the server. React fits
    into this SPA architecture in steps 6 and 8 by rendering content based on data
    as well as handling user input and updating the content based on the updated data
    that results from these inputs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在SPA中，大多数UI渲染发生在浏览器中。只有数据在浏览器之间传输。与此相对的是“经典”网站，它不是SPA，所有的渲染都在服务器上完成。React通过根据数据渲染内容以及处理用户输入并根据这些输入的结果更新内容，在步骤6和8中适应了SPA架构。
- en: 1.3.2 The React stack
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 React堆栈
- en: React isn’t a full-blown, frontend JavaScript SPA framework. React is minimalistic
    in the sense that it only does a single job (rendering reactive UIs) and tries
    to do that very well. It doesn’t enforce a particular way of doing things such
    as data modeling, styling, or routing (it’s non-opinionated). Because of that,
    developers often need to pair React with a routing and/or data library.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: React 不是一个完整的、前端 JavaScript 单页应用 (SPA) 框架。React 在最小化方面表现得很好，因为它只做一件事情（渲染响应式
    UI）并且尽力做好。它不强制执行特定的做事方式，如数据建模、样式或路由（它没有特定的观点）。正因为如此，开发者通常需要将 React 与路由和/或数据库配对。
- en: 'While you can use React as a smaller part of your stack, developers most often
    opt to use a React-centric stack, which consists of the React core itself as well
    as data, routing, and styling libraries created to be used specifically with React,
    such as the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将 React 作为你技术栈的一个小部分来使用，但开发者通常更倾向于使用以 React 为中心的栈，这包括 React 核心本身以及专门为与
    React 一起使用而创建的数据、路由和样式库，例如以下内容：
- en: '*Data model libraries and backends*—Examples include TanStack Query ([https://tanstack.com/query/latest](https://tanstack.com/query/latest)),
    Redux ([http://redux.js.org](http://redux.js.org)), Recoil.js ([https://recoiljs.org/](https://recoiljs.org/)),
    XState ([https://xstate.js.org/](https://xstate.js.org/)), and Apollo ([www.apollographql.com/](http://www.apollographql.com/))'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据模型库和后端*—例如 TanStack Query ([https://tanstack.com/query/latest](https://tanstack.com/query/latest))、Redux
    ([http://redux.js.org](http://redux.js.org))、Recoil.js ([https://recoiljs.org/](https://recoiljs.org/))、XState
    ([https://xstate.js.org/](https://xstate.js.org/)) 和 Apollo ([www.apollographql.com/](http://www.apollographql.com/))'
- en: '*Routing library*—Often React Router ([https://github.com/remix-run/react-router](https://github.com/remix-run/react-router))
    or a similar router implemented in many frameworks'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路由库*—通常是 React Router ([https://github.com/remix-run/react-router](https://github.com/remix-run/react-router))
    或许多框架中实现的类似路由'
- en: '*Styling libraries*—Either a predefined set of styled components such as Material
    UI ([https://mui.com/](https://mui.com/)) or Bootstrap ([https://react-bootstrap.github.io/](https://react-bootstrap.github.io/))
    or a library to easily work with CSS inside React components, such as Styled-Components
    ([https://styled-components.com/](https://styled-components.com/)), Vanilla Extract
    ([https://vanilla-extract.style/](https://vanilla-extract.style/)), or even Tailwind
    CSS ([https://tailwindcss.com/](https://tailwindcss.com/))'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式库*—可以是预定义的样式组件集，如 Material UI ([https://mui.com/](https://mui.com/)) 或 Bootstrap
    ([https://react-bootstrap.github.io/](https://react-bootstrap.github.io/))，或者是一个库，可以轻松地在
    React 组件内部使用 CSS，如 Styled-Components ([https://styled-components.com/](https://styled-components.com/))、Vanilla
    Extract ([https://vanilla-extract.style/](https://vanilla-extract.style/))，甚至是
    Tailwind CSS ([https://tailwindcss.com/](https://tailwindcss.com/)))'
- en: The ecosystem of libraries for React is growing every day. In addition, React’s
    ability to describe composable components (self-contained chunks of the UI) enables
    code reuse. Many components are packaged as npm modules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: React 的库生态系统每天都在增长。此外，React 描述可组合组件（UI 的自包含块）的能力使得代码重用成为可能。许多组件被打包成 npm 模块。
- en: 'A great (curated) list of a lot of various React components for many purposes
    can be found here: [https://github.com/brillout/awesome-react-components](https://github.com/brillout/awesome-react-components).
    This list has everything from UI components (including tons of form elements)
    to complete UI frameworks to development utilities and testing tools.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到大量各种用途的 React 组件的精选列表：[https://github.com/brillout/awesome-react-components](https://github.com/brillout/awesome-react-components)。这个列表包括了从
    UI 组件（包括大量的表单元素）到完整的 UI 框架，再到开发工具和测试工具。
- en: React website frameworks
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: React 网站框架
- en: 'Another category of React frameworks is the full-blown server-side framework,
    which takes care of everything for you. Such frameworks come in two variants,
    but sometimes a framework can work in either way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类 React 框架是完整的后端框架，它为你处理所有事情。这些框架有两种变体，但有时一个框架可以以两种方式工作：
- en: Static site generators (SSGs)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态站点生成器 (SSGs)
- en: Dynamic server-rendered React (SSR)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态服务器端渲染的 React (SSR)
- en: SSGs are just that—frameworks that will generate a completely static website
    for you fully ready to deploy to any static website host, which requires very
    little work on your part and no expensive hosting. This is particularly popular
    for smaller personal websites such as blogs, but can also be used for smaller
    businesses and even e-commerce websites (that don’t require updates too often).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SSGs就是这样——为你生成一个完全静态的网站框架，完全准备好部署到任何静态网站托管服务，这需要你很少的工作，并且不需要昂贵的托管费用。这对于较小的个人网站，如博客来说尤其受欢迎，但也可以用于较小的商业网站，甚至电子商务网站（不需要经常更新）。
- en: SSR frameworks are more complex and will take care of pre-rendering your React
    application on the server before serving the HTML over the wire to your visitors’
    browsers. This means it’s good for SEO, embraces shareability, and has many other
    benefits.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: SSR框架更为复杂，它们会在服务器上预先渲染你的React应用，然后再通过网络将HTML发送给访客的浏览器。这意味着它对SEO友好，易于分享，并且具有许多其他优点。
- en: 'We’ll list three such frameworks here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里列出三个这样的框架：
- en: '*Gatsby*—This very popular blogging framework is also useful for many other
    types of static websites.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gatsby*——这个非常流行的博客框架也适用于许多其他类型的静态网站。'
- en: '*Next.js*—As probably the most popular React website framework out there, this
    is useful for both small static websites and huge dynamic behemoths.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Next.js*——作为最流行的React网站框架之一，它适用于小型静态网站和大型动态网站。'
- en: '*Remix*—This fairly new kid on the block is gaining traction and popularity
    very quickly in serving super-fast dynamic React websites.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Remix*——这个相对较新的框架在快速动态React网站服务方面迅速获得了关注和人气。'
- en: All of these frameworks—and many, many more—are different extensions of React,
    each functioning by its own paradigms. They all add extra functionality on top
    of React and sometimes also come with a set of React components that helps you
    create your website to utilize the framework to its fullest.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些框架——以及许多许多其他框架——都是React的不同扩展，每个框架都按照自己的范式运行。它们都在React之上添加了额外的功能，有时还附带一组React组件，帮助你充分利用框架创建网站。
- en: By now, you should have an understanding of what React is, its stack, its place
    in higher-level web applications, and how you can use tools built on top of React
    to generate complex websites. It’s time to get your hands dirty and write your
    first React application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经了解了React是什么，它的技术栈，它在高级Web应用中的位置，以及如何使用建立在React之上的工具来生成复杂的网站。现在是时候动手编写你的第一个React应用了。
- en: '1.4 Your first React app: Hello World'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 你的第一个React应用：Hello World
- en: Let’s explore your first React application by implementing a Hello World application—the
    quintessential example used for learning programming languages (see figure 1.4).
    If we don’t, the gods of programming might punish us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个Hello World应用来探索你的第一个React应用——这是用于学习编程语言的典范示例（见图1.4）。如果我们不这样做，编程之神可能会惩罚我们。
- en: '![01-04](../Images/01-04.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![01-04](../Images/01-04.png)'
- en: Figure 1.4 The process to create your first React application has just three
    simple steps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 创建你的第一个React应用的过程只有三个简单的步骤。
- en: 'You’ll need a few things before you can get going. Fortunately, because we’re
    developing an application that runs in the browser, you don’t need all sorts of
    compilers or libraries. Here’s the short list of things you do need before you
    can get started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，你需要准备一些东西。幸运的是，因为我们正在开发一个在浏览器中运行的应用，所以你不需要各种编译器或库。以下是你开始之前需要的东西的简要列表：
- en: A text editor.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器。
- en: Knowledge of how to use the terminal on your system.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在你的系统上使用终端。
- en: Have npm version 5.2 or newer installed (given that version 5.2 has been around
    since July 2017, odds are strong that your npm version is good enough if you have
    one).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保已经安装了npm版本5.2或更高版本（鉴于5.2版本自2017年7月以来就已经存在，如果你有这个版本，那么你的npm版本应该足够好了）。
- en: Have a modern browser installed (any recent version of Edge, Firefox, Chrome,
    or Safari will work).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个现代浏览器（任何Edge、Firefox、Chrome或Safari的最新版本都可以）。
- en: And that’s about it. If you can check off this list, you’re good to go for this
    first example. When we get to other examples in future chapters, you won’t need
    a lot more than what’s on this list.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果你能勾选这个清单，那么对于这个第一个例子来说你就准备好了。当我们进入未来章节中的其他示例时，你不需要比这个清单上更多的东西。
- en: 1.4.1 The result
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 结果
- en: The project will print a *“*Hello world!!!” heading (<h1>) on a web page. Figure
    1.5 shows what it will look like when you’re finished (unless you’re not quite
    that enthusiastic and prefer just a single exclamation point).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将在网页上打印一个 *“*Hello world!!!” 标题（<h1>）。图 1.5 展示了完成后的样子（除非你并不那么热情，只想用一个感叹号）。
- en: '![01-05](../Images/01-05.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![01-05](../Images/01-05.png)'
- en: Figure 1.5 Hello World application
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 Hello World 应用程序
- en: You won’t be using JSX yet, just plain JavaScript (we actually won’t start using
    JSX until chapter 3 and onward).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在还不会使用 JSX，只是纯 JavaScript（我们实际上直到第 3 章才会开始使用 JSX）。
- en: Learning React first without JSX
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先学习 React 而不是 JSX
- en: Although all React developers write React using JSX, browsers will only run
    standard JavaScript and not understand JSX directly. That’s why it’s beneficial
    to be able to understand React code in pure JavaScript. Another reason we’re starting
    with plain JavaScript is to show that JSX is optional, albeit the de facto standard
    template language for React. Finally, preprocessing JSX requires a bit more tooling,
    but it will make the whole setup simpler because you’ll see less of how the sausage
    is made and do more of the fun stuff—writing awesome React components.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有 React 开发者都使用 JSX 编写 React，但浏览器只会运行标准 JavaScript，而不会直接理解 JSX。这就是为什么能够理解纯
    JavaScript 中的 React 代码是有益的。我们之所以从纯 JavaScript 开始，另一个原因是想表明 JSX 是可选的，尽管它是 React
    的实际标准模板语言。最后，预处理 JSX 需要更多的工具，但这样会使整个设置更简单，因为你将看到更少的“制作香肠”的过程，而能更多地做有趣的事情——编写出色的
    React 组件。
- en: We want to get you started with React as soon as possible without spending too
    much time on setups in this chapter. You’ll be introduced to how to start a new
    application in chapter 2, and we’ll add JSX to the mix in chapter 3.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽快让你开始使用 React，而不会在这个章节中花费太多时间在设置上。你将在第 2 章中了解如何启动一个新的应用程序，我们将在第 3 章中添加
    JSX。
- en: 1.4.2 Writing the application
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 编写应用程序
- en: This project is so simple, it’ll only consist of a single HTML file. This file
    will include links to the most recent versions of React 18 (the most stable version
    at the time of writing) of the React Core and ReactDOM libraries. It will also,
    of course, include a tiny bit of JavaScript code required to render the very simple
    application that we’re building.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目非常简单，它只包含一个 HTML 文件。这个文件将包含指向 React 18（写作时的最稳定版本）的 React 核心和 ReactDOM 库的最新版本的链接。当然，它还将包含一小段
    JavaScript 代码，用于渲染我们正在构建的非常简单的应用程序。
- en: The code for the HTML file is simple and starts with the inclusion of the libraries
    in <head>. In the <body> element, you’ll create a <div> container with the ID
    root and a <script> element (that’s where the app’s code will go later), as shown
    in the following listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文件的代码很简单，从在 `<head>` 中包含库开始。在 `<body>` 元素中，你将创建一个具有 ID root 的 `<div>` 容器和
    `<script>` 元素（稍后应用程序的代码将放在这里），如下所示。
- en: Listing 1.1 Loading React libraries and code
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 加载 React 库和代码
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Imports the React library
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 React 库
- en: ❷ Imports the ReactDOM library
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入 ReactDOM 库
- en: ❸ Defines an empty <div> element to mount the React UI
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义一个空的 `<div>` 元素来挂载 React UI
- en: ❹ Creates a script node that will hold our JavaScript
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个将包含我们的 JavaScript 的脚本节点
- en: ❺ The actual JavaScript code will go in here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 实际的 JavaScript 代码将放在这里。
- en: Just type this code using your text editor and save it as a file named index.html
    in some folder on your machine.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用你的文本编辑器输入此代码，并将其保存为名为 index.html 的文件，存放在你的机器上的某个文件夹中。
- en: 'You might be wondering why we have to create a <div> node to render the content
    into instead of rendering the React element directly in the <body> element. The
    answer is that doing so can lead to conflict with other libraries and browser
    extensions that manipulate the document body. If you try attaching an element
    directly to the body, you’ll get this console error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不得不创建一个 `<div>` 节点来渲染内容，而不是直接在 `<body>` 元素中渲染 React 元素。答案是这样做可能会导致与其他库和操作文档体的浏览器扩展发生冲突。如果你尝试直接将元素附加到
    body 上，你会在控制台中看到这个错误：
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is another good thing about React: it has great warnings and error messages!'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 React 的一个优点：它有很好的警告和错误信息！
- en: Note React warning and error messages aren’t part of the production build to
    reduce noise, increase security, and minimize the distribution size. The production
    build is the minified file from the React Core library, that is, react.min.js.
    The development version with the warnings and error messages is the unminified
    version, react.development.js, as you see us using in this example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：React 的警告和错误消息不是生产构建的一部分，以减少噪音、提高安全性和最小化分发大小。生产构建是从 React 核心库中提取的压缩文件，即 react.min.js。带有警告和错误消息的开发版本是未压缩版本，react.development.js，正如你在本例中看到的那样使用。
- en: 'By including the libraries in the HTML file, you get access to the React and
    ReactDOM global objects: window.React and window.ReactDOM. You’ll need two methods
    from those objects: one to create an element (React) and another to render it
    in the <div> container (ReactDOM), as shown in listing 1.2\. To create a React
    element, all you need to do is call React.createElement(elementName, data, children)
    with three arguments that have the following meanings:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 HTML 文件中包含库，你可以访问 React 和 ReactDOM 全局对象：window.React 和 window.ReactDOM。你需要从这些对象中获取两个方法：一个用于创建元素（React）和另一个用于将其渲染到
    <div> 容器中（ReactDOM），如列表 1.2 所示。要创建一个 React 元素，你所需要做的就是调用 React.createElement(elementName,
    data, children) 并传递三个具有以下意义的参数：
- en: elementName—HTML tag as a string (e.g., 'h1') or a custom component class as
    an object. We don’t have any custom components just yet, but we’ll start creating
    those in chapter 2.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: elementName——HTML 标签作为字符串（例如，'h1'）或自定义组件类作为对象。我们目前还没有任何自定义组件，但我们将从第 2 章开始创建那些组件。
- en: data—A data object containing attributes and properties for the element. We
    don’t need any properties now, so we just pass null. We’ll get back to using properties
    in chapter 2.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据对象——包含元素属性和属性的 data 对象。我们现在不需要任何属性，所以我们只传递 null。我们将在第 2 章中重新使用属性。
- en: children—Child elements or inner HTML/text content. In this example, it’s just
    “Hello world!!!”.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子元素——子元素或内部 HTML/文本内容。在这个例子中，它只是“Hello world!!!”。
- en: Listing 1.2 Creating and rendering an h1 element
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 创建并渲染 h1 元素
- en: '[PRE5]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates an h1 React element with the text “Hello world!!!”
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个带有文本“Hello world!!!”的 h1 React 元素
- en: ❷ Grabs a reference to the DOM element on the page with ID “root”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取页面中 ID 为“root”的 DOM 元素的引用
- en: ❸ Creates a root holder for the React application connected to the specific
    DOM element
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为连接到特定 DOM 元素的 React 应用程序创建一个根容器
- en: ❹ Renders the h1 element into the root holder
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 h1 元素渲染到根容器中
- en: The code in listing 1.2 goes into the <script> tag in the HTML file, which you
    created before, in place of the ... that we originally put there as a placeholder.
    This listing gets a React element and stores the reference to this object in the
    reactElement variable. The reactElement variable isn’t an actual DOM node; rather,
    it’s an instantiation of the React h1 component (element). You can name it any
    way you want, for example, helloWorldHeading. In other words, React provides an
    abstraction over the DOM.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 中的代码放入 HTML 文件中的 <script> 标签，这是你之前创建的，代替我们最初放置的占位符 ...。此列表获取一个 React
    元素并将对该对象的引用存储在 reactElement 变量中。reactElement 变量不是一个实际的 DOM 节点；而是 React h1 组件（元素）的实例化。你可以按任何你想要的方式命名它，例如，helloWorldHeading。换句话说，React
    提供了对 DOM 的抽象。
- en: Once the element is created and stored in the variable, you then create a React
    application holder (called *root*) from the DOM element using the ReactDOM.createRoot()
    method. Finally, you render the React element into the root with the root .render()
    method, shown in listing 1.2.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦元素被创建并存储在变量中，然后你使用 ReactDOM.createRoot() 方法从 DOM 元素创建一个 React 应用程序容器（称为 *root*）。最后，你使用
    root 的 .render() 方法将 React 元素渲染到根中，如列表 1.2 所示。
- en: If you prefer, you can move all steps into a single call. The result is the
    same, except you don’t use the three extra variables, as we’ve done in the next
    listing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以将所有步骤移动到一个单独的调用中。结果是一样的，只是你不使用我们接下来列表中所做的三个额外变量。
- en: Listing 1.3 Single statement
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.3 单语句
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll be using the more explicit version in listing 1.2, so the full HTML file
    should now look like the following listing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在列表 1.2 中使用更明确的版本，所以完整的 HTML 文件现在应该看起来像以下列表。
- en: Listing 1.4 Creating and rendering an h1 element
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 创建并渲染 h1 元素
- en: '[PRE7]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The inserted JavaScript is located in its proper place.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 插入的 JavaScript 位于其适当的位置。
- en: With the HTML file completed, we now need to see this in action by serving the
    content to our browser.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文件完成后，我们现在需要通过将内容提供给我们的浏览器来查看其效果。
- en: 1.4.3 Installing and running a web server
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 安装和运行一个网络服务器
- en: Now comes the next step, serving the HTML page to a browser. Why do we need
    to serve the content? Can’t we just open the HTML file directly in the browser?
    Due to cross-origin restrictions, you can’t open a file located on your local
    hard drive in the browser and have it access content on other domains (such as
    the React libraries loaded from [https://unpkg.com](https://unpkg.com)). Browsers
    simply don’t allow this. You can try to open the file in your browser directly
    by double-clicking it, but it will just show an empty white page. So that’s no
    good.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是下一步，将HTML页面服务到浏览器。为什么我们需要服务内容？我们难道不能直接在浏览器中打开HTML文件吗？由于跨域限制，你无法在浏览器中打开位于本地硬盘上的文件，并使其访问其他域的内容（例如从[https://unpkg.com](https://unpkg.com)加载的React库）。浏览器根本不允许这样做。你可以尝试通过双击文件直接在浏览器中打开它，但它只会显示一个空白的白色页面。所以这不是一个好的方法。
- en: Instead, we need to serve the content using a local development web server.
    That might sound terribly complex, but it’s surprisingly simple to do today.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要使用本地开发Web服务器来服务内容。这听起来可能非常复杂，但今天做起来却出奇地简单。
- en: 'If you have node set up as recommended in the introduction, this will be enough
    to get you going. Just type the following command in the folder where you saved
    your index.html file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照介绍中的建议设置了node，这将足够你开始使用。只需在你的index.html文件所在的文件夹中输入以下命令：
- en: '[PRE8]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s it. You might be asked to install a package (if you haven’t used this
    command before, simply press Enter to confirm), but after a few seconds, once
    the tool reports that everything is rolling, your web server is running.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你可能会被要求安装一个包（如果你之前没有使用过这个命令，只需按下Enter键确认即可），但几秒钟后，一旦工具报告一切都在正常运行，你的Web服务器就已经启动了。
- en: Local development web server
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本地开发Web服务器
- en: Unfortunately, in this very first example, you have to worry about setting up
    your own local web server. Although the task is very simple, it’s a bit annoying
    to do here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在这个非常第一个例子中，你必须担心设置自己的本地Web服务器。尽管这个任务非常简单，但在这里做起来有点烦人。
- en: If for some reason the given command doesn’t work for you, there are a couple
    of other ways to easily serve the current folder as a local web server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，给定的命令对你不起作用，还有其他几种方法可以轻松地将当前文件夹作为本地Web服务器提供服务。
- en: 'If you have Node, you can try this command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了Node，你可以尝试这个命令：
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, if you have a working Python 2 installation on your computer,
    you can just do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你在电脑上有一个工作的Python 2安装，你可以直接这样做：
- en: '[PRE10]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or, if you have a working Python 3 installation, you can do this (you might
    have to type python3 rather than python in the following depending on your setup):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你有一个工作的Python 3安装，你可以这样做（根据你的设置，你可能需要输入python3而不是python）：
- en: '[PRE11]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, if you have a PHP setup working locally, you can do this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在本地已经设置好了PHP环境，你可以这样做：
- en: '[PRE12]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Any of those commands will run a local web server on your computer in the folder
    where you run the command serving your HTML file to http:/ /localhost:3000.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些命令都会在你的电脑上运行一个本地Web服务器，在运行命令的文件夹中，将你的HTML文件服务到http://localhost:3000。
- en: 1.4.4 Going to the local website
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 访问本地网站
- en: 'With the web server running, you can now use your browser and go to this site:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web服务器运行时，你现在可以使用浏览器并访问这个网站：
- en: '[PRE13]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you should be able to see your application in action, and it should look
    pretty much like figure 1.5 at the start of this section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该能看到你的应用正在运行，并且它应该看起来与这一节开头的图1.5非常相似。
- en: Figure 1.6 shows the Elements tab in the browser developer tools with the <h1>
    element selected. You know that React must have done something here because, in
    your source HTML file, there’s no <h1> element inside the root node—it was empty.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6显示了浏览器开发者工具中的元素标签页，其中选择了<h1>元素。你知道React在这里一定做了些什么，因为在你源HTML文件中，根节点内没有<h1>元素——它是空的。
- en: '![01-06](../Images/01-06.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![01-06](../Images/01-06.png)'
- en: Figure 1.6 Inspecting the Hello World web app as rendered by React
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 检查由React渲染的Hello World Web应用
- en: Congratulations! You’ve just implemented your first React application!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚实现了你的第一个React应用！
- en: Separate JavaScript file
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 分离的JavaScript文件
- en: 'You can abstract the JavaScript code into a separate file instead of including
    the script directly in the HTML file (refer to listing 1.1). For example, you
    can create a file named script.js and copy and paste the entire snippet from either
    listing 1.2 or listing 1.3 into that file. Then, in the HTML file, you need to
    link to your script.js file after the <div id="root"> rather than include the
    script itself, like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 JavaScript 代码抽象成一个单独的文件，而不是直接在 HTML 文件中包含脚本（参考列表 1.1）。例如，你可以创建一个名为 script.js
    的文件，并将列表 1.2 或列表 1.3 中的整个片段复制粘贴到该文件中。然后，在 HTML 文件中，你需要在 <div id="root"> 之后链接到你的
    script.js 文件，而不是包含脚本本身，如下所示：
- en: '[PRE14]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the next chapter going forward, we won’t be creating our React applications
    like this. We’ll be using a small tool to quickly generate and set up our React
    application basics for us, which will make this entire process much smoother.
    It will take care of serving our content as well, so you don’t have to worry about
    web servers anymore.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们不会像这样创建我们的 React 应用程序。我们将使用一个小工具来快速生成和设置我们的 React 应用程序基本设置，这将使整个过程更加顺畅。它还将负责提供我们的内容，所以你再也不用担心
    Web 服务器了。
- en: 1.5 Quiz
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 问答
- en: React is a complete framework in and of itself, and you can create many applications
    using nothing but React. *True* or *false*?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 是一个完整的框架，本身就可以创建许多应用程序，仅使用 React 就可以。*正确*还是*错误*？
- en: What is the primary problem that React solves?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 解决的主要问题是什么？
- en: Fetching data from the server
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: Creating beautiful HTML widgets
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建漂亮的 HTML 小部件
- en: Rendering dynamic data in a UI layer
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UI 层渲染动态数据
- en: React components are rendered into the DOM with which of the following methods?
    (Beware, it’s a tricky question!)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 组件是通过以下哪种方法渲染到 DOM 中的？（注意，这是一个棘手的问题！）
- en: ReactDOM.appendRoot(...).render()
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReactDOM.appendRoot(...).render()
- en: ReactDOM.renderRoot(...).render()
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReactDOM.renderRoot(...).render()
- en: ReactDOM.createRoot(...).render()
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReactDOM.createRoot(...).render()
- en: ReactDOM.launchRoot(...).render()
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReactDOM.launchRoot(...).render()
- en: You have to use Node.js on the server to be able to use React in your SPA. *True*
    or *false*?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须在服务器上使用 Node.js 才能使用 React 在你的 SPA 中。*正确*还是*错误*？
- en: You must include react-dom.js to render React elements on a web page. *True*
    or *false*?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须包含 react-dom.js 以在网页上渲染 React 元素。*正确*还是*错误*？
- en: Quiz answers
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问答答案
- en: '*False*. You almost always have to use other frameworks or libraries to create
    the vast majority of React applications.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。你几乎总是需要使用其他框架或库来创建大多数 React 应用程序。'
- en: While you can create beautiful HTML widgets in React, the primary problem that
    React solves is to *render dynamic data in a UI layer* (answer *c*).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你可以在 React 中创建漂亮的 HTML 小部件，但 React 解决的主要问题是在 UI 层*渲染动态数据*（答案 *c*）。
- en: ReactDOM.createRoot(...).render().
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReactDOM.createRoot(...).render().
- en: '*False*. You can use any backend technology.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。你可以使用任何后端技术。'
- en: '*True*. You need the ReactDOM library.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正确*。你需要 ReactDOM 库。'
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: React for the web consists of the React Core and ReactDOM libraries. React Core
    is a library geared toward building and sharing composable UI components using
    JavaScript and (optionally) JSX in a universal manner. On the other hand, to work
    with React in the browser, you can use the ReactDOM library, which has methods
    for DOM rendering as well as for server-side rendering.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React for the web 由 React Core 和 ReactDOM 库组成。React Core 是一个库，旨在以通用方式使用 JavaScript
    和（可选）JSX 构建、共享可组合的 UI 组件。另一方面，要在浏览器中使用 React，你可以使用 ReactDOM 库，它具有 DOM 渲染以及服务器端渲染的方法。
- en: React is declarative; it’s only a view or UI layer.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是声明式的；它只是一个视图或 UI 层。
- en: React uses components that you bring into existence with ReactDOM.createRoot().
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 使用你通过 ReactDOM.createRoot() 创建的组件。
- en: You use pure JavaScript to develop and compose UIs in React.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用纯 JavaScript 在 React 中开发和组合 UI。
- en: Although optional, you don’t need to use JSX (an HTML-like syntax for React
    objects) when developing with React, but everyone does.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然是可选的，但在使用 React 开发时，你不需要使用 JSX（React 对象的类似 HTML 的语法），但每个人都在这样做。
- en: React can fit into your web stack in many ways, from just a small widget on
    some page to the foundation of your entire website.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 可以以多种方式融入你的 Web 栈，从某些页面上的小部件到整个网站的基石。
- en: React is not a Swiss Army knife, but rather the UI layer of a web application
    that also consists of many other parts. React is often used together with data
    libraries such as Redux or XState.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 不是一个瑞士军刀，而是由许多其他部分组成的 Web 应用程序的 UI 层。React 通常与 Redux 或 XState 等数据库一起使用。
