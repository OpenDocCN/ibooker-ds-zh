- en: Chapter 3\. Time Series Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。时间序列分析
- en: Now that I’ve covered SQL and databases and the key steps in preparing data
    for analysis, it’s time to turn to specific types of analysis that can be done
    with SQL. There are a seemingly unending number of data sets in the world, and
    correspondingly infinite ways in which they could be analyzed. In this and the
    following chapters, I have organized types of analysis into themes that I hope
    will be helpful as you build your analysis and SQL skills. Many of the techniques
    to be discussed build on those shown in [Chapter 2](ch02.xhtml#preparing_data_for_analysis)
    and then on the preceding chapters as the book progresses. Time series of data
    are so prevalent and so important that I’ll start the series of analysis themes
    here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讲解了 SQL 和数据库以及准备数据分析的关键步骤，是时候转向可以使用 SQL 进行的具体分析类型了。世界上似乎有无数的数据集，因此它们可以分析的方式也几乎是无限的。在本章节和接下来的章节中，我将把分析类型组织成主题，希望这些主题能帮助您建立分析和
    SQL 技能。许多将要讨论的技术是基于[第二章](ch02.xhtml#preparing_data_for_analysis)和随着本书进展的前几章展示的技术。数据的时间序列如此普遍且重要，以至于我将从这里开始讨论分析主题系列。
- en: Time series analysis is one of the most common types of analysis done with SQL.
    A *time series* is a sequence of measurements or data points recorded in time
    order, often at regularly spaced intervals. There are many examples of time series
    data in daily life, such as the daily high temperature, the closing value of the
    S&P 500 stock index, or the number of daily steps recorded by your fitness tracker.
    Time series analysis is used in a wide variety of industries and disciplines,
    from statistics and engineering to weather forecasting and business planning.
    Time series analysis is a way to understand and quantify how things change over
    time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析是使用 SQL 进行的最常见的分析类型之一。*时间序列* 是按时间顺序记录的一系列测量或数据点，通常是在定期间隔。日常生活中有许多时间序列数据的例子，如每日最高温度、标准普尔500股票指数的收盘价，或者您的健身追踪器记录的每日步数。时间序列分析广泛应用于各行各业，从统计学和工程学到天气预报和业务规划。时间序列分析是理解和量化事物随时间变化的一种方法。
- en: Forecasting is a common goal of time series analysis. Since time only marches
    forward, future values can be expressed as a function of past values, while the
    reverse is not true. However, it’s important to note that the past doesn’t perfectly
    predict the future. Any number of changes to wider market conditions, popular
    trends, product introductions, or other large changes make forecasting difficult.
    Still, looking at historical data can lead to insights, and developing a range
    of plausible outcomes is useful for planning. As I’m writing this, the world is
    in the midst of a global COVID-19 pandemic, the likes of which haven’t been seen
    in 100 years—predating all but the most long-lived organizations’ histories. Thus
    many current organizations haven’t seen this specific event before, but they have
    existed through other economic crises, such as those following the dot-com burst
    and the 9/11 attacks in 2001, as well as the global financial crisis of 2007–2008\.
    With careful analysis and understanding of context, we can often extract useful
    insights.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 预测是时间序列分析的一个常见目标。由于时间只会向前推进，未来的值可以表示为过去值的函数，反之则不成立。然而，重要的是要注意，过去并不能完美预测未来。任何广泛市场条件、流行趋势、产品推出或其他重大变化的变动都会使预测变得困难。尽管如此，查看历史数据可以带来洞察，并开发一系列合理的结果对计划非常有用。在我撰写本文时，全球正处于一场前所未有的COVID-19大流行中，这样的情况已有100年未见——早于所有但最长寿的组织历史。因此，许多现有的组织尚未经历过这种特定事件，但它们已经经历了其他经济危机，比如2001年的互联网泡沫破裂和9/11袭击，以及2007年至2008年的全球金融危机。通过仔细分析和理解背景，我们通常可以提取有用的见解。
- en: 'In this chapter, we’ll first cover the SQL building blocks of time series analysis:
    syntax and functions for working with dates, timestamps, and time. Next, I’ll
    introduce the retail sales data set used for examples throughout the rest of the
    chapter. A discussion of methods for trending analysis follows, and then I’ll
    cover calculating rolling time windows. Next are period-over-period calculations
    to analyze data with seasonality components. Finally, we’ll wrap up with some
    additional techniques that are useful for time series analysis.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先介绍时间序列分析的SQL基本构建块：用于处理日期、时间戳和时间的语法和函数。接下来，我将介绍本章后续示例中使用的零售销售数据集。随后是趋势分析方法的讨论，然后是计算滚动时间窗口。接下来是周期对比计算，用于分析具有季节性成分的数据。最后，我们将介绍一些其他对时间序列分析有用的技术。
- en: Date, Datetime, and Time Manipulations
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期、日期时间和时间操作
- en: Dates and times come in a wide variety of formats, depending on the data source.
    We often need or want to transform the raw data format for our output, or to perform
    calculations to arrive at new dates or parts of dates. For example, the data set
    might contain transaction timestamps, but the goal of the analysis is to trend
    monthly sales. At other times, we might want to know how many days or months have
    elapsed since a particular event. Fortunately, SQL has powerful functions and
    formatting capabilities that can transform just about any raw input to almost
    any output we might need for analysis.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间以多种格式呈现，取决于数据源。我们经常需要或希望转换原始数据格式以便输出，或者执行计算以得出新的日期或日期部分。例如，数据集可能包含交易时间戳，但分析的目标是趋势分析月度销售。其他时候，我们可能想知道自特定事件以来经过了多少天或多少个月。幸运的是，SQL具有强大的函数和格式化功能，可以将几乎任何原始输入转换为我们分析所需的几乎任何输出。
- en: In this section, I’ll show you how to convert between time zones, and then I’ll
    go into depth on formatting dates and datetimes. Next, I’ll explore date math
    and time manipulations, including those that make use of intervals. An interval
    is a data type that holds a span of time, such as a number of months, days, or
    hours. Although data can be stored in a database table as an interval type, in
    practice I rarely see this done, so I will talk about intervals alongside the
    date and time functions that you can use them with. Last, I’ll discuss some special
    considerations when joining or otherwise combining data from different sources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将向您展示如何在不同时区之间转换，并深入讨论日期和日期时间的格式化。接下来，我将探讨日期数学和时间操作，包括使用时间间隔的操作。时间间隔是一种数据类型，表示一段时间，如几个月、几天或几小时。虽然数据可以存储在数据库表中作为时间间隔类型，但在实际操作中我很少见到这样做，因此我会在讨论日期和时间函数时同时介绍时间间隔。最后，我将讨论从不同数据源联接或组合数据时的一些特殊考虑因素。
- en: Time Zone Conversions
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时区转换
- en: Understanding the standard time zone used in a data set can prevent misunderstandings
    and mistakes further into the analysis process. Time zones split the world into
    north-south regions that observe the same time. Time zones allow different parts
    of the world to have similar clock times for daytime and nighttime—so, for example,
    the sun is overhead at 12 p.m. wherever you are in the world. The zones follow
    irregular boundaries that are as much political as geographic ones. Most are one
    hour apart, but some are offset only 30 or 45 minutes, and so there are more than
    30 time zones spanning the globe. Many countries that are distant from the equator
    observe daylight savings time for parts of the year as well, but there are exceptions,
    such as in the United States and Australia, where some states observe daylight
    savings time and others do not. Each time zone has a standard abbreviation, such
    as PST for Pacific Standard Time and PDT for Pacific Daylight Time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据集中使用的标准时区可以防止在分析过程的后期出现误解和错误。时区将世界分为观察同一时间的南北地区。时区允许世界上不同地区在白天和黑夜拥有类似的时钟时间，因此无论您身处世界何处，太阳在正午时都会在头顶上。时区遵循不规则的边界，这些边界既有政治性质也有地理性质。大多数时区相隔一小时，但有些只相隔30或45分钟，全球共有30多个时区。许多远离赤道的国家在一年中的部分时间内采用夏令时，但也有例外，如美国和澳大利亚，其中一些州采用夏令时，而其他州则不采用。每个时区都有一个标准缩写，例如太平洋标准时间的PST和太平洋夏令时间的PDT。
- en: Many databases are set to *Coordinated Universal Time* (UTC), the global standard
    used to regulate clocks, and record events in this time zone. It replaced *Greenwich
    Mean Time* (GMT), which you might still see if your data comes from an older database.
    UTC does not have daylight savings time, so it stays consistent all year long.
    This turns out to be quite useful for analysis. I remember one time a panicked
    product manager asked me to figure out why sales on a particular Sunday dropped
    so much compared to the prior Sunday. I spent hours writing queries and investigating
    possible causes before eventually figuring out that our data was recorded in Pacific
    Time (PT). Daylight savings started early Sunday morning, the database clock moved
    ahead 1 hour, and the day had only 23 hours instead of 24, and thus sales appeared
    to drop. Half a year later we had a corresponding 25-hour day, when sales appeared
    unusually high.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库设置为*协调世界时*（UTC），这是用于调节时钟的全球标准，并在此时区记录事件。它取代了*格林威治标准时间*（GMT），如果您的数据来自旧数据库，您可能仍然会看到
    GMT。UTC 没有夏令时，因此整年保持一致。这对分析非常有用。我记得有一次，一位惊慌失措的产品经理让我找出为什么某个特定星期日的销售额与前一个星期日相比下降这么多。我花了几个小时编写查询和调查可能的原因，最终发现我们的数据记录在太平洋时间（PT）中。夏令时在周日凌晨开始，数据库时钟向前移动了1小时，这一天只有23小时而不是24小时，因此销售额似乎下降了。半年后，我们经历了一个对应的25小时的日子，销售额看起来异常高。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Often timestamps in the database are not encoded with the time zone, and you
    will need to consult with the source or developer to figure out how your data
    was stored. UTC has become most common in the data sets I see, but that is certainly
    not universal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的时间戳通常没有编码时区信息，您需要与数据源或开发人员协商以确定数据的存储方式。我见过的数据集中，UTC 已经成为最常见的时间表示方式，但这并不是普遍适用的。
- en: One drawback to UTC, or really to any logging of machine time, is that we lose
    information about the local time for the human doing the actions that generated
    the event recorded in the database. I might want to know whether people tend to
    use my mobile app more during the workday or during nights and weekends. If my
    audience is clustered in one time zone, it’s not hard to figure this out. But
    if the audience spans multiple time zones or is international, then it becomes
    a calculation task of converting each recorded time to its local time zone.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: UTC 或任何机器时间记录的一个缺点是，我们丢失了生成数据库记录事件的人类操作的本地时间信息。我可能想知道人们在工作日还是在夜间和周末更频繁地使用我的移动应用。如果我的受众集中在一个时区内，那么弄清楚这一点并不难。但如果受众跨越多个时区或国际范围，那么将每个记录的时间转换为其本地时区就成为一个计算任务。
- en: 'All local time zones have a UTC offset. For example, the offset for PDT is
    UTC – 7 hours, while the offset for PST is UTC – 8 hours. Timestamps in databases
    are stored in the format YYYY-MM-DD hh:mi:ss (for years-months-days hours:minutes:seconds).
    Timestamps with the time zone have an additional piece of information for the
    UTC offset, expressed as a positive or negative number. Converting from one time
    zone to another can be accomplished with `at time zone` followed by the destination
    time zone’s abbreviation. For example, we can convert a timestamp in UTC (offset
    – 0) to PST:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有本地时区都有一个 UTC 偏移量。例如，PDT 的偏移量是 UTC - 7 小时，而 PST 的偏移量是 UTC - 8 小时。数据库中的时间戳以
    YYYY-MM-DD hh:mi:ss 格式存储（年-月-日 时:分:秒）。带有时区的时间戳有一个额外的信息块，表示为正数或负数的 UTC 偏移量。可以使用
    `at time zone` 后跟目标时区的缩写来实现从一个时区到另一个时区的转换。例如，我们可以将 UTC 中的时间戳（偏移量 - 0）转换为 PST：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The destination time zone name can be a constant, or a database field, allowing
    this conversion to be dynamic to the data set. Some databases have a `convert_timezone`
    or `convert_tz` function that works similarly. One argument is the time zone of
    the result, and the other argument is the time zone from which to convert:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目标时区名称可以是常量，也可以是数据库字段，从而使此转换对数据集动态可行。一些数据库有类似的 `convert_timezone` 或 `convert_tz`
    函数。一个参数是结果的时区，另一个参数是要从中转换的时区：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Check your database’s documentation for the exact name and ordering of the target
    time zone and the source timestamp arguments. Many databases contain a list of
    time zones and their abbreviations in a system table. Some common ones are seen
    in [Table 3-1](#time_zone_information_system_tables_in). These can be queried
    with *SELECT * FROM* the table name. Wikipedia also has a useful list of [standard
    time zone abbreviations and their UTC offsets](https://oreil.ly/im0wi).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅您数据库的文档，获取目标时区和源时间戳参数的确切名称和排序方式。许多数据库包含一个时区及其缩写的列表在一个系统表中。一些常见的见于 [表 3-1](#time_zone_information_system_tables_in)。您可以通过*SELECT
    * FROM*表名进行查询。维基百科还有一个有用的列表，标准时区缩写和它们的 UTC 偏移量，可以在[这里](https://oreil.ly/im0wi)查看。
- en: Table 3-1\. Time zone information system tables in common databases
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 常见数据库中的时区信息系统表
- en: '| Postgres | `pg_timezone_names` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | `pg_timezone_names` |'
- en: '| MySQL | `mysql.time_zone_names` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | `mysql.time_zone_names` |'
- en: '| SQL Server | `sys.time_zone_info` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| SQL Server | `sys.time_zone_info` |'
- en: '| Redshift | `pg_timezone_names` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Redshift | `pg_timezone_names` |'
- en: Time zones are an innate part of working with timestamps. With time zone conversion
    functions, moving between the time zone in which the data was recorded and any
    other world time zone is possible. Next, I’ll show you a variety of techniques
    for manipulating dates and timestamps with SQL.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 时区是处理时间戳的固有部分。使用时区转换函数，可以在记录数据的时区和其他任何世界时区之间进行移动。接下来，我将向您展示几种使用 SQL 操作日期和时间戳的技巧。
- en: Date and Timestamp Format Conversions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期和时间戳格式转换
- en: 'Dates and timestamps are key to time series analysis. Due to the wide variety
    of ways in which dates and times can be represented in source data, it is almost
    inevitable that you will need to convert date formats at some point. In this section,
    I’ll cover several of the most common conversions and how to accomplish them with
    SQL: changing the data type, extracting parts of a date or timestamp, and creating
    a date or timestamp from parts. I’ll begin by introducing some handy functions
    that return the current date and/or time.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间戳对于时间序列分析至关重要。由于源数据中日期和时间的表示方式多种多样，几乎不可避免地需要在某些时候进行日期格式转换。在本节中，我将介绍几种常见的转换方式，并演示如何在
    SQL 中完成这些操作：改变数据类型、提取日期或时间戳的部分，以及根据部分创建日期或时间戳。首先，我将介绍一些有用的函数，它们可以返回当前日期和/或时间。
- en: Returning the current date or time is a common analysis task—for example, to
    include a timestamp for the result set or to use in date math, covered in the
    next section. The current date and time are referred to as *system time*, and
    while returning them is easy to do with SQL, there are some syntax differences
    between databases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前日期或时间是常见的分析任务，例如为结果集包含一个时间戳或在下一节中使用日期数学。当前日期和时间称为*系统时间*，使用 SQL 返回它们很容易，但不同数据库之间存在一些语法差异。
- en: 'To return the current date, some databases have a `current_date` function,
    with no parentheses:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回当前日期，一些数据库具有`current_date`函数，无需括号：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is a wider variety of functions to return the current date and time.
    Check your database’s documentation or just experiment by typing into a SQL window
    to see whether a function returns a value or an error. The functions with parentheses
    do not take arguments, but it is important to include the parentheses:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多种类的函数用于返回当前日期和时间。请查阅您数据库的文档，或直接在 SQL 窗口中尝试输入以查看函数是否返回值或错误。带有括号的函数不接受参数，但是包括括号是很重要的：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, there are functions to return only the timestamp portion of the current
    system time. Again, consult documentation or experiment to figure out which function(s)
    to use with your database:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些函数只返回当前系统时间的时间戳部分。再次查阅文档或实验，以确定在您的数据库中使用哪些函数：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'SQL has a number of functions for changing the format of dates and times. To
    reduce the granularity of a timestamp, use the `date_trunc` function. The first
    argument is a text value indicating the time period level to which to truncate
    the timestamp in the second argument. The result is a timestamp value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 具有许多用于改变日期和时间格式的函数。要减少时间戳的粒度，请使用`date_trunc`函数。第一个参数是指示在第二个参数中截断时间戳的时间段级别的文本值。结果是一个时间戳值：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Standard arguments that can be used are listed in [Table 3-2](#standard_time_period_arguments).
    They range all the way from microseconds to millennia, providing plenty of flexibility.
    Databases that don’t support `date_trunc`, such as MySQL, have an alternate function
    called `date_format` that can be used in a similar way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的标准参数列在[表 3-2](#standard_time_period_arguments)中。这些参数的范围从微秒到千年，提供了充分的灵活性。不支持`date_trunc`的数据库（如
    MySQL）有一个名为`date_format`的替代函数，可以以类似的方式使用：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Table 3-2\. Standard time period arguments
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2\. 标准时间段参数
- en: '| Time period arguments |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 时间段参数 |'
- en: '| --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| microsecond |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 微秒 |'
- en: '| millisecond |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 毫秒 |'
- en: '| second |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 秒 |'
- en: '| minute |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 分钟 |'
- en: '| hour |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 小时 |'
- en: '| day |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 天 |'
- en: '| week |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 周 |'
- en: '| month |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 月 |'
- en: '| quarter |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 季度 |'
- en: '| year |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 年 |'
- en: '| decade |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 十年 |'
- en: '| century |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 世纪 |'
- en: '| millennium |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 千年 |'
- en: Rather than returning dates or timestamps, sometimes our analysis calls for
    parts of dates or times. For example, we might want to group sales by month, day
    of the week, or hour of the day.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的分析不是返回日期或时间戳，而是需要返回日期或时间的部分。例如，我们可能希望按月、星期几或每天的小时来分组销售数据。
- en: SQL provides a few functions for returning just the part of the date or timestamp
    required. Dates and timestamps are usually interchangeable, except when the request
    is to return a time part. In those cases, time is of course required.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 提供了一些函数，只返回所需的日期或时间戳部分。日期和时间戳通常是可以互换的，除非请求返回的是时间部分。在这种情况下，当然是需要时间的。
- en: 'The `date_part` function takes a text value for the part to be returned and
    a date or timestamp value. The returned value is a FLOAT, which is a numeric value
    with a decimal part; depending on your needs, you may want to cast the value to
    an integer data type:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`date_part`函数接受一个文本值来返回指定的部分以及一个日期或时间戳值。返回值是一个 FLOAT，这是一个带有小数部分的数值；根据您的需求，您可能希望将该值转换为整数数据类型：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another function that works similarly is `extract`, which takes a part name
    and a date or timestamp value and returns a FLOAT value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的函数是`extract`，它接受一个部分名称和一个日期或时间戳值，并返回一个 FLOAT 值：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The functions `date_part` and `extract` can be used with intervals, but note
    that the requested part must match the units of the interval. So, for example,
    requesting days from an interval stated in days returns the expected value of
    30:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`date_part`和`extract`可以与间隔一起使用，但请注意，请求的部分必须与间隔的单位匹配。因此，例如，从以天表示的间隔中请求天数将返回预期值
    30：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, requesting days from an interval stated in months returns a value
    of 0.0:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从以月表示的间隔中请求天数将返回值 0.0：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A full list of date parts can be found in your database’s documentation or by
    searching online, but some of the most common are “day,” “month,” and “year” for
    dates, and “second,” “minute,” and “hour” for timestamps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在数据库的文档或在线搜索中找到日期部分的完整列表，但一些最常见的包括日期的“day”、“month”和“year”，以及时间戳的“second”、“minute”和“hour”。
- en: 'To return text values of the date parts, use the `to_char` function, which
    takes the input value and the output format as arguments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回日期部分的文本值，请使用`to_char`函数，该函数接受输入值和输出格式作为参数：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you ever encounter timestamps stored as Unix epochs (the number of seconds
    that have elapsed since January 1, 1970, at 00:00:00 UTC), you can convert them
    to timestamps using the `to_timestamp` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经遇到以 Unix 时间戳存储的时间戳（自 1970 年 1 月 1 日 00:00:00 UTC 以来经过的秒数），您可以使用`to_timestamp`函数将其转换为时间戳。
- en: Sometimes analysis calls for creating a date from parts from different sources.
    This can occur when the year, month, and day values are stored in different columns
    in the database. It can also be necessary when the parts have been parsed out
    of text, a topic I’ll cover in more depth in [Chapter 5](ch05.xhtml#text_analysis).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时分析需要从不同来源的部分创建日期。当年、月和日的值存储在数据库的不同列中时，就会发生这种情况。当从文本中解析出部分内容时，也可能需要这样做，这是我将在[第
    5 章](ch05.xhtml#text_analysis)中更深入讨论的一个主题。
- en: 'A simple way to create a timestamp from separate date and time components is
    to concatenate them together with a plus sign (+):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从单独的日期和时间组件创建时间戳的简单方法是使用加号（+）将它们连接在一起：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A date can be assembled using the `make_date`, `makedate`, `date_from_parts`,
    or `datefromparts` function. These are equivalent, but different databases name
    the functions differently. The function takes arguments for the year, month, and
    day parts and returns a value with a date format:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`make_date`、`makedate`、`date_from_parts`或`datefromparts`函数来组装日期。这些函数等效，但不同的数据库使用不同的函数名称。该函数接受年、月和日部分的参数，并返回具有日期格式的值：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The arguments can be constants or reference field names and must be integers.
    Yet another way to assemble a date or timestamp is to concatenate the values together
    and then cast the result to a date format using one of the casting syntaxes or
    the `to_date` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是常量或参考字段名，并且必须是整数。组装日期或时间戳的另一种方法是将值连接在一起，然后使用一个转换语法或 `to_date` 函数将结果转换为日期格式：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: SQL has a number of ways to format and convert dates and timestamps and retrieve
    system dates and times. In the next section, I will start putting them to use
    in date math.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 有多种方法可以格式化和转换日期和时间戳，获取系统日期和时间。在下一节中，我将开始在日期数学中应用它们。
- en: Date Math
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期数学
- en: SQL allows us to do various mathematical operations on dates. This might be
    surprising since, strictly speaking, dates are not numeric data types, but the
    concept should be familiar if you’ve ever tried to figure out what day it will
    be four weeks from now. Date math is useful for a variety of analytics tasks.
    For example, we can use it to find the age or tenure of a customer, how much time
    elapsed between two events, and how many things occurred within a window of time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 允许我们对日期执行各种数学运算。这可能令人惊讶，因为严格来说，日期不是数值数据类型，但如果您曾尝试过计算四周后的日期，这个概念应该是熟悉的。日期数学对各种分析任务都很有用。例如，我们可以用它来找出客户的年龄或任职时间，两个事件之间经过了多少时间，以及在时间窗口内发生了多少事件。
- en: 'Date math involves two types of data: the dates themselves and intervals. We
    need the concept of intervals because date and time components don’t behave like
    integers. One-tenth of 100 is 10; one-tenth of a year is 36.5 days. Half of 100
    is 50; half of a day is 12 hours. Intervals allow us to move smoothly between
    units of time. Intervals come in two types: year-month intervals and day-time
    ones. We’ll start with a few operations that return integer values and then move
    on to functions that work with or return intervals.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 日期数学涉及两种类型的数据：日期本身和间隔。我们需要间隔的概念，因为日期和时间组件的行为不像整数。100的十分之一是10；一年的十分之一是36.5天。100的一半是50；一天的一半是12小时。间隔允许我们在时间单位之间平滑移动。间隔有两种类型：年-月间隔和日-时间间隔。我们将从返回整数值的几个操作开始，然后转向处理或返回间隔的函数。
- en: 'First, let’s find the days elapsed between two dates. There are several ways
    to do this in SQL. The first way is by using a mathematical operator, the minus
    sign (–):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找到两个日期之间的天数差。在 SQL 中有几种方法可以实现这一点。第一种方法是使用数学运算符，减号（–）：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This returns the number of days between these two dates. Note that the answer
    is 30 days and not 31\. The number of days is inclusive of only one of the endpoints.
    Subtracting the dates in the reverse also works and returns an interval of –30
    days:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回这两个日期之间的天数。请注意，答案是30天而不是31天。天数包括了其中一个端点。反向减去日期也可以工作，并返回一个间隔为–30天：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finding the difference between two dates can also be accomplished with the
    `datediff` function. Postgres does not support it, but many other popular databases
    do, including SQL Server, Redshift, and Snowflake, and it’s quite handy, particularly
    when the goal is to return an interval other than the number of days. The function
    takes three arguments—the time period units you want to return, a starting timestamp
    or date, and an ending timestamp or date:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `datediff` 函数也可以找到两个日期之间的差异。Postgres 不支持它，但许多其他流行的数据库支持，包括 SQL Server、Redshift
    和 Snowflake，它非常方便，特别是当目标不仅仅是返回天数时。该函数接受三个参数——要返回的时间段单位，起始时间戳或日期，以及结束时间戳或日期：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So our previous example would look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们之前的例子看起来像这样：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also find the number of months between two dates, and the database will
    do the correct math even though month lengths differ throughout the year:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找到两个日期之间的月份数，尽管一年中的月份长度有所不同，数据库会进行正确的计算：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In Postgres, this can be accomplished using the `age` function, which calculates
    the interval between two dates:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postgres 中，可以使用 `age` 函数来实现这一点，它计算两个日期之间的间隔：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can then find the number of months component of the interval with the `date_part()`
    function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后可以使用 `date_part()` 函数找到时间间隔的月份组成部分：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Subtracting dates to find the time elapsed between them is quite powerful. Adding
    dates does not work in the same way. To do addition with dates, we need to leverage
    intervals or special functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个日期之间减去以找到经过的时间是非常强大的。通过添加日期无法以相同的方式工作。要对日期进行加法运算，我们需要利用间隔或特殊函数。
- en: 'For example, we can add seven days to a date by adding the interval `''7 days''`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过添加间隔`'7 days'`来将七天添加到日期中：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Some databases don’t require the interval syntax and instead automatically
    convert the provided number to days, although it’s generally good practice to
    use the interval notation, both for cross-database compatibility and to make your
    code easier to read:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库不需要间隔语法，而是自动将提供的数字转换为天数，尽管通常最好使用间隔表示法，这样既可跨数据库兼容，又能使代码更易读：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to add a different unit of time, use the interval notation with
    months, years, hours, or another date or time period. Note that this can also
    be used to subtract intervals from dates by using a “-” instead of a “+.” Many
    but not all databases have a `date_add` or `dateadd` function that takes the desired
    interval, a value, and the starting date and does the math:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要添加不同单位的时间，请使用月份、年份、小时或其他日期或时间段的间隔表示法。请注意，这也可以用于通过使用“-”而不是“+”从日期中减去间隔。许多但不是所有的数据库都有一个`date_add`或`dateadd`函数，该函数接受所需的间隔、值和起始日期，并进行数学计算。
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Consult your database’s documentation, or just experiment with queries, to figure
    out the syntax and functions that are available and appropriate for your project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考数据库的文档，或者尝试查询，以找出适合项目的语法和函数。
- en: 'Any of these formulations can be used in the *WHERE* clause in addition to
    the *SELECT* clause. For example, we can filter to records that occurred at least
    three months ago:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以上任何一种表述都可以用于*WHERE*子句，除了*SELECT*子句。例如，我们可以筛选出至少发生在三个月前的记录：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: They can also be used in *JOIN* conditions, but note that database performance
    will usually be slower when the *JOIN* condition contains a calculation rather
    than an equality or inequality between dates.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用于*JOIN*条件，但请注意，如果*JOIN*条件包含计算而不是日期之间的相等或不等，数据库性能通常会较慢。
- en: Using date math is common in analysis with SQL, both to find the time elapsed
    between dates or timestamps and to calculate new dates based on an interval from
    a known date. There are several ways to find the elapsed time between two dates,
    add intervals to dates, and subtract intervals from dates. Next, we’ll turn to
    time manipulations, which are similar.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL分析中使用日期数学是常见的，用于查找日期或时间戳之间经过的时间，并根据已知日期的间隔计算新日期。有几种方法可以找到两个日期之间经过的时间，将间隔添加到日期中，并从日期中减去间隔。接下来，我们将转向类似的时间操作。
- en: Time Math
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间数学
- en: 'Time math is less common in many areas of analysis, but it can be useful in
    some situations. For example, we might want to know how long it takes for a support
    representative to answer a phone call in a call center or respond to an email
    requesting assistance. Whenever the elapsed time between two events is less than
    a day, or when rounding the result to a number of days doesn’t provide enough
    information, time manipulation comes into play. Time math works similarly to date
    math, by leveraging intervals. We can add time intervals to times:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多分析领域中，时间数学不常见，但在某些情况下非常有用。例如，我们可能想知道一个支持代表在呼叫中心接听电话或回复请求协助的电子邮件需要多长时间。当两个事件之间的经过时间少于一天，或者将结果舍入到天数不提供足够信息时，时间操作变得重要。时间数学与日期数学类似，通过利用间隔来工作。我们可以将时间间隔添加到时间中：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can subtract intervals from times:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从时间中减去间隔：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also subtract times, resulting in an interval:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以相减时间，得到一个时间间隔：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Times, unlike dates, can be multiplied:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与日期不同，时间可以相乘：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Intervals can also be multiplied, resulting in a time value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔也可以相乘，得到一个时间值：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These examples use constant values, but you can include database field names
    or calculations in the SQL query as well to make the calculations dynamic. Next,
    I’ll discuss special date considerations to keep in mind when combining data sets
    from different source systems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用了常量值，但你也可以在SQL查询中包含数据库字段名称或计算，使计算变得动态。接下来，我将讨论在合并来自不同来源系统的数据集时需要考虑的特殊日期问题。
- en: Joining Data from Different Sources
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自不同来源的数据连接
- en: Combining data from different sources is one of the most compelling use cases
    for a data warehouse. However, different source systems can record dates and times
    in different formats or different time zones or even just be off slightly due
    to issues with the internal clock time of the server. Even tables from the same
    data source can have differences, though this is less common. Reconciling and
    standardizing dates and timestamps is an important step before moving further
    in the analysis.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结合不同来源的数据是数据仓库的最具吸引力的应用之一。然而，不同的源系统可能会以不同的格式记录日期和时间，或者以不同的时区记录，甚至可能仅仅因为服务器内部时钟时间的问题而略有差异。即使来自同一数据源的表也可能存在差异，尽管这种情况较少见。在进一步分析之前，调和和标准化日期和时间戳是一个重要的步骤。
- en: Dates and timestamps that are in different formats can be standardized with
    SQL. *JOIN*ing on dates or including date fields in *UNION*s generally requires
    that the dates or timestamps be in the same format. Earlier in the chapter, I
    showed techniques for formatting dates and timestamps that will serve well with
    these problems. Take care with time zones when combining data from different sources.
    For example, an internal database may use UTC time, but data from a third party
    could be in a local time zone. I have seen data sourced from software as a service
    (SaaS) that was recorded in a variety of local times. Note that the timestamp
    values themselves won’t necessarily have the time zone embedded. You may need
    to consult the vendor’s documentation and convert the data to UTC if the rest
    of your data is stored that way. Another option is to store the time zone in a
    field so that the timestamp value can be converted as needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 SQL 来标准化不同格式的日期和时间戳。在日期上进行 *JOIN* 或在 *UNION* 中包含日期字段通常要求日期或时间戳具有相同的格式。在本章前面，我展示了一些处理日期和时间戳格式的技术，这些技术在处理这些问题时非常有用。在合并来自不同来源的数据时要特别注意时区问题。例如，内部数据库可能使用UTC时间，但来自第三方的数据可能使用本地时区。我曾看到来自软件即服务（SaaS）的数据记录在各种本地时间中。注意，时间戳的值本身不一定包含时区信息。您可能需要查阅供应商的文档并将数据转换为UTC时间，以便与存储在此方式的其他数据对接。另一个选项是在一个字段中存储时区信息，以便根据需要转换时间戳值。
- en: 'Another thing to look out for when working with data from different sources
    is timestamps that are slightly out of sync. This can happen when timestamps are
    recorded from client devices—for example, from a laptop or mobile phone in one
    data source and a server in the other data source. I once saw a series of experiment
    results be miscalculated because the client mobile device that recorded a user’s
    action was offset by a few minutes from the server that recorded the treatment
    group to which the user was assigned. Data from the mobile clients appeared to
    arrive before the treatment group timestamp, so some events were inadvertently
    excluded. A fix for something like this is relatively straightforward: rather
    than filter for action timestamps greater than the treatment group timestamp,
    allow events within a short interval or window of time prior to the treatment
    timestamp to be included in the results. This can be accomplished with a *BETWEEN*
    clause and date math, as seen in the last section.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 处理来自不同来源的数据时，另一个需要注意的问题是时间戳略微不同步。当时间戳记录来自客户端设备时（例如来自一种数据源的笔记本电脑或移动电话和另一种数据源的服务器），这种情况可能会发生。我曾经看到一系列实验结果被错误计算，因为记录用户操作的客户端移动设备与记录用户分配的处理组的服务器的时间戳相差几分钟。来自移动客户端的数据似乎早于处理组时间戳到达，因此某些事件被无意中排除在外。这类问题的修复相对比较简单：不是过滤操作时间戳大于处理组时间戳的事件，而是允许在处理时间戳之前的一个短时间间隔或时间窗口内的事件包含在结果中。这可以通过
    *BETWEEN* 子句和日期计算来实现，正如在最后一节所见。
- en: When working with data from mobile apps, pay particular attention to whether
    the timestamps represent when the action happened on the device *or* when the
    event arrived in the database. The difference can range from negligible all the
    way up to days, depending on whether the mobile app allows offline usage and on
    how it handles sending data during periods of low signal strength. Data from mobile
    apps can be late-arriving or may make its way into the database days after it
    occurred on the device. Dates and timestamps can also become corrupted en route,
    and you may see ones that are impossibly distant in the past or future as a result.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理来自移动应用的数据时，特别注意时间戳是否表示事件在设备上发生的时间*或者*事件到达数据库的时间。这种差异可能从可以忽略不计一直到几天，这取决于移动应用是否允许离线使用以及在低信号强度期间如何处理发送数据。移动应用的数据可能会迟到，或者在设备上发生后数天才会进入数据库。日期和时间戳也可能在传输途中损坏，因此您可能会看到远在过去或未来的不可能的日期。
- en: Now that I’ve shown how to manipulate dates, datetimes, and time by changing
    the formats, converting time zones, performing date math, and working across data
    sets from different sources, we’re ready to get into some time series examples.
    First, I’ll introduce the data set for examples in the rest of the chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经展示了如何通过更改格式、转换时区、执行日期数学运算以及跨不同来源的数据集进行操作，我们已经准备好进入一些时间序列示例。首先，我将介绍本章其余部分示例数据集。
- en: The Retail Sales Data Set
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零售销售数据集
- en: 'The examples in the rest of this chapter use a data set of monthly US retail
    sales from the [Monthly Retail Trade Report: Retail and Food Services Sales: Excel
    (1992–present)](https://www.census.gov/retail/index.html#mrts), available on the
    [Census.gov website](http://Census.gov). The data in this report is used as an
    economic indicator to understand trends in US consumer spending patterns. While
    gross domestic product (GDP) figures are published quarterly, this retail sales
    data is published monthly, so it is also used to help predict GDP. For both of
    these reasons, the latest figures are usually covered in the business press when
    they are released.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分的示例使用来自[月度零售贸易报告：零售和食品服务销售：Excel（1992年至今）](https://www.census.gov/retail/index.html#mrts)的数据集，可在[Census.gov网站](http://Census.gov)上找到。这份报告中的数据被用作经济指标，以了解美国消费者支出模式的趋势。尽管国内生产总值（GDP）数据每季度发布一次，但这些零售销售数据每月发布一次，因此它也被用来帮助预测GDP。由于这两个原因，最新的数据通常在发布时被商业新闻报道。
- en: The data spans from 1992 to 2020 and includes both total sales as well as details
    for subcategories of retail sales. It contains both unadjusted and seasonally
    adjusted numbers. This chapter will use the unadjusted numbers, since one of the
    goals is analyzing seasonality. Sales figures are in millions of US dollars. The
    original file format is an Excel file, with a tab for each year and with months
    as columns. The [GitHub site for this book](https://oreil.ly/LMiHw) has the data
    in a format that’s easier to import into a database, along with code specifically
    for importing into Postgres. [Figure 3-1](#preview_of_the_us_retail_sales_data_set)
    shows a sample of the `retail_sales` table.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据跨越从1992年到2020年，并包括零售销售的子类别的详细信息。它包含未经调整和季节性调整的数字。本章将使用未经调整的数字，因为分析季节性是目标之一。销售数据以美元百万计。原始文件格式为Excel文件，每年一个标签，并以月份为列。[这本书的GitHub站点](https://oreil.ly/LMiHw)提供了一种更容易导入数据库的数据格式，以及专门用于导入到Postgres的代码。[图
    3-1](#preview_of_the_us_retail_sales_data_set)展示了`retail_sales`表的样本。
- en: '![](Images/sfda_0301.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0301.png)'
- en: Figure 3-1\. Preview of the US retail sales data set
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 美国零售销售数据集预览
- en: Trending the Data
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据趋势
- en: With time series data, we often want to look for trends in the data. A trend
    is simply the direction in which the data is moving. It may be moving up or increasing
    over time, or it may be moving down or decreasing over time. It can remain more
    or less flat, or there could be so much noise, or movement up and down, that it’s
    hard to determine a trend at all. This section will cover several techniques for
    trending time series data, from simple trends for graphing to comparing components
    of a trend, using percent of total calculations to compare parts to the whole,
    and finally indexing to see the percent change from a reference time period.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间序列数据，我们通常希望查找数据的趋势。趋势只是数据移动的方向。它可能随时间上升或增加，也可能随时间下降或减少。它可能保持相对平坦，或者可能有很多噪声或上下波动，以至于很难确定趋势。本节将介绍几种用于趋势时间序列数据的技术，从简单趋势图到比较趋势组件，使用百分比总计来比较部分和整体，最后使用指数计算来查看与参考时间段的百分比变化。
- en: Simple Trends
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单趋势
- en: 'Creating a trend may be a step in profiling and understanding data, or it may
    be the final output. The result set is a series of dates or timestamps and a numerical
    value. When graphing a time series, the dates or timestamps will become the x-axis,
    and the numerical value will be the y-axis. For example, we can check the trend
    of total retail and food services sales in the US:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建趋势可能是描述和理解数据的步骤，也可能是最终的输出。结果集是一系列日期或时间戳和一个数值。在图示时间序列时，日期或时间戳将成为x轴，数值将成为y轴。例如，我们可以检查美国总零售和食品服务销售的趋势：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The results are graphed in [Figure 3-2](#trend_of_monthly_retail_and_food_servic).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在 [图 3-2](#trend_of_monthly_retail_and_food_servic) 中进行了图示。
- en: '![](Images/sfda_0302.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0302.png)'
- en: Figure 3-2\. Trend of monthly retail and food services sales
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 月度零售和食品服务销售趋势
- en: 'This data clearly has some patterns, but it also has some noise. Transforming
    the data and aggregating at the yearly level can help us gain a better understanding.
    First, we’ll use the `date_part` function to return just the year from the `sales_month`
    field and then `sum` the `sales`. The results are filtered to the “Retail and
    food services sales, total” `kind_of_business` in the *WHERE* clause:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据显然有一些模式，但也有一些噪音。将数据转换并在年度水平进行汇总可以帮助我们更好地理解。首先，我们将使用 `date_part` 函数从 `sales_month`
    字段中返回年份，然后对 `sales` 进行求和。结果在 *WHERE* 子句中筛选为“总体零售和食品服务销售”。
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After graphing this data, as in [Figure 3-3](#trend_of_yearly_total_retail_and_food_s),
    we now have a smoother time series that is generally increasing over time, as
    might be expected, since the sales values are not adjusted for inflation. Sales
    for all retail and food services fell in 2009, during the global financial crisis.
    After growing every year throughout the 2010s, sales were flat in 2020 compared
    to 2019, due to the impact of the COVID-19 pandemic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 [图 3-3](#trend_of_yearly_total_retail_and_food_s) 中展示这些数据之后，我们现在有一个随时间逐渐增长的更平滑的时间序列，这是可以预期的，因为销售值没有进行通货膨胀调整。所有零售和食品服务的销售在全球金融危机期间的2009年下降。在整个2010年代的每年增长之后，由于COVID-19大流行的影响，2020年的销售与2019年相比保持平稳。
- en: '![](Images/sfda_0303.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0303.png)'
- en: Figure 3-3\. Trend of yearly total retail and food services sales
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 年度总零售和食品服务销售趋势
- en: Graphing time series data at different levels of aggregation, such as weekly,
    monthly, or yearly, is a good way to understand trends. This step can be used
    to simply profile the data, but it can also be the final output, depending on
    the goals of the analysis. Next, we’ll turn to using SQL to compare components
    of a time series.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同级别（如每周、每月或每年）图示时间序列数据是了解趋势的好方法。此步骤可用于简单地描述数据，但也可以是最终输出，具体取决于分析的目标。接下来，我们将转向使用SQL来比较时间序列的组成部分。
- en: Comparing Components
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较各个组成部分
- en: 'Often data sets contain not just a single time series but multiple slices or
    components of a total across the same time range. Comparing these slices often
    reveals interesting patterns. In the retail sales data set, there are values for
    total sales but also a number of subcategories. Let’s compare the yearly sales
    trend for a few categories that are associated with leisure activities: book stores,
    sporting goods stores, and hobby stores. This query adds `kind_of_business` in
    the *SELECT* clause and, since it is another attribute rather than an aggregation,
    adds it to the *GROUP BY* clause  as well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集通常不仅包含单一时间序列，还包含多个切片或总体的组成部分。比较这些切片通常会显示出有趣的模式。在零售销售数据集中，不仅有总销售额的数值，还有许多子类别。让我们比较与休闲活动相关的几个类别的年度销售趋势：书店、运动用品店和爱好店。此查询在*SELECT*子句中添加了`kind_of_business`，并且由于它是另一个属性而不是聚合，还将其添加到*GROUP
    BY*子句中。
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The results are graphed in [Figure 3-4](#trend_of_yearly_retail_sales_for_sporti).
    Sales at sporting goods retailers started the highest among the three categories
    and grew much faster during the time period, and by the end of the time series,
    those sales were substantially higher. Sales at sporting goods stores started
    declining in 2017 but had a big rebound in 2020\. Sales at hobby, toy, and game
    stores were relatively flat over this time span, with a slight dip in the mid-2000s
    and another slight decline prior to a rebound in 2020\. Sales at book stores grew
    until the mid-2000s and have been on the decline since then. All of these categories
    have been impacted by the growth of online retailers, but the timing and magnitude
    seem to differ.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在[图3-4](#trend_of_yearly_retail_sales_for_sporti)中。运动用品零售商的销售在三类别中起始最高，并在时间段内增长迅速，到时间序列结束时，这些销售额显著更高。运动用品店的销售从2017年开始下降，但在2020年有了大幅反弹。玩具和游戏店的销售在此期间相对稳定，中期有轻微下降，2020年前有另一轻微下降后又反弹。书店的销售在2000年代中期之前一直增长，此后一直在下降。所有这些类别都受到在线零售商的影响，但时间和影响程度似乎不同。
- en: '![](Images/sfda_0304.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0304.png)'
- en: Figure 3-4\. Trend of yearly retail sales for sporting goods stores; hobby,
    toy, and game stores; and book stores
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-4\. 运动用品店，玩具和游戏店以及书店的年度零售销售趋势
- en: 'In addition to looking at simple trends, we might want to perform more complex
    comparisons between parts of the time series. For the next few examples, we’ll
    look at sales at women’s clothing stores and at men’s clothing stores. Note that
    since the names contain apostrophes, the character otherwise used to indicate
    the beginning and end of strings, we need to escape them with an extra apostrophe.
    This lets the database know that the apostrophe is part of the string rather than
    the end. Although we might consider adding a step in a data-loading pipeline that
    removes extra apostrophes in names, I’ve left them in here as a demonstration
    of the types of code adjustments that are often needed in the real world. First,
    we’ll trend the data for each type of store by month:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的趋势分析外，我们可能还希望在时间序列的各个部分之间进行更复杂的比较。在接下来的几个例子中，我们将分析女装店和男装店的销售情况。请注意，由于名称中包含撇号，这是字符串开头和结尾的指示字符，我们需要用额外的撇号对其进行转义。这样数据库才能知道撇号是字符串的一部分而不是结尾。尽管我们可能考虑在数据加载管道中添加一个步骤，以删除名称中的额外撇号，但我已将其保留在这里，以展示现实世界中通常需要进行的代码调整类型。首先，我们将按月份趋势显示每种类型商店的数据：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The results are graphed in [Figure 3-5](#monthly_trend_of_sales_at_womenapostrop).
    Sales at women’s clothing retailers are much higher than those at men’s clothing
    retailers. Both types of stores exhibit seasonality, a topic I’ll cover in depth
    in [“Analyzing with Seasonality”](#analyzing_with_seasonality). Both experienced
    significant drops in 2020 due to store closures and a reduction in shopping because
    of the COVID-19 pandemic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在[图3-5](#monthly_trend_of_sales_at_womenapostrop)中。女装零售商的销售额远高于男装零售商。这两种类型的商店都表现出季节性，这是我将在[“分析季节性”](#analyzing_with_seasonality)中深入讨论的一个主题。由于2020年的店铺关闭和COVID-19大流行导致购物减少，两者在2020年经历了显著下降。
- en: '![](Images/sfda_0305.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0305.png)'
- en: Figure 3-5\. Monthly trend of sales at women’s and men’s clothing stores
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-5\. 女装和男装店销售的月度趋势
- en: 'The monthly data has intriguing patterns but is noisy, so we’ll use yearly
    aggregates for the next few examples. We’ve seen this query format previously
    when rolling up total sales and sales for leisure categories:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 月度数据显示出有趣的模式，但也有噪音，因此在接下来的几个示例中我们将使用年度聚合数据。我们之前见过这种查询格式，用于汇总总销售额和休闲类别的销售：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Are sales at women’s clothing stores uniformly higher than those at men’s clothing
    stores? In the yearly trend shown in [Figure 3-6](#yearly_trend_of_sales_at_womenapostroph),
    the gap between men’s and women’s sales does not appear constant but rather was
    increasing during the early to mid-2000s. Women’s clothing sales in particular
    dipped during the global financial crisis of 2008–2009, and sales in both categories
    dropped a lot during the pandemic in 2020.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 女装店铺的销售额是否一直高于男装店铺？如图[Figure 3-6](#yearly_trend_of_sales_at_womenapostroph)所示的年度趋势，男装和女装的销售差距似乎并不是恒定的，而是在2000年代初期到中期逐渐扩大。尤其是在2008年至2009年的全球金融危机期间，女装销售量明显下降，而2020年的疫情期间两个类别的销售都大幅下降。
- en: '![](Images/sfda_0306.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0306.png)'
- en: Figure 3-6\. Yearly trend of sales at women’s and men’s clothing stores
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-6\. 女装和男装店铺销售的年度趋势
- en: 'We don’t need to rely on visual estimation, however. For more precision on
    this gap, we can calculate the gap between the two categories, the ratio, and
    the percent difference between them. To do this, the first step is to arrange
    the data so that there is a single row for each month, with a column for each
    category. Pivoting the data with aggregate functions combined with CASE statements
    accomplishes this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不需要依赖视觉估计。为了更精确地了解这一差距，我们可以计算两个类别之间的差距、比率以及百分比差异。为此，第一步是调整数据，使每个月份都有一行数据，每个类别都有一个列。使用聚合函数结合CASE语句来逆转数据可以实现这一点：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this building block calculation, we can find the difference, ratio, and
    percent difference between time series in the data set. The difference can be
    calculated by subtracting one value from the other using the mathematical “–”
    operator. Depending on the goals of the analysis, either finding the difference
    from men’s sales or finding the difference from women’s sales might be appropriate.
    Both are shown here and are equivalent except for the sign:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个基础计算模块，我们可以找到数据集中时间序列之间的差异、比率和百分比差异。差异可以通过数学运算符“-”相减来计算。根据分析的目标，从男装销售额或女装销售额中找到差异可能都是合适的。这里展示了两者的等价性，除了符号的不同：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The subquery is not required from a query execution standpoint, since aggregations
    can be added to or subtracted from each other. A subquery is often more legible
    but does add more lines to the code. Depending on how long or complex the rest
    of your SQL query is, you might prefer to place the intermediate calculation in
    a subquery, or just calculate it in the main query. Here is an example without
    the subquery, subtracting men’s sales from women’s sales, with an added *WHERE*
    clause filter to remove 2020, since a few months have null values:^([1](ch03.xhtml#ch01fn6))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从查询执行的角度来看，子查询并不是必需的，因为可以将聚合函数添加到或从彼此中减去。子查询通常更易读，但会增加代码的行数。根据SQL查询的长度或复杂性，您可能更喜欢将中间计算放在子查询中，或者直接在主查询中计算。这是一个没有子查询的示例，从女装销售中减去男装销售，并增加了一个*WHERE*子句过滤器，以移除2020年的空值月份：^([1](ch03.xhtml#ch01fn6))
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Figure 3-7](#yearly_difference_between_sales_at_wome) shows that the gap decreased
    between 1992 and about 1997, began a long increase through about 2011 (with a
    brief dip in 2007), and then was more or less flat through 2019.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-7\. 女装和男装店铺销售差异的年度变化
- en: '![](Images/sfda_0307.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0307.png)'
- en: Figure 3-7\. Yearly difference between sales at women’s and men’s clothing stores
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-7\. 女装和男装店铺销售差异的年度变化
- en: 'Let’s continue our investigation and look at the ratio of these categories.
    We’ll use men’s sales as the baseline or denominator, but note that we could just
    as easily use women’s store sales instead:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续调查并观察这些类别之间的比率。我们将使用男装销售作为基线或分母，但请注意我们也可以轻松地使用女装店铺销售：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: SQL returns a lot of decimal digits when performing division. You should generally
    consider rounding the result before presenting the analysis. Use the level of
    precision (number of decimal places) that tells the story.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行除法运算时，SQL返回大量小数位。在呈现分析结果之前，通常考虑对结果进行四舍五入处理。使用合适的精度（小数位数）来讲述故事。
- en: Plotting the result, shown in [Figure 3-8](#yearly_ratio_of_womenapostrophes_to_men),
    reveals that the trend is similar to the difference trend, but while there was
    a drop in the difference in 2009, the ratio actually increased.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制结果，如[图3-8](#yearly_ratio_of_womenapostrophes_to_men)所示，显示出趋势与差异趋势相似，但在2009年差异减少时，比率实际上增加了。
- en: '![](Images/sfda_0308.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0308.png)'
- en: Figure 3-8\. Yearly ratio of women’s to men’s clothing sales
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-8\. 每年女装销售与男装销售的比率
- en: 'Next, we can calculate the percent difference between sales at women’s and
    men’s clothing stores:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以计算女装店和男装店销售之间的百分比差异：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Although the units for this output are different from those in the previous
    example, the shape of this graph is the same as that of the ratio graph. The choice
    of which to use depends on your audience and the norms in your domain. All of
    these statements are accurate: in 2009, sales at women’s clothing stores were
    $28.7 billion higher than sales at men’s stores; in 2009, sales at women’s clothing
    stores were 4.9 times the sales at men’s stores; in 2009, sales at women’s stores
    were 390% higher than sales at men’s stores. Which version to select depends on
    the story you want to tell with the analysis.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此输出的单位与前面示例中的单位不同，但此图的形状与比率图相同。选择使用哪种取决于您的受众和您领域的规范。所有这些声明都是准确的：在2009年，女装店的销售比男装店高287亿美元；在2009年，女装店的销售是男装店销售的4.9倍；在2009年，女装店的销售比男装店销售高390%。选择哪个版本取决于您希望通过分析讲述的故事。
- en: The transformations we’ve seen in this section allow us to analyze time series
    by comparing related parts. The next section will continue the theme of comparing
    time series by showing ways to analyze series that represent parts of a whole.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中所见的转换允许我们通过比较相关部分来分析时间序列。下一节将继续通过展示如何分析代表整体部分的系列来比较时间序列。
- en: Percent of Total Calculations
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分比总计算
- en: When working with time series data that has multiple parts or attributes that
    constitute a whole, it’s often useful to analyze each part’s contribution to the
    whole and whether that has changed over time. Unless the data already contains
    a time series of the total values, we’ll need to calculate the overall total in
    order to calculate the percent of total for each row. This can be accomplished
    with a self-*JOIN*, or a window function, which as we saw in [Chapter 2](ch02.xhtml#preparing_data_for_analysis)
    is a special kind of SQL function that can reference any row within a specified
    partition of the table.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理具有多个部分或属性构成整体的时间序列数据时，通常有必要分析每个部分对整体的贡献以及这种贡献是否随时间变化。除非数据已经包含总值的时间序列，否则我们需要计算总体总值，以便计算每行的总百分比。这可以通过自我-*JOIN*或窗口函数来实现，正如我们在[第2章](ch02.xhtml#preparing_data_for_analysis)中所见，窗口函数是一种特殊的SQL函数，可以引用表中指定分区内的任何行。
- en: 'First I’ll show the self-*JOIN* method. A self-*JOIN* is any time a table is
    joined to itself. As long as each instance of the table in the query is given
    a different alias, the database will treat them all as distinct tables. For example,
    to find the percent of combined men’s and women’s clothing sales that each series
    represents, we can *JOIN* `retail_sales`, aliased as `a`, to `retail_sales`, aliased
    as `b`, on the `sales_month` field. We then *SELECT* the individual series name
    (`kind_of_business`) and `sales` values from alias `a`. Then, from alias `b` we
    `sum` the `sales` for both categories and call the result `total_sales`. Note
    that the *JOIN* between the tables on the `sales_month` field creates a partial
    Cartesian *JOIN*, which results in two rows from alias `b` for each row in alias
    `a`. Grouping by `a.sales_month`, `a.kind_of_business`, and `a.sales` and aggregating
    `b.sales` returns exactly the results needed, however. In the outer query, the
    percent of total for each row is calculated by dividing `sales` by `total_sales`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我将展示自我-*JOIN*方法。自我-*JOIN*是指表与自身连接的任何时刻。只要查询中表的每个实例都被赋予不同的别名，数据库将把它们都视为不同的表。例如，为了找出每个系列表示的男装和女装总销售的百分比，我们可以将`retail_sales`作为`a`别名与`retail_sales`作为`b`别名进行*JOIN*，并在`sales_month`字段上。然后从别名`a`中*SELECT*出单个系列名称（`kind_of_business`）和`sales`值。然后，从别名`b`中对两个类别的销售求和，并将结果命名为`total_sales`。请注意，表之间在`sales_month`字段上的*JOIN*创建了部分笛卡尔*JOIN*，导致别名`a`的每一行对应别名`b`的两行。通过按`a.sales_month`、`a.kind_of_business`和`a.sales`进行分组，并对`b.sales`进行聚合，确切返回所需的结果。在外部查询中，每行的百分比总数通过将`sales`除以`total_sales`来计算：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The subquery isn’t required here, as the same result could be obtained without
    it, but it makes the code a little easier to follow. A second way to calculate
    the percent of total sales for each category is to use the `sum` window function
    and *PARTITION BY* the `sales_month`. Recall that the *PARTITION BY* clause indicates
    the section of the table within which the function should calculate. The *ORDER
    BY* clause is not required in this `sum` window function, because the order of
    calculation doesn’t matter. Additionally, the query does not need a *GROUP BY*
    clause, because window functions look across multiple rows, but they do not reduce
    the number of rows in the result set:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里并不需要子查询，因为可以在没有它的情况下获得相同的结果，但是它使代码稍微容易理解一些。另一种计算每个类别总销售额百分比的方法是使用`sum`窗口函数并按`sales_month`进行*PARTITION
    BY*。请记住，*PARTITION BY*子句指示函数应计算的表中的部分。在这种`sum`窗口函数中不需要*ORDER BY*子句，因为计算的顺序并不重要。此外，查询不需要*GROUP
    BY*子句，因为窗口函数跨多行查看数据，但它们不会减少结果集中的行数：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Graphing this data, as in [Figure 3-9](#menapostrophes_and_womenapostrophes_cl),
    reveals some interesting trends. First, starting in the late 1990s, women’s clothing
    store sales became an increasing percentage of the total.  Second, early in the
    series a seasonal pattern is evident, where men’s sales spike as a percent of
    total sales in December and January. In the first decade of the 21st century,
    two seasonal peaks appear, in the summer and the winter, but by the late 2010s,
    the seasonal patterns are dampened almost to the point of randomness. We’ll take
    a look at analyzing seasonality in greater depth later in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图表化这些数据，如[图 3-9](#menapostrophes_and_womenapostrophes_cl)，显示了一些有趣的趋势。首先，从20世纪90年代末开始，女装店销售额占总销售额的比例逐渐增加。其次，在系列初期可以看到明显的季节性模式，其中男装在12月和1月的销售额作为总销售额的百分比出现了峰值。在21世纪的第一个十年中，出现了两个季节性高峰，分别是夏季和冬季，但到2010年代末，季节性模式几乎消失，几乎变得随机。我们将在本章后面更深入地分析季节性。
- en: '![](Images/sfda_0309.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0309.png)'
- en: Figure 3-9\. Men’s and women’s clothing store sales as percent of monthly total
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-9\. 男装和女装店销售额占月度总额的百分比
- en: 'Another percent of total we might want to find is the percent of sales within
    a longer time period, such as the percent of yearly sales each month represents.
    Again, either a self-*JOIN* or a window function will do the job. In this example,
    we’ll use a self-*JOIN* in the subquery:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可能想要找到的百分比是在较长时间段内的销售额百分比，例如每个月占年度销售额的百分比。在这种情况下，可以使用自连接（self-*JOIN*）或窗口函数来完成。在这个例子中，我们将在子查询中使用自连接（self-*JOIN*）：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Alternatively, the window function method can be used:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用窗口函数方法：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The results, zoomed in to 2019, are shown in [Figure 3-10](#percent_of_yearly_sales_for_twozeroonen).
    The two time series track fairly closely, but men’s stores had a greater percentage
    of their sales in January than did women’s stores. Men’s stores had a summer dip
    in July, while the corresponding dip in women’s store sales wasn’t until September.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小至2019年的结果如[图 3-10](#percent_of_yearly_sales_for_twozeroonen)所示。这两个时间序列基本上是紧密跟踪的，但男装店在1月的销售额比女装店更高。男装店在7月有一个夏季低谷，而女装店的对应低谷则直到9月才出现。
- en: '![](Images/sfda_0310.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0310.png)'
- en: Figure 3-10\. Percent of yearly sales for 2019 for women’s and men’s clothing
    sales
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-10\. 2019 年女装和男装销售额占年度销售额的百分比
- en: Now that I’ve shown how to use SQL for percent of total calculations and the
    types of analysis that can be accomplished, I’ll turn to indexing and calculating
    percent change over time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经展示了如何使用SQL进行总计百分比的计算以及可以完成的分析类型，接下来我将转向索引和计算随时间变化的百分比变化。
- en: Indexing to See Percent Change over Time
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引以查看随时间变化的百分比变化
- en: The values in time series usually fluctuate over time. Sales increase with growing
    popularity and availability of a product, while web page response time decreases
    with engineers’ efforts to optimize code. Indexing data is a way to understand
    the changes in a time series relative to a base period (starting point). Indices
    are widely used in economics as well as business settings. One of the most famous
    indices is the Consumer Price Index (CPI), which tracks the change in the prices
    of items that a typical consumer purchases and is used to track inflation, to
    decide salary increases, and for many other applications. The CPI is a complex
    statistical measure using various weights and data inputs, but the basic premise
    is straightforward. Pick a base period and compute the percent change in value
    from that base period for each subsequent period.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列中的值通常随时间波动。销售随产品的流行度和可用性增长而增加，而网页响应时间则随工程师优化代码的努力而减少。索引数据是理解时间序列相对于基期（起始点）变化的一种方式。指数在经济学以及商业环境中被广泛使用。最著名的指数之一是消费者价格指数（CPI），它跟踪典型消费者购买的物品价格变化，并用于跟踪通货膨胀、决定工资增长等多种应用。CPI是一个复杂的统计指标，使用各种权重和数据输入，但其基本原理很简单。选择一个基期，并计算从该基期开始每个后续期间的值的百分比变化。
- en: 'Indexing time series data with SQL can be done with a combination of aggregations
    and window functions, or self-*JOIN*s. As an example, we index women’s clothing
    store sales to the first year in the series, 1992\. The first step is to aggregate
    the `sales` by `sales_year` in a subquery, as we’ve done previously. In the outer
    query, the `first_value` window function finds the value associated with the first
    row in the *PARTITION BY* clause, according to the sort in the *ORDER BY* clause.
    In this example, we can omit the *PARTITION BY* clause, because we want to return
    the sales `value` for the first row in the entire data set returned by the subquery:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL索引时间序列数据可以通过聚合和窗口函数，或者自连接来完成。例如，我们将女装店销售与系列的第一年1992年索引。第一步是在子查询中按`sales_year`聚合`sales`，正如我们之前所做的那样。在外部查询中，`first_value`窗口函数根据*ORDER
    BY*子句中的排序，在*PARTITION BY*子句中找到与第一行关联的值。在这个例子中，我们可以省略*PARTITION BY*子句，因为我们想要返回由子查询返回的整个数据集中的第一行的销售`value`：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this sample of data, we can visually verify that the index value is correctly
    set at the value for 1992\. Next, find the percent change from this base year
    for each row:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个数据样本，我们可以直观地验证索引值是否正确地设置在1992年的值上。接下来，找到每一行相对于这个基准年的百分比变化：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The percent change can be either positive or negative, and we’ll see that does
    in fact occur in this time series. The `last_value` window function could be substituted
    for `first_value` in this query. Indexing from the last value in a series is much
    less common, however, since analysis questions more often relate to change from
    a starting point rather than looking back from an arbitrary ending point; still,
    the option is there. Additionally, the sort order can be used to achieve indexing
    from the first or last value by switching between *ASC* and *DESC*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比变化可以是正数也可以是负数，我们将看到这种情况确实发生在这个时间序列中。在此查询中，可以用`first_value`替换`last_value`窗口函数。从系列的最后一个值开始索引远不常见，然而，由于分析问题更经常与从一个任意结束点向后查看有关，而不是从一个起始点开始，这种选择仍然存在。另外，排序顺序可以用来实现从第一个或最后一个值进行索引，通过在*ASC*和*DESC*之间切换：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Window functions provide a lot of flexibility. Indexing can be accomplished
    without them through a series of self-*JOIN*s, though more lines of code are required:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数提供了很大的灵活性。可以通过一系列自连接来完成索引，尽管需要更多的代码行数：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice the unusual *JOIN* clause `on 1 = 1` between alias `aa` and subquery
    `bb`. Since we want the `index_sales` value to populate for every row in the result
    set, we can’t *JOIN* on the year or any other value, which would restrict the
    results. However, the database will return an error if no *JOIN* clause is specified.
    We can fool the database by using any expression that evaluates to TRUE in order
    to create the desired Cartesian *JOIN*. Any other TRUE statement, such as `on
    2 = 2` or `on 'apples' = 'apples'`, could be used instead.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在别名`aa`和子查询`bb`之间的不寻常的*JOIN*子句`on 1 = 1`。由于我们希望`index_sales`值填充结果集中的每一行，我们不能根据年份或任何其他值进行*JOIN*，因为这将限制结果。然而，如果未指定*JOIN*子句，数据库将返回错误。我们可以通过使用任何计算结果为TRUE的表达式来愚弄数据库，以创建所需的笛卡尔*JOIN*。任何其他TRUE语句，比如`on
    2 = 2`或`on 'apples' = 'apples'`，都可以使用。
- en: Warning
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Beware of zeros in the denominator of division operations such as `sales / index_sales`
    in the last example. Databases return an error when they encounter division by
    zero, which can be frustrating. Even when you think a zero in the denominator
    field is unlikely, it’s good practice to prevent this by telling the database
    to return an alternate default value when it encounters a zero. This can be done
    with a CASE statement. The examples in this section do not have zeros in the denominator,
    so I will omit this extra code for the sake of legibility.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，例如 `sales / index_sales`，请注意分母中的零。当数据库遇到除以零时，会返回错误，这可能很令人沮丧。即使你认为分母字段中的零不太可能出现，也最好通过告诉数据库在遇到零时返回备用默认值的方式来预防这种情况。可以通过
    CASE 语句实现这一点。本节的示例中分母没有零，为了可读性，我将省略额外的代码。
- en: 'To wrap up this section, let’s look at a graph of the indexed time series for
    men’s and women’s clothing stores, shown in [Figure 3-11](#menapostrophes_and_womenapostrophes_clo).
    The SQL code looks like:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下男装店和女装店索引时间序列的图表，如[图3-11](#menapostrophes_and_womenapostrophes_clo)所示。SQL代码如下：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](Images/sfda_0311.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0311.png)'
- en: Figure 3-11\. Men’s and women’s clothing store sales, indexed to 1992 sales
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-11。男装店和女装店销售，以1992年的销售为基准
- en: It’s apparent from this graph that 1992 was something of a high-water mark for
    sales at men’s clothing stores. After 1992 sales dropped, then returned briefly
    to the same level in 1998, and have been declining ever since. This is striking
    since the data set is not adjusted for inflation, the tendency for prices to rise
    over time. Sales at women’s clothing stores decreased from 1992 levels initially,
    but they returned to the 1992 level by 2003\. They have increased since, with
    the exception of the drop during the financial crisis that decreased sales in
    2009 and 2010\. One explanation for these trends is that men simply decreased
    spending on clothes over time, perhaps becoming less fashion conscious relative
    to women. Perhaps men’s clothing simply became less expensive as global supply
    chains decreased costs. Yet another explanation might be that men shifted their
    clothing purchases from retailers categorized as “men’s clothing stores” to other
    types of retailers, such as sporting goods stores or online retailers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图表可以明显看出，1992年对于男装店的销售来说是一个高点。1992年后销售下降，然后在1998年短暂回到同一水平，此后一直在下降。这一点很显著，因为数据集没有调整为不考虑通货膨胀，即随着时间推移价格上涨的趋势。女装店的销售从1992年开始也有所下降，但到了2003年又回到了1992年的水平。此后销售有所增加，除了2009年和2010年金融危机期间的销售下降。这些趋势的一个解释可能是，随着时间推移，男性简单地减少了对服装的支出，相对于女性来说可能对时尚不那么关注。也许男装变得更便宜，因为全球供应链降低了成本。还有一个解释可能是，男性将他们的服装购买从分类为“男装店”的零售商转移到了其他类型的零售商，如体育用品店或在线零售商。
- en: Indexing time series data is a powerful analysis technique, allowing us to find
    a range of insights in the data. SQL is well suited to this task, and I’ve shown
    how to construct indexed time series with and without window functions. Next,
    I’ll show you how to analyze data by using rolling time windows to find patterns
    in noisy time series.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间序列数据进行索引是一种强大的分析技术，可以让我们从数据中发现各种见解。SQL非常适合这项任务，我已经展示了如何使用窗口函数和不使用窗口函数来构建索引时间序列。接下来，我将展示如何通过使用滚动时间窗口来分析数据，以便在嘈杂的时间序列中找到模式。
- en: Rolling Time Windows
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动时间窗口
- en: 'Time series data is often noisy, a challenge for one of our primary goals of
    finding patterns. We’ve seen how aggregating data, such as from monthly to yearly,
    can smooth out the results and make them easier to interpret. Another technique
    for smoothing data is *rolling time windows*, also known as moving calculations,
    that take into account multiple periods. Moving averages are probably the most
    common, but with the power of SQL, any aggregate function is available for analysis.
    Rolling time windows are used in a wide variety of analysis areas, including stock
    markets, macroeconomic trends, and audience measurement. Some calculations are
    so commonly used that they have their own acronyms: last twelve months (LTM),
    trailing twelve months (TTM), and year-to-date (YTD).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据通常噪声较大，这是我们寻找模式的主要目标之一的挑战。我们已经看到，聚合数据（例如从月度到年度）可以平滑结果并使其更易于解释。另一种平滑数据的技术是
    *滚动时间窗口*，也称为移动计算，它考虑了多个周期。移动平均值可能是最常见的，但是通过 SQL 的强大功能，任何聚合函数都可以用于分析。滚动时间窗口在各种分析领域广泛应用，包括股票市场、宏观经济趋势和受众测量。一些计算如此常见，以至于它们有自己的首字母缩写：过去十二个月（LTM）、滚动十二个月（TTM）和年初至今（YTD）。
- en: '[Figure 3-12](#example_of_ltm_and_ytd_rolling_sum_of_s) shows an example of
    a rolling time window and a cumulative calculation, relative to the month of October
    in the time series.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-12](#example_of_ltm_and_ytd_rolling_sum_of_s) 显示了一个滚动时间窗口和累计计算的示例，相对于时间序列中的十月份。'
- en: '![](Images/sfda_0312.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0312.png)'
- en: Figure 3-12\. Example of LTM and YTD rolling sum of sales
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-12\. LTM 和 YTD 销售总和的示例
- en: There are several important pieces of any rolling time series calculation. First
    is the size of the window, which is the number of periods to include in the calculation.
    Larger windows with more time periods have a greater smoothing effect, but at
    the risk of losing sensitivity to important short-term changes in the data. Shorter
    windows with fewer time periods do less smoothing and thus are more sensitive
    to short-term changes, but at the risk of too little noise reduction.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 任何滚动时间序列计算的几个重要部分。首先是窗口的大小，即计算中包含的时间周期数。较大的窗口具有更大的平滑效果，但有可能失去对数据重要短期变化的敏感性。较短的窗口具有较少的平滑效果，因此对短期变化更为敏感，但可能无法有效减少噪声。
- en: The second piece of time series calculations is the aggregate function used.
    As noted previously, moving averages are probably the most common. Moving sums,
    counts, minimums, and maximums can also be calculated with SQL. Moving counts
    are useful in user population metrics (see the following sidebar). Moving minimums
    and maximums can help in understanding the extremes of the data, useful for planning
    analyses.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列计算的第二部分是所使用的聚合函数。正如前面提到的，移动平均值可能是最常见的。还可以使用 SQL 计算移动总和、计数、最小值和最大值。移动计数在用户群体指标中非常有用（请参见以下侧边栏）。移动最小值和最大值有助于理解数据的极端值，这对于计划分析非常有用。
- en: The third piece of time series calculations is choosing the partitioning, or
    grouping, of the data that is included in the window. The analysis might call
    for resetting the window every year. Or the analysis might need a different moving
    series for each component or user group. [Chapter 4](ch04.xhtml#cohort_analysis)
    will go into more detail on cohort analysis of user groups, where we will consider
    how retention and cumulative values such as spend differ between populations over
    time. Partitioning will be controlled through grouping as well as the *PARTITION
    BY* statement of window functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列计算的第三部分是选择包含在窗口中的数据的分区或分组。分析可能需要每年重置窗口。或者分析可能需要每个组件或用户组的不同移动系列。[第四章](ch04.xhtml#cohort_analysis)
    将更详细地讨论用户组的队列分析，我们将考虑如何随着时间推移，留存和支出等累计值在不同人群之间的差异。分区将通过分组以及窗口函数的 *PARTITION BY*
    语句来控制。
- en: With these three pieces in mind, we’ll move into the SQL code and calculations
    for moving time periods, continuing with the US retail sales data set for examples.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这三个部分后，我们将进入移动时间周期的 SQL 代码和计算，继续使用美国零售销售数据集作为示例。
- en: Calculating Rolling Time Windows
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算滚动时间窗口
- en: Now that we know what rolling time windows are, how they’re useful, and their
    key components, let’s get into calculating them using the US retail sales data
    set. We’ll start with the simpler case, when the data set contains a record for
    each period that should be in the window, and then in the next section we’ll look
    at what to do when this is not the case.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道滚动时间窗口是什么，它们如何有用以及它们的关键组成部分，让我们开始使用美国零售销售数据集计算它们。我们将从较简单的情况开始，即数据集包含应在窗口中的每个期间的记录，然后在下一节中我们将看看当情况不是这样时该怎么做。
- en: 'There are two main methods for calculating a rolling time window: a self-*JOIN*,
    which can be used in any database, and a window function, which as we’ve seen
    isn’t available in some databases. In both cases we need the same result: a date
    and a number of data points that corresponds to the size of the window to which
    we will apply an average or another aggregate function.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方法来计算滚动时间窗口：自连接，可以在任何数据库中使用；窗口函数，在某些数据库中不可用，正如我们所见的那样。在这两种情况下，我们需要相同的结果：一个日期和与窗口大小相对应的数据点数量，我们将对其应用平均值或其他聚合函数。
- en: 'For this example, we’ll use a window of 12 months to get rolling annual sales,
    since the data is at a monthly level of granularity. We’ll then apply an average
    to get a 12-month moving average of retail sales. First, let’s develop the intuition
    for what will go into the calculation. In this query, alias `a` of the table is
    our “anchor” table, the one from which we gather the dates. To start, we’ll look
    at a single month, December 2019\. From alias `b`, the query gathers the 12 individual
    months of sales that will go into the moving average. This is accomplished with
    the *JOIN* clause `b.sales_month between a.sales_month - interval ''11 months''
    and a.sales_month`, which creates an intentional Cartesian *JOIN*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本示例，我们将使用一个12个月的窗口来获取滚动年度销售额，因为数据以月为单位。然后，我们将应用平均值来获取12个月的移动平均零售销售额。首先，让我们开发出对计算所需的直觉。在此查询中，表的别名`a`是我们的“锚”表，从中收集日期。首先，我们将查看单个月份，2019年12月。从别名`b`，查询收集将用于移动平均的12个单独月份的销售额。这是通过`JOIN`子句`b.sales_month
    between a.sales_month - interval '11 months' and a.sales_month`完成的，它创建了一个有意的笛卡尔`JOIN`：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that the `sales_month` and `sales` figures from alias `a` are repeated
    for each row of the 12 months in the window.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，别名为`a`的`sales_month`和`sales`数据在窗口的每个月份行中都会重复出现。
- en: Warning
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Remember that the dates in a *BETWEEN* clause are inclusive (both will be returned
    in the result set). It’s a common mistake to use 12 instead of 11 in the preceding
    query. When in doubt, check the intermediate query results as I’ve done here to
    make sure the intended number of periods ends up in the window calculation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`BETWEEN`子句中的日期是包含的（结果集中将返回两者）。在前述查询中使用12而不是11是一个常见错误。当有疑问时，请像我在这里所做的那样检查中间查询结果，以确保期望的时间段数量包含在窗口计算中。
- en: 'The next step is to apply the aggregation—in this case, `avg`, since we want
    a rolling average. The `count` of records returned from alias `b` is included
    to confirm that each row averages 12 data points, a useful data quality check.
    Alias `a` also has a filter on `sales_month`. Since this data set starts in 1992,
    months in that year, except for December, have fewer than 12 historical records:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是应用聚合函数——在这种情况下是`avg`，因为我们想要一个滚动平均值。返回自别名`b`的记录数量包括在内，以确认每行平均包含12个数据点，这是一个有用的数据质量检查。别名`a`还对`sales_month`进行了过滤。由于这个数据集始于1992年，该年的月份，除了12月外，都有少于12个历史记录：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The results are graphed in [Figure 3-13](#monthly_sales_and_onetwo_month_moving_a).
    While the monthly trend is noisy, the smoothed moving average trend makes detecting
    changes such as the increase from 2003 to 2007 and the subsequent dip through
    2011 easier to spot. Notice that the extreme drop in early 2020 pulls the moving
    average down even after sales start to rebound later in the year.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在[图 3-13](#monthly_sales_and_onetwo_month_moving_a)中显示。虽然每月趋势有噪音，但平滑的移动平均趋势使得识别变化更加容易，比如从2003年到2007年的增长以及随后到2011年的下降。请注意，2020年初的极端下降在销售后来年反弹之后仍然将移动平均值拉低。
- en: '![](Images/sfda_0313.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0313.png)'
- en: Figure 3-13\. Monthly sales and 12-month moving average sales for women’s clothing
    stores
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-13\. 女装店每月销售额和12个月移动平均销售额
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Adding the filter `kind_of_business = 'Women''s clothing stores'` to each alias
    isn’t strictly necessary. Since the query uses an *INNER JOIN*, filtering on one
    table will automatically filter on the other. However, filtering on both tables
    often makes queries run faster, particularly when the tables are large.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 向每个别名添加过滤器`kind_of_business = 'Women''s clothing stores'`并非绝对必要。由于查询使用*INNER
    JOIN*，在一张表上进行过滤将自动过滤另一张表。然而，在两张表上同时过滤通常会使查询速度更快，特别是当表很大时。
- en: 'Window functions are another way to calculate rolling time windows. To make
    a rolling window, we need to use another optional part of a window calculation:
    the *frame clause*. The frame clause allows you to specify which records to include
    in the window. By default, all records in the partition are included, and for
    many cases this works just fine. However, controlling the included records at
    a more fine-grained level is useful for cases like moving window calculations.
    The syntax is simple and yet can be confusing when encountering it for the first
    time. The frame clause can be specified as:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数是计算滚动时间窗口的另一种方式。要创建滚动窗口，我们需要使用窗口计算的另一个可选部分：*frame clause*。*frame clause*允许您指定要包含在窗口中的记录。默认情况下，包括分区中的所有记录，在许多情况下这都很好用。然而，在更细粒度地控制包含的记录对于像移动窗口计算这样的情况很有用。语法简单，但初次遇到时可能会有些困惑。*frame
    clause*可以指定为：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Within the curly braces are three options for the frame type: range, rows,
    and groups. These are the ways you can specify which records to include in the
    result, relative to the current row. Records are always chosen from the current
    partition and follow the *ORDER BY* specified. The default sorting is ascending
    (*ASC*), but it can be changed to descending (*DESC*). *Rows* is the most straightforward
    and will allow you to specify the exact number of rows that should be returned.
    *Range* includes records that are within some boundary of values relative to the
    current row. *Groups* can be used when there are multiple records with the same
    *ORDER BY* value, such as when a data set includes multiple lines per sales month,
    one for each customer.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号中有三种框架类型选项：range、rows和groups。这些是您可以指定要包含在结果中的记录的方式，相对于当前行。记录始终从当前分区中选择，并按指定的*ORDER
    BY*排序。默认排序为升序（*ASC*），但可以更改为降序（*DESC*）。*Rows*是最简单的，允许您指定应返回的确切行数。*Range*包括在与当前行相对值的某些边界内的记录。*Groups*可用于当数据集包含每个销售月份的多行时，例如每个客户一行。
- en: 'The *frame_start* and *frame_end* can be any of the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*frame_start*和*frame_end*可以是以下任何一种：'
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Preceding* means to include rows before the current row, according to the
    *ORDER BY* sorting. *Current row* is just that, and *following* means to include
    rows that occur after the current row according to the *ORDER BY* sorting. The
    *UNBOUNDED* keyword means to include all records in the partition before or after
    the current row. The *offset* is the number of records, often just an integer
    constant, though a field or an expression that returns an integer could also be
    used. Frame clauses also have an optional *frame_exclusion* option, which is beyond
    the scope of the discussion here. [Figure 3-14](#window_frame_clauses_and_the_rows_they)
    shows an example of the rows that each of the window frame options will pick up.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*Preceding*表示包括当前行之前的行，根据*ORDER BY*排序。*Current row*就是当前行，*Following*表示包括当前行之后的行，根据*ORDER
    BY*排序。*UNBOUNDED*关键字表示在当前行之前或之后包括分区中的所有记录。*Offset*是记录的数量，通常只是一个整数常数，虽然也可以使用返回整数的字段或表达式。*frame
    clause*还具有一个可选的*frame_exclusion*选项，在此处讨论范围之外。[图 3-14](#window_frame_clauses_and_the_rows_they)展示了每个窗口帧选项将选取的行的示例。'
- en: '![](Images/sfda_0314.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0314.png)'
- en: Figure 3-14\. Window frame clauses and the rows they include
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-14\. 窗口帧子句及其包含的行
- en: 'From partition to ordering to window frames, window functions have a variety
    of options that control the calculations, making them incredibly powerful and
    well suited to tackling complex calculations with relatively simple syntax. Returning
    to our retail sales example, the moving average that we calculated using a self-*JOIN*
    can be accomplished with window functions in fewer lines of code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从分区到排序再到窗口帧，窗口函数具有多种选项来控制计算，使其非常强大且适合用相对简单的语法处理复杂的计算。回到我们的零售销售示例，使用自身*JOIN*计算的移动平均数可以在少量代码中通过窗口函数实现：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this query, the window orders the sales by month (ascending) to ensure that
    the window records are in chronological order.  The frame clause is `rows between
    11 preceding and current row`, since I know that I have one record for each month
    and I want the 11 prior months and the month from the current row included in
    the average and count calculations. The query returns all months, including those
    that don’t have 11 prior months, and we might want to filter these out by placing
    this query in a subquery and filtering by month or number of records in the outer
    query.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，窗口按月份（升序）排序，以确保窗口记录按时间顺序排列。帧子句为`rows between 11 preceding and current
    row`，因为我知道每个月都有一条记录，我希望包括前11个月和当前行的月份在平均值和计数计算中。查询返回所有月份，包括那些没有11个先前月份的月份，我们可能希望通过将此查询置于子查询中并在外部查询中按月份或记录数进行过滤来过滤这些记录。
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: While calculating moving averages from prior time periods is common in many
    business contexts, SQL window functions are flexible enough to include future
    time periods as well. They can also be used in any scenario in which the data
    has some ordering, not just in time series analysis.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在许多商业背景下从先前时间段计算移动平均值很常见，SQL窗口函数足够灵活，可以包括未来时间段。它们也可以用于任何数据具有某种排序的场景，不仅限于时间序列分析。
- en: Calculating rolling averages or other moving aggregations can be accomplished
    with self-*JOIN*s or window functions when records exist in the data set for each
    time period in the window. There may be performance differences between the two
    methods, depending on the type of database and the size of the data set. Unfortunately,
    it’s difficult to predict which one will be performant or to give general advice
    on which to use. It’s worth trying both methods and paying attention to how long
    it takes to return your query results; then make whichever one seems to run faster
    your default choice. Now that we’ve seen how to calculate rolling time windows,
    I’ll show how to calculate rolling windows with sparse data sets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 计算滚动平均值或其他移动聚合可以通过自身*连接*或窗口函数来实现，当数据集中存在每个时间段内的记录时。根据数据库类型和数据集大小，这两种方法可能会有性能差异。不幸的是，很难预测哪一种方法会更有效，或者给出关于使用哪种方法的一般建议。值得尝试两种方法，并注意返回查询结果所需的时间；然后选择运行更快的方法作为默认选择。现在我们已经看到了如何计算滚动时间窗口，接下来我将展示如何在稀疏数据集中计算滚动窗口。
- en: Rolling Time Windows with Sparse Data
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏数据的滚动时间窗口
- en: Data sets in the real world may not contain a record for every time period that
    falls within the window. The measurement of interest might be seasonal or intermittent
    by nature. For example, customers might return to purchase from a website at irregular
    intervals, or a particular product might go in and out of stock. This results
    in sparse data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的数据集可能不包含在窗口内的每个时间段的记录。感兴趣的测量可能是季节性的或自然间歇性的。例如，顾客可能会不规则地返回网站购买商品，或者特定产品可能会断货。这导致数据稀疏。
- en: 'In the last section, I showed how to calculate a rolling window with a self-*JOIN*
    and a date interval in the *JOIN* clause. You might be thinking that this will
    pick up any records within the 12-month time window, whether all were in the data
    set or not, and you’d be correct. The problem with this approach comes when there
    is no record for the month (or day or year) itself. For example, imagine I want
    to calculate the rolling 12-month sales for each model of shoe my store stocks
    as of December 2019\. Some of the shoes went out of stock prior to December, however,
    and so don’t have sales records in that month. Using a self-*JOIN* or window function
    will return a data set of rolling sales for all the shoes that sold in December,
    but the data will be missing the shoes that went out of stock. Fortunately, we
    have a way to solve this problem: by using a date dimension.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我展示了如何使用自身*连接*和*JOIN*子句中的日期间隔来计算滚动窗口。您可能认为这将捕获在12个月时间窗口内的任何记录，无论数据集中是否全部包含，您是正确的。但是，当本身不存在该月（或者日或年）的记录时，这种方法存在问题。例如，假设我想计算截至2019年12月每款鞋店存货的滚动12个月销售额。然而，一些鞋子在12月之前已经断货，因此在那个月没有销售记录。使用自身*连接*或窗口函数将返回一个滚动销售数据集，但数据将缺少已断货的鞋子。幸运的是，我们有解决这个问题的方法：使用日期维度。
- en: 'The *date dimension*, a static table that contains a row for each calendar
    date, was introduced in [Chapter 2](ch02.xhtml#preparing_data_for_analysis). With
    such a table we can ensure that a query returns a result for every date of interest,
    whether or not there was a data point for that date in the underlying data set.
    Since the `retail_sales` data does include rows for all months, I’ve simulated
    a sparse data set by adding a subquery to filter the table to only `sales_month`s
    from January and July (1 and 7). Let’s look at the results when *JOIN*ed to the
    `date_dim`, but before aggregation, to develop intuition about the data before
    applying calculations:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*日期维度*，一个静态表，包含每个日历日期的一行，在[第二章](ch02.xhtml#preparing_data_for_analysis)中被引入。通过这样一个表，我们可以确保查询返回所有感兴趣的日期的结果，无论底层数据集中是否有该日期的数据点。由于`retail_sales`数据确实包含了所有月份的行，我通过添加一个子查询来模拟稀疏数据集，仅将表过滤为仅包含一月和七月（1和7）的`sales_month`。让我们看看在*JOIN*到`date_dim`之前的结果，但在聚合之前，以便在应用计算之前开发关于数据的直觉：'
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice that the query returns results for February and March `date`s in addition
    to January, even though there are no sales for these months in the subquery results.
    This is possible because the date dimension contains records for all months. The
    filter `a.date = a.first_day_of_month` restricts the result set to one value per
    month, instead of the 28 to 31 rows per month that would result from joining to
    every date. The construction of this query is otherwise very similar to the self-*JOIN*
    query in the last section, with the *JOIN* clause `on b.sales_month between a.date
    - interval ''11 months'' and a.date` of the same form as the *JOIN* clause in
    the self-*JOIN*. Now that we have developed an understanding of what the query
    will return, we can go ahead and apply the `avg` aggregation to get the moving
    average:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，查询返回了二月和三月的`date`结果，除了一月，尽管在子查询结果中这些月份没有销售。这是因为日期维度包含了所有月份的记录。过滤器`a.date
    = a.first_day_of_month`将结果集限制为每个月一个值，而不是每个月28到31行的连接结果。该查询的构建与上一节的自连接查询非常相似，其*JOIN*子句`on
    b.sales_month between a.date - interval '11 months' and a.date`与自连接中的*JOIN*子句形式相同。既然我们已经理解了查询将返回什么结果，我们可以继续应用`avg`聚合来获取移动平均值：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As we saw above, the result set includes a row for every month; however, the
    moving average stays constant until a new data point (in this case, a January
    or July) is added. Each moving average consists of two underlying data points.
    In a real use case, the number of underlying data points is likely to vary. To
    return the current month’s value when using a data dimension, an aggregation with
    a CASE statement can be used—for example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，结果集包括每个月的一行；然而，移动平均值在添加新的数据点（在本例中为一月或七月）之前保持不变。每个移动平均值由两个基础数据点组成。在实际用例中，基础数据点的数量可能会有所变化。使用数据维度时，可以使用带有CASE语句的聚合来返回当前月份的值，例如：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The conditions inside the CASE statement can be changed to return any of the
    underlying records that the analysis requires through use of equality, inequality,
    or offsets with date math. If a date dimension is not available in your database,
    then another technique can be used to simulate one. In a subquery, *SELECT* the
    *DISTINCT* dates needed and *JOIN* them to your table in the same way as in the
    preceding examples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: CASE语句内的条件可以更改为通过使用相等性、不等式或日期数学偏移返回分析所需的任何基础记录。如果您的数据库中没有日期维度，则可以使用另一种技术来模拟它。在子查询中，*SELECT*所需的*DISTINCT*日期，并以与前面示例中相同的方式*JOIN*它们到您的表中：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, I used the same underlying table because I know it contains
    all the months. However, in practice any database table that contains the needed
    dates can be used, whether or not it is related to the table from which you want
    to calculate the rolling aggregation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用了相同的基础表，因为我知道它包含所有的月份。然而，在实践中，任何包含所需日期的数据库表都可以使用，无论它是否与您要计算滚动聚合的表相关。
- en: Calculating rolling time windows with sparse or missing data can be done in
    SQL with controlled application of Cartesian *JOIN*s. Next, we’ll look at how
    to calculate cumulative values that are often used in analysis.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用受控应用笛卡尔*JOIN*可以在SQL中计算包含稀疏或缺失数据的滚动时间窗口。接下来，我们将看看如何计算在分析中经常使用的累积值。
- en: Calculating Cumulative Values
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算累积值
- en: Rolling window calculations, such as moving averages, typically use fixed-size
    windows, such as 12 months, as we saw in the last section.  Another commonly used
    type of calculation is the *cumulative value*, such as YTD, quarter-to-date (QTD),
    and month-to-date (MTD). Rather than a fixed-length window, these rely on a common
    starting point, with the window size growing with each row.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动窗口计算，例如移动平均，通常使用固定大小的窗口，如12个月，正如我们在上一节中看到的。另一种常用的计算类型是*累积值*，例如YTD（年初至今），QTD（季初至今）和MTD（月初至今）。与固定长度窗口不同，这些类型依赖于一个共同的起始点，并且随着每一行窗口大小逐渐增长。
- en: 'The simplest way to calculate cumulative values is with a window function.
    In this example, `sum` is used to find total sales YTD as of each month. Other
    analyses might call for a monthly average YTD or a monthly maximum YTD, which
    can be accomplished by swapping `sum` for `avg` or `max`. The window resets according
    to the *PARTITION BY* clause, in this case the year of the sales month. The *ORDER
    BY* clause typically includes a date field in time series analysis. Omitting the
    *ORDER BY* can lead to incorrect results due to the way the data is sorted in
    the underlying table, so it’s a good idea to include it even if you think the
    data is already sorted by date:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '计算累积值的最简单方法是使用窗口函数。在这个例子中，使用`sum`来查找每个月的总销售额YTD。其他分析可能需要月度平均YTD或月度最大YTD，可以通过将`sum`替换为`avg`或`max`来实现。窗口根据*PARTITION
    BY*子句重置，本例中为销售月份的年份。*ORDER BY*子句通常包括时间序列分析中的日期字段。即使您认为数据已经按日期排序，省略*ORDER BY*可能会导致不正确的结果，因为底层表中数据的排序方式，因此最好包括它： '
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The query returns a record for each `sales_month`, the `sales` for that month,
    and the running total `sales_ytd`. The series starts in 1992 and then resets in
    January 1993, as it will for every year in the data set. The results for years
    2016 through 2020 are graphed in [Figure 3-15](#monthly_sales_and_cumulative_annual_sal).
    The first four years show similar patterns through the year, but of course 2020
    looks very different.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 查询为每个`sales_month`返回一条记录，该月份的`sales`以及累积总计`sales_ytd`。系列从1992年开始，然后在每年的1月份重置，就像数据集中的每一年一样。2016年到2020年的结果在[图3-15](#monthly_sales_and_cumulative_annual_sal)中显示。前四年显示了类似的年度模式，但2020年显然与众不同。
- en: '![](Images/sfda_0315.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0315.png)'
- en: Figure 3-15\. Monthly sales and cumulative annual sales for women’s clothing
    stores
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-15\. 女装店每月销售和年度累积销售
- en: 'The same results can be achieved without window functions, by using a self-*JOIN*
    that leverages a Cartesian *JOIN*. In this example, the two table aliases are
    *JOIN*ed on the year of the `sales_month` to ensure that the aggregated values
    are for the same year, resetting each year. The *JOIN* clause also specifies that
    the results should include `sales_month`s from alias `b` that are less than or
    equal to the `sales_month` in alias `a`. In January 1992, only the January 1992
    row from alias `b` meets this criterion; in February 1992, both January and February
    1992 do; and so on:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用一个自*连接*来实现相同的结果，而不是使用窗口函数，该自*连接*利用笛卡尔*连接*。在这个例子中，两个表别名根据`sales_month`的年份*连接*，以确保聚合值是同一年的，并且每年重新设置。*连接*子句还指定结果应包括别名`b`中小于或等于别名`a`中的`sales_month`。在1992年1月，只有别名`b`中的1992年1月行符合此条件；在1992年2月，别名`b`中的1992年1月和2月行都符合此条件；依此类推：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Window functions require fewer characters of code, and it’s usually easier
    to keep track of exactly what they are calculating once you are familiar with
    the syntax. There’s often more than one way to approach a problem in SQL, and
    rolling time windows are a good example of that. I find it useful to know multiple
    approaches, because every once in a while I run into a tricky problem that is
    actually better solved with an approach that seems less efficient in other contexts.
    Now that we’ve covered rolling time windows, we’ll move on to our final topic
    in time series analysis with SQL: seasonality.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数需要较少的代码字符，并且一旦熟悉了语法，通常更容易跟踪它们正在计算的内容。在SQL中，解决问题的方法通常不止一种，滚动时间窗口就是一个很好的例子。我发现知道多种方法很有用，因为偶尔会遇到一个棘手的问题，实际上最好用看起来在其他上下文中效率较低的方法来解决。现在我们已经介绍了滚动时间窗口，我们将继续讨论SQL中时间序列分析的最后一个主题：季节性。
- en: Analyzing with Seasonality
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用季节性进行分析
- en: '*Seasonality* is any pattern that repeats over regular intervals. Unlike other
    noise in the data, seasonality can be predicted. The word *seasonality* brings
    to mind the four seasons of the year—spring, summer, fall, winter—and some data
    sets include these patterns. Shopping patterns change with the seasons, from the
    clothes and food people buy to the money spent on leisure and travel. The winter
    holiday shopping season can be make-or-break for many retailers. Seasonality can
    also exist at other time scales, from years down to minutes. Presidential elections
    in the United States happen every four years, leading to distinct patterns in
    media coverage.  Day of week cyclicality is common, as work and school dominate
    Monday to Friday, while chores and leisure activities dominate the weekend. Time
    of day is another type of seasonality that restaurants experience, with rushes
    around lunch and dinner time and slower sales in between.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*季节性* 是指在规则间隔内重复的任何模式。与数据中的其他噪音不同，季节性可以预测。"季节性"这个词让人想到一年四季——春、夏、秋、冬——某些数据集包含这些模式。购物模式随季节而变化，从人们购买的衣服和食物到休闲和旅行的支出。冬季假日购物季对许多零售商来说可能是成败的关键。季节性也可能存在于其他时间尺度，从年到分钟。美国的总统选举每四年举行，导致媒体报道出现明显的模式。星期日的周期性是常见的，因为工作和学校主导了星期一到星期五，而家务和休闲活动主导了周末。一天中的时间也是餐厅经历季节性的一种类型，午餐和晚餐时间有高峰期，中间销售较慢。'
- en: To understand whether seasonality exists in a time series, and at what scale,
    it’s useful to graph it and then visually inspect for patterns. Try aggregating
    at different levels, from hourly to daily, weekly, and monthly. You should also
    incorporate knowledge about the data set. Are there patterns that you can guess
    based on what you know about the entity or process it represents? Consult subject
    matter experts, if available.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解时间序列中是否存在季节性以及其规模，有助于绘制图表并视觉检查模式。尝试在不同级别进行聚合，从小时到日常、每周和每月。您还应该融入关于数据集的知识。根据您对实体或过程的了解，是否可以猜测出模式？如果可以的话，可以咨询相关主题专家。
- en: 'Let’s take a look at some seasonal patterns in the retail sales data set, shown
    in [Figure 3-16](#examples_of_seasonality_patterns_in_boo). Jewelry stores have
    a highly seasonal pattern, with annual peaks in December related to holiday gift
    giving. Book stores have two peaks each year: one peak is in August, corresponding
    with back-to-school time in the United States; the other peak starts in December
    and lasts through January, including both the holiday gift period and back-to-school
    time for the spring semester. A third example is grocery stores, which have much
    less monthly seasonality than the other two time series (although they likely
    have seasonality at the day of week and time of day level). This isn’t surprising:
    people need to eat year-round. Grocery store sales increase a bit in December
    for the holidays, and they decline in February, since that month simply has fewer
    days.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看零售销售数据集中的一些季节性模式，显示在[图 3-16](#examples_of_seasonality_patterns_in_boo)中。珠宝店有一个高度季节性的模式，每年12月的高峰与节日赠礼相关联。书店每年有两个高峰：一个高峰在8月，与美国返校季节相对应；另一个高峰从12月开始，持续到1月，包括假日赠礼期和春季学期的返校时间。第三个例子是杂货店，其月度季节性远低于其他两个时间序列（尽管它们可能在每周的某些日子和一天的某些时段存在季节性）。这并不奇怪：人们全年需要食物。杂货店的销售在12月稍有增加，因为节日购物，而在2月份则会下降，因为这个月天数较少。
- en: '![](Images/sfda_0316.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0316.png)'
- en: Figure 3-16\. Examples of seasonality patterns in book store, grocery store,
    and jewelry store sales
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-16\. 书店、杂货店和珠宝店销售中的季节性模式示例
- en: Seasonality can take many forms, though there are some common approaches to
    analyzing it regardless. One way to deal with seasonality is to smooth it out,
    either by aggregating the data to a less granular time period or by using rolling
    windows, as we saw previously. Another way to work with seasonal data is to benchmark
    against similar time periods and analyze the difference. I’ll show several ways
    to accomplish this next.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性可以采取许多形式，但不论如何，有一些常见的分析方法可以解决。处理季节性的一种方法是平滑处理，可以通过将数据聚合到较少粒度的时间段或使用滚动窗口来实现，正如我们之前看到的那样。处理季节性数据的另一种方法是与类似的时间段进行基准比较并分析差异。接下来我将展示几种实现这一目标的方法。
- en: 'Period-over-Period Comparisons: YoY and MoM'
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐期比较：年度同比和月度同比
- en: Period-over-period comparisons can take multiple forms. The first one is to
    compare a time period to the previous value in the series, a practice so common
    in analysis that there are acronyms for the most often-used comparisons. Depending
    on the level of aggregation the comparison might be year-over-year (YoY), month-over-month
    (MoM), day-over-day (DoD), and so on.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 期间对期间的比较可以采用多种形式。第一种是将一个时间段与系列中的前一个值进行比较，这种做法在分析中非常常见，对于最常用的比较方式甚至有缩写。根据比较的聚合级别，比较可以是年度对比
    (YoY)、月度对比 (MoM)、日度对比 (DoD) 等等。
- en: 'For these calculations we’ll use the `lag` function, another one of the window
    functions. The `lag` function returns a previous or lagging value from a series.
    The `lag` function has the following form:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些计算，我们将使用 `lag` 函数，另一个窗口函数。`lag` 函数返回一个系列中的前一个或滞后值。`lag` 函数的形式如下：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `*return_value*` is any field from the data set and thus can be any data
    type. The optional *OFFSET* indicates how many rows back in the partition to take
    the `*return_value*` from. The default is 1, but any integer value can be used.
    You can also optionally specify a `*default*` value to use if there is no lagging
    record to retrieve a value from. Like other window functions, `lag` is also calculated
    over a partition, with sorting determined by the *ORDER BY* clause. If no *PARTITION
    BY* clause is specified, `lag` looks back over the whole data set, and likewise
    if no *ORDER BY* clause is specified, the database order is used. It’s usually
    a good idea to at least include an *ORDER BY* clause in a `lag` window function
    to control the output.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`*return_value*` 是数据集中的任何字段，因此可以是任何数据类型。可选的 *OFFSET* 表示从分区中往回多少行来取 `*return_value*`。默认值为
    1，但可以使用任何整数值。还可以选择指定一个 `*default*` 值，以在没有滞后记录可用时使用。与其他窗口函数一样，`lag` 函数也是在分区内计算的，排序由
    *ORDER BY* 子句确定。如果没有指定 *PARTITION BY* 子句，`lag` 将在整个数据集上往回查找，同样地，如果没有指定 *ORDER
    BY* 子句，则使用数据库的顺序。通常建议在 `lag` 窗口函数中至少包含一个 *ORDER BY* 子句以控制输出。'
- en: Tip
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `lead` window function works in the same way as the `lag` function, except
    that it returns a subsequent value as determined by the offset. Changing the *ORDER
    BY* from ascending (*ASC*) to descending (*DESC*) in a time series has the effect
    of turning a `lag` statement into the equivalent of a `lead` statement. Alternatively,
    a negative integer can be used as the *OFFSET* value to return a value from a
    subsequent row.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`lead` 窗口函数与 `lag` 函数的工作方式相同，不同之处在于它返回由偏移确定的后续值。在时间序列中将 *ORDER BY* 从升序 (*ASC*)
    更改为降序 (*DESC*)，将使 `lag` 语句效果等同于 `lead` 语句。或者，可以使用负整数作为 *OFFSET* 值来返回后续行的值。'
- en: 'Let’s apply this to our retail sales data set to calculate MoM and YoY growth.
    In this section, we’ll focus on book store sales, since I’m a real book store
    nerd. First, we’ll develop our intuition about what is returned by the `lag` function
    by returning both the lagging month and the lagging sales values:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这一方法应用于我们的零售销售数据集，以计算环比增长和同比增长。在本节中，我们将专注于书店销售，因为我是一个真正的书店迷。首先，我们将通过返回滞后的月份和滞后的销售值来开发对
    `lag` 函数返回值的直觉：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For each row, the previous `sales_month` is returned, as well as the `sales`
    for that month, and we can confirm this by inspecting the first few lines of the
    result set. The first row has null for `prev_month` and `prev_month_sales` since
    there is no earlier record in this data set. With an understanding of the values
    returned by the `lag` function, we can calculate the percent change from the previous
    value:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，返回上一个 `sales_month`，以及该月份的 `sales`，我们可以通过检查结果集的前几行来确认这一点。由于数据集中没有更早的记录，第一行的
    `prev_month` 和 `prev_month_sales` 为 null。了解 `lag` 函数返回的值后，我们可以计算与上一个值的百分比变化：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Sales dropped 31.8% from January to February, due at least in part to the seasonal
    decline after the holidays and the return to school for the spring semester. Sales
    were down only 0.7% from February to March.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从一月到二月销售下降了 31.8%，部分原因是假期后季节性下降以及春季学期开学。从二月到三月销售仅下降了 0.7%。
- en: 'The calculation for the YoY comparison is similar, but first we need to aggregate
    sales to the yearly level. Since we’re looking at only one `kind_of_business`,
    I’ll drop that field from the rest of the examples to simplify the code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: YoY 比较的计算方式类似，但首先我们需要将销售额聚合到年度水平。因为我们只关注一个 `kind_of_business`，所以我将该字段从其余的示例中删除，以简化代码。
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Sales grew more than 9.3% from 1992 to 1993, and almost 11% from 1993 to 1994\.
    These period-over-period calculations are useful, but they don’t quite allow us
    to analyze the seasonality in the data set. For example, in [Figure 3-17](#percent_growth_from_previous_month_for)
    the MoM percent growth values are plotted, and they contain just as much seasonality
    as the original time series.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从1992年到1993年，销售额增长了超过9.3%，从1993年到1994年增长了近11%。这些时期对时期的计算非常有用，但它们不能完全分析数据集中的季节性。例如，在[图3-17](#percent_growth_from_previous_month_for)中绘制了MoM百分比增长值，它们与原始时间序列一样包含同样多的季节性。
- en: '![](Images/sfda_0317.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0317.png)'
- en: Figure 3-17\. Percent growth from previous month for US retail book store sales
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-17. 美国零售书店销售额上个月百分比增长
- en: To tackle this, the next section will demonstrate how to use SQL to compare
    current values to the values for the same month in the previous year.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将演示如何使用SQL比较当前值与去年同月的值。
- en: 'Period-over-Period Comparisons: Same Month Versus Last Year'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时期对时期比较：同月对比去年
- en: Comparing data for one time period to data for a similar previous time period
    can be a useful way to control for seasonality. The previous time period may be
    the same day of the week in the previous week, the same month in the previous
    year, or another variation that makes sense for the data set.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个时间段的数据与一个类似的先前时间段的数据进行比较，可以有效地控制季节性变化。先前的时间段可以是前一周的同一天，前一年的同一月，或者数据集合理的其他变化。
- en: 'To accomplish this comparison, we can use the `lag` function along with some
    clever partitioning: the unit of time with which we want to compare the current
    value. In this case, we will compare monthly `sales` to the `sales` for the same
    month in the previous year. For example, January `sales` will be compared to prior
    year January `sales`, February `sales` will be compared to prior year February
    `sales`, and so on.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一比较，我们可以使用`lag`函数以及一些巧妙的分区方法：我们想要将当前值与其比较的时间单位。在这种情况下，我们将每月的`sales`与去年同月的`sales`进行比较。例如，1月的`sales`将与前一年的1月`sales`进行比较，2月的`sales`将与前一年的2月`sales`进行比较，依此类推。
- en: 'First, recall that the `date_part` function returns a numeric value when used
    with the “month” argument:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回想一下`date_part`函数在使用“month”参数时返回一个数值：
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, we include the `date_part` in the *PARTITION BY* clause so that the window
    function looks up the value for the matching month number from the prior year.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`date_part`包含在*PARTITION BY*子句中，以便窗口函数从前一年查找匹配的月份数值。
- en: 'This is an example of how window function clauses can include calculations
    in addition to database fields, giving them even more versatility. I find it useful
    to check intermediate results to build intuition about what the final query will
    return, so first we’ll confirm that the `lag` function with `partition by date_part(''mon⁠th'',​sales_month)`
    returns the intended values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个窗口函数子句如何在数据库字段之外进行计算的示例，从而使它们具有更高的灵活性。我发现检查中间结果以建立对最终查询返回内容的直觉非常有用，因此我们首先确认带有`partition
    by date_part('mon⁠th',​sales_month)`的`lag`函数是否返回预期的值：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first `lag` function returns the same month for the prior year, which we
    can verify by looking at the `prev_year_month` value. The row for the 1993-01-01
    `sales_month` returns 1992-01-01 for the `prev_year_month` as intended, and the
    `prev_year_sales` of 790 match the `sales` we can see in the 1992-01-01 row. Notice
    that the `prev_year_month` and `prev_year_sales` are null for 1992 since there
    are no prior records in the data set.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`lag`函数返回前一年的同月数据，我们可以通过查看`prev_year_month`值来验证。对于1993-01-01的`sales_month`，`prev_year_month`返回了1992-01-01，与预期一致，并且`prev_year_sales`的值为790，与我们在1992-01-01行看到的`sales`匹配。请注意，由于数据集中没有先前的记录，1992年的`prev_year_month`和`prev_year_sales`为空。
- en: 'Now that we’re confident the `lag` function as written returns the correct
    values, we can calculate comparison metrics such as absolute difference and percent
    change from previous:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`lag`函数返回正确值很有信心，我们可以计算比较指标，如绝对差异和与上年同期的百分比变化：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can now graph the results in [Figure 3-18](#book_store_salescomma_yoy_absolute_diff)
    and more easily see the months where growth was unusually high, such as January
    2002, or unusually low, such as December 2001.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在[图3-18](#book_store_salescomma_yoy_absolute_diff)中绘制结果，并更容易地看到增长异常高的月份，如2002年1月，或者异常低的月份，如2001年12月。
- en: '![](Images/sfda_0318.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0318.png)'
- en: Figure 3-18\. Book store sales, YoY absolute difference in sales, and YoY percent
    growth
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-18\. 书店销售额，年同比销售额绝对差异及年同比增长率
- en: Another useful analysis tool is to create a graph that lines up the same time
    period—in this case, months—with a line for each time series—in this case, years.
    To do this, we’ll create a result set that has a row for each month number or
    name, and a column for each of the years we want to consider. To get the month,
    we can use either the `date_part` or the `to_char` function, depending on whether
    we want numeric or text values for the months. Then we’ll pivot the data using
    an aggregate function.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的分析工具是创建一个图表，将相同时间段（在本例中是月份）与每个时间序列（在本例中是年份）对齐。为此，我们将创建一个结果集，其中每个月份都有一行，以及我们想考虑的每年的列。为了获取月份，我们可以使用`date_part`或`to_char`函数，具体取决于我们是想要数字还是文本值的月份。然后，我们将使用聚合函数对数据进行透视。
- en: 'This example uses the `max` aggregate, but depending on the analysis, a `sum`,
    `count`, or other aggregation might be appropriate. We’ll zoom in on 1992 through
    1994 for this example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了`max`聚合函数，但根据分析情况，可能需要使用`sum`、`count`或其他聚合函数。本例中我们将重点放在1992年至1994年之间：
- en: '[PRE68]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: By lining the data up in this way, we can see some trends immediately. December
    sales are the highest monthly sales of the year. Sales in 1994 were higher every
    month than sales in 1992 and 1993\. The August-to-September sales bump is visible,
    and particularly easy to spot in 1994.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式对齐数据，我们可以立即看到一些趋势。12月的销售额是全年最高的。1994年的每个月销售额均高于1992年和1993年的销售额。8月至9月的销售增长在1994年特别明显。
- en: With a graph of the data, as in [Figure 3-19](#book_store_sales_for_onenineninetwoen_d),
    the trends are much easier to identify. Sales increased year to year in every
    month, though the increases were larger in some months than others. With this
    data and graph in hand, we can start to construct a story about book store sales
    that might help with inventory planning or scheduling of marketing promotions
    or might serve as a piece of evidence in a wider story about US retail sales.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[图3-19](#book_store_sales_for_onenineninetwoen_d)中的数据图表所示，趋势更加容易识别。销售额在每个月份年度增长，尽管某些月份的增长幅度较大。有了这些数据和图表，我们可以开始构建有关书店销售的故事，这可能有助于库存规划、营销促销的安排，或者作为美国零售销售更广泛故事中的证据之一。
- en: With SQL there are a number of techniques for cutting through the noise of seasonality
    to compare data in time series. In this section, we’ve seen how to compare current
    values to prior comparable periods using `lag` functions and how to pivot the
    data with `date_part`, `to_char`, and aggregate functions. Next, I’ll show some
    techniques for comparing multiple prior periods in order to further control for
    noisy time series data.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL可以采用多种技术来消除季节性噪声，以比较时间序列数据。在本节中，我们已经看到了如何使用`lag`函数来比较当前值与先前可比期间的值，以及如何使用`date_part`、`to_char`和聚合函数来透视数据。接下来，我将展示一些比较多个先前期间的技术，以进一步控制时间序列数据中的噪声。
- en: '![](Images/sfda_0319.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0319.png)'
- en: Figure 3-19\. Book store sales for 1992–1994, aligned by month
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-19\. 1992年至1994年书店销售额，按月对齐
- en: Comparing to Multiple Prior Periods
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与多个先前时期比较
- en: Comparing data to prior comparable periods is a useful way to reduce the noise
    that arises from seasonality. Sometimes comparing to a single prior period is
    insufficient, particularly if that prior period was impacted by unusual events.
    Comparing a Monday to the previous Monday is difficult if one of them was a holiday.
    The month in the prior year might be unusual due to economic events, severe weather,
    or a site outage that changed typical behavior. Comparing current values to an
    aggregate of multiple prior periods can help smooth out these fluctuations. These
    techniques also combine what we’ve learned about using SQL to calculate rolling
    time periods and comparable prior period results.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据与先前可比期间进行比较是减少由季节性引起的噪声的一种有效方式。有时，仅与单个先前期间比较是不够的，特别是如果该先前期间受到异常事件影响。比如，如果一个周一是假期，那么与前一个周一进行比较就很困难。由于经济事件、恶劣天气或站点故障改变了典型行为，前一年的同月份可能是异常的。将当前值与多个先前期间的聚合值进行比较可以帮助平滑这些波动。这些技术也结合了我们学到的使用SQL计算滚动时间段和可比先前期间结果的内容。
- en: The first technique uses the `lag` function, as in the last section, but here
    we’ll take advantage of the optional offset value. Recall that when no offset
    is provided to `lag`, the function returns the immediate prior value according
    to the *PARTITION BY* and *ORDER BY* clauses. An offset value of 2 skips over
    the immediate prior value and returns the value prior to that, an offset value
    of 3 returns the value from 3 rows back, and so on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术使用了 `lag` 函数，就像上一节中一样，但在这里我们将利用可选的偏移值。回想一下，当 `lag` 函数没有提供偏移值时，根据 *PARTITION
    BY* 和 *ORDER BY* 子句，函数返回即时前值。偏移值为2跳过即时前值，并返回再前一个值；偏移值为3返回3行前的值，以此类推。
- en: 'For this example, we’ll compare the current month’s sales to the same month’s
    sales over three prior years. As usual, first we’ll inspect the returned values
    to confirm the SQL is working as expected:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例，我们将比较当前月销售与前三年同月销售情况。和往常一样，首先我们将检查返回的值，确认 SQL 是否按预期工作：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Null is returned where no prior record exists, and we can confirm that the
    correct same month, prior year value appears. From here we can calculate whatever
    comparison metric the analysis calls for—in this case, the percent of the rolling
    average of three prior periods:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有先前记录的情况下返回 Null，并且我们可以确认正确的上年同月值已出现。从这里我们可以计算分析需要的任何比较指标，比如本例中的前三个时期滚动平均值的百分比：
- en: '[PRE70]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can see from the result that book sales grew from the prior three-year rolling
    average in the mid-1990s, but the picture was different in the late 2010s, when
    sales were a shrinking percentage of that three-year rolling average each year.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从结果看出，书籍销售量从上世纪90年代中期的前三年滚动平均值中增长，但在2010年代末期情况有所不同，每年的销售量占该三年滚动平均值的比例在逐年减少。
- en: 'You might have noticed that this problem resembles one we saw earlier when
    calculating rolling time windows. As an alternative to the last example, we can
    use an `avg` window function with a frame clause. To accomplish this, the *PARTITION
    BY* will use the same `date_part` function, and the *ORDER BY* is the same. A
    frame clause is added to include `rows between 3 preceding and 1 preceding`.  This
    includes the values in the 1, 2, and 3 rows prior but excludes the value in the
    current row:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这个问题与我们在计算滚动时间窗口时看到的问题类似。作为最后一个示例的替代方案，我们可以使用具有框架子句的 `avg` 窗口函数。为了实现这一点，*PARTITION
    BY* 将使用相同的 `date_part` 函数，*ORDER BY* 也是相同的。框架子句被添加以包括 `rows between 3 preceding
    and 1 preceding`。这包括前1、2和3行的值，但不包括当前行的值：
- en: '[PRE71]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The results match those of the previous example, confirming that the alternative
    code is equivalent.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与先前示例的结果相匹配，证实了替代代码的等效性。
- en: Tip
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you look closely, you’ll notice that the decimal place values are slightly
    different in the result using the three `lag` windows and the result using the
    `avg` window function. This is due to how the database handles decimal rounding
    in intermediate calculations. For many analyses, the difference won’t matter,
    but pay careful attention if you’re working with financial or other highly regulated
    data.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会注意到在使用三个 `lag` 窗口和使用 `avg` 窗口函数时，结果中的小数位值略有不同。这是由于数据库在中间计算中处理小数舍入的方式不同。对于许多分析而言，这种差异并不重要，但是如果您处理财务或其他受严格监管的数据时，请注意仔细检查。
- en: Analyzing data with seasonality often involves trying to reduce noise in order
    to make clear conclusions about the underlying trends in the data. Comparing data
    points against multiple prior time periods can give us an even smoother trend
    to compare to and determine what is actually happening in the current time period.
    This does require that the data include enough history to make these comparisons,
    but when we have a long enough time series, it can be insightful.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 分析具有季节性的数据通常涉及试图减少噪声，以便对数据中的基本趋势做出明确的结论。将数据点与多个先前时间段进行比较，可以为我们提供更平滑的趋势，并确定当前时间段实际发生的情况。这要求数据包含足够的历史记录以进行这些比较，但是当我们拥有足够长的时间序列时，这可能会提供深刻的见解。
- en: Conclusion
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Time series analysis is a powerful way to analyze data sets. We’ve seen how
    to set up our data for analysis with date and time manipulations. We talked about
    date dimensions and saw how to apply them to calculating rolling time windows.
    We looked at period-over-period calculations and how to analyze data with seasonality
    patterns. In the next chapter, we’ll delve deep into a related topic that extends
    on time series analysis: cohort analysis.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析是分析数据集的一种强大方式。我们已经了解了如何通过日期和时间操作设置我们的数据进行分析。我们讨论了日期维度，并看到如何将其应用于计算滚动时间窗口。我们研究了期间对比的计算方法以及如何分析具有季节性模式的数据。在下一章中，我们将深入探讨一个与时间序列分析相关的主题：队列分析。
- en: ^([1](ch03.xhtml#ch01fn6-marker)) October and November 2020 data points were
    suppressed by the publisher of the data, due to concerns about the data quality.
    Collecting the data likely became more difficult due to store closures during
    the 2020 pandemic.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#ch01fn6-marker)) 出版商由于对数据质量的担忧，压制了2020年10月和11月的数据点。由于2020年大流行期间商店关闭，数据的收集可能变得更加困难。
