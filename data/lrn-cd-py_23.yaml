- en: 'Lesson 19\. Capstone project: Scrabble, Art Edition'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19课\. 期末项目：Scrabble，艺术版
- en: After reading [lesson 19](#ch19), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第19课](#ch19)之后，你将能够
- en: Apply conditionals and loops to write a more complicated program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用条件语句和循环来编写更复杂的程序
- en: Understand what’s being asked of you in a program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解程序中对你提出的要求
- en: Draw up a plan of how to solve a problem before starting to code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始编码之前，制定解决问题的计划
- en: Break the problem into smaller subproblems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题分解成更小的子问题
- en: Write code for the solution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写解决方案的代码
- en: You’re playing a simpler version of Scrabble with your kids. The kids have been
    winning most games so far, and you realize it’s because you aren’t picking the
    best word from the given tiles. You decide that you need a bit of help in the
    form of a computer program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在和你孩子玩一个更简单的Scrabble版本。到目前为止，孩子们赢得了大多数游戏，你意识到这是因为你没有从给定的瓷砖中挑选出最好的单词。你决定你需要一点计算机程序的帮助。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The problem
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: 'Write a program that can tell you words that you can form from a set of tiles;
    the set of all valid words is a subset of all the English words (in this case,
    only words related to art). When dealing with choosing the best word from the
    given tiles, here are some details to remember:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，可以告诉你可以从一组瓷砖中形成的单词；所有有效单词的集合是所有英语单词的子集（在这种情况下，仅限于与艺术相关的单词）。在处理从给定瓷砖中选择最佳单词时，以下是一些需要注意的细节：
- en: All valid words related to art are given to you as a string, each word separated
    by a newline. The string organizes the words by length, shortest to longest. All
    valid words contain only letters in the alphabet (no spaces, hyphens, or special
    symbols). For example,
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有与艺术相关的有效单词都给你作为字符串，每个单词由换行符分隔。字符串按长度组织单词，从短到长。所有有效单词只包含字母（没有空格、连字符或特殊符号）。例如，
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The number of tiles you get can vary; it’s not a fixed number.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你得到的瓷砖数量可能不同；它不是一个固定的数字。
- en: Letters on tiles don’t have point values; they’re all worth the same.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓷片上的字母没有点值；它们都值相同。
- en: The tiles you get are given as a string. For example, `tiles = "hijklmnop"`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你得到的瓷砖是以字符串的形式给出的。例如，`tiles = "hijklmnop"`。
- en: Report all valid words you can form with your tiles in a tuple of strings; for
    example, `('ink', 'oil', 'kiln')`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以字符串元组的形式报告你可以用你的瓷砖形成的所有有效单词；例如，`('ink', 'oil', 'kiln')`。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 19.1\. Understanding the problem statement
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1\. 理解问题陈述
- en: 'This programming task sounds involved, so try to break it into a few subtasks.
    There are two big parts to this problem:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编程任务听起来很复杂，所以试着将其分解成几个子任务。这个问题有两个主要部分：
- en: Represent all the possible valid words in a format that you can work with. Convert
    the words from a long string of characters into a tuple of string words.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以你可以处理的形式表示所有可能的有效单词。将单词从一长串字符转换为字符串单词元组。
- en: Decide whether a word in the list of all valid words can be made with the set
    of tiles you’re given.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断列表中所有有效单词是否可以用你给出的瓷砖组合成。
- en: 19.1.1\. Change the representation of all valid words
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.1.1\. 改变所有有效单词的表示形式
- en: Let’s tackle the first part, which will help you create a tuple of all the valid
    words so you can work with them later. You need to do this step because if you
    keep the valid words as is, you have a big string of characters that’s hard to
    work with.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决第一部分，这将帮助你创建所有有效单词的元组，以便你以后可以处理它们。你需要这样做，因为如果你保持有效单词不变，你将有一个难以处理的字符长串。
- en: The set of all valid words is given to you as a string. To the computer, each
    “line” that a human sees isn’t a line with a word on it, but a long sequence of
    characters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有效单词的集合以字符串的形式给出。对计算机来说，人类看到的每一行并不是带有单词的行，而是一长串字符。
- en: Draw out the problem
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制出问题
- en: It’s always a good idea to start with a small sketch of what you need to do.
    To the human eye, the string looks nicely organized, and you can tell the words
    apart, but the computer doesn’t know the concept of words in a string, only single
    characters. The computer sees something like `"""art\nhue\nink\noil\n...\ncrosshatching"""`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总是先画一个小草图，看看你需要做什么。对人眼来说，字符串看起来组织得很好，你可以分辨出单词，但计算机不知道字符串中单词的概念，它只看到单个字符。计算机看到的是类似`"""art\nhue\nink\noil\n...\ncrosshatching"""`的东西。
- en: The line breaks that you can see with your eyes are single characters themselves,
    each called the *newline* (or *linebreak*) character, represented by `\n`. You’ll
    have to find out the position of every newline character so you can separate each
    word. [Figure 19.1](#ch19fig01) shows how you might think about this in a more
    systematic way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你用眼睛可以看到的行断是单个字符，每个都称为**换行符**（或**行断**），表示为`\n`。你需要找出每个换行符的位置，以便分隔每个单词。[图19.1](#ch19fig01)展示了你可能会以更系统的方式考虑这一点。
- en: Figure 19.1\. Converting a string of characters into words. In the top example
    named *start*, you can keep track of where you are in the character string by
    using a *start* and *end* pointer. In the middle example named *found word*, you
    stop changing *end* when you reach a newline character. In the bottom example
    named *start next*, you reset the *start* and *end* pointers to the character
    right after the newline.
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.1. 将字符字符串转换为单词。在上面的例子中，命名为*start*，你可以通过使用*开始*和*结束*指针来跟踪你在字符字符串中的位置。在中间的例子中，命名为*found
    word*，当你达到换行字符时停止改变*结束*指针。在底部的例子中，命名为*start next*，你将*开始*和*结束*指针重置为换行符之后的字符。
- en: '![](images/19fig01_alt.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/19fig01_alt.jpg)'
- en: With this simple sketch, you can already see how to achieve this task. The *start*
    and *end* pointers start at the beginning of the big string. As you’re looking
    for a newline character to mark the end of the word, you’ll increment the *end*
    pointer until you find the `\n`. At that point, you can store the word from the
    *start* pointer to the *end* pointer. Then, move both pointers to one index past
    the newline character to start looking for the next word.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的草图，你就可以看到如何完成这个任务。**开始**和**结束**指针从大字符串的开头开始。当你寻找换行字符来标记单词的结尾时，你会增加**结束**指针直到找到`\n`。在那个点上，你可以从**开始**指针到**结束**指针存储单词。然后，将两个指针移动到换行字符之后的索引处，开始寻找下一个单词。
- en: Come up with some examples
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提出一些例子
- en: Write some test cases that you may want to think about as you’re writing your
    program. Try to think of simple cases and complex ones. For example, all valid
    words might be just one word, such as `words = """art"""`, or it might be a few
    words, such as the example given in the problem statement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些测试用例，你可能想在编写程序时考虑这些用例。尽量考虑简单的情况和复杂的情况。例如，所有有效的单词可能只是一个单词，比如`words = """art"""`，或者可能是一两个单词，比如问题陈述中给出的例子。
- en: Abstract the problem into pseudocode
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将问题抽象为伪代码
- en: Now that you have an idea of how to convert characters to words, you can start
    writing a mixture of code and text to help you put the big picture into place,
    and to start thinking about the details.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何将字符转换为单词，你可以开始编写代码和文本的混合体，帮助你将整体情况定位，并开始考虑细节。
- en: 'Because you need to look at all letters in the string, you need a loop. In
    the loop, you decide whether you’ve found a newline character. If you found the
    newline character, save the word and reset your pointer indexes. If you didn’t
    find a newline character, keep incrementing only the *end* index until you do.
    The pseudocode might look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你需要查看字符串中的所有字母，你需要一个循环。在循环中，你决定是否找到了换行字符。如果你找到了换行字符，保存单词并重置你的指针索引。如果你没有找到换行字符，只增加*结束*索引直到你找到。伪代码可能看起来像这样：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 19.1.2\. Making a valid word with the given tiles
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.1.2. 使用给定的拼图制作一个有效的单词
- en: Now you can think about the logic for deciding whether you can make a valid
    word using the given tiles, with the valid word coming from the list of allowed
    words.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以考虑使用给定的拼图来决定是否可以组成一个有效的单词，有效的单词来自允许的单词列表。
- en: Draw out the problem
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制出问题
- en: 'As usual, it helps to draw what you need to do. The logic for this part of
    the problem can be approached in a couple of ways:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，画图有助于理解。这个问题的一部分逻辑可以通过几种方式来处理：
- en: You can start by looking at the tiles in your hand. Find all combinations of
    them. Then you can look at each combination of letters and see whether they match
    any of the valid words.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从查看手中的拼图开始。找出所有可能的组合。然后你可以查看每个字母组合，看看它们是否与任何有效的单词匹配。
- en: You can start by looking at the valid words and see whether each can be made
    using the tiles you have.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从查看有效的单词开始，看看每个是否可以用你拥有的拼图制作。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Thinking like a programmer**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: This part is crucial when you’re trying to decide which way to approach a problem.
    The process of drawing helps you think of a few ways before settling on one. If
    you start to code immediately, you’ll feel boxed into one path that may or may
    not even be appropriate for the problem at hand. The process of sketching will
    help you see what issues may arise with a few solutions without committing to
    any yet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图决定如何解决问题时，这部分内容至关重要。绘图的过程可以帮助你在确定一种方法之前想出几种方法。如果你立即开始编码，你可能会感觉被限制在一条可能或可能不适合当前问题的路径上。草图的过程将帮助你看到在没有做出任何承诺的情况下，几种解决方案可能引发的问题。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first option, although possibly more intuitive, is a bit harder to implement
    with what you know so far because it involves finding all combinations and permutations
    of all the tiles. The second option is more appropriate at this time. [Figure
    19.2](#ch19fig02) illustrates the second option.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项，虽然可能更直观，但根据你目前所知，实现起来可能有点困难，因为它涉及到找到所有拼图块的所有组合和排列。第二个选项目前更合适。[图19.2](#ch19fig02)说明了第二个选项。
- en: Figure 19.2\. Given the valid words and a set of tiles, start with the first
    valid word and check whether all its letters are in the set of tiles. If so, add
    it to the set of words you can make. If at least one letter is in a valid word
    but not in the tiles, you can’t make the word.
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.2。给定有效的单词和一组拼图块，从第一个有效的单词开始，检查其所有字母是否都在拼图块的集合中。如果是这样，将其添加到你可以用它组成的单词集合中。如果至少有一个字母在有效的单词中但不在拼图块中，你就无法组成那个单词。
- en: '![](images/19fig02_alt.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/19fig02_alt.jpg)'
- en: You’ll go through each valid word and then look at each letter in that word,
    checking whether you can find the letter in your tiles. After you’ve gone through
    all the letters of the word and you’re able to find them in your tiles, you can
    make that word with your tiles. As soon as you find that there’s one letter not
    in your tiles, you can immediately stop because you can’t make that word.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遍历每个有效的单词，然后查看该单词中的每个字母，检查你是否能在你的拼图块中找到该字母。在你遍历了单词的所有字母并且你能在你的拼图块中找到它们之后，你就可以用你的拼图块组成那个单词。一旦你发现有一个字母不在你的拼图块中，你就可以立即停止，因为你无法组成那个单词。
- en: Come up with some examples
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提出一些例子
- en: 'Coming up with examples can help you determine special situations you may have
    to take care of in your code. Here are some examples of tiles you may want to
    make sure your code can handle:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 提出例子可以帮助你确定你可能需要在代码中处理的特殊情况。以下是一些你可能想要确保你的代码可以处理的拼图块示例：
- en: A single tile—in this case, you can’t make any valid word.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个拼图块——在这种情况下，你无法组成任何有效的单词。
- en: All the tiles given make exactly one valid word—with `tiles = "art"`, you can
    make the word *art.*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的拼图块恰好可以组成一个有效的单词——当`tiles = "art"`时，你可以组成单词*art*。
- en: All the tiles given make exactly two valid words—with `tiles = "euhtar",` you
    can make *art* and *hue.*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定的所有拼图块恰好可以组成两个有效的单词——当`tiles = "euhtar"`时，你可以组成*art*和*hue*。
- en: You can make one valid word but have extra tiles left over—with `tiles = "tkabr"`,
    you can make *art* and have *k* and *b* left over.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以组成一个有效的单词，但会有多余的拼图块剩下——当`tiles = "tkabr"`时，你可以组成*art*，并且还剩下*k*和*b*。
- en: You have only one tile of a certain letter, but a valid word uses two of that
    letter—with `tiles = "colr"`, you can’t make the word *color* because you have
    only one *o*.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只有一个特定字母的拼图块，但一个有效的单词需要两个该字母——当`tiles = "colr"`时，你无法组成单词*color*，因为你只有一个*o*。
- en: Abstract the problem into pseudocode
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将问题抽象成伪代码
- en: With pseudocode, you can start to think about more of the details that you discovered
    while coming up with examples. You’ll need to go through each valid word to see
    whether you can make it with your tiles, so you’ll need a loop. Then you’ll go
    through each letter in that word; you’ll need a nested loop inside the first one.
    You can immediately exit the inner loop as soon as you find one letter that isn’t
    in your tiles. But if each letter you look at is in your tiles, keep going.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪代码，你可以开始思考在提出例子时发现的更多细节。你需要遍历每个有效的单词，看看你是否可以用你的拼图块组成它，所以你需要一个循环。然后你将遍历该单词中的每个字母；你需要在第一个循环内部嵌套一个循环。一旦你找到一个不在你的拼图块中的字母，你就可以立即退出内部循环。但如果你看的每个字母都在你的拼图块中，你就继续。
- en: 'This logic has two tricky parts: (1) how to keep track of words that have multiples
    of the same letter and (2) how to tell when you found the full word in your tiles.
    You don’t have to outline exactly how to do these in the pseudocode, but you should
    be able to tell whether they’re issues that can be resolved. I can tell you that
    they can be resolved, and you’ll see how in the next section. The pseudocode for
    this part might be'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑有两个棘手的部分：（1）如何跟踪有相同字母多次出现的单词，以及（2）如何判断你在拼图中找到了完整的单词。你不需要在伪代码中详细说明如何做到这些，但你应该能够判断这些问题是否可以解决。我可以告诉你，它们是可以解决的，你将在下一节中看到。这个部分的伪代码可能如下所示
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that there’s a lot going on and a few more variables to keep track of
    in this problem than you’re used to! Without thinking about the problem first,
    you’d quickly get lost. At this point, with an understanding of the major components
    to this problem, you can start to write the code. An important first step is deciding
    how to divide your code into smaller, more manageable chunks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题中有很多事情在进行，并且比你所习惯的问题有更多的变量需要跟踪！如果不先思考这个问题，你会很快迷失方向。在这个时候，如果你理解了这个问题的主要组成部分，你就可以开始编写代码了。一个重要的第一步是决定如何将你的代码分成更小、更易于管理的块。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Thinking like a programmer**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: 'Dividing code into smaller pieces is a necessary and important skill for a
    programmer for a few important reasons:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分成更小的部分是程序员的一项必要且重要的技能，有几个重要的原因：
- en: Large problems look less intimidating after they’re broken into smaller pieces.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大问题分解成小块后，它们看起来就不那么令人畏惧了。
- en: Pieces are easier to code when you can focus on only the relevant parts of the
    problem.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你可以只关注问题的相关部分时，编写代码会更容易。
- en: Pieces are much easier to debug than an entire program, because the number of
    possible inputs to a module is typically a lot smaller than the number of possible
    inputs to your entire program.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与整个程序相比，模块的可能输入数量通常要小得多，因此这些部分更容易调试。
- en: When you know that each separate piece works as expected, you can put them together
    to create your final program. The more you program, the more you’ll get the hang
    of what would make a good, coherent piece of code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道每个单独的部分都按预期工作后，你可以将它们组合起来创建你的最终程序。你编写的程序越多，你就越能掌握什么会是一个好的、连贯的代码块。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 19.2\. Dividing your code into pieces
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2\. 将你的代码分成块
- en: You can now start thinking about how to divide the code into small chunks of
    logic. The first chunk is usually to look at the input given and extract all the
    useful information you want to use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以开始思考如何将代码分成逻辑上的小块。第一块通常是查看输入并提取你想要使用的所有有用信息。
- en: Set up the valid words related to art (as a string) and set up the tiles you’re
    starting out with (as a string).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置与艺术相关的有效单词（作为一个字符串）和设置你开始时的拼图（作为一个字符串）。
- en: Set up initializations for *start* and *end* pointers to find all valid words.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起始和结束指针的初始化，以找到所有有效单词。
- en: Set up an empty tuple to add to it all valid words as you find them.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个空元组，以便在找到所有有效单词时将其添加到其中。
- en: Set up an empty tuple for the words found in your tiles.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你在拼图中发现的所有单词设置一个空元组。
- en: '[Listing 19.1](#ch19ex01) provides the code for these initializations. You’ll
    notice something new: a string variable that contains characters within two sets
    of triple quotes. The triple quotes allow you to create a string object that spans
    multiple lines. All characters inside the triple quotes are part of the string
    object, including line breaks!'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表19.1](#ch19ex01) 提供了这些初始化的代码。你会注意到一些新东西：一个包含字符的字符串变量，这些字符位于三重引号之间。三重引号允许你创建跨越多行的字符串对象。三重引号内的所有字符都是字符串对象的一部分，包括换行符！'
- en: 'Listing 19.1\. Scrabble: Art Edition code for initializations'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表19.1\. Scrabble: Art Edition 初始化代码'
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Valid words as a big string**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 作为大字符串的有效单词**'
- en: '***2* Empty tuple for all valid words**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用于所有有效单词的空元组**'
- en: '***3* Initializes a pointer to the beginning of index search**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 初始化索引搜索的起始指针**'
- en: '***4* Initializes a pointer to the end of index search**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 初始化索引搜索的结束指针**'
- en: '***5* Empty tuple for words found in tiles**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 用于拼图中找到的单词的空元组**'
- en: In this program, the second chunk of logic is to convert the big string of all
    words into a tuple containing string elements as each word. With the pseudocode
    written previously, all you have to do is convert the English parts to code. The
    one part you must be careful of is how to add the valid word to your tuple of
    valid words. Notice that the word you find is a single word that’s added to the
    tuple, so you’ll have to use the concatenation operator between your valid words
    tuple and the singleton tuple of the word that you just found.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，第二个逻辑块是将所有单词的大字符串转换为包含字符串元素的元组。根据之前编写的伪代码，你只需要将英语部分转换为代码。你必须小心处理的部分是如何将有效单词添加到你的有效单词元组中。注意，你找到的单词是一个单独的单词，它被添加到元组中，所以你将不得不在你的有效单词元组和刚刚找到的单词的单例元组之间使用连接运算符。
- en: '[Listing 19.2](#ch19ex02) shows the code. Pointers `start` and `end` are initially
    0, pointing to the first character. Words are read as one big string, so you iterate
    through each character. When the character is a newline, you know that you’ve
    reached the end of a word. At that point, you save the word by indexing using
    the `start` and `end` pointer positions. Then, reset the pointers to be one position
    past the newline’s position; this is the character that starts the next valid
    word. If the character isn’t a newline, you’re still reading what word it is,
    so move only the `end` pointer over.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表19.2](#ch19ex02)显示了代码。指针`start`和`end`最初为0，指向第一个字符。单词作为一个大字符串被读取，因此你遍历每个字符。当字符是换行符时，你知道你已经到达了单词的末尾。在那个点上，你通过使用`start`和`end`指针位置来索引保存单词。然后，将指针重置为换行符位置之后的一个位置；这是下一个有效单词开始的字符。如果字符不是换行符，你仍在读取它是什么单词，所以只移动`end`指针。'
- en: 'Listing 19.2\. Scrabble: Art Edition code to get all valid words'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.2\. 拼字游戏：艺术版代码以获取所有有效单词
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Iterates through every character**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历每个字符**'
- en: '***2* Checks whether the character is a newline**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查字符是否为换行符**'
- en: '***3* Adds singleton tuple to current all valid words tuple**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将单例元组添加到当前所有有效单词元组中**'
- en: '***4* Moves start and end pointers to start of next word**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将开始和结束指针移动到下一个单词的开始**'
- en: '***5* Moves only end pointer**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 只移动结束指针**'
- en: 'The third and last chunk of logic is to check whether each of the valid words
    can be made using your tiles. As with the previous chunk, you can copy the pseudocode
    and fill in the blanks. A couple of interesting things to note were left unanswered
    in the pseudocode: (1) how to keep track of words that have multiples of the same
    letter and (2) how to tell when you found the full word in your tiles.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和最后一个逻辑块是检查每个有效单词是否可以使用你的拼图来制作。与前面的块一样，你可以复制伪代码并填写空白。在伪代码中留下了几个有趣但未解决的问题：(1)
    如何跟踪具有相同字母多个副本的单词，以及(2) 如何判断你已经在拼图中找到了完整的单词。
- en: To solve (1), you can write code that removes tiles as they’re matched from
    a valid word. With each new valid word, you can use a variable named `tiles_left`,
    initially all the tiles you have, that keeps track of the tiles you have left.
    As you iterate through each letter in a valid word and find that it’s in your
    tiles, you can update `tiles_left` to be all the letters except the letter just
    found.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决(1)，你可以编写代码，在匹配到有效单词时移除拼图。对于每个新的有效单词，你可以使用一个名为`tiles_left`的变量，最初包含你所有的拼图，以跟踪你剩余的拼图。当你遍历有效单词中的每个字母并发现它在你的拼图中时，你可以更新`tiles_left`以包含所有字母，除了刚刚找到的字母。
- en: To solve (2), you know that if you found all the tiles and you’ve been removing
    tiles from `tiles_left` as you find them, then the number of tiles removed plus
    the length of the valid word are going to be equal to the number of tiles you
    started with.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决(2)，你知道如果你找到了所有拼图，并且你在找到它们时从`tiles_left`中移除了拼图，那么移除的拼图数量加上有效单词的长度将等于你开始时的拼图数量。
- en: The following listing shows the code. There’s a nested loop in this code. The
    outer one goes through each valid word, and the inner one goes through each letter
    for a given valid word. As soon as you see a letter in a word that’s not in your
    tiles, you can stop looking at this word and go on to the next one. Otherwise,
    keep looking. The variable `tiles_left` stores the tiles you have left after checking
    whether a letter from a valid word is in your tiles. Every time you find that
    a letter is in your tiles, you get its position and make a new `tiles_left` with
    all the remaining letters. The final step is to check whether you made a full,
    valid word with your tiles by using up all the letters. If so, add the word.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出代码。这段代码中有一个嵌套循环。外层循环遍历每个有效单词，内层循环遍历给定有效单词的每个字母。一旦你看到单词中有一个不在你的瓷砖中的字母，你就可以停止查看这个单词，转到下一个单词。否则，继续查找。变量
    `tiles_left` 存储检查有效单词中的字母是否在你瓷砖中后你剩下的瓷砖。每次你发现一个字母在你瓷砖中，你就得到它的位置，并使用所有剩余的字母创建一个新的
    `tiles_left`。最后一步是检查你是否用完了所有字母制作了一个完整的、有效的单词。如果是这样，就添加这个单词。
- en: Listing 19.3\. Game code to check whether valid words can be made with tiles
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.3\. 检查是否可以用瓷砖制作有效单词的游戏代码
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Looks at every valid word**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 查看每个有效单词'
- en: '***2* tiles_left deals with duplicate tiles**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** tiles_left 处理重复的瓷砖'
- en: '***3* Looks at every letter in a valid word**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 查看有效单词中的每个字母'
- en: '***4* Stops looking if letter not in tiles_left**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 如果字母不在 tiles_left 中则停止查找'
- en: '***5* Finds position of letter in tiles_left**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 在 tiles_left 中查找字母的位置'
- en: '***6* Removes letter and makes a new tiles_left**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 移除字母并创建新的 tiles_left'
- en: '***7* Checks whether found entire word**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 检查是否找到了整个单词'
- en: '***8* Adds word to found_words**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 将单词添加到 found_words'
- en: At the end, you print all the words you can make. But you can tweak the results
    you get to choose words that are only a certain length, or only words that are
    the longest, or words that contain a certain letter (whatever you prefer).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你打印出你可以制作的所有单词。但你可以调整结果，以选择特定长度的单词，或者只选择最长的单词，或者包含特定字母的单词（无论你更喜欢哪种）。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, my objective was to show you how to think about approaching
    complicated problems and to walk you through a real-life problem for which you
    could use programming to write a custom program for your situation. Understanding
    a problem before coding can be a major confidence boost. You can use pictures
    or simple input values and expected outputs to help refine your understanding
    of the problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是向你展示如何思考解决复杂问题的方法，并带你通过一个你可以使用编程来为你的情况编写自定义程序的现实生活问题。在编码之前理解问题可以是一个巨大的信心提升。你可以使用图片或简单的输入值和预期输出，以帮助你细化对问题的理解。
- en: When you understand the problem, you should write a few pieces of pseudocode.
    You can use a mixture of English and code to see whether you’ll have to break
    up the problem further before starting to code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你理解了问题后，你应该编写一些伪代码。你可以混合使用英语和代码来查看在开始编码之前是否需要进一步分解问题。
- en: The final step is to look at the visual representation and the abstractions
    you came up with and use these as natural divisions in your code. These smaller
    pieces are easier to handle when coding, and they also provide natural points
    for taking a break from coding to test and debug the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是查看你提出的视觉表示和抽象，并将这些作为代码中的自然划分。这些较小的部分在编码时更容易处理，并且它们也提供了在编码时休息、测试和调试代码的自然点。
- en: 'Here are the key takeaways:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关键要点：
- en: Understand the problem being asked by drawing a couple of relevant pictures.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过绘制一些相关的图片来理解被提出的问题。
- en: Understand the problem being asked by coming up with a few simple test cases
    that you can write out.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提出一些简单的测试用例来理解被提出的问题。
- en: Generalize parts of the problem to come up with formulas or the logic for accomplishing
    each part.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题的部分进行泛化，以得出公式或完成每个部分的逻辑。
- en: Pseudocode can be useful, especially for writing algorithm logic that includes
    conditionals or looping constructs.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪代码可能很有用，特别是对于编写包含条件或循环结构的算法逻辑。
- en: Think in terms of code pieces and ask whether the code has any natural divisions—for
    example, initializing variables, implementing one or more algorithms, and cleanup
    code.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从代码片段的角度思考，并问自己代码是否有任何自然的划分——例如，初始化变量、实现一个或多个算法和清理代码。
