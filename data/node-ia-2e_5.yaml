- en: Appendix C. Connect’s officially supported middleware
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录C. Connect官方支持的中间件
- en: Connect is a minimal wrapper around Node’s built-in HTTP client and server modules.
    The Connect authors and contributors have also produced officially supported middleware
    components that implement low-level features used by most web frameworks, including
    things like cookie handling, body parsing, sessions, basic auth, and cross-site
    request forgery (CSRF). This appendix demonstrates all of the officially supported
    modules so you can use them to build lightweight web applications without a larger
    framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Connect是Node内置的HTTP客户端和服务器模块的最小包装器。Connect的作者和贡献者还生产了官方支持的中间件组件，这些组件实现了大多数Web框架使用的低级功能，包括像cookie处理、请求体解析、会话、基本认证和跨站请求伪造（CSRF）等。本附录演示了所有官方支持的模块，以便您可以使用它们构建无需大型框架的轻量级Web应用程序。
- en: C.1\. Parsing cookies, request bodies, and query strings
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1\. 解析cookies、请求体和查询字符串
- en: 'Node’s core doesn’t provide modules for higher-level web application concepts
    such as parsing cookies, buffering request bodies, or parsing complex query strings,
    so Connect modules implement these features. This section covers four modules
    that parse request data:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node的核心不提供解析cookies、缓冲请求体或解析复杂查询字符串等高级Web应用程序概念的模块，因此Connect模块实现了这些功能。本节涵盖了四个解析请求数据的模块：
- en: '***cookie-parser—*** Parses cookies from web browsers into `req.cookies`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***cookie-parser—*** 将来自Web浏览器的cookies解析到`req.cookies`'
- en: '***qs—*** Parses the request URL query string into req.query'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***qs—*** 将请求URL查询字符串解析到`req.query`'
- en: '***body-parser—*** Consumes and parses the request body into `req.body`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***body-parser—*** 消耗并解析请求体到`req.body`'
- en: The first module we’ll look at is cookie-parser. This makes it easy to retrieve
    data stored by a website visitor’s browser so you can read things such as authorization
    status, website settings, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个模块是cookie-parser。这个模块使得检索网站访问者浏览器存储的数据变得容易，这样您可以读取诸如授权状态、网站设置等内容。
- en: 'C.1.1\. cookie-parser: parse HTTP cookies'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.1\. cookie-parser：解析HTTP cookies
- en: The cookie-parser module supports regular cookies, signed cookies, and special
    JSON cookies ([www.npmjs.com/package/cookie-parser](http://www.npmjs.com/package/cookie-parser)).
    By default, regular unsigned cookies are used, populating the `req.cookies` object.
    If you want signed cookie support, which helps prevent cookies from being tampered
    with, you’ll want to pass a secret string when creating the `cookie-parser` instance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookie-parser`模块支持常规cookies、签名cookies和特殊的JSON cookies ([www.npmjs.com/package/cookie-parser](http://www.npmjs.com/package/cookie-parser))。默认情况下，使用常规未签名的cookies，填充`req.cookies`对象。如果您想支持签名cookies，这有助于防止cookies被篡改，您需要在创建`cookie-parser`实例时传递一个密钥字符串。'
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Setting cookies on the server side
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在服务器端设置cookies
- en: The `cookie-parser` module doesn’t provide any helpers for setting outgoing
    cookies. For this, you should use the `res.setHeader()` function with `Set-Cookie`
    as the header name. Connect patches Node’s default `res.setHeader()` function
    to special-case the `Set-Cookie` headers so that it just works, as you’d expect
    it to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookie-parser`模块不提供设置输出cookies的任何辅助函数。为此，您应使用`res.setHeader()`函数，并将`Set-Cookie`作为头名称。将Node的默认`res.setHeader()`函数与特殊处理的`Set-Cookie`头连接起来，以便它按预期工作。'
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Regular cookies
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常规cookies
- en: To read cookies, you need to load the module, add it to the middleware stack,
    and then read the cookies in a request. The following listing illustrates each
    of these steps.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取cookies，您需要加载模块，将其添加到中间件堆栈中，然后在请求中读取cookies。以下列表说明了这些步骤。
- en: Listing C.1\. Reading cookies sent in a request
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.1\. 读取请求中发送的cookies
- en: '![](Images/clis01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis01_alt.jpg)'
- en: This example loads the middleware component ![](Images/circ1.jpg). Remember
    that you need to install the middleware with `npm install cookie-parser` for this
    to work. Next it adds an instance of the cookie parser to the middleware stack
    for this application ![](Images/circ2.jpg). The final step is to send back the
    cookies to the browser as a string ![](Images/circ3.jpg), so you can see it working.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例加载中间件组件 ![](Images/circ1.jpg)。请记住，您需要使用`npm install cookie-parser`安装中间件才能使其工作。接下来，它将cookie解析器的一个实例添加到该应用程序的中间件堆栈中
    ![](Images/circ2.jpg)。最后一步是将cookies作为字符串发送回浏览器 ![](Images/circ3.jpg)，以便您可以查看其工作情况。
- en: 'If you run this example, you’ll need to set cookies with the request. If you
    go to http://localhost:3000 in a browser, you probably won’t see much; it should
    return an empty object (`{}`). You can use cURL to set a cookie like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，你需要在请求中设置cookies。如果你在浏览器中访问http://localhost:3000，你可能不会看到太多；它应该返回一个空对象（`{}`）。你可以使用cURL设置一个cookie，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Signed cookies
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 已签名的cookies
- en: Signed cookies are better suited for sensitive data, as the integrity of the
    cookie data can be verified, helping to prevent man-in-the-middle attacks. Signed
    cookies are placed in the `req.signedCookies` object when valid. The reasoning
    behind having two separate objects is that it shows the developer’s intention.
    If you were to place both signed and unsigned cookies in the same object, a regular
    cookie could be crafted to contain data to mimic a signed cookie.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 已签名的cookies更适合敏感数据，因为可以验证cookie数据的完整性，有助于防止中间人攻击。当有效时，已签名的cookies将放在`req.signedCookies`对象中。有两个单独的对象背后的原因是它显示了开发者的意图。如果你将已签名和未签名的cookies放在同一个对象中，可以制作一个常规cookie来包含模仿已签名cookie的数据。
- en: A signed cookie looks something like `s:tobi.DDm3AcVxE9oneYnbmpqxoy[...],`^([[1](#app03fn01)])
    where the content to the left of the period (`.`) is the cookie’s value, and the
    content to the right is the secret hash generated on the server with SHA-256 HMAC
    (hash-based message authentication code). When Connect attempts to unsign the
    cookie, it will fail if either the value or HMAC has been altered.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已签名的cookie看起来像这样`s:tobi.DDm3AcVxE9oneYnbmpqxoy[...]`^([[1](#app03fn01)]),其中点(`.`)左侧的内容是cookie的值，右侧的内容是在服务器上使用SHA-256
    HMAC（基于哈希的消息认证码）生成的秘密哈希。当Connect尝试取消签名cookie时，如果值或HMAC被更改，它将失败。
- en: ¹
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The signed values have been shortened.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 已签名的值已被缩短。
- en: 'Suppose, for example, you set a signed cookie with a key of `name` and a value
    of `luna`. `cookieParser` would encode the cookie to `s:luna.PQLM0wNvqOQEObZX[...]`.
    The hash portion is checked on each request, and when the cookie is sent intact,
    it will be available as `req.signedCookies.name`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你设置了一个带有`name`键和`luna`值的已签名cookie。`cookieParser`将cookie编码为`s:luna.PQLM0wNvqOQEObZX[...]`。哈希部分在每个请求上都会进行检查，当cookie完整发送时，它将作为`req.signedCookies.name`可用：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the cookie’s value were to change, as shown in the next `curl` command,
    the `name` cookie would be available as `req.cookies.name` because it wasn’t valid.
    It might still be of use for debugging or application-specific purposes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果cookie的值发生变化，如下一个`curl`命令所示，`name`cookie将作为`req.cookies.name`可用，因为它不是有效的。它可能仍然用于调试或特定于应用程序的目的：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first argument to `cookieParser` is the secret to be used for signing cookies.
    In the following listing, the secret is *tobi is a cool ferret*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookieParser`的第一个参数是用于签名cookies的秘密。在下面的列表中，秘密是*tobi is a cool ferret*。'
- en: Listing C.2\. Parsing signed cookies
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.2\. 解析已签名的cookies
- en: '![](Images/clis02_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis02_alt.jpg)'
- en: In this example, the signed cookies are parsed automatically because the `secret`
    argument was passed to the `cookieParser` middleware component ![](Images/circ1.jpg).
    The values can be accessed on the `request` object ![](Images/circ2.jpg). The
    cookie-parser module also makes the cookie parsing functionality available through
    the `signedCookie` and `signedCookies` methods.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于将`secret`参数传递给了`cookieParser`中间件组件，所以已签名的cookies被自动解析![Images/circ1.jpg]。值可以在`request`对象上访问![Images/circ2.jpg]。cookie-parser模块还通过`signedCookie`和`signedCookies`方法提供了cookie解析功能。
- en: Before moving on, let’s look at how to use this example. As with [listing C.1](#app03ex01),
    you can use `curl` with the `-H` option to send a cookie. But for it to be considered
    a signed cookie, it needs to be encoded in a certain way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看如何使用这个示例。与[列表C.1](#app03ex01)一样，你可以使用带有`-H`选项的`curl`发送一个cookie。但是，为了使其被视为已签名的cookie，它需要以某种方式进行编码。
- en: 'Node’s crypto module is used to unsign cookies in the `signedCookie` method.
    If you want to sign a cookie to test [listing C.2](#app03ex02), you need to install
    `cookie-signature` and then sign a string with the same secret:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Node的crypto模块用于在`signedCookie`方法中取消签名cookies。如果你想测试[列表C.2](#app03ex02)并签名一个cookie，你需要安装`cookie-signature`，然后使用相同的秘密签名一个字符串：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now if the signature or message were modified, the server would be able to tell.
    In addition to signed cookies, this module supports JSON-encoded cookies. The
    next section shows how these work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果签名或消息被修改，服务器将能够检测到。除了已签名的cookies，此模块还支持JSON编码的cookies。下一节将展示它们是如何工作的。
- en: JSON cookies
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JSON cookies
- en: The special JSON cookie is prefixed with `j:`, which informs Connect that it’s
    intended to be serialized JSON. JSON cookies can be either signed or unsigned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的 JSON Cookie 以 `j:` 为前缀，这通知 Connect 它打算被序列化为 JSON。JSON Cookie 可以是已签名的或未签名的。
- en: 'Frameworks such as Express can use this functionality to provide developers
    with a more intuitive cookie interface, instead of requiring them to manually
    serialize and parse JSON cookie values. Here’s an example of how Connect parses
    JSON cookies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 Express 这样的框架可以使用此功能为开发者提供更直观的 Cookie 接口，而不是要求他们手动序列化和解析 JSON Cookie 值。以下是一个
    Connect 解析 JSON Cookie 的示例：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As mentioned, JSON cookies can also be signed, as illustrated in the following
    request:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JSON Cookie 也可以被签名，如下面的请求所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting outgoing cookies
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置输出 Cookie
- en: As noted earlier, the cookie-parser module doesn’t provide any functionality
    for writing outgoing headers to the HTTP client via the `Set-Cookie` header. Connect,
    however, provides explicit support for multiple `Set-Cookie` headers via the `res.setHeader()`
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，cookie-parser 模块不提供通过 `Set-Cookie` 头部将输出头部写入 HTTP 客户端的任何功能。但是，Connect 通过
    `res.setHeader()` 函数提供了对多个 `Set-Cookie` 头部的显式支持。
- en: 'Say you want to set a cookie named `foo` with the string value `bar`. Connect
    enables you to do this in one line of code by calling `res.setHeader()`. You can
    also set the various options of a cookie, such as its expiration date, as shown
    in the second `setHeader()` call here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想设置一个名为 `foo` 的 Cookie，其字符串值为 `bar`。Connect 允许您通过调用 `res.setHeader()` 在一行代码中完成此操作。您还可以设置
    Cookie 的各种选项，例如其过期日期，如第二个 `setHeader()` 调用所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you check out the headers that this server sends back to the HTTP request
    by using the `--head` flag of `curl`, you can see the `Set-Cookie` headers set
    as you would expect:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `curl` 的 `--head` 标志检查服务器发送回 HTTP 请求的头部，您可以看到 `Set-Cookie` 头部被设置为预期的那样：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s all there is to sending cookies with your HTTP response. You can store
    any kind of text data in cookies, but it has become usual to store a single session
    cookie on the client side so that you can have full user state on the server.
    This session technique is encapsulated in the express-session module, which you’ll
    learn about later in this appendix.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 HTTP 响应发送 Cookie 的全部内容。您可以在 Cookie 中存储任何类型的文本数据，但通常在客户端存储单个会话 Cookie，以便您可以在服务器上拥有完整的用户状态。这种会话技术封装在
    express-session 模块中，您将在本附录的后面了解它。
- en: Now that you can handle cookies, you’re probably eager to handle the other usual
    methods for accepting user input. The next two sections cover parsing query strings
    and request bodies, and you’ll discover that even though Connect is relatively
    low-level, you can still get the same features as more complicated web frameworks
    without writing lots of code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以处理 Cookie，您可能渴望处理其他接受用户输入的常用方法。接下来的两个部分将涵盖解析查询字符串和请求体，您会发现尽管 Connect
    相对底层，但您仍然可以像更复杂的 Web 框架一样获得相同的功能，而无需编写大量代码。
- en: C.1.2\. Parsing query strings
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.2\. 解析查询字符串
- en: 'One method for accepting input is to use `GET` parameters. You place a question
    mark after a URL, with a list of arguments separated by ampersands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接受输入的一种方法是通过使用 `GET` 参数。您在 URL 后面放置一个问号，后面跟着由与符号分隔的参数列表：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This type of URL can be presented to your application by a form that’s set to
    use the `GET` method, or by anchor elements within your application’s templates.
    You’ve probably seen this used for pagination.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此类 URL 可以通过设置为使用 `GET` 方法的表单或通过应用程序模板中的锚点元素呈现给您的应用程序。您可能已经看到它被用于分页。
- en: 'The request object that’s passed to each middleware component in Connect applications
    includes a `url` property, but what you want is the last part of the URL: just
    the portion after the question mark. Node comes with a URL-parsing module, so
    you could technically use `url.parse` to get the query string. But Connect also
    has to parse the URL, so it sets an internal property with a parsed version.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Connect 应用程序中传递给每个中间件组件的请求对象包括一个 `url` 属性，但您想要的是 URL 的最后一部分：即问号之后的部分。Node
    内置了 URL 解析模块，因此您可以使用 `url.parse` 来获取查询字符串。但是 Connect 也需要解析 URL，因此它设置了一个包含解析版本的内部属性。
- en: The recommended module for parsing query strings is qs ([www.npmjs.com/package/qs](http://www.npmjs.com/package/qs)).
    This module isn’t officially supported by Connect, and alternatives are available
    through npm. To use qs and similar modules, you need to call its `.parse()` method
    from your own middleware component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐用于解析查询字符串的模块是 qs ([www.npmjs.com/package/qs](http://www.npmjs.com/package/qs))。此模块不是
    Connect 的官方支持模块，并且通过 npm 提供了替代方案。要使用 qs 和类似模块，您需要从自己的中间件组件中调用其 `.parse()` 方法。
- en: Basic usage
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: The following listing uses the `qs.parse` method to create an object that’s
    stored on the `req.query` property for subsequent middleware components to use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表使用 `qs.parse` 方法创建一个对象，该对象存储在 `req.query` 属性上，以便后续中间件组件使用。
- en: Listing C.3\. Parsing query strings
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.3\. 解析查询字符串
- en: '![](Images/clis03_alt.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/clis03_alt.jpg)'
- en: This example uses a custom middleware component to obtain the parsed URL, parse
    it using `qs.parse` ![](Images/circ1.jpg), and then display it in a subsequent
    component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用自定义中间件组件来获取解析后的 URL，使用 `qs.parse` ![图片](Images/circ1.jpg) 进行解析，然后在后续组件中显示它。
- en: 'Suppose you’re designing a music library app. You could offer a search engine
    and use the query string to build up the search parameters, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在设计一个音乐库应用程序。您可以提供一个搜索引擎，并使用查询字符串来构建搜索参数，如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example query produces a `res.query` object like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例查询生成一个 `res.query` 对象，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `qs.parse` method supports nested arrays, so complex query strings such
    as `?images[]=foo.png&images[]=bar.png` produce objects like this one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`qs.parse` 方法支持嵌套数组，因此复杂的查询字符串，如 `?images[]=foo.png&images[]=bar.png`，会产生如下对象：'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When no query-string parameters are given in the HTTP request, such as `/songSearch`,
    `req.query` will default to an empty object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTTP请求中没有提供查询字符串参数时，例如 `/songSearch`，`req.query` 将默认为空对象：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Higher-level frameworks such as Express tend to have query-string parsing built
    in, because it’s such a common requirement for web development. Another common
    feature of web frameworks is parsing request bodies, so you can accept data posted
    in forms. The next section explains how to parse request bodies, handle forms
    and file uploads, and validate these requests to ensure they’re safe.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 高级框架，如 Express，通常内置查询字符串解析，因为这对于Web开发来说是一个常见的需求。Web框架的另一个常见功能是解析请求主体，这样您就可以接受通过表单提交的数据。下一节将解释如何解析请求主体、处理表单和文件上传，并验证这些请求以确保它们是安全的。
- en: 'C.1.3\. body-parser: parse request bodies'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.3\. body-parser：解析请求主体
- en: 'Most web applications have to accept and process user input. This can be from
    forms or even other programs in the case of RESTful APIs. HTTP requests and responses
    are collectively known as *HTTP messages*. The format of a message consists of
    a list of headers and then a message body. In Node web applications, the body
    is usually a stream, and it can be encoded in various ways: a POST from a form
    will usually be `application/x-www-form-urlencoded`, and a RESTful JSON request
    could be `application/json`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序都必须接受和处理用户输入。这可能来自表单，甚至在RESTful API的情况下来自其他程序。HTTP请求和响应统称为 *HTTP 消息*。消息的格式由一系列头和消息体组成。在Node
    Web应用程序中，体通常是一个流，并且可以用各种方式编码：来自表单的 POST 请求通常为 `application/x-www-form-urlencoded`，而RESTful
    JSON请求可能是 `application/json`。
- en: 'That means your Connect applications need middleware that’s capable of decoding
    streams of form-encoded data, JSON, or even compressed data using gzip or deflate.
    In this section, we’ll show how to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您的 Connect 应用程序需要能够解码表单编码数据、JSON或甚至使用 gzip 或 deflate 压缩数据的中间件。在本节中，我们将展示如何执行以下操作：
- en: Handle input from forms
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单输入
- en: Parse JSON requests
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 JSON 请求
- en: Validate bodies based on content and size
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据内容和大小验证主体
- en: Accept file uploads
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受文件上传
- en: Forms
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表单
- en: Suppose you want to accept registration information for your application though
    a form. All you have to do is add the body-parser component ([www.npmjs.com/package/body-parser](http://www.npmjs.com/package/body-parser))
    before any other middleware that will access the `req.body` object. [Figure C.1](#app03fig01)
    shows how this works.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想通过表单接受您应用程序的注册信息。您只需在将访问 `req.body` 对象的任何其他中间件之前添加 body-parser 组件 ([www.npmjs.com/package/body-parser](http://www.npmjs.com/package/body-parser))。![图
    C.1](#app03fig01) 展示了这是如何工作的。
- en: Figure C.1\. How a form is processed by body-parser
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 C.1\. body-parser 如何处理表单
- en: '![](Images/cfig01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/cfig01.jpg)'
- en: The following listing shows how to use the body-parser module with HTTP `POST`s
    from forms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用 body-parser 模块处理来自表单的 HTTP `POST` 请求。
- en: Listing C.4\. Parsing form requests
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.4\. 解析表单请求
- en: '![](Images/clis04_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Images/clis04_alt.jpg]'
- en: 'To use this example, you need to install the body-parser module,^([[2](#app03fn02)])
    and then you need a way to make a simple HTTP request with a URL-encoded body.
    The easiest way is to use `curl` with the `-d` option:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用此示例，您需要安装body-parser模块^([[2](#app03fn02)]), 然后您需要一种方法来使用URL编码的body发送简单的HTTP请求。最简单的方法是使用带有`-d`选项的`curl`:'
- en: ²
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We used version 1.11.0.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用了版本1.11.0。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should cause the server to display `You sent: {"name":"tobi"}`. To make
    this work, the body parser is added to the middleware stack ![](Images/circ1.jpg),
    and then the parsed body in `req.body` is converted to a string ![](Images/circ2.jpg)
    so it can be displayed more easily. The `urlencoded` body parser accepts a UTF-8
    encoded string, and it’ll automatically decompress request bodies encoded with
    gzip or deflate.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '这应该会导致服务器显示`您发送了: {"name":"tobi"}`。为了使这生效，body解析器被添加到中间件堆栈 ![Images/circ1.jpg]，然后解析后的body在`req.body`中转换为字符串
    ![Images/circ2.jpg]，以便更容易显示。`urlencoded`请求体解析器接受UTF-8编码的字符串，并且它会自动解压缩使用gzip或deflate编码的请求体。'
- en: 'In this example, the options passed to the body parser are `extended: false`.
    When set to `true`, this option causes the body parser to use another library
    to parse the query-string format. This allows you to use more complex, nested,
    JSON-like objects in forms. The other options are presented in the next section,
    where you’ll look at validating requests.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '在此示例中，传递给body解析器的选项是`extended: false`。当设置为`true`时，此选项会导致body解析器使用另一个库来解析查询字符串格式。这允许您在表单中使用更复杂、嵌套、类似JSON的对象。其他选项将在下一节中介绍，您将了解如何验证请求。'
- en: Validating requests
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证请求
- en: 'Each parser that comes with the body-parser module supports two options for
    validating requests: `limit` and `verify`. The `limit` option allows you to block
    requests over a certain size: the default is 100 KB, so you can increase it if
    you want to accept larger forms. If you’re making something like a content management
    system or blog, where people can potentially enter valid but lengthy fields, this
    would be useful.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: body-parser模块附带的所有解析器都支持两种验证请求的选项：`limit`和`verify`。`limit`选项允许您阻止超过一定大小的请求：默认为100
    KB，因此如果您想接受更大的表单，可以将其增加。如果您正在制作类似内容管理系统或博客的东西，人们可能会输入有效但较长的字段，这将很有用。
- en: The `verify` option allows you to use a function to validate requests. It’s
    useful if you want to get the raw request body and check that it’s in the correct
    format. For example, you could use this to ensure that API methods that accept
    XML always start with the correct XML header. The following listing shows how
    to use both of these options.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify`选项允许您使用一个函数来验证请求。如果您想获取原始请求体并检查其格式是否正确，这很有用。例如，您可以使用此选项确保接受XML的API方法始终以正确的XML头开始。以下列表显示了如何使用这两个选项。'
- en: Listing C.5\. Validating form requests
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.5\. 验证表单请求
- en: '![](Images/clis05_alt.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Images/clis05_alt.jpg]'
- en: Notice that an `Error` object should be thrown by using the `throw` keyword
    ![](Images/circ1.jpg). The body-parser module is set up to catch these before
    parsing the request, so it’ll pass the error back to Connect. After a request
    validation function has been created, you need to pass it to the body-parser middleware
    component by using the `verify` option ![](Images/circ3.jpg).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应该使用`throw`关键字抛出一个`Error`对象 ![Images/circ1.jpg]。body-parser模块在解析请求之前会捕获这些错误，因此它会将错误回传给Connect。在创建了一个请求验证函数之后，您需要通过使用`verify`选项将此函数传递给body-parser中间件组件
    ![Images/circ3.jpg]。
- en: The body size limit is in bytes; here it’s quite small, at 10 bytes ![](Images/circ2.jpg).
    You can easily see what happens when the request is too large by using the previous
    `curl` command with a larger name value. Also, if you want to see what happens
    when the validation error is thrown, use `curl` to send another value instead
    of `name`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体大小限制是以字节为单位的；这里相当小，只有10字节 ![Images/circ2.jpg]。您可以通过使用之前的`curl`命令并使用更大的名称值来轻松地看到请求太大时会发生什么。另外，如果您想看到当验证错误被抛出时会发生什么，请使用`curl`发送另一个值而不是`name`。
- en: Why is limit needed?
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么需要限制？
- en: 'Let’s take a look at how a malicious user can render a vulnerable server useless.
    First, create the following small Connect application named server.js, which does
    nothing other than parse request bodies by using the `bodyParser()` middleware
    component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个恶意用户如何使一个易受攻击的服务器变得无用。首先，创建以下名为server.js的小型Connect应用程序，它除了使用`bodyParser()`中间件组件解析请求体之外，什么都不做：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now create a file named dos.js, as shown in the following listing. You can
    see how a malicious user could use Node’s HTTP client to attack the preceding
    Connect application, simply by writing several megabytes of JSON data:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为 dos.js 的文件，如下所示。你可以看到恶意用户如何仅通过写入几个兆字节的 JSON 数据来利用 Node 的 HTTP 客户端攻击前面的
    Connect 应用程序：
- en: '![](Images/p0320_01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0320_01.jpg)'
- en: 'Fire up the server and run the attack script:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器并运行攻击脚本：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you watch the `node` process in `top(1)`, you should see that it starts to
    use more CPU and RAM as dos.js runs. This is bad, but thankfully it’s exactly
    why all the body parsing middleware components accept a `limit` option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `top(1)` 观察 `node` 进程，你应该会看到随着 dos.js 的运行，它开始使用更多的 CPU 和 RAM。这是不好的，但幸运的是，这正是所有
    body 解析中间件组件接受 `limit` 选项的原因。
- en: Parsing JSON data
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析 JSON 数据
- en: If you’re making web applications with Node, you’re going to be dealing with
    a lot of JSON. The body-parser module’s JSON parser has a few handy options that
    you’ve seen in the previous examples. The following listing shows how parsing
    JSON and using the resulting values works.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Node 制作 Web 应用程序，你将需要处理大量的 JSON。body-parser 模块的 JSON 解析器在之前的例子中已经展示了一些实用的选项。以下列表显示了如何解析
    JSON 并使用结果值。
- en: Listing C.6\. Validating form requests
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.6\. 验证表单请求
- en: '![](Images/clis06_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis06_alt.jpg)'
- en: After the JSON parser has been loaded ![](Images/circ1.jpg), your request handlers
    can treat the `req.body` value as a JavaScript object rather than a string. This
    example assumes that a JSON object with a `name` property has been sent, and it’ll
    send the value back in the response ![](Images/circ2.jpg). That means your request
    has to have a `Content-Type` of `application/json`, and you need to send valid
    JSON. By default, the `json` middleware component uses strict parsing, but you
    can relax encoding requirements by setting this to `false`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 解析器加载后 ![](Images/circ1.jpg)，你的请求处理器可以将 `req.body` 值作为 JavaScript 对象而不是字符串来处理。此示例假设已发送一个具有
    `name` 属性的 JSON 对象，并且它将在响应中发送该值 ![](Images/circ2.jpg)。这意味着你的请求必须具有 `Content-Type`
    为 `application/json`，并且你需要发送有效的 JSON。默认情况下，`json` 中间件组件使用严格的解析，但你可以通过将其设置为 `false`
    来放宽编码要求。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting the JSON Content-Type option**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置 JSON Content-Type 选项**'
- en: One option that you need to be aware of is `type`. This allows you to change
    the `Content-Type` that’ll be parsed as JSON. In the following example, we use
    the default, which is `application/json`. But in some cases your application might
    have to interact with HTTP clients that don’t send this header, so be warned.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的一个选项是 `type`。这允许你更改将被解析为 JSON 的 `Content-Type`。在下面的例子中，我们使用默认值，即 `application/json`。但在某些情况下，你的应用程序可能需要与不发送此头信息的
    HTTP 客户端交互，所以请小心。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following `curl` request could be used to submit data to your application,
    and will send a JSON object with the `username` property set to `tobi`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `curl` 请求可以用来向你的应用程序提交数据，并将包含 `username` 属性设置为 `tobi` 的 JSON 对象发送：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Parsing multipart <form> data
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析 multipart <form> 数据
- en: The body-parser module doesn’t handle multipart request bodies. You need to
    handle multipart messages to support file uploads, so anything such as uploading
    a user’s avatar needs multipart support.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: body-parser 模块不处理 multipart 请求体。你需要处理 multipart 消息以支持文件上传，因此任何如上传用户头像这样的操作都需要
    multipart 支持。
- en: 'There’s no officially supported multipart parser for Connect, but some popular
    ones are well maintained. Two examples are busboy ([www.npmjs.com/package/busboy](http://www.npmjs.com/package/busboy))
    and multiparty ([www.npmjs.com/package/multiparty](http://www.npmjs.com/package/multiparty)).
    Both of these modules have associated connect modules: connect-busboy and connect-multiparty.
    The reason for this is that the multipart parsers themselves are dependent on
    Node’s lower-level HTTP modules, so a wide range of frameworks can use them. They’re
    not specifically tied into Connect.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 没有官方支持的 multipart 解析器，但一些流行的解析器维护得很好。两个例子是 busboy ([www.npmjs.com/package/busboy](http://www.npmjs.com/package/busboy))
    和 multiparty ([www.npmjs.com/package/multiparty](http://www.npmjs.com/package/multiparty))。这两个模块都有相关的
    connect 模块：connect-busboy 和 connect-multiparty。之所以这样，是因为 multipart 解析器本身依赖于 Node
    的底层 HTTP 模块，因此它们可以被广泛的应用框架使用。它们并不是专门绑定到 Connect 的。
- en: The following listing is based on multiparty, and will print out the details
    of an uploaded file in the console.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表基于 multiparty，将在控制台打印出上传文件的详细信息。
- en: Listing C.7\. Handling uploaded files
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.7\. 处理上传的文件
- en: '![](Images/clis07_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis07_alt.jpg)'
- en: This short example adds the multiparty middleware component ![](Images/circ1.jpg)
    and then logs the received files ![](Images/circ2.jpg). The files will be uploaded
    to a temporary location, so you have to use the fs module to delete the files
    when your application is finished with them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的示例添加了multiparty中间件组件 ![](Images/circ1.jpg) 并记录接收到的文件 ![](Images/circ2.jpg)。文件将被上传到临时位置，所以当你应用程序完成使用这些文件时，你必须使用fs模块删除这些文件。
- en: 'To use this example, make sure you’ve installed connect-multiparty.^([[3](#app03fn03)])
    Then start the server and send it a file with `curl`’s `-F` option:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此示例，请确保你已经安装了connect-multiparty.^([[3](#app03fn03)]) 然后启动服务器，并使用`curl`的`-F`选项发送一个文件：
- en: ³
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We used version 1.2.5 to test this example.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用版本1.2.5来测试这个示例。
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The filename is placed after the `@` symbol, and it’s prefixed with a field
    name. The field name will be available in the `req.files` object, so you can distinguish
    between separate uploaded files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名放在`@`符号之后，并且它前面有一个字段名。字段名将在`req.files`对象中可用，因此你可以区分不同的上传文件。
- en: 'If you take a look at the output of the application, you’ll see something similar
    to the following example output. As you can see, `req.files.file.path` would be
    available to your application, and you could rename the file on disk, transfer
    the data to a worker for processing, upload to a content delivery network, or
    do anything else your app requires:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看应用程序的输出，你会看到类似于以下示例输出的内容。正如你所看到的，`req.files.file.path`将可用于你的应用程序，你可以重命名磁盘上的文件，将数据传输到工作进程进行处理，上传到内容分发网络，或者做任何你的应用程序需要的其他事情：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Although body-parser copes with compression, you may be wondering about compressing
    outgoing responses. Read on to learn about the compression middleware component
    that can reduce your bandwidth bills and make your web applications feel faster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然body-parser可以处理压缩，但你可能想知道如何压缩发出的响应。继续阅读，了解可以减少你的带宽账单并让你的Web应用感觉更快的压缩中间件组件。
- en: 'C.1.4\. compression: compressing outgoing responses'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.4\. 压缩：压缩发出的响应
- en: In the preceding section, you may have noticed that the body parsers are capable
    of decompressing requests that used gzip or deflate. Node comes with a core module
    for handling compression called zlib, and this is used to implement both compression
    and decompression methods. The compression middleware component ([www.npmjs.com/package/compression](http://www.npmjs.com/package/compression))
    can be used to compress outgoing responses, which means the data your server sends
    can be compressed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你可能已经注意到，体解析器可以解压缩使用gzip或deflate的请求。Node自带一个用于处理压缩的核心模块，名为zlib，它用于实现压缩和解压缩方法。压缩中间件组件([www.npmjs.com/package/compression](http://www.npmjs.com/package/compression))可以用于压缩发出的响应，这意味着你的服务器发送的数据可以被压缩。
- en: Google’s PageSpeed Insights tool recommends enabling gzip compression,^([[4](#app03fn04)])
    and if you look at requests made by your browser in the developer tools, you should
    see that many sites send gzipped responses. Compression adds CPU overhead, but
    because formats such as plain text and HTML compress well, it can improve your
    site’s performance and reduce bandwidth usage.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Google的PageSpeed Insights工具建议启用gzip压缩，^([[4](#app03fn04)]) 如果你查看开发工具中浏览器发出的请求，你应该看到许多网站发送了压缩的响应。压缩会增加CPU开销，但由于纯文本和HTML等格式压缩得很好，它可以提高你网站的性能并减少带宽使用。
- en: ⁴
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://developers.google.com/speed/docs/insights/EnableCompression](https://developers.google.com/speed/docs/insights/EnableCompression)
    for more information.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://developers.google.com/speed/docs/insights/EnableCompression](https://developers.google.com/speed/docs/insights/EnableCompression)。
- en: '|  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Deflate or gzip?**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deflate或gzip？**'
- en: Having two compression options can be confusing. You’re probably wondering which
    is best, and why two exist at all. Well, according to the standards (RFC 1950
    and RFC 2616), both use the same compression algorithm, but they differ in the
    way the header and checksum are handled.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个压缩选项可能会让人感到困惑。你可能想知道哪个最好，以及为什么会有两个。嗯，根据标准（RFC 1950 和 RFC 2616），它们都使用相同的压缩算法，但它们在处理头部和校验和的方式上有所不同。
- en: Unfortunately, some browsers don’t correctly handle deflate, so the general
    advice is to use gzip. In the case of body parsing, it’s best to be able to support
    both, but if you’re compressing your server’s output, use gzip to be on the safe
    side.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一些浏览器不能正确处理deflate，所以一般的建议是使用gzip。在解析体的情况下，最好能够支持两者，但如果你正在压缩服务器的输出，使用gzip以确保安全。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The compression module detects the accepted encodings from the `Accept-Encoding`
    header field. If this field isn’t present, the identity encoding is used, meaning
    the response is untouched. Otherwise, if the field contains `gzip`, `deflate`,
    or both, the response will be compressed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩模块会检测来自 `Accept-Encoding` 头字段的接受编码。如果该字段不存在，则使用身份编码，意味着响应不会被修改。否则，如果该字段包含
    `gzip`、`deflate` 或两者都包含，则响应将被压缩。
- en: Basic usage
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: You should generally add compression high in the Connect stack, because it wraps
    the `res.write()` and `res.end()` methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常应该在Connect堆栈中添加压缩，因为它封装了 `res.write()` 和 `res.end()` 方法。
- en: 'In the following example, the content will be compressed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，内容将被压缩：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To run this example, you need to install the compression module from npm. Then,
    start the server and try making a request with `curl` that sets `Accept-Encoding`
    to `gzip`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，你需要从npm安装压缩模块。然后，启动服务器并尝试使用设置 `Accept-Encoding` 为 `gzip` 的 `curl` 发送请求：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `-i` argument makes cURL show you the headers, so you should see the `Content-Encoding`
    set to `gzip`. The output should be garbled, because the compressed data won’t
    be standard characters. Try piping it through `gunzip` without the `-i` option
    to see the output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 参数使 cURL 显示头信息，因此你应该看到 `Content-Encoding` 设置为 `gzip`。输出应该是乱码的，因为压缩数据不会是标准字符。尝试不带
    `-i` 选项通过 `gunzip` 来管道化它以查看输出：'
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is powerful and relatively simple to set up, but you won’t always want
    to compress everything your server sends. To skip compression, you can use custom
    filter functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这功能强大且相对简单易设，但你并不总是想压缩服务器发送的所有内容。要跳过压缩，你可以使用自定义过滤器函数。
- en: Using a custom filter function
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用自定义过滤器函数
- en: 'By default, `compression` includes the MIME types `text/*`, `*/json`, and `*/java-script`
    in the default `filter` function to avoid compressing these data types:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`compression` 在默认的 `filter` 函数中包含 `text/*`、`*/json` 和 `*/java-script`
    MIME类型，以避免压缩这些数据类型：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To alter this behavior, you can pass a `filter` in the options object, as shown
    in the following snippet, which will compress only plain text:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这种行为，你可以在选项对象中传递一个 `filter`，如下面的代码片段所示，这将仅压缩纯文本：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Specifying compression and memory levels
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指定压缩和内存级别
- en: Node’s zlib bindings provide options for tweaking performance and compression
    characteristics, and they can also be passed to the `compression` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Node的zlib绑定提供了调整性能和压缩特性的选项，并且它们也可以传递给 `compression` 函数。
- en: 'In the following example, the compression `level` is set to `3` for less but
    faster compression, and `memLevel` is set to `8` for faster compression by using
    more memory. These values depend entirely on your application and the resources
    available to it. Consult Node’s zlib documentation for details:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，压缩 `level` 设置为 `3` 以实现更快的压缩但压缩效果较低，`memLevel` 设置为 `8` 以使用更多内存来实现更快的压缩。这些值完全取决于你的应用程序及其可用的资源。有关详细信息，请参阅Node的zlib文档：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s all there is to it. Next we’ll look at middleware that covers core web
    application needs, such as logging and sessions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。接下来，我们将探讨覆盖核心Web应用需求的中间件，例如日志记录和会话。
- en: C.2\. Implementing core web application functions
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2\. 实现核心Web应用功能
- en: Connect aims to implement and provide built-in middleware for the most common
    web application needs so that they don’t need to be reimplemented over and over
    by every developer. Core web application functions such as logging, sessions,
    and virtual hosting are all provided by Connect out of the box.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 旨在实现并提供内置中间件以满足最常见的Web应用需求，这样它们就不需要每个开发者反复重新实现。核心Web应用功能，如日志记录、会话和虚拟主机，都由Connect提供。
- en: 'In this section, you’ll learn about five useful middleware components that
    you’ll likely use in your applications:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解五个有用的中间件组件，你可能会在应用程序中使用它们：
- en: '***morgan—*** Provides flexible request logging'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***morgan—*** 提供灵活的请求日志'
- en: '***serve-favicon—*** Takes care of the /favicon.ico request without you having
    to think about it'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***serve-favicon—*** 处理 /favicon.ico 请求，无需你费心'
- en: '***method-override—*** Enables incapable clients to transparently overwrite
    `req.method`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***method-override—*** 允许无能力的客户端透明地覆盖 `req.method`'
- en: '***vhost—*** Sets up multiple websites on a single server (virtual hosting)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***vhost—*** 在单个服务器上设置多个网站（虚拟主机）'
- en: '***express-session—*** Manages session data'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***express-session—*** 管理会话数据'
- en: Up until now, you’ve created your own custom logging middleware, but the Connect
    maintainers provide a flexible solution named morgan, so let’s explore that first.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了您自己的自定义日志中间件，但 Connect 维护者提供了一个名为 Morgan 的灵活解决方案，因此让我们首先探索它。
- en: 'C.2.1\. morgan: log requests'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'C.2.1\. morgan: 记录请求'
- en: The morgan module ([www.npmjs.com/package/morgan](http://www.npmjs.com/package/morgan))
    is a flexible request-logging middleware component with customizable log formats.
    It also has options for buffering log output to decrease disk writes, and for
    specifying a log stream if you want to log to something other than the console,
    such as a file or socket.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 模块 ([www.npmjs.com/package/morgan](http://www.npmjs.com/package/morgan))
    是一个灵活的请求记录中间件组件，具有可定制的日志格式。它还具有缓冲日志输出以减少磁盘写入的选项，以及如果您想将日志记录到控制台以外的其他位置（如文件或套接字）时指定日志流。
- en: Basic usage
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: To use morgan in your own application, invoke it as a function to return a middleware
    function, as shown in the following listing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中使用 Morgan，请将其作为函数调用，以返回一个中间件函数，如下所示列表所示。
- en: Listing C.8\. Using the morgan module for logging
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.8\. 使用 Morgan 模块进行日志记录
- en: '![](Images/clis08_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis08_alt.jpg)'
- en: To use this example, you need to install the morgan module from npm.^([[5](#app03fn05)])
    It adds the module at the top of the middleware stack ![](Images/circ1.jpg) and
    then outputs a simple text response ![](Images/circ2.jpg). By using the `combined`
    logging format argument ![](Images/circ1.jpg), this Connect application will output
    the Apache log format. This is a flexible format that many command-line utilities
    can parse, so you can run your logs through log-processing applications that can
    generate useful statistics. If you try making requests from different clients,
    such as `curl`, `wget`, and a browser, you should see the user agent string in
    the logs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此示例，您需要从 npm 安装 Morgan 模块.^([[5](#app03fn05)]) 它将模块添加到中间件堆栈的顶部 ![](Images/circ1.jpg)
    并然后输出简单的文本响应 ![](Images/circ2.jpg)。通过使用 `combined` 记录格式参数 ![](Images/circ1.jpg)，此
    Connect 应用程序将输出 Apache 日志格式。这是一个灵活的格式，许多命令行工具都可以解析，因此您可以将日志通过日志处理应用程序运行，以生成有用的统计数据。如果您尝试从不同的客户端（如
    `curl`、`wget` 和浏览器）发出请求，您应该在日志中看到用户代理字符串。
- en: ⁵
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We used version 1.5.1.
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用了版本 1.5.1。
- en: 'The `combined` logging format is defined like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`combined` 记录格式定义如下：'
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each of the `:something` pieces are *tokens*, and in a log entry they’d contain
    real values from the HTTP request that’s being logged. For example, a simple `curl(1)`
    request would generate a log line similar to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `:something` 部分 *标记*，在日志条目中它们将包含正在记录的 HTTP 请求的实时值。例如，一个简单的 `curl(1)` 请求将生成一个类似于以下日志行的记录：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Customizing log formats
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自定义日志格式
- en: 'You can also create your own log formats. To do this, pass a custom string
    of tokens. For example, the following format would output something like `GET
    /users 15 ms`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的日志格式。为此，传递一个自定义的标记字符串。例如，以下格式将输出类似 `GET /users 15 ms` 的内容：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By default, the following tokens are available for use (note that the header
    names aren’t case-sensitive):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，以下标记可用于使用（注意，头部名称不区分大小写）：
- en: '`:req[header]` example: `:req[Accept]`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:req[header]` 示例：`:req[Accept]`'
- en: '`:res[header]` example: `:res[Content-Length]`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:res[header]` 示例：`:res[Content-Length]`'
- en: '`:http-version`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:http-version`'
- en: '`:response-time`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:response-time`'
- en: '`:remote-addr`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:remote-addr`'
- en: '`:date`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:date`'
- en: '`:method`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:method`'
- en: '`:url`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:url`'
- en: '`:referrer`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:referrer`'
- en: '`:user-agent`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:user-agent`'
- en: '`:status`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:status`'
- en: 'You can even define custom tokens. All you have to do is provide a token name
    and callback function to the `connect.logger.token` function. For example, say
    you want to log each request’s query string. You might define it like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以定义自定义标记。您只需向 `connect.logger.token` 函数提供一个标记名称和回调函数即可。例如，假设您想记录每个请求的查询字符串。您可能定义如下：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The morgan module comes with predefined formats other than the default one,
    such as `short` and `tiny`. Another predefined format is `dev`, which produces
    concise output for development, for situations when you’re usually the only user
    on the site and you don’t care about the details of the HTTP requests. This format
    also color-codes the response status codes by type: responses with a status code
    in the 200s are green, 300s are blue, 400s are yellow, and 500s are red. This
    color scheme makes it great for development.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 模块除了默认格式外，还提供了预定义的格式，例如 `short` 和 `tiny`。另一个预定义的格式是 `dev`，它为开发环境生成简洁的输出，适用于你通常是网站上的唯一用户且不关心
    HTTP 请求的详细信息的情况。此格式还会根据类型对响应状态码进行颜色编码：状态码在 200 范围内的响应为绿色，300 范围内的为蓝色，400 范围内的为黄色，500
    范围内的为红色。这种颜色方案非常适合开发使用。
- en: 'To use a predefined format, you provide the name to `logger()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预定义的格式，你需要在 `logger()` 中提供名称：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that you know how to format the logger’s output, let’s look at the options
    you can provide to it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何格式化日志输出，让我们看看你可以提供给它的选项。
- en: 'Logger options: stream, immediate, and buffer'
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 日志选项：stream，immediate 和 buffer
- en: As mentioned previously, you can use options to tweak how morgan behaves.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以使用选项来调整 morgan 的行为。
- en: One such option is `stream`, which allows you to pass a Node `Stream` instance
    that the logger will write to instead of stdout. This allows you to direct the
    logger output to its own log file, independent of your server’s own output, by
    using a `Stream` instance created from `fs.createWriteStream`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个选项是 `stream`，它允许你传递一个 Node `Stream` 实例，日志将写入该实例而不是 stdout。这允许你通过使用从 `fs.createWriteStream`
    创建的 `Stream` 实例将日志输出定向到自己的日志文件，独立于服务器的输出。
- en: 'When you use these options, it''s generally recommended to also include the
    `format` property. The following example uses a custom format and logs to /var/log/myapp.log
    with the `append` flag, so that the file isn’t truncated when the application
    boots:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这些选项时，通常建议还包括 `format` 属性。以下示例使用自定义格式，并带有 `append` 标志将日志记录到 /var/log/myapp.log，这样在应用程序启动时文件不会被截断：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another useful option is `immediate`, which writes the log line when the request
    is first received, rather than waiting for the response. You might use this option
    if you’re writing a server that keeps its requests open for a long time, and you
    want to know when the connection begins. Or you might use it for debugging a critical
    section of your app. Tokens such as `:status` and `:response-time` can’t be used,
    because they’re related to the response. To enable immediate mode, pass `true`
    for the `immediate` value, as shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项是 `immediate`，它在接收到请求时立即写入日志行，而不是等待响应。如果你正在编写一个长时间保持请求打开的服务器，并且想知道连接何时开始，或者你可能用它来调试应用程序的关键部分。像
    `:status` 和 `:response-time` 这样的令牌不能使用，因为它们与响应相关。要启用立即模式，将 `immediate` 的值传递为 `true`，如下所示：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That’s it for logging! Next we’ll look at the favicon-serving middleware component.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 日志部分到此结束！接下来，我们将查看 favicon-serving 中间件组件。
- en: 'C.2.2\. serve-favicon: address bar and bookmark icons'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.2.2\. serve-favicon：地址栏和书签图标
- en: A *favicon* is that tiny website icon your browser displays in the address bar
    and bookmarks. To get this icon, the browser makes a request for a file at /favicon.ico.
    It’s usually best to serve favicon files as soon as possible, so the rest of your
    application can simply ignore them. The serve-favicon module ([www.npmjs.com/package/serve-favicon](http://www.npmjs.com/package/serve-favicon))
    causes Connect’s icon to be displayed by default. This can be configured by passing
    arguments for other icons. This favicon is shown in [figure C.2](#app03fig02).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*favicon* 是浏览器在地址栏和书签中显示的微小网站图标。为了获取这个图标，浏览器会向 /favicon.ico 的文件发送请求。通常最好尽快提供
    favicon 文件，这样其余的应用程序就可以简单地忽略它们。serve-favicon 模块([www.npmjs.com/package/serve-favicon](http://www.npmjs.com/package/serve-favicon))默认显示
    Connect 的图标。这可以通过传递其他图标的参数来配置。此 favicon 如图 C.2 所示。'
- en: Figure C.2\. A favicon
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 C.2\. 一个 favicon
- en: '![](Images/cfig02.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cfig02.jpg)'
- en: Basic usage
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: The serve-favicon middleware component can be placed at the top of the stack,
    which causes favicon requests to be ignored by any subsequent logging components.
    The icon is cached in memory for fast responses.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: serve-favicon 中间件组件可以被放置在堆栈的顶部，这会导致后续的任何日志组件忽略 favicon 请求。图标被缓存在内存中以实现快速响应。
- en: 'The following example shows serve-favicon sending an .ico file by passing the
    file path as the only argument:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示 serve-favicon 通过传递文件路径作为唯一参数发送 .ico 文件：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that you need a file called favicon.ico to test this out. Optionally, you
    can pass in a `maxAge` argument to specify how long browsers should cache the
    favicon in memory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要一个名为 favicon.ico 的文件来测试这一点。可选地，你可以传递一个 `maxAge` 参数来指定浏览器应该在内存中缓存 favicon
    的时间长度。
- en: 'Next we have another small but helpful middleware component: method-override.
    It provides the means to fake the HTTP request method when client capabilities
    are limited.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个另一个小但很有用的中间件组件：method-override。它提供了在客户端功能有限时伪造 HTTP 请求方法的方法。
- en: 'C.2.3\. method-override: fake HTTP methods'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.2.3\. method-override：伪造 HTTP 方法
- en: Sometimes it’s useful to use HTTP verbs beyond the common `GET` and `POST` methods.
    Imagine that you’re building a blog, and you want to allow people to create, update,
    and delete articles. It feels more natural to say `DELETE` /article rather than
    `GET` or `POST`. Unfortunately, not every browser understands the `DELETE` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候使用超出常见 `GET` 和 `POST` 方法的 HTTP 动词是有用的。想象一下你正在构建一个博客，并希望允许人们创建、更新和删除文章。说 `DELETE`
    /article 比说 `GET` 或 `POST` 更自然。不幸的是，并非每个浏览器都理解 `DELETE` 方法。
- en: A common workaround is to allow the server to get a hint about which HTTP method
    to use from the query parameters, form values, and sometimes even the HTTP headers.
    One way this is done is by adding `<input type=hidden>` with the value set to
    the method name you want to use. The server can then check the value and pretend
    it’s the request method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是允许服务器从查询参数、表单值以及有时甚至 HTTP 头部中获取有关要使用哪个 HTTP 方法的提示。这样做的一种方式是添加 `<input
    type=hidden>` 并将其值设置为要使用的方程序名。然后服务器可以检查该值并假装它是请求方法。
- en: Most web frameworks support this technique, and the method-override module ([www.npmjs.com/package/method-override](http://www.npmjs.com/package/method-override))
    is the recommended way to do it with Connect.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Web 框架都支持这种技术，而 `method-override` 模块（[www.npmjs.com/package/method-override](http://www.npmjs.com/package/method-override)）是使用
    Connect 实现它的推荐方式。
- en: Basic usage
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'By default, the HTML input name is `_method`, but you can pass a custom value
    to `methodOverride`, as shown in the following snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HTML 输入名称是 `_method`，但你可以向 `methodOverride` 传递一个自定义值，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To demonstrate how `methodOverride()` is implemented, let’s see how to create
    a tiny application to update user information. The application consists of a single
    form that will respond with a simple success message when the form is submitted
    by the browser and processed by the server, as illustrated in [figure C.3](#app03fig03).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `methodOverride()` 的实现方式，让我们看看如何创建一个用于更新用户信息的小型应用程序。该应用程序由一个表单组成，当浏览器提交表单并由服务器处理时，它会返回一个简单的成功消息，如图
    C.3 所示。
- en: Figure C.3\. Using methodoverride to simulate a `PUT` request to update a form
    in the browser
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 C.3\. 使用 methodoverride 在浏览器中模拟 `PUT` 请求以更新表单
- en: '![](Images/cfig03.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/cfig03.jpg)'
- en: The application updates the user data through the use of two separate middleware
    components. In the `update` function, `next()` is called when the request method
    isn’t `PUT`. As mentioned previously, most browsers don’t respect the form attribute
    `method="put"`, so the application in the following listing won’t function properly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序通过使用两个独立的中间件组件来更新用户数据。在 `update` 函数中，当请求方法不是 `PUT` 时，会调用 `next()`。如前所述，大多数浏览器不尊重表单属性
    `method="put"`，所以以下列表中的应用程序将无法正常工作。
- en: Listing C.9\. A broken user-update application
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.9\. 一个损坏的用户更新应用程序
- en: '![](Images/clis09_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/clis09_alt.jpg)'
- en: In this example, a form has been set up that sends a `PUT` to the server ![](Images/circ1.jpg).
    The form should send data to the `update` function, but only if it’s sent with
    a `PUT` ![](Images/circ2.jpg). You can try this with different browsers and HTTP
    clients; you can send a `PUT` with `curl` by using the `-X` option.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，已经设置了一个表单，它将向服务器发送 `PUT` ![图片](Images/circ1.jpg)。该表单应该将数据发送到 `update`
    函数，但只有当它以 `PUT` 发送时 ![图片](Images/circ2.jpg)。你可以尝试使用不同的浏览器和 HTTP 客户端；你可以使用 `-X`
    选项通过 `curl` 发送 `PUT`。
- en: To improve browser support, you’ll add the method-override module. Here an additional
    input with the name `_method` has been added to the form, and `methodOverride()`
    has been added below the `bodyParser()` method because it references `req.body`
    to access the form data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高浏览器支持，你将添加 `method-override` 模块。这里在表单中添加了一个额外的输入，其名称为 `_method`，并在 `bodyParser()`
    方法下方添加了 `methodOverride()`，因为它引用 `req.body` 以访问表单数据。
- en: Listing C.10\. Using method-override to support HTTP `PUT`
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.10\. 使用 method-override 支持HTTP `PUT`
- en: '![](Images/app03ex10-0.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/app03ex10-0.jpg)'
- en: '![](Images/app03ex10-1.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/app03ex10-1.jpg)'
- en: If you run this example, you should see that you can now send `PUT` requests
    from almost any browser.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，你应该会看到你现在可以从几乎任何浏览器发送 `PUT` 请求。
- en: Accessing the original req.method
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问原始 req.method
- en: '`methodOverride()` alters the original `req.method` property, but Connect copies
    over the original method, which you can always access with `req.originalMethod`.
    The previous form would output values like these:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`methodOverride()` 修改了原始的 `req.method` 属性，但 Connect 会复制原始方法，你可以始终使用 `req.originalMethod`
    访问它。之前的表单会输出如下值：'
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To avoid including extra form variables, HTTP headers are supported as well.
    Different vendors use different headers, so you can create servers that support
    several header field names. This will help if you want to support client tools
    and libraries that assume a specific header. In the following example, the three
    header field names are supported:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免包含额外的表单变量，HTTP 头部也得到了支持。不同的供应商使用不同的头部，因此你可以创建支持多个头部字段名的服务器。如果你想要支持假设特定头部的客户端工具和库，这将有所帮助。在下面的示例中，支持了三个头部字段名：
- en: '![](Images/p0331_01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0331_01.jpg)'
- en: Routing based on headers is a common task. One good example of this is supporting
    virtual hosts. You may have seen Apache servers that do this when you want to
    host multiple websites on a smaller number of IP addresses. Apache and Nginx can
    determine which website should be served based on the `Host` header.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 基于头部进行路由是一个常见的任务。一个很好的例子是支持虚拟主机。你可能见过 Apache 服务器在你想在较少的 IP 地址上托管多个网站时执行此操作。Apache
    和 Nginx 可以根据 `Host` 头部确定应该服务哪个网站。
- en: Connect can do this too, and it’s easier than you might think. Read on to learn
    about virtual hosts and the vhost module.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 也可以这样做，比你想象的要简单。继续阅读，了解虚拟主机和 vhost 模块。
- en: 'C.2.4\. vhost: virtual hosting'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'C.2.4\. vhost: 虚拟主机'
- en: The vhost (virtual host) module ([www.npmjs.com/package/vhost](http://www.npmjs.com/package/vhost))
    is a simple, lightweight middleware component that routes requests via the `Host`
    request header. This task is commonly performed by a reverse proxy, which then
    forwards the request to a web server running locally on a different port. The
    `vhost` component does this in the same Node process by passing control to a Node
    HTTP server associated with the `vhost` instance.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: vhost（虚拟主机）模块 ([www.npmjs.com/package/vhost](http://www.npmjs.com/package/vhost))
    是一个简单、轻量级的中间件组件，它通过 `Host` 请求头部路由请求。这项任务通常由反向代理执行，然后它将请求转发到运行在本地不同端口的 Web 服务器。`vhost`
    组件通过将控制权传递给与 `vhost` 实例关联的 Node HTTP 服务器来完成这项任务。
- en: Basic usage
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Like most middleware, a single line is all it takes to get up and running with
    the `vhost` component. It takes two arguments: The first is the hostname string
    that this `vhost` instance will match against. The second is the `http.Server`
    instance that’ll be used when an HTTP request with a matching hostname is made
    (all Connect apps are subclasses of `http.Server`, so an application instance
    will work as well):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数中间件一样，只需一行代码就可以启动 `vhost` 组件。它接受两个参数：第一个是这个 `vhost` 实例将与之匹配的主机字符串。第二个是在创建匹配主机名的
    HTTP 请求时将使用的 `http.Server` 实例（所有 Connect 应用程序都是 `http.Server` 的子类，因此应用程序实例也可以使用）：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to use the preceding ./sites/expressjs.dev module, it should assign
    the HTTP server to `module.exports`, as in the following example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用前面的 ./sites/expressjs.dev 模块，它应该将 HTTP 服务器分配给 `module.exports`，如下面的示例所示：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using multiple vhost instances
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用多个 vhost 实例
- en: 'As with any other middleware, you can use `vhost` more than once in an application
    to map several hosts to their associated applications:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他中间件一样，你可以在一个应用程序中使用 `vhost` 多次，将多个主机映射到它们相关的应用程序：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Rather than setting up the `vhost` middleware manually like this, you could
    generate a list of hosts from the filesystem. That’s shown in the following example,
    with the `fs.readdirSync()` method returning an array of directory entries:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是像这样手动设置 `vhost` 中间件，你可以从文件系统中生成一个主机列表。以下是一个示例，其中 `fs.readdirSync()` 方法返回一个目录条目数组：
- en: '[PRE38]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The benefit of using `vhost` instead of a reverse proxy is simplicity. It allows
    you to manage all your applications as a single unit. This is ideal for serving
    several smaller sites, or for serving sites that are largely composed of static
    content, but it also has the downside that if one site causes a crash, all your
    sites will be taken down (because they all run in the same process).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vhost` 而不是反向代理的好处是简单性。它允许你将所有应用程序作为一个单一单元来管理。这对于服务多个较小的网站，或者服务主要由静态内容组成的网站来说很理想，但它也有一个缺点，那就是如果某个网站导致崩溃，所有你的网站都会被关闭（因为它们都在同一个进程中运行）。
- en: 'Next we’ll take a look at one of the most fundamental middleware components
    that Connect provides: the session management component, appropriately named express-session.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 Connect 提供的最基本的中间件组件之一：会话管理组件，命名为 express-session。
- en: 'C.2.5\. express-session: session management'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'C.2.5\. express-session: 会话管理'
- en: 'The way web applications handle sessions is dependent on varying requirements.
    For example, one important choice is the storage back end: some applications benefit
    from high-performance databases such as Redis; others require simplicity and use
    the same database as the main application. The express-session module ([www.npmjs.com/package/express-session](http://www.npmjs.com/package/express-session))
    provides an API that can be extended to suit different databases. It’s robust
    and easy to extend, so it has many community-supported extensions. In this section,
    you’ll learn how to use the memory-backed version and Redis.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序处理会话的方式取决于不同的需求。例如，一个重要的选择是存储后端：一些应用程序受益于高性能数据库，如Redis；而其他应用程序则需要简单性，并使用与主应用程序相同的数据库。express-session模块([www.npmjs.com/package/express-session](http://www.npmjs.com/package/express-session))提供了一个可以扩展以适应不同数据库的API。它既健壮又易于扩展，因此拥有许多社区支持的扩展。在本节中，您将学习如何使用基于内存的版本和Redis。
- en: First, let’s see how to set up the middleware and explore the options available.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何设置中间件并探索可用的选项。
- en: Basic usage
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: '[Listing C.11](#app03ex11) implements a small application that counts the number
    of times a given user has accessed the page. The data is stored in the user’s
    session. By default, the cookie name is connect.sid, and it’s set to be `httpOnly`,
    meaning client-side scripts can’t access its value. The data in the session itself
    is stored in-memory on the server. The listing shows the basic usage for express-session
    in Connect.^([[6](#app03fn06)])'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表C.11](#app03ex11) 实现了一个小型应用程序，该应用程序计算给定用户访问页面的次数。数据存储在用户的会话中。默认情况下，cookie名称为connect.sid，并且它被设置为`httpOnly`，这意味着客户端脚本无法访问其值。会话中的数据在服务器上以内存形式存储。列表显示了在Connect中使用express-session的基本用法.^([[6](#app03fn06)])'
- en: ⁶
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This was tested with express-session 1.10.2.
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是在 express-session 1.10.2 版本上进行的测试。
- en: Listing C.11\. Using sessions in Connect
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.11\. 在Connect中使用会话
- en: '![](Images/clis11_alt.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](Images/clis11_alt.jpg)'
- en: 'This short example sets up sessions and then manipulates a single session variable
    called `views`. First, the session middleware component is initialized with the
    required options: `secret`, `resave`, and `saveUninitialized` ![](Images/circ1.jpg).
    The `secret` option is required and determines whether the cookie used to identify
    the session is signed. The `resave` option is used to force the session to be
    saved on each request, even if it hasn’t changed. Some session storage back ends
    require this, so you need to check before enabling it. The last option, `saveUninitialized`,
    causes a session to be created even if no values were saved. You can turn this
    off if you want to comply with laws that require consent before saving cookies.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的示例首先设置了会话，然后操作一个名为 `views` 的单个会话变量。首先，会话中间件组件使用所需的选项进行初始化：`secret`、`resave`
    和 `saveUninitialized` ![图片1](Images/circ1.jpg)。`secret` 选项是必需的，它决定了用于标识会话的cookie是否被签名。`resave`
    选项用于强制在每次请求时保存会话，即使它没有发生变化。某些会话存储后端需要这个选项，因此您在启用之前需要检查。最后一个选项 `saveUninitialized`
    会导致即使没有保存任何值也会创建一个会话。如果您想遵守在保存cookie之前需要获得同意的法律，您可以关闭此选项。
- en: Setting the session expiration date
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置会话过期日期
- en: 'Suppose you want sessions to expire in 24 hours, to send the session cookie
    only when HTTPS is used, and to configure the cookie name. You can control how
    long the session lasts by setting the `expires` or `maxAge` properties on the
    expression object:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望会话在24小时后过期，仅在HTTPS使用时发送会话cookie，并配置cookie名称。您可以通过在表达式对象上设置 `expires` 或
    `maxAge` 属性来控制会话的持续时间：
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When using Connect, you’ll often set `maxAge`, specifying a number of milliseconds
    from that point in time. This method of expressing future dates is often written
    more intuitively, expanding to `new Date(Date.now() + maxAge)`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Connect 时，您通常会设置 `maxAge`，指定从该时间点开始的一段时间（以毫秒为单位）。这种表示未来日期的方法通常更直观地写成 `new
    Date(Date.now() + maxAge)`。
- en: Now that sessions are set up, let’s look at the methods and properties available
    when working with session data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会话已经设置好了，让我们看看在处理会话数据时可用的方法和属性。
- en: Working with session data
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用会话数据
- en: 'The express-session data management API is simple. The basic principle is that
    any properties assigned to the `req.session` object are saved when the request
    is complete; then they’re loaded on subsequent requests from the same user (browser).
    For example, saving shopping cart information is as simple as assigning an object
    to the `cart` property, as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Express-session 数据管理 API 很简单。其基本原理是，当请求完成时，分配给 `req.session` 对象的任何属性都会被保存；然后它们会在同一用户（浏览器）的后续请求中加载。例如，保存购物车信息就像将一个对象分配给
    `cart` 属性一样简单，如下所示：
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you access `req.session.cart` on subsequent requests, the `.items` array
    will be available. Because this is a regular JavaScript object, you can call methods
    on the nested objects in subsequent requests, as in the following example, and
    they’ll be saved as you expect:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在后续请求中访问 `req.session.cart` 时，`.items` 数组将是可用的。因为这是一个常规的JavaScript对象，你可以在后续请求中对嵌套对象调用方法，就像以下示例中那样，并且它们会按预期保存：
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'One important thing to keep in mind is that this session object gets serialized
    as JSON between requests, so the `req.session` object has the same restrictions
    as JSON: cyclic properties aren’t allowed, `function` objects can’t be used, `Date`
    objects can’t be serialized correctly, and so on. Keep those restrictions in mind
    when using the session object.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要记住，这个会话对象在请求之间会被序列化为JSON，所以 `req.session` 对象有与JSON相同的限制：不允许循环属性，不能使用
    `function` 对象，`Date` 对象不能正确序列化，等等。在使用会话对象时，请记住这些限制。
- en: Connect will save session data for you automatically, but internally it’s calling
    the `Session#save([callback])` method, which is also available as a public API.
    Two additional helpful methods are `Session#destroy()` and `Session#regenerate()`,
    which are often used when authenticating a user to prevent session fixation attacks.
    When you build applications with Express, you’ll use these methods for authentication.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 会自动为你保存会话数据，但内部它调用的是 `Session#save([callback])` 方法，这个方法也作为公共API提供。另外两个有用的方法是
    `Session#destroy()` 和 `Session#regenerate()`，它们通常在验证用户时使用，以防止会话固定攻击。当你使用Express构建应用程序时，你会使用这些方法进行身份验证。
- en: Now let’s move on to manipulating session cookies.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续操作会话cookie。
- en: Manipulating session cookies
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作会话cookie
- en: Connect allows you to provide global cookie settings for sessions, but it’s
    also possible to manipulate a specific cookie via the `Session#cookie` object,
    which defaults to the global settings.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 允许你为会话提供全局cookie设置，但也可以通过 `Session#cookie` 对象操作特定的cookie，该对象默认为全局设置。
- en: 'Before you start tweaking properties, let’s see how to extend the previous
    session application to inspect the session cookie properties by writing each property
    into individual `<p>` tags in the response HTML, as shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始调整属性之前，让我们看看如何通过将每个属性写入响应HTML中的单独 `<p>` 标签来扩展先前的会话应用程序，如下所示：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Express-session allows all the cookie properties (such as `expires`, `httpOnly`,
    `secure`, `path`, and `domain`) to be altered programmatically on a per-session
    basis. For example, you could expire an active session in 5 seconds like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Express-session 允许按会话基础程序化地更改所有cookie属性（如 `expires`、`httpOnly`、`secure`、`path`
    和 `domain`）。例如，你可以这样在5秒内使一个活跃的会话过期：
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'An alternative, more intuitive API for expiry is the `.maxAge` accessor, which
    allows you to get and set the value in milliseconds relative to the current time.
    The following also expires the session in 5 seconds:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过期设置，有一个更直观的API是 `.maxAge` 访问器，它允许你相对于当前时间以毫秒为单位获取和设置值。以下代码也会在5秒后使会话过期：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The remaining properties, `domain`, `path`, and `secure`, limit the cookie
    *scope*, restricting it by domain, path, or to secure connections, whereas `httpOnly`
    prevents client-side scripts from accessing the cookie data. These properties
    can be manipulated in the same manner:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的属性，`domain`、`path` 和 `secure`，限制了cookie的 *作用域*，通过域名、路径或安全连接来限制，而 `httpOnly`
    阻止客户端脚本访问cookie数据。这些属性可以以相同的方式操作：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So far you’ve been using the default memory store to store session data, so
    let’s take a look at how to plug in alternative data stores.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用默认的内存存储来存储会话数据，所以让我们看看如何连接替代数据存储。
- en: Session stores
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 会话存储
- en: In the previous examples, we’ve been using the built-in `MemoryStore` session
    storage. It’s a simple, in-memory data store, which is ideal for running application
    tests because no other dependencies are necessary. But during development and
    in production, it’s best to have a persistent, scalable database backing your
    session data; otherwise, you’ll keep losing your session when you restart the
    server.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们一直在使用内置的`MemoryStore`会话存储。它是一个简单的内存数据存储，非常适合运行应用程序测试，因为它不需要其他依赖项。但在开发和生产中，最好有一个持久、可扩展的数据库作为您的会话数据后端；否则，每次重启服务器时，您都会丢失会话。
- en: Just about any database can act as a session store, but low-latency key/value
    stores work best for such volatile data. The Connect community has created several
    session stores for databases, including CouchDB, MongoDB, Redis, Memcached, PostgreSQL,
    and others.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何数据库都可以作为会话存储，但对于这种易变数据，低延迟的键/值存储效果最好。Connect社区为数据库创建了几种会话存储，包括CouchDB、MongoDB、Redis、Memcached、PostgreSQL等。
- en: Here you’ll use Redis with the connect-redis module ([https://www.npmjs.com/package/connect-redis](https://www.npmjs.com/package/connect-redis)).
    Redis is a good backing store because it supports key expiration, provides great
    performance, and is easy to install.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将使用connect-redis模块与Redis一起使用([https://www.npmjs.com/package/connect-redis](https://www.npmjs.com/package/connect-redis))。Redis是一个很好的后端存储，因为它支持键过期、提供出色的性能，并且易于安装。
- en: 'Invoke `redis-server` to make sure you’ve got Redis installed:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`redis-server`以确保您已安装Redis：
- en: '[PRE46]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, you need to install connect-redis by adding it to your package.json file
    and running `npm install`, or by executing `npm install --save connect-redis`
    directly.^([[7](#app03fn07)]) The connect-redis module exports a function that
    should be passed `connect`, as shown in the following listing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要通过将其添加到您的package.json文件并运行`npm install`，或者直接执行`npm install --save connect-redis`来安装connect-redis。^([[7](#app03fn07)])
    connect-redis模块导出一个函数，该函数应该传递给`connect`，如下面的列表所示。
- en: ⁷
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We used version 2.2.0 when writing this book.
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在编写这本书时使用了2.2.0版本。
- en: Listing C.12\. Using Redis as a session store
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.12\. 使用Redis作为会话存储
- en: '![](Images/clis12_alt.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis12_alt.jpg)'
- en: This example sets up a session store that uses Redis. Passing the `connect`
    reference to `connect-redis` allows it to inherit from `connect.session.Store.prototype`.
    This is important because in Node a single process may use multiple versions of
    a module simultaneously; by passing your specific version of Connect, you can
    be sure that connect-redis uses the proper copy.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例设置了一个使用Redis的会话存储。将`connect`引用传递给`connect-redis`允许它从`connect.session.Store.prototype`继承。这很重要，因为在Node中，单个进程可能同时使用多个模块的多个版本；通过传递您的特定Connect版本，您可以确保connect-redis使用正确的副本。
- en: The instance of `RedisStore` is passed to `session()` as the `store` value,
    and any options you want to use, such as a key prefix for your sessions, can be
    passed to the `RedisStore` constructor. After both of these steps are done, you
    can access session variables the same way as with `MemoryStore`. One small detail
    about this example is that we included the favicon middleware component to prevent
    the session variable from being incremented twice; otherwise, the `views` value
    will appear to be increased by 2 on each request as the browser fetches the page
    and /favicon.ico.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RedisStore`实例传递给`session()`作为`store`值，您想要使用的任何选项，例如会话的键前缀，都可以传递给`RedisStore`构造函数。完成这两个步骤后，您就可以像使用`MemoryStore`一样访问会话变量。关于这个示例的一个小细节是，我们包括了favicon中间件组件以防止会话变量被两次增加；否则，每次浏览器获取页面和/favicon.ico时，`views`值看起来都会增加2。
- en: Whew! `session` was a lot to cover, but that finishes up all the core concept
    middleware. Next we’ll go over the built-in middleware that handles web application
    security. This is an important subject for applications that need to secure their
    data.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！`session`有很多内容要涵盖，但这完成了所有核心概念中间件。接下来，我们将介绍处理Web应用程序安全的内置中间件。这对于需要保护其数据的应用程序来说是一个重要主题。
- en: C.3\. Handling web application security
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3\. 处理Web应用程序安全
- en: As we’ve stated many times, Node’s core API is intentionally low-level. This
    means it provides no built-in security or best practices when it comes to building
    web applications. Fortunately, Connect middleware components implement these security
    practices.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次提到的，Node的核心API故意是低级的。这意味着在构建Web应用程序时，它不提供内置的安全或最佳实践。幸运的是，Connect中间件组件实现了这些安全实践。
- en: 'This section will teach you about three security-related modules that you can
    install from npm:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您介绍三个可以从 npm 安装的与安全相关的模块：
- en: '***basic-auth—*** Provides HTTP Basic authentication for protecting data'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***basic-auth—*** 为保护数据提供 HTTP 基本认证'
- en: '***csurf—*** Implements protection against cross-site request forgery (CSRF)
    attacks'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***csurf—*** 实现对跨站请求伪造（CSRF）攻击的保护'
- en: '***errorhandler—*** Helps you debug during development'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***errorhandler—*** 在开发期间帮助您调试'
- en: First, let’s see how to set up an application that uses basic-auth to provide
    HTTP Basic authentication.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何设置一个使用 basic-auth 提供 HTTP 基本认证的应用程序。
- en: 'C.3.1\. basic-auth: HTTP Basic authentication'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'C.3.1\. basic-auth: HTTP 基本认证'
- en: In [chapter 4](kindle_split_015.xhtml#ch04), you created a crude Basic authentication
    middleware component. Well, it turns out that several Connect modules can do this
    for you. As previously mentioned, Basic authentication is a simple HTTP authentication
    mechanism, and it should be used with caution because user credentials can be
    trivial for an attacker to intercept unless Basic authentication is served over
    HTTPS. That being said, it can be useful for adding quick and dirty authentication
    to a small or personal application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](kindle_split_015.xhtml#ch04) 中，您创建了一个粗略的基本认证中间件组件。好吧，结果证明，几个 Connect
    模块可以为您做这件事。如前所述，基本认证是一种简单的 HTTP 认证机制，应该谨慎使用，因为除非基本认证通过 HTTPS 提供，否则用户凭证对攻击者来说很容易被拦截。话虽如此，它对于向小型或个人应用程序添加快速且简单的认证可能很有用。
- en: When your application has the basic-auth module in use, web browsers will prompt
    for credentials the first time the user attempts to connect to your application,
    as shown in [figure C.4](#app03fig04).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序使用 basic-auth 模块时，当用户第一次尝试连接到您的应用程序时，网络浏览器会提示输入凭证，如图 C.4 所示。
- en: Figure C.4\. Basic authentication prompt
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 C.4\. 基本认证提示
- en: '![](Images/cfig04.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cfig04.jpg)'
- en: Basic usage
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: The basic-auth module ([www.npmjs.com/package/basic-auth](http://www.npmjs.com/package/basic-auth))
    allows you to get the credentials from the HTTP `Authorization` header field.
    The following listing shows how to use it with your own password verification
    function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: basic-auth 模块 ([www.npmjs.com/package/basic-auth](http://www.npmjs.com/package/basic-auth))
    允许您从 HTTP `Authorization` 头字段获取凭证。以下列表显示了如何使用您自己的密码验证函数。
- en: Listing C.13\. Using the basic-auth module
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.13\. 使用基本认证模块
- en: '![](Images/clis13_alt.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/clis13_alt.jpg)'
- en: The basic-auth module provides only the `Authorization` header field parsing
    part of the authentication process. You have to check the password yourself by
    calling it in a middleware component and then the basic-auth module sends back
    the right headers when authentication fails. This example calls `next()` when
    authentication has succeeded so execution will continue to the protected parts
    of the application.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: basic-auth 模块仅提供认证过程中的 `Authorization` 头字段解析部分。您必须自己通过在中间件组件中调用它来检查密码，然后当认证失败时，basic-auth
    模块会发送正确的头。此示例在认证成功时调用 `next()`，以便执行继续到应用程序的保护部分。
- en: An example with curl
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: curl 的一个示例
- en: 'Now try issuing an HTTP request to the server with `curl`, and you’ll see that
    you’re unauthorized:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 `curl` 向服务器发送 HTTP 请求，您将看到您未授权：
- en: '[PRE47]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Issuing the same request with HTTP Basic authorization credentials (notice
    the beginning of the URL) will provide access:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的请求和 HTTP 基本认证凭证（注意 URL 的开头）将提供访问权限：
- en: '[PRE48]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Continuing on with the security theme of this section, let’s look at the csurf
    module, which is designed to help protect against cross-site request forgery attacks.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 继续本节的网络安全主题，让我们看看 csurf 模块，该模块旨在帮助防止跨站请求伪造攻击。
- en: 'C.3.2\. csurf: cross-site request forgery protection'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'C.3.2\. csurf: 跨站请求伪造保护'
- en: Cross-site request forgery (CSRF) is a form of attack that exploits the trust
    that a web browser has in a site. The attack works by having an authenticated
    user on your application visit a different site that an attacker has either created
    or compromised, and then making requests on the user’s behalf without them knowing
    about it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF）是一种攻击形式，它利用了网络浏览器对网站的信任。攻击通过让您的应用程序上的已认证用户访问攻击者创建或破坏的另一个网站来实现，然后代表用户进行请求，而用户并不知道这一点。
- en: It’s easier to understand this process with an example. Suppose that in your
    application the request `DELETE /account` will trigger a user’s account to be
    destroyed (though only while the user is logged in). Now suppose that user visits
    a forum that happens to be vulnerable to CSRF. An attacker could post a script
    that issues the `DELETE /account` request, thus destroying the user’s account.
    This is a bad situation for your application to be in, and the csurf module can
    help protect against such an attack.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个示例更容易理解这个过程。假设在您的应用程序中，请求`DELETE /account`将触发用户的账户被销毁（尽管仅在用户登录时）。现在假设该用户访问了一个恰好容易受到CSRF攻击的论坛。攻击者可以发布一个脚本，发出`DELETE
    /account`请求，从而销毁用户的账户。这对您的应用程序来说是一个糟糕的情况，而csurf模块可以帮助防止这种攻击。
- en: The csurf module ([https://www.npmjs.com/package/csurf](https://www.npmjs.com/package/csurf))
    works by generating a 24-character unique ID, the *authenticity token*, and assigning
    it to the user’s session as `req.session._csrf`. This token can then be included
    as a hidden form input named `_csrf`, and the CSRF component can validate the
    token on submission. This process is repeated for each interaction.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: csurf模块（[https://www.npmjs.com/package/csurf](https://www.npmjs.com/package/csurf)）通过生成一个24字符的唯一ID，即*认证令牌*，并将其分配给用户的会话作为`req.session._csrf`来实现。然后，可以将此令牌包含为名为`_csrf`的隐藏表单输入，CSRF组件可以在提交时验证令牌。此过程对每次交互都会重复。
- en: Basic usage
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: To ensure that csurf can access `req.body._csrf` (the hidden input value) and
    `req.session._csrf`, you need to make sure that you add the module’s middleware
    function below body-parser and express-session, as shown in the following listing.^([[8](#app03fn08)])
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保csurf可以访问`req.body._csrf`（隐藏输入值）和`req.session._csrf`，您需要确保在body-parser和express-session之后添加模块的中间件函数，如下面的列表所示.^([[8](#app03fn08)])
- en: ⁸
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We tested this example with csurf 1.6.6.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用csurf 1.6.6测试了这个示例。
- en: Listing C.14\. CSRF protection
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.14\. CSRF保护
- en: '![](Images/app03ex14-0.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app03ex14-0.jpg)'
- en: '![](Images/app03ex14-1.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app03ex14-1.jpg)'
- en: To use csurf, you have to first load the body-parser and session middleware
    components. This example then shows a form, which includes a text field with the
    current CSRF token. This token will cause all requests of certain method types
    to be checked based on the secret in the session. You can get the current token
    with `req.csrf-Token`, which is a method added by csurf. Posts with invalid tokens
    will automatically be flagged by csurf, so we’ve included a “token successful”
    handler and an error handler. This example uses a text field so you can see what
    happens if you change it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用csurf，您必须首先加载body-parser和session中间件组件。此示例显示了一个表单，其中包含一个带有当前CSRF令牌的文本字段。此令牌将导致某些方法类型的所有请求根据会话中的密钥进行检查。您可以使用`req.csrf-Token`获取当前令牌，这是csurf添加的方法。带有无效令牌的帖子将由csurf自动标记，因此我们包括了一个“令牌成功”处理程序和一个错误处理程序。此示例使用文本字段，以便您可以看到如果更改它会发生什么。
- en: This example shows that csurf automatically kicks in for certain kinds of requests.
    This is defined by the `ignoreMethods` option that you can pass to csurf. By default,
    HTTP `GET`, `HEAD`, and `OPTIONS` are ignored, but you could add others if required.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例显示，csurf会自动对某些类型的请求启动。这是通过传递给csurf的`ignoreMethods`选项定义的。默认情况下，HTTP `GET`、`HEAD`和`OPTIONS`被忽略，但如果需要，您可以添加其他方法。
- en: Another aspect of web development is ensuring that verbose logs and detailed
    error reporting are available both in production and development environments.
    Let’s look at the errorhandler module, which is designed to do exactly that.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的另一个方面是确保在生产环境和开发环境中都提供详尽的日志和详细的错误报告。让我们看看errorhandler模块，它正是为此而设计的。
- en: 'C.3.3\. errorhandler: displaying errors during development'
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.3.3\. errorhandler：在开发期间显示错误
- en: The errorhandler module ([www.npmjs.com/package/errorhandler](http://www.npmjs.com/package/errorhandler))
    is ideal for development, providing verbose HTML, JSON, and plain-text error responses
    based on the `Accept` header field. It’s meant for use during development and
    shouldn’t be part of the production configuration.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: errorhandler模块（[www.npmjs.com/package/errorhandler](http://www.npmjs.com/package/errorhandler)）非常适合开发，它根据`Accept`头字段提供详尽的HTML、JSON和纯文本错误响应。它旨在在开发期间使用，不应成为生产配置的一部分。
- en: Basic usage
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Typically, this component should be the last used so it can catch all errors:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个组件应该是最后使用的，以便它可以捕获所有错误：
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Receiving an HTML error response
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接收HTML错误响应
- en: If you view any page in your browser with the setup shown here, you’ll see a
    Connect error page like the one shown in [figure C.5](#app03fig05), displaying
    the error message, the response status, and the entire stack trace.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这里显示的设置在你的浏览器中查看任何页面，你会看到一个像[图C.5](#app03fig05)中显示的Connect错误页面，显示错误消息、响应状态和整个堆栈跟踪。
- en: Figure C.5\. The default errorhandler HTML as displayed in a web browser
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图C.5. 在Web浏览器中显示的默认errorhandler HTML
- en: '![](Images/cfig05.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/cfig05.jpg)'
- en: Receiving a plain-text error response
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接收纯文本错误响应
- en: 'Now suppose you’re testing an API built with Connect. It’s far from ideal to
    respond with a large chunk of HTML, so by default `errorHandler()` will respond
    with `text/plain`, which is ideal for command-line HTTP clients such as `curl(1)`.
    This is illustrated in the following stdout:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你正在测试使用Connect构建的API。以大量HTML响应远非理想，所以默认情况下`errorHandler()`将以`text/plain`响应，这对于命令行HTTP客户端（如`curl(1)`）来说是非常理想的。这在上面的标准输出中得到了说明：
- en: '[PRE50]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Receiving a JSON error response
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接收JSON错误响应
- en: 'If you send an HTTP request that has the `Accept: application/json` HTTP header,
    you’ll get the following JSON response:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你发送一个带有`Accept: application/json` HTTP头部的HTTP请求，你将得到以下JSON响应：'
- en: '[PRE51]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’ve added additional formatting to the JSON response, so it’s easier to read
    on the page, but when Connect sends the JSON response, it gets compacted nicely
    by `JSON.stringify()`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对JSON响应添加了额外的格式化，使其在页面上更容易阅读，但当Connect发送JSON响应时，它会被`JSON.stringify()`方法很好地压缩。
- en: 'Are you feeling like a Connect security guru now? Maybe not yet, but you should
    have enough of the basics down to make your applications secure. Now let’s move
    on to a common web application function: serving static files.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在感觉像是一个Connect安全专家了吗？可能还不是，但你应该已经掌握了足够的基础知识来使你的应用程序安全。现在让我们继续到一个常见的Web应用程序功能：提供静态文件。
- en: C.4\. Serving static files
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.4\. 提供静态文件
- en: Serving static files is another requirement common to many web applications
    that’s not provided by Node’s core. Fortunately, with some simple modules, Connect
    has you covered here as well.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 提供静态文件是许多Web应用程序的共同需求，但Node的核心并没有提供。幸运的是，通过一些简单的模块，Connect在这里也为你提供了支持。
- en: 'In this section, you’ll learn about two more of Connect’s officially supported
    modules—this time focusing on serving files from the filesystem. These types of
    features are provided by HTTP servers such as Apache and Nginx, but with a little
    bit of configuration you can add them to your Connect projects:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解Connect的两个更多官方支持的模块——这次将重点放在从文件系统提供文件上。这些类型的功能由Apache和Nginx等HTTP服务器提供，但通过一点配置，你可以将它们添加到你的Connect项目中：
- en: '***serve-static—*** Serves files from the filesystem from a given root directory'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***serve-static—*** 从给定的根目录从文件系统中提供文件'
- en: '***serve-index—*** Serves pretty directory listings when a directory is requested'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***serve-index—*** 当请求目录时提供漂亮的目录列表'
- en: First we’ll show you how to serve static files with a single line of code by
    using the server-static module.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向您展示如何通过使用server-static模块用一行代码来提供静态文件。
- en: 'C.4.1\. serve-static: automatically serving files to the browser'
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.4.1\. serve-static：自动向浏览器提供文件
- en: The serve-static module ([www.npmjs.com/package/serve-static](http://www.npmjs.com/package/serve-static))
    implements a high-performance, flexible, feature-rich static file server supporting
    HTTP cache mechanisms, `Range` requests, and more. It also includes security checks
    for malicious paths, disallows access to hidden files (beginning with a period)
    by default, and rejects poison `null` bytes. In essence, serve-static is a secure
    and compliant static file-serving middleware component, ensuring compatibility
    with the various HTTP clients out there.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: serve-static模块([www.npmjs.com/package/serve-static](http://www.npmjs.com/package/serve-static))实现了一个高性能、灵活、功能丰富的静态文件服务器，支持HTTP缓存机制、`Range`请求等。它还包括对恶意路径的安全检查，默认不允许访问以点开头的隐藏文件，并拒绝有毒的`null`字节。本质上，serve-static是一个安全且符合规范的静态文件提供中间件组件，确保与各种HTTP客户端的兼容性。
- en: Basic usage
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Suppose your application follows the typical scenario of serving static assets
    from a directory named ./public. This can be achieved with a single line of code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序遵循从名为./public的目录提供静态资产的典型场景。这可以通过一行代码实现：
- en: '[PRE52]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this configuration, serve-static will check for regular files that exist
    in ./public/ based on the request URL. If a file exists, the response’s `Content-Type`
    field value will be defaulted based on the file’s extension, and the data will
    be transferred. If the requested path doesn’t represent a file, the `next()` callback
    will be invoked, allowing subsequent middleware (if any) to handle the request.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置下，serve-static 将根据请求 URL 检查 ./public/ 中存在的常规文件。如果文件存在，响应的 `Content-Type`
    字段值将默认基于文件的扩展名，并且数据将被传输。如果请求的路径不表示文件，则将调用 `next()` 回调，允许后续中间件（如果有的话）处理请求。
- en: 'To test it out, create a file named ./public/foo.js with `console.log(''tobi'')`,
    and issue a request to the server by using `curl(1)` with the `-i` flag, telling
    it to print the HTTP headers. You’ll see that the HTTP cache-related header fields
    are set appropriately, the `Content-Type` reflects the .js extension, and the
    content is transferred:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，创建一个名为 ./public/foo.js 的文件，并使用 `console.log('tobi')`，然后通过使用带有 `-i` 标志的
    `curl(1)` 向服务器发送请求，告诉它打印 HTTP 头部信息。你会看到 HTTP 缓存相关的头部字段被适当地设置，`Content-Type` 反映了
    .js 扩展名，并且内容被传输：
- en: '[PRE53]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Because the request path is used as is, files nested within directories are
    served as you’d expect. For example, you might have a `GET /javascripts/jquery.js`
    request and a `GET /stylesheets/app.css` request on your server, which would serve
    the files ./public/javascripts/jquery.js and ./public/stylesheets/app.css, respectively.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因为请求路径被原样使用，目录内的文件将按预期提供服务。例如，你可能在服务器上有一个 `GET /javascripts/jquery.js` 请求和一个
    `GET /stylesheets/app.css` 请求，分别会服务 ./public/javascripts/jquery.js 和 ./public/stylesheets/app.css
    文件。
- en: Using serve-static with mounting
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 serve-static 和挂载
- en: Sometimes applications prefix pathnames with /public, /assets, /static, and
    so on. With the mounting concept that Connect implements, serving static files
    from multiple directories is simple. Just mount the app at the location you want.
    As mentioned in [chapter 5](kindle_split_016.xhtml#ch05), the middleware itself
    has no knowledge that it’s mounted, because the prefix is removed.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序会在路径名前加上 /public、/assets、/static 等前缀。使用 Connect 实现的挂载概念，从多个目录中提供服务静态文件变得简单。只需将应用挂载到你想要的位置。如
    [第 5 章](kindle_split_016.xhtml#ch05) 中所述，中间件本身并不知道它被挂载，因为前缀已被移除。
- en: 'For example, a request to `GET /app/files/js/jquery.js` with serve-static mounted
    at /app/files will appear to the middleware as `GET /js/jquery`. This works out
    well for the prefixing functionality because /app/files won’t be part of the file
    resolution:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当 serve-static 挂载在 /app/files 上时，对 `GET /app/files/js/jquery.js` 的请求对中间件来说将表现为
    `GET /js/jquery`。这对于前缀功能来说效果很好，因为 /app/files 不会成为文件解析的一部分：
- en: '[PRE54]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The original request of `GET /foo.js` won’t work anymore, because the middleware
    isn’t invoked unless the mount point is present, but the prefixed version `GET
    /app/files/foo.js` will transfer the file:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `GET /foo.js` 请求将不再有效，因为除非存在挂载点，否则中间件不会被调用，但前缀版本 `GET /app/files/foo.js`
    将会传输文件：
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Absolute vs. relative directory paths
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绝对路径与相对路径目录
- en: Keep in mind that the path passed to serve-static is relative to the current
    working directory. Passing in `"public"` as your path will essentially resolve
    to `process.cwd() + "public"`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，传递给 serve-static 的路径相对于当前工作目录。将 `"public"` 作为路径传递将本质上解析为 `process.cwd()
    + "public"`。
- en: 'Sometimes, though, you may want to use absolute paths when specifying the base
    directory, and the `__dirname` variable helps with that:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能想在指定基本目录时使用绝对路径，`__dirname` 变量有助于实现这一点：
- en: '[PRE56]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Serving index.html when a directory is requested
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 当请求目录时提供服务 index.html
- en: Another useful feature of serve-static is its ability to serve index.html files.
    When a request for a directory is made and an index.html file lives in that directory,
    it will be served.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: serve-static 的另一个有用功能是它能够提供服务 index.html 文件。当一个目录请求被发起，并且该目录中存在 index.html 文件时，它将被提供服务。
- en: Serving static files is useful for web application assets, such as CSS, JavaScript,
    and images. But what if you want to allow people to download a list of arbitrary
    files from a list of directories? That’s where serve-index comes in.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为网页应用程序资源提供服务静态文件是有用的，例如 CSS、JavaScript 和图片。但如果你想允许人们从目录列表中下载任意文件列表怎么办？这就是 serve-index
    的用武之地。
- en: 'C.4.2\. serve-index: generating directory listings'
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.4.2\. serve-index：生成目录列表
- en: The serve-index module ([www.npmjs.com/package/serve-index](http://www.npmjs.com/package/serve-index))
    is a small directory-listing component that provides a way for users to browse
    remote files. [Figure C.6](#app03fig06) illustrates the interface provided by
    this component, complete with a search input field, file icons, and clickable
    breadcrumbs.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: serve-index 模块 ([www.npmjs.com/package/serve-index](http://www.npmjs.com/package/serve-index))
    是一个小型目录列表组件，它为用户提供了一种浏览远程文件的方式。[图 C.6](#app03fig06) 展示了该组件提供的界面，包括搜索输入字段、文件图标和可点击的面包屑。
- en: Figure C.6\. Serving directory listings with Connect’s `directory()` middleware
    component
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 C.6\. 使用 Connect 的 `directory()` 中间件组件提供目录列表
- en: '![](Images/cfig06.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图 C.6](Images/cfig06.jpg)'
- en: Basic usage
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'This component is designed to work with serve-static, which will perform the
    file serving; serve-index simply serves the listings. The setup can be as simple
    as the following snippet, where the request `GET /` serves the ./public directory:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件旨在与 serve-static 一起工作，它将执行文件提供；serve-index 简单地提供列表。设置可以像以下代码片段那样简单，其中请求 `GET
    /` 提供了 ./public 目录：
- en: '[PRE57]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using directory() with mounting
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 directory() 进行挂载
- en: 'Through the use of middleware mounting, you can prefix both the server-static
    and serve-index modules to any path you like, such as `GET /files` in the following
    example. Here the `icons` option is used to enable icons, and `hidden` is enabled
    for both components to allow the viewing and serving of hidden files:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用中间件挂载，你可以将服务器静态和 serve-index 模块前缀添加到任何你喜欢的路径，例如以下示例中的 `GET /files`。在这里，`icons`
    选项用于启用图标，`hidden` 选项对两个组件都启用，以便查看和提供隐藏文件：
- en: '[PRE58]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It’s now possible to navigate through files and directories with ease.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以轻松地浏览文件和目录。
