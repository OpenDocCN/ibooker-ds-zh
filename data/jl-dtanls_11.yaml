- en: 9 Getting data from a data frame
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 从数据框获取数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Subsetting rows of a data frame
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子集数据框的行
- en: Selecting columns of a data frame
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数据框的列
- en: Creating local linear regression (LOESS) models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建局部线性回归（LOESS）模型
- en: Visualizing LOESS predictions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化LOESS预测
- en: In chapter 8, you learned the basic principles of working with data frames in
    Julia provided by the DataFrames.jl package, and we started to analyze the Lichess
    chess puzzle data. Recall that our objective was to identify the relationship
    between puzzle difficulty and popularity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，您学习了使用DataFrames.jl包在Julia中处理数据框的基本原则，并且我们开始分析Lichess棋盘数据。回想一下，我们的目标是确定谜题难度与受欢迎程度之间的关系。
- en: In section 8.3, we stopped our investigation by concluding that we would like
    to clean the original data before performing its final analysis (in figure 9.1,
    I reproduce the histograms we used in chapter 8 to conclude that the original
    data is significantly skewed). The simplest form of data cleaning is removing
    the unwanted observations. Therefore, in this chapter, you will learn how to get
    data from a data frame by subsetting its rows and selecting columns.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.3节中，我们通过得出结论，我们希望在最终分析（如图9.1所示，我重现了第8章中使用的直方图）之前清理原始数据来停止我们的调查，即原始数据具有显著偏斜。数据清理的最简单形式是删除不需要的观测值。因此，在本章中，您将学习如何通过子集数据框的行和选择列来获取数据。
- en: 'Our goal in this chapter is to check the relationship between the puzzle difficulty
    and how much users like it. To perform this analysis, we will take the following
    steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是检查谜题难度与用户喜爱程度之间的关系。为了进行这项分析，我们将采取以下步骤：
- en: Subset the data set to concentrate only on columns and rows that we want to
    analyze later.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集子集化，仅关注我们想要稍后分析的列和行。
- en: Aggregate data about the relationship between puzzle difficulty and popularity
    in a data frame and plot it.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据框中聚合关于谜题难度与受欢迎程度之间关系的数据并绘制它。
- en: Build a local linear regression (LOESS) to obtain better summary information
    about relationships present in the data.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立局部线性回归（LOESS）模型以获取关于数据中存在的关系的更好总结信息。
- en: Through this analysis, the key skill that you will obtain after studying this
    chapter is learning various ways for indexing into a data frame.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次分析，您将在学习本章后获得的关键技能是学习各种进入数据框的方法。
- en: Data frame *indexing*—selecting some of its columns or subsetting rows—is one
    of the most often needed operations in practice. Therefore, learning how to index
    into a data frame is a good starting point in your journey with DataFrames.jl.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框索引——选择其部分列或子集行——是实践中最常需要的操作之一。因此，学习如何在数据框中进行索引是您使用DataFrames.jl进行数据框之旅的一个良好起点。
- en: 'To accomplish this goal, and at the same time show you how to perform the analysis
    of the Lichess puzzle, I organized this chapter as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，同时向您展示如何分析Lichess谜题，我按照以下结构组织了本章：
- en: In section 9.1, I discuss in depth multiple ways to index into a data frame
    by subsetting its rows and/or selecting columns.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第9.1节中，我深入讨论了通过子集数据框的行和/或选择列来索引数据框的多种方法。
- en: To reinforce your learning, in section 9.2, I do not introduce any new concepts
    but show how knowledge introduced in chapter 8 and section 9.1 can be combined
    in a more complex scenario. As a final step in this section, we will build a LOESS
    model to understand the relationship between puzzle difficulty and popularity
    in the Lichess database.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了加强您的学习，在第9.2节中，我不介绍任何新概念，而是展示如何在第8章和第9.1节中介绍的知识在更复杂的场景中结合起来。在本节的最后一步，我们将构建一个LOESS模型来理解Lichess数据库中谜题难度与受欢迎程度之间的关系。
- en: 9.1 Advanced data frame indexing
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 高级数据框索引
- en: In this section, you will learn how to perform column selection and row subsetting
    in a data frame. This is one of the most common operations when working with data
    frames.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在数据框中执行列选择和行子集。这是处理数据框时最常见的操作之一。
- en: Figure 8.2, reproduced here as figure 9.1 for your convenience, shows that the
    data we are working with is significantly skewed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2，在此处作为方便您查看的图9.1重现，显示我们正在处理的数据具有显著偏斜。
- en: 'Before continuing with the analysis of the relationship of the Rating and Popularity
    columns, let’s apply the following conditions to our data frame to create a new
    one that we will use later in the analysis:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续分析评分和受欢迎程度列之间的关系之前，让我们将以下条件应用到我们的数据框中，以创建一个我们将用于后续分析的新的数据框：
- en: We want to keep only the Rating and Popularity columns, as these are the only
    columns we will need for the analysis.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只想保留Rating和Popularity列，因为这些是我们分析所需的唯一列。
- en: We want to drop rows representing puzzles that we do not want to include in
    the analysis.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望删除代表我们不希望包含在分析中的谜题的行。
- en: Let’s now discuss the conditions that the puzzle must meet to be included in
    our analysis.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论谜题必须满足的条件才能被包含在我们的分析中。
- en: '![CH09_F01_Kaminski2](../Images/CH09_F01_Kaminski2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Kaminski2](../Images/CH09_F01_Kaminski2.png)'
- en: Figure 9.1 These histograms of the Rating, RatingDeviation, Popularity, and
    NbPlays columns from the puzzles data frame show that all the analyzed variables
    are skewed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 从puzzles数据框的Rating、RatingDeviation、Popularity和NbPlays列的直方图中可以看出，所有分析变量都是偏斜的。
- en: First, we want to keep puzzles that were played enough times. Therefore, we
    focus on those puzzles for which the number of plays, NbPlays, is greater than
    the median of that column. This condition will eliminate 50% of puzzles. In this
    way, we remove puzzles that were not played much, as they might not have a stable
    value for their rating or popularity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望保留被玩得足够的谜题。因此，我们关注那些NbPlays列中的播放次数大于该列中位数的谜题。这个条件将消除50%的谜题。这样，我们去除那些玩得很少的谜题，因为它们可能没有稳定的评分或流行度值。
- en: Second, we want to drop puzzles with low or very high difficulty ratings. This
    removes easy puzzles, which are most likely evaluated by inexperienced players,
    as well as very hard puzzles for which typical players might not have enough experience
    to fairly evaluate them. We will consider puzzles having ratings less than 1500
    as too easy to be included. I chose 1500 as a threshold since this is the starting
    rating of any puzzle. In listing 8.2, you can see that the median and mean of
    ratings are around 1500\. To indicate a very high rating, we use the 99th percentile
    (we will drop 1% of the hardest puzzles).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们希望删除难度评分低或非常高的谜题。这会去除简单的谜题，这些谜题很可能是经验不足的玩家评估的，以及对于典型玩家来说可能没有足够经验来公正评估的非常难的谜题。我们将考虑评分低于1500的谜题为过于简单，不适合包含。我选择1500作为阈值，因为这是任何谜题的起始评分。在列表8.2中，你可以看到评分的中位数和平均值大约是1500。为了表示一个非常高的评分，我们使用第99百分位数（我们将删除最难的1%的谜题）。
- en: This section is organized as follows. In section 9.1.1, I show you how to perform
    the exact operation that we want to do to analyze the Lichess puzzle data. In
    this way, you will get an idea of how these operations work. Next, in subsection
    9.1.2, I will give you a complete list of allowed column selectors, and in subsection
    9.1.3, we will discuss a complete list of allowed row-subsetting options.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节组织如下。在9.1.1节中，我将向你展示如何执行我们想要分析Lichess谜题数据的确切操作。这样，你将了解这些操作是如何工作的。接下来，在9.1.2小节中，我将提供一个允许的列选择器的完整列表，而在9.1.3小节中，我们将讨论允许的行子集选项的完整列表。
- en: note Before working with code from this chapter, follow the instructions in
    section 8.1 to make sure that you have the puzzles.csv file present in your working
    directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在处理本章的代码之前，请按照第8.1节的说明操作，以确保你的工作目录中存在puzzles.csv文件。
- en: 'Before we start, we need to load the libraries and create the puzzles data
    frame object from the puzzles.csv file that we created in chapter 8:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要加载库并从我们在第8章中创建的puzzles.csv文件创建puzzles数据框对象：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 9.1.1 Getting a reduced puzzles data frame
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 获取简化的puzzles数据框
- en: In this section, you will learn how to select columns of a data frame and subset
    its rows. To get our processed data frame, we need to define a proper column selector
    and row selector.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何选择数据框的列和子集其行。为了获取我们的处理后的数据框，我们需要定义一个合适的列选择器和行选择器。
- en: 'We start with the column selector, as in this case, it is simple. We can just
    pass a vector of column names like this: ["Rating", "Popularity"]. Alternatively,
    we could have passed the column names as symbols, [:Rating, :Popularity], or,
    for example, as integers [4, 6]. (Remember that you can easily check a column
    number by using the columnindex function.) In section 9.1.2, you will learn more
    column selector options that DataFrames.jl offers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从列选择器开始，因为在这种情况下，它是简单的。我们可以传递一个列名向量，例如：["Rating", "Popularity"]。或者，我们也可以传递列名作为符号，[:Rating,
    :Popularity]，或者，例如，作为整数[4, 6]。（记住，你可以通过使用columnindex函数轻松检查列号。）在9.1.2节中，你将了解DataFrames.jl提供的更多列选择器选项。
- en: To define a proper row-subsetting operation, we will use the *indicator vector*.
    This vector must have as many elements as we have rows in our data frame and must
    contain Bool values. Rows corresponding to true values in the indicator vector
    are kept, and the false values are dropped.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义适当的行子集操作，我们将使用 *指示向量*。这个向量必须与我们数据框中的行数一样多，并且必须包含布尔值。指示向量中对应于真值的行将被保留，而假值将被删除。
- en: 'First, we create an indicator vector of rows with the number of plays less
    than the median by using the median function from the Statistics module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 Statistics 模块中的 median 函数创建一个表示播放次数少于中值的行的指示向量：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that we use broadcasting when we write .> to compare the NbPlays column
    to a scalar value of a computed median. If we were to omit the dot (.), we would
    get an error:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们用 .> 比较 NbPlays 列与计算出的中值的标量值时，我们使用了广播。如果我们省略点（.），我们会得到一个错误：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a similar way, let’s create an indicator vector of puzzles whose rating
    is between 1500 and the 99th percentile. For the second condition, we use the
    quantile function from the Statistics module:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，让我们创建一个表示评分在 1500 到第 99 个百分位数之间的谜题的指示向量。对于第二种条件，我们使用 Statistics 模块中的
    quantile 函数：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have used broadcasting again to get the desired result. Finally, let’s combine
    both conditions by using the broadcasted && operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了广播来得到期望的结果。最后，让我们使用广播的 && 操作符结合这两个条件：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this expression, I could have omitted the parentheses, but my personal preference
    leads me to always explicitly show how operations should be grouped together when
    working with complex conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，我可以省略括号，但我的个人偏好是始终在工作于复杂条件时明确显示操作应该如何分组。
- en: 'Let’s check how many rows we selected. We can use either the sum or the count
    function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们选择了多少行。我们可以使用 sum 或 count 函数：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The difference between the sum and the count functions is that count requires
    that the data passed to it is Boolean and counts the number of true values, while
    sum can process any data for which addition is meaningfully defined. Since in
    Julia, Bool values are treated as numbers, as you learned in chapter 2, you can
    add them. In such an addition, true is considered to be 1 and false to be 0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: sum 函数和 count 函数之间的区别在于，count 要求传递给它的数据是布尔值，并计算真值的数量，而 sum 可以处理任何对加法有意义的定义的数据。由于在
    Julia 中，布尔值被视为数字，正如你在第 2 章中学到的，你可以将它们相加。在这种加法中，true 被认为是 1，false 被认为是 0。
- en: We are now ready to create our desired data frame in the next listing. We’ll
    call it good.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在下一个列表中创建我们所需的数据框了。我们将它称为 good。
- en: Listing 9.1 Selecting rows and columns of a data frame by using indexing
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 通过索引选择数据框的行和列
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that the good data frame has 513,357 rows and two columns as expected.
    Let’s create the histograms of the selected columns (figure 9.2) to see if they
    have a better distribution now:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，good 数据框有 513,357 行和两列，正如预期的那样。让我们创建所选列的直方图（图 9.2），看看它们现在是否有更好的分布：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![CH09_F02_Kaminski2](../Images/CH09_F02_Kaminski2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Kaminski2](../Images/CH09_F02_Kaminski2.png)'
- en: Figure 9.2 In these histograms of the columns Rating and Popularity from the
    good data frame, the distributions of both variables follow the expectations,
    and we will use this data in our further analysis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 在 good 数据框的列 Rating 和 Popularity 的这些直方图中，两个变量的分布都符合预期，我们将在进一步的分析中使用这些数据。
- en: The rating distribution is now roughly decreasing; we have fewer difficult puzzles
    than easy puzzles. For the distribution of popularity, we do not have peaks at
    -100 and 100 as in figure 8.2, which were most likely caused by puzzles that have
    not been played much. Please check this hypothesis as an exercise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 评分分布现在大致呈下降趋势；我们比简单谜题有更少的困难谜题。对于流行度的分布，我们没有在 -100 和 100 处出现峰值，如图 8.2 所示，这很可能是由于玩得很少的谜题造成的。请将此假设作为练习进行检查。
- en: Exercise 9.1 Calculate summary statistics of the NbPlays column under two conditions.
    In the first, select only puzzles that have popularity equal to 100, and in the
    second, select puzzles that have popularity equal to -100\. To calculate the summary
    statistics of a vector, use the summarystats function from the StatsBase.jl package.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.1 在两种条件下计算 NbPlays 列的摘要统计量。在第一种情况下，仅选择流行度为 100 的谜题，在第二种情况下，选择流行度为 -100
    的谜题。要计算向量的摘要统计量，请使用 StatsBase.jl 包中的 summarystats 函数。
- en: 9.1.2 Overview of allowed column selectors
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 允许的列选择器概述
- en: In practice, you might want to select columns of a data frame by using different
    conditions—for example, keep all columns except several that you do not want,
    or keep all columns whose name matches a particular pattern. In this section,
    you will learn that DataFrames.jl provides a rich set of column selectors that
    allow you to easily accomplish such tasks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能希望使用不同的条件来选择数据框的列——例如，保留所有你不想保留的列，或者保留所有名称与特定模式匹配的列。在本节中，你将了解到DataFrames.jl提供了一套丰富的列选择器，允许你轻松完成此类任务。
- en: 'You learned in section 8.3 that passing a string, a Symbol, or an integer as
    a column selector extracts a column from a data frame. These three column selectors
    are called *single-column selectors*. The type of the obtained result depends
    on the row selector used. If it is a single integer, you get the value stored
    in the cell of a data frame:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第8.3节中学到，传递一个字符串、一个Symbol或一个整数作为列选择器可以从数据框中提取一个列。这三个列选择器被称为*单列选择器*。获得的结果类型取决于所使用的行选择器。如果你使用单个整数，你会得到数据框单元格中存储的值：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If a row selector picks multiple rows, you get a vector. Let’s repeat an example
    you already saw in section 8.3:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果行选择器选择了多行，你会得到一个向量。让我们重复一下你在第8.3节中已经看到过的例子：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All other selectors we will discuss select multiple columns. The type of the
    obtained result again depends on the row-subsetting value used. If you pick a
    single row, you get an object called DataFrameRow:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的所有其他选择器都选择多列。获得的结果类型再次取决于所使用的行子集值。如果你选择单行，你会得到一个名为DataFrameRow的对象：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can think of DataFrameRow as a NamedTuple containing the selected cells.
    The only difference is that DataFrameRow retains a link to the data frame it was
    taken from. Technically, it is a view. Therefore, when the data frame is updated,
    it is reflected in the DataFrameRow. Conversely, if you update the DataFrameRow,
    the underlying data frame would also be updated (we will discuss mutation of data
    frames in detail in chapter 12).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将DataFrameRow视为一个包含所选单元格的NamedTuple。唯一的区别是DataFrameRow保留了一个指向它所来自的数据框的链接。技术上，它是一个视图。因此，当数据框更新时，它会在DataFrameRow中反映出来。相反，如果你更新DataFrameRow，底层数据框也会更新（我们将在第12章详细讨论数据框的突变）。
- en: Some users are surprised that using normal indexing creates a view in this case.
    However, this design choice, after a hot debate, was made to ensure that getting
    a row of a data frame is a fast operation, as typically you pick many consecutive
    rows of a data frame in a loop and only read data from them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户可能会惊讶，在这种情况下使用常规索引会创建一个视图。然而，经过一番激烈的辩论后，这个设计选择被做出，以确保获取数据框的行是一个快速操作，因为通常你会在循环中挑选数据框的许多连续行，并且只从它们中读取数据。
- en: 'For now, as I have said, you can think of DataFrameRow as a single-dimensional
    object. Therefore, you can get data from it exactly as from a data frame, but
    just using a single index if you use indexing. Here are the ways to get a Rating
    value from the row1 object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，正如我所说的，你可以将DataFrameRow视为一个一维对象。因此，你可以像从数据框中获取数据一样从它那里获取数据，但如果你使用索引，只需使用单个索引。以下是从row1对象获取评分值的方法：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the other hand, if you select multiple rows and multiple columns, you get
    a DataFrame. You have already seen this kind of selection in listing 9.1:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你选择多行和多列，你会得到一个DataFrame。你已经在列表9.1中看到了这种选择类型：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Table 9.1 summarizes the possible output types of data frame indexing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1总结了数据框索引的可能输出类型。
- en: Table 9.1 Output types of data frame indexing, depending on the row subsetting
    value and column selector
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 数据框索引的输出类型，取决于行子集值和列选择器
- en: '|  | Single-column selector | Multiple-column selector |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  | 单列选择器 | 多列选择器 |'
- en: '| Single-row subsetting | good[1, "Rating"]Value stored in a cell | good[1,
    :]DataFrameRow |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 单行子集 | good[1, "Rating"]单元格中存储的值 | good[1, :]DataFrameRow |'
- en: '| Multiple-row subsetting | good[:, "Rating"]A vector | good[:, :]DataFrame
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 多行子集 | good[:, "Rating"]向量 | good[:, :]DataFrame |'
- en: Now that you now know the output types that you can expect, given different
    column selectors, we are ready to dive into the available multiple column selectors.
    We have a lot of them, as many rules exist for selecting columns. I will list
    them one by one with examples, referring to our puzzles data frame.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了在给定不同的列选择器时可以期望的输出类型，我们就可以深入探讨可用的多列选择器了。我们有很多这样的选择器，因为存在许多选择列的规则。我将逐一列举它们，并附上例子，参考我们的puzzles数据框。
- en: 'I’ll first show you the list of available options so that you have a brief
    reference to them. Next, I explain how you can check which columns are selected
    by each of them, using the names function. We start with the list:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先会向你展示可用的选项列表，这样你就可以简要地参考它们。接下来，我将解释如何使用 names 函数检查每个选项所选择的列，我们从列表开始：
- en: '*A vector of string,* Symbol*, or integer values*—You have already seen this
    style in section 8.3: ["Rating", "Popularity"], [:Rating, :Popularity], [4, 6].'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个字符串、符号或整数值的向量*——你已经在第8.3节中看到了这种风格：["Rating", "Popularity"], [:Rating, :Popularity],
    [4, 6]。'
- en: '*A vector of Boolean values that has a length equal to the data frame’s number
    of columns*—Here, to select the columns Rating and Popularity, an appropriate
    vector would be the following (note that it has length 9 and has a true value
    in positions 4 and 6):'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个长度等于数据框列数的布尔值向量*——在这里，要选择 Rating 和 Popularity 列，一个合适的向量如下（注意它长度为9，并在第4位和第6位有
    true 值）：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*A regular expression*—This selects columns matching the passed expression
    (we discussed regular expressions in chapter 6). For example, passing an r"Rating"
    regular expression would pick columns Rating and RatingDeviation.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*——这会选择与传递的表达式匹配的列（我们在第6章讨论了正则表达式）。例如，传递一个 r"Rating" 正则表达式将选择 Rating
    和 RatingDeviation 列。'
- en: '*A* Not *expression*—This negates the passed selector. For example, Not([4,
    6]) would select all columns except columns 4 and 6; similarly, Not(r"Rating")
    would pick all columns except Rating and RatingDeviation that match the r"Rating"
    regular expression.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个* Not *表达式*——这会否定传递的选择器。例如，Not([4, 6]) 将选择除了第4列和第6列之外的所有列；同样，Not(r"Rating")
    将选择除了匹配 r"Rating" 正则表达式的 Rating 和 RatingDeviation 列之外的所有列。'
- en: A Between expression—An example is Between("Rating", "Popularity"), which fetches
    consecutive columns starting from Rating and ending with Popularity, so in our
    case, it would be Rating, RatingDeviation, and Popularity.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Between 表达式——一个例子是 Between("Rating", "Popularity")，它从 Rating 开始并结束于 Popularity
    的连续列，因此在我们的情况下，它将是 Rating、RatingDeviation 和 Popularity。
- en: A colon (:) or All() selector—This selects all columns.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号（:）或 All() 选择器——这会选择所有列。
- en: A Cols selector—This has two forms. In the first one, you can pass multiple
    selectors as arguments and select their union; for example, Cols(r"Rating", "NbPlays")
    would select columns Rating, RatingDeviation, and NbPlays. In the second form,
    you pass a function as an argument to Cols; then this function should accept a
    string that is the name of the column and return a Boolean value. As a result,
    you will get the list of columns for which the passed function returns true. For
    example, if you use the Cols(startswith ("P")) selector, you would get PuzzleId
    and Popularity columns, as these are the only columns in the puzzles data frame
    whose names start with P.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cols 选择器——这有两种形式。在第一种形式中，你可以将多个选择器作为参数传递并选择它们的并集；例如，Cols(r"Rating", "NbPlays")
    将选择 Rating、RatingDeviation 和 NbPlays 列。在第二种形式中，你将函数作为参数传递给 Cols；然后这个函数应该接受一个字符串，它是列的名称，并返回一个布尔值。结果，你将得到一个列表，其中包含传递的函数返回
    true 的列。例如，如果你使用 Cols(startswith ("P")) 选择器，你会得到 PuzzleId 和 Popularity 列，因为这些是唯一以
    P 开头的 puzzles 数据框中的列名。
- en: This was exhausting. Fortunately, as I have hinted, there is an easy way to
    test all of these examples.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常累人。幸运的是，正如我暗示的，有一个简单的方法来测试所有这些例子。
- en: 'Do you remember the names function discussed in section 8.2? It returns the
    column names stored in the data frame. Often you need to pick column names from
    a data frame without performing data frame indexing. The nice thing about the
    names function is that it can take any column selector as its second argument
    and will return the names of the selected columns. Let’s try the names function
    with all the examples in the preceding list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在第8.2节中讨论的 names 函数吗？它返回数据框中存储的列名。通常你需要从数据框中选择列名而不执行数据框索引。names 函数的好处是它可以接受任何列选择器作为其第二个参数，并将返回所选列的名称。让我们尝试使用
    names 函数与前面列表中的所有示例：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is not everything that the names function has in its store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是 names 函数所拥有的全部功能。
- en: First, instead of writing names(puzzles, Cols(startswith("P"))), you can omit
    the Cols wrapper. The call to names(puzzles, startswith("P")), where you pass
    a function taking a string and returning a Boolean value, will produce the same
    result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你不必写 names(puzzles, Cols(startswith("P")))，你可以省略 Cols 包装器。调用 names(puzzles,
    startswith("P"))，其中你传递一个接受字符串并返回布尔值的函数，将产生相同的结果。
- en: 'The final feature is that you can pass a type as a second argument to the names
    function. You will get columns whose element type is a subtype of the passed type.
    For example, to get all columns that store real numbers in our puzzles data frame,
    you can write this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个特性是，你可以将类型作为names函数的第二个参数传递。你将得到元素类型是传递类型子类型的列。例如，要获取存储在puzzles数据框中所有实数列，你可以编写以下内容：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And to get all columns holding strings, write this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有包含字符串的列，请编写以下内容：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the last two forms accepted in names (passing a function and passing
    a type) are not accepted in indexing. Therefore, to select all columns storing
    real numbers from the puzzles data frame, write puzzles[:, names(puzzles, Real)].
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，names中最后两种接受的形式（传递函数和传递类型）在索引中不被接受。因此，要从puzzles数据框中选择所有存储实数的列，请编写puzzles[:,
    names(puzzles, Real)]。
- en: You now have all the power of flexible selection of data frame columns at your
    fingertips. We can move on to row selectors, which are a bit simpler.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在指尖上拥有灵活选择数据框列的所有功能。我们可以继续到行选择器，它们稍微简单一些。
- en: 9.1.3 Overview of allowed row-subsetting values
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 允许的行子集值概述
- en: In this section, you will learn the options for performing row subsetting of
    a data frame. In subsection 9.1.2, we discussed passing a single integer as a
    row-subsetting value. You get either a value of a single cell (if a single-column
    selector is used) or a DataFrameRow (if a multiple-column selector is used).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习执行数据框行子集的选项。在第9.1.2小节中，我们讨论了传递单个整数作为行子集值。如果你使用单列选择器，你将得到单个单元格的值；如果你使用多列选择器，你将得到DataFrameRow。
- en: 'When you select multiple rows, you get either a vector (when a single column
    is picked) or a data frame (when multiple columns are selected). Which multiple-row
    selectors are allowed? Here is a complete list:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择多行时，你会得到一个向量（当选择单个列时）或数据框（当选择多个列时）。哪些多行选择器是被允许的？以下是一个完整的列表：
- en: '*A vector of integers*—For example, [1, 2, 3] will pick rows corresponding
    to the passed-in numbers.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数向量*—例如，[1, 2, 3]将选择与传入的数字对应的行。'
- en: '*A vector of Boolean values*—Its length must be equal to the number of rows
    in a data frame, and in the result, you get rows for which the vector contains
    true. You saw this selector in section 8.3; for example, in the expression puzzles[row_selector,
    ["Rating", "Popularity"]] in listing 9.1, the row_selector is a Boolean vector.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔值向量*—其长度必须等于数据框中的行数，在结果中，你将得到向量包含true的行。你在第8.3节中看到了这个选择器；例如，在列表9.1中的表达式puzzles[row_selector,
    ["Rating", "Popularity"]]中，row_selector是一个布尔向量。'
- en: '*A* Not *expression*—This works in the same way as for columns. Writing Not([1,
    2, 3]) will pick all rows except rows 1, 2, and 3.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非* 表达式—这与列的工作方式相同。编写Not([1, 2, 3])将选择除了第1行、第2行和第3行之外的所有行。'
- en: '*A colon* (:)—This picks all rows from a data frame with copying.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冒号* (:)—这会选择数据框中的所有行并进行复制。'
- en: '*An exclamation mark* (!)—This picks all rows from a data frame without copying
    (remember the warning in section 8.2 that you should use this option with care,
    as it can lead to hard-to-catch bugs).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*感叹号* (!)—这会从数据框中选择所有行而不进行复制（记住第8.2节中的警告，你应该小心使用此选项，因为它可能导致难以发现的错误）。'
- en: 'First, let’s look at a comparison of integer, Boolean, and Not selectors on
    a small data frame. In the example, we first create the df_small data frame with
    a single column named :id and values in the range from 1 to 4 (we will discuss
    this and other ways to create a data frame in detail in chapter 10). Next, we
    subset this data frame by using various row selectors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们比较整数、布尔和Not选择器在一个小数据框上的效果。在示例中，我们首先创建名为:id的单列df_small数据框，其值在1到4的范围内（我们将在第10章中详细讨论创建数据框的这种方法和其他方法）。接下来，我们使用各种行选择器对这个数据框进行子集化：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the example, all indexing operations keep rows number 1 and 3 from the df_small
    data frame.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，所有索引操作都保留了df_small数据框的第1行和第3行。
- en: 'Next, let’s look at an example comparing the : and ! row selectors. Let’s compare
    the following selection operations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看比较:和!行选择器的示例。让我们比较以下选择操作：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Both df1 and df2 pick all rows and two columns from the puzzles data frame.
    We can check whether they store the same data:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: df1和df2都从puzzles数据框中选择所有行和两列。我们可以检查它们是否存储相同的数据：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Although df1 and df2 share the same contents, they are not identical. The difference
    is that df1 has copied the Rating and Popularity columns, while df2 reuses the
    Rating and Popularity columns from the puzzles data frame. We can easily check
    it by using the === comparison:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然df1和df2具有相同的内容，但它们并不相同。区别在于df1复制了Rating和Popularity列，而df2则重用了来自puzzles数据框的Rating和Popularity列。我们可以通过使用===比较来轻松检查它：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Therefore, mutating the df2 data frame later could affect the data stored in
    the puzzles data frame, which is unsafe. Again, the benefit of using ! over :
    is speed and memory consumption, as we can see in the following benchmark:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，稍后修改df2数据框可能会影响存储在puzzles数据框中的数据，这是不安全的。再次强调，使用!而不是:的好处是速度和内存消耗，如下面的基准测试所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a wrap-up, I’ll summarize the available options again. Remember that passing
    an integer like 1 selects a single row or column, while passing a vector wrapping
    it like [1] selects multiple rows or columns (which happen to be 1 in this case).
    Therefore, we have four options for indexing to a data frame, differing in the
    obtained result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为总结，我将再次总结可用的选项。请记住，传递一个整数，如1，可以选择单个行或列，而传递一个包含它的向量，如[1]，可以选择多个行或列（在这种情况下恰好是1）。因此，我们有四种索引到数据框的方法，它们在获得的结果上有所不同：
- en: 'Passing single-element selectors for both row and column indices returns the
    contents of a single cell of a data frame:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于行和列索引都传递单元素选择器，返回数据框的单个单元格内容：
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Passing a multirow subsetting value and a single-column selector returns a
    vector:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个多行子集值和一个单列选择器返回一个向量：
- en: '[PRE23]'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Passing a single-row subsetting value and a multicolumn selector returns a
    DataFrameRow:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个单行子集值和多列选择器返回一个DataFrameRow：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Passing a multirow subsetting value and a multicolumn selector returns a DataFrame:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个多行子集值和多列选择器返回一个DataFrame：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Data frame row names
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框行名
- en: You might have noticed that DataFrames.jl does not support providing row names
    for your DataFrame objects. The only way to refer to a data frame’s row is by
    its number.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到DataFrames.jl不支持为你的DataFrame对象提供行名。引用数据框的行的唯一方式是通过其编号。
- en: However, it is easy to add a column to your data frame that stores row names.
    Row names are often used in other ecosystems to provide a way to perform a fast
    row lookup. In chapters 11, 12, and 13, you will learn that DataFrames.jl delivers
    this functionality by using an alternative approach based on the groupby function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很容易向你的数据框中添加一个存储行名的列。行名常在其他生态系统中用于提供一种快速行查找的方式。在第11、12和13章中，你将了解到DataFrames.jl通过使用基于groupby函数的替代方法来提供这种功能。
- en: 9.1.4 Making views of data frame objects
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 创建数据框对象的视图
- en: In chapter 4, you learned that you can use the @view macro to create views into
    arrays that avoid copying the data. The same mechanism is supported in DataFrames.jl.
    If you pass any indexing expression to a @view macro, you get a view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你了解到可以使用@view宏创建避免复制数据的数组视图。在DataFrames.jl中也支持相同的机制。如果你将任何索引表达式传递给@view宏，你将得到一个视图。
- en: The benefit of creating a view is that it is, in general, faster and uses less
    memory than the standard indexing discussed in section 9.1.3\. However, this benefit
    comes at a cost. A view shares data with the parent object, which can lead to
    hard-to-catch bugs in your code, especially if you modify the data that the view
    references.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图的好处是，通常它比第9.1.3节中讨论的标准索引更快，使用的内存更少。然而，这种好处是有代价的。视图与父对象共享数据，这可能导致代码中难以捕捉的bug，尤其是如果你修改了视图引用的数据。
- en: 'You have four options for making a view of a data frame, depending on whether
    row and column selectors pick one or multiple rows, as discussed in subsection
    9.1.3:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你有四种方法来创建数据框的视图，这取决于行和列选择器是否选择一个或多个行，如第9.1.3小节所述：
- en: 'Passing single-element selectors for both row and column indices returns a
    view to the contents of a single cell of a data frame (technically, as you can
    see, it is considered a zero-dimensional object; if you want to learn more about
    these, refer to the “Frequently Asked Questions” section of the Julia manual at
    [http://mng.bz/9VKq](http://mng.bz/9VKq)):'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于行和列索引都传递单元素选择器，返回数据框单个单元格内容的视图（技术上，如你所见，它被认为是一个零维对象；如果你想了解更多关于这些的信息，请参阅Julia手册的“常见问题解答”部分，网址为[http://mng.bz/9VKq](http://mng.bz/9VKq)）：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Passing a multirow selector and single column selector returns a view into
    a vector:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个多行选择器和单列选择器返回一个向量的视图：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Passing a single-row selector and multicolumn selector returns a DataFrameRow
    (so there is no difference from puzzles[1, [1]], as normal indexing already produces
    a view; see the discussion in subsection 9.1.2):'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单行选择器和多列选择器返回一个DataFrameRow（因此与puzzles[1, [1]]的正常索引没有区别，因为正常索引已经产生了一个视图；参见9.1.2小节中的讨论）：
- en: '[PRE28]'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Passing a multirow and multicolumn selector returns a SubDataFrame:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多行和多列选择器返回一个子数据框：
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Out of these options, the most frequently used one is creating a SubDataFrame.
    You use a view of a data frame when you want to save memory and time, and you
    accept that your resulting object will reuse the memory with its parent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选项中，最常用的是创建一个子数据框。当你想要节省内存和时间时，你会使用数据框的视图，并且接受你的结果对象将与其父对象共享内存。
- en: 'As an example, let’s compare the performance of the operation puzzles[row_selector,
    ["Rating", "Popularity"]] that we did in listing 9.1 against the same operation
    creating a view:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们比较一下我们在9.1小节中列出的操作puzzles[row_selector, ["Rating", "Popularity"]]的性能与创建视图的相同操作：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Creating a view is faster and uses less memory. The biggest allocations that
    we see when creating a view of a data frame are for storing information about
    the selected rows and columns. You can retrieve the indices of the source data
    frame that are picked by a SubDataFrame by using the parentindices function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图更快且占用更少的内存。我们在创建数据框视图时看到的最大分配是为存储所选行和列的信息。你可以使用parentindices函数检索由子数据框选择的源数据框的索引：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What is a data frame?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是数据框？
- en: 'You now know that DataFrames.jl defines the DataFrame and SubDataFrame types.
    These two types have a common supertype: AbstractDataFrame. The AbstractDataFrame
    represents a general concept of a data frame in DataFrames.jl, independent of
    its underlying representation in memory.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道DataFrames.jl定义了DataFrame和子数据框类型。这两个类型有一个共同的超类型：AbstractDataFrame。AbstractDataFrame在DataFrames.jl中表示数据框的一般概念，与其在内存中的底层表示无关。
- en: Most of the functions in DataFrames.jl work with AbstractDataFrame objects,
    so they accept both the DataFrame and SubDataFrame types In these cases. In this
    book, I write that we work with a data frame. For example, the indexing that we
    used in this chapter works in the same way for all data frames.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrames.jl中的大多数函数都适用于AbstractDataFrame对象，因此在这些情况下它们接受DataFrame和子数据框类型。在这本书中，我写的是我们使用数据框。例如，我们在这章中使用的索引对所有数据框都按相同的方式工作。
- en: However, in some cases, it is important that we work with a concrete type. For
    example, the DataFrame constructor always returns a DataFrame. Also, in chapter
    11, we will discuss adding rows to a DataFrame in place by using the push! function.
    This operation is not supported by SubDataFrame objects since they are views.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们与具体类型一起工作是很重要的。例如，DataFrame构造函数始终返回一个DataFrame。此外，在第11章中，我们将讨论通过使用push!函数就地添加行到DataFrame。由于子数据框对象是视图，因此不支持此操作。
- en: 9.2 Analyzing the relationship between puzzle difficulty and popularity
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 分析谜题难度与流行度之间的关系
- en: As promised in the chapter introduction, in this section, we’ll use the skills
    that you have acquired in a more complex context to understand the relationship
    between puzzle difficulty and popularity. We’ll do it in two steps. In section
    9.2.1, we’ll calculate the mean popularity of puzzles by their rating. Next, in
    section 9.2.2, we’ll fit a LOESS regression to this data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如章节介绍中所承诺的，在本节中，我们将使用你在更复杂的环境中获得的技能来理解谜题难度与流行度之间的关系。我们将分两步进行。在9.2.1节中，我们将根据评分计算谜题的平均流行度。接下来，在9.2.2节中，我们将对数据进行LOESS回归拟合。
- en: 9.2.1 Calculating mean puzzle popularity by its rating
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 通过评分计算谜题的平均流行度
- en: In this section, you’ll learn how to aggregate data in a data frame by using
    functionalities from Base Julia. Aggregation is one of the most common operations
    needed for data analysis.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Base Julia的功能在数据框中聚合数据。聚合是数据分析中最常见的操作之一。
- en: 'We will use the good data frame that we created in listing 9.1\. The approach
    that we use in this section is intended to show you how to use indexing into a
    data frame. However, this is not the most efficient way to perform the analysis.
    At the end of this chapter, I will show you the code that accomplishes the required
    operation faster but requires learning more advanced features of the DataFrames.jl
    package related to the groupby function (these are discussed in chapters 11, 12,
    and 13). First, let’s recall the contents of the good data frame:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在第9.1节中创建的好数据框。本节中使用的这种方法旨在向您展示如何使用数据框的索引。然而，这并不是执行分析的最有效方法。在本章末尾，我将向您展示完成所需操作更快但需要学习与groupby函数相关的DataFrames.jl包的高级功能的代码（这些将在第11、12和13章中讨论）。首先，让我们回顾一下好数据框的内容：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For each unique value in the Rating column, we will want to calculate the average
    of the Popularity column. We will perform this task in two steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于评级列中的每个唯一值，我们希望计算流行度列的平均值。我们将分两步进行这项任务：
- en: Create a dictionary, mapping a given rating value to a vector of rows in the
    data frame where it can be found.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字典，将给定的评级值映射到数据框中可以找到的行向量。
- en: Use this dictionary to compute the average popularity per each unique value
    of rating.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个字典来计算每个唯一评级值的平均流行度。
- en: 'We start with the first task, creating a dictionary and mapping a rating to
    data frame rows where it can be found:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一个任务开始，创建一个字典并将评级映射到可以找到它的数据框行：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Creates an empty dictionary that will be used to store the mapping
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空字典，用于存储映射
- en: ❷ Iterates all elements of the good.Rating vector and keeps track of both the
    index and value of the iterated element
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历good.Rating向量的所有元素，并跟踪迭代元素的索引和值
- en: ❸ Checks whether we have already encountered a given rating value
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查我们是否已经遇到了给定的评级值
- en: ❹ If we have seen a given rating value, appends its index to an existing entry
    in the dictionary
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果我们看到了给定的评级值，则将其索引追加到字典中的现有条目
- en: ❺ If we have not seen a given rating value, creates a new entry in the dictionary
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果我们还没有看到给定的评级值，则在字典中创建一个新的条目
- en: Let’s review key parts of this code. The enumerate(good.Rating) expression used
    in a for loop yields (i, rating) tuples, where i is a counter starting at 1 and
    rating is the i-th value from the good.Rating vector. Using enumerate is useful
    when you need not only the values rating over which you are iterating, but also
    the number of iterations so far.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这段代码的关键部分。在for循环中使用的enumerate(good.Rating)表达式产生(i, rating)元组，其中i是一个从1开始的计数器，rating是从good.Rating向量中取出的第i个值。使用enumerate在您需要不仅迭代rating的值，还需要迭代次数时很有用。
- en: Next, we check whether the rating we get was seen previously. If we already
    have it in the rating_mapping dictionary, we retrieve the vector of indices mapped
    to this rating value and append at the end of this vector the row number i using
    the push! function. On the other hand, if we have not seen a given rating yet,
    we create a new entry in the dictionary that maps rating to a vector holding a
    single integer i.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查我们得到的评级是否之前已经出现过。如果我们已经在rating_mapping字典中有了它，我们就检索映射到这个评级值的索引向量，并使用push!函数将行号i添加到这个向量的末尾。另一方面，如果我们还没有看到给定的评级，我们就在字典中创建一个新的条目，将评级映射到一个只包含单个整数i的向量。
- en: 'Let’s try to get the rows of the good data frame for indices stored in the
    rating_ mapping dictionary for a rating equal to 2108:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试获取评级等于2108的rating_mapping字典中存储的行的数据框：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It seems we get only rows with the 2108 rating. We can make sure that this
    is the case by using the unique function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们只得到了具有2108评级的行。我们可以通过使用unique函数来确保这一点：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Indeed, only the 2108 value is in the Rating column in our selection.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在我们的选择中，只有2108这个值在评级列中。
- en: Exercise 9.2 Make sure that the values stored in the rating_mapping dictionary
    add up to represent all row indices of our good data frame. To do this, check
    whether the sum of lengths of these vectors is equal to the number of rows in
    the good data frame.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.2 确保存储在rating_mapping字典中的值加起来代表我们好数据框的所有行索引。为此，检查这些向量的长度之和是否等于好数据框中的行数。
- en: 'Computing the mean rating of our Popularity column for a 2108 rating is now
    easy:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2108评级计算我们的流行度列的平均评级现在变得容易：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we have all the pieces ready to create a plot, showing the relationship
    between rating and popularity of puzzles. First, create a vector of unique rating
    values by using the unique function again:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有必要的组件来创建一个图表，展示评分与谜题流行度之间的关系。首先，使用unique函数再次创建一个唯一评分值的向量：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we compute mean popularity per unique rating value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算每个唯一评分值的平均流行度：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you would like to refresh your understanding of how the map function works
    with the do-end block, see chapter 2\. To get the desired result, we could have
    used comprehension instead of the map function. It would be the following expression:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要刷新你对map函数如何在do-end块中工作的理解，请参阅第2章。为了得到期望的结果，我们本可以使用列表推导式而不是map函数。表达式如下：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: However, I prefer the solution using the map function as, in my opinion, the
    code is easier to understand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我更喜欢使用map函数的解决方案，因为在我看来，代码更容易理解。
- en: 'Finally, we can perform the desired plot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以执行所需的图表：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Figure 9.3 shows the result.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3显示了结果。
- en: '![CH09_F03_Kaminski2](../Images/CH09_F03_Kaminski2.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Kaminski2](../Images/CH09_F03_Kaminski2.png)'
- en: Figure 9.3 Plotting the relationship between a puzzle rating and its popularity
    shows that puzzles with a rating of around 1750 have the highest mean popularity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3展示了评分与流行度之间的关系，表明结果存在一些噪声。让我们创建一个图表，展示评分与平均流行度之间的平滑关系。为此，我们将使用一个流行的局部回归模型，称为LOESS。
- en: 9.2.2 Fitting LOESS regression
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 拟合LOESS回归
- en: In this section, you will learn how to fit the LOESS regression to your data
    and make predictions using the fitted model.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将LOESS回归拟合到你的数据中，并使用拟合的模型进行预测。
- en: The relationship presented in figure 9.3 shows that the results have some noise.
    Let’s create a plot showing a smoothed relationship between rating and mean popularity.
    For this, we will use a popular local regression model called LOESS.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3中呈现的关系表明结果存在一些噪声。让我们创建一个图表，展示评分与平均流行度之间的平滑关系。为此，我们将使用一个流行的局部回归模型，称为LOESS。
- en: LOESS regression
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: LOESS回归
- en: The locally estimated scatterplot smoothing (LOESS) model was originally developed
    for scatterplot smoothing. You can find more information about this method in
    “Computational Methods for Local Regression” by William S. Cleveland and E. Grosse
    ([https://doi.org/10.1007/BF01890836](https://doi.org/10.1007/BF01890836)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 局部估计散点图平滑（LOESS）模型最初是为散点图平滑开发的。你可以在William S. Cleveland和E. Grosse的《局部回归的计算方法》（[https://doi.org/10.1007/BF01890836](https://doi.org/10.1007/BF01890836)）中找到更多关于此方法的信息。
- en: In Julia, the Loess.jl package allows you to build LOESS regression models.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，Loess.jl包允许你构建LOESS回归模型。
- en: 'We’ll create a LOESS model, make a prediction using it, and add a line to our
    plot. First prepare the predictions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个LOESS模型，使用它进行预测，并在我们的图表中添加一条线。首先准备预测：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that to make a prediction, we first sort ratings by using the sort function.
    This is done to make a final plot look nice, as we want the points to be ordered
    on the x-axis. (As an alternative to sorting data, you can pass the serisetype=:line
    keyword argument to the plot function.) Additionally, we use the float function
    on the resulting vector. The reason is that the predict function accepts only
    vectors of floating-point numbers, and our original ratings vector contains integers,
    not floats.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了进行预测，我们首先使用sort函数对评分进行排序。这样做是为了使最终的图表看起来更美观，因为我们希望点在x轴上按顺序排列。（作为对排序数据的替代，你可以在plot函数中传递serisetype=:line关键字参数。）此外，我们对生成的向量使用float函数。原因是predict函数只接受浮点数向量，而我们的原始评分向量包含整数，不是浮点数。
- en: 'You can check which arguments the predict function accepts by running the methods
    function with predict as its argument:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行methods函数并将predict作为其参数来检查predict函数接受哪些参数：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the predict function has three methods. Each takes a trained
    model as a first argument, and the second argument can be a scalar, a vector,
    or a matrix. In all three methods, the restriction is that the elements of the
    second argument must be a subtype of AbstractFloat.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，predict函数有三个方法。每个方法都接受一个训练好的模型作为第一个参数，第二个参数可以是标量、向量或矩阵。在所有三种方法中，限制是第二个参数的元素必须是AbstractFloat的子类型。
- en: 'We are now ready to add a smoothed line to our plot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在我们的图表中添加一条平滑线：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that we use plot! to add an additional line to the already existing plot.
    The result is shown in figure 9.4.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用plot!来向已经存在的图表中添加额外的线。结果如图9.4所示。
- en: '![CH09_F04_Kaminski2](../Images/CH09_F04_Kaminski2.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F04_Kaminski2](../Images/CH09_F04_Kaminski2.png)'
- en: Figure 9.4 Adding a local regression plot to the relationship between a puzzle
    rating and its popularity confirms that the puzzles with the highest mean popularity
    have a rating of around 1750.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 将局部回归图添加到谜题评分与其流行度之间的关系中，证实了具有最高平均流行度的谜题评分为约 1750。
- en: From figure 9.4, we can see that the most popular puzzles have a rating of around
    1750, so if the puzzle is either too easy or too hard, its popularity is lower.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从图 9.4 中，我们可以看到最受欢迎的谜题的评分为约 1750，因此如果谜题要么太简单要么太难，其流行度就会较低。
- en: 'From a data science perspective, this analysis is, of course, a bit simplified:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据科学的角度来看，当然，这种分析有点简化：
- en: I have omitted that both ratings are measured with uncertainty (the RatingDeviation
    column measures it).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我省略了评分都带有不确定性（RatingDeviation 列测量它）的事实。
- en: Popularity is also based on only a sample of users’ responses.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行度也是基于用户响应样本的一部分。
- en: For different ratings, we have a different number of puzzles.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不同的评分，我们有不同数量的谜题。
- en: I have not optimized the smoothing in the LOESS model (this can be done using
    the span keyword argument in the Loess.loess function; see [https://github.com/JuliaStats/Loess.jl](https://github.com/JuliaStats/Loess.jl)).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我尚未优化 LOESS 模型中的平滑处理（这可以通过在 Loess.loess 函数中使用 span 关键字参数来完成；请参阅 [https://github.com/JuliaStats/Loess.jl](https://github.com/JuliaStats/Loess.jl)）。
- en: A more careful analysis could have taken all these factors into account, but
    I decided to omit such analysis to keep the example simple and concentrate on
    the topic of indexing that we cover in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细的分析可能会考虑所有这些因素，但我决定省略这种分析，以保持示例简单，并专注于本章中涵盖的索引主题。
- en: Exercise 9.3 Check the consequences of changing the value of the span keyword
    argument in the loess function. By default, this argument has the value 0.75\.
    Set it to 0.25 and add another prediction line to the plot presented in figure
    9.4\. Make the line yellow with its width equal to 5.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.3 检查在 loess 函数中更改 span 关键字参数值的影响。默认情况下，此参数的值为 0.75。将其设置为 0.25 并向图 9.4 所示的图中添加另一条预测线。使线条为黄色，宽度为
    5。
- en: 'As a last example in this chapter, as promised previously, let’s see how we
    could have used more advanced features of DataFrames.jl to aggregate the data
    for our analysis to get popularity means by rating:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最后一个例子，正如之前所承诺的，让我们看看我们如何可以使用 DataFrames.jl 的更高级功能来聚合我们的分析数据，以通过评分获取流行度平均值：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The exact rules for the meaning of this code and its execution are explained
    in chapters 11, 12, and 13\. I decided to show this code here to make it clear
    to you that the calculations using a dictionary in section 9.2.1 are not an idiomatic
    way to perform data aggregation in DataFrames.jl. Still, I wanted to present the
    low-level approach in that section as I believe it nicely explains how you can
    write more-complex data processing code using loops, dictionaries, and data frame
    indexing, as you might occasionally need to write such low-level code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此代码的意义及其执行的精确规则，请参阅第 11、12 和 13 章。我决定在这里展示此代码，以便让你清楚地知道，在第 9.2.1 节中使用字典进行的计算并不是在
    DataFrames.jl 中进行数据聚合的惯用方式。尽管如此，我还是想在那一节中展示低级方法，因为我相信它很好地解释了如何使用循环、字典和数据框索引编写更复杂的数据处理代码，正如你偶尔需要编写这样的低级代码一样。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Indexing into a data frame always requires passing both a row selector and column
    selector and has the general form data_frame[row_selector, column_selector]. This
    approach ensures that the person reading your code will immediately see what output
    to expect.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据框中进行索引始终需要传递行选择器和列选择器，其一般形式为 data_frame[row_selector, column_selector]。这种方法确保阅读你代码的人会立即看到预期的输出。
- en: DataFrames.jl defines a wide range of accepted column selectors that can be
    integers, strings, symbols, vectors, regular expressions, or :, Not, Between,
    Cols, or All expressions. This flexibility is needed as users often want to use
    complex patterns for column selection. Note that the 1 and [1] selectors are not
    equivalent. Although both refer to the first column, the first one extracts it
    from a data frame, while the second creates a data frame with this single column.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrames.jl 定义了一系列可接受的列选择器，可以是整数、字符串、符号、向量、正则表达式或 :, Not, Between, Cols, 或
    All 表达式。这种灵活性是必需的，因为用户经常希望使用复杂的模式进行列选择。请注意，1 和 [1] 选择器并不等价。尽管两者都指向第一列，但前者是从数据框中提取它，而后者则创建一个只包含这一列的数据框。
- en: To select rows of a data frame, you can use integers, vectors, and Not, :, and
    ! expressions. Similarly, column selectors 1 and [1] are not equivalent. The first
    one creates a DataFrameRow, while the second creates a data frame.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要选择数据框的行，您可以使用整数、向量、Not、: 和 ! 表达式。同样，列选择器 1 和 [1] 并不等效。第一个创建一个 DataFrameRow，而第二个创建一个数据框。'
- en: 'Both : and ! select all rows from a data frame. The difference between them
    is that : performs a copy of the vectors stored in the data frame, while ! reuses
    the vectors stored in the source data frame. Using ! is faster and uses less memory
    but can lead to hard-to-catch bugs, so I discourage it unless the user’s code
    is performance sensitive.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ': 和 ! 都会从数据框中选择所有行。它们之间的区别在于：: 会复制数据框中存储的向量，而 ! 会重用源数据框中存储的向量。使用 ! 更快且内存使用更少，但可能导致难以捕捉的bug，因此我建议除非用户的代码对性能敏感，否则不要使用它。'
- en: You can make views of DataFrame objects by using the @view macro exactly as
    you can for arrays. It is important to remember that views share memory with the
    parent object. Therefore, they are fast to create and do not use much memory,
    but at the same time, you need to be careful when mutating their contents. In
    particular, if you select a single row and multiple columns of a data frame, you
    get a DataFrameRow object that is a view into a single row of a data frame.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 @view 宏来创建 DataFrame 对象的视图，就像您为数组做的那样。重要的是要记住，视图与父对象共享内存。因此，它们创建速度快且内存使用量少，但在此同时，您在修改其内容时需要小心。特别是，如果您选择数据框的单行和多列，您将得到一个
    DataFrameRow 对象，它是数据框单行的视图。
- en: The == infix operator compares the contents of containers like vectors or data
    frames. The === operator can be used to check whether the compared objects are
    the same (in the most common case of mutable containers, this checks whether they
    are stored in the same memory location).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: == 中缀运算符比较容器（如向量或数据框）的内容。=== 运算符可以用来检查比较的对象是否相同（在可变容器最常见的案例中，这检查它们是否存储在相同的内存位置）。
- en: You can use dictionaries to help you with aggregation of data. This approach
    allows you to process data independent of the type of container storing your data.
    However, if you are using DataFrames.jl, you can alternatively use the groupby
    function to achieve the same result. The details of this functionality are explained
    in chapters 11, 12, and 13.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用字典来帮助您进行数据的聚合。这种方法允许您独立于存储数据的容器类型处理数据。然而，如果您使用 DataFrames.jl，您还可以使用 groupby
    函数来达到相同的结果。此功能的详细信息在第 11、12 和 13 章中解释。
- en: The Loess.jl package can be used to build local regression models. These models
    are used when your data has nonlinear relationships between the feature and target
    variable.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loess.jl 包可以用来构建局部回归模型。这些模型在特征和目标变量之间存在非线性关系时使用。
