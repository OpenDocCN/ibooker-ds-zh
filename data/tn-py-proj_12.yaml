- en: '11 Bottles of Beer Song: Writing and testing functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 瓶啤酒歌曲：编写和测试函数
- en: '| Few songs are as annoying as “99 Bottles of Beer on the Wall.” Hopefully
    you’ve never had to ride for hours in a van with middle school boys who like to
    sing this. I have. It’s a fairly simple song that we can write an algorithm to
    generate. This will give us an opportunity to play with counting up and down,
    formatting strings, and--new to this exercise--writing functions and tests for
    those functions! | ![](../Images/11-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 没有歌曲像“墙上的99瓶啤酒”那样令人烦恼。希望你从未被迫在货车里和喜欢唱这首歌的中学生一起度过几个小时。我有过。这是一首相当简单的歌，我们可以编写一个算法来生成它。这将给我们一个机会来练习上下计数、格式化字符串，以及——在这个练习中是新的——编写函数及其测试！
    | ![](../Images/11-unnumb-1.png) |'
- en: 'Our program will be called bottles.py and will take one option, `-n` or `--num`,
    which must be a *positive* `int` (the default will be `10`). The program should
    print all the verses from `--num` down to 1\. There should be two newlines between
    each verse to visually separate them, but there must be only one newline after
    the last verse (for one bottle), which should print “No more bottles of beer on
    the wall” rather than “0 bottles”:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将命名为 bottles.py，并接受一个选项 `-n` 或 `--num`，它必须是一个 *正数* `int`（默认值为 `10`）。程序应该从
    `--num` 打印到 1 的所有节。每个节之间应该有两个换行符来视觉上分隔它们，但在最后一个节之后必须只有一个换行符（对于一瓶），应该打印 “墙上的啤酒瓶没有更多”
    而不是 “0 瓶”：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this exercise, you will
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Learn how to produce a list of numbers decreasing in value
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何生成一个按值递减的数字列表
- en: Write a function to create a verse of the song, using a test to verify when
    the verse is correct
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数来创建歌曲的节，使用测试来验证节是否正确
- en: Explore how `for` loops can be written as list comprehensions, which in turn
    can be written with the `map()` function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索如何将 `for` 循环写成列表推导式，而列表推导式又可以写成 `map()` 函数的形式
- en: 11.1 Writing bottles.py
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 编写 bottles.py
- en: 'We’ll be working in the 11_bottles_of_beer directory. Start off by copying
    template.py or using new.py to create your bottles.py program there. Then modify
    the `get_args()` function until your usage matches the following usage statement.
    You need to define only the `--num` option with `type=int` and `default=10`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 11_bottles_of_beer 目录下工作。首先，复制 template.py 或使用 new.py 在那里创建 bottles.py
    程序。然后修改 `get_args()` 函数，直到你的用法与以下用法说明相符。你需要定义的只有 `--num` 选项，其类型为 `int`，默认值为 `10`：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the `--num` argument is not an `int` value, your program should print an
    error message and exit with an error value. This should happen automatically if
    you define your parameter to `argparse` properly:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `--num` 参数不是一个 `int` 值，你的程序应该打印一个错误消息并退出，返回错误值。如果你正确地定义了参数到 `argparse`，这应该会自动发生：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we can’t sing zero or fewer verses, we’ll need to check if `--num` is
    less than `1`. To handle this, I suggest you use `parser.error()` inside the `get_args()`
    function, as in previous exercises:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能唱零或更少的节，我们需要检查 `--num` 是否小于 `1`。为了处理这个问题，我建议你在 `get_args()` 函数中使用 `parser.error()`，就像之前的练习一样：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 11.1 shows a string diagram of the inputs and outputs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 显示了输入和输出的字符串图。
- en: '![](../Images/11-1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-1.png)'
- en: Figure 11.1 The bottles program may take a number for the verse to start, or
    it will sing the song starting at 10.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 瓶子程序可能需要一个数字来指定起始节，或者它会从 10 开始唱这首歌。
- en: 11.1.1 Counting down
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 倒数计数
- en: 'The song starts at the given `--num` value, like 10, and needs to count down
    to 9, 8, 7, and so forth. How can we do that in Python? We’ve seen how to use
    `range(start,` `stop)` to get a list of integers that go *up* in value. If you
    give it just one number, that will be considered the `stop`, and it will assume
    `0` as the `start`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 歌曲从给定的 `--num` 值开始，比如 10，需要倒数到 9、8、7 等等。我们如何在 Python 中做到这一点？我们已经看到如何使用 `range(start,
    stop)` 来获取一个按值 *递增* 的整数列表。如果你只提供一个数字，那么这个数字将被认为是 `stop`，它将假设 `start` 为 `0`：
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because this is a lazy function, we must use the `list()` function in the REPL
    to force it to produce the numbers. Remember that the `stop` value is never included
    in the output, so the preceding output stopped at 4, not 5. | ![](../Images/11-unnumb-2.png)
    |
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个惰性函数，我们必须在 REPL 中使用 `list()` 函数来强制它产生数字。记住，`stop` 值永远不会包含在输出中，所以前面的输出在
    4 处停止，而不是 5。 | ![](../Images/11-unnumb-2.png) |
- en: 'If you give `range()` two numbers, they are considered to be `start` and `stop`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给 `range()` 函数两个数字，它们被认为是 `start` 和 `stop`：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To reverse this sequence, you might be tempted to swap the `start` and `stop`
    values. Unfortunately, if `start` is greater than `stop`, you get an empty list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转这个序列，你可能想交换`start`和`stop`的值。不幸的是，如果`start`大于`stop`，你会得到一个空列表：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You saw in chapter 3 that we can use the `reversed()` function to reverse a
    `list`. This is another lazy function, so again I’ll use the `list()` function
    to force the values in the REPL:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第三章中看到，我们可以使用`reversed()`函数来反转一个`list`。这是一个惰性函数，所以我会再次使用`list()`函数来强制REPL中的值：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| The `range()` function can also take an optional third argument for a `step`
    value. For instance, you could use this to count by fives:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| `range()`函数也可以接受一个可选的第三个参数作为`步长`值。例如，你可以使用这个来以五的倍数计数：'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| ![](../Images/11-unnumb-3.png)  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/11-unnumb-3.png)  |'
- en: 'Another way to count down is to swap the `start` and `stop` and use `-1` for
    the step:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种倒数的方法是交换`start`和`stop`，并使用`-1`作为步长：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So you have couple of ways to count in reverse.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你有几种方法可以反向计数。
- en: 11.1.2 Writing a function
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 编写一个函数
- en: Up to this point, I’ve suggested that all your code go into the `main()` function.
    This is the first exercise where I suggest you write a function. I would like
    you to consider how to write the code to sing *just one verse*. The function could
    take the number of the verse and return the text for that verse.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我建议你所有的代码都放入`main()`函数中。这是第一个建议你编写函数的练习。我想让你考虑如何编写代码来唱**仅一个节**。这个函数可以接受节的数量，并返回该节的文本。
- en: You can start off with something like the example in figure 11.2\. The `def`
    keyword “defines” a function, and the name of the function follows. Function names
    should contain only letters, numbers, and underscores and cannot start with a
    number. After the name comes parentheses, which describe any parameters that the
    function accepts. Here our function will be called `verse()`, and it has the parameter
    `bottle` (or `number` or whatever you want to call it). After the parameters comes
    a colon to indicate the end of the `def` line. The function body comes next, with
    all lines being indented at least four spaces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从图11.2中的示例开始。`def`关键字“定义”了一个函数，函数名紧随其后。函数名应只包含字母、数字和下划线，并且不能以数字开头。在名称之后是括号，它描述了函数接受的任何参数。在我们的函数中，它将被命名为`verse()`，并且它有一个参数`bottle`（或`number`或你想要叫它的任何名字）。在参数之后是一个冒号，表示`def`行的结束。接下来是函数主体，所有行至少缩进四个空格。
- en: '![](../Images/11-2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-2.png)'
- en: Figure 11.2 The elements of a function definition in Python
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 Python中函数定义的元素
- en: The docstring in figure 11.2 is a string just after the function definition.
    It will show up in the help for your function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2中的文档字符串是一个函数定义之后的字符串。它将显示在你的函数的帮助信息中。
- en: 'You can enter this function into the REPL:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此函数输入到REPL中：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you do, you will see this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你会看到这个：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `return` statement tells Python what to send back from the function. It’s
    not very interesting right now because it will just send back the empty string:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句告诉Python从函数中返回什么。现在它并不很有趣，因为它只会返回一个空字符串：'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s also common practice to use the `pass` statement for the body of a dummy
    function. The `pass` will do nothing, and the function will return `None` instead
    of the empty string, as we have done here. When you start writing your own functions
    and tests, you might like to use `pass` when you stub out a new function, until
    you decide what the function will do.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pass`语句作为虚拟函数的主体也是一种常见的做法。`pass`将不会做任何事情，函数将返回`None`而不是空字符串，就像我们在这里所做的那样。当你开始编写自己的函数和测试时，你可能喜欢在创建新函数的存根时使用`pass`，直到你决定函数将做什么。
- en: 11.1.3 Writing a test for verse()
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 为verse()编写测试
- en: 'In the spirit of *test-driven development*, let’s write a test for `verse()`
    before we go any further. The following listing shows a test you can use. Add
    this code into your bottles.py program just after your `main()` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在*测试驱动开发*的精神下，在我们继续之前，让我们为`verse()`编写一个测试。下面的列表显示了你可以使用的测试。将此代码添加到你的bottles.py程序中，在`main()`函数之后：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| There are many, many ways you could write this program. I have in mind that
    my `verse()` function will produce a single verse of the song, returning a new
    `str` value that is the lines of the verse joined on newlines.You don’t have to
    write your program this way, but I’d like you to consider what it means to write
    a function and a *unit test*. If you read about software testing, you’ll find
    that there are different definitions of what a “unit” of code is. In this book,
    I consider a *function* to be a *unit*, so my unit tests are tests of individual
    functions. | ![](../Images/11-unnumb-4.png) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 你可以有很多种方式来编写这个程序。我心中所想的是，我的 `verse()` 函数将生成歌曲的单节，返回一个新的 `str` 值，它是节的行通过换行符连接起来的。你不必以这种方式编写你的程序，但我希望你能考虑编写一个函数和一个
    *单元测试* 的意义。如果你阅读有关软件测试的内容，你会发现关于“单元”代码的不同定义。在这本书中，我认为一个 *函数* 是一个 *单元*，因此我的单元测试是对单个函数的测试。|
    ![](../Images/11-unnumb-4.png) |'
- en: Even though the song has potentially hundreds of verses, these two tests should
    cover everything you need to check. It may help to look at the musical notation
    in figure 11.3 for the song, as this does a nice job of graphically showing the
    structure of the song and, hence, our program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这首歌可能有数百节，但这两个测试应该涵盖你需要检查的所有内容。查看图 11.3 中的音乐符号可能会有所帮助，因为它很好地图形化了歌曲的结构，因此我们的程序。
- en: '![](../Images/11-3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-3.png)'
- en: 'Figure 11.3 The musical notation for the song shows there are two cases to
    handle: one for all the verses up to the last, and then the last one.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 歌曲的乐谱显示了有两个情况需要处理：一个是处理到最后的一节，然后是最后一节。
- en: I’ve taken a few liberties with the notation by mixing in some programming ideas.
    If you don’t know how to read music, let me briefly explain the important parts.
    The `N` is the current *number*, like “99” so that `(N` `-` `1)` would be “98.”
    The endings are noted `1` `-` `(N` `-` `1)`, which is a bit confusing because
    we’re using the hyphen to indicate both a range and subtraction in the same “equation.”
    Still, the first ending is used for the first time through the penultimate repeat.
    The colon before the bar lines in the first ending means to repeat the song from
    the beginning. Then the `N` ending is taken on the last repeat, and the double
    bar indicates the end of the song/program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我在符号上做了一些变通，混合了一些编程思想。如果你不知道如何阅读音乐，让我简要地解释一下重要部分。`N` 表示当前的 *数字*，比如 “99”，所以 `(N`
    `-` `1)` 就会是 “98”。结尾部分标记为 `1` `-` `(N` `-` `1)`，这有点令人困惑，因为我们在这个“等式”中同时使用了连字符来表示范围和减法。尽管如此，第一次结尾是在倒数第二次重复时使用的。第一次结尾前的冒号表示从歌曲开头重复。然后，在最后一次重复时使用
    `N` 结尾，双横线表示歌曲/程序的结束。
- en: 'What we can see from the music is that there are only two cases we need to
    handle: the last verse, and all the other verses. So first we check the last verse.
    We’re looking for “1 bottle” (singular) and not “1 bottles” (plural). We also
    need to check that the last line says “No more bottles” instead of “0 bottles.”
    The second test, for “2 bottles of beer,” is making sure that the numbers are
    “2 bottles” and then “1 bottle.” If we managed to pass these two tests, our program
    ought to be able to handle all the verses.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从音乐中我们可以看到，我们只需要处理两种情况：最后一节和所有其他节。所以首先我们检查最后一节。我们寻找的是“1 瓶”（单数）而不是“1 瓶”（复数）。我们还需要检查最后一行说的是“没有更多的瓶子”而不是“0
    瓶”。对于“2 瓶啤酒”的第二个测试，是确保数字是“2 瓶”然后是“1 瓶”。如果我们能够通过这两个测试，我们的程序应该能够处理所有节。
- en: I wrote `test_verse()` to test just the `verse()` function. The name of the
    function matters because I am using the `pytest` module to find all the functions
    in my code that start with `test_` and run them. If your bottles.py program has
    the preceding functions for `verse()` and `test_verse()`, you can run `pytest`
    `bottles.py`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了 `test_verse()` 来测试 `verse()` 函数。函数的名称很重要，因为我正在使用 `pytest` 模块来查找我的代码中以 `test_`
    开头的所有函数并运行它们。如果你的 `bottles.py` 程序有前面的 `verse()` 和 `test_verse()` 函数，你可以运行 `pytest
    bottles.py`。
- en: 'Try it, and you should see something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，你应该会看到类似这样的结果：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Call the verse() function with the argument 1 to get the last verse of the
    song.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 1 作为参数调用 `verse()` 函数以获取歌曲的最后一节。
- en: ② The > at the beginning of this line indicates this is the source of the error.
    The test checks if the value of last_verse is equal to an expected str value.
    Since it’s not, this line throws an exception, causing the assertion to fail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这行开头的 > 表示这是错误的来源。测试检查 last_verse 的值是否等于预期的 str 值。由于它不等于，这一行抛出异常，导致断言失败。
- en: ③ The “E” lines show the difference between what was received and what was expected.
    The value of last_verse is the empty string (''), which does not match the expected
    string “1 bottle of beer...” and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ③ “E”行显示了接收到的内容与预期内容的差异。`last_verse`的值是空字符串 ('')，这与预期的字符串“1瓶啤酒...”等不匹配。
- en: 'To pass the first test, you could copy the code for the expected value of `last_verse`
    directly from the test. Change your `verse()` function to match this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过第一个测试，你可以直接从测试中复制`last_verse`的预期值代码。将你的`verse()`函数修改为匹配以下内容：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now run your test again. The first test should pass, and the second one should
    fail. Here are the relevant error lines:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行你的测试。第一个测试应该通过，而第二个应该失败。以下是相关的错误行：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① This test now passes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这个测试现在通过了。
- en: ② Call verse() with the value of 2 to get the “Two bottles...” verse.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用值为2调用`verse()`以获取“Two bottles...”这首诗。
- en: ③ Assert that this verse is equal to the expected string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 断言这首诗等于预期的字符串。
- en: ④ These E lines are showing you the problem. The verse() function returned '1
    bottle' but the test expected '2 bottles', etc.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 这些“E”行显示了问题。`verse()`函数返回了'1瓶'，但测试期望的是'2瓶'等。
- en: 'Go back and look at your `verse()` definition. Look at figure 11.4 and think
    about which parts need to change--the first, second, and fourth lines. The third
    line is always the same. You’re given a value for `bottle` that needs to be used
    in the first two lines, along with either “bottle” or “bottles,” depending on
    the value of `bottle`. (Hint: It’s only singular for the value `1`; otherwise,
    it’s plural.) The fourth line needs the value of `bottle` `-` `1` and, again,
    the proper singular or plural depending on that value. Can you figure out how
    to write this?'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回去看看你的`verse()`定义。看看图11.4，思考哪些部分需要更改--第一、第二和第四行。第三行总是相同的。你得到了一个`bottle`的值，需要用于前两行，以及根据`bottle`的值，“bottle”或“bottles”。（提示：当值为`1`时，它是单数；否则，它是复数。）第四行需要`bottle`的值`-``1`，以及根据该值适当的单数或复数。你能想出如何编写这个吗？
- en: '![](../Images/11-4.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-4.png)'
- en: Figure 11.4 Each verse has four lines, where the first two and last are very
    similar. The third line is always the same. Find the parts that vary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 每一首诗有四行，其中前两行和最后一行非常相似。第三行总是相同的。找出不同的部分。
- en: 'Focus on passing those two tests before you move to the next stage of printing
    the whole song. That is, do not attempt anything until you see this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入打印整首歌曲的下一阶段之前，专注于通过这两个测试。也就是说，在你看到这个之前不要尝试任何事情：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 11.1.4 Using the verse() function
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4 使用`verse()`函数
- en: At this point, you know
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你知道
- en: That the `--num` value is a valid integer value greater than 0
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--num`值是一个有效的整数，且大于0'
- en: How to count from that `--num` value backwards down to 0
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从`--num`值开始倒数到0
- en: That the `verse()` function will print any one verse properly
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verse()`函数将正确打印任何一首诗'
- en: Now you need to put them together. I suggest you start by using a `for` loop
    with the `range()` function to count down. Use each value from that to produce
    a `verse()`. There should be two newlines after every verse except for the last.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要将它们组合起来。我建议您首先使用带有`range()`函数的`for`循环来倒计时。使用该循环中的每个值来生成一个`verse()`。除了最后一首诗外，每首诗后应有两个换行符。
- en: You will use `pytest` `-xv` `test.py` (or `make` `test`) to test the program
    at this point. In the parlance of testing, test.py is an *integration test* because
    it checks that the program *as a whole* is working. From this point on, we’ll
    focus on how to write *unit* tests to check individual functions in addition to
    *integration* tests to ensure that all the functions work together.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`pytest` `-xv` `test.py`（或`make` `test`）来测试当前程序。在测试的术语中，test.py是一个*集成测试*，因为它检查程序*整体*是否正常工作。从现在开始，我们将专注于如何编写*单元测试*来检查单个函数，以及除了*集成测试*外，确保所有函数协同工作。
- en: Once you can pass the test suite using a `for` loop, try to rewrite it using
    either a list comprehension or a `map()`. Rather than starting again from scratch,
    I suggest you comment out your working code by adding `#` to the beginnings of
    the lines, and then try other ways to write the algorithm. Use the tests to verify
    that your code still passes. If it is at all motivating, my solution is one line
    long. Can you write a single line of code that combines the `range()` and `verse()`
    functions to produce the expected output?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你可以使用 `for` 循环通过测试套件，尝试使用列表推导式或 `map()` 重新编写它。而不是从头开始，我建议你通过在行首添加 `#` 来注释掉你的工作代码，然后尝试其他编写算法的方式。使用测试来验证你的代码仍然可以通过。如果这有任何激励作用，我的解决方案只有一行长。你能写一行代码来结合
    `range()` 和 `verse()` 函数以产生预期的输出吗？
- en: 'Here are a few hints:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Define the `--num` argument as an `int` with a default value of `10`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `--num` 参数定义为默认值为 `10` 的 `int`。
- en: Use `parser.error()` to get `argparse` to print an error message for a negative
    `--num` value.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `parser.error()` 来让 `argparse` 打印出一个错误信息，当 `--num` 值为负数时。
- en: Write the `verse()` function. Use the `test_verse()` function and Pytest to
    make that work properly.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `verse()` 函数。使用 `test_verse()` 函数和 Pytest 来确保其正确运行。
- en: Combine the `verse()` function with `range()` to create all the verses.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `verse()` 函数与 `range()` 结合起来创建所有诗句。
- en: Do try your best to write the program before reading the solution. Also feel
    free to solve the problem in a completely different way, even writing your own
    unit tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读解决方案之前，尽量写出程序。你也可以自由地以完全不同的方式解决问题，甚至编写你自己的单元测试。
- en: 11.2 Solution
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 解决方案
- en: I’ve decided to show you a slightly fancy-pants version that uses `map()`. Later
    I’ll show you how to write it using a `for` loop and a list comprehension.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定向你展示一个稍微花哨一点的版本，它使用了 `map()` 函数。稍后我会展示如何使用 `for` 循环和列表推导式来编写它。
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Define the --num argument as an int with a default value of 10.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 `--num` 参数定义为默认值为10的整数。
- en: ② Parse the command-line argument into the variable args.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将命令行参数解析到变量 `args` 中。
- en: ③ If args.num is less than 1, use parser.error() to display an error message
    and exit the program with an error value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果 `args.num` 小于1，使用 `parser.error()` 显示错误信息并退出程序，返回错误值。
- en: ④ The map() function expects a function as the first argument and some iterable
    as the second argument. Here I feed the descending numbers from the range() function
    to my verse() function. The result from map() is a new list of verses that can
    be joined on two newlines.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ④ `map()` 函数期望第一个参数是一个函数，第二个参数是一个可迭代的对象。在这里，我将 `range()` 函数中递减的数字传递给我的 `verse()`
    函数。`map()` 的结果是一个新的诗句列表，可以用两个换行符连接。
- en: ⑤ Define a function that can create a single verse().
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义一个可以创建单个诗句的函数 `verse()`。
- en: ⑥ Define a next_bottle that is one less than the current bottle.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 定义一个 `next_bottle`，它的值比当前瓶子少一个。
- en: ⑦ Define an s1 (the first “s”) that is either the character 's' or the empty
    string, depending on the value of current bottle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 根据当前瓶子的值，定义一个 `s1`（第一个“s”），它可以是字符 's' 或空字符串。
- en: ⑧ Do the same for s2 (the second “s”), depending on the value of next_bottle.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 根据 `next_bottle` 的值，对 `s2`（第二个“s”）做同样的处理。
- en: ⑨ Define a value for next_num depending on whether the next value is 0 or not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 根据下一个值是否为0来定义 `next_num` 的值。
- en: ⑩ Create a return string by joining the four lines of text on the newline. Substitute
    in the variables to create the correct verse.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 通过在换行符上连接四行文本来创建一个返回字符串。将变量代入以创建正确的诗句。
- en: ⑪ Define a unit test called test_verse() for the verse() function. The test_
    prefix means that the pytest module will find this function and execute it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 为 `verse()` 函数定义一个名为 `test_verse()` 的单元测试。`test_` 前缀意味着 pytest 模块将找到这个函数并执行它。
- en: ⑫ Test the last verse() with the value 1.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 使用值1测试最后的 `verse()` 函数。
- en: ⑬ Test a verse() with the value 2\.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 使用值2测试 `verse()`。
- en: 11.3 Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 讨论
- en: There isn’t anything new in the `get_args()` function in this program. By this
    point, you have had several opportunities to define an optional integer parameter
    with a default argument and to use `parser.error()` to halt your program if the
    user provides a bad argument. By relying on `argparse` to handle so much busy
    work, you are saving yourself loads of time as well as ensuring that you have
    good data to work with. Let’s move on to the new stuff!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的 `get_args()` 函数中没有什么新的内容。到目前为止，你已经有很多机会定义一个具有默认参数的可选整数参数，并使用 `parser.error()`
    来在用户提供不良参数时停止程序。通过依赖 `argparse` 来处理这么多繁琐的工作，你不仅节省了大量的时间，而且还确保了你拥有良好的数据来工作。让我们继续学习新的内容！
- en: 11.3.1 Counting down
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 倒计时
- en: 'You know how to count down from the given `--num`, and you know you can use
    a `for` loop to iterate:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何从给定的 `--num` 开始倒计时，并且你知道你可以使用一个 `for` 循环来迭代：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Instead of directly creating each verse inside the `for` loop, I suggested that
    you could create a function called `verse()` to create any given verse and use
    that with the `range()` of numbers. Up to this point, we’ve been doing all our
    work in the `main()` function. As you grow as a programmer, though, your programs
    will become longer--hundreds to even thousands of lines of code (LOC). Long programs
    and functions can get very difficult to test and maintain, so you should try to
    break ideas into small, functional units that you can understand and test. Ideally,
    functions should do *one* thing. If you understand and trust your small, simple
    *functions*, then you know you can safely compose them into longer, more complicated
    *programs*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在 `for` 循环中直接创建每个诗行，我建议你可以创建一个名为 `verse()` 的函数来创建任何给定的诗行，并使用 `range()` 的数字范围。到目前为止，我们一直在
    `main()` 函数中做所有的工作。然而，随着你作为一个程序员的成长，你的程序将变得更长——数百行甚至数千行代码（LOC）。长程序和函数可能非常难以测试和维护，因此你应该尝试将想法分解成小的、功能性的单元，这样你就可以理解和测试它们。理想情况下，函数应该只做
    *一件事*。如果你理解并信任你的小而简单的 *函数*，那么你知道你可以安全地将它们组合成更长、更复杂的 *程序*。
- en: 11.3.2 Test-driven development
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 测试驱动开发
- en: 'I wanted you to add a `test_verse()` function to your program to use with Pytest
    to create a working `verse()` function. This idea follows the principles described
    by Kent Beck in his book, *Test-Driven Development* (Addison-Wesley Professional,
    2002):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让你在你的程序中添加一个 `test_verse()` 函数，以便使用 Pytest 创建一个工作的 `verse()` 函数。这个想法遵循 Kent
    Beck 在他的书 *测试驱动开发*（Addison-Wesley Professional，2002）中描述的原则：
- en: Add a new test for an unimplemented unit of functionality.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为未实现的功能单元添加一个新测试。
- en: Run all previously written tests and see the newly added test fails.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有先前编写的测试，并查看新添加的测试失败。
- en: Write code that implements the new functionality.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写实现新功能的代码。
- en: Run all tests and see them succeed.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试并查看它们成功。
- en: Refactor (rewrite to improve readability or structure).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构（重写以改进可读性或结构）。
- en: Start at the beginning (repeat).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从开始处（重复）开始。
- en: 'For instance, suppose we want a function that adds 1 to any given number. We’ll
    called it `add1()` and define the function body as `pass` to tell Python “nothing
    to see here”:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要一个将 1 加到任何给定数字的函数。我们将它命名为 `add1()` 并将函数体定义为 `pass` 以告诉 Python “这里没有东西可看”：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now write a `test_add1()` function where you pass some arguments to the function,
    and use `assert` to verify that you get back the value that you expect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写一个 `test_add1()` 函数，将一些参数传递给该函数，并使用 `assert` 验证你得到你预期的值：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run pytest (or whatever testing framework you like) and verify that the function
    *does not work* (of course it won’t, because it just executes `pass`). Then go
    fill in some function code that *does* work (`return` `n` `+` `1` instead of `pass`).
    Pass all manner of arguments you can imagine, including nothing, one thing, and
    many things.[1](#pgfId-1016482)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 pytest（或你喜欢的任何测试框架）并验证该函数 *不工作*（当然不会，因为它只是执行 `pass`）。然后去填写一些函数代码，使其 *工作*（将
    `return` `n` `+` `1` 替换为 `pass`）。传递你所能想象的各种参数，包括没有参数、一个参数和多个参数。[1](#pgfId-1016482)
- en: 11.3.3 The verse() function
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 `verse()` 函数
- en: '| I provided you with a `test_verse()` function that shows you exactly what
    is expected for the arguments of 1 and 2\. What I like about writing my tests
    first is that it gives me an opportunity to think about how I’d like to use the
    code, what I’d like to give as arguments, and what I expect to get back in return.
    For instance, what *should* the function `add1()` return if given | ![](../Images/11-unnumb-5.png)
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 我为你提供了一个 `test_verse()` 函数，它显示了对于 1 和 2 的参数期望的确切内容。我喜欢先写测试的原因是，它给了我一个思考如何使用代码的机会，我想传递什么参数，以及我期望得到什么回报。例如，如果给定
    | ![](../Images/11-unnumb-5.png) |，函数 `add1()` 应该返回什么？'
- en: No arguments
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无参数
- en: More than one argument
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多于一个参数
- en: The value `None`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 `None`
- en: Anything other than a numeric type (`int`, `float`, or `complex`) like a `str`
    value or a `dict`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何非数值类型（如 `str` 值或 `dict`）
- en: You can write tests to pass both good and bad values and decide how you want
    your code to behave under both favorable and adverse conditions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写测试来传递好的和坏的值，并决定你希望你的代码在有利和不利条件下如何表现。
- en: 'Here’s the `verse()` function I wrote, which passes the `test_verse()` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我在 `verse()` 函数中编写的，它通过了 `test_verse()` 函数：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code is annotated in section 11.2, but I essentially isolate all the parts
    of the return string that change, and I create variables to substitute into those
    places. I use `bottle` and `next_bottle` to decide if there should be an “s” or
    not after the “bottle” strings. I also need to figure out whether to print the
    next bottle as a number, or if I should print the string “No more” (when `next_bottle`
    is `0`). Choosing the values for `s1`, `s2`, and `num_next` all involve *binary*
    decisions, meaning they are a choice between *two* values, so I find it best to
    use an `if` expression.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在 11.2 节中有注释，但我基本上隔离了返回字符串中所有会变化的部分，并为这些位置创建了变量以进行替换。我使用 `bottle` 和 `next_bottle`
    来决定在“bottle”字符串后面是否应该有“s”。我还需要弄清楚是否应该打印下一个瓶子作为数字，或者应该打印字符串“没有更多”（当 `next_bottle`
    为 `0` 时）。为 `s1`、`s2` 和 `num_next` 选择值都涉及 *二进制* 决策，这意味着它们是在两个值之间的选择，所以我发现使用 `if`
    表达式是最好的。
- en: This function passes `test_verse()`, so I can move on to using it to generate
    the song.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过了 `test_verse()` 测试，所以我可以继续使用它来生成歌曲。
- en: 11.3.4 Iterating through the verses
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 遍历诗行
- en: 'I could use a `for` loop to count down and `print()` each `verse()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `for` 循环进行倒计时并 `print()` 每个函数 `verse()`：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That’s *almost* correct, but we need two newlines in between all the verses.
    I could use the `end` option to `print` to include two newlines for all values
    greater than 1:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是正确的，但我们需要在所有诗行之间插入两个换行符。我可以使用 `end` 选项来 `print` 包括两个换行符的所有大于 1 的值：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I would rather use the `str.join()` method to put two newlines in between items
    in a `list`. My items are the verses, and I can turn a `for` loop into a list
    comprehension as shown in figure 11.5.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我更愿意使用 `str.join()` 方法在 `list` 中的项目之间插入两个换行符。我的项目是诗行，我可以将一个 `for` 循环转换成如图 11.5
    所示的列表推导式。
- en: '![](../Images/11-5.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 11-5](../Images/11-5.png)'
- en: Figure 11.5 A `for` loop compared to a list comprehension
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 `for` 循环与列表推导式的比较
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That is a fine solution, but I would like you to start noticing a pattern we
    will see repeatedly: applying a function to every element of a sequence, which
    is exactly what `map()` does! As shown in figure 11.6, our list comprehension
    can be rewritten very concisely using `map()`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的解决方案，但我希望你们开始注意到我们将反复看到的模式：将函数应用于序列的每个元素，这正是 `map()` 所做的！如图 11.6 所示，我们的列表推导式可以使用
    `map()` 非常简洁地重写。
- en: '![](../Images/11-6.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 11-6](../Images/11-6.png)'
- en: Figure 11.6 A list comprehension can be replaced with `map()`. They both return
    a new `list`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 列表推导式可以用 `map()` 替换。它们都返回一个新的 `list`。
- en: 'In our case, our sequence is a descending `range()` of numbers, and we want
    to apply our `verse()` function to each number and collect the resulting verses.
    It’s like the paint booth idea in chapter 8, where the function “painted” the
    cars “blue” by adding the word “blue” to the start of the string. When we want
    to apply a function to every element in a sequence, we might consider refactoring
    the code using `map()`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，我们的序列是一个递减的 `range()` 数列，我们希望将 `verse()` 函数应用于每个数字并收集结果诗行。这就像第 8 章中提到的喷漆间想法，其中函数“painted”汽车“蓝色”是通过在字符串开头添加单词“blue”来实现的。当我们想要将一个函数应用于序列中的每个元素时，我们可能会考虑使用
    `map()` 对代码进行重构：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Whenever I need to transform some sequence of items with some function, I like
    to start off by thinking about how I’ll handle just *one* of the items. I find
    it’s much easier to write and test one function with one input rather than some
    possibly huge list of operations. List comprehensions are often considered more
    “Pythonic,” but I tend to favor `map()` because it usually involves shorter code.
    If you search the internet for “python list comprehension map,” you’ll find that
    some people think list comprehensions are easier to read than `map()`, but `map()`
    might possibly be somewhat faster. I wouldn’t say either approach is better than
    the other. It really comes down to taste or perhaps a discussion with your teammates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我需要使用某个函数转换一系列项目时，我总是先思考如何处理其中的一个项目。我发现，用单个输入编写和测试一个函数比用可能非常庞大的操作列表要容易得多。列表推导式通常被认为是更“Pythonic”的，但我更倾向于使用
    `map()`，因为它通常涉及更短的代码。如果你在互联网上搜索“python list comprehension map”，你会发现有些人认为列表推导式比
    `map()` 更容易阅读，但 `map()` 可能会稍微快一些。我不会说哪种方法比另一种方法更好。这完全取决于个人喜好或与队友的讨论。
- en: If you want to use `map()`, remember that it wants a *function* as the first
    argument and then a sequence of elements that will become arguments to the function.
    The `verse()` function (which you’ve tested!) is the first argument, and the `range()`
    provides the `list`. The `map()` function will pass each element of the `range()`
    as an argument to the `verse()` function, as shown in figure 11.7\. The result
    is a new `list` with the return values from all those function calls. Many are
    the `for` loops that can be better written as mapping a function over a list of
    arguments!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`map()`，请记住它需要一个*函数*作为第一个参数，然后是一个元素序列，这些元素将成为函数的参数。`verse()`函数（你已经测试过了！）是第一个参数，`range()`提供列表。`map()`函数将把`range()`的每个元素作为参数传递给`verse()`函数，如图11.7所示。结果是包含所有这些函数调用返回值的新列表。许多`for`循环都可以更好地写成映射函数到参数列表！
- en: '![](../Images/11-7.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-7.png)'
- en: Figure 11.7 The `map()` function will call the `verse()` function with each
    element produced by the `range()` function. It’s functions all the way down.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 `map()`函数将使用`range()`函数产生的每个元素调用`verse()`函数。完全是函数的堆叠。
- en: 11.3.5 1,500 other solutions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5 1,500种其他解决方案
- en: '| There are literally hundreds of ways to solve this problem. The “99 Bottles
    of Beer” website ([www.99-bottles-of-beer.net](http://www.99-bottles-of-beer.net))
    claims to have 1,500 variations in various languages. Compare your solution to
    others there. Trivial as the program may be, it has allowed us to explore some
    really interesting ideas in Python, testing, and algorithms. | ![](../Images/11-unnumb-6.png)
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 实际上，有数百种解决这个问题的方法。“99瓶啤酒”网站([www.99-bottles-of-beer.net](http://www.99-bottles-of-beer.net))声称有1,500种不同语言的变体。将你的解决方案与其他人进行比较。虽然程序可能很
    trivial，但它使我们能够探索一些真正有趣的Python、测试和算法思想。| ![图片](../Images/11-unnumb-6.png) |'
- en: 11.4 Going further
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 进一步探索
- en: Replace the Arabic numbers (1, 2, 3) with text (one, two, three).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将阿拉伯数字（1、2、3）替换为文本（one、two、three）。
- en: Add a `--step` option (positive `int`, default `1`) that allows the user to
    skip numbers, like by twos or fives.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`--step`选项（正整数，默认`1`），允许用户跳过数字，例如每隔两个或五个数字。
- en: Add a `--reverse` flag to reverse the order of the verses, counting up instead
    of down.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`--reverse`标志来反转诗的顺序，从上往下计数而不是从下往上。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Test-driven development (TDD) is central to developing dependable, reproducible
    code. Tests also give you the freedom to refactor your code (reorganize and improve
    it for speed or clarity), knowing that you can always verify your new version
    still works properly. As you write your code, always write tests!
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）对于开发可靠、可重复的代码至关重要。测试还赋予你重构代码的自由（重新组织并改进它以提高速度或清晰度），因为你始终可以验证你的新版本仍然可以正常工作。当你编写代码时，始终编写测试！
- en: The `range()` function will count backwards if you swap `start` and `stop` and
    supply the optional third `step` value of `-1`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你交换`start`和`stop`并提供一个可选的第三个`step`值`-1`，`range()`函数将倒序计数。
- en: A `for` loop can often be replaced with a list comprehension or a `map()` for
    shorter, more concise code.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环`for`通常可以用列表推导式或`map()`来替换，以获得更短、更简洁的代码。
- en: '* * *'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: 1 A CS professor once told me in office hours to handle the cases of 0, 1, and
    *n* (infinity), and that has always stuck with me.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 1 一位计算机科学教授曾在办公时间告诉我要处理0、1和*n*（无穷大）的情况，这始终让我印象深刻。
