- en: 6 Password generators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 个密码生成器
- en: Are you weary of the prompts? You know when some website asks you to apply a
    password to your account? “Ensure that it has at least one uppercase letter, one
    number, a symbol, and some hieroglyphics.” Or, “Here’s a suggested password that
    you’re incapable of typing, let alone committing to memory.” It’s exasperating.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你厌倦了这些提示吗？你知道当某些网站要求你为你的账户应用密码时吗？“确保它至少有一个大写字母、一个数字、一个符号和一些象形文字。”或者，“这里有一个你无法输入、更不用说记住的推荐密码。”这真是令人沮丧。
- en: 'I hope you recognize the importance of applying a password to a digital account.
    And I trust that you’re familiar with the common rules: don’t use easily guessed
    passwords. Don’t use any words or terms easily associated with you. Don’t set
    the same password for every account. These admonishments are tedious but important.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能认识到将密码应用于数字账户的重要性。我相信你已经熟悉了常见的规则：不要使用容易被猜到的密码。不要使用任何与你容易关联的单词或术语。不要为每个账户设置相同的密码。这些告诫虽然繁琐但很重要。
- en: 'Setting a solid password is a must these days. As a C programmer, you can bolster
    your weary password arsenal by:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个稳固的密码是当今的必需品。作为一名 C 语言程序员，你可以通过以下方式增强你疲惫的密码库：
- en: Understanding password strategy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解密码策略
- en: Creating basic, jumble passwords
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本、混乱的密码
- en: Ensuring the password has the required characters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保密码具有所需的字符
- en: Taking a detour in the world of Mad Libs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Mad Libs 的世界中绕道而行
- en: Using random words to build passwords
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机词汇构建密码
- en: At its core, of course, a password is nothing more than a string. Authentication
    is a case-sensitive, character-by-character comparison of the input password with
    a password stored in an encrypted database. True, the process is more complex
    than this; I assume at some point the process involves a squirrel on a treadmill.
    Still, once decrypted, it’s that good old comparison that unlocks the digital
    door. The point of setting a good password is to create a key no one else knows
    about or can even guess.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从本质上讲，密码不过是一串字符。身份验证是对输入密码与存储在加密数据库中的密码逐字符、区分大小写的比较。是的，这个过程比这更复杂；我假设在某个时候，这个过程涉及到一只在跑步机上跑步的松鼠。尽管如此，一旦解密，就是那古老的比较打开了数字之门。设置好密码的目的是创造一个无人知晓或能猜到的密钥。
- en: 6.1 Password strategies
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 密码策略
- en: 'Unix systems have always had password requirements for accounts. I mean, look
    at Unix nerds! Do you trust them? Better question: did they trust each other?
    Probably not, because the Unix logon has always prompted for a username and password.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统始终对账户有密码要求。我的意思是，看看 Unix 精英们！你们信任他们吗？更好的问题是：他们彼此信任吗？可能不是，因为 Unix 登录一直要求输入用户名和密码。
- en: Despite knowing about computer security for decades, Microsoft didn’t require
    a password for Windows until Windows 95 escaped the castle laboratory in 1996\.
    Even then, one of the most common emails I received from users at the time would
    ask how to avoid typing in the Windows password. Unlike Unix and other multiuser
    systems, PC users were unaccustomed to security. Proof of their ignorance is the
    proliferation of viruses in the 1990s, but I digress. Windows users just wanted
    to access the computer. Many of them avoided passwords on purpose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几十年来都知道计算机安全，但微软直到 1996 年 Windows 95 从实验室城堡中逃出时才要求 Windows 有密码。即使那时，我收到用户最常见的问题之一就是如何避免输入
    Windows 密码。与 Unix 和其他多用户系统不同，PC 用户不习惯于安全。他们无知的一个证明是 1990 年代的病毒泛滥，但我跑题了。Windows
    用户只是想访问电脑。其中许多人故意避免使用密码。
- en: Enter the internet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 进入互联网。
- en: As more of our lives are absorbed by the digital realm, creating and using passwords—serious
    passwords—becomes a must. Yes, at first, these were silly passwords just to meet
    the minimum requirement. But as the Bad Guys grew more sophisticated, passwords
    required more complexity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们生活中的更多部分被数字领域所吸收，创建和使用密码——严肃的密码——变得必不可少。是的，起初，这些只是为了满足最低要求而设置的愚蠢密码。但随着坏人的日益复杂化，密码需要更多的复杂性。
- en: 6.1.1 Avoiding basic and useless passwords
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 避免基本和无用的密码
- en: Lazy Windows 95 users must still be with us. Inept passwords are used every
    day. Silly humans. You’ll find a list of the top 10 most common passwords in table
    6.1\. These aren’t even the silly or weak passwords—just the most common. Dwell
    on that thought for a moment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰的 Windows 95 用户可能仍然在我们中间。无能的密码每天都在使用。愚蠢的人类。你将在表 6.1 中找到一个最常见的 10 个密码列表。这些甚至不是愚蠢或脆弱的密码——只是最常见的。稍作思考。
- en: Table 6.1 Stupid passwords
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 愚蠢的密码
- en: '| Rank | Password | Comment |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 排名 | 密码 | 评论 |'
- en: '| 1. | 123456 | The bare minimum for a “must be six characters long” password.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1. | 123456 | 对于“必须六位长”的密码来说是最基本的。|'
- en: '| 2. | 123456789 | A “more than six characters long” password. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2. | 123456789 | 一个“超过六位长”的密码。|'
- en: '| 3. | qwerty | Keyboard, top row, left. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 3. | qwerty | 键盘，顶部行，左边。|'
- en: '| 4. | password | An all-time classic. No one would guess! |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 4. | password | 一个永恒的经典。没有人会猜到！|'
- en: '| 5. | 12345 | Some people are just lazy. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 5. | 12345 | 有些人就是太懒了。|'
- en: '| 6. | qwert123 | Must have letters and numbers. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 6. | qwert123 | 必须包含字母和数字。|'
- en: '| 7. | 1q2w3e | Keyboard, numbers and characters, top left. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 7. | 1q2w3e | 键盘，数字和字符，顶部左方。|'
- en: '| 8. | 12345678 | More unclever numbers. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 8. | 12345678 | 更不聪明的数字。|'
- en: '| 9. | 111111 | Repetitive unclever numbers. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 9. | 111111 | 重复且不聪明的数字。|'
- en: '| 10. | 1234567890 | Probably using the numeric keypad for this baby. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 10. | 1234567890 | 很可能是在使用数字键盘输入这个数字。|'
- en: The reason using these passwords is useless is that every Bad Guy knows them
    and tries them first. And you know what? Sometimes they work! Lots of cases documented
    every day show some high-and-mighty official whose online security is compromised
    because the bozo was lazy and used a convenient password. It seems like such a
    person deserves to be hacked.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些密码无用的原因是每个坏蛋都知道并首先尝试它们。而且你知道吗？有时候它们是有效的！每天都有很多案例记录下来，一些高官的在线安全被破坏，因为那个笨蛋太懒，使用了方便的密码。似乎这样的人应该被黑客攻击。
- en: 'Not listed in table 6.1, but still incredibly stupid, are using the following
    personal information tidbits foolishly in or as a password:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 未列在表6.1中，但仍然非常愚蠢的是，以下个人信息片段被愚蠢地用作密码：
- en: Your birth year
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的出生年份
- en: The current year
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前年份
- en: Your first name
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的名字
- en: Your favorite sports team’s name
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你最喜欢的运动队的名字
- en: A curse word
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个诅咒词
- en: The word sex
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词sex
- en: Your city or street name or street number
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的城市或街道名称或街道号码
- en: The list goes on. These items are important to avoid—and why those quizzes on
    social media ask you such silly questions. Trust me—confessing who your best friend
    was in high school doesn’t tell Facebook which *Star Wars* character you are any
    more than rolling dice does. The Bad Guys are smart. Humans are dumb. The common
    answers people provide are used later to crack their passwords.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。这些项目需要避免——这就是为什么社交媒体上的那些测验会问你这样的愚蠢问题。相信我——承认你在高中的最好朋友是谁，并不比掷骰子告诉你你是哪个*星球大战*角色更有用。坏蛋们很聪明。人类很愚蠢。人们提供的常见答案后来被用来破解他们的密码。
- en: Knowing these tricks is important when crafting a better password. After all,
    it’s easy for someone to take a stab at what might be your password than to brute-force
    combinations of letters, numbers, and symbols to try to guess a password. Be smart.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计更好的密码时，了解这些技巧很重要。毕竟，有人尝试猜测你的密码比尝试字母、数字和符号的组合来猜测密码要容易得多。要聪明。
- en: Exercise 6.1
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.1
- en: Write a program that brute-force guesses the password *password*. Have your
    code spin through all the letter combinations *aaaaaaaa* through *zzzzzzzz* until
    it matches password. Eventually it will, of course, but the purpose of this exercise
    is to see how long the process takes. The solution I coded takes about 8 minutes
    to crack the password on my fastest computer (generating no output).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，暴力猜测密码*password*。让代码遍历所有字母组合*aaaaaaaa*到*zzzzzzzz*，直到匹配密码。当然，最终它会匹配，但这个练习的目的是看看这个过程需要多长时间。我编写的解决方案在我的最快电脑上破解密码大约需要8分钟（没有生成输出）。
- en: My solution is titled brutepass01.c, and it’s available in this book’s online
    repository. It uses recursion to spin through letters of the alphabet like miles
    turning on an odometer. Comments in the code explain my madness.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案命名为brutepass01.c，并且可以在本书的在线仓库中找到。它使用递归遍历字母表，就像里程表上的里程一样旋转。代码中的注释解释了我的疯狂。
- en: 6.1.2 Adding password complexity
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 增加密码复杂性
- en: 'To help you be smart when it comes to passwords, your kind and loving system
    administrators have devised a few rules. These started simple:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你聪明地处理密码，你善良而体贴的系统管理员制定了一些规则。这些规则最初很简单：
- en: '*Have a password. Please.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*请设置一个密码。*'
- en: 'Then complexity was added:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后增加了复杂性：
- en: '*Your password must contain both letters and numbers.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的密码必须包含字母和数字。*'
- en: 'As the Bad Guys grew more adept at guessing passwords, or applying brute-force
    methods, more details were added:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着坏蛋们越来越擅长猜测密码或应用暴力破解方法，更多的细节被添加：
- en: '*Your password must contain at least one uppercase letter.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的密码必须至少包含一个大写字母。*'
- en: '*Your password must be at least eight (or more) characters long.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的密码必须至少有八个（或更多）字符长。*'
- en: '*Your password must contain a symbol.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*您的密码必须包含一个符号。*'
- en: These suggestions add complexity, making it difficult to guess or brute-force
    the password. Even then, some websites offer even more annoying specifics. For
    example, figure 6.1 shows the rules for creating a new password at my bank. These
    rules are about as complex as they can get.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建议增加了复杂性，使得猜测或暴力破解密码变得困难。即便如此，一些网站甚至提供了更多令人烦恼的具体规则。例如，图6.1显示了在我银行创建新密码的规则。这些规则几乎是最复杂的。
- en: '![06-01](Images/06-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](Images/06-01.png)'
- en: Figure 6.1 Bank password restrictions are about as obnoxious as you can get.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 银行密码限制几乎是最令人讨厌的。
- en: To add even more security, many services employ two-factor authentication. This
    technique involves a confirmation code sent to your cell phone or a code value
    generated by an app or special device. This extra level of security ensures that
    even if your password is compromised, the second-factor security key keeps your
    information safe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加更多的安全性，许多服务采用双因素认证。这项技术涉及将确认码发送到您的手机或由应用程序或专用设备生成的代码值。这一额外的安全级别确保即使您的密码被泄露，第二因素的安全密钥也能保护您的信息安全。
- en: 6.1.3 Applying the word strategy
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 应用单词策略
- en: 'Studies have shown that your typical jumbled password is no better at thwarting
    the Bad Guys than a password consisting of several words slung together and separated
    by numbers or symbols. For example, this password:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 研究表明，您典型的混乱密码在阻止坏人方面并不比由几个单词随意组合并使用数字或符号分隔的密码更有效。例如，这个密码：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'offers no added security over this one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，没有提供额外的安全性：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second password has the advantage of being easier to remember and type.
    Yet when put to the test, password-cracking software takes the same if not longer
    amount of time to break the second, more readable password than the useless jumble.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个密码的优点是更容易记住和输入。然而，在测试中，密码破解软件破解第二个、更易读的密码所需的时间与破解无用的混乱密码所需的时间相同，甚至更长。
- en: 'This better approach to password creation is what I call the *word strategy*:
    string together three or more words, mix in some upper- and lowercase letters,
    add numbers and symbols. In fact, the password requirements shown in figure 6.1
    allow both password types shown in this section, but the word strategy is better.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更好的密码创建方法是我所说的*单词策略*：将三个或更多单词连在一起，混合使用大小写字母，添加数字和符号。实际上，图6.1中显示的密码要求允许本节中显示的两种密码类型，但单词策略更好。
- en: The word strategy also has the advantage of hashing. For example, you can key
    specific passwords to the sites and services you frequent. Should a password become
    compromised, you would immediately identify the source. Such a thing happened
    to me, when I received an email saying that “I know your password.” The Bad Guy
    listed the password—which was one I’ve used. I recognized it as my old Yahoo!
    password, which I changed after hackers stole the Yahoo! user database. I knew
    the password was compromised, and, based on the words used in the password, I
    knew the source. I wasn’t surprised or concerned by this revelation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单词策略还有哈希的优势。例如，您可以将特定的密码与您常访问的网站和服务关联起来。如果密码被泄露，您会立即识别出源头。这种情况就发生在我身上，当我收到一封邮件说“我知道你的密码。”坏人列出了密码——这是我曾经使用过的。我认出这是我的旧Yahoo!密码，在我更换密码后，黑客盗取了Yahoo!用户数据库。我知道密码已被泄露，并且根据密码中使用的单词，我知道了源头。我对这个发现并不感到惊讶或担忧。
- en: 6.2 The complex password jumble
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 复杂密码的混乱
- en: 'You may think it’s relatively easy to write code that outputs your typical,
    jumbled text password. It is. You may have written such a program in your digital
    youth: a silly random-character generator. But like all things easy, it’s not
    a really good way to code a password program. Don’t let the silliness of the exercise
    dissuade you.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为编写输出典型混乱文本密码的代码相对容易。确实如此。您可能在您的数字青年时期编写过这样的程序：一个愚蠢的随机字符生成器。但就像所有容易的事情一样，这并不是编写密码程序的好方法。不要让这个练习的愚蠢性使您气馁。
- en: 6.2.1 Building a silly random password program
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 构建一个愚蠢的随机密码程序
- en: Listing 6.1 shows my random password generator, a silly version titled randomp01.c
    because the filename silly.c is already taken on my computer. It slices off the
    printable character ASCII spectrum from the exclamation point to the tilde, codes
    33 through 126\. (Refer to chapter 5 for fun details on ASCII.) This value sets
    the random number range. The character value output is added to the exclamation
    point character, which brings it back into printable range.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1展示了我的随机密码生成器，一个愚蠢的版本，标题为randomp01.c，因为我的电脑上已经有一个silly.c的文件名。它从感叹号到波浪号切断了可打印字符的ASCII谱，编码为33到126。
    （有关ASCII的有趣细节，请参阅第5章。）这个值设置了随机数的范围。输出的字符值加上感叹号字符，使其回到可打印范围内。
- en: Listing 6.1 Source code for randomp01.c
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 randomp01.c的源代码
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Makes the password 10 characters long
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将密码长度设置为10个字符
- en: ❷ Sets the range of random values to printable characters
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置随机值的范围到可打印字符
- en: ❸ Outputs the printable character
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出可打印的字符
- en: 'The program’s output is delightfully random but practically useless as a password:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出是令人愉快的随机，但作为密码实际上毫无用处：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, good luck memorizing that. Second, better luck typing it. Third, hope
    that the website allows all the characters’ output; the double-quote is suspect.
    Obviously, some conditions must be applied to the output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，祝你好运记住它。其次，打字时好运。第三，希望网站允许所有字符的输出；双引号可疑。显然，必须应用一些条件到输出上。
- en: 6.2.2 Adding conditions to the password program
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 向密码程序添加条件
- en: Most of those random password generator routines on the internet produce a jumble
    of letters, numbers, and symbols, like a festive salad of nonsense but—like real
    salad—supposedly healthy for you. Obviously, some sort of intelligent programming
    is going on, as opposed to silly random character generation shown in the preceding
    section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 网上大多数随机密码生成程序产生的是字母、数字和符号的混乱组合，就像一个荒谬的节日沙拉，但——就像真正的沙拉一样——据说对你有好处。显然，正在进行某种智能编程，这与前一部分中展示的愚蠢的随机字符生成形成对比。
- en: 'A generated password’s characters can still be random, but they must be typed:
    uppercase, lowercase, numbers, symbols. The quantity of each depends on the password
    length, and the ratio of character types varies.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的密码字符仍然可以是随机的，但它们必须是以下类型：大写字母、小写字母、数字、符号。每种类型的数量取决于密码长度，并且字符类型的比例会有所不同。
- en: 'To improve the silly password program and make it smarter, consider limiting
    the password’s contents to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这个愚蠢的密码程序并使其更智能，考虑将密码的内容限制如下：
- en: One uppercase letter
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大写字母
- en: Six lowercase letters
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个小写字母
- en: One number
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字
- en: Two symbols
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个符号
- en: The total number of characters is 10, which is good for a password.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总字符数为10，这对于密码来说是个不错的选择。
- en: 'Random letters and numbers are easy to generate, but to avoid running afoul
    of any character restrictions, I would offer that these symbols are safe, though
    you’re always free to create your own list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随机字母和数字很容易生成，但为了避免违反任何字符限制，我会提供以下符号是安全的，尽管你可以自由地创建自己的列表：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The task now is to limit the password to the restrictions given.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的任务是限制密码到给定的限制。
- en: Exercise 6.2
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.2
- en: 'Write code that generates a random password limited to the characters listed
    in this section (10 total). Name the code randomp02.c. Include in your solution
    these four functions: *uppercase()*, *lowercase()*, *number()*, and *symbol()*.
    The *uppercase()* function returns a random character in the range from A to Z.
    The *lowercase()* function returns a lowercase character, A to Z. The *number()*
    function returns a character 0 through 9\. And the *symbol()* function plucks
    a random character from an array of safe symbols and returns it. The password
    is output in the *main()* function, which uses this pattern: one uppercase letter,
    six lowercase letters, one number, two symbols.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码生成一个限制在本节列出的字符（总共10个）的随机密码。将代码命名为randomp02.c。在解决方案中包含这四个函数：*uppercase()*,
    *lowercase()*, *number()*, 和 *symbol()*. *uppercase()* 函数返回A到Z范围内的随机字符。*lowercase()*
    函数返回小写字母，A到Z。*number()* 函数返回0到9的字符。*symbol()* 函数从一个安全符号数组中随机抽取一个字符并返回它。密码在 *main()*
    函数中输出，使用以下模式：一个大写字母，六个小写字母，一个数字，两个符号。
- en: 'As a tip, I use defined constants to create the pattern:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小贴士，我使用定义的常量来创建模式：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These defined constants save time later, as the code is updated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义的常量在代码更新时可以节省时间。
- en: 6.2.3 Improving upon the password
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 改进密码
- en: 'My solution to exercise 6.2 generates output like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我对练习6.2的解决方案生成的输出如下：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These valiant attempts at generating a random, jumbled password are successful
    but uninspired. Further, they might be easily compromised in that their pattern
    is predictable: they all start with an uppercase letter, six lowercase letters,
    a number, and finally two symbols. Writing a password-cracking program would be
    easier knowing this pattern.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成随机、混乱密码的勇敢尝试是成功的，但缺乏灵感。此外，它们可能很容易被破解，因为它们的模式是可预测的：它们都以一个大写字母开头，接着是六个小写字母，一个数字，最后是两个符号。知道这个模式后，编写密码破解程序会更容易。
- en: A better way to output the random characters is to scramble them. For this improvement,
    the password must be stored in an array as opposed to output directly (which is
    what I did for my solution to exercise 6.2). So, the first step in making the
    conversion from randomp02.c to randomp03.c is to store the generated password—still
    using the same functions and pattern as before.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出随机字符的更好方法是将其打乱。为此改进，密码必须存储在数组中，而不是直接输出（这是我解决 6.2 练习时所做的）。因此，将 randomp02.c
    转换为 randomp03.c 的第一步是存储生成的密码——仍然使用之前相同的函数和模式。
- en: Listing 6.2 shows the *main()* function from my updated code randomp03.c. The
    password[] buffer is created, equal to the number of characters stored—all defined
    constants created earlier in the code—plus one for the terminating null character.
    I replaced the *for* loops in my version of randomp02.c with while loops, which
    pack the array with the necessary characters. The string is terminated and then
    output.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 展示了来自我更新的代码 randomp03.c 中的 *main()* 函数。password[] 缓冲区被创建，等于存储的字符数——所有之前在代码中定义的常量——加上一个用于终止的空字符。我将
    randomp02.c 版本中的 *for* 循环替换为 while 循环，用必要的字符填充数组。字符串被终止并输出。
- en: Listing 6.2 Improvements to the *main()* function for randomp03.c
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 对 randomp03.c 的 *main()* 函数的改进
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Necessary storage for the password, plus one for the null character
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 密码所需的存储空间，加上一个空字符
- en: ❷ Seeds the randomizer
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化随机数生成器
- en: ❸ Initializes the index variable x
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始化索引变量 x
- en: ❹ Fetches the uppercase letters and puts them in the password[] array
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取大写字母并将它们放入 password[] 数组
- en: ❺ Fetches the lowercase letters
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取小写字母
- en: ❻ Fetches the numbers
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 获取数字
- en: ❼ Fetches the symbols
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 获取符号
- en: ❽ Caps the string with a null character
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用空字符终止字符串
- en: ❾ Outputs the password
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 输出密码
- en: The program’s output is unchanged, but this incremental step stores the password.
    With the password stored in a buffer, it can be passed to a new function, *scramble()*,
    which randomizes the characters in the buffer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出没有改变，但这个增量步骤存储了密码。将密码存储在缓冲区中后，它可以传递给一个新的函数，*scramble()*，该函数随机化缓冲区中的字符。
- en: My *scramble()* function is shown in listing 6.3\. It uses a temporary buffer
    key[] to determine which characters need to be randomized. This array is initialized
    with null characters. A *while* loop spins, generating random values in the range
    of 0 through 9—the same as the number of elements in both the passed array p[]
    and local array key[]. If a random element contains the null character, a character
    from the passed array is stored in that position. The *while* loop repeats until
    all characters from the passed array are copied. A final *for* loop updates the
    passed array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *scramble()* 函数在列表 6.3 中展示。它使用一个临时缓冲区 key[] 来确定哪些字符需要随机化。此数组以空字符初始化。一个 *while*
    循环旋转，生成 0 到 9 范围内的随机值——与传递数组 p[] 和局部数组 key[] 中的元素数量相同。如果一个随机元素包含空字符，则从传递数组中存储一个字符在该位置。*while*
    循环重复，直到传递数组中的所有字符都被复制。一个最终的 *for* 循环更新传递的数组。
- en: Listing 6.3 The *scramble()* function to randomize characters in an array
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 用于随机化数组字符的 *scramble()* 函数
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Calculates the buffer size
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算缓冲区大小
- en: ❷ Initializes the array with null characters
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用空字符初始化数组
- en: ❸ The index into the passed array
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 传递数组的索引
- en: ❹ Loops until the passed array has been fully processed (minus one for the null
    character)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 循环直到传递的数组被完全处理（减去一个空字符）
- en: ❺ Generates a random value, 0 through the buffer size (minus one for the null
    character)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 生成一个随机值，从 0 到缓冲区大小（减去一个空字符）
- en: ❻ If the random value at element r is a null character...
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果元素 r 中的随机值是空字符...
- en: ❼ . . . it copies the original character to its new, random position.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ ... 它将原始字符复制到其新的随机位置。
- en: ❽ Updates the index
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 更新索引
- en: ❾ Copies the randomized array into the passed array
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将随机化后的数组复制到传递的数组
- en: 'To call the *scramble()* function, update the code from randomp03.c. First
    add the *scramble()* function somewhere before the *main()* function. This position
    negates the need to prototype the function earlier in the source code file. Then
    insert the following line before the *printf()* statement in the *main()* function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *scramble()* 函数时，需要从 randomp03.c 文件中更新代码。首先，在 *main()* 函数之前某个位置添加 *scramble()*
    函数。这个位置消除了在源代码文件中更早地原型化函数的需要。然后，在 *main()* 函数中的 *printf()* 语句之前插入以下行：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The full source code is available as randomp04.c in the book’s online repository.
    Here is sample output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码作为 randomp04.c 在书籍的在线存储库中可用。以下是示例输出：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Yay! It’s still a horrible password to memorize or type, but it’s blessedly
    randomized.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！这仍然是一个难以记忆或输入的糟糕密码，但它幸运地是随机的。
- en: 'Further modification to the code can be made to adjust the password length
    and the specific number of the different type of characters. I had originally
    thought of presenting command-line switches to set the number of options and overall
    password length. For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步修改代码以调整密码长度和不同类型字符的具体数量。我最初想过提供命令行开关来设置选项数量和整体密码长度。例如：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These arguments set one uppercase letter, six lowercase letters, one number,
    and two symbols. These options allow for more flexibility in creating the password.
    You could take the idea further and specify which symbols to include in the random
    password. Oh! I could go nuts coding this thing, but personally I prefer to use
    words in my passwords, so I’m moving on to the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数设置了一个大写字母，六个小写字母，一个数字和两个符号。这些选项在创建密码时提供了更多的灵活性。你可以进一步扩展这个想法，并指定要包含在随机密码中的符号。哦！我可以疯狂地编写这个程序，但就我个人而言，我更喜欢在密码中使用单词，所以我将进入下一部分。
- en: 6.3 Words in passwords
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 密码中的单词
- en: I gave up on jumbled passwords years ago. My preferred approach is to string
    a few random words together, along with the requisite capital letter and symbol,
    and at the desired length. This approach is far easier to remember and type. In
    fact, I still remember my old CompuServe password, with was just two words separated
    by a number. A password generator that spews forth words and the proper quantities
    of symbols and such is far more useful and interesting to code than the random
    password generator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我多年前就放弃了混乱的密码。我更喜欢的方法是将几个随机单词连在一起，加上必要的首字母和符号，以及所需的长度。这种方法更容易记忆和输入。事实上，我仍然记得我旧的计算器服务密码，它只是由两个单词和一个数字分隔。
- en: 6.3.1 Generating random words, Mad Libs style
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 以 Mad Libs 风格生成随机单词
- en: To build a random word password generator, you need a routine that spits out
    random words. If they’re to be legitimate words, you most likely need some type
    of list from which to extract the words. Writing a word-generating function is
    a good approach, plus it gives you an opportunity to create a list of words you
    like, silly words, or words you frequently say in Walmart.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个随机单词密码生成器，你需要一个输出随机单词的程序。如果它们要成为合法的单词，你很可能需要某种类型的列表来从中提取单词。编写一个单词生成函数是一个好方法，同时这也给你一个机会创建一个你喜欢的单词列表，愚蠢的单词，或者你在沃尔玛经常说的单词。
- en: 'Listing 6.4 highlights my *add_word()* function as it appears in the source
    code file randwords01.c. The function contains a dozen words (actually pointers
    to strings) in array vocabulary[]. Variable r holds a random value in the range
    of zero to the number of elements in the array: sizeof(vocabulary) returns the
    number of bytes occupied by the array. This value is divided by sizeof(char *),
    which is the size of each element in the array—a *char* pointer. The result is
    12, which means r holds a random number from 0 through 11\. This expression ensures
    that no matter how many words are in the array, the random number calculated is
    in the proper range. The function returns the random array element, a pointer
    to a string.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 突出了在源代码文件 randwords01.c 中出现的 *add_word()* 函数。该函数包含数组 vocabulary[] 中的十二个单词（实际上是字符串指针）。变量
    r 在 0 到数组元素数量之间的随机值范围内：sizeof(vocabulary) 返回数组占用的字节数。这个值除以 sizeof(char *)，即数组中每个元素的大小——一个
    *char* 指针。结果是 12，这意味着 r 包含一个从 0 到 11 的随机数。这个表达式确保无论数组中有多少单词，计算出的随机数都在正确的范围内。该函数返回随机数组元素，一个指向字符串的指针。
- en: Listing 6.4 The *add_word()* function in randwords01.c
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 randwords01.c 中的 *add_word()* 函数
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ This macro makes the *for* loop more readable in the *main()* function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个宏使得 *main()* 函数中的 *for* 循环更易于阅读。
- en: ❷ Generates a random value, zero through the number of elements in the array
    (minus one)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个随机值，从零到数组中元素的数量（减一）
- en: ❸ Returns the random element—the word
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回随机元素——单词
- en: ❹ Outputs three random words
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出三个随机单词
- en: 'The code calls the *add_word()* function thrice, though no guarantee is provided
    to prevent the same word from repeating, as shown in this sample output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码三次调用 *add_word()* 函数，尽管没有提供防止相同单词重复的保证，如下所示：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a C programmer, you could add code to prevent duplicates from appearing in
    the output, but I would offer that a repeated word is also random. Still, this
    code is merely one step in a longer process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 C 语言程序员，你可以添加代码以防止输出中出现重复的单词，但我认为重复的单词也是随机的。尽管如此，这段代码只是更长过程的一步。
- en: After writing the randwords01.c code, I felt inspired to ape the famous Mad
    Libs word game. Mad Libs is a registered trademark of Penguin Random House LLC
    and is fairly used here for educational purposes. Please don’t sue me.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 randwords01.c 代码后，我受到了模仿著名 Mad Libs 字词游戏的启发。Mad Libs 是企鹅兰登书屋 LLC 的注册商标，在此仅用于教育目的。请不要起诉我。
- en: 'The first step in coding a Mad Libs program, all while avoiding a lawsuit,
    is crafting several functions along the lines of *add_word()* used in the randwords01.c
    code. You must write one function for each word category as found in a Mad Libs:
    *add_noun()*, *add_verb()*, and *add_adjective()*, for example. Each function
    is populated with its own vocabulary[] array, packed with the corresponding word
    types: nouns, verbs, and adjectives. The *main()* function calls each function
    as required to fill in the blanks for a Mad Libs-like sentence, carefully crafted
    to avoid legal peril, such as the deliberately weak and unfunny example shown
    here.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Mad Libs 程序的第一步，同时避免诉讼，是制作几个类似于 randwords01.c 代码中使用的 *add_word()* 函数。你必须为
    Mad Libs 中发现的每个单词类别编写一个函数，例如：*add_noun()*, *add_verb()*, 和 *add_adjective()*。每个函数都包含自己的词汇数组，填充了相应的单词类型：名词、动词和形容词。*main()*
    函数根据需要调用每个函数，以填充类似 Mad Libs 的句子中的空白，并精心制作以避免法律风险，如这里故意制作得弱智且不幽默的示例。
- en: Listing 6.5 The *main()* function from madlib01.c
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 来自 madlib01.c 的 *main()* 函数
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Seeds the randomizer
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为随机数生成器设置种子
- en: ❷ Outputs the first part of the sentence
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出句子的第一部分
- en: ❸ Fills in the adjective blank
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 填充形容词空白
- en: ❹ Fills in a noun blank
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 填充一个名词空白
- en: ❺ Outputs the last part of the sentence
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出句子的最后一部分
- en: ❻ Fills in the verb blank
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 填充动词空白
- en: ❼ Fills in another noun blank
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 填充另一个名词空白
- en: 'Yes, my Mad Libs prototype is embarrassing. If you really want to treat yourself
    to a good Mad Libs, obtain one of the books from Leonard Stern and Roger Price
    because they won’t sic their lawyers on me. Still, the code works, fetching a
    random word from each of the functions. The output is less than hilarious, which,
    like any Mad Libs game, depends on good word choices:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我的 Mad Libs 原型很尴尬。如果你真的想享受一次好的 Mad Libs，可以获取 Leonard Stern 和 Roger Price
    的书籍，因为他们不会让他们的律师来找我。尽管如此，代码是有效的，从每个函数中随机获取一个单词。输出并不好笑，就像任何 Mad Libs 游戏，取决于好的单词选择：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One way to add a richer variety of words to the various functions is to take
    the code a step further and read words from a vocabulary text file. For example,
    a noun.txt file contains dozens or hundreds of nouns, each on a line by itself.
    This format keeps the list accessible, easy to view and edit. Similar files could
    be created for other word types: verb.txt, adjective.txt, and so on.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给各种函数添加更丰富的词汇多样性，可以将代码进一步扩展，并从词汇文本文件中读取单词。例如，noun.txt 文件包含数十个或数百个名词，每个名词单独一行。这种格式使列表易于访问、查看和编辑。可以创建类似文件用于其他单词类型：verb.txt、adjective.txt
    等。
- en: 'To read through the files and pluck out a random word, you can borrow a technique
    presented in chapter 2: the “pithy saying” series of programs ended with code
    that read from a text file, stored all the lines from the file, and then selected
    a random line of text for output. This approach can be used in an update to the
    Mad Libs program, where three separate files are scanned for random words. The
    code from chapter 2 is incorporated into the *build_vocabulary()* function found
    in my updated Mad Libs program.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取文件并从中随机抽取单词，你可以借鉴第 2 章中介绍的技术：“pithy saying” 系列程序以读取文本文件的代码结束，存储了文件的所有行，然后随机选择一行文本进行输出。这种方法可以用于更新
    Mad Libs 程序，其中扫描三个单独的文件以获取随机单词。第 2 章的代码被整合到我的更新版 Mad Libs 程序中的 *build_vocabulary()*
    函数中。
- en: In the next listing, you see the *main()* function from my updated Mad Libs
    program, madlib02.c. To handle numerous problems, and effectively shunt a lot
    of the work to the *build_vocabulary()* function, I chose to use structures to
    hold information about the various types of words. The output is lamentably the
    same pathetic text generated by the madlib01.c program.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，您可以看到我的更新版Mad Libs程序madlib02.c中的*main()*函数。为了处理众多问题，并将大量工作有效地转移到*build_vocabulary()*函数，我选择使用结构来保存有关各种类型单词的信息。遗憾的是，输出与madlib01.c程序生成的可悲文本相同。
- en: Listing 6.6 The *main()* function from madlib02.c
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 madlib02.c中的*main()*函数
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Structures are declared and defined, saving lotsa code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明和定义结构，节省了大量代码。
- en: ❷ The *build_vocabulary()* function reads words from a file and creates a list
    in memory with each word indexed. This information is saved in the term structure
    specific to each word type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ *build_vocabulary()*函数从文件中读取单词并创建一个内存中的列表，每个单词都有一个索引。这些信息保存在针对每种单词类型的特定术语结构中。
- en: ❸ The *add_word()* function reads well in English, making the code understandable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ *add_word()*函数的英文读起来很好，使代码易于理解。
- en: The *main()* function begins by defining three term structures to hold and reference
    the types of words to fill in the Mad Libs. Each member in the structure is defined,
    with NULL constants set for the two pointer items.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*main()*函数首先定义三个术语结构来保存和引用要填充Mad Libs的单词类型。结构中的每个成员都被定义，两个指针项设置为NULL常量。'
- en: 'Here is the unfunny output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是无聊的输出：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can view the entire source code file found in this book’s online repository.
    It’s named madlib02.c. It helps if you have this code visible in your editor as
    I discuss the details over the next few pages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看本书在线仓库中找到的整个源代码文件。它命名为madlib02.c。如果您在编辑器中可以看到此代码，那么在接下来的几页中讨论细节时会很有帮助。
- en: 'The workhorse in the madlib02.c code is the *build_vocabulary()* function.
    It relies upon the term structure, which is defined externally so that it’s visible
    to all the functions in the source code file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: madlib02.c代码中的工作马是*build_vocabulary()*函数。它依赖于术语结构，该结构在外部定义，以便在源代码文件中的所有函数中可见：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ A string representing the filename to open
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示要打开的文件名的字符串
- en: ❷ A FILE pointer referencing the open file listed in the filename member
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指向在filename成员中列出的打开文件的FILE指针
- en: ❸ The total number of words extracted from the file
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从文件中提取的单词总数
- en: ❹ A block of memory containing pointers referencing each word extracted from
    the file
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含指向从文件中提取的每个单词的指针的内存块
- en: 'By throwing these items in a structure, each call to the *build_vocabulary()*
    function needs only one argument. The *build_vocabulary()* function is based on
    the source code for pithy05.c (covered in chapter 2). Major retooling is done
    to use the passed structure members instead of local variables, but most of the
    code remains the same. Here is the prototype:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些项放入一个结构中，每次调用*build_vocabulary()*函数只需要一个参数。*build_vocabulary()*函数基于pithy05.c的源代码（在第2章中介绍）。对代码进行了大量重整，以使用传递的结构成员而不是局部变量，但大部分代码保持不变。以下是原型：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The structure is passed as a pointer, struct term *t, which allows the function
    to modify the structure’s members and have the updated data retained. Otherwise,
    when the structure is passed directly (not as a pointer), any changes are abandoned
    when the function terminates. Because a pointer is passed, structure pointer notation
    (->) is used within the function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结构作为指针传递，struct term *t，这允许函数修改结构成员并保留更新后的数据。否则，当结构直接传递（而不是作为指针）时，任何更改都会在函数结束时丢失。因为传递了一个指针，所以在函数内部使用结构指针表示法（->）。
- en: 'The *build_vocabulary()* function performs these tasks:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*build_vocabulary()*函数执行以下任务：'
- en: Open the t->filename member, saving the FILE pointer in variable t->fp upon
    success.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开t->filename成员，在成功的情况下将FILE指针保存在变量t->fp中。
- en: Allocate storage for the t->list_base member, which eventually references all
    strings read from the file.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为t->list_base成员分配存储空间，该成员最终引用从文件中读取的所有字符串。
- en: 'A *while* loop reads each string (word) from the file. It performs these tasks:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*while*循环从文件中读取每个字符串（单词）。它执行以下任务：
- en: Fetches the string and double-checks to confirm the EOF isn’t encountered.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取字符串并双检查以确认没有遇到文件结束符EOF。
- en: Allocates memory for the string.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为字符串分配内存。
- en: Copies the string into allocated memory.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串复制到分配的内存中。
- en: Removes the newline (\n) from the string. This step isn’t found in the original
    pithy05.c code. It’s required to ensure that the word returned doesn’t contain
    a newline.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串中删除换行符(\n)。这一步在原始的pithy05.c代码中没有找到。这是确保返回的单词不包含换行符所必需的。
- en: Confirms that the t->list_base buffer isn’t full. If so, reallocates the buffer
    to a larger size.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认t->list_base缓冲区没有满。如果是这样，则将缓冲区重新分配到更大的大小。
- en: 'The last step takes place after the *while* loop is done:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步发生在*while*循环完成后：
- en: Closes the open file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭打开的文件。
- en: At the end of the function, the items member of the structure contains a count
    of all the words read from the file. The list_base member contains the addresses
    for each string stored in memory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数结束时，结构体的items成员包含从文件中读取的所有单词的计数。list_base成员包含存储在内存中每个字符串的地址。
- en: 'The *main()* function in listing 6.6 also references the *add_word()* function.
    This function doesn’t require a pointer as an argument because it doesn’t modify
    the structure’s contents. Here is the add_word() function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6中的*main()*函数也引用了*add_word()*函数。这个函数不需要作为参数传递指针，因为它不会修改结构体的内容。以下是add_word()函数：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The function returns a *char* pointer, a string.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数返回一个*char*指针，即一个字符串。
- en: ❷ Generates a random value ranging from zero to the number of items
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个介于零和项目数量之间的随机值
- en: ❸ References a random word stored at t.list_base, and returns its address
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 引用存储在t.list_base中的随机单词，并返回其地址
- en: Most of the add_word() function exists in the original pithy05.c code. It was
    set into a function here because it’s called with different structures, each one
    representing a grammatical word category.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分add_word()函数存在于原始的pithy05.c代码中。它被设置为函数，因为它是用不同的结构体调用的，每个结构体代表一个语法单词类别。
- en: These programs can be used in any application where words stored in a file must
    be fetched and referenced as a program runs. By keeping the words stored in memory,
    the list can be accessed multiple times without having to reread the file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序可以在任何需要程序运行时从文件中检索并引用存储的单词的应用中使用。通过在内存中保留单词，可以在不重新读取文件的情况下多次访问列表。
- en: 6.3.2 Building a random word password generator
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 构建随机单词密码生成器
- en: You can craft two different types of random word password programs based on
    the two versions of the Mad Libs programs shown in the preceding section. The
    first program (madlib01.c) uses arrays to store a series of random words. For
    more variety, however, you can use the second (madlib02.c) code to take advantage
    of files that store your favorite password words.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据前述部分中显示的两个Mad Libs程序的版本制作两种不同类型的随机单词密码程序。第一个程序(madlib01.c)使用数组存储一系列随机单词。然而，为了增加多样性，您还可以使用第二个(madlib02.c)代码来利用存储您最喜欢的密码单词的文件。
- en: 'The easy version of the random word password generator works like the earlier
    *randomp* series of programs, specifically from the source code for randomp04.c.
    The goal is to create functions that return specific password pieces: a random
    word, a random number, and a random symbol. The words should already be mixed
    case. My version is named passwords01.c, and it’s found in this book’s online
    repository. Open it in an editor window so that you can follow along in the text.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随机单词密码生成器的简单版本与早期的*randomp*系列程序类似，特别是来自randomp04.c的源代码。目标是创建返回特定密码片段的函数：一个随机单词、一个随机数字和一个随机符号。单词应该已经是混合大小写。我的版本命名为passwords01.c，可以在本书的在线存储库中找到。在编辑器窗口中打开它，以便在文本中跟随。
- en: 'The *number()* and *symbol()* functions are retained from the earlier code,
    though each now returns a string as opposed to a single character. A *static char*
    array holds the character to return as two-character string: The random character
    is saved in the first element, and a null character is saved in the second, making
    the array a string. Here are both functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*number()*和*symbol()*函数是从早期代码中保留下来的，尽管现在每个函数都返回一个字符串而不是单个字符。一个*static char*数组用于存储要返回的两个字符字符串：随机字符存储在数组的第一个元素中，而空字符存储在第二个元素中，使数组成为一个字符串。以下是这两个函数：'
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ The *static* array’s contents are retained when the function terminates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当函数结束时，保留*static*数组的所有内容。
- en: ❷ Generates a random character, 0 through 9, storing it as the first element
    of array n[]
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个随机字符，0到9之间，将其存储为数组n[]的第一个元素
- en: ❸ Caps the string with a null character
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在字符串末尾添加一个空字符
- en: ❹ Plucks a random character from the sym[] array and sets it as the first element
    of array n[]
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从sym[]数组中抽取一个随机字符，并将其设置为数组n[]的第一个元素
- en: 'To generate words for the password, I borrowed the *add_noun()* function from
    madlib01.c, changing it to reflect a series of random words with a few uppercase
    letters thrown in:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成密码的单词，我从 madlib01.c 中借用了 *add_noun()* 函数，并将其修改为反映一系列带有几个大写字母的随机单词：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What I didn’t need from the randomp04.c code were the functions *scramble()*,
    *uppercase()*, and *lowercase()*. The *main()* function, shown here, assembles
    everything into the final password string.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要从 randomp04.c 代码中提取 *scramble()*, *uppercase()*, 和 *lowercase()* 函数。这里显示的
    *main()* 函数将所有内容组装成最终的密码字符串。
- en: Listing 6.7 The *main()* function from passwords01.c
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 passwords01.c 的 *main()* 函数
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Storage where the password is built
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储密码的地方
- en: ❷ Initializes the string so that the *strcpy()* function doesn’t puke
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化字符串，以便 *strcpy()* 函数不会崩溃
- en: ❸ Copies the first word generated into the password[] array
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将生成的第一个单词复制到 password[] 数组中
- en: ❹ Appends a number
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 添加一个数字
- en: ❺ Appends the second word
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 添加第二个单词
- en: ❻ Appends a symbol
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 添加一个符号
- en: ❼ Appends the final word
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 添加最后一个单词
- en: 'Here is a sample run:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Nothing is done in the code to prevent a word from being repeated, and the output
    might be missing an uppercase letter. But if you don’t like the words, add more
    by expanding the vocabulary[] array in the *add_word()* function. Or, better,
    devise a system where you have files containing words you like to use in a password,
    like the way the second Mad Libs program works. In fact, you can use the same
    word files, noun.txt, verb.txt, and adjective.txt.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中没有做任何操作来防止单词重复，输出可能缺少一个大写字母。但如果你不喜欢这些单词，可以在 *add_word()* 函数中扩展 vocabulary[]
    数组来添加更多单词。或者，更好的是，设计一个系统，其中包含包含你想要在密码中使用的单词的文件，就像第二个 Mad Libs 程序那样工作。实际上，你可以使用相同的单词文件，noun.txt、verb.txt
    和 adjective.txt。
- en: My source code for passwords02.c pulls in elements from both passwords01.c and
    madlib02.c—specifically, the *build_vocabulary()* function that reads words from
    a file and stores them in memory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 passwords02.c 的源代码从 passwords01.c 和 madlib02.c 中提取了元素——特别是从文件中读取单词并将其存储在内存中的
    *build_vocabulary()* 函数。
- en: You can see how both source code files are merged by examining the *main()*
    function from passwords02.c in the following listing. Yes, I’m being lazy with
    this code, where the first part of the *main()* function pulled from the *Mad
    Libs* program and the second part from passwords02.c. The output is a string containing
    three random words, a random number, and a random symbol.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看以下列表中 passwords02.c 的 *main()* 函数来了解两个源代码文件是如何合并的。是的，我在这段代码上偷懒了，其中 *main()*
    函数的前半部分是从 *Mad Libs* 程序中拉取的，后半部分是从 passwords02.c 中来的。输出是一个包含三个随机单词、一个随机数字和一个随机符号的字符串。
- en: Listing 6.8 The *main()* function from passwords02.c
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 passwords02.c 的 *main()* 函数
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Stolen from the first *passwords* code
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从第一个 *passwords* 代码中窃取
- en: ❷ Stolen from madlib02.c
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 madlib02.c 中窃取
- en: ❸ Always cap a string you build!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 建立字符串时总是大写！
- en: 'Here is a sample run, which isn’t any different from the passwords01.c code’s
    program output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行，它与 passwords01.c 代码的程序输出没有区别：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On a positive note, this password output is far more hilarious than the output
    from any of my Mad Libs programs. Still, it has a password problem: where is the
    uppercase letter?'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这个密码输出比我的任何 Mad Libs 程序的输出都要有趣得多。然而，它仍然存在密码问题：大写字母在哪里？
- en: Exercise 6.3
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.3
- en: Add another function to the source code from passwords02.c to create a new source
    code file, passwords03.c. This new function, *check_caps()*, examines a string
    for an uppercase letter. If no uppercase letter is found, the function converts
    a lowercase letter to uppercase at some random position within the string. My
    solution is available online as passwords03.c, but try this exercise on your own
    before you sneak off to see how I did it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将 passwords02.c 中的另一个函数添加到源代码中，以创建一个新的源代码文件 passwords03.c。这个新函数，*check_caps()*，检查一个字符串中是否有大写字母。如果没有找到大写字母，该函数将字符串中的某个随机位置的小写字母转换为大写字母。我的解决方案作为
    passwords03.c 在线提供，但在你偷偷溜去看我是如何做到的之前，请先自己尝试这个练习。
