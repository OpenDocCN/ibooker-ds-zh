- en: 5 Genetic algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 遗传算法
- en: Genetic algorithms are not used for everyday programmatic problems. They are
    called upon when traditional algorithmic approaches are insufficient for arriving
    at a solution to a problem in a reasonable amount of time. In other words, genetic
    algorithms are usually reserved for complex problems without easy solutions. If
    you need a sense of what some of these complex problems might be, feel free to
    read ahead in section 5.7 before proceeding. One interesting example, though,
    is protein-ligand docking and drug design. Computational biologists need to design
    molecules that will bind to receptors to deliver drugs. There may be no obvious
    algorithm for designing a particular molecule, but as you will see, sometimes
    genetic algorithms can provide an answer without much direction beyond a definition
    of the goal of a problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法不用于日常编程问题。当传统算法方法不足以在合理的时间内解决问题时，才会被调用。换句话说，遗传算法通常保留用于复杂问题，这些问题没有简单的解决方案。如果您需要了解一些可能存在的复杂问题，请在继续之前，自由地阅读第5.7节。然而，有一个有趣的例子，那就是蛋白质-配体对接和药物设计。计算生物学家需要设计能够与受体结合以递送药物的分子。可能没有明显的算法来设计特定的分子，但正如您将看到的，有时遗传算法可以在没有太多方向性指导的情况下提供答案，除了定义问题的目标。
- en: 5.1 Biological background
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 生物背景
- en: In biology, the theory of evolution is an explanation of how genetic mutation,
    coupled with the constraints of an environment, leads to changes in organisms
    over time (including speciation--the creation of new species). The mechanism by
    which the well-adapted organisms succeed and the less well-adapted organisms fail
    is known as natural selection. Each generation of a species will include individuals
    with different (and sometimes new) traits that come about through genetic mutation.
    All individuals compete for limited resources to survive, and because there are
    more individuals than there are resources, some individuals must die.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在生物学中，进化论是对遗传突变与环境约束相结合，如何导致生物体随时间变化（包括物种形成——新物种的创造）的解释。适应良好的生物体成功而适应不良的生物体失败这一机制被称为自然选择。每个物种的每一代都会包括具有不同（有时是新的）特征的个人，这些特征是通过遗传突变产生的。所有个体为了生存而争夺有限的资源，由于个体数量多于资源，因此一些个体必须死亡。
- en: An individual with a mutation that makes it better adapted for survival in its
    environment will have a higher probability of living and reproducing. Over time,
    the better-adapted individuals in an environment will have more children and through
    inheritance will pass on their mutations to those children. Therefore, a mutation
    that benefits survival is likely to eventually proliferate among a population.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有使其在环境中更好地适应生存的突变的个体，将有更高的生存和繁殖概率。随着时间的推移，环境中适应良好的个体将会有更多的孩子，并通过遗传将这些突变传递给后代。因此，有利于生存的突变很可能最终在种群中传播。
- en: For example, if bacteria are being killed by a specific antibiotic, and one
    individual bacterium in the population has a mutation in a gene that makes it
    more resistant to the antibiotic, it is more likely to survive and reproduce.
    If the antibiotic is continually applied over time, the children who have inherited
    the gene for antibiotic resistance will also be more likely to reproduce and have
    children of their own. Eventually the whole population may gain the mutation,
    as continued assault by the antibiotic kills off the individuals without the mutation.
    The antibiotic does not cause the mutation to develop, but it does lead to the
    proliferation of individuals with the mutation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果细菌正在被一种特定的抗生素杀死，并且种群中有一个细菌个体在某个基因上发生了突变，使其对这种抗生素的抵抗力更强，那么它更有可能存活并繁殖。如果抗生素持续使用，那么继承了抗生素耐药基因的后代也更有可能繁殖并有自己的后代。最终，整个种群可能会获得这种突变，因为抗生素的持续攻击杀死了没有突变的个体。抗生素不会导致突变的发展，但它确实导致了具有突变的个体的增殖。
- en: Natural selection has been applied in spheres beyond biology. Social Darwinism
    is natural selection applied to the sphere of social theory. In computer science,
    genetic algorithms are a simulation of natural selection to solve computational
    challenges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 自然选择已应用于生物学之外的领域。社会达尔文主义是将自然选择应用于社会理论领域。在计算机科学中，遗传算法是对自然选择的模拟，用于解决计算挑战。
- en: A genetic algorithm includes a population (group) of individuals known as chromosomes.
    The chromosomes, each composed of genes that specify their traits, compete to
    solve some problem. How well a chromosome solves a problem is defined by a fitness
    function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法包括一个称为染色体的个体群体（组）。染色体由基因组成，这些基因指定了它们的特征，它们为了解决某个问题而竞争。染色体解决问题的好坏由适应度函数定义。
- en: The genetic algorithm goes through generations. In each generation, the chromosomes
    that are more fit are more likely to be selected to reproduce. There is also a
    probability in each generation that two chromosomes will have their genes merged.
    This is known as crossover. And finally, there is the important possibility in
    each generation that a gene in a chromosome may mutate (randomly change).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法会经历多个世代。在每一代中，适应性更强的染色体更有可能被选中进行繁殖。在每一代中，也有两个染色体合并其基因的概率。这被称为交叉。最后，在每一代中，染色体中的一个基因可能会发生变异（随机改变）。
- en: After the fitness function of some individual in the population crosses some
    specified threshold, or the algorithm runs through some specified maximum number
    of generations, the best individual (the one that scored highest in the fitness
    function) is returned.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当种群中某个个体的适应度函数超过某个特定的阈值，或者算法运行了指定的最大代数时，返回最佳个体（在适应度函数中得分最高的个体）。
- en: 'Genetic algorithms are not a good solution for all problems. They depend on
    three partially or fully stochastic (randomly determined) operations: selection,
    crossover, and mutation. Therefore, they may not find an optimal solution in a
    reasonable amount of time. For most problems, more deterministic algorithms exist
    with better guarantees. But there are problems for which no fast deterministic
    algorithm is known to exist. In these cases, genetic algorithms are a good choice.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法并不是所有问题的良好解决方案。它们依赖于三个部分或全部随机的（随机确定的）操作：选择、交叉和变异。因此，它们可能无法在合理的时间内找到最优解。对于大多数问题，存在更多确定性的算法，并提供了更好的保证。但是，对于某些问题，尚未知道存在快速确定性算法。在这些情况下，遗传算法是一个好的选择。
- en: 5.2 A generic genetic algorithm
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 一个通用的遗传算法
- en: Genetic algorithms are often highly specialized and tuned for a particular application.
    In this chapter, we will define a generic genetic algorithm that can be used with
    multiple problems while not being particularly well tuned for any of them. It
    will include some configurable options, but the goal is to show the algorithm’s
    fundamentals instead of its tunability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法通常高度专业化，针对特定应用进行了调整。在本章中，我们将定义一个通用的遗传算法，它可以用于多个问题，而不会对任何问题特别优化。它将包括一些可配置的选项，但目标是展示算法的基本原理，而不是其可调整性。
- en: 'We will start by defining an interface for the individuals that the generic
    algorithm can operate on. The abstract class Chromosome defines five essential
    features. A chromosome must be able to do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个接口，该接口是通用算法可以操作的个人。抽象类Chromosome定义了五个基本特征。一条染色体必须能够执行以下操作：
- en: Determine its own fitness
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定自己的适应度
- en: Implement crossover (combine itself with another of the same type to create
    children)--in other words, mix itself with another chromosome
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现交叉（将自己与另一个相同类型的染色体结合以创建子代）——换句话说，与另一个染色体混合
- en: Mutate--make a small, fairly random change in itself
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异——对自己进行小而相对随机的改变
- en: Copy itself
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制自身
- en: Compare itself to other chromosomes of the same type
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自己与其他相同类型的染色体进行比较
- en: Here is the code for Chromosome, codifying these five needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Chromosome的代码，编码了这五个需求。
- en: Listing 5.1 Chromosome.java
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 Chromosome.java
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: NOTE You’ll notice that Chromosome’s generic type T is bound to Chromosome itself
    (Chromosome<T extends Chromosome<T>>). This means that anything that fills in
    for type T must be a subclass of Chromosome. This is helpful for the methods crossover(),
    copy(), and compareTo() since we want the implementations of these methods to
    be operating with relation to other chromosomes of the same type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你会注意到Chromosome的泛型类型T被绑定到Chromosome本身（Chromosome<T extends Chromosome<T>>）。这意味着任何填充类型T的东西都必须是Chromosome的子类。这对于crossover()、copy()和compareTo()方法很有帮助，因为我们希望这些方法的实现能够与相同类型的其他染色体相关联。
- en: 'We will implement the algorithm itself (the code that will manipulate chromosomes)
    as a generic class that is open to subclassing for future specialized applications.
    Before we do so, though, let’s revisit the description of a genetic algorithm
    from the beginning of the chapter and clearly define the steps that a genetic
    algorithm takes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现算法本身（将操作染色体的代码）作为一个通用的类，该类可以用于未来专门应用的子类化。但在这样做之前，让我们重新回顾一下本章开头对遗传算法的描述，并明确定义遗传算法采取的步骤：
- en: Create an initial population of random chromosomes for the first generation
    of the algorithm.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为算法的第一代创建一个随机的染色体初始种群。
- en: Measure the fitness of each chromosome in this generation of the population.
    If any exceeds the threshold, return it, and the algorithm ends.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量种群中每个染色体的适应性。如果任何染色体超过阈值，则返回它，算法结束。
- en: Select some individuals to reproduce, with a higher probability of selecting
    those with the highest fitness.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一些个体进行繁殖，以更高的概率选择适应性最高的个体。
- en: Crossover (combine), with some probability, some of the selected chromosomes
    to create children that represent the population of the next generation.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以一定的概率进行交叉（组合），将一些选中的染色体组合成代表下一代种群的孩子。
- en: Mutate, usually with a low probability, some of those chromosomes. The population
    of the new generation is now complete, and it replaces the population of the last
    generation.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以低概率变异一些染色体。新的一代种群现在完成，并取代上一代的种群。
- en: Return to step 2 unless the maximum number of generations has been reached.
    If that is the case, return the best chromosome found so far.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到步骤2，除非达到最大代数。如果是这种情况，则返回迄今为止找到的最佳染色体。
- en: This general outline of a genetic algorithm (illustrated in figure 5.1) is missing
    a lot of important details. How many chromosomes should be in the population?
    What is the threshold that stops the algorithm? How should the chromosomes be
    selected for reproduction? How should they be combined (crossover) and at what
    probability? At what probability should mutations occur? How many generations
    should be run?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个遗传算法的一般概述（如图5.1所示）缺少很多重要细节。种群中应该有多少个染色体？停止算法的阈值是多少？如何选择染色体进行繁殖？如何组合（交叉）以及以什么概率？以什么概率发生变异？应该运行多少代？
- en: '![5-1](../Images/5-1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![5-1](../Images/5-1.png)'
- en: Figure 5.1 The general outline of a genetic algorithm
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 遗传算法的一般概述
- en: All of these points will be configurable in our GeneticAlgorithm class. We will
    define it piece by piece so we can talk about each piece separately.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些点都将可在我们的GeneticAlgorithm类中进行配置。我们将逐步定义它，这样我们就可以单独讨论每个部分。
- en: Listing 5.2 GeneticAlgorithm.java
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 GeneticAlgorithm.java
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: GeneticAlgorithm takes a generic type that conforms to Chromosome, and its name
    is C. The enum SelectionType is an internal type used for specifying the selection
    method used by the algorithm. The two most common genetic algorithm selection
    methods are known as roulette-wheel selection (sometimes called fitness proportionate
    selection) and tournament selection. The former gives every chromosome a chance
    of being picked, proportionate to its fitness. In tournament selection, a certain
    number of random chromosomes are challenged against one another, and the one with
    the best fitness is selected.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GeneticAlgorithm接受一个符合Chromosome泛型的泛型类型，其名称为C。枚举SelectionType是一个内部类型，用于指定算法使用的选择方法。两种最常用的遗传算法选择方法被称为轮盘赌选择（有时称为适应性比例选择）和锦标赛选择。前者给每个染色体一个被选中的机会，与它的适应性成比例。在锦标赛选择中，一定数量的随机染色体相互竞争，具有最佳适应性的染色体被选中。
- en: Listing 5.3 GeneticAlgorithm.java continued
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 GeneticAlgorithm.java继续
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding constructor defines several properties of the genetic algorithm
    that will be configured at the time of creation. initialPopulation is the chromosomes
    in the first generation of the algorithm. mutationChance is the probability of
    each chromosome in each generation mutating. crossoverChance is the probability
    that two parents selected to reproduce have children that are a mixture of their
    genes; otherwise, the children are just duplicates of the parents. Finally, selectionType
    is the type of selection method to use, as delineated by the enum SelectionType.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个构造函数定义了遗传算法在创建时将配置的几个属性。initialPopulation 是算法第一代的染色体。mutationChance 是每一代中每个染色体的突变概率。crossoverChance
    是两个被选中繁殖的父母产生混合了他们基因的孩子的概率；否则，孩子只是父母的复制品。最后，selectionType 是要使用的选择方法的类型，如 SelectionType
    枚举所定义的。
- en: In our example problems later in the chapter, population is initialized with
    a random set of chromosomes. In other words, the first generation of chromosomes
    is just composed of random individuals. This is a point of potential optimization
    for a more sophisticated genetic algorithm. Instead of starting with purely random
    individuals, the first generation could contain individuals that are closer to
    the solution, through some knowledge of the problem. This is referred to as seeding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的示例问题中，种群以一组随机染色体初始化。换句话说，染色体的第一代只是由随机个体组成。这是更复杂的遗传算法的一个潜在的优化点。不是从完全随机的个体开始，第一代可以包含更接近解决方案的个体，这需要一些对问题的了解。这被称为播种。
- en: Now we will examine the two selection methods that our class supports.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查我们的类支持的两个选择方法。
- en: Listing 5.4 GeneticAlgorithm.java continued
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 GeneticAlgorithm.java 续
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Roulette-wheel selection is based on each chromosome’s proportion of fitness
    to the sum of all fitness values in a generation. The chromosomes with the highest
    fitness have a better chance of being picked. The values that represent each chromosome’s
    percentage of total fitness are provided in the parameter wheel. These percentages
    are represented by floating-point values between 0 and 1\. A random number (pick)
    between 0 and 1 is used to figure out which chromosome to select. The algorithm
    works by decreasing pick by each chromosome’s proportional fitness value sequentially.
    When it crosses 0, that’s the chromosome to select.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 轮盘赌选择基于每个染色体在一代中相对于所有适应度值的比例。适应度最高的染色体有更大的机会被选中。代表每个染色体总适应度百分比的价值由 wheel 参数提供。这些百分比由介于
    0 和 1 之间的浮点数表示。使用介于 0 和 1 之间的随机数（pick）来确定选择哪个染色体。算法通过按顺序减少 pick 的每个染色体的比例适应度值来工作。当它穿过
    0 时，那就是要选择的染色体。
- en: Does it make sense to you why this process results in each chromosome being
    pickable by its proportion? If not, think about it with pencil and paper. Consider
    drawing a proportional roulette wheel, as in figure 5.2.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你能理解为什么这个过程会导致每个染色体按其比例可被选中吗？如果不能，用铅笔和纸思考一下。考虑绘制一个如图 5.2 所示的成比例的轮盘赌。
- en: The most basic form of tournament selection is simpler than roulette-wheel selection.
    Instead of figuring out proportions, we simply pick numParticipants chromosomes
    from the whole population at random. The numPicks chromosomes with the best fitness
    out of the randomly selected bunch win.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 轮盘赌选择的最基本形式比轮盘赌选择简单。我们不是计算比例，而是简单地从整个种群中随机选择 numParticipants 个染色体。在随机选择的群体中，适应度最好的
    numPicks 个染色体获胜。
- en: Listing 5.5 GeneticAlgorithm.java continued
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 GeneticAlgorithm.java 续
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![5-2](../Images/5-2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![5-2](../Images/5-2.png)'
- en: Figure 5.2 An example of roulette-wheel selection in action
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 轮盘赌选择动作的示例
- en: The code for pickTournament() first uses shuffle() to randomize the order of
    the population, and then takes the first numParticipants from the population.
    This is just a simple way of getting numParticipants random chromosomes. Next,
    it sorts the participating chromosomes by their fitness and returns the numPicks
    most fit participants.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: pickTournament() 代码首先使用 shuffle() 随机化种群顺序，然后从种群中取出前 numParticipants。这只是获取 numParticipants
    随机染色体的简单方法。接下来，它按适应度对参与染色体进行排序，并返回最适应的 numPicks 个参与者。
- en: What is the right number for numParticipants? As with many parameters in a genetic
    algorithm, trial and error may be the best way to determine it. One thing to keep
    in mind is that a higher number of participants in the tournament leads to less
    diversity in the population, because chromosomes with poor fitness are more likely
    to be eliminated in matchups.[1](#pgfId-1158471) More sophisticated forms of tournament
    selection may pick individuals that are not the best, but are second or third
    best, based on some kind of decreasing probability model.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: numParticipants的正确数量是多少？与遗传算法中的许多参数一样，试错可能是确定它的最佳方法。需要注意的是，锦标赛中参与者数量越多，种群中的多样性就越少，因为具有较差适应度的染色体更有可能在配对中被淘汰。[1](#pgfId-1158471)
    更复杂的锦标赛选择形式可能会选择不是最好的，而是第二或第三好的个体，基于某种递减概率模型。
- en: These two methods, pickRoulette() and pickTournament(), are used for selection,
    which occurs during reproduction. Reproduction is implemented in reproduceAndReplace(),
    and it also takes care of ensuring that a new population of an equal number of
    chromosomes replaces the chromosomes in the last generation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法，pickRoulette() 和 pickTournament()，用于选择，在繁殖过程中发生。繁殖在 reproduceAndReplace()
    中实现，并确保用数量相等的染色体新种群替换上一代的染色体。
- en: Listing 5.6 GeneticAlgorithm.java continued
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 GeneticAlgorithm.java 继续部分
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In reproduceAndReplace(), the following steps occur in broad strokes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 reproduceAndReplace() 方法中，大致发生以下步骤：
- en: Two chromosomes, called parents, are selected for reproduction using one of
    the two selection methods. For tournament selection, we always run the tournament
    among half of the total population, but this too could be a configuration option.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两种选择方法之一选择两个染色体作为繁殖对象。对于锦标赛选择，我们总是在总种群的一半中运行锦标赛，但这也可以是一个配置选项。
- en: There is crossoverChance that the two parents will be combined to produce two
    new chromosomes, in which case they are added to nextPopulation. If there are
    no children, the two parents are just added to nextPopulation.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有 crossoverChance 的概率，两个父母将结合产生两个新的染色体，在这种情况下，它们将被添加到 nextPopulation 中。如果没有子代，则直接将两个父母添加到
    nextPopulation。
- en: If nextPopulation has as many chromosomes as population, it replaces it. Otherwise,
    we return to step 1.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 nextPopulation 中的染色体数量与 population 相同，则替换它。否则，我们返回到步骤 1。
- en: The method that implements mutation, mutate(), is very simple, with the details
    of how to perform a mutation being left to individual chromosomes. Each of our
    chromosome implementations will know how to mutate itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实现变异的 mutate() 方法非常简单，如何执行变异的细节留给单个染色体自行处理。我们每个染色体的实现都将知道如何变异自身。
- en: Listing 5.7 GeneticAlgorithm.java continued
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 GeneticAlgorithm.java 继续部分
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have all of the building blocks needed to run the genetic algorithm.
    run() coordinates the measurement, reproduction (which includes selection), and
    mutation steps that bring the population from one generation to the next. It also
    keeps track of the best (fittest) chromosome found at any point in the search.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了运行遗传算法所需的所有构建块。run() 协调测量、繁殖（包括选择）和变异步骤，这些步骤将种群从一个代带到下一个代。它还跟踪搜索过程中找到的任何最佳（最适应）染色体。
- en: Listing 5.8 GeneticAlgorithm.java continued
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 GeneticAlgorithm.java 继续部分
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: best keeps track of the best chromosome found so far. The main loop executes
    maxGenerations times. If any chromosome meets or exceeds threshold in fitness,
    it is returned, and the loop ends early. Otherwise, it calls reproduceAndReplace()
    as well as mutate() to create the next generation and run the loop again. If maxGenerations
    is reached, the best chromosome found so far is returned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: best 跟踪迄今为止找到的最佳染色体。主循环执行 maxGenerations 次。如果任何染色体在适应度上达到或超过阈值，则返回，并提前结束循环。否则，它将调用
    reproduceAndReplace() 和 mutate() 来创建下一代并再次运行循环。如果达到 maxGenerations，则返回迄今为止找到的最佳染色体。
- en: 5.3 A naive test
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 一个简单的测试
- en: The generic genetic algorithm, GeneticAlgorithm, will work with any type that
    implements Chromosome. As a test, we will start by implementing a simple problem
    that can be easily solved using traditional methods. We will try to maximize the
    equation 6x - x 2 + 4y - y 2\. In other words, what values for x and y in that
    equation will yield the largest number?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通用遗传算法 GeneticAlgorithm 可以与实现 Chromosome 的任何类型一起工作。作为一个测试，我们将从一个可以用传统方法轻松解决的问题开始实现。我们将尝试最大化方程
    6x - x^2 + 4y - y^2。换句话说，方程中的 x 和 y 的哪些值会产生最大的数？
- en: The maximizing values can be found, using calculus, by taking partial derivatives
    and setting each equal to zero. The result is x = 3 and y = 2\. Can our genetic
    algorithm reach the same result without using calculus? Let’s dig in.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过求偏导数并将每个等于零，可以使用微积分找到最大化值。结果是 x = 3 和 y = 2。我们的遗传算法能否在不使用微积分的情况下达到相同的结果？让我们深入探讨。
- en: Listing 5.9 SimpleEquation.java
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 SimpleEquation.java
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: SimpleEquation conforms to Chromosome, and true to its name, it does so as simply
    as possible. The genes of a SimpleEquation chromosome can be thought of as x and
    y. The method fitness() evaluates x and y using the equation 6x - x 2 + 4y - y
    2\. The higher the value, the more fit the individual chromosome is, according
    to GeneticAlgorithm. In the case of a random instance, x and y are initially set
    to be random integers between 0 and 100, so randomInstance() does not need to
    do anything other than instantiate a new SimpleEquation with these values. To
    combine one SimpleEquation with another in crossover(), the y values of the two
    instances are simply swapped to create the two children. mutate() randomly increments
    or decrements x or y. And that is pretty much it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleEquation 符合染色体结构，并且正如其名，它尽可能地简单。SimpleEquation 染色体的基因可以被视为 x 和 y。fitness()
    方法使用方程 6x - x^2 + 4y - y^2 来评估 x 和 y。根据遗传算法，值越高，个体染色体的适应性越强。在随机实例的情况下，x 和 y 初始设置为介于
    0 和 100 之间的随机整数，因此 randomInstance() 除了实例化一个具有这些值的新的 SimpleEquation 外，不需要做任何事情。在
    crossover() 中将一个 SimpleEquation 与另一个结合时，两个实例的 y 值简单地交换以创建两个子代。mutate() 随机增加或减少
    x 或 y。就是这样。
- en: Because SimpleEquation conforms to Chromosome, we can already plug it into GeneticAlgorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SimpleEquation 符合染色体结构，我们已将其插入到 GeneticAlgorithm 中。
- en: Listing 5.10 SimpleEquation.java continued
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 SimpleEquation.java 继续阅读
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameters used here were derived through guess-and-check. You can try others.
    threshold is set to 13.0 because we already know the correct answer. When x =
    3 and y = 2, the equation evaluates to 13.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的参数是通过猜测和检查得出的。您可以尝试其他参数。阈值设置为 13.0，因为我们已经知道正确答案。当 x = 3 和 y = 2 时，方程的值为
    13。
- en: If you did not previously know the answer, you might want to see the best result
    that could be found in a certain number of generations. In that case, you would
    set threshold to some arbitrarily large number. Remember, because genetic algorithms
    are stochastic, every run will be different.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前不知道答案，您可能想看到在特定代数内能找到的最佳结果。在这种情况下，您可以将阈值设置为任意大的数。记住，由于遗传算法是随机的，每次运行都会有所不同。
- en: 'Here is some sample output from a run in which the genetic algorithm solved
    the equation in seven generations:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从遗传算法在七代内解决方程的运行中获取的一些示例输出：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, it came to the proper solution derived earlier with calculus,
    x = 3 and y = 2\. You may also note that each successive generation got closer
    to the right answer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它得到了之前通过微积分得出的正确解，x = 3 和 y = 2。您也可能注意到，每一代都比前一代更接近正确答案。
- en: Take into consideration that the genetic algorithm took more computational power
    than other methods would have to find the solution. In the real world, such a
    simple maximization problem would not be a good use of a genetic algorithm. But
    its simple implementation at least suffices to prove that our genetic algorithm
    works.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到遗传算法在找到解决方案时比其他方法需要更多的计算能力。在现实世界中，这样一个简单的最大化问题并不适合使用遗传算法。但它的简单实现至少足以证明我们的遗传算法是有效的。
- en: 5.4 SEND+MORE=MONEY revisited
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 再次审视 SEND+MORE=MONEY
- en: In chapter 3, we solved the classic cryptarithmetic problem SEND+MORE=MONEY
    using a constraint-satisfaction framework. (For a refresher on what the problem
    is all about, look back to the description in chapter 3.) The problem can also
    be solved in a reasonable amount of time using a genetic algorithm.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我们使用约束满足框架解决了经典数独问题 SEND+MORE=MONEY。（如果您想回顾一下问题的具体描述，请参阅第 3 章的描述。）该问题也可以使用遗传算法在合理的时间内解决。
- en: One of the largest difficulties in formulating a problem for a genetic algorithm
    solution is determining how to represent it. A convenient representation for cryptarithmetic
    problems is to use list indices as digits.[2](#pgfId-1158693) Hence, to represent
    the 10 possible digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9), a 10-element list is required.
    The characters to be searched within the problem can then be shifted around from
    place to place. For example, if it is suspected that the solution to a problem
    includes the character “E” representing the digit 4, then position 4 in the list
    will hold an “E.” SEND+MORE=MONEY has eight distinct letters (S, E, N, D, M, O,
    R, Y), leaving two slots in the array empty. They can be filled with spaces indicating
    no letter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在为遗传算法解决方案制定问题时，最大的困难之一是确定如何表示它。对于密码学问题，使用列表索引作为数字是一种方便的表示方法。[2](#pgfId-1158693)
    因此，为了表示10个可能的数字（0，1，2，3，4，5，6，7，8，9），需要一个10个元素的列表。问题中要搜索的字符可以依次移动到各个位置。例如，如果怀疑问题的解决方案包括代表数字4的字符“E”，那么列表中的第4个位置将持有“E”。SEND+MORE=MONEY有八个不同的字母（S，E，N，D，M，O，R，Y），留下两个数组空位。它们可以用空格填充，表示没有字母。
- en: A chromosome that represents the SEND+MORE=MONEY problem is represented in SendMoreMoney2.
    Note how the fitness() method is strikingly similar to satisfied() from SendMoreMoneyConstraint
    in chapter 3.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代表SEND+MORE=MONEY问题的染色体在SendMoreMoney2中表示。注意fitness()方法与第3章中的SendMoreMoneyConstraint的satisfied()方法惊人地相似。
- en: Listing 5.11 SendMoreMoney2.java
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11 SendMoreMoney2.java
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is, however, a major difference between satisfied() in chapter 3 and fitness().
    Here, we return 1 / (difference + 1). difference is the absolute value of the
    difference between MONEY and SEND+MORE. This represents how far off the chromosome
    is from solving the problem. If we were trying to minimize fitness(), returning
    difference on its own would be fine. But because GeneticAlgorithm tries to maximize
    the value of fitness(), it needs to be flipped (so smaller values look like larger
    values), and that is why 1 is divided by difference. First, 1 is added to difference,
    so that a difference of 0 does not yield a fitness() of 0 but instead of 1\. Table
    5.1 illustrates how this works.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第3章中的satisfied()和fitness()之间存在一个主要区别。在这里，我们返回1 / (difference + 1)。difference是MONEY和SEND+MORE之间差异的绝对值。这表示染色体离解决问题有多远。如果我们试图最小化fitness()，只返回difference本身就可以了。但是，因为GeneticAlgorithm试图最大化fitness()的值，所以它需要反转（使得较小的值看起来像较大的值），这就是为什么1被除以difference的原因。首先，1被加到difference上，这样0的差异就不会产生fitness()为0，而是为1。表5.1说明了这是如何工作的。
- en: How the equation 1 / (difference + 1) yields fitness values for maximization
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式1 / (difference + 1)如何产生用于最大化的适应度值
- en: '| difference | difference + 1 | fitness (1/(difference + 1)) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| difference | difference + 1 | fitness (1/(difference + 1)) |'
- en: '| 0 | 1 | 1 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 2 | 0.5 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 0.5 |'
- en: '| 2 | 3 | 0.33 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 0.33 |'
- en: '| 3 | 4 | 0.25 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | 0.25 |'
- en: Remember, lower differences are better, and higher fitness values are better.
    Because this formula causes those two facts to line up, it works well. Dividing
    1 by a fitness value is a simple way to convert a minimization problem into a
    maximization problem. It does introduce some biases, though, so it is not foolproof.[3](#pgfId-1158859)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，差异越小越好，适应度值越高越好。因为这个公式使得这两个事实对齐，所以它工作得很好。将1除以适应度值是将最小化问题转换为最大化问题的一种简单方法。尽管如此，它确实引入了一些偏差，所以并不是万无一失的。[3](#pgfId-1158859)
- en: randomInstance() makes use of the shuffle() function in the Collections class.
    crossover() selects two random indices in the letters lists of both chromosomes
    and swaps letters so that we end up with one letter from the first chromosome
    in the same place in the second chromosome, and vice versa. It performs these
    swaps in children so that the placement of letters in the two children ends up
    being a combination of the parents. mutate() swaps two random locations in the
    letters list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: randomInstance()使用了Collections类中的shuffle()函数。crossover()在两个染色体的字母列表中选择两个随机索引，并交换字母，以便我们最终在第二个染色体中与第一个染色体相同的位置得到一个字母，反之亦然。它在子代中执行这些交换，以便两个子代中字母的位置是父母的组合。mutate()交换字母列表中的两个随机位置。
- en: 'We can plug SendMoreMoney2 into GeneticAlgorithm just as easily as we plugged
    in SimpleEquation. But be forewarned: This is a fairly tough problem, and it will
    take a long time to execute if the parameters are not well tweaked. And there’s
    still some randomness even if one gets them right! The problem may be solved in
    a few seconds or a few minutes. Unfortunately, that is the nature of genetic algorithms.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像插入SimpleEquation一样轻松地将SendMoreMoney2插入到遗传算法中。但请提前警告：这是一个相当困难的问题，如果参数没有很好地调整，执行时间会很长。即使参数调整正确，仍然存在一些随机性！问题可能在几秒钟或几分钟内解决。不幸的是，这就是遗传算法的本质。
- en: Listing 5.12 SendMoreMoney2.java continued
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.12 SendMoreMoney2.java继续
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following output is from a run that solved the problem in three generations
    using 1,000 individuals in each generation (as created above). See if you can
    mess around with the configurable parameters of GeneticAlgorithm and get a similar
    result with fewer individuals. Does it seem to work better with roulette selection
    than it does with tournament selection?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是从一次运行中得到的，该运行在每一代使用1,000个个体（如上所述创建）的情况下，在三代内解决了问题。看看你是否可以调整遗传算法的可配置参数，以更少的个体获得类似的结果。它是否比锦标赛选择更适合轮盘赌选择？
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This solution indicates that SEND = 8324, MORE = 913, and MONEY = 9237\. How
    is that possible? It looks like letters are missing from the solution. In fact,
    if M = 0, there are several solutions to the problem not possible in the version
    from chapter 3\. MORE is actually 0913 here, and MONEY is 09237\. The 0 is just
    ignored.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案表明SEND = 8324，MORE = 913，MONEY = 9237。这是怎么可能的？看起来解决方案中缺少字母。实际上，如果M = 0，那么在第三章版本中不可能解决的问题有几种解决方案。在这里MORE实际上是0913，MONEY是09237。0只是被忽略。
- en: 5.5 Optimizing list compression
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 优化列表压缩
- en: Suppose that we have some information we want to compress. Suppose that it is
    a list of items, and we do not care about the order of the items, as long as all
    of them are intact. What order of the items will maximize the compression ratio?
    Did you even know that the order of the items will affect the compression ratio
    for most compression algorithms?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些想要压缩的信息。假设它是一个物品列表，我们不在乎物品的顺序，只要它们都是完整的。什么顺序的物品将最大化压缩比率？你是否知道物品的顺序会影响大多数压缩算法的压缩比率？
- en: The answer will depend on the compression algorithm used. For this example,
    we will use the GZIPOutputStream class from the java.util.zip package. The solution
    is shown here in its entirety for a list of 12 first names. If we do not run the
    genetic algorithm and we just run compress() on the 12 names in the order they
    were originally presented, the resulting compressed data will be 164 bytes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 答案将取决于所使用的压缩算法。在这个例子中，我们将使用java.util.zip包中的GZIPOutputStream类。解决方案在这里完整展示，针对12个名字的列表。如果我们不运行遗传算法，只是按照原始顺序对12个名字运行compress()，生成的压缩数据将是164字节。
- en: Listing 5.13 ListCompression.java
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13 ListCompression.java
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how similar this implementation is to the implementation from SEND+MORE=
    MONEY in section 5.4\. The crossover() and mutate() functions are essentially
    the same. In both problems’ solutions, we take a list of items and continually
    rearrange them and test those rearrangements. One could write a generic superclass
    for both problems’ solutions that would work with a wide variety of problems.
    Any problem that can be represented as a list of items that needs to find its
    optimal order could be solved the same way. The only real point of customization
    for the subclasses would be their respective fitness functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个实现与第5.4节中SEND+MORE= MONEY的实现是多么相似。crossover()和mutate()函数基本上是相同的。在这两个问题的解决方案中，我们取一个物品列表，并不断重新排列它们，并测试这些排列。可以为这两个问题的解决方案编写一个通用的超类，它可以与各种问题一起工作。任何可以用物品列表表示并需要找到其最优顺序的问题都可以以相同的方式解决。子类唯一的真正定制点就是它们各自的适应度函数。
- en: If we run ListCompression.java, it may take a very long time to complete. This
    is because we don’t know what constitutes the “right” answer ahead of time, unlike
    the prior two problems, so we have no real threshold that we are working toward.
    Instead, we set the number of generations and the number of individuals in each
    generation to an arbitrarily high number and hope for the best. What is the minimum
    number of bytes that rearranging the 12 names will yield in compression? Frankly,
    we don’t know the answer to that. In my best run, using the configuration in the
    preceding solution, after 100 generations the genetic algorithm found an order
    of the 12 names that yielded 158 bytes compressed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行ListCompression.java，它可能需要非常长的时间才能完成。这是因为与前面两个问题不同，我们事先不知道“正确”的答案是什么，所以我们没有真正的工作阈值。相反，我们将代数数和每一代的个体数设置为一个任意高的数字，并寄希望于最好的结果。重新排列12个名字将产生多少字节的压缩？坦白说，我们不知道答案。在我的最佳运行中，使用前面解决方案中的配置，在100代之后，遗传算法找到了12个名字的顺序，产生了158字节的压缩。
- en: That’s only a savings of 6 bytes over the original order--a savings of ~4%.
    One might say that 4% is irrelevant, but if this were a far larger list that would
    be transferred many times over the network, that could add up. Imagine if this
    were a 1 MB list that would eventually be transferred across the internet 10,000,000
    times. If the genetic algorithm could optimize the order of the list for compression
    to save 4%, it would save ~40 kilobytes per transfer and ultimately 400 GB in
    bandwidth across all transfers. That’s not a huge amount, but perhaps it could
    be significant enough that it’s worth running the algorithm once to find a near
    optimal order for compression.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在原始顺序上节省了6个字节——大约节省了4%。有人可能会说4%微不足道，但如果这是一个远大于列表，并且多次在网络中传输的列表，那么这可能会累积起来。想象一下，如果这是一个最终将在互联网上传输10,000,000次的1
    MB列表。如果遗传算法能够优化列表的顺序以节省4%，那么每次传输将节省约40千字节，并且在所有传输中最终节省400 GB的带宽。这并不是一个巨大的数字，但也许它足够重要，以至于值得运行一次算法来找到一个接近最优的顺序以进行压缩。
- en: Consider this, though--we don’t really know if we found the optimal order for
    the 12 names, let alone for the hypothetical 1 MB list. How would we know if we
    did? Unless we have a deep understanding of the compression algorithm, we would
    have to try compressing every possible order of the list. Just for a list of 12
    items, that’s a fairly unfeasible 479,001,600 possible orders (12!, where ! means
    factorial). Using a genetic algorithm that attempts to find optimality is perhaps
    more feasible, even if we don’t know whether its ultimate solution is truly optimal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此——我们并不真正知道我们是否找到了12个名字的最优顺序，更不用说假设的1 MB列表了。我们如何知道我们做到了呢？除非我们对压缩算法有深入的了解，否则我们必须尝试压缩列表的每一种可能的顺序。仅对于12个项目的列表，就有相当不切实际的479,001,600种可能的顺序（12!，其中!表示阶乘）。使用尝试找到最优性的遗传算法可能是可行的，即使我们不知道其最终解决方案是否真正最优。
- en: 5.6 Challenges for genetic algorithms
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 遗传算法的挑战
- en: Genetic algorithms are not a panacea. In fact, they are not suitable for most
    problems. For any problem for which a fast deterministic algorithm exists, a genetic
    algorithm approach does not make sense. Their inherently stochastic nature makes
    their runtimes unpredictable. To solve this problem, they can be cut off after
    a certain number of generations. But then it is not clear if a truly optimal solution
    has been found.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法并非万能。实际上，它们并不适合大多数问题。对于任何存在快速确定性算法的问题，使用遗传算法的方法是没有意义的。它们固有的随机性使得它们的运行时间不可预测。为了解决这个问题，它们可以在一定代数后停止。但这样，就不知道是否找到了真正的最优解。
- en: 'Steven Skiena, author of one of the most popular texts on algorithms, even
    went so far as to write this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 算法方面最受欢迎的教材之一《算法导论》的作者史蒂文·斯基尼亚甚至写道：
- en: I have never encountered any problem where genetic algorithms seemed to me the
    right way to attack it. Further, I have never seen any computational results reported
    using genetic algorithms that have favorably impressed me.[4](#pgfId-1159023)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未遇到过任何问题，让我觉得遗传算法是解决它的正确方法。此外，我也从未看到过任何使用遗传算法报告的计算结果给我留下深刻印象。[4](#pgfId-1159023)
- en: Skiena’s view is a little extreme, but it is indicative of the fact that genetic
    algorithms should only be chosen when you are reasonably confident that a better
    solution does not exist, or you are exploring an unknown problem space. Another
    issue with genetic algorithms is determining how to represent a potential solution
    to a problem as a chromosome. The traditional practice is to represent most problems
    as binary strings (sequences of 1s and 0s, raw bits). This is often optimal in
    terms of space usage, and it lends itself to easy crossover functions. But most
    complex problems are not easily represented as divisible bit strings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Skiena的观点有些极端，但它表明遗传算法只有在你有合理信心认为不存在更好的解决方案，或者你正在探索未知的问题空间时才应该选择。遗传算法的另一个问题是确定如何将问题的潜在解决方案表示为染色体。传统的做法是将大多数问题表示为二进制字符串（1s和0s的序列，原始比特）。这在空间使用方面通常是最佳的，并且有利于简单的交叉函数。但大多数复杂问题不容易表示为可分割的二进制字符串。
- en: Another, more specific issue worth mentioning is challenges related to the roulette-wheel
    selection method described in this chapter. Roulette-wheel selection, sometimes
    referred to as fitness proportional selection, can lead to a lack of diversity
    in a population due to the dominance of relatively fit individuals each time selection
    is run. On the other hand, if fitness values are close together, roulette-wheel
    selection can lead to a lack of selection pressure.[5](#pgfId-1159029) Further,
    roulette-wheel selection, as constructed in this chapter, does not work for problems
    in which fitness can be measured with negative values, as in our simple equation
    example in section 5.3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提及的更具体的问题是本章中描述的轮盘赌选择方法的相关挑战。轮盘赌选择，有时也称为适应度比例选择，由于每次选择时相对适应度较高的个体占主导地位，可能会导致种群中缺乏多样性。另一方面，如果适应度值彼此接近，轮盘赌选择可能会导致缺乏选择压力。[5](#pgfId-1159029)
    此外，本章中构建的轮盘赌选择对于可以用负值衡量的适应度问题不适用，例如在第5.3节中的简单方程示例。
- en: In short, for most problems large enough to warrant using them, genetic algorithms
    cannot guarantee the discovery of an optimal solution in a predictable amount
    of time. For this reason, they are best utilized in situations that do not call
    for an optimal solution, but instead for a “good enough” solution. They are fairly
    easy to implement, but tweaking their configurable parameters can take a lot of
    trial and error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于大多数足够大以至于需要使用它们的问题，遗传算法不能保证在可预测的时间内发现最优解。因此，它们最好用于不需要最优解，而是需要“足够好”的解决方案的情况。它们相对容易实现，但调整它们的可配置参数可能需要大量的尝试和错误。
- en: 5.7 Real-world applications
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 实际应用
- en: Despite what Skiena wrote, genetic algorithms are frequently and effectively
    applied in a myriad of problem spaces. They are often used on hard problems that
    do not require perfectly optimal solutions, such as constraint-satisfaction problems
    too large to be solved using traditional methods. One example is complex scheduling
    problems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Skiena这样写了，但遗传算法在众多问题空间中被频繁且有效地应用。它们通常用于不需要完美最优解的难题，例如传统方法难以解决的约束满足问题。一个例子是复杂的调度问题。
- en: Genetic algorithms have found many applications in computational biology. They
    have been used successfully for protein-ligand docking, which is a search for
    the configuration of a small molecule when it is bound to a receptor. This is
    used in pharmaceutical research and to better understand mechanisms in nature.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法在计算生物学中找到了许多应用。它们在蛋白质-配体对接方面取得了成功，这是寻找小分子与受体结合时的配置。这用于药物研究和更好地理解自然界的机制。
- en: The Traveling Salesman Problem, which we will revisit in chapter 9, is one of
    the most famous problems in computer science. A traveling salesman wants to find
    the shortest route on a map that visits every city exactly once and brings him
    back to his starting location. It may sound like minimum spanning trees in chapter
    4, but it is different. In the Traveling Salesman, the solution is a giant cycle
    that minimizes the cost to traverse it, whereas a minimum spanning tree minimizes
    the cost to connect every city. A person traveling a minimum spanning tree of
    cities may have to visit the same city twice to reach every city. Even though
    they sound similar, there is no reasonably timed known algorithm for finding a
    solution to the Traveling Salesman Problem for an arbitrary number of cities.
    Genetic algorithms have been shown to find suboptimal, but pretty good, solutions
    in short periods of time. The problem is widely applicable to the efficient distribution
    of goods. For example, dispatchers of FedEx and UPS trucks use software to solve
    the Traveling Salesman Problem every day. Algorithms that help solve the problem
    can cut costs in a large variety of industries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题，我们将在第9章中再次讨论，是计算机科学中最著名的问题之一。旅行商希望找到地图上最短的路线，该路线访问每个城市一次，并带他回到起点。这听起来可能像第4章中的最小生成树，但它不同。在旅行商中，解决方案是一个巨大的循环，它最小化了穿越它的成本，而最小生成树最小化了连接每个城市的成本。旅行一个最小生成树的人可能需要访问同一个城市两次才能到达每个城市。尽管它们听起来很相似，但还没有合理的算法可以在合理的时间内找到任意数量城市的旅行商问题的解决方案。遗传算法已被证明可以在短时间内找到次优但相当好的解决方案。该问题广泛应用于货物的有效分配。例如，FedEx和UPS的调度员每天使用软件来解决旅行商问题。帮助解决问题算法可以在许多行业中降低成本。
- en: In computer-generated art, genetic algorithms are sometimes used to mimic photographs
    using stochastic methods. Imagine 50 polygons placed randomly on a screen and
    gradually twisted, turned, moved, resized, and changed in color until they match
    a photograph as closely as possible. The result looks like the work of an abstract
    artist or, if more angular shapes are used, a stained-glass window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机生成的艺术中，遗传算法有时被用来使用随机方法模拟照片。想象一下，在屏幕上随机放置50个多边形，并逐渐扭曲、旋转、移动、调整大小和改变颜色，直到它们尽可能接近照片。结果看起来像抽象艺术家的作品，或者如果使用更尖锐的形状，则像彩色玻璃窗。
- en: Genetic algorithms are part of a larger field called evolutionary computation.
    One area of evolutionary computation closely related to genetic algorithms is
    genetic programming, in which programs use the selection, crossover, and mutation
    operations to modify themselves to find nonobvious solutions to programming problems.
    Genetic programming is not a widely used technique, but imagine a future where
    programs write themselves.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法是更大领域进化计算的一部分。进化计算的一个与遗传算法密切相关的研究领域是遗传编程，其中程序使用选择、交叉和变异操作来修改自身，以找到编程问题的非显而易见的解决方案。遗传编程不是一种广泛使用的技巧，但想象一下，在未来，程序将能够自己编写。
- en: A benefit of genetic algorithms is that they lend themselves to easy parallelization.
    In the most obvious form, each population can be simulated on a separate processor.
    In the most granular form, each individual can be mutated and crossed, and have
    its fitness calculated in a separate thread. There are also many possibilities
    in between.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的一个好处是它们很容易并行化。在最明显的形式中，每个种群可以在一个单独的处理器上模拟。在最细粒度的形式中，每个个体可以变异和交叉，并在单独的线程中计算其适应度。还有许多介于两者之间的可能性。
- en: 5.8 Exercises
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 练习
- en: Add support to GeneticAlgorithm for an advanced form of tournament selection
    that may sometimes choose the second- or third-best chromosome, based on a diminishing
    probability.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为GeneticAlgorithm添加对一种高级锦标赛选择的支持，该选择有时可能会根据递减的概率选择第二或第三好的染色体。
- en: Add a new function to the constraint-satisfaction framework from chapter 3 that
    solves any arbitrary CSP using a genetic algorithm. A possible measure of fitness
    is the number of constraints that are resolved by a chromosome.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第3章的约束满足框架添加一个新功能，该功能使用遗传算法解决任何任意的CSP。一个可能的适应度度量是染色体解决的约束数量。
- en: Create a class, BitString, that implements Chromosome. Recall what a bit string
    is from chapter 1\. Then use your new class to solve the simple equation problem
    from section 5.3\. How can the problem be encoded as a bit string?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为BitString的类，该类实现了Chromosome。回想一下第1章中提到的位串是什么。然后使用您的新类来解决第5.3节中的简单方程问题。这个问题如何编码为位串？
- en: '* * *'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. Artem Sokolov and Darrell Whitley, “Unbiased Tournament Selection,” GECCO
    ’05 (June 25-29, 2005, Washington, D.C., U.S.A.), [http://mng.bz/S7l6](http://mng.bz/S7l6).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 1. Artem Sokolov和Darrell Whitley，“无偏锦标赛选择，”GECCO’05（2005年6月25日至29日，美国华盛顿特区），[http://mng.bz/S7l6](http://mng.bz/S7l6)。
- en: 2. Reza Abbasian and Masoud Mazloom, “Solving Cryptarithmetic Problems Using
    Parallel Genetic Algorithm,” 2009 Second International Conference on Computer
    and Electrical Engineering, [http://mng.bz/RQ7V](http://mng.bz/RQ7V).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Reza Abbasian和Masoud Mazloom，“使用并行遗传算法解决密码学问题，”2009年第二届计算机与电气工程国际会议，[http://mng.bz/RQ7V](http://mng.bz/RQ7V)。
- en: 3. For example, we might end up with more numbers closer to 0 than we would
    closer to 1 if we were to simply divide 1 by a uniform distribution of integers,
    which--with the subtleties of how typical microprocessors interpret floating-point
    numbers--could lead to some unexpected results. An alternative way to convert
    a minimization problem into a maximization problem is to simply flip the sign
    (make it negative instead of positive). However, this will only work if the values
    are all positive to begin with.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 例如，如果我们简单地用整数均匀分布除以1，可能会得到比接近1时更多的接近0的数字，这在典型微处理器解释浮点数的细微差别下可能会导致一些意想不到的结果。将最小化问题转换为最大化问题的一种替代方法是将符号翻转（使其变为负数而不是正数）。然而，这只有在所有值最初都是正数的情况下才会有效。
- en: 4. Steven Skiena, The Algorithm Design Manual, 2nd ed. (Springer, 2009), p.
    267.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 4. Steven Skiena，《算法设计手册》，第2版（Springer，2009年），第267页。
- en: 5. A. E. Eiben and J. E. Smith, Introduction to Evolutionary Computation, 2nd
    edition (Springer, 2015), p. 80.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 5. A. E. Eiben和J. E. Smith，《进化计算导论》，第2版（Springer，2015年），第80页。
