- en: 6 Modeling complex time series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 模型复杂的时间序列
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Examining the autoregressive moving average model or ARMA(*p*,*q*)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检验自回归移动平均模型或 ARMA(*p*,*q*)
- en: Experimenting with the limitations of the ACF and PACF plots
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试 ACF 和 PACF 图的限制
- en: Selecting the best model with the Akaike information criterion (AIC)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用赤池信息准则 (AIC) 选择最佳模型
- en: Analyzing a time series model using residual analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用残差分析分析时间序列模型
- en: Building a general modeling procedure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一个通用的建模程序
- en: Forecasting using the ARMA(*p*,*q*) model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ARMA(*p*,*q*) 模型进行预测
- en: In chapter 4 we covered the moving average process, denoted as MA(*q*)), where
    *q* is the order. You learned that in a moving average process, the present value
    is linearly dependent on the mean, the current error term, and past error terms.
    The order *q* can be inferred using the ACF plot, where autocorrelation coefficients
    will be significant up until lag *q* only. In the case where the ACF plot shows
    a slowly decaying pattern or a sinusoidal pattern, it is possible that you are
    in the presence of an autoregressive process instead of a moving average process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们介绍了移动平均过程，表示为 MA(*q*)，其中 *q* 是阶数。你了解到，在移动平均过程中，当前值与均值、当前误差项和过去误差项线性相关。阶数
    *q* 可以通过自相关图推断，其中自相关系数将在滞后 *q* 时显著。在自相关图显示缓慢衰减模式或正弦波模式的情况下，可能存在的是自回归过程而不是移动平均过程。
- en: This led us to chapter 5, in which we covered the autoregressive process, denoted
    as AR(*p*), where *p* is the order. In the autoregressive process, the present
    value is linearly dependent on its own past value. In other words, it is a regression
    of the variable against itself. You saw that we can infer the order *p* using
    the PACF plot, where the partial autocorrelation coefficients will be significant
    up until lag *p* only. We are therefore at a point where we can identify, model,
    and predict a random walk, a pure moving average process, and a pure autoregressive
    process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们进入了第5章，其中我们介绍了自回归过程，表示为 AR(*p*)，其中 *p* 是阶数。在自回归过程中，当前值与其自身的过去值线性相关。换句话说，它是变量对其自身的回归。你看到我们可以通过偏自相关图推断出阶数
    *p*，其中偏自相关系数将在滞后 *p* 时显著。因此，我们现在可以识别、建模和预测随机游走、纯移动平均过程和纯自回归过程。
- en: The next step is learning how to treat time series where you cannot infer an
    order from the ACF plot or from the PACF plot. This means that both figures exhibit
    a slowly decaying pattern or a sinusoidal pattern. In such a case, we are in the
    presence of an autoregressive moving average (ARMA) process. This denotes the
    combination of both the autoregressive and moving average processes that we covered
    in the two previous chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是学习如何处理无法从自相关图或偏自相关图推断出顺序的时间序列。这意味着这两个图都表现出缓慢衰减的模式或正弦波模式。在这种情况下，我们面临的是自回归移动平均（ARMA）过程。这表示了我们在前两章中涵盖的自回归和移动平均过程的组合。
- en: In this chapter, we will examine the autoregressive moving average process,
    ARMA(*p*,*q*), where *p* denotes the order of the autoregressive portion and *q*
    denotes the order of the moving average portion. Furthermore, using the ACF and
    PACF plots to determine the orders *q* and *p*, respectively, becomes difficult,
    as both plots will show either a slowly decaying or sinusoidal pattern. Thus,
    we will define a general modeling procedure that will allow us to model such complex
    time series. This procedure involves model selection using the *Akaike information
    criterion* (AIC), which will determine the optimal combination of *p* and *q*
    for our series. Then we must evaluate the model’s validity using residual analysis
    by studying the correlogram, Q-Q plot, and density plot of the model’s residuals
    to assess if they closely resemble white noise. If that is the case, we can move
    on to forecasting our time series using the ARMA(*p*,*q*) model.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究自回归移动平均过程，ARMA(*p*,*q*)，其中 *p* 表示自回归部分的阶数，*q* 表示移动平均部分的阶数。此外，使用 ACF
    和 PACF 图来确定 *q* 和 *p* 的阶数变得困难，因为两个图都将显示缓慢衰减或正弦波模式。因此，我们将定义一个通用的建模程序，使我们能够对这种复杂的时间序列进行建模。此程序涉及使用
    *赤池信息准则* (AIC) 进行模型选择，这将确定我们序列中 *p* 和 *q* 的最佳组合。然后我们必须通过研究模型的残差的自相关图、Q-Q 图和密度图来评估模型的合理性，以确定它们是否接近白噪声。如果是这样，我们就可以继续使用
    ARMA(*p*,*q*) 模型预测我们的时间序列。
- en: This chapter will introduce foundational knowledge for forecasting complex time
    series. All the concepts introduced here will be reused in further chapters when
    we start modeling non-stationary time series and incorporating seasonality and
    exogenous variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍预测复杂时间序列的基础知识。在这里介绍的所有概念都将在后续章节中重复使用，当我们开始建模非平稳时间序列并引入季节性和外生变量时。
- en: 6.1 Forecasting bandwidth usage for data centers
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 预测数据中心带宽使用
- en: Suppose that you are tasked with predicting bandwidth usage for a large data
    center. Bandwidth is defined as the maximum rate of data that can be transferred.
    Its base unit is bits per second (bps).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被分配预测大型数据中心的带宽使用情况的任务。带宽被定义为可以传输数据的最大速率。其基本单位是每秒比特数（bps）。
- en: Forecasting bandwidth usage allows data centers to better manage their computing
    resources. In the case where less bandwidth usage is expected, they can shut down
    some of their computing resources. This in turns reduces expenses and allows for
    maintenance. On the other hand, if bandwidth usage is expected to increase, they
    can dedicate the required resources to sustain the demand and ensure low latency,
    thus keeping their customers satisfied.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 预测带宽使用情况允许数据中心更好地管理其计算资源。在预期带宽使用较少的情况下，它们可以关闭部分计算资源。这反过来又减少了开支并允许进行维护。另一方面，如果预期带宽使用会增加，它们可以将所需资源分配给满足需求，并确保低延迟，从而保持客户满意。
- en: For this situation, there are 10,000 data points representing the hourly bandwidth
    usage starting in January 1, 2019\. Here the bandwidth is measured in megabits
    per second (Mbps), which is equivalent to 10⁶ bps. We can visualize our time series
    in figure 6.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，有10,000个数据点表示从2019年1月1日开始的小时带宽使用情况。在这里，带宽以每秒兆比特数（Mbps）衡量，相当于10⁶ bps。我们可以在图6.1中可视化我们的时间序列。
- en: '![](../../OEBPS/Images/06-01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-01.png)'
- en: Figure 6.1 Hourly bandwidth usage in a data center since January 1, 2019\. The
    dataset contains 10,000 points.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 自2019年1月1日以来的数据中心每小时带宽使用情况。数据集包含10,000个数据点。
- en: Looking at figure 6.1, you can see long-term trends over time, meaning that
    this series is likely not stationary, so we need to apply a transformation. Also,
    there seems to be no cyclical behavior, so we can rule out the presence of seasonality
    in our series.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图6.1，你可以看到随时间变化的长期趋势，这意味着这个序列可能不是平稳的，因此我们需要应用转换。此外，似乎没有周期性行为，因此我们可以排除我们的序列中存在季节性的可能性。
- en: In order to forecast bandwidth usage, we need to identify the underlying process
    in our series. Thus, we’ll follow the steps that we defined in chapter 5\. That
    way, we can verify whether we have a random walk, a moving average process, or
    an autoregressive process. The steps are shown in figure 6.2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测带宽使用情况，我们需要识别我们序列中的潜在过程。因此，我们将遵循第5章中定义的步骤。这样，我们可以验证我们是否有随机游走、移动平均过程或自回归过程。步骤在图6.2中显示。
- en: '![](../../OEBPS/Images/06-02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-02.png)'
- en: Figure 6.2 Steps to identify a random walk, a moving average process, and an
    autoregressive process
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 识别随机游走、移动平均过程和自回归过程的步骤
- en: The first step is to collect the data, which is already done in this case. Then
    we must determine if our series is stationary or not. The presence of a trend
    in the plot hints that our series is not stationary. Nevertheless, we will apply
    the ADF test to check for stationarity and apply a transformation accordingly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是收集数据，在这个案例中这项工作已经完成。然后我们必须确定我们的序列是否是平稳的。图中趋势的存在暗示我们的序列可能不是平稳的。尽管如此，我们将应用ADF测试来检查平稳性，并根据结果进行相应的转换。
- en: Then we will plot the ACF function and find that there are significant autocorrelation
    coefficients after lag 0, which means it is not a random walk. However, we will
    observe that coefficients slowly decay. They do not become abruptly non-significant
    after a certain lag, which means that it is not a purely moving average process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将绘制ACF函数，并发现滞后0之后存在显著的自相关系数，这意味着它不是一个随机游走。然而，我们将观察到系数缓慢衰减。它们在一定的滞后后不会突然变得不显著，这意味着它不是一个纯粹移动平均过程。
- en: We’ll then move on to plotting the PACF function. This time we will notice a
    sinusoidal pattern, meaning that coefficients do not become abruptly non-significant
    after a certain lag. This will lead us to the conclusion that it is not a purely
    autoregressive process either.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向绘制PACF函数。这次我们会注意到一个正弦波模式，这意味着系数在一定的滞后后不会突然变得不显著。这将导致我们得出结论，它也不是一个纯粹的自回归过程。
- en: Therefore, it must be a combination of autoregressive and moving average processes,
    resulting in an autoregressive moving average process that can be modeled with
    the ARMA(*p*,*q*) model, where *p* is the order of the autoregressive process
    and *q* is the order of the moving average process. It is difficult to use the
    ACF and PACF plots to respectively find *p* and *q*, so we will fit many ARMA(*p*,*q*)
    models with different combinations of values for *p* and *q*. We will then select
    a model according to the Akaike information criterion and assess its viability
    by analyzing its residuals. Ideally, the residuals of a model will have characteristics
    similar to white noise. Then we will be able to use this model to make forecasts.
    For this example, we will forecast the hourly bandwidth usage over the next two
    hours.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它必须是一个自回归和移动平均过程的组合，从而形成一个可以用ARMA(*p*,*q*)模型进行建模的自回归移动平均过程，其中*p*是自回归过程的阶数，*q*是移动平均过程的阶数。使用ACF和PACF图分别找到*p*和*q*是困难的，因此我们将拟合许多具有不同*p*和*q*值组合的ARMA(*p*,*q*)模型。然后，我们将根据赤池信息准则选择一个模型，并通过分析其残差来评估其可行性。理想情况下，模型的残差将具有类似于白噪声的特征。然后，我们将能够使用此模型进行预测。对于这个例子，我们将预测未来两小时的每小时带宽使用情况。
- en: 6.2 Examining the autoregressive moving average process
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 检查自回归移动平均过程
- en: The *autoregressive moving average process* is a combination of the autoregressive
    process and the moving average process. It states that the present value is linearly
    dependent on its own previous values and a constant, just like in an autoregressive
    process, as well as on the mean of the series, the current error term, and past
    error terms, like in a moving average process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归移动平均过程是自回归过程和移动平均过程的组合。它表明，当前值线性依赖于其自身的先前值和一个常数，就像在自回归过程中一样，同时也依赖于序列的均值、当前误差项和过去误差项，就像在移动平均过程中一样。
- en: The autoregressive moving average process is denoted as ARMA(*p*,*q*), where
    *p* is the order of the autoregressive portion, and *q* is the order of the moving
    average portion. Mathematically, the ARMA(*p*,*q*) process is expressed as a linear
    combination of a constant C, the past values of the series *y*[*t*–*p*], the mean
    of the series µ, past error terms ϵ[*t*–*q*], and the current error term *ϵ[*t*]*,
    as shown in equation 6.1.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归移动平均过程表示为ARMA(*p*,*q*)，其中*p*是自回归部分的阶数，*q*是移动平均部分的阶数。数学上，ARMA(*p*,*q*)过程表示为常数C、序列*y*[*t*–*p*]的过去值、序列的均值µ、过去误差项ϵ[*t*–*q*]和当前误差项*ϵ[*t*]*的线性组合，如方程6.1所示。
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅+ ϕ[p]*y[t–p]* + *ϵ[*t*]*
    + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅+ ϕ[p]*y[t–p]* + *ϵ[*t*]*
    + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
- en: Equation 6.1
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.1
- en: Autoregressive moving average process
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归移动平均过程
- en: The autoregressive moving average process is a combination of the autoregressive
    process and the moving average process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归移动平均过程是自回归过程和移动平均过程的组合。
- en: It is denoted as ARMA(*p*,*q*), where *p* is the order of the autoregressive
    process, and *q* is the order of the moving average process. The general equation
    of the ARMA(*p*,*q*) model is
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示为ARMA(*p*,*q*)，其中*p*是自回归过程的阶数，*q*是移动平均过程的阶数。ARMA(*p*,*q*)模型的一般方程是
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y[t]*[–2] +⋅⋅⋅+ ϕ*[p]y[t–p]* + μ + *ϵ[*t*]*
    + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y[t]*[–2] +⋅⋅⋅+ ϕ*[p]y[t–p]* + μ + *ϵ[*t*]*
    + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
- en: An ARMA(0,*q*) process is equivalent to an MA(*q*) process, since the order
    *p* = 0 cancels the AR(*p*) portion. An ARMA(*p*,0) process is equivalent to an
    AR(*p*) process, since the order *q* = 0 cancels the MA(*q*) portion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA(0,*q*)过程等同于MA(*q*)过程，因为阶数*p* = 0抵消了AR(*p*)部分。ARMA(*p*,0)过程等同于AR(*p*)过程，因为阶数*q*
    = 0抵消了MA(*q*)部分。
- en: Again, the order *p* determines the number of past values that affect the present
    value. Similarly, the order *q* determines the number of past error terms that
    affect the present value. In other words, the orders *p* and *q* dictate the number
    of parameters for the autoregressive and moving average portions, respectively.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，阶数*p*决定了影响当前值的过去值的数量。同样，阶数*q*决定了影响当前值的过去误差项的数量。换句话说，阶数*p*和*q*分别决定了自回归和移动平均部分的参数数量。
- en: Thus, if we have an ARMA(1,1) process, we are combining an autoregressive process
    of order 1, or AR(1), with a moving average process of order 1, or MA(1). Recall
    that a first-order autoregressive process is a linear combination of a constant
    C, the value of the series at the previous timestep ϕ[1]*y*[*t*–1], and white
    noise *ϵ[*t*]*, as shown in equation 6.2.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一个ARMA(1,1)过程，我们就是在结合一个一阶自回归过程，或AR(1)，和一个一阶移动平均过程，或MA(1)。回想一下，一阶自回归过程是一个常数C、序列在上一时间步的值ϕ[1]*y*[*t*–1]和白色噪声*ϵ[*t*]*的线性组合，如方程6.2所示。
- en: AR(1) := *y[t]* = C + ϕ[1]*y*[*t*–1] + *ϵ[*t*]*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: AR(1) := *y[t]* = C + ϕ[1]*y*[*t*–1] + *ϵ[*t*]*
- en: Equation 6.2
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.2
- en: Also recall that a first-order moving average process, or MA(1), is a linear
    combination of the mean of the series μ, the current error term *ϵ[*t*]* , and
    the error term at the previous timestep θ[1]ϵ[*t*–1], as shown in equation 6.3.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，一阶移动平均过程，或MA(1)，是序列均值μ、当前误差项*ϵ[*t*]*和上一时间步的误差项θ[1]ϵ[*t*–1]的线性组合，如方程6.3所示。
- en: MA(1) := *y[t]* = *μ* + *ϵ[*t*]* + θ[1]ϵ[*t*–1]
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MA(1) := *y[t]* = *μ* + *ϵ[*t*]* + θ[1]ϵ[*t*–1]
- en: Equation 6.3
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.3
- en: We can combine the AR(1) and MA(1) processes to obtain an ARMA(1,1) process
    as shown in equation 6.4, which combines the effects of equations 6.2 and 6.3.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将AR(1)和MA(1)过程结合起来，得到一个ARMA(1,1)过程，如方程6.4所示，它结合了方程6.2和6.3的效果。
- en: ARMA(1,1) := *y[t]* = C + ϕ[1]*y*[*t*–1] + *ϵ[*t*]* + θ[1]ϵ[*t*–1]
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA(1,1) := *y[t]* = C + ϕ[1]*y*[*t*–1] + *ϵ[*t*]* + θ[1]ϵ[*t*–1]
- en: Equation 6.4
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.4
- en: If we have an ARMA(2,1) process, we are combining a second-order autoregressive
    process with a first-order moving average process. We know that we can express
    an AR(2) process as equation 6.5, while the MA(1) process from equation 6.3 remains
    the same.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个ARMA(2,1)过程，我们就是在结合一个二阶自回归过程和一个一阶移动平均过程。我们知道我们可以将AR(2)过程表示为方程6.5，而方程6.3中的MA(1)过程保持不变。
- en: AR(2) := *y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] + *ϵ[*t*]*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AR(2) := *y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] + *ϵ[*t*]*
- en: Equation 6.5
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.5
- en: Thus, an ARMA(2,1) process can be expressed as the combination of the AR(2)
    process defined in equation 6.5 and the MA(1) process defined in equation 6.3\.
    This is shown in equation 6.6.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个ARMA(2,1)过程可以表示为方程6.5中定义的AR(2)过程和方程6.3中定义的MA(1)过程的组合。这如方程6.6所示。
- en: ARMA(2, 1) := *y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] + *μ* + *ϵ[*t*]*
    + θ[1]ϵ[*t*–1]
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA(2, 1) := *y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] + *μ* + *ϵ[*t*]*
    + θ[1]ϵ[*t*–1]
- en: Equation 6.6
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.6
- en: In the case where *p* = 0, we have an ARMA(0,*q*) process, which is equivalent
    to a pure MA(*q*) process as seen in chapter 4\. Similarly, if *q* = 0, we have
    an ARMA(*p*,0) process, which is equivalent to a pure AR(*p*) process, as seen
    in chapter 5.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*p* = 0的情况下，我们有一个ARMA(0,*q*)过程，它等同于第4章中看到的纯MA(*q*)过程。同样，如果*q* = 0，我们有一个ARMA(*p*,0)过程，它等同于第5章中看到的纯AR(*p*)过程。
- en: We can see now how the order *p* only affects the autoregressive portion of
    the process by determining the number of past values to include in the equation.
    Similarly, the order *q* only affects the moving average portion of the process
    by determining the number of past error terms to include in the equation of ARMA(*p*,*q*).
    Of course, the higher the orders *p* and *q*, the more terms that are included,
    and the more complex our process becomes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，阶数*p*只影响过程的自回归部分，通过确定在方程中包含的过去值的数量。同样，阶数*q*只影响过程的移动平均部分，通过确定在ARMA(*p*,*q*)方程中包含的过去误差项的数量。当然，*p*和*q*的阶数越高，包含的项就越多，我们的过程就越复杂。
- en: In order to model and forecast an ARMA(*p*,*q*) process, we need to find the
    orders *p* and *q*. That way, we can use an ARMA(*p*,*q*) model to fit the available
    data and produce forecasts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对ARMA(*p*,*q*)过程进行建模和预测，我们需要找到*p*和*q*的阶数。这样，我们可以使用ARMA(*p*,*q*)模型来拟合可用数据并生成预测。
- en: 6.3 Identifying a stationary ARMA process
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 识别平稳的ARMA过程
- en: Now that we’ve defined the autoregressive moving average process and seen how
    the orders *p* and *q* affect the model’s equation, we need to determine how to
    identify such an underlying process in a given time series.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了自回归移动平均过程，并看到了*p*和*q*的阶数如何影响模型方程，我们需要确定如何在一个给定的时间序列中识别这样的潜在过程。
- en: We’ll extend the steps that we defined in chapter 5 to include the final possibility
    that we have an ARMA(*p*,*q*) process, as shown in figure 6.3.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展第5章中定义的步骤，包括我们有一个ARMA(*p*,*q*)过程的可能性，如图6.3所示。
- en: '![](../../OEBPS/Images/06-03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-03.png)'
- en: Figure 6.3 Steps to identify a random walk, a moving average process MA(*q*),
    an autoregressive process AR(*p*), and an autoregressive moving average process
    ARMA(*p*, *q*)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3识别随机游走、移动平均过程MA(*q*)、自回归过程AR(*p*)和自回归移动平均过程ARMA(*p*, *q*)的步骤
- en: In figure 6.3 you’ll notice that if neither of the ACF and PACF plots shows
    a clear cutoff between significant and non-significant coefficients, then we have
    an ARMA(*p*,*q*) process. To verify that, let’s simulate our own ARMA process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.3中，你会注意到，如果ACF和PACF图都没有在显著和非显著系数之间显示清晰的截止点，那么我们就有了一个ARMA(*p*,*q*)过程。为了验证这一点，让我们模拟自己的ARMA过程。
- en: We’ll simulate an ARMA(1,1) process. This is equivalent to combining an MA(1)
    process with an AR(1) process. Specifically, we will simulate the ARMA(1,1) process
    defined in equation 6.7\. Notice that the constant C and mean μ are both equal
    to 0 here. The coefficients 0.33 and 0.9 are subjective choices for this simulation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟一个ARMA(1,1)过程。这相当于将MA(1)过程与AR(1)过程相结合。具体来说，我们将模拟方程6.7中定义的ARMA(1,1)过程。请注意，这里的常数C和均值μ都等于0。0.33和0.9是这个模拟的主观选择。
- en: '*y[t]* = 0.33*y*[*t*–1] + 0.9ϵ[*t*–1] + *ϵ[*t*]*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.33*y*[*t*–1] + 0.9ϵ[*t*–1] + *ϵ[*t*]*'
- en: Equation 6.7
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 方程6.7
- en: The objective of this simulation is to demonstrate that we cannot use the ACF
    plot to identify the order *q* of an ARMA(*p*,*q*) process, which in this case
    is 1, nor can we use the PACF plot to identify the order *p* of an ARMA(*p*,*q*)
    process, which in this case is 1 also.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟的目标是证明我们无法使用ACF图来识别ARMA(*p*,*q*)过程的阶数*q*，在这个例子中是1，也无法使用PACF图来识别ARMA(*p*,*q*)过程的阶数*p*，在这个例子中也是1。
- en: We’ll use the `ArmaProcess` function from the `statsmodels` library to simulate
    our ARMA(1,1) process. As in previous chapters, we’ll define the array of coefficients
    for the AR(1) process, as well as for the MA(1) process. From equation 6.7, we
    know our AR(1) process will have a coefficient of 0.33\. However, keep in mind
    that the function expects to have the coefficient of the autoregressive process
    with its opposite sign, as this is how it is implemented in the `statsmodels`
    library. Therefore, we input it as–0.33\. For the moving average portion, equation
    6.7 specifies that the coefficient is 0.9\. Also recall that when defining your
    arrays of coefficients, the first coefficient is always equal to 1, as specified
    by the library, which represents the coefficient at lag 0\. Once our coefficients
    are defined, we will generate 1,000 data points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`statsmodels`库中的`ArmaProcess`函数来模拟我们的ARMA(1,1)过程。正如前几章所做的那样，我们将定义AR(1)过程的系数数组，以及MA(1)过程的系数数组。从方程6.7中，我们知道我们的AR(1)过程将有一个系数为0.33。然而，请记住，该函数期望具有自回归过程的系数，其符号相反，因为这是在`statsmodels`库中的实现方式。因此，我们将其输入为-0.33。对于移动平均部分，方程6.7指定系数为0.9。还请记住，在定义你的系数数组时，第一个系数始终等于1，这是由库指定的，它代表滞后0的系数。一旦我们的系数定义完毕，我们将生成1,000个数据点。
- en: 'Note The source code for this chapter is available on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的源代码可在GitHub上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06)。
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Define the coefficients for the AR(1) portion. Remember that the first coefficient
    is always 1, as specified by the documentation. Also, we must write the coefficient
    of the AR portion with the opposite sign of what is defined in equation 6.7.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义AR(1)部分的系数。记住，根据文档，第一个系数始终为1。此外，我们必须用方程6.7中定义的相反符号来写AR部分的系数。
- en: ❷ Define the coefficients for the MA(1) portion. The first coefficient is 1,
    for lag 0, as specified by the documentation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义MA(1)部分的系数。第一个系数为1，代表滞后0，这是由文档指定的。
- en: ❸ Generate 1,000 samples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成1,000个样本。
- en: With our simulated data ready, we can move on to the next step and verify whether
    our process is stationary or not. We can do this by running the augmented Dickey-Fuller
    (ADF) test. We’ll print out the ADF statistic as well as the p-value. If the ADF
    statistic is a large negative number, and if we have a p-value smaller than 0.05,
    we can reject the null hypothesis and conclude that we have a stationary process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟数据准备好后，我们可以继续下一步，并验证我们的过程是否是平稳的。我们可以通过运行增强的迪基-富勒(ADF)测试来完成。我们将打印出ADF统计量以及p值。如果ADF统计量是一个大的负数，并且如果我们的p值小于0.05，我们可以拒绝零假设，并得出我们有一个平稳过程的结论。
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Run the ADF test on the simulated ARMA(1,1) data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对模拟的ARMA(1,1)数据进行ADF测试。
- en: This returns an ADF statistic of –6.43 and a p-value of 1.7×10^(–8). Since we
    have a large negative ADF statistic and a p-value that’s much smaller than 0.05,
    we can conclude that our simulated ARMA(1,1) process is stationary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个ADF统计量为-6.43和p值为1.7×10^(–8)。由于我们有一个大的负ADF统计量和远小于0.05的p值，我们可以得出结论，我们的模拟ARMA(1,1)过程是平稳的。
- en: Following the steps outlined in figure 6.3, we’ll plot the ACF and see if we
    can infer the order of the moving average portion of our simulated ARMA(1,1) process.
    Again, we’ll use the `plot_acf` function from `statsmodels` to generate figure
    6.4.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图6.3中概述的步骤，我们将绘制自相关函数（ACF）并查看我们是否可以推断出模拟的ARMA(1,1)过程中移动平均部分的阶数。再次强调，我们将使用`statsmodels`库中的`plot_acf`函数来生成图6.4。
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../../OEBPS/Images/06-04.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-04.png)'
- en: Figure 6.4 ACF plot of our simulated ARMA(1,1) process. Notice the sinusoidal
    pattern on the plot, meaning that an AR(*p*) process is in play. Also, the last
    significant coefficient is at lag 2, which suggests that *q* = 2\. However, we
    know that we simulated an ARMA(1,1) process, so *q* must be equal to 1! Therefore,
    the ACF plot cannot be used to infer the order *q* of an ARMA(*p*, *q*) process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：我们模拟的ARMA(1,1)过程的ACF图。注意图中的正弦波模式，这意味着存在一个AR(*p*)过程。此外，最后一个显著的系数出现在滞后2处，这表明*q*
    = 2。然而，我们知道我们模拟了一个ARMA(1,1)过程，因此*q*必须等于1！因此，ACF图不能用来推断ARMA(*p*, *q*)过程的阶数*q*。
- en: In figure 6.4 you’ll notice a sinusoidal pattern in the plot, which indicates
    the presence of an autoregressive process. This is expected, since we simulated
    an ARMA(1,1) process and we know of the existence of the autoregressive portion.
    Furthermore, you’ll notice that the last significant coefficient is at lag 2\.
    However, we know that our simulated data has an MA(1) process, so we would expect
    to have significant coefficients up to lag 1 only. We can thus conclude that the
    ACF plot does not reveal any useful information about the order *q* of our ARMA(1,1)
    process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.4中，你会在图中注意到一个正弦波模式，这表明存在一个自回归过程。这是预期的，因为我们模拟了一个ARMA(1,1)过程，并且我们知道存在自回归部分。此外，你还会注意到最后一个显著的系数出现在滞后2处。然而，我们知道我们的模拟数据具有MA(1)过程，因此我们预计只有到滞后1处才会有显著的系数。因此，我们可以得出结论，ACF图并没有揭示关于我们的ARMA(1,1)过程阶数*q*的有用信息。
- en: We can now move on to the next step outlined in figure 6.3 and plot the PACF.
    In chapter 5 you learned that the PACF can be used to find the order of a stationary
    AR(*p*) process. We will now verify whether we can find the order *p* of our simulated
    ARMA(1,1) process, where *p* = 1. We’ll use the `plot_pacf` function to generate
    figure 6.5.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续按照图6.3中概述的下一步，绘制PACF图。在第五章中，你学习了PACF可以用来找到平稳AR(*p*)过程的阶数。现在，我们将验证我们是否可以找到模拟ARMA(1,1)过程的阶数*p*，其中*p*
    = 1。我们将使用`plot_pacf`函数来生成图6.5。
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../../OEBPS/Images/06-05.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-05.png)'
- en: Figure 6.5 PACF plot of our simulated ARMA(1,1) process. Again, we have a sinusoidal
    pattern with no clear cutoff between significant and non-significant coefficients.
    From this plot, we cannot infer that *p* = 1 in our simulated ARMA(1,1) process,
    meaning that we cannot determine the order *p* of an ARMA(*p*, *q*) process using
    a PACF plot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：我们模拟的ARMA(1,1)过程的PACF图。再次，我们有一个正弦波模式，显著和非显著系数之间没有明显的截止点。从这个图中，我们不能推断出在我们的模拟ARMA(1,1)过程中*p*
    = 1，这意味着我们不能使用PACF图来确定ARMA(*p*, *q*)过程的阶数*p*。
- en: In figure 6.5 we can see a clear sinusoidal pattern, meaning that we cannot
    infer a value for the order *p*. We know that we simulated an ARMA(1,1) process,
    but we cannot determine that value from the PACF plot in figure 6.5, since we
    have significant coefficients past lag 1\. Therefore, the PACF plot cannot be
    used to find the order *p* of an ARMA(*p*,*q*) process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.5中，我们可以看到一个清晰的正弦波模式，这意味着我们不能推断出阶数*p*的值。我们知道我们模拟了一个ARMA(1,1)过程，但我们不能从图6.5中的PACF图中确定该值，因为我们有滞后1之后的显著系数。因此，PACF图不能用来找到ARMA(*p*,
    *q*)过程的阶数*p*。
- en: According to figure 6.3, since there is no clear cutoff between significant
    and non-significant coefficients in both the ACF and PACF plots, we can conclude
    that we have an ARMA(*p*,*q*) process, which is indeed the case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图6.3，由于ACF和PACF图中显著和非显著系数之间没有明显的截止点，我们可以得出结论，我们有一个ARMA(*p*,*q*)过程，这确实是情况。
- en: Identifying a stationary ARMA(*p*,*q*) process
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 识别平稳的ARMA(*p*,*q*)过程
- en: If your process is stationary and both the ACF and PACF plots show a decaying
    or sinusoidal pattern, then it is a stationary ARMA(*p*,*q*) process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的过程是平稳的，并且ACF和PACF图都显示出衰减或正弦波模式，那么它就是一个平稳的ARMA(*p*,*q*)过程。
- en: We know that determining the order of our process is key in modeling and forecasting,
    since the order will dictate how many parameters must be included in our model.
    Since the ACF and PACF plots are not useful in the case of an ARMA(*p*,*q*) process,
    we must thus devise a general modeling procedure that will allow us to find the
    appropriate combination of (*p*,*q*) for our model.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在建模和预测中确定我们过程的顺序是关键，因为顺序将决定我们模型中必须包含多少参数。由于在ARMA(*p*,*q*)过程中ACF和PACF图没有用，因此我们必须制定一个通用的建模程序，以便我们能够找到适合我们模型的适当(*p*,*q*)组合。
- en: 6.4 Devising a general modeling procedure
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 制定一个通用的建模程序
- en: In the previous section, we covered the steps for identifying a stationary ARMA(*p*,*q*)
    process. We saw that if both the ACF and PACF plots display a sinusoidal or decaying
    pattern, our time series can be modeled by an ARMA(*p*,*q*) process. However,
    neither plot was useful for determining the orders *p* and *q*. With our simulated
    ARMA(1,1) process, we noticed that coefficients were significant after lag 1 in
    both plots.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了识别平稳ARMA(*p*,*q*)过程的步骤。我们看到了如果ACF和PACF图都显示出正弦波或衰减模式，我们的时间序列可以通过ARMA(*p*,*q*)过程建模。然而，这两个图在确定*p*和*q*的顺序时都没有用。在我们的模拟ARMA(1,1)过程中，我们注意到在滞后1之后，两个图中的系数都是显著的。
- en: Therefore, we must devise a procedure that allows us to find the orders *p*
    and *q*. This procedure will have the advantage that it can also be applied in
    situations where our time series is non-stationary and has seasonal effects. Furthermore,
    it will also be suitable for cases where *p* or *q* are equal to 0, meaning that
    we can move away from plotting the ACF and PACF and rely entirely on a model selection
    criterion and residual analysis. The steps are shown in figure 6.6.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须制定一个程序，使我们能够找到*p*和*q*的顺序。这个程序的优势在于它也可以应用于我们的时间序列非平稳且有季节性影响的情况。此外，它也适用于*p*或*q*等于0的情况，这意味着我们可以摆脱ACF和PACF的绘图，完全依赖于模型选择准则和残差分析。步骤在图6.6中显示。
- en: '![](../../OEBPS/Images/06-06.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-06.png)'
- en: Figure 6.6 General modeling procedure for an ARMA(*p*, *q*) process. The first
    steps are to gather the data, test for stationarity, and apply transformations
    accordingly. Then we define a list of possible values for *p* and *q*. We then
    fit every combination of ARMA(*p*, *q*) to our data and select the model with
    the lowest AIC. Then we perform the residual analysis by looking at the Q-Q plot
    and the residual correlogram. If they approach that of white noise, the model
    can be used for forecasts. Otherwise, we must try different values for *p* and
    *q*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 ARMA(*p*, *q*)过程的一般建模程序。第一步是收集数据，测试平稳性，并相应地应用转换。然后我们定义*p*和*q*的可能值列表。然后我们将ARMA(*p*,
    *q*)的每个组合拟合到我们的数据中，并选择AIC最低的模型。然后我们通过查看Q-Q图和残差自相关图来进行残差分析。如果它们接近白噪声，则可以使用该模型进行预测。否则，我们必须尝试不同的*p*和*q*值。
- en: In figure 6.6 you can see that this new modeling procedure completely removes
    the plotting of the ACF and PACF. It allows us to select a model based entirely
    on statistical tests and numerical criteria, instead of relying on the qualitative
    analysis of the ACF and PACF plots.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.6中，你可以看到这个新的建模程序完全去除了ACF和PACF的绘图。它允许我们完全基于统计测试和数值标准来选择模型，而不是依赖于ACF和PACF图的定性分析。
- en: The first few steps remain unchanged from those we gradually built up until
    chapter 5, as we must still gather the data, test for stationarity, and apply
    transformations accordingly. Then we list different possible values of *p* and
    *q*—note that they only take positive integers. With a list of possible values,
    we can fit every unique combination of ARMA(*p*,*q*) to our data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个步骤与我们在第5章逐渐建立起来的步骤保持不变，因为我们仍然需要收集数据，测试平稳性，并相应地应用转换。然后我们列出*p*和*q*的不同可能值——请注意，它们只取正整数。有了可能值的列表，我们可以将每个唯一的ARMA(*p*,*q*)组合拟合到我们的数据中。
- en: Once that’s done, we can compute the *Akaike information criterion* (AIC), which
    is discussed at length in sections 6.4.1 and 6.4.2\. This quantifies the quality
    of each model in relation to each other. The model with the lowest AIC is then
    selected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以计算*赤池信息准则*（AIC），这在第6.4.1和6.4.2节中进行了详细讨论。这量化了每个模型相对于其他模型的质量。然后选择AIC最低的模型。
- en: From there, we can analyze the model’s residuals, which is the difference between
    the actual and predicted values of the model. Ideally, the residuals will look
    like white noise, which would mean that any difference between the predicted values
    and actual values is due to randomness. Therefore, the residuals must be uncorrelated
    and independently distributed. We can assess those properties by studying the
    *quantile-quantile plot* (Q-Q plot) and running the *Ljung-Box test*, which we’ll
    explore in section 6.4.3\. If the analysis leads us to conclude that the residuals
    are completely random, we have a model ready for forecasting. Otherwise, we must
    try a different set of values for *p* and *q* and start the process over.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以分析模型的残差，即模型实际值和预测值之间的差异。理想情况下，残差将看起来像白噪声，这意味着预测值和实际值之间的任何差异都是由于随机性造成的。因此，残差必须是未相关且独立分布的。我们可以通过研究
    *分位数-分位数图* (Q-Q plot) 和运行 *Ljung-Box 测试* 来评估这些属性，这些内容将在 6.4.3 节中探讨。如果分析导致我们得出残差完全随机的结论，我们就有一个适合预测的模型。否则，我们必须尝试不同的
    *p* 和 *q* 值组合，并重新开始这个过程。
- en: A lot of new concepts and techniques will be introduced as we work through our
    new general modeling procedure. We will dive into each step in detail in future
    sections and work with our simulated ARMA(1,1) process. Then we will apply the
    same procedure to model bandwidth usage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过新的通用建模过程，将介绍许多新的概念和技术。我们将在未来的章节中详细探讨每一步，并使用我们的模拟 ARMA(1,1) 过程进行操作。然后我们将应用相同的程序来建模带宽使用。
- en: 6.4.1 Understanding the Akaike information criterion (AIC)
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 理解 Akaike 信息准则 (AIC)
- en: Before covering the steps outlined in figure 6.6, we need to determine how we
    will choose the best model of all the models that we will fit. Here we will use
    the Akaike information criterion (AIC) to select the optimal model.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍图 6.6 中的步骤之前，我们需要确定我们将如何从我们将要拟合的所有模型中选择最佳模型。在这里，我们将使用 Akaike 信息准则 (AIC) 来选择最佳模型。
- en: The AIC estimates the quality of a model relative to other models. Given that
    there will be some information lost when a model is fitted to the data, the AIC
    quantifies the relative amount of information lost by the model. The less information
    lost, the lower the AIC value and the better the model.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 估计模型相对于其他模型的质量。由于当模型拟合到数据时，总会丢失一些信息，AIC 量化了模型丢失的相对信息量。丢失的信息越少，AIC 值越低，模型越好。
- en: The AIC is a function of the number of estimated parameters *k* and the maximum
    value of the likelihood function for the model *L̂*, as shown in equation 6.8.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 是估计参数数量 *k* 和模型似然函数最大值 *L̂* 的函数，如方程 6.8 所示。
- en: AIC 2*k* – 2ln(*L̂*)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 2*k* – 2ln(*L̂*)
- en: Equation 6.8
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 6.8
- en: Akaike information criterion (AIC)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Akaike 信息准则 (AIC)
- en: The Akaike information criterion (AIC) is a measure of the quality of a model
    in relation to other models. It is used for model selection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Akaike 信息准则 (AIC) 是衡量模型质量相对于其他模型的指标。它用于模型选择。
- en: 'The AIC is a function of the number of parameters *k* in a model and the maximum
    value of the likelihood function *L̂*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 是模型中参数数量 *k* 和似然函数最大值 *L̂* 的函数：
- en: AIC 2*k* – 2ln(*L̂*)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 2*k* – 2ln(*L̂*)
- en: The lower the value of the AIC, the better the model. Selecting according to
    the AIC allows us to keep a balance between the complexity of a model and its
    goodness of fit to the data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 的值越低，模型越好。根据 AIC 进行选择，可以使我们在模型的复杂性和其与数据的拟合优度之间保持平衡。
- en: 'The number of estimated parameters *k* is directly related to the order (*p*,*q*)
    of an ARMA(*p*,*q*) model. If we fit an ARMA(2,2) model, then we have 2 + 2 =
    4 parameters to estimate. If we fit an ARMA(3,4) model, then we have 3 + 4 = 7
    parameters to estimate. You can see how fitting a more complex model can penalize
    the AIC score: as the order (*p*,*q*) increases, the number of parameters *k*
    increases, and so the AIC increases.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 估计参数数量 *k* 与 ARMA(*p*,*q*) 模型的阶数 (*p*,*q*) 直接相关。如果我们拟合一个 ARMA(2,2) 模型，那么我们就有
    2 + 2 = 4 个参数需要估计。如果我们拟合一个 ARMA(3,4) 模型，那么我们就有 3 + 4 = 7 个参数需要估计。你可以看到拟合一个更复杂的模型如何惩罚
    AIC 分数：随着 (*p*,*q*) 阶数的增加，参数数量 *k* 增加，因此 AIC 也增加。
- en: The likelihood function measures the goodness of fit of a model. It can be viewed
    as the opposite of the distribution function. Given a model with fixed parameters,
    the distribution function will measure the probability of observing a data point.
    The likelihood function flips the logic. Given a set of observed data, it will
    estimate how likely it is that different model parameters will generate the observed
    data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 似然函数衡量模型的拟合优度。它可以被视为分布函数的相反。给定一个具有固定参数的模型，分布函数将衡量观察到数据点的概率。似然函数翻转了这种逻辑。给定一组观察数据，它将估计不同模型参数生成观察数据的可能性有多大。
- en: 'For example, consider the situation where we roll a six-sided die. The distribution
    function tells us that there is a 1/6 probability that we’ll observe one of these
    values: [1,2,3,4,5,6]. Now let’s flip this logic to explain the likelihood function.
    Suppose that you roll a die 10 times and you obtain the following values: [1,5,3,4,6,2,4,3,2,1].
    The likelihood function will determine how likely it is that the die has six sides.
    Applying this logic to the context of AIC, we can think of the likelihood function
    as an answer to the question “How likely is it that my observed data is coming
    from an ARMA(1,1) model?” If it is very likely, meaning that *L̂* is large, then
    the ARMA(1,1) model fits the data well.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们掷一个六面骰子的情况。分布函数告诉我们，我们有1/6的概率观察到以下值之一：[1,2,3,4,5,6]。现在让我们翻转这个逻辑来解释似然函数。假设你掷骰子10次，得到以下值：[1,5,3,4,6,2,4,3,2,1]。似然函数将确定骰子有六个面的可能性有多大。将这种逻辑应用于AIC的上下文中，我们可以将似然函数视为回答“我的观察数据来自ARMA(1,1)模型的可能性有多大？”的问题。如果可能性非常大，意味着*L̂*很大，那么ARMA(1,1)模型与数据拟合得很好。
- en: Therefore, if a model fits the data really well, the maximum value of the likelihood
    will be high. Since the AIC subtracts the natural logarithm of the maximum value
    of the likelihood, represented by *L̂* in equation 6.8, then a large value of
    *L̂* will lower the AIC.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个模型与数据非常吻合，似然函数的最大值将会很高。由于AIC减去似然函数最大值的自然对数，由方程6.8中的*L̂*表示，那么*L̂*的大值将会降低AIC。
- en: You can see how the AIC keeps a balance between underfitting and overfitting.
    Remember that the lower the AIC, the better the model relative to other models.
    Therefore, an overfitting model would have a very good fit, meaning that *L̂*
    is large and AIC decreases. However, the number of parameters *k* would be large
    as well, which penalizes the AIC. An underfitting model would have a small number
    of parameters, so *k* would be small. However, the maximum value of the likelihood
    function would also be small due to the poor fit, meaning again that the AIC is
    penalized. Thus, the AIC allows us to find a balance between the number of parameters
    in a model and a good fit to the training data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到AIC如何在欠拟合和过拟合之间保持平衡。记住，AIC越低，相对于其他模型，模型越好。因此，一个过拟合的模型会有一个非常好的拟合，这意味着*L̂*很大，AIC降低。然而，参数的数量*k*也会很大，这会惩罚AIC。一个欠拟合的模型会有很少的参数，所以*k*会很小。然而，由于拟合不好，似然函数的最大值也会很小，这意味着AIC再次受到惩罚。因此，AIC使我们能够在模型参数的数量和训练数据的良好拟合之间找到平衡。
- en: Finally, we must keep in mind that the AIC quantifies the quality of a model
    in relation to other models only. It is therefore a relative measure of quality.
    In the event that we fit only poor models to our data, the AIC will simply help
    us determine the best from that group of models.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须记住，AIC仅量化模型相对于其他模型的质量。因此，它是一个相对质量度量。如果我们只将较差的模型拟合到我们的数据上，AIC将帮助我们确定那一组模型中的最佳模型。
- en: Now let’s use the AIC to help us select an appropriate model for our simulated
    ARMA(1,1) process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用AIC帮助我们为模拟的ARMA(1,1)过程选择一个合适的模型。
- en: 6.4.2 Selecting a model using the AIC
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 使用AIC选择模型
- en: We’ll now cover the steps of the general modeling procedure outlined in figure
    6.6 using our simulated ARMA(1,1) process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用图6.6中概述的一般建模步骤，结合我们的模拟ARMA(1,1)过程进行说明。
- en: In section 6.3 we tested for stationarity and concluded that our simulated process
    is already stationary. Therefore, we can move on to defining a list of possible
    values for *p* and *q*. While we know the values of both orders from the simulation,
    let’s consider the following steps as a demonstration that the general modeling
    procedure works.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6.3节中，我们进行了平稳性检验，并得出结论，我们的模拟过程已经平稳。因此，我们可以继续定义一个可能的*p*和*q*值的列表。虽然我们知道这两个阶数来自模拟，但让我们考虑以下步骤作为演示，说明一般建模过程是可行的。
- en: We will allow the values of *p* and *q* to vary from 0 to 3\. Note that this
    range is arbitrary, and you may try a larger range of values if you wish. We will
    create a list of all possible combinations of (*p*,*q*), using the `product` function
    from `itertools`. Since there four possible values for *p* and *q*, this will
    generate a list of 16 unique combinations of (*p*,*q*).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许*p*和*q*的值从0到3变化。请注意，这个范围是任意的，如果您愿意，可以尝试更大的值范围。我们将使用`itertools`模块中的`product`函数创建所有可能的(*p*,*q*)组合的列表。由于*p*和*q*有四个可能的值，这将生成一个包含16个唯一的(*p*,*q*)组合的列表。
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Create a list of possible values for p starting from 0 inclusively to 4 exclusively,
    with steps of 1.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个从0（包含）到4（不包含）开始的可能值列表，步长为1。
- en: ❷ Create a list of possible values for q starting from 0 inclusively to 4 exclusively,
    with steps of 1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个从0（包含）到4（不包含）开始的可能值列表，步长为1。
- en: ❸ Generate a list containing all unique combinations of (p,q).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成一个包含所有唯一的(p,q)组合的列表。
- en: With our list of possible values created, we must now fit all unique 16 ARMA(*p*,*q*)
    models to our simulated data. To do so, we’ll define an `optimize_ARMA` function
    that takes the data and the list of unique (*p*,*q*) combinations as input. Inside
    the function, we’ll initialize an empty list to store each (*p*,*q*) combination
    and its corresponding AIC. Then we’ll iterate over each (*p*,*q*) combination
    and fit an ARMA(*p*,*q*) model to our data. We’ll compute the AIC and store the
    result. Then we’ll create a `DataFrame` and sort it by AIC value in ascending
    order, since the lower the AIC, the better the model. Our function will finally
    output the ordered `DataFrame` so we can select the appropriate model. The `optimize_ARMA`
    function is shown in the following listing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了可能的值列表之后，我们现在必须将所有唯一的16个ARMA(*p*,*q*)模型拟合到我们的模拟数据中。为此，我们将定义一个`optimize_ARMA`函数，该函数接受数据和唯一的(*p*,*q*)组合列表作为输入。在函数内部，我们将初始化一个空列表来存储每个(*p*,*q*)组合及其对应的AIC。然后我们将遍历每个(*p*,*q*)组合，并拟合一个ARMA(*p*,*q*)模型到我们的数据。我们将计算AIC并存储结果。然后我们将创建一个`DataFrame`并按AIC值升序排序，因为AIC越低，模型越好。我们的函数最终将输出排序后的`DataFrame`，以便我们可以选择合适的模型。`optimize_ARMA`函数如下所示。
- en: Listing 6.1 Function to fit all unique ARMA(*p*,*q*) models
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1：拟合所有唯一ARMA(*p*,*q*)模型的函数
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The function takes as inputs the time series data and the list of unique (p,q)
    combinations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数接受时间序列数据和唯一的(p,q)组合列表作为输入。
- en: ❷ Initialize an empty list to store the order (p,q) and its corresponding AIC
    as a tuple.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化一个空列表来存储顺序(p,q)及其对应的AIC作为元组。
- en: ❸ Iterate over each unique (p,q) combination. The use of tqdm_notebook will
    display a progress bar.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历每个唯一的(p,q)组合。使用tqdm_notebook将显示进度条。
- en: ❹ Fit an ARMA(p,q) model using the SARIMAX function. We specify simple_differencing=False
    to prevent differencing. Recall that differencing is the result of y[t]– y[*t*–1].
    We also specify disp=False to avoid printing convergence messages to the console.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用SARIMAX函数拟合ARMA(p,q)模型。我们指定simple_differencing=False以防止差分。回想一下，差分是y[t]–
    y[*t*–1]的结果。我们还指定disp=False以避免将收敛消息打印到控制台。
- en: ❺ Calculate the model’s AIC.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算模型的AIC。
- en: ❻ Append the (p,q) combination and AIC as a tuple to the results list.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将(p,q)组合和AIC作为元组添加到结果列表中。
- en: ❼ Store the (p,q) combination and AIC in a DataFrame.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将(p,q)组合和AIC存储在DataFrame中。
- en: ❽ Label the columns of the DataFrame.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 标记DataFrame的列。
- en: ❾ Sort the DataFrame in ascending order of AIC values. The lower the AIC, the
    better the model.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 按AIC值升序排序DataFrame。AIC越低，模型越好。
- en: With our function defined, we can now use it and fit the different ARMA(*p*,*q*)
    models. The output is shown in figure 6.7\. You’ll see that the model with the
    lowest AIC corresponds to an ARMA(1,1) model, which is exactly the process that
    we simulated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的函数后，现在我们可以使用它来拟合不同的ARMA(*p*,*q*)模型。结果如图6.7所示。您会看到AIC最低的模型对应于ARMA(1,1)模型，这正是我们模拟的过程。
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Fit the different ARMA(p,q) models on the simulated ARMA(1,1) data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在模拟的ARMA(1,1)数据上拟合不同的ARMA(p,q)模型。
- en: ❷ Display the resulting DataFrame.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示生成的DataFrame。
- en: '![](../../OEBPS/Images/06-07.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-07.png)'
- en: Figure 6.7 Resulting `DataFrame` from fitting all ARMA(*p*, *q*) models to the
    simulated ARMA(1,1) data. We can see that the model with the lowest AIC corresponds
    to an ARMA(1,1) model, meaning that we successfully identified the order of our
    simulated data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：将所有ARMA(*p*, *q*)模型拟合到模拟的ARMA(1,1)数据的结果`DataFrame`。我们可以看到AIC最低的模型对应于ARMA(1,1)模型，这意味着我们成功识别了模拟数据的阶数。
- en: As mentioned in the previous section, the AIC is a measure of relative quality.
    Here we can say that an ARMA(1,1) model is the best model relative to all other
    models that we fit to our data. Now we need an absolute measure of the model’s
    quality. This brings us to the next step of our modeling procedure, which is residual
    analysis.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AIC 是相对质量的度量。在这里，我们可以说 ARMA(1,1) 模型相对于我们拟合到数据中的所有其他模型来说是最好的模型。现在我们需要一个模型质量的绝对度量。这带我们进入了建模过程的下一步，即残差分析。
- en: 6.4.3 *Understanding residual analysis*
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 *理解残差分析*
- en: Up to this point, we have fit different ARMA(*p*,*q*) models to our simulated
    ARMA(1,1) process. Using the AIC as a model selection criterion, we found that
    an ARMA(1,1) model is the best model relative to all others that were fit. Now
    we must measure its absolute quality by performing an analysis on the model’s
    residuals.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将不同的 ARMA(*p*,*q*) 模型拟合到我们的模拟 ARMA(1,1) 过程中。使用 AIC 作为模型选择标准，我们发现 ARMA(1,1)
    模型相对于所有其他拟合的模型来说是最好的。现在我们必须通过分析模型的残差来衡量其绝对质量。
- en: 'This brings us to the last steps before forecasting, which is residual analysis
    and answering the two questions in figure 6.8: does the Q-Q plot show a straight
    line, and are the residuals uncorrelated? If the answer to both questions is yes,
    then we have a model that’s ready to make forecasts. Otherwise, we must try different
    combinations of (*p*,*q*) and restart the process.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们进入预测前的最后一步，即残差分析和回答图 6.8 中的两个问题：Q-Q 图是否显示一条直线，残差是否不相关？如果这两个问题的答案都是肯定的，那么我们就拥有了一个可以用来进行预测的模型。否则，我们必须尝试不同的
    (*p*,*q*) 组合并重新开始这个过程。
- en: '![](../../OEBPS/Images/06-08.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-08.png)'
- en: Figure 6.8 The general modeling procedure for an ARMA(*p*, *q*) process
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 ARMA(*p*, *q*) 过程的一般建模步骤
- en: The residuals of a model are simply the difference between the predicted values
    and the actual values. Consider our simulated ARMA(1,1) process expressed in equation
    6.9.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的残差简单地是预测值和实际值之间的差异。考虑我们用方程 6.9 表示的模拟 ARMA(1,1) 过程。
- en: '*y[t]* = 0.33*y*[*t*–1] + 0.9*ϵ*[*t*–1] + *ϵ[*t*]*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.33*y*[*t*–1] + 0.9*ϵ*[*t*–1] + *ϵ[*t*]*'
- en: Equation 6.9
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 6.9
- en: Now suppose that we fit an ARMA(1,1) model to our process, and we estimate the
    model’s coefficients perfectly, such that the model is expressed as equation 6.10.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们将 ARMA(1,1) 模型拟合到我们的过程中，并且我们完美地估计了模型的系数，使得模型可以表示为方程 6.10。
- en: '*ŷ[t]* = 0.33*y*[*t*–1] + 0.9*ϵ*[*t*–1]'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*ŷ[t]* = 0.33*y*[*t*–1] + 0.9*ϵ*[*t*–1]'
- en: Equation 6.10
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 6.10
- en: The residuals will be the difference between the values coming from our model
    and the observed values from our simulated process. In other words, the residuals
    are the difference between equation 6.9 and equation 6.10\. The result is shown
    in equation 6.11.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 残差将是模型输出的值与模拟过程中的观测值之间的差异。换句话说，残差是方程 6.9 和方程 6.10 之间的差异。结果在方程 6.11 中显示。
- en: residuals = 0.33*y*[*t*–1] + 0.9*ϵ*[*t*–1] + *ϵ[*t*]* – (0.33*y*[*t*–1] + 0.9)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 残差 = 0.33*y*[*t*–1] + 0.9*ϵ*[*t*–1] + *ϵ[*t*]* – (0.33*y*[*t*–1] + 0.9)
- en: residuals = *ϵ[*t*]*
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 残差 = *ϵ[*t*]*
- en: Equation 6.11
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 6.11
- en: As you can see in equation 6.11, in a perfect situation the residuals of a model
    are white noise. This indicates that the model has captured all predictive information,
    and there is only a random fluctuation left that cannot be modeled. Thus, the
    residuals must be uncorrelated and have a normal distribution in order for us
    to conclude that we have a good model for making forecasts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如方程 6.11 所示，在理想情况下，模型的残差是白噪声。这表明模型已经捕捉到了所有预测信息，只剩下无法建模的随机波动。因此，为了得出我们有一个适合进行预测的好模型这一结论，残差必须是不相关的，并且具有正态分布。
- en: 'There are two aspects to residual analysis: a qualitative analysis and a quantitative
    analysis. The qualitative analysis focuses on studying the Q-Q plot, while the
    quantitative analysis determines whether our residuals are uncorrelated.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 残差分析有两个方面：定性分析和定量分析。定性分析侧重于研究 Q-Q 图，而定量分析确定我们的残差是否不相关。
- en: 'Qualitative analysis: Studying the Q-Q plot'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 定性分析：研究 Q-Q 图
- en: The first step in residual analysis is the study of the *quantile-quantile plot*
    (Q-Q plot). The Q-Q plot is a graphical tool for verifying our hypothesis that
    the model’s residuals are normally distributed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 残差分析的第一步是研究 *分位数-分位数图* (Q-Q 图)。Q-Q 图是一种图形工具，用于验证我们的假设，即模型的残差是正态分布的。
- en: The Q-Q plot is constructed by plotting the quantiles of our residuals on the
    *y*-axis against the quantiles of a theoretical distribution, in this case the
    normal distribution, on the *x*-axis. This results in a scatterplot. We are comparing
    the distribution to a normal distribution because we want the residuals to be
    similar to white noise, which is normally distributed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Q-Q图是通过在*y*轴上绘制我们的残差分位数与*x*轴上理论分布的分位数（在这种情况下是正态分布）相对比来构建的。这产生了一个散点图。我们比较分布与正态分布，因为我们希望残差类似于白噪声，它是正态分布的。
- en: If both distributions are similar, meaning that the distribution of the residuals
    is close to a normal distribution, the Q-Q plot will display a straight line that
    approximately lies on *y* = *x*. This in turn means that our model is a good fit
    for our data. You can see an example of a Q-Q plot where the residuals are normally
    distributed in figure 6.9.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个分布相似，即残差分布接近正态分布，Q-Q图将显示一条大约位于*y* = *x*上的直线。这反过来又意味着我们的模型适合我们的数据。你可以在图6.9中看到一个残差正态分布的Q-Q图示例。
- en: '![](../../OEBPS/Images/06-09.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9示例](../../OEBPS/Images/06-09.png)'
- en: Figure 6.9 A Q-Q plot of randomly distributed residuals. On the *y*-axis, we
    have the quantiles coming from the residuals. On the *x*-axis, we have the quantiles
    coming from a theoretical normal distribution. You can see a straight line approximately
    lying on *y* = *x*. This is an indication that our residuals are very close to
    a normal distribution.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 随机分布残差的Q-Q图。在*y*轴上，我们有来自残差的分位数。在*x*轴上，我们有来自理论正态分布的分位数。你可以看到一条大约位于*y* =
    *x*上的直线。这是我们的残差非常接近正态分布的指示。
- en: On the other hand, a Q-Q plot of residuals that are not close to a normal distribution
    will generate a curve that departs from *y* = *x*. In figure 6.10 you can see
    that the thick line is not straight and not lying on *y* = *x*. If we get this
    sort of result, we can conclude that the distribution of our residuals does not
    resemble a normal distribution, which is a sign that our model is not a good fit
    for our data. Therefore, we must try a different range of values for *p*and *q*,
    fit the models, select the one with the lowest AIC, and perform residual analysis
    on the new model.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果残差与正态分布不接近的Q-Q图将生成一条偏离*y* = *x*的曲线。在图6.10中，你可以看到粗线不是直的，并且不位于*y* = *x*上。如果我们得到这种结果，我们可以得出结论，我们的残差分布不类似于正态分布，这是我们的模型不适合我们的数据的迹象。因此，我们必须尝试不同的*p*和*q*值范围，拟合模型，选择具有最低AIC的模型，并在新的模型上执行残差分析。
- en: '![](../../OEBPS/Images/06-10.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Q-Q图示例](../../OEBPS/Images/06-10.png)'
- en: Figure 6.10 A Q-Q plot of residuals that are not close to a normal distribution.
    You can clearly see that the thick line is curved, and it is not lying on *y*
    = *x*. Therefore, the distribution of the residuals is very different from a normal
    distribution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 不接近正态分布的残差的Q-Q图。你可以清楚地看到粗线是弯曲的，并且不位于*y* = *x*上。因此，残差分布与正态分布非常不同。
- en: Quantile-quantile plot (Q-Q plot)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 分位数-分位数图（Q-Q图）
- en: A Q-Q plot is a plot of the quantiles of two distributions against each other.
    In time series forecasting, we plot the distribution of our residuals on the *y*-axis
    against the theoretical normal distribution on the *x*-axis.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Q-Q图是两个分布的分位数相互之间的图。在时间序列预测中，我们在*y*轴上绘制我们的残差分布，与*x*轴上的理论正态分布相对比。
- en: This graphical tool allows to us to assess the goodness of fit of our model.
    If the distribution of our residuals is similar to a normal distribution, we will
    see a straight line lying on *y* = *x*. This means that our model is a good fit,
    because the residuals are similar to white noise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图形工具使我们能够评估我们模型的拟合优度。如果我们的残差分布类似于正态分布，我们将在*y* = *x*上看到一条直线。这意味着我们的模型是一个好的拟合，因为残差类似于白噪声。
- en: On the other hand, if the distribution of our residuals is different from a
    normal distribution, we will see a curved line. We can then conclude that our
    model is not a good fit, since the residuals’ distribution is not close to a normal
    distribution, and therefore the residuals are not similar to white noise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们的残差分布与正态分布不同，我们将看到一条曲线。然后我们可以得出结论，我们的模型不是一个好的拟合，因为残差分布不接近正态分布，因此残差不类似于白噪声。
- en: You can see how the Q-Q plot can help us. We know that if a model is a good
    fit to our data, the residuals will be similar to white noise and therefore will
    have similar properties. This means that they should be normally distributed.
    Hence, if the Q-Q plot displays a straight line, we have a good model. Otherwise,
    our model must be discarded, and we must try to fit a better model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 Q-Q 图如何帮助我们。我们知道，如果一个模型很好地拟合我们的数据，残差将类似于白噪声，因此将具有相似的性质。这意味着它们应该是正态分布的。因此，如果
    Q-Q 图显示一条直线，我们有一个好的模型。否则，我们的模型必须被舍弃，我们必须尝试拟合一个更好的模型。
- en: While the Q-Q plot is a fast method for assessing the quality of our model,
    this analysis remains subjective. Thus, we will further support our residual analysis
    with a quantitative method by applying the Ljung-Box test.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Q-Q 图是一种快速评估模型质量的方法，但这种分析仍然是主观的。因此，我们将通过应用 Ljung-Box 检验来进一步支持我们的残差分析，使用定量方法。
- en: 'Quantitative analysis: Applying the Ljung-Box test'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定量分析：应用 Ljung-Box 检验
- en: Once we have analyzed the Q-Q plot and determined that our residuals are approximately
    normally distributed, we can then apply the Ljung-Box test to demonstrate that
    the residuals are uncorrelated. Remember that a good model has residuals that
    are similar to white noise, so the residuals should be normally distributed and
    uncorrelated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们分析了 Q-Q 图并确定我们的残差近似正态分布，我们就可以应用 Ljung-Box 检验来证明残差是不相关的。记住，一个好的模型具有类似于白噪声的残差，因此残差应该是正态分布且不相关的。
- en: The Ljung-Box test is a statistical test that tests if the autocorrelation of
    a group of data is significantly different from 0\. In our case, we will apply
    the Ljung-Box test to the model’s residuals to assess whether they are correlated
    or not. The null hypothesis states that the data is independently distributed,
    meaning that there is no autocorrelation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Ljung-Box 检验是一种统计检验，用于检验一组数据的自相关是否显著不同于 0。在我们的情况下，我们将应用 Ljung-Box 检验来评估模型的残差是否相关。零假设表明数据是独立分布的，这意味着没有自相关。
- en: Ljung-Box test
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Ljung-Box 检验
- en: The Ljung-Box test is a statistical test that determines whether the autocorrelation
    of a group of data is significantly different from 0.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Ljung-Box 检验是一种统计检验，用于确定一组数据的自相关是否显著不同于 0。
- en: In time series forecasting, we apply the Ljung-Box test on the model’s residuals
    to test whether they are similar to white noise. The null hypothesis states that
    the data is independently distributed, meaning that there is no autocorrelation.
    If the p-value is larger than 0.05, we cannot reject the null hypothesis, meaning
    that the residuals are independently distributed. Therefore, there is no autocorrelation,
    the residuals are similar to white noise, and the model can be used for forecasting.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列预测中，我们应用 Ljung-Box 检验于模型的残差，以检验它们是否类似于白噪声。零假设表明数据是独立分布的，这意味着没有自相关。如果 p
    值大于 0.05，我们不能拒绝零假设，这意味着残差是独立分布的。因此，没有自相关，残差类似于白噪声，该模型可用于预测。
- en: If the p-value is less than 0.05, we reject the null hypothesis, meaning that
    our residuals are not independently distributed and are correlated. The model
    cannot be used for forecasting.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 p 值小于 0.05，我们拒绝零假设，这意味着我们的残差不是独立分布的，并且是相关的。该模型不能用于预测。
- en: The test will return the Ljung-Box statistic and a p-value. If the p-value is
    less than 0.05, we reject the null hypothesis, meaning that the residuals are
    not independently distributed, which in turn means that there is autocorrelation.
    In such a situation, the residuals do not approximate the properties of white
    noise, and the model must be discarded.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将返回 Ljung-Box 统计量和 p 值。如果 p 值小于 0.05，我们拒绝零假设，这意味着残差不是独立分布的，这反过来意味着存在自相关。在这种情况下，残差不近似白噪声的性质，该模型必须被舍弃。
- en: If the p-value is larger than 0.05, we cannot reject the null hypothesis, meaning
    that our residuals are independently distributed. Thus, there is no autocorrelation,
    and the residuals are similar to white noise. This means that we can move on with
    our model and make forecasts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 p 值大于 0.05，我们不能拒绝零假设，这意味着我们的残差是独立分布的。因此，没有自相关，残差类似于白噪声。这意味着我们可以继续使用我们的模型进行预测。
- en: Now that you understand the concepts of residual analysis, let’s apply these
    techniques to our simulated ARMA(1,1) process.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了残差分析的概念，让我们将这些技术应用到我们的模拟 ARMA(1,1) 过程中。
- en: 6.4.4 Performing residual analysis
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 执行残差分析
- en: We will now resume the modeling procedure for our simulated ARMA(1,1) process.
    We have successfully selected a model with the lowest AIC, which was expectedly
    an ARMA(1,1) model. Now, as you can see in figure 6.11, we need to perform residual
    analysis to assess whether our model is a good fit to the data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续对模拟的ARMA(1,1)过程进行建模。我们已经成功选择了一个具有最低AIC的模型，这预期是一个ARMA(1,1)模型。现在，如图6.11所示，我们需要进行残差分析，以评估我们的模型是否很好地拟合了数据。
- en: '![](../../OEBPS/Images/06-11.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-11.png)'
- en: Figure 6.11 General modeling procedure for an ARMA(*p*, *q*) process
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 ARMA(*p*, *q*)过程的通用建模过程
- en: We know that our ARMA(1,1) model must be good, since we simulated an ARMA(1,1)
    process, but this section will demonstrate that our modeling procedure works.
    We are not likely to be modeling and forecasting simulated data in a business
    context, so it is important to cover the entire modeling procedure on a known
    process first, to convince ourselves that it works, before applying it on real-life
    data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的ARMA(1,1)模型必须是好的，因为我们模拟了一个ARMA(1,1)过程，但本节将演示我们的建模过程是有效的。在商业环境中，我们不太可能对模拟数据进行建模和预测，因此首先在已知过程中覆盖整个建模过程是很重要的，这样我们才能确信它有效，然后再将其应用于实际数据。
- en: To perform residual analysis, we need to fit our model and store the residuals
    in a variable for easy access. Using `statsmodels`, we will first define an ARMA(1,1)
    model before fitting it to our simulated data. Then we can access the residuals
    with the `resid` property.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行残差分析，我们需要拟合我们的模型并将残差存储在一个变量中以便于访问。使用`statsmodels`，我们首先定义一个ARMA(1,1)模型，然后将其拟合到我们的模拟数据。然后我们可以通过`resid`属性访问残差。
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Store the model’s residuals.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储模型的残差。
- en: The next step is to plot the Q-Q plot, and we’ll use the `qqplot` function from
    `statsmodels` to display our residuals against a normal distribution. The function
    simply requires the data, and it will by default compare its distribution to a
    normal distribution. We’ll also need to display the line *y* = *x* in order to
    assess the similarity of both distributions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是绘制Q-Q图，我们将使用`statsmodels`中的`qqplot`函数来显示我们的残差与正态分布的对比。该函数只需要数据，它将默认将其分布与正态分布进行比较。我们还需要显示线*y*
    = *x*，以便评估两个分布的相似性。
- en: '[PRE8]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Plot the Q-Q plot of the residuals. Specify the display of the line y = x.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制残差的Q-Q图。指定显示线y = x。
- en: The result is shown in figure 6.12\. You will see a thick straight line that
    approximately lies on *y* = *x*. Therefore, from a qualitative standpoint, the
    model’s residuals seem to be normally distributed, just like white noise, which
    is an indication that our model fits the data well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图6.12所示。你会看到一个大约位于*y* = *x*上的厚直线。因此，从定性角度来看，模型的残差似乎呈正态分布，就像白噪声一样，这是我们的模型很好地拟合数据的指示。
- en: '![](../../OEBPS/Images/06-12.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-12.png)'
- en: Figure 6.12 Q-Q plot of our ARMA(1,1) residuals. You can see a thick straight
    line lying on *y* = *x*. This means that our residuals are normally distributed,
    just like white noise.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12展示了我们的ARMA(1,1)残差的Q-Q图。你可以看到一个厚直的线躺在*y* = *x*上。这意味着我们的残差是正态分布的，就像白噪声一样。
- en: We’ll extend our qualitative analysis by using the `plot_diagnostics` method.
    This generates a figure containing four different plots, including a Q-Q plot.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用`plot_diagnostics`方法来扩展我们的定性分析。这会生成一个包含四个不同图的图形，包括Q-Q图。
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is shown in figure 6.13\. You can see how `statsmodels` makes it
    easy for us to qualitatively analyze the residuals.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图6.13所示。你可以看到`statsmodels`如何使我们能够轻松地进行残差的定性分析。
- en: '![](../../OEBPS/Images/06-13.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-13.png)'
- en: Figure 6.13 Model diagnostics from `statsmodels`. The top-left plot displays
    the residuals, the histogram of the residuals is at the top right, the Q-Q plot
    of the residuals is at the bottom left, and the bottom right shows the ACF plot
    of the residuals.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 `statsmodels`的模型诊断。左上角的图显示了残差，残差直方图在右上角，残差的Q-Q图在左下角，右下角显示了残差的ACF图。
- en: The top-left plot shows the residuals across the entire dataset. You can see
    that there is no trend, and the mean seems stable over time, which is indicative
    of stationarity, just like white noise.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 左上角的图显示了整个数据集的残差。你可以看到没有趋势，并且均值似乎随时间稳定，这表明了平稳性，就像白噪声一样。
- en: The top-right plot shows a histogram of the residuals. You can see the shape
    of a normal distribution on this plot, which again indicates that the residuals
    are close to white noise, as white noise is normally distributed as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 右上角的图显示了残差直方图。你可以看到这个图上的正态分布形状，这再次表明残差接近白噪声，因为白噪声也是正态分布的。
- en: At the bottom left, we have the Q-Q plot, which is identical to figure 6.12,
    and therefore leads us to the same conclusion.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在左下角，我们有 Q-Q 图，它与图 6.12 相同，因此得出相同的结论。
- en: Finally, the bottom-right plot shows the autocorrelation function of our residuals.
    You can see that there is only a significant peak at lag 0, and no significant
    coefficients otherwise. This means that the residuals are not correlated, which
    further supports the conclusion that they are similar to white noise, which is
    what we expect from a good model.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，右下角的图显示了我们的残差的自相关函数。你可以看到，仅在滞后 0 处有一个显著的峰值，其他地方没有显著的系数。这意味着残差是不相关的，这进一步支持了结论，即它们类似于白噪声，这是我们期望的良好模型所应有的。
- en: The final step in residual analysis is applying the Ljung-Box test. This allows
    us to quantitatively assess whether our residuals are indeed uncorrelated. We
    will use the `acorr_ljungbox` function from `statsmodels` to perform the Ljung-Box
    test on the residuals. The function takes as input the residuals as well as a
    list of lags. Here we will compute the Ljung-Box statistic and p-value for 10
    lags.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 残差分析的最后一步是应用 Ljung-Box 测试。这使我们能够定量地评估我们的残差是否确实是不相关的。我们将使用 `statsmodels` 中的 `acorr_ljungbox`
    函数对残差进行 Ljung-Box 测试。该函数接受残差以及滞后项列表作为输入。这里我们将计算 10 个滞后项的 Ljung-Box 统计量和 p 值。
- en: '[PRE10]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Apply the Ljung-Box test on the residuals, on 10 lags.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在残差上应用 Ljung-Box 测试，在 10 个滞后项上。
- en: ❷ Display the p-value for each lag.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示每个滞后项的 p 值。
- en: The resulting list of p-values shows that each is above 0.05\. Therefore, at
    each lag, the null hypothesis cannot be rejected, meaning that the residuals are
    independently distributed and uncorrelated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 p 值列表显示，每个值都高于 0.05。因此，在每个滞后项上，不能拒绝零假设，这意味着残差是独立分布且不相关的。
- en: We can conclude from our analysis that the residuals are similar to white noise.
    The Q-Q plot showed a straight line, meaning that the residuals are normally distributed.
    Furthermore, the Ljung-Box test shows that the residuals are uncorrelated, just
    like white noise. Thus, the residuals are completely random, meaning that we have
    a model that fits our data well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的分析中可以得出结论，残差类似于白噪声。Q-Q 图显示了一条直线，这意味着残差是正态分布的。此外，Ljung-Box 测试显示残差是不相关的，就像白噪声一样。因此，残差是完全随机的，这意味着我们有一个很好地拟合我们数据的模型。
- en: Now let’s apply the same modeling procedure to the bandwidth dataset.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将相同的建模过程应用于带宽数据集。
- en: 6.5 Applying the general modeling procedure
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 应用通用建模过程
- en: We now have a general modeling procedure that allows us to model and forecast
    a general ARMA(*p*,*q*) model, as outlined in figure 6.14\. We applied this procedure
    to our simulated ARMA(1,1) process and found that the best fit was an ARMA(1,1)
    model, as expected.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个通用的建模过程，它允许我们建模和预测一个通用的 ARMA(*p*,*q*) 模型，如图 6.14 所示。我们将此过程应用于我们的模拟 ARMA(1,1)
    过程，并发现最佳拟合模型是一个 ARMA(1,1) 模型，正如预期的那样。
- en: '![](../../OEBPS/Images/06-14.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-14.png)'
- en: Figure 6.14 General modeling procedure for an ARMA(*p*, *q*) process
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 ARMA(*p*, *q*) 过程的通用建模过程
- en: Now we can apply the same procedure on the bandwidth dataset to obtain the best
    model possible for this situation. Recall that our objective is to forecast bandwidth
    usage for the next 2 hours.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将相同的程序应用于带宽数据集，以获得这种情况的最佳模型。回想一下，我们的目标是预测未来 2 小时的带宽使用情况。
- en: 'The first step is to gather and load the data using `pandas`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用 `pandas` 收集和加载数据：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can then plot our time series and look for a trend or a seasonal pattern.
    By now, you should be comfortable with plotting your time series. The result is
    shown in figure 6.15.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制我们的时间序列并寻找趋势或季节性模式。到现在为止，你应该已经熟悉了绘制时间序列。结果如图 6.15 所示。
- en: '[PRE12]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](../../OEBPS/Images/06-15.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-15.png)'
- en: Figure 6.15 Hourly bandwidth usage in a data center since January 1, 2019\.
    The dataset contains 10,000 points.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 自 2019 年 1 月 1 日起数据中心的小时带宽使用情况。数据集包含 10,000 个点。
- en: With the data plotted in figure 6.15, you can see that there is no periodic
    pattern in the data. However, you’ll notice the presence of a long-term trend,
    meaning that our data is likely not stationary. Let’s apply the ADF test to verify
    our hypothesis. Again, we’ll use the `adfuller` function from `statsmodels` and
    print out the ADF statistic and the p-value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.15中绘制数据后，你可以看到数据中没有周期性模式。然而，你会注意到存在长期趋势，这意味着我们的数据可能不是平稳的。让我们应用ADF测试来验证我们的假设。同样，我们将使用`statsmodels`中的`adfuller`函数，并打印出ADF统计量和p值。
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This prints out an ADF statistic of –0.8 and a p-value of 0.80\. Therefore,
    we cannot reject the null hypothesis, meaning that our time series is not stationary.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印出一个ADF统计量为-0.8和p值为0.80。因此，我们不能拒绝零假设，这意味着我们的时间序列不是平稳的。
- en: We must apply a transformation to our data in order to make it stationary. Let’s
    apply a first-order differencing using `numpy`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对我们的数据进行变换，使其平稳。让我们使用`numpy`进行一阶差分。
- en: '[PRE14]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this done, we can apply the ADF test again, this time on the differenced
    data, in order to test for stationarity.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以再次应用ADF测试，这次是对差分数据进行测试，以检验平稳性。
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This returns an ADF statistic of –20.69 and a p-value of 0.0\. With a large,
    negative ADF statistic and a p-value that is much smaller than 0.05, we can say
    that our differenced series is stationary.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个ADF统计量为-20.69和p值为0.0。由于ADF统计量很大且为负值，且p值远小于0.05，我们可以断定我们的差分序列是平稳的。
- en: We are now ready to start modeling our stationary process using an ARMA(*p*,*q*)
    model. We’ll split our series into train and test sets. Here we’ll keep the last
    7 days of data for the test set. Since our forecasts are for the next 2 hours,
    the test set thus contains 84 periods of 2 hours on which to evaluate our models’
    performance, since 7 days of hourly data totals 168 hours.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始使用ARMA(*p*,*q*)模型对平稳过程进行建模。我们将把我们的序列分为训练集和测试集。在这里，我们将保留最后7天的数据作为测试集。由于我们的预测是针对接下来的2小时，因此测试集包含84个2小时的周期，用于评估我们模型的性能，因为7天的每小时数据总计168小时。
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ There are 168 hours in a week, so we will assign the last 168 data points
    to the test set.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一周有168小时，因此我们将最后168个数据点分配给测试集。
- en: We can print out the length of the train and test sets as a sanity check, and
    sure enough, the test set has 168 data points, and the train set has 9,831 data
    points.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出训练集和测试集的长度作为合理性检查，果然，测试集有168个数据点，训练集有9,831个数据点。
- en: Now let’s visualize our train set and test set for both the differenced and
    original series. The resulting plot is shown in figure 6.16.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们可视化我们的训练集和测试集，包括差分序列和原始序列。结果图如图6.16所示。
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../../OEBPS/Images/06-16.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-16.png)'
- en: Figure 6.16 Train and test sets for the original and differenced series
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 原始和差分序列的训练集和测试集
- en: With our train set ready, we can now fit different ARMA(*p*,*q*) models using
    the `optimize_ ARMA` function that we defined earlier. Remember that the function
    takes the data and the list of unique (*p*,*q*) combinations as input. Inside
    the function, we initialize an empty list to store each (*p*,*q*) combination
    and its corresponding AIC. Then we iterate over each (*p*,*q*) combination and
    fit an ARMA(*p*,*q*) model on our data. We compute the AIC and store the result.
    Then we create a `DataFrame` and sort it by AIC value in ascending order, since
    the lower the AIC, the better the model. Our function finally outputs the ordered
    `DataFrame` so we can select the appropriate model. The `optimize_ ARMA` function
    is shown in the following listing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好训练集后，我们现在可以使用之前定义的`optimize_ ARMA`函数来拟合不同的ARMA(*p*,*q*)模型。请记住，该函数接受数据和唯一(*p*,*q*)组合列表作为输入。在函数内部，我们初始化一个空列表来存储每个(*p*,*q*)组合及其对应的AIC。然后我们遍历每个(*p*,*q*)组合，并在我们的数据上拟合一个ARMA(*p*,*q*)模型。我们计算AIC并存储结果。然后我们创建一个`DataFrame`，按AIC值升序排序，因为AIC越低，模型越好。我们的函数最终输出排序后的`DataFrame`，以便我们可以选择合适的模型。`optimize_
    ARMA`函数的代码如下所示。
- en: Listing 6.2 Function to fit all unique ARMA(*p*,*q*) models
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 拟合所有唯一ARMA(*p*,*q*)模型的函数
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The function takes as inputs the time series data and the list of unique (p,q)
    combinations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数接受时间序列数据和唯一（p,q）组合列表作为输入。
- en: ❷ Initialize an empty list to store the order (p,q) and its corresponding AIC
    as a tuple.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化一个空列表来存储顺序（p,q）及其对应的AIC作为元组。
- en: ❸ Iterate over each unique (p,q) combination. The use of tqdm_notebook will
    display a progress bar.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历每个唯一的（p,q）组合。使用tqdm_notebook将显示进度条。
- en: ❹ Fit an ARMA(p,q) model using the SARIMAX function. We specify simple_differencing=False
    to prevent differencing. We also specify disp=False to avoid printing convergence
    messages to the console.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用SARIMAX函数拟合ARMA(p,q)模型。我们指定simple_differencing=False以防止差分。我们还指定disp=False以避免将收敛消息打印到控制台。
- en: ❺ Calculate the model’s AIC.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算模型的AIC值。
- en: ❻ Append the (p,q) combination and AIC as a tuple to the results list.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将(p,q)组合和AIC作为一个元组添加到结果列表中。
- en: ❼ Store the (p,q) combination and AIC in a DataFrame.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将(p,q)组合和AIC存储在DataFrame中。
- en: ❽ Label the columns of the DataFrame.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 标记DataFrame的列。
- en: ❾ Sort the DataFrame in ascending order of AIC value. The lower the AIC, the
    better the model.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 按AIC值升序排序DataFrame。AIC值越低，模型越好。
- en: Here we will try values for *p* and *q* ranging from 0 to 3 inclusively. This
    means that we will fit 16 unique ARMA(*p*,*q*) models to our training set and
    select the one with the lowest AIC. Feel free to change the range of values for
    *p* and *q*, but keep in mind that a larger range will result in more models being
    fit and a longer computation time. Also, you don’t need to worry about overfitting—we
    are selecting our model using the AIC, which will prevent us from selecting a
    model that overfits.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试*p*和*q*的值从0到3（包括0和3）。这意味着我们将拟合16个独特的ARMA(*p*,*q*)模型到我们的训练集，并选择AIC最低的那个。你可以随意更改*p*和*q*的值范围，但请记住，范围越大，拟合的模型越多，计算时间也会更长。另外，你不需要担心过拟合——我们是通过AIC来选择模型的，这会防止我们选择一个过拟合的模型。
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The order p can have the values {0,1,2,3}.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 阶数p可以取值{0,1,2,3}。
- en: ❷ The order q can have the values {0,1,2,3}.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 阶数q可以取值{0,1,2,3}。
- en: ❸ Generate the unique (p,q) combinations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成唯一的(p,q)组合。
- en: With this step done, we can pass in our training set and the list of unique
    (*p*,*q*) combinations to the `optimize_ARMA` function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我们可以将我们的训练集和唯一的(*p*,*q*)组合列表传递给`optimize_ARMA`函数。
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The resulting `DataFrame` is shown in figure 6.17\. You’ll notice that the first
    three models all have an AIC of 27,991, with only slight differences. Therefore,
    I would argue that the ARMA(2,2) model is the model that should be selected. Its
    AIC value is very close to the ARMA(3,2) and ARMA(2,3) models, while being less
    complex, since it has four parameters to be estimated instead of five. Therefore,
    we’ll select the ARMA(2,2) model and move on to the next steps, which is the analysis
    of the model’s residuals.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`DataFrame`如图6.17所示。你会注意到前三个模型的所有AIC值都是27,991，只有细微的差异。因此，我会认为ARMA(2,2)模型是应该选择的模型。它的AIC值非常接近ARMA(3,2)和ARMA(2,3)模型，而它的复杂度更低，因为它有四个参数需要估计，而不是五个。因此，我们将选择ARMA(2,2)模型，并继续下一步，即分析模型的残差。
- en: '![](../../OEBPS/Images/06-17.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-17.png)'
- en: Figure 6.17 A `DataFrame` ordered by ascending value of AIC, resulting from
    fitting different ARMA(*p*, *q*) models on the differenced bandwidth dataset.
    Notice how the first three models all have an AIC value of 27,991.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 按AIC值升序排列的`DataFrame`，结果是在差分带宽数据集上拟合不同的ARMA(*p*, *q*)模型。注意前三个模型的所有AIC值都是27,991。
- en: To perform the residual analysis, we’ll fit the ARMA(2,2) model on our training
    set. Then we’ll use the `plot_diagnostics` method to study the Q-Q plot, as well
    as the other accompanying plots. The result is shown in figure 6.18.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行残差分析，我们将对训练集拟合ARMA(2,2)模型。然后，我们将使用`plot_diagnostics`方法来研究Q-Q图，以及其他伴随的图表。结果如图6.18所示。
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../../OEBPS/Images/06-18.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-18.png)'
- en: Figure 6.18 Model diagnostics from `statsmodels`. The top-left plot displays
    the residuals, the histogram of the residuals is at the top right, the Q-Q plot
    of the residuals is at the bottom left, and the bottom right shows the ACF plot
    of the residuals.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 `statsmodels`的模型诊断。左上角的图显示了残差，残差的直方图在右上角，残差的Q-Q图在左下角，右下角显示了残差的ACF图。
- en: In figure 6.18 you can see that the top-left plot shows no trend, and the mean
    seems constant over time, meaning that our residuals are likely stationary. The
    top right displays a density plot with a shape similar to that of a normal distribution.
    The Q-Q plot at the bottom left shows a thick straight line that is very close
    to *y* = *x*. Finally, the ACF plot at the bottom right shows no autocorrelation
    after lag 0\. Thus, figure 6.18 indicates that our residuals clearly resemble
    white noise, since they are normally distributed and uncorrelated.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.18中，你可以看到左上角的图没有趋势，平均值似乎随时间保持不变，这意味着我们的残差很可能是平稳的。右上角显示了一个密度图，其形状类似于正态分布。左下角的Q-Q图显示了一条非常接近*y*
    = *x*的粗直线。最后，右下角的ACF图在滞后0之后没有自相关。因此，图6.18表明我们的残差明显类似于白噪声，因为它们是正态分布且不相关的。
- en: Our last step is to run the Ljung-Box test on the residuals for the first 10
    lags. If the returned p-values exceed 0.05, we cannot reject the null hypothesis,
    which means that our residuals are uncorrelated and independently distributed,
    just like white noise.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是对前10个滞后项的残差进行Ljung-Box测试。如果返回的p值超过0.05，我们不能拒绝零假设，这意味着我们的残差是不相关的且独立分布的，就像白噪声一样。
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The returned p-values all exceed 0.05\. Therefore, we can conclude that our
    residuals are indeed uncorrelated. Our ARMA(2,2) model has passed all the checks
    on the residual analysis, and we are ready to use this model to forecast bandwidth
    usage.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的p值都超过了0.05。因此，我们可以得出结论，我们的残差确实是不相关的。我们的ARMA(2,2)模型已经通过了残差分析的各项检查，我们准备使用这个模型来预测带宽使用。
- en: 6.6 Forecasting bandwidth usage
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 预测带宽使用
- en: In the previous section, we applied the general modeling procedure on the bandwidth
    dataset and concluded than an ARMA(2,2) model was the best model for our data.
    Now we will use the ARMA(2,2) model to forecast the next 2 hours of bandwidth
    usage over 7 days.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将通用建模过程应用于带宽数据集，并得出结论：ARMA(2,2)模型是我们数据的最佳模型。现在我们将使用ARMA(2,2)模型来预测未来7天内2小时的带宽使用情况。
- en: 'We will reuse the `rolling_forecast` function that we defined and used in chapters
    4 and 5, as shown in listing 6.3\. Recall that this function allows us to forecast
    a few timesteps at a time, until we have forecasts for the entire horizon. This
    time, of course, we’ll fit an ARMA(2,2) model to our differenced data. Also, we’ll
    compare the model’s performance to two benchmarks: the mean and the last known
    value. This will allow us to make sure that an ARMA(2,2) model performs better
    than naive forecasting methods.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们在第4章和第5章中定义并使用的`rolling_forecast`函数，如列表6.3所示。回想一下，这个函数允许我们一次预测几个时间步长，直到我们对整个预测范围都有预测。这次，当然，我们将对差分数据拟合一个ARMA(2,2)模型。此外，我们将比较该模型与两个基准的性能：平均值和最后一个已知值。这将确保ARMA(2,2)模型比简单的预测方法表现更好。
- en: Listing 6.3 A function to perform a rolling forecast on a horizon
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 执行滚动预测的函数
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The order specifies an ARMA(2,2) model.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定ARMA(2,2)模型。
- en: With `rolling_forecast` defined, we can use it to evaluate the performance of
    the different forecasting methods. We’ll first create a `DataFrame` to hold the
    actual values of the test set as well as the predictions from the different methods.
    Then we’ll specify the size of the train and test sets. We will predict two steps
    at a time, because we have an ARMA(2,2) model, meaning that there is an MA(2)
    component. We know from chapter 4 that predicting beyond *q* steps into the future
    with an MA(*q*) model will simply return the mean, so the predictions will remain
    flat. We’ll therefore avoid this situation by setting the window to 2\. We can
    then forecast on the test set using the mean method, the last known value method,
    and the ARMA(2,2) model, and store each forecast in its appropriate column in
    `test`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`rolling_forecast`之后，我们可以用它来评估不同预测方法的性能。我们首先创建一个`DataFrame`来保存测试集的实际值以及不同方法的预测。然后我们指定训练集和测试集的大小。由于我们有ARMA(2,2)模型，意味着存在一个MA(2)成分，我们将一次预测两个步骤。我们知道从第4章中，使用MA(*q*)模型预测超过*q*个步骤的未来将简单地返回平均值，因此预测将保持平坦。因此，我们将通过设置窗口为2来避免这种情况。然后我们可以使用平均值方法、最后一个已知值方法和ARMA(2,2)模型在测试集上进行预测，并将每个预测存储在`test`的相应列中。
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can then plot and visualize the forecasts for each method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制并可视化每种方法的预测。
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Assign a gray background for the testing period.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为测试期间分配灰色背景。
- en: ❷ Zoom in on the testing period.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 放大测试期间。
- en: The results are shown in figure 6.19\. I’ve zoomed in on the testing period
    for a better visualization.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在图6.19中。我已经放大了测试期以获得更好的可视化。
- en: '![](../../OEBPS/Images/06-19.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-19.png)'
- en: Figure 6.19 Forecasts of the differenced hourly bandwidth usage using the mean,
    the last known value, and an ARMA(2,2) model. You can see how the ARMA(2,2) forecasts
    and last known value forecasts almost coincide with the actual values of the test
    set.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 使用均值、最后一个已知值和ARMA(2,2)模型预测的差分小时带宽使用情况。您可以看到ARMA(2,2)预测和最后一个已知值预测几乎与测试集的实际值相吻合。
- en: In figure 6.19 you can see that the ARMA(2,2) forecasts, shown as a dashed line,
    almost coincide with the actual values of the test set. The same can be said of
    the forecasts from the last known value method, shown as a dashed and dotted line.
    Of course, the forecasts using the mean, shown as a dotted line, are completely
    flat over the testing period.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.19中，您可以看到ARMA(2,2)预测（以虚线表示）几乎与测试集的实际值相吻合。同样，最后一个已知值方法的预测（以虚线和点划线表示）也是如此。当然，使用均值进行的预测（以点划线表示）在测试期间完全平坦。
- en: We’ll now measure the mean squared error (MSE) to evaluate the performance of
    each model. The model with the lowest MSE is the best-performing model.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测量均方误差（MSE）以评估每个模型的性能。MSE最低的模型是表现最好的模型。
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This returns an MSE of 6.3 for the mean method, 2.2 for the last known value
    method, and 1.8 for the ARMA(2,2) model. The ARMA(2,2) model outperforms the benchmarks,
    meaning that we have a well-performing model.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了均值的MSE为6.3，最后一个已知值的MSE为2.2，ARMA(2,2)模型的MSE为1.8。ARMA(2,2)模型优于基准模型，这意味着我们有一个表现良好的模型。
- en: The final step is to reverse the transformation of our forecast in order to
    bring it to the same scale as our original data. Remember that we differenced
    the original data to make it stationary. The ARMA(2,2) model was then applied
    on the stationary dataset and produced forecasts that are differenced.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们预测的变换逆转，以便将其调整到与原始数据相同的尺度。记住，我们通过差分原始数据使其平稳。然后，ARMA(2,2)模型被应用于平稳数据集，并产生了差分的预测。
- en: To reverse the differencing transformation, we can apply a cumulative sum, just
    as we did in chapters 4 and 5.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要逆转差分变换，我们可以应用累积和，就像我们在第4章和第5章中所做的那样。
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can then plot the forecasts on the original scale of the data.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在数据的原始尺度上绘制预测值。
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Looking at the results in figure 6.20, you can see that our forecasts, shown
    as a dashed line, closely follow the actual values of the test set, and the two
    lines almost coincide.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图6.20中的结果，您可以看到我们的预测（以虚线表示）紧密跟随测试集的实际值，并且两条线几乎相吻合。
- en: '![](../../OEBPS/Images/06-20.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-20.png)'
- en: Figure 6.20 Undifferenced predictions of hourly bandwidth usage. Notice how
    the dashed line representing our predictions almost coincides with the solid line
    representing the actual values. This means that our predictions are very close
    to the actual values, indicating a performant model.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 小时带宽使用的未差分预测。注意，代表我们预测的虚线几乎与代表实际值的实线相吻合。这意味着我们的预测非常接近实际值，表明模型表现良好。
- en: We can measure the mean absolute error (MAE) of the undifferenced ARMA(2,2)
    predictions to understand how far apart the predictions are from the actual values.
    We’ll use the MAE simply because it is easy to interpret.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测量未差分的ARMA(2,2)预测的平均绝对误差（MAE），以了解预测与实际值之间的差距。我们将使用MAE，因为它易于解释。
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This returns an MAE of 14, meaning that, on average, our forecasts are 14 Mbps
    above or below the actual bandwidth usage.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了14的MAE，这意味着，平均而言，我们的预测比实际带宽使用量高14 Mbps或低14 Mbps。
- en: 6.7 Next steps
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 下一步
- en: 'In this chapter, we covered the ARMA(*p*,*q*) model and how it effectively
    combines an AR(*p*) model with an MA(*q*) model to model and forecast more complex
    time series. This required us to define an entirely new modeling procedure that
    does not rely on the qualitative study of the ACF and PACF plots. Instead, we
    fit many ARMA(*p*,*q*) models with different (*p*,*q*) combinations and selected
    the model with the lowest AIC. Then we analyzed the model’s residuals to make
    sure that their properties were similar to white noise: normally distributed,
    stationary, and uncorrelated. This analysis is both qualitative, because we can
    study the Q-Q plot to evaluate whether the residuals are normally distributed,
    as well as quantitative, since we can apply the Ljung-Box test to determine whether
    the residuals are correlated or not. If the model’s residuals have the properties
    of a random variable, like white noise, the model can be used for forecasting.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了ARMA(*p*,*q*)模型以及它如何有效地将AR(*p*)模型与MA(*q*)模型结合，以建模和预测更复杂的时间序列。这要求我们定义一个全新的建模程序，该程序不依赖于ACF和PACF图的定性研究。相反，我们拟合了许多具有不同(*p*,*q*)组合的ARMA(*p*,*q*)模型，并选择了具有最低AIC的模型。然后我们分析了模型的残差，以确保它们的性质与白噪声相似：正态分布、平稳和无关。这种分析既是定性的，因为我们可以通过研究Q-Q图来评估残差是否正态分布，也是定量的，因为我们可以通过应用Ljung-Box测试来确定残差是否相关。如果模型的残差具有随机变量的性质，如白噪声，则该模型可用于预测。
- en: 'So far we have covered different models for stationary time series: mainly
    the MA(*q*) model, AR(*p*) model, and ARMA(*p*,*q*) model. Each model required
    us to transform our data to make it stationary before we could forecast. Furthermore,
    we had to reverse the transformation on our forecast to obtain predictions in
    the original scale of the data.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了平稳时间序列的不同模型：主要是MA(*q*)模型、AR(*p*)模型和ARMA(*p*,*q*)模型。每个模型都需要我们在进行预测之前将我们的数据转换为平稳状态。此外，我们还需要在预测上逆转这种转换，以获得数据原始尺度上的预测。
- en: However, there is a way to model non-stationary time series without having to
    transform them and reverse the transformation on the predictions. Specifically,
    we can model *integrated* time series using the *autoregressive integrated moving
    average* model or ARIMA(*p*,*d*,*q*). This will be the subject of the next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以建模非平稳时间序列，而无需对其进行转换并在预测上逆转转换。具体来说，我们可以使用自回归积分移动平均模型或ARIMA(*p*,*d*,*q*)来建模*积分*时间序列。这将是下一章的主题。
- en: 6.8 Exercises
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 练习
- en: 'It is time to test your knowledge and apply the general modeling procedure
    with these exercises. The solutions are available on GitHub: [https://github.com/marcopeix/
    TimeSeriesForecastingInPython/tree/master/CH06](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试你的知识，并使用这些练习应用通用的建模程序了。解决方案可在GitHub上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH06)。
- en: 6.8.1 Make predictions on the simulated ARMA(1,1) process
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1 在模拟的ARMA(1,1)过程中进行预测
- en: Reusing the simulated ARMA(1,1) process, split it into train and test sets.
    Assign 80% of the data to the train set and the remaining 20% to the test set.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新使用模拟的ARMA(1,1)过程，将其分为训练集和测试集。将80%的数据分配给训练集，剩余的20%分配给测试集。
- en: Use the `rolling_forecast` function to make predictions using the ARMA(1,1)
    model, the mean method, and the last known value method.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rolling_forecast`函数，利用ARMA(1,1)模型、均值方法和最后已知值方法进行预测。
- en: Plot your forecasts.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: Evaluate each method’s performance using the MSE. Which method performed best?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用均方误差（MSE）评估每种方法的性能。哪种方法表现最好？
- en: 6.8.2 Simulate an ARMA(2,2) process and make forecasts
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.2 模拟ARMA(2,2)过程并进行预测
- en: 'Simulate a stationary ARMA(2,2) process. Use the `ArmaProcess` function from
    `statsmodels` and simulate this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一个平稳的ARMA(2,2)过程。使用`statsmodels`中的`ArmaProcess`函数进行模拟：
- en: '*y[t]* = 0.33*y*[*t*–1] + 0.50*y*[*t*–2] + 0.9*ϵ*[*t*–1] + 0.3*ϵ*[*t*–2]'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.33*y*[*t*–1] + 0.50*y*[*t*–2] + 0.9*ϵ*[*t*–1] + 0.3*ϵ*[*t*–2]'
- en: Simulate 10,000 samples.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟10,000个样本。
- en: '[PRE30]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Set the seed for reproducibility. Change the seed if you want to experiment
    with different values.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 设置种子以实现可重复性。如果你想尝试不同的值，可以更改种子。
- en: Plot your simulated process.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的模拟过程。
- en: Test for stationarity using the ADF test.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ADF测试进行平稳性检验。
- en: Split your data into train and test sets. The test set must contain the last
    200 timesteps. The rest is for the train set.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的数据分为训练集和测试集。测试集必须包含最后200个时间步长。其余的用于训练集。
- en: Define a range of values for *p* and *q*, and generate all unique combinations
    of orders (*p*,*q*).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义*p*和*q*的值范围，并生成所有唯一的(*p*,*q*)阶数组合。
- en: Use the `optimize_ARMA` function to fit all unique ARMA(*p*,*q*) models, and
    select the one with the lowest AIC. Is the ARMA(2,2) model the one with the lowest
    AIC?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`optimize_ARMA`函数拟合所有唯一的ARMA(*p*,*q*)模型，并选择AIC最低的模型。ARMA(2,2)模型是AIC最低的吗？
- en: Select the best model according to the AIC, and store the residuals in a variable
    called `residuals`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据AIC选择最佳模型，并将残差存储在一个名为`residuals`的变量中。
- en: Perform a qualitative analysis of the residuals with the `plot_diagnostics`
    method. Does the Q-Q plot show a straight line that lies on *y* = *x*? Does the
    correlogram show significant coefficients?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`plot_diagnostics`方法对残差进行定性分析。Q-Q图是否显示一条位于*y* = *x*上的直线？自相关图是否显示显著的系数？
- en: Perform a quantitative analysis of the residuals by applying the Ljung-Box test
    on the first 10 lags. Are all returned p-values above 0.05? Are the residuals
    correlated or not?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对前10个滞后项应用Ljung-Box测试，对残差进行定量分析。所有返回的p值是否都高于0.05？残差是否相关？
- en: Use the `rolling_forecast` function to make predictions using the selected ARMA(*p*,*q*)
    model, the mean method, and the last known value method.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rolling_forecast`函数使用选定的ARMA(*p*,*q*)模型、均值方法和最后已知值方法进行预测。
- en: Plot your forecasts.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: Evaluate each method’s performance using the MSE. Which method performed best?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MSE评估每种方法的性能。哪种方法表现最好？
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The autoregressive moving average model, denoted as ARMA(*p*,*q*), is the combination
    of the autoregressive model AR(*p*) and the moving average model MA(*q*).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自回归移动平均模型，表示为ARMA(*p*,*q*)，是自回归模型AR(*p*)和移动平均模型MA(*q*)的组合。
- en: An ARMA(*p*,*q*) process will display a decaying pattern or a sinusoidal pattern
    on both the ACF and PACF plots. Therefore, they cannot be used to estimate the
    orders *p* and *q*.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMA(*p*,*q*)过程将在ACF和PACF图上显示衰减模式或正弦模式。因此，它们不能用来估计*p*和*q*的阶数。
- en: The general modeling procedure does not rely on the ACF and PACF plots. Instead,
    we fit many ARMA(*p*,*q*) models and perform model selection and residual analysis.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用建模过程不依赖于ACF和PACF图。相反，我们拟合许多ARMA(*p*,*q*)模型，并进行模型选择和残差分析。
- en: Model selection is done with the Akaike information criterion (AIC). It quantifies
    the information loss of a model, and it is related to the number of parameters
    in a model and its goodness of fit. The lower the AIC, the better the model.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型选择是通过赤池信息准则（AIC）进行的。它量化了模型的信息损失，它与模型中的参数数量及其拟合优度有关。AIC越低，模型越好。
- en: The AIC is relative measure of quality. It returns the best model among other
    models. For an absolute measure of quality, we perform residual analysis.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AIC是质量的相对度量。它返回其他模型中的最佳模型。为了获得绝对的质量度量，我们进行残差分析。
- en: Residuals of a good model must approximate white noise, meaning that they must
    be uncorrelated, normally distributed, and independent.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好模型的残差必须近似白噪声，这意味着它们必须是不相关的、正态分布的且独立的。
- en: The Q-Q plot is a graphical tool for comparing two distributions. We use it
    to compare the distribution of the residuals against a theoretical normal distribution.
    If the plot shows a straight line that lies on *y* = *x*, then both distributions
    are similar. Otherwise, it means that the residuals are not normally distributed.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q-Q图是一种用于比较两个分布的图形工具。我们用它来比较残差分布与理论正态分布。如果图显示一条位于*y* = *x*上的直线，那么这两个分布是相似的。否则，这意味着残差不是正态分布的。
- en: The Ljung-Box test allows us to determine whether the residuals are correlated
    or not. The null hypothesis states that the data is independently distributed
    and uncorrelated. If the returned p-values are larger than 0.05, we cannot reject
    the null hypothesis, meaning that the residuals are uncorrelated, just like white
    noise.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ljung-Box测试使我们能够确定残差是否相关。零假设表明数据是独立分布且不相关的。如果返回的p值大于0.05，我们不能拒绝零假设，这意味着残差是不相关的，就像白噪声一样。
