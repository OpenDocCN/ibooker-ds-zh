- en: Chapter 2\. Working with Java data types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 使用 Java 数据类型
- en: '| Exam objectives covered in this chapter | What you need to know |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 本章涵盖的考试目标 | 你需要了解的内容 |'
- en: '| --- | --- |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [[2.2](#ch02lev1sec2)] Differentiate between object reference variables and
    primitive variables. | The primitive data types in Java, including scenarios when
    a particular primitive data type should or can’t be used. Similarities and differences
    between the primitive data types. Similarities and differences between primitive
    and object reference variables. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [[2.2](#ch02lev1sec2)] 区分对象引用变量和原始变量。 | Java 中的原始数据类型，包括何时应该或可以不使用特定原始数据类型的场景。原始数据类型之间的相似之处和不同之处。原始数据类型和对象引用变量之间的相似之处和不同之处。
    |'
- en: '| [[2.1](#ch02lev1sec1)] Declare and initialize variables (including casting
    of primitive data types). | Declaration and initialization of primitives and object
    reference variables. Literal values for primitive and object reference variables.
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [[2.1](#ch02lev1sec1)] 声明和初始化变量（包括原始数据类型的转换）。 | 原始数据类型和对象引用变量的声明和初始化。原始数据类型和对象引用变量的字面量值。
    |'
- en: '| [[2.5](#ch02lev1sec5)] Develop code that uses wrapper classes such as Boolean,
    Double, and Integer. | How and when values are boxed and unboxed when used with
    wrapper classes. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [[2.5](#ch02lev1sec5)] 开发使用包装类（如 Boolean、Double 和 Integer）的代码。 | 当与包装类一起使用时，值是如何装箱和拆箱的以及何时进行装箱和拆箱。
    |'
- en: '| [[3.1](kindle_split_014.html#ch03lev1sec1)] Use Java operators; including
    parentheses to override operator precedence. | Use of assignment, arithmetic,
    relational, and logical operators with primitives and object reference variables.
    Valid operands for an operator. Output of an arithmetic expression. Determine
    the equality of two primitives. How to override the default operator precedence
    by using parentheses. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [[3.1](kindle_split_014.html#ch03lev1sec1)] 使用 Java 运算符；包括括号来覆盖运算符优先级。 |
    使用赋值、算术、关系和逻辑运算符与原始数据类型和对象引用变量。运算符的有效操作数。算术表达式的输出。确定两个原始数据类型的相等性。如何通过使用括号来覆盖默认的运算符优先级。
    |'
- en: Imagine that you’ve just purchased a new home. You’ll likely need to buy different-sized
    containers to store different types of food items, because one size can’t fit
    all. Also, you might move around food items in your home—perhaps because of a
    change in the requirements over time (you wish to eat it or you wish to store
    it).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你刚刚购买了一套新房。你可能需要购买不同大小的容器来存储不同类型的食品，因为一个尺寸无法满足所有需求。此外，你也可能在家中移动食品——可能是因为随着时间的推移需求发生了变化（你希望食用它或你希望储存它）。
- en: Your new kitchen is an analogy for how Java stores its data using different
    data types, and manipulates the data using operators. The food items are like
    data types in Java, and the containers used to store the food are like variables
    in Java. The change in the requirements that triggers a change in the state of
    food items can be compared to the processing logic. The agents of change (fire,
    heat, or cooling) that change the state of the food items can be compared to Java
    operators. You need these agents of change so that you can process the raw food
    items to create delicacies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新厨房可以类比于 Java 如何使用不同的数据类型存储数据，并使用运算符来操作数据。食品项目就像 Java 中的数据类型，而用来存储食品的容器就像
    Java 中的变量。触发食品项目状态变化的条件变化可以与处理逻辑相提并论。改变食品项目状态的变化因素（如火、热或冷却）可以与 Java 运算符相提并论。你需要这些变化因素，以便你可以处理原始食品项目以制作佳肴。
- en: 'In the OCA Java SE 8 Programmer I exam, you’ll be asked questions on the various
    data types in Java, such as how to create and initialize them and what their similarities
    and differences are. The exam will also question you on using the Java operators.
    This chapter covers the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OCA Java SE 8 程序员 I 考试中，你将被问及 Java 中的各种数据类型，例如如何创建和初始化它们以及它们的相似之处和不同之处。考试还将询问你关于使用
    Java 运算符的问题。本章涵盖了以下内容：
- en: Primitive data types in Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中的原始数据类型
- en: Literal values of primitive Java data types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始 Java 数据类型的字面量值
- en: Object reference variables in Java
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中的对象引用变量
- en: Valid and invalid identifiers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的和无效的标识符
- en: Usage of Java operators
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 运算符的使用
- en: Modification of default operator precedence via parentheses
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过括号修改默认运算符优先级
- en: 2.1\. Primitive variables
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 原始变量
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[2.1](#ch02lev1sec1)] Declare and initialize variables (including casting
    of primitive data types)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.1](#ch02lev1sec1)] 声明和初始化变量（包括原始数据类型的转换）'
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[2.2](#ch02lev1sec2)] Differentiate between object reference variables and
    primitive variables'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.2](#ch02lev1sec2)] 区分对象引用变量和原始变量'
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, you’ll learn all the primitive data types in Java, their literal
    values, and the process of creating and initializing primitive variables. A variable
    defined as one of the primitive data types is a *primitive variable*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习Java中的所有原始数据类型、它们的字面值以及创建和初始化原始变量的过程。定义为原始数据类型之一的变量是*原始变量*。
- en: 'Primitive data types, as the name suggests, are the simplest data types in
    a programming language. In the Java language, they’re predefined. The names of
    the primitive types are quite descriptive of the values that they can store. Java
    defines the following eight primitive data types:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，原始数据类型是编程语言中最简单的数据类型。在Java语言中，它们是预定义的。原始数据类型的名称相当描述了它们可以存储的值。Java定义了以下八个原始数据类型：
- en: '`char`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`byte`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`short`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`int`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`long`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`float`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`double`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`boolean`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: Examine [figure 2.1](#ch02fig01) and try to match the given value with the corresponding
    type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图2.1([#ch02fig01](#ch02fig01))并尝试将给定的值与相应的类型匹配。
- en: Figure 2.1\. Matching a value with its corresponding type
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 将值与其对应类型匹配
- en: '![](02fig01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01.jpg)'
- en: This should be a simple exercise. [Table 2.1](#ch02table01) provides the answers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是一个简单的练习。[表2.1](#ch02table01)提供了答案。
- en: Table 2.1\. Matching a value with its corresponding data type
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. 将值与其对应的数据类型匹配
- en: '| Character values | Integer values | Decimal values | Boolean |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 字符值 | 整数值 | 小数值 | 布尔型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| a | 100 | 7.3 | true |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| a | 100 | 7.3 | true |'
- en: '|   | 4573 |   |   |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|   | 4573 |   |   |'
- en: 'In the preceding exercise, I categorized the data that you need to store as
    follows: character, integer, decimal, and Boolean values. This categorization
    will make your life simpler when confronted with selecting the most appropriate
    primitive data type to store a value. For example, to store an integer value,
    you need a primitive data type that’s capable of storing integer values; to store
    decimal numbers, you need a primitive data type that can store decimal numbers.
    Simple, isn’t it?'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我将您需要存储的数据分类如下：字符型、整型、小数型和布尔型值。这种分类将在您面对选择最合适的原始数据类型来存储值时使您的生活更加简单。例如，要存储整数值，您需要一个能够存储整数值的原始数据类型；要存储小数，您需要一个可以存储小数的原始数据类型。简单，不是吗？
- en: Let’s map the types of data that the primitive data types can store, because
    it’s always easy to group and remember information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们映射原始数据类型可以存储的数据类型，因为这总是很容易分组和记住信息。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The category *Boolean* is not the same as the primitive data type `boolean`
    or wrapper class `Boolean`. Java primitive data types and class names are displayed
    using code font.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔型类别与原始数据类型`boolean`或包装类`Boolean`不同。Java的原始数据类型和类名使用代码字体显示。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The primitive data types can be categorized as follows: Boolean, character,
    and numeric (further categorized as integral and floating-point) types. Take a
    look at this categorization in [figure 2.2](#ch02fig02).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型可以分为以下类别：布尔型、字符型和数值型（进一步分为整型和浮点型）类型。请查看[图2.2](#ch02fig02)中的分类。
- en: Figure 2.2\. Categorization of primitive data types
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 原始数据类型的分类
- en: '![](02fig02_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig02_alt.jpg)'
- en: As shown in [figure 2.2](#ch02fig02), the `char` primitive data type is an unsigned
    numeric data type. It can only store positive integers. The rest of the numeric
    data types (`byte`, `short`, `int`, `long`, `float`, and `double`) are signed
    numeric data types (they can store both negative and positive values). The categorization
    in [figure 2.2](#ch02fig02) will help you further associate each data type with
    the value that it can store. Let’s start with the Boolean category.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2.2](#ch02fig02)所示，`char`原始数据类型是一个无符号数值数据类型。它只能存储正整数。其余的数值数据类型（`byte`、`short`、`int`、`long`、`float`和`double`）是有符号数值数据类型（它们可以存储正负值）。[图2.2](#ch02fig02)中的分类将帮助您进一步将每个数据类型与其可以存储的值关联起来。让我们从布尔类别开始。
- en: '2.1.1\. Category: Boolean'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 类别：布尔型
- en: 'The Boolean category has only one data type: `boolean`. A `boolean` variable
    can store one of two values: `true` or `false`. It’s used in scenarios where only
    two states can exist. See [table 2.2](#ch02table02) for a list of questions and
    their probable answers.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔型类别只有一个数据类型：`boolean`。一个`boolean`变量可以存储两个值之一：`true`或`false`。它在只有两种状态可以存在的情况下使用。参见[表2.2](#ch02table02)以获取问题及其可能的答案。
- en: Table 2.2\. Suitable data that can be stored using a `boolean` data type
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.2\. 可以使用`boolean`数据类型存储的合适数据
- en: '| Question | Probable answers |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 可能的答案 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Did you purchase the exam voucher? | Yes/No |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 你是否购买了考试券？ | 是/否 |'
- en: '| Did you log in to your email account? | Yes/No |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 你今天登录过你的电子邮件账户吗？ | 是/否 |'
- en: '| Did you tweet about your passion today? | Yes/No |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 你今天是否发推文谈论你的热情？ | 是/否 |'
- en: '| Tax collected in financial year 2001–2002 | Good question! But it can’t be
    answered as yes/no. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 2001-2002财年征收的税款 | 好问题！但无法以是/否的形式回答。 |'
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: 'In this exam, the questions test your ability to select the best suitable data
    type for a condition that can only have two states: yes/no or true/false. The
    correct answer here is the `boolean` type.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次考试中，问题测试你选择最适合的数据类型的能力，该条件只能有两种状态：是/否或真/假。这里的正确答案是`boolean`类型。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here’s some code that defines `boolean` primitive variables:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些定义`boolean`原始变量的代码：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In some languages, such as JavaScript, you don’t need to define the type of
    a variable before you use it. In JavaScript, the compiler defines the type of
    the variable according to the value that you assign to it. Java, in contrast,
    is a strongly typed language. You must declare a variable and define its type
    before you can assign a value to it. [Figure 2.3](#ch02fig03) illustrates defining
    a `boolean` variable and assigning a value to it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，例如JavaScript，在使用变量之前不需要定义其类型。在JavaScript中，编译器根据你分配给变量的值来定义变量的类型。相比之下，Java是一种强类型语言。你必须声明一个变量并定义其类型，然后才能为其赋值。[图2.3](#ch02fig03)说明了定义一个`boolean`变量并为其赋值的过程。
- en: Figure 2.3\. Defining and assigning a primitive variable
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 定义和赋值原始变量
- en: '![](02fig03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig03.jpg)'
- en: Another point to note here is the value that’s assigned to a `boolean` variable.
    I used the literals `true` and `false` to initialize the `boolean` variables.
    A *literal* is a fixed value that doesn’t need further calculations in order for
    it to be assigned to any variable. `true` and `false` are the only two `boolean`
    literals.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的另一点是分配给`boolean`变量的值。我使用了字面值`true`和`false`来初始化`boolean`变量。*字面值*是一个固定值，不需要进一步计算就可以分配给任何变量。`true`和`false`是唯一的两个`boolean`字面值。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are only two `boolean` literal values: `true` and `false`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`类型只有两个字面值：`true`和`false`。'
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '2.1.2\. Category: signed numeric'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 类别：有符号数值
- en: 'The numeric category defines two subcategories: integers and floating point
    (also called decimals). Let’s start with the integers.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类别定义了两个子类别：整数和浮点数（也称为小数）。让我们从整数开始。
- en: 'Integers: byte, int, short, long'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数类型：byte, int, short, long
- en: When you can count a value in whole numbers, the result is an integer. It includes
    both negative and positive numbers. [Table 2.3](#ch02table03) lists probable scenarios
    in which the data can be stored as integers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以用整数计数一个值时，结果是整数。它包括负数和正数。[表2.3](#ch02table03)列出了数据可以存储为整数的一些可能场景。
- en: Table 2.3\. Data that can be categorized as numeric (nondecimal numbers) data
    type
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.3\. 可以归类为数值（非小数）数据类型的数据
- en: '| Situation | Can be stored as integers? |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 情况 | 是否可以存储为整数？ |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Number of friends on Facebook | Yes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Facebook上的朋友数量 | 是 |'
- en: '| Number of tweets posted today | Yes |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 今天发布的推文数量 | 是 |'
- en: '| Number of photographs uploaded for printing | Yes |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 今天上传用于打印的照片数量 | 是 |'
- en: '| Your body temperature | Not always |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 你的体温 | 不总是 |'
- en: 'You can use the `byte`, `short`, `int`, and `long` data types to store integer
    values. Wait a minute: why do you need so many types to store integers?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`byte`、`short`、`int`和`long`数据类型来存储整数值。等等：为什么你需要这么多类型来存储整数？
- en: 'Each one of these can store a different range of values. The benefits of the
    smaller ones are obvious: they need less space in memory and are faster to work
    with. [Table 2.4](#ch02table04) lists all these data types, along with their sizes
    and the ranges of the values that they can store.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个都可以存储不同范围的值。较小的类型的好处是明显的：它们在内存中需要的空间更少，并且处理速度更快。[表2.4](#ch02table04)列出了所有这些数据类型，以及它们的尺寸和它们可以存储的值的范围。
- en: Table 2.4\. Ranges of values stored by the signed numeric Java primitive data
    types
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.4\. 有符号数值Java原始数据类型存储的值范围
- en: '| Data type | Size | Range of values |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 大小 | 值范围 |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| byte | 8 bits | –128 to 127, inclusive |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| byte | 8位 | –128到127，包括 |'
- en: '| short | 16 bits | –32,768 to 32,767, inclusive |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| short | 16位 | –32,768到32,767，包括 |'
- en: '| int | 32 bits | –2,147,483,648 to 2,147,483,647, inclusive |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| int | 32位 | –2,147,483,648到2,147,483,647，包括 |'
- en: '| long | 64 bits | –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807,
    inclusive |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| long | 64位 | –9,223,372,036,854,775,808到9,223,372,036,854,775,807，包括 |'
- en: The OCA Java SE 8 Programmer I exam may ask you questions about the range of
    integers that can be assigned to a `byte` data type, but it won’t include questions
    on the ranges of integer values that can be stored by `short`, `int`, or `long`
    data types. Don’t worry—you don’t have to memorize the ranges for all these data
    types!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8 程序员I考试可能会问你关于可以分配给 `byte` 数据类型的整数范围的问题，但不会包括关于可以存储在 `short`、`int`
    或 `long` 数据类型中的整数值范围的问题。不用担心——你不需要记住所有这些数据类型的范围！
- en: 'Here’s some code that assigns literal values to primitive numeric variables
    within their acceptable ranges:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码示例，将字面值分配给原始数值变量，这些变量在其可接受范围内：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The default type of a nondecimal number is `int`. To designate an integer literal
    value as a `long` value, add the suffix `L` or `l` (`L` in lowercase), as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 非十进制数字的默认类型是 `int`。要将整数字面值指定为 `long` 值，请添加后缀 `L` 或 `l`（小写的 `L`），如下所示：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Integer literal values come in four flavors: binary, decimal, octal, and hexadecimal:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面值有四种类型：二进制、十进制、八进制和十六进制：
- en: '***Binary number system—*** A base-2 system, which uses only 2 digits, 0 and
    1.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***二进制数制—*** 一个基数为2的系统，它只使用两个数字，0和1。'
- en: '***Octal number system—*** A base-8 system, which uses digits 0 through 7 (a
    total of 8 digits). Here the decimal number 8 is represented as octal 10, decimal
    9 as 11, and so on.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***八进制数制—*** 一个基数为8的系统，它使用数字0到7（总共8个数字）。在这里，十进制数字8表示为八进制10，十进制数字9表示为11，依此类推。'
- en: '***Decimal number system—*** The base-10 number system that you use every day.
    It’s based on 10 digits, from 0 through 9 (a total of 10 digits).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***十进制数制—*** 你每天使用的基数为10的数制。它基于10个数字，从0到9（总共10个数字）。'
- en: '***Hexadecimal number system—*** A base-16 system, which uses digits 0 through
    9 and the letters A through F (a total of 16 digits and letters). Here the number
    10 is represented as A or a, 11 as B or b, 12 as C or c, 13 as D or d, 14 as E
    or e, and 15 as F or f.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***十六进制数制—*** 一个基数为16的系统，它使用数字0到9和字母A到F（总共16个数字和字母）。在这里，数字10表示为A或a，11表示为B或b，12表示为C或c，13表示为D或d，14表示为E或e，15表示为F或f。'
- en: Let’s take quick look at how you can convert integers in the decimal number
    system to the other number systems. [Figures 2.4](#ch02fig04), [2.5](#ch02fig05),
    and [2.6](#ch02fig06) show how to convert the decimal number 267 to the octal,
    hexadecimal, and binary number systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何将十进制数制中的整数转换为其他数制。图[2.4](#ch02fig04)、[2.5](#ch02fig05)和[2.6](#ch02fig06)展示了如何将十进制数267转换为八进制、十六进制和二进制数制。
- en: Figure 2.4\. Converting an integer from decimal to octal
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 将十进制整数转换为八进制
- en: '![](02fig04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig04.jpg)'
- en: Figure 2.5\. Converting an integer from decimal to hexadecimal
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 将十进制整数转换为十六进制
- en: '![](02fig05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig05.jpg)'
- en: Figure 2.6\. Converting an integer from decimal to binary
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. 将十进制整数转换为二进制
- en: '![](02fig06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig06.jpg)'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: In the exam, you won’t be asked to convert a number from the decimal number
    system to the octal and hexadecimal number systems and vice versa. But you can
    expect questions that ask you to select valid literals for integers. The [figures
    2.4](#ch02fig04)–[2.6](#ch02fig06) will help you understand these number systems
    better and retain this information longer, which will in turn enable you to answer
    questions correctly during the exam.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，你不会要求将数字从十进制数制转换为八进制和十六进制数制，反之亦然。但你可以期待一些问题，这些问题要求你选择有效的整数字面值。图[2.4](#ch02fig04)–[2.6](#ch02fig06)将帮助你更好地理解这些数制，并更长时间地保留这些信息，这反过来又使你能够在考试中正确回答问题。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can assign integer literals in base decimal, binary, octal, and hexadecimal.
    For octal literals, use the prefix `0`; for binary, use the prefix `0B` or `0b`;
    and for hexadecimal, use the prefix `0X` or `0x`. Here’s an example of each of
    these:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用十进制、二进制、八进制和十六进制来分配整数字面值。对于八进制字面值，使用前缀 `0`；对于二进制，使用前缀 `0B` 或 `0b`；对于十六进制，使用前缀
    `0X` 或 `0x`。以下是一个每个前缀的示例：
- en: '![](098fig01_alt.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](098fig01_alt.jpg)'
- en: 'Java 7 introduced the use of underscores as part of the literal values. Grouping
    individual digits or letters of literal values makes them more readable. The underscores
    have no effect on the values. The following is valid code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 引入了将下划线用作字面值一部分的使用。将字面值的单个数字或字母分组可以使它们更易于阅读。下划线对值没有影响。以下是一个有效的代码示例：
- en: '![](099fig01_alt.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](099fig01_alt.jpg)'
- en: Rules to remember
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要记住的规则
- en: 'Here’s a quick list of rules for usage of underscores in the numeric literal
    values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一份关于在数值字面值中使用下划线的规则快速列表：
- en: You can place an underscore right after the prefix `0`, which is used to define
    an octal literal value.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在前缀 `0` 后面直接放置一个下划线，用于定义八进制字面值。
- en: You can’t start or end a literal value with an underscore.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能以下划线开始或结束一个字面值。
- en: You can’t place an underscore right after the prefixes `0b`, `0B`, `0x`, and
    `0X`, which are used to define binary and hexadecimal literal values.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在用于定义二进制和十六进制字面值的前缀 `0b`、`0B`、`0x` 和 `0X` 后面直接放置下划线。
- en: You can’t place an underscore prior to an `L` suffix (the `L` suffix is used
    to mark a literal value as `long`).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在 `L` 后缀（用于标记字面值为 `long`）之前放置下划线。
- en: You can’t use an underscore in positions where a string of digits is expected
    (see the following example).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在期望一串数字的位置使用下划线（见以下示例）。
- en: 'Because you’re likely to be questioned on valid and invalid uses of underscores
    in literal values on the exam, let’s look at some invalid examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在考试中可能会被问到字面值中下划线的有效和无效使用，让我们看看一些无效的例子：
- en: '![](099fig02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片 099fig02](099fig02.jpg)'
- en: 'The following line of code will compile successfully but will fail at runtime:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将成功编译但在运行时失败：
- en: '![](099fig03_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片 099fig03_alt](099fig03_alt.jpg)'
- en: Because a `String` value can accept underscores, the compiler will compile the
    previous code. But the runtime will throw an exception stating that an invalid
    format of value was passed to the method `parseInt`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `String` 值可以接受下划线，编译器会编译之前的代码。但运行时会抛出一个异常，指出传递给 `parseInt` 方法的值格式无效。
- en: Here’s the first Twist in the Tale exercise of this chapter for you to attempt.
    It uses multiple combinations of underscores in numeric literal values. See if
    you can get all of them right (answers in the appendix).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章的第一个故事转折练习，供你尝试。它使用了数值字面值中多个下划线的组合。看看你是否能全部答对（答案在附录中）。
- en: Twist in the Tale 2.1
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 2.1
- en: 'Let’s use the primitive variables `baseDecimal`, `octVal`, `hexVal`, and `binVal`
    defined earlier in this section and introduce additional code for printing the
    values of all these variables. Determine the output of the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用本节中定义的原始变量 `baseDecimal`、`octVal`、`hexVal` 和 `binVal`，并引入额外的代码来打印所有这些变量的值。确定以下代码的输出：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s another quick exercise—let’s define and initialize some `long` primitive
    variables that use underscores in the literal values assigned to them. Determine
    which of these does this job correctly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速练习——让我们定义和初始化一些使用下划线作为它们赋值中字面值的前缀的 `long` 原始变量。确定以下哪个正确地完成了这项工作：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Floating-point numbers: float and double'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 浮点数：float 和 double
- en: You need floating-point numbers where you expect decimal numbers. For example,
    can you define the probability of an event occurring as an integer? [Table 2.5](#ch02table05)
    lists probable scenarios in which the corresponding data is stored as a floating-point
    number.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你期望十进制数时，你需要使用浮点数。例如，你能将事件发生的概率定义为整数吗？[表 2.5](#ch02table05) 列出了可能场景，其中对应的数据存储为浮点数。
- en: Table 2.5\. Data that’s stored as floating-point numbers
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.5\. 存储为浮点数的数值
- en: '| Situation | Is the answer a floating-point number? |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 情况 | 答案是一个浮点数吗？ |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Orbital mechanics of a spacecraft | Yes (very precise values are required)
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 航天器的轨道力学 | 是（需要非常精确的值） |'
- en: '| Probability of your friend request being accepted | Yes; probability is between
    0.0 (none) and 1.0 (sure) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 你朋友请求被接受的概率 | 是；概率介于 0.0（无）和 1.0（确定）之间 |'
- en: '| Speed of Earth revolving around the sun | Yes |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 地球围绕太阳旋转的速度 | 是 |'
- en: '| Magnitude of an earthquake on the Richter scale | Yes |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 里氏震级地震的震级 | 是 |'
- en: In Java, you can use the `float` and `double` primitive data types to store
    decimal numbers. `float` requires less space than `double`, but it can store a
    smaller range of values than `double`. `float` is less precise than `double`.
    `float` can’t represent accurately some numbers even if they’re in range. The
    same limitation applies to `double`—even if it’s a data type that offer more precision.
    [Table 2.6](#ch02table06) lists the sizes and ranges of values for `float` and
    `double`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你可以使用 `float` 和 `double` 原始数据类型来存储十进制数。`float` 比较节省空间，但可以存储的值范围比 `double`
    小。`float` 的精度低于 `double`。即使数值在范围内，`float` 也可能无法准确表示某些数值。同样的限制也适用于 `double`——即使它是一个提供更多精度的数据类型。[表
    2.6](#ch02table06) 列出了 `float` 和 `double` 的值大小和范围。
- en: Table 2.6\. Range of values for decimal numbers
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.6\. 十进制数字的值范围
- en: '| Data type | Size | Range of values |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 大小 | 值范围 |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| float | 32 bits | +/–1.4E–45 to +/–3.4028235E+38, +/–infinity, +/–0, NaN
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| float | 32位 | +/–1.4E–45到+/–3.4028235E+38，+/–infinity，+/–0，NaN |'
- en: '| double | 64 bits | +/–4.9E–324 to +/–1.7976931348623157E+308, +/–infinity,
    +/–0, NaN |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| double | 64位 | +/–4.9E–324到+/–1.7976931348623157E+308，+/–infinity，+/–0，NaN
    |'
- en: 'Here’s some code in action:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些实际运行的代码示例：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Did you notice the use of the suffixes `F` and `f` while initializing the variables
    `average` and `orbit` in the preceding code? The default type of a decimal literal
    is `double`, but by suffixing a decimal literal value with `F` or `f`, you tell
    the compiler that the literal value should be treated like a `float` and not a
    `double`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到在前面代码中初始化变量`average`和`orbit`时使用了后缀`F`和`f`吗？十进制字面量的默认类型是`double`，但通过在十进制字面量值后附加`F`或`f`后缀，你告诉编译器该字面量值应被当作`float`处理，而不是`double`。
- en: 'You can also assign a literal decimal value in scientific notation as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按照以下方式将字面量十进制值分配为科学记数法：
- en: '![](101fig01_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](101fig01_alt.jpg)'
- en: 'You can also add the suffix `D` or `d` to a decimal number value to specify
    that it’s a `double` value. Because the default type of a decimal number is `double`,
    the use of the suffix `D` or `d` is redundant. Examine the following line of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将后缀`D`或`d`添加到十进制数值中，以指定它是`double`值。因为十进制数的默认类型是`double`，所以使用后缀`D`或`d`是多余的。检查以下代码行：
- en: '![](101fig02_alt.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](101fig02_alt.jpg)'
- en: 'Starting with Java version 7, you can also use underscores with the floating-point
    literal values. The rules are generally the same as previously mentioned for numeric
    literal values; the following rules are specific to floating-point literals:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 7版本开始，你也可以在浮点字面量值中使用下划线。规则通常与之前提到的数值字面量规则相同；以下规则是针对浮点字面量特定的：
- en: You can’t place an underscore prior to a `D`, `d`, `F`, or `f` suffix (these
    suffixes are used to mark a floating-point literal as `double` or `float`).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在下划线之前放置`D`、`d`、`F`或`f`后缀（这些后缀用于标记浮点字面量为`double`或`float`）。
- en: You can’t place an underscore adjacent to a decimal point.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能在十进制点旁边放置下划线。
- en: 'Let’s look at some examples that demonstrate the invalid use of underscores
    in floating-point literal values:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例，这些示例展示了在浮点字面量值中无效使用下划线的情况：
- en: '![](101fig03_alt.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](101fig03_alt.jpg)'
- en: '2.1.3\. Category: character (unsigned integer)'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 类别：字符（无符号整数）
- en: 'The character category defines only one data type: `char`. A `char` is an unsigned
    integer. It can store a single 16-bit Unicode character; that is, it can store
    characters from virtually all the existing scripts and languages, including Japanese,
    Korean, Chinese, Devanagari, French, German, and Spanish. Because your keyboard
    may not have keys to represent all these characters, you can use a value from
    `\u0000` (or `0`) to a maximum value of `\uffff` (or `65,535`) inclusive. The
    following code shows the assignment of a value to a `char` variable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类别定义了唯一的数据类型：`char`。`char`是一个无符号整数。它可以存储单个16位Unicode字符；也就是说，它可以存储几乎所有现有脚本和语言中的字符，包括日语、韩语、中文、德文、法语、德语和西班牙语。因为你的键盘可能没有键来表示所有这些字符，你可以使用`\u0000`（或`0`）的值到最大值`\uffff`（或`65,535`）的值。以下代码显示了将值分配给`char`变量的示例：
- en: '![](102fig01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](102fig01.jpg)'
- en: A very common mistake is using double quotes to assign a value to a `char`.
    The correct option is single quotes. [Figure 2.7](#ch02fig07) shows a conversation
    between two (hypothetical) programmers, Paul and Harry.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的错误是使用双引号将值分配给`char`。正确的选项是单引号。[图2.7](#ch02fig07)显示了两个（假设的）程序员保罗和哈里的对话。
- en: Figure 2.7\. Never use double quotes to assign a letter as a `char` value.
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 永远不要使用双引号来分配一个字母作为`char`值。
- en: '![](02fig07_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig07_alt.jpg)'
- en: 'What happens if you try to assign a `char` using double quotes? The code will
    fail to compile, with this message:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试使用双引号分配一个`char`，代码将无法编译，并显示以下信息：
- en: '[PRE6]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Never use double quotes to assign a letter to a `char` variable. Double quotes
    are used to assign a value to a variable of type `String`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用双引号将字母分配给`char`变量。双引号用于将值分配给类型为`String`的变量。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Internally, Java stores `char` data as an unsigned integer value (positive
    integer). It’s therefore acceptable to assign a positive integer value to a `char`,
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Java将`char`数据存储为无符号整数值（正整数）。因此，将正整数值分配给`char`是可以接受的，如下所示：
- en: '![](102fig02.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](102fig02.jpg)'
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The exam will test you on multiple (obscure) techniques like assigning an unsigned
    integer value to a `char` data type. But I don’t recommend using these on real
    projects. Please write code that’s readable and easy to maintain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考试将测试你对多种（隐晦的）技术，例如将无符号整数值分配给 `char` 数据类型。但我不建议在实际项目中使用这些技术。请编写可读性和易于维护的代码。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The integer value `122` is equivalent to the letter `z`, but the integer value
    `122` is not equal to the Unicode value `\u0122`. The former is a number in base
    10 (uses digits 0–9) and the latter is a number in base 16 (uses digits 0–9 and
    letters a–f—lower- or uppercase). `\u` is used to mark the value as a Unicode
    value. You must use quotes to assign Unicode values to `char` variables. Here’s
    an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 整数值 `122` 等价于字母 `z`，但整数值 `122` 不等于 Unicode 值 `\u0122`。前者是十进制数（使用数字 0-9），后者是十六进制数（使用数字
    0-9 和字母 a-f——大小写均可）。`\u` 用于标记值作为 Unicode 值。你必须使用引号将 Unicode 值分配给 `char` 变量。以下是一个示例：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Figure 2.8](#ch02fig08) shows the output of the preceding code on a system
    that supports Unicode characters.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.8](#ch02fig08) 展示了在支持 Unicode 字符的系统上运行前面代码的输出。'
- en: Figure 2.8\. The output of assigning a character using the integer value `122`
    versus the Unicode value `\u0122`
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.8\. 使用整数值 `122` 与 Unicode 值 `\u0122` 分配字符的输出
- en: '![](02fig08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig08.jpg)'
- en: 'As mentioned earlier, `char` values are unsigned integer values, so if you
    try to assign a negative number to one, the code won’t compile. Here’s an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`char` 值是无符号整数值，因此如果你尝试将负数分配给一个 `char`，代码将无法编译。以下是一个示例：
- en: '![](103fig01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](103fig01.jpg)'
- en: 'But you can forcefully assign a negative number to a `char` type by casting
    it to `char`, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以通过强制转换为 `char` 类型来给 `char` 类型分配一个负数，如下所示：
- en: '![](103fig02_alt.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](103fig02_alt.jpg)'
- en: In the previous code, note how the literal value `–122` is prefixed by `(char)`.
    This practice is called *casting*. Casting is the forceful conversion of one data
    type to another data type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意字面值 `–122` 前面有 `(char)` 前缀。这种做法称为 *类型转换*。类型转换是将一种数据类型强制转换为另一种数据类型。
- en: You can cast only compatible data types. For example, you can cast a `char`
    to an `int` and vice versa. But you can’t cast an `int` to a `boolean` value or
    vice versa. When you cast a bigger value to a data type that has a smaller range,
    you tell the compiler that you know what you’re doing, so the compiler proceeds
    by chopping off any extra bits that may not fit into the smaller variable. Use
    casting with caution—it may not always give you the correct converted values.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能转换兼容的数据类型。例如，你可以将 `char` 转换为 `int`，反之亦然。但你不能将 `int` 转换为 `boolean` 值或反之亦然。当你将更大的值转换为范围较小的数据类型时，你告诉编译器你知道自己在做什么，因此编译器会通过截断任何可能不适合较小变量的额外位来继续操作。谨慎使用类型转换——它可能不会总是给出正确的转换值。
- en: '[Figure 2.9](#ch02fig09) shows the output of the preceding code that cast a
    value to `c3` (the value looks weird!).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.9](#ch02fig09) 展示了将值转换为 `c3`（值看起来很奇怪！）的前面代码的输出。'
- en: Figure 2.9\. The output of assigning a negative value to a character variable
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.9\. 分配字符变量负值的输出
- en: '![](02fig09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig09.jpg)'
- en: The `char` data type in Java doesn’t allocate space to store the sign of an
    integer. If you try to forcefully assign a negative integer to `char`, the sign
    bit is stored as the part of the integer value, which results in the storage of
    unexpected values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的 `char` 数据类型不分配空间来存储整数的符号。如果你尝试强制将负整数分配给 `char`，符号位将存储为整数值的一部分，这会导致存储意外的值。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The exam will test your understanding of the possible values that can be assigned
    to a variable of type `char`, including whether an assignment will result in a
    compilation error. Don’t worry—it won’t test you on the value that’s actually
    displayed after assigning arbitrary integer values to a `char`!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 考试将测试你对 `char` 类型变量可能分配的值的理解，包括分配是否会导致编译错误。不用担心——它不会测试你在将任意整数值分配给 `char` 后实际显示的值！
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.1.4\. Confusion with the names of the primitive data types
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.4\. 对原始数据类型名称的混淆
- en: 'If you’ve previously worked in another programming language, there’s a good
    chance that you might get confused with the names of the primitive data types
    in Java and other languages. For example, C defines a primitive `short int` data
    type. But `short` and `int` are two separate primitive data types in Java. The
    OCA Java SE 8 Programmer I exam will test you on your ability to recognize the
    names of the primitive data types, and the answers to these questions may not
    be immediately obvious. An example follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在其他编程语言中工作过，你可能会对 Java 和其他语言中的基本数据类型名称感到困惑。例如，C 定义了一个原始的 `short int` 数据类型。但在
    Java 中，`short` 和 `int` 是两个不同的原始数据类型。OCA Java SE 8 程序员 I 考试将测试你识别原始数据类型名称的能力，这些问题答案可能不会立即明显。以下是一个例子：
- en: 'Question: What is the output of the following code?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：以下代码的输出是什么？
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It prints 7 once.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打印 7 一次。
- en: It prints nothing.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它什么也不打印。
- en: Compilation error.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误。
- en: Runtime error.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时错误。
- en: The correct answer is (c). This question tries to trick you with complex code
    that doesn’t use any `if` constructs or `do`-`while` loops! As you can see, it
    uses an incorrect data type name, `bool`, to declare and initialize the variable
    `result`. Therefore, the code will fail to compile.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 (c)。这个问题试图通过不使用任何 `if` 构造或 `do`-`while` 循环的复杂代码来欺骗你！正如你所看到的，它使用了一个不正确的数据类型名称
    `bool` 来声明和初始化变量 `result`。因此，代码将无法编译。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for questions that use incorrect names for the primitive data types.
    For example, there isn’t any `bool` primitive data type in Java. The correct data
    type is `boolean`. If you’ve worked with other programming languages, you might
    get confused trying to remember the exact names of all the primitive data types
    used in Java. Remember that just two of the primitive data types—`int` and `char`—are
    shortened; the rest of the primitive data types (`byte`, `short`, `long`, `float`,
    and `double`) are not.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些使用不正确的基本数据类型名称的问题。例如，Java 中没有 `bool` 基本数据类型。正确的数据类型是 `boolean`。如果你在其他编程语言中工作过，你可能会在尝试记住
    Java 中使用的所有基本数据类型的确切名称时感到困惑。记住，只有两种基本数据类型——`int` 和 `char`——被缩短；其余的基本数据类型（`byte`、`short`、`long`、`float`
    和 `double`）没有被缩短。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.2\. Identifiers
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 标识符
- en: 'Identifiers are names of packages, classes, interfaces, methods, and variables.
    Though identifying a valid identifier is not explicitly included in the exam objectives,
    there’s a good chance that you’ll encounter a question similar to the following
    that will require you to identify valid and invalid identifiers:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是包、类、接口、方法和变量的名称。虽然识别有效的标识符并没有明确包含在考试目标中，但你可能会遇到类似以下的问题，这些问题将要求你识别有效的和无效的标识符：
- en: 'Question: Which of the following lines of code will compile successfully?'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：以下哪一行代码可以成功编译？
- en: '`byte exam_total = 7;`'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`byte exam_total = 7;`'
- en: '`int exam-Total = 1090;`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int exam-Total = 1090;`'
- en: The correct answer is (a). Option (b) is incorrect because hyphens aren’t allowed
    in the name of a Java identifier. Underscores are allowed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 (a)。选项 (b) 是错误的，因为在 Java 标识符的名称中不允许使用连字符。下划线是允许的。
- en: 2.2.1\. Valid and invalid identifiers
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 有效的和无效的标识符
- en: '[Table 2.7](#ch02table07) contains a list of rules that will enable you to
    correctly define valid (and invalid) identifiers, along with some examples.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2.7](#ch02table07) 包含了一组规则，这些规则将帮助你正确地定义有效的（以及无效的）标识符，以及一些示例。'
- en: Table 2.7\. Ingredients of valid and invalid identifiers
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.7\. 有效的和无效标识符的成分
- en: '| Properties of valid identifiers | Properties of invalid identifiers |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 有效的标识符的特性 | 无效的标识符的特性 |'
- en: '| --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Unlimited length | Same spelling as a Java reserved word or keyword (see
    [table 2.8](#ch02table08)) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 无限制长度 | 与 Java 保留字或关键字拼写相同（见 [表 2.8](#ch02table08)） |'
- en: '| Starts with a letter (a–z, upper- or lowercase), a currency sign, or an underscore
    | Uses special characters: !, @, #, %, ^, &, *, (, ), '', :, ;, [, /, \, } |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 以字母（a–z，大写或小写）、货币符号或下划线开头 | 使用特殊字符：!、@、#、%、^、&、*、(、)、''、:、;、[、/、\、} |'
- en: '| Can use a digit (not at the starting position) | Starts with a Java digit
    (0–9) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 可以使用数字（但不能位于起始位置） | 以 Java 数字（0–9）开头 |'
- en: '| Can use an underscore (at any position) |   |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 可以使用下划线（在任何位置） |   |'
- en: '| Can use a currency sign (at any position): ¤, $, £, ¢, ¥, and others |  
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 可以使用货币符号（在任何位置）：¥、$、£、¢、¥ 和其他 |   |'
- en: '| **Examples of valid identifiers** | **Examples of invalid identifiers** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 有效的标识符的例子 | 无效的标识符的例子 |'
- en: '| customerValueObject | 7world (identifier can’t start with a digit) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| customerValueObject | 7world (标识符不能以数字开头) |'
- en: '| $rate, £Value, _sine | %value (identifier can’t use special char %) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| $rate, £Value, _sine | %value (标识符不能使用特殊字符%) |'
- en: '| happy2Help, nullValue | Digital!, books@manning (identifier can’t use special
    char ! or @) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| happy2Help, nullValue | Digital!, books@manning (标识符不能使用特殊字符!或@) |'
- en: '| Constant | null, true, false, goto (identifier can’t have the same name as
    a Java keyword or reserved word) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | null, true, false, goto (标识符不能与Java关键字或保留词同名) |'
- en: You can’t define a variable with the same name as Java keywords or reserved
    words. As these names suggest, they’re reserved for specific purposes. [Table
    2.8](#ch02table08) lists Java keywords, reserved words, and literals that you
    can’t use as identifier names.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能定义与Java关键字或保留词相同的变量名。正如这些名称所暗示的，它们是为特定目的保留的。[表2.8](#ch02table08)列出了不能用作Java变量名的Java关键字、保留词和字面量。
- en: Table 2.8\. Java keywords and reserved words that can’t be used as names for
    Java variables
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.8\. 不能用作Java变量名的Java关键字和保留词
- en: '| abstract | default | goto | package | this |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| abstract | default | goto | package | this |'
- en: '| assert | do | if | private | throw |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| assert | do | if | private | throw |'
- en: '| boolean | double | implements | protected | throws |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| boolean | double | implements | protected | throws |'
- en: '| break | else | import | public | transient |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| break | else | import | public | transient |'
- en: '| byte | enum | instanceof | return | true |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| byte | enum | instanceof | return | true |'
- en: '| case | extends | int | short | try |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| case | extends | int | short | try |'
- en: '| catch | false | interface | static | void |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| catch | false | interface | static | void |'
- en: '| char | final | long | strictfp | volatile |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| char | final | long | strictfp | volatile |'
- en: '| class | finally | native | super | while |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| class | finally | native | super | while |'
- en: '| const | float | new | switch |   |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| const | float | new | switch |   |'
- en: '| continue | for | null | synchronized |   |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| continue | for | null | synchronized |   |'
- en: 'Let’s combat some of the common mistakes when determining correct and incorrect
    variables using the following variable declarations:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下变量声明来对抗确定正确和错误变量时的一些常见错误：
- en: '![](106fig01_alt.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](106fig01_alt.jpg)'
- en: Next, let’s look at the object reference variables and how they differ from
    the primitive variables.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看对象引用变量以及它们与原始变量的区别。
- en: 2.3\. Object reference variables
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 对象引用变量
- en: '|  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[2.1](#ch02lev1sec1)] Declare and initialize variables (including casting
    of primitive data types)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.1](#ch02lev1sec1)] 声明和初始化变量（包括原始数据类型的转换）'
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[2.2](#ch02lev1sec2)] Differentiate between object reference variables and
    primitive variables'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.2](#ch02lev1sec2)] 区分对象引用变量和原始变量'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The variables in Java can be categorized into two types: *primitive variables*
    and *reference variables*. In this section, along with a quick introduction to
    reference variables, we’ll cover the basic differences between reference variables
    and primitive variables.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的变量可以分为两种类型：*原始变量*和*引用变量*。在本节中，除了对引用变量进行简要介绍外，我们还将介绍引用变量和原始变量之间的基本区别。
- en: Reference variables are also known as *object reference variables* or *object
    references*. I use these terms interchangeably in this text.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量也被称为*对象引用变量*或*对象引用*。我在本文中使用这些术语是通用的。
- en: 2.3.1\. What are object reference variables?
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 什么是对象引用变量？
- en: Objects are instances of classes, including both predefined and user-defined
    classes. For a reference type in Java, the variable name evaluates to the address
    of the location in memory where the object referenced by the variable is stored.
    An object reference is, in fact, a memory address that points to a memory area
    where an object’s data is located.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是类的实例，包括预定义和用户定义的类。对于Java中的引用类型，变量名计算出的值是存储在内存中变量引用的对象的地址。实际上，对象引用是一个内存地址，它指向存储对象数据的内存区域。
- en: 'Let’s quickly define a barebones class, `Person`, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速定义一个基本的类，`Person`，如下所示：
- en: '[PRE9]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When an object is instantiated with the `new` operator, a memory address value
    to that object is returned. That address is usually assigned to the reference
    variable. [Figure 2.10](#ch02fig10) shows a line of code that creates a reference
    variable `person` of type `Person` and assigns an object to it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`new`运算符实例化对象时，会返回该对象的内存地址值。这个地址通常被分配给引用变量。[图2.10](#ch02fig10)显示了创建类型为`Person`的引用变量`person`并将其赋值的代码行。
- en: Figure 2.10\. The creation and assignment of a reference variable
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10\. 引用变量的创建和赋值
- en: '![](02fig10.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig10.jpg)'
- en: 'When the statement shown in [figure 2.10](#ch02fig10) executes, three things
    happen:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行图2.10所示的语句时，会发生三件事：
- en: A new `Person` object is created.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新的`Person`对象。
- en: A variable named `person` is created in the stack with an empty (`null`) value.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈中创建了一个名为`person`的变量，其值为空（`null`）。
- en: The variable `person` is assigned the memory address value where the object
    is located.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`person`被分配到对象所在内存地址的值。
- en: '[Figure 2.11](#ch02fig11) contains an illustration of a reference variable
    and the object it refers to in memory.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.11](#ch02fig11)包含了一个引用变量及其在内存中所引用的对象的插图。'
- en: Figure 2.11\. An object reference variable and the referenced object in memory
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.11. 内存中一个引用变量及其所引用的对象
- en: '![](02fig11_alt.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig11_alt.jpg)'
- en: 'You can think of an object reference variable as a *handle* to an object that
    allows you access to that object’s attributes. The following analogy will help
    you understand object reference variables, the objects that they refer to, and
    their relationship. Think of objects as analogous to *dogs*, and think of object
    references as analogous to *leashes*. Although this analogy won’t bear too much
    analysis, the following comparisons are valid:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将对象引用变量视为访问对象属性的*把手*。以下类比将帮助您理解对象引用变量、它们所引用的对象以及它们之间的关系。将对象类比为*狗*，将对象引用类比为*皮带*。尽管这个类比可能不会深入分析，以下比较是有效的：
- en: A leash not attached to a dog is a reference object variable with a `null` value.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未系在狗上的皮带是一个具有`null`值的引用对象变量。
- en: A dog without a leash is a Java object that’s not referred to by any object
    reference variable.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有皮带的狗是一个没有任何对象引用变量引用的Java对象。
- en: Just as an unleashed dog might be picked up by animal control, an object that
    isn’t referred to by a reference variable is liable to be garbage collected (removed
    from memory by the JVM).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如一只未拴绳的狗可能会被动物控制部门带走一样，没有被引用变量引用的对象可能会被垃圾回收（由JVM从内存中移除）。
- en: Several leashes may be tethered to a single dog. Similarly, a Java object may
    be referenced by multiple object reference variables.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几条皮带可能系在一只狗上。同样，Java对象可能被多个对象引用变量引用。
- en: '[Figure 2.12](#ch02fig12) illustrates this analogy.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.12](#ch02fig12)展示了这个类比。'
- en: Figure 2.12\. Dog leash analogy for understanding objects
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12. 理解对象的狗皮带类比
- en: '![](02fig12_alt.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig12_alt.jpg)'
- en: 'The default value of all types of object reference variables is `null`. You
    can also assign a `null` value to a reference variable explicitly. Here’s an example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的对象引用变量的默认值都是`null`。您也可以显式地将`null`值赋给引用变量。以下是一个示例：
- en: '[PRE10]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the reference variable `person` can be compared to a leash without
    a dog.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，引用变量`person`可以比作没有狗的皮带。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The literal value for all types of object reference variables is `null`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的对象引用变量的字面值都是`null`。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.3.2\. Differentiating between object reference variables and primitive variables
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2. 区分对象引用变量和原始变量
- en: Just as men and women are fundamentally different (according to John Gray, author
    of *Men Are from Mars, Women Are from Venus*), primitive variables and object
    reference variables differ from each other in multiple ways. The basic difference
    is that primitive variables store the actual values, whereas reference variables
    store the addresses of the objects they refer to.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如约翰·格雷（John Gray，《火星人来自火星，金星人来自金星》一书的作者）所说，男人和女人在本质上是有区别的，原始变量和对象引用变量在多个方面也有区别。基本区别是原始变量存储实际值，而引用变量存储它们所引用的对象的地址。
- en: Let’s assume that a class `Person` is already defined. If you create an `int`
    variable `a` and an object reference variable `person`, they will store their
    values in memory, as shown in [figure 2.13](#ch02fig13).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已经定义了一个`Person`类。如果您创建一个`int`变量`a`和一个对象引用变量`person`，它们将在内存中存储它们的值，如图2.13所示。
- en: '[PRE11]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 2.13\. Primitive variables store the actual values, whereas object reference
    variables store the addresses of the objects they refer to.
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.13. 原始变量存储实际值，而对象引用变量存储它们所引用的对象的地址。
- en: '![](02fig13_alt.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig13_alt.jpg)'
- en: Other important differences between primitive variables and object reference
    variables are shown in [figure 2.14](#ch02fig14) as a conversation between a girl
    and a boy. The girl represents an object reference variable and the boy represents
    a primitive variable. (Don’t worry if you don’t understand all of these analogies.
    They’ll make much more sense after you read related topics in later chapters.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 原始变量和对象引用变量之间的重要差异如图2.14所示，即一个女孩和一个男孩之间的对话。女孩代表对象引用变量，男孩代表原始变量。（如果你不理解所有这些类比，不要担心。在阅读后续章节的相关主题后，它们会更有意义。）
- en: In the next section, you’ll start manipulating these variables using operators.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将开始使用运算符操作这些变量。
- en: Figure 2.14\. Differences between object reference variables and primitive variables
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.14\. 对象引用变量和原始变量之间的差异
- en: '![](02fig14_alt.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig14_alt.jpg)'
- en: 2.4\. Operators
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 运算符
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[3.1](kindle_split_014.html#ch03lev1sec1)] Use Java operators; including parentheses
    to override operator precedence'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3.1](kindle_split_014.html#ch03lev1sec1)] 使用Java运算符；包括括号以覆盖运算符优先级'
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, you’ll use different types of operators—assignment, arithmetic,
    relational, and logical—to manipulate the values of variables. You’ll write code
    to determine the equality of two primitive data types. You’ll also learn how to
    modify the default precedence of an operator by using parentheses. For the OCA
    Java SE 8 Programmer I exam, you should be able to work with the operators listed
    in [table 2.9](#ch02table09).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用不同类型的运算符——赋值、算术、关系和逻辑——来操作变量的值。你将编写代码来确定两个原语数据类型的相等性。你还将学习如何通过使用括号来修改运算符的默认优先级。对于OCA
    Java SE 8程序员I级考试，你应该能够处理[表2.9](#ch02table09)中列出的运算符。
- en: Table 2.9\. Operator types and the relevant operators
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.9\. 运算符类型和相关运算符
- en: '| Operator type | Operators | Purpose |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 运算符类型 | 运算符 | 目的 |'
- en: '| --- | --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Assignment | =, +=, -=, *=, /= | Assign value to a variable |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 赋值 | =, +=, -=, *=, /= | 将值赋给变量 |'
- en: '| Arithmetic | +, -, *, /, %, ++, -- | Add, subtract, multiply, divide, and
    modulus primitives |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | +, -, *, /, %, ++, -- | 加、减、乘、除和取模原语 |'
- en: '| Relational | <, <=, >, >=, ==, != | Compare primitives |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 关系 | <, <=, >, >=, ==, != | 比较原语 |'
- en: '| Logical | !, &&, &#124;&#124; | Apply NOT, AND, and OR logic to primitives
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | !, &&, &#124;&#124; | 对原语应用NOT、AND和OR逻辑 |'
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Not all operators can be used with all types of operands. For example, you can
    determine whether a number is greater than another number, but you can’t determine
    whether `true` is greater than `false` or a number is greater than `true`. Take
    note of this as you learn the usage of all the operators on this exam.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有运算符都可以与所有类型的操作数一起使用。例如，你可以确定一个数字是否大于另一个数字，但你不能确定 `true` 是否大于 `false` 或一个数字是否大于
    `true`。在学习本考试中所有运算符的使用时，请注意这一点。
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4.1\. Assignment operators
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 赋值运算符
- en: The assignment operators that you need to know for the exam are `=`, `+=`, `-=`,
    `*=`, and `/=`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为考试准备的赋值运算符是 `=`, `+=`, `-=`, `*=`, 和 `/=`.
- en: The simple assignment operator, `=`, is the most frequently used operator. It’s
    used to initialize variables with values and to reassign new values to them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 简单赋值运算符 `=` 是最常用的运算符。它用于初始化变量并重新分配新值给它们。
- en: 'The `+=`, `-=`, `*=`, and `/=` operators are short forms of addition, subtraction,
    multiplication, and division with assignment. The `+=` operator can be read as
    “first add and then assign,” and `-=` can be read as “first subtract and then
    assign.” Similarly, `*=` can be read as “first multiply and then assign,” `/=`
    can be read as “first divide and then assign,” and `%=` can be read as “first
    modulus and then assign.” If you apply these operators to two operands, `a` and
    `b`, they can be represented as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=`, `-=`, `*=`, 和 `/=` 运算符是带有赋值的加法、减法、乘法和除法的简写形式。`+=` 运算符可以读作“先加后赋”，`-=`
    可以读作“先减后赋”。同样，`*=` 可以读作“先乘后赋”，`/=` 可以读作“先除后赋”，`%=` 可以读作“先取模后赋”。如果你将这些运算符应用于两个操作数
    `a` 和 `b`，它们可以表示如下：'
- en: '[PRE12]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s have a look at some valid lines of code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些有效的代码行：
- en: '![](112fig01_alt.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](112fig01_alt.jpg)'
- en: 'Next let’s look at some invalid lines of code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看一些无效的代码行：
- en: '![](113fig01_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](113fig01_alt.jpg)'
- en: 'Now let’s try to squeeze the variables that can store a larger range of values
    into variables with a shorter range. Try the following assignments:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试将可以存储更大范围值的变量挤入范围较短的变量中。尝试以下赋值：
- en: '![](113fig02.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](113fig02.jpg)'
- en: It’s similar to what’s shown in [figure 2.15](#ch02fig15), where someone is
    forcefully trying to squeeze a bigger value (`long`) into a smaller container
    (`int`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它与[图 2.15](#ch02fig15) 中显示的内容类似，其中有人试图强行将更大的值（`long`）挤入较小的容器（`int`）中。
- en: Figure 2.15\. Assigning a bigger value (`long`) to a variable (`int`) that’s
    only capable of storing a smaller value range
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.15\. 将更大的值（`long`）分配给只能存储较小值范围的变量（`int`）
- en: '![](02fig15.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig15.jpg)'
- en: You can still assign a bigger value to a variable that can only store smaller
    ranges by explicitly casting the bigger value to a smaller value. By doing so,
    you tell the compiler that you know what you’re doing. In that case, the compiler
    proceeds by chopping off any extra bits that may not fit into the smaller variable.
    Beware! Though chopping off extra bits will make a bigger value fit in a smaller
    data type, the remaining bits won’t represent the original value and can produce
    unexpected results.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过显式地将更大的值转换为更小的值，将更大的值分配给只能存储较小范围的变量。这样做，您告诉编译器您知道自己在做什么。在这种情况下，编译器会通过截断任何可能不适合较小变量的额外位来继续操作。小心！虽然截断额外位可以使更大的值适合较小的数据类型，但剩余的位不会表示原始值，并可能产生意外的结果。
- en: 'Compare the previous assignment example (assigning a `long` to an `int`) with
    the following example that assigns a smaller value (`int`) to a variable (`long`)
    that’s capable of storing bigger value ranges:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个赋值示例（将 `long` 分配给 `int`）与以下示例进行比较，该示例将较小的值（`int`）分配给可以存储较大值范围的变量（`long`）：
- en: '![](114fig01.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](114fig01.jpg)'
- en: An `int` can easily fit into a `long` because there’s enough room for it (as
    shown in [figure 2.16](#ch02fig16)).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 可以轻松地放入 `long` 中，因为足够的空间（如[图 2.16](#ch02fig16)所示）。'
- en: Figure 2.16\. Assigning a smaller value (`int`) to a variable (`long`) that’s
    capable of storing a larger value range
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.16\. 将较小的值（`int`）分配给可以存储较大值范围的变量（`long`）
- en: '![](02fig16.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig16.jpg)'
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can’t use the assignment operators to assign a `boolean` value to variables
    of type `char`, `byte`, `int`, `short`, `long`, `float`, or `double`, or vice
    versa.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能使用赋值运算符将 `boolean` 值分配给类型为 `char`、`byte`、`int`、`short`、`long`、`float` 或 `double`
    的变量，反之亦然。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can also assign multiple values on the same line using the assignment operator.
    Examine the following lines of code:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用赋值运算符在同一行上分配多个值。请检查以下代码行：
- en: '![](114fig02_alt.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](114fig02_alt.jpg)'
- en: On the line tagged ![](num-1.jpg), the assignment starts from right to left.
    The value of variable `c` is assigned to the variable `b`, and the value of variable
    `b` (which is already equal to `c`) is assigned to the variable `a`. This is proved
    by the fact that line 3 prints `8`, and not `7`!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记为 ![](num-1.jpg) 的行上，赋值是从右到左开始的。变量 `c` 的值被分配给变量 `b`，而变量 `b`（它已经等于 `c`）的值被分配给变量
    `a`。这可以通过第3行打印 `8`，而不是 `7` 来证明！
- en: The next Twist in the Tale throws in a few twists with variable assignment and
    initialization. Let’s see if you can identify the incorrect ones (answers in the
    appendix).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 故事转折 2.15 中的下一个故事在变量分配和初始化方面加入了一些转折。让我们看看您是否能识别出错误的地方（答案见附录）。
- en: Twist in the Tale 2.2
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 2.2
- en: 'Let’s modify the assignment and initialization of the `boolean` variables used
    in previous sections. Examine the following code initializations and select the
    incorrect answers:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前章节中使用的 `boolean` 变量的赋值和初始化。检查以下代码初始化并选择错误的答案：
- en: '[PRE13]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code on line 1 will fail to compile.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第1行的代码将无法编译。
- en: Can’t initialize multiple variables like the code on line 2.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不能像第2行代码那样初始化多个变量。
- en: The code on line 3 is correct.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第3行的代码是正确的。
- en: Can’t assign `'false'` to a `boolean` variable.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不能将 `'false'` 分配给 `boolean` 变量。
- en: The code on line 5 is correct.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第5行的代码是正确的。
- en: 2.4.2\. Arithmetic operators
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 算术运算符
- en: Let’s take a quick look at each of these operators, together with a simple example,
    in [table 2.10](#ch02table10).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看每个运算符，以及一个简单的示例，[表 2.10](#ch02table10) 中有介绍。
- en: Table 2.10\. Use of arithmetic operators with examples
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.10\. 使用算术运算符的示例
- en: '| Operator | Purpose | Usage | Answer |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 目的 | 用法 | 答案 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| + | Addition | 12 + 10 | 22 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| + | 加法 | 12 + 10 | 22 |'
- en: '| - | Subtraction | 19 – 29 | -10 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| - | 减法 | 19 – 29 | -10 |'
- en: '| * | Multiplication | 101 * 45 | 4545 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| * | 乘法 | 101 * 45 | 4545 |'
- en: '| / | Division (quotient) | 10 / 6 10.0 / 6.0 | 1 1.6666666666666667 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| / | 除法（商） | 10 / 6 10.0 / 6.0 | 1 1.6666666666666667 |'
- en: '| % | Modulus (remainder in division) | 10 % 6 10.0 % 6.0 | 4 4.0 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| % | 取模（除法的余数） | 10 % 6 10.0 % 6.0 | 4 4.0 |'
- en: '| ++ | Unary increment operator; increments value by 1 | ++var or var++ | 11
    (assuming value of var is 10) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| ++ | 一元自增运算符；值增加 1 | ++var 或 var++ | 11（假设 var 的值为 10）|'
- en: '| -- | Unary decrement operator; decrements value by 1 | --var or var-- | 9
    (assuming value of var is 10) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| -- | 一元自减运算符；值减少 1 | --var 或 var-- | 9（假设 var 的值为 10）|'
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can use unary increment and decrement operators with variables but not with
    literal values. If you do, the code won’t compile.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一元自增和自减运算符与变量一起使用，但不能与字面量一起使用。如果你这样做，代码将无法编译。
- en: '|  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'When you apply the addition operator to `char` values, their corresponding
    ASCII values are added and subtracted. Here’s a quick example (the ASCII value
    of character `a` is 97):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将加法运算符应用于 `char` 类型的值时，它们的对应 ASCII 值会被相加和相减。以下是一个快速示例（字符 `a` 的 ASCII 值为 97）：
- en: '![](115fig01.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](115fig01.jpg)'
- en: 'And the following code outputs 0:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码输出 0：
- en: '![](115fig02.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](115fig02.jpg)'
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can use all arithmetic operators with the `char` primitive data type, including
    unary increment and decrement operators.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用所有算术运算符与 `char` 原始数据类型一起使用，包括一元自增和自减运算符。
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Implicit widening of data types in an arithmetic operation
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 算术运算中的数据类型隐式提升
- en: 'All `byte`, `short`, and `char` values are automatically widened to `int` when
    used as operands for arithmetic operations. If a `long` value is involved somewhere,
    then everything, including `int` values, is widened to `long`. This explains why
    you can’t assign the sum of two `byte` values to a `short` type:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `byte`、`short` 和 `char` 类型的值在用作算术运算的操作数时都会自动提升为 `int` 类型。如果涉及到 `long` 类型的值，那么包括
    `int` 值在内的所有值都会提升为 `long` 类型。这解释了为什么你不能将两个 `byte` 类型的值的和赋值给 `short` 类型的变量：
- en: '![](116fig01.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](116fig01.jpg)'
- en: 'The preceding code fails with the following error message:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会因以下错误信息而失败：
- en: '[PRE14]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: For arithmetic operations with data types `char`, `byte`, `short`, or `int`,
    all operand values are widened to `int`. If an arithmetic operation includes the
    data type `long`, all operand values are widened to `long`. If an arithmetic operation
    includes a data type of `float` or `double`, all operand values are widened to
    `double`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `char`、`byte`、`short` 或 `int` 数据类型的算术运算，所有操作数值都会提升为 `int`。如果算术运算包括 `long`
    数据类型，所有操作数值都会提升为 `long`。如果算术运算包括 `float` 或 `double` 数据类型，所有操作数值都会提升为 `double`。
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'But if you modify the preceding example and define variables `age1` and `age2`
    as `final` variables, then the compiler *is assured* that their sum, value `30`,
    can be assigned to a variable of type `short`, without any loss of precision.
    In this case, the compiler is good to assign the sum of `age1` and `age2` to `sum`.
    Here’s the modified code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你修改上述示例，并将变量 `age1` 和 `age2` 定义为 `final` 变量，那么编译器 *可以保证* 它们的和，值 `30`，可以被赋值给
    `short` 类型的变量，而不会丢失精度。在这种情况下，编译器会将 `age1` 和 `age2` 的和赋值给 `sum`。以下是修改后的代码：
- en: '![](116fig02.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](116fig02.jpg)'
- en: ++ and -- (unary increment and decrement operators)
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ++ 和 --（一元自增和自减运算符）
- en: The operators `++` and `--` are unary operators; they work with a single operand.
    They’re used to increment or decrement the value of a variable by `1`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `++` 和 `--` 是一元运算符；它们与单个操作数一起工作。它们用于将变量的值增加或减少 `1`。
- en: 'Unary operators can also be used in prefix and postfix notation. In *prefix
    notation*, the operator appears before its operand:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符也可以使用前缀和后缀表示法。在 *前缀表示法* 中，运算符出现在其操作数之前：
- en: '![](116fig03.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图片](116fig03.jpg)'
- en: 'In *postfix notation*, the operator appears after its operand:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *后缀表示法* 中，运算符出现在其操作数之后：
- en: '![](116fig04.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](116fig04.jpg)'
- en: 'When these operators aren’t part of an expression, the postfix and prefix notations
    behave in exactly the same manner:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些运算符不是表达式的一部分时，后缀和前缀表示法的行为完全相同：
- en: '![](117fig01.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](117fig01.jpg)'
- en: 'When a unary operator is used in an expression, its placement with respect
    to its operand decides whether its value will increment or decrement before the
    evaluation of the expression or after the evaluation of the expression. See the
    following code, where the operator `++` is used in prefix notation:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当一元运算符在表达式中使用时，其相对于操作数的放置决定了其值是在表达式评估之前还是之后增加或减少。请看以下代码，其中运算符 `++` 使用了前缀表示法：
- en: '![](117fig02_alt.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](117fig02_alt.jpg)'
- en: In the preceding example, the expression `a - ++b` uses the increment operator
    (`++`) in prefix notation. Therefore, the value of variable `b` increments to
    `11` before it’s subtracted from 20, assigning the result `9` to the variable
    `c`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，表达式 `a - ++b` 使用了前缀表示法中的增量运算符 (`++`)。因此，变量 `b` 的值增加到 `11`，然后从 20 中减去，将结果
    `9` 赋值给变量 `c`。
- en: 'When `++` is used in postfix notation with an operand, its value increments
    after it’s been used in the expression:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用后缀表示法与操作数一起使用`++`时，它的值在使用表达式后增加：
- en: '![](117fig03_alt.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](117fig03_alt.jpg)'
- en: The interesting part here is that the value of `b` is printed as `11` in both
    cases because the value of the variable increments (or decrements) as soon as
    the expression in which it’s used is evaluated.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是，在两种情况下 `b` 的值都打印为 `11`，因为变量 `b` 的值在它所使用的表达式评估后立即增加（或减少）。
- en: 'The same logic applies to the unary operator, `--`. Here’s an example:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑也适用于单目运算符 `--`。以下是一个示例：
- en: '![](117fig04_alt.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](117fig04_alt.jpg)'
- en: 'Let’s use the unary decrement operator (`--`) in postfix notation and see what
    happens:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用后缀递减运算符 (`--`) 并看看会发生什么：
- en: '![](118fig01_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](118fig01_alt.jpg)'
- en: Let’s check out some example code that uses unary increment and decrement operators
    in both prefix and postfix notation in the same line of code. What do you think
    the output of the following code will be?
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一些示例代码，这些代码在同一行代码中使用前缀和后缀表示法的单目增量运算符和递减运算符。你认为以下代码的输出会是什么？
- en: '[PRE15]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this code is `32`. The expression on the right-hand side evaluates
    from left to right, with the following values, which evaluate to `32`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出是`32`。右侧表达式的评估是从左到右进行的，以下值评估为`32`：
- en: '[PRE16]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The evaluation of an expression starts from left to right. For a prefix unary
    operator, the value of its operand increments or decrements just before its value
    is used in an expression. For a postfix unary operator, the value of its operand
    increments or decrements just after its value is used in an expression. [Figure
    2.17](#ch02fig17) illustrates what’s happening in the preceding expression.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的评估从左到右开始。对于前缀单目运算符，其操作数的值在使用表达式之前增加或减少。对于后缀单目运算符，其操作数的值在使用表达式之后增加或减少。[图
    2.17](#ch02fig17) 说明了前面表达式中发生的情况。
- en: Figure 2.17\. Evaluation of an expression that has multiple occurrences of unary
    operators in postfix and prefix notation
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.17\. 具有多处后缀和前缀单目运算符出现的表达式评估
- en: '![](02fig17_alt.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig17_alt.jpg)'
- en: For the exam, it’s important for you to have a good understanding of, and practice
    in, using postfix and prefix operators. In addition to the expressions shown in
    the previous examples, you can also find them in use as conditions in `if` statements,
    `for` loops, and `do-while` and `while` loops.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 对于考试，您需要很好地理解并练习使用后缀和前缀运算符。除了前面示例中显示的表达式外，您还可以在 `if` 语句、`for` 循环以及 `do-while`
    和 `while` 循环的条件中找到它们的使用。
- en: The next Twist in the Tale exercise will give you practice with unary operators
    used in prefix and postfix notation (answer in the appendix).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个故事转折练习将为您提供在前缀和后缀表示法中使用的单目运算符的实践（答案见附录）。
- en: Twist in the Tale 2.3
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 2.3
- en: 'Let’s modify the expression used in [figure 2.17](#ch02fig17) by replacing
    all occurrences of unary operators in prefix notation with postfix notations and
    vice versa. So `++a` changes to `a++`, and vice versa. Similarly, `--a` changes
    to `a--`, and vice versa. Your task is to evaluate the modified expression and
    determine the output of the following code:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 [图 2.17](#ch02fig17) 中使用的表达式，将所有前缀表示法中的单目运算符替换为后缀表示法，反之亦然。因此 `++a` 变为
    `a++`，反之亦然。同样，`--a` 变为 `a--`，反之亦然。您的任务是评估修改后的表达式并确定以下代码的输出：
- en: '[PRE17]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Try to form the expression by replacing the values of variable `a` in the expression
    and explain each of them, the way it was done for you in [figure 2.17](#ch02fig17).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过替换表达式中变量 `a` 的值来形成表达式，并解释每个值，就像在 [图 2.17](#ch02fig17) 中为您所做的那样。
- en: 2.4.3\. Relational operators
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. 关系运算符
- en: Relational operators are used to check one condition. You can use these operators
    to determine whether a primitive value is equal to another value or whether it
    is less than or greater than the other value.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符用于检查一个条件。您可以使用这些运算符来确定一个原始值是否等于另一个值，或者它是否小于或大于另一个值。
- en: 'These relational operators can be divided into two categories:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系运算符可以分为两类：
- en: Comparing greater (`>`, `>=`) and lesser values (`<`, `<=`)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较大于（`>`, `>=`）和小于（`<`, `<=`）的值
- en: Comparing values for equality (`==`) and inequality (`!=`)
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较值（`==`）和不等（`!=`）
- en: 'The operators `<`, `<=`, `>`, and `>=` work with all types of numbers, both
    integers (including `char`) and floating point, that can be added and subtracted.
    Examine the following code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`, `<=`, `>`, 和 `>=` 运算符适用于所有类型的数字，包括整数（包括`char`）和浮点数，可以进行加法和减法运算。查看以下代码：'
- en: '![](119fig01_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](119fig01_alt.jpg)'
- en: The second category of operators is covered in the following section.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类运算符将在下一节中介绍。
- en: '|  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can’t compare incomparable values. For example, you can’t compare a `boolean`
    with an `int`, a `char`, or a floating-point number. If you try to do so, your
    code will not compile.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能比较不可比较的值。例如，你不能比较一个`boolean`与一个`int`、一个`char`或一个浮点数。如果你尝试这样做，你的代码将无法编译。
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Comparing primitives for equality (using == and !=)
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较原始数据类型（使用 == 和 !=）
- en: 'The operators `==` (equal to) and `!=` (not equal to) can be used to compare
    all types of primitives: `char`, `byte`, `short`, `int`, `long`, `float`, `double,`
    and `boolean`. The operator `==` returns the `boolean` value `true` if the primitive
    values that you’re comparing are equal, and `false` otherwise. The operator `!=`
    returns `true` if the primitive values that you’re comparing are *not* equal,
    and `false` otherwise. For the same set of values, if `==` returns `true`, `!=`
    will return `false`. Sounds interesting!'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`（等于）和`!=`（不等于）运算符可以用来比较所有类型的原始数据类型：`char`、`byte`、`short`、`int`、`long`、`float`、`double`和`boolean`。如果比较的原始数据类型值相等，`==`运算符返回`boolean`值`true`，否则返回`false`。如果比较的原始数据类型值不相等，`!=`运算符返回`true`，否则返回`false`。对于同一组值，如果`==`返回`true`，则`!=`将返回`false`。听起来很有趣！'
- en: 'Examine the following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码：
- en: '![](120fig01_alt.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![](120fig01_alt.jpg)'
- en: 'Remember that you can’t apply these operators to incomparable types. In the
    following code snippet, the code that compares an `int` variable to a `boolean`
    variable will fail to compile:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你不能将这些运算符应用于不可比较的类型。在下面的代码片段中，比较一个`int`变量和一个`boolean`变量的代码将无法编译：
- en: '![](120fig02.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](120fig02.jpg)'
- en: 'Here’s the compilation error:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编译错误：
- en: '[PRE18]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The result of the relational operation is always a `boolean` value. You can’t
    assign the result of a relational operation to a variable of type `char`, `int`,
    `byte`, `short`, `long`, `float`, or `double`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算的结果始终是一个`boolean`值。你不能将关系运算的结果赋值给类型为`char`、`int`、`byte`、`short`、`long`、`float`或`double`的变量。
- en: '|  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Comparing primitives using the assignment operator (=)
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用赋值运算符（=）比较原始数据类型
- en: 'It’s a very common mistake to use the assignment operator, `=`, in place of
    the equality operator, `==`, to compare primitive values. Before reading any further,
    check out the following code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用赋值运算符`=`代替相等运算符`==`来比较原始数据类型是一个非常常见的错误。在继续阅读之前，请查看以下代码：
- en: '![](120fig03_alt.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](120fig03_alt.jpg)'
- en: In the previous example, ![](num-1.jpg) isn’t comparing the variables `a` and
    `b`. It’s assigning the value of the variable `b` to `a` and then printing out
    the value of the variable `a`, which is `20`. Similarly, ![](num-2.jpg) isn’t
    comparing the variable `b1` with the `boolean` literal `true`. It’s assigning
    the `boolean` literal `true` to variable `b1` and printing out the value of the
    variable `b1`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，![](num-1.jpg)并不是在比较变量`a`和`b`。它将变量`b`的值赋给变量`a`，然后打印变量`a`的值，该值为`20`。同样，![](num-2.jpg)并不是在比较变量`b1`与布尔字面量`true`。它将布尔字面量`true`赋给变量`b1`，然后打印变量`b1`的值。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t compare primitive values by using the assignment operator, `=`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用赋值运算符`=`来比较原始数据类型。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.4.4\. Logical operators
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4. 逻辑运算符
- en: 'Logical operators are used to evaluate one or more expressions. These expressions
    should return a `boolean` value. You can use the logical operators `AND`, `OR`,
    and `NOT` to check multiple conditions and proceed accordingly. Here are a few
    real-life examples:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符用于评估一个或多个表达式。这些表达式应该返回一个`boolean`值。你可以使用逻辑运算符`AND`、`OR`和`NOT`来检查多个条件并相应地执行。以下是一些现实生活中的例子：
- en: '***Case 1 (for managers)—*** Request promotion if customer is extremely happy
    with the delivered project `AND` you think you deserve to be in your boss’s seat!'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***案例 1（针对管理者）——*** 如果客户对交付的项目非常满意，并且你认为你应坐在老板的位置上，请要求晋升！'
- en: '***Case 2 (for students)—*** Accept job proposal if handsome pay and perks
    `OR` awesome work profile.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***案例2（针对学生）—*** 如果薪资和福利优厚或工作前景出色，则接受工作提议。'
- en: '***Case 3 (for entry-level Java programmers)—*** If `NOT` happy with current
    job, change it.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***案例3（针对初级Java程序员）—*** 如果对当前工作不满意，则更换工作。'
- en: In each of these example cases, you’re making a decision (request promotion,
    accept job proposal, or change job) only if a set of conditions is satisfied.
    In case 1, a manager may request a promotion only if *both* the specified conditions
    are met. In case 2, a student may accept a new job if *either* of the conditions
    is true. In case 3, an entry-level Java programmer may change their current job
    if *not* happy with the current job, that is, if the specified condition (being
    happy with the current job) is false.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例案例中，你只有在满足一系列条件的情况下才会做出决定（请求晋升、接受工作提议或更换工作）。在案例1中，如果满足所有指定条件，经理才可能请求晋升。在案例2中，如果任一条件为真，学生可以接受新的工作。在案例3中，如果初级Java程序员对当前工作不满意，他们可以更换工作，也就是说，如果指定的条件（对当前工作满意）为假。
- en: As illustrated in these examples, if you wish to proceed with a task when *both*
    the conditions are true, use the logical `AND` operator, `&&`. If you wish to
    proceed with a task when *either* of the conditions is true, use the logical `OR`
    operator, `||`. If you wish to reverse the outcome of a `boolean` value, use the
    negation operator, `!`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，如果你希望在两个条件都为真时执行任务，请使用逻辑`AND`运算符`&&`。如果你希望在任一条件为真时执行任务，请使用逻辑`OR`运算符`||`。如果你要反转`boolean`值的输出，请使用否定运算符`!`。
- en: 'Time to look at some code in action:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看代码的实际应用：
- en: '![](121fig01_alt.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](121fig01_alt.jpg)'
- en: '![](num-1.jpg) prints `false` because both of the conditions, `a > 20` and
    `b > 10`, are not `true`. The first one (`a > 20`) is `false`. ![](num-2.jpg)
    prints `true` because one of these conditions (`b > 10`) is `true`. ![](num-3.jpg)
    prints `false` because the specified condition, `b > 10`, is `true`. ![](num-4.jpg)
    prints `true` because the specified condition, `a > 20`, is `false`.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 打印`false`，因为两个条件`a > 20`和`b > 10`都不是`true`。第一个条件(`a > 20`)是`false`。![](num-2.jpg)
    打印`true`，因为其中之一的条件(`b > 10`)是`true`。![](num-3.jpg) 打印`false`，因为指定的条件`b > 10`是`true`。![](num-4.jpg)
    打印`true`，因为指定的条件`a > 20`是`false`。'
- en: '[Table 2.11](#ch02table11) will help you understand the result of using these
    logical operators.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.11](#ch02table11) 将帮助你理解使用这些逻辑运算符的结果。'
- en: Table 2.11\. Outcome of using `boolean` literal values with the logical operators
    `AND`, `OR`, and `NOT`
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.11\. 使用逻辑运算符 `AND`、`OR` 和 `NOT` 的 `boolean` 文字值的输出结果
- en: '| Operators && (AND) | Operator &#124;&#124; (OR) | Operator ! (NOT) |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 && (AND) | 运算符 &#124;&#124; (OR) | 运算符 ! (NOT) |'
- en: '| --- | --- | --- |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| true && true → true true && false → false false && true → false false &&
    false → false true && true && false → false | true &#124;&#124; true → true true
    &#124;&#124; false → true false &#124;&#124; true → true false &#124;&#124; false
    → false false &#124;&#124; false &#124;&#124; true →true | !true → false !false
    → true |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| true && true → true true && false → false false && true → false false &&
    false → false true && true && false → false | true || true → true true || false
    → true false || true → true false || false → false false || false || true →true
    | !true → false !false → true |'
- en: 'Here’s a summary of this table:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个表的总结：
- en: '*Logical* `AND` *(*`&&`*)*—Evaluates to `true` if *all* operands are `true`;
    `false` otherwise.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑* `AND` (*`&&`*)—如果所有操作数都是`true`，则返回`true`；否则返回`false`。'
- en: '*Logical* `OR` *(*`||`*)*—Evaluates to `true` if *any or all* the operands
    are `true`.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑* `OR` (*`||`*)—如果任一或所有操作数都是`true`，则返回`true`。'
- en: '*Logical negation (*`!`*)*—Negates the `boolean` value. Evaluates to `true`
    for `false` and vice versa.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑否定（`!`）*—否定`boolean`值。对于`false`返回`true`，反之亦然。'
- en: The operators `|` and `&` can also be used to manipulate individual bits of
    a number value, but I won’t cover this usage here, because it’s not on this exam.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `|` 和 `&` 也可以用来操作数值的各个位，但在这里不涉及这种用法，因为它不是本次考试的考点。
- en: '&& and || are short-circuit operators'
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '&& 和 || 是短路运算符'
- en: Another interesting point to note with respect to the logical operators `&&`
    and `||` is that they’re also called *short-circuit* operators because of the
    way they evaluate their operands to determine the result. Let’s start with the
    operator `&&`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 关于逻辑运算符 `&&` 和 `||` 的另一个有趣点是，它们也被称为*短路*运算符，因为它们通过评估操作数来确定结果的方式。让我们从运算符 `&&`
    开始。
- en: The `&&` operator returns `true` only if both the operands are `true`. If the
    first operand to this operator evaluates to `false`, the result can *never* be
    `true`. Therefore, `&&` does not evaluate the second operand. Similarly, the `||`
    operator does not evaluate the second operator if the first operand evaluates
    to `true`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 运算符仅在两个操作数都为 `true` 时返回 `true`。如果此运算符的第一个操作数评估为 `false`，则结果永远不能为 `true`。因此，`&&`
    不会评估第二个操作数。同样，如果第一个操作数评估为 `true`，则 `||` 运算符不会评估第二个操作数。'
- en: '![](122fig01_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](122fig01_alt.jpg)'
- en: In the first print statement ![](num-1.jpg), because the first condition, `total
    < marks`, evaluates to `false`, the next condition, `++marks > 5`, isn’t even
    evaluated. As you can see ![](num-2.jpg), the output value of `marks` is still
    `8` (the value to which it was initialized on line 1)! Similarly, in the next
    comparison ![](num-3.jpg), because `total == 10` evaluates to `true`, the second
    condition, `++marks > 10`, isn’t evaluated. Again, this can be verified when the
    value of `marks` is printed again ![](num-4.jpg), and the output is `8`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个打印语句 ![](num-1.jpg) 中，因为第一个条件 `total < marks` 评估为 `false`，所以下一个条件 `++marks
    > 5` 甚至没有被评估。正如你所见 ![](num-2.jpg)，`marks` 的输出值仍然是 `8`（它在第 1 行初始化的值）！同样，在下一个比较
    ![](num-3.jpg) 中，因为 `total == 10` 评估为 `true`，所以第二个条件 `++marks > 10` 没有被评估。再次，这可以在再次打印
    `marks` 的值时得到验证 ![](num-4.jpg)，输出为 `8`。
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: All the relational and logical operators return a `boolean` value, which can
    be assigned to a primitive `boolean` variable.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关系和逻辑运算符都返回一个 `boolean` 值，该值可以赋给原始 `boolean` 变量。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The purpose of the next Twist in the Tale is to encourage you to play with code
    that uses short-circuit operators. To determine whether a `boolean` expression
    passed as an operand to the short-circuit operators evaluates, you can apply a
    unary increment operator (in postfix notation) to the variable used in the expression.
    Compare the new variable value with the old value to verify whether the expression
    was evaluated (answers in the appendix).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个故事转折的目的是鼓励你玩使用短路运算符的代码。为了确定作为短路运算符操作数的 `boolean` 表达式是否评估，你可以对表达式中所使用的变量应用一元增量运算符（后缀表示法）。比较新变量的值与旧值，以验证表达式是否已评估（答案见附录）。
- en: Twist in the Tale 2.4
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 2.4
- en: As you know, the short-circuit operators `&&` and `||` may not evaluate both
    their operands if they can determine the result of the expression by evaluating
    just the first operand. Examine the following code and circle the expressions
    that you think will evaluate. Draw a square around the expressions that you think
    may not execute. (For example, on line 1, both `a++ > 10` and `++b < 30` will
    evaluate.)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，短路运算符 `&&` 和 `||` 如果仅通过评估第一个操作数就可以确定表达式的结果，则可能不会评估它们的操作数。检查以下代码，并圈出你认为将评估的表达式。围绕你认为可能不会执行的表达式画一个方框。（例如，在第
    1 行，`a++ > 10` 和 `++b < 30` 都将评估。）
- en: '[PRE19]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Example use of the short-circuit operator `&&` in real projects**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例中在真实项目中使用短路运算符 `&&` 的应用**'
- en: 'The logical operator `&&` is often used in code to check whether an object
    reference variable has been assigned a value before invoking a method on it:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符 `&&` 常用于代码中，以检查在调用对象引用变量上的方法之前是否已为其分配了值：
- en: '[PRE20]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4.5\. Operator precedence
  id: totrans-488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.5\. 运算符优先级
- en: What happens if you use multiple operators within a single line of code with
    multiple operands? Which one should be treated like the king and given preference
    over the others?
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一行代码中使用多个操作数和多个运算符会发生什么？哪一个应该被视为“国王”并给予优先权？
- en: 'Don’t worry. Java already has a rule in place for just such a situation. [Table
    2.12](#ch02table12) lists the precedence of operators: the operator on top has
    the highest precedence, and operators within the same group have the same precedence
    and are evaluated from left to right.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心。Java 已经为这种情况制定了规则。[表 2.12](#ch02table12) 列出了运算符的优先级：上方的运算符具有最高的优先级，同一组内的运算符具有相同的优先级，并且从左到右进行评估。
- en: Table 2.12\. Precedence of operators
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.12\. 运算符优先级
- en: '| Operator | Precedence |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 优先级 |'
- en: '| --- | --- |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Postfix | Expression++, expression-- |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 后缀 | 表达式++，表达式-- |'
- en: '| Unary | ++expression, --expression, +expression, -expression, ! |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 一元 | ++表达式，--表达式，+表达式，-表达式，! |'
- en: '| Multiplication | * (multiply), / (divide), % (remainder) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | * (乘)，/ (除)，% (余数) |'
- en: '| Addition | + (add), - (subtract) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | + (加)，- (减) |'
- en: '| Relational | <, >, <=, >= |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 关系 | <, >, <=, >= |'
- en: '| Equality | ==, != |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | ==, != |'
- en: '| Logical AND | && |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑与 | && |'
- en: '| Logical OR | &#124;&#124; |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑或 | &#124;&#124; |'
- en: '| Assignment | =, +=, -=, *=, /=, %= |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 赋值 | =, +=, -=, *=, /=, %= |'
- en: '|  |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Table 2.12](#ch02table12) is limited to the operators that are part of the
    OCA exam. You can access the complete list at [https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.12](#ch02table12)仅限于OCA考试中的运算符。您可以在[https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)访问完整列表。'
- en: '|  |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s execute an expression that uses multiple operators (with different precedence)
    in an expression:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行一个使用多个运算符（具有不同优先级）的表达式：
- en: '![](124fig01_alt.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![](124fig01_alt.jpg)'
- en: 'Because this expression ![](num-1.jpg) defines multiple operators with different
    precedence, it’s evaluated as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个表达式 ![](num-1.jpg) 定义了多个具有不同优先级的运算符，所以它的评估如下：
- en: '[PRE21]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What if you don’t want to evaluate the expression in this way? The remedy is
    simple: use parentheses to override the default operator precedence. Here’s an
    example that adds `int3` and `int1` before multiplying by `int2`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想以这种方式评估表达式，补救措施很简单：使用括号来覆盖默认的运算符优先级。以下是一个在乘以 `int2` 之前先添加 `int3` 和 `int1`
    的示例：
- en: '![](124fig02_alt.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![](124fig02_alt.jpg)'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can use parentheses to override the default operator precedence. If your
    expression defines multiple operators and you’re unsure how your expression will
    be evaluated, use parentheses to evaluate in your preferred order. The inner parentheses
    are evaluated prior to the outer ones, following the same rules of classic algebra.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用括号来覆盖默认的运算符优先级。如果您的表达式定义了多个运算符，并且您不确定您的表达式将如何被评估，请使用括号以您首选的顺序进行评估。内部括号先于外部括号进行评估，遵循经典代数的相同规则。
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.5\. Wrapper classes
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 包装类
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[2.5](#ch02lev1sec5)] Develop code that uses wrapper classes such as Boolean,
    Double, and Integer.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.5](#ch02lev1sec5)] 开发使用包装类（如Boolean、Double和Integer）的代码。'
- en: '|  |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Java defines a wrapper class for each of its primitive data types. The wrapper
    classes are used to wrap primitives in an object, so they can be added to a collection
    object. They enable all types to be treated like object instances. Wrapper classes
    help you write cleaner code, which is easy to read. For this exam, you should
    be able to write code that uses these wrapper classes.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Java为它的每个原始数据类型定义了一个包装类。包装类用于将原始数据类型包装在对象中，因此它们可以被添加到集合对象中。它们使所有类型都可以像对象实例一样被对待。包装类帮助您编写更干净的代码，易于阅读。对于这次考试，您应该能够编写使用这些包装类的代码。
- en: 2.5.1\. Class hierarchy of wrapper classes
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1\. 包装类的类层次结构
- en: All the wrapper classes are *immutable*—classes that don’t allow changes to
    the state of their instances after initialization. They share multiple usage details
    and methods. [Figure 2.18](#ch02fig18) shows their hierarchy.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包装类都是**不可变的**——这些类在初始化后不允许对其实例的状态进行更改。它们共享多个使用细节和方法。[图2.18](#ch02fig18)显示了它们的层次结构。
- en: Figure 2.18\. Hierarchy of wrapper classes
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.18\. 包装类的层次结构
- en: '![](02fig18_alt.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig18_alt.jpg)'
- en: All the numeric wrapper classes extend the class `java.lang.Number`. Classes
    `Boolean` and `Character` directly extend the class `Object`. All the wrapper
    classes implement the interfaces `java.io.Serializable` and `java.lang.Comparable`.
    All these classes can be serialized to a stream, and their objects define a natural
    sort order.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数值包装类都扩展了类 `java.lang.Number`。类 `Boolean` 和 `Character` 直接扩展了类 `Object`。所有包装类都实现了接口
    `java.io.Serializable` 和 `java.lang.Comparable`。所有这些类都可以被序列化到流中，并且它们的对象定义了一个自然排序顺序。
- en: 2.5.2\. Creating objects of the wrapper classes
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2\. 创建包装类对象
- en: 'You can create objects of all the wrapper classes in multiple ways:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式创建所有包装类的对象：
- en: '***Assignment—*** By assigning a primitive to a wrapper class variable (autoboxing)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***赋值——*** 通过将原始数据类型赋给包装类变量（自动装箱）'
- en: '***Constructor—*** By using wrapper class constructors'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***构造函数——*** 通过使用包装类构造函数'
- en: '***Static methods—*** By calling static method of wrapper classes, like, `valueOf()`'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***静态方法——*** 通过调用包装类的静态方法，例如，`valueOf()`'
- en: 'For example:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '![](125fig01_alt.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](125fig01_alt.jpg)'
- en: You can create objects of the rest of the wrapper classes (`Short`, `Integer`,
    `Long`, and `Float`) in a similar manner. All the wrapper classes define constructors
    to create an object using a corresponding primitive value or as a `String`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用类似的方式创建其他包装类（`Short`、`Integer`、`Long` 和 `Float`）的对象。所有包装类都定义了构造函数，可以使用相应的原始值或作为
    `String` 来创建对象。
- en: Another interesting point to note is that neither of these classes defines a
    default no-argument constructor. The wrapper classes are immutable. So it doesn’t
    make sense to initialize the wrapper objects with the default primitive values
    if they can’t be modified later.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的有趣点是，这些类中没有一个定义默认的无参构造函数。包装类是不可变的。因此，如果它们以后不能被修改，用默认的原始值初始化包装对象是没有意义的。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: All wrapper classes (except `Character`) define a constructor that accepts a
    `String` argument representing the primitive value that needs to be wrapped. Watch
    out for exam questions that include a call to a no-argument constructor of a wrapper
    class. None of these classes define a no-argument constructor.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包装类（除了 `Character`）都定义了一个接受表示需要包装的原始值的 `String` 参数的构造函数。请注意考试中包含调用包装类无参构造函数的问题。这些类中没有一个定义无参构造函数。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can assign a primitive value directly to a reference variable of its wrapper
    class type—thanks to *autoboxing*. The reverse is *unboxing,* when an object of
    a primitive wrapper class is converted to its corresponding primitive value. I’ll
    discuss autoboxing and auto-unboxing, in detail, in the next section.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接将原始值赋给其包装类类型的引用变量——这要归功于 *自动装箱*。相反，当原始包装类的对象转换为相应的原始值时，这是 *自动拆箱*。我将在下一节详细讨论自动装箱和自动拆箱。
- en: 2.5.3\. Retrieving primitive values from the wrapper classes
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.3\. 从包装类获取原始值
- en: All wrapper classes define methods of the format *primitive*Value(), where the
    term *primitive* refers to the exact primitive data type name. [Table 2.13](#ch02table13)
    shows a list of the classes and their methods to retrieve corresponding primitive
    values.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包装类都定义了格式为 *primitive*Value() 的方法，其中术语 *primitive* 指的是确切的原始数据类型名称。[表2.13](#ch02table13)
    展示了这些类及其获取相应原始值的方法列表。
- en: Table 2.13\. Methods to retrieve primitive values from wrapper classes
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.13\. 从包装类获取原始值的方法
- en: '| Boolean | Character | Byte, Short, Integer, Long, Float, Double |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| Boolean | Character | Byte, Short, Integer, Long, Float, Double |'
- en: '| --- | --- | --- |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| booleanValue() | charValue() | byteValue(), shortValue(), intValue(), |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| booleanValue() | charValue() | byteValue(), shortValue(), intValue(), |'
- en: '|   |   | longValue(), floatValue(), doubleValue() |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|   |   | longValue(), floatValue(), doubleValue() |'
- en: It’s interesting to note that all numeric wrapper classes define methods to
    retrieve the value of the primitive value they store, as a `byte`, `short`, `int`,
    `long`, `float`, or `double`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有数值包装类都定义了方法来检索它们存储的原始值的值，作为 `byte`、`short`、`int`、`long`、`float` 或 `double`。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: All six numeric wrapper classes inherit all six *****`Value()` methods from
    their common superclass, `Number`.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的六个数值包装类都从它们的共同超类 `Number` 继承了所有六个 *****`Value()` 方法。
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.5.4\. Parsing a string value to a primitive type
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4\. 将字符串值解析为原始类型
- en: To get a primitive data type value corresponding to a string value, you can
    use the static utility method parse*DataType*, where *DataType* refers to the
    type of the return value. Each wrapper class (except `Character`) defines a method
    to parse a `String` to the corresponding primitive value, as listed in [table
    2.14](#ch02table14).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与字符串值对应的原始数据类型值，您可以使用静态实用方法 parse*DataType*，其中 *DataType* 指的是返回值的类型。每个包装类（除了
    `Character`）都定义了一个将 `String` 解析为相应原始值的方法，如 [表2.14](#ch02table14) 中所示。
- en: Table 2.14\. List of *parseDataType* methods in wrapper classes
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.14\. 包装类中 *parseDataType* 方法的列表
- en: '| Class name | Method |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 方法 |'
- en: '| --- | --- |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Boolean | public static boolean parseBoolean(String s) |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| Boolean | public static boolean parseBoolean(String s) |'
- en: '| Character | no corresponding parsing method |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 没有对应的解析方法 |'
- en: '| Byte | public static byte parseByte(String s) |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| Byte | public static byte parseByte(String s) |'
- en: '| Short | public static short parseShort (String s) |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| Short | public static short parseShort (String s) |'
- en: '| Integer | public static int parseInt(String s) |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| Integer | public static int parseInt(String s) |'
- en: '| Long | public static long parseLong(String s) |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| Long | public static long parseLong(String s) |'
- en: '| Float | public static float parseFloat(String s) |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| Float | public static float parseFloat(String s) |'
- en: '| Double | public static double parseDouble(String s) |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| Double | public static double parseDouble(String s) |'
- en: 'All these parsing methods throw `NumberFormatException`s for invalid values.
    Here are some examples:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解析方法对于无效值都会抛出 `NumberFormatException`。以下是一些示例：
- en: '![](127fig01_alt.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![图片](127fig01_alt.jpg)'
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: All parse methods (listed in [table 2.14](#ch02table14)) throw `NumberFormat-Exception`
    except `Boolean.parseBoolean()`. This method returns `false` whenever the string
    it parses is not equal to “true” (case-insensitive comparison).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Boolean.parseBoolean()`方法外，所有解析方法（列于[表2.14](#ch02table14)）都会抛出`NumberFormatException`。此方法返回`false`，当它解析的字符串不等于“true”（不区分大小写比较）时。
- en: '|  |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.5.5\. Difference between using the valueOf method and constructors of wrapper
    classes
  id: totrans-572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.5\. 使用valueOf方法和包装类构造函数的区别
- en: The `valueOf()` method returns an object of the corresponding wrapper class
    when it’s passed an argument of a primitive type or `String`. So what is the difference
    between the `valueOf()` method and constructors of these classes, which also accept
    method arguments of a primitive type and `String`?
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当`valueOf()`方法传入原始类型或`String`类型的参数时，它返回相应包装类的对象。那么，`valueOf()`方法和这些类的构造函数之间的区别是什么，这些构造函数也接受原始类型和`String`类型的参数？
- en: 'Wrapper classes `Byte`, `Short`, `Integer`, and `Long` cache objects with values
    in the range of `-128` to `127`. The `Character` class caches objects with values
    `0` to `127`. These classes define inner static classes that store objects for
    the primitive values `-128` to `127` or `0` to `127` in an array. If you request
    an object of any of these classes, from this range, the `valueOf()` method returns
    a reference to a predefined object; otherwise, it creates a new object and returns
    its reference:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类`Byte`、`Short`、`Integer`和`Long`缓存值在`-128`到`127`范围内的对象。`Character`类缓存值为`0`到`127`的对象。这些类定义了内部静态类，它们在数组中存储原始值`-128`到`127`或`0`到`127`的对象。如果您请求这些类中的任何一个对象，在这个范围内，`valueOf()`方法返回一个指向预定义对象的引用；否则，它创建一个新的对象并返回其引用：
- en: '![](128fig01_alt.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![图片](128fig01_alt.jpg)'
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Wrapper classes `Float` and `Double` don’t cache objects for any range of values.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类`Float`和`Double`不会为任何值范围内的对象缓存。
- en: '|  |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the case of the `Boolean` class, the cached instances are accessible directly
    because only two exist: static constants `Boolean.TRUE` and `Boolean.FALSE`.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Boolean`类的例子中，缓存的实例可以直接访问，因为只有两个：静态常量`Boolean.TRUE`和`Boolean.FALSE`。
- en: 2.5.6\. Comparing objects of wrapper classes
  id: totrans-581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.6\. 比较包装类对象
- en: You can compare objects of wrapper classes for equality by using the method
    `equals` or the comparison operator, that is, `==`. Method `equals()` always compares
    the primitive value stored by a wrapper instance, and `==` compares object references.
    The operator `==` returns `true` if the variables being compared to refer to the
    same instance.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`equals`方法或比较运算符（即`==`）来比较包装类对象的相等性。`equals`方法始终比较包装实例存储的原始值，而`==`比较对象引用。如果被比较的变量引用相同的实例，则运算符`==`返回`true`。
- en: 'Refer to the preceding section on `valueOf()`. Wrapper classes like `Character`,
    `Byte`, `Short`, `Integer`, and `Long` cache wrapper objects for values `0` to
    `127` or `-128` to `127`. Depending on how you initialize wrapper instances, they
    might or might not refer to the same instances. The following example initializes
    `Integer` variables using constructors, the static method `valueOf`, and autoboxing
    (covered in the next section). Let’s compare these references using `==`:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面关于`valueOf()`的部分。包装类如`Character`、`Byte`、`Short`、`Integer`和`Long`为值`0`到`127`或`-128`到`127`缓存包装对象。根据您如何初始化包装实例，它们可能或可能不引用相同的实例。以下示例使用构造函数、静态方法`valueOf`和自动装箱（将在下一节中介绍）初始化`Integer`变量。让我们使用`==`比较这些引用：
- en: '![](128fig02_alt.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![图片](128fig02_alt.jpg)'
- en: '[PRE22]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE23]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As evident from the output of the preceding code, `Integer` instances created
    using the method `valueOf` and autoboxing for `int` value `10` refer to the same
    instance. If you replace `==` with `equals()` in the preceding lines of code,
    they will output `true`:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面代码的输出可以看出，使用`valueOf`方法和自动装箱为`int`值`10`创建的`Integer`实例引用了相同的实例。如果在前面代码的这些行中将`==`替换为`equals()`，它们将输出`true`：
- en: '![](129fig01.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![图片](129fig01.jpg)'
- en: 'But the same isn’t applicable for `Integer` instances created for `int` value
    `200` and compared using `==` (because they aren’t stored in the `Integer` cache):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于使用`==`比较的`int`值`200`创建的`Integer`实例并不适用（因为它们没有存储在`Integer`缓存中）：
- en: '![](129fig02.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![图片](129fig02.jpg)'
- en: Again, if you replace `==` with `equals()` in the preceding code, the code will
    output `true` for all comparisons.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果在前面代码中将`==`替换为`equals()`，所有比较的输出将为`true`。
- en: '|  |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Cached instances exist for the wrapper `Boolean` class for the values `true`
    and `false`. The `Character` class caches instances with values from `0` to `127`.
    Classes `Byte`, `Short`, `Integer`, and `Long` cache instances for values `-127`
    to `128`. No cached instances exist for the `Float` and `Double` wrapper classes.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类`Boolean`存在缓存实例，用于值`true`和`false`。`Character`类缓存从`0`到`127`的值的实例。`Byte`、`Short`、`Integer`和`Long`类为值`-127`到`128`缓存实例。`Float`和`Double`包装类没有缓存实例。
- en: The method `equals` compares the values stored by wrapper instances. The comparison
    operator `==` compares reference variables—checking whether they refer to the
    same instance.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`方法比较包装实例存储的值。比较运算符`==`比较引用变量——检查它们是否指向同一个实例。'
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using hashCode() and equals() to determine equality of wrapper class instances**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用hashCode()和equals()确定包装类实例的相等性**'
- en: Instances of wrapper classes can be used with the Java collection framework,
    as keys, with classes that support key-value pairs (like `HashMap`). These classes
    use `hashCode()` and `equals()` to determine the equality of instances. Because
    the collection framework classes (apart from `ArrayList`) aren’t on this exam,
    I don’t cover them in this book.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类实例可以用作Java集合框架中的键，与支持键值对的类（如`HashMap`）一起使用。这些类使用`hashCode()`和`equals()`来确定实例的相等性。由于集合框架类（除了`ArrayList`）不在此考试范围内，因此我在本书中没有涉及它们。
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can’t compare wrapper instances for equality using `equals()` or `==`,
    if they aren’t of the same class. The code won’t compile for instances that are
    compared using `==`. When compared using `equals()`, the output will be `false`:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包装实例不是同一类，则不能使用`equals()`或`==`来比较它们的相等性。对于使用`==`比较的实例，代码将无法编译。当使用`equals()`比较时，输出将是`false`：
- en: '![](130fig01_alt.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![130fig01_alt.jpg]'
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Objects of different wrapper classes with same values are not equal. Using `equals()`
    with such instances will return `false`. If you use `==` with such instances,
    the code won’t compile.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 值相同的不同包装类对象不相等。使用`equals()`与这样的实例将返回`false`。如果你使用`==`与这样的实例，代码将无法编译。
- en: '|  |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next section covers autoboxing and unboxing, used by the compiler to convert
    primitive values to wrapper objects and vice versa.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍自动装箱和拆箱，编译器使用这些功能将原始值转换为包装对象，反之亦然。
- en: 2.5.7\. Autoboxing and unboxing
  id: totrans-609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.7\. 自动装箱和拆箱
- en: '*Autoboxing* is the automatic conversion of a primitive data type to an object
    of the corresponding wrapper class (you *box* the primitive value). *Unboxing*
    is the reverse process (you *unbox* the primitive value), as shown in [figure
    2.19](#ch02fig19).'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动装箱*是将原始数据类型自动转换为相应包装类的对象（你*装箱*原始值）。*拆箱*是相反的过程（你*拆箱*原始值），如图2.19所示。'
- en: Figure 2.19\. Autoboxing and unboxing
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.19\. 自动装箱和拆箱
- en: '![](02fig19_alt.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![02fig19_alt.jpg]'
- en: 'The wrapper classes use autoboxing and unboxing features quite frequently:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类频繁地使用自动装箱和拆箱功能：
- en: '![](130fig02_alt.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![130fig02_alt.jpg]'
- en: 'Compare the use of the preceding method against the following method defined
    by the class `Double`:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面方法的使用与类`Double`定义的以下方法进行比较：
- en: '[PRE24]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Wait—did I just mention that the `compareTo()` method defined in the class
    `Double` accepts an object of the class `Double` and not a `double` primitive
    data type? Then why does the preceding code compile? The answer is autoboxing.
    Java converted the primitive `double` to an object of the class `Double` (by using
    the `valueOf()` method), so it works correctly. The Java compiler converted it
    to the following at runtime:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——我刚刚提到类`Double`中定义的`compareTo()`方法接受一个`Double`类的对象，而不是一个`double`原始数据类型吗？那么为什么前面的代码可以编译呢？答案是自动装箱。Java将原始的`double`转换为`Double`类的对象（通过使用`valueOf()`方法），所以它工作正常。Java编译器在运行时将其转换为以下代码：
- en: '[PRE25]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now examine the following code (an example of unboxing with autoboxing):'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查以下代码（自动装箱的拆箱示例）：
- en: '![](131fig01_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![131fig01_alt.jpg]'
- en: 'In the preceding code, at the end of execution of the `for` loop, `total` will
    be assigned a `Double` value of `23.36`. The arithmetic operators like `+=` can’t
    be used with objects. So why do you think the code compiles? In this example,
    the Java compiler converted the preceding code to the following at runtime:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`for`循环执行结束时，`total`将被分配一个值为`23.36`的`Double`对象。算术运算符如`+=`不能与对象一起使用。那么你认为代码为什么可以编译呢？在这个例子中，Java编译器在运行时将前面的代码转换为以下代码：
- en: '[PRE26]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous section, I mentioned that wrapper classes are immutable. So
    what happens when you *add* a value to the variable `total`, a `Double` object?
    In this case, the variable `total` refers to a *new* `Double` object.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我提到包装类是不可变的。那么当你向变量`total`（一个`Double`对象）添加值时会发生什么？在这种情况下，变量`total`引用了一个新的`Double`对象。
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Wrapper classes are immutable. Adding a primitive value to a wrapper class variable
    doesn’t modify the value of the object it refers to. The wrapper class variable
    is assigned a new object.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类是不可变的。向包装类变量添加原始值不会修改它所引用的对象的值。包装类变量被分配了一个新的对象。
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Here’s another interesting question. What happens if you pass `null` as an argument
    to the following method?
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有趣的问题。如果你将`null`作为以下方法的参数传递会发生什么？
- en: '[PRE27]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because the Java compiler would call `obj.intValue()` to get `obj`’s `int` value,
    passing `null` to the `increment()` method will throw a `NullPointerException`.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Java编译器会调用`obj.intValue()`来获取`obj`的`int`值，所以将`null`传递给`increment()`方法将抛出`NullPointerException`。
- en: '|  |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Unboxing a wrapper reference variable, which refers to `null`, will throw a
    `NullPointerException`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果拆箱一个引用包装类变量，该变量引用`null`，将抛出`NullPointerException`。
- en: '|  |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.6\. Summary
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6. 概述
- en: In this chapter, we started with the primitive data types in Java, including
    examples of where to use each of the kinds and their literal values. We also categorized
    the primitives into character type, integer type, and floating type. Then we covered
    the ingredients of valid and invalid Java identifiers. We covered the differences
    between primitive and reference types.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了Java中的基本数据类型，包括每种类型的用途示例及其文字面量。我们还把原始数据类型分为字符类型、整数类型和浮点类型。然后我们讨论了有效和无效Java标识符的要素。我们还介绍了原始类型和引用类型之间的区别。
- en: We discussed the operators used to manipulate primitives (limited to the ones
    required for the OCA Java SE 8 Programmer I exam). We also covered the conditions
    in which a particular operator can be used. For example, if you wish to check
    whether a set of conditions is true, you can use the logical operators. It’s also
    important to understand the operand types that can be used for each of these operators.
    For example, you can’t use `boolean` operands with the operators `>`, `>=`, `=<,`
    and `<`.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了用于操作原始数据类型的运算符（限于OCA Java SE 8程序员I考试所需的运算符）。我们还介绍了特定运算符可以使用的情况。例如，如果你希望检查一组条件是否为真，你可以使用逻辑运算符。了解每个运算符可以使用的操作数类型也很重要。例如，你不能使用`boolean`操作数与运算符`>`、`>=`、`<=`和`<`一起使用。
- en: We discussed the wrapper classes, including their class hierarchy, creating
    their instances, retrieving primitive values stored by wrapper class instance,
    parsing string values to primitive types, and comparing instances of wrapper classes.
    At the end of the chapter, we covered autoboxing and unboxing.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了包装类，包括它们的类层次结构、创建它们的实例、检索包装类实例存储的基本值、将字符串值解析为基本类型，以及比较包装类实例。在本章末尾，我们介绍了自动装箱和拆箱。
- en: 2.7\. Review notes
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7. 复习笔记
- en: 'Primitive data types:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据类型：
- en: 'Java defines eight primitive data types: `char`, `byte`, `short`, `int`, `long`,
    `float`, `double`, and `boolean`.'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java定义了八个基本数据类型：`char`、`byte`、`short`、`int`、`long`、`float`、`double`和`boolean`。
- en: Primitive data types are the simplest data types.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型是最简单的数据类型。
- en: Primitive data types are predefined by the programming language. A user can’t
    define a primitive data type in Java.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型是由编程语言预定义的。在Java中，用户不能定义基本数据类型。
- en: It’s helpful to categorize the primitive data types as Boolean, numeric, and
    character data types.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基本数据类型分类为布尔型、数值型和字符型是有帮助的。
- en: 'The `boolean` data type:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`数据类型：'
- en: The `boolean` data type is used to store data with only two possible values.
    These two possible values may be thought of as yes/no, 0/1, true/false, or any
    other combination. The actual values that a `boolean` can store are `true` and
    `false`.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`数据类型用于存储只有两种可能值的数。这两种可能的值可以认为是是/否、0/1、真/假，或者任何其他组合。`boolean`可以存储的实际值是`true`和`false`。'
- en: '`true` and `false` are literal values.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`和`false`是文字面量。'
- en: A literal is a fixed value that doesn’t need further calculations to be assigned
    to any variable.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字面量是一个固定值，不需要进一步计算就可以分配给任何变量。
- en: 'Numeric data types:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 数值数据类型：
- en: Numeric values can be stored as either integers or decimal numbers.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值可以存储为整数或小数。
- en: '`byte`, `short`, `int`, and `long` can be used to store integers.'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`、`short`、`int`和`long`可以用来存储整数。'
- en: The `byte`, `short`, `int`, and `long` data types use 8, 16, 32, and 64 bits,
    respectively, to store their values.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`、`short`、`int`和`long`数据类型分别使用8、16、32和64位来存储它们的值。'
- en: '`float` and `double` can be used to store decimal numbers.'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`和`double`可以用来存储十进制数。'
- en: The `float` and `double` data types use 32 and 64 bits, respectively, to store
    their values.
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`和`double`数据类型分别使用32和64位来存储它们的值。'
- en: The default type of integers—that is, nondecimal numbers—is `int`.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数的默认类型（即非十进制数）是`int`。
- en: To designate an integer literal value as a `long` value, add the suffix `L`
    or `l` to the literal value.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将整数字面值指定为`long`值，请在字面值后添加后缀`L`或`l`。
- en: Numeric values can be stored in binary, octal, decimal, and hexadecimal number
    formats. This exam won’t ask you to convert a number from one number system to
    another.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值可以存储在二进制、八进制、十进制和十六进制数格式中。这次考试不会要求你将一个数字从一个数制转换为另一个数制。
- en: Literal values in the decimal number system use digits from 0 to 9 (a total
    of 10 digits).
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制数系统中的字面值使用从0到9的数字（总共10个数字）。
- en: Literal values in the octal number system use digits from 0 to 7 (a total of
    8 digits).
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制数系统中的字面值使用从0到7的数字（总共8个数字）。
- en: Literal values in the hexadecimal number system use digits from 0 to 9 and letters
    from A to F (a total of 16 digits and letters).
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制数系统中的字面值使用从0到9的数字和从A到F的字母（总共16个数字和字母）。
- en: Literal values in the binary number system use digits 0 and 1 (a total of 2
    digits).
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数系统中的字面值使用数字0和1（总共2个数字）。
- en: The literal values in the octal number system start with the prefix `0`. For
    example, `0413` in the octal number system is `267` in the decimal number system.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制数系统中的字面值以前缀`0`开头。例如，八进制数系统中的`0413`在十进制数系统中是`267`。
- en: The literal values in the hexadecimal number system start with the prefix `0x.`
    For example, `0x10B` in the hexadecimal number system is `267` in the decimal
    number system.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制数系统中的字面值以前缀`0x`开头。例如，十六进制数系统中的`0x10B`在十进制数系统中是`267`。
- en: The literal values in the binary number system start with the prefix `0b` or
    `0B`. For example, the decimal value `267` is `0B100001011` in the binary system.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数系统中的字面值以前缀`0b`或`0B`开头。例如，十进制值`267`在二进制系统中是`0B100001011`。
- en: Starting with Java 7, you can use underscores within the Java literal values
    to make them more readable. `0B1_0000_10_11`, `0_413`, and `0x10_B` are valid
    binary, octal, and hexadecimal literal values.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java 7开始，你可以在Java字面值中使用下划线来使它们更易于阅读。`0B1_0000_10_11`、`0_413`和`0x10_B`是有效的二进制、八进制和十六进制字面值。
- en: The default type of a decimal number is `double`.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制数的默认类型是`double`。
- en: To designate a decimal literal value as a `float` value, add the suffix `F`
    or `f` to the literal value.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将十进制字面值指定为`float`值，请在字面值后添加后缀`F`或`f`。
- en: The suffixes `D` and `d` can be used to mark a literal value as a `double` value.
    Though it’s allowed, doing so is not required because the default value of decimal
    literals is `double`.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀`D`和`d`可以用来标记字面值为`double`值。虽然这样做是允许的，但不是必需的，因为十进制字面值的默认值是`double`。
- en: 'Character primitive data types:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 字符原始数据类型：
- en: A `char` data type can store a single 16-bit Unicode character; that is, it
    can store characters from virtually all the world’s existing scripts and languages.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`数据类型可以存储单个16位Unicode字符；也就是说，它可以存储几乎所有世界现有脚本和语言中的字符。'
- en: You can use values from `\u0000` (or 0) to a maximum of `\uffff` (or 65,535
    inclusive) to store a `char`. Unicode values are defined in the hexadecimal number
    system.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用从`\u0000`（或0）到最大`\uffff`（或65,535 inclusive）的值来存储一个`char`。Unicode值是在十六进制数系统中定义的。
- en: Internally, the `char` data type is stored as an unsigned integer value (only
    positive integers).
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，`char`数据类型以无符号整数值的形式存储（只有正整数）。
- en: When you assign a letter to a `char`, Java stores its integer equivalent value.
    You may assign a positive integer value to a `char` instead of a letter, such
    as 122.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个字母分配给`char`时，Java存储其整数等效值。你可以将一个正整数值分配给`char`而不是字母，例如122。
- en: The literal value `122` is not the same as the Unicode value `\u0122`. The former
    is a decimal number and the latter is a hexadecimal number.
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面值`122`与Unicode值`\u0122`不同。前者是十进制数，后者是十六进制数。
- en: Single quotes, not double quotes, are used to assign a letter to a `char` variable.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号，而不是双引号，用于将一个字母分配给`char`变量。
- en: 'Valid identifiers:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的标识符：
- en: A valid identifier starts with a letter (a–z, upper- or lowercase), a currency
    sign, or an underscore. There is no limit to its length.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的标识符以字母（a–z，大写或小写）、货币符号或下划线开头。其长度没有限制。
- en: A valid identifier can contain digits but not in the starting place.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的标识符可以包含数字，但不能位于起始位置。
- en: A valid identifier can use the underscore and currency sign at any position
    of the identifier.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的标识符可以在标识符的任何位置使用下划线和货币符号。
- en: A valid identifier can’t have the same spelling as a Java keyword, such as `switch`.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的标识符不能与Java关键字有相同的拼写，例如`switch`。
- en: A valid identifier can’t use any special characters, including `!`, `@`, `#`,
    `%`, `^`, `&`, `*`, `(`, `)`, `'`, `:`, `;`, `[`, `/`, `\`, and `}`.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的标识符不能使用任何特殊字符，包括`!`、`@`、`#`、`%`、`^`、`&`、`*`、`(`、`)`、`'`、`:`、`;`、`[`、`/`、`\`和`}`。
- en: 'Assignment operators:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符：
- en: Assignment operators can be used to assign or reassign values to all types of
    variables.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符可以用来为所有类型的变量赋值或重新赋值。
- en: A variable can’t be assigned to an incompatible value. For example, character
    and numeric values can’t be assigned to a `boolean` variable and vice versa.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能被赋值为不兼容的值。例如，字符和数值不能赋值给`boolean`变量，反之亦然。
- en: '`+=` and `-=` are short forms of addition/subtraction and assignment.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=`和`-=`是加法/减法和赋值的简写形式。'
- en: '`+=` can be read as “first add and then assign” and `-=` can be read as “first
    subtract and then assign.”'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=`可以读作“先加后赋”，而`-=`可以读作“先减后赋”。'
- en: 'Arithmetic operators:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符：
- en: Arithmetic operators can’t be used with the `boolean` data type. Attempting
    to do so will make the code fail to compile.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符不能与`boolean`数据类型一起使用。尝试这样做将使代码无法编译。
- en: '`++` and `–-` are unary increment and decrement operators. These operators
    work with single operands.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++`和`--`是一元递增和递减运算符。这些运算符与单个操作数一起使用。'
- en: Unary operators can be used in prefix or postfix notation.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符可以用前缀或后缀表示法使用。
- en: When the unary operators `++` and `--` are used in prefix notation, the value
    of the variable increments/decrements just before the variable is used in an expression.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用一元运算符`++`和`--`的前缀表示法时，变量的值在变量在表达式中使用前立即增加/减少。
- en: When the unary operators `++` and `--` are used in postfix notation, the value
    of the variable increments/decrements just after the variable is used in an expression.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用一元运算符`++`和`--`的后缀表示法时，变量的值在变量在表达式中使用后立即增加/减少。
- en: By default, unary operators have a higher precedence than multiplication operators
    and addition operators.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，一元运算符的优先级高于乘法运算符和加法运算符。
- en: 'Relational operators:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符：
- en: Relational operators are used to compare values for equality (`==`) and inequality
    (`!=`). They’re also used to determine whether two numeric values are greater
    than (`>`, `>=`) or less than (`<`, `<=`) each other.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符用于比较值是否相等（`==`）或不相等（`!=`），还用于确定两个数值是否大于（`>`、`>=`）或小于（`<`、`<=`）对方。
- en: You can’t compare incomparable values. For example, you can’t compare a `boolean`
    with an `int`, a `char,` or a floating-point number. If you try to do so, your
    code will not compile.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能比较不可比较的值。例如，您不能比较`boolean`与`int`、`char`或浮点数。如果您尝试这样做，您的代码将无法编译。
- en: 'The operators equal to (`==`) and not equal to (`!=`) can be used to compare
    all types of primitives: `char`, `byte`, `short`, `int`, `long`, `float`, `double`,
    and `boolean`.'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于（`==`）和不等于（`!=`）运算符可以用来比较所有类型的原始数据类型：`char`、`byte`、`short`、`int`、`long`、`float`、`double`和`boolean`。
- en: The operator `==` returns `true` if the primitive values being compared are
    equal.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符`==`如果正在比较的原始值相等则返回`true`。
- en: The operator `!=` returns `true` if the primitive values being compared are
    *not* equal.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符`!=`如果正在比较的原始值不相等则返回`true`。
- en: The result of the relational operator is always a `boolean` value.
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符的结果始终是一个`布尔`值。
- en: 'Logical operators:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符：
- en: You can use the logical operators to determine whether a set of conditions is
    true or false and proceed accordingly.
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用逻辑运算符来确定一组条件是否为真或假，并据此进行操作。
- en: Logical `AND` (`&&`) evaluates to `true` if all operands are `true` and `false`
    otherwise.
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑`AND`（`&&`）如果所有操作数都是`true`则返回`true`，否则返回`false`。
- en: Logical `OR` (`||`) evaluates to `true` if any or all the operands are `true`.
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑`OR`（`||`）如果任何或所有操作数都是`true`则返回`true`。
- en: Logical negation (`!`) negates the `boolean` value. It evaluates to `true` for
    `false` and vice versa.
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑非（`!`）否定`布尔`值。对于`false`返回`true`，反之亦然。
- en: The result of a logical operation is always a `boolean` value.
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算的结果始终是一个 `boolean` 值。
- en: The logical operators `&&` and `||` are also called short-circuit operators.
    If these operators can determine the output of the expression with the evaluation
    of the first operand, they don’t evaluate the second operand.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符 `&&` 和 `||` 也被称为短路运算符。如果这些运算符可以通过评估第一个操作数来确定表达式的输出，则它们不会评估第二个操作数。
- en: The `&&` operator returns `true` only if both of the operands are `true`. If
    the first operand to this operator evaluates to `false`, the result can never
    be `true`. Therefore, `&&` does not evaluate the second operand.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当两个操作数都为 `true` 时，`&&` 运算符才返回 `true`。如果此运算符的第一个操作数评估为 `false`，则结果永远不会是 `true`。因此，`&&`
    不会评估第二个操作数。
- en: Similarly, the `||` operator returns `true` if any of the operands is `true`.
    If the first operand to this operator evaluates to `true`, the result can never
    be `false`. Therefore, `||` does not evaluate the second operator.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，如果运算符的任一操作数是 `true`，则 `||` 运算符返回 `true`。如果此运算符的第一个操作数评估为 `true`，则结果永远不会是
    `false`。因此，`||` 不会评估第二个操作数。
- en: 'Wrapper classes:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类：
- en: The wrapper classes are used to wrap primitives in an object, so they can be
    added to a collection object.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装类用于将原始值包装在对象中，因此可以将它们添加到集合对象中。
- en: All the wrapper classes are immutable.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有包装类都是不可变的。
- en: 'You can create objects of all the wrapper classes in multiple ways:'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过多种方式创建所有包装类的对象：
- en: '*Assignment*—By assigning a primitive to a wrapper class variable (autoboxing)'
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*赋值*—通过将原始值赋给包装类变量（自动装箱）'
- en: '*Constructor*—By using wrapper class constructors'
  id: totrans-715
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数*—通过使用包装类构造函数'
- en: '*Static methods*—By calling the static method of wrapper classes, like `valueOf()`'
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态方法*—通过调用包装类的静态方法，如 `valueOf()`'
- en: All wrapper classes (except `Character`) define a constructor that accepts a
    `String` argument representing the primitive value that needs to be wrapped.
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有包装类（除了 `Character`）都定义了一个接受表示需要包装的原始值的 `String` 参数的构造函数。
- en: None of the wrapper class defines a no-argument constructor.
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有包装类定义无参数构造函数。
- en: You can assign a primitive value directly to a reference variable of its wrapper
    class type, called autoboxing. The reverse is unboxing, when an object of a primitive
    wrapper class is converted to its corresponding primitive value.
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以直接将原始值赋给其包装类类型的引用变量，这称为自动装箱。相反，当原始包装类对象转换为相应的原始值时，称为拆箱。
- en: All wrapper classes define methods of the format *primitive* Value(), where
    the term *primitive* refers to the exact primitive data type name.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有包装类都定义了格式为 *primitive* Value() 的方法，其中术语 *primitive* 指的是确切的原始数据类型名称。
- en: To get a primitive data type value corresponding to a string value, you can
    use the static utility method parse*DataType*, where *DataType* refers to the
    type of the return value.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取与字符串值对应的原始数据类型值，您可以使用静态实用方法 parse*DataType*，其中 *DataType* 指的是返回值的类型。
- en: The `valueOf()` method returns an object of the corresponding wrapper class
    when it’s passed an argument of a primitive type or `String`.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递一个原始类型或 `String` 参数时，`valueOf()` 方法返回相应包装类的对象。
- en: You can compare objects of wrapper classes for equality by using the method
    `equals` or the comparison operator, `==`.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用 `equals` 方法或比较运算符 `==` 来比较包装类的对象是否相等。
- en: The method `equals` always compares the primitive value stored by a wrapper
    instance and `==` compares object references. The operator `==` returns `true`
    if the variables being compared refer to the same instance.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 `equals` 总是对比包装实例存储的原始值，而 `==` 比较对象引用。运算符 `==` 如果被比较的变量引用相同的实例，则返回 `true`。
- en: 'In the case of the `Boolean` class, the cached instances are accessible directly
    because only two exist: the static constants `Boolean.TRUE` and `Boolean.FALSE`.'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Boolean` 类的情况下，由于只有两个实例：静态常量 `Boolean.TRUE` 和 `Boolean.FALSE`，因此缓存的实例可以直接访问。
- en: The `Character` class caches instances with values from `0` to `127`. Classes
    `Byte`, `Short`, `Integer`, and `Long` cache instances for values `-128` to `127`.
    No cached instances exist for the `Float` and `Double` wrapper classes.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Character` 类缓存了值为 `0` 到 `127` 的实例。类 `Byte`、`Short`、`Integer` 和 `Long` 缓存值为
    `-128` 到 `127` 的实例。对于 `Float` 和 `Double` 包装类没有缓存的实例。'
- en: Wrapper classes are immutable. Adding a primitive value to a wrapper class variable
    doesn’t modify the value of the object it refers to. The wrapper class variable
    is assigned a new object.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装类是不可变的。将原始值添加到包装类变量不会修改它所引用的对象的值。包装类变量被分配了一个新的对象。
- en: Unboxing a wrapper reference variable, which refers to `null`, will throw a
    `NullPointerException`.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包引用包装器变量，该变量引用`null`，将抛出`NullPointerException`。
- en: 2.8\. Sample exam questions
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8. 样本考试问题
- en: '**[Q2-1.](#ch02qa2q0a1)**'
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-1.](#ch02qa2q0a1)**'
- en: ''
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ''
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output?
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出是什么？
- en: ''
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`195 20.0`'
  id: totrans-738
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`195 20.0`'
- en: '`195 20`'
  id: totrans-739
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`195 20`'
- en: '`ab 20.0`'
  id: totrans-740
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ab 20.0`'
- en: '`ab 20`'
  id: totrans-741
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ab 20`'
- en: Compilation error
  id: totrans-742
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-743
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '**[Q2-2.](#ch02qa2q0a2)**'
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-2.](#ch02qa2q0a2)**'
- en: ''
  id: totrans-745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the options are correct for the following code?
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的正确选项是哪些？
- en: ''
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ''
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code at line 4 fails to compile.
  id: totrans-750
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行4的代码编译失败。
- en: Code at line 5 fails to compile.
  id: totrans-751
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行5的代码编译失败。
- en: Code at line 6 fails to compile.
  id: totrans-752
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行6的代码编译失败。
- en: Code at line 7 fails to compile.
  id: totrans-753
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行7的代码编译失败。
- en: '**[Q2-3.](#ch02qa2q0a3)**'
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-3.](#ch02qa2q0a3)**'
- en: ''
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ''
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`611`'
  id: totrans-760
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`611`'
- en: '`641`'
  id: totrans-761
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`641`'
- en: '`930`'
  id: totrans-762
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`930`'
- en: '`960`'
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`960`'
- en: '**[Q2-4.](#ch02qa2q0a4)**'
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-4.](#ch02qa2q0a4)**'
- en: ''
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-767
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ''
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output?
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出是什么？
- en: ''
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`falsefalsefalse`'
  id: totrans-772
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`falsefalsefalse`'
- en: '`truefalsetrue`'
  id: totrans-773
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`truefalsetrue`'
- en: '`falsetruetrue`'
  id: totrans-774
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`falsetruetrue`'
- en: '`falsefalsetrue`'
  id: totrans-775
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`falsefalsetrue`'
- en: Compilation error
  id: totrans-776
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-777
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '**[Q2-5.](#ch02qa2q0a5)**'
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-5.](#ch02qa2q0a5)**'
- en: ''
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following options contain correct code to declare and initialize
    variables to store whole numbers?
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项包含正确的代码来声明和初始化存储整数的变量？
- en: ''
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`bit a = 0;`'
  id: totrans-782
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bit a = 0;`'
- en: '`integer a2 = 7;`'
  id: totrans-783
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`integer a2 = 7;`'
- en: '`long a3 = 0x10C;`'
  id: totrans-784
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`long a3 = 0x10C;`'
- en: '`short a4 = 0512;`'
  id: totrans-785
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`short a4 = 0512;`'
- en: '`double a5 = 10;`'
  id: totrans-786
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`double a5 = 10;`'
- en: '`byte a7 = -0;`'
  id: totrans-787
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`byte a7 = -0;`'
- en: '`long a8 = 123456789;`'
  id: totrans-788
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`long a8 = 123456789;`'
- en: '**[Q2-6.](#ch02qa2q0a6)**'
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-6.](#ch02qa2q0a6)**'
- en: ''
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the options that, when inserted at `// INSERT CODE HERE`, will make
    the following code output a value of `11`:'
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择在`// INSERT CODE HERE`处插入的选项，将使以下代码输出值为`11`：
- en: ''
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ''
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ctr += 1;`'
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ctr += 1;`'
- en: '`ctr =+ 1;`'
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ctr =+ 1;`'
- en: '`++ctr;`'
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`++ctr;`'
- en: '`ctr = 1;`'
  id: totrans-798
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ctr = 1;`'
- en: '**[Q2-7.](#ch02qa2q0a7)**'
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-7.](#ch02qa2q0a7)**'
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ''
  id: totrans-804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`218`'
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`218`'
- en: '`232`'
  id: totrans-806
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`232`'
- en: '`246`'
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`246`'
- en: Compilation error
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q2-8.](#ch02qa2q0a8)**'
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-8.](#ch02qa2q0a8)**'
- en: ''
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is true about the following lines of code?
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的哪些行是正确的？
- en: ''
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ''
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code prints `true`
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`true`
- en: Code prints `false`
  id: totrans-816
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`false`
- en: Code prints `90 >= false`
  id: totrans-817
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`90 >= false`
- en: Compilation error
  id: totrans-818
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q2-9.](#ch02qa2q0a9)**'
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-9.](#ch02qa2q0a9)**'
- en: ''
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct options:'
  id: totrans-821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项：
- en: ''
  id: totrans-822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ''
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code prints `false`
  id: totrans-825
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`false`
- en: Code prints `true`
  id: totrans-826
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`true`
- en: 'Code will print `true` if code on line 6 is modified to the following:'
  id: totrans-827
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将行6的代码修改为以下内容，代码将打印`true`：
- en: ''
  id: totrans-828
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-829
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ''
  id: totrans-830
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-831
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Code will print `true` if code on line 6 is modified to the following:'
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将行6的代码修改为以下内容，代码将打印`true`：
- en: ''
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**[Q2-10.](#ch02qa2q0a10)**'
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-10.](#ch02qa2q0a10)**'
- en: ''
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ''
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the result?
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果是什么？
- en: ''
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-843
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ''
  id: totrans-844
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ''
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-848
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-849
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ''
  id: totrans-850
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-851
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-852
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: 2.9\. Answers to sample exam questions
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9. 样本考试问题答案
- en: '**[Q2-1.](#ch02qa1q1)**'
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-1.](#ch02qa1q1)**'
- en: ''
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ''
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output?
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出是什么？
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`195 20.0`**'
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`195 20.0`**'
- en: '`195 20`'
  id: totrans-863
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`195 20`'
- en: '`ab 20.0`'
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ab 20.0`'
- en: '`ab 20`'
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ab 20`'
- en: Compilation error
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: ''
  id: totrans-868
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-869
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: When a `char` primitive data type is used as an operand to arithmetic
    operators, its corresponding ASCII value is used in the arithmetic operation.
    Though `(char)myChar` explicitly casts `int` variable `myChar` to `char` type,
    its value `97` is used in the arithmetic operation. When literal value `20` is
    explicitly cast to a `float` type, it outputs its value as a decimal number, that
    is, `20.0`.'
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：当使用`char`原始数据类型作为算术运算符的操作数时，其对应的ASCII值用于算术运算。尽管`(char)myChar`将`int`变量`myChar`显式转换为`char`类型，但其值`97`用于算术运算。当将字面值`20`显式转换为`float`类型时，它以十进制数的形式输出其值，即`20.0`。
- en: '**[Q2-2.](#ch02qa1q2)**'
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-2.](#ch02qa1q2)**'
- en: ''
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the options are correct for the following code?
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的正确选项是哪些？
- en: ''
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ''
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Code at line 4 fails to compile.**'
  id: totrans-878
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行4的代码编译失败。**'
- en: Code at line 5 fails to compile.
  id: totrans-879
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行5的代码编译失败。
- en: '**Code at line 6 fails to compile.**'
  id: totrans-880
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行6的代码编译失败。**'
- en: '**Code at line 7 fails to compile.**'
  id: totrans-881
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行7的代码编译失败。**'
- en: ''
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, c, d'
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, c, d
- en: ''
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is correct. The code at line 4 fails to compile because
    you can’t assign a negative value to a primitive `char` data type without casting.'
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项(a)是正确的。行4的代码编译失败，因为你不能在不进行类型转换的情况下将负值赋给原始`char`数据类型。
- en: ''
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is correct. There is no primitive data type with the name “integer.”
    The valid data types are `int` and `Integer` (a wrapper class with *I* in uppercase).
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(c)是正确的。没有名为“integer”的原始数据类型。有效的数据类型是`int`和`Integer`（一个以大写*I*为特征的包装类）。
- en: ''
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is correct. The variable `d` remains undefined on line 7 because
    its declaration fails to compile on line 6\. So the arithmetic expression `(++a
    + b++ * c - d)` that uses variable `d` fails to compile. There are no issues with
    using the variable `c` of the `char` data type in an arithmetic expression. The
    `char` data types are internally stored as unsigned integer values and can be
    used in arithmetic expressions.
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的。变量 `d` 在第 7 行未定义，因为它的声明在第 6 行未能编译。因此，使用变量 `d` 的算术表达式 `(++a + b++
    * c - d)` 未能编译。在算术表达式中使用 `char` 数据类型的变量 `c` 没有问题。`char` 数据类型在内部存储为无符号整数值，可以在算术表达式中使用。
- en: '**[Q2-3.](#ch02qa1q3)**'
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-3.](#ch02qa1q3)**'
- en: ''
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-894
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`611`**'
  id: totrans-896
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`611`**'
- en: '`641`'
  id: totrans-897
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`641`'
- en: '`930`'
  id: totrans-898
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`930`'
- en: '`960`'
  id: totrans-899
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`960`'
- en: ''
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The prefix increment operator (`++`) used with the variable `a`
    will increment its value before it’s used in the expression `++a + b++ * c`. The
    postfix increment operator (`++`) used with the variable `b` will increment its
    value after its initial value is used in the expression `++a + b++ * c`.'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：与变量 `a` 一起使用的前缀增量运算符 (`++`) 将在它被用于表达式 `++a + b++ * c` 之前增加其值。与变量 `b` 一起使用的后缀增量运算符
    (`++`) 将在表达式 `++a + b++ * c` 使用其初始值之后增加其值。
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Therefore, the expression `++a + b++ * c` evaluates with the following values:'
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，表达式 `++a + b++ * c` 使用以下值进行评估：
- en: ''
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Because the multiplication operator has a higher precedence than the addition
    operator, the values `20` and `30` are multiplied before the result is added to
    the value `11`. The example expression evaluates as follows:'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为乘法运算符的优先级高于加法运算符，所以 `20` 和 `30` 的值在将结果加到值 `11` 之前被相乘。示例表达式评估如下：
- en: ''
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ''
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exam Tip
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: ''
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although questions 2-2 and 2-3 seemed to test you on your understanding of operators,
    they actually tested you on different topics. Question 2-2 tested you on the name
    of the primitive data types. Beware! The real exam has many such questions. A
    question that may seem to test you on threads may actually be testing you on the
    use of a `do`-`while` loop!
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然问题 2-2 和 2-3 似乎是在测试你对运算符的理解，但实际上它们测试的是不同的主题。问题 2-2 测试的是原始数据类型的名称。注意！真正的考试有很多这样的问题。一个可能看起来是在测试你对线程的理解的问题，实际上可能是在测试你使用
    `do`-`while` 循环的能力！
- en: ''
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  |'
- en: '**[Q2-4.](#ch02qa1q4)**'
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-4.](#ch02qa1q4)**'
- en: ''
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output?
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出是什么？
- en: ''
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`falsefalsefalse`'
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`falsefalsefalse`'
- en: '`truefalsetrue`'
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`truefalsetrue`'
- en: '`falsetruetrue`'
  id: totrans-928
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`falsetruetrue`'
- en: '**`falsefalsetrue`**'
  id: totrans-929
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`falsefalsetrue`**'
- en: Compilation error
  id: totrans-930
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: ''
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The `Boolean` instances `buy` and `sell` are created using constructors.
    Constructors don’t refer to existing instances in cache; they create new instances.
    Because the comparison operator `==` compares object references and not the primitive
    value stored by a wrapper instance, `buy == sell` returns `false`.'
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：使用构造函数创建的 `Boolean` 实例 `buy` 和 `sell`。构造函数不引用缓存中的现有实例；它们创建新的实例。因为比较运算符 `==`
    比较的是对象引用，而不是包装实例存储的基本值，所以 `buy == sell` 返回 `false`。
- en: ''
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The method `booleanValue()` can be used to get the primitive `boolean` value
    stored by a Boolean wrapper instance. So `buy.booleanValue()` returns `false`.
    Because wrapper instances can be used with arithmetic and logical operators, `buy
    && sell` compiles, returning `true`.
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以使用 `booleanValue()` 方法来获取由布尔包装实例存储的基本 `boolean` 值。因此，`buy.booleanValue()`
    返回 `false`。因为包装实例可以与算术和逻辑运算符一起使用，所以 `buy && sell` 可以编译，返回 `true`。
- en: '**[Q2-5.](#ch02qa1q5)**'
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-5.](#ch02qa1q5)**'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following options contain correct code to declare and initialize
    variables to store whole numbers?
  id: totrans-940
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项包含正确代码来声明和初始化存储整数的变量？
- en: ''
  id: totrans-941
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`bit a = 0;`'
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bit a = 0;`'
- en: '`integer a2 = 7;`'
  id: totrans-943
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`integer a2 = 7;`'
- en: '**`long a3 = 0x10C;`**'
  id: totrans-944
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`long a3 = 0x10C;`**'
- en: '**`short a4 = 0512;`**'
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`short a4 = 0512;`**'
- en: '`double a5 = 10;`'
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`double a5 = 10;`'
- en: '**`byte a7 = -0;`**'
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`byte a7 = -0;`**'
- en: '**`long a8 = 123456789;`**'
  id: totrans-948
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`long a8 = 123456789;`**'
- en: ''
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c, d, f, g'
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c, d, f, g
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Options (a) and (b) are incorrect. There are no primitive data
    types in Java with the names `bit` and `integer`. The correct names are `byte`
    and `int`.'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项 (a) 和 (b) 是错误的。Java 中没有名为 `bit` 和 `integer` 的原始数据类型。正确的名称是 `byte` 和 `int`。
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is correct. It assigns a hexadecimal literal value to the variable
    `a3`.
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是正确的。它将十六进制字面值赋给变量 `a3`。
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is correct. It assigns an octal literal value to the variable `a4`.
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的。它将八进制字面值赋给变量 `a4`。
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) is incorrect. It defines a variable of type `double`, which is used
    to store decimal numbers, not integers.
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（e）是错误的。它定义了一个类型为`double`的变量，用于存储小数，而不是整数。
- en: ''
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (f) is correct. `-0` is a valid literal value.
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（f）是正确的。`-0`是一个有效的字面量值。
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (g) is correct. `123456789` is a valid integer literal value that can
    be assigned to a variable of type `long`.
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（g）是正确的。`123456789`是一个有效的整数字面量值，可以被赋给类型为`long`的变量。
- en: '**[Q2-6.](#ch02qa1q6)**'
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-6.](#ch02qa1q6)**'
- en: ''
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the options that, when inserted at `// INSERT CODE HERE`, will make
    the following code output a value of `11`:'
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择在`// INSERT CODE HERE`处插入的选项，以使以下代码输出值为`11`：
- en: ''
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ''
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`ctr += 1;`**'
  id: totrans-969
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ctr += 1;`**'
- en: '`ctr =+ 1;`'
  id: totrans-970
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ctr =+ 1;`'
- en: '**`++ctr;`**'
  id: totrans-971
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`++ctr;`**'
- en: '`ctr = 1;`'
  id: totrans-972
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ctr = 1;`'
- en: ''
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, c'
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, c
- en: ''
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: To output a value of `11`, the value of the variable `ctr` should
    be `51` because `51%20` is `11`. Operator `%` outputs the remainder from a division
    operation. The current value of the variable `ctr` is `50`. It can be incremented
    by `1` using the correct assignment or increment operator.'
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：为了输出`11`的值，变量`ctr`的值应该是`51`，因为`51%20`是`11`。运算符`%`输出除法操作的余数。变量`ctr`的当前值是`50`。可以使用正确的赋值或增量运算符将其增加`1`。
- en: ''
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is incorrect. Java does not define a `=+` operator. The correct operator
    is `+=`.
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（b）是错误的。Java没有定义`=+`运算符。正确的运算符是`+=`。
- en: ''
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is incorrect because it’s assigning a value of `1` to the variable
    `result`, not incrementing it by `1`.
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（d）是错误的，因为它将变量`result`的值赋为`1`，而不是将其增加`1`。
- en: '**[Q2-7.](#ch02qa1q7)**'
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-7.](#ch02qa1q7)**'
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ''
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`218`'
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`218`'
- en: '`232`'
  id: totrans-988
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`232`'
- en: '`246`'
  id: totrans-989
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`246`'
- en: '**Compilation error**'
  id: totrans-990
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译错误**'
- en: ''
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: First of all, whenever you answer any question that uses parentheses
    to override operator precedence, check whether the number of opening parentheses
    matches the number of closing parentheses. This code won’t compile because the
    number of opening parentheses doesn’t match the number of closing parentheses.'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：首先，每次回答任何使用括号来覆盖运算符优先级的题目时，检查开括号的数量是否与闭括号的数量匹配。这段代码将无法编译，因为开括号的数量不匹配闭括号的数量。
- en: ''
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Second, you may not have to answer complex expressions in the real exam. Whenever
    you see overly complex code, look for other possible issues in the code. Complex
    code may be used to distract your attention from the real issue.
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其次，你可能不需要在真正的考试中回答复杂的表达式。每次看到过于复杂的代码时，都要寻找代码中的其他可能问题。复杂的代码可能被用来分散你的注意力，从而掩盖真正的问题。
- en: '**[Q2-8.](#ch02qa1q8)**'
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-8.](#ch02qa1q8)**'
- en: ''
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is true about the following lines of code?
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码行有什么正确之处？
- en: ''
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ''
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code prints `true`
  id: totrans-1003
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`true`
- en: Code prints `false`
  id: totrans-1004
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`false`
- en: Code prints `90 >= false`
  id: totrans-1005
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`90 >= false`
- en: '**Compilation error**'
  id: totrans-1006
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译错误**'
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The code will fail to compile; hence, it can’t execute. You can’t
    compare incomparable types, such as a `boolean` value with a number.'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：这段代码将无法编译；因此，它无法执行。你不能比较不可比较的类型，例如`boolean`值与数字。
- en: '**[Q2-9.](#ch02qa1q9)**'
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-9.](#ch02qa1q9)**'
- en: ''
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct options:'
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项：
- en: ''
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ''
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code prints `false`
  id: totrans-1017
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印`false`
- en: '**Code prints `true`**'
  id: totrans-1018
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码打印`true`**'
- en: '**Code will print `true` if code on line 6 is modified to the following:**'
  id: totrans-1019
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果将第6行的代码修改为以下内容，代码将打印`true`：**'
- en: ''
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Code will print `true` if code on line 6 is modified to the following:'
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将第6行的代码修改为以下内容，代码将打印`true`：
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b, c'
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b, c
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is incorrect because the code prints `true`.'
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项（a）是错误的，因为代码打印`true`。
- en: ''
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is incorrect because the code prints `false`.
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（d）是错误的，因为代码打印`false`。
- en: ''
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The code in option (c) uses parentheses to indicate which expression should
    evaluate prior to the rest. Here are the steps of execution:'
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（c）中的代码使用括号来指示哪个表达式应该先于其他表达式评估。以下是执行步骤：
- en: ''
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ''
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The original code in the question doesn’t use parentheses to group the expressions.
    In this case, because the operator `&&` has a higher operator precedence than
    `||`, the expression `''num1 >= 12 && num2 < 4.567''` will be the first expression
    to execute. Here are the steps of execution:'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 题目中的原始代码没有使用括号来分组表达式。在这种情况下，因为运算符`&&`的优先级高于`||`，表达式`'num1 >= 12 && num2 < 4.567'`将是首先执行的表达式。以下是执行步骤：
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**[Q2-10.](#ch02qa1q10)**'
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q2-10.](#ch02qa1q10)**'
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ''
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the result?
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果是什么？
- en: ''
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1051
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ''
  id: totrans-1052
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1053
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 10.0 **false** **false**
  id: totrans-1054
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10.0 **false** **false**
- en: '[PRE58]'
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1057
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-1058
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译错误**'
- en: ''
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The expression `myBool = false` uses the assignment operator (`=`)
    and not a comparison operator (`==`). This expression assigns the `boolean` literal
    `false` to `myBool`; it doesn’t compare `false` with `myBool`. Watch out for similar
    (trick) assignments in the exam, which may *seem* to be comparing values.'
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：表达式 `myBool = false` 使用的是赋值运算符（`=`），而不是比较运算符（`==`）。这个表达式将布尔字面量 `false` 赋值给
    `myBool`；它并不是在比较 `false` 和 `myBool`。在考试中要留意类似的（技巧性）赋值，它们可能 *看起来* 是在比较值。
