- en: Appendix E. Memory management in Java apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录E. Java应用程序中的内存管理
- en: In this appendix, we discuss how the Java Virtual Machine (JVM) manages the
    memory of a Java app. Some of the most challenging problems you’ll have to investigate
    in Java apps are related to the way the apps manage memory. Fortunately, we can
    use several techniques to analyze such problems and find their root causes, with
    minimal time invested. But to benefit from those techniques, you first need to
    know at least some basics about how a Java app manages its memory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们讨论了Java虚拟机（JVM）如何管理Java应用程序的内存。您在Java应用程序中可能遇到的一些最具挑战性的问题都与应用程序管理内存的方式有关。幸运的是，我们可以使用几种技术来分析这些问题并找到其根本原因，而无需投入大量时间。但是，为了从这些技术中受益，您首先至少需要了解一些关于Java应用程序如何管理其内存的基本知识。
- en: An app’s memory is a limited resource. Even if today’s systems can offer a large
    amount of memory for an app to use during its execution, we still need to be careful
    with how an app spends this resource. No system can offer unlimited memory as
    a magical solution (figure E.1). Memory issues lead to performance problems (the
    app becomes slow, it’s more costly to deploy, it starts more slowly, etc.) and
    sometimes can even bring the entire process to a complete stop (e.g., in the case
    of an `OutOfMemoryError`).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的内存是一种有限的资源。即使今天的系统可以为应用程序在执行期间提供大量内存，我们仍然需要小心地对待应用程序如何使用这种资源。没有系统可以提供无限的内存作为魔法解决方案（图E.1）。内存问题会导致性能问题（应用程序变慢，部署成本更高，启动速度变慢等），有时甚至可以将整个进程完全停止（例如，在`OutOfMemoryError`的情况下）。
- en: '![](../../OEBPS/Images/APPE_F01_Spilca3.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPE_F01_Spilca3.png)'
- en: Figure E.1 An app’s memory is a limited resource. There’s no magical solution
    that allows us to allocate infinite memory to an app. When building apps, we need
    to treat memory consumption with consideration and avoid spending it for no reason.
    Apps may sometimes have memory issues. If a certain capability uses too much memory,
    it can cause performance problems or even a complete failure. You need to be ready
    to find the causes of such issues and solve them properly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.1 应用程序的内存是一种有限的资源。没有魔法解决方案可以让我们为应用程序分配无限的内存。在构建应用程序时，我们需要谨慎对待内存消耗，避免无端浪费。应用程序有时可能会出现内存问题。如果某个功能使用过多的内存，它可能会引起性能问题，甚至导致完全失败。您需要准备好找到这些问题的原因并妥善解决它们。
- en: 'We’ll cover the essential aspects of memory management. In section E.1, we’ll
    discuss how the JVM organizes the memory for an executing process. You’ll learn
    about three ways of allocating the app’s memory: the stack, the heap, and the
    metaspace. In section E.2, we’ll discuss the stack, the memory space a thread
    uses to store locally declared variables and their data. Section E.3 discusses
    the heap and the way an app stores object instances in memory. We’ll end our discussion
    in section E.4 with the metaspace, a memory location where an app stores the object
    types’ metadata.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖内存管理的必要方面。在第E.1节中，我们将讨论JVM如何为执行进程组织内存。您将了解三种分配应用程序内存的方式：栈、堆和元空间。在第E.2节中，我们将讨论栈，这是线程用于存储局部声明的变量及其数据的空间。第E.3节讨论堆以及应用程序在内存中存储对象实例的方式。我们的讨论将在第E.4节结束，涉及元空间，这是应用程序存储对象类型元数据的位置。
- en: Be aware that a Java app’s memory management is complex. In this appendix, I’ll
    present only the details you need to understand the discussions you’ll find throughout
    the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Java应用程序的内存管理是复杂的。在本附录中，我将仅介绍您需要了解以理解书中所讨论内容的细节。
- en: E.1 How the JVM organizes an app’s memory
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.1 JVM如何组织应用程序的内存
- en: In this section, we’ll discuss how the JVM organizes data in different memory
    locations, which are each managed differently. Understanding how the JVM manages
    memory is essential for investigating issues related to memory. We’ll use some
    visuals to discuss the main aspects related to memory management, and you’ll learn
    which data goes where in a Java app’s memory. Then, we’ll detail the memory management
    in each memory location.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论JVM如何在不同内存位置组织数据，这些位置分别以不同的方式管理。理解JVM如何管理内存对于调查与内存相关的问题至关重要。我们将使用一些视觉元素来讨论与内存管理相关的关键方面，您将了解在Java应用程序的内存中哪些数据存储在哪里。然后，我们将详细说明每个内存位置的内存管理。
- en: 'For the moment (to simplify the discussion), let’s assume that a Java app has
    two ways to manage the data it stores during its execution: the stack and the
    heap. Depending on how the data is defined, the app will manage it in either the
    stack or the heap. But before discussing which data goes where, remember one essential
    detail: an app has more than one thread, allowing it to concurrently process data.
    The heap is a singular memory location, and all the app’s threads use it. However,
    each thread has its own memory location, called a *stack*. This can create confusion
    when developers first learn about memory management. Figure E.2 presents these
    details visually.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前（为了简化讨论），让我们假设一个Java应用程序在执行过程中管理其存储的数据有两种方式：栈和堆。根据数据的定义方式，应用程序将分别在栈或堆中管理它。但在讨论哪些数据放在哪里之前，请记住一个基本细节：应用程序有多个线程，允许它并发处理数据。堆是一个单独的内存位置，应用程序的所有线程都使用它。然而，每个线程都有自己的内存位置，称为栈。这可能会在开发者第一次学习内存管理时造成困惑。图E.2以视觉方式展示了这些细节。
- en: '![](../../OEBPS/Images/APPE_F02_Spilca3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPE_F02_Spilca3.png)'
- en: Figure E.2 T1, T2, and T3 are all threads of a Java app. All these threads use
    the same heap. The heap is a memory location where the app stores object instances’
    data. However, each thread uses its own memory location, called a stack, to store
    data locally declared.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.2 T1、T2和T3都是Java应用程序的线程。所有这些线程使用相同的堆。堆是应用程序存储对象实例数据的内存位置。然而，每个线程都使用自己的内存位置，称为栈，来存储局部声明的数据。
- en: 'The stack is a memory location owned by a thread. Each thread owns a particular
    stack that is not shared with other threads. The thread stores any data locally
    declared in a block of code and executed by that thread in this memory location.
    Say you have a method like the one presented in the next code snippet. The parameters
    `x` and `y` and the variable `sum`, declared inside the method’s code block, are
    local variables. These values will be stored in the thread’s stack when the method
    executes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是线程拥有的内存位置。每个线程都拥有一个特定的栈，该栈不与其他线程共享。线程将任何在代码块中局部声明的数据存储在这个内存位置，并由该线程执行。假设你有一个像下面代码片段中展示的方法。参数`x`和`y`以及方法代码块内声明的变量`sum`都是局部变量。当方法执行时，这些值将存储在线程的栈中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Variables x, y, and sum will be stored in the stack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 变量x、y和sum将存储在栈中。
- en: 'The heap is a memory location where the app stores object instances’ data.
    Suppose your app declares a class, `Cat`, such as the one shown in the next code
    snippet. Any time you create an instance using the class’s constructor, `new Cat()`,
    the instance goes to the heap:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是应用程序存储对象实例数据的内存位置。假设你的应用程序声明了一个类，例如下面代码片段中展示的`Cat`类。每次你使用类的构造函数`new Cat()`创建实例时，该实例都会进入堆：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the class declares instance attributes, the JVM stores these values in the
    heap too. For example, if the `Cat` class looks like the one in the next code
    snippet, the JVM will store the name and age of each instance in the heap:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类声明了实例属性，JVM也会将这些值存储在堆中。例如，如果`Cat`类看起来像下面代码片段中展示的那样，JVM将存储每个实例的名称和年龄在堆中：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The object’s attributes are stored in the heap.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对象的属性存储在堆中。
- en: Figure E.3 visually presents an example of data allocation. Notice that the
    locally declared variables and their values (`x` and `c`) are stored in the thread’s
    stack, while the `Cat` instance and its data go in the app’s heap. A reference
    to the `Cat` instance will be stored in the thread’s stack in variable `c`. Even
    the method’s parameter that stores a reference to a `String` array will be part
    of the stack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.3以视觉方式展示了一个数据分配的例子。注意，局部声明的变量及其值（`x`和`c`）存储在线程的栈中，而`Cat`实例及其数据存储在应用程序的堆中。`Cat`实例的引用将存储在变量`c`的线程栈中。甚至存储`String`数组引用的方法参数也将成为栈的一部分。
- en: '![](../../OEBPS/Images/APPE_F03_Spilca3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPE_F03_Spilca3.png)'
- en: Figure E.3 The app reserves the locally declared variables in the thread’s stack
    and the data defining an object instance in the heap. A variable in one thread’s
    stack may refer to an object in the heap. In this example, variable `x`, holding
    value 10, and variable `c`, holding the reference to the `Cat` instance, are part
    of the thread’s stack.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.3 应用程序在线程的栈中保留局部声明的变量，以及在堆中定义的对象实例的数据。一个线程栈中的变量可能指向堆中的对象。在这个例子中，变量`x`持有值10，变量`c`持有`Cat`实例的引用，它们都是线程栈的一部分。
- en: E.2 The stack used by threads to store local data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.2 线程用于存储局部数据的栈
- en: In this section, we’ll analyze the mechanics behind the stack in more depth.
    In section E.1, you learned that local values are stored in a stack and that each
    thread has its own stack location. Let’s find out now how these values are stored
    and when the app removes them from memory. We’ll use visuals to describe this
    process step by step with a short code example. Once we clarify the mechanics
    behind the stack’s memory management, we’ll discuss what could go wrong and cause
    problems related to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地分析栈背后的机制。在E.1节中，你了解到局部变量存储在栈中，并且每个线程都有自己的栈位置。现在让我们弄清楚这些值是如何存储的，以及应用何时从内存中移除它们。我们将通过一个简短的代码示例逐步使用视觉描述这个过程。一旦我们阐明了栈内存管理的机制，我们将讨论可能出错的地方以及与之相关的问题。
- en: First, why is this memory location called “a stack”? A thread’s stack uses the
    principles of a stack data structure. A *stack* is an ordered collection in which
    you can always remove the most recently added element. We usually visualize such
    a collection as a stack of layers, where each layer is stored above another. You
    can only add a new layer on top of all the existing ones, and you can only remove
    the top layer. This method of adding and removing elements is also called *last
    in, first out* (LIFO). Figure E.4 demonstrates how a stack works with a series
    of add-and-remove steps. To make the example simpler, numbers are the values in
    the stack.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么这个内存位置被称为“栈”？线程的栈使用栈数据结构的原则。*栈*是一个有序集合，其中你可以始终移除最近添加的元素。我们通常将此类集合可视化为一层层的堆叠，其中每一层都存储在另一层之上。你只能将新层添加到所有现有层之上，并且你只能移除顶层。这种添加和移除元素的方法也称为*后进先出*（LIFO）。图E.4通过一系列添加和移除步骤演示了栈是如何工作的。为了使示例更简单，数字是栈中的值。
- en: '![](../../OEBPS/Images/APPE_F04_Spilca3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPE_F04_Spilca3.png)'
- en: Figure E.4 Adding and removing values from a stack. The stack is an ordered
    collection working on the LIFO principle. When you add a value to the stack it
    becomes the top layer—the only one you can remove.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.4展示了如何向栈中添加和移除值。栈是一个按顺序排列的集合，遵循后进先出（LIFO）原则。当你向栈中添加一个值时，它成为顶层——唯一可以移除的层。
- en: 'You will recognize the same behavior in how the app manages the data in a thread’s
    stack. Whenever the execution reaches the start of a code block, it creates a
    new layer in the thread stack. Following a common stack principle, any new layer
    becomes the top layer and is the first to be removed. In figures E.5, E.6, E.7,
    and E.8, we follow the execution of a simple code snippet step by step to observe
    how the thread’s stack changes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在应用如何管理线程栈中的数据时认识到相同的行为。每当执行达到代码块的开头时，它就会在线程栈中创建一个新的层。遵循常见的栈原则，任何新的层都成为顶层，并且是第一个被移除的。在图E.5、E.6、E.7和E.8中，我们逐步跟踪一个简单代码片段的执行，以观察线程栈是如何变化的：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The execution starts with the `main()` method (figure E.5). When the execution
    reaches the start of the `main()` method, the first layer is added to the thread’s
    stack. This layer is a memory location where every local value declared in the
    code block is stored. In this case, the code block declares a variable, `x`, and
    initializes the variable with the value `10`. This variable will be stored in
    this newly created layer of the thread’s stack. This layer will be removed from
    the stack when the method ends its execution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行从`main()`方法开始（图E.5）。当执行达到`main()`方法的开始时，第一个层被添加到线程的栈中。这个层是一个内存位置，其中存储了代码块中声明的所有局部变量。在这种情况下，代码块声明了一个变量`x`，并用值`10`初始化该变量。这个变量将存储在这个新创建的线程栈层中。当方法结束执行时，这个层将从栈中移除。
- en: '![](../../OEBPS/Images/APPE_F05_Spilca3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPE_F05_Spilca3.png)'
- en: Figure E.5 When the execution reaches the start of a block of code, a new layer
    is created in the thread’s stack. All the variables the block of code defines
    are stored in this new layer. The layer is removed when the block of code ends.
    This way, we know that the values in this part of the memory are released when
    they’re no longer needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.5展示了当执行达到代码块的开头时，在线程的栈中创建了一个新的层。代码块定义的所有变量都存储在这个新层中。当代码块结束时，这个层将被移除。这样，我们知道当这部分内存不再需要时，其中的值就会被释放。
- en: A code block can call other code blocks. For example, in this case, method `main()`
    calls methods `a()` and `b()`, which work similarly. When the execution reaches
    the start of their blocks of code, a new layer is added to the stack. That new
    layer is the memory location where all the data that is declared local is stored.
    Figure E.6 shows what happens when the execution reaches method `a()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块可以调用其他代码块。例如，在这种情况下，方法 `main()` 调用方法 `a()` 和 `b()`，它们的工作方式类似。当执行到达它们代码块的开头时，栈中会添加一个新的层。这个新层是存储所有声明为局部数据的内存位置。图
    E.6 展示了执行到达方法 `a()` 时发生的情况。
- en: '![](../../OEBPS/Images/APPE_F06_Spilca3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 E.7](../../OEBPS/Images/APPE_F06_Spilca3.png)'
- en: Figure E.6 Another block of code can be called from one in execution. In this
    case, method `main()` calls method `a()`. Since `main()` didn’t finish, its layer
    is still part of the stack. Method `a()` creates its own layer where the local
    values it defines are stored.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.6 另一个代码块可以从正在执行的代码块中调用。在这种情况下，方法 `main()` 调用方法 `a()`。由于 `main()` 没有完成，其层仍然是栈的一部分。方法
    `a()` 创建自己的层，其中存储它定义的局部值。
- en: When method `a()` ends its execution and returns to `main()`, the layer reserved
    in the thread’s stack is also removed (figure E.7)—meaning the data it stored
    is no longer in the memory. This way, the memory that is not needed is deallocated
    to allow space for new data to be stored. A code block ends when the execution
    reaches its last instruction, gives a `return` instruction, or throws an exception.
    Notice that when a code block ends, its layer is always the top one in the stack,
    fulfilling the LIFO principle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法 `a()` 结束执行并返回到 `main()` 时，线程栈中预留的层也被移除（图 E.7）——这意味着它存储的数据不再在内存中。这样，不再需要的内存被释放，为新数据存储腾出空间。代码块在执行到达其最后一条指令、给出
    `return` 指令或抛出异常时结束。请注意，当代码块结束时，其层总是栈顶的，符合后进先出（LIFO）原则。
- en: '![](../../OEBPS/Images/APPE_F07_Spilca3.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 E.8](../../OEBPS/Images/APPE_F07_Spilca3.png)'
- en: Figure E.7 When the execution reaches the end of a block of code, the stack
    layer opened for that block is removed with all the data it contains. In this
    case, when method `a()` returns, its stack layer is removed. This way, we make
    sure the unneeded data is removed from the memory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.7 当执行到达代码块末尾时，为该代码块打开的栈层及其包含的所有数据将被移除。在这种情况下，当方法 `a()` 返回时，其栈层被移除。这样，我们确保不再需要的数据从内存中移除。
- en: Method `main()` continues its execution by calling method `b()`. Just like method
    `a()` did, method `b()`reserves a new layer in the stack to store the local data
    it declares (figure E.8).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `main()` 通过调用方法 `b()` 继续执行。就像方法 `a()` 所做的那样，方法 `b()` 在栈中预留一个新的层来存储它声明的局部数据（图
    E.8）。
- en: '![](../../OEBPS/Images/APPE_F08_Spilca3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 E.8](../../OEBPS/Images/APPE_F08_Spilca3.png)'
- en: Figure E.8 Just like with method `a()`, when method `b()` is called and the
    execution reaches the start of its block of code, a new layer is added to the
    stack. The method can use this layer to store local data until the method returns
    and the layer is removed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.8 就像方法 `a()` 一样，当调用方法 `b()` 并且执行到达其代码块的开头时，栈中会添加一个新的层。该方法可以使用这个层来存储局部数据，直到方法返回并且层被移除。
- en: When method `main()`finally reaches its end, the thread ends its execution,
    and the stack remains empty and is completely removed. At the same time, the thread
    goes into the dead state of its life cycle, as described in appendix D.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法 `main()` 最终到达其末尾时，线程结束执行，栈保持为空并且被完全移除。同时，线程进入其生命周期中描述的死亡状态，如附录 D 所述。
- en: 'The stack has a default memory space allocated. You can find the precise values
    depending on the JVM you use here: [http://mng.bz/JVYp](http://mng.bz/JVYp). This
    limit can also be adjusted, but you wouldn’t be able to make it infinite. A common
    issue with the stack is the `StackOverflowError`, which means a stack is filled
    completely, and no more layers can be added. When this happens, the code throws
    a `StackOverflowError`, and the thread whose stack became full stops completely.
    A recursion (or recursive implementation), a method that calls itself until a
    given condition is filled, with a wrong stop condition usually causes such a problem.
    If this condition is missing or allows the method to call itself too many times,
    the stack may get filled with the layers the method creates every time it begins
    its execution. Figure E.9 visually presents the stack created by an infinite recursion
    caused by two methods that call one another.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 栈有一个默认的内存空间分配。您可以根据使用的 JVM 在这里找到精确的值：[http://mng.bz/JVYp](http://mng.bz/JVYp)。此限制也可以调整，但您无法将其设置为无限。栈的一个常见问题是
    `StackOverflowError`，这意味着栈已完全填满，无法添加更多层。当发生这种情况时，代码会抛出 `StackOverflowError`，并且栈已满的线程会完全停止。一个递归（或递归实现），一个在给定条件满足之前不断调用自身的函数，如果停止条件错误通常会导致此类问题。如果这个条件缺失或允许方法调用自身太多次数，栈可能会被方法在每次执行开始时创建的层填满。图
    E.9 以视觉方式展示了由两个相互调用的方法引起的无限递归创建的栈。
- en: '![](../../OEBPS/Images/APPE_F09_Spilca3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPE_F09_Spilca3.png)'
- en: Figure E.9 Every new execution of a method creates a new layer in the stack.
    In case of a recursion, a method may fill the stack if it’s called too many times.
    When the stack gets full, the app throws a `StackOverflowError`, and the current
    thread stops.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.9 每次方法的新执行都会在栈中创建一个新的层。在递归的情况下，如果方法被调用太多次数，它可能会填满栈。当栈满时，应用程序会抛出 `StackOverflowError`，并且当前线程会停止。
- en: Since each thread has its own stack, a `StackOverflowError` affects only the
    thread whose stack becomes full. The process can continue its execution, and other
    threads will not be affected. Also, a `StackOverflowError` produces a stack trace,
    which you can use to identify the code that caused the problem. Figure E.10 shows
    an example of what this type of stack trace looks like. You can use project da-app-e-ex1
    provided with the book to replicate this stack trace.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个线程都有自己的栈，`StackOverflowError` 只会影响栈已满的线程。进程可以继续执行，其他线程不会受到影响。此外，`StackOverflowError`
    生成堆栈跟踪，您可以使用它来识别导致问题的代码。图 E.10 展示了此类堆栈跟踪的示例。您可以使用书中提供的项目 da-app-e-ex1 来复制此堆栈跟踪。
- en: '![](../../OEBPS/Images/APPE_F10_Spilca3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPE_F10_Spilca3.png)'
- en: Figure E.10 The stack trace caused by a `StackOverflowError`. Usually, a `StackOverflowError`
    is easy to identify. The stack trace shows a method calling itself repeatedly
    or a group of methods that call each other, as in this example. You can go directly
    to these methods to figure out how they started infinitely calling each other.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.10 由 `StackOverflowError` 引起的堆栈跟踪。通常，`StackOverflowError` 很容易识别。堆栈跟踪显示了方法反复调用自身或一组相互调用的方法，就像这个例子一样。您可以直接进入这些方法，找出它们是如何无限期地相互调用的。
- en: E.3 The heap the app uses to store object instances
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.3 应用程序使用的堆来存储对象实例
- en: 'In this section, we’ll discuss the heap: a memory location shared by all threads
    of a Java app. The heap stores object instance data. As you’ll see in this section,
    the heap causes problems more often than the stack does. Also, the root causes
    of heap-related issues are more challenging to find. We’ll analyze how objects
    are stored in the heap and who can keep references to them, which is relevant
    to understanding when they can be removed from the memory. Further, we’ll discuss
    the main causes of issues related to the heap. You need to know this information
    to understand the investigation techniques discussed in chapters 7 to 9.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论堆：Java 应用程序中所有线程共享的内存位置。堆存储对象实例数据。正如您在本节中将要看到的，堆比堆栈更容易引起问题。此外，堆相关问题的根本原因更难以找到。我们将分析对象在堆中的存储方式以及谁可以保留对它们的引用，这对于理解它们何时可以从内存中移除是相关的。此外，我们还将讨论与堆相关的问题的主要原因。您需要了解这些信息，以便理解第
    7 章到第 9 章中讨论的调查技术。
- en: Note The heap has a complex structure. We won’t discuss all the heap details
    since you won’t immediately need them. We also won’t discuss details such as the
    string pool or heap generations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：堆具有复杂结构。由于您不会立即需要所有这些细节，我们不会讨论所有堆的细节。我们也不会讨论字符串池或堆代际等细节。
- en: The first thing you need to remember about the heap is that it’s a memory location
    shared by all the threads (figure E.11). Not only does this allow for thread-related
    issues such as race conditions to happen (discussed in appendix D), but it also
    makes memory issues more challenging to investigate. Since all the threads add
    the object instances they create in the same memory location, one thread may impact
    the execution of others. If one thread suffers from a memory leak (which means
    it adds instances in the memory but never removes them), it affects the whole
    process because other threads will also suffer from the lack of memory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住关于堆的第一件事是，它是由所有线程共享的内存位置（图 E.11）。这不仅允许线程相关的问题，如竞态条件发生（在附录 D 中讨论），而且还使得内存问题更难以调查。由于所有线程都在相同的内存位置添加它们创建的对象实例，一个线程可能会影响其他线程的执行。如果一个线程遭受内存泄漏（这意味着它在内存中添加实例但从未移除它们），它会影响整个进程，因为其他线程也会因为内存不足而受到影响。
- en: '![](../../OEBPS/Images/APPE_F11_Spilca3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPE_F11_Spilca3.png)'
- en: Figure E.11 All threads use the same heap location. If one of the threads has
    an issue that causes the heap to become full (memory leak), another thread may
    signal the problem. This scenario happens quite often because the problem will
    be reported by the first thread unable to store data in the heap. Because any
    thread can signal the problem and it’s not necessarily the one causing the problem,
    heap-related issues are more challenging to solve.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.11 所有线程使用相同的堆位置。如果一个线程由于问题导致堆变满（内存泄漏），另一个线程可能会发出问题信号。这种情况很常见，因为问题将由第一个无法在堆中存储数据的线程报告。因为任何线程都可以发出问题信号，并且不一定是导致问题的那个线程，所以与堆相关的问题更难以解决。
- en: In most cases, when an `OutOfMemoryError` occurs, as shown in figure E.11, the
    situation is signaled by a different thread than the one affected by the root
    cause of the problem (the memory leak). The `OutOfMemoryError` is signaled by
    the first thread that tries to add something in the memory but cannot because
    there is no more free space.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当发生`OutOfMemoryError`时，如图 E.11 所示，这种情况是由受问题根本原因（内存泄漏）影响的线程之外的其他线程发出的信号。`OutOfMemoryError`是由第一个试图在内存中添加内容但无法添加的线程发出的。
- en: The garbage collector (GC) is the mechanism that frees the heap by removing
    unneeded data. The GC knows that an object instance is no longer needed when nothing
    references it. Thus, if an object isn’t needed but the app fails to remove all
    the references, the GC won’t remove that object. When an app continually fails
    to remove references to newly created objects until at some point they fill the
    memory (causing an `OutOfMemoryError`), we say that the app has a memory leak.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器（GC）是通过移除不再需要的数据来释放堆的机制。当没有任何引用指向一个对象实例时，垃圾回收器知道该对象实例不再需要。因此，如果一个对象不再需要但应用程序未能移除所有引用，垃圾回收器就不会移除该对象。当应用程序持续未能移除新创建对象的引用，直到它们填满内存（导致`OutOfMemoryError`）时，我们说该应用程序有内存泄漏。
- en: An object instance may be referred to from another object in a heap (figure
    E.12). A common example of a memory leak is a collection in which we continuously
    add object references. If these references aren’t removed, then, as long as the
    collection is in the memory, the GC won’t remove them; they become a memory leak.
    You should pay special attention to static objects (object instances referred
    to from static variables). These variables don’t disappear once they are created,
    so unless you explicitly remove the reference, you can assume that an object referred
    to from a static variable will stay for the whole life of the process. If that
    object is a collection that refers to other objects that are never removed, it
    can potentially become a memory leak.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象实例可能从堆中的另一个对象中引用（图 E.12）。内存泄漏的一个常见例子是我们持续添加对象引用的集合。如果这些引用没有被移除，那么只要这个集合在内存中，垃圾回收器就不会移除它们；它们就变成了内存泄漏。你应该特别注意静态对象（从静态变量引用的对象实例）。这些变量一旦创建就不会消失，所以除非你显式地移除引用，否则你可以假设从静态变量引用的对象将保持整个进程的生命周期。如果该对象是一个引用其他对象且这些对象永远不会被移除的集合，它可能成为潜在的内存泄漏。
- en: '![](../../OEBPS/Images/APPE_F12_Spilca3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPE_F12_Spilca3.png)'
- en: Figure E.12 Any object in the heap can keep references to other objects in the
    heap. The GC can remove an object only when no reference to it exists.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.12 堆中的任何对象都可以保持对堆中其他对象的引用。垃圾回收器只有在没有任何引用存在时才能移除一个对象。
- en: An object instance can also be referred to from the stack (figure E.13). Usually,
    references from the stack don’t cause memory leaks since (as discussed in section
    E.2) a stack layer automatically disappears when the execution reaches the end
    of the code block for which the app created the layer. But in specific cases,
    when combined with other issues, references from the stack can also cause trouble.
    Imagine a deadlock that keeps the execution from running through a whole block
    of code. The layer in the stack won’t be removed, and if it keeps references to
    objects, this may also become a memory leak.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象实例也可以从堆栈中引用（如图 E.13）。通常情况下，从堆栈中的引用不会导致内存泄漏，因为（如 E.2 节所述）当执行到达为应用创建该层的代码块末尾时，堆栈层会自动消失。但在某些特定情况下，当与其他问题结合时，堆栈中的引用也可能引起麻烦。想象一下，一个死锁阻止了执行通过整个代码块。堆栈中的层不会被移除，如果它继续引用对象，这也可能成为内存泄漏。
- en: '![](../../OEBPS/Images/APPE_F13_Spilca3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPE_F13_Spilca3.png)'
- en: Figure E.13 A variable in the stack can also refer to an instance in the heap,
    which cannot be removed until all its references are gone (including the ones
    in the stack).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.13 堆栈中的变量也可以引用堆中的实例，直到所有引用都消失（包括堆栈中的引用）才能被移除。
- en: E.4 The metaspace memory location for storing data types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.4 存储数据类型的元空间内存位置
- en: The metaspace is a memory location the JVM uses to store the data types used
    to create instances stored in the heap (figure E.14). The app needs this information
    to handle the object instances in the heap. Sometimes, in specific conditions,
    an `OutOfMemoryError` can also affect the metaspace. If the metaspace becomes
    full and there’s no more space for the app to store new data types, the app throws
    an `OutOfMemoryError,` announcing that the metaspace is full. In my experience,
    these errors are rare, but I would like you to be aware of them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 元空间是 JVM 用来存储用于创建堆中存储的实例的数据类型的内存位置（如图 E.14）。应用需要这些信息来处理堆中的对象实例。有时，在特定条件下，`OutOfMemoryError`
    也可以影响元空间。如果元空间满了，没有更多空间供应用存储新的数据类型，应用会抛出 `OutOfMemoryError`，宣布元空间已满。根据我的经验，这些错误很少见，但我希望您对此有所了解。
- en: '![](../../OEBPS/Images/APPE_F14_Spilca3.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPE_F14_Spilca3.png)'
- en: Figure E.14 The metaspace is a memory location where the app stores the data
    types’ descriptors. It holds the blueprints used to define the instances stored
    in the heap.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.14 元空间是应用存储数据类型描述符的内存位置。它包含了定义堆中存储的实例的蓝图。
