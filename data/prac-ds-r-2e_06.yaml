- en: Chapter 5\. Data engineering and data shaping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。数据工程和数据整理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Becoming comfortable with applying data transforms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 习惯于应用数据转换
- en: Starting with important data manipulation packages including `data.table` and
    `dplyr`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从重要的数据处理包包括`data.table`和`dplyr`开始
- en: Learning to control the layout of your data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习控制您数据的布局
- en: This chapter will show you how to use R to organize or wrangle data into a shape
    useful for analysis. Data shaping is a set of steps you have to take if your data
    is not found all in one table or in an arrangement ready for analysis.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何使用R来组织或整理数据，使其适合分析。数据整理是一系列步骤，如果您发现数据不是全部在一个表中，或者不是在分析准备好的排列中。
- en: '[Figure 5.1](../Text/05.xhtml#ch05fig01) is the mental model for this chapter:
    working with data. Previous chapters have assumed the data is in a ready-to-go
    form, or we have pre-prepared the data to be in such a form for you. This chapter
    will prepare you to take these steps yourself. The basic concept of data wrangling
    is to visualize your data being structured to make your task easier, and then
    take steps to add this structure to your data. To teach this, we''ll work a number
    of examples, each with a motivating task, and then work a transform that solves
    the problem. We''ll concentrate on a set of transforms that are powerful and useful,
    and that cover most common situations.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](../Text/05.xhtml#ch05fig01)是本章的心理模型：与数据一起工作。前几章假设数据是现成的，或者我们已经预先准备数据，使其以这种形式呈现。本章将使您能够自己采取这些步骤。数据整理的基本概念是可视化您的数据结构，以使您的任务更容易，然后采取步骤将这种结构添加到您的数据中。为了教学，我们将处理一些示例，每个示例都有一个激励性的任务，然后处理一个解决问题的转换。我们将专注于一组强大且有用的转换，这些转换涵盖了大多数常见情况。'
- en: Figure 5.1\. [Chapter 5](../Text/05.xhtml#ch05) mental model
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1。[第5章](../Text/05.xhtml#ch05)心理模型
- en: '![](Images/05fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01.jpg)'
- en: 'We will show data wrangling solutions using base R, `data.table`, and `dplyr`.^([[1](../Text/05.xhtml#ch05fn1)])
    Each of these has its advantages, which is why we are presenting more than one
    solution. Throughout this book, we are deliberately using a polyglot approach
    to data wrangling: mixing base R, `data.table`, and `dplyr`, as convenient. Each
    of these systems has its strengths:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示使用基础R、`data.table`和`dplyr`进行数据处理解决方案。^([[1](../Text/05.xhtml#ch05fn1)])
    每个都有其优势，这就是为什么我们展示了不止一个解决方案。在整个这本书中，我们故意采用多语言方法进行数据处理：混合基础R、`data.table`和`dplyr`，以方便起见。每个系统都有其优势：
- en: ¹
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For database tasks, we suggest using `dbplyr` or `rquery`, which we will touch
    on briefly in [appendix A](../Text/A.xhtml#app01).
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于数据库任务，我们建议使用`dbplyr`或`rquery`，我们将在附录A（../Text/A.xhtml#app01）中简要介绍。
- en: '***Base R—*** This is code written in R that directly manipulates `data.frame`s
    using R’s built-in capabilities. Breaking complex transforms into base R primitives
    can be a puzzle, but we will give you the tools to solve the puzzle in this chapter.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***基础R—*** 这是在R中编写的代码，它直接使用R的内置功能操作`data.frame`。将复杂的转换分解为基础R原语可能是一个难题，但我们将在本章中为您提供解决这个难题的工具。'
- en: '***`data.table`—*** `data.table` is the package for fast and memory-efficient
    data manipulation in R. It differs from normal R semantics in that `data.table`
    uses *reference semantics* where changes are made directly in a shared data structure
    (visible to all references to the same structure) instead of R’s more typical
    *value semantics* (where changes made in one reference do not become visible to
    other references). `data.table` notation specifies powerful transforms through
    a variation of the []-indexing operator, and is well explained in `help(data .table,
    package="data.table")` and `vignette("datatable-intro", package= "data.table")`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`data.table`—*** `data.table`是R中进行快速和内存高效数据处理的包。它与常规R语义的不同之处在于`data.table`使用*引用语义*，其中更改直接在共享数据结构（对所有引用同一结构可见）中进行，而不是R的更典型的*值语义*（在一个引用中做出的更改不会对其他引用可见）。`data.table`符号通过[]索引操作符的变体指定强大的转换，并在`help(data
    .table, package="data.table")`和`vignette("datatable-intro", package= "data.table")`中得到很好的解释。'
- en: '***`dplyr`—*** `dplyr` is a popular data manipulation package that emphasizes
    data manipulations through sequences of SQL-like (or Codd-style) operators. `dplyr`
    is usually not as fast (or space efficient) as `data.table`, but the notations
    are convenient.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`dplyr`—*** `dplyr`是一个流行的数据处理包，它强调通过一系列类似SQL（或Codd风格）操作符的数据操作。`dplyr`通常不如`data.table`快（或空间效率高），但符号很方便。'
- en: 'Some good places to start on manipulating data in R are the following free
    guides:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中操作数据的良好起点是以下免费指南：
- en: 'Getting Started in R, `data.table` version: [https://eddelbuettel.github.io/gsir-te/Getting-Started-in-R.pdf](https://eddelbuettel.github.io/gsir-te/Getting-Started-in-R.pdf)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R入门，`data.table`版本：[https://eddelbuettel.github.io/gsir-te/Getting-Started-in-R.pdf](https://eddelbuettel.github.io/gsir-te/Getting-Started-in-R.pdf)
- en: 'Getting Started in R, `tidyverse` version: [https://github.com/saghirb/Getting-Started-in-R](https://github.com/saghirb/Getting-Started-in-R)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R入门，`tidyverse`版本：[https://github.com/saghirb/Getting-Started-in-R](https://github.com/saghirb/Getting-Started-in-R)
- en: 'We want to improve your ability to write R code (to translate intent into implementation)
    and to read R code (to infer intent from existing code). To this end, this chapter,
    like much of this book, is designed as a sequence of worked examples. We strongly
    encourage you try running the examples yourself (they are available here: [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)).
    It is key to get into the habit of planning (even drawing) your data transformation
    before coding. Finish clarifying your intent before getting bogged down by the
    details of coding. Trust that there are easy-to-find methods for most common data
    wrangling tasks in R, and plan with the assumption that you can find them when
    needed. The principle is this: make your analysis simpler by transforming your
    data into a simple “data matrix” format where each row is an observation, and
    each column is a measurement type. Fix issues, such as odd column names, early,
    and then you don’t have to write complicated code to work around them.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提高你编写R代码（将意图转化为实现）和阅读R代码（从现有代码中推断意图）的能力。为此，本章，就像这本书的大部分内容一样，被设计成一系列的工作示例。我们强烈鼓励你亲自尝试运行这些示例（它们在这里可用：[https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)）。养成在编码之前规划（甚至绘制）数据转换的习惯是关键。在陷入编码细节之前，先明确你的意图。相信R中大多数常见的数据整理任务都有易于找到的方法，并假设你可以在需要时找到它们。原则是这样的：通过将你的数据转换成简单的“数据矩阵”格式来简化你的分析，其中每一行是一个观察值，每一列是一个测量类型。尽早解决像奇特的列名等问题，这样你就不必编写复杂的代码来绕过它们。
- en: 'This chapter is organized in terms of the type of transform needed. For variety,
    we will bring in a number of small notional datasets, and spend a little time
    looking at each dataset. This task-to-example organization will give you a quick
    introduction to data transforms in R. The transforms we are going to cover include
    these:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章按所需的转换类型组织。为了多样化，我们将引入一些小型概念数据集，并花一点时间查看每个数据集。这种任务到示例的组织将快速介绍R中的数据转换。我们将涵盖的转换包括以下内容：
- en: Choosing a subset of columns
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择列的子集
- en: Choosing a subset of rows
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择行子集
- en: Reordering rows
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排序行
- en: Creating new columns
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新列
- en: Dealing with missing values
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Combining two datasets by row
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过行合并两个数据集
- en: Combining two datasets by column
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过列合并两个数据集
- en: Joining two datasets
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并两个数据集
- en: Aggregating rows
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合行
- en: General data reshaping (tall versus wide forms)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用数据重塑（长格式与宽格式）
- en: 'The idea is that this list will give you enough tools for a very large number
    of tasks. We''ll work from problems to solutions. We will show which command solves
    a given problem, and leave details of the command’s syntax to R’s help system
    and the guides and tutorials we suggest in this chapter. Please think of this
    chapter as a Rosetta Stone for data wrangling: each concept is explained once
    and then executed three times (usually in base R, `data.table`, and `dplyr`).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表的目的是为你提供足够多的工具来完成大量任务。我们将从问题到解决方案进行工作。我们将展示哪个命令解决了给定问题，并将命令的语法细节留给R的帮助系统以及我们在本章中建议的指南和教程。请将本章视为数据整理的罗塞塔石碑：每个概念只解释一次，然后执行三次（通常是在基础R、`data.table`和`dplyr`中）。
- en: Our first application (subsetting rows and columns) will set up the general
    pattern of the applications, so it is worth reading through even if you are already
    confidently subsetting data in R.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个应用（选择行和列）将设定应用的一般模式，所以即使你已经自信地使用R进行数据选择，也值得阅读。
- en: '* * *'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Data sources
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来源
- en: 'In this chapter, we’ll use small, toy-sized datasets to make it easier to examine
    data before and after the transforms. We strongly suggest you run all the examples
    along with us. All examples are either built-in data that comes with R or available
    from the book’s GitHub site: [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2).
    Also, all code examples can be found in the `CodeExamples` at the same location.
    We suggest cloning or downloading this material to help working with this book.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用小型、玩具大小的数据集来简化在转换前后检查数据的过程。我们强烈建议您与我们一同运行所有示例。所有示例要么是R自带的数据集，要么可以从本书的GitHub站点获取：[https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)。此外，所有代码示例都可以在相同位置的`CodeExamples`中找到。我们建议克隆或下载此材料以帮助您使用本书。
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: For more information on R’s built-in examples, try the command `help(datasets)`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于R的内置示例的更多信息，请尝试使用命令 `help(datasets)`。
- en: 5.1\. Data selection
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1\. 数据选择
- en: This section covers removing rows, removing columns, reordering columns, removing
    missing data, and reordering data rows. In the era of big data, you often have
    too much to look at, so limiting your data to what you need can greatly speed
    up your work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了删除行、删除列、重新排序列、删除缺失数据和重新排序数据行。在大数据时代，你常常需要查看太多的数据，因此将你的数据限制在你需要的内容上可以大大加快你的工作速度。
- en: 5.1.1\. Subsetting rows and columns
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1\. 选择行和列
- en: A common task when working with a dataset is selecting a subset of rows or columns.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据集时，选择行或列的子集是一个常见任务。
- en: Situation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 情境
- en: 'For our first example, we will use the `iris` dataset: measurements of sepal
    length and width and petal length and width for three species of iris.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将使用`iris`数据集：测量三种鸢尾花物种的萼片长度和宽度以及花瓣长度和宽度。
- en: 'First we will look at some aspects of the data. We suggest always doing this
    and making it part of an “eyes on the data” work discipline. For example, [figure
    5.2](../Text/05.xhtml#ch05fig02) shows the petal dimensions of our example irises:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看一些数据方面的内容。我们建议始终这样做，并将其作为“关注数据”工作纪律的一部分。例如，[图5.2](../Text/05.xhtml#ch05fig02)显示了我们的示例iris的花瓣尺寸：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Attaches the ggplot2 package for later plotting
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将ggplot2包附加到后续绘图
- en: ❷ Takes a look at the built-in iris data
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查看内置的iris数据
- en: Figure 5.2\. Example iris plot
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2\. 番茄图示例
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Attaching packages
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 附加包
- en: It is good practice to attach packages early. If a package won’t attach, try
    installing it with a command such as `install.packages ("ggplot2")`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 早期附加包是一个好习惯。如果一个包无法附加，请尝试使用如`install.packages("ggplot2")`之类的命令安装它。
- en: '* * *'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `iris` data comes preinstalled with R and is part of the `datasets` package.
    We will deliberately use small examples in this chapter so it is easy to look
    at results.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`iris`数据是R预安装的，并属于`datasets`包。我们将故意在本章中使用小型示例，以便更容易查看结果。'
- en: Scenario
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: '*Suppose we are assigned to generate a report on only petal length and petal
    width, by iris species, for irises where the petal length is greater than 2\.
    To accomplish this, we need to select a subset of columns (variables) or a subset
    of rows (instances) from a data frame*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设我们被分配生成一份关于仅包含花瓣长度和花瓣宽度，按iris物种分类的报告，对于花瓣长度大于2的iris。为了完成这项任务，我们需要从数据框中选择列（变量）的子集或行的子集（实例）*。'
- en: Column and row selections look like [figure 5.3](../Text/05.xhtml#ch05fig03).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列和行选择看起来像[图5.3](../Text/05.xhtml#ch05fig03)。
- en: Figure 5.3\. Selecting columns and rows
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3\. 选择列和行
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: '* * *'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The diagrams
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图表
- en: The diagrams in this chapter are meant to be mnemonic cartoons of the transform.
    We suggest looking at the actual data before and after the transform to get more
    details on what the data transforms are doing. We also suggest reviewing them
    again after working the solutions and noticing how they abstract the arrangement
    of the data before and after the transforms. Think of these diagrams as a visual
    index of transforms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的图表旨在成为转换的助记卡通。我们建议在转换前后查看实际数据以获取数据转换所做的更多详细信息。我们还在解决完问题后再次审查它们，并注意它们如何抽象转换前后的数据排列。将这些图表视为转换的视觉索引。
- en: '* * *'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Solution 1: Base R'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案1：基础R
- en: The base R solution works by using the `[,]` indexing operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R解决方案是通过使用`[,]`索引运算符来实现的。
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: drop = FALSE
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: drop = FALSE
- en: When working with `[,]` always add a third argument `drop = FALSE` to get around
    the issue that the default behavior when selecting a single column from an R `data.frame`
    returns a vector and not a `data.frame` containing the column. In many cases,
    we know we have more than one column, and don’t strictly need the command. But
    it is good to get in the habit of adding this argument to avoid unpleasant surprises.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: When working with `[,]` always add a third argument `drop = FALSE` to get around
    the issue that the default behavior when selecting a single column from an R `data.frame`
    returns a vector and not a `data.frame` containing the column. In many cases,
    we know we have more than one column, and don’t strictly need the command. But
    it is good to get in the habit of adding this argument to avoid unpleasant surprises.
- en: '* * *'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'The solution strategy is this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'The solution strategy is this:'
- en: Get desired columns by name or column index in the second position of `[,]`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Get desired columns by name or column index in the second position of `[,]`.
- en: Get desired rows by Boolean per-row selection in the first position of `[,]`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Get desired rows by Boolean per-row selection in the first position of `[,]`.
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice column selection is also a good way to reorder columns. An advantage
    of base R is it tends to be fast and has very stable APIs: code written this year
    in base R is most likely to work next year (`tidyverse` packages, unfortunately,
    tend to have less-stable APIs). The one disadvantage is that a few base R defaults
    are irritating. For example, we included the `drop=FALSE` notation to work around
    the fact that base R would return a `vector` instead of a `data.frame` if we tried
    to select only one column.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'Notice column selection is also a good way to reorder columns. An advantage
    of base R is it tends to be fast and has very stable APIs: code written this year
    in base R is most likely to work next year (`tidyverse` packages, unfortunately,
    tend to have less-stable APIs). The one disadvantage is that a few base R defaults
    are irritating. For example, we included the `drop=FALSE` notation to work around
    the fact that base R would return a `vector` instead of a `data.frame` if we tried
    to select only one column.'
- en: 'Solution 2: data.table'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'Solution 2: data.table'
- en: Row and column selection in `data.table` is performed similarly to base R. `data
    .table` uses a very powerful set of index notations. In this case, we use a `..`
    notation to tell `data.table` that we are using the second index position to specify
    column names (and not to specify calculations, as we will demonstrate later).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Row and column selection in `data.table` is performed similarly to base R. `data
    .table` uses a very powerful set of index notations. In this case, we use a `..`
    notation to tell `data.table` that we are using the second index position to specify
    column names (and not to specify calculations, as we will demonstrate later).
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Converts to data.table class to get data.table semantics
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Converts to data.table class to get data.table semantics
- en: ❷ The .. notation tells data.table that columns_we_want isn’t itself the name
    of a column but a variable referring to names of columns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ The .. notation tells data.table that columns_we_want isn’t itself the name
    of a column but a variable referring to names of columns.
- en: 'The advantage of `data.table` is that it is the fastest and most memory efficient
    solution for data wrangling in R at a wide range of scales. `data.table` has a
    very helpful FAQ, and there is a nice cheat sheet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'The advantage of `data.table` is that it is the fastest and most memory efficient
    solution for data wrangling in R at a wide range of scales. `data.table` has a
    very helpful FAQ, and there is a nice cheat sheet:'
- en: '[https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html)'
- en: '[https://www.datacamp.com/community/tutorials/data-table-cheat-sheet](https://www.datacamp.com/community/tutorials/data-table-cheat-sheet)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.datacamp.com/community/tutorials/data-table-cheat-sheet](https://www.datacamp.com/community/tutorials/data-table-cheat-sheet)'
- en: Both of these will make more sense if you approach them after working some examples
    from the `data.table` vignette accessible in R with the command `vignette ("datatable-intro",
    package = "data.table")`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用`data.table`的示例之后再来理解这两个概念，它们就会更加清晰。这些示例可以在R中使用命令`vignette("datatable-intro",
    package = "data.table")`获取。
- en: Taking care when using data.table
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Taking care when using data.table
- en: '`data.table` works like `data.frame`s for packages that are not `data.table`-aware.
    This means you can use `data.table`s with just about any package, even those that
    predate `data.table`. In a `data.table`-aware situation (using `data.table` at
    the command line, or using a package that depends on `data.table`), `data.table`
    implements slightly enhanced semantics. We show a quick example here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` works like `data.frame`s for packages that are not `data.table`-aware.
    This means you can use `data.table`s with just about any package, even those that
    predate `data.table`. In a `data.table`-aware situation (using `data.table` at
    the command line, or using a package that depends on `data.table`), `data.table`
    implements slightly enhanced semantics. We show a quick example here:'
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Example data.frame
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Example data.frame
- en: ❷ Notice that writing df[, x] instead of df[, "x"] is an error (assuming x is
    not bound to a value in our environment).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Notice that writing df[, x] instead of df[, "x"] is an error (assuming x is
    not bound to a value in our environment).
- en: ❸ Sets up data.table example
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Sets up data.table example
- en: ❹ Notice that this returns the column x much like d$x would.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注意这返回的列x与d$x非常相似。
- en: ❺ This uses data.table’s “look up” idiom to get a data.table of columns referred
    to by the variable x.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这使用data.table的“查找”习语来获取由变量x引用的列的数据表。
- en: 'Solution 3: dplyr'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案3：dplyr
- en: 'The `dplyr` solution is written in terms of select and filter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`解决方案是用选择和过滤来编写的：'
- en: '`dplyr::select` to select desired columns'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dplyr::select`来选择所需的列
- en: '`dplyr::filter` to select desired rows'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dplyr::filter`来选择所需的行
- en: 'It is traditional to chain `dplyr` steps with the `magrittr` pipe operator
    `%>%`, but assigning to temporary variables works just as well. While teaching
    here, we''ll use *explicit dot* notation, where the data pipeline is written as
    `iris %>% select(., column)` instead of the more-common implicit first-argument
    notation (`iris %>% select(column)`). Explicit dot notation was discussed in [chapter
    2](../Text/02.xhtml#ch02) and is the topic of the following R Tip: [http://www.win-vector.com/blog/2018/03/r-tip-make-arguments-explicit-in-magrittr-dplyr-pipelines/](http://www.win-vector.com/blog/2018/03/r-tip-make-arguments-explicit-in-magrittr-dplyr-pipelines/).^([[2](../Text/05.xhtml#ch05fn2)])'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`magrittr`管道操作符`%>%`来链式调用`dplyr`步骤，但分配给临时变量同样有效。在这里教学时，我们将使用*显式点*表示法，其中数据管道被写作`iris
    %>% select(., column)`而不是更常见的隐式第一个参数表示法（`iris %>% select(column)`）。显式点表示法在[第2章](../Text/02.xhtml#ch02)中已有讨论，也是以下R技巧的主题：[http://www.win-vector.com/blog/2018/03/r-tip-make-arguments-explicit-in-magrittr-dplyr-pipelines/](http://www.win-vector.com/blog/2018/03/r-tip-make-arguments-explicit-in-magrittr-dplyr-pipelines/).^([[2](../Text/05.xhtml#ch05fn2)])
- en: ²
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A powerful alternate pipe called the *dot arrow pipe* (written as `%.>%`) that
    insists on explicit dot notation and supplies additional capabilities can be found
    in the `wrapr` package. For most of this book, we will stick to the `magrittr`
    pipe, but we encourage curious readers to check out the `wrapr` pipe in their
    own work.
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`wrapr`包中可以找到一个强大的替代管道，称为*点箭头管道*（写作`%.>%`），它坚持使用显式点表示法并提供额外的功能。在这本书的大部分内容中，我们将坚持使用`magrittr`管道，但我们鼓励好奇的读者在自己的工作中检查`wrapr`管道。
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The advantage of `dplyr` is the emphasis of data processing as a sequence of
    operations broken down into a visible pipeline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`的优势在于强调数据处理作为一个分解为可见管道的操作序列。'
- en: There is a nice cheat sheet for `dplyr` available from [https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf).
    Cheat sheets are always going to be a bit brief, so the sheet will become very
    useful after you have tried a few examples.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)获取一份关于`dplyr`的不错的速查表。速查表总是简明扼要的，所以你在尝试了一些示例之后，这份表格将会非常有用。
- en: 5.1.2\. Removing records with incomplete data
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2\. 删除不完整数据记录
- en: An important variation of subsetting data is removing rows of data that have
    missing values. We will also deal with some simple strategies for replacing missing
    values by moving values across rows (using `na.locf()`) or moving values across
    columns (called *coalescing*).^([[3](../Text/05.xhtml#ch05fn3)])
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 子集数据的一个重要变体是删除含有缺失值的行数据。我们还将讨论一些简单的策略，通过在行之间移动值（使用`na.locf()`）或在列之间移动值（称为*合并*）来替换缺失值.^([[3](../Text/05.xhtml#ch05fn3)])
- en: ³
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is actually an entire science devoted to imputing values for missing data.
    A good resource on this topic is [https://CRAN.R-project.org/view=MissingData](https://CRAN.R-project.org/view=MissingData).
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，有一个完整的科学致力于填补缺失数据值的值。关于这个主题的一个好资源是[https://CRAN.R-project.org/view=MissingData](https://CRAN.R-project.org/view=MissingData)。
- en: In this section, we will show how to quickly select only rows that have no missing
    data or values. This is only an example; we generally suggest using the methodologies
    in [chapters 4](../Text/04.xhtml#ch04) and [8](../Text/08.xhtml#ch08) for treating
    missing values in real-world applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何快速选择只有没有缺失数据或值的行。这只是一个例子；我们通常建议在现实世界的应用中使用[第4章](../Text/04.xhtml#ch04)和[第8章](../Text/08.xhtml#ch08)中提到的处理缺失值的方法。
- en: Situation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 情况
- en: 'As our preceding example does not have missing values, we will move to another
    example: the `msleep` dataset of sleep times of animals with different characteristics.
    In this dataset, several rows have missing values. An additional goal of this
    example is to familiarize you with a number of common practice datasets. These
    are the datasets that you should break out to try a new data wrangling method.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们前面的例子没有缺失值，我们将转向另一个例子：具有不同特征的动物的睡眠时间 `msleep` 数据集。在这个数据集中，有几行有缺失值。本例的另一个目标是让你熟悉一些常见的实践数据集。这些是应该尝试新数据整理方法的数据库集。
- en: 'First, as always, let’s look at the data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样，让我们看看数据：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Copies the msleep from the ggplot2 package into our workspace
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 ggplot2 包中的 msleep 复制到我们的工作空间
- en: Scenario
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: We have been asked to build an extract of the `msleep` data that has no missing
    values. To accomplish this, we will remove all rows that have missing values.
    The cartoon of the transform is shown in [figure 5.4](../Text/05.xhtml#ch05fig04).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求构建一个没有缺失值的 `msleep` 数据的提取。为了完成这个任务，我们将删除所有包含缺失值的行。转换的卡通图显示在[图 5.4](../Text/05.xhtml#ch05fig04)中。
- en: Figure 5.4\. Removing rows with missing values
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4\. 删除包含缺失值的行
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: Base R solution
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Base R 解决方案
- en: '`complete.cases()` returns a vector with one entry for each row of the data
    frame, which is `TRUE` if and only if the row has no missing entries. Once we
    know what rows we want, it is just a matter of selecting those rows (which we
    have seen earlier).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete.cases()` 返回一个向量，其中每个数据框的行都有一个条目，如果且仅当该行没有缺失条目时为 `TRUE`。一旦我们知道我们想要哪些行，就只是选择这些行（我们之前已经看到过）。'
- en: '`na.omit()` performs the whole task in one step.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`na.omit()` 在一步中完成整个任务。'
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: data.table solution
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: 'The `complete.cases()` solution also works with `data.table`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`complete.cases()` 解决方案也适用于 `data.table`：'
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: dplyr solution
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '`dplyr::filter` can also be used with `complete.cases()`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr::filter` 也可以与 `complete.cases()` 一起使用。'
- en: With `magrittr` pipe notation, a `.` is taken to mean the item being piped.
    So we can use `.` to refer to our data multiple times conveniently, such as telling
    the `dplyr::filter` to use the data both as the object to be filtered and as the
    object to pass to `complete .cases()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `magrittr` 管道符号，`.` 被认为是管道中的项目。因此，我们可以方便地多次使用 `.` 来引用我们的数据，例如告诉 `dplyr::filter`
    使用数据作为要过滤的对象，并将其作为要传递给 `complete .cases()` 的对象。
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 5.1.3\. Ordering rows
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3\. 排序行
- en: In this section, we want to sort or control what order our data rows are in.
    Perhaps the data came to us unsorted, or sorted for a purpose other than ours.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想要排序或控制我们的数据行顺序。也许数据到达我们这里时未排序，或者排序的目的不是我们的。
- en: Scenario
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: 'We are asked to build a running or cumulative sum of sales by time, but the
    data came to us out of order:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求构建按时间累积的销售总和，但数据到达我们这里时是乱序的：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Uses wrapr::build_frame to type data in directly in legible column order
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 wrapr::build_frame 直接以可读的列顺序输入数据
- en: Problem
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: Reorder the rows by `day` and then `hour` and compute a running sum. The abstract
    diagram is shown in [figure 5.5](../Text/05.xhtml#ch05fig05).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照日期和小时重新排序行，并计算运行总和。抽象图显示在[图 5.5](../Text/05.xhtml#ch05fig05)中。
- en: Figure 5.5\. Ordering rows
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5\. 排序行
- en: '![](Images/05fig05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05.jpg)'
- en: Base R solution
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Base R 解决方案
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ with() executes the code in its second argument as if the columns of the first
    argument were variables. This lets us write x instead of purchases_ordered$x.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `with()` 函数执行其第二个参数中的代码，就像第一个参数的列是变量一样。这使得我们可以用 `x` 代替 `purchases_ordered$x`。
- en: ❷ Computes the running sum
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算运行总和
- en: data.table solution
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Reorders data
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重新排序数据
- en: '* * *'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: := and []
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: := 和 []
- en: Operations that alter data in place (such as `:=`) annotate the result to suppress
    printing. This is important, as often you are working with large structures and
    do not want intermediate data to print. `[]` is a no-operation that as a side
    effect restores printing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数据位置的操作（如 `:=`）会注释结果以抑制打印。这很重要，因为通常你正在处理大型结构，并且不希望中间数据打印出来。`[]` 是一个无操作，作为副作用恢复打印。
- en: '* * *'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '`setorderv()` reorders data in place and takes a list of ordering column names
    to specify the order. This is much more convenient than the base R solution that
    takes multiple ordering columns as multiple arguments. `wrapr::orderv()` tries
    to bridge this gap by allowing the user to specify ordering constraints with a
    list of columns (column values, not column names).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`setorderv()`就地重新排序数据，并接受一个排序列名的列表来指定顺序。这比基础R解决方案更方便，后者需要多个排序列作为多个参数。`wrapr::orderv()`试图通过允许用户使用列的列表（列值，而不是列名）来指定排序约束来弥合这一差距。'
- en: dplyr solution
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr解决方案
- en: '`dplyr` uses the word `arrange` to order data, and `mutate` to add a new column:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`使用单词`arrange`来排序数据，并使用`mutate`来添加新列：'
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Advanced use of ordering
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 高级排序使用
- en: For our advanced example, suppose we want the cumulative sum of sales to be
    perday—that is, to reset the sum at the start of each day.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的高级示例，假设我们想要按日计算销售总额——也就是说，在每天的开始重置总和。
- en: Base R solution
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R解决方案
- en: 'This easiest base R solution is a split and recombine strategy:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的基于基础R的解决方案，采用拆分和重新组合策略：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ First sorts the data
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先对数据进行排序
- en: ❷ Now splits the data into a list of groups
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 现在将数据拆分成一组组
- en: ❸ Applies the cumsum to each group
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对每个组应用cumsum
- en: ❹ Puts the results back together into a single data.frame
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将结果重新组合成一个单独的数据框
- en: ❺ R often keeps annotations in rownames(). In this case, it is storing the original
    row numbers of the pieces we are assembling. This can confuse users when printing,
    so it is good practice to remove these annotations, as we do here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ R通常在rownames()中保留注释。在这种情况下，它存储了我们正在组装的各个部分的原始行号。当打印时，这可能会让用户困惑，因此，像我们在这里所做的那样，删除这些注释是良好的实践。
- en: data.table solution
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: data.table解决方案
- en: The `data.table` solution is particularly concise. We order the data and then
    tell `data.table` to calculate the new running sum per-group with the `by` argument.
    The idea that the grouping is a property of the calculation, and not a property
    of the data, is similar to SQL and helps minimize errors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table`解决方案特别简洁。我们排序数据，然后告诉`data.table`使用`by`参数按组计算新的运行总和。分组是计算的性质，而不是数据的性质，这一想法与SQL类似，有助于最小化错误。'
- en: '* * *'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: := versus =
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: := 与 =
- en: In `data.table`, `:=` means “assign in place”—it is used to alter or create
    a column in the incoming `data.table`. Conversely, `=` is used to mean “create
    in new `data.table`,” and we wrap these sorts of assignments in a `.()` notation
    so that column names are not confused with arguments to `data.table`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data.table`中，`:=`表示“就地分配”——它用于更改或创建传入的`data.table`中的列。相反，`=`用于表示“创建新的`data.table`”，我们用`.()`符号包装这些类型的赋值，以避免列名与`data.table`的参数混淆。
- en: '* * *'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Adding the by keyword converts the calculation into a per-group calculation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加by关键字将计算转换为按组计算。
- en: '❷ First solution: result is a second copy of the data .(=) notation. Only columns
    used in the calculation (such as day) and those explicitly assigned to are in
    the result.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一种解决方案：结果是数据的第二个副本。（=）符号。只有用于计算的列（如日期）和明确分配的列在结果中。
- en: '❸ Second solution: result is computed in place by ordering the table before
    the grouped calculation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二种解决方案：在分组计算之前对表进行排序，结果就地计算。
- en: '❹ Third solution: result is in the same order as the original table, but the
    cumulative sum is computed as if we sorted the table, computed the grouped running
    sum, and then returned the table to the original order.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 第三种解决方案：结果与原始表顺序相同，但累积总和是按排序表、计算分组运行总和然后返回到原始顺序的方式计算的。
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Sequencing data.table operations
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table`操作的排序'
- en: Sequencing `data.table` operations is achieved either by writing in-place operations
    one after the other (as we did in these examples) or by starting a new open-`[`
    right after a close-`]` for operations that create new copies (this is called
    *method chaining* and is equivalent to using a pipe operator).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table`操作的排序可以通过连续写入就地操作（就像我们在这些示例中所做的那样）或在一个关闭的`]`之后开始一个新的开放的`[`来创建新副本的操作（这称为*方法链*，相当于使用管道操作符）来实现。'
- en: '* * *'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: dplyr solution
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr解决方案
- en: 'The `dplyr` solution works because the command `mutate()` (which we will discuss
    in the next section) works per-group if the data is grouped. We can make the data
    grouped by using the `group_by()` command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`解决方案之所以有效，是因为`mutate()`命令（我们将在下一节中讨论）如果数据已分组，则按组工作。我们可以使用`group_by()`命令使数据分组：'
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '* * *'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ungroup()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ungroup()
- en: In `dplyr` it is important to always `ungroup` your data when you are done performing
    per-group operations. This is because the presence of a `dplyr` grouping annotation
    can cause many downstream steps to calculate unexpected and incorrect results.
    We advise doing this even after a `summarize()` step, as `summarize()` removes
    one key from the grouping, leaving it unclear to a code reader if the data remains
    grouped or not.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dplyr` 中，当您完成对每个组操作的执行时，始终要取消分组您的数据。这是因为 `dplyr` 分组注释的存在可能会导致许多后续步骤计算出不期望和不正确的结果。我们建议即使在
    `summarize()` 步骤之后也要这样做，因为 `summarize()` 会移除一个关键分组，使得代码读者不清楚数据是否仍然分组。
- en: '* * *'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 5.2\. Basic data transforms
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2\. 基本数据转换
- en: This section covers adding and renaming columns.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍添加和重命名列。
- en: 5.2.1\. Adding new columns
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1\. 添加新列
- en: The section covers adding new variables (columns) to a data frame, or applying
    transformations to existing columns (see [figure 5.6](../Text/05.xhtml#ch05fig06)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖向数据框添加新变量（列）或对现有列应用转换（参见 [图 5.6](../Text/05.xhtml#ch05fig06)）。
- en: Figure 5.6\. Adding or altering columns
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6\. 添加或修改列
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig06_alt.jpg)'
- en: Example data
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 示例数据
- en: 'For our example data, we will use air quality measurements with missing data
    and non-standard date formatting, for the year 1973:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例数据，我们将使用 1973 年的空气质量测量数据，其中包含缺失数据和非标准日期格式：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Scenario
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: We are asked to convert this non-standard date representation into a new, more
    useful date column for queries and plotting.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求将这种非标准的日期表示转换为一个新的、更有用的日期列，以便进行查询和绘图。
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Base R solution
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Base R 解决方案
- en: 'In base R, we create new columns by assigning to them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础 R 中，我们通过赋值来创建新列：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Builds a copy of the dat
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建数据的副本
- en: a
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: ❷ Adds the date column, using with () to refer to columns without needing the
    table name
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 with() 添加日期列，无需引用表名即可引用列
- en: ❸ Limits down to the columns of interest
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 限制到感兴趣的列
- en: ❹ Shows the results
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 显示结果
- en: ❺ Plots the results
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 绘制结果
- en: The preceding code produces [figure 5.7](../Text/05.xhtml#ch05fig07).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了 [图 5.7](../Text/05.xhtml#ch05fig07)。
- en: Figure 5.7\. Ozone plot example
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7\. 臭氧图示例
- en: '![](Images/05fig07_alt.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig07_alt.jpg)'
- en: 'Base R has had transform-style (or pipeable) versions of these basic operators
    for quite some time (just no pipe!). Let’s work the example again in that style:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 已经有这些基本操作符的转换样式（或可管道化）版本了（只是没有管道！）。让我们再次以这种方式处理这个例子：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '❶ Attaches the wrapr package to define the wrapr dot arrow pipe: %.>%. The
    dot arrow pipe is another R pipe and is described in the R Journal at [https://journal.r-project.org/archive/2018/RJ-2018-042/index.html](https://journal.r-project.org/archive/2018/RJ-2018-042/index.html).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 wrapr 包附加到定义 wrapr 点箭头管道：%.>%. 点箭头管道是另一个 R 管道，在 R 项目的期刊中有所描述，请参阅 [https://journal.r-project.org/archive/2018/RJ-2018-042/index.html](https://journal.r-project.org/archive/2018/RJ-2018-042/index.html)。
- en: ❷ Runs all the steps as before using transform() and subset(), adding an extra
    step of filtering down to rows that do not have missing Ozone values
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 transform() 和 subset() 重复所有步骤，并添加一个额外的步骤，过滤掉没有缺失臭氧值的行
- en: data.table solution
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: '`data.table` uses `:=` to show column alterations or creations that are supposed
    to happen “in place” (the `data.table` at hand gets altered, instead of a new
    one being created).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 使用 `:=` 来显示“就地”发生的列更改或创建（当前 `data.table` 被更改，而不是创建一个新的）。'
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Builds a data.table copy of the data
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建数据的 data.table 副本
- en: ❷ Adds the date column
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加日期列
- en: ❸ Limits down to the columns of interest
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 限制到感兴趣的列
- en: 'Notice how the open-`[` steps work a lot like pipes, connecting one `data.table`
    stage to another. This is one of the reasons `data.table` places so many operations
    inside the `[]`: in R the `[]` naturally chains operations left to right.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到开放的 `[` 步骤如何大量地像管道一样工作，将一个 `data.table` 阶段连接到另一个。这是 `data.table` 在 `[]` 中放置许多操作的原因之一：在
    R 中，`[]` 自然地按从左到右的顺序链式操作。
- en: dplyr solution
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '`dplyr` users will remember that in `dplyr`, new columns are produced with
    the `mutate()` command :'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 用户会记得在 `dplyr` 中，新列是通过 `mutate()` 命令生成的：'
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The scenario continued
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 情景继续
- en: Notice the original Ozone graph had holes in the data, due to missing values.
    We will try to fix this by propagating the last known Ozone reading forward to
    the dates with missing values. This “the task was finished ... until we looked
    at the results” situation is typical of data science. So always look, and look
    for problems.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意原始臭氧图中的数据有孔，这是由于缺失值造成的。我们将尝试通过将最后已知的臭氧读数传播到有缺失值的日期来修复这个问题。这种“任务完成了……直到我们查看结果”的情况是数据科学的典型情况。所以总是要查看，并寻找问题。
- en: Filling in missing values from earlier in a column is illustrated in [figure
    5.8](../Text/05.xhtml#ch05fig08).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 5.8 中展示了从列中较早的缺失值填充。
- en: Figure 5.8\. Filling in missing values
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8\. 填充缺失值
- en: '![](Images/05fig08.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig08.jpg)'
- en: The `zoo` package supplies a function called `na.locf()`, which is designed
    to solve our issue. We will show how to apply this function now.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoo` 包提供了一个名为 `na.locf()` 的函数，该函数旨在解决我们的问题。我们现在将展示如何应用此函数。'
- en: Base R solution
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 解决方案
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This produces [figure 5.9](../Text/05.xhtml#ch05fig09).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了 [图 5.9](../Text/05.xhtml#ch05fig09)。
- en: Figure 5.9\. Ozone plot again
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9\. 再次展示臭氧图
- en: '![](Images/05fig09_alt.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig09_alt.jpg)'
- en: '* * *'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Use na.rm = FALSE
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 na.rm = FALSE
- en: Always use `na.rm = FALSE` with `na.locf()`; otherwise, it may delete initial
    `NA` elements from your data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用 `na.rm = FALSE` 与 `na.locf()` 一起；否则，它可能会删除数据中的初始 `NA` 元素。
- en: '* * *'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: data.table solution
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that `data.table` performed the correction “in place,” in `DT_airquality`
    instead of producing a new `data.frame`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `data.table` 在 `DT_airquality` 中“就地”进行了修正，而不是生成一个新的 `data.frame`。
- en: dplyr solution
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 5.2.2\. Other simple operations
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2\. 其他简单操作
- en: 'A number of additional simple operations commonly used in working with data
    are available—in particular, renaming columns by altering the column names directly,
    and also removing columns by assigning `NULL`. We will show these briefly:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据时，有许多常用的简单操作可用——特别是通过直接更改列名来重命名列，以及通过分配 `NULL` 来删除列。我们将简要展示这些操作：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 5.3\. Aggregating transforms
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3\. 聚合转换
- en: This section covers transforms that combine multiple rows or multiple columns.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了结合多行或多列的转换。
- en: 5.3.1\. Combining many rows into summary rows
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1\. 将多行合并为汇总行
- en: Here we address the situation where there are multiple observations or measurements
    of a single subject, in this case species of Iris, that we wish to aggregate into
    a single observation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理了存在多个观察或测量值的情况，在这种情况下是鸢尾花的物种，我们希望将其聚合为单个观察值。
- en: Scenario
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: We have been asked to make a report summarizing iris petals by species.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求制作一份总结报告，总结鸢尾花花瓣按物种的分类。
- en: Problem
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: Summarize measurements by category, as shown in [figure 5.10](../Text/05.xhtml#ch05fig10).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 按类别汇总测量值，如图 5.10 所示。
- en: Figure 5.10\. Aggregating rows
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10\. 聚合行
- en: '![](Images/05fig10_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig10_alt.jpg)'
- en: Example data
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 示例数据
- en: 'Again, we use measurements of petal length and width, by iris species, from
    the `iris` dataset :'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用来自 `iris` 数据集的鸢尾花花瓣长度和宽度的测量值，按鸢尾花种类：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Base R solution
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 解决方案
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This produces [figure 5.11](../Text/05.xhtml#ch05fig11), a new iris plot with
    group mean annotations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了 [图 5.11](../Text/05.xhtml#ch05fig11)，一个新的带有分组平均值的鸢尾花图。
- en: Figure 5.11\. Iris plot
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11\. 鸢尾花图
- en: '![](Images/05fig11_alt.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig11_alt.jpg)'
- en: data.table solution
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: dplyr solution
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '`dplyr::group_by`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr::group_by`'
- en: '`dplyr::summarize`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr::summarize`'
- en: A one-argument aggregation function, for example `sum` or `mean`
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单参数聚合函数，例如 `sum` 或 `mean`
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Window functions
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数
- en: 'Both `data.table` and `dplyr` have grouped versions of the preceding operations
    (similar to what relational databases call *window functions*). This lets each
    row include the per-group summary in each row without having to build a summary
    table and join (the usual way to compute such quantities). For example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 和 `dplyr` 都有前面操作的分组版本（类似于关系数据库中称为 *窗口函数* 的内容）。这允许每行包含每个组的汇总，而无需构建汇总表和连接（计算此类量的常用方法）。例如：'
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `data.table`, the task looks like the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `data.table` 中，任务看起来如下：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Please run the preceding code and print `iris_data.table` to see that the computed
    means are per-group.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请运行前面的代码并打印 `iris_data.table`，以查看计算出的平均值是按组计算的。
- en: '`dplyr` has similar functionality:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 有类似的功能：'
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, it is critical to `ungroup()` when applying per-group transforms. Also,
    be aware that `dplyr` grouped operations (in particular, row selection through
    `filter()`) can be much slower than ungrouped operations, so you want to make
    your `group()`/ `ungroup()` intervals as short as possible. And `dplyr` grouped
    operations are usually much slower than `data.table` grouped operations in general.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在应用每个组的转换时，必须执行 `ungroup()`。此外，请注意，`dplyr` 分组操作（特别是通过 `filter()` 进行行选择）通常比未分组操作慢得多，因此您希望将
    `group()`/ `ungroup()` 间隔尽可能缩短。并且通常 `dplyr` 分组操作比 `data.table` 分组操作慢。
- en: 5.4\. Multitable data transforms
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4\. 多表数据转换
- en: This section covers operations between multiple tables. This includes the tasks
    of splitting tables, concatenating tables, and joining tables.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了多个表之间的操作。这包括拆分表、连接表和连接表的任务。
- en: 5.4.1\. Combining two or more ordered data frames quickly
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1\. 快速合并两个或多个有序数据框
- en: Here we discuss combining two data frames, with the same number of rows or columns
    (and same order!). A more involved, but more general way to combine data is demonstrated
    in [section 5.4.2](../Text/05.xhtml#ch05lev2sec8).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论合并具有相同行数或列数（以及相同顺序）的两个数据框。一种更复杂但更通用的合并数据的方法在[5.4.2 节](../Text/05.xhtml#ch05lev2sec8)中演示。
- en: Scenario
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: We have been asked to draw information about products from a sales database
    and produce a report. Typically, different facts (in this case, price and units
    sold) are stored in different tables, so to produce our report, we will have to
    combine data from more than one table.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求从销售数据库中提取有关产品的信息并生成报告。通常，不同的事实（在本例中为价格和销售单位）存储在不同的表中，因此为了生成我们的报告，我们将不得不从多个表中组合数据。
- en: 'For example, suppose our example data was the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的示例数据如下：
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Problem 1: Appending rows'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1：追加行
- en: When two tables have the exact same column structure, we can concatenate them
    to get a larger table, as in [figure 5.12](../Text/05.xhtml#ch05fig12).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个表具有完全相同的列结构时，我们可以将它们连接起来以获得更大的表，如[图 5.12](../Text/05.xhtml#ch05fig12)所示。
- en: Figure 5.12\. Unioning rows
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12\. 行合并
- en: '![](Images/05fig12_alt.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig12_alt.jpg)'
- en: Base R solution
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 解决方案
- en: '*`rbind`*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*`rbind`*'
- en: '[PRE35]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that `rbind` creates a new factor variable when merging incompatible factor
    variables:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `rbind` 在合并不兼容的因子变量时创建一个新的因子变量：
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: data.table solution
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`data.table` also correctly merges factor types.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 还正确合并因子类型。'
- en: dplyr solution
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '*`dplyr::bind_rows`*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*`dplyr::bind_rows`*'
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that `bind_rows` coerces incompatible factor variables to character.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `bind_rows` 将不兼容的因子变量强制转换为字符。
- en: 'Problem 2: Splitting tables'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2：拆分表
- en: The inverse of row binding is *splitting*. Many difficult calculations can be
    made easy by splitting a data frame into a family of data frames, then working
    on each data frame, and finally rebinding them together. The best implementation
    is the one found in `data.table`, which has some priority (being one of the first).
    `na.rm = FALSE` only simulates splitting and recombining data (so tends to be
    very fast).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 行绑定（row binding）的逆操作是*拆分*。通过将数据框拆分为一系列数据框，然后对每个数据框进行操作，最后将它们重新绑定在一起，可以简化许多复杂的计算。`data.table`
    中的实现是最好的，它有一些优先级（因为它是第一批之一）。`na.rm = FALSE` 仅模拟拆分和重组数据（因此通常非常快）。
- en: Base R solution
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 解决方案
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: data.table solution
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: '`data.table` combines the split, apply, and recombine steps into a single,
    very efficient operation. We will continue our example with the `rbind_base` object
    to show the effect. `data.table` is willing to call a user function or execute
    a user expression for each data group and supplies special variables to work per-group:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 将拆分、应用和重组步骤合并为一个单一且非常高效的运算。我们将继续使用 `rbind_base` 对象来展示其效果。`data.table`
    愿意为每个数据组调用用户函数或执行用户表达式，并为每个组提供特殊变量以进行工作：'
- en: '***`.BY`—*** A named list of the grouping variables and values per group. .BY
    is a list of scalars, as by definition grouping variables do not vary per group.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`.BY`—*** 一个命名列表，包含分组变量和每个组的值。.BY 是一个标量列表，因为根据定义，分组变量在每个组中不变化。'
- en: '***`.SD`—*** A `data.table` representation of the set of rows for the given
    group with the grouping columns removed.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`.SD`—*** 给定组的行集的 `data.table` 表示，分组列已被移除。'
- en: 'For instance, to compute a max price per group, we can do the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了计算每个组的最大价格，我们可以执行以下操作：
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that the preceding is a powerful general form not needed for such a simple
    task. Simple per-group aggregation of values is usually achieved by naming the
    columns:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的内容是一个强大的通用形式，对于这样一个简单的任务并不需要。通常通过命名列来实现简单的按组聚合值：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we took the liberty of showing how we would group by a column
    chosen by a variable.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了如何通过变量选择的列进行分组。
- en: dplyr solution
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '`dplyr` doesn’t have its own split implementation. `dplyr` tries to simulate
    working on subtables with its `group_by()` notation. For example, to compute the
    maximum price per group in `dplyr`, we would write code like the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 没有自己的分割实现。`dplyr` 尝试通过其 `group_by()` 符号来模拟在子表上工作。例如，要在 `dplyr` 中计算每个组的最大价格，我们会编写如下代码：'
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is not going to be as powerful as calling an arbitrary function per data
    group.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不会像为每个数据组调用任意函数那样强大。
- en: 'Problem 3: Appending columns'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3：追加列
- en: Append a data frame as columns to another data frame. The data frames must have
    the same number of rows and same row order (with respect to what we consider to
    be row-keys). This is illustrated in [figure 5.13](../Text/05.xhtml#ch05fig13).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据框作为列追加到另一个数据框中。数据框必须具有相同数量的行和相同的行顺序（相对于我们认为是行键的内容）。这在[图 5.13](../Text/05.xhtml#ch05fig13)中得到了说明。
- en: Figure 5.13\. Unioning columns
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13. 合并列
- en: '![](Images/05fig13_alt.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图像 5.13](Images/05fig13_alt.jpg)'
- en: Create a table of product information (price and units sold), from `productTable`
    and `salesTable`. This assumes that the products are sorted in the same order
    in both tables. If they are not, then sort them, or use a join command to merge
    the tables together (please see [section 5.4.2](../Text/05.xhtml#ch05lev2sec8)).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `productTable` 和 `salesTable` 创建一个产品信息表（价格和销售单位）。这假设产品在这两个表中按相同的顺序排序。如果它们不是，那么对它们进行排序，或者使用连接命令将表合并在一起（请参阅[第
    5.4.2 节](../Text/05.xhtml#ch05lev2sec8)）。
- en: Base R solution
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 解决方案
- en: '*`cbind`*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cbind`*'
- en: '[PRE43]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: data.table solution
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: data.table 解决方案
- en: For binding columns, `data.table` methods require the data to already be of
    type `data.table`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绑定列，`data.table` 方法要求数据已经为 `data.table` 类型。
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: dplyr solution
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 解决方案
- en: '*`dplyr::bind_cols`*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*`dplyr::bind_cols`*'
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 5.4.2\. Principal methods to combine data from multiple tables
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2. 从多个表中组合数据的主要方法
- en: '*Join* is the relational name for the process of combining two tables to create
    a third. The join results in a table that possibly has a new row for every pair
    of rows from the original two tables (plus possibly rows from each table that
    did not have matches from the other table). Rows are matched on key-values, matching
    from one table to another. The simplest case is when each table has a set of columns
    that uniquely determine each row (a unique key), and this is the case we will
    discuss here.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接*是关系数据库中合并两个表以创建第三个表的过程。连接的结果可能是一个表，它可能对于原始两个表中的每一对行都有一个新行（以及可能来自每个表没有匹配的其他表中的行）。行是通过键值匹配的，从一个表匹配到另一个表。最简单的情况是，每个表都有一组列，这些列可以唯一确定每一行（一个唯一键），这是我们在这里要讨论的情况。'
- en: Scenario
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: Our example data is information about products in a sales database. Various
    facts (in this case, price and units sold) are stored in different tables. Missing
    values are allowed. We are tasked with combining these tables to produce a report.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例数据是销售数据库中产品信息。各种事实（在这种情况下，价格和销售单位）存储在不同的表中。允许存在缺失值。我们的任务是组合这些表以生成报告。
- en: 'First let’s set up some example data:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一些示例数据：
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Left join
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 左连接
- en: The most important join for the data scientist is likely the *left join*. This
    join keeps every row from the left table and adds columns coming from matching
    rows in the right table. When there are no matching rows, `NA` values are substituted
    in. Usually, you design the right table (the second argument to your join command)
    to have unique keys; otherwise, the number of rows may grow (there is no need
    for the left table to have unique keys).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据科学家来说，最重要的连接可能是*左连接*。这种连接保留左表中的每一行，并添加来自右表中匹配行的列。如果没有匹配的行，则用 `NA` 值替换。通常，你设计右表（连接命令的第二个参数）具有唯一的键；否则，行数可能会增加（左表不需要有唯一的键）。
- en: The operation is typically used to adjoin data from the second (or right) table
    into a copy of the first or left table, as shown in [figure 5.14](../Text/05.xhtml#ch05fig14).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作通常用于将来自第二个（或右）表的数据附加到第一个或左表的副本中，如图 5.14 所示。
- en: Figure 5.14\. Left join
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14. 左连接
- en: '![](Images/05fig14_alt.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图像 5.14](Images/05fig14_alt.jpg)'
- en: Base R solution
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 解决方案
- en: '*`merge` with argument `all.x = TRUE`*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*`merge`函数，其中`all.x = TRUE`*'
- en: '[PRE47]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: data.table solution
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: data.table解决方案
- en: '[PRE48]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Base R indexing solution
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Base R索引解决方案
- en: 'The `data.table` index notation reminds us that there is another very good
    Base R way to use one table to add a single column to another: vectorized lookup
    through the `match()` and `[]` methods.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table`索引表示法提醒我们，还有另一种非常好的Base R方法，即使用一个表向另一个表添加单个列：通过`match()`和`[]`方法进行向量化查找。'
- en: '[PRE49]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`match()` found the matching indices, and `[]` used the indices to retrieve
    the data. Please see `help(match)` for more details.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`match()`找到了匹配的索引，`[]`使用这些索引检索数据。请参阅`help(match)`获取更多详细信息。'
- en: dplyr solution
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr解决方案
- en: '[PRE50]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Right join
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 右连接
- en: There is also a join called *right join* that is just the left join with the
    arguments reversed. As the right join is so similar to the left, we will forgo
    any right join examples.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为**右连接**的连接，它只是将左连接的参数反转。由于右连接与左连接非常相似，我们将省略任何右连接的示例。
- en: Inner join
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 内连接
- en: In an *inner join*, you merge two tables into a single table, keeping only the
    rows where the key exists in both tables. This produces an intersection of the
    two tables, as shown in [figure 5.15](../Text/05.xhtml#ch05fig15).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个**内连接**中，你将两个表合并成一个单一的表，只保留两个表中都存在的键的行。这将产生两个表的交集，如图5.15所示。
- en: Figure 5.15\. Inner join
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15\. 内连接
- en: '![](Images/05fig15_alt.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig15_alt.jpg)'
- en: Base R solution
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Base R解决方案
- en: '*`merge`*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*`merge`*'
- en: '[PRE51]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: data.table solution
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: data.table解决方案
- en: '[PRE52]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: dplyr solution
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr解决方案
- en: '*`inner_join`*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*`inner_join`*'
- en: '[PRE53]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Full join
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 全连接
- en: In a *full join*, you merge two tables into a single table, keeping rows for
    all key values. Notice that the two tables have equal importance here. We show
    the result in [figure 5.16](../Text/05.xhtml#ch05fig16).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个**全连接**中，你将两个表合并成一个单一的表，保留所有键值对应的行。注意，在这里两个表具有相同的重要性。我们将在[图5.16](../Text/05.xhtml#ch05fig16)中展示结果。
- en: Figure 5.16\. Full join
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16\. 全连接
- en: '![](Images/05fig16_alt.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig16_alt.jpg)'
- en: Base R solution
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Base R解决方案
- en: '*`merge` with argument `all=TRUE`*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*`merge`函数，其中`all=TRUE`*'
- en: '[PRE54]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: data.table solution
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: data.table解决方案
- en: '[PRE55]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: dplyr solution
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr解决方案
- en: '*`dplyr::full_join`*'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*`dplyr::full_join`*'
- en: '[PRE56]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A harder join problem
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的连接问题
- en: The examples we have given up to now do not use row order. Some problems can
    be solved much more efficiently with methods that do use row order, such as `data.table`'s
    powerful rolling join operation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止给出的示例没有使用行顺序。有些问题可以通过使用行顺序的方法解决得更加高效，例如`data.table`强大的滚动连接操作。
- en: Scenario
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: 'You are given historic stock trade and quote (bid/ask) data. You are asked
    to perform the following analyses on the stock data: find what the bid and ask
    price were current when each trade was performed. This involves using row order
    to indicate time, and sharing information between rows.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你被提供了历史股票交易和报价（买入/卖出）数据。你被要求对股票数据进行以下分析：找出每次交易时的买入价和卖出价。这涉及到使用行顺序来表示时间，并在行之间共享信息。
- en: Example data
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 示例数据
- en: 'In stock markets, the *bid* is the highest price somebody has declared they
    are willing to pay for a stock, and the *ask* is the lowest price that somebody
    has declared they are willing to sell a stock for. Bid and ask data are called
    *quotes*, and they usually are in an irregular time series (as new quotes can
    be formed at arbitrary times, not just at regular intervals), such as the following
    example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在股票市场中，*买入价*是某人声明的愿意支付的最高价格，而*卖出价*是某人声明的愿意以该价格出售股票的最低价格。买入价和卖出价数据称为*报价*，它们通常是不规则的时序数据（因为新的报价可以在任意时间形成，而不仅仅是定期间隔），如下面的示例所示：
- en: '[PRE57]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Another irregular time series is *trades*. These are after-the-fact reports
    about exchanges of quantities of stock at a given price at a given time.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不规则的时序数据是*交易*。这些是在特定时间以特定价格交换股票数量的事后报告。
- en: '[PRE58]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Rolling joins
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动连接
- en: The `data.table` rolling join is perfect for finding what was the most recent
    quote information for each trade. A *rolling join* is a type of join on an ordered
    column that gives us the most recent data available at the lookup time.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table`的滚动连接非常适合找到每个交易的最新报价信息。滚动连接是一种在有序列上的连接类型，它在我们查找时间点提供最新的可用数据。'
- en: '[PRE59]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We read the preceding as “for each trade, look up the appropriate quote.” In
    the join, the `when` field comes from the trades, which is why we added a `quote_time`
    field so we could also see when the quote was established. The `data.table` rolling
    join is very fast, and also not easy to efficiently simulate in base R, `SQL`,
    or `dplyr`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前面的内容解读为“对于每一笔交易，查找相应的报价。”在连接中，`when`字段来自交易，这也是为什么我们添加了`quote_time`字段，以便我们也能看到报价是在何时建立的。`data.table`的滚动连接非常快，而且在基础R、`SQL`或`dplyr`中也不容易高效地模拟。
- en: Rolling joins are unique to `data.table`. In R there are a number of tasks,
    such as matching most recent records, that are easily expressed as moving indexes
    across rows. However, moving indexes across rows tends to be inefficient in R,
    as it can’t be vectorized like column operations can. A rolling join is a direct
    way of solving such problems, and has an efficient implementation.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动连接是`data.table`独有的。在R中，有许多任务，如匹配最新记录，可以很容易地表示为在行之间移动索引。然而，在R中，在行之间移动索引通常效率不高，因为它不能像列操作那样向量化。滚动连接是直接解决这类问题的方法，并且有一个高效的实现。
- en: 5.5\. Reshaping transforms
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5\. 重新塑造转换
- en: 'This section covers moving data between rows and columns. This is often called
    *pivoting*, a name from Pito Salas’s work that combines data summarization and
    shape transforms. Examples will be worked in three packages: `data.table`, `cdata`
    (which only reshapes data, and does not summarize data), and `tidyr`. Base R does
    have notations for these transforms (such as `stack()` and `unstack()`), but the
    package versions are significantly better tools.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖在行和列之间移动数据。这通常被称为*旋转*，这个名字来自Pito Salas的工作，它结合了数据汇总和形状转换。示例将在三个包中完成：`data.table`、`cdata`（它只重新塑造数据，不汇总数据）和`tidyr`。基础R确实有这些转换的符号（如`stack()`和`unstack()`），但包版本是显著更好的工具。
- en: 5.5.1\. Moving data from wide to tall form
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1\. 将数据从宽格式转换为长格式
- en: We will show how to move data records where all measurements are in single rows
    to a new record set where data is in multiple rows. We call this moving from a
    wide form to a thin or tall form.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何将所有测量值都在单行中的数据记录移动到一个新的记录集中，其中数据在多行中。我们称这种移动为从宽格式到窄或长格式。
- en: Data example
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 数据示例
- en: Let’s work with measurements of vehicle drivers/passengers injured or killed,
    by month. The data includes additional information about fuel price and whether
    seatbelts are required by law.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以按月份测量的车辆驾驶员/乘客受伤或死亡的数据为例。数据还包括有关燃料价格以及法律是否要求使用安全带的信息。
- en: 'Relevant variables for this example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的相关变量：
- en: '**`date`—** Year and month of measurement (numeric representation)'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`date`—** 测量年份和月份（数字表示）'
- en: '**`DriversKilled`—** Car drivers killed'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`DriversKilled`—** 被杀害的汽车驾驶员'
- en: '**`front`—** Front seat passengers killed or seriously injured'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`front`—** 前排乘客死亡或严重受伤'
- en: '**`rear`—** Rear seat passengers killed or seriously injured'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`rear`—** 后排乘客死亡或严重受伤'
- en: '**`law`—** Whether or not seatbelt law was in effect (0/1)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`law`—** 安全带法律是否生效（0/1）'
- en: '[PRE60]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To get our data into a presentable format, we have performed transforms described
    in earlier sections of this chapter: selecting rows, selecting columns, adding
    new derived columns, and so on. The data now has one row per date (we think of
    the date as the row-key) and contains information such as how many people were
    killed in each of three seating positions (driver, front, rear) and if the new
    seatbelt law was in effect.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的数据转换成可展示的格式，我们已经在本章前面的部分中描述了转换操作：选择行，选择列，添加新的派生列等等。现在数据中每行对应一个日期（我们将日期视为行键），并包含诸如在三个座位位置（驾驶员、前排、后排）中各有多少人死亡以及新的安全带法律是否生效等信息。
- en: 'We want to see if the new seatbelt law saves lives. Notice that we are missing
    a key bit of information: a normalizing factor such as number of cars owned per
    date, driving population size by date, or total miles driven per date (risks make
    more sense as rates than as absolute counts). This is an example of true data
    science being an iterative process: we are going to do the best job we can with
    the data at hand, but in a real project, we would also go back to sources and
    partners to try to get the critical missing data (or at least an estimate or proxy
    for the missing data).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想看看新的安全带法律是否能够挽救生命。请注意，我们缺少一个关键信息：一个标准化因子，例如每日期的汽车拥有数量，按日期划分的驾驶人口规模，或每日期的总行驶里程（风险作为比率比作为绝对计数更有意义）。这是一个真正的数据科学是迭代过程的例子：我们将尽我们所能使用现有的数据，但在实际项目中，我们也会回到来源和合作伙伴那里，试图获取关键的缺失数据（或者至少是缺失数据的估计或代理）。
- en: 'Let’s plot the data conditioned on the law:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据法律绘制数据：
- en: '[PRE61]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This code produces [figure 5.17](../Text/05.xhtml#ch05fig17).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成了[图5.17](../Text/05.xhtml#ch05fig17)。
- en: Figure 5.17\. Passenger deaths plot
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17\. 乘客死亡图表
- en: '![](Images/05fig17_alt.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig17_alt.jpg)'
- en: From the chart, it looks like the introduction of the seatbelt law produced
    a drop in deaths that is non-trivial when compared to the normal variation in
    deaths. It also looks like the effect may have reverted quickly.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表来看，引入安全带法与死亡数的正常变化相比，死亡人数的下降是非平凡的。这也表明效果可能迅速逆转。
- en: Suppose our follow-up question is to break down this data further to seating
    position (as types of seatbelts differ quite a bit by seating position).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的后续问题是进一步将数据分解到座位位置（因为安全带类型根据座位位置有很大差异）。
- en: To make such a plot with `ggplot2`, we need to move the data from all facts
    being in each row to having one row per seating position. This is an example of
    moving from a wide or denormalized format, the natural format for machine learning
    tasks, to a tall or multiline record format.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ggplot2` 制作此类图表，我们需要将数据从每行包含所有事实转换为每个座位位置一行。这是一个从宽或非规范化格式（机器学习任务的自然格式）到高或多行记录格式的转换示例。
- en: Problem
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: Plot deaths conditioned on date and seating position, using `ggplot2`. `ggplot2`
    requires the data to be in a long, rather than wide, format. So we will concentrate
    on how to perform this transform. We call this sort of transform moving data from
    row-oriented records to blocks of rows, as shown in [figure 5.18](../Text/05.xhtml#ch05fig18).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ggplot2` 根据日期和座位位置绘制死亡人数图表。`ggplot2` 要求数据以长格式而非宽格式。因此，我们将集中讨论如何执行此转换。我们称这种转换是将数据从面向行的记录移动到行块，如图5.18所示。
- en: Figure 5.18\. Wide-to-tall conversion
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18\. 宽到高的转换
- en: '![](Images/05fig18_alt.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig18_alt.jpg)'
- en: 'Solution 1: data.table::melt.data.table()'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案1：data.table::melt.data.table()
- en: We can solve this with `data.table::melt.data.table()`. Specify the columns
    of the original table that the values are to be taken from with the `measure.vars`
    argument. Specify the pair of columns the information is to be written into in
    the transformed table with the arguments `variable.name` (the new key column)
    and `value.name` (the new value column).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `data.table::melt.data.table()` 解决这个问题。使用 `measure.vars` 参数指定原始表中要取值的列。使用
    `variable.name`（新键列）和 `value.name`（新值列）参数指定在转换表中写入信息的列对。
- en: '[PRE62]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'These new graphs do show us something more: the law had essentially no effect
    on people in the rear seats. This could be perhaps because the law didn''t cover
    these seats, perhaps enforcing rear seat compliance was difficult, or perhaps
    rear-seat seatbelts were lap belts (instead of three-point restraints) and were
    not effective. The strongest benefit seems to be to front-seat passengers, and
    that is not too unusual, as they tend to have high-quality seatbelts and are not
    sitting in front of the steering column (a primary source of fatal injuries).'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新图表确实显示了一些更多信息：法律对后排乘客几乎没有影响。这可能是因为法律没有涵盖这些座位，或许执行后排座位遵守规定很困难，或者后排安全带可能是安全带（而不是三点式约束）并且效果不佳。最大的好处似乎是对前排乘客，这并不太奇怪，因为他们通常配备高质量的座椅安全带，并且不坐在方向盘前面（这是致命伤害的主要来源）。
- en: 'Solution 2: cdata::unpivot_to_blocks()'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案2：cdata::unpivot_to_blocks()
- en: '[PRE63]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`cdata` has simple methods to specify the coordinated conversions of many columns
    at once. A good introduction can be found at [http://www.win-vector.com/blog/2018/10/faceted-graphs-with-cdata-and-ggplot2/](http://www.win-vector.com/blog/2018/10/faceted-graphs-with-cdata-and-ggplot2/).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdata` 提供了简单的方法来一次性指定多个列的坐标转换。有关介绍，请参阅[http://www.win-vector.com/blog/2018/10/faceted-graphs-with-cdata-and-ggplot2/](http://www.win-vector.com/blog/2018/10/faceted-graphs-with-cdata-and-ggplot2/)。'
- en: We encourage you to try all three solutions and convince yourself they produce
    the equivalent results. We prefer the `cdata` solution, but it is new and not
    as well known as the `data.table` or `tidyr` solutions.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您尝试所有三种解决方案，并确信它们产生等效的结果。我们更喜欢 `cdata` 解决方案，但它较新，不如 `data.table` 或 `tidyr`
    解决方案知名。
- en: 'Solution 3: tidyr::gather()'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案3：tidyr::gather()
- en: '[PRE64]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: And we now have the passenger death data faceted by seating position in [figure
    5.19](../Text/05.xhtml#ch05fig19).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了按座位位置分组的乘客死亡数据，如图5.19所示。
- en: Figure 5.19\. Faceted passenger death plot
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19\. 分面乘客死亡图表
- en: '![](Images/05fig19_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig19_alt.jpg)'
- en: 5.5.2\. Moving data from tall to wide form
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2\. 从高到宽的数据移动
- en: We have been given data in a log style, where each detail of a measurement is
    written in a separate row. Colloquially, we call this a *tall* or *thin* data
    form (formally, it is related to information storage ideas such as RDF triples).
    The operation of moving to a wide form is very much like what Microsoft Excel
    users call *pivoting*, except aggregations (sums, averages, counts) are not strictly
    part of moving from tall to wide form (we suggest aggregating first before transforming).
    Also, moving from tall to wide form is, of course, the inverse of the moving from
    wide to tall form conversion we discussed earlier.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以日志风格提供的数据，其中每个测量的细节都写在单独的一行中。通俗地说，我们称这种形式为“高”或“瘦”数据形式（正式上，它与如RDF三元组这样的信息存储理念相关）。将数据转换为宽形式的过程非常类似于微软Excel用户所说的“旋转”，除了聚合（总和、平均值、计数）不是从高到宽形式转换的严格部分（我们建议在转换之前先进行聚合）。此外，从高到宽形式的转换当然是之前讨论的从宽到高形式转换的逆过程。
- en: The data
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 数据
- en: 'For our example, we have taken the `ChickWeight` data from R’s `datasets` package.
    Please try these commands along with the book and take extra steps to examine
    the data (using commands such as `View()`, `head()`, `summary()` and so on):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，我们从R的`datasets`包中取了`ChickWeight`数据。请尝试与本书一起使用这些命令，并采取额外步骤检查数据（使用`View()`、`head()`、`summary()`等命令）：
- en: '[PRE65]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This data is organized so each row is a single fact (`weight`) about a given
    chick at a given time. The is a very easy format to produce and transmit, which
    is why it is popular in scientific settings. To perform interesting work or learn
    from the data, we need to bring the data into a wider structure. For our problem,
    we would like all the weight facts about a chick to be in a single row, with time
    as the new column name.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据组织得如此之好，以至于每一行都是关于给定时间给定小鸡的一个单一事实（重量）。这是一个非常容易产生和传输的格式，这也是为什么它在科学环境中很受欢迎。为了从数据中进行有趣的工作或从中学习，我们需要将数据带入更宽的结构。对于我们的问题，我们希望所有关于小鸡的重量事实都在一行中，时间作为新的列名。
- en: Before doing that, let’s use some of our earlier lessons to get a look at the
    data. We can aggregate the data to move from information about individuals to
    overall trends.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在做那之前，让我们利用我们之前的一些课程来查看数据。我们可以聚合数据，从关于个体的信息转换到整体趋势。
- en: '[PRE66]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In `ChickSummary` the only key is `Time` (specified by the `data.tableby` argument)
    and we can now see how many chicks are surviving at a given time and the distribution
    of surviving chick weights at a given time.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ChickSummary`中，唯一的关键是`Time`（由`data.tableby`参数指定），现在我们可以看到在给定时间存活的小鸡数量以及给定时间存活小鸡重量的分布。
- en: We can present this table graphically. To use `ggplot2` to do this, we need
    to move the summarized data to a tall form (as `ggplot2` prefers to work with
    tall data). We use `cdata::unpivot_to_blocks:`
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个表格以图形方式呈现。要使用`ggplot2`来完成此操作，我们需要将汇总数据移动到高形式（因为`ggplot2`更喜欢与高数据一起工作）。我们使用`cdata::unpivot_to_blocks:`。
- en: '[PRE67]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ❶ Unpivots into tall form for plotting
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据从宽形式转换为高形式以进行绘图
- en: ❷ Makes sure we have the exact set of columns needed for plotting
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保我们有用于绘图的所需列的准确集合
- en: ❸ Makes the plot
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 绘制图表
- en: This gives the chick weights organized by time and chick, as shown in [figure
    5.20](../Text/05.xhtml#ch05fig20).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这为小鸡提供了按时间和小鸡组织起来的重量，如图[图5.20](../Text/05.xhtml#ch05fig20)所示。
- en: Figure 5.20\. Chick count and weight over time
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20\. 随时间变化的小鸡数量和重量
- en: '![](Images/05fig20_alt.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig20_alt.jpg)'
- en: Here we have plotted the total count of surviving chicks as a function of time,
    plus the weight trajectory of each individual check, and the summary statistics
    (mean weight, and 25% through 75% quartiles of weight).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将存活小鸡的总数作为时间的函数绘制出来，以及每个个体检查的重量轨迹，以及总结统计（平均重量和25%至75%的四分位数）。
- en: Problem
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: 'We can now return to the example task of this section: putting all the information
    about each chick into a single row.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回到本节示例任务：将每个小鸡的所有信息放入一行中。
- en: 'Diagrammatically, it looks like the following: one column’s (meastype) values
    are used as new column headers and a second column (meas) supplies values. We
    call this moving data from blocks to wide row records, as illustrated in [figure
    5.21](../Text/05.xhtml#ch05fig21).'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图形上，它看起来如下：一列的（meastype）值用作新的列标题，第二列（meas）提供值。我们称这种将数据从块移动到宽行记录的过程，如图[图5.21](../Text/05.xhtml#ch05fig21)所示。
- en: Figure 5.21\. Moving from tall to wide form
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21\. 从高到宽形式转换
- en: '![](Images/05fig21_alt.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig21_alt.jpg)'
- en: 'Solution 1: data.table::dcast.data.table()'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案1：data.table::dcast.data.table()
- en: 'To move data to a wide form using `dcast.data.table()`, we specify the rows
    and columns of a result matrix using a formula with the `~`notation. We then say
    how to populate the cells of this matrix with the `value.var` argument. In our
    case, to get a data frame with a row per chick, a column per time, and weight
    in the cells, we use the following step:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `dcast.data.table()` 将数据移动到宽格式，我们使用带有 `~` 符号的公式指定结果矩阵的行和列。然后我们通过 `value.var`
    参数说明如何填充这个矩阵的单元格。在我们的例子中，为了得到一个每只小鸡一行、每段时间一列，单元格中是重量的数据框，我们使用以下步骤：
- en: '[PRE68]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This table is a matrix where the row is identified by the chick, and the column
    is time. The cells contain the weight for the given chick and time (and `NA` if
    the chick did not survive to a given time). Notice that this format is much easier
    to read and may be required for reporting.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表是一个矩阵，行由小鸡标识，列是时间。单元格包含给定小鸡和时间的重量（如果小鸡没有存活到给定时间，则为 `NA`）。请注意，这种格式更容易阅读，可能需要用于报告。
- en: '`data.table`’s implementation of `dcast` also allows more-powerful transforms,
    such as casting to multiple variables and aggregations at the same time.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 对 `dcast` 的实现还允许更强大的转换，例如同时进行变量铸造和聚合。'
- en: 'Solution 2: cdata::pivot_to_rowrecs()'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案2：cdata::pivot_to_rowrecs()
- en: '`cdata::pivot_to_rowrecs()` describes the intended table by row-keys, column
    to take new column keys from, and column to take values from:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdata::pivot_to_rowrecs()` 通过行键、从列中获取新列键的列和从列中获取值的列来描述预期的表：'
- en: '[PRE69]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Solution 3: tidyr::spread()'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案3：tidyr::spread()
- en: '[PRE70]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 5.5.3\. Data coordinates
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3. 数据坐标
- en: 'There are a lot of details to data transforms. The important concept to retain
    is this: data has coordinates such as name of table, name of column, and identity
    of row. The exact way the coordinates are specified is an implementation detail
    to be overcome or transformed to a convenient state. All of this is a consequence
    of Codd’s second rule of database design: “Each and every datum (atomic value)
    in a relational database is guaranteed to be logically accessible by resorting
    to a combination of table name, primary key value, and column name.”^([[4](../Text/05.xhtml#ch05fn4)])
    What we hope you have learned is this: what parts of the coordinates (or access
    plan) happen to be the table name, versus row-keys, versus the column name is
    an alterable implementation detail.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换有很多细节。需要保留的重要概念是：数据有坐标，例如表名、列名和行标识符。坐标的确切指定方式是实现细节，需要克服或转换为方便的状态。所有这些都是Codd数据库设计第二规则的后果：“关系数据库中的每个原子值（数据项）都保证可以通过表名、主键值和列名的组合来逻辑访问。”^([[4](../Text/05.xhtml#ch05fn4)])
    我们希望您已经学到的是：坐标（或访问计划）的哪些部分是表名，与行键、列名相比，是一个可更改的实现细节。
- en: ⁴
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/Edgar_F._Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd).
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [https://en.wikipedia.org/wiki/Edgar_F._Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd)。
- en: '* * *'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Prefer simple code
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于使用简单的代码
- en: Building temporary tables, adding columns, and correcting column names early
    is much better than having complicated analysis code. This follows Raymond’s “Rule
    of Representation.”
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 早期构建临时表、添加列和更正列名要比有复杂的分析代码好得多。这遵循了Raymond的“表示规则”。
- en: Raymond’s “Rule of Representation”
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Raymond的“表示规则”
- en: '* * *'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '*Fold knowledge into data, so program logic can be stupid and robust.*'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*将知识融入数据，使程序逻辑可以简单且健壮。*'
- en: ''
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Art of Unix Programming, Erick S. Raymond, Addison-Wesley, 2003*'
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*《Unix编程艺术》，Erick S. Raymond，Addison-Wesley，2003*'
- en: 'We suggest transforming your data to fix problems (correct column names, change
    the data layout) early, to make later steps easier. The format you should try
    to move to for predictive modeling is what database designers call a *denormalized
    form*, or what statisticians call a *multivariate data matrix*, or *model matrix*:
    a regular array where rows are individuals, and columns are possible observations.^([[5](../Text/05.xhtml#ch05fn5)])'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您尽早转换数据以解决问题（更正列名、更改数据布局），以便使后续步骤更容易。您应该尝试转换为用于预测建模的格式，数据库设计者称之为*非规范化形式*，统计学家称之为*多元数据矩阵*或*模型矩阵*：一个常规数组，其中行是个人，列是可能的观测值.^([[5](../Text/05.xhtml#ch05fn5)])
- en: ⁵
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See W. J. Krzanowski and F. H. C. Marriott, *Multivariate Analysis, Part 1*,
    Edward Arnold, 1994.
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 W. J. Krzanowski 和 F. H. C. Marriott 的 *多元分析，第一部分*，Edward Arnold，1994。
- en: 'The interested reader may want to pursue `cdata`’s powerful diagrammatic system
    of data layout, which is being broadly adopted, and is discussed here: [https://github.com/WinVector/cdata](https://github.com/WinVector/cdata).'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 对此感兴趣的读者可能希望深入了解`cdata`强大的数据布局图示系统，该系统正在被广泛采用，并在此处讨论：[https://github.com/WinVector/cdata](https://github.com/WinVector/cdata)。
- en: Summary
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve worked through the basic examples of transform data for
    analysis and presentation.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了用于分析和展示的基本转换数据示例。
- en: 'At this point, we have worked through a great number of data transforms. Natural
    questions to ask are these: are these enough transforms? Can we quickly decompose
    any task into a small sequence of these transforms?'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了大量的数据转换。自然要问的问题是：这些转换是否足够？我们能否快速将任何任务分解成一系列这些转换？
- en: 'The answer is “no and yes.” There are more-specialized transforms such as “rolling
    window” functions and other time-series operations that are hard to express in
    terms of these transforms, but do in fact have their own efficient implementations
    in R and `data.table`. However, toward the “yes” answer, there are good reasons
    to consider the set of transforms we have learned as substantial. The basic manipulation
    transforms pretty much cover all of Edgar F. Codd’s relational algebra: a set
    of transforms that has been driving data engineering since 1970.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是“不，也不”。有一些更专业的转换，如“滚动窗口”函数和其他时间序列操作，难以用这些转换来表示，但在R和`data.table`中确实有它们自己的高效实现。然而，对于“是”的答案，有很好的理由认为我们学到的转换集是相当全面的。基本的操作转换几乎涵盖了Edgar
    F. Codd的关系代数：自1970年以来一直在推动数据工程的一系列转换。
- en: In this chapter you have learned
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学到了
- en: How to use a catalog of powerful data-reshaping transforms
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用强大的数据重塑转换目录
- en: How to apply these transforms to solve data organization issues
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用这些转换来解决数据组织问题
- en: In [part 2](../Text/p2.xhtml#part02) of the book, we’ll talk about the process
    of building and evaluating models to meet your stated objectives.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第二部分](../Text/p2.xhtml#part02)中，我们将讨论构建和评估模型的过程，以满足您所设定的目标。
