- en: 'Lesson 38\. Capstone project: game of tag'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第38课. 综合项目：捉迷藏游戏
- en: After reading [lesson 38](#ch38), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第38课](#ch38)之后，你将能够
- en: Write a simple game by using the tkinter library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tkinter库编写一个简单的游戏
- en: Use classes and object-oriented programming to organize code for a GUI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类和面向对象编程来组织GUI代码
- en: Write code that interacts with the user using the keyboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写与用户交互的代码，使用键盘
- en: Use a canvas to draw shapes in your program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用画布在你的程序中绘制形状
- en: When you think of a program that uses a GUI, one of the most common kinds of
    programs that comes to mind are games. Games that are short and interactive offer
    quick distractions. They’re even more fun to play when you write them yourself!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到一个使用GUI的程序时，最常见的一种程序类型就是游戏。短小且互动的游戏可以提供快速的娱乐。当你自己编写它们时，它们甚至更有趣！
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The problem
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: 'Write a GUI game using the tkinter library. The game simulates a game of tag.
    You should create two players inside a window. The players’ position and size
    can be randomized at the start. Both players will use the same keyboard: one will
    use the W, A, S, D keys, and the other will use the I, J, K, L keys to move their
    piece. Users decide which one will try to catch the other. Then, they’ll move
    around the window using their respective keys to try to touch the other player.
    When they touch the other player, the word *Tag* should appear somewhere on the
    screen.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter库编写一个GUI游戏。该游戏模拟捉迷藏游戏。你应在窗口内创建两个玩家。玩家的位置和大小可以在开始时随机化。两个玩家将使用相同的键盘：一个将使用W、A、S、D键，另一个将使用I、J、K、L键来移动他们的棋子。用户决定哪一个将尝试捕捉另一个。然后，他们将使用各自的键在窗口内移动，试图触摸另一个玩家。当他们触摸到另一个玩家时，屏幕上应出现“Tag”这个词。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is a simple game, and the code to write it won’t be long. When writing
    GUIs or visual applications such as games, it’s important to not be too ambitious
    at the beginning. Start with a simpler problem and build upon it as you get things
    working.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的游戏，编写它的代码不会很长。在编写GUI或像游戏这样的视觉应用程序时，一开始不要过于雄心勃勃是非常重要的。从一个更简单的问题开始，随着事情的开始工作，逐步构建。
- en: 38.1\. Identifying the parts to the problem
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.1. 确定问题的各个部分
- en: 'Given the problem, it’s time to identify its parts. You’ll find it easier to
    write the code if you do it incrementally. Ultimately, you need to accomplish
    three tasks:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这个问题，现在是时候确定它的各个部分了。如果你逐步进行，你会发现编写代码会更容易。最终，你需要完成三个任务：
- en: Create two shapes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个形状
- en: Move them around the window when certain keys are pressed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按下某些键时，在窗口内移动它们
- en: Detect whether the two shapes have touched
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测两个形状是否接触
- en: Each of these can be written as a separate piece of code that can be tested
    separately.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以编写为独立的代码片段，可以单独测试。
- en: 38.2\. Creating two shapes in a window
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.2. 在窗口中创建两个形状
- en: As with the other GUIs you’ve seen, the first step is to create a window and
    add any widgets your game will use to it. The next listing shows the code for
    this. The window will hold only one widget, a canvas. The canvas widget is a rectangular
    area in which you can place shapes and other graphical objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与你见过的其他GUI一样，第一步是创建一个窗口并向其中添加你的游戏将使用的小部件。下一个列表显示了这段代码。窗口将只包含一个小部件，即画布。画布小部件是一个矩形区域，你可以在这里放置形状和其他图形对象。
- en: Listing 38.1\. Initializing a window and widgets
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表38.1. 初始化窗口和小部件
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Canvas widget that will contain the player shapes**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含玩家形状的画布小部件**'
- en: '***2* Adding the canvas so that it fills entire window and scales if the window
    is resized**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加画布以使其填充整个窗口，并在窗口大小调整时缩放**'
- en: Now it’s time to create the shapes for the players. You’ll make the player pieces
    rectangles. The shapes are going to be objects added to the canvas, not the window
    itself. Because you’ll be creating more than one player, it’s a good idea to think
    in a modular way. You’ll create a class for the player, which will initialize
    the player piece on the canvas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建玩家的形状了。你将制作玩家棋子为矩形。这些形状将是添加到画布上的对象，而不是窗口本身。由于你将创建多个玩家，以模块化方式思考是个好主意。你将创建一个玩家类，它将在画布上初始化玩家棋子。
- en: To make the game more interesting, you can use random numbers to set up the
    starting position and size of the shape. [Figure 38.1](#ch38fig01) shows how you’ll
    construct the rectangle. You’ll choose a random coordinate for the top-left corner,
    `x1` and `y1`. Then, you’ll choose a random number for the size of the rectangle.
    The `x2` and `y2` coordinates are calculated by adding the size to `x1` and `y1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏更有趣，你可以使用随机数来设置形状的起始位置和大小。[图 38.1](#ch38fig01) 展示了如何构建矩形。你将选择一个随机坐标作为左上角
    `x1` 和 `y1`。然后，你将选择一个随机数作为矩形的大小。`x2` 和 `y2` 坐标通过将大小加到 `x1` 和 `y1` 上来计算。
- en: Figure 38.1\. Constructing the rectangle playing piece by choosing a coordinate
    for the top-left corner and a random number for the size
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 38.1\. 通过选择左上角坐标和随机大小来构建矩形游戏部件
- en: '![](images/38fig01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](images/38fig01.jpg)'
- en: The random aspect of creating the rectangle means that every time you create
    a new player, the rectangle will be placed at a random position in the window
    and will be a random size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建矩形的随机性意味着每次创建新的玩家时，矩形都会在窗口的随机位置放置，并且大小也是随机的。
- en: '[Listing 38.2](#ch38ex02) shows the code for creating the player’s rectangle
    piece. The code creates a class named `Player`. You’ll use a rectangle to denote
    the player’s piece. Any object on a canvas is denoted by a tuple of four integers,
    `x1`, `y1`, `x2`, `y2`, where (`x1`, `y1`) is the top-left corner, and (`x2`,
    `y2`) is the bottom-right corner of the shape.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 38.2](#ch38ex02) 展示了创建玩家矩形部件的代码。代码创建了一个名为 `Player` 的类。你将使用矩形来表示玩家的部件。画布上的任何对象都由四个整数的元组表示，`x1`、`y1`、`x2`、`y2`，其中
    (`x1`、`y1`) 是形状的左上角，(`x2`、`y2`) 是形状的右下角。'
- en: Listing 38.2\. A class for the player
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 38.2\. 用于玩家的类
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* init method to create an object that takes in the canvas on which to
    add the shape, and the shape’s color**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `init` 方法用于创建一个对象，该对象接受要添加形状的画布以及形状的颜色**'
- en: '***2* Sets the color of the object as a data attribute**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将对象的颜色设置为数据属性**'
- en: '***3* Chooses a random number between 1 and 100 for the size of the player
    piece**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为玩家部件的大小选择 1 到 100 之间的随机数**'
- en: '***4* The x-value of the top-left corner of the object, selected randomly between
    the range specified**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 对象左上角 x 值，在指定的范围内随机选择**'
- en: '***5* The y-value of the top-left corner of the object, selected randomly between
    the range specified**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 对象左上角 y 值，在指定的范围内随机选择**'
- en: '***6* The x-value of the bottom-right coordinate of the object**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 对象右下角坐标的 x 值**'
- en: '***7* The y-value of the bottom-right coordinate of the object**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 对象右下角坐标的 y 值**'
- en: '***8* Sets the coordinates of the object as a data attribute, with type list**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 将对象的坐标设置为数据属性，类型为列表**'
- en: '***9* Sets the player piece data attribute as a rectangle, placed at the position
    given by the coordinates above**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 将玩家部件数据属性设置为矩形，放置在上述坐标指定的位置**'
- en: '***10* Sets the color of the player piece, referencing it by its variable name,
    self.piece, from the preceding line**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 通过引用上一行的变量名 self.piece 设置玩家部件的颜色**'
- en: 'After creating the window, you can add the players to the canvas with the following
    code, which creates two `Player` objects on the same canvas, one yellow and one
    blue:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建窗口后，你可以使用以下代码将玩家添加到画布上，该代码在同一个画布上创建了两个 `Player` 对象，一个黄色和一个蓝色：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run the code, you’ll get a window that looks something like [figure 38.2](#ch38fig02).
    You have two shapes of different colors at a random position and with a random
    size. Nothing happens when the mouse is clicked or when a key is pressed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，你会得到一个看起来像[图 38.2](#ch38fig02)的窗口。你有两个不同颜色的形状，它们位于随机位置和随机大小。当鼠标点击或按键时，没有任何动作发生。
- en: Figure 38.2\. The game after creating two player objects. The position and size
    of each square varies each time the program is run.
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 38.2\. 创建两个玩家对象后的游戏。每次程序运行时，每个方块的位子和大小都会变化。
- en: '![](images/38fig02_alt.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/38fig02_alt.jpg)'
- en: 38.3\. Moving shapes inside the canvas
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.3\. 在画布内移动形状
- en: 'Each shape responds to the same type of event, keypresses:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个形状都响应相同类型的事件，即按键：
- en: To move the shape up, press W for one shape and I for the other.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将形状向上移动，按 W 键移动一个形状，按 I 键移动另一个形状。
- en: To move the shape left, press A for one shape and J for the other.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将形状向左移动，按 A 键移动一个形状，按 J 键移动另一个形状。
- en: To move the shape down, press S for one shape and K for the other.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将形状向下移动，按 S 键移动一个形状，按 K 键移动另一个形状。
- en: To move the shape right, press D for one shape and L for the other.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将形状向右移动，按 D 键移动一个形状，按 L 键移动另一个形状。
- en: You’ll have to create a function that acts as the event handler for any keypress
    on the canvas. Inside the function, you’ll move one player or the other, depending
    on which button is pressed. The following listing shows the code. In this code,
    `move` is a method you’ll define in the `Player` class. It’ll move the player’s
    position with `"u"` for up, `"d"` for down, `"r"` for right, and `"l"` for left.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不创建一个函数，作为画布上任何按键事件的处理器。在函数内部，你将根据按下的按钮移动一个玩家或另一个玩家。以下列表显示了代码。在这个代码中，`move`是你将在`Player`类中定义的方法。它将使用“u”向上，“d”向下，“r”向右，“l”向左来移动玩家的位置。
- en: Listing 38.3\. Event handler function when any key is pressed on the canvas
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表38.3\. 在画布上按下任何键时的事件处理函数
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Event handler function**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 事件处理函数**'
- en: '***2* Checks whether the keypress from the event is a W**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查事件中的按键是否是W**'
- en: '***3* move is a method that you’ll define in the player class, so call that
    method to move the shape up.**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* move是你将在player类中定义的方法，所以调用该方法来移动形状向上。**'
- en: '***4* Checks whether the keypress from the event is an I**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 检查事件中的按键是否是I**'
- en: '***5* Because move is defined in the player class, you call it on the other
    player to move the shape up.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 因为move是在player类中定义的，所以你调用它来移动形状向上。**'
- en: '***6* For the canvas, any keypress event will call the handle_key function.**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 对于画布，任何按键事件都会调用handle_key函数。**'
- en: Notice how nicely modular this code is. It’s easy to understand what’s going
    on, because you’ve removed the logic behind moving the shape into the player class.
    All that you do in the event handler function is decide which player to move and
    in which direction, denoted by `"u"` for up, `"d"` for down, `"l"` for left, and
    `"r"` for right.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个代码的模块化做得很好。因为它将移动形状的逻辑移到了player类中，所以很容易理解正在发生的事情。在事件处理函数中，你只需决定移动哪个玩家以及移动的方向，方向由“u”表示向上，“d”表示向下，“l”表示向左，“r”表示向右。
- en: Inside the `Player` class, you can write code that handles moving the shape
    by changing the values of the coordinates. [Listing 38.4](#ch38ex04) shows the
    code. For each of the directions that the player can move, you modify the coordinate
    data attribute. Then, you update the canvas coordinates for the shape to the new
    coordinates. Two players can’t move simultaneously. After a player starts moving,
    it’ll stop moving as soon as the other player presses a key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '在`Player`类中，你可以编写代码通过改变坐标值来处理形状的移动。[列表38.4](#ch38ex04)显示了代码。对于玩家可以移动的每个方向，你修改坐标数据属性。然后，你更新形状在画布上的坐标为新坐标。两个玩家不能同时移动。当一个玩家开始移动后，一旦另一个玩家按下键，它就会停止移动。 '
- en: Listing 38.4\. How to move a shape inside the canvas
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表38.4\. 在画布内移动形状的方法
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Method to move the shape; takes in a direction: one of ‘u’, ‘d’, ‘l’,
    ‘r’**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 移动形状的方法；接受一个方向：‘u’，‘d’，‘l’，‘r’之一**'
- en: '***2* Does something different for each of the four possible inputs (‘u’, ‘d’,
    ‘l’, ‘r’)**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对四种可能的输入（‘u’，‘d’，‘l’，‘r’）执行不同的操作**'
- en: '***3* If you’re moving up, changes the y1 and y2 values by decreasing them
    by indexing into the list coords**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果你正在向上移动，通过索引列表coords减少y1和y2的值**'
- en: '***4* Changes the coordinates of the rectangle, denoted by self.piece, to the
    new coordinates**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将矩形（由self.piece表示）的坐标更改为新坐标**'
- en: This code is used by any player object created. It follows the abstraction and
    modularity principles because it’s under the `Player` class, which means you have
    to write it only once but it can be reused by any of the objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码由任何创建的player对象使用。它遵循抽象和模块化原则，因为它位于`Player`类下，这意味着你只需编写一次，但它可以被任何对象重用。
- en: Now when you run the program, the set of keys W, A, S, D will move the yellow
    shape around the window, and the keys I, J, K, L will move the blue shape. You
    can even ask someone to play with you to test the code. You’ll notice that if
    you hold a key down, the shape will move continuously, but as soon as you press
    another key, the shape will stop and move according to the other keypress (until
    another key is pressed). Chasing the shapes around is fun, but nothing happens
    when they touch.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行程序时，W，A，S，D键将移动黄色的形状在窗口周围，而I，J，K，L键将移动蓝色的形状。你甚至可以请别人和你一起玩来测试代码。你会注意到，如果你按住一个键，形状将连续移动，但只要你按下另一个键，形状就会停止并按照另一个按键移动（直到再次按下另一个键）。追逐形状很有趣，但它们接触时不会发生任何事情。
- en: 38.4\. Detecting a collision between shapes
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.4\. 检测形状之间的碰撞
- en: The last piece to the game is to add the code logic for detecting whether two
    shapes collide. After all, this is a game of tag, and it’d be nice to be notified
    when one shape has touched the other one. The code logic will consist of making
    two method calls on the canvas. It’ll be implemented inside the same event function
    that deals with keypresses in the canvas. This is because after every keypress,
    you’d like to see whether a collision has occurred.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的最后一部分是添加检测两个形状是否碰撞的代码逻辑。毕竟，这是一个捉迷藏游戏，当形状接触到另一个形状时，得到通知会很好。代码逻辑将包括在画布上调用两个方法。它将在处理画布按键事件的同一个事件函数中实现。这是因为每次按键后，你都想看到是否发生了碰撞。
- en: '[Listing 38.5](#ch38ex05) shows the code for detecting the collision between
    two shapes. By design, in the tkinter library, every shape added to the canvas
    is assigned an ID. The first shape added gets an ID of 1, the second of 2, and
    so on. The first shape you added to the canvas was the yellow one. The idea behind
    the code is that you’ll get the coordinates of the first shape in the canvas by
    calling the method `bbox`, which finds the bounding box around the shape. In the
    case of the rectangle, the bounding box is the rectangle itself, but in other
    cases, the bounding box is a rectangle that the shape barely fits in. Then, you
    call the `find_overlapping` method on the canvas, with the coordinates of the
    bounding box as a parameter. The method returns a tuple that tells you all IDs
    that are within that box. Because the coordinates given as a parameter are those
    of the bounding box for one shape, the method will give back a tuple of (1, 2)
    whenever the shapes are overlapping. All that’s left to do is to check whether
    the shape with ID of 2 is in the returned tuple. If it is, then add text to the
    canvas.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表38.5](#ch38ex05) 展示了检测两个形状之间碰撞的代码。按照设计，在 tkinter 库中，添加到画布上的每个形状都会分配一个ID。第一个添加的形状获得ID
    1，第二个获得ID 2，依此类推。你首先添加到画布上的形状是黄色的。代码背后的想法是，通过调用 `bbox` 方法来获取画布上第一个形状的坐标，该方法找到形状周围的边界框。在矩形的情况下，边界框就是矩形本身，但在其他情况下，边界框是一个形状勉强适合的矩形。然后，你使用边界框的坐标作为参数，在画布上调用
    `find_overlapping` 方法。该方法返回一个元组，告诉你所有在该框内的ID。因为作为参数给出的坐标是其中一个形状的边界框坐标，所以当形状重叠时，该方法将返回一个包含
    (1, 2) 的元组。剩下要做的就是检查ID为2的形状是否在返回的元组中。如果是，那么就在画布上添加文本。'
- en: Listing 38.5\. Detecting a collision
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表38.5。检测碰撞
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Gets coordinates around one of the shapes**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取一个形状周围的坐标**'
- en: '***2* Finds IDs of all shapes that are within the box formed by those coordinates**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 找到所有在由这些坐标形成的框内的形状的ID**'
- en: '***3* Checks whether the ID of the other shape is in the overlapping IDs**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查另一个形状的ID是否在重叠的ID中**'
- en: '***4* Adds text to the canvas**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在画布上添加文本**'
- en: As soon as one shape touches the other one, the screen will look something like
    [figure 38.3](#ch38fig03).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个形状接触到另一个形状，屏幕将看起来像[图38.3](#ch38fig03)。
- en: Figure 38.3\. When one shape overlaps with the bounding box of the other shape,
    the text *Tag!* is printed on the canvas.
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图38.3。当一个形状与另一个形状的边界框重叠时，画布上会打印出文本 *Tag!*。
- en: '![](images/38fig03_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](images/38fig03_alt.jpg)'
- en: 38.5\. Possible extensions
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.5. 可能的扩展
- en: 'Many possibilities for extensions exist with this game. Your coding in this
    lesson is a great start. Here are some ideas:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏有许多扩展的可能性。在这个课程中，你的编码是一个很好的开始。以下是一些想法：
- en: Instead of closing the window and restarting it to play again, add a button
    to ask the user to play again. When they do, choose another random position and
    size for your shapes.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是关闭窗口并重新启动来再次玩游戏，添加一个按钮来询问用户是否再次玩游戏。当他们这样做时，为你的形状选择另一个随机位置和大小。
- en: Allow the shape to escape. If the shapes aren’t touching after having touched
    once, remove the text from the canvas.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许形状逃脱。如果形状在接触一次之后没有接触，则从画布上删除文本。
- en: Allow the players to customize their shapes by changing the color or changing
    the shape to a circle.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许玩家通过改变颜色或改变形状为圆形来自定义他们的形状。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, my goal was to teach you how to use more advanced GUI elements
    to make a game. You used a canvas to add shapes to the GUI, and you added an event
    handler that moved shapes around depending on which key was pressed. You also
    saw how to detect collisions between shapes in a canvas. You saw how to write
    neat, organized, and easy-to-read code by using classes and functions for major
    parts of the code that you know will be reused.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，我的目标是教你们如何使用更高级的GUI元素来制作游戏。你们使用画布添加形状到GUI中，并添加了一个事件处理器，根据按下的哪个键来移动形状。你们还看到了如何检测画布中形状之间的碰撞。你们还看到了如何通过使用类和函数来编写整洁、有组织且易于阅读的代码，这些类和函数用于代码的主要部分，这些部分你们知道将会被重复使用。
