- en: 9 Adding interactive devices and items within the game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 在游戏中添加交互式设备和物品
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Programming doors that the player can open
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程玩家可以打开的门
- en: Enabling physics simulations that scatter a stack of boxes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用物理模拟，使一摞箱子散开
- en: Building collectible items that players store in their inventory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建玩家存储在他们的库存中的可收集物品
- en: Using code to manage game state, such as inventory data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码管理游戏状态，例如库存数据
- en: Equipping and using inventory items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备和使用库存物品
- en: 'Implementing functional items is the next topic we’re going to focus on. Previous
    chapters covered various elements of a complete game: movement, enemies, the UI,
    and so forth. But our projects have lacked anything to interact with other than
    enemies, nor have they had much in the way of game state. In this chapter, you’ll
    learn how to create functional devices like doors.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实现功能性物品是我们接下来要关注的话题。前几章涵盖了完整游戏的各种元素：移动、敌人、用户界面等。但我们的项目缺乏与其他东西交互的内容，也没有多少游戏状态。在本章中，你将学习如何创建像门这样的功能性设备。
- en: We’ll also discuss collecting items, which involves both interacting with objects
    in the level and tracking game state. Games often have to track state like the
    player’s current stats, progress through objectives, and so on. The player’s inventory
    is an example of this sort of state, so you’ll build a code architecture that
    can keep track of items collected by the player. By the end of this chapter, you’ll
    have built a dynamic space that really feels like a game!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论收集物品，这涉及到与关卡中的对象交互以及跟踪游戏状态。游戏通常需要跟踪状态，如玩家的当前统计数据、完成目标进度等。玩家的库存就是这类状态的例子，因此你将构建一个代码架构来跟踪玩家收集的物品。到本章结束时，你将构建一个真正感觉像游戏的动态空间！
- en: We’ll start by exploring devices (such as doors) that are operated with keypresses
    from the player. After that, you’ll write code to detect when the player collides
    with objects in the level, enabling interactions like pushing objects around or
    collecting inventory items. Then you’ll set up a robust Model-View-Controller
    (MVC) style of code architecture to manage data for the collected inventory. Finally,
    you’ll program interfaces to make use of the inventory for gameplay, such as requiring
    a key to open a door.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索（如门）由玩家按键操作的操作设备。之后，你将编写代码以检测玩家与关卡中的对象发生碰撞，从而实现推动物体或收集库存物品等交互。然后，你将设置一个健壮的模型-视图-控制器（MVC）风格的代码架构来管理收集的库存数据。最后，你将编写接口以利用库存进行游戏玩法，例如需要钥匙才能打开门。
- en: WARNING Previous chapters were relatively self-contained and didn’t technically
    require projects from earlier chapters, but this time some of the code listings
    make edits to scripts from chapter 8\. If you skipped directly to this chapter,
    download the sample project for chapter 8 to build on that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：前几章相对独立，技术上不需要早期章节的项目，但这次一些代码列表对第8章的脚本进行了编辑。如果你直接跳到本章，请下载第8章的示例项目以在此基础上构建。
- en: The example project will have these devices and items randomly strewn about
    the level. A polished game would have a lot of careful design behind the placement
    of items, but we don’t need to carefully plan out a level that only tests functionality.
    However, even though the placement of objects doesn’t require a plan, the bullet
    points at the start of the chapter lay out the order in which we’ll implement
    things. As usual, the explanations build up the code step by step, but if you
    want to see all the finished code in one place, you can download the sample project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目将在关卡上随机分布这些设备和物品。一个精心打磨的游戏会在物品放置上有很多精心设计，但我们不需要精心规划一个只测试功能的关卡。然而，尽管对象的放置不需要计划，章节开头列出的项目符号却概述了我们实施事物的顺序。通常，解释会逐步构建代码，但如果你想在同一个地方看到所有完成的代码，你可以下载示例项目。
- en: 9.1 Creating doors and other devices
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 创建门和其他设备
- en: Although levels in games consist mostly of static walls and scenery, they also
    usually incorporate a lot of functional devices. I’m talking about objects that
    the player can interact with and operate—things like lights that turn on or a
    fan that starts turning. The specific devices can vary a lot and are mostly limited
    only by your imagination, but almost all of them use the same sort of code to
    have the player activate the device. You’ll implement a couple of examples in
    this chapter, and then you should be able to adapt this same code to work with
    all sorts of other devices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然游戏中的层级主要由静态墙壁和景观组成，但它们通常也包含许多功能设备。我指的是玩家可以与之交互和操作的对象——比如可以打开的灯或开始旋转的扇子。具体的设备可以有很多种，通常只受限于你的想象力，但几乎所有这些设备都使用相同类型的代码来让玩家激活设备。在本章中，你将实现几个示例，然后你应该能够将相同的代码适应到各种其他设备上。
- en: 9.1.1 Doors that open and close on a keypress
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 通过按键打开和关闭的门
- en: The first kind of device you’ll program is a door that opens and closes, and
    you’re going to start with operating the door by pressing a key. You could have
    lots of devices in a game, and lots of ways to operate those devices. We’re eventually
    going to look at a couple of variations, but doors are the most common interactive
    devices found in games, and using items with a keypress is the most straightforward
    approach to start with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的第一种设备是能够打开和关闭的门，你将从一个通过按键操作门开始。游戏中可以有大量的设备，以及操作这些设备的方法。我们最终会看看一些变体，但门是游戏中最常见的交互式设备，使用物品通过按键操作是最直接的方法来开始。
- en: The scene has a few spots where a gap exists between walls, so place a new object
    that blocks the gap. I created a new cube object and then set its transform to
    Position 2.5, 1.5, 17 and Scale 5, 3, 0.5, creating the door shown in figure 9.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中有几个地方墙壁之间存在缝隙，所以放置一个新的对象来阻挡缝隙。我创建了一个新的立方体对象，并将其变换设置为位置2.5, 1.5, 17和缩放5, 3,
    0.5，创建了图9.1中显示的门。
- en: '![CH09_F01_Hocking3](../Images/CH09_F01_Hocking3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Hocking3](../Images/CH09_F01_Hocking3.png)'
- en: Figure 9.1 Door object fit into a gap in the wall
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 门对象嵌入到墙的缝隙中
- en: Create a C# script, call it DoorOpenDevice, and put that script on the door
    object. This code will cause the object to operate as a door.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个C#脚本，命名为DoorOpenDevice，并将其放置在门对象上。这段代码将使对象作为一个门来操作。
- en: Listing 9.1 Script that opens and closes the door on command
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 命令打开和关闭门的脚本
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Amount to offset the position by when the door opens
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当门打开时偏移的位置量
- en: ❷ Boolean to keep track of the open state of the door
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于跟踪门开启状态的布尔值
- en: ❸ Open or close the door depending on the open state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 根据门的开启状态打开或关闭门。
- en: The first variable defines the offset that’s applied when the door opens. The
    door will move this amount when it opens, and then it will subtract this amount
    when it closes. The second variable is a private Boolean for tracking whether
    the door is open or closed. In the Operate() method, the object’s transform is
    set to a new position, adding or subtracting the offset depending on whether the
    door is already open; then open is toggled on or off.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量定义了门打开时应用的偏移量。门打开时会移动这个量，关闭时则会减去这个量。第二个变量是一个私有的布尔值，用于跟踪门是打开还是关闭。在Operate()方法中，对象的变换被设置为新的位置，根据门是否已经打开，添加或减去偏移量；然后打开状态被切换开或关。
- en: As with other serialized variables, dPos appears in the Inspector. But this
    is a Vector3 value, so instead of one input box, we have three, all under the
    one variable name. Type in the relative position of the door when it opens; I
    decided to have the door slide down to open, so the offset is 0, -2.9, 0 (because
    the door object has a height of 3, moving down 2.9 leaves a tiny sliver of the
    door sticking up out of the floor).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他序列化变量一样，dPos出现在检查器中。但这是一个Vector3值，所以我们有三个输入框，都在一个变量名下。输入门打开时的相对位置；我决定让门滑动打开，所以偏移量是0,
    -2.9, 0（因为门对象的高度为3，向下移动2.9后，门的一小部分会露出地板）。
- en: NOTE The transform is applied instantly, but you may prefer seeing the movement
    when the door opens. As mentioned in chapter 3, you can use tweens to make objects
    move smoothly over time. The word *tween* means different things in different
    contexts, but in game programming it refers to code commands that cause objects
    to move around; appendix D mentions tweening systems for Unity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：变换是即时应用的，但你可能更喜欢在门打开时看到移动。如第3章所述，你可以使用tween使对象在一段时间内平滑移动。在不同的上下文中，“tween”这个词有不同的含义，但在游戏编程中，它指的是导致对象移动的代码命令；附录D提到了Unity的tweening系统。
- en: Other code needs to call Operate() to make the door open and close (the single
    function call handles both cases). You don’t yet have that other script on the
    player, so writing that is the next step.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码需要调用Operate()来使门打开和关闭（单个函数调用处理两种情况）。你还没有在玩家上放置那个其他脚本，所以编写这个脚本是下一步。
- en: 9.1.2 Checking distance and facing before opening the door
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 在开门前检查距离和朝向
- en: Create a new script and name it DeviceOperator. This listing implements a control
    key that operates nearby devices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为DeviceOperator。这个列表实现了一个控制键，用于操作附近的设备。
- en: Listing 9.2 Device control key for the player
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 玩家设备控制键
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ How far away from the player to activate devices
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 激活设备时玩家距离多远
- en: ❷ Respond when the named key is pressed down.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当按下指定的键时做出响应。
- en: ❸ OverlapSphere() returns a list of nearby objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ OverlapSphere()返回一个附近对象的列表。
- en: ❹ SendMessage() tries to call the named function, regardless of the target’s
    type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ SendMessage()试图调用指定的函数，而不考虑目标类型。
- en: The majority of this listing should look familiar, but a crucial new method
    is at the center. First, establish a value for how far away to operate devices
    from. Then, in the Update() function, look for keyboard input. Just as the RelativeMovement
    script uses GetButtonDown() and a button from the project’s input settings, this
    time you’ll use GetKeyDown() for input from a specific letter key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的大部分内容应该看起来很熟悉，但中心有一个关键的新方法。首先，确定操作设备距离的值。然后，在Update()函数中，查找键盘输入。就像RelativeMovement脚本使用GetButtonDown()和项目输入设置中的一个按钮一样，这次你将使用GetKeyDown()来获取特定字母键的输入。
- en: 'Now we get to the crucial new method: OverlapSphere(). This method returns
    an array of all objects that are within a given distance of a given position.
    By passing in the position of the player and the radius variable, this method
    detects all objects near the player. What you do with this list can vary (perhaps
    you set off a bomb and want to apply an explosive force), but in this situation
    you want to attempt to call Operate() on all nearby objects.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了关键的新方法：OverlapSphere()。这个方法返回一个数组，包含所有位于给定位置一定距离内的对象。通过传入玩家的位置和半径变量，这个方法可以检测到玩家附近的全部对象。你可以根据这个列表进行不同的操作（比如你可能想要引爆一个炸弹并施加爆炸力），但在这个情况下，你想要尝试在所有附近的对象上调用Operate()方法。
- en: That method is called via SendMessage() instead of the typical dot notation,
    an approach you also saw with UI buttons in previous chapters. As was the case
    there, you use SendMessage() because you don’t know the exact type of the target
    object, and that command works on all GameObjects. But this time you’re going
    to pass the DontRequireReceiver option to the method. This is because most of
    the objects returned by OverlapSphere() won’t have an Operate() method; normally,
    SendMessage() prints an error message if nothing in the object received the message,
    but in this case the error messages would be distracting because you already know
    most objects will ignore the message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方法是通过SendMessage()而不是典型的点符号调用的，这种做法你也在之前的章节中看到过UI按钮的使用。就像之前那样，你使用SendMessage()是因为你不知道目标对象的精确类型，而这个命令适用于所有GameObject。但这次你将传递DontRequireReceiver选项给这个方法。这是因为OverlapSphere()返回的大多数对象不会有Operate()方法；通常，如果对象没有接收消息，SendMessage()会打印一个错误信息，但在这个情况下，错误信息会分散注意力，因为你已经知道大多数对象会忽略这个消息。
- en: Once the code is written, you can attach this script to the player object. Now
    you can open and close the door by standing near it and pressing the key.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码编写完成，你可以将这个脚本附加到玩家对象上。现在你可以通过站在门附近并按下一个键来打开和关闭门。
- en: You can fix one little detail. Currently, it doesn’t matter which way the player
    is facing, as long as the player is close enough. But you could also adjust the
    script to operate only devices the player is facing, so let’s do that. Recall
    from chapter 8 that you can calculate the dot product for checking facing. That’s
    a mathematical operation done on a pair of vectors that returns a range between
    *-N* and *N*, with *N* meaning they point in exactly the same direction and *-N*
    when they point in exactly opposite directions. Well, *N* is 1 when the vectors
    are normalized, resulting in an easy-to-work-with range from -1 to 1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修复一个小细节。目前，玩家面向哪个方向无关紧要，只要玩家足够近即可。但你也可以调整脚本，使其仅操作玩家面向的设备，让我们这么做。回想第8章，你可以计算点积来检查面向。这是一个在两个向量上进行的数学运算，返回介于
    *-N* 和 *N* 之间的范围，其中 *N* 表示它们指向完全相同的方向，而 *-N* 表示它们指向完全相反的方向。嗯，当向量归一化时，*N* 为 1，结果是一个从
    -1 到 1 的易于处理的范围。
- en: Definition When a vector is *normalized*, the result continues to point in the
    same direction, but its length (also referred to as its *magnitude*) is adjusted
    to 1\. Many mathematical operations work best with normalized vectors, so Unity
    provides properties that return normalized vectors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 当一个向量被 *归一化* 时，结果将继续指向同一方向，但其长度（也称为其 *大小*）将被调整为 1。许多数学运算最适合使用归一化向量，因此 Unity
    提供了返回归一化向量的属性。
- en: Here is the new code in the DeviceOperator script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 DeviceOperator 脚本中的新代码。
- en: Listing 9.3 Adjusting DeviceOperator to operate only devices that the player
    faces
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 调整 DeviceOperator 以仅操作玩家面向的设备
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Vertical correction so the direction won’t point up or down
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 垂直校正以确保方向不会指向上下
- en: ❷ Send the message only when facing the right direction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅在面向正确方向时发送消息。
- en: To use the dot product, you first determine the direction to check against.
    That would be the direction from the player to the object; make a direction vector
    by subtracting the position of the player from the position of the object (with
    the vertical position corrected, so that the direction will be horizontal instead
    of pointing down at the lowered door). Then call Vector3.Dot() with both that
    direction vector and the forward direction of the player. When the dot product
    is close to 1 (specifically, this code checks whether it is greater than 0.5),
    the two vectors are close to pointing in the same direction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用点积，你首先确定要检查的方向。那将是玩家到物体的方向；通过从物体的位置减去玩家的位置（垂直位置已校正，因此方向将是水平的而不是指向降低的门）来制作一个方向向量。然后使用
    Vector3.Dot() 函数调用该方向向量和玩家的前方方向。当点积接近 1（具体来说，此代码检查它是否大于 0.5）时，两个向量几乎指向同一方向。
- en: With this adjustment made, the door won’t open and close when the player faces
    away from it, even if the player is close. And this same approach to operating
    devices can be used with any sort of device. To demonstrate that flexibility,
    let’s create another example device.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此调整后，当玩家背对门时，门不会打开和关闭，即使玩家很近。并且这种操作设备的方法可以用于任何类型的设备。为了展示这种灵活性，让我们创建另一个示例设备。
- en: 9.1.3 Operating a color-changing monitor
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 操作颜色变化的显示器
- en: We’ve created a door that opens and closes, but that same device-operating logic
    can be used with any sort of device. You’re going to create another device that’s
    operated in the same way; this time, you’ll create a color-changing display on
    the wall.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个可以打开和关闭的门，但相同的设备操作逻辑可以用于任何类型的设备。你将创建另一个以相同方式操作的设备；这次，你将在墙上创建一个颜色变化的显示器。
- en: Create a new cube and place it so that one side is barely sticking out of the
    wall. For example, I went with Position 10.9, 1.5, -5. Now create a new script
    called ColorChangeDevice and attach that script (listing 9.4) to the wall display.
    Run up to the wall monitor and press the same “operate” key as used with the door;
    you should see the display change color, as figure 9.2 illustrates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的立方体，并将其放置在墙壁的一侧几乎伸出墙壁的位置。例如，我选择了位置 10.9，1.5，-5。现在创建一个新的脚本，命名为 ColorChangeDevice，并将其（列表
    9.4）附加到墙壁显示器上。走到墙壁显示器前，按下与门相同的“操作”键；你应该看到显示器颜色改变，如图 9.2 所示。
- en: '![CH09_F02_Hocking3](../Images/CH09_F02_Hocking3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Hocking3](../Images/CH09_F02_Hocking3.png)'
- en: Figure 9.2 Color-changing display embedded in the wall
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 嵌入墙中的颜色变化显示器
- en: Listing 9.4 Script for a device that changes color
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 改变颜色的设备脚本
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Declare a method with the same name as the door script.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明一个与门脚本具有相同名称的方法。
- en: ❷ The numbers are RGB values that range from 0 to 1.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些数字是介于0到1之间的RGB值。
- en: ❸ The color is set in the material attached to the object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 颜色设置在附加到对象上的材质中。
- en: To start with, declare the same function name as the door script used. Operate
    is the function name that the device operator script uses, so you need to use
    that name for it to be triggered. Inside this function, the code assigns a random
    color to the object’s material (remember, color isn’t an attribute of the object
    itself, but rather the object has a material, and that material can have a color).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明与门脚本使用的相同函数名。Operate是设备操作脚本使用的函数名，所以你需要使用这个名字来触发它。在这个函数内部，代码将随机颜色分配给对象的材质（记住，颜色不是对象的属性，而是对象有一个材质，而这个材质可以有颜色）。
- en: NOTE Although the color is defined with Red, Blue, and Green components, as
    is standard in most computer graphics, the values in Unity’s Color object vary
    between 0 and 1, instead of 0 and 255, as is common in most places (including
    Unity’s color picker UI).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管颜色是通过红色、蓝色和绿色组件定义的，这与大多数计算机图形的标准一致，但Unity的Color对象中的值在0到1之间变化，而不是在大多数地方（包括Unity的颜色选择器UI）常见的0到255。
- en: All right, so we’ve gone over one approach to interacting with devices in the
    game and have even implemented a couple of devices to demonstrate. Another way
    of interacting with items is by bumping into them, so let’s go over that next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经介绍了一种与游戏中的设备交互的方法，甚至实现了一些设备来演示。与物品交互的另一种方法是碰撞它们，所以让我们来看看这一点。
- en: 9.2 Interacting with objects by bumping into them
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 通过碰撞物体与物体交互
- en: In the previous section, devices were operated by keyboard input from the player,
    but that’s not the only way players can interact with items in the level. Another
    straightforward approach is to respond to collisions with the player. Unity handles
    most of that for you, by having collision detection and physics built into the
    game engine. Unity will detect collisions for you, but you still need to program
    the object to respond.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，设备是通过玩家的键盘输入来操作的，但这并不是玩家与关卡中的物品交互的唯一方式。另一种直接的方法是响应与玩家的碰撞。Unity通过在游戏引擎中内置碰撞检测和物理为你处理大部分工作。Unity会为你检测碰撞，但你仍然需要编程对象以做出响应。
- en: 'We’ll go over three collision responses that are useful for games:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍三种对游戏有用的碰撞响应：
- en: Push away and fall over
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推开并倒下
- en: Trigger a device in the level
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发关卡中的设备
- en: Disappear on contact (for item pickups)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系时消失（用于物品拾取）
- en: 9.2.1 Colliding with physics-enabled obstacles
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 与启用了物理的障碍物碰撞
- en: To start, you’re going to create a pile of boxes and then cause the pile to
    collapse when the player runs into it. Although the physics calculations involved
    are complicated, Unity has all of that built in and will scatter the boxes in
    a realistic way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一堆盒子，然后当玩家撞到它时使这堆盒子倒塌。尽管涉及的物理计算很复杂，但Unity已经内置了所有这些，并将以逼真的方式散布盒子。
- en: By default, Unity doesn’t use its physics simulation to move objects around.
    That can be enabled by adding a Rigidbody component to the object. This concept
    was first discussed in chapter 3, because the enemy’s fireballs also needed a
    Rigidbody component. As I explained in that chapter, Unity’s physics system will
    act only on objects that have a Rigidbody component. Look for Rigidbody by clicking
    Add Component and going to the Physics (not Physics 2D!) menu.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity不会使用其物理模拟来移动对象。可以通过向对象添加Rigidbody组件来启用此功能。这个概念首次在第3章中讨论，因为敌人的火球也需要一个Rigidbody组件。正如我在那一章中解释的，Unity的物理系统只会对具有Rigidbody组件的对象起作用。通过点击添加组件并进入物理（不是物理2D！）菜单来查找Rigidbody。
- en: Create a new cube object and then add a Rigidbody component to it. Create several
    such cubes and position them in a neat stack. For example, in the sample download,
    I created five boxes and stacked them into two tiers (see figure 9.3).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的立方体对象，然后向其添加一个Rigidbody组件。创建几个这样的立方体并将它们整齐地堆叠起来。例如，在示例下载中，我创建了五个盒子并将它们堆叠成两层（见图9.3）。
- en: '![CH09_F03_Hocking3](../Images/CH09_F03_Hocking3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Hocking3](../Images/CH09_F03_Hocking3.png)'
- en: Figure 9.3 Stack of five boxes to collide with
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 要碰撞的五层盒子堆
- en: The boxes are now ready to react to physics forces. To have the player apply
    a force to the boxes, make the small addition shown in the following listing to
    the RelativeMovement script (this is one of the scripts written in chapter 8)
    that’s on the player.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在箱子已经准备好对物理力做出反应。为了让玩家对箱子施加力量，将以下列表中所示的小修改添加到玩家上的 RelativeMovement 脚本（这是第 8
    章中编写的脚本之一）中。
- en: Listing 9.5 Adding physics force to the RelativeMovement script
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 向 RelativeMovement 脚本添加物理力
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Amount of force to apply
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要应用的力量大小
- en: ❷ Check if the collided object has a Rigidbody to receive physics forces.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查碰撞的物体是否具有 Rigidbody 以接收物理力。
- en: ❸ Apply velocity to the physics body.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将速度应用于物理体。
- en: 'There’s not much to explain about this code: whenever the player collides with
    something, check whether the collided object has a Rigidbody component. If so,
    apply a velocity to that Rigidbody.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有太多需要解释的：每当玩家与某个物体碰撞时，检查碰撞的物体是否具有 Rigidbody 组件。如果是，则向该 Rigidbody 应用速度。
- en: Play the game and then run into the pile of boxes; you should see them scatter
    around realistically. And that’s all you have to do to activate physics simulation
    on a stack of boxes in the scene! Unity has physics simulation built in, so you
    don’t have to write much code. That simulation can cause objects to move around
    in response to collisions, but another possible response is firing trigger events,
    so let’s use those trigger events to control the door.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并撞向箱子堆；你应该看到它们真实地散开。这就是你需要在场景中的箱子堆上激活物理模拟所需要做的全部！Unity 内置了物理模拟，所以你不需要编写很多代码。这种模拟可以使物体在碰撞响应时移动，但另一种可能的响应是触发事件，所以让我们使用这些触发事件来控制门。
- en: 9.2.2 Operating the door with a trigger object
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用触发对象操作门
- en: Previously, the door was operated by a keypress. This time it will open and
    close in response to the character colliding with another object in the scene.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，门是通过按键操作的。这次它将在角色与场景中的另一个物体碰撞时打开和关闭。
- en: Create yet another door and place it in another wall gap (I duplicated the previous
    door and moved the new door to -2.5, 1.5, -17). Now create a new cube to use for
    the trigger object, and select the Is Trigger check box for the collider (this
    step was illustrated when making the fireball in chapter 3). In addition, set
    the trigger object to the Ignore Raycast layer; the top-right corner of the Inspector
    has a Layer menu. Finally, you should turn off Cast Shadows from this object (remember,
    this setting is under Mesh Renderer when you select the object).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '创建另一个门并将其放置在另一个墙缝中（我复制了之前的门并将新门移动到 -2.5, 1.5, -17）。现在创建一个新的立方体作为触发对象，并选择碰撞器的“Is
    Trigger”复选框（这一步骤在第 3 章制作火球时已说明）。此外，将触发对象设置为“Ignore Raycast”层；检查器的右上角有一个“Layer”菜单。最后，你应该关闭此对象的“Cast
    Shadows”（记住，当你选择对象时，这个设置在“Mesh Renderer”下）。 '
- en: 'WARNING These tiny steps are easy to miss but important: To use an object as
    a trigger, be sure to turn on Is Trigger. In the Inspector, look for the check
    box in the Collider component. Also, change the layer to Ignore Raycast so that
    the trigger object won’t show up in raycasting.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这些微小的步骤很容易被忽略但很重要：要使用对象作为触发器，请确保启用“Is Trigger”。在检查器中，寻找 Collider 组件中的复选框。此外，将层更改为“Ignore
    Raycast”，这样触发对象就不会出现在射线投射中。
- en: NOTE When trigger objects were introduced in chapter 3, the object needed to
    have a Rigidbody component added. Rigidbody isn’t required for the trigger this
    time because the trigger will be responding to the player (versus colliding with
    a wall, the earlier situation). For triggers to work, either the trigger or the
    object entering the trigger needs to have Unity’s physics system enabled; a Rigidbody
    component fulfills this requirement, but so does the player’s character controller.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第 3 章介绍触发对象时，该对象需要添加 Rigidbody 组件。这次触发不需要 Rigidbody 组件，因为触发对象将响应玩家（与之前碰撞墙壁的情况不同）。为了触发器能够工作，触发器或进入触发器的对象需要启用
    Unity 的物理系统；Rigidbody 组件满足这一要求，但玩家的角色控制器也是如此。
- en: Position and scale the trigger object so that it both encompasses the door and
    surrounds an area around the door; I used Position -2.5, 1.5, -17 (same as the
    door) and Scale 7.5, 3, 6. Additionally, you may want to assign a semitransparent
    material to the object so that you can visually distinguish trigger volumes from
    solid objects. Create a new material by using the Assets menu, and select the
    new material in the Project view. Looking at the Inspector, the top setting is
    Rendering Mode (currently set to the default value of Opaque); select Transparent
    in this menu.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将触发对象的位置和缩放调整到既包括门又围绕门周围的一个区域；我使用了位置 -2.5, 1.5, -17（与门相同）和缩放 7.5, 3, 6。此外，你可能还想将半透明材质分配给对象，以便你可以从视觉上区分触发体积和固体对象。通过使用
    Assets 菜单创建一个新的材质，并在项目视图中选择该新材质。查看检查器，顶部设置是渲染模式（当前设置为默认值不透明）；在此菜单中选择透明。
- en: Now click the Albedo color swatch to bring up the Color Picker window. Pick
    green in the main part of the window, and lower the alpha by using the bottom
    slider. Drag this material from Project onto the object; figure 9.4 shows the
    trigger with this material.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击 Albedo 颜色样本以打开颜色选择器窗口。在窗口的主要部分选择绿色，并使用底部的滑块降低 alpha 值。将此材质从项目拖动到对象上；图 9.4
    显示了带有此材质的触发器。
- en: '![CH09_F04_Hocking3](../Images/CH09_F04_Hocking3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F04_Hocking3](../Images/CH09_F04_Hocking3.png)'
- en: Figure 9.4 Trigger volume surrounding the door it will trigger
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 围绕门的触发体积
- en: DEFINITION *Triggers* are often referred to as *volumes* rather than objects
    to conceptually differentiate solid objects from objects you can move through.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *触发器* 通常被称为 *体积* 而不是对象，以概念上区分固体对象和可以穿过的对象。
- en: Play the game now and you can freely move through the trigger volume. Unity
    still registers collisions with the object, but those collisions don’t affect
    the player’s movement anymore. To react to the collisions, you need to write code.
    Specifically, you want this trigger to control the door. Create a new script called
    DeviceTrigger.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏，你可以自由地穿过触发体积。Unity 仍然会检测到与对象的碰撞，但这些碰撞不再影响玩家的移动。要响应碰撞，你需要编写代码。具体来说，你希望这个触发器控制门。创建一个新的脚本，命名为
    DeviceTrigger。
- en: Listing 9.6 Code for a trigger that controls a device
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 控制设备的触发器代码
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ List of target objects that this trigger will activate
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此触发器将激活的目标对象列表
- en: ❷ OnTriggerEnter() is called when another object enters the trigger volume .
    . .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当另一个对象进入触发体积时，调用 OnTriggerEnter() ...
- en: ❸ . . . whereas OnTriggerExit() is called when an object leaves the trigger
    volume.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ... whereas OnTriggerExit() 被调用时，一个对象离开触发体积。
- en: This listing defines an array of target objects for the trigger; even though
    it’ll be a list of only one most of the time, it’s possible to have multiple devices
    controlled by a single trigger. Loop through the array of targets to send a message
    to all the targets. This loop happens inside the OnTriggerEnter() and OnTriggerExit()
    methods. These functions are called once when another object first enters and
    exits the trigger (as opposed to being called over and over while the object is
    inside the trigger volume).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表定义了触发器的目标对象数组；尽管大多数时候它将是一个只有一个对象的列表，但可能有一个触发器控制多个设备。遍历目标数组，向所有目标发送消息。这个循环发生在
    OnTriggerEnter() 和 OnTriggerExit() 方法内部。这些函数在另一个对象首次进入和退出触发体积时被调用一次（而不是在对象在触发体积内部时反复调用）。
- en: Notice that the messages being sent are different from before; now you need
    to define the Activate() and Deactivate() functions on the door. Add the code
    in the next listing to the DoorOpenDevice script.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在发送的消息与之前不同；现在你需要在门上定义 Activate() 和 Deactivate() 函数。将下一列表中的代码添加到 DoorOpenDevice
    脚本中。
- en: Listing 9.7 Adding activate and deactivate functions to the DoorOpenDevice script
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 将激活和去激活函数添加到 DoorOpenDevice 脚本中
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Open the door only if it isn’t already open.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅当门未打开时才打开门。
- en: ❷ Close the door only if it isn’t already closed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅当门未关闭时才关闭门。
- en: The new Activate() and Deactivate() methods are much the same code as the Operate()
    method from earlier, except now separate functions open and close the door instead
    of only one function that handles both cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Activate() 和 Deactivate() 方法与早期的 Operate() 方法几乎相同，区别在于现在有单独的函数来打开和关闭门，而不是只有一个函数处理这两种情况。
- en: With all the necessary code in place, you can now use the trigger volume to
    open and close the door. Put the DeviceTrigger script on the trigger volume and
    then link the door to the targets property of that script; in the Inspector, first
    set the size of the array and then drag objects from the Hierarchy view over to
    slots in the targets array. Because you have only one door that you want to control
    with this trigger, type 1 in the array’s Size field and then drag that door into
    the target slot.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了所有必要的代码后，你现在可以使用触发体积来打开和关闭门。将设备触发器脚本放在触发体积上，然后将门链接到该脚本的“目标”属性；在检查器中，首先设置数组的大小，然后将对象从层次结构视图拖动到目标数组的槽位中。因为你只想用这个触发器控制一个门，所以在数组的“大小”字段中输入
    1，然后将那个门拖入目标槽位。
- en: With all of this done, play the game and watch what happens to the door when
    the player walks toward and away from it. It’ll open and close automatically as
    the player enters and leaves the trigger volume.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，玩游戏并观察当玩家走向和远离门时门会发生什么。当玩家进入和离开触发体积时，门会自动打开和关闭。
- en: That’s another great way to put interactivity into levels! But this trigger
    volume approach doesn’t work only with devices like doors; you can also use this
    approach to make collectible items.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是将交互性引入关卡的另一种极好的方法！但这种方法不仅适用于像门这样的设备；你还可以使用这种方法来制作可收集物品。
- en: 'Exercise: Trigger devices in 2D platformer'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：在 2D 平台游戏中实现触发设备
- en: In this chapter, you’ve implemented triggers in a 3D game, but the logic is
    almost exactly the same to do this in a 2D game; you’d just be reacting to 2D
    colliders instead, using OnTrigger2D. As an exercise, go back to the 2D platform
    game from chapter 6 and implement trigger volumes and devices in that platformer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经在 3D 游戏中实现了触发器，但要在 2D 游戏中做同样的事情逻辑几乎完全相同；你只需对 2D 碰撞体做出反应，使用`OnTrigger2D`。作为一个练习，回到第
    6 章的 2D 平台游戏，并在那个平台游戏中实现触发体积和设备。
- en: 9.2.3 Collecting items scattered around the level
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 在关卡中收集散落的物品
- en: Many games include items that can be picked up by the player. These items include
    equipment, health packs, and power-ups. The basic mechanism of colliding with
    items to pick them up is simple; most of the complicated stuff happens after items
    are picked up, but we’ll get to that a bit later.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏包括玩家可以捡起的物品。这些物品包括装备、健康包和增强效果。与物品碰撞以捡起它们的基本机制很简单；大多数复杂的事情发生在捡起物品之后，但我们会稍后讨论这一点。
- en: Create a sphere object and place it hovering at about waist height in an open
    area of the scene. Make the object small (like Scale 0.5, 0.5, 0.5), but otherwise
    prepare it as you did with the large trigger volume. Select the Is Trigger setting
    in the collider, set the object to the Ignore Raycast layer, and then create a
    new material to give the object a distinct color. Because the object doesn’t cover
    much, you don’t need to make it semitransparent, so don’t turn down the alpha
    slider this time. Also, as mentioned in chapter 8, settings are available for
    removing the shadows cast from this object; whether to use the shadows is a judgment
    call, but for small pickup items like this, I prefer to turn them off.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个球体对象，并将其放置在场景中一个开阔区域腰部高度的位置。使对象变小（例如缩放 0.5, 0.5, 0.5），但除此之外，按照你处理大型触发体积的方式准备它。在碰撞器中选择“是触发器”设置，将对象设置为忽略射线投射层，然后创建一个新的材质，给对象一个独特的颜色。因为对象覆盖面积不大，所以不需要使其半透明，所以这次不要降低
    alpha 滑块。此外，如第 8 章所述，有设置可以移除由此对象产生的阴影；是否使用阴影是一个判断问题，但对于像这样的小型拾取物品，我更喜欢将其关闭。
- en: Now that the object in the scene is ready, create a new script to attach to
    that object. Call the script CollectibleItem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景中的对象已经准备好了，创建一个新的脚本并将其附加到该对象上。将脚本命名为CollectibleItem。
- en: Listing 9.8 Script that makes an item delete itself on contact with the player
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8：与玩家接触时使项目删除自身的脚本
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Type the name of this item in the Inspector.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在检查器中输入此物品的名称。
- en: This script is extremely short and simple. Give the item a name value so that
    different items can be in the scene. OnTriggerEnter()destroys itself. A debug
    message is also being printed to the console; eventually it will be replaced with
    useful code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本非常简短且简单。给项目一个名称值，以便不同的项目可以出现在场景中。`OnTriggerEnter()`会销毁自身。同时，还会在控制台打印一条调试信息；最终它将被有用的代码所取代。
- en: WARNING Be sure to call Destroy() on this.gameObject and not this! Don’t get
    confused between the two; this refers only to this script component, whereas this.gameObject
    refers to the object the script is attached to.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 确保调用this.gameObject上的Destroy()而不是this！不要混淆这两个；这仅指代此脚本组件，而this.gameObject指的是脚本附加到的对象。
- en: 'Back in Unity, the variable you added to the code should become visible in
    the Inspector. Type in a name to identify this item; I went with energy for my
    first item. Then duplicate the item a few times and change the name of the copies;
    I also created ore, health, and key (these names must be exact because they’ll
    be used in code later). Also create separate materials for each item to give them
    distinct colors: I used light blue energy, dark gray ore, pink health, and yellow
    key.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，你添加到代码中的变量应该在Inspector中可见。输入一个名称来标识此物品；我选择了“能量”作为我的第一个物品。然后复制几次物品并更改副本的名称；我还创建了矿石、健康和钥匙（这些名称必须是确切的，因为它们将在后面的代码中使用）。此外，为每个物品创建单独的材料，以赋予它们不同的颜色：我使用了浅蓝色能量、深灰色矿石、粉色健康和黄色钥匙。
- en: TIP Rather than a name, as we’ve done here, items in more complex games often
    have an identifier used to look up further data. For example, one item might be
    assigned ID 301, and ID 301 correlates to a certain display name, image, description,
    and so forth.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 与我们在这里所做的不一样，在更复杂的游戏中，物品通常有一个用于查找更多数据的标识符。例如，一个物品可能被分配ID 301，而ID 301与某个显示名称、图像、描述等相关联。
- en: Now make prefabs of the items so you can clone them throughout the level. In
    chapter 3, I explained that dragging an object from the Hierarchy view down to
    the Project view will turn that object into a prefab; do that for all four items.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在制作物品的预制体，这样你就可以在整个关卡中克隆它们。在第3章中，我解释了将对象从Hierarchy视图拖拽到Project视图会将该对象转换为预制体；为所有四个物品都这样做。
- en: NOTE The object’s name will turn blue in the Hierarchy list; blue names indicate
    objects that are instances of a prefab. Right-click a prefab instance to pick
    Select Prefab and select the prefab that the object is an instance of.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 对象的名称将在Hierarchy列表中变为蓝色；蓝色名称表示预制体的实例。右键单击预制体实例，选择Select Prefab，然后选择该对象是其实例的预制体。
- en: Drag out instances of the prefabs and place the items in open areas of the level;
    even drag out multiple copies of the same item to test with. Play the game and
    run into items to collect them. That’s pretty neat, but at the moment nothing
    happens when you collect an item. You’re going to start keeping track of the items
    collected; to do that, you need to set up the inventory code structure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将预制体的实例拖拽出来，并将物品放置在关卡的可开放区域；甚至可以拖拽出同一物品的多个副本进行测试。玩游戏并遇到物品来收集它们。这相当不错，但目前在收集物品时没有任何动作发生。你将开始跟踪收集到的物品；为此，你需要设置库存代码结构。
- en: 9.3 Managing inventory data and game state
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 管理库存数据和游戏状态
- en: Now that you’ve programmed the features of collecting items, you need background
    data managers (similar to web coding patterns) for the game’s inventory. The code
    you’ll write will be similar to the MVC architectures behind many web applications.
    The advantage of these data managers is in decoupling data storage from the objects
    that are displayed onscreen, allowing for easier experimentation and iterative
    development. Even when the data and/or displays are complex, changes in one part
    of the application don’t affect other parts of the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了收集物品的功能，你需要为游戏库存设置背景数据管理器（类似于网络编码模式）。你将要编写的代码将与许多网络应用程序背后的MVC架构相似。这些数据管理器的优势在于将数据存储与屏幕上显示的对象解耦，这使得实验和迭代开发更加容易。即使数据和/或显示很复杂，应用程序某一部分的更改也不会影响其他部分。
- en: That said, such structures vary a lot among games, because not every game has
    the same data-management needs. For example, a role-playing game will have high
    data-management needs, so you probably want to implement something like an MVC
    architecture. A puzzle game, though, has little data to manage, so building a
    complex decoupled structure of data managers would be overkill. Instead, the game
    state can be tracked in the scene-specific controller objects (indeed, that’s
    how we handled game state in previous chapters).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，不同游戏之间的这些结构差异很大，因为并非每个游戏都有相同的数据管理需求。例如，角色扮演游戏会有较高的数据管理需求，因此你可能想要实现类似于MVC架构的东西。然而，解谜游戏的数据管理需求很少，因此构建一个复杂的解耦数据管理器结构将是过度设计。相反，游戏状态可以在场景特定的控制器对象中跟踪（实际上，我们就是这样在前几章处理游戏状态的）。
- en: In this project, you need to manage the player’s inventory. Let’s set up the
    code structure needed for that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你需要管理玩家的库存。让我们设置所需的代码结构。
- en: 9.3.1 Setting up player and inventory managers
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 设置玩家和库存管理器
- en: The general idea here is to split up all the data management into separate,
    well-defined modules, with each managing its own area of responsibility. You’re
    going to create separate modules to maintain player state in PlayerManager (things
    like the player’s health) and maintain the inventory list in InventoryManager.
    These data managers will behave like the *model* in MVC; the *controller* is an
    invisible object in most scenes (it wasn’t needed here, but recall SceneController
    in previous chapters), and the rest of the scene is analogous to the *view*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思路是将所有数据管理分成独立的、定义良好的模块，每个模块负责其自身的责任区域。你将创建独立的模块来维护玩家状态（如玩家的健康）并在InventoryManager中维护库存列表。这些数据管理器将类似于MVC中的*模型*；*控制器*是大多数场景中的一个不可见对象（在这里不需要，但回想一下前几章中的SceneController），而场景的其余部分则类似于*视图*。
- en: A higher-level *manager of managers* will keep track of all the separate modules.
    Besides keeping a list of all the managers, this higher-level manager will control
    the life cycles of the various managers—in particular, initializing them at the
    start. All the other scripts in the game will be able to access these centralized
    modules by going through the main manager. Specifically, other code can use static
    properties in the main manager to connect with the specific module desired.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级别的*管理器管理器*将跟踪所有独立的模块。除了保持所有管理器的列表外，这个高级管理器还将控制各种管理器的生命周期——特别是初始化它们。游戏中的所有其他脚本都可以通过主管理器访问这些集中化的模块。具体来说，其他代码可以使用主管理器中的静态属性来连接到所需的特定模块。
- en: Design patterns for accessing centralized shared modules
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 访问集中化共享模块的设计模式
- en: Over the years, a variety of design patterns have emerged to solve the problem
    of connecting parts of a program to centralized modules that are shared throughout
    the program. For example, the Singleton pattern was enshrined in the original
    “Gang of Four” book about design patterns.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的发展，出现了各种设计模式来解决将程序的一部分连接到程序中共享的集中化模块的问题。例如，Singleton模式在原始的“四人帮”设计模式书中被确立。
- en: But that pattern has fallen out of favor with many software engineers, so they
    use alternative patterns like service locator and dependency injection. In my
    code, I use a compromise between the simplicity of static variables and the flexibility
    of a service locator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种模式已经不被许多软件工程师所青睐，因此他们使用替代模式，如服务定位器和依赖注入。在我的代码中，我使用了一种介于静态变量简单性和服务定位器灵活性之间的折中方案。
- en: This design leaves the code simple to use while also allowing for swapping in
    different modules. For example, requesting InventoryManager by using a singleton
    will always refer to the exact same class, and thus will tightly couple your code
    to that class; conversely, requesting Inventory from a service locator leaves
    the option to return either InventoryManager or DifferentInventoryManager. Sometimes
    it’s handy to be able to switch between slightly different versions of the same
    module (deploying the game on different platforms, for example).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使得代码易于使用，同时也允许替换不同的模块。例如，通过使用单例模式请求InventoryManager将始终引用同一个类，因此将你的代码紧密耦合到该类；相反，通过服务定位器请求Inventory则提供了返回InventoryManager或DifferentInventoryManager的选择。有时能够在不同版本的同一模块之间切换（例如在不同平台上部署游戏）是非常方便的。
- en: For the main manager to reference other modules in a consistent way, these modules
    must all inherit properties from a common base. You’re going to do that with an
    interface; many programming languages (including C#) allow you to define a sort
    of blueprint that other classes need to follow. Both PlayerManager and InventoryManager
    will implement a common interface (called IGameManager in this case), and then
    the main Managers object can treat both PlayerManager and InventoryManager as
    type IGameManager. Figure 9.5 illustrates the setup I’m describing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使主管理器以一致的方式引用其他模块，这些模块都必须继承自一个共同的基类。你将通过接口来实现这一点；许多编程语言（包括C#）允许你定义一种蓝图，其他类需要遵循。PlayerManager和InventoryManager都将实现一个通用接口（在本例中称为IGameManager），然后主管理器对象可以将PlayerManager和InventoryManager都视为IGameManager类型。图9.5展示了我所描述的设置。
- en: '![CH09_F05_Hocking3](../Images/CH09_F05_Hocking3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F05_Hocking3](../Images/CH09_F05_Hocking3.png)'
- en: Figure 9.5 Diagram of the various modules and how they’re related
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5各种模块及其关系的图解
- en: Incidentally, whereas all of the code architecture I’ve been talking about consists
    of invisible modules that exist in the background, Unity still requires scripts
    to be linked to objects in the scene in order to run that code. As you’ve done
    with the scene-specific controllers in previous projects, you’re going to create
    an empty GameObject to link these data managers to.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，虽然我一直在谈论的所有代码架构都由存在于背景中的无形模块组成，但Unity仍然需要将脚本链接到场景中的对象才能运行代码。就像你在之前的项目中为场景特定的控制器所做的那样，你将创建一个空GameObject来将这些数据管理者链接到。
- en: 9.3.2 Programming the game managers
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 编程游戏管理者
- en: All right, so that explains all the concepts behind what you’ll do; it’s time
    to write the code. To start, create a new script called IGameManager.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就解释了你将要做的所有概念背后的内容；现在是时候编写代码了。首先，创建一个名为IGameManager的新脚本。
- en: Listing 9.9 Base interface that the data managers will implement
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 数据管理者将实现的基接口
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ This is an enum you need to define.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是一个你需要定义的枚举。
- en: Hmm, there’s barely any code in this file. Note that it doesn’t even inherit
    from MonoBehaviour; an interface doesn’t do anything on its own and exists only
    to impose structure on other classes. This interface declares one property (a
    variable that has a getter function) and one method; both need to be implemented
    in any class that implements this interface. The status property tells the rest
    of the code whether this module has completed its initialization. The purpose
    of Startup() is to handle the initialization of the manager, so initialization
    tasks happen there and the function sets the manager’s status.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个文件里几乎没有代码。注意，它甚至没有从 MonoBehaviour 继承；一个接口本身并不能做什么，它只是用来对其他类施加结构。这个接口声明了一个属性（一个有
    getter 函数的变量）和一个方法；任何实现这个接口的类都需要实现这两个。状态属性告诉其他代码这个模块是否已经完成了初始化。Startup() 的目的是处理管理器的初始化，所以初始化任务在那里发生，并且函数设置管理器的状态。
- en: Notice that the property is of type ManagerStatus. That’s an enum you haven’t
    written yet, so create the ManagerStatus script.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性的类型是ManagerStatus。那是一个你还没有编写的枚举，所以创建ManagerStatus脚本。
- en: 'Listing 9.10 ManagerStatus: possible states for IGameManager status'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 ManagerStatus：IGameManager状态的可能状态
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is another file with barely any code in it. This time, you’re listing the
    possible states that managers can be in, thereby enforcing that the status property
    will always be one of these listed values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个几乎没有代码的文件。这次，你正在列出管理者可能处于的状态，从而确保状态属性始终是这些列出的值之一。
- en: Now that IGameManager is written, you can implement it in other scripts. Listings
    9.11 and 9.12 contain code for InventoryManager and PlayerManager, respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在IGameManager已经编写好了，你可以在其他脚本中实现它。列表9.11和9.12包含了InventoryManager和PlayerManager的代码。
- en: Listing 9.11 InventoryManager
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 InventoryManager
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Property can be read from anywhere but set only within this script.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 属性可以在任何地方读取，但只能在脚本内部设置。
- en: ❷ Any long-running startup tasks go here.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 长时间运行的启动任务放在这里。
- en: ❸ For long-running tasks, use status Initializing instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于长时间任务，使用状态Initializing。
- en: Listing 9.12 PlayerManager
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 PlayerManager
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Both inherit a class and implement an interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 它们都继承了一个类并实现了一个接口。
- en: ❷ These values could be initialized with saved data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些值可以用保存的数据初始化。
- en: ❸ Other scripts can’t set health directly but can call this function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 其他脚本不能直接设置健康值，但可以调用这个函数。
- en: For now, InventoryManager is a shell that will be filled in later, whereas PlayerManager
    has all the functionality needed for this project. These managers both inherit
    from the MonoBehaviour class and implement the IGameManager interface. That means
    the managers gain all the functionality of MonoBehaviour while also needing to
    implement the structure imposed by IGameManager. The structure in IGameManager
    was one property and one method, so the managers define those two things.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，InventoryManager是一个空壳，稍后将被填充，而PlayerManager拥有这个项目所需的所有功能。这两个管理者都继承自MonoBehaviour类并实现了IGameManager接口。这意味着管理者获得了MonoBehaviour的所有功能，同时还需要实现IGameManager施加的结构。IGameManager的结构是一个属性和一个方法，因此管理者定义了这两件事。
- en: The status property was defined so that the status could be read from anywhere
    (the getter is public) but set only within this script (the setter is private).
    The method in the interface is Startup(), so both managers define that function.
    In both managers, initialization completes right away (InventoryManager doesn’t
    do anything yet, whereas PlayerManager sets a couple of values), so the status
    is set to Started. But data modules may have long-running tasks as part of their
    initialization (such as loading saved data), in which case Startup() will launch
    those tasks and set the manager’s status to Initializing. Change status to Started
    after those tasks complete.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 状态属性被定义为可以从任何地方读取状态（获取器是公共的），但只能在脚本内部设置（设置器是私有的）。接口中的方法是 Startup()，因此两个管理器都定义了该函数。在两个管理器中，初始化立即完成（库存管理器目前什么也不做，而玩家管理器设置了一些值），因此状态被设置为
    Started。但数据模块可能在其初始化过程中有长时间运行的任务（例如加载保存的数据），在这种情况下，Startup() 将启动这些任务并将管理器的状态设置为
    Initializing。在那些任务完成后，将状态更改为 Started。
- en: Great! We’re finally ready to tie everything together with a main manager of
    managers. Create one more script and call it Managers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们终于准备好使用主管理者将一切联系在一起了。创建一个额外的脚本，并将其命名为 Managers。
- en: Listing 9.13 The manager of managers!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 管理器中的管理者！
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Ensure that the various managers exist.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确保各种管理器存在。
- en: ❷ Static properties that other code uses to access managers
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 其他代码用来访问管理器的静态属性
- en: ❸ The list of managers to loop through during the startup sequence
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 启动序列期间循环遍历的管理器列表
- en: ❹ Launch the startup sequence asynchronously.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 异步启动启动序列。
- en: ❺ Keep looping until all managers are started.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 继续循环，直到所有管理器都已启动。
- en: ❻ Pause for one frame before checking again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在再次检查之前暂停一帧。
- en: The most important parts of this pattern are the static properties at the top.
    Those enable other scripts to use syntax like Managers.Player or Managers.Inventory
    to access the various modules. Those properties are initially empty, but they’re
    filled immediately when the code runs in the Awake() method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的最重要的部分是顶部的静态属性。这些属性使其他脚本可以使用 Managers.Player 或 Managers.Inventory 这样的语法来访问各个模块。这些属性最初是空的，但它们在代码在
    Awake() 方法中运行时立即被填充。
- en: TIP Like Start() and Update(), Awake is another method automatically provided
    by MonoBehaviour. It’s similar to Start(), running once when the code first starts
    running. But in Unity’s code-execution sequence, Awake() runs even sooner than
    Start(), allowing for initialization tasks that absolutely must run before any
    other code modules.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 就像 Start() 和 Update() 一样，Awake 也是由 MonoBehaviour 自动提供的方法之一。它与 Start() 类似，在代码首次运行时只运行一次。但在
    Unity 的代码执行序列中，Awake() 比 Start() 运行得更早，允许执行必须在其他任何代码模块之前运行的初始化任务。
- en: The Awake() method also lists the startup sequence, and then launches the coroutine
    to start all the managers. Specifically, the function creates a List and then
    uses List.Add() to add the managers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Awake() 方法还列出了启动序列，然后启动协程以启动所有管理器。具体来说，该函数创建一个列表，然后使用 List.Add() 向其中添加管理器。
- en: 'DEFINITION List is a collection data structure provided by C#. List objects
    are similar to arrays: they’re declared with a specific type and store a series
    of entries in sequence. But a list can change size after being created, whereas
    arrays are created at a static size that can’t change later.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: DEFINITION List 是由 C# 提供的集合数据结构。List 对象类似于数组：它们使用特定类型声明，并按顺序存储一系列条目。但列表在创建后可以改变大小，而数组是在静态大小创建的，之后无法更改。
- en: Because all the managers implement IGameManager, this code can list them all
    as that type and can call the Startup() method defined in each. The startup sequence
    is run as a coroutine so that it will run asynchronously, with other parts of
    the game proceeding too (for example, a progress bar animated on a startup screen).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有管理器都实现了 IGameManager 接口，所以这段代码可以将它们全部列出为该类型，并可以调用每个定义的 Startup() 方法。启动序列作为协程运行，以便它将异步执行，同时游戏的其他部分也在进行（例如，启动屏幕上的进度条动画）。
- en: The startup function first loops through the entire list of managers and calls
    Startup() on each one. Then it enters a loop that keeps checking whether the managers
    have started up and won’t proceed until they all have. Once all the managers are
    started, the startup function finally alerts us to this fact before finally completing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 启动函数首先遍历整个管理器列表，并对每个管理器调用 Startup()。然后它进入一个循环，不断检查管理器是否已启动，并且只有在它们全部启动后才会继续。一旦所有管理器都已启动，启动函数最终会通知我们这一事实，然后最终完成。
- en: TIP The managers you wrote earlier have such simple initialization that no waiting
    is required, but in general this coroutine-based startup sequence can elegantly
    handle long-running asynchronous startup tasks like loading saved data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 你之前编写的管理器初始化如此简单，无需等待，但通常这种基于协程的启动序列可以优雅地处理长时间运行的异步启动任务，如加载数据。
- en: Now all of the code structure has been written. Go back to Unity and create
    a new empty GameObject; as usual with these sorts of empty code objects, position
    it at 0, 0, 0 and give the object a descriptive name like Game Managers. Attach
    the Managers, PlayerManager, and InventoryManager script components to this new
    object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有代码结构都已编写。回到 Unity，创建一个新的空 GameObject；像往常一样，将这些空代码对象放置在 0, 0, 0 位置，并给对象一个描述性的名称，如
    Game Managers。将 Managers、PlayerManager 和 InventoryManager 脚本组件附加到这个新对象上。
- en: When you play the game now, no visible change in the scene should occur, but
    in the console, you should see a series of messages logging the progress of the
    startup sequence. Assuming the managers are starting up correctly, it’s time to
    start programming the inventory manager.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在玩游戏时，场景中不应该出现任何可见的变化，但在控制台中，你应该看到一系列记录启动序列进度的消息。假设管理器启动正确，现在是时候开始编写库存管理器了。
- en: '9.3.3 Storing inventory in a collection object: List vs. Dictionary'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 在集合对象中存储库存：列表与字典
- en: The list of items collected could also be stored as a List object. This listing
    adds a list of items to InventoryManager.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 收集的物品列表也可以存储为列表对象。此列表将物品列表添加到 InventoryManager。
- en: Listing 9.14 Adding items to InventoryManager
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 向 InventoryManager 添加物品
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Initialize the empty item list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化空物品列表。
- en: ❷ Print console message of the current inventory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印当前库存的控制台消息。
- en: ❸ Other scripts can’t manipulate the item list directly but can call this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 其他脚本不能直接操作物品列表，但可以调用此方法。
- en: 'This listing makes two key additions to InventoryManager: a List object to
    store items in and a public method, AddItem(), that other code can call. This
    function adds the item to the list and then prints the list to the console. Now
    let’s make a slight adjustment in the CollectibleItem script to call the new AddItem()
    method.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表为 InventoryManager 增加了两个关键功能：一个用于存储物品的列表对象和一个公共方法 AddItem()，其他代码可以调用。此函数将物品添加到列表中，然后将其打印到控制台。现在让我们在
    CollectibleItem 脚本中稍作调整，以调用新的 AddItem() 方法。
- en: Listing 9.15 Using the new InventoryManager in CollectibleItem
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 在 CollectibleItem 中使用新的 InventoryManager
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now when you run around collecting items, you should see your inventory growing
    in the console messages. This is pretty cool, but it does expose one limitation
    of List data structures: as you collect multiples of the same type of item (such
    as collecting a second Health item), you’ll see both copies listed, instead of
    aggregating all items of the same type (refer to figure 9.6). Depending on your
    game, you may want the inventory to track each item separately, but in most games,
    the inventory should aggregate multiple copies of the same item. It’s possible
    to accomplish this using List, but it’s done more naturally and efficiently using
    Dictionary instead.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你四处收集物品时，你应该在控制台消息中看到你的库存增长。这非常酷，但它也暴露了列表数据结构的一个限制：当你收集相同类型的多个物品（例如收集第二个健康物品）时，你会看到两个副本都被列出，而不是将同一类型的所有物品聚合在一起（参见图
    9.6）。根据你的游戏，你可能希望库存单独跟踪每个物品，但在大多数游戏中，库存应该聚合相同物品的多个副本。使用列表可以实现这一点，但使用字典更自然、更高效。
- en: '![CH09_F06_Hocking3](../Images/CH09_F06_Hocking3.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F06_Hocking3](../Images/CH09_F06_Hocking3.png)'
- en: Figure 9.6 Console message with multiples of the same item listed multiple times
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 列出多个相同物品的多次控制台消息
- en: DEFINITION Dictionary is another collection data structure provided by C#. Entries
    in the dictionary are accessed by an identifier (or key) rather than by their
    position in the list. This is similar to a hash table but more flexible, because
    the keys can be literally any type (for example, “Return the entry for this GameObject”).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DEFINITION 字典是 C# 提供的另一种集合数据结构。字典中的条目通过标识符（或键）访问，而不是通过列表中的位置。这与哈希表类似，但更灵活，因为键可以是任何类型（例如，“返回此
    GameObject 的条目”）。
- en: Change the code in InventoryManager to use Dictionary instead of List. Replace
    everything from listing 9.14 with the code from this listing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将 InventoryManager 中的代码更改为使用字典而不是列表。用此列表中的代码替换列表 9.14 中的所有内容。
- en: Listing 9.16 Dictionary of items in InventoryManager
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 InventoryManager 中的物品字典
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '❶ Dictionary is declared with two types: the key and the value.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Dictionary使用两种类型声明：键和值。
- en: ❷ Check for existing entries before entering new data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在输入新数据之前检查现有条目。
- en: Overall, this code looks the same as before, but a few tricky differences exist.
    If you aren’t already familiar with Dictionary data structures, note that this
    one was declared with two types. Whereas List was declared with only one type
    (the type of values that’ll be listed), a Dictionary declares both the type of
    key (that is, what the identifiers will be) and the type of value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这段代码看起来和之前一样，但存在一些微妙的不同之处。如果你还不熟悉Dictionary数据结构，请注意，这个是使用两种类型声明的。与只声明一个类型（即将被列出的值的类型）的List不同，Dictionary声明了键的类型（即标识符的类型）和值的类型。
- en: A bit more logic exists in the AddItem() method. Before, every item was appended
    to the List, but now you need to check whether the Dictionary already contains
    that item; that’s what the ContainsKey() method is for. If it’s a new entry, then
    you’ll start the count at 1, but if the entry already exists, then increment the
    stored value. Play with the new code and you’ll see that the inventory messages
    have an aggregated count of each item (refer to figure 9.7).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AddItem()方法中存在一些额外的逻辑。之前，每个物品都是追加到List中的，但现在你需要检查字典是否已经包含该物品；这就是ContainsKey()方法的作用。如果是一个新条目，那么计数将从1开始，但如果条目已经存在，那么将增加存储的值。尝试使用新代码，你会看到库存消息中每个物品都有一个聚合计数（参见图9.7）。
- en: '![CH09_F07_Hocking3](../Images/CH09_F07_Hocking3.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F07_Hocking3](../Images/CH09_F07_Hocking3.png)'
- en: Figure 9.7 Console message with multiples of the same item aggregated
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 带有相同物品多次聚合的控制台消息
- en: Whew, finally, collected items are managed in the player’s inventory! This probably
    seems like a lot of code to handle a relatively simple problem, and if this were
    the entire purpose, then, yeah, it would be over-engineered. The point of this
    elaborate code architecture, though, is to keep all the data in separate flexible
    modules, a useful pattern when the game gets more complex. For example, now you
    can write UI displays, and the separate parts of the code will be much easier
    to handle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，终于，收集到的物品现在被管理在玩家的库存中了！这可能看起来处理一个相对简单的问题需要很多代码，如果这就是整个目的，那么，是的，这将是过度设计的。然而，这个复杂的代码架构的目的是将所有数据保存在独立的灵活模块中，当游戏变得更加复杂时，这是一种有用的模式。例如，现在你可以编写UI显示，而代码的各个部分将更容易处理。
- en: 9.4 Inventory UI for using and equipping items
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用和装备项目的库存UI
- en: The collection of items in your inventory can be used in multiple ways within
    the game, but all of those uses first rely on some sort of inventory UI so that
    players can see their collected items. Then, when the inventory is being shown
    to the player, you can program interactivity into the UI by enabling players to
    click their items. Again, you’ll program a couple of specific examples (equipping
    a key and consuming health packs), and then you should be able to adapt this code
    to work with other types of items.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你的库存中的物品可以以多种方式使用，但所有这些用途都首先依赖于某种库存UI，以便玩家可以看到他们收集到的物品。然后，当库存被展示给玩家时，你可以通过允许玩家点击他们的物品来将交互性编程到UI中。再次强调，你将编写几个特定的示例（装备钥匙和消耗生命药包），然后你应该能够将此代码适应到其他类型的物品。
- en: NOTE As mentioned in chapter 7, Unity has both an older immediate mode GUI and
    a newer sprite-based UI system. We’ll use the immediate mode GUI in this chapter
    because that system is faster to implement and requires less setup; less setup
    is great for practice exercises. The sprite-based UI system is more polished,
    though, and for an actual game, you’d want a more polished interface.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如第7章所述，Unity既有较老的即时模式GUI，也有较新的基于精灵的UI系统。在本章中，我们将使用即时模式GUI，因为该系统实现起来更快，需要设置的工作更少；对于练习来说，设置工作越少越好。虽然基于精灵的UI系统更精致，但对于实际游戏，你可能会想要一个更精致的界面。
- en: 9.4.1 Displaying inventory items in the UI
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 在UI中显示库存项目
- en: To show the items in a UI display, you first need to add a couple more methods
    to InventoryManager. Right now, the item list is private and accessible only within
    the manager. To display the list, that information must have public methods for
    accessing the data. Add two methods shown in the following listing to InventoryManager.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UI显示中展示项目，你首先需要向InventoryManager添加几个额外的方法。目前，项目列表是私有的，只能在管理器内部访问。要显示列表，必须提供公共方法来访问数据。向InventoryManager添加以下列表中的两个方法。
- en: Listing 9.17 Adding data access methods to InventoryManager
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 向InventoryManager添加数据访问方法
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Returns a List of all the Dictionary keys
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回所有字典键的列表
- en: ❷ Returns how many of that item are in inventory
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回库存中该项目的数量
- en: The GetItemList() method returns a list of items in the inventory. You might
    be thinking, “Wait a minute, didn’t we just spend lots of effort to convert the
    inventory away from a List?” The difference now is that each type of item will
    appear only once in the list. If the inventory contains two health packs, for
    example, the word health will still appear only once in the list. That’s because
    the List was created from the keys in the Dictionary, not from every individual
    item.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: GetItemList() 方法返回库存中的项目列表。你可能正在想，“等等，我们不是刚刚花费了大量努力将库存从列表中转换过来吗？”现在的不同之处在于列表中每种项目只会出现一次。例如，如果库存中有两个急救包，那么列表中仍然只会出现一次“健康”这个词。这是因为列表是从字典的键创建的，而不是从每个单独的项目创建的。
- en: The GetItemCount() method returns a count of how many of a given item are in
    the inventory. For example, call GetItemCount("health") to ask, “How many health
    packs are in the inventory?” This way, the UI can display a number of each item
    along with displaying each item.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: GetItemCount() 方法返回给定项目在库存中的数量。例如，调用 GetItemCount("health") 来询问，“库存中有多少个急救包？”这样，UI
    可以显示每个项目的数量，同时显示每个项目。
- en: With these methods added to InventoryManager, you can create the UI display.
    Let’s display all the items in a horizontal row across the top of the screen.
    The items will be displayed using icons, so you need to import those images into
    the project. Unity handles assets in a special way if those assets are in a folder
    called Resources.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 InventoryManager 中添加了这些方法后，你可以创建 UI 显示。让我们在屏幕顶部水平显示所有项目。项目将通过图标显示，因此你需要将这些图像导入到项目中。如果这些资产在名为
    Resources 的文件夹中，Unity 会以特殊方式处理这些资产。
- en: TIP Assets placed into the Resources folder can be loaded in code by using the
    Resources.Load() method. Otherwise, assets can be placed in scenes only through
    Unity’s editor.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 将资产放入 Resources 文件夹可以通过使用 Resources.Load() 方法在代码中加载。否则，资产只能通过 Unity 的编辑器放置在场景中。
- en: Figure 9.8 shows the four icon images, along with the directory structure showing
    where to put those images. Create a folder called Resources and then create a
    folder called Icons inside it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 显示了四个图标图像，以及显示这些图像放置位置的目录结构。创建一个名为 Resources 的文件夹，然后在其中创建一个名为 Icons 的文件夹。
- en: '![CH09_F08_Hocking3](../Images/CH09_F08_Hocking3.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F08_Hocking3](../Images/CH09_F08_Hocking3.png)'
- en: Figure 9.8 Image assets for equipment icons placed inside the Resources folder
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 将设备图标图像资产放置在 Resources 文件夹中的图像
- en: The icons are all set up, so create a new empty GameObject named Controller
    and then assign it a new script called BasicUI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图标都已设置好，因此创建一个新的空 GameObject 命名为 Controller，然后给它分配一个新的脚本名为 BasicUI。
- en: Listing 9.18 BasicUI to display the inventory
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 基本UI显示库存
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Display a message if the inventory is empty.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果库存为空，显示一条消息。
- en: ❷ Method loads assets from the Resources folder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 方法从 Resources 文件夹加载资产。
- en: ❸ Shift sideways each time through the loop.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在循环中每次都向侧面移动。
- en: This listing displays the collected items in a horizontal row (see figure 9.9)
    along with displaying the number collected. As mentioned in chapter 3, every MonoBehaviour
    automatically responds to an OnGUI() method. That function runs every frame right
    after the 3D scene is rendered.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示收集的项目在水平行中（见图 9.9），同时显示收集的数量。如第 3 章所述，每个 MonoBehaviour 都会自动响应 OnGUI() 方法。该函数在
    3D 场景渲染后立即每帧运行。
- en: '![CH09_F09_Hocking3](../Images/CH09_F09_Hocking3.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F09_Hocking3](../Images/CH09_F09_Hocking3.png)'
- en: Figure 9.9 UI display of the inventory
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 库存 UI 显示
- en: Inside OnGUI(), first define a bunch of values for positioning UI elements.
    These values are incremented when you loop through all the items in order to position
    UI elements in a row. The specific UI element drawn is GUI.Box; those are noninteractive
    displays that show text and images inside boxes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OnGUI() 函数内部，首先定义一些用于定位 UI 元素的位置值。当你遍历所有项目时，这些值会增加，以便在行中定位 UI 元素。具体绘制的 UI
    元素是 GUI.Box；这些是非交互式显示，在框内显示文本和图像。
- en: The Resources.Load() method is used to load assets from the Resources folder.
    This method is a handy way to load assets by name; notice that the name of the
    item is passed as a parameter. You have to specify a type to load. Otherwise,
    the return value for that method is a generic object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Resources.Load() 方法用于从 Resources 文件夹加载资产。这是一种通过名称加载资产的好方法；注意，项目的名称作为参数传递。你必须指定要加载的类型。否则，该方法的返回值是一个泛型对象。
- en: The UI shows us what items have been collected. Now you can use the items.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: UI 显示了已经收集到的物品。现在你可以使用这些物品了。
- en: 9.4.2 Equipping a key to use on locked doors
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 将钥匙装备用于锁着的门
- en: Let’s go over a couple of examples of using inventory items so that you can
    extrapolate out to any type of item you want. The first example involves equipping
    a key required to open the door.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾几个使用库存物品的例子，这样你就可以推广到任何你想要的物品类型。第一个例子涉及装备一个打开门的钥匙。
- en: At the moment, the DeviceTrigger script doesn’t pay attention to your items
    (because that script was written before the inventory code). This listing shows
    how to adjust that script.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，DeviceTrigger 脚本没有注意到你的物品（因为该脚本是在库存代码之前编写的）。此列表显示了如何调整该脚本。
- en: Listing 9.19 Requiring a key in DeviceTrigger
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 在 DeviceTrigger 中要求钥匙
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, all that’s needed is a new public variable in the script and
    a condition that looks for an equipped key. The requireKey Boolean appears as
    a check box in the Inspector so that you can require a key from some triggers
    but not others. The condition at the beginning of OnTriggerEnter() checks for
    an equipped key in InventoryManager; that requires you to add the code from the
    next listing to InventoryManager.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所需的所有内容只是一个新的公共变量和查找已装备钥匙的条件。requireKey 布尔值在检查器中作为复选框出现，这样您就可以要求某些触发器提供钥匙，而其他则不要求。OnTriggerEnter()
    函数开始处的条件检查 InventoryManager 中的已装备钥匙；这需要您将下一列表中的代码添加到 InventoryManager 中。
- en: Listing 9.20 Equipping code for InventoryManager
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 InventoryManager 的装备代码
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Check that inventory has the item and that the item isn’t already equipped.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查库存中是否有该物品，并且该物品尚未装备。
- en: At the top, add the equippedItem property that gets checked by other code. Then
    add the public EquipItem() method to allow other code to change which item is
    equipped. That method equips an item if it isn’t already equipped, or *unequips*
    if that item is already equipped.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，添加一个由其他代码检查的 equippedItem 属性。然后添加公共 EquipItem() 方法，允许其他代码更改装备的物品。如果该物品尚未装备，则该方法会装备该物品，如果该物品已装备，则
    *解除装备*。
- en: Finally, in order for the player to equip an item, add that functionality to
    the UI. This listing adds a row of buttons for that purpose.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了让玩家能够装备物品，将此功能添加到 UI 中。此列表为此目的添加了一行按钮。
- en: Listing 9.21 Adding equip functionality to BasicUI
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.21 向 BasicUI 添加装备功能
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Italicized code was already in the script, shown here for reference.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 已在脚本中 italicized 的代码，此处仅供参考。
- en: ❷ Display the currently equipped item.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示当前装备的物品。
- en: ❸ Loop through all items to make buttons.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历所有物品以创建按钮。
- en: ❹ Run the contained code if the button is clicked.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果按钮被点击，则运行包含的代码。
- en: GUI.Box() is used again to display the equipped item. But that element is noninteractive,
    so the row of Equip buttons is drawn using GUI.Button() instead. That method creates
    a button that executes the code inside the if statement when clicked.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: GUI.Box() 再次用于显示装备的物品。但该元素是不可交互的，因此使用 GUI.Button() 绘制装备按钮行。该方法创建一个按钮，当点击时执行
    if 语句内的代码。
- en: With all the necessary code in place, select the requireKey option in DeviceTrigger
    and then play the game. Try running into the trigger volume before equipping a
    key; nothing happens. Now collect a key and click the button to equip it. Running
    into the trigger volume opens the door.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有必要的代码就绪后，在 DeviceTrigger 中选择 requireKey 选项，然后玩游戏。尝试在装备钥匙之前进入触发体积；没有任何事情发生。现在收集一个钥匙并点击按钮来装备它。进入触发体积会打开门。
- en: Just for fun, you could put a key at Position -11, 5, -14 to add a simple gameplay
    challenge to see if you can figure out how to reach the key. Whether or not you
    try that, let’s move on to using health packs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，你可以在位置 -11, 5, -14 放一个钥匙，以添加一个简单的游戏挑战，看看你是否能想出如何到达钥匙。无论你是否尝试这样做，让我们继续使用健康包。
- en: 9.4.3 Restoring the player’s health by consuming health packs
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 通过消耗健康包恢复玩家的生命值
- en: 'Using items to restore the player’s health is another generally useful example.
    That requires two code changes: a new method in InventoryManager and a new button
    in the UI (see listings 9.22 and 9.23, respectively).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用物品恢复玩家生命值是另一个普遍有用的例子。这需要两个代码更改：InventoryManager 中的一个新方法和一个 UI 中的新按钮（分别见列表
    9.22 和 9.23）。
- en: Listing 9.22 New method in InventoryManager
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.22 InventoryManager 中的新方法
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Check whether the item is in inventory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查物品是否在库存中。
- en: ❷ Remove the entry if the count goes to 0.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果计数变为 0，则删除条目。
- en: ❸ Response if that item isn’t in inventory
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果该物品不在库存中时的响应
- en: Listing 9.23 Adding a health item to BasicUI
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.23 向 BasicUI 添加健康物品
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Italicized code was already in script, shown here for reference.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 斜体代码已经在脚本中，这里展示以供参考。
- en: ❷ Start of new code
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新代码的开始
- en: ❸ Run the contained code if the button is clicked.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果按钮被点击，则运行包含的代码。
- en: The new ConsumeItem() method is pretty much the reverse of AddItem(). It checks
    for an item in the inventory and decrements if the item is found. It has responses
    to a couple of tricky cases, such as if the item count decrements to 0\. The UI
    code calls this new inventory method, and it calls the ChangeHealth() method that
    PlayerManager has had from the beginning.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 ConsumeItem() 方法基本上是 AddItem() 的逆操作。它会检查库存中的物品，如果找到该物品，则递减。它对一些棘手的情况有响应，例如如果物品计数递减到
    0。UI 代码调用这个新的库存方法，并调用 PlayerManager 从一开始就有的 ChangeHealth() 方法。
- en: If you collect some health items and then use them, you’ll see health messages
    appear in the console. And there you go—multiple examples of how to use inventory
    items!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收集一些健康物品并使用它们，你会在控制台中看到健康信息出现。就这样——展示了如何使用库存物品的多个示例！
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Both keypresses and collision triggers can be used to operate devices.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用按键和碰撞触发器来操作设备。
- en: Objects with physics enabled can respond to collision forces or trigger volumes.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用了物理的对象可以响应碰撞力或触发体积。
- en: Complex game state is managed via special objects that can be accessed globally.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的游戏状态通过可以全局访问的特殊对象进行管理。
- en: Collections of objects can be organized in List or Dictionary data structures.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象集合可以组织在列表或字典数据结构中。
- en: Tracking the equip state of items can be used to affect other parts of the game.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪物品的装备状态可以用来影响游戏的其它部分。
