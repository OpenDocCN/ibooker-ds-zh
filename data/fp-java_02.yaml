- en: Chapter 3\. Making Java more functional
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 使Java更具函数式
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Making standard control structures functional
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使标准控制结构函数化
- en: Abstracting control structures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象控制结构
- en: Abstracting iteration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象迭代
- en: Using the right types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的类型
- en: 'You now have all the types of functions you’ll need. As you saw in the previous
    chapter, these functions don’t require any exceptions to the traditional Java
    coding rules. Using methods as pure functions (a.k.a. functional methods) is perfectly
    in line with most so-called Java best practices. You haven’t changed the rules
    or added any exotic constructs. You’ve just added some restrictions about what
    functional methods can do: they can return a value, and that’s all. They can’t
    mutate any objects or references in the enclosing scope, nor their arguments.
    In the first part of this chapter, you’ll learn how to apply the same principles
    to Java control structures.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了所有需要的函数类型。正如你在上一章中看到的，这些函数不需要违反传统的Java编码规则。将方法作为纯函数（也称为函数式方法）使用与大多数所谓的Java最佳实践完全一致。你没有改变规则或添加任何异构结构。你只是增加了一些关于函数式方法可以做什么的限制：它们可以返回一个值，仅此而已。它们不能修改封装作用域中的任何对象或引用，也不能修改它们的参数。本章的第一部分，你将学习如何将这些相同的原理应用到Java控制结构中。
- en: You’ve also learned how to create objects representing functions, so that these
    functions can be passed as arguments to methods and other functions. But for such
    functions to be useful, you must create the methods or functions that can manipulate
    them. In the second part of this chapter, you’ll learn how to abstract collection
    operations and control structures to use the power of functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何创建表示函数的对象，以便这些函数可以作为参数传递给方法和其他函数。但是，为了使这些函数有用，你必须创建可以操作它们的函数或方法。本章的第二部分，你将学习如何抽象集合操作和控制结构，以利用函数的力量。
- en: The last part of the chapter presents techniques that will allow you to get
    the most out of the type system when handling business problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分介绍了处理业务问题时，如何充分利用类型系统的技术。
- en: 3.1\. Making standard control structures functional
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 使标准控制结构函数化
- en: Control structures are the main building blocks of imperative programming. No
    imperative Java programmer would believe it’s possible to write programs without
    using `if ... else`, `switch ... case`, and `for`, `while`, and `do` loops. These
    structures are the essence of imperative programming. But in the following chapters,
    you’ll learn how to write functional programs with absolutely no control structures.
    In this section, you’ll be less adventurous—we’ll only look at using the traditional
    control structures in a more functional style.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构是命令式编程的主要构建块。没有命令式Java程序员会相信没有使用`if ... else`、`switch ... case`以及`for`、`while`和`do`循环就能编写程序。这些结构是命令式编程的精髓。但在接下来的章节中，你将学习如何编写完全没有控制结构的函数式程序。在本节中，我们将不那么冒险——我们只会探讨以更函数式的方式使用传统的控制结构。
- en: One point you learned in [chapter 2](kindle_split_009.xhtml#ch02) is that purely
    functional methods can’t do anything but return a value. They can’t mutate an
    object or reference in the enclosing scope. The value returned by a method can
    depend only on its arguments, although the method can read data in the enclosing
    scope. In such a case, the data is considered to be implicit arguments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第2章](kindle_split_009.xhtml#ch02)中学到的一点是，纯函数式方法除了返回一个值之外什么都不能做。它们不能修改封装作用域中的对象或引用。方法返回的值只能依赖于其参数，尽管方法可以读取封装作用域中的数据。在这种情况下，数据被认为是隐式参数。
- en: In imperative programming, control structures define a scope in which they generally
    do something, which means they have an effect. This effect might be visible only
    inside the scope of the control structure, or it might be visible in the enclosing
    scope. The control structures might also access the enclosing scope to read values.
    The following listing shows a basic example of email validation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，控制结构定义了一个它们通常在其中执行某些操作的作用域，这意味着它们有影响。这种影响可能只在控制结构的作用域内可见，也可能在封装作用域内可见。控制结构还可以访问封装作用域以读取值。以下列表显示了一个基本的电子邮件验证示例。
- en: Listing 3.1\. Simple email validation
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 简单的电子邮件验证
- en: '![](Images/058fig01_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/058fig01_alt.jpg)'
- en: In this example, the `if ... else` structure ![](Images/num-01.jpg) accesses
    the `emailPattern` variable from the enclosing scope. From the Java syntax point
    of view, there’s no obligation for this variable to be `final`, but it’s necessary
    if you want to make the `testMail` method functional. Another solution would be
    to declare the pattern inside the method, but this would cause it to be compiled
    for each method call. If the pattern could change between calls, you should make
    it a second parameter of the method. If the condition is `true`, an effect ![](Images/num-02.jpg)
    is applied to this email variable. This effect consists of sending a verification
    email, probably to check whether the email address, besides being well formed,
    is a valid one. In this example, the effect is simulated ![](Images/num-04.jpg)
    by printing a message to standard output. If the condition is `false`, a different
    effect ![](Images/num-03.jpg) is applied to the variable by including it in an
    error message. This message is logged ![](Images/num-05.jpg), which once again
    is simulated by printing to *standard error*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`if ... else` 结构 ![图片 1](Images/num-01.jpg) 从封装作用域中访问 `emailPattern`
    变量。从 Java 语法角度来看，这个变量不一定要是 `final`，但如果你想使 `testMail` 方法函数化，这是必要的。另一个解决方案是在方法内部声明模式，但这会导致每次方法调用都重新编译它。如果模式可以在调用之间改变，你应该将其作为方法的第二个参数。如果条件为
    `true`，则对这个电子邮件变量应用一个效果 ![图片 2](Images/num-02.jpg)。这个效果包括发送一个验证电子邮件，可能是为了检查电子邮件地址，除了格式正确外，是否有效。在这个例子中，效果通过将消息打印到标准输出进行模拟
    ![图片 4](Images/num-04.jpg)。如果条件为 `false`，则通过将其包含在错误消息中对该变量应用不同的效果 ![图片 3](Images/num-03.jpg)。这个消息被记录
    ![图片 5](Images/num-05.jpg)，这同样是通过打印到 *标准错误* 来模拟的。
- en: 3.2\. Abstracting control structures
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. 抽象控制结构
- en: The code in [listing 3.1](#ch03ex01) is purely imperative. You’ll never find
    such code in functional programming. Although the `testMail` method seems to be
    a pure effect because it doesn’t return anything, it mixes data processing with
    effects. This is something you want to avoid, because it results in code that’s
    impossible to test. Let’s see how you can clean this up.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.1](#ch03ex01) 中的代码完全是命令式的。在函数式编程中你永远不会找到这样的代码。尽管 `testMail` 方法看起来是一个纯效果，因为它不返回任何内容，但它将数据处理与效果混合在一起。这是你想要避免的事情，因为它会导致无法测试的代码。让我们看看你如何可以清理这个问题。'
- en: The first thing you may want to do is separate computation and effects so you
    can test the computation result. This could be done imperatively, but I prefer
    to use a function, as shown in the following listing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要做的第一件事是分离计算和效果，这样你就可以测试计算结果。这可以通过命令式完成，但我更喜欢使用一个函数，如下面的列表所示。
- en: Listing 3.2\. Using a function to validate the email
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2. 使用函数验证电子邮件
- en: '![](Images/059fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](Images/059fig01_alt.jpg)'
- en: 'Now you can test the data processing part of the program (validating the `email`
    string) because you’ve clearly separated it from the effects. But you still have
    many problems. One is that you handle only the case where the string doesn’t validate.
    But if the string received is `null`, a `NullPointerException` (NPE) is thrown.
    Consider the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以测试程序的数据处理部分（验证 `email` 字符串），因为你已经清楚地将其与效果分离。但你仍然有很多问题。一个是只处理字符串不验证的情况。但如果接收到的字符串是
    `null`，则会抛出 `NullPointerException`（NPE）。考虑以下示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The third line won’t be executed, even though the email address is valid, because
    the NPE thrown by the second line kills the thread. It would be better to get
    a logged message indicating what happened, and to continue processing the next
    address.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使电子邮件地址有效，第三行也不会执行，因为第二行抛出的 NPE 杀死了线程。更好的做法是得到一个记录的消息，表明发生了什么，并继续处理下一个地址。
- en: 'Another problem appears if you receive an empty string:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一个空字符串，会出现另一个问题：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This won’t cause an error, but the address won’t validate, and the following
    message will be logged:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会导致错误，但地址不会验证，以下消息将被记录：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The double space (between “email” and “is”) indicates that the string was empty.
    A specific message would be better, such as this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之间（“email”和“is”之间）的双空格表示字符串为空。一个特定的消息会更好，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To handle these problems, you’ll first define a special component to handle
    the result of the computation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些问题，你首先定义一个特殊组件来处理计算的结果。
- en: Listing 3.3\. A component to manage the result of a computation
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3. 管理计算结果的一个组件
- en: '![](Images/060fig01_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](Images/060fig01_alt.jpg)'
- en: Now you can write your new version of the program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编写你程序的新版本了。
- en: Listing 3.4\. The program with better error handling
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4. 具有更好错误处理的程序
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running this program produces the expected output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序会产生预期的输出：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But this still isn’t satisfactory. Using `instanceof` to determine whether the
    result is a success is ugly. And using a cast to access the failure message is
    even more so. But worse than this is the fact that you have some program logic
    in the `validate` method that can’t be tested. This is because the method is an
    effect, which means it doesn’t return a value but mutates the outside world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然不满意。使用`instanceof`来确定结果是否成功很丑陋。使用类型转换来访问失败消息更丑陋。但更糟糕的是，你在`validate`方法中有一些程序逻辑无法测试。这是因为该方法是一个效果，这意味着它不返回值而是修改外部世界。
- en: Is there a way to fix this? Yes. Instead of sending an email or logging a message,
    you could return a small program that does the same thing. Instead of executing
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有解决问题的方法？是的。与其发送电子邮件或记录消息，不如返回一个执行相同操作的小程序。与其执行
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: you could return instructions that, when executed, will produce the same results.
    Thanks to lambdas, you can do this easily.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以返回执行时会产生相同结果的指令。多亏了lambda表达式，你可以轻松做到这一点。
- en: 'First, you need a functional interface representing an executable program:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个表示可执行程序的函数式接口：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You could have used the standard `Runnable` interface, but most code verifiers
    raise a warning if this interface is used for something other than running a thread.
    So you’ll use your own interface.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以使用标准的`Runnable`接口，但大多数代码验证器如果这个接口用于除了运行线程之外的其他目的，都会发出警告。所以你会使用你自己的接口。
- en: You can easily change your program, as shown in the following listing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地更改你的程序，如下面的列表所示。
- en: Listing 3.5\. Returning executables
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5. 返回可执行程序
- en: '![](Images/ch03ex05-0.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex05-0.jpg)'
- en: '![](Images/ch03ex05-1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex05-1.jpg)'
- en: The `validate` method ![](Images/num-02.jpg) now returns `Executable` instead
    of `void`. It no longer has any side effect, and it’s a pure function. When an
    `Executable` is returned ![](Images/num-01.jpg), it can be executed by calling
    its `exec` method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`方法![图片](Images/num-02.jpg)现在返回`Executable`而不是`void`。它不再有任何副作用，并且是一个纯函数。当返回`Executable`![图片](Images/num-01.jpg)时，可以通过调用它的`exec`方法来执行它。'
- en: Note that the `Executable` could also be passed to other methods or stored away
    to be executed later. In particular, it could be put in a data structure and executed
    in sequence after all computations are done. This allows you to separate the functional
    part of the program from the part that mutates the environment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Executable`也可以传递给其他方法或存储起来稍后执行。特别是，它可以在所有计算完成后放入数据结构中并按顺序执行。这允许你将程序的函数部分与修改环境的部分分开。
- en: You’ve also replaced the `if ... else` control structure with the ternary operator.
    This is a matter of preference. The ternary operator is functional because it
    returns a value and has no side effect. In contrast, the `if ... else` structure
    can be made functional by making it mutate only local variables, but it can also
    have side effects. If you see imperative programs with many embedded `if ... else`
    structures, ask yourself how easy it would be to replace them with the ternary
    operator. This is often a good indication of how close to functional the design
    is. Note, however, that it’s also possible to make the ternary operator nonfunctional
    by calling nonfunctional methods to get the resulting values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你还用三元运算符替换了`if ... else`控制结构。这是一个个人喜好问题。三元运算符是函数式的，因为它返回一个值并且没有副作用。相比之下，`if
    ... else`结构可以通过只修改局部变量来使其函数式，但它也可能有副作用。如果你看到有很多嵌套的`if ... else`结构的命令式程序，问问自己用三元运算符替换它们有多容易。这通常是一个很好的指标，表明设计离函数式有多近。然而，通过调用非函数式方法来获取结果值，三元运算符也可能变得非函数式。
- en: 3.2.1\. Cleaning up the code
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1. 清理代码
- en: Your `validate` method is now functional, but it’s dirty. Using the `instanceof`
    operator is almost always an indication of bad code. Another problem is that reusability
    is low. When the `validate` method returns a value, you have no choice besides
    executing it or not. What if you want to reuse the validation part but produce
    a different effect?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`validate`方法现在是函数式的，但它很脏。使用`instanceof`运算符几乎总是坏代码的迹象。另一个问题是可重用性低。当`validate`方法返回一个值时，除了执行或不执行之外，你没有其他选择。如果你想重用验证部分但产生不同的效果怎么办？
- en: The `validate` method shouldn’t have a dependency on `sendVerificationMail`
    or `logError`. It should only return a result expressing whether the email is
    valid, and you should be able to choose whatever effects you need for success
    or failure. Or you might prefer not to apply the effect but to compose the result
    with some other processing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`方法不应该依赖于`sendVerificationMail`或`logError`。它应该只返回一个结果，表示电子邮件是否有效，并且你应该能够选择成功或失败所需的任何效果。或者你可能更喜欢不应用效果，而是将结果与其他处理组合。'
- en: Exercise 3.1 (hard)
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.1（难度较高）
- en: Try to decouple the validation from the effects applied.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将验证与施加的效果解耦。
- en: Hint
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: First, you’ll need an interface with a single method to represent an effect.
    Second, because the `emailChecker` function returns a `Result`, the `validate`
    method could return this `Result`. In such a case, you’d no longer need the `validate`
    method. Third, you’ll need to “bind” an effect to the `Result`. But because the
    result may be a success or a failure, it would be better to bind two effects and
    let the `Result` class choose which one to apply.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个接口，它只有一个方法来表示一个效果。其次，因为`emailChecker`函数返回一个`Result`，所以`validate`方法可以返回这个`Result`。在这种情况下，你将不再需要`validate`方法。第三，你需要将一个效果“绑定”到`Result`上。但由于结果可能是成功或失败，绑定两个效果并让`Result`类选择应用哪一个会更好。
- en: Solution 3.1
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 3.1
- en: 'The first thing to do is create the interface representing an effect, such
    as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是创建一个表示效果的接口，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may prefer the `Consumer` interface of Java 8\. Although the name was badly
    chosen, it does the same job.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会更喜欢Java 8的`Consumer`接口。尽管名字选得不好，但它做的是同样的工作。
- en: Then you’ll need to make some changes to the `Result` interface, as shown in
    [figure 3.1](#ch03fig01).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要对`Result`接口做一些修改，如图[3.1](#ch03fig01)所示。
- en: Figure 3.1\. Changes to the `Result` interface
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. `Result`接口的更改
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig01_alt.jpg)'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What’s in a name?**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**名字有什么意义？**'
- en: Many great authors have written about names. Shakespeare wrote in *Romeo and
    Juliet*:^([[a](#ch03fn01)])
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多伟大的作家都曾写过关于名字。莎士比亚在《罗密欧与朱丽叶》中写道：^([[a](#ch03fn01)])
- en: ^a
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: William Shakespeare, *Romeo and Juliet* (1599), act 2, scene 2, [http://shakespeare.mit.edu/romeo_juliet/romeo_juliet.2.2.html](http://shakespeare.mit.edu/romeo_juliet/romeo_juliet.2.2.html)
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 威廉·莎士比亚，《罗密欧与朱丽叶》（1599），第二幕，第二场，[http://shakespeare.mit.edu/romeo_juliet/romeo_juliet.2.2.html](http://shakespeare.mit.edu/romeo_juliet/romeo_juliet.2.2.html)
- en: '*What’s in a name? that which we call a rose By any other name would smell
    as sweet;*'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*名字有什么意义？那我们称之为玫瑰的东西，换一个名字，也会一样芬芳；*'
- en: 'This says in two beautiful lines what Ferdinand de Saussure and other linguists
    have explained in hundreds of pages: the relationship between a name and what
    it names is arbitrary. The consequence is that a programmer should never trust
    names. Most often, names are chosen to reflect what objects are or do. But even
    when objects are able to do only one clear thing, there may be a mismatch.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这用两行美丽的文字说明了费迪南德·德·索绪尔和其他语言学家在数百页中解释的内容：名字与其指称之间的关系是任意的。结果是，程序员永远不应该相信名字。通常，名字被选择来反映对象是什么或能做什么。但即使对象只能做一件明确的事情，也可能存在不匹配。
- en: Take the example of Java interfaces. They’re supposed to be named either after
    what objects *are* (`Comparable`, `Clonable`, `Serializable`) or what they can
    *do* (`Listener`, `Supplier`, `Consumer`). Following this rule, a `Function` should
    be renamed `Applicable` and should have a method `apply`. A `Supplier` should
    define a method `supply`, and a `Consumer` should consume something and have a
    method named `consume`. But a `Consumer` defines an `accept` method, and it doesn’t
    consume anything, because after having accepted an object, this object is still
    available.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以Java接口为例。它们应该根据对象*是什么*（`Comparable`、`Clonable`、`Serializable`）或它们能*做什么*（`Listener`、`Supplier`、`Consumer`）来命名。遵循这个规则，`Function`应该更名为`Applicable`，并应该有一个`apply`方法。`Supplier`应该定义一个`supply`方法，而`Consumer`应该消费某些内容并有一个名为`consume`的方法。但`Consumer`定义了一个`accept`方法，并且它并没有消费任何东西，因为接受了一个对象之后，这个对象仍然可用。
- en: Don’t trust names. Trust types. Types don’t lie. Types are your friends!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不要相信名字。相信类型。类型不会说谎。类型是你的朋友！
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows the modified version of the `Result` class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了`Result`类的修改版本。
- en: Listing 3.6\. A `Result` that can handle `Effect`s
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 可以处理`Effect`的`Result`
- en: '![](Images/ch03ex06-0.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch03ex06-0.jpg)'
- en: '![](Images/ch03ex06-1.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch03ex06-1.jpg)'
- en: You can choose whatever name you want for the `bind` method. You could call
    it `ifSuccess` or `forEach`. Only the type is important.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`bind`方法选择任何你想要的名称。你可以称之为`ifSuccess`或`forEach`。只有类型才是重要的。
- en: Now you can clean up the program by using the new `Effect` and `Result` interfaces,
    as shown in the following listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过使用新的`Effect`和`Result`接口来清理程序，如下面的列表所示。
- en: Listing 3.7\. A cleaner version of the program
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 程序的更简洁版本
- en: '![](Images/ch03ex07-0.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/ch03ex07-0.jpg)'
- en: '![](Images/ch03ex07-1.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/ch03ex07-1.jpg)'
- en: 'The `emailChecker` function now returns a parameterized `Result<String>` ![](Images/num-01.jpg).
    It’s irrelevant that `Result` is parameterized by the same type as the type of
    an error message. It could have been any type, such as `Result<Email>`. If you
    look at the `Result` implementation, you’ll see that the value of `Failure` is
    always `String`, whatever the value of `Success` might be. The `Success` class
    holds a value of type `T`, and the `Failure` class holds a value of type `String`.
    In this example, it just so happens that `T` is `String`, but it could have been
    anything else. (You’ll come back to this subject in the last section of this chapter.)
    The `validate` method has been removed, and two `Effect` instances are now defined
    ![](Images/num-03.jpg): one for success and one for failure. These two effects
    are bound ![](Images/num-02.jpg) to the result of the `emailChecker` function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`emailChecker`函数现在返回一个参数化的`Result<String>` ![图像](Images/num-01.jpg)。`Result`与错误消息的类型相同这一事实并不重要。它可以是任何类型，例如`Result<Email>`。如果你查看`Result`实现，你会看到`Failure`的值总是`String`，无论`Success`的值可能是什么。`Success`类持有类型为`T`的值，而`Failure`类持有类型为`String`的值。在这个例子中，`T`恰好是`String`，但它可以是任何其他类型。（你将在本章的最后部分回到这个主题。）`validate`方法已被移除，现在定义了两个`Effect`实例
    ![图像](Images/num-03.jpg)：一个用于成功，一个用于失败。这两个效果现在绑定 ![图像](Images/num-02.jpg) 到`emailChecker`函数的结果。'
- en: 3.2.2\. An alternative to if ... else
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. if ... else 的替代方案
- en: 'You may wonder whether it’s possible to completely remove conditional structures
    or operators. Can you write a program without any of these constructs? This may
    seem impossible, because many programmers have learned that decision-making is
    the basic building block of programming. But *decision-making* is an imperative
    programming notion. It’s the notion of examining a value and deciding what to
    do next based on this observation. In functional programming, there’s no “what
    to do next” question, but only functions returning values. The most basic `if`
    structure may be seen as the implementation of a function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否可以完全移除条件结构或运算符。你能编写一个没有任何这些结构的程序吗？这看起来可能是不可能的，因为许多程序员已经了解到决策是编程的基本构建块。但*决策*是命令式编程的概念。它是检查一个值并根据这个观察结果决定下一步做什么的概念。在函数式编程中，没有“下一步做什么”的问题，只有返回值的函数。最基本的`if`结构可能被视为函数的实现：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a function of `x`. It returns the absolute value of `x`. You could
    write this function as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于`x`的函数。它返回`x`的绝对值。你可以这样编写这个函数：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The difference with a function such as
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与如下函数的区别
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: is that you have two implementations of the function and have to choose between
    the two depending on the value of the argument. This isn’t a big problem, but
    what if you had many possible implementations? You’d end up with as many embedded
    `if ... else` structures as you have in [listing 3.7](#ch03ex07), or as many embedded
    ternary operators as in [listing 3.5](#ch03ex05). Can you do better?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可能有函数的两个实现，并且必须根据参数的值在这两个实现之间进行选择。这并不是一个大问题，但如果你有很多可能的实现呢？你最终会有与[列表 3.7](#ch03ex07)中一样多的嵌套`if
    ... else`结构，或者与[列表 3.5](#ch03ex05)中一样多的嵌套三元运算符。你能做得更好吗？
- en: Exercise 3.2
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.2
- en: 'Write a `Case` class representing a condition and corresponding result. The
    condition will be represented by a `Supplier<Boolean>`, where `Supplier` is a
    functional interface such as this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示条件和相应结果的`Case`类。条件将由一个`Supplier<Boolean>`表示，其中`Supplier`是一个如下的函数式接口：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can use the Java 8 implementation of `Supplier` or your own. The result
    corresponding to the condition will be represented by a `Supplier<Result<T>>`.
    To hold both, you can use a `Tuple<Supplier<Boolean>, Supplier<Result<T>>>`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Java 8的`Supplier`实现或你自己的实现。对应于条件的结果将由一个`Supplier<Result<T>>`表示。为了同时持有这两个，你可以使用一个`Tuple<Supplier<Boolean>,
    Supplier<Result<T>>>`。
- en: 'The `Case` class should define three methods:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Case` 类应该定义三个方法：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I used the name *mcase* because *case* is a reserved word in Java; *m* stands
    for *match*. Of course, you can choose any other name.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用名称 *mcase* 是因为 *case* 在 Java 中是一个保留字；*m* 代表 *match*。当然，你可以选择任何其他名称。
- en: The first `mcase` method defines a normal case, with a condition and a resulting
    value. The second `mcase` method defines a default case, represented by a subclass.
    The third method, `match`, selects a case. Because this method uses a vararg,
    the default case is to be put first, but will be the last to be used!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `mcase` 方法定义了一个正常情况，包含一个条件和结果值。第二个 `mcase` 方法定义了一个默认情况，由一个子类表示。第三个方法，`match`，选择一个情况。因为这个方法使用可变参数，所以默认情况应该放在第一个，但将是最后一个被使用的！
- en: 'Additionally, the `Case` class should define the private `DefaultCase` subclass
    with the following signature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Case` 类应该定义具有以下签名的私有 `DefaultCase` 子类：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Solution 3.2
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.2
- en: 'I said that the class must represent a `Supplier<Boolean>` for the condition
    and a `Supplier<Result<T>>>` for the resulting value. The simplest way to do this
    is to define it as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过，这个类必须代表一个 `Supplier<Boolean>` 用于条件和一个 `Supplier<Result<T>>>` 用于结果值。最简单的方法是如下定义它：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `mcase` methods are simple. The first one takes the two parameters and
    creates a new instance. The second receives only the second parameter (the `Supplier`
    for the value) and creates the default `Supplier` for the condition, which always
    returns `true`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`mcase` 方法很简单。第一个接受两个参数并创建一个新的实例。第二个只接受第二个参数（值的 `Supplier`）并创建默认的 `Supplier`
    用于条件，它总是返回 `true`：'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `DefaultCase` class couldn’t be simpler. It’s only a marker class, so you
    only have to create a constructor calling `super`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultCase` 类非常简单。它只是一个标记类，所以你只需要创建一个调用 `super` 的构造函数：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `match` method is more complex, but that’s an overstatement because it
    has only three lines of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 方法更复杂，但这是一种夸张，因为它只有三行代码：'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As I previously mentioned, the default case has to come first in the argument
    list because the second argument is a vararg, but this case is used last. You
    test all cases one by one by evaluating them through a call to the `get` method.
    If the result is `true`, you return the corresponding value after having evaluated
    it. If no case matches, the default case is used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，默认情况必须在参数列表中首先出现，因为第二个参数是一个可变参数，但这个情况是最后被使用的。你通过调用 `get` 方法逐个测试所有情况。如果结果是
    `true`，你将在评估后返回相应的值。如果没有情况匹配，则使用默认情况。
- en: Note that *evaluation* means evaluation of the returned value. No effect is
    applied at this time. The following listing shows the complete class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*评估*意味着对返回值的评估。目前没有任何效果被应用。以下列表显示了完整的类。
- en: Listing 3.8\. Matching conditions with the `Case` class
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8。使用 `Case` 类匹配条件
- en: '![](Images/ch03ex08-0.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex08-0.jpg)'
- en: '![](Images/ch03ex08-1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex08-1.jpg)'
- en: Now you can greatly simplify the code of your email validation application.
    As you can see in the following listing, it contains absolutely no control structures.
    (Note the use of static import for methods of `Case` and `Result`.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以极大地简化你的电子邮件验证应用程序的代码。正如你在以下列表中可以看到的，它绝对不包含任何控制结构。（注意对 `Case` 和 `Result`
    方法的静态导入的使用。）
- en: Listing 3.9\. The email validation application with no control structures
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9。没有控制结构的电子邮件验证应用程序
- en: '![](Images/ch03ex09-0.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex09-0.jpg)'
- en: '![](Images/ch03ex09-1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex09-1.jpg)'
- en: But wait. There’s a trick! You don’t see any control structures because they’re
    hidden in the `Case` class, which contains an `if` instruction and even a `for`
    loop. So are you cheating? Not really. First, you have a single clean loop and
    a single clean `if`. No more series of embedded `if` statements. Second, you’ve
    abstracted these structures. You can now write as many conditional applications
    as you want without having to write a single `if` or `for`. But most important,
    you’re only at the beginning of your trip into functional programming. In [chapter
    5](kindle_split_012.xhtml#ch05) you’ll learn how to completely remove these two
    constructs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。有一个技巧！你没有看到任何控制结构，因为它们隐藏在包含 `if` 指令甚至 `for` 循环的 `Case` 类中。所以你在作弊吗？不是的。首先，你有一个干净的循环和一个干净的
    `if`。不再有嵌套的 `if` 语句系列。其次，你已经抽象了这些结构。你现在可以编写任意多的条件应用，而无需编写单个 `if` 或 `for`。但最重要的是，你只是功能编程之旅的开始。在第
    [5](kindle_split_012.xhtml#ch05) 章中，你将学习如何完全移除这两个结构。
- en: In this chapter, you’ll see how to generalize abstractions of all control structures.
    You’ve done this for conditional control structures such as embedded `if..else`
    statements (and `switch..case` is no different). Let’s see how to do the same
    with loops.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解如何泛化所有控制结构的抽象。你已经为条件控制结构，如嵌套的`if..else`语句（以及`switch..case`也没有什么不同）做过这样的事情。让我们看看如何用循环来做同样的事情。
- en: 3.3\. Abstracting iteration
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 抽象迭代
- en: '*Loops* are structures that iterate over lists. In Java, loops can also iterate
    over sets, or might even seem to iterate on nothing, such as indexed loops, but
    they always iterate on lists. Loops that seem to iterate on sets won’t produce
    different results if executed twice, because an order is applied to the sets while
    iterating. And even if the order isn’t the same on each iteration, it won’t change
    during the course of one iteration. So iterating on a set turns it into a list
    from the iteration point of view.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环*是遍历列表的结构。在Java中，循环也可以遍历集合，或者甚至可能看起来在没有任何东西上迭代，比如索引循环，但它们总是遍历列表。看似遍历集合的循环，如果执行两次，结果不会不同，因为在迭代过程中会应用一个顺序到集合上。即使每次迭代的顺序不相同，它也不会在单次迭代过程中改变。所以从迭代的角度来看，遍历集合就变成了一个列表。'
- en: An indexed loop isn’t any different—it iterates over a list of the evaluated
    indexes. The loop could exit before evaluating all the arguments because index
    loops are lazy regarding their indexes. Loops are always lazy regarding their
    bodies, which means that if a loop exits, the remaining elements won’t be processed.
    The `if..else` construct behaves similarly. The condition is always evaluated,
    so it’s strict regarding the condition, but only one of the `if` and `else` parts
    is evaluated, depending on the condition, so `if..else` is lazy regarding its
    body too. Maybe you thought Java was a strict language, but this isn’t true. Java
    is strict regarding method arguments, but fortunately it’s also sometimes lazy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 索引循环并没有什么不同——它遍历一个由评估过的索引组成的列表。循环可以在评估所有参数之前退出，因为索引循环对它们的索引是惰性的。循环总是对它们的主体是惰性的，这意味着如果循环退出，剩余的元素将不会被处理。`if..else`结构的行为也类似。条件总是会被评估，所以它对条件是严格的，但只有`if`和`else`部分中的一个会被根据条件评估，所以`if..else`在它的主体上也是惰性的。也许你以为Java是一种严格的语言，但事实并非如此。Java对方法参数是严格的，但幸运的是，它有时也是惰性的。
- en: 'Getting back to loops, their main use is to iterate over all elements of a
    list, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回到循环上来，它们的主要用途是遍历列表的所有元素，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each time you want to process a list, you use this construct, or other constructs
    such as `while` or `do..while`, which are no different. They’re only syntactic
    sugar over iteration. Even the preceding `for` loop is syntactic sugar for the
    following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想处理一个列表时，你都会使用这个结构，或者使用其他结构，如`while`或`do..while`，它们并没有什么不同。它们只是迭代上的语法糖。甚至前面的`for`循环也只是以下内容的语法糖：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `while` loop is different because it’s used to iterate as long as a condition
    is verified. It allows you to exit the loop on a condition that’s applied before
    the first iteration. The `do..while` loop does the same, but only after the first
    iteration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环是不同的，因为它用于在条件得到验证的情况下迭代。它允许你在第一次迭代之前根据一个条件退出循环。`do..while`循环做的是同样的事情，但只是在第一次迭代之后。'
- en: What’s important is what’s done inside the loop, so why should you have to write
    the loops again and again? Why can’t you just say what you want done and have
    it be done without messing with the control structures, the conditions, and the
    indexes?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是在循环内部所做的事情，所以为什么你还得一次次地写循环呢？为什么你不能只说出你想要完成的事情，然后让它完成，而不必去弄乱控制结构、条件和索引呢？
- en: Take a simple example. Let’s say you have a list of names, and you want to return
    comma-separated strings. Could you write the program on paper correctly the first
    time? If you’re a good programmer, I guess you could. But many programmers have
    to write the code, run it, fix the bugs in the general case, run it again, fix
    the bugs in the marginal cases, and then run the program again until it’s correct.
    The problem isn’t difficult, but it’s so boring that you often don’t get it right
    on the first try. If you always write your programs correctly the first time,
    congratulations. You’re a good programmer, and the remainder of this section might
    not be for you. But if you’re an average programmer, keep reading.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个简单的例子。假设你有一串名字列表，并且你想要返回以逗号分隔的字符串。你能否第一次就把程序写在纸上正确无误？如果你是一个优秀的程序员，我想你能够做到。但许多程序员不得不编写代码，运行它，修复一般情况下的错误，再次运行，修复边缘情况下的错误，然后再次运行程序直到它正确无误。问题并不困难，但它如此无聊，以至于你往往第一次就做不对。如果你总是第一次就把你的程序写对，恭喜你。你是一个优秀的程序员，本节剩余的内容可能对你来说不是必要的。但如果你是一个普通的程序员，请继续阅读。
- en: 'Inside a loop, you might want to do several things:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，你可能想要做几件事情：
- en: Transform each element into something else
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个元素转换成其他东西
- en: Aggregate elements into a single result
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素聚合为单个结果
- en: Remove some elements according to a condition on the elements
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据元素的条件移除一些元素
- en: Remove some elements according to an external condition
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据外部条件移除一些元素
- en: Group elements according to certain criteria
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些标准分组元素
- en: Various operations for which looping is needed can be applied to collections,
    such as concatenating, zipping, or unzipping. (*Zipping* means taking elements
    from two lists and creating a list of tuples. *Unzipping* is the inverse operation.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 需要循环的各种操作可以应用于集合，例如连接、压缩或解压缩。（*压缩*意味着从两个列表中取元素并创建一个元组的列表。*解压缩*是逆操作。）
- en: All these operations could be abstracted. In [chapter 5](kindle_split_012.xhtml#ch05),
    you’ll create functional data structures implementing all these abstractions.
    For now, you’ll develop a library of these abstractions that you can apply to
    legacy Java collections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都可以被抽象。在[第5章](kindle_split_012.xhtml#ch05)中，你将创建实现所有这些抽象的功能数据结构。现在，你将开发一个可以应用于遗留Java集合的这些抽象的库。
- en: 3.3.1\. Abstracting an operation on lists with mapping
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 使用映射抽象列表上的操作
- en: 'Mapping, when applied to collections, means applying a transformation to each
    element of the collection. Here’s how it’s generally done in traditional imperative
    programming:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射应用于集合时，意味着对集合中的每个元素应用一个转换。这是在传统的命令式编程中通常是如何做的：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, an operation is applied to each element of an `Integer` list
    (`integerList`) to increase it by 20%. The result of the operation is a double,
    so it’s put in a new list that’s created before the start of the loop. Although
    simple, this program raises some interesting questions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个操作被应用于`Integer`列表的每个元素（`integerList`），将其增加20%。操作的结果是一个双精度浮点数，所以它被放入在循环开始之前创建的新列表中。尽管程序很简单，但它引发了一些有趣的问题。
- en: 'The first point is that you could separate the iteration from the calculation.
    The following example does this with a method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要点是你可以将迭代与计算分离。以下示例使用方法来实现这一点：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This allows you to reuse the calculation, but it doesn’t allow you to reuse
    the loop. To allow this, you can put the loop inside a method and pass it a function
    to apply the calculation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你重用计算，但它不允许你重用循环。为了允许这样做，你可以把循环放在一个方法内部，并传递一个应用计算的函数：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now you can call the `map` method with an `Integer` list and a function from
    `Integer` to `Double` as arguments, and you’ll get a new `Double` list in return.
    Plus, you can freely reuse the function and can call the `map` method with a different
    function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`Integer`列表和一个从`Integer`到`Double`的函数作为参数调用`map`方法，你将得到一个新的`Double`列表作为返回。此外，你可以自由地重用该函数，并且可以用不同的函数调用`map`方法。
- en: 'You can greatly enhance reusability by using generics:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用泛型，你可以极大地提高可重用性：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can include this method in a library where you’ll define several methods,
    allowing you to abstract many list-related operations. You’ll call this library
    `Collection-Utilities`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个方法包含在一个库中，你将在其中定义几个方法，允许你抽象许多与列表相关的操作。你将调用这个库为`Collection-Utilities`。
- en: 3.3.2\. Creating lists
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 创建列表
- en: Besides iterating, programmers need to repeat other basic operations again and
    again when working on lists. The most basic operation is creating lists. Java
    supports many ways to create lists, but they aren’t consistent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迭代之外，当在列表上工作时，程序员需要反复执行其他基本操作。最基本操作是创建列表。Java 支持许多创建列表的方法，但它们并不一致。
- en: Exercise 3.3
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.3
- en: Write methods that create an empty list, a list with one element, and a list
    from a collection of elements, as well as a vararg method that creates a list
    from a list of arguments. All these lists will be immutable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编写创建空列表、包含一个元素的列表以及从元素集合创建列表的方法，以及一个 vararg 方法，它从参数列表创建列表。所有这些列表都将不可变。
- en: Solution 3.3
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.3
- en: 'This is straightforward, as you can see in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，正如你在下面的代码中可以看到：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the `list(List<T> ts)` method makes a copy of the argument list. This
    defensive copy is needed to ensure that the list won’t be modified afterward by
    the caller of the `list` method. Also note that the vararg version may be called
    with an array as its argument. In such a case, the resulting list is backed by
    the original array. As a consequence, changing an element of the array would change
    the corresponding element of the resulting list. This is why you make a copy of
    the array argument.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`list(List<T> ts)` 方法会复制参数列表。这个防御性复制是为了确保列表不会被调用 `list` 方法的调用者之后修改。此外，vararg
    版本可以用数组作为其参数。在这种情况下，结果列表由原始数组支持。因此，修改数组的一个元素将改变结果列表中相应的元素。这就是为什么你需要复制数组参数。
- en: Also note that the resulting lists aren’t really immutable. They’re immutable
    views of mutable lists, but this is sufficient because no one will have access
    to these mutable lists. They will only be mutable in the `CollectionUtilities`
    class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，结果列表实际上并不是不可变的。它们是可变列表的不可变视图，但这已经足够了，因为没有人会访问这些可变列表。它们只会在 `CollectionUtilities`
    类中是可变的。
- en: 3.3.3\. Using head and tail operations
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 使用 head 和 tail 操作
- en: Functional operations on lists often access the *head* (or first element) of
    the list, as well as the *tail* (the list with its first element removed).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上的函数式操作通常访问 *head*（或第一个元素）以及 *tail*（移除第一个元素后的列表）。
- en: Exercise 3.4
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.4
- en: Create two methods that return the head and the tail of a list, respectively.
    The list passed as an argument must not be modified. Because you’ll need to make
    a copy of the list, also define a `copy` method. The list returned by `tail` should
    be immutable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个方法，分别返回列表的 head 和 tail。传递给列表的参数不得修改。因为你需要复制列表，所以还定义了一个 `copy` 方法。`tail`
    返回的列表应该是不可变的。
- en: Solution 3.4
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.4
- en: The `head()` method is simple. If the list is empty, you throw an exception.
    Otherwise, you read the element at index 0 and return it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()` 方法很简单。如果列表为空，你抛出异常。否则，你读取索引 0 处的元素并返回它。'
- en: The `copy` method is also basic. It’s the same as the list-creation method,
    taking a list as its argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 方法也是基本的。它与列表创建方法相同，以列表作为其参数。'
- en: 'The `tail` method is slightly more complex. It must make a copy of its argument,
    remove the first element, and return the result:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 方法稍微复杂一些。它必须复制其参数，删除第一个元素，并返回结果：'
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that `copy` is private. It returns a mutable list. To make a copy from
    the outside, you can call `list(List<T>)`, which returns an immutable list. Also
    note that this example throws exceptions when calling `head` or `tail` on an empty
    list. This isn’t functional, because you should always catch exceptions but never
    throw them in order to be referentially transparent. It is, however, simpler at
    this stage. In [chapter 5](kindle_split_012.xhtml#ch05), when you look at functional
    lists, you’ll see that the `head` and `tail` methods will be declared protected.
    This way, they’ll be usable only inside the `List` class, and no exception will
    ever leak out of this class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`copy` 是私有的。它返回一个可变列表。要从外部复制，你可以调用 `list(List<T>)`，它返回一个不可变列表。此外，这个例子在调用
    `head` 或 `tail` 时对空列表抛出异常。这不是函数式的，因为你应该总是捕获异常，而不是抛出它们，以便具有引用透明性。然而，在这个阶段，这要简单一些。在
    [第 5 章](kindle_split_012.xhtml#ch05) 中，当你查看函数式列表时，你会看到 `head` 和 `tail` 方法将被声明为受保护的。这样，它们就只能在内
    `List` 类中使用，并且永远不会从这个类中泄漏异常。
- en: 3.3.4\. Functionally appending to a list
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4\. 函数式地追加到列表
- en: 'Appending an element to a Java list in an imperative program is a basic operation
    that’s used again and again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式程序中将元素追加到 Java 列表是一个基本操作，它被反复使用：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But this operation isn’t usable in functional programs because it mutates its
    argument and doesn’t return the modified list. If you think it’s functional because
    it doesn’t mutate its element argument, remember what you learned in [chapter
    2](kindle_split_009.xhtml#ch02): this is object notation. The list itself is an
    implicit argument to the method `add`, so it’s equivalent to this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个操作在函数式程序中不可用，因为它会改变它的参数，并且不返回修改后的列表。如果你认为它是因为它不改变它的元素参数而函数式的，记住你在[第2章](kindle_split_009.xhtml#ch02)中学到的东西：这是对象表示法。列表本身是方法
    `add` 的隐含参数，所以它等同于以下内容：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Transforming this method into a functional one is simple. You’ll call it `append`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种方法转换成函数式方法是简单的。你会调用它为 `append`：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `append` method makes a defensive copy of its first argument (through a
    call to the previously defined `copy` method), adds the second argument to it,
    and then returns the modified list wrapped in an immutable view. You’ll soon have
    occasion to use this `append` method in places where it would be impossible to
    use `add`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 方法会对其第一个参数（通过调用之前定义的 `copy` 方法）进行防御性复制，然后将第二个参数添加到其中，最后返回一个不可变视图包裹的修改后的列表。你很快就会有机会在无法使用
    `add` 的地方使用这个 `append` 方法。'
- en: 3.3.5\. Reducing and folding lists
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.5. 减法和折叠列表
- en: List *folding* transforms a list into a single value by using a specific operation.
    The resulting value may be of any type—it doesn’t have to be of the same type
    as the elements of the list. Folding to a result that’s the same type as the list
    elements is a specific case called *reducing*. Computing the sum of the elements
    of a list of integers is a simple case of reducing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 *折叠* 通过使用特定的操作将列表转换成一个单一值。结果值可以是任何类型——它不必与列表的元素类型相同。将结果折叠成与列表元素相同类型的特定情况称为
    *减少*。计算整数列表的元素总和是减少的一个简单例子。
- en: 'You can fold a list in two directions, from left to right or from right to
    left, depending on the operation used:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从两个方向折叠一个列表，从左到右或从右到左，这取决于使用的操作：
- en: If the operation is commutative, both ways of folding are equivalent.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作是交换的，两种折叠方式是等价的。
- en: If the operation isn’t commutative, the two ways of folding give different results.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作不是交换的，两种折叠方式会得到不同的结果。
- en: Folding needs a starting value, which is the neutral element, or identity element,
    for the operation. This element is used as the starting value of the *accumulator*.
    When the computation is complete, the accumulator contains the result. Reducing,
    on the other hand, can be done without a starting element, with the condition
    that the list isn’t empty, because the first (or last) element will be used as
    the starting element.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠需要一个起始值，这是操作的中性元素，或称为恒等元素。这个元素被用作累加器的起始值。当计算完成时，累加器包含结果。另一方面，如果没有起始元素也可以进行减少操作，条件是列表不为空，因为第一个（或最后一个）元素将被用作起始元素。
- en: Reducing lists of numbers with addition
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用加法减少数字列表
- en: 'Suppose you have a list, `(1, 2, 3, 4)`, and you want to compute the sum of
    the elements. The first way to do it is to put the accumulator on the left side
    of the operand:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个列表 `(1, 2, 3, 4)`，你想计算元素的总和。第一种方法是把累加器放在操作数的左边：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You could also proceed from the other side:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从另一边开始：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The results are identical. You could do the same thing with multiplication,
    but you’d have to use the identity element `1` as the starting value of the accumulator.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相同的。你也可以用乘法做同样的事情，但你需要使用恒等元素 `1` 作为累加器的起始值。
- en: Folding lists of characters into strings
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将字符列表折叠成字符串
- en: 'Let’s now do the same thing with a different operation applied to a list of
    characters, `(''a'', ''b'', ''c'')`. The operation used here is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用不同的操作对一个字符列表 `('a', 'b', 'c')` 做同样的事情。这里使用的操作如下：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, let’s fold from the left:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从左边折叠：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s now try the same thing from the right:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试从右边做同样的事情：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Folding from the right doesn’t work because the left operand is a character,
    and the right one is a string. So you have to change the operation to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从右边折叠不工作，因为左操作数是一个字符，而右操作数是一个字符串。所以你必须将操作更改为以下内容：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, the character is prepended to the string instead of being appended.
    The first fold is called a *left fold*, which means that the accumulator is on
    the left side of the operation. When the accumulator is on the right side, it’s
    a *right fold*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字符被添加到字符串的开头而不是末尾。第一次折叠被称为*左折叠*，这意味着累加器位于操作的左侧。当累加器位于右侧时，它被称为*右折叠*。
- en: Understanding the relationship between left and right folds
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解左右折叠之间的关系
- en: 'You might say that folding right can be defined in terms of folding left. Let’s
    rewrite the right-folding operation by using a different form, called *corecursion*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，右折叠可以用左折叠来定义。让我们通过使用不同的形式来重写右折叠操作，这种形式称为*核心递归*：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In recursion as well as corecursion, evaluation of one step is dependent on
    the previous step. But a recursive definition starts with the last step and defines
    its relationship with the preceding one. In order to be able to conclude, it also
    has to define the base step. Corecursion, on the other hand, starts from the first
    step and defines its relationship to the next one. There’s no need for a base
    step, because it’s also the first step.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归以及核心递归中，一步的评估依赖于前一步。但递归定义从最后一步开始，并定义其与前一步的关系。为了能够得出结论，它还必须定义基本步骤。另一方面，核心递归从第一步开始，并定义其与下一步的关系。由于它也是第一步，因此不需要基本步骤。
- en: From this, it seems that right-folding a list is equivalent to left-folding
    the list after having reversed the order of the elements.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，似乎右折叠列表等同于反转元素顺序后的左折叠列表。
- en: 'But wait. Addition is a commutative operation. If you use a noncommutative
    operation, you must change the operation as well. If you don’t, you could end
    up with two different situations, depending on the types. If the operation has
    operands of different types, if won’t compile. On the other hand, if the operation
    has operands of the same types but it isn’t commutative, you’ll get a wrong result
    with no error. So `foldLeft` and `foldRight` have the following relationship,
    where `operation1` and `operation2` give the same results with the same operands
    in reverse order:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。加法是一个交换操作。如果你使用非交换操作，你必须更改操作。如果不这样做，你可能会根据类型得到两种不同的情况。如果操作有不同类型的操作数，它将无法编译。另一方面，如果操作有相同类型的操作数但不是交换的，你将得到一个错误的结果而没有错误。所以`foldLeft`和`foldRight`有以下关系，其中`operation1`和`operation2`在相反的顺序下给出相同的结果：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: is equivalent to
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the operation is commutative, `operation1` and `operation2` are the same.
    Otherwise, if `operation1` is `x -> y -> compute(x, y)`, `operation2` is `x ->
    y -> compute(y, x)`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作是交换的，`operation1`和`operation2`是相同的。否则，如果`operation1`是`x -> y -> compute(x,
    y)`，则`operation2`是`x -> y -> compute(y, x)`。
- en: Think about the `reverse` function used to reverse a list. Can you see how it
    could be expressed in terms of `leftFold`? This is part of the beauty of functional
    programming. Abstraction can be found everywhere. Now let’s look at how you can
    apply this to legacy Java lists.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下用于反转列表的`reverse`函数。你能看到它是如何用`leftFold`来表达的吗？这是函数式编程之美的一部分。抽象无处不在。现在让我们看看如何将此应用于遗留的Java列表。
- en: Exercise 3.5
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习3.5
- en: Create a method to fold a list of integers that can be used, for example, to
    sum the elements of a list. This method will take a list of integers, an integer
    starting value, and a function as its parameters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个方法来折叠整数列表，例如，用于求列表元素的和。此方法将接受一个整数列表、一个整数起始值和一个函数作为其参数。
- en: Solution 3.5
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案3.5
- en: 'The starting value is dependent on the operation applied. The value has to
    be the *neutral*, or *identity*, element of the operation. The operation is represented
    as a curried function, as you learned in the previous chapter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 起始值取决于所应用的运算。该值必须是运算的*中性*或*单位*元素。运算表示为你在上一章中学到的柯里化函数：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After statically importing `CollectionUtilities.*`, this method can be called
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态导入`CollectionUtilities.*`之后，此方法可以按如下方式调用：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `result` is equal to 15, which is the sum of 1, 2, 3, 4, and 5\. Replacing
    `+` with `*` and `0` with `1` (the identity element for multiplication) gives
    the result of 1 x 2 x 3 x 4 x 5 = 120.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`result`等于15，这是1、2、3、4和5的和。将`+`替换为`*`并将`0`替换为`1`（乘法的单位元素）得到结果1 x 2 x 3 x
    4 x 5 = 120。
- en: Left-folding example
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 左折叠示例
- en: The operation you just defined was named `fold` because folding left or right
    for integer addition or multiplication gives the same result. But if you want
    to use other functions, or if you want to make the folding method generic, you
    must distinguish between right and left folds.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚才定义的操作被命名为`fold`，因为左折叠或右折叠整数加法或乘法给出相同的结果。但如果您想使用其他函数，或者如果您想使折叠方法通用，您必须区分左右折叠。
- en: Exercise 3.6
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习3.6
- en: Generalize the `fold` method to `foldLeft` so that it can be used to apply a
    left fold to a list of elements of arbitrary types. To test that the method is
    correct, apply it to the following parameters,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将`fold`方法推广到`foldLeft`，以便它可以应用于任意类型元素的列表的左折叠。为了测试该方法是否正确，将其应用于以下参数，
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'where method `addSI` is defined as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其中方法`addSI`定义如下：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Verify that you get the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 验证您是否得到以下输出：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that the `addSI` method allows you to verify that the arguments are in
    the correct order. Using the `"(" + s + " + " + i + ")"` expression directly wouldn’t
    allow this verification because inverting the argument would change only the meaning
    of the `+` signs without changing the result.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`addSI`方法允许您验证参数是否按正确顺序排列。直接使用`"(" + s + " + " + i + ")"`表达式无法进行此验证，因为反转参数只会改变`+`符号的意义，而不会改变结果。
- en: Solution 3.6
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案3.6
- en: 'The imperative implementation is quite simple:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式实现相当简单：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This generic version can be used for integer operations, so the specific integer
    version is useless.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用版本可以用于整数运算，因此特定的整数版本是无用的。
- en: Right-folding example
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 右折叠示例
- en: As you saw previously, folding left is a corecursive operation, so implementing
    it through an imperative loop is easy. On the other hand, folding right is a recursive
    operation. To test your tentative implementation, you can use the approach you
    used for folding left. You’ll test the implementation against the following parameters,
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，左折叠是一个核心递归操作，因此通过命令式循环实现它很容易。另一方面，右折叠是一个递归操作。为了测试您的尝试性实现，您可以使用用于左折叠的方法。您将对以下参数进行测试，
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: where the method `addIS` is defined as
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 其中方法`addIS`定义如下：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Verify that the output is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 验证输出如下：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Exercise 3.7
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习3.7
- en: Write an imperative version of the `foldRight` method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`foldRight`方法的命令式版本。
- en: Solution 3.7
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案3.7
- en: 'A right fold is a recursive operation. To implement it with an imperative loop,
    you have to process the list in reverse order:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 右折叠是一个递归操作。要使用命令式循环实现它，您必须以逆序处理列表：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Exercise 3.8
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习3.8
- en: Write a recursive version of `foldRight`. Beware that a naive recursive version
    won’t fully work in Java because it uses the stack to accumulate intermediate
    calculations. In [chapter 4](kindle_split_011.xhtml#ch04), you’ll learn how to
    make stack-safe recursion available.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`foldRight`的递归版本。请注意，在Java中，一个简单的递归版本可能不会完全工作，因为它使用栈来累积中间计算。在第4章[kindle_split_011.xhtml#ch04]中，您将学习如何使栈安全递归可用。
- en: Hint
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You should apply the function to the head of the list and to the result of folding
    the tail.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将函数应用于列表的头部以及折叠尾部的结果。
- en: Solution 3.8
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案3.8
- en: 'The naive version will work for at least 5,000 elements, which is enough for
    an exercise:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 简单版本至少适用于5,000个元素，这对于练习来说已经足够了：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Heap-based Recursion
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于堆的递归
- en: Solution 3.8 isn’t tail recursive, so it can’t be optimized to use the heap
    instead of the stack. We’ll look at a heap-based implementation in [chapter 5](kindle_split_012.xhtml#ch05).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案3.8不是尾递归，因此不能优化为使用堆而不是栈。我们将在第5章中查看基于堆的实现。[第5章](kindle_split_012.xhtml#ch05)。
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Reversing a list
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反转列表
- en: Reversing a list is sometimes useful, although this operation is generally not
    optimal in terms of performance. Finding other solutions that don’t require reversing
    a list is preferable, but not always possible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 反转列表有时很有用，尽管从性能的角度来看，这个操作通常不是最优的。寻找不需要反转列表的其他解决方案更可取，但并不总是可能的。
- en: 'Defining a `reverse` method with an imperative implementation is easy by iterating
    backward over the list. You must be careful, though, not to mess with the indexes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代列表的逆序来定义一个具有命令式实现的`reverse`方法很容易。但您必须小心，不要弄乱索引：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Many possible arrangements exist. For example, you could iterate from `list.size()`
    and use `i > 0` as the condition. You would then have to use `i – 1` as the index
    to the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多可能的排列方式。例如，您可以从`list.size()`开始迭代，并使用`i > 0`作为条件。然后您必须使用`i – 1`作为列表的索引。
- en: Exercise 3.9 (hard)
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习3.9（困难）
- en: Define the reverse method without using a loop. Instead, use the methods you’ve
    developed to this point.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用循环定义反转方法。相反，使用你到目前为止开发的方法。
- en: Hint
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The methods to use are `foldLeft` and `append`. It might be useful to start
    defining a `prepend` method that adds an element in front of a list and is defined
    in terms of `append`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的方法是 `foldLeft` 和 `append`。可能从定义一个在列表前添加元素的 `prepend` 方法开始会有所帮助，这个方法是用 `append`
    定义的。
- en: Solution 3.9
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.9
- en: 'You can first define a `prepend` functional method that allows you to add an
    element in front of a list. This can be done by left-folding the list, using an
    accumulator containing the element to add instead of the empty list:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先定义一个允许你在列表前添加元素的 `prepend` 函数式方法。这可以通过使用包含要添加的元素的累加器而不是空列表来左折叠列表来完成：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then you can define the reverse method as a left fold, starting with an empty
    list and using the `prepend` method as the operation:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以定义一个反转方法作为左折叠，从空列表开始，并使用 `prepend` 方法作为操作：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After you’ve done this, you can eventually replace the call to `prepend` with
    the corresponding implementation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成这个之后，你最终可以将对 `prepend` 的调用替换为相应的实现：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t use the solution 3.9 implementations of `reverse` and `prepend` in production
    code. Both imply traversing the whole list several times, so they’re slow. In
    [chapter 5](kindle_split_012.xhtml#ch05), you’ll learn how to create functional
    immutable lists that perform well on all occasions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产代码中使用解决方案 3.9 中 `reverse` 和 `prepend` 的实现。它们都意味着要遍历整个列表几次，所以它们很慢。在第5章（[chapter
    5](kindle_split_012.xhtml#ch05)）中，你将学习如何创建在所有场合都能良好运行的函数式不可变列表。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exercise 3.10 (hard)
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.10（困难）
- en: In section 3.10 you defined a method to map a list by applying an operation
    to each element. This operation, as it was implemented, included a fold. Rewrite
    the `map` method in terms of `foldLeft` or `foldRight`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 3.10 节中，你定义了一个通过将操作应用于每个元素来映射列表的方法。这个操作，正如它被实现的那样，包括一个折叠。用 `foldLeft` 或 `foldRight`
    重新编写 `map` 方法。
- en: Hint
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: To solve this problem, you should use the `append` or `prepend` method you just
    defined.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，你应该使用你刚刚定义的 `append` 或 `prepend` 方法。
- en: Solution
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To understand the problem, you have to consider that `map` consists of two
    operations: applying a function to each element, and then gathering all elements
    into a new list. This second operation is a fold, where the identity is the empty
    list (written as `list()` after a static import `CollectionUtilities.*`) and the
    operation is the addition of an element to a list.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个问题，你必须考虑 `map` 包含两个操作：对每个元素应用一个函数，然后将所有元素收集到一个新列表中。第二个操作是一个折叠，其中恒等元是空列表（在静态导入
    `CollectionUtilities.*` 之后写作 `list()`），操作是将一个元素添加到列表中。
- en: 'Here’s an implementation using the `append` and `foldLeft` methods:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `append` 和 `foldLeft` 方法的实现：
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following implementation uses `foldRight` and `prepend`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现使用了 `foldRight` 和 `prepend`：
- en: '[PRE56]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Part of the beauty of functional programming is in finding every small element
    that can be abstracted and reused. After you get used to this way of thinking,
    you’ll start seeing patterns everywhere and you’ll want to abstract them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的美丽之处在于寻找每个可以抽象和重用的微小元素。在你习惯了这种方式思考之后，你会在各个地方看到模式，并且想要抽象它们。
- en: You could define lots of other useful functions by composing the basic list
    functions you just wrote. But we’ll delay their study until [chapter 5](kindle_split_012.xhtml#ch05),
    when you’ll learn to replace the legacy Java lists with pure functional immutable
    lists that will offer many advantages, including much better performance for most
    of the functional operations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过组合你刚刚编写的基列表函数来定义很多其他有用的函数。但我们将在第5章（[chapter 5](kindle_split_012.xhtml#ch05)）中推迟它们的学习，那时你将学习如何用纯函数式不可变列表替换遗留的Java列表，这将提供许多优势，包括大多数函数操作的性能将大大提高。
- en: 3.3.6\. Composing mappings and mapping compositions
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.6\. 组合映射和映射组合
- en: 'It isn’t unusual to apply several transformations to list elements. Imagine
    you have a list of prices, and you want to apply a 9% tax to all, and then add
    a fixed charge of $3.50 for shipping. You can do this by composing two mappings:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对列表元素应用多个转换并不罕见。想象一下，你有一个价格列表，你想要将9%的税应用到所有价格上，然后为运费添加一个固定的3.50美元费用。你可以通过组合两个映射来完成这个操作：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This code prints the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印以下内容：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It works but it isn’t efficient, because mapping is applied twice. You could
    obtain the same result with this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作，但效率不高，因为映射被应用了两次。你可以用这个来获得相同的结果：
- en: '[PRE59]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But this is still mapping twice. A much better solution is to compose the functions
    instead of composing mappings, or, in other words, to map the composition instead
    of composing mappings:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然是映射两次。一个更好的解决方案是组合函数而不是组合映射，或者说，映射组合而不是组合映射：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or if you prefer a more “natural” writing order:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果你更喜欢更“自然”的编写顺序：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 3.3.7\. Applying effects to lists
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.7\. 将效果应用于列表
- en: 'In the previous example, you printed the list in order to verify the result.
    In a real situation, you’d probably apply more-sophisticated effects to each element
    of the list. You could, for example, print each price after formatting it to display
    only two decimal digits. This could be done through iteration:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你打印列表以验证结果。在实际情况下，你可能会对列表的每个元素应用更复杂的效应。例如，你可以打印每个价格，在显示时只保留两位小数。这可以通过迭代来完成：
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'But once again, you’re mixing actions that could be abstracted. Iteration can
    be abstracted exactly as you did for mapping, and the effect applied to each element
    could be abstracted into something resembling a function, but with a side effect
    and no return value. This is exactly what the `Effect` interface you used in the
    solution to exercise 3.1 is for. So the example could be rewritten as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次强调，你正在混合可以抽象化的动作。迭代可以像你对映射所做的那样进行抽象，并且应用于每个元素的效果可以抽象成一个类似函数的东西，但它有副作用且没有返回值。这正是你在3.1练习的解决方案中使用的`Effect`接口的作用。因此，示例可以重写如下：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This seems to be much more code, but the `Effect` interface and the `forEach`
    method can be written once and reused, so you can test each of them in isolation.
    Your business code is reduced to only one line.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎有更多的代码，但`Effect`接口和`forEach`方法可以一次性编写并重用，因此你可以单独测试它们。你的业务代码简化为只有一行。
- en: 3.3.8\. Approaching functional output
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.8\. 接近函数式输出
- en: With the `forEach` method, you can somewhat abstract side effects. You abstracted
    effect application so it can be isolated, but you could go much further. With
    the `forEach` method, one single effect is applied to each element of the list.
    It would be nice to be able to compose these effects into a single one. Think
    about it as a fold resulting in a single effect. If you could do this, your program
    could be a fully functional one with absolutely no side effects. It would produce
    a new program, with no control structures but a single list of effects that would
    be applied one after the other. Let’s do this!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`forEach`方法，你可以某种程度上抽象副作用。你抽象了效果应用，使其可以隔离，但你还可以走得更远。使用`forEach`方法，单个效果应用于列表的每个元素。如果能将这些效果组合成一个单一的效果，那就太好了。把它想象成一个折叠成单一效果的过程。如果你能这样做，你的程序就可以是一个完全函数式的程序，完全没有副作用。它将生成一个新的程序，没有控制结构，只有一个效果列表，这些效果将依次应用。让我们来做这件事！
- en: 'To represent the instructions of your program, you’ll use the `Executable`
    interface you used in [listing 3.5](#ch03ex05). Then you’ll need a way to compose
    `Executable` instances, which can be done by a functional method or by a function.
    You’re in a functional mood, so let’s use a function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示程序的指令，你将使用在[列表3.5](#ch03ex05)中使用的`Executable`接口。然后你需要一种方法来组合`Executable`实例，这可以通过函数式方法或函数来完成。你正处于函数式思维中，所以让我们使用一个函数：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next you need a neutral element, or identity element, for the composition of
    `Executable`s. This couldn’t be simpler than an executable doing nothing. Let’s
    call it `ez`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要一个中性元素，或者称为单位元素，用于`Executable`的组合。这比一个什么也不做的可执行程序还要简单。让我们称它为`ez`：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The name `ez` stands for executable zero, which means the zero (or identity)
    element of the operation consisting of composing executables.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`ez`代表可执行零，这意味着由组合可执行程序组成的操作的零（或单位）元素。
- en: 'You can now write your purely functional program as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以按照以下方式编写你的纯函数式程序：
- en: '[PRE66]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It may seem a bit complicated, but it’s simple. It’s a `foldLeft` of the list
    `prices-IncludingShipping`, using `ez` as the initial value of the accumulator.
    The only part that’s slightly more complex is the function. If you forget about
    the curried form and think about it as a function of two arguments, it takes an
    `Executable` (`e`) as its first argument and a `Double` (`d`) as its second argument,
    and it composes the first one with a new `Executable` consisting of applying the
    `printWith2decimals` method to the `Double`. As you see, it’s just a matter of
    composing abstractions!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点复杂，但实际上很简单。它是 `prices-IncludingShipping` 列表的 `foldLeft`，使用 `ez` 作为累加器的初始值。唯一稍微复杂一点的部分是函数。如果你忘记了柯里化形式，把它当作一个接受两个参数的函数来考虑，它接受一个
    `Executable`（`e`）作为第一个参数，一个 `Double`（`d`）作为第二个参数，并将第一个参数与一个新的 `Executable` 组合，这个
    `Executable` 包含应用 `printWith2decimals` 方法到 `Double` 上。正如你所见，这只是一个组合抽象的问题！
- en: 'Note that you haven’t applied any side effects. What you get is a new program
    (or rather a script) written in a new language. You can execute this program by
    calling `exec()` on it:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你没有应用任何副作用。你得到的是一个用新语言编写的新程序（或者更确切地说，是一个脚本）。你可以通过在它上面调用 `exec()` 来执行这个程序：
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You get the following result:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下结果：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This gives you a taste of how functional programming can produce output without
    using side effects. Deciding whether you should use this kind of technique in
    production is up to you. True functional languages give you no choice, but Java
    is in no way a functional language, so you have a choice. If you decide to program
    functionally, you may miss some facilities to help you in this domain, but it’s
    important to know that everything remains possible.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你尝到了函数式编程如何在不使用副作用的情况下产生输出的味道。决定你是否应该在生产中使用这种技术取决于你自己。真正的函数式语言不会给你选择，但 Java
    绝对不是一种函数式语言，所以你有选择。如果你决定以函数式编程，你可能会错过一些在这个领域帮助你的一些功能，但重要的是要知道，一切仍然都是可能的。
- en: 3.3.9\. Building corecursive lists
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.9\. 构建 corecursive 列表
- en: 'One thing programmers do again and again is build corecursive lists, and most
    of these are lists of integers. If you think you, as a Java programmer, don’t
    do this too often, consider the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员反复做的事情之一是构建 corecursive 列表，其中大多数是整数列表。如果你认为，作为一个 Java 程序员，你不太经常这样做，考虑以下例子：
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This code is a composition of two abstractions: a corecursive list and some
    processing. The corecursive list is a list of integers from `0` (included) to
    `limit` (excluded). As we’ve already noted, functional programming is, among other
    things, about pushing abstraction to the limit. So let’s abstract the construction
    of this corecursive list.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是两个抽象的组合：一个 corecursive 列表和一些处理。corecursive 列表是从 `0`（包含）到 `limit`（不包含）的整数列表。正如我们之前已经提到的，函数式编程，在许多方面，是关于将抽象推向极限。所以让我们抽象这个
    corecursive 列表的构建。
- en: As I mentioned earlier, *corecursive* means that each element can be constructed
    by applying a function to the previous element, starting from the first one. This
    is what distinguishes corecursive from recursive constructs. (In recursive constructs,
    each element is a function of the previous one, starting with the last one.) We’ll
    come back to this difference in [chapter 4](kindle_split_011.xhtml#ch04), but
    for now, this means that corecursive lists are easy to construct. Just start from
    the first element (`int i = 0`) and apply the chosen function (`i > i++`).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，*corecursive* 意味着每个元素都可以通过应用一个函数到前一个元素来构建，从第一个元素开始。这就是 corecursive 与递归结构区分开来的地方。（在递归结构中，每个元素都是前一个元素的函数，从最后一个元素开始。）我们将在[第4章](kindle_split_011.xhtml#ch04)中再次回到这个区别，但就现在而言，这意味着
    corecursive 列表很容易构建。只需从第一个元素（`int i = 0`）开始，并应用选定的函数（`i > i++`）。
- en: 'You could have constructed the list first and then mapped it to a function
    corresponding to `some processing ...` or to a composition of functions, or an
    effect. Let’s do this with a concrete limit:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先构建列表，然后再将其映射到对应于 `some processing ...` 或函数组合或效果的函数。让我们用一个具体的限制来做这个例子：
- en: '[PRE70]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is nearly equivalent to the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎等同于以下内容：
- en: '[PRE71]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You’ve abstracted the list and the effect. But you can push abstraction further.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经抽象了列表和效果。但你可以进一步抽象。
- en: Exercise 3.11
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.11
- en: 'Write a method to produce a list using a starting value, a limit, and the function
    `x > x + 1`. You’ll call this method `range`, and it will have the following signature:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个方法，使用起始值、限制和函数 `x > x + 1` 来生成一个列表。你将调用这个方法 `range`，它将有以下签名：
- en: '[PRE72]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Solution 3.11
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.11
- en: 'You could use the `for` loop implementation to implement the `range` method.
    But you’ll use a `while` loop to prepare for the next exercise:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for`循环实现来实施`range`方法。但你会使用`while`循环为下一项练习做准备：
- en: '[PRE73]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: I chose a `while` loop because it translates more easily into a generic method
    that can be applied to any type, given a function from this type to itself and
    a second function (called a `predicate`) from this type to a Boolean.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用`while`循环，因为它更容易转换成适用于任何类型的通用方法，给定从该类型到自身的函数以及第二个函数（称为`predicate`）从该类型到布尔值。
- en: Exercise 3.12
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.12
- en: 'Write a generic *range* method that will work for any type and any condition.
    Because the notion of range works mainly for numbers, let’s call this method `unfold`
    and give it the following signature:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个通用的`range`方法，使其适用于任何类型和任何条件。因为范围的概念主要适用于数字，所以让我们称这个方法为`unfold`，并给它以下签名：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Solution 3.12
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.12
- en: 'Starting from the `range` method implementation, all you have to do is replace
    the specific parts with generic ones:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 从`range`方法实现开始，你只需要将特定部分替换为通用部分：
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Exercise 3.13
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.13
- en: Implement the `range` method in terms of `unfold`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 用`unfold`来实现`range`方法。
- en: Solution 3.13
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.13
- en: 'There’s nothing difficult here. You have to provide the `seed`, which is the
    `start` parameter of `range`; the function `f`, which is `x > x + 1`; and the
    predicate `p`, which resolves to `x > x < end`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么困难的。你必须提供`seed`，即`range`的`start`参数；函数`f`，即`x > x + 1`；以及谓词`p`，它解析为`x >
    x < end`：
- en: '[PRE76]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Corecursion and recursion have a dual relationship. One is the counterpart of
    the other, so it’s always possible to change a recursive process into a corecursive
    one, and vice versa. This is the main subject of the next chapter, where you’ll
    learn to change a recursive process into a corecursive one. For now, let’s do
    the inverse process.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 核递归和递归之间存在双重关系。一个是另一个的对立面，因此总是可以将一个递归过程转换为核递归过程，反之亦然。这是下一章的主要内容，你将学习如何将递归过程转换为核递归过程。现在，让我们做相反的过程。
- en: Exercise 3.14
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.14
- en: Write a recursive version of `range` based on the functional method you’ve defined
    in previous sections.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你在前几节中定义的函数式方法编写`range`的递归版本。
- en: Hint
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The only method you need is `prepend`, although you can choose other implementations
    using different methods.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要`prepend`方法，尽管你可以选择使用不同方法的其他实现。
- en: Solution 3.14
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 3.14
- en: 'Defining a recursive implementation is quite simple. You just have to `prepend`
    the `start` parameter to the same method, using the same `end` parameter and replacing
    the `start` parameter with the result of applying the `f` function to it. It’s
    much easier to do than to verbalize:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 定义递归实现相当简单。你只需将`start`参数`prepend`到相同的方法中，使用相同的`end`参数，并用应用`f`函数后的结果替换`start`参数。这比用言语表达要容易得多：
- en: '[PRE77]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Applying the `range` method to obtain the same result as the `for` loop you
    used earlier as an example is simple:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将`range`方法应用于获得与之前作为示例使用的`for`循环相同的结果很简单：
- en: '[PRE78]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can rewrite this as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其重写如下：
- en: '[PRE79]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'More interestingly, if the process applied inside the `for` loop is functional,
    the benefit is even more spectacular:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，如果`for`循环内部应用的过程是函数式的，那么好处会更加显著：
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This can be replaced with the following (assuming the static import of `Collection-Utilities.*`):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以替换为以下内容（假设静态导入`Collection-Utilities.*`）：
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Of course, in this example, `mapViaFoldRight` may also be used.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，也可以使用`mapViaFoldRight`。
- en: The danger of stack-based recursion
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于栈的递归的危险
- en: Recursive implementations as developed in the previous examples shouldn’t be
    used in production, because it’s limited to somewhere between 6,000 and 7,000
    steps. If you try to go further, the stack will overflow. [Chapter 4](kindle_split_011.xhtml#ch04)
    provides more information on this subject.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述示例中开发的递归实现不应在生产环境中使用，因为它限制在6,000到7,000步之间。如果你尝试走得更远，栈将溢出。[第4章](kindle_split_011.xhtml#ch04)提供了更多关于这个主题的信息。
- en: The danger of strictness
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 严格性的危险
- en: None of these versions (recursive and corecursive) are equivalent to the `for`
    loop. This is because, although Java is mostly a strict language (it’s strict
    regarding method arguments), the `for` loop, like all Java control structures
    and some operators, is lazy. This means that in the `for` loop you used as an
    example, the order of evaluation will be index, computation, index, computation
    ..., although using the `range` method will first compute the complete list before
    mapping the function.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这些版本（递归和核心递归）都不等同于`for`循环。这是因为，尽管 Java 主要是一种严格的语言（它在方法参数方面是严格的），但`for`循环，像所有的
    Java 控制结构和一些运算符一样，是惰性的。这意味着在作为示例使用的`for`循环中，评估的顺序将是索引、计算、索引、计算……，尽管使用`range`方法将首先计算完整的列表，然后再映射函数。
- en: 'This problem arises because you shouldn’t be using lists for this: lists are
    strict data structures. But you have to start somewhere. In [chapter 9](kindle_split_016.xhtml#ch09),
    you’ll learn how to build lazy collections that will solve this problem.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题出现是因为你不应该使用列表来做这件事：列表是严格的数据结构。但你必须从某个地方开始。在[第 9 章](kindle_split_016.xhtml#ch09)中，你将学习如何构建惰性集合，这将解决这个问题。
- en: In this section, you’ve learned how to abstract and encapsulate imperative operations
    that are unavoidable when using imperative data structures such as lists. In [chapter
    5](kindle_split_012.xhtml#ch05), you’ll learn how to completely replace these
    legacy data structures with purely functional ones, which will offer more freedom
    and better performance. In the meantime, you must look more closely at types.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经学会了如何抽象和封装在使用命令式数据结构（如列表）时不可避免的命令式操作。在[第 5 章](kindle_split_012.xhtml#ch05)中，你将学习如何完全用纯函数式数据结构替换这些遗留数据结构，这将提供更多的自由和更好的性能。同时，你必须更仔细地考虑类型。
- en: 3.4\. Using the right types
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 使用正确的类型
- en: In the previous examples, you’ve used standard types such as integers, doubles,
    and strings to represent business entities such as prices and email addresses.
    Although this is common practice in imperative programming, it causes problems
    that should be avoided. As I said, you should trust types more than names.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你已经使用了标准类型，如整数、双精度浮点数和字符串来表示业务实体，如价格和电子邮件地址。尽管这在命令式编程中是常见的做法，但它会导致应该避免的问题。正如我所说的，你应该比名称更信任类型。
- en: 3.4.1\. Problems with standard types
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 标准类型的问题
- en: Let’s examine a simplified problem and see how solving it by using standard
    types leads to problems. Imagine you have products with a name, a price, and a
    weight, and you have to create invoices representing product sales. These invoices
    have to mention the products, the quantities, the total price, and the total weight.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个简化的问题，看看如何使用标准类型解决问题会导致问题。想象你有产品，有名称、价格和重量，你必须创建代表产品销售的发票。这些发票必须提到产品、数量、总价和总重量。
- en: 'You could represent a `Product` with the following class:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下类来表示一个`Product`：
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Because properties are final, you need a constructor to initialize them and
    getters to read them, but we didn’t represent the getters.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因为属性是最终的，你需要一个构造函数来初始化它们，以及获取器来读取它们，但我们没有表示获取器。
- en: Next, you can use an `OrderLine` class to represent each line of an order. This
    class is shown in the following listing.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用一个`OrderLine`类来表示订单的每一行。这个类在下面的列表中展示。
- en: Listing 3.10\. The component representing one line of an order
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. 代表订单一行组件
- en: '[PRE83]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This looks like a good old Java object, initialized with a `Product` and an
    `int`, and representing one line of an order. It also has methods for computing
    the total price and the total weight for the line.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个古老的 Java 对象，用`Product`和一个`int`初始化，代表订单的一行。它还具有计算行总价和总重量的方法。
- en: Continuing with the decision to use standard types, you’ll use `List<OrderLine>`
    to represent an order. [Listing 3.11](#ch03ex11) shows how you can handle orders.
    (If you aren’t yet comfortable with functional style, you can compare this code
    to the imperative equivalent, `StoreImperative`, which you’ll find on the book’s
    website at [https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava).)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用标准类型的决定，你将使用`List<OrderLine>`来表示一个订单。[列表 3.11](#ch03ex11)展示了如何处理订单。（如果你还不习惯于函数式风格，你可以将此代码与命令式等效的`StoreImperative`进行比较，你可以在本书的网站上找到，网址为[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)。）
- en: Listing 3.11\. Handling orders
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. 处理订单
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Running this program displays the following result on the console:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将在控制台显示以下结果：
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is fine, but wrong! The problem is that the compiler didn’t tell you anything
    about the error. The only way to catch this error is to test the program, but
    tests can’t prove a program to be correct. They can only prove that you haven’t
    been able to prove it incorrect through writing another program (which, by the
    way, could be incorrect too).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但是错误的！问题是编译器没有告诉你任何关于错误的信息。唯一能够捕获这个错误的方法是测试程序，但测试不能证明程序是正确的。它们只能证明你没有通过编写另一个程序（顺便说一句，这个程序也可能是不正确的）来证明它是不正确的。
- en: 'In case you didn’t notice it (which is unlikely), the problem is in the following
    lines:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有注意到（这不太可能），问题出在以下几行：
- en: '[PRE86]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You’ve incorrectly mixed prices and weights, which the compiler couldn’t notice
    because they’re both doubles.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你错误地将价格和重量混合在一起，编译器因为它们都是`double`类型而没有注意到这一点。
- en: 'By the way, if you’ve learned about modeling, you might recall an old rule:
    classes shouldn’t have several properties of the same type. Instead, they should
    have one property with a specific cardinality. Here, this would mean that a `Product`
    should have one property of type `double`, with cardinality `2`. This is clearly
    not the right way to solve the problem, but it’s a good rule to remember. If you
    find yourself modeling objects with several properties of the same type, you’re
    probably doing it wrong.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你已经学过建模，你可能还记得一条旧规则：类不应该有多个相同类型的属性。相反，它们应该有一个具有特定基数（cardinality）的属性。在这里，这意味着一个`Product`应该有一个类型为`double`的属性，基数（cardinality）为`2`。这显然不是解决问题的正确方法，但这是一个值得记住的好规则。如果你发现自己正在用多个相同类型的属性来建模对象，你很可能做错了。
- en: What can you do to avoid such problems? First, you have to realize that prices
    and weights aren’t numbers. They are quantities. Quantities may be numbers, but
    prices are quantities of money units, and weights are quantities of weight units.
    You should never be in the situation of adding pounds and dollars.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做些什么来避免这样的问题？首先，你必须意识到价格和重量不是数字。它们是数量。数量可能是数字，但价格是货币单位的数量，重量是重量单位的数量。你不应该处于将磅和美元相加的情况。
- en: 3.4.2\. Defining value types
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 定义值类型
- en: 'To avoid this problem, you should use *value types*. Value types are types
    representing values. You could define a value type to represent a price:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，你应该使用*值类型*。值类型是表示值的类型。你可以定义一个值类型来表示价格：
- en: '[PRE87]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You could do the same for the weight:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对重量做同样的处理：
- en: '[PRE88]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'But this doesn’t solve your problem, because you could write this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不能解决你的问题，因为你可能写出这样的代码：
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You need to define addition for `Price` and for `Weight`, and you could do
    that with a method:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为`Price`和`Weight`定义加法，你可以用一个方法来做这件事：
- en: '[PRE90]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You also need multiplication, but multiplication is a bit different. Addition
    adds things of the same type, whereas multiplication multiplies things of one
    type by a number. So multiplication isn’t commutative when it isn’t applied just
    to numbers. Here’s an example of multiplication for `Product`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要乘法，但乘法有点不同。加法是相同类型的对象相加，而乘法是将一个类型的对象乘以一个数字。所以当乘法不是仅应用于数字时，它不是交换律的。以下是`Product`的乘法示例：
- en: '[PRE91]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In your program, you add prices and weights starting with zero. You can’t do
    this any longer, so you need a zero for `Price` and a zero for `Weight`. This
    can be a singleton, so you’ll use
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你从零开始添加价格和重量。你不能再这样做，所以你需要为`Price`和`Weight`提供一个零。这可以是一个单例，所以你会使用
- en: '[PRE92]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: in the `Price` class, and the same thing for the `Weight` class.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Price`类中，以及对于`Weight`类也是同样的情况。
- en: 'The `Product` class needs to be modified as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`类需要按以下方式修改：'
- en: '[PRE93]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`OrderLine` needs to be modified too:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderLine`也需要进行修改：'
- en: '[PRE94]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can now rewrite your program using these types and operations:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用这些类型和操作重写你的程序：
- en: '[PRE95]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can’t mess with types anymore without the compiler warning you. But you
    can do far better than this. First, you can add validation to `Price` and `Weight`.
    Neither of them should be constructed with a zero value, except from inside the
    class itself, for the identity element. You can use a private constructor and
    a factory method. Here’s how it goes for `Price`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不能再随意操作类型而不让编译器警告你。但你可以做得更好。首先，你可以为`Price`和`Weight`添加验证。它们都不应该用零值构造，除非是在类内部，用于身份元素。你可以使用私有构造函数和工厂方法。以下是`Price`的示例：
- en: '[PRE96]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'But the main change you can make is to reuse the fold functions you developed
    in [section 3.3](#ch03lev1sec3). These functions take a function as their third
    parameter, so you first have to define a function for adding prices (in the `Price`
    class):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可以做出的主要改变是重用您在[第3.3节](#ch03lev1sec3)中开发的折叠函数。这些函数将函数作为它们的第三个参数，因此您首先必须定义一个用于添加价格的功能（在`Price`类中）：
- en: '[PRE97]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You also need the same function in the `Weight` class in order to add weights:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在`Weight`类中具有相同的函数，以便添加重量：
- en: '[PRE98]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, you’ll add a `toString` method to `Price` and `Weight` in order to
    simplify testing:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将为`Price`和`Weight`添加一个`toString`方法以简化测试：
- en: '[PRE99]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now you can modify your `Store` class to use folds:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将您的`Store`类修改为使用折叠：
- en: '[PRE100]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 3.4.3\. The future of value types in Java
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3. Java中值类型的未来
- en: Value types can be used for all business types to bring type safety to your
    programs. But value types as I’ve described them aren’t real value types. Real
    value types are manipulated as if they were objects, but perform as if they were
    primitives. Other languages have built-in value types, but Java doesn’t, although
    this might change; a proposal has been made to include value types in a future
    version of Java. If you’re interested in the subject, you can read the proposal
    at [http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型可以用于所有业务类型，以将类型安全引入您的程序。但如我所描述的值类型并不是真正的值类型。真正的值类型被当作对象来操作，但表现起来像原始类型。其他语言有内置的值类型，但Java没有，尽管这可能会改变；已经有人提出了在Java未来的版本中包含值类型的建议。如果您对这个主题感兴趣，可以阅读该建议[http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html)。
- en: 3.5\. Summary
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 摘要
- en: Java control structures can be made more functional by ensuring that no state
    mutation is visible from outside of the structures.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过确保从结构外部不可见任何状态突变，Java的控制结构可以变得更加函数式。
- en: Control structures can be abstracted from the effects they control.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构可以从它们所控制的效果中抽象出来。
- en: The `Result` interface may be used to represent the result of operations that
    may fail.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result`接口可以用来表示可能失败的操作的结果。'
- en: Control structures like `if ... else` and `switch ... case` can be replaced
    with functions.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于`if ... else`和`switch ... case`的控制结构可以用函数替换。
- en: Iteration can be abstracted into functions that may be used as a replacement
    for loops.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代可以抽象成函数，这些函数可以用作循环的替代品。
- en: Lists can be folded in two directions (right and left) to reduce them to a single
    object (which, by the way, may be a new list).
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以双向折叠（右向和左向）以将其简化为一个单一的对象（顺便说一句，这个对象可能是一个新的列表）。
- en: Lists can be processed by recursion or corecursion.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以通过递归或核心递归进行处理。
- en: Functions can be mapped to lists to change the value and/or the type of its
    elements.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以映射到列表中，以改变其元素的价值和/或类型。
- en: Mapping can be implemented using folds.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射可以通过折叠实现。
- en: Effects can be bound to lists in order to be applied to each of their elements.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将效果绑定到列表上，以便应用于它们的每个元素。
- en: Recursion and corecursion can also be used to construct lists.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归和核心递归也可以用来构建列表。
- en: Recursion is limited in depth by the size of the Java stack.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归的深度受Java堆栈大小的限制。
- en: Value types can be used to make programs safer by allowing the compiler to detect
    type problems.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型可以通过允许编译器检测类型问题来使程序更安全。
