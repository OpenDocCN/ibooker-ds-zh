- en: Chapter 4\. Getting organized
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章. 组织起来
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*How to plan programs more thoroughly*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何更彻底地规划程序*'
- en: '*Testing programs using unit tests*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用单元测试测试程序*'
- en: '|  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Until now, you’ve been learning how to use Python, and programming has been
    “by the seat of your pants.” Hunt the Wumpus didn’t have much in the way of planning
    and no tests at all, and, although you tested in the last chapter, you did so
    only fairly lightly. Now, you’ll change tactics and focus on how to plan and test
    programs more thoroughly. You’ll also do some more tricky things with functions
    and learn about *pickle* and *text-wrap*, two more of Python’s standard libraries.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在学习如何使用Python，编程一直是“摸着石头过河”。《寻找巨怪》在规划方面几乎没有什么，也没有任何测试，尽管你在上一章中进行了测试，但你只是轻描淡写地进行了测试。现在，你将改变策略，专注于如何更彻底地规划和测试程序。你还将使用函数做一些更复杂的事情，并了解*pickle*和*text-wrap*，这两个Python标准库中的功能。
- en: The major change in this chapter is that you’ll start learning how to test programs
    automatically. *Unit tests* are a relatively recent idea and help offload a lot
    of the grunt work of testing and debugging your programs onto the computer. You’ll
    also be turning development practice on its head by using Test-Driven Development,
    writing tests before the program. It sounds odd, but it can be enlightening to
    see how unit testing can make tricky problems easy, and how writing tests first
    can help shape the design of your program for the better.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要变化是，你将开始学习如何自动测试程序。*单元测试*是一个相对较新的概念，它可以帮助将大量测试和调试程序的工作转移到计算机上。你还将通过使用测试驱动开发（先写测试再写程序）来颠覆开发实践。这听起来很奇怪，但看到单元测试如何使棘手的问题变得简单，以及先写测试如何有助于更好地塑造程序的设计，可能会令人耳目一新。
- en: Because the theme for this chapter is “getting organized,” the program you’ll
    be writing is a productivity application to help manage to-do lists. You’ll be
    making it a command line application so you can focus on the important parts,
    namely, getting the to-do list functionality right. Later, in [chapter 8](kindle_split_016.html#ch08),
    we’ll take a look at how you can extend the core of this program and give it a
    web interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的主题是“组织”，你将要编写的程序是一个生产力应用程序，用于帮助管理待办事项列表。你将使其成为一个命令行应用程序，这样你可以专注于重要的部分，即确保待办事项列表功能正确。稍后，在第8章（[chapter
    8](kindle_split_016.html#ch08)）中，我们将探讨如何扩展程序的核心并为其添加一个网络界面。
- en: Let’s start by figuring out what you’d like to accomplish.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先弄清楚你想要实现什么目标。
- en: 'Planning: specifying your program'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划：指定你的程序
- en: The first thing you need to do is try to figure out ahead of time what your
    program needs to do, as well as what would be nice to have. That way, you’ll have
    the advantage of knowing in advance what you’re trying to do, and you’ll have
    had time to think about the best way to approach a problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你需要做的是提前尝试弄清楚你的程序需要做什么，以及有什么是令人愉快的。这样，你将提前知道你试图做什么，并且你有时间思考最佳的问题解决方法。
- en: 'You’ll be using a top-down approach to design, where you break down your program
    and describe each part. You’ll also want to think about how each part fits together
    and how they’ll communicate and store data—commonly referred to as the *architecture*
    of your program. If you have enough detail to start programming: great. If not,
    you can repeat it by breaking down your parts into other parts until each is detailed
    enough for you to start work (or, for your customer to sign off). Different projects
    will require different levels of detail depending on what they are and who the
    final customer is. The finished product of this process is known as a *specification*,
    or *spec*, and it’s similar to a blueprint for a building.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你将采用自顶向下的方法进行设计，其中你将分解程序并描述每个部分。你还将想要考虑每个部分如何组合在一起，以及它们如何通信和存储数据——通常被称为程序的结构。如果你有足够的细节开始编程：太好了。如果没有，你可以通过将部分分解为其他部分来重复这个过程，直到每个部分都足够详细，你可以开始工作（或者，让你的客户签字）。不同的项目将需要不同级别的细节，这取决于它们是什么以及最终客户是谁。这个过程完成后的最终产品被称为*规范*或*spec*，它类似于建筑物的蓝图。
- en: '![](f0100-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](f0100-01.jpg)'
- en: 'In the case of the to-do list program, you can use the popular computer industry
    acronym *CRUD* to help guide your spec. CRUD isn’t a statement on the quality
    of your program; it stands for create, retrieve, update, and delete, which are
    the four basic things you generally need to be able to do with your data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在待办事项列表程序的情况下，你可以使用流行的计算机行业缩写词**CRUD**来帮助指导你的规范。CRUD并不是对你程序质量的评价；它代表创建、检索、更新和删除，这是你通常需要能够对数据进行的基本操作：
- en: Add a to-do item (create).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加任务项（创建）。
- en: View the to-dos you’ve already created (retrieve).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您已创建的任务（检索）。
- en: Edit the information in a to-do (update).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑任务中的信息（更新）。
- en: Delete a to-do from your list (delete).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的列表中删除任务（删除）。
- en: The program will also need to handle input from the user, in addition to saving
    the current to-dos so they’re accessible later, and searching for specific to-dos
    (or at least displaying a list of the ones which match certain criteria, such
    as “due today”).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还需要处理用户输入，除了保存当前任务以便以后可以访问，还需要搜索特定任务（或者至少显示符合某些标准（如“今天到期”）的任务列表）。
- en: In terms of architecture, you’ll reuse the route featuring functions plus shared
    data that you put together for Hunt the Wumpus, but you’ll enhance the user interface
    so you can ask the user for more detailed information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构方面，你将重用为“猎捕独角兽”程序准备的路由功能以及共享数据，但你将增强用户界面，以便你可以要求用户提供更详细的信息。
- en: How do you know your program works?
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你怎么知道你的程序能工作？
- en: Before we dive into coding, let’s first talk a little about unit tests and how
    to test your programs more thoroughly. Testing properly sounds boring, but it’s
    actually the opposite. If you don’t test, you’ll invariably end up debugging your
    program instead—if you think testing is boring, debugging is ten times worse.
    Let’s see how automated tests can help make programming more fun.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入编码之前，让我们先简单谈谈单元测试以及如何更彻底地测试你的程序。正确测试听起来很无聊，但实际上正好相反。如果你不测试，你不可避免地会调试你的程序——如果你认为测试无聊，调试则更糟糕十倍。让我们看看自动测试如何帮助使编程更有趣。
- en: Testing manually—boring!
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动测试——无聊！
- en: In the Hunt the Wumpus program, you had no automatic testing at all. Any changes
    you made to the program were verified manually; whenever you made a change, you’d
    run the program and type some input, and, if everything looked good, then you
    could assume your change was good. This can have some downsides, as you’ve seen.
    Your program can *look* ok but have errors you can’t see.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在“猎捕独角兽”程序中，你完全没有自动测试。你对程序所做的任何更改都是手动验证的；每次你做出更改时，你都会运行程序并输入一些数据，如果一切看起来都很好，那么你可以假设你的更改是好的。这可能会带来一些缺点，正如你所看到的。你的程序可能看起来没问题，但存在你看不见的错误。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Why the emphasis on testing? The simple answer is that creating a program is
    much more fun than trying to debug it. Testing thoroughly, particularly with automatic
    tests, helps to nip errors in the bud, and will keep your programming fun!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么强调测试？简单的答案是创建程序比尝试调试它更有趣。彻底测试，尤其是使用自动测试，有助于在错误萌芽时将其扼杀，并将保持编程的乐趣！
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](f0101-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0101-01.jpg)'
- en: The other problem is that it’s boring. That means, as you develop your program
    further, you’re more likely to assume something’s working when it may be broken,
    particularly as you ask old parts of your program to do new things. An “easy fix”
    can end up seriously damaging your program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是有趣。这意味着，随着你进一步开发程序，你更有可能假设某些东西在正常工作，而实际上可能已经损坏，尤其是在你要求程序的老部分做新的事情时。一个“简单的修复”可能会严重损害你的程序。
- en: Functional testing
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能测试
- en: When writing your difference engine, you used some simple *functional testing*
    to make sure the program worked properly. You set up two directories, ran the
    program, and checked that it output the right results; that is, you tested its
    functionality directly. That’s a lot better than manually testing, because it’s
    easier and faster and you’re not likely to get too bored, but the downside is
    that it only finds bugs in your program. You still need to go through the arduous
    process of debugging in order to find out what’s causing the error.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写你的差分机时，你使用了一些简单的**功能测试**来确保程序能正确工作。你设置了两个目录，运行了程序，并检查了它是否输出了正确的结果；也就是说，你直接测试了它的功能。这比手动测试要好得多，因为它更容易、更快，而且你不太可能感到无聊，但缺点是它只能找到你程序中的错误。你仍然需要经历繁琐的调试过程，才能找出导致错误的原因。
- en: The other problem is that if you change how your program works, then you might
    need to change your tests, which could potentially be a lot of work. In that case,
    you might be tempted to ignore your tests and go back to testing manually.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是你可能会改变程序的工作方式，那么您可能需要更改测试，这可能会涉及大量工作。在这种情况下，您可能会倾向于忽略测试并回到手动测试。
- en: 'Unit testing: make the computer do it'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试：让计算机来做
- en: 'Luckily, there’s an easier way to deal with repetitive, boring tasks: make
    the computer do it. The mechanism you’ll use in this chapter is called *unit testing*.
    Unit testing works by testing small parts, or units, of your program. In the same
    way you’ve been breaking down programs to make them easier to write, unit testing
    breaks down the program into units—such as functions—and makes sure they work
    for a range of inputs. Unit tests also help to isolate the code you’re testing,
    which means any errors that occur when running your tests can be quickly tracked
    down to individual functions and fixed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更简单的方法来处理重复、无聊的任务：让计算机来做。在本章中您将使用的机制称为 *单元测试*。单元测试通过测试程序的小部分，或单元，来工作。就像您一直在分解程序以使其更容易编写一样，单元测试将程序分解成单元——例如函数——并确保它们在一系列输入下都能正常工作。单元测试还有助于隔离您正在测试的代码，这意味着在运行测试时发生的任何错误都可以快速追踪到单个函数并修复。
- en: Test-Driven Development
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'The key way to use unit testing when developing your programs is to write your
    tests first. That seems backward, but it forces you to focus on the higher-level
    design of your code instead of the details. The way it works is this: if you want
    to add a feature, you write a test and run it. You won’t have written the code
    the test needs yet, so it will break. You then add enough code so your test passes
    and starts to work; then you think of another test, and repeat the process. [Figure
    4.1](#ch04fig01) is a handy three-step chart you can follow if you get lost.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发程序时使用单元测试的关键方式是先编写测试。这看起来有些反直觉，但它迫使您关注代码的高级设计而不是细节。其工作方式是这样的：如果您想添加一个功能，您将编写一个测试并运行它。您还没有编写测试所需的代码，所以它会失败。然后您添加足够的代码以便测试通过并开始工作；然后您想到另一个测试，并重复这个过程。[图4.1](#ch04fig01)
    是一个方便的三步流程图，如果您迷路了可以遵循。
- en: Figure 4.1\. The Test-Driven Development cycle
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. 测试驱动开发周期
- en: '![](04fig01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01.jpg)'
- en: As you work, you’ll be building a suite of tests that will help keep your program
    on the right track. Your unit tests will also act as a low-level specification
    for how your program should work. It will answer questions such as, exactly what
    input should Python expect from this function? What should it do when you give
    it some input it’s not expecting, or if the input is wrong?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的工作过程中，您将构建一系列测试，这将帮助您的程序保持正确的方向。您的单元测试还将作为程序应该如何工作的低级规范。它将回答诸如，Python应该从这个函数中期望什么输入？当您给它一些它没有期望的输入，或者输入错误时，它应该做什么等问题？
- en: Writing the program
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写程序
- en: 'Let’s get started with writing the first test. There are libraries that can
    help you to test your programs, but, for now, you’ll keep things simple and use
    Python’s built-in *assert* statement. *assert* takes the following format:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写第一个测试开始。有一些库可以帮助您测试您的程序，但，目前，您将保持简单，并使用Python的内置 *assert* 语句。*assert*
    采用以下格式：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](f0103-01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](f0103-01.jpg)'
- en: Python will test the first condition, exactly like an *if* statement, and, if
    it’s false, then an error is raised with the message you’ve specified in the second
    part. You’ll test each part of the program with a function that tries a particular
    section of the program then uses *assert* to make sure the results are what you
    expect.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将测试第一个条件，就像一个 *if* 语句一样，如果它为假，则将引发一个错误，并显示您在第二部分中指定的消息。您将通过一个尝试程序特定部分的函数来测试程序的每个部分，然后使用
    *assert* 确保结果符合您的预期。
- en: Type the program from the following listing into a file called test_todo.py.
    This test specifies how one function from your program should behave.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下列表中的程序输入到名为 test_todo.py 的文件中。此测试指定了程序中的一个函数应该如何表现。
- en: Listing 4.1\. Your first unit test
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 您的第一个单元测试
- en: '![](04list01_alt.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](04list01_alt.jpg)'
- en: This is the program you’ll write, which will be called todo.py![](one.jpg).
    Don’t create the file just yet; you’ll do that in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是您将要编写的程序，将被命名为 todo.py![](one.jpg)。现在请不要创建文件；您将在下一节中这样做。
- en: The first test is a simple function ![](two.jpg). Note that you should follow
    the same rules for your unit tests that you do for the functions in the rest of
    your program. If they’re confusing, then you’ll have trouble finding errors or
    fixing things when your tests fail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试是一个简单的函数 ![图片](two.jpg)。请注意，你应该遵循与程序中其他函数相同的规则来编写你的单元测试。如果它们令人困惑，那么当你的测试失败时，你将难以找到错误或修复问题。
- en: '*todos* will be where your program will store its list of to-dos ![](three.jpg).
    Note that you’re overriding whatever the current list of to-dos is by making it
    an empty list. This helps you write your tests faster—if you had a shared to-do
    list, then you’d have to worry about what other tests had done to it before you’d
    run the tests. The other thing to note is that you’re referring to the module’s
    version of *todos*. If you were to only use a local *todos* variable, you’d have
    two versions: one in the module and another you’d created, and you might confuse
    the two.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*todos* 将是程序存储待办事项列表的地方 ![图片](three.jpg)。请注意，你通过将其设置为空列表来覆盖当前的待办事项列表。这有助于你更快地编写测试——如果你有一个共享的待办事项列表，那么你必须在运行测试之前担心其他测试对它的操作。要注意的另一件事是，你正在引用模块的
    *todos* 版本。如果你只使用一个局部 *todos* 变量，你将有两个版本：一个在模块中，另一个是你创建的，你可能会混淆这两个版本。'
- en: The test runs one small part of the to-do program ![](four.jpg), creating a
    to-do. It might be tempting to do more in one test, but the larger your test is,
    the more difficult it is to track down errors when they happen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行待办程序的一个小部分 ![图片](four.jpg)，创建一个待办事项。你可能想在一个测试中做更多的事情，但你的测试越大，出错时追踪错误就越困难。
- en: Now you use Python’s *assert* command to test that *create_todo* has done the
    right thing ![](five.jpg). It should have created a to-do item with the right
    details and added it into your to-do list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你使用 Python 的 *assert* 命令来测试 *create_todo* 是否正确执行 ![图片](five.jpg)。它应该已经创建了一个带有正确细节的任务项并将其添加到你的待办事项列表中。
- en: Once you’ve set up the test, you can call it to run it and test the program
    ![](six.jpg). You’ve also added a *print* statement so you know when the test
    has been run successfully.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了测试，你就可以调用它来运行并测试程序 ![图片](six.jpg)。你还在代码中添加了一个 *print* 语句，这样你知道测试何时成功运行。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s not just your tests that should be simple. Unit testing also forces you
    to make your *code* simple. Large, clumsy functions are hard to test—and, by extension,
    hard to understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅你的测试应该是简单的。单元测试还迫使你使你的 *code* 简单。大型、笨拙的函数难以测试——并且，通过扩展，难以理解。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The main thing to notice about [listing 4.1](#ch04list1) is that it’s short
    and simple. Unit tests shouldn’t be long, complicated, and hard to understand—if
    they are, then there’s something wrong with either your tests or your code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [列表 4.1](#ch04list1) 的主要注意事项是它简短且简单。单元测试不应该长、复杂且难以理解——如果它们是这样的，那么你的测试或代码可能存在问题。
- en: Making your tests pass
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使测试通过
- en: 'You have a unit test, but what does it do? Let’s run it and see what happens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个单元测试，但它做什么？让我们运行它看看会发生什么：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](f0105-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0105-01.jpg)'
- en: 'Uh-oh, what’s gone wrong? Well, nothing. That’s pretty much what you were expecting.
    Because you haven’t written the program yet, your test doesn’t have a *todo* module
    to work with. From here, you’ll be adding bits to the program to fix the errors
    you’ll get from your unit tests, so go ahead and create a file called todo.py
    in the same directory and run the test again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，出了什么问题？嗯，没什么。这正是你预期的。因为你还没有编写程序，你的测试没有 *todo* 模块可以工作。从这里开始，你将向程序中添加一些内容来修复从单元测试中得到的错误，所以请继续在同一个目录下创建一个名为
    todo.py 的文件，并再次运行测试：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another error, but it’s different this time and on line 6 rather than line
    2, so you’re making progress. Your test is now complaining that it can’t find
    the *create_todo* function, so let’s go ahead and add that to todo.py. As input,
    it will need to have your to-do list, plus a title, description, and level, because
    that’s what you’ve specified in the test:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误，但这次不同，它在第 6 行而不是第 2 行，所以你正在取得进步。你的测试现在抱怨找不到 *create_todo* 函数，所以让我们继续在
    todo.py 中添加它。作为输入，它需要你的待办事项列表，以及标题、描述和级别，因为这是你在测试中指定的：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s a simple program that uses Python’s *pass* statement to do nothing at
    all. It doesn’t pass your test either, but you’re making progress. You’re starting
    to test the functionality of the program rather than whether a function exists:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的程序，它使用 Python 的 *pass* 语句什么都不做。它也没有通过你的测试，但你正在取得进步。你开始测试程序的功能，而不是检查函数是否存在：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now your test is complaining that the to-do wasn’t added to the to-do list.
    The code to make your test pass is pretty obvious now, so fix it all in one fell
    swoop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试抱怨待办事项没有被添加到待办事项列表中。使测试通过所需的代码现在很明显，所以一次性修复所有问题：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The test passes. When you run the test against this program, you should see
    *ok - create_todo* printed to the screen. Fantastic—the test passes, so you know
    the function is working. Now, let’s have a look at how you’ll be calling this
    function within your program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过。当你运行测试针对此程序时，你应该在屏幕上看到*ok - create_todo*打印出来。太棒了——测试通过了，所以你知道函数正在正常工作。现在，让我们看看你将在程序中如何调用此函数。
- en: Putting your program together
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装你的程序
- en: 'You’ll follow the same strategy you did for Hunt the Wumpus: get something
    simple up and running quickly, and then build from there. The simplest usable
    program you can create will be something that’s only able to create to-dos—but
    that should be enough. To get there, you’ll have to think about how you want to
    be able to input to-dos, as well as how to get from that input to running the
    relevant function in the program, and then how to return output to the screen.
    More important, you want to think about an easy way for you to write tests to
    make sure everything is working properly.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遵循与Hunt the Wumpus相同的策略：快速构建一个简单的可运行程序，然后在此基础上构建。你可以创建的最简单可用的程序将只能创建待办事项——但这应该足够了。为了达到这个目标，你必须考虑你想要如何输入待办事项，以及如何从输入到程序中相关函数的运行，然后如何将输出返回到屏幕。更重要的是，你想要考虑一个简单的方法来编写测试，以确保一切正常工作。
- en: '![](f0107-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![f0107-01.jpg](f0107-01.jpg)'
- en: Testing user interfaces
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试用户界面
- en: One of the big problems with unit testing is that it’s not so good at testing
    user interfaces. For example, there’s no Python command that will let you type
    information into *raw_input*. Things get even harder when it comes to testing
    graphical interfaces, with mouse positions and pop-up windows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个大问题在于它并不擅长测试用户界面。例如，没有Python命令可以让你在*raw_input*中输入信息。当涉及到测试图形界面，包括鼠标位置和弹出窗口时，事情变得更加困难。
- en: The solution is to make your user interface as simple as possible, so it’s easy
    to test. Ideally, it should be possible to make sure your code is correct just
    by looking at it. In your to-do list application, you’ll use the following snippet
    to run everything in the program. Go ahead and add it to todo.py at the bottom
    of the file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是尽可能简化用户界面，使其易于测试。理想情况下，应该能够仅通过查看代码来确保代码的正确性。在你的待办事项列表应用程序中，你将使用以下代码片段来运行程序中的所有内容。请将其添加到文件的底部todo.py中。
- en: Listing 4.2\. One part of the program you can’t test
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. 你无法测试程序的一部分
- en: '![](04list02_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![04list02_alt.jpg](04list02_alt.jpg)'
- en: First, you do something with the command the person using the program has typed
    in ![](one.jpg). Initially, you’re not accepting input, which might seem a bit
    backward, but it will let you print a welcome/help screen when the program is
    first run. *run_command* is the meat of the program, but it takes whatever input
    has been typed in; that will make it easier for you to test in a minute.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用程序用户输入的命令进行一些操作 ![one.jpg](one.jpg)。最初，你并不接受输入，这可能会显得有些反直觉，但它会允许你在程序首次运行时打印欢迎/帮助屏幕。"run_command"是程序的精髓，但它接受任何已输入的输入；这将使你在下一分钟测试时更容易。
- en: Once you’ve run with the input you’ve been given, tell Python to ask for some
    more input ![](two.jpg).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用给定的输入运行了程序，告诉Python要求更多的输入 ![two.jpg](two.jpg)。
- en: The one command that’s outside the *run_command* function is *quit*. You check
    here for any command that starts with the word *quit* ![](three.jpg). If you see
    it, you break out of the *while* loop right away; this will end the program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在*run_command*函数之外的一个命令是*quit*。你在这里检查任何以单词*quit*开头的命令 ![three.jpg](three.jpg)。如果你看到它，立即跳出*while*循环；这将结束程序。
- en: When you’re importing your program as part of your tests, you don’t want to
    run the *main_loop* function, but you do if you run it directly as a program ![](four.jpg).
    The solution is this *if* statement, which is common in Python programs. *__name__*
    is the current namespace, or the name of the module you’re running in. If a program
    is run directly, it will be called *__main__*, and you can catch it with the *if*
    statement. Usually, this *if* block will go at the end of your program to make
    sure all the functions it uses are defined.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将程序作为测试的一部分导入时，你不想运行`*main_loop*`函数，但如果你直接将其作为程序运行，你就想运行它！解决方案是这个`*if*`语句，这在Python程序中很常见。`__name__`是当前命名空间，或者你正在运行的模块的名称。如果程序直接运行，它将被称为`__main__`，你可以用`*if*`语句捕获它。通常，这个`*if*`块会放在程序的末尾，以确保它使用的所有函数都已定义。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This type of structure is called an *event loop*; it tells Python to wait for
    input from the person using the program—or some other source, like the network—and
    then takes action based on what it finds.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构被称为*事件循环*；它告诉Python等待程序使用者（或网络等其他来源）的输入，并根据找到的内容采取行动。
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The other thing you need is some way to get multiple lines of input. If you’re
    adding a new to-do, then you’ll need to ask for its title, description, and level.
    That’s also fairly hard to test without resorting to drastic measures, like modifying
    the *raw_input* function. The following function goes in todo.py too and prompts
    the person using the program for an entry into a list of fields.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一种方式来获取多行输入。如果你要添加一个新的待办事项，那么你需要询问它的标题、描述和级别。这也相当难以测试，除非采取极端措施，比如修改`*raw_input*`函数。以下函数也放在`todo.py`中，并提示程序使用者输入一个字段列表。
- en: Listing 4.3\. The other part of the program you can’t test
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3。程序中你无法测试的另一部分
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, this is a straightforward part of the program. We’re keeping it as simple
    as possible so you have little to debug manually. If there’s an error your tests
    can’t pick up, it should be obvious where that error is.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是程序的一个简单部分。我们尽量让它尽可能简单，这样你手动调试的量就会很少。如果测试无法检测到错误，那么错误应该很明显。
- en: What do you do with your input?
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 你如何处理你的输入？
- en: 'Now you can start writing the run_command script in earnest. The first thing
    you’ll want the program to do is to pick a Python function to run based on what
    the user types in, so let’s do that part first. It’s fairly easy, but you’ll need
    to use a new Python trick. You should put the next section in `test_todo.py`.
    All the testing code will go in that file, and the program code itself will go
    in `todo.py`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始认真编写`run_command`脚本了。你首先想让程序做的事情是根据用户输入选择一个Python函数来运行，所以让我们先做这部分。这相当简单，但你需要使用一个新的Python技巧。你应该把下一部分放在`test_todo.py`中。所有的测试代码都将放在那个文件中，程序代码本身将放在`todo.py`中：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](f0109-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0109-01.jpg)'
- en: You’re planning on setting up a function that tells you what to run for a given
    command. Then, when you call it with a *new* command, you expect it to return
    the *create_todo* function—not the results of the function, but the function itself.
    In Python, you can assign functions to variables the same way you can assign strings,
    numbers, lists, and dictionaries. You’ll see how to make use of it shortly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划设置一个函数，告诉你给定命令应该运行什么。然后，当你用*新*命令调用它时，你期望它返回`*create_todo*`函数——不是函数的结果，而是函数本身。在Python中，你可以像分配字符串、数字、列表和字典一样分配函数到变量。你很快就会看到如何使用它。
- en: Now that you have your test, add the code to call it beneath the *test_create_todo()*
    one and run the tests again. The new test you’ve just added should fail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了测试，请在`*test_create_todo()*`下面添加调用它的代码，并再次运行测试。你刚刚添加的新测试应该会失败。
- en: 'Here’s some code that fixes it and allows room for you to expand to include
    other functions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码可以修复它，并为你提供扩展到包括其他函数的空间：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*commands* is a dictionary with all your commands in it. The key is the name
    of the command, and the value of the dictionary is the function that will be called.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`*commands*`是一个包含所有命令的字典。键是命令的名称，值是将被调用的函数。'
- en: Given the name of the command you want to run, *get_function* will return the
    function you need to call.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给定你想要运行的命令的名称，`*get_function*`将返回你需要调用的函数。
- en: Running commands
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行命令
- en: 'That’s one piece of the puzzle. The next piece is how you get the input from
    your *get_input* function into your final function. Well, you’ll need to know
    what fields a particular function needs, so let’s start with that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是谜题的一部分。下一部分是如何将 *get_input* 函数的输入传递到你的最终函数中。好吧，你需要知道特定函数需要哪些字段，所以我们从这里开始：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s pretty easy, because it’s much the same thing you did to find the command
    function. Add the test function at the bottom as before, run your tests, and make
    sure your new test fails; then you can write your code. My version is featured
    in the following listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，因为它与你用来查找命令函数的方法几乎相同。像以前一样在底部添加测试函数，运行你的测试，并确保你的新测试失败；然后你可以编写代码。我的版本在下面的列表中。
- en: Listing 4.4\. Finding command fields
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 查找命令字段
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the *commands* dictionary has changed as well as the code you wrote
    to find the function. It makes more sense to keep the command function and the
    fields it’s expecting in the same place so they’re easier to change and don’t
    get mixed up. That’s completely normal and perfectly ok—as long as your tests
    still pass.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 *commands* 字典以及你用来查找函数的代码都已经发生了变化。将命令函数及其期望的字段放在同一个地方，这样更容易更改并且不会混淆，这是完全正常且完全可行的——只要你的测试仍然通过。
- en: '![](f0111-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f0111-01.jpg](f0111-01.jpg)'
- en: Now that you’ve created and tested those two low-lying functions, you’re ready
    to try to create the *run_command* function. That will complete the user interface
    section of the program, and you can work on the rest of the code that does the
    work. There are a few more unit-testing techniques you’ll need to use first, though.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建并测试了这两个低级函数，你就可以尝试创建 *run_command* 函数了。这将完成程序的界面部分，然后你可以继续编写其他执行工作的代码。不过，你首先需要使用一些单元测试技术。
- en: The following listing is a new test that makes sure your *run* command works.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表是一个新的测试，确保你的 *run* 命令正常工作。
- en: Listing 4.5\. Testing `run_command`
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 测试 `run_command`
- en: '![](04list05_alt.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![04list05_alt.jpg](04list05_alt.jpg)'
- en: Ideally, when you’re unit testing, you’d like to test exactly one aspect of
    the program. If you have tests that combine results from lots of functions and
    one of those functions fails, you still have to debug the program. You only want
    to test *run_command*, so let’s create a dummy test program ![](one.jpg) that
    only returns its input, rather than forcing the tests to use (and then interpret
    the results from) the *create_todo* function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，当你进行单元测试时，你希望测试程序的某个特定方面。如果你有将多个函数的结果组合在一起的测试，并且其中一个函数失败了，你仍然需要调试程序。你只想测试
    *run_command*，所以让我们创建一个虚拟测试程序 ![one.jpg](one.jpg)，它只返回其输入，而不是强迫测试使用（然后解释）*create_todo*
    函数的结果。
- en: The other thing you need to test is that data is fed into the command function
    properly. But how do you do that without forcing someone to enter the data every
    time you test? The solution is to use a Python default variable to mimic the data
    entry ![](two.jpg). When the program runs normally, it will ask the user via the
    *get_input* function; but if you feed in a dictionary, it will use that instead.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要测试的是数据是否正确地输入到命令函数中。但是，你如何在每次测试时都不强迫某人输入数据呢？解决方案是使用 Python 默认变量来模拟数据输入 ![two.jpg](two.jpg)。当程序正常运行时，它将通过
    *get_input* 函数询问用户；但是如果你输入一个字典，它将使用该字典。
- en: Because the architecture is only moving text around ![](three.jpg), your function
    is easy to test—feed in some input dictionary, and check that you get the right
    output back. Note that I’ve broken up the line here in a different way, by using
    a backslash character (\) instead of braces. If you choose to use this too, make
    sure it’s the very last character on the line; otherwise it won’t work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为架构只是移动文本 ![three.jpg](three.jpg)，所以你的函数很容易测试——输入一些输入字典，并检查你是否得到了正确的输出。注意，我在这里以不同的方式拆分了行，通过使用反斜杠字符（\）而不是花括号。如果你选择使用这个方法，确保它是行上的最后一个字符；否则，它将不起作用。
- en: Let’s see what the code looks like that will make your test pass. Again, once
    you’ve written the test, the code is relatively straightforward— and you generally
    don’t have to debug functions you’ve already written. My version looks like the
    following listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使测试通过的代码是什么样的。同样，一旦你编写了测试，代码相对简单——而且你通常不需要调试你已经编写的函数。我的版本如下所示。
- en: Listing 4.6\. Writing `run_command`
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 编写 `run_command`
- en: '![](04list06_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![04list06_alt.jpg](04list06_alt.jpg)'
- en: First, you use a default variable ![](one.jpg). You set data to *None* for most
    cases, but, when testing, you can feed in data as a dictionary to mimic user input.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用一个默认变量 ![](one.jpg)。在大多数情况下，你将数据设置为 *None*，但在测试时，你可以将数据作为字典输入以模拟用户输入。
- en: You use the *lower()* method to make the command lowercase, and then you look
    it up in your dictionary ![](two.jpg). If you can’t find it, then you return an
    error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 *lower()* 方法将命令转换为小写，然后你在你的字典 ![](two.jpg) 中查找它。如果你找不到它，那么你将返回一个错误。
- en: When running the program normally, data will be *None*. When you see this, you
    know you need to read some input from the user, and you can call *get_fields*
    so you know what to ask ![](three.jpg).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序正常运行时，数据将是 *None*。当你看到这个时，你知道你需要从用户那里读取一些输入，并且你可以调用 *get_fields* 来了解应该询问
    ![](three.jpg) 什么。
- en: Now that you know which function to call and what data to call it with, you
    can go ahead and pass control over ![](four.jpg). The command function will do
    whatever it’s supposed to and feed the results back as a string, which you hand
    back to the user. The **** in front of your input dictionary looks a bit weird—what
    it does is pass in the dictionary arguments as keyword arguments. This way, you
    can see what values a particular function is expecting in the function definition,
    rather than having one big value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道要调用哪个函数以及传递什么数据，你可以继续操作并控制 ![](four.jpg)。命令函数将执行其应有的操作，并将结果作为字符串返回，然后你将这个字符串返回给用户。你输入字典前面的
    **** 看起来有点奇怪——它的作用是将字典参数作为关键字参数传递。这样，你可以在函数定义中看到特定函数期望的值，而不是有一个大值。
- en: Great—now you have a straightforward way to assign text input from the person
    using the program and pass that on to a particular function. The rest of the chapter
    will deal with adding to that framework by writing other functions that fit into
    it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——现在你有一个直接的方法来分配程序使用者的文本输入并将其传递给特定的函数。接下来的章节将讨论通过编写其他适合该框架的函数来扩展这个框架。
- en: '![](f0113-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](f0113-01.jpg)'
- en: Running your program
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序
- en: You might’ve noticed something odd by this stage; you haven’t actually run the
    program yet to make sure it works. In previous chapters, you’ve been writing your
    program, running it to make sure it works, and then writing a bit more. Because
    you’ve been unit testing, though, you haven’t had to do that once—the unit tests
    pass, so the code must be working, right?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你可能已经注意到一些奇怪的事情；你实际上还没有运行程序来确保它工作。在之前的章节中，你一直在编写程序，运行它以确保它工作，然后再编写一些。但是，由于你一直在进行单元测试，所以你实际上一次都没有这样做——单元测试通过了，所以代码必须工作，对吧？
- en: You might be a bit skeptical about that, but your program is pretty functional
    at this stage, and you can run it if you want to make sure. The following listing
    shows a sample run.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对此有点怀疑，但你的程序在这个阶段已经相当功能化了，如果你想确保它工作，可以运行它。下面的列表显示了一个示例运行。
- en: Listing 4.7\. Your program so far
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 到目前为止的程序
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are still a few loose ends to tidy up, but you can already create a to-do
    item from the user interface on your program, which means all of your infrastructure
    is working. You’re on a roll!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些细节需要整理，但你已经可以从程序的用户界面创建待办事项，这意味着你的所有基础设施都在正常工作。你正在取得进展！
- en: Taking stock
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查清单
- en: So far, you’ve made a good start on your program, and you have most of the core
    of it working. Additionally, you have tests you can run to make sure the program
    *stays* working. Your unit tests have also had another benefit; because you’ve
    only been testing small parts of the program, your program is already broken down
    into small functions, and there’s no need to tidy it up or refactor it. At least,
    not yet.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在程序上已经取得了良好的开端，并且程序的大部分核心功能已经工作。此外，你可以运行测试来确保程序 *持续* 工作。你的单元测试也有另一个好处；因为你只测试了程序的小部分，所以你的程序已经被分解成小的函数，没有必要整理或重构它。至少，目前不需要。
- en: '![](f0114-01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](f0114-01.jpg)'
- en: What to do next?
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下一步该做什么？
- en: The next important part of your application is showing what’s in the to-do list;
    there’s not much point in adding to your list if you can’t see what’s in it later.
    To get started, you’ll write a test for a function that will show you all your
    to-dos. Then, you’ll look at streamlining it to hide those that aren’t as important.
    After you’ve done that, we’ll look at how you can save your lists and reload them,
    so you don’t have to reenter everything when you restart the program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你应用程序的下一个重要部分是显示待办事项列表中的内容；如果你不能在以后看到列表中的内容，添加到列表中就没有什么意义了。为了开始，你将编写一个测试函数，该函数将显示你所有的待办事项。然后，你将查看如何简化它以隐藏不那么重要的待办事项。完成这些后，我们将探讨如何保存你的列表并重新加载它们，这样你就不必在程序重新启动时重新输入一切。
- en: This next listing makes sure a to-do is shown properly when you view it in your
    program.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表确保当你在你的程序中查看待办事项时，待办事项能够正确显示。
- en: Listing 4.8\. Testing your to-do list view
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 测试你的待办事项列表视图
- en: '![](04list08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![04list08.jpg]'
- en: First, you set up a to-do list ![](one.jpg). Because your to-do list is in a
    known state, this will make it easier to test. It’s tempting here to reuse your
    creation test to set up the to-do list, but that’s a trap. Even though it might
    save some code, you’re creating a dependency between your tests. Later, if there
    was a bug in the creation function, you’d have two (or more) test failures, and
    the bug would be much harder to track down.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你设置一个待办事项列表 ![待办事项列表](one.jpg)。因为你的待办事项列表处于已知状态，这将使测试更容易进行。在这里重用你的创建测试来设置待办事项列表很有诱惑力，但这是一个陷阱。尽管这可能节省一些代码，但你正在在测试之间创建依赖关系。以后，如果创建函数中存在错误，你将有两个（或更多）测试失败，错误追踪将变得更加困难。
- en: 'You run the view function over the to-do list ![](two.jpg) and get the results
    back. To make life easier, you split the result into lines by using the *split()*
    method of the result string to split on line endings. I’m imagining that the list
    of to-dos will look something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你在待办事项列表 ![待办事项列表](two.jpg) 上运行视图函数，并返回结果。为了使生活更简单，你使用结果字符串的 *split()* 方法通过行结束符来拆分结果。我想象待办事项列表将看起来像以下这样：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](f0116-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![f0116-01.jpg]'
- en: Next, you test that the words you’re expecting exist in each line ![](three.jpg).
    The first line should be the headers for the columns, and the second should have
    the values you’re expecting. Notice that you’re specifying each value individually
    in the test—you could generate a string for the exact result you’re expecting
    from the function, but that’s another trap. Specifying the results too strictly
    makes the test fragile, and the slightest change to how the results are formatted
    or the order of the columns can make your test fail when it shouldn’t. In practice,
    you should only test what’s important and leave out as much of the rest as you
    can.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你测试你期望的单词是否存在于每一行 ![待办事项列表](three.jpg)。第一行应该是列的标题，第二行应该有你期望的值。注意你在测试中指定每个值都是单独的——你可以为函数期望的确切结果生成一个字符串，但这又是一个陷阱。过于严格地指定结果会使测试变得脆弱，格式或列的顺序的任何微小变化都可能导致测试失败，而实际上它不应该失败。在实践中，你应该只测试重要的内容，并尽可能多地省略其他内容。
- en: Now that you know what you’re expecting of your function, you can go ahead and
    write it. Python strings have several methods you can use to format the output;
    let’s see how you can use them. The *show_todos()* function in the following listing
    shows you how a few of them work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道你期望你的函数做什么，你可以继续编写它。Python字符串有几种你可以用来格式化输出的方法；让我们看看你如何使用它们。以下列表中的 *show_todos()*
    函数展示了其中一些方法的工作原理。
- en: Listing 4.9\. Displaying to-do items
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 显示待办事项
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, you initialize the output as a list of headers. You’ll be copying each
    line onto the end of the output as you go. Notice how the string is placed on
    two lines and wrapped within brackets? This makes it easier to read on the page.
    Python automatically joins strings like this, so there’ll only be one big string
    when it’s assigned to *output*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化输出为一个标题列表。随着你进行，你将逐行将每一行复制到输出的末尾。注意字符串是如何放在两行中并用括号括起来的？这使得在页面上阅读更容易。Python会自动将字符串这样连接起来，所以当它被分配给*output*时，将只有一个大字符串。
- en: '![](f0117-01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![f0117-01.jpg]'
- en: Next, you go through each of the to-dos and add numbers. I’ve added an index
    to make it easier to see how many to-dos you have. *enumerate()* takes a list
    or iterable and returns the next item along with its index in the list—handy for
    situations like this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你遍历每个待办事项并添加数字。我添加了一个索引，以便更容易地看到你有多少个待办事项。*enumerate()* 接受一个列表或可迭代对象，并返回列表中的下一个项及其索引——这对于这种情况很有用。
- en: In order to format the results, you start the line by printing the number of
    the to-do. So that the rest of the columns line up, you convert it to a string
    and use the *.ljust()* string method to space it out to eight columns. Python
    strings have many other methods like this, such as *.rjust()* and *.center()*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了格式化结果，你开始一行打印待办事项的编号。为了使其余的列对齐，你将其转换为字符串，并使用 *.ljust()* 字符串方法将其扩展到八列。Python
    字符串有其他许多类似的方法，例如 *.rjust()* 和 *.center()*。
- en: Next, you print each part of your to-do in a column. Here I’ve been a bit tricky
    and pulled out the key you’re printing and its width into a list, which you’re
    looping over. That way, you can pull out each value from the to-do and make it
    the right width.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你按列打印每个待办事项的部分。在这里，我稍微有点狡猾，把你要打印的键及其宽度拉到一个列表中，然后你遍历这个列表。这样，你可以从待办事项中提取每个值，并使其具有正确的宽度。
- en: Finally, don’t forget to add the *show* command into the list of commands so
    you can use it when you’re running your program. It doesn’t take any arguments,
    so it has an empty list instead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了将 *show* 命令添加到命令列表中，这样你就可以在运行程序时使用它。它不需要任何参数，所以它有一个空列表。
- en: The code you’ve added is straightforward, but if you were developing this using
    “code and bugfix” as you did for Hunt the Wumpus, you’d have to go back and forth
    several times to get the code working. With unit testing, you can specify exactly
    what your output should be and then add it directly to your program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的代码很简单，但如果你像为“Hunt the Wumpus”开发时那样使用“代码和错误修复”，你可能需要多次来回才能使代码工作。使用单元测试，你可以指定你的输出应该是什么，然后直接将其添加到你的程序中。
- en: I’m very busy and important
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我非常忙，非常重要
- en: The other thing you’d like to check is that your view function displays your
    todos in the right order. Ideally, important things should be displayed differently
    depending on how important they are. You’ll put the important items at the top
    and unimportant ones at the bottom. The problem is that, so far, you’ve been putting
    the level of importance as a text field, which would appear to make your list
    a bit hard to sort. Luckily, there are tools in Python to deal with this sort
    of thing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还想检查的另一件事是，你的视图函数是否按正确的顺序显示待办事项。理想情况下，重要的事情应该根据其重要性以不同的方式显示。你将重要事项放在顶部，不重要的事项放在底部。问题是，到目前为止，你一直将重要性级别作为文本字段，这可能会使你的列表难以排序。幸运的是，Python
    中有处理这类问题的工具。
- en: '![](f0118-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](f0118-01.jpg)'
- en: But we’re getting ahead of ourselves. First you need a test to make sure your
    program sorts your to-dos properly! The test in the following listing should do
    the trick.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可能有点超前了。首先，你需要一个测试来确保你的程序正确地排序了待办事项！以下列表中的测试应该能解决问题。
- en: Listing 4.10\. Testing the order of your view
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 测试视图的顺序
- en: '![](04list10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项列表](04list10.jpg)'
- en: Here’s your sample list of to-dos ![](one.jpg). They’re in reverse order (unimportant
    to important), to make sure the sorting is working.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的待办事项样本列表 ![待办事项](one.jpg)。它们是按逆序排列的（不重要到重要），以确保排序工作正常。
- en: '![](f0119-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](f0119-01.jpg)'
- en: The to-dos should be in order from important to unimportant ![](two.jpg). You
    also display the important statuses in capitals, so they stand out more.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项应该按重要到不重要的顺序排列 ![待办事项](two.jpg)。你还应该用大写字母显示重要状态，这样它们会更突出。
- en: This covers what you’re expecting. How do you get there? In practice, you’ll
    still be entering them as text strings, so how about if you put all the important
    fields first, all the ones marked “unimportant” at the bottom, and everything
    else in between?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了你的预期。你是如何做到这一点的？在实践中，你仍然会以文本字符串的形式输入它们，那么你为什么不把所有重要的字段放在前面，所有标记为“不重要”的字段放在底部，其余的放在中间呢？
- en: The standard way you’d do that would be with three *for* loops one after the
    other, each for a separate case—but I’d like to show you a faster way, which is
    also clearer once you get used to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会使用三个连续的 *for* 循环来做这件事，每个循环对应一个单独的情况——但我想向你展示一种更快的方法，一旦你习惯了，这种方法也更清晰。
- en: List comprehensions
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表推导式
- en: 'List comprehensions are a powerful built-in Python tool for making sense of
    lists of things. They’re a general solution to a common programming problem: handling
    groups of items. Perhaps you want to get the total of every item in a list, or
    filter out the ones that aren’t important, or only include the ones that have
    been open for too long. List comprehensions will let you do all these things.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式是Python中一个强大的内置工具，用于理解事物列表。它们是解决常见编程问题的通用解决方案：处理项目组。也许你想要获取列表中每个项目的总和，或者过滤掉那些不重要的，或者只包括那些开放时间过长的。列表推导式将让你做到所有这些。
- en: 'What you’re trying to ask for when you want to display important todos is something
    like this: “Python, please give me every to-do in the to-do list that is marked
    as ‘Important.’”'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想显示重要待办事项时，你试图请求的是类似以下这样的内容：“Python，请给我待办事项列表中标记为‘重要’的每个待办事项。”
- en: You can use a list comprehension to get exactly that and more. The following
    listing gives you a look at some common types of list comprehension and a feel
    for what they can do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表推导式来获取更多内容。以下列表展示了常见的列表推导式类型，以及它们能做什么的感觉。
- en: Listing 4.11\. Lots of things you can do with list comprehensions
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 列表推导式可以做的许多事情
- en: '![](04list11_alt.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![04list11_alt.jpg]'
- en: Here’s a list comprehension that gives you what you’re after ![](one.jpg). Python
    will go through each to-do in your list and collect the ones that match your *if*
    statement (that is, have a level of “important”). You add a *.lower()* call so
    the level will get converted to lowercase; important, Important, and IMPORTANT
    will all match.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个列表推导式，它给你你想要的东西 ![one.jpg]。Python将遍历你的列表中的每个待办事项，并收集与你的 *if* 语句匹配的待办事项（即级别为“重要”）。你添加了一个
    *.lower()* 调用，以便将级别转换为小写；important、Important和IMPORTANT都将匹配。
- en: That’s not all list comprehensions can do. You can also apply functions to each
    member of the final result to get a different list ![](two.jpg). Here, you’re
    writing a function to capitalize the level and then calling it on each to-do that’s
    marked as “important”.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式能做的不仅仅是这些。你还可以将函数应用于最终结果中的每个成员，以获得不同的列表 ![two.jpg]。在这里，你正在编写一个函数来将级别大写，然后对标记为“重要”的每个待办事项调用它。
- en: If you have a list of numbers, you can perform other operations on them as well
    ![](three.jpg). If they’re an object, you can call any method of that object,
    and so on. Anything you can do to the original value you can do within a list
    comprehension.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一系列数字，你还可以对它们执行其他操作 ![three.jpg]。如果它们是对象，你可以调用该对象的所有方法，依此类推。你可以在列表推导式中对原始值执行的所有操作都可以在列表推导式中执行。
- en: '![](f0120-01.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![f0120-01.jpg]'
- en: Finally, you have a list comprehension that uses two lists of numbers to generate
    a list of coordinates ![](four.jpg).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你有一个使用两个数字列表生成坐标列表的列表推导式 ![four.jpg]。
- en: Given all that, your final code listing could look something like the following.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，你的最终代码列表可能看起来像以下这样。
- en: Listing 4.12\. Code to sort your list of to-dos
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 对待办事项列表进行排序的代码
- en: '![](04list12_alt.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![04list12_alt.jpg]'
- en: 'Here are three list comprehensions ![](one.jpg), each for a separate level
    of to-do: “Important”, “unimportant”, and “everything else.” You capitalize the
    important ones to make them stand out a bit more.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三组列表推导式 ![one.jpg]，分别对应待办事项的三个不同级别：“重要”、“不重要”和“其他所有事项。”你将重要的那些大写，以便使它们更加突出。
- en: Once you have the to-do lists separated, you can join them back up by using
    a *+* ![](two.jpg).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将待办事项列表分开，你可以使用 *+* 来将它们重新连接 ![two.jpg]。
- en: If you want to see what the output looks like when running your tests, you can
    print the output here, right before it’s sent back. Your program will print exactly
    what the function returns, so you’ll see what the end user will see ![](three.jpg).
    Alternatively, you can put the print statements in your tests. If you’re having
    trouble with a failing test, printing out some of the variables you’re working
    with can save a lot of time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看运行测试时的输出结果，你可以在发送回之前在这里打印输出。你的程序将打印出函数返回的确切内容，因此你会看到最终用户会看到的内容 ![three.jpg]。或者，你也可以在你的测试中放置打印语句。如果你在失败的测试中遇到麻烦，打印出你正在处理的某些变量可以节省大量时间。
- en: Finally, if you run your tests again, you’ll notice that one of your earlier
    tests, *test_show_todos*, is now failing. In this case it’s nothing to worry about—you
    wrote that test before you’d really thought about how the program should look.
    Just change the “Important” in the test to “IMPORTANT”, and the test should pass.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你再次运行测试时，你会注意到你之前的一个测试，*test_show_todos*，现在失败了。在这种情况下，你不必担心——你在真正考虑程序应该如何看起来之前就写了这个测试。只需将测试中的“Important”改为“IMPORTANT”，测试就应该通过了。
- en: Now, you can sort to-dos into a specific order by using some list comprehensions,
    a powerful tool that’s easy to understand. Often, you’ll find you can replace
    complicated *for* loops with a simple function and a list comprehension.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过使用一些列表推导式，一个易于理解的有力工具，将待办事项排序到特定的顺序。通常，你会发现你可以用一个简单的函数和一个列表推导式来替换复杂的
    *for* 循环。
- en: Oops, a bug!
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哎呀，一个错误！
- en: If you look at the output in [listing 4.13](#ch04list13), you’ll notice the
    columns don’t quite display properly. The *show_todos* test looks ok, but the
    second one has all its fields squashed together—where an item is too long, it’s
    pushing the other columns out.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 [列表 4.13](#ch04list13) 中的输出，你会注意到列并没有完全正确显示。*show_todos* 测试看起来没问题，但第二个测试的所有字段都挤在一起——当一个条目太长时，它会将其他列推出去。
- en: Listing 4.13\. Output from your tests
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 测试的输出
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That doesn’t look nice. Isn’t unit testing supposed to make sure code is bug-free?
    Unfortunately, not entirely. You can test for things you’ve thought of, but if
    there’s something you haven’t considered, then you might still have bugs in your
    program. If you’re using unit testing and you notice a bug in your program like
    this, the solution is relatively easy: write a test that covers the behavior you
    *do* expect, make sure it fails, and then fix your program.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不好。单元测试不是应该确保代码没有错误吗？不幸的是，并不完全是这样。你可以测试你所想到的事情，但如果还有你没有考虑到的事情，那么你的程序可能仍然存在错误。如果你在使用单元测试并且注意到程序中存在这样的错误，解决方案相对简单：写一个测试来覆盖你
    *确实* 预期的行为，确保它失败，然后修复你的程序。
- en: It’s also possible you might have made a mistake in one of your tests. Again,
    unit testing is a useful tool, but not a complete solution. It’s still possible
    to test the wrong thing, or to have bugs in your unit tests. In practice, that’s
    a lot less likely than having errors in your program because the unit tests are
    easier to follow.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能你在某个测试中犯了一个错误。同样，单元测试是一个有用的工具，但不是完整的解决方案。仍然有可能测试错误的事情，或者单元测试中存在错误。在实践中，这比程序中存在错误的可能性要小得多，因为单元测试更容易跟踪。
- en: 'The question still remains, though: what do you want the program to do when
    a line is too long? If you don’t have a clear answer for that, then it’s hard
    to write a test! You could trim the string down to a fixed width if it was too
    long—but you’d like all the information to still be visible. A better way to do
    it would be to wrap each to-do.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，问题仍然存在：当一行太长时，你希望程序做什么？如果你对这个问题没有明确的答案，那么编写测试就很难了！如果字符串太长，你可以将其截断到固定宽度——但你希望所有信息仍然可见。更好的方法是折行每个待办事项。
- en: Listing 4.14\. A better way to display your to-dos
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 更好地显示你的待办事项
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From a visual point of view, that looks a lot better. But how on earth are
    you going to program it? The short answer is ... exactly the way you’ve been programming
    it so far: write a test first! I came up with *test_todo_wrap_long_lines*, which
    you can see in the next listing.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉角度来看，这看起来要好得多。但你怎么能编写这样的程序呢？简短的回答是...完全是你迄今为止一直在使用的方式：先写一个测试！我想出了 *test_todo_wrap_long_lines*，你可以在下一列表中看到。
- en: Listing 4.15\. Testing that your to-dos wrap lines
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15\. 测试你的待办事项是否换行
- en: '![](04list15_alt.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![04list15_alt.jpg](04list15_alt.jpg)'
- en: First, you set up a to-do with long lines that should be wrapped ![](one.jpg).
    In this example, I’ve made it look as close as I can to what a real to-do might
    look like to make sure wrapping works when you have to wrap over several lines,
    as well as only one. Notice that I’ve broken up the description so the lines are
    less than 24 characters long, which is the width of the description column. That
    helps when you’re writing the test, because you can see what you need to check
    for.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你设置了一个带有长行的待办事项，这些行应该被换行 ![one.jpg](one.jpg)。在这个例子中，我尽量让它看起来像真实的待办事项，以确保在需要跨多行换行以及只有一行时，换行都能正常工作。注意，我已经将描述拆分，使得行长小于24个字符，这是描述列的宽度。这有助于你在编写测试时看到你需要检查的内容。
- en: Then you test that the correct parts of the lines appear when the to-do is viewed
    ![](two.jpg). The test for the description goes for several lines, but this way
    you’re sure the program is wrapping properly for larger descriptions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你测试当查看待办事项时，正确的行是否出现！[](two.jpg)。对描述的测试会跨越几行，但这样你就能确保程序对较长的描述进行了适当的包装。
- en: Well, the test was easy; but I suspect that writing the code might be a bit
    harder. Fortunately, you’ve been testing thoroughly so far, so if you make a mistake,
    your tests should catch you.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，测试很简单；但我怀疑编写代码可能会有些困难。幸运的是，你到目前为止一直在彻底测试，所以如果你犯了错误，你的测试应该会捕捉到。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: What would you do if the code was too hard to write? In that case, the answer
    is usually that you’re trying to do too much at once, and you need to break the
    problem into smaller, easier parts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码太难编写，你会怎么办？在这种情况下，通常的答案是你在一次尝试做太多事情，你需要将问题分解成更小、更简单的部分。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The problem is that you’re wrapping the lines, but within other lines, so you
    can’t rely on Python’s built-in printing mechanisms. Python does have a *textwrap*
    module available, which doesn’t quite do what we’d like, but it’s a start. The
    overall plan would then be to write a function to generate the lines for each
    to-do. Within that, you can split each section of the to-do (the title, description,
    and so on) into lines using the *textwrap* module, and then somehow knit them
    together into the final output. Let’s try that. The following listing features
    the new function, *show_todo*, and the changes you’ll need to make to *show_todos.*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你正在包装行，但它们在其他行内部，所以你不能依赖Python的内置打印机制。Python确实有一个*textwrap*模块可用，它并不完全符合我们的期望，但这是一个开始。整体计划将是编写一个函数来生成每个待办事项的行。在这个函数内部，你可以使用*textwrap*模块将待办事项的每个部分（标题、描述等）拆分成行，然后以某种方式将它们编织成最终的输出。让我们试试。下面的列表展示了新的函数*show_todo*和你需要对*show_todos*进行的更改。
- en: Listing 4.16\. A function to show a to-do
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.16\. 显示待办事项的函数
- en: '![](ch04list16-0.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list16-0.jpg)'
- en: '![](ch04list16-1.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list16-1.jpg)'
- en: First, you use the *textwrap* module’s *wrap()* function to wrap the title and
    description to the right number of characters ![](one.jpg). You’ll also need *import
    textwrap*at the top of your script.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用*textwrap*模块的*wrap()*函数将标题和描述包装到正确的字符数！[](one.jpg)。你还需要在脚本顶部添加*import
    textwrap*。
- en: You start by building the first line with the index and level, which you assume
    don’t wrap, plus the first wrapped line of the title and description ![](two.jpg).
    You’re using the *+=* operator, which is shorthand for *output = output + ...*.
    (You’re also adding two spaces between each column, to make it easier to read.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先使用索引和级别构建第一行，假设它们不会包装，再加上标题和描述的第一条包装行！[](two.jpg)。你使用的是*+=*运算符，它是*output
    = output + ...*的简写。（你还在每列之间添加两个空格，以便更容易阅读。）
- en: If there are any lines left in your title or description, you print them here
    and put in placeholders for the index and importance ![](three.jpg). You’re using
    a slightly different version of range, where you specify the starting index as
    well as the ending one. If there’s only one line, *max_len* will be 1 as well,
    *enumerate* will be empty, and no extra lines will be printed. The other catch
    is that before you print out each line in the title and description, you need
    to make sure you still have something to print; otherwise, Python will crash with
    a “list index out of range” error. You use the multiplier operation on a single
    blank space so it’s obvious how long the strings are.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标题或描述中还有任何行，你在这里打印它们，并为索引和重要性输入占位符！[](three.jpg)。你使用的是稍微不同的range版本，其中你指定了起始索引和结束索引。如果只有一行，*max_len*也将是1，*enumerate*将为空，并且不会打印额外的行。另一个需要注意的问题是，在打印标题和描述中的每一行之前，你需要确保你还有东西可以打印；否则，Python会因“list
    index out of range”错误而崩溃。你使用单个空格的乘法运算，这样就可以清楚地看到字符串的长度。
- en: Although it isn’t strictly necessary, you break the sorting of to-dos out into
    its own function ![](four.jpg). You can do this because you have unit tests to
    catch any breakages, and it makes the program nicer to look at.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是严格必要的，但你将待办事项的排序分离到自己的函数中！[](four.jpg)。你可以这样做，因为你已经有了单元测试来捕获任何损坏，并且这使得程序看起来更美观。
- en: The new version of *show_todos* calls on both *show_todo* and *sort_todos* and
    is much shorter and easier to follow ![](five.jpg). That tells you you’re moving
    in the right direction; if it were longer and more complicated, you’d be doing
    the wrong thing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的 *show_todos* 同时调用了 *show_todo* 和 *sort_todos*，它更短，更容易理解 ![更短更易理解](five.jpg)。这告诉你你正在朝着正确的方向前进；如果它更长更复杂，你就做错了。
- en: The last thing you’ll need to do is update the *test_todo_sort_order* test case
    so it references the new line numbers in the output. If you run your tests after
    that change, they should all pass, and you now have a much prettier view of your
    to-dos. Ta-da! Next feature!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是更新 *test_todo_sort_order* 测试用例，使其引用输出中的新行号。在那之后运行你的测试，它们都应该通过，你现在有了待办事项的更美观的视图。哇！下一个功能！
- en: Saving your work
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存你的工作
- en: The last essential thing you need to be able to do is save the to-do list to
    a file. Without that, the person using the program would have to reenter all their
    work. Well, they probably wouldn’t—they would instead find a program that could
    save their data. Because you’ll be using this program yourself, that’s not an
    option.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要能够做的最后一件事是将待办事项列表保存到文件中。没有这个功能，使用程序的人将不得不重新输入所有的工作。嗯，他们可能不会这么做——他们可能会找到一个可以保存他们数据的程序。因为你自己也会使用这个程序，所以这不是一个选择。
- en: To save your to-do list, you’ll be using a Python module called *pickle*, which
    is designed for writing Python objects to a file. There are some limitations on
    the sorts of objects you can pickle, but all the basic Python types such as strings,
    lists, and dictionaries are supported, so it’s ideal for your program. Using *pickle*
    has the advantage of being quick to implement and easy to test, but it won’t be
    editable in a plaintext editor. Writing your own functions to read and write a
    custom format is possible, but it’s harder to program and difficult to get completely
    right. Here you’ll take the easy option, but you can always write your own format
    at a later stage if you need it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存你的待办事项列表，你将使用一个名为 *pickle* 的 Python 模块，它被设计用于将 Python 对象写入文件。你可以序列化的对象类型有一些限制，但所有基本的
    Python 类型，如字符串、列表和字典都受支持，所以它非常适合你的程序。使用 *pickle* 的优点是快速实现和易于测试，但它在纯文本编辑器中不可编辑。编写你自己的函数来读取和写入自定义格式是可能的，但这更难编程，并且很难完全正确。在这里，你将选择简单的方法，但如果你需要，你总是可以在以后阶段编写你自己的格式。
- en: 'How do you test your saving function? The easiest option is to use what’s called
    a *round-trip*: create a to-do list and save it, and then reload it from the same
    file and compare it to the original. If it’s the same, then your test passes;
    but the downside is that you’re testing both the load and save functionality in
    one go. If your test doesn’t pass, then it’s hard to tell whether it’s the load
    function or the save function (or both) that is at fault. The way around that
    is to create a *known good* file from a successful save. But that implies you’ve
    already saved properly.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何测试你的保存功能？最简单的方法是使用所谓的 *往返测试*：创建一个待办事项列表并保存它，然后从同一文件重新加载它并与原始版本进行比较。如果它们相同，那么你的测试就通过了；但缺点是你在一次操作中同时测试了加载和保存功能。如果你的测试没有通过，那么很难判断是加载功能、保存功能（或两者）出了问题。解决这个问题的方法是创建一个
    *已知良好* 的文件，从一个成功的保存中生成。但这意味着你已经正确地保存过了。
- en: Let’s pick the first option and see how it goes. You’ll be using a built-in
    Python module in a pretty straightforward way, so you’re not likely to run into
    any major problems. The next listing is your round-trip test, *test_save_todo_list*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第一个选项，看看结果如何。你将以相当直接的方式使用内置的 Python 模块，所以你不太可能遇到任何大问题。下一个列表是你的往返测试，*test_save_todo_list*。
- en: '![](f0128-01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![截图](f0128-01.jpg)'
- en: Listing 4.17\. Testing that your application saves properly
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17\. 测试你的应用程序是否正确保存
- en: '![](04list17_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项列表截图](04list17_alt.jpg)'
- en: Here you’re creating your to-do list ![](one.jpg) exactly the same way you’ve
    been doing in previous tests. The only difference is that you’re keeping another
    copy so you can refer back to it once you’ve reloaded the to-do list. You also
    make sure you don’t have an existing to-do list; otherwise the tests would fail
    or overwrite someone’s to-do list.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在创建你的待办事项列表 ![创建待办事项列表](one.jpg) ，方式和你在之前的测试中做的一样。唯一的区别是，你保留了一份副本，这样你就可以在重新加载待办事项列表后参考它。你还要确保你没有现有的待办事项列表；否则测试会失败或覆盖某个人的待办事项列表。
- en: First, you run the save command ![](two.jpg). Although you can’t test the contents
    of the save file directly, you can test that the file has been created by using
    the *os.listdir()* function. *'.'* is shorthand for whatever the current directory
    is.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你运行保存命令 ![](two.jpg)。虽然你不能直接测试保存文件的内容，但你可以通过使用 *os.listdir()* 函数来测试文件是否已创建。*'.'*
    是当前目录的简写。
- en: Next, you clear the to-do list out and then call the *load_todo_list()* function
    to reload it ![](three.jpg). At the end, you’ll have two lists of dictionaries
    that should be exactly the same.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你清空待办事项列表，然后调用 *load_todo_list()* 函数来重新加载它 ![](three.jpg)。最后，你将有两个字典列表，它们应该完全相同。
- en: Run your tests, make sure the new one fails, and then you can add the following
    code to create your save file and reload it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试，确保新的测试失败，然后你可以添加以下代码来创建你的保存文件并重新加载它。
- en: '![](f0129-01.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](f0129-01.jpg)'
- en: Listing 4.18\. Loading and saving your to-dos
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18\. 加载和保存你的待办事项
- en: '![](04list18_alt.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](04list18_alt.jpg)'
- en: '*pickle* needs an open file to work with, so you first open your save file
    ![](one.jpg), which you’ve called *"todos.pickle"*, with a mode of *"w"*, which
    means open it and overwrite whatever’s already there.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*pickle* 需要一个打开的文件来工作，因此你首先以 *"w"* 模式打开你的保存文件 ![](one.jpg)，你将其命名为 *"todos.pickle"*，这意味着打开文件并覆盖其中已有的内容。'
- en: The pickle syntax is straightforward—just call the *pickle.dump()* function
    ![](two.jpg) with the object you want to pickle and the file where you want it
    to be pickled.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: pickle 语法很简单——只需调用 *pickle.dump()* 函数 ![](two.jpg)，并传入你想要序列化的对象以及你想要序列化到其中的文件。
- en: '![](f0129-02.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](f0129-02.jpg)'
- en: Next, you close the file ![](three.jpg). You don’t have to do this step, because
    Python will close the file once it leaves the *save_todo_list()* function, but
    it’s a good habit to get into and helps to keep things tidy.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你关闭文件 ![](three.jpg)。你不必执行此步骤，因为一旦离开 *save_todo_list()* 函数，Python 将自动关闭文件，但养成这个习惯是个好习惯，并且有助于保持事物整洁。
- en: Because you’re replacing your to-do list when you load it, you’ll need to declare
    it as a global variable ![](four.jpg). This means the changes you make to the
    *todos* variable will be visible outside your function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在加载时正在替换待办事项列表，所以你需要将其声明为全局变量 ![](four.jpg)。这意味着你对 *todos* 变量所做的更改将在函数外部可见。
- en: One thing you need to check before you do anything is that the file exists ![](five.jpg).
    If you try to open a non-existent file, then Python will raise an error and the
    program will crash.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始接受任何用户输入之前，你需要检查文件是否存在 ![](five.jpg)。如果你尝试打开一个不存在的文件，那么 Python 将引发错误，程序将崩溃。
- en: Once you’re ready to load from your save file, it should be opened in read mode
    ![](six.jpg). The *pickle.load()* method will then read the to-do list you previously
    saved. When you’re done, you close the save file. You don’t need to return the
    object, because it’s a global variable and you’ve already updated it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好从保存文件中加载数据时，应该以读取模式打开它 ![](six.jpg)。然后，*pickle.load()* 方法将读取你之前保存的任务列表。完成之后，你需要关闭保存文件。你不需要返回对象，因为它是全局变量，并且你已经更新了它。
- en: The only question that remains after you’ve added the load and save functions
    is where you call them. You could make the user call them explicitly, but they’d
    have to know the functions were there and remember to call them. An easier way
    is to call load automatically when the program starts, and then save when the
    program exits. You can easily add that by calling *load_todo_list()* and *save_todo_list()*
    at the start and end of the main loop, as in the listing that follows.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在你添加了加载和保存功能之后，唯一剩下的问题是你在哪里调用它们。你可以让用户显式地调用它们，但用户必须知道这些函数的存在并记得调用它们。一个更简单的方法是在程序开始时自动调用
    *load_todo_list()*，然后在程序退出时保存。你可以通过在主循环的开始和结束时调用 *load_todo_list()* 和 *save_todo_list()*
    来轻松实现这一点，如下面的列表所示。
- en: Listing 4.19\. Automatic loading and saving
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19\. 自动加载和保存
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before you start accepting any user input, you first look for a pre-existing
    save file, and, if it exists, you load the to-dos from that.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始接受任何用户输入之前，你首先查找现有的保存文件，如果存在，则从该文件中加载待办事项。
- en: 'Once the user issues a quit command, you break out of the loop and the program
    will automatically save its to-do list. If you want to be even more cautious,
    you can call *save_todo_list()* at the end of each function that might cause a
    change: *create_todo()*, *edit_todo()*, and *delete_todo()*.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户发出退出命令时，你将退出循环，程序将自动保存其待办事项列表。如果你想更加谨慎，你可以在每个可能引起变化的函数的末尾调用 *save_todo_list()*：*create_todo()*,
    *edit_todo()*, 和 *delete_todo()*。
- en: You can add, view, and save your to-do lists (that’s the C and R in CRUD for
    those of you who remember the first part of the chapter) and store all the to-dos
    entered to date, so all you have to do now to have completed all the absolutely
    essential features is to handle the editing and deleting of the existing to-dos.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加、查看和保存你的待办事项列表（对于那些记得章节第一部分 CRUD 中的 C 和 R 的你），并存储迄今为止输入的所有待办事项，因此你现在要完成所有绝对必要功能只需处理现有待办事项的编辑和删除。
- en: Editing and deleting
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑和删除
- en: For this particular application they’re not quite as essential, which is why
    we’ve left them until last, but it’d be pretty annoying to have to do without
    deletion or editing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的应用，它们并不是那么必要，这就是为什么我们将其留到了最后，但如果没有删除或编辑功能，将会非常令人烦恼。
- en: A quick fix
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快速修复
- en: First, there’s one problem which you should deal with before you start. When
    you sorted the to-dos earlier, you didn’t update the stored list, and sorted your
    list every time you viewed it. When the user wants to tell you which to-do they
    want to edit or delete—say, with the index number—you’ll have to rebuild the list
    again to know which one they mean. It’d be much easier to have the to-do list
    sorted already. Let’s do that now. It will mean calling the *sort_todos* function
    every time a to-do is added to the to-do list. The user might’ve changed the importance
    of a to-do when editing it, so you’ll need to call it then, too, but you won’t
    need to call it for deletion because it will already be in order then.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个问题你应该在开始之前解决。当你之前对待办事项进行排序时，你没有更新存储的列表，每次查看时都会重新排序你的列表。当用户想要告诉你他们想要编辑或删除哪个待办事项——比如说，使用索引号——你将不得不再次构建列表以知道他们指的是哪一个。如果待办事项列表已经排序，将会容易得多。让我们现在就做这件事。这意味着每次添加待办事项到待办事项列表时都要调用
    *sort_todos* 函数。用户在编辑待办事项时可能会更改其重要性，所以你也需要在那时调用它，但不需要在删除时调用，因为那时它已经是有序的。
- en: '![](f0131-01.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![f0131-01.jpg](f0131-01.jpg)'
- en: As you’ve done so far, start by writing a unit test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如你迄今为止所做的那样，先编写一个单元测试。
- en: Listing 4.20\. Adding a to-do sorter
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.20\. 添加待办事项排序器
- en: '![](04list20_alt.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![04list20_alt.jpg](04list20_alt.jpg)'
- en: This should be pretty familiar by now. For this test, you’re only setting up
    two to-dos, in the reverse order ![](one.jpg).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该很熟悉了。对于这次测试，你只需设置两个待办事项，顺序相反 ![one.jpg](one.jpg)。
- en: '![](two.jpg) is where the action takes place. You create an important to-do.
    With the code as it currently stands, this will only append the important to-do
    at the bottom.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![two.jpg](two.jpg) 是动作发生的地方。你创建一个重要的待办事项。按照目前的代码，这将只将重要的待办事项追加到底部。'
- en: '![](f0132-01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![f0132-01.jpg](f0132-01.jpg)'
- en: Now you check that all the to-dos are in the right order ![](three.jpg). Important
    ones come first, unimportant at the bottom, and everything else in the middle.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查所有待办事项是否按正确顺序排列 ![three.jpg](three.jpg)。重要的待办事项排在前面，不重要的排在底部，其余的排在中间。
- en: Run your tests now, and the newest one should fail. Time to write some code!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的测试，最新的一个应该会失败。是时候编写一些代码了！
- en: Listing 4.21\. New sort_todos
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.21\. 新的 sort_todos
- en: '![](04list21_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![04list21_alt.jpg](04list21_alt.jpg)'
- en: Ideally, you’d like to be able to call *sort_todos()* from anywhere in the program,
    but that’s a bit hard in its current state. The easiest way forward is to make
    *todos* a global variable ![](one.jpg). Note that once you’ve done this, you don’t
    have to return *todos* from *sort_todos()*. Now you can call it from any function
    you want to.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你希望能够在程序的任何地方调用 *sort_todos()*，但就目前的状态而言，这有点困难。前进的最简单方法是使 *todos* 成为全局变量
    ![one.jpg](one.jpg)。请注意，一旦你这样做，你就不需要从 *sort_todos()* 中返回 *todos*。现在你可以从任何你想要的地方调用它。
- en: Now that *sort_todos()* is easier to use, you can remove it from *show_todos()*
    and put it wherever the order of *todos* is likely to be changed ![](two.jpg).
    In the next section, you’ll also call it when changing to-dos in the to-do list.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 *sort_todos()* 更容易使用，你可以将其从 *show_todos()* 中移除，并将其放在 *todos* 顺序可能被更改的任何地方
    ![two.jpg](two.jpg)。在下一节中，你也会在更改待办事项列表时调用它。
- en: You’ll find that you have test failures once *show_todos()* doesn’t sort the
    to-dos any more, but they’re easy to fix. In *test_todo_sort_order()* and *test_show_todos()*,
    just call *todo.sort_todos()*once you’ve set up your list of to-dos, to make sure
    they’re in the right order and have the correct formatting.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，一旦 *show_todos()* 无法再对待办事项进行排序，你将遇到测试失败，但这些问题很容易解决。在 *test_todo_sort_order()*
    和 *test_show_todos()* 中，一旦你设置了待办事项列表，只需调用一次 *todo.sort_todos()*，以确保它们按正确的顺序排列并具有正确的格式。
- en: '![](f0134-01.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![f0134-01.jpg](f0134-01.jpg)'
- en: That should be enough to get you going for the next section. What you’ve done
    is to ensure that the to-do list is always sorted in the same order, whether that’s
    behind the scenes or when displayed on the screen. It’s a major change to the
    way the program stores its data, but because you have a suite of unit tests, you
    can be confident that making major changes like this won’t have broken anything
    in the program. Let’s press on and put the final pieces in place.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以让你开始下一部分了。你所做的是确保待办事项列表始终按相同的顺序排序，无论是幕后还是显示在屏幕上。这是对程序存储数据方式的重大改变，但由于你有一套单元测试，你可以有信心进行这样的重大更改不会破坏程序中的任何内容。让我们继续前进，把最后几块拼图放好。
- en: Deleting to-dos
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除待办事项
- en: Now you’re ready to starting deleting to-dos from your list. The code to do
    this is pretty straightforward, but because you’re starting on destructive functions
    that can potentially delete user data, you’ll step up the unit testing a notch.
    Up until now you’ve mainly been testing the “happy path,” by making sure the code
    works for normal usage. It’s equally important to make sure your program notices
    input or data which is wrong and generates an appropriate error message. Let’s
    take a look now at how you test that in the following listing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始从你的列表中删除待办事项了。执行此操作的代码相当直接，但由于你开始进行可能删除用户数据的破坏性函数，你需要提高单元测试的级别。到目前为止，你主要测试的是“快乐路径”，确保代码在正常使用中工作。同样重要的是要确保你的程序注意到错误或数据，并生成适当的错误消息。现在让我们看看如何在以下列表中测试这一点。
- en: Listing 4.22\. Testing deletion
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.22\. 测试删除
- en: '![](ch04list22-0.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![ch04list22-0.jpg](ch04list22-0.jpg)'
- en: '![](ch04list22-1.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![ch04list22-1.jpg](ch04list22-1.jpg)'
- en: '![](f0135-01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![f0135-01.jpg](f0135-01.jpg)'
- en: For the deletion test, you set up three to-dos and delete the middle one. This
    tests that you don’t delete the wrong to-do, as well as that the right one is
    deleted ![](one.jpg). You’re also checking that *delete_todos* gives back a reasonable
    message to tell you what it’s done.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除测试，你设置了三个待办事项，并删除了中间的一个。这测试了你不会删除错误的待办事项，以及正确的一个被删除了 ![one.jpg](one.jpg)。你还在检查
    *delete_todos* 是否返回一个合理的消息来告诉你它做了什么。
- en: One of the things you’ve been able to skip over so far is checking user input.
    For your deletion script, that’s no longer possible, because you might put in
    a wrong number or something that isn’t a number. Here, you check that all the
    possible types of bad input generate an error message and don’t delete any to-dos
    ![](three.jpg).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你能够跳过的一件事是检查用户输入。对于你的删除脚本，这不再可能，因为你可能会输入一个错误的数字或不是数字的东西。在这里，你检查所有可能的错误输入类型都会生成一个错误消息，并且不会删除任何待办事项
    ![three.jpg](three.jpg)。
- en: 'That covers all the potential things I can think of can go wrong, but it’s
    important to note that testing failures like this is an ongoing process. In other
    words, the failure tests aren’t final. Especially with more complex functions,
    there may be bad input or data which will cause errors you haven’t considered.
    When you find input like that, you should consider it a bug in your program. But
    the fix is easy: add either another unit test or an extra case to your failure
    test that will cover the failure, and then fix your code so the test passes.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我想到的所有可能出错的情况，但重要的是要注意，测试失败是一个持续的过程。换句话说，失败测试不是最终的。特别是对于更复杂的函数，可能有不良的输入或数据会导致你没有考虑到的错误。当你发现这样的输入时，你应该将其视为程序中的错误。但修复很简单：为覆盖失败添加另一个单元测试或额外的测试用例，然后修复你的代码以便测试通过。
- en: The following listing is the code I wrote to make the two deletion tests pass.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我编写的代码，以使两个删除测试通过。
- en: Listing 4.23\. Deleting to-dos
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.23\. 删除待办事项
- en: '[PRE17]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here’s where you do your checking to make sure the input you’re fed matches
    a to-do in your list. It has to be a number, so you first use the *.isdigit()*
    method to make sure of that. Then, you turn it into a number by using *int()*,
    and check to see if it corresponds to an entry in the to-do list. If your input
    fails any of these checks, you do nothing except return an informative error message.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你进行检查的地方，以确保你提供的输入与你的待办事项列表中的待办事项匹配。它必须是一个数字，所以你首先使用 *.isdigit()* 方法来确保这一点。然后，你使用
    *int()* 将其转换为数字，并检查它是否对应于待办事项列表中的条目。如果你的输入未能通过这些检查中的任何一个，你将不采取任何行动，只是返回一个信息性错误消息。
- en: Now you can delete the to-do. Notice that you’re converting the number you’re
    given into a list index by subtracting one from it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以删除待办事项了。注意，你正在通过从它减去一来将你给出的数字转换为列表索引。
- en: The person using the program probably wants to know what you’ve done, so you
    tell them here ![](three.jpg). Whatever string you return will be printed on the
    screen as a result.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序的人可能想知道你做了什么，所以你在这里告诉他们 ![three.jpg](three.jpg)。你返回的任何字符串都将作为结果打印在屏幕上。
- en: '![](f0136-01.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![f0136-01.jpg](f0136-01.jpg)'
- en: Because you’ve added a new command, you’ll also need to add it to the *commands*
    dictionary too. The only argument it takes is *'which'*, which is the id of the
    to-do you want to delete.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因为添加了一个新命令，所以你还需要将它添加到 *commands* 字典中。它只接受一个参数 *'which'*)，这是你想要删除的待办事项的 ID。
- en: That’s all you need to do to make sure deleting to-dos works properly. All your
    tests should pass now, and you’re ready to move on to the next section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你确保删除待办事项正常工作的所有步骤。现在，所有测试都应该通过，你可以继续到下一节。
- en: Editing to-dos
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编辑待办事项
- en: Editing to-dos is also fairly straightforward. Because, in many ways, editing
    is a cross between deletion and editing, you can combine code from your previous
    unit tests and program code to create an *edit_todo()* function. There’s nothing
    in principle that we haven’t already covered in this chapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑待办事项也是相当直接的。因为从许多方面来看，编辑是删除和编辑之间的交叉，你可以将之前的单元测试和程序代码中的代码结合起来创建一个 *edit_todo()*
    函数。原则上，我们在这个章节中已经涵盖了所有内容。
- en: '![](f0137-01.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![f0137-01.jpg](f0137-01.jpg)'
- en: The only catch is that you’re running into a limitation of Python’s *raw_input()*
    function. Because you can’t pre-populate the text that’s entered into the function,
    you can’t make it as easy as you’d like to edit an existing entry. Unfortunately,
    you’ll need to work around it. The easiest way is to make a blank entry not overwrite
    an existing field; rather, for any field you want to edit, you’ll need to either
    reenter the data or cut and paste it from earlier on in the output. It’s annoying,
    but there’s not a lot you can do about it. In [chapter 8](kindle_split_016.html#ch08),
    you’ll extend your to-do list and give it a web interface with Django, so proper
    editing will have to wait until then.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的难点在于你遇到了 Python 的 *raw_input()* 函数的限制。因为你无法预先填充要输入到函数中的文本，所以你无法让它像你希望的那样轻松地编辑现有条目。不幸的是，你需要绕过这个限制。最简单的方法是创建一个空白条目不会覆盖现有字段；相反，对于任何你想要编辑的字段，你可能需要重新输入数据或者从输出中的较早部分剪切并粘贴它。这很烦人，但对此你无能为力。在
    [第 8 章](kindle_split_016.html#ch08) 中，你将扩展你的待办事项列表，并使用 Django 为它提供一个网络界面，因此适当的编辑将不得不等到那时。
- en: Let’s go ahead and write a test that covers the functionality you can add.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写一个测试，以覆盖你可以添加的功能。
- en: Listing 4.24\. Testing to-do editing
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.24\. 测试待办事项编辑
- en: '![](04list24_alt.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![04list24_alt.jpg](04list24_alt.jpg)'
- en: Here’s a function call that should edit a to-do ![](one.jpg). You’re simulating
    blank entries with blank strings in the input arguments.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应该编辑待办事项的函数调用 ![one.jpg](one.jpg)。你正在使用输入参数中的空字符串来模拟空白条目。
- en: Now you test that the to-do has the right fields ![](three.jpg). Those that
    were blank should be unchanged, and those that weren’t should be set to the correct
    values. You’re also checking that you still have only one to-do and that you get
    the right response.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你测试待办事项是否有正确的字段 ![three.jpg](three.jpg)。那些为空的字段应该保持不变，而那些不为空的应该设置为正确的值。你还检查你仍然只有一个待办事项，并且得到正确的响应。
- en: The other thing you need to test is that editing the level of a to-do will result
    in it being reordered. If a to-do suddenly becomes important, you want it to appear
    at the start of the list, rather than still being halfway down. The following
    listing shows how to test that.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要测试的是，编辑待办事项的优先级会导致它重新排序。如果一个待办事项突然变得重要，你希望它出现在列表的顶部，而不是仍然在中间。下面的列表显示了如何测试这一点。
- en: Listing 4.25\. Testing sort order after editing
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.25\. 编辑后测试排序顺序
- en: '![](04list25_alt.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![04list25_alt.jpg](04list25_alt.jpg)'
- en: First, you set up two Medium level to-dos ![](one.jpg). You edit the last to-do
    and set its level to Important but leave the other fields unchanged ![](two.jpg).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你设置两个中等优先级的待办事项 ![one.jpg](one.jpg)。你编辑最后一个待办事项，将其优先级设置为重要，但其他字段保持不变 ![two.jpg](two.jpg)。
- en: Now that the importance of the second to-do has been changed, it should appear
    first in the list rather than second ![](three.jpg).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第二个待办事项的重要性已经改变，它应该出现在列表的第一位而不是第二位 ![three.jpg](three.jpg)。
- en: That covers the behavior you’re expecting from editing a to-do. Let’s see how
    you go about implementing it in your program.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了你对编辑待办事项所期望的行为。让我们看看你如何在程序中实现它。
- en: Listing 4.26\. Code to edit a to-do
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.26\. 编辑待办事项的代码
- en: '![](04list26_alt.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![04list26_alt.jpg](04list26_alt.jpg)'
- en: You use exactly the same code you’re using in *delete_todo()* to check user
    input ![](one.jpg). You could probably pull it out and make it a function, but
    because you’re only using it in two places, whether you do so or not is a line
    call. If you add a third function that uses this code, then it should definitely
    be separated.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用与在`*delete_todo()*`中相同的代码来检查用户输入 ![one.jpg](https://example.org/one.jpg)。你可能将其提取出来并使其成为一个函数，但由于你只在使用两个地方，是否这样做是一个选择。如果你添加了第三个使用此代码的函数，那么它应该肯定被分离。
- en: Now you update the to-do ![](two.jpg). For any non-blank input, you override
    the field of the to-do with what’s been entered.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以更新待办事项 ![two.jpg](https://example.org/two.jpg)。对于任何非空输入，你将覆盖待办事项的字段，使用已输入的内容。
- en: The final step is to sort the to-dos (because the level might have changed)
    and return a message to let the user know what’s happened ![](three.jpg). Don’t
    forget to add the *edit_todo()* function to the *commands* dictionary with the
    arguments it needs.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是对待办事项进行排序（因为级别可能已经改变）并返回一条消息，告知用户发生了什么 ![three.jpg](https://example.org/three.jpg)。别忘了将`*edit_todo()*`函数添加到`*commands*`字典中，并带上它需要的参数。
- en: You’re done! All the essential features you set out at the start of the chapter
    have been completed, and you have a usable to-do list program.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了！在章节开始时设定的所有基本功能都已实现，你现在拥有了一个可用的待办事项列表程序。
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The definition of “essential” will vary from person to person, but getting the
    core of your application in place will definitely help put the finishing touches
    on the rest of the essential parts.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: “基本”的定义因人而异，但确保你的应用程序的核心功能到位，无疑将有助于完善其他基本部分的细节。
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Better yet, you have a comprehensive test suite that covers all the major functionality
    of the application, so if you make any changes further down the line, you can
    easily check to make sure the program still works.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你有一个涵盖应用程序所有主要功能的全面测试套件，所以如果你在以后进行任何更改，你可以轻松地检查以确保程序仍然正常工作。
- en: Where to from here?
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来该做什么？
- en: Like all the programs in this book, the to-do list program is now yours, and
    you can extend and enhance it to suit your own needs. Although it’s usable, there
    are some things that could dramatically improve it, and adding them would be a
    useful exercise. Here are some ideas for features you could add.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中的所有程序一样，待办事项列表程序现在属于你，你可以根据自身需求对其进行扩展和增强。尽管它可用，但还有一些事情可以显著改进它，添加这些功能将是一个有用的练习。以下是一些你可以添加的功能的想法。
- en: A help command
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 帮助命令
- en: If you’re getting confused about what each of the commands does, a help command
    would probably make things clearer. To make it even easier, you might want to
    bind it to multiple commands such as *?* and *help*, and possibly add it to the
    error message given if the program doesn’t understand the command given.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于每个命令的作用感到困惑，一个帮助命令可能会使事情更清晰。为了使其更加方便，你可能想要将其绑定到多个命令，如`*?*`和`*help*`，并且如果程序不理解给出的命令，还可以将其添加到错误信息中。
- en: Undo
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 撤销
- en: When deleting or editing to-do items, there’s no way out if you make a mistake.
    You’re only human, and it makes sense to try to allow for errors as much as possible,
    especially when deleting to-do items. When you’ve deleted one, there’s no way
    to get it back.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除或编辑待办事项时，如果你犯了一个错误，就没有办法退出。你只是个人，尽量允许错误发生是有意义的，尤其是在删除待办事项时。一旦你删除了一个，就没有办法恢复它。
- en: One way to get around this would be to mark deleted to-dos instead of removing
    them from the list, and not display them under normal circumstances. If necessary,
    you could use another command to display the to-dos that were deleted (perhaps
    *showdeleted*?) and restore them (*restore*).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是在列表中标记已删除的待办事项而不是将其从列表中删除，并且在正常情况下不显示它们。如果需要，你可以使用另一个命令来显示已删除的待办事项（可能如`*showdeleted*`？）并恢复它们（`*restore*`）。
- en: Different interface
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不同的界面
- en: You might find the fact that this interface requires you to click prompt, then
    click response, then prompt, then response, and so on, to be a bit annoying. The
    interface was designed to be as easy to program as possible, but that doesn’t
    mean it’s as easy to use as possible. One alternative is to allow arguments after
    commands the user types in. For example, instead of typing *delete <enter> 3 <enter>*,
    you could instead type *delete 3 <enter>* and have the program do the same thing.
    How essential this is will depend on whether you prefer the existing interface
    or not, but if you decide to add this type of interface, the *shlex* module will
    be extremely useful.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这个界面要求你先点击提示，然后点击响应，然后提示，然后响应，如此循环，有点让人烦恼。界面设计得尽可能容易编程，但这并不意味着它尽可能容易使用。一个替代方案是允许用户在输入命令后添加参数。例如，你不必输入
    *delete <enter> 3 <enter>*，而是可以输入 *delete 3 <enter>*，程序会完成相同的事情。这个功能是否必要取决于你是否喜欢现有的界面，但如果你决定添加这种类型的界面，*shlex*
    模块将非常有用。
- en: Time management and estimation
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时间管理和估计
- en: Another useful feature would be to record an estimate of how long you think
    a task will take to complete and then, later, mark items as done and record the
    time you spent on them. At the end, you could generate a report showing where
    you’ve spent your time, and discover how accurate your initial estimates were.
    Being able to estimate the time it will take to complete a task can be a useful
    skill, but it improves only if you practice and get feedback on how accurate your
    estimates were.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是记录你认为完成任务所需的时间估计，然后稍后标记项目为完成，并记录你在它们上的时间。最后，你可以生成一个报告，显示你花费了时间的地方，并发现你的初始估计有多准确。能够估计完成任务所需的时间可以是一项有用的技能，但只有通过练习并获得对你估计准确性的反馈，它才会得到改善。
- en: Study one of the unit-testing frameworks
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 学习其中一个单元测试框架
- en: Unit testing in itself isn’t particularly difficult, which is why you developed
    your own method in this chapter. But there are a number of unit testing modules
    you can use, and using them offers two key advantages. First, they can help you
    organize your tests into test suites and classes and run them all automatically
    from multiple files, as well as run setup and tear-down code before and after
    each test. Second, they allow you to test a lot more than you can with only simple
    assert statements, and they’ll give you more detailed information when things
    go wrong. The three unit-testing modules you’ll initially want to look at are
    *unittest* and *doctest*, both included with Python, and *py.test*, which is a
    lighter-weight version of *unittest*, available from [http://pytest.org/](http://pytest.org/).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试本身并不特别困难，这就是为什么你在本章中开发了你自己方法的原因。但有许多单元测试模块你可以使用，使用它们提供了两个主要优势。首先，它们可以帮助你将测试组织成测试套件和类，并从多个文件中自动运行所有测试，以及在每次测试前后运行设置和清理代码。其次，它们允许你测试比仅使用简单的断言语句更多的内容，并在出错时提供更详细的信息。你最初想要查看的三个单元测试模块是
    *unittest* 和 *doctest*，它们都包含在 Python 中，以及 *py.test*，这是一个比 *unittest* 更轻量级的版本，可以从
    [http://pytest.org/](http://pytest.org/) 获取。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about unit testing, saw firsthand how to use it
    to write programs, and developed a large suite of unit tests so you could extend
    your application without worrying about how you might break it if you change something.
    You also learned about some aspects of the program (mainly user input) that were
    harder to unit test, and you discovered how to work around that by keeping the
    untested sections of code as small and simple as possible.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了单元测试，亲自看到了如何使用它来编写程序，并开发了一套大量的单元测试，这样你就可以在扩展应用程序时不必担心如何避免在更改某些内容时破坏它。你还了解了一些程序方面（主要是用户输入）的测试比较困难，并发现了如何通过尽可能保持未测试代码部分的小巧和简单来解决这个问题。
- en: You also learned that Python has first-class functions that can be assigned
    to variables in the same way as more basic types, such as integers and strings,
    and that one good way to make use of functions is by assigning them as values
    in a dictionary. You’ll learn more about first-class functions in [chapter 7](kindle_split_015.html#ch07).
    You used two more Python libraries, *pickle* and *textwrap*, and also discovered
    how you could filter the to-do lists using list comprehensions, a simple but powerful
    way of filtering and processing lists.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解到 Python 有第一类函数，这些函数可以被分配给变量，就像整数和字符串等更基本的数据类型一样，而且利用函数的一个好方法是将它们作为字典中的值。你将在第
    7 章[学习更多关于第一类函数的内容](kindle_split_015.html#ch07)。你还使用了两个 Python 库，*pickle* 和 *textwrap*，并且还发现了如何使用列表推导来过滤待办事项列表，这是一种简单但强大的过滤和处理列表的方法。
- en: The final thing we covered was how to work around problems that arise in development.
    Sometimes, as with editing to-do items, there’s not much that can be done beyond
    finding a reasonable workaround. In other cases—for example, when wrapping the
    text of to-dos—some patience and persistence (and a decent suite of tests) can
    pay off.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后讨论的是如何在开发过程中解决出现的问题。有时候，比如编辑待办事项，除了找到一个合理的解决方案之外，没有太多可以做的事情。在其他情况下——例如，当包装待办事项的文本时——一些耐心和坚持（以及一套合理的测试）可能会带来回报。
