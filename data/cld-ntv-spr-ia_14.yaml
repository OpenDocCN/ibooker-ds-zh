- en: '11 Security: Authentication and SPA'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 安全：身份验证和 SPA
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the Spring Security fundamentals
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Spring Security 基础知识
- en: Managing user accounts with Keycloak
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Keycloak 管理用户账户
- en: Working with OpenID Connect, JWT, and Keycloak
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 OpenID Connect、JWT 和 Keycloak 一起工作
- en: Authenticating users with Spring Security and OpenID Connect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Security 和 OpenID Connect 验证用户
- en: Testing Spring Security and OpenID Connect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Spring Security 和 OpenID Connect
- en: Security is one of the most critical aspects of web applications and probably
    the one with the most catastrophic effects when done wrong. For educational purposes,
    I’m introducing this topic only now. In a real-world scenario, I recommend considering
    security from the beginning of each new project or feature and never letting it
    go until the application is retired.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是 Web 应用程序中最关键的因素之一，而且如果处理不当，可能产生最灾难性的影响。出于教育目的，我现在才介绍这个主题。在现实世界的场景中，我建议在每个新项目或特性的开始时就考虑安全性，并且直到应用程序退役都不要放弃。
- en: 'Access control systems allow users access to resources only when their identity
    has been proven and they have the required permissions. To accomplish that, we
    need to follow three pivotal steps: identification, authentication, and authorization.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制系统允许用户仅在证明其身份并拥有所需权限时访问资源。为了实现这一点，我们需要遵循三个关键步骤：识别、身份验证和授权。
- en: '*Identification* happens when a user (human or machine) claims an identity.
    In the physical world, that’s when I introduce myself by stating my name. In the
    digital world, I would do that by providing my username or email address.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*识别*发生在用户（人类或机器）声称一个身份的时候。在物理世界中，那是我通过说出我的名字来介绍自己的时候。在数字世界中，我会通过提供我的用户名或电子邮件地址来做这件事。'
- en: '*Authentication* is about verifying the user’s claimed identity through factors
    like a passport, a driver’s license, a password, a certificate, or a token. When
    multiple factors are used to verify the user’s identity, we talk about *multi-factor
    authentication*.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*身份验证*是通过护照、驾照、密码、证书或令牌等要素来验证用户声明的身份。当使用多个要素来验证用户身份时，我们谈论的是 *多因素身份验证*。'
- en: '*Authorization* always happens after authentication, and it checks what the
    user is allowed to do in a given context.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*授权*总是在身份验证之后发生，并检查用户在特定上下文中被允许做什么。'
- en: This chapter and the next one will cover implementing access control systems
    in cloud native applications. You’ll see how to add authentication to a system
    like Polar Bookshop and use a dedicated identity and access management solution
    like Keycloak. I’ll show you how to use Spring Security to secure applications
    and adopt standards like JWT, OAuth2, and OpenID Connect. In the process, you’ll
    also add an Angular frontend to the system and learn the best practices for security
    when a single-page application (SPA) is involved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章将涵盖在云原生应用程序中实现访问控制系统。您将了解如何向类似 Polar Bookshop 这样的系统添加身份验证，并使用像 Keycloak
    这样的专用身份和访问管理解决方案。我将向您展示如何使用 Spring Security 来保护应用程序并采用 JWT、OAuth2 和 OpenID Connect
    等标准。在这个过程中，您还将向系统中添加一个 Angular 前端，并学习涉及单页应用程序（SPA）时的安全最佳实践。
- en: Note The source code for the examples in this chapter is available in the Chapter11/11-begin
    and Chapter11/11-end folders, which contain the initial and final states of the
    project ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在 Chapter11/11-begin 和 Chapter11/11-end 文件夹中找到，这些文件夹包含项目的初始状态和最终状态
    ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))。
- en: 11.1 Understanding the Spring Security fundamentals
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 理解 Spring Security 基础知识
- en: Spring Security ([https://spring.io/projects/spring-security](https://spring.io/projects/spring-security))
    is the de facto standard for securing Spring applications, supporting imperative
    and reactive stacks. It provides authentication and authorization features as
    well as protection against the most common attacks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security ([https://spring.io/projects/spring-security](https://spring.io/projects/spring-security))
    是保护 Spring 应用程序的既定标准，支持命令式和响应式堆栈。它提供身份验证和授权功能，以及防止最常见的攻击。
- en: The framework provides its main functionality by relying on *filters*. Let’s
    consider a possible requirement for adding authentication to a Spring Boot application.
    Users should be able to authenticate with their username and password through
    a login form. When we configure Spring Security to enable such a feature, the
    framework adds a filter that intercepts any incoming HTTP request. If the user
    is already authenticated, it sends the request through to be processed by a given
    web handler, such as a @RestController class. If the user is not authenticated,
    it forwards the user to a login page and prompts for their username and password.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架通过依赖*过滤器*提供其主要功能。让我们考虑一个为Spring Boot应用程序添加身份验证的可能需求。用户应能够通过登录表单使用用户名和密码进行身份验证。当我们配置Spring
    Security以启用此功能时，框架会添加一个拦截任何传入HTTP请求的过滤器。如果用户已经通过验证，它将请求发送到给定的Web处理器，例如一个@RestController类。如果用户未通过验证，它将用户转发到登录页面并提示输入用户名和密码。
- en: Note In imperative Spring applications, a filter is implemented as a Servlet
    Filter class. In reactive applications, the WebFilter class is used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在命令式Spring应用程序中，过滤器实现为一个Servlet Filter类。在反应式应用程序中，使用WebFilter类。
- en: Most Spring Security features, when enabled, are handled via filters. The framework
    establishes a chain of filters that are executed according to a well-defined and
    sensible order. For instance, the filter that handles authentication runs before
    the one that checks for authorization because we can’t verify a user’s authority
    before knowing who it is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Spring Security功能在启用时都通过过滤器处理。框架建立了一个按良好定义和合理顺序执行的过滤器链。例如，处理身份验证的过滤器在检查授权的过滤器之前运行，因为我们不能在知道用户是谁之前验证用户的权限。
- en: Let’s start with a basic example to better understand how Spring Security works.
    We want to add authentication to the Polar Bookshop system. Since Edge Service
    is the entry point, it makes sense to handle cross-cutting concerns like security
    there. Users should be able to authenticate with a username and password via a
    login form.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本示例开始，以更好地理解Spring Security的工作原理。我们希望向Polar Bookshop系统添加身份验证。由于Edge Service是入口点，因此在那里处理像安全这样的横切关注点是有意义的。用户应能够通过登录表单使用用户名和密码进行身份验证。
- en: First, add a new dependency on Spring Security in the build.gradle file for
    the Edge Service project (edge-service). Remember to refresh or reimport the Gradle
    dependencies after the new addition.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Edge Service项目的build.gradle文件中添加一个新的Spring Security依赖项（edge-service）。请记住，在添加新依赖项后刷新或重新导入Gradle依赖项。
- en: Listing 11.1 Adding dependency for Spring Security in Edge Service
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 在Edge Service中添加Spring Security依赖项
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The central place for defining and configuring security policies in Spring Security
    is a SecurityWebFilterChain bean. That object tells the framework which filters
    should be enabled. You can build a SecurityWebFilterChain bean through the DSL
    provided by ServerHttpSecurity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中定义和配置安全策略的中心位置是一个SecurityWebFilterChain bean。该对象告诉框架哪些过滤器应该启用。您可以通过ServerHttpSecurity提供的DSL构建SecurityWebFilterChain
    bean。
- en: 'For now, we want to comply with the following requirements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们希望遵守以下要求：
- en: All endpoints exposed by Edge Service must require user authentication.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Edge Service公开的所有端点都必须需要用户身份验证。
- en: The authentication must happen via a login form page.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证必须通过登录表单页面进行。
- en: 'To collect all the configurations related to security, create a SecurityWebFilterChain
    bean in a new SecurityConfig class (com.polarbookshop.edgeservice.config package):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集所有与安全相关的配置，在新的SecurityConfig类（com.polarbookshop.edgeservice.config包）中创建一个SecurityWebFilterChain
    bean：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The SecurityWebFilterChain bean is used to define and configure security policies
    for the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用SecurityWebFilterChain bean定义和配置应用程序的安全策略。
- en: 'The ServerHttpSecurity object, autowired by Spring, provides a convenient DSL
    for configuring Spring Security and building a SecurityWebFilterChain bean. With
    authorizeExchange(), you can define access policies for any request (called an
    *exchange* in reactive Spring). In this case, we want all requests to require
    authentication (authenticated()):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由Spring自动注入的ServerHttpSecurity对象提供了一个方便的DSL（领域特定语言），用于配置Spring Security并构建SecurityWebFilterChain
    bean。使用authorizeExchange()，您可以定义任何请求（在反应式Spring中称为*exchange*）的访问策略。在这种情况下，我们希望所有请求都需要身份验证（authenticated()）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ All requests require authentication.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有请求都需要身份验证。
- en: 'Spring Security provides several authentication strategies, including HTTP
    Basic, login form, SAML, and OpenID Connect. For this example, we want to use
    the login form strategy, which we can enable via the formLogin() method exposed
    by the ServerHttpSecurity object. We’ll go with the default configuration (available
    via the Spring Security Customizer interface), which includes a login page, provided
    by the framework out of the box, and an automatic redirect to that page whenever
    a request is not authenticated:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了多种身份验证策略，包括HTTP基本身份验证、登录表单、SAML和OpenID Connect。对于这个示例，我们想使用登录表单策略，我们可以通过ServerHttpSecurity对象公开的formLogin()方法来启用它。我们将使用默认配置（通过Spring
    Security Customizer接口可用），该配置包括一个由框架提供的登录页面，并在请求未进行身份验证时自动重定向到该页面：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Enables user authentication via a login form
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过登录表单启用用户身份验证
- en: Next, annotate the SecurityConfig class with @EnableWebFluxSecurity to enable
    Spring Security WebFlux support. The final security configuration is shown in
    the following listing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用@EnableWebFluxSecurity注解SecurityConfig类以启用Spring Security WebFlux支持。最终的安全配置如下所示。
- en: Listing 11.2 Requiring authentication for all endpoints via a login form
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 通过登录表单要求所有端点进行身份验证
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ All requests require authentication.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有请求都需要身份验证。
- en: ❷ Enables user authentication via a login form
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过登录表单启用用户身份验证
- en: 'Let’s verify that it works correctly. First, start your Redis container, required
    by Edge Service. Open a Terminal window, navigate to the folder where you keep
    your Docker Compose file (polar-deployment/docker/docker-compose.yml), and run
    the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证它是否正确工作。首先，启动边缘服务所需的Redis容器。打开一个终端窗口，导航到您保存Docker Compose文件（polar-deployment/docker/docker-compose.yml）的文件夹，并运行以下命令：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then run the Edge Service application (./gradlew bootRun), open a browser window,
    and head to http://localhost:9000/books. You should be redirected to a login page
    served by Spring Security, where you can authenticate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行边缘服务应用程序（./gradlew bootRun），打开一个浏览器窗口，并转到http://localhost:9000/books。您应该被重定向到由Spring
    Security提供的登录页面，在那里您可以进行身份验证。
- en: 'Wait a minute! How can we authenticate without defining a user in the system?
    By default, Spring Security defines a user account in memory with the username
    user and a password randomly generated and printed out in the application logs.
    You should look for a log entry like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我们如何在系统中没有定义用户的情况下进行身份验证？默认情况下，Spring Security在内存中定义了一个用户账户，用户名为user，密码是随机生成的，并在应用程序日志中打印出来。您应该查找如下日志条目：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can authenticate with the predefined user account created by Spring Security.
    After successfully authenticating, you will be redirected to the /books endpoint.
    Since Catalog Service is down and Edge Service has a fallback method to return
    an empty list when querying books (implemented in chapter 9), you’ll see a blank
    page. That’s expected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Spring Security创建的预定义用户账户进行身份验证。身份验证成功后，您将被重定向到/books端点。由于目录服务不可用，并且边缘服务在查询书籍时有一个回退方法来返回空列表（在第9章中实现），您将看到一个空白页面。这是预期的。
- en: Note I recommend you open a new incognito browser window every time you test
    the application from now on. Since you’re going to try out different security
    scenarios, the incognito mode will prevent you from having issues related to browser
    caches and cookies from previous sessions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我建议您从现在开始每次测试应用程序时都打开一个新的无痕浏览器窗口。由于您将尝试不同的安全场景，无痕模式将防止您遇到与浏览器缓存和之前会话的cookie相关的问题。
- en: The crucial point of this test is that a user tried to access a protected endpoint
    exposed by Edge Service. The application redirected the user to a login page,
    showed a login form, and asked the user to provide a username and password. Then
    Edge Service validated the credentials against its internal user database (auto-generated
    in memory) and, on discovering they were valid, started an authenticated session
    with the browser. Since HTTP is a stateless protocol, the user session is kept
    alive through a cookie whose value is provided by the browser with each HTTP request
    (a *session cookie*). Internally, Edge Service maintains a mapping between the
    session identifier and user identifier, as shown in figure 11.1.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的关键点是用户尝试访问 Edge Service 提供的受保护端点。应用程序将用户重定向到登录页面，显示登录表单，并要求用户提供用户名和密码。然后
    Edge Service 验证凭证与其内部用户数据库（在启动时自动生成）的匹配，并在发现它们有效时，通过浏览器启动一个认证会话。由于 HTTP 是一种无状态协议，用户会话通过一个
    cookie 保持活跃，该 cookie 的值由浏览器在每次 HTTP 请求时提供（一个 *会话 cookie*）。内部，Edge Service 维护会话标识符和用户标识符之间的映射，如图
    11.1 所示。
- en: '![11-01](../Images/11-01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![11-01](../Images/11-01.png)'
- en: Figure 11.1 After the login step, the user session is kept alive through a session
    cookie.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 登录步骤之后，用户会话通过会话 cookie 保持活跃。
- en: 'When you are done testing the application, terminate the process with Ctrl-C.
    Then navigate to the folder where you keep your Docker Compose file (polar-deployment/docker/docker-compose.yml),
    and run the following command to stop the Redis container:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成应用程序的测试后，使用 Ctrl-C 终止进程。然后导航到您保存 Docker Compose 文件（polar-deployment/docker/docker-compose.yml）的文件夹，并运行以下命令来停止
    Redis 容器：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are a few problems with the previous approach when applied to a cloud
    native system. In the rest of the chapter, we’ll analyze those problems, identify
    viable solutions for cloud native applications, and use them on top of what we
    have just implemented.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当将之前的方法应用于云原生系统时，存在一些问题。在本章的剩余部分，我们将分析这些问题，确定适用于云原生应用的可行解决方案，并在我们刚刚实现的基础上使用它们。
- en: 11.2 Managing user accounts with Keycloak
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用 Keycloak 管理用户账户
- en: In the previous section, we added user authentication to Edge Service based
    on a login form. You tried logging in via a user account that was auto-generated
    in memory at startup time. That’s fine for experimenting with Spring Security
    the first time, but it’s not something you’ll want to do in production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们基于登录表单向 Edge Service 添加了用户认证。您尝试通过启动时在内存中自动生成的用户账户进行登录。这对于第一次尝试 Spring
    Security 来说是可以的，但在生产环境中您不会想要这样做。
- en: As a minimum requirement, we need persistent storage for user accounts and an
    option to register new users. There should be a particular focus on storing passwords
    using a robust encryption algorithm and preventing unauthorized access to the
    database. Given the criticality of such a feature, it makes sense to delegate
    it to a dedicated application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最低要求，我们需要为用户账户提供持久存储，并有一个注册新用户的选择。应特别关注使用强大的加密算法存储密码，并防止对数据库的未授权访问。鉴于这一功能的至关重要性，将其委托给一个专用应用程序是有意义的。
- en: Keycloak ([www.keycloak.org](http://www.keycloak.org)) is an open source identity
    and access management solution developed and maintained by the Red Hat community.
    It offers a broad set of features, including single sign-on (SSO), social login,
    user federation, multi-factor authentication, and centralized user management.
    Keycloak relies on standards like OAuth2, OpenID Connect, and SAML 2.0\. For now,
    we’ll use Keycloak to manage user accounts in Polar Bookshop. Later I’ll show
    you how to use its OpenID Connect and OAuth2 features.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak ([www.keycloak.org](http://www.keycloak.org)) 是由 Red Hat 社区开发和维护的开源身份和访问管理解决方案。它提供了一系列广泛的功能，包括单点登录（SSO）、社交登录、用户联合、多因素认证和集中式用户管理。Keycloak
    依赖于 OAuth2、OpenID Connect 和 SAML 2.0 等标准。目前，我们将使用 Keycloak 来管理 Polar Bookshop
    的用户账户。稍后我会向您展示如何使用其 OpenID Connect 和 OAuth2 功能。
- en: Note Spring Security provides all the necessary features to implement a user
    management service. If you’d like to learn more about this subject, you can refer
    to chapters 3 and 4 of *Spring Security in Action* by Laurențiu Spilcă (Manning,
    2020).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Spring Security 提供了实现用户管理服务所需的所有功能。如果您想了解更多关于这个主题的信息，可以参考 Laurențiu Spilcă
    所著的 *Spring Security in Action* 一书的第 3 章和第 4 章（Manning, 2020）。
- en: You can run Keycloak locally as a standalone Java application or a container.
    For production, there are a few solutions for running Keycloak on Kubernetes.
    Keycloak also needs a relational database for persistence. It comes with an embedded
    H2 database, but you’ll want to replace it with an external one in production.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本地作为独立的 Java 应用程序或容器运行 Keycloak。对于生产环境，有几种在 Kubernetes 上运行 Keycloak 的解决方案。Keycloak
    还需要一个关系型数据库来持久化。它自带嵌入式 H2 数据库，但在生产环境中，您希望将其替换为外部数据库。
- en: For Polar Bookshop, we’ll run Keycloak locally as a Docker container, relying
    on the embedded H2 database. In production we’ll use PostgreSQL. This might seem
    to contradict the environment parity principle, but since it’s a third-party application,
    it’s not your responsibility to test its interaction with a data source.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Polar Bookshop，我们将本地运行 Keycloak 作为 Docker 容器，依赖于嵌入式 H2 数据库。在生产环境中，我们将使用 PostgreSQL。这可能会似乎与环境一致性原则相矛盾，但既然它是一个第三方应用程序，测试其与数据源的交互不是您的责任。
- en: This section will guide you step-by-step through the Keycloak configuration
    for the Polar Bookshop use case. First, open your polar-deployment repository.
    Then define a new polar-keycloak container in docker/docker-compose.yml.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将逐步指导您完成 Polar Bookshop 用例的 Keycloak 配置。首先，打开您的 polar-deployment 仓库。然后在 docker/docker-compose.yml
    中定义一个新的 polar-keycloak 容器。
- en: Listing 11.3 Defining a Keycloak container in Docker Compose
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 在 Docker Compose 中定义 Keycloak 容器
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The section describing the Keycloak container
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 描述 Keycloak 容器的部分
- en: ❷ Starts Keycloak in development mode (using an embedded database)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以开发模式启动 Keycloak（使用嵌入式数据库）
- en: ❸ Defines admin credentials as environment variables
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将管理员凭据定义为环境变量
- en: Note Later I will provide you with a JSON file you can use to load the entire
    configuration when starting up the Keycloak container, so you won’t need to be
    concerned about the container’s persistence.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：稍后我将为您提供可以用于启动 Keycloak 容器时加载整个配置的 JSON 文件，这样您就不必担心容器的持久性。
- en: 'You can start a Keycloak container by opening a Terminal window, navigating
    to the folder where you keep the docker-compose.yml file, and running this command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开终端窗口，导航到保存 docker-compose.yml 文件的文件夹，并运行以下命令来启动 Keycloak 容器：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we can start managing user accounts, we need to define a security realm.
    We’ll do that next.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始管理用户账户之前，我们需要定义一个安全域。我们将在下一步进行定义。
- en: 11.2.1 Defining a security realm
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 定义安全域
- en: In Keycloak, any security aspect of an application or a system is defined in
    the context of a *realm*, a logical domain in which we apply specific security
    policies. By default, Keycloak comes preconfigured with a *Master* realm, but
    you’ll probably want to create a dedicated one for each product you build. Let’s
    create a new *PolarBookshop* realm to host any security-related aspects of the
    Polar Bookshop system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Keycloak 中，应用程序或系统的任何安全方面都是在 *域* 的上下文中定义的，这是一个我们应用特定安全策略的逻辑域。默认情况下，Keycloak
    预配置了一个 *Master* 域，但您可能希望为每个构建的产品创建一个专用的域。让我们创建一个新的 *PolarBookshop* 域来托管 Polar
    Bookshop 系统的任何安全相关方面。
- en: 'Make sure the Keycloak container you started earlier is still running. Then
    open a Terminal window, and enter a bash console inside the Keycloak container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您之前启动的 Keycloak 容器仍在运行。然后打开一个终端窗口，并在 Keycloak 容器内进入 bash 控制台：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip Keycloak might take several seconds to start up. If you try to access it
    right after starting the container, you might get an error because it’s not yet
    ready to accept connections. If that happens, wait a few seconds and try again.
    You can check the Keycloak logs with docker logs -f polar-keycloak. After the
    message “Running the server in development mode” is printed out, Keycloak is ready
    to be used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Keycloak 启动可能需要几秒钟。如果您在容器启动后立即尝试访问它，可能会收到错误，因为它尚未准备好接受连接。如果发生这种情况，请等待几秒钟再试。您可以使用
    docker logs -f polar-keycloak 检查 Keycloak 日志。当打印出“以开发模式运行服务器”的消息后，Keycloak 即可使用。
- en: 'We’ll configure Keycloak through its Admin CLI, but you can achieve the same
    result by using the GUI available at http://localhost:8080\. First, navigate to
    the folder where the Keycloak Admin CLI scripts are located:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 Keycloak 的 Admin CLI 配置 Keycloak，但您也可以通过使用位于 http://localhost:8080 的 GUI
    实现相同的结果。首先，导航到 Keycloak Admin CLI 脚本所在的文件夹：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Admin CLI is protected by the username and password we defined in Docker
    Compose for the Keycloak container. We’ll need to start an authenticated session
    before running any other commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Admin CLI 由我们在 Docker Compose 中为 Keycloak 容器定义的用户名和密码保护。在运行任何其他命令之前，我们需要启动一个认证会话：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Keycloak runs on port 8080 inside the container.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Keycloak在容器内运行在8080端口。
- en: ❷ The default realm configured in Keycloak
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 默认的Keycloak域配置
- en: ❸ The username we defined in Docker Compose
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在Docker Compose中定义的用户名
- en: ❹ The password we defined in Docker Compose
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在Docker Compose中定义的密码
- en: Tip You should keep the current Terminal window open until you’re done configuring
    Keycloak. If at any point the authenticated session expires, you can always start
    a new one by running the previous command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你应该在配置完Keycloak之前保持当前终端窗口打开。如果在任何时刻认证会话过期，你都可以通过运行之前的命令来启动一个新的会话。
- en: 'At this point, you can go ahead and create a new security realm where all the
    policies associated with Polar Bookshop will be stored:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以继续创建一个新的安全域，其中将存储与Polar Bookshop相关的所有策略：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 11.2.2 Managing users and roles
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 管理用户和角色
- en: 'We’ll need some users to test different authentication scenarios. As anticipated
    in chapter 2, Polar Bookshop has two types of users: customers and employees.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些用户来测试不同的身份验证场景。正如第2章所预料的，Polar Bookshop有两种类型的用户：客户和员工。
- en: '*Customers* can browse books and purchase them.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户*可以浏览书籍并购买它们。'
- en: '*Employees* can also add new books to the catalog, modify the existing ones,
    and delete them.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*员工*也可以向目录添加新书，修改现有书籍，并删除它们。'
- en: 'To manage the different permissions associated with each type of user, let’s
    create two roles: *customer* and *employee*. Later you’ll protect application
    endpoints based on those roles. It’s an authorization strategy called *role-based
    access control* (RBAC).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理与每种用户类型相关的不同权限，让我们创建两个角色：*客户*和*员工*。稍后你将根据这些角色保护应用程序端点。这是一种称为*基于角色的访问控制*（RBAC）的授权策略。
- en: 'First, create the two roles in the Polar Bookshop realm from the Keycloak Admin
    CLI console you have used so far:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从你迄今为止使用的Keycloak Admin CLI控制台创建两个角色：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then create two users. *Isabelle Dahl* will be both an employee and a customer
    of the bookshop (username: isabelle). You can create an account for her as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建两个用户。*伊莎贝尔·达尔*（用户名：isabelle）将是书店的员工和客户。你可以按照以下方式为她创建一个账户：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The username for the new user. It will be used for logging in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新用户的用户名。它将用于登录。
- en: ❷ The user should be active.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用户应该是活跃的。
- en: ❸ Isabelle is both an employee and a customer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 伊莎贝尔既是员工也是客户。
- en: 'Then do the same for *Bjorn Vinterberg* (username: bjorn), a customer of the
    bookshop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为*Bjorn Vinterberg*（用户名：bjorn），书店的客户执行相同的操作：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The username for the new user. It will be used for logging in.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新用户的用户名。它将用于登录。
- en: ❷ The user should be active.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用户应该是活跃的。
- en: ❸ Bjorn is a customer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Bjorn是客户。
- en: 'In a real scenario, users would choose a password themselves and preferably
    enable two-factor authentication. Isabelle and Bjorn are test users, so assigning
    an explicit password (password) is OK. You can do that from the Keycloak Admin
    CLI as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，用户会自己选择密码，并最好启用双因素身份验证。伊莎贝尔和Bjorn是测试用户，因此分配一个明确的密码（密码）是可以的。你可以从Keycloak
    Admin CLI按照以下方式执行：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s it for user management. You can get out of the bash console inside the
    Keycloak container with the exit command, but keep Keycloak running.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理到此结束。你可以使用exit命令从Keycloak容器内的bash控制台退出，但请保持Keycloak运行。
- en: Next, let’s explore how we can improve the authentication strategy in Edge Service.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何改进Edge Service的身份验证策略。
- en: 11.3 Authentication with OpenID Connect, JWT, and Keycloak
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用OpenID Connect、JWT和Keycloak进行身份验证
- en: At the moment, users must log in via a browser with a username and password.
    Since Keycloak now manages user accounts, we could go ahead and update Edge Service
    to check the user credentials with Keycloak itself, rather than using its internal
    storage. But what happens if we introduce different clients to the Polar Bookshop
    system, such as mobile applications and IoT devices? How should the users authenticate
    then? What if the bookshop employees are already registered in the company’s Active
    Directory (AD) and want to log in via SAML? Can we provide a single sign-on (SSO)
    experience across different applications? Will the users be able to log in via
    their GitHub or Twitter accounts (*social login*)?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，用户必须通过浏览器使用用户名和密码登录。由于Keycloak现在管理用户账户，我们可以继续更新Edge Service以使用Keycloak本身来检查用户凭据，而不是使用其内部存储。但是，如果我们向Polar
    Bookshop系统引入不同的客户端，例如移动应用程序和物联网设备，会发生什么？用户应该如何进行身份验证？如果书店员工已经在公司的Active Directory（AD）中注册并想通过SAML登录，怎么办？我们能否在不同应用程序之间提供单一登录（SSO）体验？用户能否通过他们的GitHub或Twitter账户（*社交登录*）登录？
- en: We could think of supporting all those authentication strategies in Edge Service
    as we get new requirements. However, that is not a scalable approach. A better
    solution is delegating a dedicated *identity provider* to authenticate users following
    any supported strategy. Edge Service would then use that service to verify the
    identity of a user without being concerned about performing the actual authentication
    step. The dedicated service could let users authenticate in various ways, such
    as using the credentials registered in the system, through social login, or via
    SAML to rely on the identity defined in the company’s AD.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获得新的需求时，我们可以考虑在边缘服务中支持所有这些认证策略。然而，这不是一个可扩展的方法。更好的解决方案是委托一个专门的*身份提供者*来根据任何支持的策略验证用户。然后边缘服务将使用该服务来验证用户的身份，而无需关心执行实际的认证步骤。该专用服务可以让用户以各种方式认证，例如使用系统中注册的凭据，通过社交登录，或通过SAML来依赖公司AD中定义的身份。
- en: Using a dedicated service to authenticate users leads to two aspects we need
    to address for the system to work. First, we need to establish a protocol for
    Edge Service to delegate user authentication to the identity provider and for
    the latter to provide information about the authentication result. Second, we
    need to define a data format that the identity provider can use to securely inform
    Edge Service about the identity of users after they have been successfully authenticated.
    This section will address both issues using OpenID Connect and JSON Web Token.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专门的服务来验证用户会导致我们需要解决两个方面的系统问题，以便系统能够正常工作。首先，我们需要为边缘服务建立一个协议，以便将用户身份验证委托给身份提供者，并让后者提供关于身份验证结果的信息。其次，我们需要定义一个数据格式，身份提供者可以使用它来在用户成功验证后安全地通知边缘服务用户的身份。本节将使用OpenID
    Connect和JSON Web Token来解决这个问题。
- en: 11.3.1 Authenticating users with OpenID Connect
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 使用OpenID Connect验证用户
- en: OpenID Connect (OIDC) is a protocol that enables an application (called the
    *Client*) to verify the identity of a user based on the authentication performed
    by a trusted party (called an *Authorization Server*) and retrieve the user profile
    information. The authorization server informs the Client application about the
    result of the authentication step via an *ID Token*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect (OIDC) 是一个协议，它允许一个应用程序（称为*客户端*）根据由受信任的第三方（称为*授权服务器*）执行的认证来验证用户的身份，并检索用户配置文件信息。授权服务器通过一个*ID令牌*通知客户端应用程序身份验证步骤的结果。
- en: OIDC is an identity layer on top of OAuth2, an authorization framework that
    solves the problem of delegating access using tokens for authorization but doesn’t
    deal with authentication. As you know, authorization can only happen after authentication.
    That’s why I decided to cover OIDC first; OAuth2 will be further explored in the
    next chapter. This is not the typical way of covering those subjects, but I think
    it makes sense when designing an access control system like we’re doing for Polar
    Bookshop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC是OAuth2之上的一个身份层，OAuth2是一个授权框架，它解决了使用令牌进行授权的委托问题，但没有处理身份验证。正如你所知，授权只能在身份验证之后发生。这就是为什么我决定首先介绍OIDC；OAuth2将在下一章中进一步探讨。这不是介绍这些主题的典型方式，但我觉得在我们为Polar
    Bookshop设计访问控制系统时，这样做是有意义的。
- en: 'Note This book will only cover some essential aspects of OAuth2 and OIDC. If
    you’re interested in learning more about them, Manning has a couple of books in
    its catalog on the subject: *OAuth 2 in Action* by Justin Richer and Antonio Sanso
    (Manning, 2017) and *OpenID Connect in Action* by Prabath Siriwardena (Manning,
    2022).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书将仅涵盖OAuth2和OIDC的一些基本方面。如果您想了解更多关于它们的信息，Manning在其目录中有一两本关于该主题的书：Justin Richer和Antonio
    Sanso的*OAuth 2 in Action*（Manning，2017）和Prabath Siriwardena的*OpenID Connect in
    Action*（Manning，2022）。
- en: 'When it comes to handling user authentication, we can identify three main actors
    in the OAuth2 framework that are used by the OIDC protocol:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理用户身份验证时，我们可以识别OIDC协议中OAuth2框架使用的三个主要参与者：
- en: '*Authorization Server*—The entity responsible for authenticating users and
    issuing tokens. In Polar Bookshop, this will be Keycloak.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*授权服务器*——负责验证用户并颁发令牌的实体。在Polar Bookshop中，这将是由Keycloak执行的。'
- en: '*User*—Also called the *Resource Owner*, this is the human logging in with
    the Authorization Server to get authenticated access to the Client application.
    In Polar Bookshop, it’s either a customer or an employee.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户*——也称为*资源所有者*，这是通过授权服务器登录以获取客户端应用程序认证访问权限的人类。在Polar Bookshop中，它可以是客户或员工。'
- en: '*Client*—The application requiring the user to be authenticated. This can be
    a mobile application, a browser-based application, a server-side application,
    or even a smart TV application. In Polar Bookshop, it’s Edge Service.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端*——需要用户进行身份验证的应用程序。这可以是一个移动应用程序、基于浏览器的应用程序、服务器端应用程序，甚至是智能电视应用程序。在 Polar
    Bookshop 中，它是 Edge 服务。'
- en: Figure 11.2 shows how the three actors are mapped to the Polar Bookshop architecture.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 展示了三个参与者如何映射到 Polar Bookshop 架构。
- en: '![11-02](../Images/11-02.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![11-02](../Images/11-02.png)'
- en: Figure 11.2 How the OIDC/OAuth2 roles are assigned to the entities in the Polar
    Bookshop architecture for user authentication
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 Polar Bookshop 架构中如何将 OIDC/OAuth2 角色分配给用户认证的实体
- en: Note The roles defined by the OAuth2 framework are also known by different names
    when used in the context of OpenID Connect. The OAuth2 Authorization Server is
    also called the *OIDC Provider*. The OAuth2 Client, which relies on the Authorization
    Server for authentication and token issuing, is also called the *Relying Party*
    (RP). The OAuth2 User is also called the *End-User*. We’ll stick to the OAuth2
    naming for consistency, but it’s helpful to know the alternative terminology used
    in OIDC.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：OAuth2 框架定义的角色在 OpenID Connect 的上下文中也有不同的名称。OAuth2 授权服务器也称为 *OIDC 提供者*。依赖于授权服务器进行身份验证和令牌发行的
    OAuth2 客户端也称为 *依赖方* (RP)。OAuth2 用户也称为 *最终用户*。我们将坚持使用 OAuth2 命名法以保持一致性，但了解 OIDC
    中使用的替代术语是有帮助的。
- en: In Polar Bookshop, Edge Service will initiate the user login flow, but then
    it will delegate the actual authentication step to Keycloak via the OIDC protocol
    (supported out of the box by Spring Security). Keycloak provides several authentication
    strategies, including traditional login forms, social logins via providers like
    GitHub or Twitter, and SAML. It also supports two-factor authentication (2FA).
    In the following sections, we’ll use the login form strategy as an example. Since
    users will interact directly with Keycloak to log in, their credentials will never
    be exposed to any component of the system except Keycloak, which is one of the
    benefits of adopting such a solution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Polar Bookshop 中，Edge 服务将启动用户登录流程，但随后将通过 OIDC 协议（由 Spring Security 内置支持）将实际的认证步骤委托给
    Keycloak。Keycloak 提供了多种认证策略，包括传统的登录表单、通过 GitHub 或 Twitter 等提供者进行的社会登录，以及 SAML。它还支持双因素认证（2FA）。在接下来的章节中，我们将使用登录表单策略作为示例。由于用户将直接与
    Keycloak 进行交互以登录，因此他们的凭据永远不会暴露给系统中的任何组件，除了 Keycloak，这是采用此类解决方案的一个好处。
- en: 'When an unauthenticated user calls a secure endpoint exposed by Edge Service,
    the following happens:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当未经认证的用户调用 Edge 服务公开的受保护端点时，以下情况会发生：
- en: Edge Service (the Client) redirects the browser to Keycloak (the Authorization
    Server) for authentication.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Edge 服务（客户端）将浏览器重定向到 Keycloak（授权服务器）进行身份验证。
- en: Keycloak authenticates the user (for example, by asking for a username and password
    via a login form) and then redirects the browser back to Edge Service, together
    with an *Authorization Code*.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Keycloak 通过登录表单（例如，要求用户输入用户名和密码）验证用户身份，然后将浏览器重定向回 Edge 服务，并附带一个 *授权码*。
- en: Edge Service calls Keycloak to exchange the Authorization Code with an ID Token,
    containing information about the authenticated user.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Edge 服务调用 Keycloak 以交换授权码和包含有关已验证用户信息的 ID 令牌。
- en: Edge Service initializes an authenticated user session with the browser based
    on a session cookie. Internally, Edge Service maintains a mapping between the
    session identifier and ID Token (the user identity).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Edge 服务根据会话 cookie 初始化基于浏览器的已验证用户会话。内部，Edge 服务维护会话标识符和 ID 令牌（用户身份）之间的映射。
- en: Note The authentication flow supported by OIDC is based on the OAuth2 *Authorization
    Code flow*. The second step might seem redundant, but the Authorization Code is
    essential for ensuring that only the legitimate Client can exchange it with tokens.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：OIDC 支持的认证流程基于 OAuth2 的 *授权码流程*。第二步可能看起来是多余的，但授权码对于确保只有合法的客户端才能将其与令牌交换是至关重要的。
- en: Figure 11.3 describes the essential parts of the authentication flow supported
    by the OIDC protocol. Even if Spring Security supports that out of the box, and
    you won’t need to implement any of it yourself, it’s still beneficial to have
    an overview of the flow in mind.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 描述了 OIDC 协议支持的认证流程的基本部分。即使 Spring Security 支持它，并且你不需要自己实现任何部分，但了解流程的概述仍然是有益的。
- en: '![11-03](../Images/11-03.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![11-03](../Images/11-03.png)'
- en: Figure 11.3 The authentication flow supported by the OIDC protocol
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 OIDC协议支持的认证流程
- en: When adopting the authentication flow illustrated in figure 11.3, Edge Service
    is not affected by the specific authentication strategy. We could configure Keycloak
    to use an Active Directory or perform a social login via GitHub, and Edge Service
    would not require any changes. It only needs to support OIDC to verify that the
    authentication happened correctly and get information about the user via an ID
    Token. What’s an ID Token? It’s a *JSON Web Token* (JWT) containing information
    about the user authentication event. We’ll take a closer look at JWTs in the next
    section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用图11.3中所示的认证流程时，边缘服务不受特定认证策略的影响。我们可以配置Keycloak使用Active Directory或通过GitHub进行社交登录，而边缘服务无需任何更改。它只需要支持OIDC来验证认证是否正确发生，并通过ID令牌获取用户信息。什么是ID令牌？它是一个包含用户认证事件信息的*JSON
    Web令牌* (JWT)。我们将在下一节中更详细地了解JWT。
- en: Note Whenever I mention OIDC, I am referring to the OpenID Connect Core 1.0
    specification ([https://openid.net/specs/openid-connect-core-1_0.html](https://openid.net/specs/openid-connect-core-1_0.html)).
    Whenever I mention OAuth2, unless specified otherwise, I am referring to the OAuth
    2.1 specification currently under standardization ([https://oauth.net/2.1](https://oauth.net/2.1))
    and meant to replace the OAuth 2.0 standard described in RFC 6749 ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每当提到OIDC时，我指的是OpenID Connect Core 1.0规范([https://openid.net/specs/openid-connect-core-1_0.html](https://openid.net/specs/openid-connect-core-1_0.html))。每当提到OAuth2时，除非另有说明，我指的是目前正在标准化中的OAuth
    2.1规范([https://oauth.net/2.1](https://oauth.net/2.1))，旨在取代RFC 6749中描述的OAuth 2.0标准([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749))。
- en: 11.3.2 Exchanging user information with JWT
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 使用JWT交换用户信息
- en: In distributed systems, including microservices and cloud native applications,
    the most-used strategy for exchanging information about an authenticated user
    and their authorization is through tokens.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，包括微服务和云原生应用，用于交换已认证用户及其授权信息的最常用策略是通过令牌。
- en: JSON Web Token (JWT) is an industry-standard for representing *claims* to be
    transferred between two parties. It’s a widely used format for propagating information
    about an authenticated user and their permissions securely among different parties
    in a distributed system. A JWT is not used by itself, but it’s included in a larger
    structure, the JSON Web Signature (JWS), which ensures the integrity of the claims
    by digitally signing the JWT object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token (JWT)是表示要在两个实体之间传输的*声明*的行业标准。它是在分布式系统中，在不同实体之间安全地传播有关已认证用户及其权限信息的广泛使用的格式。JWT本身不单独使用，但它包含在一个更大的结构中，即JSON
    Web签名（JWS），通过数字签名JWT对象来确保声明的完整性。
- en: 'A digitally signed JWT (JWS) is a string composed of three parts encoded in
    Base64 and separated by a dot (.) character:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字签名的JWT（JWS）是由三个部分组成的字符串，这些部分使用Base64编码，并由点（.）字符分隔：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note For debugging purposes, you can use the tool available on [https://jwt.io](https://jwt.io)
    to encode and decode tokens.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了调试目的，你可以使用[https://jwt.io](https://jwt.io)上提供的工具来编码和解码令牌。
- en: 'As you saw, a digitally signed JWT has three parts:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一个数字签名的JWT有三个部分：
- en: '*Header*—A JSON object (called *JOSE Header*) containing information about
    the cryptographic operations performed on the payload. The operations follow the
    standards from the Javascript Object Signing and Encryption (JOSE) framework.
    A decoded header looks like this:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部*——一个包含对有效载荷执行的加密操作信息的JSON对象（称为*JOSE头部*）。这些操作遵循来自JavaScript对象签名和加密（JOSE）框架的标准。解码后的头部看起来如下：'
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The algorithm used to sign the token digitally
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 用于数字签名令牌的算法
- en: ❷ The type of token
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 令牌的类型
- en: '*Payload*—A JSON object (called *Claims Set*) containing the claims conveyed
    by the token. The JWT specification defines some standard claim names, but you
    can also define your own. A decoded payload looks like the following:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效载荷*——一个包含令牌传达的声明的JSON对象（称为*声明集*）。JWT规范定义了一些标准声明名称，但您也可以定义自己的。解码后的有效载荷看起来如下：'
- en: '[PRE20]'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The entity that issued the JWT (the issuer)
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 发布JWT的实体（发布者）
- en: ❷ The entity that is the subject of the JWT (the end-user)
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ JWT的主题实体（终端用户）
- en: ❸ When the JWT expires (a timestamp)
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❸ JWT过期时间（时间戳）
- en: '*Signature*—The signature of the JWT, ensuring that the claims have not been
    tampered with. A prerequisite of using a JWS structure is that we trust the entity
    issuing the token (the *issuer*), and we have a way to check its validity.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*签名*——JWT 的签名，确保声明没有被篡改。使用 JWS 结构的先决条件是我们信任发行令牌的实体（*发行者*），并且我们有检查其有效性的方法。'
- en: When a JWT requires integrity and confidentiality, it’s first signed as a JWS
    and then encrypted with JSON Web Encryption (JWE). In this book, we’ll use only
    JWS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JWT 需要完整性和机密性时，它首先被作为 JWS 签名，然后使用 JSON Web Encryption (JWE) 加密。在这本书中，我们将只使用
    JWS。
- en: Note If you’re interested in learning more about JWT and its related aspects,
    you can refer to the IETF standard specifications. JSON Web Token (JWT) is documented
    in RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)),
    JSON Web Signature (JWS) is described in RFC 7515 ([https://tools.ietf.org/html/rfc7515](https://tools.ietf.org/html/rfc7515)),
    and JSON Web Encryption (JWE) is presented in RFC 7516 ([https://tools.ietf.org/html/rfc7516](https://tools.ietf.org/html/rfc7516)).
    You might also be interested in JSON Web Algorithms (JWA), which defines the available
    cryptographic operations for JWTs and is detailed in RFC 7518 ([https://tools.ietf.org/html
    rfc7518](https://tools.ietf.org/html/rfc7518)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想了解更多关于 JWT 及其相关方面的信息，可以参考 IETF 标准规范。JSON Web Token (JWT) 记录在 RFC 7519
    ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)) 中，JSON
    Web Signature (JWS) 描述在 RFC 7515 ([https://tools.ietf.org/html/rfc7515](https://tools.ietf.org/html/rfc7515))
    中，而 JSON Web Encryption (JWE) 则在 RFC 7516 ([https://tools.ietf.org/html/rfc7516](https://tools.ietf.org/html/rfc7516))
    中展示。您可能还对 JSON Web Algorithms (JWA) 感兴趣，它定义了 JWT 可用的加密操作，并在 RFC 7518 ([https://tools.ietf.org/html/rfc7518](https://tools.ietf.org/html/rfc7518))
    中详细说明。
- en: In the case of Polar Bookshop, Edge Service can delegate the authentication
    step to Keycloak. After authenticating the user successfully, Keycloak will send
    a JWT to Edge Service with information about the newly authenticated user (ID
    Token). Edge Service will validate the JWT through its signature and inspect it
    to retrieve data (claims) about the user. Finally, it will establish an authenticated
    session with the user’s browser based on a session cookie, whose identifier is
    mapped to the JWT.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Polar Bookshop 的情况下，边缘服务可以将认证步骤委托给 Keycloak。认证用户成功后，Keycloak 将包含有关新认证用户信息的
    JWT 发送给边缘服务（ID Token）。边缘服务将通过其签名验证 JWT，并检查它以检索有关用户的数据（声明）。最后，它将根据会话 cookie 与用户的浏览器建立认证会话，该
    cookie 的标识符映射到 JWT。
- en: To delegate authentication and retrieve tokens securely, Edge Service must be
    registered as an OAuth2 Client in Keycloak. Let’s see how.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了委托认证并安全地检索令牌，边缘服务必须在 Keycloak 中注册为 OAuth2 客户端。让我们看看如何操作。
- en: 11.3.3 Registering an application in Keycloak
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 在 Keycloak 中注册应用程序
- en: As you learned in the previous sections, an OAuth2 Client is an application
    that can request user authentication and ultimately receive tokens from an Authorization
    Server. In the Polar Bookshop architecture, this role is played by Edge Service.
    When using OIDC/OAuth2, you need to register each OAuth2 Client with the Authorization
    Server before using it for authenticating users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一节所学，OAuth2 客户端是一个可以请求用户认证并最终从授权服务器接收令牌的应用程序。在 Polar Bookshop 架构中，这个角色由边缘服务扮演。当使用
    OIDC/OAuth2 时，您需要在使用它进行用户认证之前，将每个 OAuth2 客户端注册到授权服务器。
- en: Clients can be *public* or *confidential*. We register an application as a public
    Client if it can’t keep a secret. For example, mobile applications would be registered
    as public Clients. On the other hand, confidential Clients are those that can
    keep a secret, and they are usually backend applications like Edge Service. The
    registration process is similar either way. The main difference is that confidential
    Clients are required to authenticate themselves with the Authorization Server,
    such as by relying on a shared secret. It’s an additional protection layer we
    can’t use for public Clients, since they have no way to store the shared secret
    securely.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以是 *公开* 或 *机密* 的。如果我们无法保持秘密，我们将应用程序注册为公开客户端。例如，移动应用程序将被注册为公开客户端。另一方面，机密客户端是可以保持秘密的客户端，通常是像边缘服务这样的后端应用程序。无论哪种方式，注册过程都是相似的。主要区别在于，机密客户端需要通过授权服务器（例如，通过依赖共享秘密）进行自身认证。这是我们不能用于公开客户端的额外保护层，因为它们没有安全存储共享秘密的方法。
- en: The Client dilemma in OAuth2
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2 中的客户端困境
- en: The Client role can be assigned either to a frontend or a backend application.
    The main difference is the level of security of the solution. The Client is the
    entity that will receive tokens from the Authorization Server. The Client will
    have to store them somewhere to be used in subsequent requests from the same user.
    Tokens are sensitive data that should be secured, and there’s no better place
    than a backend application to do that. But it’s not always possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端角色可以分配给前端或后端应用程序。主要区别在于解决方案的安全级别。客户端是将从授权服务器接收令牌的实体。客户端必须将它们存储在某个地方，以便在来自同一用户的后续请求中使用。令牌是敏感数据，应该得到保护，而后端应用程序是做这件事的最佳地点。但这并不总是可能的。
- en: Here is my rule of thumb. If the frontend is a mobile or desktop application
    like iOS or Android, that will be the OAuth2 Client, and it will be categorized
    as a *public* Client. You can use libraries like AppAuth ([https://appauth.io](https://appauth.io))
    to add support for OIDC/ OAuth2 and store the tokens as securely as possible on
    the device. If the frontend is a web application (like in Polar Bookshop), then
    a backend service should be the Client. In this case, it would be categorized
    as a *confidential* Client.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的经验法则。如果前端是一个移动或桌面应用程序，如iOS或Android，那么它将是OAuth2客户端，并将被分类为*公共*客户端。您可以使用AppAuth
    ([https://appauth.io](https://appauth.io))等库来添加对OIDC/OAuth2的支持，并在设备上尽可能安全地存储令牌。如果前端是Web应用程序（如极地书店），那么后端服务应该是客户端。在这种情况下，它将被分类为*机密*客户端。
- en: The reason for this distinction is that no matter how much you try to hide the
    OIDC/OAuth2 tokens in the browser (cookies, local storage, session storage), they
    will always be at risk of being exposed and misused. “From a security perspective,
    it is virtually impossible to secure tokens in a frontend web application.” That’s
    what application security expert Philippe De Ryck writes^a, recommending engineers
    rely on the backend-for-frontend pattern and have a backend application deal with
    tokens instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区分的原因是，无论你如何尝试在浏览器中隐藏OIDC/OAuth2令牌（cookie、本地存储、会话存储），它们总是存在被暴露和滥用的风险。“从安全角度来看，在前端Web应用程序中保护令牌几乎是不可能的。”这是应用安全专家Philippe
    De Ryck的观点^a，他建议工程师依赖后端-for-前端模式，并让后端应用程序处理令牌。
- en: I recommend basing the interaction between browser and backend on a session
    cookie (like you’d do for monoliths) and have the backend application be responsible
    for controlling the authentication flow and using the tokens issued by the Authorization
    Server, even in the case of SPAs. That is the current best practice recommended
    by security experts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议基于会话cookie（就像你在单体应用中做的那样）在浏览器和后端之间建立交互，并让后端应用程序负责控制身份验证流程和使用授权服务器颁发的令牌，即使在单页应用（SPAs）的情况下。这是安全专家推荐的最佳实践。
- en: ^(a )P. De Ryck, “A Critical Analysis of Refresh Token Rotation in Single-page
    Applications,” *Ping Identity* blog, March 18, 2021, [http://mng.bz/QWG6](http://mng.bz/QWG6)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^（a ）P. De Ryck，“单页应用中刷新令牌轮换的批判性分析”，*Ping Identity*博客，2021年3月18日，[http://mng.bz/QWG6](http://mng.bz/QWG6)
- en: .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: Since Edge Service will be the OAuth2 Client in the Polar Bookshop system, let’s
    register it with Keycloak. We can rely on the Keycloak Admin CLI one more time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于边缘服务将是极地书店系统中的OAuth2客户端，让我们使用Keycloak来注册它。我们可以再次依赖Keycloak Admin CLI。
- en: 'Make sure the Keycloak container you started earlier is still running. Then
    open a Terminal window and enter a bash console inside the Keycloak container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您之前启动的Keycloak容器仍在运行。然后打开一个终端窗口，并在Keycloak容器内进入bash控制台：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, navigate to the folder where the Keycloak Admin CLI scripts are located:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到Keycloak Admin CLI脚本所在的文件夹：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you learned earlier, the Admin CLI is protected by the username and password
    we defined in Docker Compose for the Keycloak container, so we need to start an
    authenticated session before running any other commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所学的，Admin CLI受我们在Docker Compose中为Keycloak容器定义的用户名和密码保护，因此我们需要在运行任何其他命令之前启动一个认证会话：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, register Edge Service as an OAuth2 Client in the PolarBookshop realm:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在PolarBookshop域中将边缘服务注册为OAuth2客户端：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The OAuth2 Client identifier
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ OAuth2客户端标识符
- en: ❷ It must be enabled.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 它必须被启用。
- en: ❸ Edge Service is a confidential client, not public.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 边缘服务是一个机密客户端，不是公开的。
- en: ❹ Since it’s a confidential client, it needs a secret to authenticate with Keycloak.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 由于它是一个机密客户端，它需要一个秘密来与Keycloak进行身份验证。
- en: ❺ The application URLs to which Keycloak is authorized to redirect a request
    after a user login or logout
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Keycloak 授权重定向请求的应用程序 URL，在用户登录或登出后
- en: The valid redirect URLs are the endpoints exposed by the OAuth2 Client application
    (Edge Service) where Keycloak will redirect authentication requests. Since Keycloak
    can include sensitive information in a redirect request, we want to limit which
    applications and endpoints are authorized to receive such information. As you’ll
    learn later, the redirect URL for authentication requests will be http://localhost:9000/login/oauth2/code/*,
    following the default format provided by Spring Security. To support redirects
    after logout operations, we also need to add http://localhost:9000 as a valid
    redirect URL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的重定向 URL 是 OAuth2 客户端应用程序（边缘服务）公开的端点，Keycloak 将将身份验证请求重定向到这些端点。由于 Keycloak
    可以在重定向请求中包含敏感信息，我们希望限制哪些应用程序和端点被授权接收此类信息。正如您稍后将要了解的，身份验证请求的重定向 URL 将是 http://localhost:9000/login/oauth2/code/*，遵循
    Spring Security 提供的默认格式。为了支持登出操作后的重定向，我们还需要添加 http://localhost:9000 作为有效的重定向 URL。
- en: That’s it for this section. In the source code repository accompanying the book,
    I included a JSON file you can use to load the entire configuration when starting
    up the Keycloak container in the future (Chapter11/11-end/polar-deployment/docker/keycloak/realm-config.json).
    Now that you’ve familiarized yourself with Keycloak, you can update the container
    definition to ensure you always have the needed configuration at startup. Copy
    the JSON file over the same path in your own project, and update the polar-keycloak
    service in your docker-compose.yml file as follows.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节的内容就到这里。在本书附带的源代码仓库中，我包含了一个 JSON 文件，您可以在将来启动 Keycloak 容器时使用它来加载整个配置（Chapter11/11-end/polar-deployment/docker/keycloak/realm-config.json）。现在您已经熟悉了
    Keycloak，您可以更新容器定义以确保在启动时始终拥有所需的配置。将 JSON 文件复制到您自己的项目中相同的路径，并按照以下方式更新您的 docker-compose.yml
    文件中的 polar-keycloak 服务：
- en: Listing 11.4 Importing realm configuration in Keycloak container
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 在 Keycloak 容器中导入领域配置
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Imports the provided configuration at startup time
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在启动时导入提供的配置
- en: ❷ Configures a volume to load the configuration file into the container
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置一个卷将配置文件加载到容器中
- en: Why Keycloak
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择 Keycloak
- en: I decided to use Keycloak since it’s a mature, open source solution for running
    an Authorization Server yourself. After increasing demands from the community,
    Spring started a new Spring Authorization Server project ([https://github.com/spring-projects/spring-authorization-server](https://github.com/spring-projects/spring-authorization-server)).
    Since version 0.2.0, it’s been a production-ready solution for setting up an OAuth2
    Authorization Server. At the time of writing, the project provides an implementation
    for the most common OAuth2 features, and it’s currently working on extending support
    for OIDC-specific features. You can follow the progress and contribute to the
    project on GitHub.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定使用 Keycloak，因为它是一个成熟的、开源的解决方案，可以自己运行授权服务器。在社区需求增加之后，Spring 开始了一个新的 Spring
    Authorization Server 项目 ([https://github.com/spring-projects/spring-authorization-server](https://github.com/spring-projects/spring-authorization-server))。从版本
    0.2.0 开始，它已经成为设置 OAuth2 授权服务器的生产就绪解决方案。在撰写本文时，该项目提供了最常见的 OAuth2 功能的实现，并且目前正在扩展对
    OIDC 特定功能的支持。您可以在 GitHub 上跟踪项目的进展并为其做出贡献。
- en: Another option is to use a SaaS solution like Okta ([www.okta.com](http://www.okta.com))
    or Auth0 ([https://auth0.com](https://auth0.com)). They are both excellent solutions
    for getting OIDC/OAuth2 as a managed service, and I encourage you to try them
    out. For this book, I wanted to use a solution that you could run and reliably
    reproduce in your local environment without depending on other services that might
    change over time, making my instructions here invalid.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用像 Okta ([www.okta.com](http://www.okta.com)) 或 Auth0 ([https://auth0.com](https://auth0.com))
    这样的 SaaS 解决方案。它们都是获取 OIDC/OAuth2 作为托管服务的优秀解决方案，我鼓励您尝试使用它们。对于这本书，我希望使用一个您可以在本地环境中运行并可靠复制的解决方案，而不依赖于可能随时间变化的其他服务，这样我的说明在这里就不再有效。
- en: 'Before moving on, let’s stop any running containers. Open a Terminal window,
    navigate to the folder where you keep your Docker Compose file (polar-deployment/
    docker/docker-compose.yml), and run the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们停止任何正在运行的容器。打开一个终端窗口，导航到您保存 Docker Compose 文件（polar-deployment/docker/docker-compose.yml）的文件夹，并运行以下命令：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We now have all the pieces for refactoring Edge Service so it can use an authentication
    strategy relying on OIDC/OAuth2, JWT, and Keycloak. The best part is that it’s
    based on standards and supported by all major languages and frameworks (frontend,
    backend, mobile, IoT), including Spring Security.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了重构Edge Service的所有组件，使其能够使用依赖于OIDC/OAuth2、JWT和Keycloak的认证策略。最好的部分是，它基于标准，并得到所有主流语言和框架（前端、后端、移动、物联网）的支持，包括Spring
    Security。
- en: 11.4 Authenticating users with Spring Security and OpenID Connect
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用Spring Security和OpenID Connect认证用户
- en: As mentioned earlier, Spring Security supports several authentication strategies.
    The current security setup for Edge Service handles user accounts and authentication
    via a login form provided by the application itself. Now that you’ve learned about
    OpenID Connect, we can refactor the application to delegate user authentication
    to Keycloak via the OIDC protocol.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Security支持多种认证策略。Edge Service当前的安全设置通过应用程序本身提供的登录表单处理用户账户和认证。现在你已经了解了OpenID
    Connect，我们可以重构应用程序，通过OIDC协议将用户认证委托给Keycloak。
- en: Support for OAuth2 used to be in a separate project called Spring Security OAuth,
    which you would use as part of Spring Cloud Security to adopt OAuth2 in a cloud
    native application. Both of those projects have now been deprecated in favor of
    the native, more comprehensive support for OAuth2 and OpenID Connect introduced
    in the main Spring Security project, starting from version 5\. This chapter focuses
    on using the new OIDC/OAuth2 support in Spring Security 5 to authenticate the
    users of Polar Bookshop.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2的支持曾经在一个名为Spring Security OAuth的独立项目中，你会在Spring Cloud Security中使用它来在云原生应用程序中采用OAuth2。这两个项目现在都已弃用，转而支持Spring
    Security主项目中引入的本地、更全面的OAuth2和OpenID Connect支持，从版本5开始。本章重点介绍如何使用Spring Security
    5中的新OIDC/OAuth2支持来认证Polar Bookshop的用户。
- en: Note If you find yourself working on a project using the deprecated Spring Security
    OAuth and Spring Cloud Security projects, you might want to check out chapters
    12 through 15 of *Spring Security in Action* by Laurenţiu Spilcǎ (Manning, 2020),
    where they are explained in great detail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你发现自己正在使用已弃用的Spring Security OAuth和Spring Cloud Security项目进行项目开发，你可能想查看Laurențiu
    Spilcǎ所著的《Spring Security in Action》（Manning, 2020）的第12章至第15章，其中对这些项目进行了详细的解释。
- en: 'Using Spring Security and its OAuth2/OIDC support, this section will show you
    how to do the following for Edge Service:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Security及其OAuth2/OIDC支持，本节将展示如何为Edge Service执行以下操作：
- en: Use OpenID Connect to authenticate users.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenID Connect进行用户认证。
- en: Configure user logout.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户注销。
- en: Extract information about the authenticated user.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取关于认证用户的详细信息。
- en: Let’s get started!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 11.4.1 Adding the new dependencies
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 添加新的依赖项
- en: First of all, we need to update the dependencies for Edge Service. We can replace
    the existing Spring Security starter dependency with the more specific OAuth2
    Client one, which adds support for OIDC/OAuth2 client features. Furthermore, we
    can add the Spring Security Test dependency, which provides additional support
    for testing security scenarios in Spring.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更新Edge Service的依赖项。我们可以用更具体的OAuth2客户端依赖项替换现有的Spring Security启动器依赖项，这增加了对OIDC/OAuth2客户端功能的支持。此外，我们还可以添加Spring
    Security Test依赖项，它为在Spring中测试安全场景提供额外的支持。
- en: Open the build.gradle file for the Edge Service project (edge-service) and add
    the new dependencies. Remember to refresh or reimport the Gradle dependencies
    after the new addition.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Edge Service项目（edge-service）的build.gradle文件，并添加新的依赖项。记得在添加新依赖项后刷新或重新导入Gradle依赖项。
- en: Listing 11.5 Adding dependencies for Spring Security OAuth2 Client
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 添加Spring Security OAuth2客户端依赖项
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Spring integration with Keycloak
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Spring与Keycloak集成
- en: When choosing Keycloak as the Authorization Server, an alternative to the native
    OpenID Connect/OAuth2 support provided by Spring Security was the Keycloak Spring
    Adapter. It was a library supplied by the Keycloak project itself to integrate
    with Spring Boot and Spring Security, but it was retired after the release of
    Keycloak 17.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择Keycloak作为授权服务器时，Spring Security提供的原生OpenID Connect/OAuth2支持的替代方案是Keycloak
    Spring Adapter。这是一个由Keycloak项目本身提供的库，用于与Spring Boot和Spring Security集成，但在Keycloak
    17发布后已退役。
- en: If you find yourself working on a project using the Keycloak Spring Adapter,
    you might want to check out my articles on the subject ([www.thomasvitale.com/tag/keycloak](http://www.thomasvitale.com/tag/keycloak))
    or chapter 9 of *Spring Microservices in Action*, second edition, by John Carnell
    and Illary Huaylupo Sánchez (Manning, 2021).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Keycloak Spring适配器的项目上工作，你可能想查看我关于这个主题的文章（[www.thomasvitale.com/tag/keycloak](http://www.thomasvitale.com/tag/keycloak)）或者John
    Carnell和Illary Huaylupo Sánchez（Manning，2021年）所著的《Spring Microservices in Action》第二版的第9章。
- en: 11.4.2 Configuring the integration between Spring Security and Keycloak
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 配置Spring Security与Keycloak之间的集成
- en: After adding the relevant dependencies on Spring Security, we need to configure
    the integration with Keycloak. In the previous section we registered Edge Service
    in Keycloak as an OAuth2 Client, defining both a client identifier (edge-service)
    and a shared secret (polar-keycloak-secret). Now we’ll use that information to
    tell Spring Security how to interact with Keycloak.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了Spring Security的相关依赖后，我们需要配置与Keycloak的集成。在上一节中，我们在Keycloak中注册了Edge Service作为OAuth2客户端，定义了客户端标识符（edge-service）和共享密钥（polar-keycloak-secret）。现在我们将使用这些信息来告诉Spring
    Security如何与Keycloak交互。
- en: Open the application.yml file in your Edge Service project, and add the following
    configuration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Edge Service项目的application.yml文件，并添加以下配置。
- en: Listing 11.6 Configuring Edge Service as an OAuth2 Client
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.6 配置Edge Service作为OAuth2客户端
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The name identifying the Client registration in Spring Security (called “registrationId”).
    It can be any string.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别Spring Security中客户端注册的名称（称为“registrationId”）。它可以任何字符串。
- en: ❷ The OAuth2 Client identifier as defined in Keycloak
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在Keycloak中定义的OAuth2客户端标识符
- en: ❸ The shared secret used by the Client to authenticate with Keycloak
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 客户端用于与Keycloak进行身份验证的共享密钥
- en: ❹ The list of scopes the Client would like to have access to. The openid scope
    triggers OIDC authentication on top of OAuth2.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 客户端希望访问的权限范围列表。openid权限范围在OAuth2之上触发OIDC身份验证。
- en: ❺ The same name used as “registrationId” a few lines above
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 几行之上用作“registrationId”的相同名称
- en: ❻ The Keycloak URL providing information about all the relevant OAuth2 and OIDC
    endpoints for the specific realm
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 提供有关特定领域所有相关OAuth2和OIDC端点信息的Keycloak URL
- en: Each Client registration in Spring Security must have an identifier (*registrationId*).
    In this example, it’s keycloak. The registration identifier is used to build the
    URL where Spring Security receives the Authorization Code from Keycloak. The default
    URL template is /login/oauth2/code/{registrationId}. For Edge Service, the full
    URL is http://localhost:9000/login/oauth2/code/keycloak, which we already configured
    in Keycloak as a valid redirect URL.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security中的每个客户端注册都必须有一个标识符（*registrationId*）。在这个例子中，它是keycloak。注册标识符用于构建Spring
    Security接收Keycloak授权码的URL。默认URL模板是/login/oauth2/code/{registrationId}。对于Edge Service，完整的URL是http://localhost:9000/login/oauth2/code/keycloak，这已经在Keycloak中配置为有效的重定向URL。
- en: Scopes are an OAuth2 concept for limiting an application’s access to user resources.
    You can think of them as roles, but for applications instead of users. When we
    use the OpenID Connect extension on top of OAuth2 to verify the user’s identity,
    we need to include the openid scope to inform the Authorization Server and receive
    an ID Token containing data about the user authentication. The next chapter will
    explain more about scopes in the context of authorization.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '权限范围是OAuth2的一个概念，用于限制应用程序对用户资源的访问。你可以将其视为角色，但针对应用程序而不是用户。当我们使用OAuth2之上的OpenID
    Connect扩展来验证用户身份时，我们需要包含openid权限范围来通知授权服务器并接收包含用户认证数据的ID令牌。下一章将更详细地解释在授权上下文中的权限范围。 '
- en: Now that we’ve defined the integration with Keycloak, let’s configure Spring
    Security to apply the desired security policies.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了与Keycloak的集成，让我们配置Spring Security以应用所需的策略。
- en: 11.4.3 Basic Spring Security configuration
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 基本Spring Security配置
- en: The central place for defining and configuring security policies in Spring Security
    is a SecurityWebFilterChain class. Edge Service is currently configured to require
    user authentication for all endpoints, and it uses an authentication strategy
    based on a login form. Let’s change that to use OIDC authentication instead.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中定义和配置安全策略的中心位置是SecurityWebFilterChain类。Edge Service目前配置为要求对所有端点进行用户身份验证，并使用基于登录表单的认证策略。让我们将其更改为使用OIDC认证。
- en: The ServerHttpSecurity object provides two ways of configuring an OAuth2 Client
    in Spring Security. With oauth2Login(), you can configure an application to act
    as an OAuth2 Client and also authenticate users through OpenID Connect. With oauth2Client(),
    the application will not authenticate users, so it’s up to you to define another
    authentication mechanism. We want to use OIDC authentication, so we’ll use oauth2Login()
    and the default configuration. Update the SecurityConfig class as follows.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ServerHttpSecurity 对象提供了两种在 Spring Security 中配置 OAuth2 客户端的方式。使用 oauth2Login()，您可以配置一个应用程序作为
    OAuth2 客户端并通过 OpenID Connect 认证用户。使用 oauth2Client()，应用程序将不会认证用户，因此您需要定义另一种认证机制。我们想使用
    OIDC 认证，所以我们将使用 oauth2Login() 和默认配置。按照以下方式更新 SecurityConfig 类。
- en: Listing 11.7 Requiring authentication for all endpoints through OIDC
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 通过 OIDC 对所有端点要求认证
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Enables user authentication with OAuth2/OpenID Connect
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用 OAuth2/OpenID Connect 用户认证
- en: 'Let’s verify that this works correctly. First, start the Redis and Keycloak
    containers. Open a Terminal window, navigate to the folder where you keep your
    Docker Compose file (polar-deployment/docker/docker-compose.yml), and run the
    following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证这是否正确工作。首先，启动 Redis 和 Keycloak 容器。打开一个终端窗口，导航到您保存 Docker Compose 文件（polar-deployment/docker/docker-compose.yml）的文件夹，并运行以下命令：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then run the Edge Service application (./gradlew bootRun), open a browser window,
    and head to http://localhost:9000\. You should be redirected to a login page served
    by Keycloak, where you can authenticate as one of the users we created previously
    (figure 11.4).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行 Edge Service 应用程序（./gradlew bootRun），打开一个浏览器窗口，并转到 http://localhost:9000。您应该会被重定向到由
    Keycloak 提供的登录页面，在那里您可以作为我们之前创建的用户之一进行认证（图 11.4）。
- en: '![11-04](../Images/11-04.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![11-04](../Images/11-04.png)'
- en: Figure 11.4 The Keycloak login page for the Polar Bookshop realm, shown after
    Edge Service triggered the OIDC authentication flow
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 Polar Bookshop 域的关键cloak 登录页面，显示在 Edge Service 触发 OIDC 认证流程之后
- en: For example, log in as Isabelle (isabelle/password) and pay attention to how
    Keycloak redirects you back to Edge Service after validating the provided credentials.
    Since Edge Service doesn’t expose any content through the root endpoint, you’ll
    see an error message (“Whitelabel Error Page”). But don’t worry! That’s where
    we’ll integrate an Angular frontend later. The crucial point of this test is that
    Edge Service required you to be authenticated before accessing any of its endpoints,
    and it triggered the OIDC authentication flow.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以 Isabelle（isabelle/password）的身份登录，并注意 Keycloak 在验证提供的凭据后如何将您重定向回 Edge Service。由于
    Edge Service 通过根端点不公开任何内容，您将看到一个错误消息（“Whitelabel Error Page”）。但别担心！那正是我们将集成 Angular
    前端的地方。这个测试的关键点是 Edge Service 要求您在访问其任何端点之前进行认证，并触发了 OIDC 认证流程。
- en: When you’re done trying out the OIDC authentication flow, stop the application
    with Ctrl-C.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试完 OIDC 认证流程后，使用 Ctrl-C 停止应用程序。
- en: If the authentication is successful, Spring Security will start an authenticated
    session with the browser and save information about the user. In the next section,
    you’ll see how we can retrieve and use that information.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证成功，Spring Security 将启动一个与浏览器的认证会话并保存有关用户的信息。在下一节中，您将了解我们如何检索和使用这些信息。
- en: 11.4.4 Inspecting the authenticated user context
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4 检查认证用户上下文
- en: As part of the authentication process, Spring Security defines a context to
    hold information about the user and map a user session to an ID Token. In this
    section, you’ll learn more about this context, what classes are involved, and
    how to retrieve the data and expose it through a new /user endpoint in Edge Service.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为认证过程的一部分，Spring Security 定义了一个上下文来保存有关用户的信息并将用户会话映射到一个 ID Token。在本节中，您将了解更多关于这个上下文的信息，涉及哪些类，以及如何在
    Edge Service 中的新 /user 端点检索和公开这些数据。
- en: First, let’s define a User model to collect the username, first name, last name,
    and roles of an authenticated user. That’s the same information we provided when
    registering the two users in Keycloak, and it is the information returned in the
    ID Token. In a new com.polarbookshop.edgeservice.user package, create a User record
    as follows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个 User 模型来收集已认证用户的用户名、名、姓和角色。这与我们在 Keycloak 中注册两个用户时提供的信息相同，也是 ID Token
    中返回的信息。在新的 com.polarbookshop.edgeservice.user 包中创建一个 User 记录，如下所示。
- en: Listing 11.8 Creating the User record to hold info about an authenticated user
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 创建用户记录以保存有关已认证用户的信息
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Immutable data class holding user data
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不可变数据类，包含用户数据
- en: Independent of the authentication strategy adopted (whether username/password,
    OpenID Connect/OAuth2, or SAML2), Spring Security keeps the information about
    an authenticated user (also called the *principal*) in an Authentication object.
    In the case of OIDC, the principal object is of type OidcUser, and it’s where
    Spring Security stores the ID Token. In turn, Authentication is saved in a SecurityContext
    object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 不论采用哪种认证策略（无论是用户名/密码、OpenID Connect/OAuth2 还是 SAML2），Spring Security 都会将有关已认证用户的信息（也称为
    *主体*）保存在一个 Authentication 对象中。在 OIDC 的情况下，主体对象是 OidcUser 类型，并且 Spring Security
    将 ID Token 存储在那里。反过来，Authentication 被保存在一个 SecurityContext 对象中。
- en: One way to access the Authentication object for the currently logged-in user
    is extracting it from the related SecurityContext retrieved from the ReactiveSecurityContextHolder
    (or SecurityContextHolder for imperative applications). Figure 11.5 illustrates
    how all these objects are related to each other.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前登录用户的 Authentication 对象的一种方法是从 ReactiveSecurityContextHolder（或对于命令式应用程序的
    SecurityContextHolder）检索到的相关 SecurityContext 中提取它。图 11.5 展示了所有这些对象之间的关系。
- en: '![11-05](../Images/11-05.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![11-05](../Images/11-05.png)'
- en: Figure 11.5 The main classes used to store information about the currently authenticated
    user
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 存储当前认证用户信息的主体类
- en: 'You can make that work by doing the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式使其工作：
- en: Create a UserController class annotated with @RestController in the com.polarbookshop.edgeservice.user
    package.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.polarbookshop.edgeservice.user 包中创建一个带有 @RestController 注解的 UserController
    类。
- en: Define a method to handle GET requests to a new /user endpoint.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法来处理对新的 /user 端点的 GET 请求。
- en: Return a User object for the currently authenticated user, retrieving the necessary
    information from OidcUser. To get the correct data, we can use the call hierarchy
    shown in figure 11.5.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个包含从 OidcUser 中检索到的必要信息的 User 对象，以获取正确数据，我们可以使用图 11.5 中所示的调用层次结构。
- en: 'The resulting method in the UserController class will look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UserController 类中生成的结果方法将如下所示：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Gets SecurityContext for the currently authenticated user from ReactiveSecurityContextHolder
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 ReactiveSecurityContextHolder 获取当前认证用户的 SecurityContext
- en: ❷ Gets Authentication from SecurityContext
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 SecurityContext 获取认证信息
- en: ❸ Gets the principal from Authentication. For OIDC, it’s of type OidcUser.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 Authentication 获取主体。对于 OIDC，它是 OidcUser 类型。
- en: ❹ Builds a User object using data from OidcUser (extracted from the ID Token)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用从 ID Token 中提取的 OidcUser 数据构建一个 User 对象
- en: In the next chapter, which focuses on authorization strategies, we’ll configure
    Keycloak to include a custom roles claim in the ID Token and use that value to
    build the User object in the UserController class. Until then, we’ll use a fixed
    list of values.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于授权策略，我们将配置 Keycloak 以在 ID Token 中包含一个自定义的角色声明，并使用该值在 UserController
    类中构建 User 对象。在此之前，我们将使用一个固定的值列表。
- en: For Spring Web MVC and WebFlux controllers, besides using ReactiveSecurityContextHolder
    directly, we can use the annotations @CurrentSecurityContext and @AuthenticationPrincipal
    to inject the SecurityContext and the principal (in this case, OidcUser) respectively.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Spring Web MVC 和 WebFlux 控制器，除了直接使用 ReactiveSecurityContextHolder，我们还可以使用
    @CurrentSecurityContext 和 @AuthenticationPrincipal 注解分别注入 SecurityContext 和主体（在这种情况下，OidcUser）。
- en: Let’s simplify the implementation of the getUser() method by injecting the OidcUser
    object directly as an argument. The final result for the UserController class
    is shown in the following listing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过直接将 OidcUser 对象作为参数注入来简化 getUser() 方法的实现。UserController 类的最终结果如下所示。
- en: Listing 11.9 Returning information about the currently authenticated user
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 返回当前认证用户的信息
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Injects an OidcUser object containing info about the currently authenticated
    user
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注入一个包含当前认证用户信息的 OidcUser 对象
- en: ❷ Builds a User object from relevant claims contained in OidcUser
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 OidcUser 中包含的相关声明构建一个 User 对象
- en: ❸ Wraps the User object in a reactive publisher, since Edge Service is a reactive
    application
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 User 对象包装在一个响应式发布者中，因为 Edge Service 是一个响应式应用程序
- en: 'Ensure that Keycloak and Redis are still running from the previous section,
    run the Edge Service application (./gradlew bootRun), open an incognito browser
    window, and navigate to http://localhost:9000/user. Spring Security will redirect
    you to Keycloak, which will prompt you to log in with a username and password.
    For example, authenticate as Bjorn (bjorn/password). After successfully authenticating,
    you will be redirected back to the /user endpoint. The result is the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 确保从上一节中 Keycloak 和 Redis 仍在运行，运行边缘服务应用程序（./gradlew bootRun），打开一个隐身浏览器窗口，并导航到
    http://localhost:9000/user。Spring Security 将您重定向到 Keycloak，您将需要使用用户名和密码登录。例如，以
    Bjorn（bjorn/password）的身份进行认证。认证成功后，您将被重定向回 /user 端点。结果是以下内容：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note The roles list includes hardcoded values. In the next chapter, we’ll change
    it to return the actual roles assigned to each user in Keycloak.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：角色列表包含硬编码的值。在下一章中，我们将将其更改为返回 Keycloak 中每个用户分配的实际角色。
- en: When you’re done trying out the new endpoint, stop the application with Ctrl-C
    and the containers with docker-compose down.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成对新端点的尝试后，使用 Ctrl-C 停止应用程序，并使用 docker-compose down 停止容器。
- en: Consider what happened when you tried to access the /user endpoint and got redirected
    to Keycloak. After successfully validating the user’s credentials, Keycloak called
    Edge Service back and sent the ID Token for the newly authenticated user. Then
    Edge Service stored the token and redirected the browser to the required endpoint,
    together with a session cookie. From that point on, any communication between
    the browser and Edge Service will use that session cookie to identify the authenticated
    context for that user. No token is exposed to the browser.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当你尝试访问 /user 端点并被重定向到 Keycloak 时发生的情况。在成功验证用户的凭据后，Keycloak 回调边缘服务并发送新认证用户的
    ID Token。然后边缘服务存储令牌并将浏览器重定向到所需的端点，同时附带一个会话 cookie。从那时起，浏览器和边缘服务之间的任何通信都将使用该会话
    cookie 来识别该用户的认证上下文。没有令牌暴露给浏览器。
- en: The ID Token is stored in OidcUser, part of Authentication and ultimately included
    in SecurityContext. In chapter 9, we used the Spring Session project to make Edge
    Service store session data in an external data service (Redis), so it could remain
    stateless and be able to scale out. SecurityContext objects are included in the
    session data and are therefore stored in Redis automatically, making it possible
    for Edge Service to scale out without any problem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ID Token 存储在 OidcUser 中，它是认证的一部分，最终包含在 SecurityContext 中。在第 9 章中，我们使用了 Spring
    Session 项目，使边缘服务将会话数据存储在外部数据服务（Redis）中，这样它就可以保持无状态并且能够扩展。SecurityContext 对象包含在会话数据中，因此会自动存储在
    Redis 中，使得边缘服务可以无问题地扩展。
- en: Another option for retrieving the currently authenticated user (the *principal*)
    is from the context associated with a specific HTTP request (called the *exchange*).
    We’ll use that option to update the rate limiter configuration. In chapter 9,
    we implemented rate-limiting with Spring Cloud Gateway and Redis. Currently the
    rate-limiting is computed based on the total number of requests received every
    second. We should update it to apply the rate limits to each user independently.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前认证用户（主体）的另一种选项是从与特定 HTTP 请求关联的上下文（称为交换）中获取。我们将使用该选项来更新速率限制器配置。在第 9 章中，我们使用
    Spring Cloud Gateway 和 Redis 实现了速率限制。目前，速率限制是基于每秒接收到的总请求数量计算的。我们应该更新它，以便独立地为每个用户应用速率限制。
- en: Open the RateLimiterConfig class and configure how the username of the currently
    authenticated principal should be extracted from the request. If no user is defined
    (that is, the request is unauthenticated, *anonymous*), we use a default key to
    apply rate-limiting to all unauthenticated requests as a whole.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 RateLimiterConfig 类，并配置如何从请求中提取当前认证主体的用户名。如果没有定义用户（即请求未认证，*匿名*），我们使用默认密钥将速率限制应用于所有未认证请求的整体。
- en: Listing 11.10 Configuring rate limiting for each user
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 为每个用户配置速率限制
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Gets the currently authenticated user (the principal) from the current request
    (the exchange)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从当前请求（交换）中获取当前认证用户（主体）
- en: ❷ Extracts the username from the principal
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从主体中提取用户名
- en: ❸ If the request is unauthenticated, it uses “anonymous” as the default key
    to apply rate-limiting.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果请求未认证，它使用“匿名”作为默认密钥来应用速率限制。
- en: That concludes the basic configuration for authenticating users of Polar Bookshop
    using OpenID Connect. The following section will cover how logout works in Spring
    Security and how we can customize it for the OAuth2/OIDC scenario.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了使用 OpenID Connect 对 Polar Bookshop 用户进行身份验证的基本配置。下一节将介绍在 Spring Security
    中注销的工作原理以及我们如何为 OAuth2/OIDC 场景进行自定义。
- en: 11.4.5 Configuring user logout in Spring Security and Keycloak
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.5 在 Spring Security 和 Keycloak 中配置用户注销
- en: So far, we have addressed the challenges and solutions for authenticating users
    in a distributed system. Still, we should consider what happens when a user logs
    out.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了在分布式系统中对用户进行身份验证的挑战和解决方案。然而，我们还应该考虑用户注销时会发生什么。
- en: In Spring Security, logging out results in all the session data associated with
    the user being deleted. When OpenID Connect/OAuth2 is used, the tokens stored
    by Spring Security for that user are also deleted. However, the user will still
    have an active session in Keycloak. Just as the authentication process involves
    both Keycloak and Edge Service, completely logging a user out requires propagating
    the logout request to both components.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Security 中，注销会导致与用户关联的所有会话数据被删除。当使用 OpenID Connect/OAuth2 时，Spring
    Security 为该用户存储的令牌也会被删除。然而，用户在 Keycloak 中仍将有一个活跃的会话。正如身份验证过程涉及 Keycloak 和 Edge
    Service 一样，完全注销用户需要将注销请求传播到这两个组件。
- en: By default, a logout performed against an application protected by Spring Security
    will not affect Keycloak. Fortunately, Spring Security provides an implementation
    of the “OpenID Connect RP-Initiated Logout” specification, which defines how a
    logout request should be propagated from an OAuth2 Client (the Relying Party)
    to the Authorization Server. You’ll see how to configure it for Edge Service soon.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，针对由 Spring Security 保护的应用程序执行的注销操作不会影响 Keycloak。幸运的是，Spring Security 提供了“OpenID
    Connect RP-Initiated Logout”规范的实现，该规范定义了如何从 OAuth2 客户端（即依赖方）将注销请求传播到授权服务器。您将很快看到如何为
    Edge Service 配置它。
- en: Note The OpenID Connect specification includes a few different scenarios for
    session management and logout. If you’d like to learn more, I recommend you check
    the official documents for OIDC Session Management ([https://openid.net/specs/openid-connect-session-1_0.html](https://openid.net/specs/openid-connect-session-1_0.html)),
    OIDC Front-Channel Logout ([https://openid.net/specs/openid-connect-frontchannel-1_0.html](https://openid.net/specs/openid-connect-frontchannel-1_0.html)),
    OIDC Back-Channel Logout ([https://openid.net/specs/openid-connect-backchannel-1_0.html](https://openid.net/specs/openid-connect-backchannel-1_0.html)),
    and OIDC RP-Initiated Logout ([https://openid.net/specs/openid-connect-rpinitiated-1_0.html](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：OpenID Connect 规范包括了一些不同的场景用于会话管理和注销。如果您想了解更多信息，我建议您查看 OIDC 会话管理（[https://openid.net/specs/openid-connect-session-1_0.html](https://openid.net/specs/openid-connect-session-1_0.html)）、OIDC
    前端通道注销（[https://openid.net/specs/openid-connect-frontchannel-1_0.html](https://openid.net/specs/openid-connect-frontchannel-1_0.html)）、OIDC
    后端通道注销（[https://openid.net/specs/openid-connect-backchannel-1_0.html](https://openid.net/specs/openid-connect-backchannel-1_0.html)）和
    OIDC RP-Initiated Logout（[https://openid.net/specs/openid-connect-rpinitiated-1_0.html](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)）的官方文档。
- en: Spring Security supports logging out by sending a POST request to the /logout
    endpoint implemented and exposed by the framework by default. We want to enable
    the RP-Initiated Logout scenario so that when a user logs out of the application,
    they are also logged out of the Authorization Server. Spring Security has full
    support for this scenario and provides an OidcClientInitiatedServerLogoutSuccessHandler
    object you can use to configure how to propagate a logout request to Keycloak.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 支持通过向框架默认实现的 /logout 端点发送 POST 请求来注销。我们希望启用 RP-Initiated Logout
    场景，以便当用户从应用程序注销时，他们也会从授权服务器注销。Spring Security 对此场景提供全面支持，并提供了一个 OidcClientInitiatedServerLogoutSuccessHandler
    对象，您可以使用它来配置如何将注销请求传播到 Keycloak。
- en: Let’s say the RP-Initiated Logout feature is enabled. In that case, after a
    user has been successfully logged out of Spring Security, Edge Service will send
    a logout request to Keycloak through the browser (using a redirect). Next you’ll
    probably want the user to be redirected back to the application after the logout
    operation has been performed on the Authorization Server as well.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 RP-Initiated Logout 功能已被启用。在这种情况下，用户在 Spring Security 中成功注销后，Edge Service
    将通过浏览器（使用重定向）向 Keycloak 发送注销请求。接下来，您可能还希望用户在授权服务器上完成注销操作后，被重定向回应用程序。
- en: You can configure where the user should be redirected after a logout with the
    setPostLogoutRedirectUri() method, which is exposed by the OidcClientInitiatedServerLogoutSuccessHandler
    class. You might specify a direct URL, but that will not work well in a cloud
    environment due to many variables such as hostnames, service names, and protocols
    (http vs. https). The Spring Security team knew that, and they added support for
    placeholders that are resolved dynamically at runtime. Instead of hardcoding a
    URL value, you can use the {baseUrl} placeholder. When you run Edge Service locally,
    the placeholder will be resolved to http://localhost:9000. If you ran it in the
    cloud behind a proxy with TLS termination and accessible through the DNS name
    polarbookshop.com, it would automatically be replaced with https://polarbookshop.com.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用setPostLogoutRedirectUri()方法配置用户注销后应重定向到的位置，该方法是OidcClientInitiatedServerLogoutSuccessHandler类公开的。您可能指定一个直接URL，但在云环境中由于许多变量（如主机名、服务名称和协议（http与https））的原因，这不会很好地工作。Spring
    Security团队知道这一点，因此他们添加了对在运行时动态解析的占位符的支持。您可以使用{baseUrl}占位符而不是硬编码URL值。当您在本地运行Edge
    Service时，占位符将被解析为http://localhost:9000。如果您在云环境中通过TLS终止代理并通过DNS名称polarbookshop.com访问它，它将自动替换为https://polarbookshop.com。
- en: However, the Client configuration in Keycloak requires an exact URL. That’s
    why we added http://localhost:9000 to the list of valid redirect URLs when we
    registered Edge Service in Keycloak. In production you’ll have to update the list
    of valid redirect URLs in Keycloak to match the actual URLs used there.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Keycloak中的客户端配置需要一个确切的URL。这就是为什么我们在Keycloak中注册Edge Service时将http://localhost:9000添加到有效重定向URL列表中。在生产环境中，您必须更新Keycloak中的有效重定向URL列表以匹配实际使用的URL。
- en: Figure 11.6 illustrates the logout scenario I’ve just described.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6展示了我刚刚描述的注销场景。
- en: '![11-06](../Images/11-06.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![11-06](../Images/11-06.png)'
- en: Figure 11.6 When a user logs out, the request is processed by Spring Security
    first, then forwarded to Keycloak, and the user is finally redirected to the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 当用户注销时，请求首先由Spring Security处理，然后转发到Keycloak，用户最终被重定向到应用程序。
- en: 'Since the application’s logout functionality is already provided by default
    in Spring Security, you only need to enable and configure the RP-Initiated Logout
    for Edge Service:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序的注销功能已经在Spring Security中默认提供，您只需要启用并配置Edge Service的RP-Initiated Logout：
- en: In the SecurityConfig class, define an oidcLogoutSuccessHandler() method to
    build an OidcClientInitiatedServerLogoutSuccessHandler object.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SecurityConfig类中，定义一个oidcLogoutSuccessHandler()方法来构建OidcClientInitiatedServerLogoutSuccessHandler对象。
- en: Configure the post-logout redirect URL using the setPostLogoutRedirectUri()
    method.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用setPostLogoutRedirectUri()方法配置注销后的重定向URL。
- en: Call the oidcLogoutSuccessHandler() method from the logout() configuration defined
    in the SecurityWebFilterChain bean.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从SecurityWebFilterChain bean中定义的logout()配置中调用oidcLogoutSuccessHandler()方法。
- en: The resulting configuration in the SecurityConfig class is as follows.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: SecurityConfig类中的配置结果如下。
- en: Listing 11.11 Configuring RP-Initiated Logout and redirecting on logout
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 配置RP-Initiated Logout和注销后的重定向
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Defines a custom handler for the scenario where a logout operation is completed
    successfully
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了一个自定义处理程序，用于注销操作成功完成的场景
- en: ❷ After logging out from the OIDC Provider, Keycloak will redirect the user
    to the application base URL computed dynamically from Spring (locally, it’s http://localhost:9000).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从OIDC提供者注销后，Keycloak将用户重定向到由Spring动态计算的应用程序基本URL（本地为http://localhost:9000）。
- en: 'Note The ReactiveClientRegistrationRepository bean is automatically configured
    by Spring Boot for storing the information about the clients registered with Keycloak,
    and it’s used by Spring Security for authentication/ authorization purposes. In
    our example, there’s only a client: the one we configured earlier in the application.yml
    file.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：ReactiveClientRegistrationRepository bean由Spring Boot自动配置，用于存储与Keycloak注册的客户端信息，并且它被Spring
    Security用于认证/授权目的。在我们的例子中，只有一个客户端：我们在application.yml文件中之前配置的那个。
- en: I won’t ask you to test the logout functionality just yet. The reason will be
    apparent after we introduce the Angular frontend to the Polar Bookshop system.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不会要求您测试注销功能。原因将在我们介绍Polar Bookshop系统的Angular前端之后变得明显。
- en: The user authentication feature based on OpenID Connect/OAuth2 is now complete,
    including logout and scalability concerns. If Edge Service used a template engine
    like Thymeleaf to build the frontend, the work we’ve done so far would be enough.
    However, when you’re integrating a secured backend application with an SPA like
    Angular, there are a few more aspects to consider. That will be the focus of the
    next section.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 基于OpenID Connect/OAuth2的用户身份验证功能现在已经完成，包括注销和可伸缩性问题。如果Edge Service使用模板引擎如Thymeleaf来构建前端，我们到目前为止所做的工作就足够了。然而，当您将受保护的后端应用与像Angular这样的SPA集成时，还有几个方面需要考虑。这将是下一节的重点。
- en: 11.5 Integrating Spring Security with SPAs
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 将Spring Security与SPA集成
- en: The web frontend part of microservice architectures and other distributed systems
    is often built as one or more single-page applications using frameworks like Angular,
    React, or Vue. Analyzing how SPAs are created is not in the scope of this book,
    but it’s essential to look at what changes are needed to support such frontend
    clients.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构和其他分布式系统的网络前端通常构建为一个或多个单页应用，使用Angular、React或Vue等框架。分析SPA的创建不在本书的范围内，但查看为了支持这样的前端客户端需要哪些更改是至关重要的。
- en: So far, you have interacted with the services composing the Polar Bookshop system
    through a Terminal window. In this section, we’ll add an Angular application that
    will be the frontend of the system. It will be served by an NGINX container and
    be accessible via the gateway provided by Edge Service. Supporting an SPA will
    require some additional configuration in Spring Security to address concerns like
    Cross-Origin Request Sharing (CORS) and Cross-Site Request Forgery (CSRF). This
    section shows how to do that.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经通过终端窗口与组成Polar Bookshop系统的服务进行了交互。在本节中，我们将添加一个Angular应用，它将成为系统的前端。它将由NGINX容器提供，并通过Edge
    Service提供的网关进行访问。支持SPA需要在Spring Security中进行一些额外的配置，以解决诸如跨源请求共享(CORS)和跨站请求伪造(CSRF)等问题。本节将展示如何进行这些操作。
- en: 11.5.1 Running an Angular application
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 运行Angular应用
- en: The Polar Bookshop system will have an Angular application as the frontend.
    Since this book doesn’t cover frontend technologies and patterns, I have prepared
    one already. We just need to decide how to include it in the Polar Bookshop system.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop系统将使用Angular应用作为前端。由于这本书没有涵盖前端技术和模式，我已经准备了一个。我们只需要决定如何将其包含在Polar
    Bookshop系统中。
- en: One option is to let Edge Service serve the SPA static resources. Spring Boot
    applications serving a frontend usually host the source code in src/main/resources.
    That’s a convenient strategy when using template engines like Thymeleaf, but for
    SPAs like Angular, I prefer keeping the code in a separate module. SPAs have their
    own development, build, and release tools, so having a dedicated folder is cleaner
    and more maintainable. Then you can configure Spring Boot to process the SPA’s
    static resources at build time and include them in the final release.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是让Edge Service提供SPA静态资源。通常，提供前端服务的Spring Boot应用会将源代码托管在src/main/resources中。当使用Thymeleaf等模板引擎时，这是一个方便的策略，但对于像Angular这样的SPA，我更喜欢将代码保存在一个单独的模块中。SPA有其自己的开发、构建和发布工具，因此拥有一个专门的文件夹更干净、更易于维护。然后你可以配置Spring
    Boot在构建时处理SPA的静态资源，并将它们包含在最终发布中。
- en: Another option is to have a dedicated service take care of serving the Angular
    static resources. That’s the strategy we’ll use for Polar Bookshop. I have already
    packaged the Angular application in an NGINX container. NGINX ([https://nginx.org](https://nginx.org))
    provides HTTP server features, and it’s very convenient for serving static resources
    such as the HTML, CSS, and JavaScript files composing the Angular application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是让一个专门的服务来处理Angular静态资源的提供。这就是Polar Bookshop将使用的策略。我已经将Angular应用打包在一个NGINX容器中。NGINX([https://nginx.org](https://nginx.org))提供了HTTP服务器功能，对于提供由HTML、CSS和JavaScript文件组成的Angular应用的静态资源来说非常方便。
- en: Let’s go ahead and run the Polar Bookshop frontend (polar-ui) in Docker. First,
    go to your polar-deployment repository, and open your Docker Compose file (docker/docker-compose.yml).
    Then add the configuration to run polar-ui and expose it through port 9004.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在Docker中运行Polar Bookshop前端（polar-ui）。首先，前往您的polar-deployment仓库，并打开您的Docker
    Compose文件（docker/docker-compose.yml）。然后添加配置以运行polar-ui并通过端口9004暴露它。
- en: Listing 11.12 Running the Angular application as a container
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.12 以容器形式运行Angular应用
- en: '[PRE37]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ The container image I built to package the Angular application
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我构建的用于打包Angular应用的容器镜像
- en: ❷ NGINX will serve the SPA on port 9004.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ NGINX 将在端口 9004 上提供 SPA 服务。
- en: ❸ Configures the NGINX server port
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 配置 NGINX 服务器端口
- en: Like the other applications in the Polar Bookshop system, we don’t want the
    Angular application to be accessible directly from the outside. Instead, we want
    to make it accessible via the gateway provided by Edge Service. We can do that
    by adding a new route for Spring Cloud Gateway to forward any requests for static
    resources to the Polar UI application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Polar Bookshop 系统中的其他应用程序一样，我们不希望 Angular 应用程序可以直接从外部访问。相反，我们希望通过 Edge Service
    提供的网关使其可访问。我们可以通过为 Spring Cloud Gateway 添加一个新的路由来实现这一点，以便将任何对静态资源的请求转发到 Polar
    UI 应用程序。
- en: Go to your Edge Service project (edge-service), open the application.yml file,
    and configure the new route as follows.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 前往您的 Edge Service 项目（edge-service），打开 application.yml 文件，并按以下方式配置新路由。
- en: Listing 11.13 Configuring a new gateway route for the SPA static resources
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 配置 SPA 静态资源的新网关路由
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ The route ID
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 路由 ID
- en: ❷ The URI value comes from an environment variable, or else the specified default.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ URI 值来自环境变量，否则使用指定的默认值。
- en: ❸ The predicate is a list of paths matching the root endpoint and the SPA static
    resources.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言是一个匹配根端点和 SPA 静态资源的路径列表。
- en: The URI for the Polar UI application is computed using the value from an environment
    variable (SPA_URL). If it’s not defined, the default value written after the first
    colon (:) symbol will be used.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Polar UI 应用程序的 URI 是通过环境变量（SPA_URL）的值计算得出的。如果没有定义，则使用第一个冒号（:）符号后面的默认值。
- en: Note When running Edge Service as a container, remember to configure the SPA_URL
    environment variable. On Docker you can use the container name and port as the
    value, resulting in http://polar-ui:9004.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当以容器形式运行 Edge Service 时，请记住配置 SPA_URL 环境变量。在 Docker 中，您可以使用容器名称和端口作为值，结果为
    http://polar-ui:9004。
- en: 'Let’s test it out. First, run the Polar UI container together with Redis and
    Keycloak. Open a Terminal window, navigate to the folder where you keep your Docker
    Compose file (polar-deployment/docker/docker-compose.yml), and run the following
    command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。首先，一起运行 Polar UI 容器、Redis 和 Keycloak。打开一个终端窗口，导航到您保存 Docker Compose
    文件（polar-deployment/docker/docker-compose.yml）的文件夹，并运行以下命令：
- en: '[PRE39]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then build the Edge Service project again, and run the application (./gradlew
    bootRun). Finally, open an incognito browser window and navigate to http://localhost:9000.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次构建 Edge Service 项目，并运行应用程序（./gradlew bootRun）。最后，打开一个无痕浏览器窗口，并导航到 http://localhost:9000。
- en: Spring Security is configured to protect all endpoints and resources, so you’ll
    automatically be redirected to the Keycloak login page. After you authenticate
    as either Isabelle or Bjorn, you’ll be redirected back to the Edge Service root
    endpoint from which the Angular frontend is served.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 被配置为保护所有端点和资源，因此您将自动重定向到 Keycloak 登录页面。在您以 Isabelle 或 Bjorn
    身份进行身份验证后，您将被重定向回提供 Angular 前端的 Edge Service 根端点。
- en: For now, there’s not much you can do. The authentication flow is triggered by
    Spring Security when it receives an unauthenticated request, but it won’t work
    if it’s an AJAX request due to CORS issues. Furthermore, POST requests (including
    the logout operation) will fail due to the CSRF protection enabled by Spring Security.
    In the following sections, I’ll show you how to update the Spring Security configuration
    to overcome those issues.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您能做的事情不多。当 Spring Security 收到未经身份验证的请求时，会触发身份验证流程，但由于 CORS 问题，如果是 AJAX 请求则不会工作。此外，由于
    Spring Security 启用了 CSRF 保护，POST 请求（包括注销操作）将失败。在接下来的章节中，我将向您展示如何更新 Spring Security
    配置以克服这些问题。
- en: Before moving on, stop the application with Ctrl-C (but keep the containers
    running—you’ll need them).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，使用 Ctrl-C 停止应用程序（但保持容器运行——您将需要它们）。
- en: 11.5.2 Controlling the authentication flow
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 控制身份验证流程
- en: In the previous section, you tried accessing the Edge Service homepage and experienced
    being automatically redirected to Keycloak to provide a username and password.
    When the frontend consists of server-rendered pages (such as when using Thymeleaf),
    that behavior works fine, and it’s convenient since it doesn’t require any extra
    configuration. If you’re not authenticated yet, or your session has expired, Spring
    Security will automatically trigger the authentication flow and redirect your
    browser to Keycloak.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你尝试访问 Edge Service 主页，并体验了自动重定向到 Keycloak 以提供用户名和密码的情况。当前端由服务器端渲染的页面组成（例如使用
    Thymeleaf 时），这种行为运行良好，并且很方便，因为它不需要任何额外的配置。如果你尚未认证，或者你的会话已过期，Spring Security 将自动触发认证流程并将你的浏览器重定向到
    Keycloak。
- en: With a single-page application, things work a bit differently. The Angular application
    is returned by the backend when accessing the root endpoint through a standard
    HTTP GET request performed by the browser. After that first step, the SPA interacts
    with the backend through AJAX requests. When the SPA sends an unauthenticated
    AJAX request to a protected endpoint, you don’t want Spring Security to reply
    with an HTTP 302 response redirecting to Keycloak. Instead, you want it to return
    a response with an error status like HTTP 401 Unauthorized.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单页应用，事情的工作方式略有不同。Angular 应用程序是在浏览器通过执行标准 HTTP GET 请求访问根端点时由后端返回的。在此第一步之后，SPA
    通过 AJAX 请求与后端交互。当 SPA 向受保护的端点发送未经认证的 AJAX 请求时，你不希望 Spring Security 返回一个 HTTP 302
    响应重定向到 Keycloak。相反，你希望它返回一个带有错误状态的响应，如 HTTP 401 未授权。
- en: The main reason for not using redirects with SPAs is that you would run into
    Cross-Origin Request Sharing (CORS) issues. Consider the scenario where an SPA
    is served from https://client.polarbookshop.com and makes HTTP calls through AJAX
    to a backend at https://server.polarbookshop.com. The communication is blocked
    because the two URLs don’t have the same origin (the same protocol, domain, and
    port). That’s the standard same-origin policy enforced by all web browsers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用重定向与单页应用（SPAs）结合使用的主要原因是你可能会遇到跨源请求共享（CORS）问题。考虑以下场景：一个 SPA 从 https://client.polarbookshop.com
    提供服务，并通过 AJAX 向 https://server.polarbookshop.com 的后端进行 HTTP 调用。由于这两个 URL 没有相同的源（相同的协议、域名和端口），通信被阻止。这是所有网络浏览器强制执行的标准的同源策略。
- en: CORS is a mechanism for allowing a server to accept HTTP calls through AJAX
    from a browser-based client like an SPA, even if the two have different origins.
    In Polar Bookshop, we serve the Angular frontend via the gateway implemented in
    Edge Service (same origin). Therefore, there aren’t any CORS issues between these
    two components. However, suppose Spring Security is configured to reply to an
    unauthenticated AJAX call with a redirect to Keycloak (having a different origin).
    In that case, the request will be blocked because redirects to different origins
    are not permitted during AJAX requests.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 是一种机制，允许服务器接受来自基于浏览器的客户端（如 SPA）的 AJAX HTTP 调用，即使这两个客户端有不同的源。在 Polar Bookshop
    中，我们通过 Edge Service 中实现的网关提供 Angular 前端（相同源）。因此，这两个组件之间没有 CORS 问题。然而，如果 Spring
    Security 被配置为对未经认证的 AJAX 调用返回重定向到 Keycloak（具有不同的源），则请求将被阻止，因为在 AJAX 请求期间不允许重定向到不同的源。
- en: Note To learn more about CORS in Spring Security, you can check out chapter
    10 of *Spring Security in Action* by Laurențiu Spilcă (Manning, 2020), where the
    subject is explained in great detail. For a comprehensive explanation of CORS,
    see *CORS in Action* by Monsur Hossain (Manning, 2014).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解更多关于 Spring Security 中 CORS 的信息，你可以查看 Laurențiu Spilcă 所著的 *Spring Security
    in Action*（Manning，2020）的第 10 章，其中详细解释了该主题。对于 CORS 的全面解释，请参阅 Monsur Hossain 所著的
    *CORS in Action*（Manning，2014）。
- en: 'When changing the Spring Security configuration to reply with an HTTP 401 response
    to unauthenticated requests, it’s up to the SPA to handle the error and call the
    backend to initiate the authentication flow. Redirects are only a problem during
    AJAX requests. The crucial part here is that the call to the backend to start
    the user authentication is not an AJAX request sent by Angular. Instead, it’s
    a standard HTTP call sent from the browser, like the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 Spring Security 配置更改为对未经认证的请求返回 HTTP 401 响应时，处理错误并调用后端以启动认证流程的责任就落在 SPA 身上。重定向仅在
    AJAX 请求期间是问题。这里的关键部分是调用后端以启动用户认证的调用不是 Angular 发送的 AJAX 请求。相反，它是一个来自浏览器的标准 HTTP
    调用，如下所示：
- en: '[PRE40]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I’d like to stress that the login call is not an AJAX request sent from the
    Angular HttpClient. Instead, it instructs the browser to call the login URL. Spring
    Security exposes an /oauth2/authorization/{registrationId} endpoint that you can
    use to start the authentication flow based on OAuth2/OIDC. Since the client registration
    identifier for Edge Service is keycloak, the login endpoint will be /oauth2/authorization/
    keycloak.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调，登录调用不是从Angular HttpClient发送的AJAX请求。相反，它指示浏览器调用登录URL。Spring Security公开了一个/oauth2/authorization/{registrationId}端点，您可以使用它根据OAuth2/OIDC启动身份验证流程。由于Edge服务的客户端注册标识符是keycloak，因此登录端点将是/oauth2/authorization/keycloak。
- en: To make that possible, we need to define a custom AuthenticationEntryPoint to
    instruct Spring Security to reply with an HTTP 401 status when an unauthenticated
    request is received for a protected resource. The framework already provides an
    HttpStatusServerEntryPoint implementation that perfectly suits this scenario,
    since it lets you specify which HTTP status to return when a user is required
    to authenticate.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要定义一个自定义AuthenticationEntryPoint来指示Spring Security在收到对受保护资源的未认证请求时回复HTTP
    401状态。框架已经提供了一个HttpStatusServerEntryPoint实现，它非常适合这个场景，因为它允许您指定在用户需要认证时返回哪个HTTP状态。
- en: Listing 11.14 Returning 401 when the user is not authenticated
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.14 当用户未认证时返回401
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ When an exception is thrown because a user is not authenticated, it replies
    with an HTTP 401 response.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当由于用户未认证而抛出异常时，它回复一个HTTP 401响应。
- en: At this point, the Angular application can explicitly intercept HTTP 401 responses
    and trigger the authentication flow. However, since the SPA is now in charge of
    starting the flow, we need to permit unauthenticated access to its static resources.
    We would also like to retrieve the books in the catalog without being authenticated,
    so let’s permit GET requests to the /books/** endpoints as well. Go ahead and
    update the SecurityWebFilterChain bean in the SecurityConfig class as follows.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Angular应用程序可以明确拦截HTTP 401响应并触发身份验证流程。然而，由于SPA现在负责启动流程，我们需要允许对其静态资源的未认证访问。我们还想在不进行认证的情况下检索目录中的书籍，因此让我们允许对/books/**端点的GET请求。请更新SecurityConfig类中的SecurityWebFilterChain
    bean，如下所示。
- en: Listing 11.15 Allowing unauthenticated GET requests to SPA and books
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.15 允许未认证的GET请求访问SPA和书籍
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Allows unauthenticated access to the SPA static resources
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许未认证访问SPA静态资源
- en: ❷ Allows unauthenticated read access to the books in the catalog
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许未认证读取访问目录中的书籍
- en: ❸ Any other request requires user authentication.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 其他任何请求都需要用户认证。
- en: Let’s test how Edge Service works now. Ensure that the Polar UI, Redis, and
    Keycloak containers are still running. Next, build and run the Edge Service application
    (./gradlew bootRun), and then go to http://localhost:9000 from an incognito browser
    window. The first thing to notice is that you don’t get redirected to the login
    page but are presented with the Angular frontend application immediately. You
    can start the authentication flow by clicking the Login button in the upper-right
    menu.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下Edge Service现在的工作情况。确保Polar UI、Redis和Keycloak容器仍在运行。接下来，构建并运行Edge Service应用程序（./gradlew
    bootRun），然后从一个隐身浏览器窗口中访问http://localhost:9000。首先要注意的是，您不会重定向到登录页面，而是立即显示Angular前端应用程序。您可以通过点击右上角的登录按钮开始身份验证流程。
- en: After logging in, the upper-right menu will contain a Logout button, which is
    only shown if the current user is successfully authenticated. Click the button
    to log out. It should trigger the logout flow, but it won’t work due to CSRF issues.
    You’ll learn how to fix that in the next section. In the meantime, stop the application
    with Ctrl-C.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，右上角菜单将包含一个注销按钮，只有当当前用户成功认证时才会显示。点击按钮注销。它应该触发注销流程，但由于CSRF问题而无法工作。您将在下一节中学习如何修复它。同时，使用Ctrl-C停止应用程序。
- en: 11.5.3 Protecting against Cross-Site Request Forgery
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 防止跨站请求伪造
- en: The interaction between the frontend and backend is based on a session cookie.
    After the user is successfully authenticated with the OIDC/OAuth2 strategy, Spring
    will generate a session identifier to match the authenticated context and send
    it to the browser as a cookie. Any subsequent request to the backend will have
    to contain the session cookie, from which Spring Security can retrieve the tokens
    associated with the specific user and validate the request.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端的交互基于会话 cookie。用户成功通过 OIDC/OAuth2 策略认证后，Spring 将生成一个会话标识符以匹配认证上下文，并将其作为
    cookie 发送到浏览器。任何随后的对后端的请求都必须包含会话 cookie，Spring Security 可以从中检索与特定用户关联的令牌并验证请求。
- en: However, session cookies are not enough to validate requests, which are vulnerable
    to Cross-Site Request Forgery (CSRF) attacks. CSRF affects *modifying* HTTP requests
    like POST, PUT, and DELETE. An attacker could induce users to perform requests
    they didn’t intend by forging a request meant to cause harm. Forged requests could
    do things like transfer money from your bank account or compromise critical data.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，会话 cookie 并不足以验证请求，这些请求容易受到跨站请求伪造（CSRF）攻击的影响。CSRF 影响修改 HTTP 请求，如 POST、PUT
    和 DELETE。攻击者可能诱导用户执行他们无意为之的请求，伪造的请求可能造成诸如从您的银行账户转账或损害关键数据等后果。
- en: Warning Many online tutorials and guides show how to disable the CSRF protection
    as the first thing when configuring Spring Security. That’s dangerous to do without
    explaining the reasoning or considering the consequences. I recommend keeping
    the protection enabled unless there’s a good reason not to (you’ll see one good
    reason in chapter 12). As a general guideline, browser-facing applications like
    Edge Service should be protected against CSRF attacks.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：许多在线教程和指南在配置 Spring Security 时首先展示如何禁用 CSRF 保护。如果不解释原因或考虑后果，这样做是危险的。我建议除非有充分的理由不启用保护（您将在第
    12 章中看到一个很好的理由），否则请保持保护启用状态。作为一个一般性指南，面向浏览器的应用程序，如 Edge Service，应该受到 CSRF 攻击的保护。
- en: Fortunately, Spring Security has built-in protection against such attacks. The
    protection is based on a so-called CSRF token generated by the framework that’s
    provided to the client at the beginning of the session and required to be sent
    along with any state-changing requests.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Spring Security 内置了对这种攻击的保护。这种保护基于框架生成的所谓 CSRF 令牌，该令牌在会话开始时提供给客户端，并要求与任何更改状态的请求一起发送。
- en: Note To learn more about CSRF protection in Spring Security, you can check out
    chapter 10 of *Spring Security in Action* by Laurențiu Spilcă (Manning, 2020),
    where the subject is explained in great detail.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解更多关于 Spring Security 中 CSRF 保护的信息，您可以查看 Laurențiu Spilcă 所著的 *Spring Security
    in Action* 一书的第 10 章（Manning，2020年），其中详细解释了该主题。
- en: In the previous section, you tried to log out, but the request failed. Since
    the logout operation is available through a POST request to the /logout endpoint,
    the application expects to receive the CSRF token generated by Spring Security
    for that user session. By default, the generated CSRF token is sent to the browser
    as an HTTP header. However, Angular applications cannot work with that and expect
    to receive the token value as a cookie. Spring Security supports this specific
    requirement, but it’s not enabled by default.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您尝试注销，但请求失败了。由于注销操作是通过向 /logout 端点发送 POST 请求来提供的，应用程序期望接收 Spring Security
    为该用户会话生成的 CSRF 令牌。默认情况下，生成的 CSRF 令牌作为 HTTP 头发送到浏览器。然而，Angular 应用程序无法与这种做法协同工作，并期望接收作为
    cookie 的令牌值。Spring Security 支持这一特定要求，但默认情况下并未启用。
- en: You can instruct Spring Security to provide CSRF tokens as cookies through the
    csrf() DSL exposed by ServerHttpSecurity and the CookieServerCsrfTokenRepository
    class. For imperative applications, that would be enough. However, for reactive
    applications like Edge Service, you need to take an extra step to ensure the CsrfToken
    value is actually provided.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指导 Spring Security 通过 ServerHttpSecurity 和 CookieServerCsrfTokenRepository
    类提供的 csrf() DSL 将 CSRF 令牌作为 cookies 提供给客户端。对于命令式应用程序，这已经足够了。然而，对于像 Edge Service
    这样的反应式应用程序，您需要额外采取一步来确保 CsrfToken 值确实被提供。
- en: 'In chapter 8, you learned that reactive streams need to be subscribed to in
    order to activate them. At the moment, CookieServerCsrfTokenRepository doesn’t
    ensure a subscription to CsrfToken, so you must explicitly provide a workaround
    in a WebFilter bean. This problem should be solved in future versions of Spring
    Security (see issue 5766 on GitHub: [https://mng.bz/XW89](https://mng.bz/XW89)).
    For now, update the SecurityConfig class as follows.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，你了解到需要订阅反应式流才能激活它们。目前，CookieServerCsrfTokenRepository 没有确保对 CsrfToken
    的订阅，因此你必须显式地在 WebFilter bean 中提供一个解决方案。这个问题应该在 Spring Security 的未来版本中得到解决（请参阅
    GitHub 上的问题 5766：[https://mng.bz/XW89](https://mng.bz/XW89)）。目前，请按以下方式更新 SecurityConfig
    类。
- en: Listing 11.16 Configuring CSRF to support a cookie-based strategy for SPAs
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.16 配置 CSRF 以支持基于 cookie 的策略用于单页应用（SPAs）
- en: '[PRE43]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Uses a cookie-based strategy for exchanging CSRF tokens with the Angular frontend
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用基于 cookie 的策略与 Angular 前端交换 CSRF 令牌
- en: ❷ A filter with the only purpose of subscribing to the CsrfToken reactive stream
    and ensuring its value is extracted correctly
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 具有仅订阅 CsrfToken 反应式流并确保其值正确提取的唯一目的的过滤器
- en: Let’s verify that the logout flow works now. Ensure that the Polar UI, Redis,
    and Keycloak containers are still up and running. Next, build and run the application
    (./gradlew bootRun), and then go to http://localhost:9000 from an incognito browser
    window. Start the authentication flow by clicking the Login button from the upper-right
    menu. Then click the Logout button. Under the hood, Spring Security will now accept
    your logout request (Angular adds the CSRF token value from the cookie as an HTTP
    header), terminate your web session, propagate the request to Keycloak, and finally
    redirect you to the homepage, unauthenticated.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证登出流程现在是否工作。确保 Polar UI、Redis 和 Keycloak 容器仍在运行。接下来，构建并运行应用程序（./gradlew
    bootRun），然后从隐身浏览器窗口访问 http://localhost:9000。通过点击右上角的登录按钮开始身份验证流程。然后点击登出按钮。在底层，Spring
    Security 现在将接受你的登出请求（Angular 将 CSRF 令牌值从 cookie 作为 HTTP 头部添加），终止你的网络会话，将请求传播到
    Keycloak，并最终将你重定向到主页，未认证。
- en: Thanks to this change, you can also perform any POST, PUT, and DELETE requests
    without receiving a CSRF error. Feel free to explore the Angular application.
    If you start up Catalog Service and Order Service, you can try adding new books
    to the catalog, modifying them, or placing an order.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个改动，你现在也可以执行任何 POST、PUT 和 DELETE 请求，而不会收到 CSRF 错误。请随意探索 Angular 应用程序。如果你启动了目录服务和订单服务，你可以尝试向目录添加新书、修改它们或下订单。
- en: Both Isabelle and Bjorn can perform any action at the moment, which is not what
    we want, since customers (like Bjorn) shouldn’t be allowed to manage the book
    catalog. The next chapter will cover authorization, and you’ll see how to protect
    each endpoint with different access policies. Before addressing authorization,
    though, we need to write autotests to cover the new functionality. That’s coming
    up in the next section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Isabelle 和 Bjorn 可以执行任何操作，这不是我们想要的，因为客户（如 Bjorn）不应被允许管理图书目录。下一章将介绍授权，你将看到如何使用不同的访问策略保护每个端点。然而，在处理授权之前，我们需要编写
    autotests 来覆盖新的功能。这将在下一节中介绍。
- en: Before moving on, stop the application with Ctrl-C and all the containers with
    docker-compose down (from polar-deployment/docker).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，使用 Ctrl-C 停止应用程序，并使用 docker-compose down 停止所有容器（从 polar-deployment/docker）。
- en: 11.6 Testing Spring Security and OpenID Connect
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 测试 Spring Security 和 OpenID Connect
- en: The importance of writing autotests is usually apparent to developers. Still,
    things can get challenging when it comes to security, and it sometimes ends up
    not being covered by automated tests because of its complexity. Fortunately, Spring
    Security provides several utilities to help you include security in your slice
    and integration tests in a simple way.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自动测试的重要性通常对开发者来说很明显。然而，当涉及到安全性时，事情可能会变得具有挑战性，并且由于其复杂性，有时它最终没有被自动化测试覆盖。幸运的是，Spring
    Security 提供了几个实用工具，以帮助您以简单的方式将安全性包含在您的切片和集成测试中。
- en: In this section, you’ll learn how to use the WebTestClient support for Spring
    Security to test OIDC authentication and CSRF protection. Let’s get started.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 Spring Security 的 WebTestClient 支持来测试 OIDC 认证和 CSRF 保护。让我们开始吧。
- en: 11.6.1 Testing OIDC authentication
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.1 测试 OIDC 认证
- en: In chapter 8, we tested REST controllers exposed by Spring WebFlux by relying
    on the @SpringWebFlux annotation and WebTestClient. In this chapter, we added
    a new controller (UserController), so let’s write some autotests for it with different
    security setups.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们通过依赖@SpringWebFlux注解和WebTestClient测试了Spring WebFlux暴露的REST控制器。在本章中，我们添加了一个新的控制器（UserController），因此让我们为它编写一些不同安全设置下的自动测试。
- en: 'First of all, open your Edge Service project, create a UserControllerTests
    class annotated with @WebFluxTest(UserController.class) in src/test/java, and
    autowire a WebTestClient bean. So far, the setup is similar to what we used in
    chapter 8: a slice test for the web layer. But we need some extra setup to cover
    security scenarios, as shown in the following listing.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开您的Edge Service项目，在src/test/java中创建一个带有@WebFluxTest(UserController.class)注解的UserControllerTests类，并自动装配一个WebTestClient
    Bean。到目前为止，设置与第8章中使用的类似：一个针对Web层的切片测试。但是，我们需要一些额外的设置来覆盖安全场景，如下所示。
- en: Listing 11.17 Defining a class to test the security policies for UserController
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.17 定义一个类来测试UserController的安全策略
- en: '[PRE44]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Imports the application’s security configuration
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入应用程序的安全配置
- en: ❷ A mock bean to skip the interaction with Keycloak when retrieving information
    about the Client registration
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个模拟的Bean，用于在检索客户端注册信息时跳过与Keycloak的交互
- en: 'Since we configured Edge Service to return an HTTP 401 response when a request
    is unauthenticated, let’s verify that happens when calling the /user endpoint
    without authenticating first:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将Edge Service配置为在请求未认证时返回HTTP 401响应，因此让我们验证在调用/user端点之前未进行认证时会发生这种情况：
- en: '[PRE45]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To test the scenario where a user is authenticated, we can use mockOidcLogin(),
    a configuration object supplied by SecurityMockServerConfigurers to mock an OIDC
    login, synthesize an ID Token, and mutate the request context in WebTestClient
    accordingly.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试用户已认证的场景，我们可以使用SecurityMockServerConfigurers提供的mockOidcLogin()配置对象来模拟OIDC登录，合成一个ID
    Token，并相应地修改WebTestClient的请求上下文。
- en: 'The /user endpoint reads claims from the ID Token through the OidcUser object,
    so we need to build an ID Token with username, first name, and last name (the
    roles are hardcoded in the controller for now). The following code shows how to
    do that:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: /user端点通过OidcUser对象从ID Token中读取声明，因此我们需要构建一个包含用户名、名和姓的ID Token（目前控制器中的角色是硬编码的）。以下代码展示了如何实现这一点：
- en: '[PRE46]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ The expected authenticated user
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预期的已认证用户
- en: ❷ Defines an authentication context based on OIDC and uses the expected user
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 基于OIDC定义一个认证上下文并使用预期的用户
- en: ❸ Expects a User object with the same information as the currently authenticated
    user
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 期望一个与当前已认证用户信息相同的User对象
- en: ❹ Builds a mock ID Token
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 构建一个模拟的ID Token
- en: 'Finally, run the tests as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式运行测试：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The testing utilities supplied by Spring Security cover a wide array of scenarios
    and integrate well with WebTestClient. In the next section, you’ll see how to
    test CSRF protection using a similar approach.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供的测试实用工具覆盖了广泛的场景，并且与WebTestClient很好地集成。在下一节中，您将看到如何使用类似的方法来测试CSRF保护。
- en: 11.6.2 Testing CSRF
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.2 测试CSRF
- en: In Spring Security, CSRF protection applies to all mutating HTTP requests by
    default (such as POST, PUT, and DELETE). As you saw in previous sections, Edge
    Service accepts POST requests to the /logout endpoint to initiate the logout flow,
    and such requests require a valid CSRF token to be executed. Furthermore, we configured
    the RP-Initiated Logout feature from OIDC, so a POST request to /logout will actually
    result in an HTTP 302 response, redirecting the browser to Keycloak to also log
    the user out of there.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中，CSRF保护默认应用于所有修改性HTTP请求（如POST、PUT和DELETE）。正如您在前面章节中看到的，Edge
    Service接受对/logout端点的POST请求以启动注销流程，此类请求需要有效的CSRF令牌才能执行。此外，我们还配置了OIDC的RP-Initiated
    Logout功能，因此对/logout的POST请求实际上会导致HTTP 302响应，将浏览器重定向到Keycloak以注销用户。
- en: Create a new SecurityConfigTests class and use the same strategy you learned
    in the previous section to set up a Spring WebFlux test with security support,
    as shown in the following listing.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的SecurityConfigTests类，并使用您在上一节中学到的相同策略来设置一个带有安全支持的Spring WebFlux测试，如下所示。
- en: Listing 11.18 Defining a class for testing the authentication flow
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.18 定义一个用于测试认证流程的类
- en: '[PRE48]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Imports the application security configuration
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入应用程序的安全配置
- en: ❷ A mock bean to skip the interaction with Keycloak when retrieving information
    about the Client registration
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个模拟的Bean，用于在检索客户端注册信息时跳过与Keycloak的交互
- en: Then add a test case to check whether the application returns an HTTP 302 response
    after sending an HTTP POST request to the /logout with the correct OIDC login
    and CSRF context.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一个测试用例来检查在向 /logout 发送带有正确 OIDC 登录和 CSRF 上下文的 HTTP POST 请求后，应用程序是否返回 HTTP
    302 响应。
- en: '[PRE49]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Uses a mock ID Token to authenticate the user
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用模拟的 ID Token 来验证用户
- en: ❷ Enhances the request to provide the required CSRF token
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 增强请求以提供所需的 CSRF 令牌
- en: ❸ The response is a redirect to Keycloak to propagate the logout operation.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 响应是重定向到 Keycloak 以传播注销操作。
- en: ❹ A mock ClientRegistration used by Spring Security to get the URLs to contact
    Keycloak
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Spring Security 使用的模拟 ClientRegistration 来获取联系 Keycloak 的 URL
- en: 'Finally, run the tests as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式运行测试：
- en: '[PRE50]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As always, you can find more test examples in the source code repository accompanying
    this book. When it comes to security, unit and integration tests are critical
    for ensuring the correctness of an application, but they are not enough. Those
    tests cover the default security configuration, which might be different in production.
    That’s why we also need security-oriented autotests in the acceptance stage of
    the deployment pipeline (as explained in chapter 3), to test applications deployed
    in a production-like environment.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 总是可以在本书附带的源代码仓库中找到更多测试示例。当涉及到安全问题时，单元测试和集成测试对于确保应用程序的正确性至关重要，但它们并不足够。这些测试覆盖了默认的安全配置，而在生产环境中可能有所不同。这就是为什么我们还需要在部署管道的验收阶段进行以安全为导向的自动测试（如第
    3 章所述），以测试在类似生产环境中部署的应用程序。
- en: Polar Labs
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Until now, the only application supposed to be accessed by users directly was
    Edge Service. All the other Spring Boot applications interact with each other
    from within the environment where they are deployed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一一个用户可以直接访问的应用程序是 Edge 服务。所有其他 Spring Boot 应用程序都从它们部署的环境内部相互交互。
- en: Service-to-service interactions within the same Docker network or Kubernetes
    cluster can be configured using the container name or the Service name respectively.
    For example, Edge Service forwards requests to Polar UI via the http://polar-ui:9004
    URL on Docker (<container-name>:<container-port>) and via the http://polar-ui
    URL on Kubernetes (Service name).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一 Docker 网络或 Kubernetes 集群内的服务间交互可以通过容器名称或服务名称分别配置。例如，Edge 服务通过 Docker 上的
    http://polar-ui:9004 URL（<容器名称>:<容器端口>）和 Kubernetes 上的 http://polar-ui URL（服务名称）将请求转发到
    Polar UI。
- en: Keycloak is different because it’s involved in service-to-service interactions
    (for now, those are just interactions with Edge Service) and also interactions
    with end users via the web browser. In production, Keycloak will be accessible
    via a public URL that both applications and users will use, so there will be no
    problem. How about in local environments?
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 与其他不同，因为它涉及到服务间交互（目前只是与 Edge 服务的交互）以及通过网页浏览器与最终用户的交互。在生产环境中，Keycloak
    将通过一个公开的 URL 可用，该 URL 供应用程序和用户使用，因此不会有问题。那么在本地环境中呢？
- en: Since we don’t deal with public URLs when working locally, we need to configure
    things differently. On Docker, we can solve the problem by using the http://host
    .docker.internal special URL configured automatically when installing the software.
    It resolves to your localhost IP address and can be used both within a Docker
    network and outside.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本地工作时并不处理公开的 URL，我们需要进行不同的配置。在 Docker 上，我们可以通过使用在安装软件时自动配置的特殊 URL http://host.docker.internal
    来解决这个问题。它解析为您的本地主机 IP 地址，并且可以在 Docker 网络外部和内部使用。
- en: On Kubernetes, we don’t have a generic URL to let Pods within a cluster access
    your local host. That means Edge Service will interact with Keycloak via its Service
    name (http://polar-keycloak). When Spring Security redirects a user to Keycloak
    to log in, the browser will return an error because the http://polar-keycloak
    URL cannot be resolved outside the cluster. To make that possible, we can update
    the local DNS configuration to resolve the polar-keycloak hostname to the cluster
    IP address. Then a dedicated Ingress will make it possible to access Keycloak
    when requests are directed to the polar-keycloak hostname.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上，我们没有通用的 URL 来让集群内的 Pods 访问本地主机。这意味着 Edge 服务将通过其服务名称（http://polar-keycloak）与
    Keycloak 交互。当 Spring Security 将用户重定向到 Keycloak 进行登录时，浏览器将返回一个错误，因为 http://polar-keycloak
    URL 无法在集群外部解析。为了实现这一点，我们可以更新本地 DNS 配置，将 polar-keycloak 主机名解析为集群 IP 地址。然后，一个专门的
    Ingress 将使得在请求被定向到 polar-keycloak 主机名时可以访问 Keycloak。
- en: 'If you’re on Linux or macOS, you can map the polar-keycloak hostname to the
    minikube local IP address in the /etc/hosts file. On Linux, the IP address is
    the one returned by the minikube ip --profile polar command (as explained in chapter
    9). On macOS, it’s going to be 127.0.0.1. Open a Terminal window, and run the
    following command (make sure you replace the <ip-address> placeholder with the
    cluster IP address, depending on your operating system):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Linux或macOS，你可以在/etc/hosts文件中将polar-keycloak主机名映射到minikube本地IP地址。在Linux上，IP地址是minikube
    ip --profile polar命令返回的IP地址（如第9章所述）。在macOS上，它将是127.0.0.1。打开终端窗口，并运行以下命令（确保用你的操作系统根据操作系统替换<ip-address>占位符，集群IP地址）：
- en: '[PRE51]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'On Windows you must map the polar-keycloak hostname to 127.0.0.1 in the hosts
    file. Open a PowerShell window as an administrator, and run the following command:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你必须将polar-keycloak主机名映射到hosts文件中的127.0.0.1。以管理员身份打开PowerShell窗口，并运行以下命令：
- en: '[PRE52]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: I have updated the scripts for deploying all the backing services for Polar
    Bookshop, including Keycloak and Polar UI. You can get them from the /Chapter11/11-end/polar-deployment/kubernetes/platform/development
    folder in the code repository accompanying the book ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))
    and copy them into the same path in your polar-deployment repository. The deployment
    also includes the configuration of a dedicated Ingress for Keycloak, accepting
    requests directed to the polar-keycloak hostname.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我已更新了部署Polar Bookshop所有支持服务的脚本，包括Keycloak和Polar UI。你可以从书中附带的代码仓库的/Chapter11/11-end/polar-deployment/kubernetes/platform/development文件夹中获取它们（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)），并将它们复制到你的polar-deployment仓库中的相同路径。部署还包括为Keycloak配置专用Ingress，接受指向polar-keycloak主机名的请求。
- en: At this point you can run the ./create-cluster.sh script (polar-deployment/kubernetes/platform/development)
    to start a minikube cluster and deploy all the backing services for Polar Bookshop.
    If you’re on Linux, you’ll be able to access Keycloak directly. If you’re on macOS
    or Windows, remember to run the minikube tunnel --profile polar command first.
    Either way, you can open a browser window and access Keycloak at polar-keycloak/
    (include the final slash).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以运行./create-cluster.sh脚本（polar-deployment/kubernetes/platform/development）来启动一个minikube集群并部署Polar
    Bookshop的所有支持服务。如果你使用Linux，你将能够直接访问Keycloak。如果你使用macOS或Windows，请记住首先运行minikube
    tunnel --profile polar命令。无论哪种方式，你都可以打开一个浏览器窗口，并在polar-keycloak/（包括最后的斜杠）访问Keycloak。
- en: Finally, try running the entire system on Kubernetes after updating the deployment
    scripts for Edge Service to configure the URLs for Polar UI and Keycloak. You
    can refer to the Chapter11/11-end folder in the code repository accompanying the
    book to check the final result ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在更新Edge Service的部署脚本以配置Polar UI和Keycloak的URL之后，尝试在Kubernetes上运行整个系统。你可以参考书中附带的代码仓库中的Chapter11/11-end文件夹以检查最终结果（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: The next chapter will expand on the subject of security. It will cover how to
    propagate the authentication context from Edge Service to the downstream applications,
    and how to configure authorization.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将扩展关于安全性的主题。它将涵盖如何从Edge Service传播身份验证上下文到下游应用程序，以及如何配置授权。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Access control systems require identification (who are you?), authentication
    (can you prove it’s really you?), and authorization (what are you allowed to do?).
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制系统需要识别（你是谁？），身份验证（你能证明是你自己吗？），以及授权（你被允许做什么？）。
- en: A common strategy for implementing authentication and authorization in cloud
    native applications is based on JWT as the data format, OAuth2 as the authorization
    framework, and OpenID Connect as the authentication protocol.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云原生应用中实现身份验证和授权的常见策略是基于JWT作为数据格式，OAuth2作为授权框架，以及OpenID Connect作为身份验证协议。
- en: When using OIDC authentication, a Client application initiates the flow and
    delegates an Authorization Server for the actual authentication. Then the Authorization
    Server issues an ID Token to the Client.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用OIDC身份验证时，客户端应用程序启动流程并将实际身份验证的授权服务器委托给授权服务器。然后授权服务器向客户端颁发ID令牌。
- en: The ID Token includes information about the user authentication.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID令牌包含有关用户身份验证的信息。
- en: Keycloak is an identity and access management solution that supports OAuth2
    and OpenID Connect and can be used as an Authorization Server.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keycloak 是一个支持 OAuth2 和 OpenID Connect 的身份和访问管理解决方案，可以用作授权服务器。
- en: Spring Security provides native support for OAuth2 and OpenID Connect, and you
    can use it to turn Spring Boot applications into OAuth2 Clients.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 提供了对 OAuth2 和 OpenID Connect 的原生支持，你可以用它将 Spring Boot 应用程序转换为
    OAuth2 客户端。
- en: In Spring Security, you can configure both authentication and authorization
    in a SecurityWebFilterChain bean. To enable the OIDC authentication flow, you
    can use the oauth2Login() DSL.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring Security 中，你可以在 SecurityWebFilterChain 实例中配置认证和授权。要启用 OIDC 认证流程，你可以使用
    oauth2Login() DSL。
- en: By default, Spring Security exposes a /logout endpoint for logging a user out.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Security 提供了一个 /logout 端点用于用户登出。
- en: In an OIDC/OAuth2 context, we also need to propagate the logout request to the
    Authorization Server (such as Keycloak) to log the user out of there. We can do
    that via the RP-Initiated Logout flow supported by Spring Security via the OidcClientInitiatedServerLogoutSuccessHandler
    class.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OIDC/OAuth2 的上下文中，我们还需要将登出请求传播到授权服务器（如 Keycloak），以从那里登出用户。我们可以通过 Spring Security
    提供的 OidcClientInitiatedServerLogoutSuccessHandler 类支持的 RP-Initiated Logout 流程来实现这一点。
- en: When a secure Spring Boot application is the backend for an SPA, we need to
    configure CSRF protection through cookies and implement an authentication entry
    point that returns an HTTP 401 response when a request is not authenticated (as
    opposed to the default HTTP 302 response redirecting to the Authorization Server
    automatically).
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个安全的 Spring Boot 应用程序作为单页应用（SPA）的后端时，我们需要通过 cookies 配置 CSRF 保护，并实现一个认证入口点，当请求未认证时返回
    HTTP 401 响应（而不是默认的 HTTP 302 响应自动重定向到授权服务器）。
- en: The Spring Security Test dependency supplies several convenient utilities for
    testing security.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 测试依赖提供了几个方便的实用工具用于安全测试。
- en: The WebTestClient bean can be enhanced by mutating its request context through
    a particular configuration for OIDC login and CSRF protection.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebTestClient 实例可以通过特定的配置来增强其请求上下文，以支持 OIDC 登录和 CSRF 保护。
