- en: 16 Organizing and modularizing your code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 组织和模块化你的代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the concept of environments to managed dependencies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍环境概念以管理依赖项
- en: Adding and removing package dependencies using environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境添加和删除包依赖项
- en: Developing code in different environments and switching between them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同环境中开发代码并在它们之间切换
- en: Creating a Julia package and adding dependencies to it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Julia包并向其中添加依赖项
- en: Organizing code within a package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包内组织代码
- en: Adding tests to packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向包中添加测试
- en: Exploring the relationship between modules and packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模块和包之间的关系
- en: For large-scale software development you cannot dump code ad hoc into Julia
    source code files as has been shown in previous chapters. Instead, code must be
    modularized and organized. Organized code is easier to understand and navigate.
    In this chapter, you will learn how to take the geometry code you worked on earlier
    and organize it into a Julia package.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大规模软件开发，你不能像前几章所展示的那样随意地将代码直接放入Julia源代码文件中。相反，代码必须进行模块化和组织。组织良好的代码更容易理解和导航。在本章中，你将学习如何将之前工作的几何代码组织成一个Julia包。
- en: Packages are useful because they give you a way of bundling related code, distributing
    it, and version controlling it. Packages can depend on other packages in elaborate
    dependency trees. Real-world systems are built by combining numerous packages
    into one larger system. If you were working in a large organization on a wide-ranging
    project, then different teams would likely make different packages, which would
    then be combined to create the complete system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 包很有用，因为它们为你提供了一种捆绑相关代码、分发它和进行版本控制的方法。包可以在复杂的依赖树中依赖于其他包。现实世界系统是通过将多个包组合成一个更大的系统来构建的。如果你在一个大型组织中的广泛项目中工作，那么不同的团队可能会创建不同的包，然后这些包将被组合起来以创建完整的系统。
- en: In this chapter, I will teach you to organize code within a package, add and
    remove dependencies to other packages, and set up tests for your package. Remember
    to load modules with statements such as using Statistics and using LinearAlgebra.
    I will also explain how the *module* concept relates to the package concept.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将教你如何在包内组织代码，向其他包添加和删除依赖项，并为你的包设置测试。请记住使用如using Statistics和using LinearAlgebra之类的语句加载模块。我还会解释*模块*概念与包概念之间的关系。
- en: 16.1 Setting up a work environment
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 设置工作环境
- en: When developing software, you may want to use different versions of the same
    packages. While developing Julia code for your workplace, you may want to use
    the most stable and well-tested version of each package; this might not be as
    crucial for your hobby projects, and you may prefer instead to use the most recent
    versions with the latest cool features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，你可能希望使用相同包的不同版本。当你为工作场所编写Julia代码时，你可能希望使用每个包最稳定和经过充分测试的版本；这可能对你的业余项目不是那么关键，你可能更愿意使用带有最新酷炫功能的最新版本。
- en: 'Julia environments let you switch between a *job* and a *hobby* environment
    setup with different package versions. I am using the word *job* instead of *work*
    to avoid confusing it with a working directory, which refers to the directory
    you are currently working in. In this section you will look at the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Julia环境允许你在具有不同包版本的*工作*和*业余*环境设置之间切换。我使用*工作*这个词而不是*工作*，以避免与工作目录混淆，工作目录指的是你当前正在工作的目录。在本节中，你将查看以下内容：
- en: Creating environments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建环境
- en: Adding and removing different package versions to and from an environment
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向环境中添加和删除不同版本的包
- en: Activating and switching between different environments
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活和在不同环境之间切换
- en: Understanding the relationship between a module and a package
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块和包之间的关系
- en: 'Creating environments is just a matter of creating a directory to hold each
    environment. In this example, I will start Julia and go into shell mode by pressing
    ;, and then I will issue Unix shell commands to create directories. Using a graphical
    file manager, such as Finder or File Explorer, is a perfectly valid alternative
    approach:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境只是创建一个目录来存放每个环境的事情。在这个例子中，我将启动Julia并进入shell模式，通过按;键，然后我将发出Unix shell命令来创建目录。使用图形文件管理器，如Finder或文件资源管理器，是完全有效的替代方法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Make job and hobby directories.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建工作和业余目录。
- en: ❷ List current directory contents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 列出当前目录内容。
- en: 'Remember, in the Julia REPL you enter package mode by pressing ]. In package
    mode you can execute commands to activate different environments and add packages
    to them. When you switch to an environment, the prompt will change to show which
    environment you are in. For instance, if you are in the job environment, the prompt
    will look like (job) pkg>. In this example, I will activate the job environment,
    so all following commands modify the job environment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Julia REPL 中，你可以通过按 ] 进入包模式。在包模式下，你可以执行命令以激活不同的环境并向其添加包。当你切换到环境时，提示符将改变以显示你所在的环境。例如，如果你在
    job 环境中，提示符将看起来像 (job) pkg>。在这个例子中，我将激活 job 环境，因此所有后续命令都将修改 job 环境：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I will add some package dependencies to this environment. For demonstration
    purposes it is not important which Julia packages I add, but I have chosen to
    demonstrate with the CairoMakie ([https://makie.juliaplots.org](https://makie.juliaplots.org))
    plotting package and the link ElectronDisplay ([https://github.com/queryverse/ElectronDisplay.jl](https://github.com/queryverse/ElectronDisplay.jl))
    package for showing plots in window. If you use Visual Studio Code you don’t need
    the ElectronDisplay package, as it can already display any Julia plot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向这个环境添加一些包依赖。为了演示目的，添加哪些 Julia 包并不重要，但我选择使用 CairoMakie ([https://makie.juliaplots.org](https://makie.juliaplots.org))
    绘图包和链接 ElectronDisplay ([https://github.com/queryverse/ElectronDisplay.jl](https://github.com/queryverse/ElectronDisplay.jl))
    包来在窗口中显示图表。如果你使用 Visual Studio Code，你不需要 ElectronDisplay 包，因为它已经可以显示任何 Julia 图表。
- en: Note CairoMakie is part of a collection of related Julia plotting packages called
    Makie. All Makie packages give users the same types and functions, and the only
    difference is the type of graphics produced. CairoMakie offers the ability to
    create high-quality 2D vector plots, while GLMakie enables creating interactive
    3D plots.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CairoMakie 是 Makie 相关 Julia 绘图包集合的一部分，称为 Makie。所有 Makie 包为用户提供相同的数据类型和函数，唯一的区别是生成的图形类型。CairoMakie
    提供了创建高质量 2D 向量图的能力，而 GLMakie 则允许创建交互式 3D 图表。
- en: 'Let’s assume you like to use the latest version of CairoMakie for your hobby
    projects, but your employer is a bit conservative. Instead, you must use the version
    0.5.10 at work:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你喜欢在你的业余项目中使用 CairoMakie 的最新版本，但你的雇主比较保守。因此，你必须在工作中使用版本 0.5.10：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Add CairoMakie version 0.5.10 to the job environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 CairoMakie 版本 0.5.10 添加到工作环境中。
- en: ❷ Add the latest version of ElectronDisplay.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加 ElectronDisplay 的最新版本。
- en: ❸ Check what packages are added to this environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查添加到这个环境中的包。
- en: When you run the add package commands you will see a lot more info than I am
    showing you here. I edited out most of it because it would have filled several
    pages, but I have kept the most important bits of information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行添加包的命令时，你会看到比这里显示的更多信息。我编辑掉了大部分内容，因为它可能会填满几页，但我保留了最重要的信息。
- en: When calling add ElectronDisplay you are informed that the ~/dev/job/Project.toml
    file is modified. What file is that? My job environment is in the ~/dev/job directory.
    If you don’t have a Project.toml file in your currently active environment, then
    Julia will create it for you to store information about what packages you have
    added to your environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 add ElectronDisplay 时，你会被告知 ~/dev/job/Project.toml 文件已被修改。这是什么文件？我的工作环境位于
    ~/dev/job 目录下。如果你当前活跃的环境中没有 Project.toml 文件，那么 Julia 会为你创建一个，以存储你添加到环境中的包信息。
- en: The ElectronDisplay v1.0.1 line tells you what version of ElectronDisplay was
    installed. That was the latest version in 2022 when I wrote this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ElectronDisplay v1.0.1 行会告诉你安装了哪个版本的 ElectronDisplay。那是在我写这本书时的 2022 年的最新版本。
- en: 'Notice how the add command for CairoMakie was slightly different. I tacked
    on a @0.5.10 to the package name to inform Julia’s package manager that I wanted
    version 0.5.10 rather than whatever the current latest version of CairoMakie might
    be. When switching to the hobby environment I will use the latest version instead:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到添加 CairoMakie 的命令略有不同。我在包名后附加了 @0.5.10，以告知 Julia 的包管理器，我想要版本 0.5.10，而不是 CairoMakie
    的当前最新版本。当切换到业余环境时，我将使用最新版本：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the hobby environment, I used the add command slightly different. I listed
    all packages I wanted to add, so I could do it all in one go. Afterward, Julia
    notifies me that the CairoMakie v0.7.5 package was installed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在业余环境中，我使用了略有不同的添加命令。我列出了所有我想添加的包，这样我就可以一次性完成。之后，Julia 通知我已安装了 CairoMakie v0.7.5
    包。
- en: 'You can always use the status command to get an overview of what packages have
    been installed in your currently active environment. The command reads info stored
    in the Project.toml. This information is used to locate the correct package in
    your local package depot at ~/.julia/packages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终可以使用status命令来获取当前活动环境中已安装的包的概览。该命令读取Project.toml中存储的信息。这些信息用于在本地包仓库~/.julia/packages中定位正确的包：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The long strings of letters and numbers starting with 13f3f980 and d872a56f,
    respectively, are the universally unique identifier (UUID) of each package. Package
    names need not be unique. Several developers could be making a package named CairoMakie;
    thus, to be able to uniquely identify a specific package, they each need a unique
    UUID. Because there is currently no other package named CairoMakie, there is no
    package name conflict.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以13f3f980和d872a56f开头的长字符串和数字分别是每个包的全局唯一标识符（UUID）。包名不必唯一。可能有几个开发者正在制作名为CairoMakie的包；因此，为了能够唯一地识别特定的包，它们每个都需要一个唯一的UUID。因为目前没有其他名为CairoMakie的包，所以没有包名冲突。
- en: 'What if there was another CairoMakie package? In that case the package would
    need to be added with the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在另一个CairoMakie包会怎样？在这种情况下，需要使用以下命令添加包：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The package system comes with its own help system, so you can write ? add to
    get a full overview of all the different ways of adding a package. To remove packages
    use the rm command. You can add a package and check how the Project.toml file
    changes as you remove it again. The following is an example of adding and removing
    the Dates package:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 包系统自带帮助系统，因此你可以写? add来获取所有不同添加包方式的全面概述。要删除包，请使用rm命令。你可以在添加包的同时检查Project.toml文件如何随着删除操作而改变。以下是一个添加和删除Dates包的示例：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 16.1.1 Using a package in the REPL
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 在REPL中使用包
- en: 'Adding a package to your active environment doesn’t make the functions and
    types the package provides available in the Julia REPL or to the Julia project
    you are coding. Rather they become available after you run using or import statements.
    Makie has many different functions for plotting graphs. I will show how to use
    two functions: lines and scatter. Unless you use VS Code, you will need to load
    the ElectronDisplay package before anything becomes visible.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将包添加到你的活动环境中不会使该包提供的函数和类型在Julia REPL或你正在编码的Julia项目中可用。相反，它们在运行using或import语句之后才可用。Makie有许多不同的绘图函数。我将展示如何使用两个函数：lines和scatter。除非你使用VS
    Code，否则你需要在任何内容可见之前加载ElectronDisplay包。
- en: I will use Makie to plot a sine and cosine curve. To achieve that I will generate
    many *x*, *y* coordinates stored in xs, ys1, and ys2, respectively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Makie来绘制正弦和余弦曲线。为了实现这一点，我将生成许多*x*，*y*坐标，分别存储在xs，ys1和ys2中。
- en: Listing 16.1 Plotting a sine and cosine curve with Makie
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.1 使用Makie绘制正弦和余弦曲线
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Create window to show plot output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建窗口以显示绘图输出。
- en: ❷ Make scatter, scatter! and current_figure available.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使scatter，scatter!和current_figure可用。
- en: ❸ Create values from 1 to 10 with stepping value of 0.1.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用步长为0.1创建从1到10的值。
- en: ❹ Modify current figure by adding cosine plot.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过添加余弦图来修改当前图形。
- en: ❺ Sends current figure to the electron display
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将当前图形发送到electron显示
- en: When Julia evaluates using CairoMakie it will look for a package named CairoMakie
    in its current environment. If your environment is hobby, then it will load the
    code for the v0.7.5 version of Makie. However, if you evaluated this code in the
    job environment the v0.5.10 version would be loaded instead. If you run the code
    in the Julia REPL you should get a figure with two dotted plots (figure 16.1).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当Julia使用CairoMakie进行评估时，它将在其当前环境中寻找名为CairoMakie的包。如果你的环境是hobby，那么它将加载Makie的v0.7.5版本的代码。然而，如果你在job环境中评估此代码，将加载v0.5.10版本。如果你在Julia
    REPL中运行此代码，你应该得到一个包含两个虚线图的图形（图16.1）。
- en: '![16-01](../Images/16-01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![16-01](../Images/16-01.png)'
- en: Figure 16.1 Makie scatter plot of the sine and cosine functions
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 Makie的正弦和余弦函数散点图
- en: These plots are called *scatter plots*. Every (x, y) coordinate produces a colored
    dot. If you want lines connecting each coordinate point you would use the lines
    and lines! functions instead, as follows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图称为*散点图*。每个(x, y)坐标产生一个彩色点。如果你想连接每个坐标点的线条，你可以使用lines和lines!函数，如下所示。
- en: Listing 16.2 Plotting sine and cosine with smooth lines
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.2 使用平滑线条绘制正弦和余弦曲线
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Plot lines with thickness 5
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制厚度为5的线条
- en: Evaluating the code will give you the plot shown in figure 16.2\. There are
    many named arguments that can modify the appearance of each plot. For example,
    the linewidth=5 named argument makes the lines thicker.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码将给出图 16.2 所示的图表。有许多命名参数可以修改每个图表的外观。例如，linewidth=5 的命名参数使线条变粗。
- en: '![16-02](../Images/16-02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![16-02](../Images/16-02.png)'
- en: Figure 16.2 Makie line plot of the sine and cosine functions
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 正弦和余弦函数的 Makie 线性图
- en: You can visit the official Makie website ([https://docs.makie.org/stable/](https://docs.makie.org/stable/))
    to learn more about plotting in Julia using Makie.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问官方 Makie 网站 ([https://docs.makie.org/stable/](https://docs.makie.org/stable/))
    了解更多关于使用 Makie 在 Julia 中进行绘图的信息。
- en: 16.1.2 How modules relate to packages
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 模块与包的关系
- en: My description of the package loading process was not entirely accurate. Packages
    define a module of the same name as the package. Hence, when you write using Dates,
    you are looking up the Dates package and loading the Dates module defined within
    it. The distinction will become much clearer once you define your own package
    and module.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我对包加载过程的描述并不完全准确。包定义了一个与包同名的模块。因此，当你写下 using Dates 时，你是在查找 Dates 包并加载其中定义的 Dates
    模块。一旦你定义了自己的包和模块，这种区别就会变得非常清晰。
- en: You can think of a Julia package as a physical bundle of source code, resources,
    and metadata, such as version, name, and dependencies. These things matter to
    the package-loading machinery of Julia but are not language constructs. Just like
    there are the keywords function and struct for defining functions or composite
    types in Julia, there is also the module keyword for defining a module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Julia 包想象成一个包含源代码、资源以及元数据（如版本、名称和依赖项）的物理包。这些对于 Julia 的包加载机制很重要，但不是语言结构。就像在
    Julia 中有用于定义函数或复合类型的关键字 function 和 struct 一样，也有用于定义模块的 module 关键字。
- en: 'While functions allow you to group chunks of code, modules allow you to group
    related functions and types. Modules also create a *namespace*, just like a function.
    That means you can use variables with the same name in different functions, and
    they won’t interfere with each other because each function forms a separate namespace.
    The volume functions in the following listing don’t interfere with each other,
    since they are in two separate modules: Cylinder and Cone.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数允许你将代码块分组时，模块允许你将相关的函数和类型分组。模块还创建了一个 *命名空间*，就像函数一样。这意味着你可以在不同的函数中使用相同名称的变量，而它们不会相互干扰，因为每个函数形成一个独立的命名空间。以下列表中的体积函数不会相互干扰，因为它们位于两个不同的模块中：Cylinder
    和 Cone。
- en: Listing 16.3 Functions with the same name in different modules
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.3 不同模块中具有相同名称的函数
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You could evaluate these modules in the REPL and call the different volume
    functions like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 REPL 中评估这些模块，并像这样调用不同的体积函数：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this chapter you will, however, focus on defining a single module per package.
    That is the most pragmatic solution in Julia.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，你将专注于每个包定义一个模块。这是 Julia 中最实用的解决方案。
- en: 16.2 Creating your own package and module
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 创建自己的包和模块
- en: On the following pages I will show you how to create your own package and module
    by taking the volume and trigonometric functions from chapter 2 and chapter 4
    and organizing them into a module ToyGeometry stored in a package. You could build
    a package from scratch manually, but it is more convenient to use the Julia package
    manager to generate the scaffolding for you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我将通过从第 2 章和第 4 章中提取体积和三角函数，并将它们组织到存储在包中的模块 ToyGeometry 中，向你展示如何创建自己的包和模块。你可以从头开始手动构建包，但使用
    Julia 包管理器为你生成脚手架会更方便。
- en: After generating the package and looking at its structure, I will show you how
    to add code to the package. You will then learn to expand your package with plotting
    functionality, so you can better grasp how to deal with package dependencies.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成包并查看其结构后，我将向你展示如何向包中添加代码。然后，你将学习如何通过绘图功能扩展你的包，这样你可以更好地掌握如何处理包依赖项。
- en: 16.2.1 Generating a package
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.1 生成包
- en: 'I start out in my ~/dev directory, where I have the hobby and job directories.
    You could, of course, organize this any way you want. I use shell mode to jump
    into the hobby directory, where I want to create my ToyGeometry package. The generate
    command is used in package mode to create a package:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 ~/dev 目录开始，其中包含爱好和职业目录。当然，你可以按任何你想要的方式组织它们。我使用 shell 模式跳转到爱好目录，在那里我想创建我的
    ToyGeometry 包。在包模式下使用 generate 命令来创建一个包：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A more sophisticated way of creating packages is using the PkgTemplate library,
    but generate is a good way of getting started, as it makes a minimalist package.
    If you look at the contents of the package, you will see it only contains two
    files: Project.toml and src/ToyGeometry.jl:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包的更复杂的方法是使用 PkgTemplate 库，但 generate 是一个很好的入门方式，因为它创建了一个极简的包。如果你查看包的内容，你会看到它只包含两个文件：Project.toml
    和 src/ToyGeometry.jl：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may be surprised to see the Project.toml file in there. Isn’t that used
    to define environments? Exactly! And a Julia package is, in fact, its own environment.
    By being an environment, a Julia package can add other packages it depends on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地看到里面的 Project.toml 文件。这不是用来定义环境的吗？没错！实际上，一个 Julia 包就是一个环境。作为一个环境，Julia
    包可以添加它所依赖的其他包。
- en: Note Environments can be nested, but that has no practical implications. It
    is more useful to nest modules, but I will not cover module nesting in this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：环境可以嵌套，但这没有实际意义。嵌套模块更有用，但在这本书中我不会介绍模块嵌套。
- en: 'At the moment there are no dependencies, so the Project.toml file will only
    show data about the package, such as its names, the unique UUID identifying the
    package, the author of the package, and the current package version:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有依赖项，所以 Project.toml 文件将只显示有关包的数据，例如其名称、唯一标识包的 UUID、包的作者以及当前包的版本：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s add a dependent package to ToyGeometry to show how adding dependencies
    works. I will add two packages, Dates and Base64, which exist in the standard
    library bundled with Julia (no download from the internet is necessary). Since
    I don’t want to add these dependencies to the hobby environment, but to the ToyGeometry
    environment, I first have to switch active environments:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 ToyGeometry 添加一个依赖包来展示添加依赖项的工作原理。我将添加两个包，Dates 和 Base64，这两个包存在于 Julia 标准库中（不需要从互联网下载）。由于我不想将这些依赖项添加到娱乐环境中，而是添加到
    ToyGeometry 环境中，我首先必须切换活动环境：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Project.toml file in ToyGeometry will now be updated to show the dependencies
    of the package:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ToyGeometry 中的 Project.toml 文件现在将更新以显示包的依赖关系：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I will have also gotten a new file called Manifest.toml, which stores information
    about the packages Dates and Base64 depend on. For instance, Dates depends on
    the Printf package to format text strings of dates. Further, Printf depends on
    the Unicode package:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将获得一个名为 Manifest.toml 的新文件，该文件存储有关 Dates 和 Base64 依赖的包的信息。例如，Dates 依赖于 Printf
    包来格式化日期的文本字符串。此外，Printf 依赖于 Unicode 包：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For packages not part of the Julia standard library, the entries will be more
    complex. The following is an entry from the Manifest.toml file in the job environment
    for the Colors package:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不属于 Julia 标准库的包，条目将更复杂。以下是从工作环境中的 Colors 包的 Manifest.toml 文件中的一个条目：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see it doesn’t just list the UUID but also the version of Colors. You
    don’t need to know what the git-tree-sha1 string means, except that it helps Julia
    locate the correct package in the local package depot to load.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它不仅列出了 UUID，还列出了 Colors 的版本。你不需要知道 git-tree-sha1 字符串的含义，除了它有助于 Julia 在本地包仓库中定位正确的包以加载。
- en: 16.2.2 Adding code to your package
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.2 向你的包中添加代码
- en: 'At the moment, the package doesn’t do anything, so let’s add code by copying
    the volume and trigonometry code from chapters 2 and 4\. I will start by creating
    two files, volume.jl and trig.jl, to hold this code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个包没有任何功能，所以让我们通过复制第 2 章和第 4 章中的体积和三角学代码来添加代码。我将首先创建两个文件，volume.jl 和 trig.jl，来存放这段代码：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Add the code shown in listing 16.4 to the src/volume.jl.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 16.4 中的代码添加到 src/volume.jl 中。
- en: Listing 16.4 ToyGeometry/src/volume.jl
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.4 ToyGeometry/src/volume.jl
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next I add the function from chapter 4 that used the Taylor series to compute
    sine; later I will add a cosine function. This code will go into the src/trig.jl
    file, as follows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将添加第 4 章中使用的泰勒级数来计算正弦值的函数；稍后我将添加一个余弦函数。这段代码将放入 src/trig.jl 文件中，如下所示。
- en: Listing 16.5 ToyGeometry/src/trig.jl
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.5 ToyGeometry/src/trig.jl
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The ToyGeometry package defines a module named ToyGeometry. I want all the functions
    I have written to be part of the ToyGeometry module. By running the include functions
    inside the module definition, all the function definitions get evaluated inside
    the ToyGeometry module and become part of it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ToyGeometry 包定义了一个名为 ToyGeometry 的模块。我希望我编写的所有函数都成为 ToyGeometry 模块的一部分。通过在模块定义内运行
    include 函数，所有函数定义都会在 ToyGeometry 模块内进行评估，并成为其一部分。
- en: Listing 16.6 ToyGeometry/src/ToyGeometry.jl
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.6 ToyGeometry/src/ToyGeometry.jl
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The workings of include may not be obvious to you if you are thinking like a
    C/C++ developer, but it is really quite simple. Let’s do a quick experiment to
    demonstrate.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像 C/C++ 开发者一样思考，你可能不会明显地理解 include 的作用，但实际上它非常简单。让我们做一个快速实验来演示。
- en: 'Start by creating a file named arithmetic.jl, and write 3 + 4 inside it. include
    can be called anywhere, even inside a function definition:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为 arithmetic.jl 的文件，并在其中写入 3 + 4。include 可以在任何地方调用，甚至是在函数定义内部：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You don’t have to split up your code into multiple files and add them to the
    module with include. You could have defined the ToyGeometry module as follows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必将代码拆分成多个文件并将它们添加到模块中，使用 include。你可以这样定义 ToyGeometry 模块。
- en: Listing 16.7 ToyGeometry/src/ToyGeometry.jl
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.7 ToyGeometry/src/ToyGeometry.jl
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So why not define it this way? Putting all the code inside the module definition
    file ToyGeometry.jl does not scale well. As your package becomes larger it becomes
    impractical to have all your code in one file. That’s why I split the code for
    a package up into multiple files and include those files inside the module definition.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不用这种方式定义呢？将所有代码放入模块定义文件 ToyGeometry.jl 中并不适合扩展。随着你的包变大，将所有代码放在一个文件中变得不切实际。这就是为什么我将包的代码拆分成多个文件，并在模块定义中包含这些文件。
- en: 16.3 Modifying and developing a package
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 修改和开发包
- en: If you are following along, you now have a correct package structure and definition;
    the next step is understanding the package development process. This is an iterative
    process in which you are testing the functionality of your package and adding
    new features over and over again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随，你现在有一个正确的包结构和定义；下一步是理解包开发过程。这是一个迭代过程，在这个过程中，你不断地测试你包的功能并添加新特性。
- en: 'While you develop your own package there are many Julia packages you may want
    to use to aid your development efforts but which should not be part of the dependencies
    of your package. The following are some packages I like to use to increase productivity:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开发自己的包时，你可能想使用许多 Julia 包来帮助你开发工作，但这些包不应成为你包的依赖项。以下是我喜欢使用的、可以提高生产力的包：
- en: OhMyREPL—Provides syntax highlighting and history matching in the Julia REPL
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OhMyREPL—在 Julia REPL 中提供语法高亮和历史匹配功能
- en: Revise—Monitors code changes to packages loaded into the REPL and updates the
    REPL with these changes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Revise—监控加载到 REPL 中的代码更改，并使用这些更改更新 REPL
- en: 'Returning to the example, I will now switch to the hobby environment, since
    I don’t want these packages added as dependencies of ToyGeometry:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回到示例，我现在将切换到娱乐环境，因为我不想将这些包作为 ToyGeometry 的依赖项：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Just check where you currently are.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只需检查你目前的位置。
- en: ❷ The hobby environment is one directory up.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 娱乐环境在上一个目录。
- en: I can now load OhMyREPL and Revise into the REPL, but trying to load ToyGeometry
    will fail. Can you guess why?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以将 OhMyREPL 和 Revise 加载到 REPL 中，但尝试加载 ToyGeometry 会失败。你能猜到为什么吗？
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The error message in this case is not very helpful. Julia, for instance, never
    looks in the current filesystem path for packages. The actual issue is that I
    have not added ToyGeometry to the hobby environment. The environment I am currently
    working in doesn’t know about my custom package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，错误信息并不很有帮助。例如，Julia 从不会在当前文件系统路径中查找包。实际问题是，我没有将 ToyGeometry 添加到娱乐环境中。我目前工作的环境不知道我的自定义包。
- en: 'I could inform it about the package by using the add command in the package
    manager. However, the problem with using add is that it captures the latest package
    version and freezes it. Normally, that is a good thing because you don’t want
    third-party packages added to your working environment to suddenly change. But
    when you actively develop a package your needs are different than when you are
    using a package. You want all your code changes to be available in your working
    environment without using an explicit update command to get latest changes. Thus
    instead of add, I will show how you can use the dev package command. The dev command
    needs the directory path of your package:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过在包管理器中使用 add 命令来告知它包的信息。然而，使用 add 的问题在于它会捕获最新的包版本并将其冻结。通常，这是好事，因为你不希望第三方包突然改变而添加到你的工作环境中。但是，当你积极开发一个包时，你的需求与使用包时不同。你希望所有代码更改都可在你的工作环境中可用，而无需使用显式的更新命令来获取最新更改。因此，我将展示如何使用
    dev 包命令。dev 命令需要你的包的目录路径：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Looking at the status of the hobby environment you can now see that OhMyREPL,
    Revise, and ToyGeometry have all been added:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看看爱好环境的当前状态，你现在可以看到 OhMyREPL、Revise 和 ToyGeometry 都已经被添加：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now your current working environment knows where ToyGeometry can be found,
    so it knows what code to load when you write using ToyGeometry. Remember, there
    could be many packages with the name ToyGeometry, so your environment needs to
    be explicitly told which package should be loaded:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当前工作环境知道 ToyGeometry 的位置，因此当你写 using ToyGeometry 时，它知道要加载哪些代码。记住，可能有多个名为 ToyGeometry
    的包，所以你的环境需要明确告知应该加载哪个包：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Call your custom sine function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用你的自定义正弦函数。
- en: ❷ Julia’s built-in sine function
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Julia 的内置正弦函数
- en: ❸ Trying to call sine without specifying module name
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 尝试调用正弦函数而不指定模块名称
- en: It is awkward to write ToyGeometry.sine every time you want to call the custom
    sine function, but as the example shows, Julia doesn’t currently know how to call
    it if you don’t prefix it with the module name. Yet, as you have seen with other
    packages, such as CairoMakie, you don’t need to prefix plot functions, such as
    scatter and lines, with the module name. How can you achieve the same?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用自定义正弦函数时都写 ToyGeometry.sine 是很尴尬的，但正如示例所示，如果你不使用模块名称前缀，Julia 目前不知道如何调用它。然而，正如你从其他包（如
    CairoMakie）中看到的，你不需要使用模块名称前缀来调用绘图函数，如散点图和线条。你如何实现同样的效果？
- en: 'The trick is to use the export statement to tell Julia which functions and
    types are to be exported (made public) from the module. While I’m at it, I’ll
    add a cosine function and export that as well:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用导出语句的技巧是告诉 Julia 哪些函数和类型应该从模块中导出（公开）。在此过程中，我将添加一个余弦函数并将其也导出：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Make sine and cosine public.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将正弦和余弦函数设置为公开。
- en: You may notice that with cosine I am replacing the clunky for loop with a more
    elegant mapreduce, which was covered in chapter 4\. mapreduce is a combination
    of the higher-order functions map and reduce.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在余弦函数中，我用更优雅的 mapreduce 替换了笨拙的 for 循环，这在第 4 章中已经介绍过。mapreduce 是 map
    和 reduce 两种高阶函数的组合。
- en: 'You will notice it is now possible to write sine and cosine without any module
    name prefixing. The following simple test shows that the custom functions give
    similar output as the built-in functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到现在可以写正弦和余弦函数而不需要任何模块名称前缀。以下简单的测试显示，自定义函数的输出与内置函数相似：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How was Julia suddenly able to know sine and even cosine without any package
    reloading? This is thanks to the magic of Revise. Because I loaded Revise before
    ToyGeometry it will monitor changes to the module and incorporate them into the
    REPL automatically.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 如何突然能够知道正弦甚至余弦，而不需要重新加载任何包？这要归功于 Revise 的魔法。因为我是在加载 ToyGeometry 之前加载了
    Revise，所以它会监控模块的更改，并将它们自动合并到 REPL 中。
- en: Should you always use Revise? Sometimes you make code changes you don’t want
    reflected in the REPL immediately. Just use common sense. You can even use Revise
    for single files by calling includet instead of include.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否应该总是使用 Revise？有时你做的代码更改你不想立即反映在 REPL 中。只需使用常识即可。你甚至可以使用 Revise 对单个文件进行操作，通过调用
    includet 而不是 include。
- en: When writing code you will naturally make mistakes. The REPL helps you quickly
    check your code to see if you are getting the right results. One of the best ways
    to quickly analyze a lot of data and spot problems is achieved by visualizing
    the data. So let’s plot both the built-in sin and the custom sine to see if you
    get similar-looking plots. Evaluate the following code in your REPL.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你自然会犯错误。REPL 帮助你快速检查代码，以查看你是否得到了正确的结果。快速分析大量数据并发现问题的一种最佳方式是通过可视化数据。所以让我们绘制内置的正弦和自定义的正弦函数，看看你是否得到了相似的图形。在你的
    REPL 中评估以下代码。
- en: Listing 16.8 Comparing built-in sin with custom sine
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.8 比较内置的正弦与自定义的正弦
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Ouch! They are not the same. At around 4.5 along the *x*-axis your custom sine
    function fails visibly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！它们并不相同。在大约 *x* 轴 4.5 处，你的自定义正弦函数明显失败。
- en: '![16-03](../Images/16-03.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![16-03](../Images/16-03.png)'
- en: Figure 16.3 Makie scatter plot of the sine and cosine functions, *n* = 5
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 Makie 散点图展示正弦和余弦函数，*n* = 5
- en: Fortunately, thanks to Revise you can modify the line that says n = 5. Try some
    different values for n to see how the plot changes. Setting n = 8 should solve
    your problem. There is no magical reason 8 works aside from the fact that higher
    values offer greater accuracy, meaning there is a tradeoff between performance
    and accuracy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，多亏了Revise，你可以修改显示n = 5的行。尝试不同的n值以查看图表如何变化。将n设置为8应该能解决你的问题。8之所以有效，并没有什么神奇的理由，除了更高的值能提供更高的精度之外，这意味着性能和精度之间存在权衡。
- en: 16.4 Tackling common misconceptions about modules
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 解决关于模块的常见误解
- en: If you are coming from a different programming language there are likely many
    concepts relating to environments, packages, and modules you find confusing. For
    instance, in the Java world, a *module* is called a *package*, and a Julia *package*
    is closer to a *JAR file*.^([1](#pgfId-1020101)) Table 16.1 gives an overview
    of the differences in terminology used to described modules, packages, and environments
    in different programming languages.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自不同的编程语言，你可能会发现许多与环境、包和模块相关的概念让你感到困惑。例如，在Java世界中，*模块*被称为*包*，而Julia的*包*更接近于*JAR文件*。^([1](#pgfId-1020101))
    表16.1概述了在不同编程语言中描述模块、包和环境所使用的术语差异。
- en: Table 16.1 Differences in package and module terminology usage across popular
    programming languages
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1 不同流行编程语言中包和模块术语使用的差异
- en: '| Julia | Java | C++ | Python |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Julia | Java | C++ | Python |'
- en: '| Module | Package | Namespace | Module |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 包 | 命名空间 | 模块 |'
- en: '| Package | JAR | DLL | Package |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 包 | JAR | DLL | 包 |'
- en: '| Environment | Environment | Sandbox or container | Virtual environment |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 环境 | 环境 | 沙盒或容器 | 虚拟环境 |'
- en: Another problem is that mainstream programming languages tend to put keywords
    such as public in front of functions that are meant to be exported or made public,
    as shown in the following listing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于主流编程语言往往将诸如public之类的关键字置于要导出或公开的函数之前，如下面的列表所示。
- en: Listing 16.9 Comparing Julia with a Java-style way of exporting functions
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.9 比较Julia与Java风格的函数导出方式
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'While Julia’s include function may seem similar to #include in C/C++, you have
    to take into account that include is a regular function call in Julia that returns
    a result. #include in C/C++ is not a function call at all but essentially a mechanism
    that pastes the content of the included files into the file with the include statements.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Julia的include函数可能看起来与C/C++中的#include相似，但你必须考虑到在Julia中include是一个常规函数调用，它返回一个结果。C/C++中的#include根本不是一个函数调用，而是一种将包含文件的内容粘贴到包含语句的文件中的机制。
- en: 16.5 Testing your package
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 测试你的包
- en: While you develop a package you can quickly test functions in the REPL. For
    long-term, large-scale development, that is not enough. You need to be able to
    quickly verify that a code you wrote weeks or months ago still works. In real-world
    software development you will make code changes in many different files. Keeping
    track of all functions affected by your code edits can be difficult; thus you
    need to have set up an extensive set of tests that can verify all previously written
    code still works.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发一个包时，你可以在REPL中快速测试函数。对于长期和大规模的开发，这还不够。你需要能够快速验证你几周或几个月前编写的代码仍然有效。在现实世界的软件开发中，你将在许多不同的文件中进行代码更改。跟踪所有受你代码编辑影响的函数可能很困难；因此，你需要设置一个广泛的测试集，以验证所有之前编写的代码仍然有效。
- en: 'Testing is a larger topic, so I will only cover the very basics in this book.
    You can read the following articles from my *Erik Explores* Substack to explore
    the topic further:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个更大的主题，所以在这本书中，我只会介绍一些非常基础的内容。你可以阅读以下来自我的*Erik Explores* Substack的文章，以进一步探索这个主题：
- en: “Organizing Tests in Julia” ([https://erikexplores.substack.com/p/julia-test-organizing](https://erikexplores.substack.com/p/julia-test-organizing))
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Organizing Tests in Julia” ([https://erikexplores.substack.com/p/julia-test-organizing](https://erikexplores.substack.com/p/julia-test-organizing))
- en: '“Julia Test Running: Best Practices” ([https://erikexplores.substack.com/p/julia-testing-best-pratice](https://erikexplores.substack.com/p/julia-testing-best-pratice))'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '“Julia Test Running: Best Practices” ([https://erikexplores.substack.com/p/julia-testing-best-pratice](https://erikexplores.substack.com/p/julia-testing-best-pratice))'
- en: 'Tests in Julia can be run from the package manager. It will try to execute
    a file named test/runtests.jl. In the example, I don’t have this file or the test
    directory, so I will have to make both:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的测试可以从包管理器运行。它将尝试执行名为test/runtests.jl的文件。在示例中，我没有这个文件或测试目录，所以我将不得不创建这两个：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Julia uses the concept of *nested test sets*, meaning a test set succeeds if
    all the test sets it contains succeed. The Julia convention is putting all test
    sets within one top-level test set. That is what I will demonstrate in the test/runtests.jl
    (listing 16.10); however, I will follow the same strategy by spreading tests across
    multiple files and including those files within the top-level test set.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Julia使用*嵌套测试集*的概念，这意味着如果一个测试集包含的所有测试集都成功，则该测试集成功。Julia的惯例是将所有测试集放入一个顶级测试集中。这就是我在test/runtests.jl（列表16.10）中将要展示的；然而，我将通过将测试分散到多个文件中并在顶级测试集中包含这些文件来遵循相同的策略。
- en: Listing 16.10 ToyGeometry/test/runtests.jl
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.10 ToyGeometry/test/runtests.jl
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tests are run separately from your module, so you need to load the module you
    are testing with the using statement. Getting access to testing macros like @testset
    and @test requires importing the Test package. This package is not in your ToyGeometry
    environment. It does not make sense to add Test to this environment, since it
    will only be used while testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是与你的模块分开运行的，因此你需要使用using语句加载你正在测试的模块。要访问测试宏如@testset和@test，需要导入Test包。这个包不在你的ToyGeometry环境中。将Test添加到这个环境中没有意义，因为它只会在测试时使用。
- en: 'Julia offers a neat solution to this problem. You can treat the test directory
    as its own environment and only add Test to that environment:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Julia为这个问题提供了一个整洁的解决方案。你可以将测试目录视为它自己的环境，并且只在该环境中添加Test：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Show what directory you are running package commands in.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示你正在运行包命令的目录。
- en: Before attempting to run the tests, you need to actually add them to your code.
    I will demonstrate this by adding tests to the test/trigtests.jl file, which contains
    tests related to trigonometric functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试运行测试之前，你需要实际上将它们添加到你的代码中。我将通过向test/trigtests.jl文件添加测试来演示这一点，该文件包含与三角函数相关的测试。
- en: Each actual test is specified with the @test macro. Because floating-point numbers
    are difficult to make exactly the same, I will not compare function results using
    == but ≈, which you can write in the Julia REPL by writing \approx and pressing
    the Tab key.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实际测试都由@test宏指定。由于浮点数难以完全相同，我将不会使用==来比较函数结果，而是使用≈，你可以在Julia REPL中通过写入\approx并按Tab键来输入。
- en: Sometimes the default tolerance of ≈ is too strict and you need a looser definition
    of equality. In those cases use the isapprox function to compare values. It takes
    a named argument atol, which you can use to specify how great the difference between
    the two results you are comparing you consider acceptable, as follows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时默认的≈容差太严格，你需要一个更宽松的相等定义。在这些情况下，使用isapprox函数来比较值。它接受一个命名参数atol，你可以用它来指定你认为两个比较结果之间的差异可以接受的极限，如下所示。
- en: Listing 16.11 ToyGeometry/test/trigtests.jl
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.11 ToyGeometry/test/trigtests.jl
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Test if all cosine values in range 0 to 2π with 0.1 increments are roughly
    equal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试范围在0到2π之间，以0.1为增量时所有余弦值是否大致相等。
- en: 'If you attempt to run this test while in the test environment it will, ironically,
    not work because test doesn’t actually know about the ToyGeometry package. Hence
    you need to switch to the hobby or ToyGeometry environment to run the tests:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在测试环境中运行此测试，它将讽刺地不工作，因为test实际上并不知道ToyGeometry包。因此，你需要切换到hobby或ToyGeometry环境来运行测试：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Cannot test from the test environment
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无法从测试环境进行测试
- en: Because of the for loops, I am able to perform a total of 130 tests in the preceding
    listing. The cosine test fails because I used n = 5, which does not make the results
    accurate enough. So I will set n = 9 instead for better accuracy. Please note
    that running tests causes a lot of output I’ve edited out.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在for循环，我能够在前面的列表中执行总共130个测试。余弦测试失败是因为我使用了n = 5，这不足以使结果足够准确。因此，我将n = 9改为提高准确性。请注意，运行测试会产生大量的输出，我已经编辑掉了。
- en: Listing 16.12 Modifying a cosine function in trig.jl
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.12 在trig.jl中修改余弦函数
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When I run the tests again they should pass:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我再次运行测试时，它们应该会通过：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The topic of testing and environments is much broader than I can cover here.
    What we have covered in this chapter provides you with a solid foundation from
    which to explore further. Here are some starting points:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和环境的话题比我在这里能涵盖的更广泛。我们在本章中涵盖的内容为你提供了一个坚实的基础，你可以在此基础上进一步探索。以下是一些起点：
- en: '*pkgdocs.julialang.org*—The site for the Pkg module, which provides the functionality
    of the package manager.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pkgdocs.julialang.org*—这是Pkg模块的网站，它提供了包管理器的功能。'
- en: '*docs.julialang.org*—The site for the official Julia documentation. You can
    look up detailed descriptions of modules, packages, and environments here, including
    testing.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*docs.julialang.org*—这是官方 Julia 文档的网站。您在这里可以查找模块、包和环境的详细描述，包括测试。'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An environment is like a work area where you set up what packages you want to
    work with and use.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境就像是一个工作区，您可以在其中设置想要使用的包以及使用它们。
- en: Julia allows you to maintain different environments configured to use different
    packages and different versions of those packages.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 允许您维护配置为使用不同包及其不同版本的多个环境。
- en: CairoMakie is a Julia package for plotting 2D vector graphics. It is part of
    a collection of plotting packages called Makie.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CairoMakie 是一个用于绘制 2D 向量图形的 Julia 包。它是 Makie 系列绘图包的一部分。
- en: scatter and lines are functions used in the Makie library to plot functions.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图和线条是 Makie 库中用于绘制函数的函数。
- en: ElectronDisplay is a package that provides a window for showing graphics, such
    as output from Makie. It is an alternative to plotting in the VS Code editor.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ElectronDisplay 是一个提供显示图形（如 Makie 的输出）窗口的包。它是 VS Code 编辑器中绘图的替代方案。
- en: You can switch between different environments using the activate package command.
    For instance, you might use this command when you want to modify the dependencies
    of another package you are developing.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用激活包命令在不同的环境之间切换。例如，当您想修改您正在开发的另一个包的依赖项时，可能会使用此命令。
- en: To make a module available in your code, add it with the add package command.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使模块在您的代码中可用，请使用添加包命令将其添加。
- en: Remove the package for modules no longer used in your program with the remove
    package command.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移除包命令移除程序中不再使用的模块的包。
- en: Check what packages have been added to an environment using the status command.
    You can use this to check what dependencies your custom-made package has.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态命令检查已添加到环境中的包。您可以使用此命令检查您自定义的包有哪些依赖项。
- en: In cases when many packages have the same name, specify the UUID of the package
    you are interested in when adding it to your work environment.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多包具有相同名称的情况下，在将其添加到工作环境时，指定您感兴趣的包的 UUID。
- en: Create a package with the generate package command.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成包命令创建一个包。
- en: Project.toml shows direct dependencies of your environment, while Manifest .toml
    shows indirect dependencies.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project.toml 显示您环境的直接依赖项，而 Manifest.toml 显示间接依赖项。
- en: When adding a local package you are developing, use dev instead of add. That
    ensures the latest code changes are incorporated whenever you load a module from
    that package.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当添加您正在开发的本地包时，使用 dev 而不是 add。这确保了每次从该包加载模块时，都会包含最新的代码更改。
- en: Use the Revise package to monitor code changes to packages loaded after Revise.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Revise 包来监控加载到 Revise 后的包的代码更改。
- en: Use test <package name> to run tests for a package. For instance, test ToyGeometry
    will run tests for the ToyGeometry package.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 test <包名> 来运行包的测试。例如，test ToyGeometry 将运行 ToyGeometry 包的测试。
- en: The test directory is its own environment that allows you to add the Test package
    as a dependency only to your test environment.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试目录是其自己的环境，允许您仅将 Test 包作为依赖项添加到测试环境中。
- en: '* * *'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^(1.)A Java Archive (JAR) is a package file format typically used to aggregate
    Java class files and associated metadata and resources (e.g., text and images)
    into one file for distribution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^^(1.)Java 存档 (JAR) 是一种包文件格式，通常用于将 Java 类文件及其关联的元数据和资源（例如文本和图像）聚合到一个文件中以便分发。
