- en: 17 Input and output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 输入和输出
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding Julia’s I/O system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Julia 的 I/O 系统
- en: Using the most common functions for reading and writing to files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最常用的文件读写函数
- en: Reading and writing to strings, sockets, and processes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写字符串、套接字和进程
- en: Adding code to the rocket example for loading rocket engines from CSV files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在火箭示例中添加代码以从 CSV 文件中加载火箭引擎
- en: Real programs need to be able to read input from users and write out results.
    In this chapter, you will learn about the Julia I/O system (input and output system).
    It provides an abstraction for working with files, network communications, and
    interprocess communications as well as interacting with the console (keyboard
    and screen).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 真实程序需要能够从用户那里读取输入并输出结果。在本章中，你将学习关于 Julia 的 I/O 系统（输入和输出系统）。它为处理文件、网络通信、进程间通信以及与控制台（键盘和屏幕）的交互提供了一个抽象层。
- en: Julia is very popular in data science, where we work a lot with input data in
    the form of CSV files (comma separated values). That is why the main code example
    will center on parsing a CSV file containing data about rocket engines, as well
    as writing rocket engine data to a CSV file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 在数据科学领域非常受欢迎，我们在那里大量处理以 CSV 文件（逗号分隔值）形式存在的输入数据。这就是为什么主要的代码示例将集中在解析包含火箭引擎数据的
    CSV 文件上，以及将火箭引擎数据写入 CSV 文件。
- en: 17.1 Introducing Julia’s I/O system
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 介绍 Julia 的 I/O 系统
- en: Let’s get a bird’s-eye view of the I/O system in Julia. It is centered on the
    abstract type IO. It has concrete subtypes, such as IOStream, IOBuffer, Process,
    and TCPSocket. Each type allows you to read and write data from different I/O
    devices, such as files, text buffers, running processes (programs you started),
    or network connections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们鸟瞰 Julia 的 I/O 系统。它以抽象类型 IO 为中心。它有具体的子类型，如 IOStream、IOBuffer、Process 和 TCPSocket。每种类型都允许你从不同的
    I/O 设备读取和写入数据，例如文件、文本缓冲区、正在运行的进程（你启动的程序）或网络连接。
- en: From the type hierarchy in figure 17.1 you can see that functions such as print,
    show, read, readline, and write are available for all I/O types. Some functions,
    such as eof and position, are not available for all I/O types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从图 17.1 中的类型层次结构中，你可以看到 print、show、read、readline 和 write 等函数对所有 I/O 类型都是可用的。一些函数，如
    eof 和 position，并不是所有 I/O 类型都可用。
- en: '![17-01](../Images/17-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![17-01](../Images/17-01.png)'
- en: Figure 17.1 Type hierarchy of an I/O system showing what different subtypes
    are used for. Light gray boxes represent concrete types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 显示不同子类型用途的 I/O 系统类型层次结构。浅灰色框表示具体类型。
- en: 'Different I/O objects are opened in different ways, but once created, you can
    use many of the same functions on all of them. I will demonstrate working with
    similar data from a file, string, and process. The data used will be from a CSV
    file called rocket-engines.csv with the following content:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 I/O 对象以不同的方式打开，但一旦创建，你就可以在它们上面使用许多相同的函数。我将演示如何处理来自文件、字符串和进程的类似数据。所使用的数据将来自名为
    rocket-engines.csv 的 CSV 文件，其内容如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I will open the file, read from it until I reach the end, and close it. In listing
    17.1, I read one line at a time using the readline function and check whether
    I have reached the end of the file with eof. I split every line using the split
    function into multiple words by using commas as delimiters. Each read line is
    printed to the console. All these functions are in the Base module, which is always
    loaded.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将打开文件，从中读取直到到达末尾，然后关闭它。在列表 17.1 中，我使用 readline 函数逐行读取，并使用 eof 检查我是否已到达文件的末尾。我使用
    split 函数通过逗号作为分隔符将每一行拆分成多个单词。每一行读取的内容都打印到控制台。所有这些函数都在 Base 模块中，该模块始终被加载。
- en: Listing 17.1 Reading a CSV file line by line to demonstrate basic I/O functionality
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.1 通过逐行读取 CSV 文件来演示基本的 I/O 功能
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can process data from a text string in a very similar fashion. I’ll demonstrate
    by creating a string with the first line in the rocket-engines.csv file and looking
    at how to process it with different I/O functions. I will use readuntil, which
    reads from an IO object, until hitting a particular character or string. I will
    use position to check how many characters into the IOStream I am, periodically
    using eof to check if I have reached the end of the I/O object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以非常相似的方式处理文本字符串中的数据。我将通过创建一个包含 rocket-engines.csv 文件第一行的字符串，并查看如何使用不同的 I/O
    函数来处理它来演示。我将使用 readuntil，它从 IO 对象中读取，直到遇到特定的字符或字符串。我将使用 position 来检查我在 IOStream
    中有多少个字符，并定期使用 eof 来检查我是否已到达 I/O 对象的末尾：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can experiment with doing the same operations on an I/O object obtained
    by opening the rocket-engines.csv file. Remember to call close(io) when you are
    done; otherwise you will leak limited OS resources. Especially when writing to
    an I/O object, it is important to close it, or you may lose data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在通过打开 rocket-engines.csv 文件获得的 I/O 对象上尝试执行相同的操作。记住，当你完成时调用 close(io)；否则，你可能会泄漏有限的操作系统资源。特别是在写入
    I/O 对象时，关闭它是很重要的，否则你可能会丢失数据。
- en: 17.2 Reading data from a process
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 从进程读取数据
- en: Script languages such as Python, Ruby, and Perl gained popularity in part for
    being good *glue languages*. A glue language excels at connecting existing software
    components, often written in different languages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python、Ruby 和 Perl 等脚本语言的部分受欢迎程度是因为它们是好的 *粘合语言*。粘合语言擅长连接现有软件组件，这些组件通常是用不同的语言编写的。
- en: 'You will briefly look at Julia’s ability to work as a glue language. Let’s
    pretend Julia lacks the ability to search through text files and you want to leverage
    the Unix grep tool^([1](#pgfId-1012565)) for that purpose. First you would jump
    into shell mode by pressing semicolon, just to demonstrate what your grep command
    will do: it finds lines with the text "Rocket Lab". By pressing backspace, you
    go back to Julia mode. Next you would open a connection to the grep process you
    launched (spawn). Notice the use of backticks to quote shell commands you want
    to run:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将简要了解 Julia 作为粘合语言的能力。让我们假设 Julia 缺乏搜索文本文件的能力，而你想要利用 Unix grep 工具[1](#pgfId-1012565)
    来实现这个目的。首先，你通过按分号进入 shell 模式，只是为了演示你的 grep 命令将做什么：它找到包含文本 "Rocket Lab" 的行。通过按退格键，你回到
    Julia 模式。接下来，你将打开一个连接到你所启动的 grep 进程（spawn）。注意使用反引号来引用你想要运行的 shell 命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike many script languages, such as Perl and Ruby, the backticks in Julia
    do not cause a shell command to run right away. Instead they cause the creation
    of a command object of a type called Cmd. When you call open on a command object,
    the command actually gets executed and spawns a process. The io object returned
    is of the Process type and represents a connection to the output of the running
    process. This way you can read from the process almost as if it were a file (figure
    17.2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Perl 和 Ruby 等许多脚本语言不同，Julia 中的反引号不会立即运行 shell 命令。相反，它们导致创建一个名为 Cmd 的类型的命令对象。当你对一个命令对象调用
    open 时，命令实际上会执行并启动一个进程。返回的 io 对象是 Process 类型，代表对运行进程输出的连接。这样，你可以几乎像读取文件一样读取进程（图
    17.2）。
- en: '![17-02](../Images/17-02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![17-02](../Images/17-02.png)'
- en: Figure 17.2 The open function spawns a child process. Both processes are connected
    through a pipe represented by the I/O object returned from the open function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 open 函数启动一个子进程。两个进程通过 open 函数返回的 I/O 对象表示的管道连接。
- en: Why do you get an error message when calling the position function? Because
    there are no methods attached to position that work on Process objects. Only IOStream
    objects working on files have the notion of a position in the stream.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么调用位置函数时你会得到错误信息？因为没有任何方法附加到位置上，可以在 Process 对象上工作。只有对文件工作的 IOStream 对象才有流中的位置概念。
- en: 17.3 Reading and writing to a socket
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 从套接字读取和写入
- en: A socket represents a network connection. I’ll present a quick example demonstrating
    a network connection using the Unix netcat utility. Netcat is a simple tool for
    experimenting with TCP/IP-socket-based communication.^([2](#pgfId-1012964)) You
    can run netcat as either a client or a server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字代表网络连接。我将通过使用 Unix netcat 工具快速演示一个网络连接的例子。Netcat 是一个简单的工具，用于实验基于 TCP/IP-socket
    的通信。[2](#pgfId-1012964) 你可以将 netcat 作为客户端或服务器运行。
- en: Note netcat is already installed on Linux and macOS. Windows users can download
    the nmap utility as a substitute from nmap.org/ncat. Any time I write the nc command
    in the text, in Windows you should write ncat instead.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，netcat 已经安装在 Linux 和 macOS 上。Windows 用户可以从 nmap.org/ncat 下载 nmap 工具作为替代品。每次我在文本中写
    nc 命令时，在 Windows 上你应该写 ncat。
- en: 'Follow these steps: Open two terminal windows. In the first window launch Julia,
    and in the second window launch netcat as a server listening for connections on
    port 1234\. You can specify almost any port number you like as long as it is not
    already taken. After launching netcat write the line "name,company,mass,thrust,Isp"
    and press Enter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：打开两个终端窗口。在第一个窗口中启动 Julia，在第二个窗口中启动 netcat 作为监听端口 1234 的服务器。只要你选择的端口号没有被占用，你几乎可以指定任何你喜欢的端口号。启动
    netcat 后，输入行 "name,company,mass,thrust,Isp" 并按 Enter 键：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the Julia window use the connect function to connect to the local server
    running at port 1234\. The connect function will return an I/O object of type
    TCPSocket:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia窗口中使用connect函数连接到在端口1234上运行的本地服务器。connect函数将返回一个类型为TCPSocket的I/O对象：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A socket is usually two-way, so you can write messages to the socket and see
    them pop up in the windows running netcat:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字通常是双向的，因此你可以向套接字写入消息，并在运行netcat的窗口中看到它们弹出：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Did you see the text string "hello netcat" pop up in the second window?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第二个窗口中看到了文本字符串"hello netcat"弹出吗？
- en: With these simple examples I have demonstrated that you can use the same functions,
    such as read, readuntil, readline, and println, for every type of I/O object,
    whether it represents a text string, file, or network connection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的示例，我已证明你可以使用相同的函数，例如read、readuntil、readline和println，对于每种I/O对象，无论它代表文本字符串、文件还是网络连接。
- en: 17.4 Parsing a CSV file
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4 解析CSV文件
- en: Let’s build up a more comprehensive code example. You will enhance your rocket
    code from the recurring example by adding the ability to load definitions of rocket
    engines from CSV files. To practice your Julia package making skills, make a Julia
    package called ToyRockets to contain your rocket code. I have already made this
    package and placed it on GitHub at github.com/ordovician/ToyRockets.jl, so you
    can follow along.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个更全面的代码示例。你将通过从重复的示例中添加从CSV文件加载火箭发动机定义的能力来增强你的火箭代码。为了练习你的Julia包制作技能，创建一个名为ToyRockets的Julia包来包含你的火箭代码。我已经创建了此包并将其放置在GitHub上，网址为github.com/ordovician/ToyRockets.jl，因此你可以跟随操作。
- en: 'The ToyRockets package is created with the generate command in the Julia package
    manager. Next create a data directory to hold the rocket-engines.csv file. Add
    the following files to the src directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ToyRockets包是通过Julia包管理器中的generate命令创建的。接下来创建一个数据目录来存放rocket-engines.csv文件。将以下文件添加到src目录中：
- en: '*interfaces.jl*—Contains definitions of abstract types, such as Engine'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*interfaces.jl*—包含抽象类型的定义，例如Engine'
- en: '*custom-engine.jl*—The definition of a concrete engine type'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*custom-engine.jl*—具体发动机类型的定义'
- en: '*io.jl*—A collection of functions for loading and saving rocket parts'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*io.jl*—用于加载和保存火箭部件的函数集合'
- en: 'Now run the necessary commands to make this happen, paying attention to the
    prompts. When the prompt says (@v1.7) pkg>, it means you must press ] first to
    enter package mode. When the prompt says shell> it means you must press ; to enter
    shell mode:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行必要的命令来实现这一点，注意提示。当提示说(@v1.7) pkg>时，意味着你必须先按]键进入包模式。当提示说shell>时，意味着你必须按;键进入shell模式：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you followed the instructions correctly and put the rocket-engines.csv file
    in the data/ directory, then your ToyRockets package should look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确遵循了说明并将rocket-engines.csv文件放在data/目录中，那么你的ToyRockets包应该看起来像这样：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure you include all your source code files in the ToyRockets.jl file (listing
    17.2), which defines your package module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你将所有源代码文件包含在ToyRockets.jl文件（列表17.2）中，该文件定义了你的包模块。
- en: Listing 17.2 src/ToyRockets.jl file
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.2 src/ToyRockets.jl文件
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next you need to turn every row in rocket-engines.csv into a CustomEngine object,
    so first you need to define Engine types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将rocket-engines.csv文件中的每一行转换为CustomEngine对象，因此首先你需要定义Engine类型。
- en: Listing 17.3 Defining engine types
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.3 定义发动机类型
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the next two sections you will load and save rocket engine data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，你将加载和保存火箭发动机数据。
- en: 17.4.1 Loading rocket engine data
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.1 加载火箭发动机数据
- en: You will now take a look at the final code (listing 17.4) before I walk through
    all the details and explain how its different parts work. The code starts by reading
    all the rows in the CSV file, with each row representing a rocket engine. Loop
    over each row, parse it, and turn it into a CustomEngine object that gets added
    to a dictionary, rocket_ engines, containing all the engines loaded from our input
    file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我详细讲解并解释其不同部分的工作原理之前，你现在将查看最终代码（列表17.4）。代码首先读取CSV文件中的所有行，每行代表一个火箭发动机。遍历每一行，解析它，并将其转换为CustomEngine对象，该对象被添加到包含从输入文件加载的所有发动机的字典rocket_engines中。
- en: Listing 17.4 An io.jl file containing code to load engine objects into a dictionary
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.4 包含将发动机对象加载到字典中的代码的io.jl文件
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ From tons to kg
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从吨到千克
- en: ❷ kN to Newton
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ kN到牛顿
- en: 'load_engines take the path to the CSV file that contains rocket engine data
    and parses it to produce a dictionary of rocket engines. Here is an example of
    using it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: load_engines函数接受包含火箭发动机数据的CSV文件的路径，并将其解析为火箭发动机的字典。以下是如何使用它的一个示例：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The load_engines function follows a pretty standard pattern I use when processing
    data, which is neatly organized by lines such as CSV files (see chapter 5). You
    use readlines here to get the rows in the file and split to get each of the columns
    of every row (figure 17.3).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: load_engines 函数遵循我处理数据时使用的相当标准的模式，这些模式被整洁地组织在类似于 CSV 文件的行中（见第 5 章）。在这里，你使用 readlines
    来获取文件中的行，并使用 split 来获取每行的每一列（图 17.3）。
- en: '![17-03](../Images/17-03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![17-03](../Images/17-03.png)'
- en: Figure 17.3 The rocket engine’s file is split into parts, transformed, and composed
    into rocket engines in multiple steps.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 火箭发动机的文件被分成几个部分，经过转换，并在多个步骤中组合成多个火箭发动机。
- en: 'To better understand how the code works, copy and paste parts of the source
    code lines into the REPL to see how the input data gets processed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解代码的工作原理，将源代码行的一部分复制并粘贴到 REPL 中，以查看输入数据是如何被处理的：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, pick an arbitrary row and split it into columns to verify the parsing
    works as expected. Occasionally, there can be missing data, so be sure to check
    that every column contains data. You can achieve this with the higher-order function
    any(isempty, cols), which applies isempty to every column. If *any* of the columns
    are empty, it will return true:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择任意一行，将其拆分为列以验证解析是否按预期工作。偶尔，可能会有缺失的数据，所以请确保每个列都包含数据。你可以使用高阶函数 any(isempty,
    cols)，它将 isempty 应用到每个列上。如果 *任何* 列为空，它将返回 true：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, you will use a little Julia magic called *destructuring* to pull out
    the name of the engine and the company making it. With destructuring you place
    multiple variables on the left side of the assignment operator =. On the right
    side, you must place an iterable collection with at least as many elements as
    variables on the left side:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用一种名为 *destructuring* 的 Julia 魔法，来提取发动机的名称和制造它的公司。使用 destructuring，你将多个变量放置在赋值运算符
    = 的左侧。在右侧，你必须放置一个可迭代的集合，其元素数量至少与左侧的变量数量相同：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: cols[1:2] gives you a two-element array. Julia iterates over this array and
    assigns the elements in the array to name and then company. A tuple or dictionary
    would have worked just as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: cols[1:2] 给你一个包含两个元素的数组。Julia 会迭代这个数组，并将数组中的元素分配给 name 和 company。元组或字典同样适用。
- en: 'The next part is a bit more complex, as you take the three last elements, cols[3:end],
    and map them to floating-point values using the parse(Float64, col) function.
    This turns the textual representations of mass, thrust, and Isp into floating-point
    values, which you can feed to the CustomEngine constructor to make an engine object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分稍微复杂一些，因为你需要将最后三个元素 cols[3:end] 映射到浮点值，使用 parse(Float64, col) 函数。这会将质量、推力和
    Isp 的文本表示转换为浮点值，你可以将这些值传递给 CustomEngine 构造函数来创建一个发动机对象：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last step is storing this engine in a dictionary under the engine name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将这个发动机存储在字典中，键为发动机名称。
- en: 17.4.2 Saving rocket engine data
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.2 保存火箭发动机数据
- en: At this point you can add code to your io.jl file to allow the saving of rocket
    engines to a file. By default a file is opened for reading. If you want to write
    to it you need to pass a "w" for the *write* argument to the open function. There
    are still a number of other new concepts in this code you will need to look at
    in greater detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以在你的 io.jl 文件中添加代码，以便将火箭发动机保存到文件中。默认情况下，文件是以读取模式打开的。如果你想写入它，你需要将一个 "w"
    传递给 open 函数的 *write* 参数。在这段代码中，还有一些其他的新概念，你需要更详细地查看。
- en: Listing 17.5 An io.jl file with added save_engines code
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.5 带有添加 save_engines 代码的 io.jl 文件
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Do you notice how you use the do-end form with your open function? That means
    it takes a function as the first argument. What is the point of that? Study the
    following implementation to see if you can make a guess.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到你是如何使用 do-end 形式与 open 函数一起使用的吗？这意味着它将一个函数作为第一个参数。这有什么用意？研究以下实现，看看你是否能猜出答案。
- en: Listing 17.6 Implementing open(f, args...)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.6 实现 open(f, args...)
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The benefit of this solution is that you can pass the responsibility of closing
    your io object to Julia when you are done with it. You will also notice the use
    of the *splat* operator .... It is used to represent a variable number of parameters.
    Regardless of how many arguments you pass to open they will be collected into
    a tuple args. When calling open(args...) you expand this tuple into arguments
    again by using the splat operator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的好处是，当你完成对 io 对象的处理后，你可以将关闭 io 对象的责任交给 Julia。你也会注意到 *splat* 操作符的使用。它用于表示可变数量的参数。无论你传递多少个参数给
    open，它们都会被收集到一个元组 args 中。当调用 open(args...) 时，你会再次使用 splat 操作符将这个元组展开成参数。
- en: 'What about the join taking an I/O argument as the first argument? Instead of
    returning the result of joining multiple elements with a separator, the join function
    will write the result to the supplied I/O object. Here is a demonstration of writing
    the result to standard out:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于join函数以I/O参数作为第一个参数的情况？与返回使用分隔符连接多个元素的结果不同，join函数将结果写入提供的I/O对象。以下是将结果写入标准输出的演示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should now have a broad understanding of the I/O Julia system. Study the
    documentation of the functions and types covered here using the built-in help
    system to learn more.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对Julia的I/O系统有一个广泛的理解。使用内置的帮助系统研究这里涵盖的函数和类型的文档，以了解更多信息。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: IOStream, IOBuffer, Process, and TCPSocket are I/O objects for reading and writing
    to files, text strings, running processes, or network connections.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IOStream、IOBuffer、Process和TCPSocket是用于读写文件、文本字符串、运行进程或网络连接的I/O对象。
- en: Use functions such as readuntil, readline, readlines, and read to read data
    from any I/O object.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用readuntil、readline、readlines和read等函数从任何I/O对象中读取数据。
- en: Use functions such as print and println to write data to an I/O object.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用print和println等函数将数据写入I/O对象。
- en: split is a convenient function for turning strings into arrays of objects by
    splitting them up using a delimiter.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: split是一个方便的函数，通过使用分隔符拆分字符串，可以将字符串转换为对象的数组。
- en: Destructuring assigns multiple elements in a collection to multiple variables,
    providing a compact and elegant way of accessing elements.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构赋值将集合中的多个元素分配给多个变量，提供了一种紧凑且优雅的访问元素的方式。
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)grep is a standard command-line utility on Unix systems for finding lines
    in a file matching a given search criteria.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）grep是Unix系统上的标准命令行实用工具，用于在文件中查找匹配给定搜索条件的行。
- en: ^(2.)TCP/IP is the protocol used on the internet for communication.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2.）TCP/IP是互联网上用于通信的协议。
