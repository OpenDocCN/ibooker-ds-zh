- en: Chapter 18\. Missing Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章 缺失值
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: You’ve already learned the basics of missing values earlier in the book. You
    first saw them in [Chapter 1](ch01.xhtml#chp-data-visualize) where they resulted
    in a warning when making a plot as well as in [“summarize()”](ch03.xhtml#sec-summarize)
    where they interfered with computing summary statistics, and you learned about
    their infectious nature and how to check for their presence in [“Missing Values”](ch12.xhtml#sec-na-comparison).
    Now we’ll come back to them in more depth so you can learn more of the details.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书的前面已经学习了缺失值的基础知识。你首次在[第1章](ch01.xhtml#chp-data-visualize)中看到它们，在绘制图时会出现警告，以及在[“summarize()”](ch03.xhtml#sec-summarize)中看到它们干扰了计算汇总统计信息，还学会了它们的传染性以及如何检查它们在[“缺失值”](ch12.xhtml#sec-na-comparison)中的存在。现在我们将更深入地回顾它们，以便你能更详细地了解。
- en: We’ll start by discussing some general tools for working with missing values
    recorded as `NA`s. We’ll then explore the idea of implicitly missing values, values
    are that are simply absent from your data, and show some tools you can use to
    make them explicit. We’ll finish off with a related discussion of empty groups,
    caused by factor levels that don’t appear in the data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论一些通用工具，用于处理记录为`NA`的缺失值。然后我们将探讨隐含缺失值的概念，即在数据中简单地缺失的值，并展示一些可以使它们显式的工具。最后，我们将讨论由于数据中不存在的因子水平而导致的空组的相关讨论。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: The functions for working with missing data mostly come from dplyr and tidyr,
    which are core members of the tidyverse.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缺失数据的函数主要来自于dplyr和tidyr，它们是tidyverse的核心成员之一。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Explicit Missing Values
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式缺失值
- en: To begin, let’s explore a few handy tools for creating or eliminating missing
    explicit values, i.e., cells where you see an `NA`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索一些方便的工具来创建或消除显式缺失值，即看到`NA`的单元格。
- en: Last Observation Carried Forward
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向前填充最后观测
- en: 'A common use for missing values is as a data entry convenience. When data is
    entered by hand, missing values sometimes indicate that the value in the previous
    row has been repeated (or carried forward):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值的常见用途是作为数据输入的便利性。当数据手动输入时，缺失值有时表示前一行的值已重复（或向前填充）：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can fill in these missing values with [`tidyr::fill()`](https://tidyr.tidyverse.org/reference/fill.xhtml).
    It works like [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml),
    taking a set of columns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用[`tidyr::fill()`](https://tidyr.tidyverse.org/reference/fill.xhtml)来填补这些缺失值。它的工作方式类似于[`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)，接受一组列：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This treatment is sometimes called “last observation carried forward,” or *locf*
    for short. You can use the `.direction` argument to fill in missing values that
    have been generated in more exotic ways.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理有时称为“向前填充最后观测”，简称*locf*。你可以使用`.direction`参数来填补通过更奇特方式生成的缺失值。
- en: Fixed Values
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定值
- en: 'Sometimes missing values represent some fixed and known value, most commonly
    0\. You can use [`dplyr::coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)
    to replace them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时缺失值代表某个固定和已知的值，最常见为0。你可以使用[`dplyr::coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)来替换它们：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sometimes you’ll hit the opposite problem where some concrete value actually
    represents a missing value. This typically arises in data generated by older software
    that doesn’t have a proper way to represent missing values, so it must instead
    use some special value like 99 or -999.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会遇到相反的问题，即某些具体值实际上表示缺失值。这通常出现在由旧软件生成的数据中，因为它没有适当的方法来表示缺失值，所以必须使用一些特殊值如99或-999。
- en: 'If possible, handle this when reading in the data, for example, by using the
    `na` argument to [`readr::read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml),
    e.g., `read_csv(path, na = "99")`. If you discover the problem later or your data
    source doesn’t provide a way to handle it on read, you can use [`dplyr::na_if()`](https://dplyr.tidyverse.org/reference/na_if.xhtml):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，在读取数据时处理这些问题，例如通过在[`readr::read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)中使用`na`参数，例如`read_csv(path,
    na = "99")`。如果稍后才发现问题，或者你的数据源没有提供处理方法，你可以使用[`dplyr::na_if()`](https://dplyr.tidyverse.org/reference/na_if.xhtml)：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: NaN
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NaN
- en: 'Before we continue, there’s one special type of missing value that you’ll encounter
    from time to time: a `NaN` (pronounced “nan”), or not a number. It’s not that
    important to know about because it generally behaves just like `NA`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一种特殊类型的缺失值你可能会遇到：`NaN`（读作“nan”），或称为非数字。虽然不那么重要，因为它通常的行为与`NA`类似：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the rare case you need to distinguish an `NA` from a `NaN`, you can use `is.nan(x)`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在您需要区分`NA`和`NaN`的罕见情况下，您可以使用`is.nan(x)`。
- en: 'You’ll generally encounter a `NaN` when you perform a mathematical operation
    that has an indeterminate result:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行具有不确定结果的数学运算时，通常会遇到`NaN`：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implicit Missing Values
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式缺失值
- en: 'So far we’ve talked about missing values that are *explicitly* missing; i.e.,
    you can see an `NA` in your data. But missing values can also be *implicitly*
    missing, if an entire row of data is simply absent from the data. Let’s illustrate
    the difference with a simple dataset that records the price of some stock each
    quarter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了*显式*缺失的值；即，你可以在数据中看到`NA`。但是，如果整行数据在数据中完全缺失，缺失的值也可以是*隐式*的。让我们通过一个简单的数据集来说明它们的区别，该数据集记录了某只股票每个季度的价格：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This dataset has two missing observations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集有两个缺失观测：
- en: The `price` in the fourth quarter of 2020 is explicitly missing, because its
    value is `NA`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2020年第四季度的`price`是显式缺失，因为其值为`NA`。
- en: The `price` for the first quarter of 2021 is implicitly missing, because it
    simply does not appear in the dataset.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年第一季度的`price`是隐式缺失，因为它在数据集中根本不存在。
- en: 'One way to think about the difference is with this Zen-like koan:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个类似禅宗的公案来思考这种差异的一种方式是：
- en: An explicit missing value is the presence of an absence.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显式缺失值是缺失的存在。
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An implicit missing value is the absence of a presence.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 隐式缺失值是存在的缺失。
- en: Sometimes you want to make implicit missings explicit to have something physical
    to work with. In other cases, explicit missings are forced upon you by the structure
    of the data, and you want to get rid of them. The following sections discuss some
    tools for moving between implicit and explicit missingness.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望将隐式缺失变为显式以便进行物理处理。在其他情况下，显式缺失是由数据结构强加的，而您希望摆脱它们。以下几节讨论了在隐式和显式缺失之间切换的一些工具。
- en: Pivoting
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透视
- en: 'You’ve already seen one tool that can make implicit missings explicit, and
    vice versa: pivoting. Making data wider can make implicit missing values explicit
    because every combination of the rows and new columns must have some value. For
    example, if we pivot `stocks` to put the `quarter` in the columns, both missing
    values become explicit:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了一个工具，可以使隐式缺失变为显式，反之亦然：透视。通过使数据变得更宽，可以使隐式缺失的值变得显式，因为每一行和新列的组合必须具有某个值。例如，如果我们将`stocks`透视以将`quarter`放入列中，则两个缺失值都变得显式：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By default, making data longer preserves explicit missing values, but if they
    are structurally missing values that exist only because the data is not tidy,
    you can drop them (make them implicit) by setting `values_drop_na = TRUE`. See
    the examples in [“Tidy Data”](ch05.xhtml#sec-tidy-data) for more details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使数据更长会保留显式缺失值，但如果它们是结构性缺失值，仅因为数据不整洁而存在，您可以通过设置`values_drop_na = TRUE`来删除它们（使它们变为隐式）。有关更多详细信息，请参阅[“整洁数据”](ch05.xhtml#sec-tidy-data)中的示例。
- en: Complete
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整
- en: '[`tidyr::complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)
    allows you to generate explicit missing values by providing a set of variables
    that define the combination of rows that should exist. For example, we know that
    all combinations of `year` and `qtr` should exist in the `stocks` data:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`tidyr::complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)允许您通过提供一组定义应存在的行组合的变量来生成显式缺失值。例如，我们知道`stocks`数据中应存在所有`year`和`qtr`的组合：'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Typically, you’ll call [`complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)
    with names of existing variables, filling in the missing combinations. However,
    sometimes the individual variables are themselves incomplete, so you can instead
    provide your own data. For example, you might know that the `stocks` dataset is
    supposed to run from 2019 to 2021, so you could explicitly supply those values
    for `year`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将使用现有变量的名称来调用[`complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)，填充缺失的组合。然而，有时个别变量本身就是不完整的，因此您可以提供自己的数据。例如，您可能知道`stocks`数据集应该从2019年到2021年运行，因此可以显式地为`year`提供这些值：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the range of a variable is correct but not all values are present, you could
    use `full_seq(x, 1)` to generate all values from `min(x)` to `max(x)` spaced out
    by 1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量的范围是正确的，但并非所有值都存在，您可以使用`full_seq(x, 1)`来生成从`min(x)`到`max(x)`每隔1的所有值。
- en: 'In some cases, the complete set of observations can’t be generated by a simple
    combination of variables. In that case, you can do manually what [`complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)
    does for you: create a data frame that contains all the rows that should exist
    (using whatever combination of techniques you need) and then combine it with your
    original dataset with [`dplyr::full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一组简单的变量组合不能生成完整的观察结果。这时，你可以手动完成[`complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)的功能：创建一个数据框，包含所有应该存在的行（使用你需要的任何组合技术），然后与你的原始数据集使用[`dplyr::full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)进行合并。
- en: Joins
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: 'This brings us to another important way of revealing implicitly missing observations:
    joins. You’ll learn more about joins in [Chapter 19](ch19.xhtml#chp-joins), but
    we wanted to quickly mention them to you here since you can often know that values
    are missing from one dataset only when you compare it another.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了揭示隐式缺失观察的另一个重要方法：连接。你将在[第19章](ch19.xhtml#chp-joins)中学到更多关于连接的内容，但我们想在这里快速提到它们，因为当你比较两个数据集时，你经常会知道一个数据集中缺少的值仅仅是与另一个数据集的比较。
- en: '`dplyr::anti_join(x, y)` is a useful tool here because it selects only the
    rows in `x` that don’t have a match in `y`. For example, we can use two [`anti_join()`s](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)
    to reveal that we’re missing information for 4 airports and 722 planes mentioned
    in `flights`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr::anti_join(x, y)` 在这里非常有用，因为它只选择在 `x` 中没有匹配的行。例如，我们可以使用两个[`anti_join()`s](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)发现在
    `flights` 中有 4 个机场和 722 架飞机的信息缺失：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercises
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Can you find any relationship between the carrier and the rows that appear to
    be missing from `planes`?
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能找到载体和在 `planes` 中缺失的行之间的任何关系吗？
- en: Factors and Empty Groups
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因子和空组
- en: 'A final type of missingness is the empty group, a group that doesn’t contain
    any observations, which can arise when working with factors. For example, imagine
    we have a dataset that contains some health information about people:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型的缺失是空组，即不包含任何观察结果的组，这可能在处理因子时出现。例如，想象我们有一个包含一些人员健康信息的数据集：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And say we want to count the number of smokers with [`dplyr::count()`](https://dplyr.tidyverse.org/reference/count.xhtml):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算有多少吸烟者，可以使用 [`dplyr::count()`](https://dplyr.tidyverse.org/reference/count.xhtml)：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This dataset contains only nonsmokers, but we know that smokers exist; the
    group of nonsmoker is empty. We can request [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)
    to keep all the groups, even those not seen in the data, by using `.drop = FALSE`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集只包含非吸烟者，但我们知道吸烟者也存在；非吸烟者组是空的。我们可以通过使用 `.drop = FALSE` 来请求[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)保留所有分组，即使在数据中没有看到它们：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The same principle applies to ggplot2’s discrete axes, which will also drop
    levels that don’t have any values. You can force them to display by supplying
    `drop = FALSE` to the appropriate discrete axis:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于 ggplot2 的离散轴，它们也会删除没有任何值的水平。你可以通过在适当的离散轴上提供 `drop = FALSE` 来强制显示它们：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![A bar chart with a single value on the x-axis, "no". The same bar chart as
    the last plot, but now with two values on the x-axis, "yes" and "no". There is
    no bar for the "yes" category.](assets/rds2_18in01.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![一个柱状图，x 轴上只有一个值“no”。同样的柱状图，现在x轴上有两个值“yes”和“no”，“yes”类别没有柱子。](assets/rds2_18in01.png)'
- en: 'The same problem comes up more generally with [`dplyr::group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml).
    And again you can use `.drop = FALSE` to preserve all factor levels:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`dplyr::group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)相似的问题也更为一般化地出现。同样，你可以使用
    `.drop = FALSE` 来保留所有因子水平：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We get some interesting results here because when summarizing an empty group,
    the summary functions are applied to zero-length vectors. There’s an important
    distinction between empty vectors, which have length 0, and missing values, each
    of which has length 1.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里得到一些有趣的结果，因为当对一个空组进行汇总时，汇总函数会应用于长度为零的向量。空向量的长度为 0，而缺失值的长度为 1，这是一个重要的区别。
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All summary functions work with zero-length vectors, but they may return results
    that are surprising at first glance. Here we see `mean(age)` returning `NaN` because
    `mean(age)` = `sum(age)/length(age)`, which here is 0/0\. [`max()`](https://rdrr.io/r/base/Extremes.xhtml)
    and [`min()`](https://rdrr.io/r/base/Extremes.xhtml) return -Inf and Inf for empty
    vectors, so if you combine the results with a nonempty vector of new data and
    recompute, you’ll get the minimum or maximum of the new data.^([1](ch18.xhtml#idm44771285285168))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有汇总函数都可以处理长度为零的向量，但它们的结果可能会让人感到意外。在这里，我们看到`mean(age)`返回`NaN`，因为`mean(age)`
    = `sum(age)/length(age)`，在这种情况下是 0/0。[`max()`](https://rdrr.io/r/base/Extremes.xhtml)
    和 [`min()`](https://rdrr.io/r/base/Extremes.xhtml) 对于空向量返回 -Inf 和 Inf，因此，如果你将这些结果与非空向量的新数据组合并重新计算，你将得到新数据的最小值或最大值。^([1](ch18.xhtml#idm44771285285168))
- en: 'Sometimes a simpler approach is to perform the summary and then make the implicit
    missings explicit with [`complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个更简单的方法是进行汇总，然后使用[`complete()`](https://tidyr.tidyverse.org/reference/complete.xhtml)使隐式缺失变为显式缺失。
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The main drawback of this approach is that you get an `NA` for the count, even
    though you know that it should be zero.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是计数为`NA`，即使你知道它应该是零。
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Missing values are weird! Sometimes they’re recorded as an explicit `NA`, but
    other times you notice them only by their absence. This chapter has given you
    some tools for working with explicit missing values and some tools for uncovering
    implicit missing values, and we discussed some of the ways that implicit can become
    explicit, and vice versa.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值很奇怪！有时它们被记录为明确的`NA`，但有时你只能通过它们的缺席来注意到它们。本章为您提供了一些处理显式缺失值的工具，以及一些揭示隐式缺失值的工具，并且我们讨论了隐式变成显式的一些方式，反之亦然。
- en: 'In the next chapter, we tackle the final chapter in this part of the book:
    joins. This is a bit of a change from the chapters so far because we’re going
    to discuss tools that work with data frames as a whole, not something that you
    put inside a data frame.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将处理本书这部分的最后一章：连接操作。这与迄今为止的章节有些不同，因为我们将讨论与数据框整体相关的工具，而不是将某些内容放入数据框中。
- en: ^([1](ch18.xhtml#idm44771285285168-marker)) In other words, `min(c(x, y))` is
    always equal to `min(min(x), min(y))`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.xhtml#idm44771285285168-marker)) 换句话说，`min(c(x, y))`总是等于`min(min(x),
    min(y))`。
