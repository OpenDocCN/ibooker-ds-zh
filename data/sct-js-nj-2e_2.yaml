- en: Part 3\. Digging into objects and fortifying your code
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分. 深入对象并加强你的代码
- en: Now that you’ve learned the ins and outs of functions, we’ll continue our exploration
    of JavaScript by taking a closer look at object fundamentals in [chapter 7](kindle_split_019.html#ch07).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了函数的方方面面，我们将通过更仔细地研究第7章[第7章](kindle_split_019.html#ch07)中的对象基础来继续我们的JavaScript探索。
- en: In [chapter 8](kindle_split_020.html#ch08), we’ll study how to control access
    to and monitor our objects with getters and setters, and with proxies, a completely
    new type of object in JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_020.html#ch08)中，我们将学习如何使用获取器和设置器以及代理来控制对对象的访问并监控我们的对象，代理是JavaScript中一种全新的对象类型。
- en: We’ll take a look at collections in [chapter 9](kindle_split_021.html#ch09)—traditional
    ones such as arrays, as well as completely new types such as maps and sets.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](kindle_split_021.html#ch09)中查看集合——传统的如数组，以及全新的类型如映射和集合。
- en: From there, we’ll move on to regular expressions in [chapter 10](kindle_split_022.html#ch10).
    You’ll learn that many tasks that used to take reams of code to accomplish can
    be condensed to a mere handful of statements through the proper use of JavaScript
    regular expressions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们将继续到第10章[第10章](kindle_split_022.html#ch10)中的正则表达式。你将了解到，许多以前需要大量代码才能完成的任务，通过正确使用JavaScript正则表达式，可以简化为仅仅几个语句。
- en: Finally, in [chapter 11](kindle_split_023.html#ch11), we’ll show you how to
    structure your JavaScript applications into smaller, well-organized units of functionality
    called modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第11章[第11章](kindle_split_023.html#ch11)中，我们将向您展示如何将JavaScript应用程序结构化为更小、更组织化的功能单元，称为模块。
- en: Chapter 7\. Object orientation with prototypes
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章. 使用原型的面向对象
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Exploring prototypes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索原型
- en: Using functions as constructors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数作为构造函数
- en: Extending objects with prototypes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型扩展对象
- en: Avoiding common gotchas
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免常见陷阱
- en: Building classes with inheritance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承构建类
- en: 'You’ve learned that functions are first-class objects in JavaScript, that closures
    make them incredibly versatile and useful, and that you can combine generator
    functions with promises to tackle the problem of asynchronous code. Now we’re
    ready to tackle another important aspect of JavaScript: object prototypes.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到函数是JavaScript中的第一类对象，闭包使它们变得极其灵活和有用，并且你可以将生成器函数与承诺结合使用来解决异步代码的问题。现在我们准备解决JavaScript的另一个重要方面：对象原型。
- en: A *prototype* is an object to which the search for a particular property can
    be delegated to. Prototypes are a convenient means of defining properties and
    functionality that will be automatically accessible to other objects. Prototypes
    serve a similar purpose to that of classes in classical object-oriented languages.
    Indeed, the main use of prototypes in JavaScript is in producing code written
    in an object-oriented way, similar to, but not exactly like, code in more conventional,
    class-based languages such as Java or C#.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*原型*是一个对象，可以将其特定属性的搜索委托给它。原型是定义将自动对其他对象可访问的属性和功能的一种方便方式。原型在经典面向对象语言中类似于类的作用。确实，原型在JavaScript中的主要用途是产生类似但又不完全像Java或C#等更传统、基于类的语言中的代码的面向对象代码。
- en: In this chapter, we’ll delve into how prototypes work, study their connection
    with constructor functions, and see how to mimic some of the object-oriented features
    often used in other, more conventional object-oriented languages. We’ll also explore
    a new addition to JavaScript, the `class` keyword, which doesn’t exactly bring
    full-featured classes to JavaScript but does enable us to easily mimic classes
    and inheritance. Let’s start exploring.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究原型的工作原理，研究它们与构造函数的联系，并了解如何模仿在其他更传统的面向对象语言中经常使用的某些面向对象特性。我们还将探索JavaScript的一个新特性，即`class`关键字，它并不完全将功能齐全的类引入JavaScript，但确实使我们能够轻松地模仿类和继承。让我们开始探索。
- en: Do you know?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you test whether an object has access to a particular property?
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何测试一个对象是否可以访问特定的属性？
- en: '**Q2:**'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is a prototype chain important for working with objects in JavaScript?
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么原型链在JavaScript中处理对象时很重要？
- en: '**Q3:**'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do ES6 classes change how JavaScript works with objects?
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ES6类是否会改变JavaScript处理对象的方式？
- en: 7.1\. Understanding prototypes
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 理解原型
- en: 'In JavaScript, objects are collections of named properties with values. For
    example, we can easily create new objects with object-literal notation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对象是由具有值的命名属性组成的集合。例如，我们可以轻松地使用对象字面量语法创建新的对象：
- en: '![](168fig01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![168fig01.jpg](168fig01.jpg)'
- en: 'As we can see, object properties can be simple values (such as numbers or strings),
    functions, and even other objects. In addition, JavaScript is a highly dynamic
    language, and the properties assigned to an object can be easily changed by modifying
    and deleting existing properties:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，对象属性可以是简单的值（如数字或字符串）、函数，甚至是其他对象。此外，JavaScript是一种高度动态的语言，我们可以通过修改和删除现有属性来轻松地更改分配给对象的属性：
- en: '![](168fig02_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![168fig02_alt.jpg](168fig02_alt.jpg)'
- en: 'We can even add completely new properties:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以添加完全新的属性：
- en: '![](168fig03_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![168fig03_alt.jpg](168fig03_alt.jpg)'
- en: 'In the end, all these modifications have left our simple object in the following
    state:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有这些修改都没有改变我们简单对象的状态：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When developing software, we strive not to reinvent the wheel, so we want to
    reuse as much code as possible. One form of code reuse that also helps organize
    our programs is *inheritance*, extending the features of one object into another.
    In JavaScript, inheritance is implemented with prototyping.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，我们努力不重复造轮子，因此我们希望尽可能多地重用代码。一种代码重用形式也有助于组织我们的程序，那就是继承，将一个对象的特性扩展到另一个对象。在JavaScript中，继承是通过原型实现的。
- en: The idea of prototyping is simple. Every object can have a reference to its
    *prototype*, an object to which the search for a particular property can be delegated
    to, if the object itself doesn’t have that property. Imagine that you’re in a
    game quiz with a group of people, and that the game show host asks you a question.
    If you know the answer, you give it immediately, and if you don’t, you ask the
    person next to you. It’s as simple as that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的概念很简单。每个对象都可以有一个对其`prototype`的引用，这是一个对象，如果对象本身没有该属性，则可以将对该属性的搜索委托给该对象。想象一下，你在一群人中参加一个游戏问答，游戏主持人问你一个问题。如果你知道答案，你会立即给出，如果你不知道，你会问旁边的人。就这么简单。
- en: Let’s take a look at the following listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的代码示例。
- en: Listing 7.1\. With prototypes, objects can access properties of other objects
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 使用原型，对象可以访问其他对象的属性
- en: '![](169fig01_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![169fig01_alt.jpg](169fig01_alt.jpg)'
- en: 'In this example, we start by creating three objects: `yoshi`, `hattori`, and
    `kuma`. Each has one specific property accessible only to that object: Only `yoshi`
    can `skulk`, only `hattori` can `sneak`, and only `kuma` can `creep`. See [figure
    7.1](#ch07fig01).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了三个对象：`yoshi`、`hattori`和`kuma`。每个对象都有一个特定的属性，只有该对象可以访问：只有`yoshi`可以`skulk`，只有`hattori`可以`sneak`，只有`kuma`可以`creep`。参见[图7.1](#ch07fig01)。
- en: Figure 7.1\. Initially, each object has access to only its own properties.
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 初始时，每个对象只能访问它自己的属性。
- en: '![](07fig01_alt.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![07fig01_alt.jpg](07fig01_alt.jpg)'
- en: To test whether an object has access to a particular property, we can use the
    `in` operator. For example, executing `skulk in yoshi` returns `true`, because
    `yoshi` has access to the `skulk` property; whereas executing `sneak in yoshi`
    returns `false`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个对象是否可以访问特定的属性，我们可以使用`in`运算符。例如，执行`skulk in yoshi`返回`true`，因为`yoshi`可以访问`skulk`属性；而执行`sneak
    in yoshi`返回`false`。
- en: In JavaScript, the object’s prototype property is an internal property that’s
    not directly accessible (so we mark it with `[[prototype]]`). Instead, the built-in
    method `Object.setPrototypeOf` takes in two object arguments and sets the second
    object as the prototype of the first. For example, calling `Object.setPrototypeOf(yoshi,
    hattori);` sets up `hattori` as a prototype of `yoshi`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对象的`prototype`属性是一个内部属性，不能直接访问（所以我们用`[[prototype]]`标记它）。相反，内置方法`Object.setPrototypeOf`接受两个对象参数，并将第二个对象设置为第一个对象的原型。例如，调用`Object.setPrototypeOf(yoshi,
    hattori);`会将`hattori`设置为`yoshi`的原型。
- en: As a result, whenever we ask `yoshi` for a property that it doesn’t have, `yoshi`
    delegates that search to `hattori`. We can access `hattori`’s `sneak` property
    through `yoshi`. See [figure 7.2](#ch07fig02).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当我们要询问`yoshi`一个它没有的属性时，`yoshi`会将该搜索委托给`hattori`。我们可以通过`yoshi`访问`hattori`的`sneak`属性。参见[图7.2](#ch07fig02)。
- en: Figure 7.2\. When we access a property that the object doesn’t have, the object’s
    prototype is searched for that property. Here, we can access `hattori`’s `sneak`
    property through `yoshi`, because `yoshi` is `hattori`’s prototype.
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 当我们访问对象没有的属性时，会搜索对象的原型以查找该属性。在这里，我们可以通过`yoshi`访问`hattori`的`sneak`属性，因为`yoshi`是`hattori`的原型。
- en: '![](07fig02_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![07fig02_alt.jpg](07fig02_alt.jpg)'
- en: We can do a similar thing with `hattori` and `kuma`. By using the `Object.setPrototypeOf`
    method, we can set `kuma` as the prototype of `hattori`. If we then ask `hattori`
    for a property that he doesn’t have, that search will be delegated to `kuma`.
    In this case, `hattori` now has access to `kuma`’s `creep` property. See [figure
    7.3](#ch07fig03).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方法处理 `hattori` 和 `kuma`。通过使用 `Object.setPrototypeOf` 方法，我们可以将 `kuma`
    设置为 `hattori` 的原型。如果我们然后询问 `hattori` 他没有的属性，搜索将会委托给 `kuma`。在这种情况下，`hattori` 现在可以访问
    `kuma` 的 `creep` 属性。参见 [图 7.3](#ch07fig03)。
- en: Figure 7.3\. The search for a particular property stops when there are no more
    prototypes to explore. Accessing `yoshi.creep` triggers the search first in `yoshi`,
    then in `hattori`, and finally in `kuma`.
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. 搜索特定属性会在没有更多原型可以探索时停止。访问 `yoshi.creep` 首先在 `yoshi` 中搜索，然后是 `hattori`，最后是
    `kuma`。
- en: '![](07fig03_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig03_alt.jpg)'
- en: It’s important to emphasize that every object can have a prototype, and an object’s
    prototype can also have a prototype, and so on, forming a *prototype chain*. The
    search delegation for a particular property occurs up the whole chain, and it
    stops only when there are no more prototypes to explore. For example, as shown
    in [figure 7.3](#ch07fig03), asking `yoshi` for the value of the `creep` property
    triggers the search for the property first in `yoshi`. Because the property isn’t
    found, `yoshi`’s prototype, `hattori`, is searched. Again, `hattori` doesn’t have
    a property named `creep`, so `hattori`’s prototype, `kuma`, is searched, and the
    property is finally found.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，每个对象都可以有一个原型，一个对象的原型也可以有一个原型，以此类推，形成一个 *原型链*。特定属性的搜索会在整个链上进行，直到没有更多的原型可以探索为止。例如，如图
    7.3 所示，询问 `yoshi` 的 `creep` 属性值会首先在 `yoshi` 中搜索该属性。因为属性未找到，所以会搜索 `yoshi` 的原型 `hattori`。再次，`hattori`
    没有名为 `creep` 的属性，所以会搜索 `hattori` 的原型 `kuma`，最终找到该属性。
- en: Now that we have a basic idea of how the search for a particular property occurs
    through the prototype chain, let’s see how prototypes are used when constructing
    new objects with constructor functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了通过原型链搜索特定属性的过程，接下来让我们看看在构造新对象时构造函数是如何使用原型的。
- en: 7.2\. Object construction and prototypes
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 对象构造和原型
- en: 'The simplest way to create a new object is with a statement like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新对象的最简单方法是使用如下语句：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This creates a new and empty object, which we can then populate with properties
    via assignment statements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的空对象，然后我们可以通过赋值语句向其中添加属性：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But those coming from an object-oriented background might miss the encapsulation
    and structuring that comes with a class constructor, a function that serves to
    initialize an object to a known initial state. After all, if we’re going to create
    multiple instances of the same type of object, assigning the properties individually
    isn’t only tedious but also highly error-prone. We’d like to be able to consolidate
    the set of properties and methods for a class of objects in one place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但那些来自面向对象背景的人可能会错过类构造函数带来的封装和结构化，类构造函数是一个用于初始化对象到已知初始状态的功能。毕竟，如果我们打算创建同一类型对象的多个实例，逐个分配属性不仅麻烦，而且容易出错。我们希望能够在同一个地方合并一个对象类的一组属性和方法。
- en: JavaScript provides such a mechanism, though in a different form than most other
    languages. Like object-oriented languages such as Java and C++, JavaScript employs
    the `new` operator to instantiate new objects via constructors, but there’s no
    true class definition in JavaScript. Instead, the `new` operator, applied to a
    constructor function (as you saw in [chapter 3](kindle_split_014.html#ch03)),
    triggers the creation of a newly allocated object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了这样的机制，尽管它的形式与其他大多数语言不同。像 Java 和 C++ 这样的面向对象语言，JavaScript 使用 `new`
    操作符通过构造函数实例化新对象，但在 JavaScript 中没有真正的类定义。相反，将 `new` 操作符应用于构造函数（正如你在第 3 章中看到的），会触发一个新分配的对象的创建。
- en: What we didn’t learn in the previous chapters was that every function has a
    prototype object that’s automatically set as the prototype of the objects created
    with that function. Let’s see how that works in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们没有学习到的是每个函数都有一个原型对象，这个对象会自动设置为使用该函数创建的对象的原型。让我们看看以下列表中它是如何工作的。
- en: Listing 7.2\. Creating a new instance with a prototyped method
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 使用原型方法创建新实例
- en: '![](172fig01_alt.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](172fig01_alt.jpg)'
- en: 'In this code, we define a seemingly do-nothing function named `Ninja` that
    we’ll invoke in two ways: as a “normal” function, `const ninja1 = Ninja()`; and
    as a constructor, `const ninja2 = new Ninja();`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们定义了一个看似什么也不做的函数`Ninja`，我们将以两种方式调用它：作为“正常”函数，`const ninja1 = Ninja()`；以及作为构造函数，`const
    ninja2 = new Ninja()`。
- en: 'When the function is created, it immediately gets a new object assigned to
    its prototype object, an object that we can extend just like any other object.
    In this case, we add a `swingSword` method to it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被创建时，它立即为其原型对象分配一个新的对象，这个对象我们可以像任何其他对象一样扩展。在这种情况下，我们向其中添加一个`swingSword`方法：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then we put the function through its paces. First we call the function normally
    and store its result in variable `ninja1`. Looking at the function body, we see
    that it returns no value, so we’d expect `ninja1` to test as `undefined`, which
    we assert to be `true`. As a simple function, `Ninja` doesn’t appear to be all
    that useful.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对这个函数进行测试。首先我们正常调用该函数并将结果存储在变量`ninja1`中。查看函数体，我们看到它没有返回任何值，所以我们预计`ninja1`将测试为`undefined`，我们断言这是`true`。作为一个简单的函数，`Ninja`看起来并不那么有用。
- en: Then we call the function via the `new` operator, invoking it as a *constructor*,
    and something completely different happens. The function is once again called,
    but this time a newly allocated object has been created and set as the context
    of the function (and is accessible through the `this` keyword). The result returned
    from the `new` operator is a reference to this new object. We then test that `ninja2`
    has a reference to the newly created object, and that that object has a `swingSword`
    method that we can call. See [figure 7.4](#ch07fig04) for a glimpse of the current
    application state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过`new`运算符调用该函数，将其作为*构造函数*调用，这时会发生完全不同的事情。函数再次被调用，但这次创建了一个新的对象，并将其设置为函数的上下文（并且可以通过`this`关键字访问）。`new`运算符返回的是对这个新对象的引用。然后我们测试`ninja2`是否引用了这个新创建的对象，并且这个对象有一个我们可以调用的`swingSword`方法。参见[图7.4](#ch07fig04)以了解当前应用程序的状态。
- en: Figure 7.4\. Every function, when created, gets a new prototype object. When
    we use a function as a constructor, the constructed object’s prototype is set
    to the function’s prototype.
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. 每个函数在创建时都会得到一个新的原型对象。当我们使用函数作为构造函数时，构造的对象的原型被设置为函数的原型。
- en: '![](07fig04_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig04_alt.jpg)'
- en: As you can see, a function, when created, gets a new object that’s assigned
    to its prototype property. The prototype object initially has only one property,
    `constructor`, that references back to the function (we’ll revisit the `constructor`
    property later).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数在创建时得到一个新的对象，该对象被分配给其原型属性。原型对象最初只有一个属性，即`constructor`，它引用回函数（我们稍后会重新访问`constructor`属性）。
- en: When we use a function as a constructor (for example, by calling `new Ninja()`),
    the prototype of the newly constructed object is set to the object referenced
    by the constructor function’s prototype.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用函数作为构造函数（例如，通过调用`new Ninja()`）时，新构造的对象的原型被设置为构造函数引用的对象。
- en: In this example, we’ve extended the `Ninja.prototype` with the `swingSword`
    method, and when the `ninja2` object is created, its `prototype` property is set
    to `Ninja`’s prototype. Therefore, when we try to access the `swingSword` property
    on `ninja2`, the search for that property is delegated to the `Ninja` prototype
    object. Notice that *all* objects created with the `Ninja` constructor will have
    access to the `swingSword` method. Now that’s code reuse!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过`swingSword`方法扩展了`Ninja.prototype`，当创建`ninja2`对象时，其`prototype`属性被设置为`Ninja`的原型。因此，当我们尝试在`ninja2`上访问`swingSword`属性时，对该属性的搜索被委托给`Ninja`原型对象。请注意，所有使用`Ninja`构造函数创建的对象都将能够访问`swingSword`方法。现在这就是代码复用！
- en: The `swingSword` method is a property of the `Ninja`’s prototype, and not a
    property of `ninja` instances. Let’s explore this difference between instance
    properties and prototype properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`swingSword`方法是`Ninja`原型的属性，而不是`ninja`实例的属性。让我们来探讨实例属性和原型属性之间的区别。'
- en: 7.2.1\. Instance properties
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 实例属性
- en: When the function is called as a constructor via the `new` operator, its context
    is defined as the new object instance. In addition to exposing properties via
    the prototype, we can initialize values within the constructor function via the
    `this` parameter. Let’s examine the creation of such instance properties in the
    next listing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数通过`new`运算符作为构造函数被调用时，其上下文被定义为新的对象实例。除了通过原型公开属性外，我们还可以通过`this`参数在构造函数内初始化值。让我们在下一列表中查看这种实例属性的创建。
- en: Listing 7.3\. Observing the precedence of initialization activities
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 观察初始化活动的优先级
- en: '![](174fig01_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](174fig01_alt.jpg)'
- en: '[Listing 7.3](#ch07ex03) is similar to the previous example in that we define
    a `swingSword` method by adding it to the `prototype` property of the constructor:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.3](#ch07ex03)与上一个示例类似，我们通过将其添加到构造函数的`prototype`属性中来定义`swingSword`方法：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But we also add an identically named method within the constructor function
    itself:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还在构造函数本身中添加了一个同名的方法：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The two methods are defined to return opposing results so we can tell which
    will be called.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法被定义为返回相反的结果，这样我们就可以知道哪个将被调用。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This isn’t anything we’d advise doing in real-world code; quite the opposite.
    We’re doing it here just to demonstrate the precedence of properties.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们在实际代码中建议做的事情；恰恰相反。我们在这里这样做只是为了演示属性的优先级。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When you run the test, you see that it passes! This shows that instance members
    will hide properties of the same name defined in the prototype. See [figure 7.5](#ch07fig05).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行测试时，你会看到它通过了！这表明实例成员将隐藏在原型中定义的同名属性。参见[图7.5](#ch07fig05)。
- en: Figure 7.5\. If a property can be found on the instance itself, the prototype
    isn’t even consulted!
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 如果实例本身可以找到属性，甚至不会咨询原型！
- en: '![](07fig05_alt.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig05_alt.jpg)'
- en: Within the constructor function, the `this` keyword refers to the newly created
    object, so the properties added within the constructor are created directly on
    the new `ninja` instance. Later, when we access the property `swingSword` on `ninja`,
    there’s no need to traverse the prototype chain (as shown in [figure 7.4](#ch07fig04));
    the property created within the constructor is immediately found and returned
    (see [figure 7.5](#ch07fig05)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数内部，`this`关键字指向新创建的对象，因此构造函数内添加的属性是直接创建在新的`ninja`实例上的。稍后，当我们访问`ninja`上的`swingSword`属性时，不需要遍历原型链（如图7.4所示）；在构造函数内创建的属性立即被找到并返回（参见图7.5）。
- en: This has an interesting side effect. Take a look at [figure 7.6](#ch07fig06),
    which shows the state of the application if we create three `ninja` instances.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个有趣的副作用。看看[图7.6](#ch07fig06)，它显示了如果我们创建三个`ninja`实例时应用程序的状态。
- en: Figure 7.6\. Every instance gets its own version of the properties created within
    the constructor, but they all have access to the same prototype’s properties.
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6\. 每个实例都拥有在构造函数内创建的属性的独特版本，但它们都可以访问相同的原型属性。
- en: '![](07fig06_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig06_alt.jpg)'
- en: As you can see, every `ninja` instance gets its own version of the properties
    that were created within the constructor, while they all have access to the same
    prototype’s properties. This is okay for value properties (for example, `swung`)
    that are specific to each object instance. But in certain cases it might be problematic
    for methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个`ninja`实例都拥有在构造函数内创建的属性的独特版本，同时它们都可以访问相同的原型属性。这对于特定于每个对象实例的值属性（例如，`swung`）来说是可行的。但在某些情况下，对于方法可能会出现问题。
- en: In this example, we’d have three versions of the `swingSword` method that all
    perform the same logic. This isn’t a problem if we create a couple of objects,
    but it’s something to pay attention to if we plan to create large numbers of objects.
    Because each method copy behaves the same, creating multiple copies often doesn’t
    make sense, because it only consumes more memory. Sure, in general, the JavaScript
    engine might perform some optimizations, but that’s not something to rely on.
    From that perspective, it makes sense to place object methods only on the function’s
    prototype, because in that way we have a single method shared by all object instances.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将有三个版本的`swingSword`方法，它们都执行相同的逻辑。如果我们创建几个对象，这并不是问题，但如果我们计划创建大量对象，那就需要注意了。因为每个方法副本的行为都是相同的，创建多个副本通常没有意义，因为它只会消耗更多的内存。当然，一般来说，JavaScript引擎可能会执行一些优化，但这不是我们可以依赖的。从这个角度来看，将对象方法仅放在函数的原型上是有意义的，因为这样我们就有了一个所有对象实例共享的单个方法。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember [chapter 5](kindle_split_016.html#ch05) on closures: Methods defined
    within constructor functions allow us to mimic private object variables. If this
    is something we need, specifying methods within constructors is the only way to
    go.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 [第 5 章](kindle_split_016.html#ch05) 中的闭包：在构造函数中定义的方法允许我们模拟私有对象变量。如果我们需要这样做，在构造函数中指定方法是唯一的方法。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.2.2\. Side effects of the dynamic nature of JavaScript
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. JavaScript 动态特性的副作用
- en: You’ve already seen that JavaScript is a dynamic language in which properties
    can be easily added, removed, and modified at will. The same thing holds for prototypes,
    both function prototypes and object prototypes. See the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到 JavaScript 是一种动态语言，其中的属性可以随意添加、删除和修改。同样，这也适用于原型，无论是函数原型还是对象原型。请参见以下列表。
- en: Listing 7.4\. With prototypes, everything can be changed at runtime
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 使用原型，一切都可以在运行时更改
- en: '![](ch07ex04-0.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex04-0.jpg)'
- en: '![](ch07ex04-1.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex04-1.jpg)'
- en: Here we again define a `Ninja` constructor and proceed to use it to create an
    object instance. The state of the application at this moment is shown in [figure
    7.7](#ch07fig07).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们再次定义一个 `Ninja` 构造函数，并继续使用它来创建一个对象实例。此时应用程序的状态如图 7.7 所示。
- en: Figure 7.7\. After construction, `ninja1` has the property `swung`, and its
    prototype is the `Ninja` prototype that has only a `constructor` property.
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 构造之后，`ninja1` 有 `swung` 属性，其原型是只有一个 `constructor` 属性的 `Ninja` 原型。
- en: '![](07fig07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig07.jpg)'
- en: '*After* the instance has been created, we add a `swingSword` method to the
    prototype. Then we run a test to show that the change we made to the prototype
    after the object was constructed takes effect. The current state of the application
    is shown in [figure 7.8](#ch07fig08).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* 实例创建之后，我们在原型中添加了一个 `swingSword` 方法。然后我们运行一个测试来显示在对象构造之后对原型所做的更改生效。应用程序的当前状态如图
    7.8 所示。'
- en: Figure 7.8\. Because the `ninja1` instance references the `Ninja` prototype,
    even changes made after the instance was constructed are accessible.
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 因为 `ninja1` 实例引用了 `Ninja` 原型，所以即使在实例创建之后所做的更改也可以访问。
- en: '![](07fig08_alt.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig08_alt.jpg)'
- en: Later, we override the `Ninja` function’s prototype by assigning it to a completely
    new object that has a `pierce` method. This results in the application state shown
    in [figure 7.9](#ch07fig09).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过将其赋值给一个具有 `pierce` 方法的全新对象来覆盖 `Ninja` 函数的原型。这导致应用程序的状态如图 7.9 所示。
- en: Figure 7.9\. The function’s prototype can be replaced at will. The already constructed
    instances reference the old prototype!
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9\. 函数的原型可以随意替换。已经构造的实例引用的是旧的原型！
- en: '![](07fig09_alt.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig09_alt.jpg)'
- en: As you can see, even though the `Ninja` function doesn’t reference the old `Ninja`
    prototype, the old prototype is still kept alive by the `ninja1` instance, which
    can still, through the prototype chain, access the `swingSword` method. But if
    we create new objects after this prototype switcheroo, the state of the application
    will be as shown in [figure 7.10](#ch07fig10).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管 `Ninja` 函数没有引用旧的 `Ninja` 原型，但旧的原型仍然被 `ninja1` 实例所保持活跃，它仍然可以通过原型链访问 `swingSword`
    方法。但如果我们在这个原型切换之后创建新的对象，应用程序的状态将如图 7.10 所示。
- en: Figure 7.10\. All newly created instances reference the new prototype.
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.10\. 所有新创建的实例都引用新的原型。
- en: '![](07fig10_alt.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig10_alt.jpg)'
- en: The reference between an object and the function’s prototype is established
    at the time of object instantiation. Newly created objects will have a reference
    to the new prototype and will have access to the `pierce` method, whereas the
    old, pre-prototype-change objects keep their original prototype, happily swinging
    their swords.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对象与函数原型的引用是在对象实例化时建立的。新创建的对象将引用新的原型，并将能够访问 `pierce` 方法，而旧的、在原型更改之前创建的对象则保持其原始原型，快乐地挥舞着他们的剑。
- en: We’ve explored how prototypes work and how they’re related to object instantiation.
    Well done! Now take a quick breath, so we can continue onward by learning more
    about the nature of those objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了原型的工作原理以及它们与对象实例化的关系。做得好！现在深吸一口气，我们可以继续学习更多关于这些对象特性的知识。
- en: 7.2.3\. Object typing via constructors
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 通过构造函数进行对象类型化
- en: Although it’s great to know how JavaScript uses the prototype to find the correct
    property references, it’s also handy to know which function constructed an object
    instance. As you’ve seen earlier, the constructor of an object is available via
    the constructor property of the constructor function prototype. For example, [figure
    7.11](#ch07fig11) shows the state of the application when we instantiate an object
    with the `Ninja` constructor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解JavaScript如何使用原型来找到正确的属性引用是很好的，但知道哪个函数构造了对象实例也很方便。正如你之前看到的，对象的构造函数可以通过构造函数原型的`constructor`属性来访问。例如，[图
    7.11](#ch07fig11) 显示了我们使用`Ninja`构造函数实例化对象时的应用程序状态。
- en: Figure 7.11\. The prototype object of each function has a constructor property
    that references the function.
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.11. 每个函数的原型对象都有一个指向函数的`constructor`属性。
- en: '![](07fig11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig11.jpg)'
- en: By using the `constructor` property, we can access the function that was used
    to create the object. This information can be used as a form of type checking,
    as shown in the next listing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`constructor`属性，我们可以访问用于创建对象的函数。这些信息可以用作类型检查的一种形式，如下一列表所示。
- en: Listing 7.5\. Examining the type of an instance and its constructor
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5. 检查实例的类型及其构造函数
- en: '![](180fig01_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](180fig01_alt.jpg)'
- en: We define a constructor and create an object instance using it. Then we examine
    the type of the instance by using the `typeof` operator. This doesn’t reveal much,
    as all instances will be objects, thus always returning `object` as the result.
    Much more interesting is the `instanceof` operator, which gives us a way to determine
    whether an instance was created by a particular function constructor. You’ll learn
    more about how the `instanceof` operator works later in the chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个构造函数并使用它来创建一个对象实例。然后我们通过使用`typeof`运算符来检查实例的类型。这并没有揭示太多，因为所有实例都将返回`object`，因此总是返回`object`作为结果。更有趣的是`instanceof`运算符，它为我们提供了一种确定实例是否由特定函数构造函数创建的方法。你将在本章后面了解更多关于`instanceof`运算符的工作原理。
- en: In addition, we can use the `constructor` property, that we now know is accessible
    to all instances, as a reference to the original function that created it. We
    can use this to verify the origin of the instance (much as we can with the `instanceof`
    operator).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用现在我们知道对所有实例都可访问的`constructor`属性，作为创建它的原始函数的引用。我们可以使用这一点来验证实例的来源（就像我们可以使用`instanceof`运算符一样）。
- en: Additionally, because this is just a reference to the original constructor,
    we can instantiate a new `Ninja` object using it, as shown in the next listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为这只是对原始构造函数的引用，我们可以使用它来实例化一个新的`Ninja`对象，如下一列表所示。
- en: Listing 7.6\. Instantiating a new object using a reference to a constructor
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6. 使用构造函数的引用来实例化新对象
- en: '![](180fig02_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](180fig02_alt.jpg)'
- en: Here we define a constructor and create an instance using that constructor.
    Then we use the `constructor` property of the created instance to construct a
    second instance. Testing shows that a second `Ninja` has been constructed and
    that the variable doesn’t merely point to the same instance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个构造函数并使用该构造函数创建了一个实例。然后我们使用创建的实例的`constructor`属性来构造第二个实例。测试显示，已经构造了第二个`Ninja`实例，并且变量不仅仅指向同一个实例。
- en: What’s especially interesting is that we can do this without even having access
    to the original function; we can use the reference completely behind the scenes,
    even if the original constructor is no longer in scope.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其有趣的是，我们甚至不需要访问原始函数就能做到这一点；我们可以在幕后完全使用引用，即使原始构造函数已经不在作用域内。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Although the `constructor` property of an object can be changed, doing so doesn’t
    have any immediate or obvious constructive purpose (though we might be able to
    think of some malicious ones). The property’s reason for being is to indicate
    from where the object was constructed. If the `constructor` property is overwritten,
    the original value is lost.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对象的`constructor`属性可以被更改，但这样做并没有任何立即或明显的建设性目的（尽管我们可能能够想到一些恶意用途）。这个属性存在的理由是指出对象是从哪里构造的。如果`constructor`属性被覆盖，原始值就会丢失。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That’s all useful, but we’ve just scratched the surface of the superpowers that
    prototypes confer on us. Now things get interesting.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这都是很有用的，但我们只是刚刚触及了原型赋予我们的超级能力的表面。现在事情变得有趣起来。
- en: 7.3\. Achieving inheritance
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 实现继承
- en: '*Inheritance* is a form of reuse in which new objects have access to properties
    of existing objects. This helps us avoid the need to repeat code and data across
    our code base. In JavaScript, inheritance works slightly differently than in other
    popular object-oriented languages. Consider the following listing, in which we
    attempt to achieve inheritance.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承*是一种重用形式，其中新对象可以访问现有对象的属性。这有助于我们避免在代码库中重复代码和数据。在JavaScript中，继承的工作方式与其他流行的面向对象语言略有不同。考虑以下列表，我们试图实现继承。'
- en: Listing 7.7\. Trying to achieve inheritance with prototypes
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 尝试使用原型实现继承
- en: '![](181fig01_alt.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](181fig01_alt.jpg)'
- en: Because the prototype of a function is an object, there are multiple ways of
    copying functionality (such as properties or methods) to effect inheritance. In
    this code, we define a `Person` and then a `Ninja`. And because a `Ninja` is clearly
    a person, we want `Ninja` to inherit the attributes of `Person`. We attempt to
    do so by copying the `dance` property of the `Person` prototype’s method to a
    similarly named property in the `Ninja` prototype.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数的原型是一个对象，所以有多种方式可以复制功能（如属性或方法）以实现继承。在这段代码中，我们定义了一个“人”，然后定义了一个“忍者”。因为“忍者”显然是一个人，我们希望“忍者”继承“人”的属性。我们尝试通过将“人”原型方法中的“dance”属性复制到“忍者”原型中同名属性中来实现这一点。
- en: Running our test reveals that although we may have taught the ninja to dance,
    we failed to make the `Ninja` a `Person`, as shown in [figure 7.12](#ch07fig12).
    We taught the `Ninja` to mimic the dance of a person, but that hasn’t *made* the
    `Ninja` a `Person`. That’s not inheritance—it’s just copying.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的测试显示，尽管我们可能已经教会了忍者跳舞，但我们未能使“忍者”成为“人”，如图7.12所示。我们教会了“忍者”模仿人的舞蹈，但这并没有*使*“忍者”成为“人”。这不是继承——这只是复制。
- en: Figure 7.12\. Our `Ninja` isn’t really a `Person`. No happy dance!
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12\. 我们的“忍者”实际上不是一个“人”。没有快乐的舞蹈！
- en: '![](07fig12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig12.jpg)'
- en: Apart from the fact that this approach isn’t exactly working, we’d also need
    to copy each property of `Person` to the `Ninja` prototype individually. That’s
    no way to do inheritance. Let’s keep exploring.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种方法并不完全奏效之外，我们还需要将“人”的每个属性单独复制到“忍者”的原型中。这不是继承的正确方法。让我们继续探索。
- en: 'What we really want to achieve is a *prototype chain* so that a `Ninja` can
    *be* a `Person`, and a `Person` can be a `Mammal`, and a `Mammal` can be an `Animal`,
    and so on, all the way to `Object`. The best technique for creating such a prototype
    chain is to use an instance of an object as the other object’s prototype:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要实现的是一个*原型链*，使得一个“忍者”可以*成为*一个“人”，一个“人”可以成为“哺乳动物”，一个“哺乳动物”可以成为“动物”，以此类推，一直到“对象”。创建这种原型链的最佳技术是使用一个对象的实例作为另一个对象的原型：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This preserves the prototype chain, because the prototype of the `SubClass`
    instance will be an instance of the `SuperClass`, which has a prototype with all
    the properties of `SuperClass`, and which will in turn have a prototype pointing
    to an instance of *its* superclass, and on and on. In the next listing, we change
    [listing 7.7](#ch07ex07) slightly to use this technique.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这保留了原型链，因为“子类”实例的原型将是一个“超类”的实例，该实例具有“超类”的所有属性，并且它将反过来有一个指向其超类实例的原型，以此类推。在下一个列表中，我们稍微修改了[列表7.7](#ch07ex07)以使用这种技术。
- en: Listing 7.8\. Achieving inheritance with prototypes
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. 使用原型实现继承
- en: '![](182fig01_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](182fig01_alt.jpg)'
- en: The only change to the code is to use an instance of `Person` as the prototype
    for `Ninja`. Running the tests shows that we’ve succeeded, as shown in [figure
    7.13](#ch07fig13). Now we’ll take a closer look at the inner workings by looking
    at the state of the application after we’ve created the new `ninja` object, as
    shown in [figure 7.14](#ch07fig14).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的唯一更改是将“人”的一个实例用作“忍者”的原型。运行测试显示我们已经成功，如图7.13所示。现在我们将通过查看创建新“忍者”对象后的应用程序状态来更详细地了解其内部工作原理，如图7.14所示。
- en: Figure 7.13\. Our `Ninja` is a `Person`! Let the victory dance begin.
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.13\. 我们的“忍者”是一个“人”！胜利的舞蹈开始吧。
- en: '![](07fig13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig13.jpg)'
- en: Figure 7.14\. We’ve achieved inheritance by setting the prototype of the `Ninja`
    constructor to a new instance of a `Person` object.
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14\. 我们通过将“忍者”构造函数的原型设置为“人”对象的新实例来实现继承。
- en: '![](07fig14_alt.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig14_alt.jpg)'
- en: '[Figure 7.14](#ch07fig14) shows that when we define a `Person` function, a
    `Person` prototype is also created that references the `Person` function through
    its `constructor` property. Normally, we can extend the `Person` prototype with
    additional properties, and in this case, we specify that every person, created
    with the `Person` constructor, has access to the `dance` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.14](#ch07fig14)显示，当我们定义一个`Person`函数时，也会创建一个`Person`原型，它通过其`constructor`属性引用`Person`函数。通常，我们可以通过扩展`Person`原型来添加额外的属性，在这种情况下，我们指定每个使用`Person`构造函数创建的人都可以访问`dance`方法：'
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also define a `Ninja` function that gets its own prototype object with a
    `constructor` property referencing the `Ninja` function: `function Ninja(){}`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`Ninja`函数，它具有自己的原型对象，该对象具有一个引用`Ninja`函数的`constructor`属性：`function Ninja(){}`。
- en: 'Next, in order to achieve inheritance, we replace the prototype of the `Ninja`
    function with a new `Person` instance. Now, when we create a new `Ninja` object,
    the internal prototype property of the newly created `ninja` object will be set
    to the object to which the current `Ninja` prototype property points to, the previously
    constructed `Person` instance:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了实现继承，我们将`Ninja`函数的原型替换为一个新的`Person`实例。现在，当我们创建一个新的`Ninja`对象时，新创建的`ninja`对象的内部原型属性将被设置为当前`Ninja`原型属性指向的对象，即之前构建的`Person`实例：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we try to access the `dance` method through the `ninja` object, the JavaScript
    runtime will first check the `ninja` object itself. Because it doesn’t have the
    `dance` property, its prototype, the `person` object, is searched. The `person`
    object also doesn’t have the `dance` property, so its prototype is searched, and
    the property is finally found. This is how to achieve inheritance in JavaScript!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试通过`ninja`对象访问`dance`方法时，JavaScript运行时会首先检查`ninja`对象本身。因为它没有`dance`属性，所以会搜索其原型，即`person`对象。`person`对象也没有`dance`属性，所以会继续搜索其原型，最终找到该属性。这就是JavaScript中实现继承的方法！
- en: 'Here’s the important implication: When we perform an `instanceof` operation,
    we can determine whether the function inherits the functionality of any object
    in its prototype chain.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的含义：当我们执行`instanceof`操作时，我们可以确定函数是否继承了其原型链中任何对象的函数功能。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another technique that may have occurred to you, and that we advise strongly
    against, is to use the `Person` prototype object directly as the `Ninja` prototype,
    like this: `Ninja.prototype = Person.prototype`. Any changes to the `Ninja` prototype
    will then also change the `Person` prototype (because they’re the same object),
    and that’s bound to have undesirable side effects.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能已经想到的技术，但我们强烈建议不要使用，是将`Person`原型对象直接用作`Ninja`原型，如下所示：`Ninja.prototype =
    Person.prototype`。然后，对`Ninja`原型的任何更改也将更改`Person`原型（因为它们是同一个对象），这很可能会产生不良的副作用。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: An additional happy side effect of doing prototype inheritance in this manner
    is that all inherited function prototypes will continue to live-update. Objects
    that inherit from the prototype always have access to the current prototype properties.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行原型继承的另一个额外的好处是，所有继承的函数原型都将继续实时更新。从原型继承的对象始终可以访问当前的原型属性。
- en: 7.3.1\. The problem of overriding the constructor property
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 覆盖构造函数属性的问题
- en: 'If we take a closer look at [figure 7.14](#ch07fig14), we’ll see that by setting
    the new `Person` object as a prototype of the `Ninja` constructor, we’ve lost
    our connection to the `Ninja` constructor that was previously kept by the original
    `Ninja` prototype. This is a problem, because the `constructor` property can be
    used to determine the function with which the object was created. Somebody using
    our code could make a perfectly reasonable assumption that the following test
    will pass:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察[图7.14](#ch07fig14)，我们会看到，通过将新的`Person`对象设置为`Ninja`构造函数的原型，我们已经失去了与原始`Ninja`原型保持的联系的`Ninja`构造函数。这是一个问题，因为`constructor`属性可以用来确定创建对象时所使用的函数。有人使用我们的代码可能会做出一个完全合理的假设，即以下测试将会通过：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But in the current state of the application, this test fails. As [figure 7.14](#ch07fig14)
    shows, if we search the `ninja` object for the `constructor` property, we won’t
    find it. So we go over to its prototype, which also doesn’t have a constructor
    property, and again, we follow the prototype and end up in the prototype object
    of `Person`, which has a `constructor` property referencing the `Person` function.
    In effect, we get the wrong answer: If we ask the `ninja` object which function
    has constructed it, we’ll get `Person` as the answer. This can be the source of
    some serious bugs.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但在当前的应用状态中，这个测试失败了。如图7.14所示，如果我们搜索`ninja`对象中的`constructor`属性，我们将找不到它。因此，我们转向其原型，它也没有`constructor`属性，然后我们再次跟随原型，最终到达`Person`的原型对象，它有一个指向`Person`函数的`constructor`属性。实际上，我们得到了错误的答案：如果我们询问`ninja`对象哪个函数构建了它，我们将得到`Person`作为答案。这可能是某些严重错误的来源。
- en: It’s up to us to fix this situation! But before we can do that, we have to take
    a detour and see how JavaScript enables us to configure properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于我们如何解决这个问题！但在我们能够这样做之前，我们必须绕道而行，看看JavaScript是如何使我们能够配置属性的。
- en: Configuring object properties
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置对象属性
- en: 'In JavaScript, every object property is described with a *property descriptor*
    through which we can configure the following keys:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，每个对象属性都是通过一个*属性描述符*来描述的，通过它可以配置以下键：
- en: '`configurable`—If set to `true`, the property’s descriptor can be changed and
    the property can be deleted. If set to `false`, we can do neither of these things.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurable`——如果设置为`true`，属性的描述符可以被更改，属性可以被删除。如果设置为`false`，我们无法执行这两件事。'
- en: '`enumerable`—If set to `true`, the property shows up during a `for-in` loop
    over the object’s properties (we’ll get to the `for-in` loop soon).'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerable`——如果设置为`true`，属性将在遍历对象属性的`for-in`循环中显示（我们很快就会了解到`for-in`循环）。'
- en: '`value`—Specifies the value of the property. Defaults to `undefined`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`——指定属性的值。默认为`undefined`。'
- en: '`writable`—If set to `true`, the property value can be changed by using an
    assignment.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable`——如果设置为`true`，属性值可以通过赋值来更改。'
- en: '`get`—Defines the *getter* function, which will be called when we access the
    property. Can’t be defined in conjunction with `value` and `writable`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`——定义*获取器*函数，当访问属性时将被调用。不能与`value`和`writable`一起定义。'
- en: '`set`—Defines the *setter* function, which will be called whenever an assignment
    is made to the property. Also can’t be defined in conjunction with `value` and
    `writable`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`——定义*设置器*函数，当对属性进行赋值时将被调用。也不能与`value`和`writable`一起定义。'
- en: 'Say we create a property through a simple assignment, for example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过简单的赋值创建一个属性，例如：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This property will be configurable, enumerable, and writable, its value will
    be set to `Yoshi`, and functions `get` and `set` would be `undefined`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将是可配置的、可枚举的、可写的，其值将被设置为`Yoshi`，而`get`和`set`函数将是`undefined`。
- en: When we want to fine-tune our property configuration, we can use the built-in
    `Object.defineProperty` method, which takes an object on which the property will
    be defined, the name of the property, and a property descriptor object. As an
    example, take a look at the following code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要微调我们的属性配置时，我们可以使用内置的`Object.defineProperty`方法，它接受一个对象，该对象将定义属性，属性的名字，以及一个属性描述符对象。以下是一个例子。
- en: Listing 7.9\. Configuring properties
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. 配置属性
- en: '![](185fig01_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](185fig01_alt.jpg)'
- en: 'We start with the creation of an empty object, to which we add two properties:
    `name` and `weapon`, in the good old-fashioned way, by using assignments. Next,
    we use the built-in `Object.define-Property` method to define the property `sneaky`,
    which isn’t `configurable`, isn’t `enumerable`, and has its `value` set to `true`.
    This `value` can be changed because it’s `writable`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个空对象开始，向其中添加两个属性：`name`和`weapon`，按照传统的方式，通过使用赋值。接下来，我们使用内置的`Object.defineProperty`方法来定义属性`sneaky`，它不是`configurable`的，不是`enumerable`的，并且其`value`被设置为`true`。因为这个`value`可以被更改，所以它是`writable`的。
- en: Finally, we test that we can access the newly created `sneaky` property, and
    we use the `for-in` loop to go through all enumerable properties of the object.
    [Figure 7.15](#ch07fig15) shows the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试我们是否可以访问新创建的`sneaky`属性，我们使用`for-in`循环遍历对象的所有可枚举属性。[图7.15](#ch07fig15)显示了结果。
- en: Figure 7.15\. Properties `name` and `weapon` will be visited in the `for-in`
    loop, whereas our specially added `sneaky` property won’t (even though we can
    access it normally).
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.15\. 在`for-in`循环中将被访问的属性是`name`和`weapon`，而我们的特殊添加的`sneaky`属性则不会（即使我们通常可以访问它）。
- en: '![](07fig15.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3](07fig15.jpg)'
- en: By setting `enumerable` to `false`, we can be sure that the property won’t appear
    when using the `for-in` loop. To understand why we’d want to do something like
    this, let’s go back to the original problem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `enumerable` 设置为 `false`，我们可以确保属性在使用 `for-in` 循环时不会出现。为了理解我们为什么要这样做，让我们回到原始问题。
- en: Finally solving the problem of overriding the constructor property
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最终解决了覆盖构造函数属性的问题
- en: 'When trying to extend `Person` with `Ninja` (or to make `Ninja` a subclass
    of `Person`), we ran into the following problem: When we set a new `Person` object
    as a prototype to the `Ninja` constructor, we lose the original `Ninja` prototype
    that keeps our `constructor` property. We don’t want to lose the `constructor`
    property, because it’s useful for determining the function used to create our
    object instances and it might be expected by other developers working on our code
    base.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试用 `Ninja` 扩展 `Person`（或者使 `Ninja` 成为 `Person` 的子类）时，我们遇到了以下问题：当我们把一个新的 `Person`
    对象设置为 `Ninja` 构造函数的原型时，我们失去了原本的 `Ninja` 原型，它保留了我们的 `constructor` 属性。我们不希望失去 `constructor`
    属性，因为它对于确定创建我们的对象实例所用的函数很有用，并且其他正在我们代码库上工作的开发者可能会期望它。
- en: We can solve this problem by using the knowledge that we’ve just obtained. We’ll
    define a new `constructor` property on the new `Ninja.prototype` by using the
    `Object.defineProperty` method. See the following listing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用我们刚刚获得的知识来解决这个问题。我们将使用 `Object.defineProperty` 方法在新的 `Ninja.prototype`
    上定义一个新的 `constructor` 属性。请参见以下列表。
- en: Listing 7.10\. Fixing the constructor property problem
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 修复构造函数属性问题
- en: '![](186fig01_alt.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4](186fig01_alt.jpg)'
- en: Now if we run the code, we’ll see that everything is peachy. We’ve reestablished
    the connection between `ninja` instances and the `Ninja` function, so we can know
    that they were constructed by the `Ninja` function. In addition, if anybody tries
    to loop through the properties of the `Ninja.prototype` object, we’ve made sure
    that our patched-on property `constructor` won’t be visited. Now that’s the mark
    of a true ninja; we went in, did our job, and got out, without anybody noticing
    anything from the outside!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们运行代码，我们会看到一切都很顺利。我们已经重新建立了 `ninja` 实例和 `Ninja` 函数之间的联系，因此我们可以知道它们是由 `Ninja`
    函数构建的。此外，如果有人尝试遍历 `Ninja.prototype` 对象的属性，我们已经确保我们的修补属性 `constructor` 不会被访问。现在这就是真正的忍者的标志；我们进去，完成了我们的工作，然后离开，没有人注意到外面有任何变化！
- en: 7.3.2\. The instanceof operator
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. instanceof 操作符
- en: In most programming languages, the straightforward approach for checking whether
    an object is a part of a class hierarchy is to use the `instanceof` operator.
    For example, in Java, the `instanceof` operator works by checking whether the
    object on the left side is either the same class or a subclass of the class type
    on the right.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，检查一个对象是否属于类层次结构的一种直接方法就是使用 `instanceof` 操作符。例如，在 Java 中，`instanceof`
    操作符通过检查左侧的对象是否与右侧的类类型相同或是一个子类来工作。
- en: 'Although certain parallels could be made with how the `instanceof` operator
    works in JavaScript, there’s a little twist. In JavaScript, the `instanceof` operator
    works on the prototype chain of the object. For example, say we have the following
    expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以与 JavaScript 中的 `instanceof` 操作符的工作方式建立某些相似之处，但也有一些细微差别。在 JavaScript 中，`instanceof`
    操作符在对象的原型链上工作。例如，假设我们有以下表达式：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `instanceof` operator works by checking whether the *current* prototype
    of the `Ninja` function is in the prototype chain of the `ninja` instance. Let’s
    go back to our persons and ninjas, for a more concrete example.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 操作符通过检查 `Ninja` 函数的 *当前* 原型是否在 `ninja` 实例的原型链中来工作。让我们回到我们的人物和忍者，以一个更具体的例子。'
- en: Listing 7.11\. Studying the instanceof operator
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 研究 instanceof 操作符
- en: '![](187fig01_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](187fig01_alt.jpg)'
- en: As expected, a ninja is, at the same time, a `Ninja` and a `Person`. But, to
    nail down this point, [figure 7.16](#ch07fig16) shows how the whole thing works
    behind the scenes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，忍者同时是 `Ninja` 和 `Person`。但是，为了确定这一点，[图 7.16](#ch07fig16) 展示了幕后整个工作的过程。
- en: Figure 7.16\. The prototype chain of a `ninja` instance is composed of a `new
    Person()` object and the `Person prototype`.
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.16\. `ninja` 实例的原型链由一个 `new Person()` 对象和 `Person prototype` 组成。
- en: '![](07fig16_alt.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](07fig16_alt.jpg)'
- en: The prototype chain of a ninja instance is composed of a `new Person()` object,
    through which we’ve achieved inheritance, and the `Person prototype`. When evaluating
    the expression `ninja instanceof Ninja`, the JavaScript engine takes the prototype
    of the `Ninja` function, the `new Person()` object, and checks whether it’s in
    the prototype chain of the `ninja` instance. Because the `new Person()` object
    is a direct prototype of the `ninja` instance, the result is `true`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ninja`实例的原型链由一个`new Person()`对象组成，通过它我们实现了继承，以及`Person prototype`。当评估表达式`ninja
    instanceof Ninja`时，JavaScript引擎会取`Ninja`函数的原型，`new Person()`对象，并检查它是否在`ninja`实例的原型链中。因为`new
    Person()`对象是`ninja`实例的直接原型，所以结果是`true`。'
- en: In the second case, where we check `ninja instanceof Person`, the JavaScript
    engine takes the prototype of the `Person` function, the `Person prototype`, and
    checks whether it can be found in the prototype chain of the `ninja` instance.
    Again, it can, because it’s the prototype of our `new Person()` object, which,
    as we’ve already seen, is the prototype of the `ninja` instance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，当我们检查`ninja instanceof Person`时，JavaScript引擎会取`Person`函数的原型，`Person
    prototype`，并检查它是否可以在`ninja`实例的原型链中找到。同样，它可以找到，因为它是我们`new Person()`对象的原型，正如我们之前看到的，它是`ninja`实例的原型。
- en: And that’s all there is to know about the `instanceof` operator. Although its
    most common use is in providing a clear way to determine whether an instance was
    created by a particular function constructor, it doesn’t exactly work like that.
    Instead, it checks whether the prototype of the right-side function is in the
    prototype chain of the object on the left. Therefore, there is a caveat that we
    should be careful about.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`instanceof`运算符的所有知识就这些了。尽管它最常见的使用是在提供一个明确的方式来确定一个实例是否是由特定的函数构造器创建的，但它并不完全是这样工作的。相反，它检查右侧函数的原型是否在左侧对象的原型链中。因此，有一个需要注意的警告。
- en: The instanceof caveat
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: instanceof的注意事项
- en: As you’ve seen multiple times throughout this chapter, JavaScript is a dynamic
    language in which we can modify a *lot* of things during program execution. For
    example, there’s nothing stopping us from changing the prototype of a constructor,
    as shown in the following listing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中多次看到的，JavaScript是一种动态语言，在程序执行期间我们可以修改很多东西。例如，没有阻止我们改变构造函数的原型，如下面的列表所示。
- en: Listing 7.12\. Watch out for changes to constructor prototypes
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.12. 注意构造函数原型的变化
- en: '![](189fig01_alt.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](189fig01_alt.jpg)'
- en: In this example, we again repeat all the basic steps of making a `ninja` instance,
    and our first test goes fine. But if we change the prototype of the `Ninja` constructor
    function *after* the creation of the `ninja` instance, and again test whether
    `ninja` is an `instanceof Ninja`, we’ll see that the situation has changed. This
    will surprise us only if we cling to the inaccurate assumption that the `instanceof`
    operator tells us whether an instance was created by a particular function constructor.
    If, on the other hand, we take the real semantics of the `instanceof` operator—that
    it checks only whether the prototype of the function on the right side is in the
    prototype chain of the object on the left side—we won’t be surprised. This situation
    is shown in [figure 7.17](#ch07fig17).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次重复了创建`ninja`实例的所有基本步骤，我们的第一次测试进行得很顺利。但如果我们在创建`ninja`实例之后改变`Ninja`构造函数的原型，然后再测试`ninja`是否是`Ninja`的实例，我们会看到情况已经改变。这只会让我们感到惊讶，如果我们坚持认为`instanceof`运算符告诉我们实例是否是由特定的函数构造器创建的。另一方面，如果我们接受`instanceof`运算符的真实语义——它只检查右侧函数的原型是否在左侧对象的原型链中——我们就不会感到惊讶。这种情况在[图7.17](#ch07fig17)中显示。
- en: Figure 7.17\. The `instanceof` operator checks whether the prototype of the
    function on the right is in the prototype chain of the object on the left. Be
    careful; the function’s prototype can be changed anytime!
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图7.17]. `instanceof`运算符检查右侧函数的原型是否在左侧对象的原型链中。请注意；函数的原型可以随时更改！'
- en: '![](07fig17_alt.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig17_alt.jpg)'
- en: 'Now that we understand how prototypes work in JavaScript, and how to use prototypes
    in conjunction with constructor functions to implement inheritance, let’s move
    on to a new addition in the ES6 version of JavaScript: classes.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JavaScript中原型的工作方式，以及如何结合构造函数使用原型来实现继承，让我们继续探讨JavaScript ES6版本中的新特性：类。
- en: 7.4\. Using JavaScript “classes” in ES6
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 在ES6中使用JavaScript“类”
- en: It’s great that JavaScript lets us use a form of inheritance via prototypes.
    But many developers, especially those from a classical object-oriented background,
    would prefer a simplification or abstraction of JavaScript’s inheritance system
    into one that they’re more familiar with.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，JavaScript允许我们通过原型的方式使用一种继承形式。但许多开发者，尤其是那些有经典面向对象背景的开发者，更希望将JavaScript的继承系统简化或抽象成一个他们更熟悉的系统。
- en: This inevitably leads toward the realm of classes, even though JavaScript doesn’t
    support classical inheritance natively. As a response to this need, several JavaScript
    libraries that simulate classical inheritance have popped up. Because each library
    implements classes in its own way, the ECMAScript committee has standardized the
    syntax for simulating class-based inheritance. Notice how we said *simulating*.
    Even though now we can use the `class` keyword in JavaScript, the underlying implementation
    is still based on prototype inheritance!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这不可避免地引导我们进入类的领域，尽管JavaScript本身不支持原生的经典继承。作为对这个需求的回应，已经出现了几个模拟经典继承的JavaScript库。因为每个库都以自己的方式实现类，ECMAScript委员会已经标准化了模拟基于类继承的语法。注意我们是如何说“模拟”的。尽管现在我们可以在JavaScript中使用`class`关键字，但底层实现仍然是基于原型继承的！
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `class` keyword has been added to the ES6 version of JavaScript, and not
    all browsers implement it (see [http://mng.bz/3ykA](http://mng.bz/3ykA) for current
    support).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`关键字已被添加到JavaScript的ES6版本中，并且并非所有浏览器都实现了它（有关当前支持情况，请参阅[http://mng.bz/3ykA](http://mng.bz/3ykA)）。'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s start by studying the new syntax.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习新的语法开始。
- en: 7.4.1\. Using the class keyword
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 使用类关键字
- en: ES6 introduces a new `class` keyword that provides a much more elegant way of
    creating objects and implementing inheritance than manually implementing it ourselves
    with prototypes. Using the `class` keyword is easy, as shown in the following
    listing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一个新的`class`关键字，它提供了一个比手动使用原型实现对象和继承更优雅的方法。使用`class`关键字很简单，如下面的列表所示。
- en: Listing 7.13\. Creating a class in ES6
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 在ES6中创建类
- en: '![](190fig01_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](190fig01_alt.jpg)'
- en: '[Listing 7.13](#ch07ex13) shows that we can create a `Ninja` class by using
    the `class` keyword. When creating ES6 classes, we can explicitly define a `constructor`
    function that will be invoked when instantiating a `Ninja` instance. In the constructor’s
    body, we can access the newly created instance with the `this` keyword, and we
    can easily add new properties, such as the `name` property. Within the class body,
    we can also define methods that will be accessible to all `Ninja` instances. In
    this case, we’ve defined a `swingSword` method that returns `true`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.13](#ch07ex13) 展示了我们可以通过使用`class`关键字来创建一个`Ninja`类。在创建ES6类时，我们可以显式定义一个在实例化`Ninja`实例时将被调用的`constructor`函数。在构造函数体内，我们可以使用`this`关键字访问新创建的实例，并且可以轻松添加新的属性，例如`name`属性。在类体内，我们还可以定义所有`Ninja`实例都可以访问的方法。在这种情况下，我们定义了一个返回`true`的`swingSword`方法：'
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next we can create a `Ninja` instance by calling the `Ninja` class with the
    keyword `new`, just as we would if `Ninja` was a simple constructor function (as
    earlier in the chapter):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过使用关键字`new`调用`Ninja`类来创建一个`Ninja`实例，就像我们之前在章节中用`Ninja`作为简单的构造函数一样：
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we can test that the `ninja` instance behaves as expected, that it’s
    an `instance-of Ninja`, has a `name` property, and has access to the `swingSword`
    method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试`ninja`实例是否按预期行为，即它是一个`instance-of Ninja`，有一个`name`属性，并且可以访问`swingSword`方法：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Classes are syntactic sugar
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类是语法糖
- en: As mentioned earlier, even though ES6 has introduced the `class` keyword, under
    the hood we’re still dealing with good old prototypes; classes are syntactic sugar
    designed to make our lives a bit easier when mimicking classes in JavaScript.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尽管ES6引入了`class`关键字，但底层我们仍然处理的是古老的、好的原型；类是语法糖，旨在使我们在模拟JavaScript中的类时生活更加轻松。
- en: 'Our class code from [listing 7.13](#ch07ex13) can be translated to functionally
    identical ES5 code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[列表 7.13](#ch07ex13) 中的类代码可以转换为功能上相同的ES5代码：
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, there’s nothing especially new with ES6 classes. The code is
    more elegant, but the same concepts are applied.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ES6类并没有什么特别新的地方。代码更加优雅，但应用的概念是相同的。
- en: Static methods
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态方法
- en: In the previous examples, you saw how to define object methods (prototype methods),
    accessible to all object instances. In addition to such methods, classical object-oriented
    languages such as Java use static methods, methods defined on a class level. Check
    out the following example.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到了如何定义对象方法（原型方法），这些方法对所有对象实例都是可访问的。除了这些方法之外，像Java这样的经典面向对象语言还使用静态方法，即在类级别上定义的方法。查看以下示例。
- en: Listing 7.14\. Static methods in ES6
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. ES6 中的静态方法
- en: '![](ch07ex14-0.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex14-0.jpg)'
- en: '![](ch07ex14-1.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex14-1.jpg)'
- en: We again create a `Ninja` class that has a `swingSword` method accessible from
    all `ninja` instances. We also define a static method, `compare`, by prefixing
    the method name with the keyword `static`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次创建一个具有 `swingSword` 方法的 `Ninja` 类，这个方法可以从所有 `ninja` 实例中访问。我们还通过在方法名前加关键字
    `static` 定义了一个静态方法 `compare`。
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `compare` method, which compares the skill levels of two ninjas, is defined
    on the class level, and not the instance level! Later we test that this effectively
    means that the `compare` method isn’t accessible from `ninja` instances but is
    accessible from the `Ninja` class:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`compare` 方法，它比较两个忍者的技能水平，是在类级别上定义的，而不是实例级别！稍后我们将测试这实际上意味着 `compare` 方法不能从
    `ninja` 实例中访问，但可以从 `Ninja` 类中访问：'
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also look at how “static” methods can be implemented in pre-ES6 code.
    For this, we have to remember only that classes are implemented through functions.
    Because static methods are class-level methods, we can implement them by taking
    advantage of functions as first-class objects, and adding a method property to
    our constructor function, as in the following example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看看如何在 ES6 之前的代码中实现“静态”方法。为此，我们只需要记住，类是通过函数实现的。因为静态方法是类级别的，我们可以通过利用函数作为一等对象，并给我们的构造函数添加一个方法属性来实现它们，如下例所示：
- en: '![](193fig01_alt.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](193fig01_alt.jpg)'
- en: Now let’s move on to inheritance.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论继承。
- en: 7.4.2\. Implementing inheritance
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. 实现继承
- en: 'To be honest, performing inheritance in pre-ES6 code can be a pain. Let’s go
    back to our trusted Ninjas, Persons example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，在 ES6 之前的代码中执行继承可能会很痛苦。让我们回到我们信任的忍者和人例子：
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There’s a lot to keep in mind here: Methods accessible to all instances should
    be added directly to the prototype of the constructor function, as we did with
    the `dance` method and the `Person` constructor. If we want to implement inheritance,
    we have to set the prototype of the derived “class” to the instance of the base
    “class.” In this case, we assigned a new instance of `Person` to `Ninja.prototype`.
    Unfortunately, this messes up the `constructor` property, so we have to manually
    restore it with the `Object.defineProperty` method. This is a lot to keep in mind
    when trying to achieve a relatively simple and commonly used feature (inheritance).
    Luckily, with ES6, all of this is significantly simplified.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多需要注意的地方：应该直接将可访问所有实例的方法添加到构造函数的原型中，就像我们用 `dance` 方法和 `Person` 构造函数所做的那样。如果我们想实现继承，我们必须将派生“类”的原型设置为基“类”的实例。在这种情况下，我们将
    `Person` 的新实例分配给了 `Ninja.prototype`。不幸的是，这破坏了 `constructor` 属性，因此我们必须使用 `Object.defineProperty`
    方法手动恢复它。在尝试实现一个相对简单且常用功能（继承）时，这些都是需要记住的。幸运的是，随着 ES6 的出现，所有这些都显著简化了。
- en: Let’s see how it’s done in the following listing.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下列表中是如何实现的。
- en: Listing 7.15\. Inheritance in ES6
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. ES6 中的继承
- en: '![](ch07ex15-0.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex15-0.jpg)'
- en: '![](ch07ex15-1.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex15-1.jpg)'
- en: '[Listing 7.15](#ch07ex15) shows how to achieve inheritance in ES6; we use the
    `extends` keyword to inherit from another class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.15](#ch07ex15) 展示了如何在 ES6 中实现继承；我们使用 `extends` 关键字从另一个类继承：'
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we create a `Person` class with a constructor that assigns
    a `name` to each `Person` instance. We also define a `dance` method that will
    be accessible to all `Person` instances:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个 `Person` 类，其构造函数将 `name` 分配给每个 `Person` 实例。我们还定义了一个 `dance` 方法，它将可访问所有
    `Person` 实例：
- en: '[PRE21]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next we define a `Ninja` class that extends the `Person` class. It has an additional
    `weapon` property, and a `wieldWeapon` method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义一个扩展 `Person` 类的 `Ninja` 类。它有一个额外的 `weapon` 属性，以及一个 `wieldWeapon` 方法：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the constructor of the derived, `Ninja` class, there’s a call to the constructor
    of the base, `Person` class, through the keyword `super`. This should be familiar,
    if you’ve worked with any class-based language.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类 `Ninja` 的构造函数中，通过关键字 `super` 调用了基类 `Person` 的构造函数。如果你使用过任何基于类的语言，这应该很熟悉。
- en: 'We continue by creating a `person` instance and checking that it’s an instance
    of the `Person` class that has a `name` and can `dance`. Just to be sure, we also
    check that a person who *isn’t* a Ninja can’t wield a weapon:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续创建一个`person`实例，并检查它是否是具有`name`和可以`dance`的`Person`类的实例。为了确保这一点，我们还检查一个不是`Ninja`的人不能使用武器：
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also create a `ninja` instance and check that it’s an instance of `Ninja`
    and can wield a weapon. Because every `ninja` is also a `Person`, we check that
    a ninja is an instance of `Person`, that it has a `name`, and that it also, in
    the interim of fighting, enjoys dancing:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`ninja`实例，并检查它是否是`Ninja`的实例，并且能够使用武器。因为每个`ninja`也是一个`Person`，所以我们检查一个`ninja`是否是`Person`的实例，它有一个`name`，并且在战斗间隙，它也喜欢跳舞：
- en: '[PRE24]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See how easy this is? There’s no need to think about prototypes or the side
    effects of certain overridden properties. We define classes and specify their
    relationship by using the `extends` keyword. Finally, with ES6, hordes of developers
    coming from languages such as Java or C# can be at peace.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有多简单？没有必要考虑原型或某些重写属性的副作用。我们定义类，并使用`extends`关键字指定它们之间的关系。最后，使用ES6，来自Java或C#等语言的大量开发者可以安心了。
- en: And that’s it. With ES6, we build class hierarchies almost as easily as in any
    other, more conventional object-oriented language.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。使用ES6，我们几乎可以像在其他任何更传统的面向对象语言中一样轻松地构建类层次结构。
- en: 7.5\. Summary
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5. 摘要
- en: JavaScript objects are simple collections of named properties with values.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript对象是具有值的命名属性集合。
- en: JavaScript uses prototypes.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript使用原型。
- en: Every object can have a reference to a *prototype*, an object to which we delegate
    the search for a particular property, if the object itself doesn’t have the searched-for
    property. An object’s prototype can have its own prototype, and so on, forming
    a *prototype chain*.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象都可以有一个指向一个*原型*的引用，一个当对象本身没有要搜索的属性时，我们将搜索该属性的搜索委托给的对象。一个对象的原型可以有自己的原型，以此类推，形成一个*原型链*。
- en: We can define the prototype of an object by using the `Object.setPrototypeOf`
    method.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`Object.setPrototypeOf`方法定义一个对象的原型。
- en: Prototypes are closely linked to constructor functions. Every function has a
    `prototype` property that’s set as the prototype of objects that it instantiates.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型与构造函数紧密相关。每个函数都有一个`prototype`属性，该属性被设置为它实例化的对象的原型。
- en: A function’s `prototype` object has a `constructor` property pointing back to
    the function itself. This property is accessible to all objects instantiated with
    that function and, with certain limitations, can be used to find out whether an
    object was created by a particular function.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的`prototype`对象有一个指向该函数本身的`constructor`属性。这个属性对所有使用该函数实例化的对象都是可访问的，并且，在一定限制下，可以用来确定一个对象是否是由特定函数创建的。
- en: In JavaScript, almost everything can be changed at runtime, including an object’s
    prototypes and a function’s prototypes!
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中，几乎可以在运行时更改任何东西，包括对象的原型和函数的原型！
- en: If we want the instances created by a `Ninja` constructor function to “inherit”
    (more accurately, have access to) properties accessible to instances created by
    the `Person` constructor function, set the prototype of the `Ninja` constructor
    to a new instance of the `Person` class.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想让由`Ninja`构造函数创建的实例“继承”（更准确地说，能够访问）由`Person`构造函数创建的实例可访问的属性，请将`Ninja`构造函数的原型设置为`Person`类的新实例。
- en: In JavaScript, properties have attributes (configurable, enumerable, writable).
    These properties can be defined by using the built-in `Object.defineProperty`
    method.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中，属性有属性（configurable、enumerable、writable）。这些属性可以使用内置的`Object.defineProperty`方法定义。
- en: JavaScript ES6 adds support for a `class` keyword that enables us to more easily
    mimic classes. Behind the scenes, prototypes are still in play!
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript ES6增加了对`class`关键字的支持，这使得我们能够更容易地模拟类。幕后，原型仍然在发挥作用！
- en: The `extends` keyword enables elegant inheritance.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extends`关键字使得优雅的继承成为可能。'
- en: 7.6\. Exercises
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 练习
- en: '**1**'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following properties points to an object that will be searched
    if the target object doesn’t have the searched-for property?
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个属性指向一个对象，如果目标对象没有要搜索的属性，则会搜索该对象？
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`class`'
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`class`'
- en: '`instance`'
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`'
- en: '`prototype`'
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`prototype`'
- en: '`pointTo`'
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pointTo`'
- en: '**2**'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the value of variable `a1` after the following code is executed?
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下代码后，变量`a1`的值是多少？
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**3**'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the value of `a1` after running the following code?
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后`a1`的值是多少？
- en: ''
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**4**'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explain the difference between the `getFullName` method in these two code fragments:'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释以下两个代码片段中`getFullName`方法的区别：
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**5**'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what will `ninja.constructor` point to?
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码后，`ninja.constructor`将指向什么？
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**6**'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**'
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what will `ninja.constructor` point to?
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码后，`ninja.constructor`将指向什么？
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**7**'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**'
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain how the `instanceof` operator works in the following example.
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释以下示例中`instanceof`运算符的工作原理。
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**8**'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**8**'
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Translate the following ES6 code into ES5 code.
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下ES6代码转换为ES5代码。
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Chapter 8\. Controlling access to objects
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章。控制对对象的访问
- en: '*This chapter covers*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using getters and setters to control access to object properties
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用获取器和设置器控制对对象属性的访问
- en: Controlling access to objects through proxies
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代理控制对对象的访问
- en: Using proxies for cross-cutting concerns
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理处理横切关注点
- en: In the previous chapter, you saw that JavaScript objects are dynamic collections
    of properties. We can easily add new properties, change the values of properties,
    and even completely remove existing properties. In many situations (for example,
    when validating property values, logging, or displaying data in the UI), we need
    to be able to monitor exactly what’s going on with our objects. So in this chapter,
    you’ll learn techniques for controlling access to and monitoring all of the changes
    that occur in your objects.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解到JavaScript对象是动态的属性集合。我们可以轻松地添加新属性、更改属性值，甚至完全删除现有属性。在许多情况下（例如，在验证属性值、日志记录或在UI中显示数据时），我们需要能够监控我们的对象所发生的一切。因此，在本章中，您将学习控制访问和监控您对象中发生的所有更改的技术。
- en: We’ll start with getters and setters, methods that control access to specific
    object properties. You first saw these methods in action in [chapters 5](kindle_split_016.html#ch05)
    and [7](kindle_split_019.html#ch07). In this chapter, you’ll see some of their
    built-in language support and how to use them for logging, performing data validation,
    and defining computed properties.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从获取器和设置器开始，这些方法用于控制对特定对象属性的访问。您第一次在[第5章](kindle_split_016.html#ch05)和[第7章](kindle_split_019.html#ch07)中看到这些方法的使用。在本章中，您将了解它们的一些内置语言支持以及如何使用它们进行日志记录、执行数据验证和定义计算属性。
- en: 'We’ll continue with proxies, a completely new type of object introduced in
    ES6\. These objects control access to other objects. You’ll learn how they work
    and how to use them to great effect to easily expand your code with cross-cutting
    concerns such as performance measurement or logging, and how to avoid null exceptions
    by autopopulating object properties. Let’s start the journey with something we
    already know to a certain degree: getters and setters.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续介绍代理，这是ES6中引入的一种全新的对象类型。这些对象控制对其他对象的访问。您将了解它们的工作原理以及如何有效地使用它们来轻松扩展代码，包括性能测量或日志记录等横切关注点，以及如何通过自动填充对象属性来避免空异常。让我们从我们已知的某个程度开始：获取器和设置器。
- en: Do you know?
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some of the benefits of accessing a property’s value through getters
    and setters?
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过获取器和设置器访问属性值有哪些好处？
- en: '**Q2:**'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the main difference between proxies and getters and setters?
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代理与获取器和设置器的主要区别是什么？
- en: '**Q3:**'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are proxy traps? Name three types of trap.
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代理陷阱是什么？命名三种类型的陷阱。
- en: 8.1\. Controlling access to properties with getters and setters
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 使用获取器和设置器控制属性访问
- en: 'In JavaScript, objects are relatively simple collections of properties. The
    primary way to keep track of our program state is by modifying those properties.
    For example, consider the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对象是相对简单的属性集合。跟踪我们程序状态的主要方式是通过修改这些属性。例如，考虑以下代码：
- en: '[PRE32]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here we define a `Ninja` constructor that creates `ninja` objects with a property
    `skillLevel`. Later, if we want to change the value of that property, we can write
    the following code: `ninja.skillLevel = 20`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`Ninja`构造函数，它创建具有`skillLevel`属性的`ninja`对象。稍后，如果我们想更改该属性的值，我们可以编写以下代码：`ninja.skillLevel
    = 20`。
- en: That’s all nice and convenient, but what happens in the following cases?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很方便，但在以下情况下会发生什么？
- en: 'We want to safeguard against accidental mistakes, such as assigning unanticipated
    data. For example, we want to stop ourselves from doing something like assigning
    a value of a wrong type: `ninja.skillLevel = "high"`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望防止意外错误，例如分配未预料到的数据。例如，我们希望阻止自己执行如下操作：`ninja.skillLevel = "high"`。
- en: We want to log all changes to the `skillLevel` property.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望记录对 `skillLevel` 属性的所有更改。
- en: We need to show the value of our `skillLevel` property somewhere in the UI of
    our web page. Naturally, we want to present the last, up-to-date value of the
    property, but how can we easily do this?
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在我们的网页 UI 中某处显示我们的 `skillLevel` 属性的值。自然地，我们希望展示属性的最后一个、最新的值，但我们如何轻松地做到这一点呢？
- en: We can handle all of these cases elegantly with getter and setter methods.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用获取器和设置器方法优雅地处理所有这些情况。
- en: In [chapter 5](kindle_split_016.html#ch05), you saw a glimpse of getters and
    setters as a means of mimicking private object properties in JavaScript through
    closures. Let’s revisit the material you’ve learned so far, by working with ninjas
    that have a private `skillLevel` property accessible only through getters and
    setters, as shown in the following listing.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](kindle_split_016.html#ch05) 中，你看到了使用获取器和设置器作为在 JavaScript 中通过闭包模拟私有对象属性的方法。让我们通过使用只有通过获取器和设置器才能访问的私有
    `skillLevel` 属性的忍者来回顾你迄今为止学到的内容，如下所示。
- en: Listing 8.1\. Using getters and setters to guard private properties
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 使用获取器和设置器保护私有属性
- en: '![](200fig01_alt.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](200fig01_alt.jpg)'
- en: 'We define a `Ninja` constructor that creates ninjas with a “private” `skillLevel`
    variable accessible only through our `getSkillLevel` and `setSkillLevel` methods:
    The property value can be obtained only through the `getSkillLevel` method, whereas
    a new property value can be set only through the `setSkillLevel` method (remember
    [chapter 5](kindle_split_016.html#ch05) on closures?).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `Ninja` 构造函数，它创建只有通过我们的 `getSkillLevel` 和 `setSkillLevel` 方法才能访问的“私有”`skillLevel`
    变量的忍者：属性值只能通过 `getSkillLevel` 方法获取，而新的属性值只能通过 `setSkillLevel` 方法设置（还记得 [第 5 章](kindle_split_016.html#ch05)
    中的闭包吗？）。
- en: 'Now, if we want to log all read attempts of the `skillLevel` property, we expand
    the `getSkillLevel` method; and if we want to react to all write attempts, we
    expand the `setSkillLevel` method, as in the following snippet:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想记录对 `skillLevel` 属性的所有读取尝试，我们扩展 `getSkillLevel` 方法；如果我们想对所有的写入尝试做出反应，我们扩展
    `setSkillLevel` 方法，如下面的代码片段所示：
- en: '![](201fig01_alt.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](201fig01_alt.jpg)'
- en: This is great. We can easily react to all interactions with our properties by
    plugging in, for example, logging, data validation, or other side effects such
    as UI modifications.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。我们可以通过插入，例如，记录、数据验证或其他副作用（如 UI 修改）来轻松地对我们属性的交互做出反应。
- en: But one nagging concern might be popping into your mind. The `skillLevel` property
    is a value property; it references data (the number 100), and not a function.
    Unfortunately, in order to take advantage of all the benefits of controlled access,
    all our interactions with the property have to be made by explicitly calling the
    associated methods, which is, to be honest, slightly awkward.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 但一个令人烦恼的疑问可能正在你的脑海中浮现。`skillLevel` 属性是一个值属性；它引用数据（数字 100），而不是一个函数。不幸的是，为了充分利用受控访问的所有好处，我们与该属性的交互必须通过显式调用相关方法来完成，这，坦白说，有点尴尬。
- en: 'Luckily, JavaScript has built-in support for true getters and setters: properties
    that are accessed as normal data properties (for example, `ninja.skillLevel`),
    but that are methods that can compute the value of a requested property, validate
    the passed-in value, or whatever else we need them to do. Let’s take a look at
    this built-in support.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript 有内置的对真正的获取器和设置器的支持：作为正常数据属性访问的属性（例如，`ninja.skillLevel`），但它们是计算请求属性值、验证传入的值或我们需要的任何其他操作的方法。让我们看看这个内置支持。
- en: 8.1.1\. Defining getters and setters
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 定义获取器和设置器
- en: 'In JavaScript, getter and setter methods can be defined in two ways:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，获取器和设置器方法可以以两种方式定义：
- en: By specifying them within object literals or within ES6 class definitions
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象字面量或 ES6 类定义中指定它们
- en: By using the built-in `Object.defineProperty` method
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用内置的 `Object.defineProperty` 方法
- en: Explicit support for getters and setters has existed for quite some time now,
    since the days of ES5\. As always, let’s explore the syntax through an example.
    In this case, we have an object storing a list of ninjas, and we want to be able
    to get and set the first ninja in the list.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对获取器和设置器的显式支持已经存在了一段时间，自从 ES5 时代起。一如既往，让我们通过一个示例来探索语法。在这种情况下，我们有一个存储忍者列表的对象，我们希望能够获取和设置列表中的第一个忍者。
- en: Listing 8.2\. Defining getters and setters in object literals
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. 在对象字面量中定义获取器和设置器
- en: '![](202fig01_alt.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](202fig01_alt.jpg)'
- en: This example defines a `ninjaCollection` object that has a standard property,
    `ninjas`, which references an array of ninjas, and a getter and a setter for the
    property `firstNinja`. The general syntax for getters and setters is shown in
    [figure 8.1](#ch08fig01).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了一个`ninjaCollection`对象，它有一个标准属性`ninjas`，该属性引用了一个忍者数组，以及`firstNinja`属性的获取器和设置器。获取器和设置器的一般语法在[图
    8.1](#ch08fig01)中显示。
- en: Figure 8.1\. The syntax for defining getters and setters. Prefix the property
    name with either the `get` or the `set` keyword.
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. 定义获取器和设置器的语法。在属性名前加上`get`或`set`关键字。
- en: '![](08fig01_alt.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig01_alt.jpg)'
- en: As you can see, we define a getter property by prefixing the name with a `get`
    keyword, and a setter property with a `set` keyword.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过在名称前加上`get`关键字来定义获取器属性，并通过`set`关键字定义设置器属性。
- en: 'In [listing 8.2](#ch08ex02), both the getter and the setter log a message.
    In addition, the getter returns the value of the ninja at index `0`, and the setter
    assigns a new value to the ninja at the same index:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 8.2](#ch08ex02)中，获取器和设置器都记录了一条消息。此外，获取器返回索引`0`处的忍者的值，而设置器将新值赋给同一索引处的忍者：
- en: '[PRE33]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we test that accessing the getter property returns the first ninja, Yoshi:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试访问获取器属性返回第一个忍者，Yoshi：
- en: '[PRE34]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that the getter property is accessed as if it were a standard object
    property (and not as the method that it is).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，获取器属性被访问的方式就像它是标准对象属性（而不是作为方法）一样。
- en: After we access a getter property, the associated getter method is implicitly
    called, the message `Getting firstNinja` is logged, and the value of the ninja
    at index `0` is returned.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们访问获取器属性后，相关的获取器方法被隐式调用，记录了消息`Getting firstNinja`，并返回索引`0`处的忍者的值。
- en: 'We continue by taking advantage of our setter method, and writing to the `firstNinja`
    property, again, just as we would assign a new value to a normal object property:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续利用我们的设置器方法，写入`firstNinja`属性，就像我们分配新值给普通对象属性一样：
- en: '[PRE35]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similar to the previous case, because the `firstNinja` property has a setter
    method, whenever we assign a value to that property, the setter method is implicitly
    called. This logs the message `Setting firstNinja` and modifies the value of the
    ninja at index `0`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个情况类似，因为`firstNinja`属性有一个设置器方法，所以每次我们给该属性赋值时，设置器方法都会被隐式调用。这记录了消息`Setting
    firstNinja`并修改了索引`0`处的忍者的值。
- en: 'Finally, we can test that our modification has done the work and that the new
    value of the ninja at index `0` can be accessed both through the `ninjas` collection
    and through our getter method:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试我们的修改是否已经完成工作，以及索引`0`处的忍者的新值可以通过`ninjas`集合和我们的获取器方法访问：
- en: '[PRE36]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Figure 8.2](#ch08fig02) shows the output generated by [listing 8.2](#ch08ex02).
    When we access a property with a getter (for example, through `ninjaCollection.firstNinja`),
    the getter method is immediately called, and in this case, the message `Getting
    firstNinja` is logged. Later, we test that the output is `Yoshi` and that the
    message `Yoshi is the first ninja` is logged. We proceed similarly by assigning
    a new value to the `firstNinja` property, and as we can see in the output, this
    implicitly triggers the execution of the setter method, which outputs the message
    `Setting firstNinja`.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.2](#ch08fig02)显示了[列表 8.2](#ch08ex02)生成的输出。当我们通过`ninjaCollection.firstNinja`访问具有获取器的属性时，获取器方法立即被调用，在这种情况下，记录了消息`Getting
    firstNinja`。稍后，我们测试输出是`Yoshi`，并记录了消息`Yoshi is the first ninja`。我们通过给`firstNinja`属性赋新值的方式继续进行，正如我们可以在输出中看到的那样，这隐式触发了设置器方法的执行，该方法输出了消息`Setting
    firstNinja`。'
- en: 'Figure 8.2\. The output from [listing 8.2](#ch08ex02): if a property has a
    getter and a setter method, the getter method is implicitly called whenever we
    read the property value, and the setter method is called whenever we assign a
    new value to the property.'
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2\. [列表 8.2](#ch08ex02)的输出：如果一个属性有获取器和设置器方法，那么每次我们读取属性值时，都会隐式调用获取器方法，而每次我们给属性赋新值时，都会调用设置器方法。
- en: '![](08fig02.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig02.jpg)'
- en: An important point to take from all this is that native getters and setters
    allow us to specify properties that are accessed as standard properties, but that
    are methods whose execution is triggered immediately when the property is accessed.
    This is further emphasized in [figure 8.3](#ch08fig03).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些中可以得出的一个重要观点是，原生的获取器和设置器允许我们指定作为标准属性访问的属性，但这些属性的方法在属性被访问时立即触发执行。这在[图 8.3](#ch08fig03)中得到了进一步的强调。
- en: Figure 8.3\. Accessing a property with a getter method implicitly calls the
    matching getter. The process is the same as if this were a standard method call,
    and the getter method gets executed. A similar thing happens when we assign a
    value to a property through a setter method.
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 使用getter方法访问属性会隐式调用匹配的getter。这个过程与这是一个标准方法调用时相同，getter方法会被执行。当我们通过setter方法将值赋给属性时，也会发生类似的事情。
- en: '![](08fig03_alt.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig03_alt.jpg)'
- en: This syntax for defining a getter and a setter is straightforward, so it’s no
    wonder that we can use the exact same syntax to define getters and setters in
    other situations. The following example uses ES6 classes.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 定义getter和setter的这种语法很简单，所以我们可以用完全相同的语法在其他情况下定义getter和setter也就不足为奇了。以下示例使用了ES6类。
- en: Listing 8.3\. Using getters and setters with ES6 classes
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 使用ES6类中的getter和setter
- en: '![](204fig01_alt.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](204fig01_alt.jpg)'
- en: This modifies the code from [listing 8.2](#ch08ex02) to include ES6 classes.
    We keep all the tests to verify that the example still works as expected.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这将[列表8.2](#ch08ex02)中的代码修改为包括ES6类。我们保留所有测试以验证示例仍然按预期工作。
- en: '|  |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t always have to define both a getter and a setter for a given property.
    For example, often we’ll want to provide only a getter. If in that case we still
    attempt to write a value to that property, the exact behavior depends on whether
    the code is in strict or nonstrict mode. If the code is in nonstrict mode, assigning
    a value to a property with only a getter achieves nothing; the JavaScript engine
    will silently ignore our request. If, on the other hand, the code is in strict
    mode, the JavaScript engine will throw a type error, indicating that we’re trying
    to assign a value to a property that has a getter but no setter.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的属性，我们并不总是需要定义一个getter和一个setter。例如，我们通常会只想提供一个getter。如果在这种情况下我们仍然尝试向该属性写入值，确切的行为取决于代码是在严格模式还是非严格模式下。如果代码是在非严格模式下，向只有一个getter的属性赋值将没有任何效果；JavaScript引擎会静默地忽略我们的请求。另一方面，如果代码是在严格模式下，JavaScript引擎将抛出一个类型错误，表明我们正在尝试向一个有getter但没有setter的属性赋值。
- en: '|  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Although specifying getters and setters through ES6 classes and object literals
    is easy, you’ve probably noticed something missing. Traditionally, getters and
    setters are used to control access to private object properties, as in [listing
    8.1](#ch08ex01). Unfortunately, as we already know from [chapter 5](kindle_split_016.html#ch05),
    JavaScript doesn’t have private object properties. Instead, we can mimic them
    through closures, by defining variables and specifying object methods that will
    close over those variables. Because with object literals and classes our getter
    and setter methods aren’t created within the same function scope as variables
    that we could use for private object properties, we can’t do this. Luckily, there’s
    an alternative way, through the `Object.defineProperty` method.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过ES6类和对象字面量指定getter和setter很简单，但你可能已经注意到了一些缺失的东西。传统上，getter和setter用于控制对私有对象属性的访问，如[列表8.1](#ch08ex01)所示。不幸的是，正如我们已经在[第5章](kindle_split_016.html#ch05)中知道的那样，JavaScript没有私有对象属性。相反，我们可以通过定义变量和指定将覆盖这些变量的对象方法来模拟它们。因为在我们使用对象字面量和类时，我们的getter和setter方法并不是在用于私有对象属性的变量相同的函数作用域内创建的，所以我们不能这样做。幸运的是，有一种替代方法，即通过`Object.defineProperty`方法。
- en: In [chapter 7](kindle_split_019.html#ch07), you saw that the `Object.defineProperty`
    method can be used to define new properties by passing in a property descriptor
    object. Among other things, the property descriptor can include a `get` and a
    `set` property that define the property’s getter and setter methods.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_019.html#ch07)中，你看到了可以使用`Object.defineProperty`方法通过传递一个属性描述符对象来定义新属性。属性描述符可以包括一个`get`和一个`set`属性，它们定义了属性的getter和setter方法。
- en: We’ll use this feature to modify [listing 8.1](#ch08ex01) to implement built-in
    getters and setters that control access to a “private” object property, as shown
    in the following listing.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个特性来修改[列表8.1](#ch08ex01)以实现内置的getter和setter，这些getter和setter可以控制对“私有”对象属性的访问，如下面的列表所示。
- en: Listing 8.4\. Defining getters and setters with Object.defineProperty
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 使用Object.defineProperty定义getter和setter
- en: '![](ch08ex04-0.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex04-0.jpg)'
- en: '![](ch08ex04-1.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex04-1.jpg)'
- en: In this example, we first define a `Ninja` constructor function with a `_skillLevel`
    variable that we’ll use as a private variable, just as in [listing 8.1](#ch08ex01).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个`Ninja`构造函数，其中包含一个`_skillLevel`变量，我们将使用它作为私有变量，就像在[列表8.1](#ch08ex01)中一样。
- en: 'Next, on the newly created object, referenced by the `this` keyword, we define
    a `skillLevel` property by using the built-in `Object.defineProperty` method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在由 `this` 关键字引用的新创建的对象上，我们使用内置的 `Object.defineProperty` 方法定义一个 `skillLevel`
    属性：
- en: '[PRE37]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because we want the `skillLevel` property to control access to a private variable,
    we specify a `get` and a `set` method that will be called whenever the property
    is accessed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望 `skillLevel` 属性控制对私有变量的访问，所以我们指定了一个在访问属性时将被调用的 `get` 和 `set` 方法。
- en: Notice that, unlike getters and setters specified on object literals and classes,
    the `get` and `set` methods defined through `Object.defineProperty` are created
    in the same scope as the “private” `skillLevel` variable. Both methods create
    a closure around the private variable, and we can access that private variable
    only through these two methods.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与在对象字面量和类上指定的获取器和设置器不同，通过 `Object.defineProperty` 定义的 `get` 和 `set` 方法是在与“私有”`skillLevel`
    变量相同的范围内创建的。这两个方法都在私有变量周围创建了一个闭包，我们只能通过这两个方法来访问那个私有变量。
- en: 'The rest of the code works exactly as in the previous examples. We create a
    new `Ninja` instance and check that we can’t access the private variable directly.
    Instead, all interactions have to go through the getter and setter, which we now
    use just as if they were standard object properties:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码与前面的示例完全一样。我们创建一个新的 `Ninja` 实例，并检查我们是否可以直接访问私有变量。相反，所有交互都必须通过获取器和设置器进行，我们现在就像它们是标准对象属性一样使用它们：
- en: '![](207fig01_alt.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](207fig01_alt.jpg)'
- en: As you can see, the approach with `Object.defineProperty` is more verbose and
    complicated than getters and setters in object literals and classes. But in certain
    cases, when we need private object properties, it’s well worth it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 `Object.defineProperty` 的方法比对象字面量和类中的获取器和设置器更冗长和复杂。但在某些情况下，当我们需要私有对象属性时，这是值得的。
- en: Regardless of the way we define them, getters and setters allow us to define
    object properties that are used like standard object properties, but are methods
    that can execute additional code whenever we read or write to a particular property.
    This is an incredibly useful feature that enables us to perform logging, validate
    assignment values, and even notify other parts of the code when certain changes
    occur. Let’s explore some of these applications.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何定义它们，获取器和设置器都允许我们定义像标准对象属性一样使用的对象属性，但它们是方法，每当我们在特定属性上读取或写入时，都可以执行额外的代码。这是一个非常实用的功能，使我们能够执行日志记录、验证赋值值，甚至在某些更改发生时通知代码的其他部分。让我们探索一些这些应用。
- en: 8.1.2\. Using getters and setters to validate property values
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 使用获取器和设置器验证属性值
- en: As we’ve established so far, a setter is a method that’s executed whenever we
    write a value to the matching property. We can take advantage of setters to perform
    an action whenever code attempts to update the value of a property. For example,
    one of the things we can do is validate the passed-in value. Take a look at the
    following code, which ensures that our `skillLevel` property can be assigned only
    integer values.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，设置器是一个方法，每当我们将值写入匹配的属性时都会执行。我们可以利用设置器在尝试更新属性值时执行某些操作。例如，我们可以执行的操作之一是验证传入的值。请看以下代码，它确保我们的
    `skillLevel` 属性只能被分配整数值。
- en: Listing 8.5\. Validating property value assignments with setters
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 使用设置器验证属性值赋值
- en: '![](ch08ex05-0.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex05-0.jpg)'
- en: '![](ch08ex05-1.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex05-1.jpg)'
- en: 'This example is a straightforward extension to [listing 8.4](#ch08ex04). The
    only major difference is that now, whenever a new value is assigned to the `skillLevel`
    property, we check whether the passed-in value is an integer. If it isn’t, an
    exception is thrown, and the private `_skillLevel` variable won’t be modified.
    If everything went okay and an integer value is received, we end up with a new
    value of the private `_skillLevel` variable:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是 [列表 8.4](#ch08ex04) 的直接扩展。唯一的重大区别是，现在每当将新值分配给 `skillLevel` 属性时，我们检查传入的值是否为整数。如果不是，将抛出异常，私有
    `_skillLevel` 变量不会被修改。如果一切顺利并且接收到了整数值，我们将得到私有 `_skillLevel` 变量的新值：
- en: '[PRE38]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When testing this code, we first check that all goes okay if we assign an integer:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试此代码时，我们首先检查如果我们分配一个整数，一切是否顺利：
- en: '[PRE39]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And then we test the situation in which we mistakenly assign a value of another
    type, such as a string. In that case, we should end up with an exception.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们测试了错误地分配其他类型值的情况，例如字符串。在这种情况下，我们应该得到一个异常。
- en: '[PRE40]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is how you avoid all those silly little bugs that happen when a value of
    the wrong type ends up in a certain property. Sure, it adds overhead, but that’s
    a price that we sometimes have to pay to safely use a highly dynamic language
    such as JavaScript.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何避免当错误类型的值最终出现在某个属性中时发生的所有那些愚蠢的小错误。当然，这会增加开销，但这是我们有时不得不为了安全地使用像 JavaScript
    这样高度动态的语言而付出的代价。
- en: This is just one example of the usefulness of setter methods; there are many
    more that we won’t explicitly explore. For example, you can use the same principle
    to track value history, perform logging, provide change notification, and more.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 setter 方法有用性的一个例子；还有更多我们没有明确探讨的例子。例如，你可以使用同样的原则来跟踪值历史、执行日志记录、提供变更通知等等。
- en: 8.1.3\. Using getters and setters to define computed properties
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 使用 getter 和 setter 定义计算属性
- en: In addition to being able to control access to certain object properties, getters
    and setters can be used to define *computed properties*, properties whose value
    is calculated per request. Computed properties don’t store a value; they provide
    a `get` and/or a `set` method to retrieve and set other properties indirectly.
    In the following example, the object has two properties, `name` and `clan`, which
    we’ll use to compute the property `fullTitle`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够控制对某些对象属性的访问之外，getter 和 setter 还可以用来定义 *计算属性*，这些属性的值是按请求计算的。计算属性不存储值；它们提供
    `get` 和/或 `set` 方法来间接检索和设置其他属性。在下面的示例中，该对象有两个属性，`name` 和 `clan`，我们将使用它们来计算属性 `fullTitle`。
- en: Listing 8.6\. Defining computed properties
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 定义计算属性
- en: '![](ch08ex06-0.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex06-0.jpg)'
- en: '![](ch08ex06-1.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex06-1.jpg)'
- en: 'Here we define a `shogun` object, with two standard properties, `name` and
    `clan`. In addition, we specify a getter and a setter method for a computed property,
    `fullTitle`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个 `shogun` 对象，具有两个标准属性，`name` 和 `clan`。此外，我们还指定了一个计算属性 `fullTitle`
    的 getter 和 setter 方法：
- en: '[PRE41]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `get` method computes the value of the `fullTitle` property, on request,
    by concatenating the `name` and `clan` properties. The `set` method, on the other
    hand, uses the built-in `split` method, available to all strings, to split the
    assigned string into segments by the space character. The first segment represents
    the name and is assigned to the `name` property, whereas the second segment represents
    the clan and is assigned to the `clan` property.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法在请求时通过连接 `name` 和 `clan` 属性来计算 `fullTitle` 属性的值。另一方面，`set` 方法使用所有字符串都有的内置
    `split` 方法，通过空格字符将分配的字符串分割成段。第一个段代表名字，并分配给 `name` 属性，而第二个段代表部落，并分配给 `clan` 属性。'
- en: 'This takes care of both routes: Reading the `fullTitle` property computes its
    value, and writing to the `fullTitle` property modifies the properties that constitute
    the property value.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了两种路由：读取 `fullTitle` 属性会计算其值，向 `fullTitle` 属性写入会修改构成属性值的属性。
- en: To be honest, we don’t have to use computed properties. A method called `getFullTitle`
    could be equally useful, but computed properties can improve the conceptual clarity
    of our code. If a certain value (in this case, the `fullTitle` value) depends
    *only* on the internal state of the object (in this case, on the `name` and `clan`
    properties), it makes perfect sense to represent it as a data field, a property,
    instead of a function.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我们不必使用计算属性。一个名为 `getFullTitle` 的方法可能同样有用，但计算属性可以提高我们代码的概念清晰度。如果某个值（在这个例子中，是
    `fullTitle` 值）*仅*依赖于对象的内部状态（在这个例子中，依赖于 `name` 和 `clan` 属性），那么将其表示为数据字段、属性而不是函数是完美的。
- en: 'This concludes our exploration of getters and setters. You’ve seen that they’re
    a useful addition to the language that can help us deal with logging, data validation,
    and detecting changes in property values. Unfortunately, sometimes this isn’t
    enough. In certain cases, we need to control all types of interactions with our
    objects, and for this, we can use a completely new type of object: a *proxy*.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 getter 和 setter 的探索。你已经看到，它们是语言的有用补充，可以帮助我们处理日志记录、数据验证和检测属性值的变化。不幸的是，有时这还不够。在某些情况下，我们需要控制与我们的对象的所有类型的交互，为此，我们可以使用一种全新的对象类型：一个
    *代理*。
- en: 8.2\. Using proxies to control access
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 使用代理来控制访问
- en: A *proxy* is a surrogate through which we control access to another object.
    It enables us to define custom actions that will be executed when an object is
    being interacted with—for example, when a property value is read or set, or when
    a method is called. You can think of proxies as almost a generalization of getters
    and setters; but with each getter and setter, you control access to only a single
    object property, whereas proxies enable you to generically handle all interactions
    with an object, including even method calls.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*代理* 是一个代理，通过它我们可以控制对另一个对象的访问。它使我们能够定义在对象交互时（例如，当读取或设置属性值，或调用方法时）将执行的定制操作。你可以将代理视为几乎是一般化的获取器和设置器；但是，每个获取器和设置器只控制对单个对象属性的访问，而代理使我们能够通用地处理与对象的交互，包括甚至方法调用。'
- en: We can use proxies when we’d traditionally use getters and setters, such as
    for logging, data validation, and computed properties. But proxies are even more
    powerful. They allow us to easily add profiling and performance measurements to
    our code, autopopulate object properties in order to avoid pesky null exceptions,
    and to wrap host objects such as the DOM in order to reduce cross-browser incompatibilities.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传统上使用获取器和设置器（例如用于日志记录、数据验证和计算属性）时，我们可以使用代理。但代理的功能更强大。它们允许我们轻松地为代码添加性能分析和性能测量，自动填充对象属性以避免讨厌的空异常，以及将宿主对象（如DOM）包装起来以减少跨浏览器不兼容性。
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Proxies are introduced by ES6\. For current browser support, see [http://mng.bz/9uEM](http://mng.bz/9uEM).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是由ES6引入的。有关当前浏览器的支持情况，请参阅[http://mng.bz/9uEM](http://mng.bz/9uEM)。
- en: '|  |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In JavaScript, we can create proxies by using the built-in `Proxy` constructor.
    Let’s start simple, with a proxy that intercepts all attempts to read and write
    to properties of an object.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以使用内置的 `Proxy` 构造函数创建代理。让我们从一个拦截所有尝试读取和写入对象属性值的代理开始。
- en: Listing 8.7\. Creating proxies with the Proxy constructor
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7\. 使用Proxy构造函数创建代理
- en: '![](ch08ex07-0.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex07-0.jpg)'
- en: '![](ch08ex07-1.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex07-1.jpg)'
- en: 'We first create our base `emperor` object that has only a `name` property.
    Next, by using the built-in `Proxy` constructor, we wrap our `emperor` object
    (or *target* object, as it’s commonly called) into a proxy object named `representative`.
    During proxy construction, as a second argument, we also send an object that specifies
    *traps*, functions that will be called when certain actions are performed on an
    object:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建我们的基础 `emperor` 对象，它只有一个 `name` 属性。然后，通过使用内置的 `Proxy` 构造函数，我们将 `emperor`
    对象（或通常称为 *target* 对象）包装成一个名为 `representative` 的代理对象。在代理构造过程中，我们还将一个对象作为第二个参数发送，该对象指定了
    *traps*，即当对对象执行某些操作时将被调用的函数：
- en: '[PRE42]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this case, we’ve specified two traps: a `get` trap that will be called whenever
    we try to read a value of a property through the proxy, and a `set` trap that
    will be called whenever we set a property value through the proxy. The *get* trap
    performs the following functionality: If the target object has a property, that
    property is returned; and if the object doesn’t have a property, we return a message
    warning our user not to bother the `emperor` with frivolous details.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定了两个捕获器：一个 `get` 捕获器，它将在我们尝试通过代理读取属性值时被调用，以及一个 `set` 捕获器，它将在我们通过代理设置属性值时被调用。*get*
    捕获器执行以下功能：如果目标对象具有属性，则返回该属性；如果对象没有属性，我们返回一条消息警告用户不要因为琐碎的细节而打扰 `emperor`。
- en: '[PRE43]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we test that we can access the `name` property both directly through
    the target `emperor` object as well as through our proxy object:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试我们是否可以通过目标 `emperor` 对象以及我们的代理对象直接访问 `name` 属性：
- en: '[PRE44]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If we access the `name` property directly through the `emperor` object, the
    value `Komei` is returned. But if we access the `name` property through the `proxy`
    object, the `get` trap is implicitly called. Because the `name` property is found
    in the target `emperor` object, the value `Komei` is also returned. See [figure
    8.4](#ch08fig04).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接通过 `emperor` 对象访问 `name` 属性，将返回值 `Komei`。但如果通过 `proxy` 对象访问 `name` 属性，将隐式调用
    `get` 捕获器。因为 `name` 属性在目标 `emperor` 对象中找到，所以也返回值 `Komei`。参见[图8.4](#ch08fig04)。
- en: Figure 8.4\. Accessing the `name` property directly (on the left) and indirectly,
    through a proxy (on the right)
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4\. 直接访问 `name` 属性（在左侧）和通过代理间接访问（在右侧）
- en: '![](08fig04_alt.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig04_alt.jpg)'
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to emphasize that proxy traps are activated in the same way as
    getters and setters. As soon as we perform an action (for example, accessing a
    property value on a proxy), the matching trap gets implicitly called, and the
    JavaScript engine goes through a similar process as if we’ve explicitly invoked
    a function.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，代理陷阱的激活方式与获取器和设置器相同。一旦我们执行一个动作（例如，在代理上访问属性值），匹配的陷阱就会隐式调用，JavaScript
    引擎会经历一个类似于我们显式调用函数的过程。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: On the other hand, if we access a nonexisting `nickname` property directly on
    the target `emperor` object, we’ll get, unsurprisingly, an `undefined` value.
    But if we try to access it through our `proxy` object, the `get` handler will
    be activated. Because the target `emperor` object doesn’t have a `nickname` property,
    the proxy’s `get` trap will return the `Don't bother the emperor!` message.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们直接在目标 `emperor` 对象上访问一个不存在的 `nickname` 属性，我们会得到一个 `undefined` 值。但如果我们尝试通过我们的
    `proxy` 对象来访问它，`get` 处理程序将被激活。因为目标 `emperor` 对象没有 `nickname` 属性，代理的 `get` 陷阱将返回
    `Don't bother the emperor!` 消息。
- en: 'We’ll continue the example by assigning a new property through our proxy object:
    `representative.nickname = "Tenno"`. Because the assignment is done through a
    proxy, and not directly, the `set` trap, which logs a message and assigns a property
    to our target `emperor` object, is activated:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过代理对象分配一个新属性来继续这个例子：`representative.nickname = "Tenno"`。因为分配是通过代理完成的，而不是直接完成，所以
    `set` 陷阱，它记录一条消息并将属性分配给我们的目标 `emperor` 对象，被激活：
- en: '[PRE45]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Naturally, the newly created property can be accessed both through the proxy
    object and the target object:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，新创建的属性可以通过代理对象和目标对象来访问：
- en: '[PRE46]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is the gist of how to use proxies: Through the `Proxy` constructor, we
    create a proxy object that controls access to the target object by activating
    certain traps, whenever an operation is performed directly on a proxy.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用代理的精髓：通过 `Proxy` 构造函数，我们创建一个代理对象，该对象通过激活某些陷阱来控制对目标对象的访问，每当直接在代理上执行操作时。
- en: 'In this example, we’ve used the `get` and `set` traps, but many other built-in
    traps allow us to define handlers for various object actions (see [http://mng.bz/ba55](http://mng.bz/ba55)).
    For example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `get` 和 `set` 陷阱，但许多其他内置陷阱允许我们为各种对象操作定义处理程序（见 [http://mng.bz/ba55](http://mng.bz/ba55)）。例如：
- en: The *apply* trap will be activated when calling a function, and the *construct*
    trap when using the new operator.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用函数时，将激活 *apply* 陷阱，当使用 `new` 操作符时，将激活 *construct* 陷阱。
- en: The *get* and *set* traps will be activated when reading/writing to a property.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当读取/写入属性时，将激活 *get* 和 *set* 陷阱。
- en: The *enumerate* trap will be activated for `for-in` statements.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `for-in` 语句，将激活 *enumerate* 陷阱。
- en: '`getPrototypeOf` and `setPrototypeOf` will be activated for getting and setting
    the prototype value.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrototypeOf` 和 `setPrototypeOf` 将在获取和设置原型值时被激活。'
- en: 'We can intercept many operations, but going through all of them is outside
    the scope of this book. For now, we turn our attention to a few operations that
    we can’t override: equality (== or ===), `instanceof`, and the `typeof` operator.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拦截许多操作，但详细讨论所有这些操作超出了本书的范围。现在，我们将注意力转向一些我们无法覆盖的操作：相等性（== 或 ===）、`instanceof`
    和 `typeof` 操作符。
- en: For example, the expression `x == y` (or a stricter `x === y`) is used to check
    whether `x` and `y` refer to identical objects (or are of the same value). This
    equality operator has some assumptions. For example, comparing two objects should
    always return the same value for the same two objects, which isn’t something that
    we can guarantee if that value is determined by a user-specified function. In
    addition, the act of comparing two objects shouldn’t give access to one of those
    objects, which would be the case if equality could be trapped. For similar reasons,
    the `instanceof` and the `typeof` operators can’t be trapped.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式 `x == y`（或更严格的 `x === y`）用于检查 `x` 和 `y` 是否引用相同的对象（或具有相同的值）。这个相等操作符有一些假设。例如，比较两个对象应该总是为相同的两个对象返回相同的值，如果我们不能保证这个值是由用户指定的函数确定的，那么我们无法保证这一点。此外，比较两个对象的行为不应该提供对其中一个对象的访问，如果相等性可以被捕获，那么就会发生这种情况。出于类似的原因，`instanceof`
    和 `typeof` 操作符也不能被捕获。
- en: Now that we know how proxies work and how to create them, let’s explore some
    of their practical aspects, such as how to use proxies for logging, performance
    measurement, autopopulating properties, and implementing arrays that can be accessed
    with negative indexes. We’ll start with logging.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了代理的工作原理以及如何创建它们，让我们来探讨一些它们的实际应用方面，例如如何使用代理进行日志记录、性能测量、自动填充属性以及实现可以通过负索引访问的数组。我们将从日志记录开始。
- en: 8.2.1\. Using proxies for logging
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 使用代理进行日志记录
- en: One of the most powerful tools when trying to figure out how code works or when
    trying to get to the root of a nasty bug is *logging*, the act of outputting information
    that we find useful at a particular moment. We might, for example, want to know
    which functions are called, how long they’ve been executing, what properties are
    read or written to, and so on.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图了解代码的工作原理或试图找到讨厌的bug的根本原因时，最强大的工具之一是*日志记录*，即在特定时刻输出我们认为有用的信息的行为。例如，我们可能想知道哪些函数被调用，它们执行了多长时间，哪些属性被读取或写入，等等。
- en: Unfortunately, when implementing logging, we usually scatter logging statements
    throughout the code. Take a look at the `Ninja` example used earlier in the chapter.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在实现日志记录时，我们通常会在代码中分散地放置日志语句。看看本章前面提到的“忍者”示例。
- en: Listing 8.8\. Logging without proxies
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. 不使用代理的日志记录
- en: '![](214fig01_alt.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图片](214fig01_alt.jpg)'
- en: We define a `Ninja` constructor function that adds a getter and a setter to
    the `skillLevel` property, which log all attempts of reading and writing to that
    property.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `Ninja` 构造函数，它向 `skillLevel` 属性添加了一个获取器和设置器，记录对该属性的所有读取和写入尝试。
- en: Notice that this isn’t an ideal solution. We’ve cluttered our domain code that
    deals with reading and writing to an object property with logging code. In addition,
    if in the future we need more properties on the `ninja` object, we have to be
    careful not to forget to add additional logging statements to each new property.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不是一个理想的解决方案。我们使处理对象属性读写操作的领域代码变得杂乱无章，加入了日志代码。此外，如果将来在“忍者”对象上需要更多的属性，我们必须小心不要忘记为每个新属性添加额外的日志语句。
- en: Luckily, one of the straightforward uses of proxies is to enable logging whenever
    we read or write to a property, but in a much nicer and cleaner way. Consider
    the following example.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，代理的一个直接用途是在我们读取或写入属性时启用日志记录，但以一种更加优雅和干净的方式。考虑以下示例。
- en: Listing 8.9\. Using proxies makes it easier to add logging to objects
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 使用代理使向对象添加日志记录更加容易
- en: '![](ch08ex09-0.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex09-0.jpg)'
- en: '![](ch08ex09-1.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex09-1.jpg)'
- en: Here we define a `makeLoggable` function that takes a `target` object and returns
    a new `Proxy` that has a handler with a `get` and a `set` trap. These traps, besides
    reading and writing to the property, log the information about which property
    is read or written to.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个 `makeLoggable` 函数，它接受一个 `target` 对象并返回一个新的 `Proxy`，该 `Proxy` 具有带有
    `get` 和 `set` 陷阱的处理程序。这些陷阱除了读取和写入属性外，还会记录读取或写入的属性信息。
- en: Next, we create a `ninja` object with a `name` property, and we pass it to the
    `make-Loggable` function, in which it will be used as a target for a newly created
    proxy. We then assign the proxy back to the `ninja` identifier, overriding it.
    (Don’t worry, our original `ninja` object is kept alive as the target object of
    our proxy.)
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个具有 `name` 属性的 `ninja` 对象，并将其传递给 `make-Loggable` 函数，其中它将作为新创建的代理的目标。然后我们将代理赋值回
    `ninja` 标识符，以覆盖它。（别担心，我们的原始 `ninja` 对象作为代理的目标对象仍然保持活跃。）
- en: 'Whenever we try to read a property (for example, with `ninja.name`), the `get`
    trap will be called, and the information about which property has been read will
    be logged. A similar thing will happen when writing to a property: `ninja.weapon
    = "sword".`'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们尝试读取一个属性（例如，使用 `ninja.name`）时，`get` 陷阱将被调用，并记录已读取的属性信息。当向属性写入时也会发生类似的事情：`ninja.weapon
    = "sword"`。
- en: Notice how much easier and more transparent this is when compared to the standard
    way of using getters and setters. We don’t have to mix our domain code with our
    logging code, and there’s no need to add separate logging for each object property.
    Instead, all property reads and writes go through our proxy object trap methods.
    Logging has been specified in only one place and is reused as many times as necessary,
    on as many objects as necessary.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与使用获取器和设置器的标准方式相比，这要容易得多，也更加透明。我们不需要将领域代码与日志代码混合，也不需要为每个对象属性添加单独的日志。相反，所有属性读取和写入都通过我们的代理对象陷阱方法进行。日志记录只在唯一的位置指定，并且根据需要重复使用，在尽可能多的对象上使用。
- en: 8.2.2\. Using proxies for measuring performance
  id: totrans-498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 使用代理来测量性能
- en: Besides being used for logging property accesses, proxies can be used for measuring
    the performance of function invocations, without even modifying the source code
    of a function. Say we want to measure the performance of a function that calculates
    whether a number is a prime, as shown in the following listing.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于记录属性访问外，代理还可以用于测量函数调用的性能，甚至不需要修改函数的源代码。比如说，我们想要测量一个计算一个数是否为质数的函数的性能，如下面的列表所示。
- en: Listing 8.10\. Measuring performance with proxies
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 使用代理测量性能
- en: '![](216fig01_alt.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图片 216fig01_alt](216fig01_alt.jpg)'
- en: In this example, we have a simple `isPrime` function. (The exact function doesn’t
    matter; we’re using it as an example of a function whose execution can last a
    nontrivial amount of time.)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个简单的 `isPrime` 函数。（具体的函数不重要；我们只是用它作为函数执行可能持续一段时间的示例。）
- en: 'Now imagine that we need to measure the performance of the `isPrime` function,
    but without modifying its code. We could wrap the function into a proxy that has
    a trap that will be called whenever the function is called:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们需要测量 `isPrime` 函数的性能，但又不想修改其代码。我们可以将函数包装到一个代理中，该代理有一个陷阱，每当函数被调用时都会被调用：
- en: '[PRE47]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We use the `isPrime` function as the target object of a newly constructed proxy.
    In addition, we supply a handler with an `apply` trap that will be executed on
    function invocation.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `isPrime` 函数作为新构造的代理的目标对象。此外，我们还提供了一个带有 `apply` 陷阱的处理程序，该陷阱将在函数调用时执行。
- en: Similarly, as in the previous example, we’ve assigned the newly created proxy
    to the `isPrime` identifier. In that way, we don’t have to change any of the code
    that calls the function whose execution time we want to measure; the rest of the
    program code is completely oblivious to our changes. (How’s that for some ninja
    stealth action?)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于前一个示例，我们将新创建的代理分配给了 `isPrime` 标识符。这样，我们就不必更改任何调用我们想要测量执行时间的函数的代码；程序代码的其余部分对我们的更改一无所知。（这难道不是一些忍者隐形行动吗？）
- en: Whenever the `isPrime` function is called, that call is rerouted to our proxy’s
    `apply` trap, which will start a stopwatch with the built-in `console.time` method
    (remember [chapter 1](kindle_split_011.html#ch01)), call the original `isPrime`
    function, log the elapsed time, and finally return the result of the `isPrime`
    invocation.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用 `isPrime` 函数时，该调用会被重定向到我们的代理的 `apply` 陷阱，该陷阱将使用内置的 `console.time` 方法启动计时器（记住
    [第 1 章](kindle_split_011.html#ch01)），调用原始的 `isPrime` 函数，记录经过的时间，并最终返回 `isPrime`
    调用的结果。
- en: 8.2.3\. Using proxies to autopopulate properties
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 使用代理来自动填充属性
- en: 'In addition to simplifying logging, proxies can be used for autopopulating
    properties. For example, imagine that you have to model your computer’s folder
    structure, in which a folder object can have properties that can also be folders.
    Now imagine that you have to model a file at the end of a long path, such as this:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简化日志记录外，代理还可以用于自动填充属性。例如，假设您必须模拟计算机的文件夹结构，其中文件夹对象可以具有也可以是文件夹的属性。现在想象一下，您必须模拟一个位于长路径末尾的文件，如下所示：
- en: '[PRE48]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To create this, you might write something along the following lines:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个，你可能需要写一些类似以下的内容：
- en: '[PRE49]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Seems a tad more tedious than necessary, doesn’t it? This is where autopopulating
    properties comes into play; just take a look at the following example.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎比必要的繁琐多了，不是吗？这就是自动填充属性发挥作用的地方；只需看看下面的例子。
- en: Listing 8.11\. Autopopulating properties with proxies
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 使用代理来自动填充属性
- en: '![](217fig01_alt.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图片 217fig01_alt](217fig01_alt.jpg)'
- en: 'Normally, if we consider only the following code, we’d expect an exception
    to be raised:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果我们只考虑以下代码，我们预期会抛出一个异常：
- en: '[PRE50]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We’re accessing a property, `firstNinjaDir,` of an undefined property, `ninjasDir`,
    of the `rootFolder` object. But if we run the code, you see that all is well,
    as shown in [figure 8.5](#ch08fig05).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在访问 `rootFolder` 对象中未定义的属性 `ninjasDir` 的属性 `firstNinjaDir`。但如果我们运行代码，你会看到一切正常，如图
    [图 8.5](#ch08fig05) 所示。
- en: Figure 8.5\. The output of running the code from [listing 8.11](#ch08ex11)
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 运行 [列表 8.11](#ch08ex11) 代码的输出
- en: '![](08fig05.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![图片 08fig05](08fig05.jpg)'
- en: This happens because we’re using proxies. Every time we access a property, the
    proxy `get` trap is activated. If our folder object already contains the requested
    property, its value is returned, and if it doesn’t, a new folder is created and
    assigned to the property. This is how two of our properties, `ninjasDir` and `firstNinjaDir`,
    are created. Requesting a value of an uninitialized property triggers its creation.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在使用代理。每次我们访问一个属性时，代理的 `get` 陷阱就会被激活。如果我们的文件夹对象已经包含请求的属性，它的值就会被返回，如果没有，就会创建一个新的文件夹并将其分配给属性。这就是我们的两个属性
    `ninjasDir` 和 `firstNinjaDir` 被创建的方式。请求未初始化属性的值会触发其创建。
- en: Finally, we have a tool for ridding ourselves of some cases of the pesky null
    exception!
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于有一个工具可以摆脱一些讨厌的空指针异常了！
- en: 8.2.4\. Using proxies to implement negative array indexes
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4\. 使用代理实现负数组索引
- en: In our day-to-day programming, we’ll usually work with *a lot* of arrays. Let’s
    explore how to take advantage of proxies to make our dealings with arrays a little
    more pleasant.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常编程中，我们通常会处理 *很多* 数组。让我们探索如何利用代理使我们对数组的处理更加愉快。
- en: 'If your programming background is from languages such as Python, Ruby, or Perl,
    you might be used to negative array indexes, which enable you to use negative
    indexes to access array items from the back, as shown in the following snippet:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编程背景来自像 Python、Ruby 或 Perl 这样的语言，你可能已经习惯了负数组索引，这允许你使用负索引从后端访问数组项，如下面的代码片段所示：
- en: '![](218fig01_alt.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](218fig01_alt.jpg)'
- en: Now compare the code that we normally use to access the last item in the array,
    `ninjas [ninjas.length-1]`, with the code that we can use if our language of choice
    supports negative array indexes, `ninjas[-1]`. See how much more elegant this
    is?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比较我们通常用来访问数组最后一个元素的代码，`ninjas [ninjas.length-1]`，以及如果我们选择的语言支持负数组索引，我们可以使用的代码，`ninjas[-1]`。看看这有多优雅？
- en: Unfortunately, JavaScript doesn’t offer built-in support for negative array
    indexes, but we can mimic this ability through proxies. To explore this concept,
    we’ll look at a slightly simplified version of code written by Sindre Sorhus ([https://github.com/sindresorhus/negative-array](https://github.com/sindresorhus/negative-array)),
    as shown in the following listing.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript 并没有提供对负数组索引的原生支持，但我们可以通过代理来模拟这种能力。为了探索这个概念，我们将查看由 Sindre Sorhus
    编写的代码的略微简化版本（[https://github.com/sindresorhus/negative-array](https://github.com/sindresorhus/negative-array)），如下所示列表。
- en: Listing 8.12\. Negative array indexes with proxies
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. 使用代理实现负数组索引
- en: '![](ch08ex12-0.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex12-0.jpg)'
- en: '![](ch08ex12-1.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex12-1.jpg)'
- en: 'In this example, we define a function that will create a proxy for a passed-in
    array. Because we don’t want our proxy to work with other types of objects, we
    throw an exception in case the argument isn’t an array:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个函数，该函数将为传入的数组创建一个代理。因为我们不希望我们的代理与其他类型的对象一起工作，所以如果参数不是数组，我们会抛出一个异常：
- en: '[PRE51]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We continue by creating and returning a new proxy with two traps, a `get` trap
    that will activate whenever we try to read an array item, and a `set` trap that
    will activate whenever we write to an array item:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续创建并返回一个新的代理，它有两个陷阱：一个 `get` 陷阱，它会在我们尝试读取数组项时激活，以及一个 `set` 陷阱，它会在我们写入数组项时激活：
- en: '[PRE52]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The trap bodies are similar. First, we turn the property into a number by using
    the unary plus operator (`index = +index`). Then, if the requested index is less
    than `0`, we access array items from the back by anchoring to the length of the
    array, and if it’s greater than or equal to `0`, we access the array item in a
    standard fashion.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱体是相似的。首先，我们使用一元加运算符（`index = +index`）将属性转换为数字。然后，如果请求的索引小于 `0`，我们通过锚定到数组的长度从后端访问数组项，如果它大于或等于
    `0`，我们以标准方式访问数组项。
- en: Finally, we perform various tests to check that on normal arrays we can only
    access array items through positive array indexes, and that, if we use a proxy,
    we can both access and modify array items through negative indexes.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们执行各种测试来检查在正常数组中我们只能通过正数组索引访问数组项，而且如果我们使用代理，我们可以通过负索引访问和修改数组项。
- en: 'Now that you’ve seen how to use proxies to achieve some interesting features
    such as autopopulating object properties and accessing negative array indexes,
    which are outright impossible without proxies, let’s explore the most significant
    downside to proxies: performance issues.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何使用代理来实现一些有趣的功能，比如自动填充对象属性和访问负数组索引（没有代理这是不可能的），让我们探索代理的最大缺点：性能问题。
- en: 8.2.5\. Performance costs of proxies
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.5\. 代理的性能成本
- en: As we already know, a proxy is a surrogate object through which we control access
    to another object. A proxy can define traps, functions that will be executed whenever
    a certain operation is performed on a proxy. And, as you’ve also seen, we can
    use these traps to implement useful functionalities such as logging, performance
    measurements, autopopulating properties, negative array indexes, and so on. Unfortunately,
    there’s also a downside. The fact that all our operations have to pass in through
    the proxy adds a layer of indirection that enables us to implement all these cool
    features, but at the same time it introduces a significant amount of additional
    processing that impacts performance.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，代理是一个代理对象，通过它我们可以控制对另一个对象的访问。代理可以定义陷阱，即当在代理上执行特定操作时将执行的函数。而且，正如你所看到的，我们可以使用这些陷阱来实现有用的功能，如记录、性能测量、自动填充属性、负数组索引等。不幸的是，也存在一个缺点。由于所有操作都必须通过代理进行，这增加了一个间接层，使我们能够实现所有这些酷炫功能，但同时它也引入了大量的额外处理，这影响了性能。
- en: To test these performance issues, we can build on the negative array indexes
    example from [listing 8.12](#ch08ex12) and compare the execution time when accessing
    items in a normal array versus accessing items through a proxy, as shown in the
    following listing.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些性能问题，我们可以在[列表 8.12](#ch08ex12)中的负数组索引示例的基础上构建，并比较在正常数组中访问项目与通过代理访问项目时的执行时间，如下面的列表所示。
- en: Listing 8.13\. Checking the performance limitations of proxies
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 检查代理的性能限制
- en: '![](221fig01_alt.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](221fig01_alt.jpg)'
- en: 'Because a single operation of the code happens much too quickly to measure
    reliably, the code has to be executed many times to get a measurable value. Frequently,
    this count can be in the tens of thousands, or even millions, depending on the
    nature of the code being measured. A little trial and error lets us choose a reasonable
    value: in this case 500,000.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码的单个操作发生得太快，无法可靠地测量，因此必须多次执行代码才能得到可测量的值。通常，这个计数可以是数万次，甚至数百万次，具体取决于被测量的代码的性质。一点尝试和错误让我们选择一个合理的值：在这种情况下是500,000。
- en: 'We also need to bracket the execution of the code with two `new Date().getTime()`
    timestamps: one before we start executing the target code, and one after. Their
    difference tells us how long the code took to perform. Finally, we can compare
    the results by calling the `measure` function on both the proxied array and the
    standard array.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用两个`new Date().getTime()`时间戳来括号化代码的执行：一个在我们开始执行目标代码之前，另一个在之后。它们的差值告诉我们代码执行所需的时间。最后，我们可以通过在代理数组和对标准数组上调用`measure`函数来比较结果。
- en: On our machine, the results don’t fare well for proxies. It turns out that in
    Chrome, proxies are around 50 times slower; in Firefox, they’re about 20 times
    slower.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的机器上，代理的结果并不理想。结果是，在Chrome中，代理大约慢50倍；在Firefox中，它们大约慢20倍。
- en: For now, we recommend that you be careful when using proxies. Although they
    allow you to be creative with controlling access to objects, that amount of control
    comes with performance issues. You can use proxies with code that’s not performance
    sensitive, but be careful when using them in code that’s executed a lot. As always,
    we recommend that you thoroughly test the performance of your code.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们建议你在使用代理时要小心。虽然它们允许你在控制对象访问方面具有创造性，但这种控制程度伴随着性能问题。你可以使用对性能不敏感的代码与代理一起使用，但在大量执行的代码中使用它们时要小心。一如既往，我们建议你彻底测试你代码的性能。
- en: 8.3\. Summary
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 摘要
- en: We can monitor our objects with getters, setters, and proxies.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用获取器（getters）、设置器（setters）和代理（proxies）来监控我们的对象。
- en: By using accessor methods (getters and setters), we can control access to object
    properties.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用访问器方法（获取器和设置器），我们可以控制对对象属性的访问。
- en: Accessor properties can be defined by using the built-in `Object.define-Property`
    method or with a special `get` and `set` syntax as parts of object literals or
    ES6 classes.
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器属性可以通过使用内置的`Object.defineProperty`方法或使用特殊的`get`和`set`语法作为对象字面量或ES6类的部分来定义。
- en: A `get` method is implicitly called whenever we try to read, whereas a `set`
    method is called whenever we assign a value to the matching object’s property.
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们尝试读取时，都会隐式调用`get`方法，而当我们为匹配对象的属性赋值时，则会调用`set`方法。
- en: Getter methods can be used to define computed properties, properties whose value
    is calculated on a per request basis, whereas setter methods can be used to achieve
    data validation and logging.
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器方法可以用来定义计算属性，这些属性的价值是基于每个请求计算的，而设置器方法可以用来实现数据验证和日志记录。
- en: Proxies are an ES6 addition to JavaScript and are used to control other objects.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理是JavaScript的ES6新增功能，用于控制其他对象。
- en: Proxies enable us to define custom actions that will be executed when an object
    is interacted with (for example, when a property is read or a function is called).
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理使我们能够定义在对象交互时（例如，当读取属性或调用函数时）将执行的定制操作。
- en: All interactions have to go through the proxy, which has traps that are triggered
    when a specific action occurs.
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有交互都必须通过代理进行，当发生特定操作时，代理会触发陷阱。
- en: Use proxies to achieve elegant
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理实现优雅
- en: Logging
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Performance measurements
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测量
- en: Data validation
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证
- en: Autopopulating object properties (thereby avoiding pesky null exceptions)
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动填充对象属性（从而避免讨厌的null异常）
- en: Negative array indexes
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负数组索引
- en: Proxies aren’t fast, so be careful when using them in code that’s executed a
    lot. We recommend that you do performance testing.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理并不快，所以在大量执行的代码中使用它们时要小心。我们建议您进行性能测试。
- en: 8.4\. Exercises
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 练习
- en: '**1**'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, which of the following expressions will throw
    an exception and why?
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码后，以下哪个表达式会抛出异常，以及为什么？
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ninja.name();`'
  id: totrans-571
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ninja.name();`'
- en: '`const name = ninja.name;`'
  id: totrans-572
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const name = ninja.name;`'
- en: '**2**'
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code, which mechanism allows getters to access a private object
    variable?
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码中，哪种机制允许获取器访问私有对象变量？
- en: ''
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**3**'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following assertions will pass?
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个断言会通过？
- en: ''
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**4**'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following assertions will pass?
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个断言会通过？
- en: ''
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Chapter 9\. Dealing with collections
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 处理集合
- en: '*This chapter covers*'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating and modifying arrays
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和修改数组
- en: Using and reusing array functions
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和重用数组函数
- en: Creating dictionaries with maps
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射创建字典
- en: Creating collections of unique objects with sets
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合创建唯一对象的集合
- en: 'Now that we’ve spent some time wrangling the particularities of object-orientation
    in JavaScript, we’ll move on to a closely related topic: collections of items.
    We’ll start with arrays, the most basic type of collection in JavaScript, and
    look at some array peculiarities you may not expect if your programming background
    is in another programming language. We’ll continue by exploring some of the built-in
    array methods that will help you write more elegant array-handling code.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花了一些时间处理JavaScript中面向对象的特定性，我们将继续探讨一个与之密切相关的话题：项目集合。我们将从数组开始，这是JavaScript中最基本的集合类型，并探讨一些如果你在另一种编程语言中编程背景，可能不会预料到的数组特性。我们将继续探讨一些内置的数组方法，这些方法将帮助你编写更优雅的数组处理代码。
- en: 'Next, we’ll discuss two new ES6 collections: maps and sets. Using maps, you
    can create dictionaries of a sort that carry mappings between keys and values—a
    collection that’s extremely useful in certain programming tasks. Sets, on the
    other hand, are collections of unique items in which each item can’t occur more
    than once. Let’s begin our exploration with the simplest and most common of all
    collections: arrays.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论两个新的ES6集合：映射和集合。使用映射，你可以创建一种类型的字典，它携带键和值之间的映射——这种集合在特定的编程任务中非常有用。另一方面，集合是唯一项目的集合，其中每个项目只能出现一次。让我们从最简单、最常见的一切集合开始：数组。
- en: Do you know?
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some of the common pitfalls of using objects as dictionaries or maps?
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用对象作为字典或映射时，常见的陷阱有哪些？
- en: '**Q2:**'
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value types can a key/value pair have in a `Map`?
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`Map`中，键/值对可以有什么值类型？
- en: '**Q3:**'
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Must the items in a `Set` be of the same type?
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Set`中的项目必须具有相同的类型吗？'
- en: 9.1\. Arrays
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 数组
- en: Arrays are one of the most common data types. Using them, you can handle collections
    of items. If your programming background is in a strongly typed language such
    as C, you probably think of arrays as sequential chunks of memory that house items
    of the same type, where each chunk of memory is of fixed size and has an associated
    index through which you can easily access it.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是最常见的数据类型之一。使用它们，你可以处理项目集合。如果你的编程背景是在C这样的强类型语言中，你可能认为数组是存储相同类型项的连续内存块，每个内存块具有固定的大小，并通过一个关联的索引可以轻松访问它。
- en: 'But as with many things in JavaScript, arrays come with a twist: They’re just
    objects. Although this leads to some unfortunate side effects, primarily in terms
    of performance, it also has some benefits. For example, arrays can access methods,
    like other objects—methods that will make our lives a lot easier.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像JavaScript中的许多事物一样，数组也有一些转折：它们只是对象。尽管这导致了一些不幸的副作用，主要是性能方面，但它也有一些好处。例如，数组可以访问方法，就像其他对象一样——这些方法将使我们的生活变得更加容易。
- en: In this section, we’ll first look at ways to create arrays. Then we’ll explore
    how to add items to and remove items from different positions in an array. Finally,
    we’ll examine the built-in array methods that will make our array-handling code
    much more elegant.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨创建数组的方法。然后我们将探讨如何向数组的不同位置添加项和从数组中移除项。最后，我们将检查内置的数组方法，这些方法将使我们的数组处理代码更加优雅。
- en: 9.1.1\. Creating arrays
  id: totrans-610
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 创建数组
- en: 'There are two fundamental ways to create new arrays:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新数组有两种基本方法：
- en: Using the built-in `Array` constructor
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的`Array`构造函数
- en: Using array literals `[]`
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组字面量`[]`
- en: Let’s start with a simple example in which `we` create an array of ninjas and
    an array of samurai.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个忍者数组和武士数组的简单例子开始。
- en: Listing 9.1\. Creating arrays
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1. 创建数组
- en: '![](ch09ex01-0.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex01-0.jpg)'
- en: '![](ch09ex01-1.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex01-1.jpg)'
- en: 'In [listing 9.1](#ch09ex01), we start by creating two arrays. The `ninjas`
    array is created with a simple array literal:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表9.1](#ch09ex01)中，我们首先创建两个数组。`ninjas`数组是通过简单的数组字面量创建的：
- en: '[PRE57]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It’s immediately prefilled with three ninjas: Kuma, Hattori, and Yagyu. The
    `samurai` array is created using the built-in `Array` constructor:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 它立即填充了三个忍者：Kuma、Hattori和Yagyu。`samurai`数组是通过内置的`Array`构造函数创建的：
- en: '[PRE58]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Array literals versus the Array constructor**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组字面量与数组构造函数**'
- en: 'Using array literals to create arrays is preferred over creating arrays with
    the `Array` constructor. The primary reason is simplicity: `[]` versus `new Array()`
    (2 characters versus 11 characters—hardly a fair contest). In addition, because
    JavaScript is highly dynamic, nothing stops someone from overriding the built-in
    `Array` constructor, which means calling `new Array()` doesn’t necessarily have
    to create an array. Thus we recommend that you generally stick to array literals.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组字面量创建数组比使用`Array`构造函数创建数组更受欢迎。主要原因是简单性：`[]`与`new Array()`（2个字符与11个字符——几乎不是一个公平的竞争）。此外，由于JavaScript高度动态，没有人可以阻止某人覆盖内置的`Array`构造函数，这意味着调用`new
    Array()`不一定必须创建一个数组。因此，我们建议你通常坚持使用数组字面量。
- en: '|  |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Regardless of how we create it, each array has a `length` property that specifies
    the size of the array. For example, the `length` of the `ninjas` array is `3`,
    and it contains 3 ninjas. We can test this with the following assertions:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何创建它，每个数组都有一个`length`属性，该属性指定了数组的大小。例如，`ninjas`数组的长度是`3`，它包含3个忍者。我们可以通过以下断言来测试这一点：
- en: '[PRE59]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you probably know, you access array items by using index notation, where
    the first item is positioned at index `0` and the last item at index `array.length`
    – 1\. But if we try to access an index outside those bounds—for example, with
    `ninjas[4]` (remember, we have only three ninjas!), we won’t get the scary “Array
    index out of bounds” exception that we receive in most other programming languages.
    Instead, `undefined` is returned, signaling that there’s nothing there:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你通过使用索引符号来访问数组项，其中第一个项目位于索引`0`，最后一个项目位于索引`array.length - 1`。但是如果我们尝试访问这些范围之外的索引——例如，使用`ninjas[4]`（记住，我们只有三个忍者！），我们不会得到在大多数其他编程语言中接收到的可怕的“数组索引越界”异常。相反，返回`undefined`，表示那里没有内容：
- en: '[PRE60]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This behavior is a consequence of the fact that JavaScript arrays are objects.
    Just as we’d get `undefined` if we tried to access a nonexistent object property,
    we get `undefined` when accessing a nonexistent array index.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是JavaScript数组是对象的事实的结果。正如如果我们尝试访问一个不存在的对象属性会得到`undefined`一样，当我们尝试访问一个不存在的数组索引时，也会得到`undefined`。
- en: On the other hand, if we try to write to a position outside of array bounds,
    as in
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们尝试写入数组范围之外的某个位置，就像
- en: '[PRE61]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'the array will expand to accommodate the new situation. For example, see [figure
    9.1](#ch09fig01): We’ve essentially created a hole in the array, and the item
    at index `3` is `undefined`. This also changes the value of the `length` property,
    which now reports a value of `5`, even though one array item is `undefined`.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 数组将扩展以适应新的情况。例如，参见 [图 9.1](#ch09fig01)：我们在数组中实际上创建了一个空位，索引 `3` 的项目是 `undefined`。这也改变了
    `length` 属性的值，现在报告的值是 `5`，尽管数组中有一个项目是 `undefined`。
- en: Figure 9.1\. Writing to an array index outside of array bounds expands the array.
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 在数组边界之外写入数组索引会扩展数组。
- en: '![](09fig01_alt.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01_alt.jpg)'
- en: 'Unlike in most other languages, in JavaScript, arrays also exhibit a peculiar
    feature related to the `length` property: Nothing stops us from manually changing
    its value. Setting a value higher than the current length will expand the array
    with `undefined` items, whereas setting the value to a lower value will trim the
    array, as in `ninjas.length = 2;`.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他语言不同，在 JavaScript 中，数组还表现出与 `length` 属性相关的奇特特性：没有任何东西阻止我们手动更改它的值。将值设置得高于当前长度将会使用
    `undefined` 项目扩展数组，而将值设置得低于当前长度将会裁剪数组，例如 `ninjas.length = 2;`。
- en: Now that we’ve gone through the basics of array creation, let’s go through some
    of the most common array methods.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了数组创建的基础知识，那么让我们来看看一些最常见的数组方法。
- en: 9.1.2\. Adding and removing items at either end of an array
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 在数组的两端添加和移除项目
- en: 'Let’s start with the following simple methods we can use to add items to and
    remove items from an array:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下简单的方法开始，这些方法可以帮助我们在数组中添加和移除项目：
- en: '`push` adds an item to the end of the array.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push` 方法向数组的末尾添加一个项目。'
- en: '`unshift` adds an item to the beginning of the array.'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unshift` 方法向数组的开头添加一个项目。'
- en: '`pop` removes an item from the end of the array.'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop` 方法从数组的末尾移除一个项目。'
- en: '`shift` removes an item from the beginning of the array.'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift` 方法从数组的开头移除一个项目。'
- en: You’ve probably already used these methods, but just in case, let’s make sure
    we’re on the same page by exploring the following listing.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经使用过这些方法，但为了以防万一，让我们通过探索以下列表来确保我们处于同一页面上。
- en: Listing 9.2\. Adding and removing array items
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 添加和移除数组项目
- en: '![](ch09ex02-0.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex02-0.jpg)'
- en: '![](ch09ex02-1.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex02-1.jpg)'
- en: 'In this example, we first create a new, empty `ninjas` array:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个新的空 `ninjas` 数组：
- en: '[PRE62]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In each array, we can use the built-in `push` method to append an item to the
    end of the array, changing its length in the process:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个数组中，我们可以使用内置的 `push` 方法将项目追加到数组的末尾，在这个过程中改变其长度：
- en: '[PRE63]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can also add new items to the beginning of the array by using the built
    in `unshift` method:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用内置的 `unshift` 方法在数组的开头添加新项目：
- en: '[PRE64]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice how existing array items are adjusted. For example, before calling the
    `unshift` method, `"Kuma"` was at index `0`, and afterward it’s at index `1`.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现有数组项目是如何调整的。例如，在调用 `unshift` 方法之前，`"Kuma"` 在索引 `0`，之后它位于索引 `1`。
- en: 'We can also remove elements from either the end or the beginning of the array.
    Calling the built-in `pop` method removes an element from the end of the array,
    reducing the array’s length in the process:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从数组的末尾或开头移除元素。调用内置的 `pop` 方法会从数组的末尾移除一个元素，在这个过程中减少数组的长度：
- en: '[PRE65]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can also remove an item from the beginning of the array by using the built-in
    `shift` method:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用内置的 `shift` 方法从数组的开头移除一个项目：
- en: '[PRE66]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[Figure 9.2](#ch09fig02) shows how `push`, `pop`, `shift`, and `unshift` modify
    arrays.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.2](#ch09fig02) 展示了 `push`、`pop`、`shift` 和 `unshift` 如何修改数组。'
- en: Figure 9.2\. The `push` and `pop` methods modify the end of an array, whereas
    `shift` and `unshift` modify the array’s beginning.
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. `push` 和 `pop` 方法修改数组的末尾，而 `shift` 和 `unshift` 修改数组的开头。
- en: '![](09fig02_alt.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig02_alt.jpg)'
- en: '|  |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Performance considerations: pop and push versus shift and unshift**'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能考虑：pop 和 push 与 shift 和 unshift 的比较**'
- en: 'The `pop` and `push` methods only affect the last item in an array: `pop` by
    removing the last item, and `push` by inserting an item at the end of the array.
    On the other hand, the `shift` and `unshift` methods change the first item in
    the array. This means the indexes of any subsequent array items have to be adjusted.
    For this reason, `push` and `pop` are significantly faster operations than `shift`
    and `unshift`, and we recommend using them unless you have a good reason to do
    otherwise.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 和 `push` 方法只影响数组中的最后一个项目：`pop` 通过删除最后一个项目，而 `push` 通过在数组末尾插入一个项目。另一方面，`shift`
    和 `unshift` 方法改变数组中的第一个项目。这意味着任何后续数组项的索引都需要调整。因此，`push` 和 `pop` 的操作比 `shift` 和
    `unshift` 快得多，我们建议除非有充分的理由，否则使用它们。'
- en: '|  |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.1.3\. Adding and removing items at any array location
  id: totrans-666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 在任何数组位置添加和删除项
- en: The previous example removed items from the beginning and end of the array.
    But this is too constraining—in general, we should be able to remove items from
    any array location. One straightforward approach for doing this is shown in the
    following listing.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是从数组的开始和结束删除项。但这太受限制了——一般来说，我们应该能够从数组的任何位置删除项。以下列表展示了实现这一点的直接方法。
- en: Listing 9.3\. Naïve way to remove an array item
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 删除数组项的朴素方法
- en: '![](230fig01_alt.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![](230fig01_alt.jpg)'
- en: This approach to deleting an item from an array doesn’t work. We effectively
    only create a hole in the array. The array still reports that it has four items,
    but one of them—the one we wanted to delete—is `undefined` (see [figure 9.3](#ch09fig03)).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组中删除项的方法不起作用。我们实际上只是在数组中创建了一个空位。数组仍然报告它有四个项目，但其中之一——我们想要删除的那个——是 `undefined`（见[图
    9.3](#ch09fig03)）。
- en: Figure 9.3\. Deleting an item from an array creates a hole in the array.
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. 从数组中删除项会在数组中创建一个空位。
- en: '![](09fig03.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03.jpg)'
- en: 'Similarly, if we wanted to insert an item at an arbitrary position, where would
    we even start? As an answer to these problems, all JavaScript arrays have access
    to the `splice` method: Starting from a given index, this method removes and inserts
    items. Check out the following example.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们想在任意位置插入一个项目，我们甚至从哪里开始呢？作为对这些问题的回答，所有 JavaScript 数组都可以访问 `splice` 方法：从给定索引开始，这个方法会删除和插入项目。查看以下示例。
- en: Listing 9.4\. Removing and adding items at arbitrary positions
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 在任意位置添加和删除项
- en: '![](ch09ex04-0.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex04-0.jpg)'
- en: '![](ch09ex04-1.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex04-1.jpg)'
- en: 'We begin by creating a new array with four items:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含四个项目的新数组：
- en: '[PRE67]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then we call the built-in `splice` method:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用内置的 `splice` 方法：
- en: '[PRE68]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this case, `splice` takes two arguments: the index from which the splicing
    starts, and the number of elements to be removed (if we leave out this argument,
    all elements to the end of the array are removed). In this case, the element with
    index `1` is removed from the array, and all subsequent elements are shifted accordingly.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`splice` 接受两个参数：开始剪切操作的索引，以及要删除的元素数量（如果我们省略这个参数，则删除数组末尾的所有元素）。在这种情况下，索引为
    `1` 的元素从数组中删除，并且所有后续元素相应地移动。
- en: 'In addition, the `splice` method returns an array of items that have been removed.
    In this case, the result is an array with a single item: `"Kuma"`.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`splice` 方法返回一个包含已删除项的数组。在这种情况下，结果是包含单个项目的数组：`"Kuma"`。
- en: 'Using the `splice` method, we can also insert items into arbitrary positions
    in an array. For example, consider the following code:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `splice` 方法，我们还可以在数组的任意位置插入项目。例如，考虑以下代码：
- en: '[PRE69]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Starting from index `1`, it first removes two items and then adds three items:
    `"Mochizuki"`, `"Yoshi"`, and `"Momochi"`.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 从索引 `1` 开始，它首先删除两个项目，然后添加三个项目：`"Mochizuki"`、`"Yoshi"` 和 `"Momochi"`。
- en: Now that we’ve given you a refresher on how arrays work, let’s continue by studying
    some common operations that are often performed on arrays. These will help you
    write more elegant array-handling code.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经向您介绍了数组的工作原理，让我们继续研究一些在数组上经常执行的一些常见操作。这将帮助您编写更优雅的数组处理代码。
- en: 9.1.4\. Common operations on arrays
  id: totrans-687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4\. 数组上的常见操作
- en: 'In this section, we’ll explore some of the most common operations on arrays:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨数组上的一些最常见操作：
- en: '*Iterating* (or *traversing*) through arrays'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代*（或*遍历*）数组'
- en: '*Mapping* existing array items to create a new array based on them'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射*现有的数组项以创建基于它们的新数组'
- en: '*Testing* array items to check whether they satisfy certain conditions'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试*数组项以检查它们是否满足某些条件'
- en: '*Finding* specific array items'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找*特定的数组项'
- en: '*Aggregating* arrays and computing a single value based on array items (for
    example, calculating the sum of an array)'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*聚合* 数组并基于数组项计算单个值（例如，计算数组的总和）'
- en: 'We’ll start with the basics: array iterations.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基础知识开始：数组迭代。
- en: Iterating over arrays
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'One of the most common operations is iterating over an array. Going back to
    Computer Science 101, an iteration is most often performed in the following way:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的操作之一是遍历数组。回到计算机科学 101，迭代通常以以下方式执行：
- en: '![](232fig01_alt.jpg)'
  id: totrans-697
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig01_alt.jpg)'
- en: This example is as simple as it looks. It uses a `for` loop to check every item
    in the array; the results are shown in [figure 9.4](#ch09fig04).
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来很简单。它使用 `for` 循环检查数组中的每个项；结果在 [图 9.4](#ch09fig04) 中显示。
- en: Figure 9.4\. The output of checking the ninjas with a `for` loop
  id: totrans-699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 使用 `for` 循环检查忍者的输出
- en: '![](09fig04.jpg)'
  id: totrans-700
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04.jpg)'
- en: You’ve probably written something like this so many times that you don’t even
    have to think about it anymore. But just in case, let’s take a closer look at
    the `for` loop.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经写了无数次类似的东西，以至于你甚至不再需要思考。但以防万一，让我们更仔细地看看 `for` 循环。
- en: To go through an array, we have to set up a counter variable, `i`, specify the
    number up to which we want to count (`ninjas.length)`, and define how the counter
    will be modified (`i++`). That’s an awful lot of bookkeeping to perform such a
    common action, and it can be a source of annoying little bugs. In addition, it
    makes our code more difficult to read. Readers have to look closely at every part
    of the `for` loop, just to be sure it goes through all the items and doesn’t skip
    any.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历一个数组，我们必须设置一个计数器变量 `i`，指定我们想要计数的数字（`ninjas.length`），并定义计数器如何被修改（`i++`）。这是一件非常繁琐的事情，只是执行这样一个常见的操作，而且它可能是令人烦恼的小错误的来源。此外，它使我们的代码更难以阅读。读者必须仔细查看
    `for` 循环的每个部分，以确保它遍历了所有项且没有跳过任何项。
- en: To make life easier, all JavaScript arrays have a built-in `forEach` method
    we can use in such situations. Look at the following example.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使生活更简单，所有 JavaScript 数组都有一个内置的 `forEach` 方法，我们可以在这种情况下使用。看看以下示例。
- en: Listing 9.5\. Using the forEach method
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 使用 forEach 方法
- en: '![](233fig01_alt.jpg)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig01_alt.jpg)'
- en: We provide a callback (in this case, an arrow function) that’s called *immediately*,
    for each item in the array. That’s it—no more fussing about the start index, the
    end condition, or the exact nature of the increment. The JavaScript engine takes
    care of all that for us, behind the scenes. Notice how much easier to understand
    this code is, and how it has fewer bug-spawning points.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个回调（在这种情况下，一个箭头函数），它对数组中的每个项都会立即被调用。就是这样——不再需要担心起始索引、结束条件或精确的增量。JavaScript
    引擎会为我们处理所有这些，幕后操作。注意，这段代码更容易理解，并且错误产生的点更少。
- en: We’ll continue by taking things up a notch and seeing how we can map arrays
    to other arrays.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续提高难度，看看我们如何将数组映射到其他数组。
- en: Mapping arrays
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射数组
- en: Imagine that you have an array of `ninja` objects. Each ninja has a name and
    a favorite weapon, and you want to extract an array of weapons from the `ninjas`
    array. Armed with the knowledge of the `forEach` method, you might write something
    like the following listing.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `ninja` 对象的数组。每个忍者和他最喜欢的武器，你想要从 `ninjas` 数组中提取武器数组。有了 `forEach` 方法的知识，你可能会写出以下列表。
- en: Listing 9.6\. Naïve extraction of a weapons array
  id: totrans-710
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 原始提取武器数组
- en: '![](233fig02_alt.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig02_alt.jpg)'
- en: 'This isn’t all that bad: We create a new, empty array, and use the `forEach`
    method to iterate over the `ninjas` array. Then, for each `ninja` object, we add
    the current weapon to the `weapons` array.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不算太糟糕：我们创建了一个新的、空的数组，并使用 `forEach` 方法遍历 `ninjas` 数组。然后，对于每个 `ninja` 对象，我们将当前武器添加到
    `weapons` 数组中。
- en: 'As you might imagine, creating new arrays based on the items in an existing
    array is surprisingly common—so common that it has a special name: *mapping* an
    array. The idea is that we map each item from one array to a new item of a new
    array. Conveniently, JavaScript has a `map` function that does exactly that, as
    shown in the following listing.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，根据现有数组中的项创建新数组是出奇地常见——常见到它有一个特殊的名称：*映射* 数组。其想法是将一个数组中的每个项映射到新数组的新项。方便的是，JavaScript
    有一个 `map` 函数可以做到这一点，如下面的列表所示。
- en: Listing 9.7\. Mapping an array
  id: totrans-714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 映射数组
- en: '![](234fig01_alt.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![](234fig01_alt.jpg)'
- en: The built-in `map` method constructs a completely new array and then iterates
    over the input array. For each item in the input array, `map` places exactly one
    item in the newly constructed array, based on the result of the callback provided
    to `map`. The inner workings of the `map` function are shown in [figure 9.5](#ch09fig05).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `map` 方法构建一个全新的数组，然后遍历输入数组。对于输入数组中的每个项目，`map` 根据提供给 `map` 的回调函数的结果，在新建的数组中放置一个项目。`map`
    函数的内部工作原理在 [图9.5](#ch09fig05) 中展示。
- en: Figure 9.5\. The `map` function calls the provided callback function (fc) on
    each array item, and creates a new array with callback return values.
  id: totrans-717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. `map` 函数对每个数组项目调用提供的回调函数（fc），并创建一个包含回调返回值的新数组。
- en: '![](09fig05_alt.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](09fig05_alt.jpg)'
- en: Now that we know how to map arrays, let’s see how to test array items for certain
    conditions.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何映射数组，让我们看看如何测试数组项目是否满足特定条件。
- en: Testing array items
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试数组项目
- en: When working with collections of items, we’ll often run into situations where
    we need to know whether *all* or at least *some* of the array items satisfy certain
    conditions. To write this code as efficiently as possible, all JavaScript arrays
    have access to the built-in `every` and `some` methods, shown next.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理项目集合时，我们经常会遇到需要知道是否所有或至少某些数组项目满足特定条件的情况。为了尽可能高效地编写此代码，所有 JavaScript 数组都可以访问内置的
    `every` 和 `some` 方法，如下所示。
- en: Listing 9.8\. Testing arrays with the every and some methods
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 使用 `every` 和 `some` 方法测试数组
- en: '![](235fig01_alt.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](235fig01_alt.jpg)'
- en: '[Listing 9.8](#ch09ex08) shows an example where we have a collection of `ninja`
    objects but are unsure of their names and whether all of them are armed. To get
    to the root of this problem, we first take advantage of `every`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.8](#ch09ex08) 展示了一个例子，其中我们有一个 `ninja` 对象集合，但我们不确定它们的名称以及是否所有对象都配备了武器。为了找到这个问题的根源，我们首先利用
    `every`：'
- en: '[PRE70]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `every` method takes a callback that, for each ninja in the collection,
    checks whether we know the ninja’s name. `every` returns `true` only if the passed-in
    callback returns `true` for *every* item in the array. [Figure 9.6](#ch09fig06)
    shows how `every` works.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`every` 方法接受一个回调函数，对于集合中的每个 `ninja`，检查我们是否知道 `ninja` 的名字。只有当传入的回调函数对数组中的每个项目都返回
    `true` 时，`every` 才返回 `true`。[图9.6](#ch09fig06) 展示了 `every` 的工作原理。'
- en: Figure 9.6\. The `every` method tests whether all items in an array satisfy
    a certain condition represented by a callback.
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. `every` 方法测试数组中的所有项目是否满足由回调函数表示的某个条件。
- en: '![](09fig06_alt.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](09fig06_alt.jpg)'
- en: 'In other cases, we only care whether *some* array items satisfy a certain condition.
    For these situations, we can use the built-in method `some`:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们只关心是否某些数组项目满足特定条件。对于这些情况，我们可以使用内置方法 `some`：
- en: '[PRE71]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Starting from the first array item, `some` calls the callback on each array
    item until an item is found for which the callback returns a `true` value. If
    such an item is found, the return value is `true`; if not, the return value is
    `false`.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个数组项目开始，`some` 对每个数组项目调用回调函数，直到找到一个回调返回 `true` 值的项目。如果找到了这样的项目，返回值是 `true`；如果没有，返回值是
    `false`。
- en: '[Figure 9.7](#ch09fig07) shows how `some` works under the hood: We search an
    array in order to find out whether some or all of its items satisfy a certain
    condition. Next we’ll explore how to search an array to find a particular item.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.7](#ch09fig07) 展示了 `some` 方法在底层是如何工作的：我们按顺序搜索数组以确定其项目是否满足某个条件。接下来，我们将探讨如何搜索数组以找到特定项目。'
- en: Figure 9.7\. The `some` method checks whether at least one array item satisfies
    a condition represented by the passed-in callback.
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. `some` 方法检查至少有一个数组项目是否满足传入回调函数表示的条件。
- en: '![](09fig07_alt.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](09fig07_alt.jpg)'
- en: Searching arrays
  id: totrans-735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 搜索数组
- en: 'Another common operation that you’re bound to use, sooner rather than later,
    is finding items in an array. Again, this task is greatly simplified with another
    built-in array method: `find`. Let’s study the following listing.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 你迟早会使用的一个常见操作是查找数组中的项目。同样，这个任务可以通过另一个内置数组方法 `find` 得到极大的简化。让我们研究以下列表。
- en: '|  |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The built-in `find` method is part of the ES6 standard. For current browser
    compatibility, see [http://mng.bz/U532](http://mng.bz/U532).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `find` 方法是 ES6 标准的一部分。关于当前浏览器的兼容性，请参阅 [http://mng.bz/U532](http://mng.bz/U532)。
- en: '|  |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 9.9\. Finding array items
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.9\. 查找数组项目
- en: '![](ch09ex09-0.jpg)'
  id: totrans-742
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](ch09ex09-0.jpg)'
- en: '![](ch09ex09-1.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](ch09ex09-1.jpg)'
- en: 'It’s easy to find an array item that satisfies a certain condition: We use
    the built-in `find` method, passing it a callback that’s invoked for each item
    in the collection until the targeted item is found. This is indicated by the callback
    returning `true`. For example, the expression'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个满足特定条件的数组项很容易：我们使用内置的 `find` 方法，传递一个回调函数，该函数对集合中的每个项进行调用，直到找到目标项。这由回调返回
    `true` 来指示。例如，以下表达式
- en: '[PRE72]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: finds Kuma, the first ninja in the `ninjas` array that’s wielding a wakizashi.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 `ninjas` 数组中第一个携带短刀的忍者 Kuma。
- en: If we’ve gone through the entire array without a single item returning `true`,
    the final result of the search is `undefined`. For example, the code
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遍历了整个数组而没有单个项返回 `true`，则搜索的最终结果是 `undefined`。例如，以下代码
- en: '[PRE73]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: returns `undefined`, because there isn’t a katana-wielding ninja. [Figure 9.8](#ch09fig08)
    shows the inner workings of the `find` function.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `undefined`，因为没有携带武士刀的忍者。![图 9.8](#ch09fig08) 展示了 `find` 函数的内部工作原理。
- en: 'Figure 9.8\. The `find` function finds one item in an array: the first item
    for which the `find` callback returns `true`.'
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. `find` 函数在一个数组中查找一个项：第一个使 `find` 回调返回 `true` 的项。
- en: '![](09fig08_alt.jpg)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig08_alt.jpg)'
- en: If we need to find multiple items satisfying a certain criterion, we can use
    the `filter` method, which creates a *new* array containing all the items that
    satisfy that criterion. For example, the expression
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要找到满足特定标准的多项，我们可以使用 `filter` 方法，它创建一个包含所有满足该标准的项的新数组。例如，以下表达式
- en: '[PRE74]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: creates a new `armedNinjas` array that contains only `ninja`s with a weapon.
    In this case, poor unarmed Yoshi is left out. [Figure 9.9](#ch09fig09) shows how
    the `filter` function works.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个只包含 `ninja`s 武器的 `armedNinjas` 数组。在这种情况下，可怜的无武器 Yoshi 被排除在外。![图 9.9](#ch09fig09)
    展示了 `filter` 函数的工作方式。
- en: Figure 9.9\. The `filter` function creates a new array that contains all items
    for which the callback returns `true`.
  id: totrans-755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.9\. `filter` 函数创建一个新数组，该数组包含所有使回调返回 `true` 的项。
- en: '![](09fig09_alt.jpg)'
  id: totrans-756
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig09_alt.jpg)'
- en: Throughout this example, you’ve seen how to find particular items in an array,
    but in many cases it might also be necessary to find the index of an item. Let’s
    take a closer look, with the following example.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你已经看到了如何在数组中查找特定项，但在许多情况下，也可能需要找到项的索引。让我们通过以下示例进行更详细的了解。
- en: Listing 9.10\. Finding array indexes
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 查找数组索引
- en: '[PRE75]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To find the index of a particular item, we use the built-in `indexOf` method,
    passing it the item whose index we want to find:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到特定项的索引，我们使用内置的 `indexOf` 方法，传递我们想要找到索引的项：
- en: '[PRE76]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In cases where a particular item can be found multiple times in an array (as
    is the case with `"Yoshi"` and the `ninjas` array), we may also be interested
    in finding the last index where Yoshi appears. For this, we can use the `lastIndexOf`
    method:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定项可以在数组中多次出现的情况下（例如 `"Yoshi"` 和 `ninjas` 数组），我们可能还感兴趣找到 Yoshi 出现的最后一个索引。为此，我们可以使用
    `lastIndexOf` 方法：
- en: '[PRE77]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, in the most-general case, when we don’t have a reference to the exact
    item whose index we want to search for, we can use the `findIndex` method:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在大多数情况下，当我们没有要搜索的项的确切索引的引用时，我们可以使用 `findIndex` 方法：
- en: '[PRE78]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `findIndex` method takes a callback and returns the index of the first item
    for which the callback returns `true`. In essence, it works a lot like the `find`
    method, the only difference being that `find` returns a particular item, whereas
    `findIndex` returns the index of that item.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIndex` 方法接受一个回调函数并返回第一个使回调返回 `true` 的项的索引。本质上，它的工作方式与 `find` 方法非常相似，唯一的区别在于
    `find` 返回一个特定的项，而 `findIndex` 返回该项的索引。'
- en: Sorting arrays
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 排序数组
- en: 'One of the most common array operations is *sorting—*arranging items systematically
    in some order. Unfortunately, correctly implementing sorting algorithms isn’t
    the easiest of programming tasks: We have to select the best sorting algorithm
    for the task, implement it, and tailor it to our needs, while, as always, being
    careful not to introduce subtle bugs. To get this burden off our back, as you
    saw in [chapter 3](kindle_split_014.html#ch03), all JavaScript arrays have access
    to the built-in `sort` method, whose usage looks something like this:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的数组操作之一是 *排序*——有系统地按某种顺序排列项。不幸的是，正确实现排序算法并不是一项容易的编程任务：我们必须为任务选择最佳的排序算法，实现它，并根据我们的需求进行调整，同时始终小心不要引入微妙的错误。为了减轻这个负担，正如你在[第
    3 章](kindle_split_014.html#ch03)中看到的，所有 JavaScript 数组都可以访问内置的 `sort` 方法，其用法如下：
- en: '[PRE79]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The JavaScript engine implements the sorting algorithm. The only thing we have
    to provide is a callback that informs the sorting algorithm about the relationship
    between two array items. The possible results are as follows:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎实现了排序算法。我们唯一需要提供的是回调函数，它告知排序算法两个数组项之间的关系。可能的结果如下：
- en: If a callback returns a value less than `0`, then item `a` should come before
    item `b`.
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果回调返回的值小于 `0`，则项目 `a` 应该排在项目 `b` 之前。
- en: If a callback returns a value equal to `0`, then items `a` and `b` are on equal
    footing (as far as the sorting algorithm is concerned, they’re equal).
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果回调返回的值等于 `0`，则项目 `a` 和 `b` 处于平等地位（就排序算法而言，它们是相等的）。
- en: If a callback returns a value greater than `0`, then item `a` should come after
    item `b`.
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果回调返回的值大于 `0`，则项目 `a` 应该排在项目 `b` 之后。
- en: '[Figure 9.10](#ch09fig10) shows the decisions made by the sorting algorithm
    depending on the callback return value.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.10](#ch09fig10) 展示了排序算法根据回调返回值所做的决策。'
- en: Figure 9.10\. If the call-back returns a value less than `0`, the first item
    should come before the second. If the callback returns `0`, both items should
    be left as is. And if the return value is greater than `0`, the first item should
    come after the second item.
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.10\. 如果回调返回的值小于 `0`，则第一个项目应排在第二个项目之前。如果回调返回 `0`，则两个项目应保持不变。如果返回值大于 `0`，则第一个项目应排在第二个项目之后。
- en: '![](09fig10_alt.jpg)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig10_alt.jpg)'
- en: And that’s about all you need to know about the sorting algorithm. The actual
    sorting is performed behind the scenes, without us having to manually move array
    items around. Let’s look at a simple example.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排序算法，你只需要知道这么多。实际的排序是在幕后进行的，我们无需手动移动数组项。让我们看看一个简单的例子。
- en: Listing 9.11\. Sorting an array
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. 排序数组
- en: '![](241fig01_alt.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](241fig01_alt.jpg)'
- en: 'In [listing 9.11](#ch09ex11) we have an array of `ninja` objects, where each
    ninja has a name. Our goal is to sort that array lexicographically (in alphabetical
    order), according to ninja names. For this, we naturally use the `sort` function:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.11](#ch09ex11) 中，我们有一个包含 `ninja` 对象的数组，其中每个忍者和一个名字。我们的目标是按忍者名字的字典顺序（字母顺序）对数组进行排序。为此，我们自然使用
    `sort` 函数：
- en: '[PRE80]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To the `sort` function we only need to pass a callback that’s used to compare
    two array items. Because we want to make a lexical comparison, we state that if
    `ninja1`’s name is “less” than `ninja2`’s name, the callback returns `-1` (remember,
    this means `ninja1` should come before `ninja2`, in the final sorted order); if
    it’s greater, the callback returns `1` (`ninja1` should come after `ninja2`);
    if they’re equal, the callback returns `0`. Notice that we can use simple less-than
    (`<`) and greater-than (`>`) operators to compare two ninja names.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要传递给 `sort` 函数一个用于比较两个数组项的回调函数。因为我们想进行字典比较，所以我们声明如果 `ninja1` 的名字“小于” `ninja2`
    的名字，回调返回 `-1`（记住，这意味着 `ninja1` 应该在最终排序顺序中排在 `ninja2` 之前）；如果它更大，回调返回 `1`（`ninja1`
    应该排在 `ninja2` 之后）；如果它们相等，回调返回 `0`。注意，我们可以使用简单的小于 (`<`) 和大于 (`>`) 运算符来比较两个忍者的名字。
- en: That’s about it! The rest of the nitty-gritty details of sorting are left to
    the JavaScript engine, without us having to worry about them.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！排序的其余细节留给 JavaScript 引擎处理，我们无需担心。
- en: Aggregating array items
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合数组项
- en: How many times have you written code like the following?
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次编写过如下代码？
- en: '[PRE81]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This code has to visit every item in a collection and aggregate some value,
    in essence reducing the entire array to a single value. Don’t worry—JavaScript
    has something to help with this situation, too: the `reduce` method, as shown
    in the following example.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码必须访问集合中的每个项目并聚合一些值，本质上是将整个数组缩减为一个值。别担心——JavaScript 也有助于这种情况，那就是 `reduce`
    方法，如下例所示。
- en: Listing 9.12\. Aggregating items with reduce
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. 使用 `reduce` 聚合项目
- en: '![](242fig01_alt.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![](242fig01_alt.jpg)'
- en: The `reduce` method works by taking the initial value (in this case, `0`) and
    calling the callback function on each array item with the result of the previous
    callback invocation (or the initial value) and the current array item as arguments.
    The result of the `reduce` invocation is the result of the last callback, called
    on the last array item. [Figure 9.11](#ch09fig11) sheds more light on the process.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 方法通过获取初始值（在本例中为 `0`）并在每个数组项上调用回调函数，将前一个回调调用的结果（或初始值）和当前数组项作为参数。`reduce`
    调用的结果是最后一个回调的结果，该回调在最后一个数组项上调用。[图 9.11](#ch09fig11) 更详细地说明了这个过程。'
- en: Figure 9.11\. The `reduce` function applies a callback to an aggregated value
    and each item in an array to reduce the array to a single value.
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.11。`reduce`函数将回调函数应用于聚合值和数组中的每个元素，以将数组缩减为单个值。
- en: '![](09fig11_alt.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![09fig11_alt.jpg](09fig11_alt.jpg)'
- en: We hope we’ve convinced you that JavaScript contains some useful array methods
    that can make our lives significantly easier and your code more elegant, without
    having to resort to pesky `for` loops. If you’d like to find out more about these
    and other array methods, we recommend the Mozilla Developer Network explanation
    at [http://mng.bz/cS21](http://mng.bz/cS21).
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们已经说服您，JavaScript包含一些有用的数组方法，这些方法可以使我们的生活变得更加轻松，代码更加优雅，而无需求助于讨厌的`for`循环。如果您想了解更多关于这些和其他数组方法的信息，我们建议您查看Mozilla开发者网络上的解释，网址为[http://mng.bz/cS21](http://mng.bz/cS21)。
- en: Now we’ll take things a bit further and show you how to reuse these array methods
    on your own, custom objects.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进一步深入，向您展示如何在自己的自定义对象上重用这些数组方法。
- en: 9.1.5\. Reusing built-in array functions
  id: totrans-795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5。重用内置数组函数
- en: There are times when we may want to create an object that contains a collection
    of data. If the collection was all we were worried about, we could use an array.
    But in certain cases, there may be more state to store than just the collection
    itself—perhaps we need to store some sort of metadata regarding the collected
    items.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要创建一个包含数据集合的对象。如果集合是我们唯一关心的事情，我们可以使用数组。但在某些情况下，可能需要存储比集合本身更多的状态——也许我们需要存储有关收集项的一些元数据。
- en: One option may be to create a new array every time you wish to create a new
    version of such an object, and add the metadata properties and methods to it.
    Remember, we can add properties and methods to an object as we please, including
    arrays. Generally, however, this can be slow, not to mention tedious.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种选择是每次需要创建此类对象的新版本时，就创建一个新的数组，并将元数据属性和方法添加到其中。记住，我们可以随意向对象添加属性和方法，包括数组。然而，通常情况下，这可能会很慢，而且很繁琐。
- en: Let’s examine the possibility of using a normal object and *giving* it the functionality
    we desire. Methods that know how to deal with collections already exist on the
    `Array` object; can we trick them into working on our own objects? Turns out that
    we can, as shown in the following listing.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一下使用普通对象并“赋予”它我们所需功能的可能性。`Array`对象上已经存在一些知道如何处理集合的方法；我们能否欺骗它们在我们的对象上工作？事实证明我们可以，如下面的列表所示。
- en: Listing 9.13\. Simulating array-like methods
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.13。模拟数组类似方法
- en: '![](ch09ex13-0.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex13-0.jpg](ch09ex13-0.jpg)'
- en: '![](ch09ex13-1.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex13-1.jpg](ch09ex13-1.jpg)'
- en: 'In this example, we create a “normal” object and instrument it to mimic some
    of the behaviors of an array. First we define a `length` property to record the
    number of elements that are stored, just like an array. Then we define a method
    to add an element to the end of the simulated array, calling this method `add`:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个“普通”对象，并对其进行了配置以模拟数组的一些行为。首先，我们定义一个`length`属性来记录存储的元素数量，就像数组一样。然后，我们定义一个方法来向模拟数组的末尾添加一个元素，这个方法叫做`add`：
- en: '[PRE82]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Rather than write our own code, we can use a native method of JavaScript arrays:
    `Array.prototype.push`.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不编写自己的代码，而是使用JavaScript数组的原生方法：`Array.prototype.push`。
- en: Normally, the `Array.prototype.push` method would operate on its own array via
    its function context. But here, we’re tricking the method to use *our* object
    as its context by using the `call` method (remember [chapter 4](kindle_split_015.html#ch04))
    and forcing our object to be the context of the `push` method. (Notice how we
    could’ve just as easily used the `apply` method.) The `push` method, which increments
    the `length` property (thinking that it’s the `length` property of an array),
    adds a numbered property to the object referencing the passed element. In a way,
    this behavior is almost subversive (how fitting for ninjas!), but it exemplifies
    what we can do with mutable object contexts.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Array.prototype.push`方法会通过其函数上下文操作它自己的数组。但在这里，我们通过使用`call`方法（记得[第4章](kindle_split_015.html#ch04)）并强制我们的对象成为`push`方法的上下文，来欺骗这个方法使用我们的对象作为上下文。（注意我们也可以同样容易地使用`apply`方法。）`push`方法增加`length`属性（认为它是数组的`length`属性），向对象添加一个引用传递元素的编号属性。从某种意义上说，这种行为几乎是颠覆性的（对于忍者来说多么合适！），但它展示了我们可以用可变对象上下文做什么。
- en: 'The `add` method expects an element reference to be passed for storage. Although
    sometimes we may have such a reference around, more often than not we won’t, so
    we also define a convenience method, `gather`, that looks up the element by its
    `id` value and adds it to storage:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法期望传递一个元素引用以进行存储。虽然有时我们可能周围有这样的引用，但更常见的情况是我们没有，所以我们还定义了一个便利方法`gather`，它通过其`id`值查找元素并将其添加到存储中：'
- en: '[PRE83]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, we also define a `find` method that lets us find an arbitrary item
    in our custom object, by taking advantage of the built-in array `find` method:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还定义了一个`find`方法，它允许我们通过利用内置数组`find`方法的优势，在我们的自定义对象中找到任意项：
- en: '[PRE84]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The borderline nefarious behavior we demonstrated in this section not only reveals
    the power that malleable function contexts give us, but also shows how we can
    be clever in reusing code that’s already written, instead of constantly reinventing
    the wheel.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中展示的边缘恶性行为不仅揭示了可塑函数上下文赋予我们的力量，还展示了我们如何巧妙地重用已经编写的代码，而不是不断地重新发明轮子。
- en: 'Now that we’ve spent some time with arrays, let’s move on to two new types
    of collections introduced by ES6: maps and sets.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花了一些时间在数组上，让我们继续学习ES6引入的两种新类型的集合：映射和集合。
- en: 9.2\. Maps
  id: totrans-812
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2。映射
- en: Imagine that you’re a developer at [freelanceninja.com](http://freelanceninja.com),
    a site that wants to cater to a more international audience. For each piece of
    text on the website—for example, “Ninjas for hire”—you’d like to create a mapping
    to each targeted language, such as “![](244fig01.jpg)” in Japanese, “![](244fig02.jpg)”
    in Chinese, or “![](244fig03.jpg)” in Korean (let’s hope Google Translate has
    done an adequate job). These collections, which map a key to a specific value,
    are called by different names in different programming languages, but most often
    they’re known as *dictionaries* or *maps*.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是[freelanceninja.com](http://freelanceninja.com)的开发商，这个网站希望迎合更国际化的受众。对于网站上的每一篇文本——例如，“招聘忍者”——你希望为每种目标语言创建一个映射，例如“![图片](244fig01.jpg)”（日语），“![图片](244fig02.jpg)”（中文）或“![图片](244fig03.jpg)”（韩语）（希望谷歌翻译已经做得足够好）。这些将键映射到特定值的集合，在不同的编程语言中被称为不同的名称，但最常见的是被称为*字典*或*映射*。
- en: 'But how do you efficiently manage this localization in JavaScript? One traditional
    approach is to take advantage of the fact that objects are collections of named
    properties and values, and create something like the following dictionary:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何在JavaScript中有效地管理这种本地化？一种传统的方法是利用对象是命名属性和值的集合的事实，并创建类似以下字典的东西：
- en: '![](245fig01_alt.jpg)'
  id: totrans-815
  prefs: []
  type: TYPE_IMG
  zh: '![图片](245fig01_alt.jpg)'
- en: At first glance, this may seem like a perfectly fine approach to this problem,
    and for this example, it isn’t half bad. But unfortunately, in general, you can’t
    rely on it.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是解决这个问题的完美方法，在这个例子中，它并不算太差。但不幸的是，在一般情况下，你不能依赖它。
- en: 9.2.1\. Don’t use objects as maps
  id: totrans-817
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1。不要将对象用作映射
- en: Imagine that somewhere on our site we need to access the translation for the
    word *constructor*, so we extend the dictionary example into the following code.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们网站的某个地方我们需要访问单词*constructor*的翻译，所以我们把字典示例扩展到以下代码。
- en: Listing 9.14\. Objects have access to properties that weren’t explicitly defined
  id: totrans-819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单9.14。对象可以访问未明确定义的属性
- en: '![](245fig02_alt.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![图片](245fig02_alt.jpg)'
- en: We try to access the translation for the word *constructor*—a word that we foolishly
    forgot to define in our dictionary. Normally, in such a case, we’d expect the
    dictionary to return `undefined`. But that isn’t the result, as you can see in
    [figure 9.12](#ch09fig12).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试访问单词*constructor*的翻译——一个我们愚蠢地忘记在字典中定义的单词。通常情况下，在这种情况下，我们期望字典返回`undefined`。但结果并非如此，正如你在[图9.12](#ch09fig12)中看到的那样。
- en: Figure 9.12\. Running [listing 9.14](#ch09ex14) shows that objects aren’t good
    maps, because they have access to properties that weren’t explicitly defined (through
    their prototypes).
  id: totrans-822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.12显示，运行[代码清单9.14](#ch09ex14)表明对象不是好的映射，因为它们可以访问未明确定义（通过它们的原型）的属性。
- en: '![](09fig12.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig12.jpg)'
- en: 'As you can see, by accessing the `constructor` property, we obtain the following
    string:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过访问`constructor`属性，我们获得了以下字符串：
- en: '[PRE85]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: What’s with this? As you learned in [chapter 7](kindle_split_019.html#ch07),
    all objects have prototypes; even if we define new, empty objects as our maps,
    they still have access to the properties of the prototype objects. One of those
    properties is `constructor` (recall that `constructor` is the property of the
    prototype object that points back to the constructor function), and it’s the culprit
    behind the mess we now have on our hands.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？正如你在[第7章](kindle_split_019.html#ch07)中学到的，所有对象都有原型；即使我们定义新的、空的对象作为我们的映射，它们仍然可以访问原型对象中的属性。这些属性之一是`constructor`（回想一下，`constructor`是原型对象指向构造函数的属性），它是我们现在手头混乱的罪魁祸首。
- en: In addition, with objects, keys can only be string values; if you want to create
    a mapping for any other value, that value will be silently converted into a string
    without anyone asking you anything! For example, imagine that we want to track
    some information about HTML nodes, as in the following listing.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在对象中，键只能为字符串值；如果你想要为任何其他值创建映射，该值将被静默转换为字符串，而不会有人询问你任何问题！例如，想象一下我们想要跟踪一些关于HTML节点的信息，如下所示。
- en: Listing 9.15\. Mapping values to HTML nodes with objects
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.15\. 使用对象将值映射到HTML节点
- en: '![](246fig01_alt.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![](246fig01_alt.jpg)'
- en: 'In [listing 9.15](#ch09ex15), we create two HTML elements, `firstElement` and
    `secondElement`, which we then fetch from the DOM by using the `document.getElementById`
    method. In order to create a mapping that will store additional information about
    each element, we define a plain old JavaScript object:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表9.15](#ch09ex15)中，我们创建了两个HTML元素，`firstElement`和`secondElement`，然后我们使用`document.getElementById`方法从DOM中获取它们。为了创建一个将存储每个元素额外信息的映射，我们定义了一个普通的JavaScript对象：
- en: '[PRE86]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then we use the HTML element as a key for our mapping object and associate
    some data with it:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用HTML元素作为映射对象的键，并与之关联一些数据：
- en: '[PRE87]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And we check that we can retrieve that data. Because that works as it should,
    we repeat the entire process for the second element:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查我们是否可以检索这些数据。因为这是按预期工作的，所以我们为第二个元素重复整个过程：
- en: '[PRE88]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Again, everything looks hunky dory; we’ve successfully associated some data
    with our HTML element. But a problem occurs if we decide to revisit the first
    element:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一切看起来都很正常；我们已经成功地与我们的HTML元素关联了一些数据。但如果我们决定重新访问第一个元素，就会出现问题：
- en: '[PRE89]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: It would be normal to assume that we’d again obtain the information about the
    first element, but this isn’t the case. Instead, as [figure 9.13](#ch09fig13)
    shows, the information about the second element is returned.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 本来可能会认为我们会再次获得第一个元素的信息，但事实并非如此。相反，如图[图9.13](#ch09fig13)所示，返回的是第二个元素的信息。
- en: Figure 9.13\. Running the code from [listing 9.15](#ch09ex15) shows that objects
    are converted to strings if we try to use them as object properties.
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.13\. 运行[列表9.15](#ch09ex15)中的代码显示，如果我们尝试将对象用作对象属性，对象会被转换为字符串。
- en: '![](09fig13.jpg)'
  id: totrans-840
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig13.jpg)'
- en: This happens because with objects, keys are stored as strings. This means when
    we try to use any non-string value, such as an HTML element, as a property of
    an object, that value is silently converted to a string by calling its `toString`
    method. Here, this returns the string `"[object HTMLDivElement]"`, and the information
    about the first element is stored as the value of the `[object HTMLDivElement]`
    property.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在对象中，键被存储为字符串。这意味着当我们尝试将任何非字符串值，例如一个HTML元素，作为对象的属性时，该值会通过调用其`toString`方法被静默转换为字符串。在这里，这返回字符串`"[object
    HTMLDivElement]"`，并且关于第一个元素的信息被存储为`[object HTMLDivElement]`属性的值。
- en: Next, when we try to create a mapping for the second element, a similar thing
    happens. The second element, which is also an HTML div element, is also converted
    to a string, and its additional data is also assigned to the `[object HTMLDivElement]`
    property, overriding the value we set for the first element.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们尝试为第二个元素创建映射时，发生类似的事情。第二个元素也是一个HTML div元素，它也被转换为字符串，并且它的额外数据也被分配给`[object
    HTMLDivElement]`属性，覆盖了我们为第一个元素设置的值。
- en: 'For these two reasons—properties inherited through prototypes and support for
    string-only keys—plain objects generally aren’t useful as maps. Due to this limitation,
    the ECMAScript committee has specified a completely new type: `Map`.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个原因——通过原型继承的属性和仅支持字符串键的支持——普通对象通常不适用于映射。由于这种限制，ECMAScript委员会指定了一个全新的类型：`Map`。
- en: '|  |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Maps are a part of the ES6 standard. For current browser compatibility, see:
    [http://mng.bz/JYYM](http://mng.bz/JYYM).'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: Map是ES6标准的一部分。关于当前浏览器的兼容性，请参阅：[http://mng.bz/JYYM](http://mng.bz/JYYM)。
- en: '|  |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.2.2\. Creating our first map
  id: totrans-848
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 创建我们的第一个映射
- en: 'Creating maps is easy: We use a new, built-in `Map` constructor. Look at the
    following example.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 创建映射很容易：我们使用一个新的内置`Map`构造函数。看看以下示例。
- en: Listing 9.16\. Creating our first map
  id: totrans-850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.16\. 创建我们的第一个映射
- en: '![](ch09ex16-0.jpg)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex16-0.jpg)'
- en: '![](ch09ex16-1.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex16-1.jpg)'
- en: 'In this example, we create a new map by calling the built-in `Map` constructor:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过调用内置的`Map`构造函数来创建一个新的映射：
- en: '[PRE90]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, we create three ninja objects, cleverly called `ninja1`, `ninja2`, and
    `ninja3`. We then use the built-in map `set` method:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了三个忍者对象，巧妙地命名为`ninja1`、`ninja2`和`ninja3`。然后我们使用内置的映射`set`方法：
- en: '[PRE91]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This creates a mapping between a key—in this case, the `ninja1` object—and a
    value—in this case, an object carrying the information about the ninja’s home
    island. We do this for the first two ninjas, `ninja1` and `ninja2`.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这在键（在这种情况下，是`ninja1`对象）和值（在这种情况下，是一个携带忍者家乡岛屿信息的对象）之间创建了一个映射。我们为前两个忍者`ninja1`和`ninja2`这样做。
- en: 'In the next step, we obtain the mapping for the first two ninjas by using another
    built-in map method, `get`:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们通过使用另一个内置的映射方法`get`来获取前两个忍者的映射：
- en: '[PRE92]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The mapping of course exists for the first two ninjas, but it doesn’t exist
    for the third ninja, because we haven’t used the third ninja as an argument to
    the `set` method. The current state of the map is shown in [figure 9.14](#ch09fig14).
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 课程映射对于前两个忍者是存在的，但对于第三个忍者则不存在，因为我们没有将第三个忍者作为`set`方法的参数使用。当前映射的状态显示在[图9.14](#ch09fig14)中。
- en: Figure 9.14\. A map is a collection of key-value pairs, where a key can be anything—even
    another object.
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.14\. 映射是一组键值对，其中键可以是任何东西——甚至是另一个对象。
- en: '![](09fig14.jpg)'
  id: totrans-862
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig14.jpg)'
- en: In addition to `get` and `set` methods, every map also has a built-in `size`
    property and `has` and `delete` methods. The `size` property tells us how many
    mappings we’ve created. In this case, we’ve created only two mappings.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`get`和`set`方法之外，每个映射还有一个内置的`size`属性和`has`以及`delete`方法。`size`属性告诉我们我们创建了多少映射。在这种情况下，我们只创建了两个映射。
- en: 'The `has` method, on the other hand, notifies us whether a mapping for a particular
    key already exists:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`has`方法会通知我们特定键的映射是否已经存在：
- en: '[PRE93]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `delete` method enables us to remove items from our map:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`方法使我们能够从我们的映射中删除项：'
- en: '[PRE94]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: One of the fundamental concepts when dealing with maps is determining when two
    map keys are equal. Let’s explore this concept.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 处理映射时的一个基本概念是确定两个映射键何时相等。让我们探讨这个概念。
- en: Key equality
  id: totrans-869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 键相等
- en: If you come from a bit more traditional background, such as C#, Java, or Python,
    you may be surprised by the next example.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个稍微传统一点的背景，比如C#、Java或Python，你可能对下一个例子感到惊讶。
- en: Listing 9.17\. Key equality in maps
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.17\. 映射中的键相等
- en: '![](249fig01_alt.jpg)'
  id: totrans-872
  prefs: []
  type: TYPE_IMG
  zh: '![](249fig01_alt.jpg)'
- en: In [listing 9.17](#ch09ex17), we use the built-in `location.href` property to
    obtain the URL of the current page. Next, by using the built-in URL constructor,
    we create two new URL objects that link to the current page. We then associate
    a description object with each link. Finally, we check that the correct mappings
    have been created, as shown in [figure 9.15](#ch09fig15).
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表9.17](#ch09ex17)中，我们使用内置的`location.href`属性来获取当前页面的URL。接下来，通过使用内置的URL构造函数，我们创建了两个指向当前页面的新URL对象。然后我们将描述对象与每个链接关联起来。最后，我们检查是否创建了正确的映射，如图[图9.15](#ch09fig15)所示。
- en: Figure 9.15\. If we run the code from [listing 9.17](#ch09ex17), we can see
    that key equality in maps is based on object equality.
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.15\. 如果我们运行[列表9.17](#ch09ex17)中的代码，我们可以看到映射中的键相等是基于对象相等的。
- en: '![](09fig15.jpg)'
  id: totrans-875
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig15.jpg)'
- en: 'People who have mostly worked in JavaScript may not find this result unexpected:
    We have two different objects for which we create two different mappings. But
    notice that the two URL objects, even though they’re separate objects, still point
    to the same URL location: the location of the current page. We could argue that,
    when creating mappings, these two objects should be considered equal. But in JavaScript,
    we can’t overload the equality operator, and the two objects, even though they
    have the same content, are always considered different. This isn’t the case with
    other languages, such as Java and C#, so be careful!'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主要在JavaScript中工作的人来说，这个结果可能并不意外：我们创建了两个不同的对象，并为它们创建了两个不同的映射。但请注意，尽管这两个URL对象是独立的对象，它们仍然指向相同的URL位置：当前页面的位置。我们可以争论，在创建映射时，这两个对象应该被视为相等。但在JavaScript中，我们不能重载等号运算符，并且这两个对象，尽管它们具有相同的内容，总是被视为不同的。在其他语言中，例如Java和C#，情况并非如此，所以请小心！
- en: 9.2.3\. Iterating over maps
  id: totrans-877
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 遍历映射
- en: 'So far, you’ve seen some of the advantages of maps: You can be sure they contain
    only items that you put in them, and you can use anything as a key. But there’s
    more!'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了一些映射的优势：你可以确信它们只包含你放入其中的项目，并且你可以使用任何东西作为键。但还有更多！
- en: Because maps are collections, there’s nothing stopping us from iterating over
    them with `for...of` loops. (Remember, we used the `for...of` loop to iterate
    over values created by generators in [chapter 6](kindle_split_017.html#ch06).)
    You’re also guaranteed that these values will be visited in the order in which
    they were inserted (something we can’t rely on when iterating over objects using
    the `for...in` loop). Let’s look at the following example.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 因为映射是集合，所以我们没有理由不能使用 `for...of` 循环遍历它们。（记住，我们在第 6 章中使用了 `for...of` 循环来遍历由生成器创建的值。）你还可以保证这些值将以它们被插入的顺序被访问（当我们使用
    `for...in` 循环遍历对象时，我们无法依赖这一点）。让我们看看以下示例。
- en: Listing 9.18\. Iterating over maps
  id: totrans-880
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.18\. 遍历映射
- en: '![](250fig01_alt.jpg)'
  id: totrans-881
  prefs: []
  type: TYPE_IMG
  zh: '![图片](250fig01_alt.jpg)'
- en: 'As the previous listing shows, once we’ve created a mapping, we can easily
    iterate over it using the `for...of` loop:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个列表所示，一旦我们创建了一个映射，我们就可以很容易地使用 `for...of` 循环遍历它：
- en: '[PRE95]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In each iteration, this gives a two-item array, where the first item is a key
    and the second item is the value of an item from our directory map. We can also
    use the `keys` and `values` methods to iterate over, well, keys and values contained
    in a map.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，这会给出一个包含两个项目的数组，其中第一个项目是一个键，第二个项目是我们目录映射中一个项目的值。我们还可以使用 `keys` 和 `values`
    方法来遍历映射中包含的键和值。
- en: 'Now that we’ve looked at maps, let’s visit another newcomer to JavaScript:
    *sets*, which are collections of unique items.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了映射，让我们来看看 JavaScript 的另一个新成员：*集合*，它是一组唯一的项。
- en: 9.3\. Sets
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 集合
- en: In many real-world problems, we have to deal with collections of *distinct*
    items (meaning each item can’t appear more than once) called *sets*. Up to ES6,
    this was something you had to implement yourself by mimicking sets with standard
    objects. For a crude example, see the next listing.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多现实世界的问题中，我们必须处理称为 *集合* 的唯一项的集合（意味着每个项目不能出现多次）。在 ES6 之前，你必须通过使用标准对象模拟集合来实现这一点。以下是一个粗略的示例。
- en: Listing 9.19\. Mimicking sets with objects
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19\. 使用对象模拟集合
- en: '![](ch09ex19-0.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex19-0.jpg)'
- en: '![](ch09ex19-1.jpg)'
  id: totrans-890
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex19-1.jpg)'
- en: '[Listing 9.19](#ch09ex19) shows a simple example of how sets can be mimicked
    with objects. We use a data-storage object, `data`, to keep track of our set items,
    and we expose three methods: `has`, which checks whether an item is already contained
    in the set; `add`, which adds an item only if the same item isn’t already contained
    in the set; and `remove`, which removes an already-contained item from the set.'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.19](#ch09ex19) 展示了如何使用对象模拟集合的简单示例。我们使用数据存储对象 `data` 来跟踪我们的集合项，并公开了三个方法：`has`，它检查一个项目是否已经包含在集合中；`add`，它仅在相同的项目尚未包含在集合中时添加项目；以及
    `remove`，它从集合中删除已包含的项目。'
- en: 'But this is a poor doppelganger. Because with maps, you can’t really store
    objects—only strings and numbers—and there’s always the risk of accessing prototype
    objects. For these reasons, the ECMAScript committee decided to introduce a completely
    new type of collection: *sets*.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个糟糕的复制品。因为与映射不同，你实际上不能存储对象——只有字符串和数字，并且始终存在访问原型对象的危险。出于这些原因，ECMAScript 委员会决定引入一种全新的集合类型：*集合*。
- en: '|  |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-894
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Sets are a part of the ES6 standard. For current browser compatibility, see
    [http://mng.bz/QRTS](http://mng.bz/QRTS).
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是 ES6 标准的一部分。关于当前浏览器的兼容性，请参阅 [http://mng.bz/QRTS](http://mng.bz/QRTS)。
- en: '|  |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3.1\. Creating our first set
  id: totrans-897
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 创建我们的第一个集合
- en: The cornerstone of creating sets is the newly introduced constructor function,
    conveniently named `Set`. Let’s look at an example.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合的基石是新引入的构造函数，方便地命名为 `Set`。让我们看看一个示例。
- en: Listing 9.20\. Creating a set
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.20\. 创建一个集合
- en: '![](252fig01_alt.jpg)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
  zh: '![图片](252fig01_alt.jpg)'
- en: 'Here we use the built-in `Set` constructor to create a new `ninjas` set that
    will contain distinct ninjas. If we don’t pass in any arguments, an empty set
    is created. We can also pass in an array, such as this, which pre-fills the set:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内置的 `Set` 构造函数创建一个新的 `ninjas` 集合，它将包含不同的忍者。如果我们不传递任何参数，将创建一个空集合。我们也可以传递一个数组，例如这个，它预先填充集合：
- en: '[PRE96]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As we already mentioned, sets are collections of unique items, and their primary
    purpose is to stop us from storing multiple occurrences of the same object. In
    this case, this means `"Hattori"`, which we tried to add twice, is added only
    once.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，集合是唯一项目的集合，它们的主要目的是阻止我们存储相同对象的多个实例。在这种情况下，这意味着 `"Hattori"`，我们试图添加两次，只添加了一次。
- en: 'A number of methods are accessible from every set. For example, the `has` method
    checks whether an item is contained in the set:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都可以访问多个方法。例如，`has` 方法检查一个项目是否包含在集合中：
- en: '[PRE97]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'and the `add` method is used to add unique items to the set:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `add` 方法用于向集合中添加唯一的元素：
- en: '[PRE98]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If you’re curious about how many items are in a set, you can always use the
    `size` property.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇一个集合中有多少个元素，你总是可以使用 `size` 属性。
- en: Similar to maps and arrays, sets are collections, so we can iterate over them
    with a `for...of` loop. As you can see in [figure 9.16](#ch09fig16), the items
    are always iterated over in the order in which they were inserted.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 与映射和数组类似，集合是集合，因此我们可以使用 `for...of` 循环遍历它们。正如你在[图 9.16](#ch09fig16) 中可以看到的，元素总是按照它们被插入的顺序遍历。
- en: Figure 9.16\. Running the code from [listing 9.20](#ch09ex20) shows that the
    items in a set are iterated over in the order in which they were inserted.
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.16. 运行[列表 9.20](#ch09ex20) 中的代码显示，集合中的元素是按照它们被插入的顺序遍历的。
- en: '![](09fig16.jpg)'
  id: totrans-911
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig16.jpg)'
- en: 'Now that we’ve gone through the basics of sets, let’s visit some common operations
    on sets: unions, intersections, and differences.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了集合的基础知识，让我们来看看集合的一些常见操作：并集、交集和差集。
- en: 9.3.2\. Union of sets
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2. 集合的并集
- en: A union of two sets, `A` and `B,` creates a new set that contains all elements
    from both `A` and `B`. Naturally, each item can’t occur more than once in the
    new set.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合 `A` 和 `B` 的并集创建了一个新的集合，该集合包含 `A` 和 `B` 中的所有元素。自然地，每个元素在新集合中不会出现超过一次。
- en: Listing 9.21\. Using sets to perform a union of collections
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.21. 使用集合执行集合的并集操作
- en: '![](254fig01_alt.jpg)'
  id: totrans-916
  prefs: []
  type: TYPE_IMG
  zh: '![](254fig01_alt.jpg)'
- en: 'We first create an array of `ninjas` and an array of `samurai`. Notice that
    Hattori is leading a busy life: samurai by day, ninja by night. Now imagine that
    we need to create a collection of people whom we can call to arms if a neighboring
    daimyo decides that his province is a bit cramped. We create a new set, `warriors`,
    that includes all ninjas and all samurai. Hattori is in both collections, but
    we want to include him only once—it’s not like two Hattoris will respond to our
    call.'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `ninjas` 数组和一个 `samurai` 数组。注意，服部的生活很忙碌：白天是武士，晚上是忍者。现在想象一下，如果我们需要创建一个集合，我们可以召集这些人，如果邻近的大名决定他的领地有点拥挤。我们创建一个新的集合
    `warriors`，包括所有忍者和所有武士。服部在两个集合中，但我们只想包含他一次——不像有两个服部会回应我们的召唤。
- en: 'In this case, a set is perfect! We don’t need to manually keep track of whether
    an item has been already included: The set takes care of that by itself, automatically.
    When creating this new set, we use the spread operator `[...ninjas, ...samurai]`
    (remember [chapter 3](kindle_split_014.html#ch03)) to create a new array that
    contains all ninjas and all samurai. In case you’re wondering, Hattori is present
    twice in this new array. But when we finally pass that array to the `Set` constructor,
    Hattori is included only once, as shown in [figure 9.17](#ch09fig17).'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，集合是完美的！我们不需要手动跟踪一个项目是否已经被包含：集合会自动处理这一点。在创建这个新集合时，我们使用扩展运算符 `[...ninjas,
    ...samurai]`（记住[第 3 章](kindle_split_014.html#ch03)）来创建一个新的数组，该数组包含所有忍者和所有武士。如果你想知道，服部在这个新数组中出现了两次。但当我们最终将这个数组传递给
    `Set` 构造函数时，服部只被包含一次，如图 9.17 所示。
- en: Figure 9.17\. A union of two sets keeps the items from both collections (without
    duplicates).
  id: totrans-919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.17. 两个集合的并集保留了两个集合中的元素（没有重复）。
- en: '![](09fig12a_alt.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig12a_alt.jpg)'
- en: 9.3.3\. Intersection of sets
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3. 集合的交集
- en: The *intersection* of two sets, `A` and `B`, creates a set that contains elements
    of `A` that are also in `B`. For example, we can find ninjas that are also samurai,
    as shown next.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合 `A` 和 `B` 的*交集*创建了一个包含 `A` 中也在 `B` 中的元素的集合。例如，我们可以找到既是忍者又是武士的人，如下所示。
- en: Listing 9.22\. Intersection of sets
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.22. 集合的交集
- en: '![](255fig01_alt.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![](255fig01_alt.jpg)'
- en: 'The idea behind [listing 9.22](#ch09ex22) is to create a new set that contains
    only ninjas who are also samurai. We do this by taking advantage of the array’s
    `filter` method, which, as you’ll remember, creates a new array that contains
    only the items that match a certain criterion. In this case, the criterion is
    that the ninja is also a samurai (is contained in the set of samurai). Because
    the `filter` method can only be used on arrays, we have to turn the `ninjas` set
    into an array by using the spread operator:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9.22](#ch09ex22) 的想法是创建一个只包含也是武士的忍者的新集合。我们通过利用数组的 `filter` 方法来实现这一点，正如你可能记得的，`filter`
    方法创建一个只包含符合特定标准的项目的新数组。在这种情况下，标准是忍者也是武士（包含在武士集合中）。因为 `filter` 方法只能用于数组，我们必须通过使用扩展运算符将
    `ninjas` 集合转换为数组：'
- en: '[PRE99]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Finally, we check that we’ve found only one ninja who’s also a samurai: the
    Jack of all trades, Hattori.'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查是否只找到了一个既是忍者又是武士的忍者：万事通，服部。
- en: 9.3.4\. Difference of sets
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4. 集合的差集
- en: The difference of two sets, `A` and `B`, contains all elements that are in set
    `A` but are *not* in set `B`. As you might guess, this is similar to the intersection
    of sets, with one small but significant difference. In the next listing, we want
    to find only true ninjas (not those who also moonlight as samurai).
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合 `A` 和 `B` 的差集包含所有在集合 `A` 中但不在集合 `B` 中的元素。正如你可能猜到的，这与集合的交集类似，但有一个微小但重要的区别。在下一个列表中，我们只想找到真正的忍者（不是那些也兼职做武士的人）。
- en: Listing 9.23\. Difference of sets
  id: totrans-930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.23. 集合的差集
- en: '![](255fig02_alt.jpg)'
  id: totrans-931
  prefs: []
  type: TYPE_IMG
  zh: '![图片 255fig02_alt.jpg](255fig02_alt.jpg)'
- en: The only change is to specify that we care only about the ninjas who are *not*
    also samurai, by putting an exclamation mark (`!`) before the `samurai.has(ninja)`
    expression.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是，我们只关心那些不是武士的忍者，通过在 `samurai.has(ninja)` 表达式前放置一个感叹号（`!`）来实现。
- en: 9.4\. Summary
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 概述
- en: Arrays are a special type of object with a `length` property and `Array.prototype`
    as their prototype.
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是一种特殊的对象，具有 `length` 属性，其原型为 `Array.prototype`。
- en: We can create new arrays using the array literal notation (`[])` or by calling
    the built-in `Array` constructor.
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用数组字面量表示法（`[]`）或通过调用内置的 `Array` 构造函数来创建新数组。
- en: 'We can modify the contents of an array using several methods accessible from
    array objects:'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用从数组对象可访问的几种方法来修改数组的内 容：
- en: The built-in `push` and `pop` methods add items to and remove items from the
    end of the array.
  id: totrans-937
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 `push` 和 `pop` 方法可以在数组的末尾添加和移除项目。
- en: The built-in `shift` and `unshift` methods add items to and remove items from
    the beginning of the array.
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 `shift` 和 `unshift` 方法可以在数组的开始处添加和移除项目。
- en: The built-in `splice` method can be used to remove items from and add items
    to arbitrary array positions.
  id: totrans-939
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 `splice` 方法可以用来从任意数组位置移除项目并添加项目。
- en: 'All arrays have access to a number of useful methods:'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有数组都可以访问许多有用的方法：
- en: The `map` method creates a new array with the results of calling a callback
    on every element.
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 方法通过在每一个元素上调用回调函数来创建一个包含结果的新数组。'
- en: The `every` and `some` methods determine whether all or some array items satisfy
    a certain criterion.
  id: totrans-942
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`every` 和 `some` 方法确定所有或某些数组项目是否满足某个特定标准。'
- en: The `find` and `filter` methods find array items that satisfy a certain condition.
  id: totrans-943
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find` 和 `filter` 方法可以找到满足特定条件的数组项目。'
- en: The `sort` method sorts an array.
  id: totrans-944
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 方法可以对数组进行排序。'
- en: The `reduce` method aggregates all items in an array into a single value.
  id: totrans-945
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce` 方法将数组中的所有项目聚合到一个单一值。'
- en: You can reuse the built-in array methods when implementing your own objects
    by explicitly setting the method call context with the `call` or `apply` method.
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过显式设置 `call` 或 `apply` 方法的方法调用上下文来实现自己的对象时，你可以重用内置的数组方法。
- en: Maps and dictionaries are objects that contain mappings between a key and a
    value.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射和字典是包含键和值之间映射的对象。
- en: Objects in JavaScript are lousy maps because you can only use string values
    as keys and because there’s always the risk of accessing prototype properties.
    Instead, use the new built-in `Map` collection.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中的对象作为映射很糟糕，因为你只能使用字符串值作为键，并且始终存在访问原型属性的风险。相反，使用新的内置 `Map` 集合。
- en: Maps are collections and can be iterated over using the `for...of` loop.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射是集合，可以使用 `for...of` 循环迭代。
- en: Sets are collections of unique items.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合是一系列独特的项目。
- en: 9.5\. Exercises
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 练习
- en: '**1**'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be the content of the `samurai` array, after running the following
    code?
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码后，`samurai` 数组的内容将是什么？
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '**2**'
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be the content of the `ninjas` array, after running the following
    code?
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，`ninjas`数组的内容将会是什么？
- en: ''
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '**3**'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be the content of the `samurai` array, after running the following
    code?
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，`samurai`数组的内容将会是什么？
- en: ''
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**4**'
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be stored in variables `first`, `second`, and `third`, after running
    the following code?
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，变量`first`、`second`和`third`将会存储什么？
- en: ''
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '**5**'
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be stored in variables `first` and `second`, after running the following
    code?
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，变量`first`和`second`将会存储什么？
- en: ''
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '**6**'
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**'
- en: ''
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following assertions will pass?
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个断言将会通过？
- en: ''
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**7**'
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**'
- en: ''
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following assertions will pass?
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个断言将会通过？
- en: ''
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Chapter 10\. Wrangling regular expressions
  id: totrans-987
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 处理正则表达式
- en: '*This chapter covers*'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: A refresher on regular expressions
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式复习
- en: Compiling regular expressions
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译正则表达式
- en: Capturing with regular expressions
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式捕获
- en: Working with frequently encountered idioms
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理常见习语
- en: Regular expressions are a necessity of modern development. There, we said it.
    Although many a web developer could go through life happily ignoring regular expressions,
    some problems that need to be solved in JavaScript code can’t be addressed elegantly
    without regular expressions.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是现代开发的必需品。我们就是这样说的。尽管许多网页开发者可能一生中都可以快乐地忽略正则表达式，但在JavaScript代码中需要解决的问题中，没有正则表达式就无法优雅地解决。
- en: Sure, there may be other ways to solve the same problems. But frequently, something
    that might take a half-screen of code can be distilled down to a single statement
    with the proper use of regular expressions. All JavaScript ninjas need regular
    expressions as an essential part of their toolkits.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能还有其他解决同样问题的方法。但通常，使用适当的正则表达式，可能需要半屏代码的任务可以简化为一个语句。所有JavaScript忍者都需要正则表达式作为他们工具箱的一个基本部分。
- en: 'Regular expressions trivialize the process of tearing apart strings and looking
    for information. Everywhere you look in mainstream JavaScript libraries, you’ll
    see the prevalent use of regular expressions for various spot tasks:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式简化了拆分字符串并查找信息的过程。在主流JavaScript库的任何地方，你都会看到正则表达式被广泛用于各种定位任务：
- en: Manipulating strings of HTML nodes
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作HTML节点字符串
- en: Locating partial selectors within a CSS selector expression
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CSS选择器表达式中定位部分选择器
- en: Determining whether an element has a specific class name
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定元素是否具有特定的类名
- en: Input validation
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: And more
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多
- en: Let’s start by looking at an example.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个例子开始。
- en: '|  |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1003
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Becoming fluent in regular expressions requires a lot of practice. You might
    find a site such as JS Bin ([http://jsbin.com](http://jsbin.com)) handy for playing
    around with examples. A couple of sites are dedicated to regular expression testing,
    such as the Regular Expression Test Page for JavaScript ([www.regexplanet.com/advanced/javascript/index.html](http://www.regexplanet.com/advanced/javascript/index.html))
    and regex101 ([www.regex101.com/#javascript](http://www.regex101.com/#javascript)).
    regex101 is an especially useful site for beginners, because it also automatically
    generates explanations for the targeted regular expression.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 要熟练掌握正则表达式需要大量的练习。你可能会发现像JS Bin([http://jsbin.com](http://jsbin.com))这样的网站在尝试示例时很有用。有几个网站专门用于正则表达式测试，例如JavaScript的正则表达式测试页面([www.regexplanet.com/advanced/javascript/index.html](http://www.regexplanet.com/advanced/javascript/index.html))和regex101([www.regex101.com/#javascript](http://www.regex101.com/#javascript))。regex101对于初学者来说尤其有用，因为它还会自动生成目标正则表达式的解释。
- en: '|  |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Do you know?
  id: totrans-1006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When would you prefer to use a RegExp literal over a RegExp object?
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在什么情况下你更愿意使用正则表达式字面量而不是正则表达式对象？
- en: '**Q2:**'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is sticky matching, and how do you enable it?
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是粘性匹配，如何启用它？
- en: '**Q3:**'
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does matching differ when using a global versus a non-global regular expression?
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用全局正则表达式与非全局正则表达式匹配时，匹配有何不同？
- en: 10.1\. Why regular expressions rock
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 为什么正则表达式很棒
- en: 'Let’s say we want to validate that a string, perhaps entered into a form by
    a website user, follows the format for a nine-digit U.S. postal code. We all know
    that the U.S. Postal Service has little sense of humor and insists that a postal
    code (also known as a ZIP code) follows this specific format:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要验证一个字符串，可能是网站用户输入到表单中的字符串，是否符合九位美国邮政编码的格式。我们都知道美国邮政服务几乎没有幽默感，并坚持认为邮政编码（也称为ZIP代码）必须遵循以下特定格式：
- en: '[PRE107]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Each `9` represents a decimal digit, and the format is 5 decimal digits, followed
    by a hyphen, followed by 4 decimal digits. If you use any other format, your package
    or letter gets diverted into the black hole of the hand-sorting department, and
    good luck predicting how long it will take to emerge again.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`9`代表一个十进制数字，格式是5个十进制数字，后面跟着一个连字符，然后是4个十进制数字。如果你使用任何其他格式，你的包裹或信件就会被送入手工分拣部门的黑洞，好运预测它再次出现需要多长时间。
- en: Let’s create a function that, given a string, verifies that the U.S. Postal
    Service will stay happy. We could resort to performing a comparison on each character,
    but we’re a ninja and that’s too inelegant a solution, resulting in a lot of needless
    repetition. Rather, consider the following solution.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，给定一个字符串，验证美国邮政服务是否会保持满意。我们可以通过逐个字符进行比较，但我们是忍者，这种解决方案太不优雅了，会导致很多不必要的重复。相反，考虑以下解决方案。
- en: Listing 10.1\. Testing for a specific pattern in a string
  id: totrans-1021
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. 在字符串中测试特定模式
- en: '![](260fig01_alt.jpg)'
  id: totrans-1022
  prefs: []
  type: TYPE_IMG
  zh: '![图片](260fig01_alt.jpg)'
- en: This code takes advantage of the fact that we have only two checks to make,
    depending on the position of the character within the string. We still need to
    perform up to nine comparisons at runtime, but we have to write each comparison
    only once.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码利用了这样一个事实，即我们只需要进行两次检查，这取决于字符在字符串中的位置。我们仍然需要在运行时进行多达九次比较，但我们必须只写一次每个比较。
- en: 'Even so, would anyone consider this solution *elegant*? It’s more elegant than
    the brute-force, noniterative approach, but it still seems like an awful lot of
    code for such a simple check. Now consider this approach:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，有人会认为这个解决方案是*优雅的*吗？它比蛮力、非迭代方法更优雅，但它仍然看起来为这样一个简单的检查编写了太多的代码。现在考虑这个方法：
- en: '[PRE108]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Except for some esoteric syntax in the body of the function, that’s a lot more
    succinct and elegant, no? That’s the power of regular expressions, and it’s just
    the tip of the iceberg. Don’t worry if that syntax looks like someone’s pet iguana
    walked across the keyboard; we’re about to recap regular expressions before you
    learn how to use them in ninja-like fashion on your pages.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数体中的一些晦涩语法之外，这要简洁和优雅得多，不是吗？这就是正则表达式的力量，这只是冰山一角。如果那种语法看起来像是某个人的宠物鬣蜥在键盘上走过，请不要担心；在我们教你如何以忍者般的方式在你的页面上使用正则表达式之前，我们将回顾正则表达式。
- en: 10.2\. A regular expression refresher
  id: totrans-1027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 正则表达式复习
- en: Much as we’d like to, we can’t offer you an exhaustive tutorial on regular expressions
    in the space we have. After all, entire books have been dedicated to regular expressions.
    But we’ll do our best to hit all the important points.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们很想在这里提供一个关于正则表达式的详尽教程，但我们不能。毕竟，已经有整本书是关于正则表达式的。但我们将尽力涵盖所有重要点。
- en: For more detail than we can offer in this chapter, the books *Mastering Regular
    Expressions* by Jeffrey E. F. Friedl, *Introducing Regular Expressions* by Michael
    Fitzgerald, and *Regular Expressions Cookbook* by Jan Goyvaerts and Steven Levithan,
    all from O’Reilly, are popular choices.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中我们无法提供的更多细节，杰弗里·E·F·弗里德尔的《精通正则表达式》、迈克尔·菲茨杰拉德的《介绍正则表达式》以及简·戈伊瓦雷茨和史蒂文·莱维森的《正则表达式食谱》（所有来自O'Reilly出版社）都是流行的选择。
- en: Let’s dig in.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨。
- en: 10.2.1\. Regular expressions explained
  id: totrans-1031
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 正则表达式解释
- en: The term *regular expression* stems from mid-century mathematics, when a mathematician
    named Stephen Kleene described models of computational automata as “regular sets.”
    But that won’t help us understand anything about regular expressions, so let’s
    simplify things and say that a regular expression is a way to express a *pattern*
    for matching strings of text. The expression itself consists of terms and operators
    that allow us to define these patterns. We’ll see what those terms and operators
    consist of shortly.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*正则表达式*起源于中世纪的数学，当时一位名叫斯蒂芬·克莱尼的数学家将计算自动机的模型描述为“正则集”。但这不会帮助我们理解正则表达式，所以让我们简化一下，说正则表达式是表达文本字符串匹配模式的一种方式。表达式本身由术语和运算符组成，允许我们定义这些模式。我们很快就会看到这些术语和运算符由什么组成。
- en: 'In JavaScript, as with most other object types, we have two ways to create
    a regular expression:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，就像大多数其他对象类型一样，我们有两种方式来创建正则表达式：
- en: Via a regular expression literal
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过正则表达式字面量
- en: By constructing an instance of a `RegExp` object
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构造一个`RegExp`对象的实例
- en: 'For example, if we want to create a mundane regular expression (or *regex*,
    for short) that matches the string `test` exactly, we could do so with a regex
    literal:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个普通的正则表达式（或简称为 *regex*），以精确匹配字符串 `test`，我们可以使用正则表达式字面量来完成：
- en: '[PRE109]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: That might look strange, but regex literals are delimited with forward slashes
    in the same way that string literals are delimited with quote characters.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些奇怪，但正则表达式字面量与字符串字面量一样，都是用正斜杠分隔的。
- en: 'Alternatively, we could construct a `RegExp` instance, passing the regex as
    a string:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以构造一个 `RegExp` 实例，传递正则表达式作为字符串：
- en: '[PRE110]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Both formats result in the same regex being created in the variable `pattern`.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种格式都会在变量 `pattern` 中创建相同的正则表达式。
- en: '|  |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The literal syntax is preferred when the regex is known at development time,
    and the constructor approach is used when the regex is constructed at runtime
    by building it up dynamically in a string.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式在开发时已知时，首选字面量语法，而当正则表达式在运行时通过动态构建字符串来构建时，则使用构造函数方法。
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One of the reasons that the literal syntax is preferred over expressing regexes
    in a string is that (as you’ll soon see) the backslash character plays an important
    part in regular expressions. But the backslash character is *also* the escape
    character for string literals, so to express a backslash within a string literal,
    we need to use a double backslash (`\\`). This can make regular expressions, which
    already possess a cryptic syntax, even more odd-looking when expressed within
    strings.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以首选字面量语法而不是在字符串中表达正则表达式，其中一个原因是（您很快就会看到）反斜杠字符在正则表达式中起着重要作用。但反斜杠字符也是字符串字面量的转义字符，因此要在字符串字面量中表达反斜杠，我们需要使用双反斜杠（`\\`）。这可能会使正则表达式，其本身就已经具有神秘的语法，在字符串中表达时看起来更加奇特。
- en: 'In addition to the expression itself, five flags can be associated with a regex:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表达式本身之外，还可以将五个标志与正则表达式相关联：
- en: '`i`—Makes the regex case-insensitive, so `/test/i` matches not only *test*,
    but also *Test*, *TEST*, *tEsT*, and so on.'
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`—使正则表达式不区分大小写，因此 `/test/i` 不仅匹配 *test*，还匹配 *Test*、*TEST*、*tEsT* 等等。'
- en: '`g`—Matches all instances of the pattern, as opposed to the default of *local*,
    which matches only the first occurrence. More on this later.'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`—匹配所有模式的实例，而不是默认的 *局部* 匹配，后者只匹配第一个出现。关于这一点稍后会有更多介绍。'
- en: '`m`—Allows matches across multiple lines, as might be obtained from the value
    of a `textarea` element.'
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`—允许跨多行匹配，就像从 `textarea` 元素的值中获取的那样。'
- en: '`y`—Enables sticky matching. A regular expression performs sticky matching
    in the target string by attempting to match from the last match position.'
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`—启用粘性匹配。正则表达式通过尝试从最后一个匹配位置开始匹配，在目标字符串中执行粘性匹配。'
- en: '`u`—Enables the use of Unicode point escapes (`\u{...}`).'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`—启用使用 Unicode 点转义（`\u{...}`）。'
- en: These flags are appended to the end of the literal (for example, `/test/ig`)
    or passed in a string as the second parameter to the `RegExp` constructor (`new
    RegExp("test", "ig")`).
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志附加到字面量的末尾（例如，`/test/ig`）或作为 `RegExp` 构造函数的第二个参数传递（`new RegExp("test", "ig")`）。
- en: Matching the exact string *test* (even in a case-insensitive manner) isn’t interesting—after
    all, we can do that particular check with a simple string comparison. So let’s
    take a look at the terms and operators that give regular expressions their immense
    power to match more compelling patterns.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 精确匹配字符串 *test*（即使在不区分大小写的情况下）并不有趣——毕竟，我们可以用简单的字符串比较来完成这个特定的检查。所以，让我们来看看那些赋予正则表达式强大匹配能力的关键词和运算符。
- en: 10.2.2\. Terms and operators
  id: totrans-1055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 术语和运算符
- en: Regular expressions, like most other expressions we’re familiar with, are made
    up of terms and operators that qualify those terms. In the sections that follow,
    you’ll see how these terms and operators can be used to express patterns.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，就像我们熟悉的许多其他表达式一样，由术语和运算符组成，这些术语和运算符对术语进行限定。在接下来的章节中，您将看到这些术语和运算符如何用来表达模式。
- en: Exact matching
  id: totrans-1057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 精确匹配
- en: Any character that’s not a special character or operator (which we’ll introduce
    as we go along) must appear literally in the expression. For example, in our `/test/`
    regex, four terms represent characters that must appear literally in a string
    for it to match the expressed pattern.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是特殊字符或运算符（我们将随着介绍而介绍）的字符都必须在表达式中以字面形式出现。例如，在我们的 `/test/` 正则表达式中，四个术语代表在字符串中必须以字面形式出现的字符，以便匹配所表达的图案。
- en: Placing such characters one after the other implicitly denotes an operation
    that means *followed by*. So `/test/` means *t* followed by *e* followed by *s*
    followed by *t*.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类字符依次放置，隐含地表示一个操作，意味着 *跟随*。所以 `/test/` 表示 *t* 跟随 *e* 跟随 *s* 跟随 *t*。
- en: Matching from a class of characters
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从字符类中匹配
- en: 'Many times, we won’t want to match a specific literal character, but a character
    from a finite set of characters. We can specify this with the set operator (also
    called the *character class* operator) by placing the set of characters that we
    want to match in square brackets: `[abc]`.'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，我们可能不想匹配特定的字面字符，而是想匹配有限字符集中的字符。我们可以通过将我们想要匹配的字符集放在方括号中来指定这一点：`[abc]`。
- en: The preceding example signifies that we want to match any of the characters
    `a`, `b`, or `c`. Note that even though this expression spans five characters
    (three letters and two brackets), it matches only a single character in the candidate
    string.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例表示我们想匹配字符 `a`、`b` 或 `c` 中的任意一个。请注意，尽管这个表达式跨越了五个字符（三个字母和两个括号），但它只匹配候选字符串中的单个字符。
- en: 'Other times, we want to match anything *but* a finite set of characters. We
    can specify this by placing a caret character (`^`) right after the opening bracket
    of the set operator:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 其他时候，我们可能想匹配除了有限字符集之外的任何字符。我们可以通过在集合操作符的开括号后放置一个 caret 字符（`^`）来指定这一点：
- en: '[PRE111]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This changes the meaning to any character *but* `a`, `b`, or `c`.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变意义，变为除了 `a`、`b` 或 `c` 之外的任意字符。
- en: 'There’s one more invaluable variation to the set operation: the ability to
    specify a range of values. For example, if we want to match any one of the lowercase
    characters between *a* and *m*, we could write `[abcdefghijklm]`. But we can express
    that much more succinctly as follows:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作中还有一个非常有价值的变体：指定值范围的能力。例如，如果我们想匹配介于 *a* 和 *m* 之间的任意一个小写字母，我们可以写成 `[abcdefghijklm]`。但我们可以更简洁地表达如下：
- en: '[PRE112]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The dash indicates that all characters from `a` through `m` inclusive (and lexicographically)
    are included in the set.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 破折号表示从 `a` 到 `m`（包括）的所有字符（按字典顺序）都包含在集合中。
- en: Escaping
  id: totrans-1069
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转义
- en: Not all characters represent their literal equivalent. Certainly all of the
    alphabetic and decimal digit characters represent themselves, but as you’ll see,
    special characters such as `$` and the period (.) represent either matches to
    something other than themselves, or operators that qualify the preceding term.
    In fact, you’ve already seen how the `[`, `]`, -, and `^` characters are used
    to represent something other than their literal selves.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有字符都代表它们的字面等价物。当然，所有的字母和十进制数字字符都代表自己，但正如你将看到的，特殊字符如 `$` 和点（.）代表的是除了它们自身之外的其他匹配项，或者是对前面项进行限定运算符。事实上，你已经在
    `[`、`]`、`-` 和 `^` 字符如何用来表示除了它们字面意义之外的内容中看到了。
- en: How do we specify that we want to match a literal `[` or `$` or `^` or other
    special character? Within a regex, the backslash character escapes whatever character
    follows it, making it a literal match term. So `\[` specifies a literal match
    to the `[` character, rather than the opening of a character class expression.
    A double backslash (`\\`) matches a single backslash.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何指定我们想要匹配字面 `[`、`$`、`^` 或其他特殊字符？在正则表达式中，反斜杠字符会转义其后的任何字符，使其成为一个字面匹配项。所以 `\[`
    指定对 `[` 字符的字面匹配，而不是字符类表达式的开始。双反斜杠（`\\`）匹配单个反斜杠。
- en: Begins and ends
  id: totrans-1072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 开始和结束
- en: Frequently, we may want to ensure that a pattern matches at the beginning of
    a string, or perhaps at the end of a string. The caret character, when used as
    the first character of the regex, anchors the match at the beginning of the string,
    such that `/^test/` matches only if the substring `test` appears at the beginning
    of the string being matched. (Note that this is an overload of the `^` character,
    because it’s also used to negate a character class set.)
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，我们可能想确保一个模式与字符串的开头匹配，或者可能在字符串的末尾匹配。当正则表达式的第一个字符是 caret 字符时，它将匹配锚定在字符串的开头，例如
    `/^test/` 只在匹配的子字符串 `test` 出现在被匹配的字符串开头时才匹配。（注意，这是 `^` 字符的重载，因为它也用于否定字符类集。）
- en: 'Similarly, the dollar sign (`$`) signifies that the pattern must appear at
    the end of the string:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，美元符号（`$`）表示模式必须出现在字符串的末尾：
- en: '[PRE113]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Using both `^` and `$` indicates that the specified pattern must encompass
    the entire candidate string:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `^` 和 `$` 两个符号表示指定的模式必须涵盖整个候选字符串：
- en: '[PRE114]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Repeated occurrences
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重复出现
- en: 'If we want to match a series of four `a` characters, we might express that
    with `/aaaa/`, but what if we want to match *any* number of the same character?
    Regular expressions enable us to specify several repetition options:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要匹配一系列四个 `a` 字符，我们可以用 `/aaaa/` 来表达，但如果我们想匹配任何数量的相同字符呢？正则表达式使我们能够指定几个重复选项：
- en: To specify that a character is optional (it can appear either once or not at
    all), follow it with `?`. For example, /`t?est/` matches both *test* and *est*.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定一个字符是可选的（它可以出现一次或不出现），在其后跟 `?`。例如，`/t?est/` 匹配 `test` 和 `est`。
- en: To specify that a character should appear one or many times, use `+`, as in
    `/t+est/`, which matches *test*, *ttest*, and *tttest*, but not *est*.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定一个字符出现一次或多次，使用 `+`，例如 `/t+est/`，它可以匹配 `test`、`ttest` 和 `tttest`，但不能匹配 `est`。
- en: To specify that the character appears *zero, one,* or *many* times, use `*`,
    as in `/t*est/`, which matches *test*, *ttest*, *tttest*, *and est*.
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定字符出现 *零、一次* 或 *多次*，使用 `*`，例如 `/t*est/`，它可以匹配 `test`、`ttest`、`tttest` 和 `est`。
- en: To specify a fixed number of repetitions, indicate the number of allowed repetitions
    between braces. For example, `/a{4}/` indicates a match on four consecutive `a`
    characters.
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定固定数量的重复，在花括号中指定允许重复的次数。例如，`/a{4}/` 表示匹配四个连续的 `a` 字符。
- en: To specify a range for the repetition count, indicate the range with a comma
    separator. For example, `/a{4,10}/` matches any string of 4 through 10 consecutive
    `a` characters.
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定重复计数的范围，用逗号分隔符表示范围。例如，`/a{4,10}/` 匹配任何由 4 到 10 个连续 `a` 字符组成的字符串。
- en: To specify an open-ended range, omit the second value in the range (but leave
    the comma). The regex `/a{4,}/` matches any string of four or more consecutive
    `a` characters.
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定一个开放的范围，省略范围中的第二个值（但保留逗号）。正则表达式 `/a{4,}/` 匹配任何由四个或更多连续 `a` 字符组成的字符串。
- en: 'Any of these repetition operators can be *greedy* or *nongreedy*. By default,
    they’re greedy: They will consume all the possible characters that make up a match.
    Annotating the operator with a `?` character (an overload of the `?` operator),
    as in `a+?`, makes the operation nongreedy: It will consume *only* enough characters
    to make a match.'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重复运算符可以是 *贪婪的* 或 *非贪婪的*。默认情况下，它们是贪婪的：它们将消耗构成匹配的所有可能的字符。通过在运算符上使用 `?` 字符（`?`
    运算符的重载），例如 `a+?`，可以使操作非贪婪的：它将只消耗 *足够* 的字符以进行匹配。
- en: For example, if we’re matching against the string `aaa`, the regular expression
    `/a+/` would match all three `a` characters, whereas the nongreedy expression
    `/a+?/` would match only one `a` character, because a single `a` character is
    all that’s needed to satisfy the `a+` term.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在匹配字符串 `aaa`，正则表达式 `/a+/` 会匹配所有三个 `a` 字符，而非贪婪表达式 `/a+?/` 只会匹配一个 `a`
    字符，因为单个 `a` 字符就足以满足 `a+` 项。
- en: Predefined character classes
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预定义字符类
- en: Some characters that we might want to match are impossible to specify with literal
    characters (for example, control characters such as a carriage return). In addition,
    often we might want to match character classes, such as a set of decimal digits,
    or a set of whitespace characters. The regular expression syntax provides predefined
    terms that represent these characters or commonly used classes so that we can
    use control-character matching in our regular expressions and don’t need to resort
    to the character class operator for commonly used sets of characters.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要匹配的一些字符无法用字面字符指定（例如，回车等控制字符）。此外，我们可能经常想要匹配字符类，例如一组十进制数字或一组空白字符。正则表达式语法提供了预定义的术语来表示这些字符或常用类，这样我们就可以在我们的正则表达式中使用控制字符匹配，而无需求助于字符类运算符来处理常用字符集。
- en: '[Table 10.1](#ch10table01) lists these terms and the character or set they
    represent. These predefined sets help keep our regular expressions from looking
    excessively cryptic.'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10.1](#ch10table01) 列出了这些术语以及它们所代表的字符或集合。这些预定义集合有助于使我们的正则表达式看起来不那么晦涩。'
- en: Table 10.1\. Predefined character classes and character terms
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.1\. 预定义字符类和字符项
- en: '| Predefined term | Matches |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
  zh: '| 预定义术语 | 匹配 |'
- en: '| --- | --- |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| \t | Horizontal tab |'
  id: totrans-1094
  prefs: []
  type: TYPE_TB
  zh: '| \t | 水平制表符 |'
- en: '| \b | Backspace |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
  zh: '| \b | 退格 |'
- en: '| \v | Vertical tab |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
  zh: '| \v | 垂直制表符 |'
- en: '| \f | Form feed |'
  id: totrans-1097
  prefs: []
  type: TYPE_TB
  zh: '| \f | 分页符 |'
- en: '| \r | Carriage return |'
  id: totrans-1098
  prefs: []
  type: TYPE_TB
  zh: '| \r | 回车 |'
- en: '| \n | Newline |'
  id: totrans-1099
  prefs: []
  type: TYPE_TB
  zh: '| \n | 换行 |'
- en: '| \cA : \cZ | Control characters |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
  zh: '| \cA : \cZ | 控制字符 |'
- en: '| \u0000 : \uFFFF | Unicode hexadecimal |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
  zh: '| \u0000 : \uFFFF | Unicode 十六进制 |'
- en: '| \x00 : \xFF | ASCII hexadecimal |'
  id: totrans-1102
  prefs: []
  type: TYPE_TB
  zh: '| \x00 : \xFF | ASCII 十六进制 |'
- en: '| . | Any character, except for whitespace characters (\s) |'
  id: totrans-1103
  prefs: []
  type: TYPE_TB
  zh: '| . | 任何字符，除了空白字符 (\s) |'
- en: '| \d | Any decimal digit; equivalent to [0-9] |'
  id: totrans-1104
  prefs: []
  type: TYPE_TB
  zh: '| \d | 任何十进制数字；等同于 [0-9] |'
- en: '| \D | Any character but a decimal digit; equivalent to [^0-9] |'
  id: totrans-1105
  prefs: []
  type: TYPE_TB
  zh: '| \D | 任何非十进制数字字符；等同于 [^0-9] |'
- en: '| \w | Any alphanumeric character including underscore; equivalent to [A-Za-z0-9_]
    |'
  id: totrans-1106
  prefs: []
  type: TYPE_TB
  zh: '| \w | 包括下划线的任何字母数字字符；等同于 [A-Za-z0-9_] |'
- en: '| \W | Any character but alphanumeric and underscore characters; equivalent
    to [^A-Za-z0-9_] |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
  zh: '| \W | 任何非字母数字和下划线字符；等同于 [^A-Za-z0-9_] |'
- en: '| \s | Any whitespace character (space, tab, form feed, and so on) |'
  id: totrans-1108
  prefs: []
  type: TYPE_TB
  zh: '| \s | 任何空白字符（空格、制表符、换页符等） |'
- en: '| \S | Any character but a whitespace character |'
  id: totrans-1109
  prefs: []
  type: TYPE_TB
  zh: '| \S | 任何非空白字符 |'
- en: '| \b | A word boundary |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '| \b | 单词边界 |'
- en: '| \B | Not a word boundary (inside a word) |'
  id: totrans-1111
  prefs: []
  type: TYPE_TB
  zh: '| \B | 非单词边界（在单词内部） |'
- en: Grouping
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分组
- en: So far, you’ve seen that operators (such as `+` and `*`) affect only the preceding
    term. If we want to apply the operator to a group of terms, we can use parentheses
    for groups, just as in a mathematical expression. For example, `/(ab)+/` matches
    one or more consecutive occurrences of the substring `ab`.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到运算符（如 `+` 和 `*`）只影响前面的术语。如果我们想将运算符应用于一组术语，我们可以使用括号进行分组，就像在数学表达式中一样。例如，`/(ab)+/`
    匹配 `ab` 子串的一个或多个连续出现。
- en: When a part of a regex is grouped with parentheses, it serves double duty, also
    creating what’s known as a *capture*. There’s a lot to captures, and we discuss
    them in more depth in [section 10.4](#ch10lev1sec4).
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式的一部分用括号分组时，它具有双重作用，同时也创建了一个称为 *捕获* 的内容。关于捕获有很多内容，我们将在 [第 10.4 节](#ch10lev1sec4)
    中更深入地讨论。
- en: Alternation (or)
  id: totrans-1115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择（或）
- en: 'Alternatives can be expressed using the pipe (`|`) character. For example:
    `/a|b/` matches either the `a` or `b` character, and `/(ab)+|(cd)+/` matches one
    or more occurrences of either `ab` or `cd`.'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用管道符（`|`）来表示替代项。例如：`/a|b/` 匹配字符 `a` 或 `b`，而 `/(ab)+|(cd)+/` 匹配 `ab` 或 `cd`
    的一个或多个连续出现。
- en: Backreferences
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回溯引用
- en: The most complex terms we can express in regular expressions are backreferences
    to *captures* defined in the regex. We address captures at length in [section
    10.4](#ch10lev1sec4), but for now just think of them as the portions of a candidate
    string that are successfully matched against terms in the regular expression.
    The notation for such a term is the backslash followed by the number of the capture
    to be referenced, beginning with 1, such as `\1`, `\2`, and so on.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在正则表达式中表达的最复杂术语是回溯到正则表达式中定义的 *捕获*。我们在 [第 10.4 节](#ch10lev1sec4) 中详细讨论了捕获，但在此处，你可以将它们视为与正则表达式中的术语成功匹配的候选字符串的部分。此类术语的表示法是反斜杠后跟要引用的捕获编号，从
    1 开始，例如 `\1`、`\2` 等。
- en: An example is `/^([dtn])a\1/`, which matches a string that starts with any of
    the `d`, `t`, or `n` characters, followed by an `a`, followed by whatever character
    matches the first capture. This latter point is important! This isn’t the same
    as `/[dtn] a[dtn]/`. The character following the `a` can’t be any of `d`, or `t`,
    or `n`, but must be whichever one of those triggers the match for the first character.
    As such, which character the `\1` will match can’t be known until evaluation time.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 `/^([dtn])a\1/` 匹配以 `d`、`t` 或 `n` 中的任何一个字符开始的字符串，后面跟着一个 `a`，然后跟着与第一个捕获匹配的任何字符。这一点很重要！这不同于
    `/[dtn] a[dtn]/`。`a` 后面的字符不能是 `d` 或 `t` 或 `n` 中的任何一个，而必须是触发第一个字符匹配的那个字符。因此，`\1`
    将匹配哪个字符只能在评估时才能知道。
- en: 'A good example of where this might be useful is in matching XML-type markup
    elements. Consider the following regex:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在匹配 XML 类型的标记元素时可能非常有用。考虑以下正则表达式：
- en: '[PRE115]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This allows us to match simple elements such as `<strong>`whatever`</strong>`.
    Without the ability to specify a backreference, this wouldn’t be possible, because
    we’d have no way to know what closing tag would match the opening tag ahead of
    time.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们匹配简单的元素，例如 `<strong>` whatever `</strong>`。如果没有指定回溯引用的能力，这是不可能的，因为我们无法提前知道哪个结束标签会匹配前面的开始标签。
- en: '|  |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: That was kind of a whirlwind crash course on regular expressions. If they’re
    still making you pull your hair out and you find yourself bogged down in the material
    that follows, we strongly recommend using one of the resources mentioned earlier
    in this chapter.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是关于正则表达式的一个快速入门课程。如果它们仍然让你感到困扰，并且你发现自己陷入了后续材料的困境，我们强烈建议你使用本章前面提到的资源之一。 '
- en: '|  |'
  id: totrans-1126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you have a handle on regular expressions, you’re ready to look at how
    to use them wisely in your code.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了正则表达式的基础，你就可以开始学习如何在代码中明智地使用它们了。
- en: 10.3\. Compiling regular expressions
  id: totrans-1128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 编译正则表达式
- en: Regular expressions go through multiple phases of processing, and understanding
    what happens during each phase can help us optimize JavaScript code that uses
    regular expressions. The two main phases are compilation and execution.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式会经过多个处理阶段，了解每个阶段发生的事情可以帮助我们优化使用正则表达式的JavaScript代码。两个主要阶段是编译和执行。
- en: '*Compilation* occurs when the regular expression is first created. *Execution*
    occurs when we use the compiled regular expression to match patterns in a string.'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译*发生在正则表达式首次创建时。*执行*发生在我们使用编译后的正则表达式来匹配字符串中的模式时。'
- en: During compilation, the expression is parsed by the JavaScript engine and converted
    into its internal representation (whatever that may be). This phase of parsing
    and conversion must occur every time a regular expression is created (discounting
    any internal optimizations performed by the browser).
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，表达式被JavaScript引擎解析并转换为它的内部表示（无论是什么）。这个解析和转换阶段必须每次创建正则表达式时发生（不考虑浏览器执行的任何内部优化）。
- en: Frequently, browsers *are* smart enough to determine when identical regular
    expressions are being used, and to cache the compilation results for that particular
    expression. But we can’t count on this being the case in all browsers. For complex
    expressions, in particular, we can begin to get some noticeable speed improvements
    by predefining (and thus precompiling) our regular expressions for later use.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，浏览器足够智能，能够确定何时使用相同的正则表达式，并缓存该特定表达式的编译结果。但我们不能依赖所有浏览器都这样做。对于复杂表达式，特别是，我们可以通过预先定义（因此预先编译）我们的正则表达式以供以后使用，开始获得一些明显的速度提升。
- en: 'As we learned in our regular expression overview in the previous section, there
    are two ways of creating a compiled regular expression in JavaScript: via a literal
    and via a constructor. Let’s look at an example in the following listing.'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中的正则表达式概述中学到的，在JavaScript中创建编译后的正则表达式有两种方式：通过字面量和通过构造函数。让我们在下面的列表中看看一个例子。
- en: Listing 10.2\. Two ways to create a compiled regular expression
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 创建编译后的正则表达式的两种方式
- en: '![](267fig01_alt.jpg)'
  id: totrans-1135
  prefs: []
  type: TYPE_IMG
  zh: '![](267fig01_alt.jpg)'
- en: In this example, both regular expressions are in their compiled state after
    creation. If we were to replace every reference to `re1` with the literal `/test/i`,
    it’s possible that the same regex would be compiled time and time again, so compiling
    a regex *once* and storing it in a variable for later reference can be an important
    optimization.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个正则表达式在创建后都处于编译状态。如果我们把对`re1`的每个引用都替换为字面量`/test/i`，那么同一个正则表达式可能会被一次又一次地编译，所以编译正则表达式*一次*并将其存储在变量中以供以后引用可能是一个重要的优化。
- en: 'Note that each regex has a unique object representation: Every time a regular
    expression is created (and thus compiled), a new regular expression object is
    created. This is unlike other primitive types (such as string, number, and so
    on), because the result will always be unique.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个正则表达式都有一个独特的对象表示：每次创建正则表达式（因此编译）时，都会创建一个新的正则表达式对象。这与其他原始类型（如字符串、数字等）不同，因为结果总是唯一的。
- en: Of particular importance is the use of the constructor (`new RegExp(...)`) to
    create a regular expression. This technique allows us to build and compile an
    expression from a string that we can dynamically create at runtime. This can be
    immensely useful for constructing complex expressions that will be heavily reused.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是使用构造函数（`new RegExp(...)》）来创建正则表达式。这种技术允许我们从可以在运行时动态创建的字符串构建和编译表达式。这对于构建将被大量重用的复杂表达式非常有用。
- en: For example, let’s say that we want to determine which elements within a document
    have a particular class name, whose value we won’t know until runtime. Because
    elements are capable of having multiple class names associated with them (inconveniently
    stored in a space-delimited string), this serves as an interesting example of
    runtime, regular-expression compilation (see the following listing).
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要确定文档中哪些元素具有特定的类名，其值我们将在运行时才知道。因为元素可以与多个类名相关联（不便地存储在空格分隔的字符串中），这构成了一个有趣的运行时正则表达式编译的例子（见以下列表）。
- en: Listing 10.3\. Compiling a runtime regular expression for later use
  id: totrans-1140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 编译运行时正则表达式以供以后使用
- en: '![](ch10ex03-0.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex03-0.jpg)'
- en: '![](ch10ex03-1.jpg)'
  id: totrans-1142
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex03-1.jpg)'
- en: We can learn several interesting things from [listing 10.3](#ch10ex03). To start,
    we set up a number of test-subject `<div>` and `<span>` elements with various
    combinations of class names. Then we define our class-name checking function,
    which accepts as parameters the class name for which we’ll check and the element
    type to check within.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从[列表10.3](#ch10ex03)中了解几个有趣的事情。首先，我们设置了一些带有各种类名组合的测试主题`<div>`和`<span>`元素。然后我们定义了我们的类名检查函数，该函数接受我们将要检查的类名和要检查的元素类型作为参数。
- en: 'Then we collect all the elements of the specified type by using the `getElementsByTagName`
    built-in method and set up our regular expression:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`getElementsByTagName`内置方法收集指定类型的所有元素，并设置我们的正则表达式：
- en: '[PRE116]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Note the use of the `new RegExp()` constructor to compile a regular expression
    based on the class name passed to the function. This is an instance where we can’t
    use a regex literal, as the class name for which we’ll search isn’t known in advance.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`new RegExp()`构造函数根据传递给函数的类名编译正则表达式。这是一个我们不能使用正则表达式文本的情况，因为我们将要搜索的类名事先是未知的。
- en: We construct (and hence, compile) this expression once in order to avoid frequent
    and unnecessary recompilation. Because the contents of the expression are dynamic
    (based on the incoming `className` argument), we can realize major performance
    savings by handling the expression in this manner.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只构建（因此，编译）这个表达式一次，以避免频繁且不必要的重新编译。因为表达式的内容是动态的（基于传入的`className`参数），我们可以通过这种方式处理表达式，从而实现重大的性能提升。
- en: 'The regex itself matches either the beginning of the string or a whitespace
    character, followed by the target class name, followed by either a whitespace
    character or the end of the string. Notice the use of a double-escape (`\\`) within
    the new regex: `\\s`. When creating literal regular expressions with terms including
    the backslash, we have to provide the backslash only once. But because we’re writing
    these backslashes within a string, we must double-escape them. This is a nuisance,
    to be sure, but one that we must be aware of when constructing regular expressions
    in strings rather than literals.'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式本身匹配字符串的开始或一个空白字符，后跟目标类名，后跟一个空白字符或字符串的结尾。注意新正则表达式中的双重转义（`\\`）的使用：`\\s`。当创建包含反斜杠的文本正则表达式时，我们必须只提供一次反斜杠。但由于我们是在字符串中写入这些反斜杠，我们必须对它们进行双重转义。这确实是一个麻烦，但当我们构建字符串中的正则表达式而不是文本时，我们必须意识到这一点。
- en: 'After the regex is compiled, using it to collect the matching elements is a
    snap via the `test` method:'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式编译后，通过`test`方法收集匹配元素变得非常简单：
- en: '[PRE117]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Preconstructing and precompiling regular expressions so that they can be reused
    (executed) time and time again is a recommended technique that provides performance
    gains that can’t be ignored. Virtually all complex regular expression situations
    can benefit from the use of this technique.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 预先构建和预编译正则表达式，以便它们可以一次又一次地重复使用（执行），这是一种推荐的技术，它提供的性能提升不容忽视。几乎所有的复杂正则表达式情况都可以从使用这种技术中受益。
- en: Earlier in this chapter, we mentioned that the use of parentheses in regular
    expressions not only serves to group terms for operator application, but also
    creates *captures*. Let’s find out more about that.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们提到正则表达式中的括号不仅用于对术语进行分组以应用运算符，而且还会创建*捕获*。让我们了解更多关于这一点的内容。
- en: 10.4\. Capturing matching segments
  id: totrans-1153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 捕获匹配段
- en: The height of usefulness with respect to regular expressions is realized when
    we *capture* the results that are found so that we can do something with them.
    Determining whether a string matches a pattern is an obvious first step and often
    all that we need, but determining *what* was matched is also useful in many situations.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正则表达式的实用性，当我们*捕获*找到的结果以便我们可以对它们进行操作时，这种实用性达到了顶峰。确定一个字符串是否与模式匹配是一个明显的第一步，通常也是我们所需要的，但在许多情况下，确定*匹配了什么*也是有用的。
- en: 10.4.1\. Performing simple captures
  id: totrans-1155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1. 执行简单捕获
- en: Say we want to extract a value that’s embedded in a complex string. A good example
    of such a string is the value of the CSS transform property, through which we
    can modify the visual position of an HTML element.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要提取嵌入在复杂字符串中的值。这样的字符串的一个很好的例子是CSS转换属性的值，通过它可以修改HTML元素的视觉位置。
- en: Listing 10.4\. A simple function for capturing an embedded value
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4. 捕获嵌入值的简单函数
- en: '![](269fig01_alt.jpg)'
  id: totrans-1158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](269fig01_alt.jpg)'
- en: 'We define an element that specifies the style that will translate its position
    by 15 px:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个元素，指定将位置平移15 px的样式：
- en: '[PRE118]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Unfortunately, the browser doesn’t offer an API for easily fetching the amount
    by which the element is translated. So we create our own function:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浏览器没有提供易于获取元素平移量的API。因此，我们创建了自己的函数：
- en: '[PRE119]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The transform parsing code may seem confusing at first:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 转换解析代码一开始可能看起来有些复杂：
- en: '[PRE120]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: But it’s not too bad when we break it down. To start, we need to determine whether
    a `transform` property even exists for us to parse. If not, we’ll return an empty
    string. If the `transform` property is resident, we can get down to the opacity
    value extraction. The `match` method of a regular expression returns an array
    of captured values if a match is found, or `null` if no match is found.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们将其分解时，情况并不太糟糕。首先，我们需要确定是否存在一个`transform`属性，以便我们进行解析。如果不存在，我们将返回一个空字符串。如果`transform`属性存在，我们就可以开始提取不透明度值。正则表达式的`match`方法在找到匹配项时返回一个捕获值的数组，如果没有找到匹配项，则返回`null`。
- en: The array returned by `match` includes the entire match in the first index,
    and then each subsequent capture following. So the zeroth entry would be the entire
    matched string of `translateY(15px)`, and the entry at the next position would
    be `15px`.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`返回的数组包括第一个索引中的整个匹配，然后是每个后续的捕获。因此，零索引将包含`translateY(15px)`的整个匹配字符串，下一个位置的条目将是`15px`。'
- en: Remember that the captures are defined by parentheses in the regular expression.
    Thus, when we match the transform value, the value is contained in the `[1]` position
    of the array, because the only capture we specified in our regex was created by
    the parentheses that we embedded after the `translateY` portion of the regex.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，捕获是由正则表达式中的括号定义的。因此，当我们匹配转换值时，该值位于数组的`[1]`位置，因为我们指定的唯一捕获是在正则表达式的`translateY`部分之后嵌入的括号创建的。
- en: This example uses a local regular expression and the `match` method. Things
    change when we use global expressions. Let’s see how.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用本地正则表达式和`match`方法。当我们使用全局表达式时，情况会有所变化。让我们看看。
- en: 10.4.2\. Matching using global expressions
  id: totrans-1169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2\. 使用全局表达式进行匹配
- en: As we saw in the previous section, using a local regular expression (one without
    the global flag) with the `String` object’s `match` methods returns an array containing
    the entire matched string, along with any matched captures in the operation.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，使用不带全局标志的本地正则表达式（`String`对象的`match`方法）返回一个包含整个匹配字符串的数组，以及任何在操作中匹配的捕获。
- en: But when we supply a global regular expression (one with the `g` flag included),
    `match` returns something different. It’s still an array of results, but in the
    case of a global regular expression, which matches all possibilities in the candidate
    string rather than just the first match, the array returned contains the global
    matches; captures *within* each match aren’t returned in this case.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们提供一个全局正则表达式（包含`g`标志的）时，`match`返回的结果就不同了。它仍然是一个结果数组，但在全局正则表达式的案例中，它匹配候选字符串中的所有可能性，而不仅仅是第一个匹配项，返回的数组包含全局匹配；在这种情况下，不返回每个匹配项内的捕获。
- en: We can see this in action in the following code and tests.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码和测试中看到这一行为。
- en: Listing 10.5\. Differences between global and local searches with match
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. `match`方法中全局和本地搜索的差异
- en: '![](271fig01_alt.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![](271fig01_alt.jpg)'
- en: We can see that when we do a local match, `html.match(/<(\/?)(\w+)([^>]*?)>/)`,
    a single instance is matched and the captures within that match are also returned.
    But when we use a global match, `html.match(/<(\/?)(\w+)([^>]*?)>/g)`, what’s
    returned is the list of matches.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们进行本地匹配时，`html.match(/<(\/?)(\w+)([^>]*?)>/)`，匹配单个实例，并且该匹配项内的捕获也被返回。但当我们使用全局匹配时，`html.match(/<(\/?)(\w+)([^>]*?)>/g)`，返回的是匹配列表。
- en: If captures are important to us, we can regain this functionality while still
    performing a global search by using the regular expression’s `exec` method. This
    method can be repeatedly called against a regular expression, causing it to return
    the next matched set of information every time it’s called. A typical pattern
    for use is shown in the following listing.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果捕获对我们很重要，我们可以在执行全局搜索的同时恢复此功能，通过使用正则表达式的`exec`方法。此方法可以反复调用正则表达式，每次调用时都返回下一个匹配的信息集。以下是一个典型的使用模式。
- en: Listing 10.6\. Using the exec method to do both capturing and a global search
  id: totrans-1177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 使用`exec`方法进行捕获和全局搜索
- en: '![](271fig02_alt.jpg)'
  id: totrans-1178
  prefs: []
  type: TYPE_IMG
  zh: '![](271fig02_alt.jpg)'
- en: 'In this example, we repeatedly call the `exec` method:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们反复调用`exec`方法：
- en: '[PRE121]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This retains state from the previous invocation so that each subsequent call
    progresses to the next global match. Each call returns the next match *and* its
    captures.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 这保留了前一次调用的状态，以便后续的每次调用都进展到下一个全局匹配。每次调用都返回下一个匹配项及其捕获。
- en: By using either `match` or `exec`, we can always find the exact matches (and
    captures) that we’re looking for. But we’ll need to dig further if we want to
    refer to the captures themselves within the regex.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`match`或`exec`，我们总能找到我们想要的精确匹配（和捕获）。但如果我们想在正则表达式中引用捕获本身，我们还需要进一步挖掘。
- en: 10.4.3\. Referencing captures
  id: totrans-1183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3\. 引用捕获
- en: 'We can refer to portions of a match that we’ve captured in two ways: one within
    the match itself, and one within a replacement string (where applicable). For
    example, let’s revisit the match in [listing 10.6](#ch10ex06) (in which we match
    an opening or closing HTML tag) and modify it in the following listing to also
    match the inner contents of the tag itself.'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式引用已捕获的匹配部分：一种是在匹配本身内部，另一种是在替换字符串（如果适用）内部。例如，让我们回顾[列表10.6](#ch10ex06)中的匹配（其中我们匹配一个开标签或闭标签）并修改它，在以下列表中使其也匹配标签本身的内部内容。
- en: Listing 10.7\. Using backreferences to match the contents of an HTML tag
  id: totrans-1185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. 使用后向引用匹配HTML标签的内容
- en: '![](272fig01_alt.jpg)'
  id: totrans-1186
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](272fig01_alt.jpg)'
- en: We use `\1` to refer to the first capture within the expression, which in this
    case is the name of the tag. Using this information, we can match the appropriate
    closing tag, referring to whatever the capture matched. (This all assumes, of
    course, that there aren’t any embedded tags of the same name within the current
    tag, so this is hardly an exhaustive example of tag matching.)
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`\1`来引用表达式中的第一个捕获，在这个例子中是标签的名称。利用这些信息，我们可以匹配适当的闭合标签，引用捕获匹配的内容。（当然，这假设当前标签内没有嵌套的同名标签，所以这几乎不是一个详尽的标签匹配示例。）
- en: 'Additionally, we can get capture references within the replace string of a
    call to the `replace` method. Instead of using the backreference codes, as in
    [listing 10.7](#ch10ex07), we use the syntax of `$1`, `$2`, `$3`, up through each
    capture number. Here’s an example:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在`replace`方法的调用中的替换字符串中获取捕获引用。与[列表10.7](#ch10ex07)中的后向引用代码不同，我们使用`$1`、`$2`、`$3`等语法，直到每个捕获编号。以下是一个示例：
- en: '[PRE122]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In this code, the value of the first capture (in this case, the capital letter
    `F`) is referenced in the *replace string* (via `$1`). This allows us to specify
    a replace string without even knowing what its value will be until matching time.
    That’s a powerful ninja-esque weapon to wield.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，第一个捕获的值（在这个例子中是首字母大写的`F`）在*替换字符串*（通过`$1`）中被引用。这允许我们在匹配时间之前甚至不知道其值的情况下指定替换字符串。这是一件强大的类似忍者般的武器。
- en: The ability to reference regular-expression captures helps make a lot of code
    that would otherwise be difficult, quite easy. The expressive nature that it provides
    ends up allowing for some terse statements that could otherwise be rather obtuse,
    convoluted, and lengthy.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 能够引用正则表达式捕获的能力使得许多原本难以编写的代码变得非常简单。它提供的表达性最终允许我们编写一些简洁的语句，否则这些语句可能会相当晦涩、复杂且冗长。
- en: Because both captures and expression grouping are specified using parentheses,
    there’s no way for the regular-expression processor to know which sets of parentheses
    we added to the regex for grouping and which were intended to indicate captures.
    It treats all sets of parentheses as both groups and captures, which can result
    in the capture of more information than we really intended, because we needed
    to specify some grouping in the regex. What can we do in such cases?
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于捕获和表达式分组都是通过括号指定的，正则表达式处理器无法知道我们在正则表达式中添加的哪些括号是为了分组，哪些是为了表示捕获。它将所有括号集都视为组和捕获，这可能导致捕获比我们真正想要的信息更多，因为我们需要在正则表达式中指定一些分组。在这种情况下我们该怎么办？
- en: 10.4.4\. Noncapturing groups
  id: totrans-1193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.4\. 非捕获组
- en: 'As we noted, parentheses serve a double duty: They not only group terms for
    operations, but also specify captures. This usually isn’t an issue, but in regular
    expressions in which lots of grouping is going on, it could cause lots of needless
    capturing, which may make sorting through the resulting captures tedious.'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，括号具有双重作用：它们不仅用于对操作项进行分组，还用于指定捕获。这通常不会成为问题，但在进行大量分组操作的正则表达式中，可能会导致不必要的捕获，这可能会使得对结果捕获的排序变得繁琐。
- en: 'Consider the following regex:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下正则表达式：
- en: '[PRE123]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Here, the intent is to create a regex that allows the prefix `ninja-` to appear
    one or more times before the word `sword`, and we want to capture the entire prefix.
    This regex requires two sets of parentheses:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们的意图是创建一个正则表达式，允许前缀 `ninja-` 在 `sword` 单词之前出现一次或多次，并且我们想要捕获整个前缀。这个正则表达式需要两组括号：
- en: The parentheses that define the capture (everything before the string `sword`)
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义捕获的括号（字符串 `sword` 之前的所有内容）
- en: The parentheses that group the text `ninja-` for the `+` operator
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `ninja-` 文本分组以供 `+` 操作符使用的括号
- en: This all works fine, but it results in more than the single intended capture
    because of the inner set of grouping parentheses.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都没有问题，但它由于内部分组括号的存在，导致捕获的结果多于一个预期的结果。
- en: To indicate that a set of parentheses shouldn’t result in a capture, the regular
    expression syntax lets us put the notation `?:` immediately after the opening
    parenthesis. This is known as a *passive subexpression*.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一组括号不应该导致捕获，正则表达式语法允许我们在开括号后立即放置 `?:` 符号。这被称为*被动子表达式*。
- en: Changing this regular expression to
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个正则表达式改为
- en: '[PRE124]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: causes only the outer set of parentheses to create a capture. The inner parentheses
    have been converted to a passive subexpression.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 只导致外部的括号集创建捕获。内部的括号已被转换为被动子表达式。
- en: To test this, take a look at the following code.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，请看以下代码。
- en: Listing 10.8\. Grouping without capturing
  id: totrans-1206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 无捕获的分组
- en: '![](274fig01_alt.jpg)'
  id: totrans-1207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](274fig01_alt.jpg)'
- en: Running these tests, we can see that the passive subexpression `/((?:ninja-)+)sword/`
    prevents unnecessary captures.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试，我们可以看到被动子表达式 `/((?:ninja-)+)sword/` 阻止了不必要的捕获。
- en: Wherever possible in our regular expressions, we should strive to use noncapturing
    (passive) groups in place of capturing when the capture is unnecessary, so that
    the expression engine will have much less work to do in remembering and returning
    the captures. If we don’t need captured results, there’s no need to ask for them!
    The price that we pay is that already-complex regular expressions can become a
    tad more cryptic.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的正则表达式中，尽可能使用非捕获（被动）组来代替捕获，当捕获不是必需的时候，这样表达式引擎在记住和返回捕获时会有更少的工作要做。如果我们不需要捕获的结果，就没有必要去请求它们！我们付出的代价是，已经复杂的正则表达式可能会变得更加晦涩难懂。
- en: 'Now let’s turn our attention to another way that regular expressions give us
    ninja powers: using functions with the `String` object’s `replace` method.'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向正则表达式赋予我们忍者力量的另一种方式：使用`String`对象的`replace`方法与函数一起使用。
- en: 10.5\. Replacing using functions
  id: totrans-1211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 使用函数进行替换
- en: The `replace` method of the `String` object is a powerful and versatile method,
    which we saw used briefly in our discussion of captures. When a regular expression
    is provided as the first parameter to `replace`, it will cause a replacement on
    a match (or *matches* if the regex is global) to the pattern rather than on a
    fixed string.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象的`replace`方法是一个强大且多功能的函数，我们在讨论捕获时简要地使用了它。当正则表达式作为`replace`的第一个参数提供时，它将对模式进行替换（如果正则表达式是全局的，则替换所有匹配项）而不是对固定字符串进行替换。'
- en: 'For example, let’s say that we want to replace all uppercase characters in
    a string with `X`. We could write the following:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要将字符串中的所有大写字母替换为 `X`。我们可以写出以下代码：
- en: '[PRE125]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This results in a value of `XXXXXfg`. Nice.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到 `XXXXXfg` 的值。不错。
- en: But perhaps the most powerful feature presented by `replace` is the ability
    to provide a function as the replacement value rather than a fixed string.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 但`replace`方法最强大的特性可能是提供函数作为替换值而不是固定字符串的能力。
- en: 'When the replacement value (the second argument) is a function, it’s invoked
    for each match found (remember that a global search will match all instances of
    the pattern in the source string) with a variable list of parameters:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 当替换值（第二个参数）是一个函数时，它会对每个找到的匹配项调用（记住全局搜索会匹配源字符串中模式的全部实例）并带有可变参数列表：
- en: The full text of the match
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛全文
- en: The captures of the match, one parameter for each
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛捕捉，每个参数一个
- en: The index of the match within the original string
  id: totrans-1220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配项在原始字符串中的索引
- en: The source string
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源字符串
- en: The value returned from the function serves as the replacement value.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回的值作为替换值。
- en: This provides a tremendous amount of leeway to determine what the replacement
    string should be at runtime, with lots of information regarding the nature of
    the match at our fingertips. For example, in the following listing, we use the
    function to provide a dynamic replacement value for converting a string with words
    separated by dashes to its camel-cased equivalent.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了巨大的灵活性来确定运行时替换字符串应该是什么，我们手头有大量关于匹配性质的信息。例如，在下面的列表中，我们使用该函数提供动态替换值，将用破折号分隔单词的字符串转换为它的驼峰式等效形式。
- en: Listing 10.9\. Converting a dashed string to camel case
  id: totrans-1224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 将破折号字符串转换为驼峰式
- en: '![](275fig01_alt.jpg)'
  id: totrans-1225
  prefs: []
  type: TYPE_IMG
  zh: '![](275fig01_alt.jpg)'
- en: Here, we provide a regex that matches any character preceded by a dash character.
    A capture in the global regex identifies the character that was matched (without
    the dash). Each time the function is called (twice in this example), it’s passed
    the full match string as the first argument, and the capture (only one for this
    regex) as the second argument. We aren’t interested in the rest of the arguments,
    so we didn’t specify them.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一个匹配任何由破折号字符之前字符的正则表达式。全局正则表达式中的捕获识别了被匹配的字符（不包括破折号）。每次函数被调用时（在这个例子中是两次），它都会传递完整的匹配字符串作为第一个参数，以及捕获（对于这个正则表达式只有一个）作为第二个参数。我们对于其余的参数不感兴趣，因此我们没有指定它们。
- en: The first time the function is called, it’s passed `-b` and `b;` and the second
    time it’s called, it’s passed `-w` and `w`. In each case, the captured letter
    is uppercased and returned as the replacement string. We end up with `-b` replaced
    by `B` and with `-w` replaced by `W`.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次函数被调用时，传递 `-b` 和 `b;`，第二次调用时传递 `-w` 和 `w`。在每种情况下，捕获的字母都会被转换为大写并作为替换字符串返回。我们最终将
    `-b` 替换为 `B`，将 `-w` 替换为 `W`。
- en: Because a global regex will cause such a replace function to be executed for
    every match in a source string, this technique can even be extended beyond doing
    rote replacements. We can use the technique as a means of string traversal, instead
    of doing the `exec()`-in-a-while-loop technique that we saw earlier in this chapter.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全局正则表达式会导致替换函数在源字符串中的每个匹配项上执行，因此这种技术甚至可以扩展到执行机械的替换之外。我们可以将这种技术用作字符串遍历的手段，而不是像在本章前面看到的
    `exec()`-in-a-while-loop 技术那样。
- en: For example, let’s say that we’re looking to take a query string and convert
    it to an alternative format that suits our purposes. We’d turn a query string
    such as
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在寻找将查询字符串转换为适合我们目的的替代格式的操作。我们会将一个查询字符串，例如
- en: '[PRE126]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: into one that looks like this
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为如下所示
- en: '[PRE127]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: A solution using regular expressions and `replace` could result in some especially
    terse code, as shown in the next listing.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式和 `replace` 的解决方案可能会导致一些特别简洁的代码，如下一列表所示。
- en: Listing 10.10\. A technique for compressing a query string
  id: totrans-1234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 压缩查询字符串的技术
- en: '![](275fig02_alt.jpg)'
  id: totrans-1235
  prefs: []
  type: TYPE_IMG
  zh: '![](275fig02_alt.jpg)'
- en: 'The most interesting aspect of this example is its use of the string `replace`
    method as a means of traversing a string for values, rather than as a search-and-replace
    mechanism. The trick is twofold: passing in a function as the replacement value
    argument, and instead of returning a value, using it as a means of searching.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子最有趣的地方在于它将字符串 `replace` 方法用作遍历字符串以获取值的一种手段，而不是用作搜索和替换机制。这个技巧有两个方面：将一个函数作为替换值参数传递，并且不返回值，而是用它作为搜索的手段。
- en: The example code first declares a hash `key` in which we store the keys and
    values that we find in the source query string. Then we call the `replace` method
    on the source string, passing a regex that will match the key-value pairs, and
    capture the key and the value. We also pass a function that will be passed the
    full match, the key capture, and the value capture. These captured values get
    stored in the hash for later reference. Note that we return the empty string because
    we don’t care what substitutions happen to the source string—we’re just using
    the side effects rather than the result.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码首先声明一个哈希 `key`，在其中我们存储在源查询字符串中找到的键和值。然后我们在源字符串上调用 `replace` 方法，传递一个将匹配键值对并捕获键和值的正则表达式。我们还传递一个函数，该函数将传递完整的匹配、键捕获和值捕获。这些捕获的值将被存储在哈希中以供以后参考。请注意，我们返回空字符串，因为我们不关心源字符串中发生了什么替换——我们只是使用副作用而不是结果。
- en: 'After `replace` returns, we declare an array in which we’ll aggregate the results
    and iterate through the keys that we found, adding each to the array. Finally,
    we join each of the results we stored in the array by using `&` as the delimiter,
    and we return the result:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`replace`返回后，我们声明一个数组，我们将在这里聚合结果并遍历我们找到的键，将每个添加到数组中。最后，我们使用`&`作为分隔符将存储在数组中的每个结果连接起来，并返回结果：
- en: '[PRE128]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Using this technique, we can co-opt the `String` object’s `replace` method as
    our own string-searching mechanism. The result isn’t only fast, but also simple
    and effective. The level of power that this technique provides, especially in
    light of the small amount of code necessary, shouldn’t be underestimated.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以利用`String`对象的`replace`方法作为我们自己的字符串搜索机制。结果不仅快速，而且简单有效。这种技术提供的强大功能，尤其是在代码量很少的情况下，不应被低估。
- en: All of these regular expression techniques can have a huge impact on how we
    write script on our pages. Let’s see how to apply what you’ve learned to solve
    some common problems we might encounter.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些正则表达式技术都可能对我们编写页面上的脚本产生巨大影响。让我们看看如何应用你所学的知识来解决我们可能遇到的一些常见问题。
- en: 10.6\. Solving common problems with regular expressions
  id: totrans-1242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6\. 使用正则表达式解决常见问题
- en: In JavaScript, a few idioms tend to occur again and again, but their solutions
    aren’t always obvious. A knowledge of regular expressions can definitely come
    to the rescue, and in this section we’ll look at a few common problems that we
    can solve with a regex or two.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，一些惯用表达式可能会反复出现，但它们的解决方案并不总是显而易见。了解正则表达式无疑可以提供帮助，在本节中，我们将探讨一些我们可以用正则表达式解决的一些常见问题。
- en: 10.6.1\. Matching newlines
  id: totrans-1244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.1\. 匹配换行符
- en: When performing a search, it’s sometimes desirable for the period (`.`) term,
    which matches any character except for newline, to also include newline characters.
    Regular expression implementations in other languages frequently include a flag
    for making this possible, but JavaScript’s implementation doesn’t.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行搜索时，有时希望点号（`.`）术语，它匹配除换行符之外的任何字符，也能包括换行符。其他语言的正则表达式实现通常包括一个标志来实现这一点，但JavaScript的实现没有。
- en: Let’s look at a couple of ways of getting around this omission in JavaScript,
    as shown in the next listing.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在JavaScript中如何解决这种遗漏的几种方法，如下一列表所示。
- en: Listing 10.11\. Matching *all* characters, including newlines
  id: totrans-1247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11\. 匹配*所有*字符，包括换行符
- en: '![](277fig01_alt.jpg)'
  id: totrans-1248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](277fig01_alt.jpg)'
- en: 'This example defines a test subject string: `"<b>Hello</b>\n<i>world!</i>"`,
    containing a newline. Then we try various ways of matching all the characters
    in the string.'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了一个测试主题字符串：`"<b>Hello</b>\n<i>world!</i>"`，其中包含换行符。然后我们尝试各种方法来匹配字符串中的所有字符。
- en: In the first test, `/.*/.exec(html)[0] === "<b>Hello</b>"`, we verify that newlines
    aren’t matched by the `.` operator. Ninjas won’t be denied, so in the next test
    we get our way with an alternative regex, `/[\S\s]*/`, in which we define a character
    class that matches anything that’s *not* a whitespace character and anything that
    *is* a whitespace character. This union is the set of all characters.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，`/.*/.exec(html)[0] === "<b>Hello</b>"`，我们验证了换行符不会被`.`运算符匹配。忍者不会拒绝，所以在下一个测试中，我们使用一个替代正则表达式`/[\S\s]*/`，在其中我们定义一个字符类，它匹配任何不是空白字符的字符，以及任何是空白字符的字符。这个并集是所有字符的集合。
- en: 'Another approach is taken in the next test:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试采用了另一种方法：
- en: '[PRE129]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Here we use an alternation regex, `/(?:.|\s)*/`, in which we match everything
    matched by `.`, which is everything but newline, and everything considered whitespace,
    which includes newline. The resulting union is the set of all characters including
    newlines. Note the use of a passive subexpression to prevent any unintended captures.
    Because of its simplicity (and implicit speed benefits), the solution provided
    by `/[\S\s]*/` is generally considered optimal.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个交替正则表达式`/(?:.|\s)*/`，在其中我们匹配由`.`匹配的所有内容，即除了换行符之外的所有内容，以及被认为是空白字符的所有内容，包括换行符。结果并集是包括换行符在内的所有字符的集合。注意使用被动子表达式以防止任何意外的捕获。由于其简单性（以及隐含的速度优势），`/[\S\s]*/`提供的解决方案通常被认为是最佳的。
- en: Next, let’s take a step to widen our view to a worldwide scope.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进一步拓宽视野，将其扩展到全球范围。
- en: 10.6.2\. Matching Unicode
  id: totrans-1255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.2\. 匹配Unicode
- en: Frequently in the use of regular expressions, we want to match alphanumeric
    characters, such as an ID selector in a CSS selector engine implementation. But
    assuming that the alphabetic characters will be from only the set of English ASCII
    characters is shortsighted.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用正则表达式的过程中，我们经常想要匹配字母数字字符，例如在 CSS 选择器引擎实现中的一个 ID 选择器。但假设字母字符仅来自英语 ASCII 字符集是短视的。
- en: Expanding the set to include Unicode characters is sometimes desirable, explicitly
    supporting multiple languages not covered by the traditional alphanumeric character
    set (see the following listing).
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 将集合扩展到包括 Unicode 字符有时是可取的，明确支持传统字母数字字符集未涵盖的多种语言（见以下列表）。
- en: Listing 10.12\. Matching Unicode characters
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12. 匹配 Unicode 字符
- en: '![](278fig01_alt.jpg)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](278fig01_alt.jpg)'
- en: This listing includes the entire range of Unicode characters in the match by
    creating a character class that includes the `\w` term, to match all the “normal”
    word characters, plus a range that spans the entire set of Unicode characters
    above U+0080. Starting at 128 gives us some high ASCII characters along with all
    Unicode characters in the Basic Multilingual Plane.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表通过创建一个包含 `\w` 项的字符类来匹配整个匹配范围内的 Unicode 字符，以匹配所有“正常”的单词字符，以及一个跨越 U+0080 以上整个
    Unicode 字符集的范围。从 128 开始，我们得到了一些高 ASCII 字符以及基本多语言平面中的所有 Unicode 字符。
- en: The astute among you might note that by adding the entire range of Unicode characters
    above `\u0080`, we match not only alphabetic characters, but also all Unicode
    punctuation and other special characters (arrows, for example). But that’s okay,
    because the point of the example is to show how to match Unicode characters in
    general. If you have a specific range of characters that you want to match, you
    can use the lesson of this example to add whatever range you wish to the character
    class.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的你们可能会注意到，通过添加上述 `\u0080` 的整个 Unicode 字符范围，我们不仅匹配了字母字符，还匹配了所有 Unicode 标点符号和其他特殊字符（例如箭头）。但这没关系，因为本例的目的是展示如何一般性地匹配
    Unicode 字符。如果您想要匹配特定范围的字符，您可以使用本例的教训将您想要的任何范围添加到字符类中。
- en: Before moving on from our examination of regular expressions, let’s tackle one
    more common issue.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对正则表达式的考察之前，让我们解决一个更常见的问题。
- en: 10.6.3\. Matching escaped characters
  id: totrans-1263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.3. 匹配转义字符
- en: It’s common for page authors to use names that conform to program identifiers
    when assigning `id` values to page elements, but that’s just a convention; `id`
    values can contain characters other than “word” characters, including punctuation.
    For example, a web developer might use the `id` value `form:update` for an element.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 页面作者在为页面元素分配 `id` 值时通常使用符合程序标识符的名称，但这只是一个约定；`id` 值可以包含除“单词”字符以外的字符，包括标点符号。例如，一个网络开发者可能会为元素使用
    `id` 值 `form:update`。
- en: A library developer, when writing an implementation for, say, a CSS selector
    engine, would like to support escaped characters. This allows the user to specify
    complex names that don’t conform to typical naming conventions. So let’s develop
    a regex that will allow matching escaped characters. Consider the following code.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个库开发者为 CSS 选择器引擎编写实现时，他希望支持转义字符。这允许用户指定不符合典型命名约定的复杂名称。因此，让我们开发一个正则表达式，以便匹配转义字符。考虑以下代码。
- en: Listing 10.13\. Matching escaped characters in a CSS selector
  id: totrans-1266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13. 匹配 CSS 选择器中的转义字符
- en: '![](278fig02_alt.jpg)'
  id: totrans-1267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](278fig02_alt.jpg)'
- en: This particular expression works by allowing for a match of either a word character
    sequence or a sequence of a backslash followed by any character.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的表达式通过允许匹配单词字符序列或一个反斜杠后跟任何字符的序列来工作。
- en: Note that more work is required to fully support all escape characters. For
    more details, visit [https://mathiasbynens.be/notes/css-escapes](https://mathiasbynens.be/notes/css-escapes).
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要完全支持所有转义字符需要做更多的工作。更多详情，请访问 [https://mathiasbynens.be/notes/css-escapes](https://mathiasbynens.be/notes/css-escapes)。
- en: 10.7\. Summary
  id: totrans-1270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7. 摘要
- en: Regular expressions are a powerful tool that permeates modern JavaScript development;
    virtually every aspect of any sort of matching depends on their use. With a good
    understanding of the advanced regex concepts covered in this chapter, you should
    feel comfortable tackling any challenging piece of code that could benefit from
    regular expressions.
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式是现代 JavaScript 开发中无处不在的强大工具；几乎任何类型的匹配的各个方面都依赖于它们的使用。通过对本章中涵盖的高级正则表达式概念的深入了解，你应该能够轻松应对任何可能从正则表达式中受益的具有挑战性的代码片段。
- en: We can create regular expressions with regular expression literals (`/test/`)
    and with the `RegExp` constructor (new RegExp(`"test"`)). Literals are preferred
    when the regex is known at development time, and the constructor when the regex
    is constructed at runtime.
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用正则表达式字面量（`/test/`）和 `RegExp` 构造函数（`new RegExp("test")`）来创建正则表达式。当正则表达式在开发时已知时，首选字面量，当正则表达式在运行时构建时，首选构造函数。
- en: 'With each regular expression, we can associate five flags: `i` makes the regex
    case-insensitive, `g` matches all instances of the pattern, `m` allows matches
    across multiple lines, `y` enables sticky matching, while `u` enables the use
    of Unicode escapes. Flags are added at the end of a regex literal: `/test/ig`,
    or as a second parameter to the `RegExp` constructor: `new RegExp("test", "i")`.'
  id: totrans-1273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个正则表达式都可以关联五个标志：`i` 使正则表达式变为不区分大小写，`g` 匹配模式的全部实例，`m` 允许跨多行匹配，`y` 启用粘性匹配，而 `u`
    启用 Unicode 转义。标志添加在正则表达式字面量的末尾：`/test/ig`，或者作为 `RegExp` 构造函数的第二个参数：`new RegExp("test",
    "i")`。
- en: Use `[]` (as in `[abc]`) to specify a set of characters that we wish to match.
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[]`（如 `[abc]`）来指定我们希望匹配的字符集。
- en: Use `^` to signify that the pattern must appear at the beginning of a string
    and `$` to signify that the pattern must appear at the end of a string.
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `^` 来表示模式必须出现在字符串的开头，而使用 `$` 来表示模式必须出现在字符串的末尾。
- en: Use `?` to specify that a term is optional, `+` that a term should appear one
    or many times, and `*` to specify that a term appears zero, one, or many times.
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `?` 来指定一个术语是可选的，`+` 来指定一个术语应该出现一次或多次，而 `*` 来指定一个术语出现零次、一次或多次。
- en: Use `.` to match any character.
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.` 来匹配任何字符。
- en: We can use backslash (`\`) to escape special regex characters (such as `. [
    $ ^`).
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用反斜杠（`\`）来转义特殊正则表达式字符（例如：`.` `[` ` $ ` ` ^ `）。
- en: Use parentheses `()` to group multiple terms together, and pipe (`|`) to specify
    alternation.
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用括号 `()` 将多个术语组合在一起，并使用管道符（`|`）来指定交替。
- en: Portions of a string that are successfully matched against terms can be back
    referenced with a backslash followed by the number of the capture (`\1`, `\2`,
    and so on).
  id: totrans-1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功匹配术语的字符串部分可以使用反斜杠后跟捕获编号（`\1`、`\2` 等）进行反向引用。
- en: Every string has access to the `match` function, which takes in a regular expression
    and returns an array containing the entire matched string along with any matched
    captures. We can also use the `replace` function, which causes a replacement on
    pattern matches rather than on a fixed string.
  id: totrans-1281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字符串都可以访问 `match` 函数，该函数接受一个正则表达式并返回一个包含整个匹配字符串以及任何匹配捕获的数组。我们还可以使用 `replace`
    函数，该函数在模式匹配上执行替换，而不是在固定字符串上。
- en: 10.8\. Exercises
  id: totrans-1282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8. 练习
- en: '**1**'
  id: totrans-1283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-1284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In JavaScript, regular expressions can be created with which of the following?
  id: totrans-1285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，可以使用以下哪种方式创建正则表达式？
- en: ''
  id: totrans-1286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Regular expression literals
  id: totrans-1287
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式字面量
- en: The built-in `RegExp` constructor
  id: totrans-1288
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的 `RegExp` 构造函数
- en: The built-in `RegularExpression` constructor
  id: totrans-1289
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的 `RegularExpression` 构造函数
- en: '**2**'
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-1291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following is a regular expression literal?
  id: totrans-1292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个是正则表达式字面量？
- en: ''
  id: totrans-1293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`/test/`'
  id: totrans-1294
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/test/`'
- en: '`\test\`'
  id: totrans-1295
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\test\`'
- en: '`new RegExp("test");`'
  id: totrans-1296
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new RegExp("test");`'
- en: '**3**'
  id: totrans-1297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-1298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Choose the correct regular expression flags:'
  id: totrans-1299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择正确的正则表达式标志：
- en: ''
  id: totrans-1300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`/test/g`'
  id: totrans-1301
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/test/g`'
- en: '`g/test/`'
  id: totrans-1302
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`g/test/`'
- en: '`new RegExp("test", "gi");`'
  id: totrans-1303
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new RegExp("test", "gi");`'
- en: '**4**'
  id: totrans-1304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-1305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The regular expression `/def/` matches which of the following strings?
  id: totrans-1306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正则表达式 `/def/` 匹配以下哪个字符串？
- en: ''
  id: totrans-1307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of the strings `d`, `e`, `f`
  id: totrans-1308
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串 `d`、`e` 或 `f` 之一
- en: '`def`'
  id: totrans-1309
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`def`'
- en: '`de`'
  id: totrans-1310
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`de`'
- en: '**5**'
  id: totrans-1311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-1312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The regular expression `/[^abc]/` matches which of the following?
  id: totrans-1313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正则表达式 `/[^abc]/` 匹配以下哪个？
- en: ''
  id: totrans-1314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of strings `a, b, c`
  id: totrans-1315
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串 `a`、`b` 或 `c` 之一
- en: One of strings `d, e, f`
  id: totrans-1316
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串 `d`、`e` 或 `f` 之一
- en: Matches the string `ab`
  id: totrans-1317
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配字符串 `ab`
- en: '**6**'
  id: totrans-1318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**'
- en: ''
  id: totrans-1319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following regular expressions matches the string `hello`?
  id: totrans-1320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个正则表达式匹配字符串 `hello`？
- en: ''
  id: totrans-1321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`/hello/`'
  id: totrans-1322
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/hello/`'
- en: '`/hell?o/`'
  id: totrans-1323
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/hell?o/`'
- en: '`/hel*o/`'
  id: totrans-1324
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/hel*o/`'
- en: '`/[hello]/`'
  id: totrans-1325
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/[hello]/`'
- en: '**7**'
  id: totrans-1326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**'
- en: ''
  id: totrans-1327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The regular expression `/(cd)+(de)*/` matches which of the following strings?
  id: totrans-1328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正则表达式 `/(cd)+(de)*/` 匹配以下哪个字符串？
- en: ''
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`cd`'
  id: totrans-1330
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd`'
- en: '`de`'
  id: totrans-1331
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`de`'
- en: '`cdde`'
  id: totrans-1332
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cdde`'
- en: '`cdcd`'
  id: totrans-1333
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cdcd`'
- en: '`ce`'
  id: totrans-1334
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ce`'
- en: '`cdcddedede`'
  id: totrans-1335
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cdcddedede`'
- en: '**8**'
  id: totrans-1336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**8**'
- en: ''
  id: totrans-1337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In regular expressions, we can express alternatives with which of the following?
  id: totrans-1338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在正则表达式中，我们可以用以下哪种方式表示选择？
- en: ''
  id: totrans-1339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`#`'
  id: totrans-1340
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#`'
- en: '`&`'
  id: totrans-1341
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&`'
- en: '`|`'
  id: totrans-1342
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`'
- en: '**9**'
  id: totrans-1343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**9**'
- en: ''
  id: totrans-1344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the regular expression `/([0-9])2/`, we can reference the first matched digit
    with which of the following?
  id: totrans-1345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在正则表达式 `/([0-9])2/` 中，我们可以用以下哪种方式引用第一个匹配的数字？
- en: ''
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`/0`'
  id: totrans-1347
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/0`'
- en: '`/1`'
  id: totrans-1348
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/1`'
- en: '`\0`'
  id: totrans-1349
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\0`'
- en: '`\1`'
  id: totrans-1350
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\1`'
- en: '**10**'
  id: totrans-1351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**10**'
- en: ''
  id: totrans-1352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The regular expression `/([0-5])6\1/` will match which of the following?
  id: totrans-1353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正则表达式 `/([0-5])6\1/` 将匹配以下哪个？
- en: ''
  id: totrans-1354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`060`'
  id: totrans-1355
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`060`'
- en: '`16`'
  id: totrans-1356
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`16`'
- en: '`261`'
  id: totrans-1357
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`261`'
- en: '`565`'
  id: totrans-1358
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`565`'
- en: '**11**'
  id: totrans-1359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**11**'
- en: ''
  id: totrans-1360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The regular expression `/(?:ninja)-(trick)?-\1/` will match which of the following?
  id: totrans-1361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正则表达式`/(?:ninja)-(trick)?-\1/`将匹配以下哪个？
- en: ''
  id: totrans-1362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ninja-`'
  id: totrans-1363
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ninja-`'
- en: '`ninja-trick-ninja`'
  id: totrans-1364
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ninja-trick-ninja`'
- en: '`ninja-trick-trick`'
  id: totrans-1365
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ninja-trick-trick`'
- en: '**12**'
  id: totrans-1366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**12**'
- en: ''
  id: totrans-1367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the result of executing `"012675".replace(/0-5/g, "a")`?
  id: totrans-1368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行`"012675".replace(/0-5/g, "a")`的结果是什么？
- en: ''
  id: totrans-1369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`aaa67a`'
  id: totrans-1370
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aaa67a`'
- en: '`a12675`'
  id: totrans-1371
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a12675`'
- en: '`a1267a`'
  id: totrans-1372
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a1267a`'
- en: Chapter 11\. Code modularization techniques
  id: totrans-1373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. 代码模块化技术
- en: '*This chapter covers*'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using the module pattern
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块模式
- en: 'Using current standards for writing modular code: AMD and CommonJS'
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用当前编写模块化代码的标准：AMD和CommonJS
- en: Working with ES6 modules
  id: totrans-1377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与ES6模块一起工作
- en: So far we’ve explored the basic primitives of JavaScript, such as functions,
    objects, collections, and regular expressions. We have more than a couple of tools
    in our belt for solving specific problems with our JavaScript code. But as our
    applications start to grow, another whole set of problems, related to how we structure
    and manage our code, starts to emerge. Time and time again, it’s been proven that
    large, monolithic code bases are far more likely to be difficult to understand
    and maintain than smaller, well-organized ones. So it’s only natural that one
    way of improving the structure and organization of our programs is to break them
    into smaller, relatively loosely coupled segments called *modules*.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了JavaScript的基本原语，如函数、对象、集合和正则表达式。我们拥有解决JavaScript代码中特定问题的工具。但随着我们的应用程序开始增长，与如何构建和管理我们的代码相关的一系列问题开始出现。一次又一次地证明，大型、单体代码库比小型、组织良好的代码库更难理解和维护。因此，改善我们程序的结构和组织的一种方法自然是将它们分解成更小、相对松散耦合的段，称为*模块*。
- en: Modules are larger units of organizing our code than objects and functions;
    they allow us to divide programs into clusters that belong together. When creating
    modules, we should strive to form consistent abstractions and encapsulate implementation
    details. This makes it easier to reason about our application, because we aren’t
    bothered with various frivolous details when using our module functionality. In
    addition, having modules means that we can easily reuse module functionality in
    different parts of our applications, and even across different applications, significantly
    speeding up our development process.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是比对象和函数更大的代码组织单位；它们允许我们将程序划分为属于一起的集群。在创建模块时，我们应该努力形成一致的抽象并封装实现细节。这使得推理我们的应用程序变得更加容易，因为我们使用模块功能时不会被各种琐碎的细节所困扰。此外，拥有模块意味着我们可以轻松地在应用程序的不同部分以及不同的应用程序中重用模块功能，从而显著加快我们的开发过程。
- en: 'As you saw earlier in the book, JavaScript is big on global variables: Whenever
    we define a variable in mainline code, that variable is automatically considered
    global and can be accessed from any other part of our code. This might not be
    a problem for small programs, but as our applications start to grow and we include
    third-party code, the chance that naming clashes will occur starts to grow significantly.
    In most other programming languages, this problem is solved with namespaces (C++
    and C#) or packages (Java), which wrap all enclosed names in another name, thereby
    significantly reducing potential clashes.'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本书前面所见，JavaScript非常重视全局变量：只要我们在主代码中定义一个变量，该变量就会自动被视为全局变量，并且可以从代码的任何其他部分访问。对于小型程序来说，这可能不是问题，但随着我们的应用程序开始增长，并且我们包含了第三方代码，命名冲突发生的可能性开始显著增加。在大多数其他编程语言中，这个问题通过命名空间（C++和C#）或包（Java）来解决，这些命名空间或包将所有封装的名称包裹在另一个名称中，从而显著减少了潜在的冲突。
- en: Up to ES6, JavaScript didn’t offer a higher-level, built-in feature that allows
    us to group related variables in a module, namespace, or package. So in order
    to tackle this problem, JavaScript programmers have developed advanced code modularization
    techniques that take advantage of existing JavaScript constructs, such as objects,
    immediate functions, and closures. In this chapter, we’ll explore some of these
    techniques.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 到ES6为止，JavaScript没有提供更高层次的内置功能，允许我们在模块、命名空间或包中分组相关的变量。因此，为了解决这个问题，JavaScript程序员已经开发了一些高级代码模块化技术，这些技术利用了现有的JavaScript结构，如对象、立即函数和闭包。在本章中，我们将探讨这些技术中的一些。
- en: Luckily, it’s only a matter of time until we’ll be able to completely let go
    of these work-around techniques, because ES6 finally introduces native modules.
    Unfortunately, the browsers haven’t caught on, so we’ll explore how modules should
    work in ES6, even though we won’t have a specific native browser implementation
    to test them on.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们很快就能完全放弃这些权宜之计，因为 ES6 最终引入了原生模块。不幸的是，浏览器还没有跟上，所以我们将探讨在 ES6 中模块应该如何工作，尽管我们不会有一个特定的原生浏览器实现来测试它们。
- en: Let’s start with modularization techniques that we can use today.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们可以使用的模块化技术开始。
- en: Do you know?
  id: totrans-1384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-1385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-1386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What existing mechanism do you use to approximate modules in JavaScript pre-ES6?
  id: totrans-1387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你使用什么现有机制在预 ES6 的 JavaScript 中近似模块？
- en: '**Q2:**'
  id: totrans-1388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-1389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the difference between the AMD and CommonJS module specifications?
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: AMD 和 CommonJS 模块规范有什么区别？
- en: '**Q3:**'
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using ES6, what two statements would you need to use the `tryThisOut()` function
    from a module called `test` from within another module called `guineaPig`?
  id: totrans-1393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 ES6，你需要使用哪两个语句从名为 `test` 的模块中在另一个名为 `guineaPig` 的模块内调用 `tryThisOut()` 函数？
- en: 11.1\. Modularizing code in pre-ES6 JavaScript
  id: totrans-1394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 在预 ES6 的 JavaScript 中模块化代码
- en: 'Pre-ES6 JavaScript has only two types of scopes: global scope and function
    scope. It doesn’t have something in between, a namespace or a module that would
    allow us to group certain functionality together. To write modular code, JavaScript
    developers are forced to be creative with existing JavaScript language features.'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 预 ES6 的 JavaScript 只有两种作用域：全局作用域和函数作用域。它没有介于两者之间的事物，如命名空间或模块，这会允许我们将某些功能组合在一起。为了编写模块化代码，JavaScript
    开发者被迫利用现有的 JavaScript 语言特性进行创新。
- en: 'When deciding which features to use, we have to keep in mind that, at a bare
    minimum, each module system should be able to do the following:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用哪些特性时，我们必须记住，在最基本的情况下，每个模块系统应该能够做到以下事情：
- en: '*Define an interface* through which we can access the functionality offered
    by the module.'
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义一个接口*，通过该接口我们可以访问模块提供的功能。'
- en: '*Hide module internals* so that the users of our modules aren’t burdened with
    a whole host of unimportant implementation details. In addition, by hiding module
    internals, we protect those internals from the outside world, thereby preventing
    unwanted modifications that can lead to all sorts of side effects and bugs.'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隐藏模块内部细节*，这样我们的模块用户就不会被一大堆不重要的实现细节所负担。此外，通过隐藏模块内部细节，我们保护这些内部细节免受外部世界的影响，从而防止可能导致各种副作用和错误的未希望修改。'
- en: In this section, we’ll first see how to create modules by using standard JavaScript
    features that we’ve explored so far in the book, features such as objects, closures,
    and immediate functions. We’ll continue this modularization vein by exploring
    Asynchronous Module Definition (AMD) and CommonJS, the two most popular module
    specification standards, built on slightly different foundations. You’ll learn
    how to define modules using these standards, as well as their pros and cons.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先看到如何通过使用我们在本书中已经探讨过的标准 JavaScript 特性来创建模块，例如对象、闭包和立即函数。我们将继续探索异步模块定义（AMD）和
    CommonJS，这两种最流行的模块规范标准，它们建立在略微不同的基础上。您将学习如何使用这些标准来定义模块，以及它们的优缺点。
- en: But let’s start with something for which we’ve already set the stage in previous
    chapters.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从在前几章中已经设定了基础的内容开始。
- en: 11.1.1\. Using objects, closures, and immediate functions to specify modules
  id: totrans-1401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1\. 使用对象、闭包和立即函数来指定模块
- en: 'Let’s go back to our minimal module system requirements, *hiding implementation
    details* and *defining module interfaces*. Now think about which JavaScript language
    features we can take advantage of in order to implement these minimal requirements:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们最小的模块系统要求，*隐藏实现细节*和*定义模块接口*。现在考虑一下我们可以利用哪些 JavaScript 语言特性来实现这些最小要求：
- en: '***Hiding module internals—*** As we already know, calling a JavaScript function
    creates a new scope in which we can define variables that are visible only within
    the current function. So, one option for hiding module internals is using functions
    as modules. In this way, all function variables become internal module variables
    that are hidden from the outside world.'
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***隐藏模块内部——*** 如我们所知，调用 JavaScript 函数会在其中创建一个新的作用域，我们可以在其中定义仅在当前函数中可见的变量。因此，隐藏模块内部的一个选项是使用函数作为模块。这样，所有函数变量都成为内部模块变量，对外部世界隐藏。'
- en: '***Defining module interfaces—*** Implementing module internals through function
    variables means that those variables are accessible from only within the module.
    But if our modules are to be used from other code, we have to be able to define
    a clean interface through which we can expose the functionality offered by the
    module. One way of achieving this is by taking advantage of objects and closures.
    The idea is that, from our function module, we return an object that represents
    the public interface of our module. That object should contain methods offered
    by the module, methods that will, through closures, keep alive our internal module
    variables, even after our module function has finished its execution.'
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***定义模块接口—*** 通过函数变量实现模块内部意味着这些变量只能从模块内部访问。但如果我们希望模块能被其他代码使用，我们必须能够定义一个干净的接口，通过这个接口我们可以暴露模块提供的功能。实现这一目标的一种方法是通过利用对象和闭包。想法是，从我们的函数模块中，我们返回一个代表我们模块公共接口的对象。这个对象应该包含模块提供的方法，这些方法将通过闭包保持我们的内部模块变量活跃，即使我们的模块函数执行完毕后也是如此。'
- en: Now that we’ve given a high-level description of how to implement modules in
    JavaScript, let’s go through it slowly, step by step, starting with using functions
    for hiding module internals.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经给出了如何在 JavaScript 中实现模块的高级描述，让我们一步一步地慢慢来，从使用函数来隐藏模块内部开始。
- en: Functions as modules
  id: totrans-1406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数作为模块
- en: 'Calling a function creates a new scope that we can use to define variables
    that won’t be visible from outside the current function. Let’s take a look at
    the following code snippet that counts the number of clicks on a web page:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数会创建一个新的作用域，我们可以在这个作用域中定义变量，这些变量在当前函数外部是不可见的。让我们看一下以下代码片段，它计算网页上的点击次数：
- en: '![](285fig01_alt.jpg)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
  zh: '![](285fig01_alt.jpg)'
- en: 'In this example, we create a function called `countClicks` that creates a variable
    `numClicks` and registers a click event handler on the entire document. Whenever
    a click is made, the `numClicks` variable gets incremented and the result is displayed
    to the user via an alert box. There are two important things to notice here:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `countClicks` 的函数，它创建了一个变量 `numClicks` 并在整个文档上注册了一个点击事件处理程序。每当点击发生时，`numClicks`
    变量会增加，并通过一个警告框将结果显示给用户。这里有两个重要的事情需要注意：
- en: The `numClicks` variable, internal to the `countClicks` function, is kept alive
    through the closure of the click handler function. The variable can be referenced
    only within the handler, and *nowhere else*! We’ve shielded the `numClicks` variable
    from the code outside the `countClicks` function. At the same time, we haven’t
    polluted the global namespace of our program with a variable that’s probably not
    that important for the rest of our code.
  id: totrans-1410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numClicks` 变量，是 `countClicks` 函数内部的，通过点击处理函数的闭包保持活跃。这个变量只能在处理程序中引用，*其他任何地方都不能引用*！我们已经将
    `numClicks` 变量从 `countClicks` 函数外部的代码中屏蔽。同时，我们也没有将一个可能对我们代码的其他部分不是那么重要的变量污染到我们的程序的全局命名空间中。'
- en: Our `countClicks` function is called only in this one place, so instead of defining
    a function and then calling it in a separate statement, we’ve used an immediate
    function, or an IIFE (presented in [chapter 3](kindle_split_014.html#ch03)), to
    define and immediately invoke the `countClicks` function.
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `countClicks` 函数只在这个地方被调用，因此我们不是定义一个函数然后在单独的语句中调用它，而是使用立即执行函数，或者称为 IIFE（在第
    3 章中介绍），来定义并立即调用 `countClicks` 函数。
- en: We can also take a look at the current application state, with respect to how
    our internal function (or module) variable is kept alive through closures, as
    shown in [figure 11.1](#ch11fig01).
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看当前应用程序的状态，特别是我们的内部函数（或模块）变量如何通过闭包保持活跃，如图 11.1 所示。
- en: Figure 11.1\. The click event handler, through closures, keeps alive the local
    `numClicks` variable.
  id: totrans-1413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. 点击事件处理程序，通过闭包，使局部 `numClicks` 变量保持活跃。
- en: '![](11fig01_alt.jpg)'
  id: totrans-1414
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig01_alt.jpg)'
- en: 'Now that we understand how to hide internal module details, and how closures
    can keep those internal details alive as long as necessary, let’s move on to our
    second minimal requirement for modules: defining module interfaces.'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何隐藏内部模块细节，以及闭包如何使这些内部细节在必要时保持活跃，让我们继续到模块的第二个最小要求：定义模块接口。
- en: 'The module pattern: augmenting functions as modules with objects as interfaces'
  id: totrans-1416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模块模式：将函数作为模块，以对象作为接口增强
- en: The module interface is usually composed of a set of variables and functions
    that our module provides to the outside world. The easiest way to create such
    an interface is to use the humble JavaScript object.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 模块接口通常由一组变量和函数组成，我们的模块将这些变量和函数提供给外部世界。创建此类接口的最简单方法就是使用谦逊的JavaScript对象。
- en: For example, let’s create an interface for our module that counts the clicks
    on our web page, as shown in the following listing.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们为我们的模块创建一个接口，该接口用于计算网页上的点击次数，如下面的列表所示。
- en: Listing 11.1\. The module pattern
  id: totrans-1419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 模块模式
- en: '![](286fig01_alt.jpg)'
  id: totrans-1420
  prefs: []
  type: TYPE_IMG
  zh: '![286fig01_alt.jpg]'
- en: 'Here we use an immediate function to implement a module. Within the immediate
    function, we define our internal module implementation details: one local variable,
    `numClicks`, and one local function, `handleClick`, that are accessible only within
    the module. Next we create and immediately return an object that will serve as
    the module’s “public interface.” This interface contains a `countClicks` method
    that we can use from outside the module to access module functionality.'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用立即函数来实现一个模块。在立即函数内部，我们定义我们的内部模块实现细节：一个局部变量`numClicks`和一个局部函数`handleClick`，这些变量和函数只能在模块内部访问。接下来，我们创建并立即返回一个对象，该对象将作为模块的“公共接口”。这个接口包含一个`countClicks`方法，我们可以从模块外部使用这个方法来访问模块功能。
- en: At the same time, because we’ve exposed a module interface, our internal module
    details are kept alive through closures created by the interface. For example,
    in this case, the `countClicks` method of the interface keeps alive internal module
    variables `numClicks` and `handleClick`, as shown in [figure 11.2](#ch11fig02).
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，因为我们已经公开了模块接口，我们的内部模块细节通过接口创建的闭包保持活跃。例如，在这种情况下，接口的`countClicks`方法保持了内部模块变量`numClicks`和`handleClick`的活跃状态，如图11.2所示。
- en: Figure 11.2\. Expose the public interface of a module through a returned object.
    The internal module implementation (“private” variables and functions) is kept
    alive through closures created by public interface methods.
  id: totrans-1423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2\. 通过返回的对象公开模块的公共接口。内部模块实现（“私有”变量和函数）通过公共接口方法创建的闭包保持活跃。
- en: '![](11fig02_alt.jpg)'
  id: totrans-1424
  prefs: []
  type: TYPE_IMG
  zh: '![11fig02_alt.jpg]'
- en: 'Finally, we store the object that represents the module interface, returned
    by the immediate function, into a variable named `MouseCounterModule`, through
    which we can easily consume module functionality, by writing the following code:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将立即函数返回的表示模块接口的对象存储在一个名为`MouseCounterModule`的变量中，通过这个变量我们可以轻松地使用模块功能，如下面的代码所示：
- en: '[PRE130]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: And that’s basically it.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是全部内容。
- en: By taking advantage of immediate functions, we can hide certain module implementation
    details. Then by adding objects and closures into the mix, we can specify a module
    interface that exposes the functionality provided by our module to the outside
    world.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用立即函数，我们可以隐藏某些模块实现细节。然后通过添加对象和闭包，我们可以指定一个模块接口，将我们的模块提供的功能暴露给外部世界。
- en: This pattern of using immediate functions, objects, and closures to create modules
    in JavaScript is called the *module pattern*. It was popularized by Douglas Crockford,
    and was one of the first massively popular ways of modularizing JavaScript code.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立即函数、对象和闭包在JavaScript中创建模块的模式称为*模块模式*。它由Douglas Crockford推广，是第一种广泛流行的JavaScript代码模块化方式。
- en: Once we have the ability to define modules, it’s always nice to be able to split
    them across multiple files (in order to more easily manage them), or to be able
    to define additional functionality on existing modules, without modifying their
    source code.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了定义模块的能力，总是很乐意能够将它们拆分到多个文件中（以便更容易管理），或者能够在不修改其源代码的情况下，在现有模块上定义额外的功能。
- en: Let’s see how this can be done.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何实现的。
- en: Augmenting modules
  id: totrans-1432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 增强模块
- en: Let’s augment our `MouseCounterModule` from the previous example with an additional
    feature of counting the number of mouse scrolls, but without modifying the original
    `MouseCounterModule` code. See the following listing.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强前一个例子中的`MouseCounterModule`，添加一个额外的功能，即计算鼠标滚动的次数，而不修改原始的`MouseCounterModule`代码。请参见以下列表。
- en: Listing 11.2\. Augmenting modules
  id: totrans-1434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. 增强模块
- en: '![](ch11ex02-0.jpg)'
  id: totrans-1435
  prefs: []
  type: TYPE_IMG
  zh: '![ch11ex02-0.jpg]'
- en: '![](ch11ex02-1.jpg)'
  id: totrans-1436
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2](#ch11fig02)'
- en: 'When augmenting a module, we usually follow a procedure similar to creating
    a new module. We immediately call a function, but this time, we pass to it the
    module we want to extend as an argument:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 当增强一个模块时，我们通常遵循一个类似于创建新模块的程序。我们立即调用一个函数，但这次，我们将要扩展的模块作为参数传递给它：
- en: '[PRE131]'
  id: totrans-1438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Within the function, we then go about our work and create all the necessary
    private variables and functions. In this case, we’ve defined a private variable
    and a private function for counting and reporting the number of scrolls:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们继续进行我们的工作并创建所有必要的私有变量和函数。在这种情况下，我们定义了一个用于计数和报告滚动次数的私有变量和私有函数：
- en: '[PRE132]'
  id: totrans-1440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Finally, we extend our module, available through the immediate function’s `module`
    parameter, just as we would extend any other object:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过立即函数的 `module` 参数扩展我们的模块，就像我们扩展任何其他对象一样：
- en: '[PRE133]'
  id: totrans-1442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: After we’ve performed this simple operation, our `MouseCounterModule` can also
    `countScrolls`.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这个简单的操作之后，我们的 `MouseCounterModule` 也可以 `countScrolls`。
- en: 'Our public module interface now has two methods, and we can use the module
    in the following ways:'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公开的模块接口现在有两个方法，我们可以以下方式使用模块：
- en: '![](288fig01_alt.jpg)'
  id: totrans-1445
  prefs: []
  type: TYPE_IMG
  zh: '![](288fig01_alt.jpg)'
- en: As we’ve already mentioned, we’ve extended the module in a way that’s similar
    to the creation of a new module, through an immediately invoked function that
    extends the module. This has some interesting side effects in terms of closures,
    so let’s take a closer look at the application state after we’ve augmented the
    module, as shown in [figure 11.3](#ch11fig03).
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，我们通过立即调用的函数扩展模块，这种方式类似于创建一个新的模块。这在闭包方面有一些有趣的副作用，所以让我们在增强模块后更仔细地看看应用状态，如图
    11.3 所示。
- en: Figure 11.3\. When augmenting a module, we extend its external interface with
    new functionality, usually by passing the module to another immediate function.
    In this example, we add the ability to `countScrolls` to our MouseCounterModule.
    Notice that two separate functions are defined in different environments, and
    they can’t access each other’s internal variables.
  id: totrans-1447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.3。当我们增强一个模块时，我们通过将模块传递给另一个立即函数来扩展其外部接口以添加新功能。在这个例子中，我们向我们的 MouseCounterModule
    添加了 `countScrolls` 的能力。请注意，两个不同的函数在不同的环境中定义，它们无法访问彼此的内部变量。
- en: '![](11fig03_alt.jpg)'
  id: totrans-1448
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig03_alt.jpg)'
- en: 'If you look closely, [figure 11.3](#ch11fig03) also shows one of the shortcomings
    of the module pattern: the inability to share private module variables across
    module extensions. For example, the `countClicks` function keeps a closure around
    the `numClicks` and `handleClick` variables, and we could access these private
    module internals through the `countClicks` method.'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，图 11.3 还显示了模块模式的一个缺点：无法在模块扩展之间共享私有模块变量。例如，`countClicks` 函数围绕 `numClicks`
    和 `handleClick` 变量保持闭包，我们可以通过 `countClicks` 方法访问这些私有模块内部。
- en: 'Unfortunately, our extension, the `countScrolls` function, is created in a
    completely separate scope, with a completely new set of private variables: `numScrolls`
    and `handleScroll`. The `countScrolls` function creates a closure only around
    `numScrolls` and `handleScroll` variables, and therefore can’t access the `numClicks`
    and `handleClick` variables.'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的扩展，即 `countScrolls` 函数，是在一个完全独立的范围内创建的，具有一组全新的私有变量：`numScrolls` 和 `handleScroll`。`countScrolls`
    函数只围绕 `numScrolls` 和 `handleScroll` 变量创建闭包，因此无法访问 `numClicks` 和 `handleClick`
    变量。
- en: '|  |'
  id: totrans-1451
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Module extensions, when performed through separate immediate functions, can’t
    share private module internals, because every function invocation creates a new
    scope. Although this is a shortcoming, it’s not a showstopper, and we can still
    use the module pattern to keep our JavaScript applications modular.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过单独的立即函数执行模块扩展时，模块扩展无法共享私有模块内部，因为每次函数调用都会创建一个新的作用域。尽管这是一个缺点，但它并不是一个致命缺陷，我们仍然可以使用模块模式来保持我们的
    JavaScript 应用程序模块化。
- en: '|  |'
  id: totrans-1454
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Note that, in the module pattern, modules are objects just like any other,
    and we can extend them in any way we find appropriate. For example, we can add
    new functionality by extending the module object with new properties:'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模块模式中，模块就像任何其他对象一样是对象，我们可以以任何我们认为合适的方式扩展它们。例如，我们可以通过向模块对象添加新属性来添加新功能：
- en: '[PRE134]'
  id: totrans-1456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We can also use the same principle to easily create submodules:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用相同的原理轻松创建子模块：
- en: '[PRE135]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Notice that all of these approaches suffer from the same fundamental shortcoming
    of the module pattern: Subsequent extensions of the module can’t access previously
    defined internal module details.'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些方法都受到模块模式相同的基本缺陷的影响：模块的后续扩展无法访问先前定义的内部模块细节。
- en: Unfortunately, there are more problems with the module pattern. When we start
    building modular applications, the modules themselves will often depend on other
    modules for their functionality. Unfortunately, the module pattern doesn’t cover
    the management of these dependencies. We, as developers, have to take care of
    the right dependency order so that our module code has all it needs to execute.
    Although this isn’t a problem in small and medium applications, it can introduce
    serious issues in large applications that use a lot of interdependent modules.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，模块模式还存在更多问题。当我们开始构建模块化应用程序时，模块本身通常会依赖于其他模块来实现其功能。不幸的是，模块模式并没有涵盖这些依赖的管理。作为开发者，我们必须注意正确的依赖顺序，以确保我们的模块代码拥有执行所需的一切。尽管这在小型和中型应用程序中不是问题，但它可能会在大量使用相互依赖模块的大型应用程序中引入严重问题。
- en: To deal with these issues, a couple of competing standards have arisen, namely
    Asynchronous Module Definition (AMD) and CommonJS.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些问题，出现了一些相互竞争的标准，即异步模块定义（AMD）和 CommonJS。
- en: 11.1.2\. Modularizing JavaScript applications with AMD and CommonJS
  id: totrans-1462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 使用 AMD 和 CommonJS 模块化 JavaScript 应用程序
- en: AMD and CommonJS are competing module specification standards that allow us
    to specify JavaScript modules. Besides some differences in syntax and philosophy,
    the main difference is that AMD was designed explicitly with the browser in mind,
    whereas CommonJS was designed for a general-purpose JavaScript environment (such
    as servers, with Node.js), without being bound to the limitations of the browser.
    This section provides a relatively short overview of these module specifications;
    setting them up and including them in your projects is beyond the scope of this
    book. For more information, we recommend *JavaScript Application Design* by Nicolas
    G. Bevacqua (Manning, 2015).
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 和 CommonJS 是相互竞争的模块规范标准，允许我们指定 JavaScript 模块。除了语法和哲学上的某些差异外，主要区别在于 AMD 是专门针对浏览器设计的，而
    CommonJS 是为通用 JavaScript 环境设计的（例如服务器，使用 Node.js），而不受浏览器限制。本节提供了一个相对简短的模块规范概述；设置它们并将它们包含在项目中超出了本书的范围。有关更多信息，我们推荐
    Nicolas G. Bevacqua 的《JavaScript 应用程序设计》（Manning，2015年）。
- en: AMD
  id: totrans-1464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AMD
- en: AMD grew out of the Dojo toolkit ([https://dojotoolkit.org/](https://dojotoolkit.org/)),
    one of the popular JavaScript toolkits for building client-side web applications.
    AMD allows us to easily specify modules and their dependencies. At the same time,
    it was built from the ground up for the browser. Currently, the most popular AMD
    implementation is RequireJS ([http://requirejs.org/](http://requirejs.org/)).
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 诞生于 Dojo 工具包（[https://dojotoolkit.org/](https://dojotoolkit.org/)），这是构建客户端
    Web 应用程序中流行的 JavaScript 工具包之一。AMD 允许我们轻松指定模块及其依赖项。同时，它是从零开始为浏览器构建的。目前，最受欢迎的 AMD
    实现是 RequireJS（[http://requirejs.org/](http://requirejs.org/)）。
- en: Let’s see an example of defining a small module that has a dependency to jQuery.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个定义小型模块的例子，该模块依赖于 jQuery。
- en: Listing 11.3\. Using AMD to specify a module dependent on jQuery
  id: totrans-1467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 使用 AMD 指定依赖于 jQuery 的模块
- en: '![](291fig01_alt.jpg)'
  id: totrans-1468
  prefs: []
  type: TYPE_IMG
  zh: '![](291fig01_alt.jpg)'
- en: 'AMD provides a function called `define` that accepts the following:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: AMD 提供了一个名为 `define` 的函数，它接受以下内容：
- en: The ID of the newly created module. This ID can later be used to require the
    module from other parts of our system.
  id: totrans-1470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新创建模块的 ID。这个 ID 可以在以后从我们系统的其他部分调用该模块时使用。
- en: A list of module IDs on which our current module depends (the required modules).
  id: totrans-1471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们当前模块所依赖的模块 ID 列表（所需的模块）。
- en: A factory function that will initialize the module and that accepts the required
    modules as arguments.
  id: totrans-1472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化模块的工厂函数，它接受所需的模块作为参数。
- en: 'In this example, we use AMD’s `define` function to create a module with an
    ID `MouseCounterModule` that depends on jQuery. Because of this dependency, AMD
    first requests the jQuery module, which can take some time if the file has to
    be requested from a server. This action is performed asynchronously, in order
    to avoid blocking. After all dependencies have been downloaded and evaluated,
    the module factory function is called with one argument for each requested module.
    In this case, there will be one argument, because our new module requires only
    jQuery. Within the factory function, we create our module just as we would with
    the standard module pattern: by returning an object that exposes the public interface
    of the module.'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用AMD的`define`函数创建一个ID为`MouseCounterModule`的模块，该模块依赖于jQuery。由于这个依赖关系，AMD首先请求jQuery模块，如果文件需要从服务器请求，这可能需要一些时间。这个操作是异步执行的，以避免阻塞。在所有依赖项都下载并评估完毕后，模块工厂函数被调用，每个请求的模块都有一个参数。在这种情况下，将有一个参数，因为我们的新模块只需要jQuery。在工厂函数内部，我们创建我们的模块，就像使用标准模块模式一样：通过返回一个对象来公开模块的公共接口。
- en: 'As you can see, AMD offers several interesting benefits, such as these:'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，AMD提供了几个有趣的好处，例如这些：
- en: Automatic resolving of dependencies, so that we don’t have to think about the
    order in which we include our modules.
  id: totrans-1475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动解析依赖关系，这样我们就不必考虑我们包含模块的顺序。
- en: Modules can by asynchronously loaded, thereby avoiding blocking.
  id: totrans-1476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以异步加载，从而避免阻塞。
- en: Multiple modules can be defined within one file.
  id: totrans-1477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文件中可以定义多个模块。
- en: Now that you have the basic idea of how AMD works, let’s take a look at another,
    massively popular module definition standard.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了AMD的基本工作原理，让我们来看看另一个广泛流行的模块定义标准。
- en: CommonJS
  id: totrans-1479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CommonJS
- en: Whereas AMD was built explicitly for the browser, CommonJS is a module specification
    designed for a general-purpose JavaScript environment. Currently it has the biggest
    following in the Node.js community.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 与AMD专为浏览器构建不同，CommonJS是一个为通用JavaScript环境设计的模块规范。目前它在Node.js社区中拥有最多的追随者。
- en: CommonJS uses file-based modules, so we can specify one module per file. To
    each module, CommonJS exposes a variable, `module`, with a property, `exports`,
    which we can easily extend with additional properties. In the end, the content
    of `module.exports` is exposed as the module’s public interface.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS使用基于文件的模块，因此我们可以为每个文件指定一个模块。对于每个模块，CommonJS公开一个变量`module`，它有一个属性`exports`，我们可以通过添加额外的属性轻松扩展它。最终，`module.exports`的内容被公开为模块的公共接口。
- en: If we want to use a module from other parts of the application, we can require
    it. The file will be synchronously loaded, and we’ll have access to its public
    interface. This is the reason that CommonJS is much more popular on the server,
    where module fetching is relatively quick because it requires only a file-system
    read, than on the client, where the module has to be downloaded from a remote
    server, and where synchronous loading usually means blocking.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在应用程序的其他部分使用一个模块，我们可以使用`require`来引用它。文件将以同步方式加载，我们将能够访问其公共接口。这也是为什么CommonJS在服务器上比客户端更受欢迎的原因，在服务器上模块检索相对较快，因为它只需要文件系统读取，而在客户端，模块需要从远程服务器下载，并且同步加载通常意味着阻塞。
- en: Let’s look at an example that defines our reoccurring `MouseCounterModule`,
    this time in CommonJS.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，这个例子定义了我们的重复使用的`MouseCounterModule`，这次是在CommonJS中。
- en: Listing 11.4\. Using CommonJS to define a module
  id: totrans-1484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.4\. 使用CommonJS定义一个模块
- en: '![](292fig01_alt.jpg)'
  id: totrans-1485
  prefs: []
  type: TYPE_IMG
  zh: '![](292fig01_alt.jpg)'
- en: 'To include our module within a different file, we can write this:'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一个文件中包含我们的模块，我们可以这样写：
- en: '[PRE136]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: See how simple this is?
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这是多么简单？
- en: Because the philosophy of CommonJS dictates one module per file, any code that
    we put in a file module will be a part of that module. Therefore, there’s no need
    for wrapping variables up in immediate functions. All variables defined within
    a module are safely contained within the scope of the current module and don’t
    leak out to the global scope. For example, all three of our module variables (`$`,
    `numClicks`, and `handleClick`) are module scoped, even though they’re defined
    in top-level code (outside all functions and blocks), which would technically
    make them global variables in standard JavaScript files.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CommonJS 的哲学是每个文件一个模块，因此我们放入文件模块中的任何代码都将成为该模块的一部分。因此，没有必要将变量包裹在立即执行函数中。模块内部定义的所有变量都安全地包含在当前模块的作用域内，不会泄漏到全局作用域。例如，我们所有的模块变量（`$`、`numClicks`
    和 `handleClick`）都是模块作用域的，即使它们是在顶层代码中定义的（在所有函数和块之外），这在技术上会使它们成为标准 JavaScript 文件中的全局变量。
- en: Once again, it’s important to note that only variables and functions exposed
    through the `module.exports` object are available from outside the module. The
    procedure is similar to the module pattern, only instead of returning a completely
    new object, the environment already provides one that we can extend with our interface
    methods and properties.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，需要注意的是，只有通过 `module.exports` 对象暴露的变量和函数才能从模块外部访问。这个过程与模块模式类似，只是我们不是返回一个全新的对象，而是环境已经提供了一个，我们可以通过我们的接口方法和属性来扩展它。
- en: 'CommonJS has a couple of advantages:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 有几个优点：
- en: It has simple syntax. We need to specify only the `module.exports` properties,
    while the rest of the module code stays pretty much the same as if we were writing
    standard JavaScript. Requiring modules is also simple; we just use the `require`
    function.
  id: totrans-1492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有简单的语法。我们只需要指定 `module.exports` 属性，而模块代码的其余部分基本上与如果我们编写标准 JavaScript 一样。引入模块也很简单；我们只需使用
    `require` 函数。
- en: CommonJS is the default module format for Node.js, so we have access to thousands
    of packages that are available through npm, node’s package manager.
  id: totrans-1493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 是 Node.js 的默认模块格式，因此我们可以通过 npm（node 的包管理器）访问成千上万的可用包。
- en: CommonJS’s biggest disadvantage is that it wasn’t explicitly built with the
    browser in mind. Within JavaScript in the browser, there’s no support for the
    `module` variable and the `export` property; we have to package our CommonJS modules
    into a browser-readable format. We can achieve this with either Browserify ([http://browserify.org/](http://browserify.org/))
    or RequireJS ([http://requirejs.org/docs/commonjs.html](http://requirejs.org/docs/commonjs.html)).
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 的最大缺点是它没有明确地考虑到浏览器。在浏览器中的 JavaScript，没有对 `module` 变量和 `export` 属性的支持；我们必须将我们的
    CommonJS 模块打包成浏览器可读的格式。我们可以通过 Browserify ([http://browserify.org/](http://browserify.org/))
    或 RequireJS ([http://requirejs.org/docs/commonjs.html](http://requirejs.org/docs/commonjs.html))
    来实现这一点。
- en: Having two competing standards for specifying modules, AMD and CommonJS, has
    led to one of those situations in which people tend to divide themselves into
    two, sometimes even opposing, camps. If you work on relatively closed projects,
    this might not be an issue; you choose the standard that suits you better. Problems
    can arise, however, when we need to reuse code from the opposing camp and are
    forced to jump through all sorts of hoops. One solution is to use Universal Module
    Definition, or UMD ([https://github.com/umdjs/umd](https://github.com/umdjs/umd)),
    a pattern with a somewhat convoluted syntax that allows the same file to be used
    by both AMD and CommonJS. This is beyond the scope of this book, but if you’re
    interested, many quality resources are available online.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在两个用于指定模块的竞争标准，AMD 和 CommonJS，这导致了人们倾向于分成两个，有时甚至是对立的阵营。如果你在相对封闭的项目上工作，这可能不是问题；你可以选择更适合你的标准。然而，当我们需要从对立阵营重用代码并被迫跳过各种障碍时，可能会出现问题。一种解决方案是使用通用模块定义（UMD），[https://github.com/umdjs/umd](https://github.com/umdjs/umd)，这是一种语法有些复杂的模式，允许同一文件同时被
    AMD 和 CommonJS 使用。这超出了本书的范围，但如果你对它感兴趣，网上有许多优质资源。
- en: Luckily, the ECMAScript committee has recognized the need for a unified module
    syntax supported in all JavaScript environments, so ES6 defines a new module standard
    that should finally put these differences to rest.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ECMAScript 委员会已经认识到在所有 JavaScript 环境中支持统一模块语法的必要性，因此 ES6 定义了一个新的模块标准，这应该最终结束这些差异。
- en: 11.2\. ES6 modules
  id: totrans-1497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. ES6 模块
- en: 'ES6 modules are designed to marry the advantages of CommonJS and AMD:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块旨在结合 CommonJS 和 AMD 的优点：
- en: Similar to CommonJS, ES6 modules have a relatively simple syntax, and ES6 modules
    are file based (one module per file).
  id: totrans-1499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与CommonJS类似，ES6模块具有相对简单的语法，ES6模块是基于文件的（每个文件一个模块）。
- en: Similar to AMD, ES6 modules provide support for asynchronous module loading.
  id: totrans-1500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与AMD类似，ES6模块提供了对异步模块加载的支持。
- en: '|  |'
  id: totrans-1501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Built-in modules are a part of the ES6 standard. As you’ll soon see, the ES6
    module syntax includes additional semantics and keywords (such as the `export`
    and `import` keywords) that aren’t supported by current browsers. If we want to
    use modules today, we have to transpile our module code with Traceur ([https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler)),
    Babel ([http://babeljs.io/](http://babeljs.io/)), or TypeScript ([www.typescriptlang.org/](http://www.typescriptlang.org/)).
    We also can use the SystemJS library ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)),
    which provides support for loading all currently available module standards: AMD,
    CommonJS, and even ES6 modules. You can find instructions on how to use SystemJS
    in the project’s repository ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)).'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 内置模块是ES6标准的一部分。正如你很快就会看到的，ES6模块语法包括一些额外的语义和关键字（如`export`和`import`关键字），这些关键字当前浏览器不支持。如果我们想今天使用模块，我们必须使用Traceur
    ([https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler))、Babel
    ([http://babeljs.io/](http://babeljs.io/))或TypeScript ([www.typescriptlang.org/](http://www.typescriptlang.org/))将我们的模块代码进行转译。我们还可以使用SystemJS库
    ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs))，它提供了对所有当前可用的模块标准的支持：AMD、CommonJS，甚至是ES6模块。你可以在项目的存储库中找到如何使用SystemJS的说明
    ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs))。
- en: '|  |'
  id: totrans-1504
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The main idea behind ES6 modules is that only the identifiers explicitly exported
    from a module are accessible from outside that module. All other identifiers,
    even the ones defined in top-level scope (what would be global scope in standard
    JavaScript), are accessible only from within the module. This was inspired by
    CommonJS.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块背后的主要思想是，只有从模块中显式导出的标识符才能从模块外部访问。所有其他标识符，即使在顶级作用域（在标准JavaScript中将是全局作用域）中定义的，也只可以在模块内部访问。这受到了CommonJS的启发。
- en: 'To provide this functionality, ES6 introduces two new keywords:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这种功能，ES6引入了两个新的关键字：
- en: '`export`—For making certain identifiers available from outside the module'
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export`——用于使某些标识符从模块外部可用'
- en: '`import`—For importing exported module identifiers'
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`——用于导入导出的模块标识符'
- en: The syntax for exporting and importing module functionality is simple, but it
    has a lot of subtle nuances that we’ll explore slowly, step by step.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 导出和导入模块功能的语法很简单，但它有很多细微的差别，我们将逐步探索。
- en: 11.2.1\. Exporting and importing functionality
  id: totrans-1510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 导出和导入功能
- en: Let’s start with a simple example that shows how to export functionality from
    one module and import it into another.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，展示如何从一个模块导出功能并将其导入到另一个模块中。
- en: Listing 11.5\. Exporting from a Ninja.js module
  id: totrans-1512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 从Ninja.js模块导出
- en: '![](294fig01_alt.jpg)'
  id: totrans-1513
  prefs: []
  type: TYPE_IMG
  zh: '![](294fig01_alt.jpg)'
- en: We first define a variable, `ninja`, a module variable that will be accessible
    only within this module, even though it’s placed in top-level code (which would
    make it a global variable in pre-ES6 code).
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个变量，`ninja`，这是一个模块变量，它只在本模块内部可访问，即使它放在顶级代码中（在ES6之前的代码中这将使其成为全局变量）。
- en: Next, we define another top-level variable, `message`, which we make accessible
    from outside the module by using the new `export` keyword. Finally, we also create
    and export the `sayHiToNinja` function.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义另一个顶级变量，`message`，通过使用新的`export`关键字，使其可以从模块外部访问。最后，我们还创建并导出了`sayHiToNinja`函数。
- en: And that’s it! This is the minimum syntax we need to know for defining our own
    modules. We don’t have to use immediate functions or remember any esoteric syntax
    in order to export functionality from a module. We write our code as we would
    write standard JavaScript code, with the only difference that we prefix some of
    the identifiers (such as variables, functions, or classes) with an `export` keyword.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这是我们定义自己的模块所需了解的最基本的语法。我们不需要使用立即执行函数或记住任何晦涩的语法，以便从模块中导出功能。我们编写代码的方式就像编写标准的JavaScript代码一样，唯一的区别是我们使用`export`关键字作为一些标识符（如变量、函数或类）的前缀。
- en: 'Before learning how to import this exported functionality, we’ll take a look
    at an alternative way to export identifiers: We list everything we want to export
    at the end of the module, as shown in the following listing.'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何导入这种导出功能之前，我们将看看另一种导出标识符的方法：我们在模块的末尾列出我们想要导出的所有内容，如下面的列表所示。
- en: Listing 11.6\. Exporting at the end of a module
  id: totrans-1518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 在模块末尾导出
- en: '![](295fig01_alt.jpg)'
  id: totrans-1519
  prefs: []
  type: TYPE_IMG
  zh: '![](295fig01_alt.jpg)'
- en: This way of exporting module identifiers bears some resemblance to the module
    pattern, as an immediate function returns an object that represents the public
    interface of our module, and especially to CommonJS, as we expand the `module.exports`
    object with the public module interface.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导出模块标识符的方式与模块模式有些相似，因为立即函数返回一个表示我们模块公共接口的对象，特别是与 CommonJS 相似，因为我们通过公共模块接口扩展了
    `module.exports` 对象。
- en: Regardless of how we’ve exported identifiers of a certain module, if we need
    to import them into another module, we have to use the `import` keyword, as in
    the following example.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何导出某个模块的标识符，如果我们需要将它们导入到另一个模块中，我们必须使用 `import` 关键字，如下面的示例所示。
- en: Listing 11.7\. Importing from the Ninja.js module
  id: totrans-1522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 从 Ninja.js 模块导入
- en: '![](295fig02_alt.jpg)'
  id: totrans-1523
  prefs: []
  type: TYPE_IMG
  zh: '![](295fig02_alt.jpg)'
- en: 'We use the new `import` keyword to import a variable, `message` and a function,
    `sayHiToNinja` from the `ninja` module:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新的 `import` 关键字从 `ninja` 模块中导入一个变量 `message` 和一个函数 `sayHiToNinja`：
- en: '[PRE137]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'By doing this, we’ve gained access to these two identifiers defined in the
    `ninja` module. Finally, we can test that we can access the `message` variable
    and call the `sayHiToNinja` function:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们获得了访问在 `ninja` 模块中定义的这两个标识符的权限。最后，我们可以测试我们是否可以访问 `message` 变量和调用 `sayHiToNinja`
    函数：
- en: '[PRE138]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'What we can’t do is access the nonexported and nonimported variables. For example,
    we can’t access the `ninja` variable because it isn’t marked with `export`:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法访问未导出和未导入的变量。例如，我们无法访问 `ninja` 变量，因为它没有标记为 `export`：
- en: '[PRE139]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: With modules, we’re finally a bit safer from the misuse of global variables.
    Everything that we didn’t explicitly mark for export stays nicely isolated within
    a module.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块，我们最终可以更安全地避免全局变量的误用。我们没有明确标记为导出的所有内容都很好地隔离在模块内部。
- en: In this example, we’ve used a *named export*, which enables us to export multiple
    identifiers from a module (as we did with `message` and `sayHiToNinja`). Because
    we can export a large number of identifiers, listing them all in an import statement
    can be tedious. Therefore, a shorthand notation enables us to bring in all exported
    identifiers from a module, as shown in the following listing.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 *命名导出*，这使得我们可以从一个模块中导出多个标识符（就像我们使用 `message` 和 `sayHiToNinja` 一样）。由于我们可以导出大量标识符，将它们全部列在导入语句中可能会很繁琐。因此，一种简写符号使我们能够将模块中所有导出的标识符导入进来，如下面的列表所示。
- en: Listing 11.8\. Importing all named exports from the Ninja.js module
  id: totrans-1532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 从 Ninja.js 模块导入所有命名导出
- en: '![](296fig01_alt.jpg)'
  id: totrans-1533
  prefs: []
  type: TYPE_IMG
  zh: '![](296fig01_alt.jpg)'
- en: As [listing 11.8](#ch11ex08) shows, to import all exported identifiers from
    a module, we use the `import *` notation in combination with an identifier that
    we’ll use to refer to the whole module (in this case, the `ninjaModule` identifier).
    After we’ve done this, we can access the exported identifiers through property
    notation; for example, `ninjaModule.message`, `ninjaModule.sayHiToNinja`. Notice
    that we still can’t access top-level variables that weren’t exported, as is the
    case with the `ninja` variable.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 11.8](#ch11ex08) 所示，要从一个模块中导入所有导出的标识符，我们使用 `import *` 符号，并结合一个我们将用来引用整个模块的标识符（在这种情况下，是
    `ninjaModule` 标识符）。完成此操作后，我们可以通过属性符号访问导出的标识符；例如，`ninjaModule.message`，`ninjaModule.sayHiToNinja`。请注意，我们仍然无法访问未导出的顶层变量，例如
    `ninja` 变量。
- en: Default exports
  id: totrans-1535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认导出
- en: Often we don’t want to export a set of related identifiers from a module, but
    instead want to represent the whole module through a single export. One fairly
    common situation in which this occurs is when our modules contain a single class,
    as in the following listing.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们不想从一个模块中导出一组相关的标识符，而是想通过单个导出来表示整个模块。这种情况相当常见的一个例子是，当我们的模块包含一个单独的类时，如下面的列表所示。
- en: Listing 11.9\. A default export from Ninja.js
  id: totrans-1537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 从 Ninja.js 模块导出的默认值
- en: '![](297fig01_alt.jpg)'
  id: totrans-1538
  prefs: []
  type: TYPE_IMG
  zh: '![](297fig01_alt.jpg)'
- en: Here we’ve added the `default` keyword after the `export` keyword, which specifies
    the default binding for this module. In this case, the default binding for this
    module is the class named `Ninja`. Even though we’ve specified a default binding,
    we can still use named exports to export additional identifiers, as we did with
    the `compare-Ninjas` function.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `export` 关键字之后添加了 `default` 关键字，这指定了此模块的默认绑定。在这种情况下，此模块的默认绑定是名为 `Ninja`
    的类。尽管我们指定了默认绑定，我们仍然可以使用命名导出导出额外的标识符，就像我们使用 `compare-Ninjas` 函数那样。
- en: Now, we can use simplified syntax to import functionalities from Ninja.js, as
    shown in the following listing.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用简化的语法从 Ninja.js 导入功能，如下所示。
- en: Listing 11.10\. Importing a default export
  id: totrans-1541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 导入默认导出
- en: '![](297fig02_alt.jpg)'
  id: totrans-1542
  prefs: []
  type: TYPE_IMG
  zh: '![](297fig02_alt.jpg)'
- en: We start this example with importing a default export. For this, we use a less
    cluttered import syntax by dropping the braces that are mandatory for importing
    named exports. Also, notice that we can choose an arbitrary name to refer to the
    default export; we aren’t bound to use the one we used when exporting. In this
    example, `ImportedNinja` refers to the `Ninja` class defined in the file Ninja.js.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个例子开始导入默认导出。为此，我们使用一个更简洁的导入语法，通过省略导入命名导出时必须的括号。注意，我们可以选择任意名称来引用默认导出；我们不必使用我们在导出时使用的那个名称。在这个例子中，`ImportedNinja`
    指的是在文件 Ninja.js 中定义的 `Ninja` 类。
- en: We continue the example by importing a named export, as in previous examples,
    just to illustrate that we can have both a default export and a number of named
    exports within a single module. Finally, we instantiate a couple of `ninja` objects
    and call the `compareNinjas` function, to confirm that all imports work as they
    should.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续这个例子，通过导入一个命名导出，就像之前的例子一样，只是为了说明我们可以在单个模块中既有默认导出也有多个命名导出。最后，我们实例化了一些 `ninja`
    对象并调用了 `compareNinjas` 函数，以确认所有导入都按预期工作。
- en: 'In this case, both imports are made from the same file. ES6 offers a shorthand
    syntax:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个导入都来自同一个文件。ES6 提供了一种简写语法：
- en: '[PRE140]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here we use the comma operator to import both the default and the named exports
    from the Ninja.js file, in a single statement.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用逗号运算符从 Ninja.js 文件中导入默认导出和命名导出，在单个语句中完成。
- en: Renaming exports and imports
  id: totrans-1548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重命名导出和导入
- en: 'If necessary, we can also rename both exports and imports. Let’s start with
    renaming exports, as shown in the following code (the comments indicate in which
    file the code is located):'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们也可以重命名导出和导入。让我们从重命名导出开始，如下面的代码所示（注释表明代码位于哪个文件中）：
- en: '![](298fig01_alt.jpg)'
  id: totrans-1550
  prefs: []
  type: TYPE_IMG
  zh: '![](298fig01_alt.jpg)'
- en: 'In the previous example, we define a function called `sayHi`, and we test that
    we can access the function only though the `sayHi` identifier, and not through
    the `sayHello` alias that we provide at the end of the module through the `as`
    keyword:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为 `sayHi` 的函数，并测试我们只能通过 `sayHi` 标识符访问该函数，而不能通过我们在模块末尾通过 `as`
    关键字提供的 `sayHello` 别名：
- en: '[PRE141]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We can perform an export rename only in this export form, and not by prefixing
    the variable or function declaration with the `export` keyword.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在这种导出形式中执行导出重命名，而不能通过在变量或函数声明前加上 `export` 关键字来实现。
- en: 'Then, when we perform an import of the renamed export, we reference the import
    through the given alias:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们导入重命名的导出时，我们通过给定的别名引用导入：
- en: '[PRE142]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Finally, we test that we have access to the aliased identifier, but not the
    original one:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试我们是否有权访问别名标识符，但不能访问原始标识符：
- en: '[PRE143]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The situation is similar when renaming imports, as shown in the following code
    segment:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 当重命名导入时，情况类似，如下面的代码段所示：
- en: '![](299fig01_alt.jpg)'
  id: totrans-1559
  prefs: []
  type: TYPE_IMG
  zh: '![](299fig01_alt.jpg)'
- en: Similarly to exporting identifiers, we can also use the `as` keyword to create
    aliases when importing identifiers from other modules. This is useful when we
    need to provide a better name that’s more suitable to the current context, or
    when we want to avoid naming clashes, as is the case in this small example.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于导出标识符，我们也可以使用 `as` 关键字在从其他模块导入标识符时创建别名。当我们需要提供一个更适合当前上下文的名字，或者当我们想要避免命名冲突时，这很有用，就像在这个小例子中一样。
- en: With this, we’ve finished our exploration of the ES6 modules’ syntax, which
    is recapped in [table 11.1](#ch11table01).
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们完成了对 ES6 模块语法的探索，这在 [表 11.1](#ch11table01) 中进行了总结。
- en: Table 11.1\. Overview of ES6 module syntax
  id: totrans-1562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 11.1\. ES6 模块语法概述
- en: '| Code | Meaning |'
  id: totrans-1563
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 含义 |'
- en: '| --- | --- |'
  id: totrans-1564
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE144]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '| Export a named variable. Export a named function. Export a named class. |'
  id: totrans-1567
  prefs: []
  type: TYPE_TB
  zh: '| 导出一个命名变量。导出一个命名函数。导出一个命名类。|'
- en: '|'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE145]'
  id: totrans-1569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '| Export the default class export. Export the default function export. |'
  id: totrans-1570
  prefs: []
  type: TYPE_TB
  zh: '| 导出默认类导出。导出默认函数导出。|'
- en: '|'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE146]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '| Export existing variables. Export a variable through a new name. |'
  id: totrans-1573
  prefs: []
  type: TYPE_TB
  zh: '| 导出现有变量。通过新名称导出变量。|'
- en: '|'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE147]'
  id: totrans-1575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '| Import a default export. Import named exports. |'
  id: totrans-1576
  prefs: []
  type: TYPE_TB
  zh: '| 导入默认导出。导入命名导出。|'
- en: '|'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE148]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '| Import all named exports from a module. |'
  id: totrans-1579
  prefs: []
  type: TYPE_TB
  zh: '| 从模块中导入所有命名的导出。|'
- en: '|'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE149]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '| Import a named export through a new name. |'
  id: totrans-1582
  prefs: []
  type: TYPE_TB
  zh: '| 通过新名称导入命名导出。|'
- en: 11.3\. Summary
  id: totrans-1583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 概述
- en: Large, monolithic code bases are far more likely to be difficult to understand
    and maintain than smaller, well-organized ones. One way of improving the structure
    and organization of our programs is to break them into smaller, relatively loosely
    coupled segments or modules.
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型、单体代码库比小型、组织良好的代码库更难理解和维护。改善我们程序的结构和组织的一种方法是将它们分解成更小、相对松散耦合的段或模块。
- en: Modules are larger units of organizing code than objects and functions, and
    they allow us to divide programs into clusters that belong together.
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是比对象和函数更大的代码组织单元，它们允许我们将程序划分为属于一起的集群。
- en: In general, modules foster understandability, ease maintenance, and improve
    the reusability of code.
  id: totrans-1586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，模块促进了可理解性、易于维护和提高了代码的可重用性。
- en: Pre-ES6 JavaScript has no built-in modules, and developers had to be creative
    with existing language features to enable code modularization. One of the most
    popular ways of creating modules is by combining immediately invoked functions
    with closures.
  id: totrans-1587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ES6 之前的 JavaScript 没有内置的模块，开发者必须利用现有语言特性进行创新，以实现代码模块化。创建模块最流行的方式之一是将立即调用的函数与闭包结合起来。
- en: Immediate functions are used because they create a new scope for defining module
    variables that aren’t visible from outside that scope.
  id: totrans-1588
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即函数被使用，因为它们为定义模块变量创建了一个新的作用域，这些变量在该作用域之外是不可见的。
- en: Closures are used because they enable us to keep module variables alive.
  id: totrans-1589
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包是因为它们使我们能够保持模块变量存活。
- en: The most popular pattern is the module pattern, which usually combines an immediate
    function with a return of a new object that represents the module’s public interface.
  id: totrans-1590
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最流行的模式是模块模式，它通常将立即函数与表示模块公共接口的新对象返回值结合起来。
- en: 'In addition to the module pattern, two popular module standards exist: Asynchronous
    Module Definition, designed to enable modules in the browser; and CommonJS, which
    is more popular in server-side JavaScript.'
  id: totrans-1591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了模块模式之外，还存在两个流行的模块标准：异步模块定义（AMD），旨在使浏览器中的模块化成为可能；以及 CommonJS，它在服务器端 JavaScript
    中更为流行。
- en: AMD can automatically resolve dependencies, and modules are asynchronously loaded,
    thereby avoiding blocking.
  id: totrans-1592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD 可以自动解析依赖关系，模块异步加载，从而避免阻塞。
- en: CommonJS has a simple syntax, synchronously loads modules (and is therefore
    more appropriate for the server), and has many packages available through node’s
    package manager (npm).
  id: totrans-1593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 具有简单的语法，同步加载模块（因此更适合服务器端），并且通过 node 的包管理器（npm）提供了许多可用的包。
- en: ES6 modules are designed to take into account the features of AMD and CommonJS.
    These modules have a simple syntax influenced by CommonJS, and provide asynchronous
    module loading as in AMD.
  id: totrans-1594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 模块旨在考虑 AMD 和 CommonJS 的特性。这些模块具有受 CommonJS 影响的简单语法，并提供与 AMD 相似的异步模块加载。
- en: ES6 modules are file based, one module per file.
  id: totrans-1595
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 模块基于文件，每个文件一个模块。
- en: We export identifiers so that they can be referenced by other modules by using
    the new `export` keyword.
  id: totrans-1596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导出标识符，以便其他模块可以使用新的 `export` 关键字来引用它们。
- en: We import identifiers exported from other modules by using the `import` keyword.
  id: totrans-1597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `import` 关键字导入来自其他模块导出的标识符。
- en: A module can have a single `default` export, which we use if we want to represent
    that whole module through a single export.
  id: totrans-1598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以有一个单一的 `default` 导出，如果我们想通过单个导出来表示整个模块，我们就使用它。
- en: Both imports and exports can be renamed with the `as` keyword.
  id: totrans-1599
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和导出都可以使用 `as` 关键字重命名。
- en: 11.4\. Exercises
  id: totrans-1600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 练习
- en: '**1**'
  id: totrans-1601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-1602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which mechanism enables private module variables in the module pattern?
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪种机制使得模块模式中存在私有模块变量？
- en: ''
  id: totrans-1604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prototypes
  id: totrans-1605
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原型
- en: Closures
  id: totrans-1606
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包
- en: Promises
  id: totrans-1607
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Promises
- en: '**2**'
  id: totrans-1608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code that uses ES6 modules, which identifiers can be accessed
    if the module is imported?
  id: totrans-1610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下使用 ES6 模块的代码中，如果导入模块，哪些标识符可以被访问？
- en: ''
  id: totrans-1611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1612
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE150]'
- en: ''
  id: totrans-1613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`spy`'
  id: totrans-1614
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spy`'
- en: '`command`'
  id: totrans-1615
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`command`'
- en: '`general`'
  id: totrans-1616
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`general`'
- en: '**3**'
  id: totrans-1617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-1618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code that uses ES6 modules, which identifiers can be accessed
    when the module is imported?
  id: totrans-1619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下使用 ES6 模块的代码中，当导入模块时，哪些标识符可以被访问？
- en: ''
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1621
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE151]'
- en: ''
  id: totrans-1622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`spy`'
  id: totrans-1623
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spy`'
- en: '`command`'
  id: totrans-1624
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`command`'
- en: '`general`'
  id: totrans-1625
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`general`'
- en: '`ninja`'
  id: totrans-1626
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ninja`'
- en: '**4**'
  id: totrans-1627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-1628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following imports are allowed?
  id: totrans-1629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些导入是允许的？
- en: ''
  id: totrans-1630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1631
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE152]'
- en: ''
  id: totrans-1632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`import {ninja, spy, general} from "personnel.js"`'
  id: totrans-1633
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从 "personnel.js" 中导入 {ninja, spy, general}` '
- en: '`import * as Personnel from "personnel.js"`'
  id: totrans-1634
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从 "personnel.js" 中导入所有内容为 Personnel`'
- en: '`import {spy} from "personnel.js"`'
  id: totrans-1635
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从 "personnel.js" 中导入 {spy}`'
- en: '**5**'
  id: totrans-1636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-1637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we have the following module code, which statement will import the `Ninja`
    class?
  id: totrans-1638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们有以下模块代码，以下哪个语句将导入 `Ninja` 类？
- en: ''
  id: totrans-1639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1640
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE153]'
- en: ''
  id: totrans-1641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: import Ninja from “Ninja.js”
  id: totrans-1642
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从 “Ninja.js” 中导入 Ninja`'
- en: import * as Ninja from “Ninja.js”
  id: totrans-1643
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从 “Ninja.js” 中导入 * as Ninja`'
- en: import * from “Ninja.js”
  id: totrans-1644
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从 “Ninja.js” 中导入 *`'
