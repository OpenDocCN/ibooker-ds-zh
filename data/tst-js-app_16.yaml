- en: 13 A culture of quality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 质量文化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: How types complement your tests and make your code safer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何类型补充你的测试并使你的代码更安全
- en: The impact of code reviews and how to perform them effectively
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查的影响以及如何有效地执行它们
- en: Adopting linting and formatting and the advantages of doing so
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用linting和格式化及其优势
- en: Setting up monitoring to ensure your systems are healthy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置监控以确保你的系统健康
- en: How documentation affects your project’s quality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档如何影响你的项目质量
- en: After 12 chapters on JavaScript testing, the 13th takes a little bit of a different
    direction. In this chapter, I will teach you new techniques that will complement
    your tests and help you foster a culture of quality in your projects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在12章关于JavaScript测试之后，第13章稍微改变了方向。在本章中，我将教你一些新的技术，这些技术将补充你的测试并帮助你培养项目中的质量文化。
- en: These techniques amplify the impact of your tests. They make your tests safer,
    your code easier to understand, or catch errors that your tests wouldn’t be able
    to.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术放大了测试的影响。它们使你的测试更安全，代码更容易理解，或者捕捉到测试无法捕捉到的错误。
- en: This chapter starts by demonstrating how type systems complement your tests.
    In this first section, I talk about the advantages of adopting type systems and
    use a practical example to elucidate what you must do to get the most significant
    safety benefits out of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先演示了类型系统如何补充你的测试。在本节中，我讨论了采用类型系统的优势，并使用一个实际例子来说明你必须做什么才能从它们中获得最大的安全效益。
- en: Once I’ve covered type systems, I will highlight how important it is for team
    members to review each other’s code and how to fit this practice into your development
    process. Furthermore, this section contains plenty of advice on how to review
    code effectively.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我涵盖了类型系统，我将强调团队成员相互审查代码的重要性以及如何将这种实践融入你的开发流程。此外，本节还包含大量关于如何有效审查代码的建议。
- en: To ease code reviews and help developers focus on code semantics instead of
    nitpicking, this chapter’s third section describes linting and formatting. It
    clarifies the difference between these two practices and reveals the benefits
    of each.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码审查并帮助开发者专注于代码语义而不是吹毛求疵，本章的第三部分描述了linting和格式化。它阐明了这两种实践之间的区别，并揭示了每种实践的好处。
- en: The penultimate section of the chapter explains how monitoring helps to keep
    your software healthy, to indicate what updates your software needs, and to detect
    bugs you couldn’t catch in your tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的倒数第二部分解释了监控如何帮助保持你的软件健康，指出你的软件需要哪些更新，以及如何检测测试中无法捕捉到的错误。
- en: 'Finally, this chapter’s last section talks about something everyone consumes
    but very few produce: documentation. This section covers the impact documentation
    can have on your team’s software and processes, which kinds of documentation to
    prioritize, and which *not* to write at all.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章的最后部分讨论了每个人都消费但很少有人生产的东西：文档。本节涵盖了文档对你的团队软件和流程可能产生的影响，哪些类型的文档应该优先考虑，以及哪些**不应该**编写。
- en: Because this book focuses on tests, I won’t go into too much detail in each
    of these sections. My main goal with this chapter is for you to understand how
    each of these practices and techniques can help you create better software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这本书专注于测试，所以我不会在每个部分中过多地详细说明。我本章的主要目标是让你了解这些实践和技术如何帮助你创建更好的软件。
- en: After reading this chapter, I expect you to have a good idea of what content
    you’ll seek and how it fits into the bigger picture of software testing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，我希望你能对你要寻找的内容有一个很好的了解，以及它如何融入软件测试的更大图景。
- en: 13.1 Using type systems to make invalid states unrepresentable
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 使用类型系统使无效状态不可表示
- en: I think of tests as experiments that confirm your hypotheses about how your
    programs work. When you write a test, you have a hypothesis about what your code
    will do, so you give it some input and check whether the code under test yields
    the expected output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为测试是确认你关于程序如何工作的假设的实验。当你编写一个测试时，你对代码将要做什么有一个假设，所以你给它一些输入，并检查被测试的代码是否产生预期的输出。
- en: Once you’ve run these experiments, you extrapolate and choose to believe the
    program will work in the same way in the future, even though that may not be true.
    It may be the case that you didn’t take a few edge cases into account or that
    there are other factors to play that change the code’s behavior, such as time
    zones if you’re dealing with time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了这些实验，你就会外推并选择相信程序在未来将以相同的方式工作，即使这可能并不正确。可能的情况是，你没有考虑到一些边缘情况，或者还有其他因素会影响代码的行为，例如如果你处理的是时间，时区可能会影响。
- en: As we’ve seen previously, tests *can’t* prove a program works. They can only
    prove it doesn’t.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，测试**不能**证明程序是有效的。它们只能证明程序不是无效的。
- en: Using type systems, on the other hand, *can* prove properties about your programs.
    If you use types to specify that a function can receive only numbers, your type
    checker will warn you if it’s possible for that function, in any circumstance,
    to be called with a string, for example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用类型系统**可以**证明程序的性质。如果你使用类型来指定一个函数只能接收数字，那么类型检查器会警告你，如果在该函数的任何情况下都可以用字符串调用该函数，例如。
- en: Unlike tests, type systems are *not* based on experimentation. They’re based
    on clear, logical rules with which your programs need to comply to be considered
    valid.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试不同，类型系统**不是**基于实验的。它们基于清晰、逻辑的规则，你的程序需要遵守这些规则才能被认为是有效的。
- en: Assume, for example, that you have a function that pushes an order to the bakery’s
    delivery queue. Because for orders to be delivered they need to be complete, this
    function should add to the delivery queue only orders whose status is `done`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你有一个函数将订单推送到面包店的配送队列。因为订单要被交付，它们需要是完整的，所以这个函数应该只向配送队列添加状态为 `done` 的订单。
- en: Listing 13.1 orderQueue.js
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.1 orderQueue.js
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Adds orders to the delivery queue only if their status is “done”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只在订单状态为“完成”时添加订单到配送队列
- en: If you were to test this function, you’d probably write a test to ensure that
    orders with an `in progress` status can’t be added to the queue, as shown in the
    next code excerpt.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你测试这个函数，你可能会编写一个测试来确保状态为 `in progress` 的订单不能添加到队列中，如以下代码片段所示。
- en: Listing 13.2 orderQueue.spec.js
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.2 orderQueue.spec.js
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ A test to ensure addToDeliveryQueue throws an error when someone tries to
    add to the delivery queue an order whose status is “in progress”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个测试以确保当有人尝试向配送队列添加状态为“进行中”的订单时，addToDeliveryQueue 会抛出错误
- en: The problem with relying exclusively on tests to assert on your program’s quality
    is that, because of JavaScript’s dynamic nature, many possible inputs could cause
    your program’s state to become invalid. In this case, for example, someone could
    add to the delivery queue orders with zero or `null` items whose status is `done`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于测试来断言程序质量的问题在于，由于 JavaScript 的动态特性，许多可能的输入可能导致程序的状态变得无效。例如，在这种情况下，有人可能向配送队列添加状态为
    `done` 且项目为零或 `null` 的订单。
- en: Additionally, there could be other functions that update the state within `orderQueue.js`,
    which could lead to invalid states. Or, even worse, someone could try to submit
    a `null` order, which would cause your program to throw an error when checking
    if the order’s status is null.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能还有其他函数会更新 `orderQueue.js` 中的状态，这可能导致无效状态。或者，更糟糕的是，有人可能尝试提交一个 `null` 订单，这会导致程序在检查订单状态是否为
    `null` 时抛出错误。
- en: For you to cover these edge cases, you’d need plenty of tests, and even then,
    you’d certainly not have covered all the possible scenarios that could lead to
    invalid states.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖这些边缘情况，你需要大量的测试，即使如此，你肯定也没有涵盖所有可能导致无效状态的可能场景。
- en: To constrain your program so that its state *must* be valid, you can use a type
    system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了约束你的程序，使其状态**必须**有效，你可以使用类型系统。
- en: Personally, TypeScript’s type system is my favorite. It’s flexible and easy
    to learn, and its tooling and community are excellent, which is why I’ve chosen
    it to write the examples in this section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，TypeScript 的类型系统是我最喜欢的。它灵活且易于学习，其工具和社区都很优秀，这就是我选择用它来编写本节示例的原因。
- en: Before you start using types to constrain our program’s state, install TypeScript
    as a dev dependency using `npm` `install` `-save` `typescript`. Once you’ve installed
    TypeScript, run `./node_modules/.bin/tsc --init` to create an initial TypeScript
    configuration file, called `tsconfig.json`. Finally, you’ll also need to change
    your file’s extensions to `.ts`. After creating that file, you’re ready to start
    using types to constrain your programs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始使用类型来约束程序状态之前，请使用 `npm` 命令 `install` `-save` `typescript` 安装 TypeScript
    作为开发依赖项。安装 TypeScript 后，运行 `./node_modules/.bin/tsc --init` 以创建一个初始的 TypeScript
    配置文件，名为 `tsconfig.json`。最后，您还需要将文件的扩展名更改为 `.ts`。创建该文件后，您就可以开始使用类型来约束您的程序了。
- en: Try, for example, creating a type that represents an order and assigning a type
    to your program’s `state`. Then, update the `addToDeliveryQueue` function so that
    it accepts only orders that match the `Order` type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试创建一个表示订单的类型，并将类型分配给程序的状态。然后，更新 `addToDeliveryQueue` 函数，使其只能接受与 `Order`
    类型匹配的订单。
- en: Listing 13.3 orderQueue.ts
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3 orderQueue.ts
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a type for Order whose status can be either “in progress” or “done”
    and whose items are represented by an array of strings
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个类型，Order 的状态可以是“进行中”或“完成”，其项目由字符串数组表示
- en: ❷ A type that represents the state of the delivery system that contains a deliveries
    property that is an array of orders
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个表示配送系统状态的类型，该状态包含一个名为 deliveries 的属性，它是一个订单数组
- en: ❸ The delivery system’s state, which initially contains an empty array of deliveries
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 配送系统的状态，最初包含一个空的配送数组
- en: NOTE When using TypeScript, you can use the ES import syntax because you’ll
    use the TypeScript Compiler to translate your programs to plain JavaScript files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当使用 TypeScript 时，您可以使用 ES 导入语法，因为您将使用 TypeScript 编译器将程序转换为纯 JavaScript 文件。
- en: Just with these two types, you have now guaranteed that TypeScript will warn
    you if there’s anywhere in your code that could add to the delivery queue anything
    other than a valid `Order`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过这两个类型，您现在已经确保 TypeScript 如果代码中任何地方添加了除有效 `Order` 之外的内容，将会警告您。
- en: Try, for example, calling `addToDeliveryQueue` and passing a string as an argument
    to it. Then, run the TypeScript compiler with `./node_modules/.bin/tsc ./orderQueue.ts`,
    and you will see that your program won’t compile.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试调用 `addToDeliveryQueue` 并将其作为字符串参数传递。然后，使用 `./node_modules/.bin/tsc ./orderQueue.ts`
    运行 TypeScript 编译器，您将看到程序无法编译。
- en: Listing 13.4 orderQueue.ts
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.4 orderQueue.ts
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can go even further and specify that any order must have at least one item
    in it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以更进一步，并指定任何订单必须至少包含一个项目。
- en: Listing 13.5 orderQueue.ts
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.5 orderQueue.ts
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Defines that values whose type is OrderItems must have their first index filled
    with a string
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义值类型为 OrderItems 的值必须将其第一个索引填充为字符串
- en: ❷ Declares that the items property has an OrderItems type that prevents the
    programmer from assigning empty arrays to it
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明 items 属性具有 OrderItems 类型，这阻止程序员将其分配为空数组
- en: This update guarantees that it won’t be possible for the program to add to the
    delivery queue orders whose `items` array is empty.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新确保程序无法向配送队列添加 `items` 数组为空的订单。
- en: Listing 13.6 orderQueue.ts
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 orderQueue.ts
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, to reduce the number of tests you’d have to write, you can also update
    your program’s types to guarantee that `addToDeliveryQueue` can accept only orders
    whose status is `done`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了减少您需要编写的测试数量，您还可以更新程序的类型，以确保 `addToDeliveryQueue` 只能接受状态为 `done` 的订单。
- en: Listing 13.7 orderQueue.ts
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7 orderQueue.ts
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a new type that represents exclusively orders whose status is “done”
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新类型，仅表示状态为“完成”的订单
- en: Now your program won’t compile if there’s any possibility for any place in your
    code to add an incomplete order to the delivery queue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您的代码中任何地方有可能添加一个不完整的订单到配送队列，程序将无法编译。
- en: Listing 13.8 orderQueue.ts
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.8 orderQueue.ts
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Thanks to your types, you won’t need the error handling within your function
    anymore or the test for it. Because you’ve written strict types, your program
    won’t even compile if you try to add an invalid order to the delivery queue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您使用了类型，您不再需要在函数内部进行错误处理或对其进行测试。因为您已经编写了严格的类型，如果您尝试向配送队列添加无效的订单，程序甚至无法编译。
- en: Listing 13.9 orderQueue.ts
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.9 orderQueue.ts
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ A function whose argument’s type is DoneOrder, which prevents others from
    calling it with any orders whose status is different from “done”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个函数的参数类型为 DoneOrder，这阻止了其他人使用状态不是“完成”的任何订单调用它
- en: After these changes, the only test you’ll need is one that checks whether `addToDeliveryQueue`
    adds complete items to the delivery queue.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，您唯一需要的测试是检查`addToDeliveryQueue`是否将完整的项目添加到交付队列中的测试。
- en: Listing 13.10 orderQueue.spec.ts
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.10 orderQueue.spec.ts
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ A test that adds to the delivery queue an order whose status is “done” and
    expects the order queue to contain the new order
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个测试将状态为“完成”的订单添加到交付队列中，并期望订单队列包含新订单
- en: NOTE Before you can compile this test, you will need to install the type definitions
    for Jest using `npm install @types/jest`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在您能够编译此测试之前，您需要使用`npm install @types/jest`安装Jest的类型定义。
- en: Now try using `./node_modules/.bin/tsc ./*.ts` to compile all your `.ts` files
    to plain JavaScript, and then run your test with Jest to confirm the test passes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用`./node_modules/.bin/tsc ./*.ts`来编译所有`.ts`文件到纯JavaScript，然后使用Jest运行测试以确认测试通过。
- en: By using types, you have constrained your program enough so that invalid states
    become unrepresentable. These types helped you cover more edge cases without having
    to write tests because TypeScript will warn you if you ever write code that does
    not comply with the types it expects. Furthermore, TypeScript does that without
    ever having to run your program. Instead, TypeScript analyzes the program *statically*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类型，您已经足够约束了您的程序，使得无效状态变得无法表示。这些类型帮助您覆盖了更多的边缘情况，而无需编写测试，因为TypeScript会在您编写不符合其期望的类型代码时警告您。此外，TypeScript无需运行您的程序就能做到这一点。相反，TypeScript会*静态地*分析程序。
- en: On top of all that, a type system also helps you make fewer mistakes when writing
    tests because it will also give you warnings if your tests could lead your program
    to invalid states (considering your types are strict enough to allow for that
    to happen).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类型系统还有助于您在编写测试时犯更少的错误，因为它还会在您的测试可能导致程序进入无效状态时给出警告（假设您的类型足够严格，允许这种情况发生）。
- en: NOTE Because this is a book focused on tests, I haven’t gone too deep into TypeScript
    itself. If you’d like to learn more about it, I’d highly recommend Marius Schulz’s
    TypeScript Evolution series, which you can find at [https://mariusschulz.com/blog/series/typescript-evolution](https://mariusschulz.com/blog/series/typescript-evolution).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于这本书专注于测试，我没有深入探讨TypeScript本身。如果您想了解更多关于TypeScript的信息，我强烈推荐Marius Schulz的TypeScript
    Evolution系列，您可以在[https://mariusschulz.com/blog/series/typescript-evolution](https://mariusschulz.com/blog/series/typescript-evolution)找到。
- en: 13.2 Reviewing code to catch problems machines can’t
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 审查代码以捕捉机器无法发现的问题
- en: Machines do only what they’re told. They don’t make mistakes; humans do. Whenever
    software misbehaves, it’s a human’s fault.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 机器只会做它们被告知的事情。它们不会犯错误；是人类会犯错误。每当软件行为异常时，都是人类的错。
- en: Code reviews exist so that humans can point out each other’s mistakes and improve
    a piece of software’s design. Additionally, code reviews help distribute ownership
    across a team and spread knowledge. If anyone needs to change a piece of code
    written by someone else, they’ve already read it before and feel more comfortable
    updating it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查存在是为了让人类指出彼此的错误，并改进软件的设计。此外，代码审查有助于在团队中分配所有权并传播知识。如果有人需要更改其他人编写的代码，他们已经阅读过它，并且更新它时会感到更舒适。
- en: Furthermore, code reviews can help catch mistakes that tests and types can’t.
    During reviews, others can flag, for example, that there’s an edge case for which
    there are no automated tests or that there are types that aren’t strict enough
    to prevent the program from getting to an invalid state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，代码审查可以帮助捕捉测试和类型检查无法发现的错误。在审查过程中，其他人可以指出，例如，存在没有自动化测试的边缘情况，或者存在不够严格的类型，无法防止程序进入无效状态。
- en: If your team doesn’t have a formal code-review process yet, in the vast majority
    of cases, I’d recommend you to implement one. Even if you don’t use pull requests
    or any other formal methods, the mere process of having someone else proofread
    your code will yield significant benefits.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的团队还没有正式的代码审查流程，在绝大多数情况下，我建议您实施一个。即使您不使用拉取请求或其他任何正式方法，仅仅让其他人审阅您的代码也会带来显著的好处。
- en: In this section, I’ll teach you a few techniques to ensure you and your team
    will get the most out of code reviews.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您介绍一些技巧，以确保您和您的团队能够从代码审查中获得最大收益。
- en: 'The first of these techniques is perhaps the most important to allow for others
    to perform thorough reviews: **writing detailed pull request descriptions**. When
    others understand your change’s intent and all the nuances involved, they can
    avoid adding redundant comments that point out something you’ve already taken
    into account when writing code.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术中最重要的是**编写详细的拉取请求描述**，这允许其他人进行彻底的审阅。当其他人理解你的更改意图和所有细微差别时，他们可以避免添加重复的评论，指出你在编写代码时已经考虑过的事情。
- en: 'Personally, I like to include the following information in the pull requests
    I open:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我喜欢在我的拉取请求中包含以下信息：
- en: A quick summary containing the change’s intent and any related issue-tracker
    tickets
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简要的总结，包含更改的意图和任何相关的跟踪器票据
- en: An in-depth explanation of the problem I’m addressing or the nuances of the
    feature I’m implementing
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我正在解决的问题的深入解释，或者我正在实施的功能的细微差别
- en: A description of the pieces of code I’ve either written or updated, emphasizing
    the nuances and questions I had during implementation
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我已编写或更新的代码片段的描述，强调我在实施过程中遇到的细微差别和问题
- en: A brief guide on how I’ve validated my changes so that others can confirm the
    code is correct
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简要指南，说明我如何验证我的更改，以便其他人可以确认代码是正确的
- en: TIP If you use GitHub, you can create pull request templates with a separate
    section for each of these items so that others can quickly and easily understand
    how they should write their pull request descriptions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你使用GitHub，你可以为这些项目中的每一个创建单独的拉取请求模板，这样其他人可以快速轻松地理解他们应该如何编写拉取请求描述。
- en: Once pull request descriptions have this much level of detail, then it’s the
    reviewer’s task to communicate with the author to ensure the code is as high quality
    as it can be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拉取请求描述达到这样的详细程度，那么审阅者的任务就是与作者沟通，确保代码的质量尽可能高。
- en: My first advice for reviewers is always to think of a pull request as a conversation.
    When doing a review, instead of only requesting changes, I recommend others to
    compliment the author’s elegant design and ask questions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我给审阅者的第一条建议总是将拉取请求视为一次对话。在进行审阅时，除了要求更改之外，我还建议其他人称赞作者的优雅设计并提问。
- en: Reviewing pull requests with the intent of interacting with the author forces
    reviewers to pay more attention. Furthermore, this attitude fosters more meaningful
    and positive interactions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以与作者互动的意图审阅拉取请求迫使审阅者更加注意。此外，这种态度促进了更有意义和积极的互动。
- en: During these interactions, I also recommend reviewers to clearly indicate whether
    a change request would block a pull request from receiving their approval. This
    indication helps teams waste less time discussing trivial or subjective matters
    that maybe the reviewers themselves didn’t think were so important.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些互动中，我还建议审阅者清楚地表明一个更改请求是否会阻止拉取请求获得他们的批准。这种指示有助于团队减少在琐碎或主观问题上浪费时间，这些问题可能连审阅者自己都没有认为那么重要。
- en: Additionally, reviewers should also explain *why* they think a particular piece
    of code needs changes. By describing the advantages of adopting the suggested
    approach, they make debates more fluid and give the author more information to
    consider when making a decision.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，审阅者还应解释他们认为为什么特定的代码片段需要更改。通过描述采用建议方法的优势，他们使辩论更加流畅，并为作者提供更多考虑的信息，以便做出决定。
- en: The final and perhaps the most crucial advice for reviewers is to **perform
    reviews with their text editor or IDE open**. When writing code, authors don’t
    merely go through files in alphabetical order and implement changes. Instead,
    they find a change’s entry point and navigate through the dependency graph, changing
    the pieces of code they need. Therefore, reviews should *not* be linear. Reviewers
    should look through files according to the dependency graph and the changes being
    implemented, *not* in alphabetical order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于审阅者来说，最后的也许是最重要的建议是**在打开文本编辑器或IDE的情况下进行审阅**。在编写代码时，作者并不仅仅按字母顺序遍历文件并实施更改。相反，他们会找到更改的起点，并通过依赖图导航，更改他们需要的代码片段。因此，审阅**不应**是线性的。审阅者应根据依赖图和正在实施的更改来查看文件，而不是按字母顺序。
- en: Reviewing code with your editor or IDE open allows you to check other pieces
    of code that might not have been changed but do have an impact on whether a pull
    request’s changes are valid.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE打开的情况下审阅代码，可以让你检查可能没有更改但会影响拉取请求更改是否有效的其他代码片段。
- en: 'To summarize, here is a list with all of this chapter’s advice on how to review
    pull requests:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是一份关于如何审查拉取请求的这章所有建议的列表：
- en: Write detailed pull request descriptions.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写详细的拉取请求描述。
- en: Consider every pull request a conversation—review with the intent of adding
    comments, regardless of whether you’re suggesting changes.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个拉取请求视为一次对话——无论你是否建议更改，都要带着添加评论的意图进行审查。
- en: Clearly indicate whether you consider a suggested change to be required for
    the author to obtain your approval.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确指出你是否认为建议的更改是作者获得你批准所必需的。
- en: Explain *why* you think a particular piece of code needs changes.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释*为什么*你认为特定的代码片段需要更改。
- en: Review pull requests with your text editor or IDE open. Follow the code; do
    *not* review it linearly.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开文本编辑器或IDE的情况下审查拉取请求。跟随代码；不要线性地审查它。
- en: In the teams and open source projects I’ve participated on over the years, one
    of the main compliments I get is that my pull request descriptions and reviews
    are detailed and comprehensive. This discipline has yielded significant productivity
    increases and more positive interactions plenty of times.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我参与的团队和开源项目中，我经常收到的最主要的赞扬之一就是我的拉取请求描述和审查非常详细和全面。这种纪律多次带来了显著的生产力提升和更多积极的互动。
- en: Finally, to make your changes easier to read and digest, try to keep your pull
    requests small. If you’re working on a large feature, you can split it into multiple
    pull requests or request others to review intermediary states of your changes.
    Often, when pull requests are too big, people will miss important details among
    the numerous lines of code in the VCS diff.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使你的更改更容易阅读和理解，尽量保持你的拉取请求小。如果你正在开发一个大型功能，你可以将其拆分为多个拉取请求，或者请求其他人审查你更改的中间状态。通常，当拉取请求太大时，人们会在VCS差异的众多代码行中错过重要的细节。
- en: 13.3 Using linters and formatters to produce consistent code
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 使用代码检查器和格式化工具生成一致的代码
- en: A consistent theme throughout this book has been that if a machine *can* do
    a particular task, you should delegate that task to it. Linting and formatting
    are two such tasks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个一致主题是，如果一台机器*能够*完成特定的任务，你应该将这项任务委托给它。代码检查和格式化就是这样的任务。
- en: Linting, similar to type checking, is a kind of static analysis process. When
    using a linter, it will analyze the code you’ve written and validate whether it
    matches a configurable set of rules. Linters can indicate issues that could lead
    to bugs or inconsistencies in how the code has been written.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查，类似于类型检查，是一种静态分析过程。当使用代码检查器时，它会分析你编写的代码，并验证它是否与可配置的规则集匹配。代码检查器可以指出可能导致错误或代码编写不一致性的问题。
- en: You can use a linter to trigger warnings when, for example, you use repeated
    names for properties in an object, when you declare unused variables, when you
    write unreachable `return` statements, or when you create empty code blocks. Even
    though all of these constructs are syntactically valid, they can be unnecessary
    or lead to defects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用代码检查器在例如使用对象中重复的属性名称、声明未使用的变量、编写不可达的`return`语句或创建空代码块时触发警告。尽管所有这些结构在语法上都是有效的，但它们可能是多余的或导致缺陷。
- en: By using a linter, you leverage the machine’s capabilities of tirelessly checking
    code and free the other members of your team to pay more attention to the actual
    semantics of the code you’ve written. Because others can trust that the machine
    has done its job in catching trivial issues, others can focus on reviewing your
    code’s semantics instead of pointing out that you have duplicate `if/else` statements,
    for example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用代码检查器，你利用了机器无休止检查代码的能力，并让团队的其他成员有更多时间关注你编写的代码的实际语义。因为其他人可以相信机器已经完成了捕捉琐碎问题的任务，其他人可以专注于审查你代码的语义，而不是指出你有多余的`if/else`语句，例如。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The file in which the linting error was found
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发现代码检查错误的文件
- en: ❷ The error’s line and column, followed by an explanation about what the problem
    is
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 错误的行号和列号，随后是对问题的解释
- en: ❸ The name of the linting rule your code violates
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 违反的代码检查规则名称
- en: Furthermore, many tools and frameworks offer linter plugins so that your linter
    can warn you about bad practices. Suppose you’re writing a React application.
    In that case, you can use a plugin to configure your linter to emit warnings if
    you’ve forgotten to specify the `PropTypes` of a component’s property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多工具和框架提供代码风格检查器插件，以便您的检查器可以警告您关于不良实践。假设您正在编写一个 React 应用程序，在这种情况下，您可以使用插件配置您的检查器，以便在您忘记指定组件属性的
    `PropTypes` 时发出警告。
- en: At the time of this writing, the most popular JavaScript linting tool is called
    *ESLint*. It’s an extensible and easy-to-use linter that you can install as a
    dev dependency by using `npm` `install` `--save-dev eslint`. Once you’ve installed
    it, you can create a configuration file by running `./node_modules/.bin/eslint`
    `--init` and validate your code by running `./node_modules/.bin/eslint .`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最受欢迎的 JavaScript 代码风格检查工具被称为 *ESLint*。它是一个可扩展且易于使用的检查器，您可以通过使用 `npm`
    命令 `install` `--save-dev eslint` 将其作为开发依赖项安装。一旦安装，您可以通过运行 `./node_modules/.bin/eslint`
    `--init` 创建一个配置文件，并通过运行 `./node_modules/.bin/eslint .` 验证您的代码。
- en: TIP As you’ve seen earlier in this book, you can omit the path to the binaries
    within the `node_modules` folder if you create an NPM script in your `package.json`
    that runs `eslint`. In most projects, that’s what you’ll probably want to do.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 如您在本书中之前所见，如果您在 `package.json` 中创建一个运行 `eslint` 的 NPM 脚本，则可以省略 `node_modules`
    文件夹中二进制的路径。在大多数项目中，您可能希望这样做。
- en: In addition to pointing out dangerous constructs or bad practices, linters can
    also indicate and fix stylistic issues, such as the inconsistent usage of double
    quotes and single quotes, unnecessary parentheses, or extra empty lines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指出危险的结构或不良实践外，代码风格检查器还可以指出并修复风格问题，例如双引号和单引号使用的不一致、不必要的括号或多余的空行。
- en: Personally, I don’t like to use linters to catch stylistics issues. Instead,
    I prefer to use an opinionated code formatter, like Prettier, for example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我不喜欢使用代码风格检查器来捕捉风格问题。相反，我更喜欢使用像 Prettier 这样的有偏见的代码格式化工具。
- en: The problem with using a linter to deal with code style is that you *can* configure
    what your stylistic rules are, and, even though this statement may seem counterintuitive,
    having *more* choice is usually bad when it comes to formatting. Code formatting
    is highly subjective, and everyone has their preferences in regard to whether
    you should use double quotes or single tabs and tabs or spaces—despite spaces
    being much better, of course.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码风格检查器处理代码风格的问题在于，您可以配置您的风格规则，尽管这个说法可能看起来有些反直觉，但在格式化方面，通常有更多的选择是件坏事。代码格式化非常主观，每个人在是否应该使用双引号或单引号、制表符或空格等方面都有自己的偏好——当然，空格的使用通常更好。
- en: Honestly, code style doesn’t matter as long as it’s consistent. I don’t mind
    if others prefer to use tabs rather than spaces, as long as the whole codebase
    uses tabs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，只要保持一致，代码风格并不重要。我不介意其他人更喜欢使用制表符而不是空格，只要整个代码库使用制表符即可。
- en: By using Prettier, you can skip all the hours of pointless subjective discussions
    and defer to Prettier’s choices instead—as I’ve done when writing this book’s
    examples.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Prettier，您可以省去所有无意义的争论时间，并转而依赖 Prettier 的选择——正如我在编写本书的示例时所做的那样。
- en: Additionally, Prettier can make code easier to read and more pleasant to work
    on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Prettier 可以使代码更容易阅读，并且更愉快地工作。
- en: NOTE I like to say that discussing code style preferences is always *bike-shedding*.
    Bike-shedding occurs when people waste way too much time discussing trivial and
    easy-to-grasp aspects of a project instead of focusing on the most complex and
    critical tasks necessary for it to be done.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 我喜欢说，讨论代码风格偏好总是 *无谓的争论*。无谓的争论发生在人们花费大量时间讨论项目中的琐碎且容易理解的部分，而不是专注于完成项目所需的最复杂和关键任务。
- en: This term was initially coined by Poul-Henning Kamp. It refers to Cyril Northcote
    Parkinson’s fictional example for his law of triviality, which states that groups
    of people typically give disproportionate weight to trivial issues. In his example,
    Cyril mentions that a committee whose job is to approve a nuclear power plant’s
    plan will often spend an immense amount of time discussing which materials to
    use for its bike shed instead of analyzing the actual power plant’s plan.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语最初由 Poul-Henning Kamp 提出。它指的是 Cyril Northcote Parkinson 的虚构例子，用于他的琐碎法则，该法则指出，群体通常会对琐碎问题给予不成比例的重视。在他的例子中，Cyril
    提到，一个负责批准核电站计划的委员会往往会花费大量时间讨论用于自行车棚的材料，而不是分析实际的核电站计划。
- en: Using Prettier is incredibly simple. To start formatting your code with Prettier,
    you only need to install it as a dev dependency with `npm` `install` `--save-dev
    prettier` and then use `./node_modules/.bin/prettier --write .`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Prettier非常简单。要开始使用Prettier格式化你的代码，你只需要将其作为开发依赖项使用`npm` `install` `--save-dev
    prettier`安装，然后使用`./node_modules/.bin/prettier --write .`。
- en: TIP In my own projects, I often integrate Prettier with Git hooks so that it
    will automatically format all the code I commit. For that, I use `husky`, a tool
    I covered in chapter 12\.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 在我的项目中，我经常将Prettier与Git钩子集成，以便它将自动格式化我提交的所有代码。为此，我使用了在第12章中介绍的工具`husky`。
- en: 13.4 Monitoring your systems to understand how they actually behave
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 监控你的系统以了解它们的实际行为
- en: I’ve never heard of a piece of software that doesn’t have *any* bugs. Up to
    today, much has been said and written about correctness, but the current state
    of the software industry clearly indicates we haven’t yet figured out how to write
    bug-free software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未听说过没有任何bug的软件。到目前为止，关于正确性的讨论和写作已经很多，但软件行业的现状清楚地表明，我们还没有找到编写无bug软件的方法。
- en: As I explained in chapter 3, not even codebases with 100% of code coverage mean
    your software is free of bugs. Sometimes, users will prove your software with
    a particular input you didn’t expect, and bugs *will* happen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第三章中解释的那样，即使代码覆盖率达到了100%，也不能保证你的软件没有bug。有时，用户会使用你未曾预料到的特定输入来证明你的软件，bug *仍然会发生*。
- en: Monitoring works on the assumption that problems *will* eventually happen, and
    that it’s better to notice them before your customers do. By monitoring your software,
    you can understand which of your assumptions about how the code works aren’t true.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 监控基于假设问题*最终会发生*，并且最好在客户之前注意到它们。通过监控你的软件，你可以了解你对代码工作方式的哪些假设是不真实的。
- en: Additionally, well-implemented monitoring systems will be able to give you insight
    on your software’s performance, resource consumption, and utilization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实施良好的监控系统将能够为你提供关于软件性能、资源消耗和利用的见解。
- en: Without collecting data on what your software *currently* does, it’s impossible
    to optimize its performance, because you’ll have no benchmark against which to
    compare your changes and because you don’t know where bottlenecks are.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不收集关于你的软件*目前*做了什么的资料，就无法优化其性能，因为你将没有基准来比较你的更改，也不知道瓶颈在哪里。
- en: 'Or, as Rob Pike states in the first of his five rules of programming ([https://users.ece.utexas.edu/~adnan/pike.html](https://users.ece.utexas.edu/~adnan/pike.html)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，正如Rob Pike在他的五条编程规则中的第一条所陈述的（[https://users.ece.utexas.edu/~adnan/pike.html](https://users.ece.utexas.edu/~adnan/pike.html)）：
- en: You can’t tell where a program is going to spend its time. Bottlenecks occur
    in surprising places, so don’t try to second guess and put in a speed hack until
    you’ve proven that’s where the bottleneck is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法预测程序将在哪里花费时间。瓶颈出现在令人惊讶的地方，所以不要试图猜测并添加速度优化，除非你已经证明了那里是瓶颈所在。
- en: —Rob Pike
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: —Rob Pike
- en: Imagine, for example, that your customers are complaining about how long it
    takes for your website to load. How will you make significant improvements to
    your pages’ load times if you don’t know how these pages *currently* behave? You
    can certainly try to guess where the bottlenecks are, but, without measuring,
    you’re shooting in the dark.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的客户抱怨你的网站加载时间过长，如果你不知道这些页面*目前*是如何表现的，你将如何显著提高页面加载时间？你当然可以尝试猜测瓶颈在哪里，但如果没有测量，你就是在黑暗中射击。
- en: On the other hand, if you have adequate monitoring, you can try a few versions
    of your website, each of which has different changes, and monitor how they perform,
    so that you can actually understand each change’s impact.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有足够的监控，你可以尝试几个不同版本的网站，每个版本都有不同的更改，并监控它们的性能，这样你才能真正了解每个更改的影响。
- en: Furthermore, measuring allows you to avoid prematurely optimizing your software.
    Even though you may have written a suboptimal algorithm, perhaps it’s already
    good enough for the load your application experiences.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测量可以让你避免过早优化你的软件。即使你可能已经编写了一个次优算法，也许它已经足够好，可以应对你的应用程序的负载。
- en: Measure. Don’t tune for speed until you’ve measured, and even then don’t unless
    one part of the code overwhelms the rest.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 测量。在你测量之前不要为了速度而调整，即使如此，除非代码的一部分明显超过了其他部分。
- en: —Rob Pike
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: —Rob Pike
- en: Finally, one last important aspect of setting up a monitoring infrastructure
    is having the capability of sending out alerts in case your monitoring systems
    detect anomalies. If your API is unreachable or if something that affects business
    value is not working, someone should wake up.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置监控基础设施的一个重要方面是，当你的监控系统检测到异常时，能够发送警报。如果你的 API 不可达或影响业务价值的东西不工作，应该有人被叫醒。
- en: For that to happen, make sure you’re tracking all the parts of your code that
    affect the value your customers get from your software. In addition to enabling
    alerting, measuring the aspects of your software that are more intimately tied
    with the value it provides to customers is what will allow you to make effective
    business decisions in the future.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，请确保你正在跟踪所有影响客户从你的软件中获得的价值的代码部分。除了启用警报外，衡量与你的软件提供给客户的价值更加紧密相关的方面，这将使你能够在未来做出有效的商业决策。
- en: Because this is a book about tests, I won’t go into detail about how to set
    up monitoring systems or what adequate monitoring infrastructures look like. Doing
    that would require an entire book—actually, it would probably require many.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一本关于测试的书，所以我不打算详细介绍如何设置监控系统或合适的监控基础设施看起来像什么。做这件事需要整整一本书——实际上，可能需要很多本书。
- en: I thought it was necessary, however, to emphasize the role that monitoring plays
    in writing high-quality software—investing time in learning more about how do
    it properly will pay off when building software at scale.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为强调监控在编写高质量软件中的作用是必要的——在了解如何正确执行方面投入时间，当构建大规模软件时将会有回报。
- en: 13.5 Explaining your software with good documentation
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 用良好的文档解释你的软件
- en: After more than half a thousand pages, saying I’m a big fan of writing is somewhat
    redundant. Nevertheless, it’s important to emphasize the positive effect that
    well-written pieces of documentation can have in a codebase.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 超过五百页之后，说我是写作的大粉丝似乎有些多余。尽管如此，强调精心编写的文档在代码库中产生的积极影响是很重要的。
- en: 'Its first benefit is well-known: it helps others understand the codebase more
    quickly. Documentation is especially helpful for others to understand not the
    code itself but, instead, *why* it’s been written in a particular manner. Personally,
    to keep documentation lean, I avoid describing how different pieces of code work
    and, instead, focus on explaining their intent.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个好处是众所周知的：它帮助他人更快地理解代码库。文档对于他人理解代码本身特别有帮助，但更重要的是，*为什么*要以特定的方式编写。就我个人而言，为了保持文档简洁，我避免描述不同代码部分的工作方式，而是专注于解释它们的意图。
- en: The biggest problem with documentation is keeping it up-to-date. As you update
    your code, if your documentation goes out of sync, it will be *more* confusing
    for others to understand what the code is supposed to do because now they have
    two conflicting sources of information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的最大问题是保持其更新。当你更新代码时，如果你的文档与代码不同步，其他人理解代码应该做什么会变得更加困惑，因为他们现在有两个相互冲突的信息来源。
- en: To avoid this situation, I personally like to keep my documentation as close
    to the code as possible. To achieve this goal, I prefer to use JSDoc to document
    my code using comment blocks instead of writing documentation separately using
    markdown files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我个人喜欢将文档与代码尽可能保持接近。为了实现这一目标，我更喜欢使用 JSDoc 通过注释块来记录我的代码，而不是单独使用 Markdown
    文件编写文档。
- en: Documenting your software within code files makes it almost impossible for others
    to forget they need to update documentation when writing code. If the function
    someone is changing has a JSDoc block above it, others won’t need to spend time
    searching for a markdown file or updating a separate wiki.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码文件中记录你的软件文档，几乎可以确保其他人不会忘记在编写代码时需要更新文档。如果某人正在更改的函数上方有 JSDoc 块，其他人就不需要花费时间搜索
    Markdown 文件或更新单独的维基百科。
- en: Additionally, if you use JSDoc, you can easily generate static websites with
    your software’s documentation and publish them to the internet. Others won’t necessarily
    have to look through your code to read its documentation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你使用 JSDoc，你可以轻松地使用你的软件文档生成静态网站，并将它们发布到互联网上。其他人不一定需要查看你的代码来阅读其文档。
- en: Furthermore, many text editors and IDEs can parse JSDoc and display tooltips
    with functions’ pieces of documentation as you write code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多文本编辑器和 IDE 可以解析 JSDoc，并在你编写代码时显示函数文档的提示信息。
- en: NOTE If you’d like to start using JSDoc, I’d highly recommend you to read the
    tool’s official documentation at [https://jsdoc.app](https://jsdoc.app).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你想开始使用JSDoc，我强烈建议你阅读该工具的官方文档，网址为[https://jsdoc.app](https://jsdoc.app)。
- en: 'The second and, in my opinion, most impactful benefit of documentation is still
    not as widespread: writing documentation forces authors to reflect on their choices
    and structure their thoughts precisely. This kind of work, in turn, tends to lead
    to friendlier designs and helps authors themselves develop a better understanding
    of the codebase. As Pulitzer-Prize–winning and National Book Award author David
    McCullough once put it, “Writing is thinking. To write well is to think clearly.
    That’s why it’s so hard.”'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的第二个，在我看来，最具影响力的好处尚未得到广泛传播：编写文档迫使作者反思他们的选择并精确地组织他们的思想。这种工作反过来又往往导致更友好的设计，并帮助作者自己更好地理解代码库。正如普利策奖和全国图书奖获得者大卫·麦库卢赫曾经说过：“写作就是思考。写得越好，思考就越清晰。这就是为什么它如此困难。”
- en: Personally, I often like to write documentation before I write any code. By
    explaining the code’s intent before I write it, I usually worry less about implementation
    details and focus on what the module’s consumers will need.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我经常喜欢在编写任何代码之前编写文档。通过在编写代码之前解释代码的意图，我通常更少担心实现细节，并专注于模块消费者将需要什么。
- en: Finally, my last advice for engineers is also to document their processes and
    contribution policies. Having an up-to-date and well-written work agreement helps
    others understand what’s expected from them and by when.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我对工程师的最后一条建议也是要记录他们的流程和贡献政策。拥有一份最新且写得好的工作协议有助于他人了解对他们有什么期望以及何时期望。
- en: Documenting, for example, that you expect every pull request to include automated
    tests, helps to formalize it as a good practice and set expectations within the
    team.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，记录你期望每个拉取请求都包含自动化测试，有助于将其正式化为一项良好实践，并在团队内设定期望。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When you write tests, you’re running experiments. You execute your programs
    with sample inputs and observe how your program behaves. Then, you choose to extrapolate
    those conclusions and trust that the program will behave similarly in the future
    for all inputs. Types, on the other hand, allow you to prove that your program
    can work only in a particular way.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你编写测试时，你正在进行实验。你使用样本输入执行你的程序，并观察你的程序如何表现。然后，你选择外推这些结论，并相信程序将在未来的所有输入中以类似的方式表现。另一方面，类型允许你证明你的程序只能以特定方式工作。
- en: By using a type system, you can prove properties of your programs without having
    to execute the program itself. This is the reason why type checking is considered
    a process of “static analysis.”
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用类型系统，你可以在不执行程序本身的情况下证明程序的性质。这就是为什么类型检查被认为是“静态分析”过程的原因。
- en: The strict usage of type systems helps you make invalid states impossible to
    represent, which, therefore, makes it impossible for you to make mistakes that
    lead your software to those invalid states.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格使用类型系统可以帮助你使无效状态无法表示，因此，使得你无法犯导致你的软件进入这些无效状态的错误。
- en: Additionally, type systems reduce the possible universe of inputs certain functions
    can take, making software easier to validate because you have fewer cases for
    which you need to write automated tests.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，类型系统减少了某些函数可以接受的输入的可能宇宙，这使得软件更容易验证，因为你需要编写的自动化测试案例更少。
- en: Code reviews exist to catch mistakes that machines can’t. Even though you can
    use automated tests to validate your code, you must ensure that your automated
    tests are correct and that they fulfill the expected business goals. To validate
    those two aspects of software development, you need an extra pair of eyes to point
    out mistakes.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查的存在是为了捕捉机器无法捕捉到的错误。尽管你可以使用自动化测试来验证你的代码，但你必须确保你的自动化测试是正确的，并且它们实现了预期的业务目标。为了验证软件开发这两个方面，你需要一双额外的眼睛来指出错误。
- en: When submitting pull requests, write thorough descriptions. These descriptions
    facilitate your reviewer’s job because they help others understand what you’re
    trying to accomplish and why you’ve made certain decisions.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提交拉取请求时，请写详细的描述。这些描述有助于你的审阅者工作，因为它们帮助他人了解你试图实现什么以及你为什么做出某些决定。
- en: If you’re a reviewer, treat pull requests as conversations. By reviewing pull
    requests with the intent of communicating with the author, you will be able to
    make sure you’ve asked the relevant questions, and, because you’re trying to create
    a meaningful communication bridge, you will inevitably pay more attention. Additionally,
    writing compliments creates a healthy bond between individuals in the team.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是一个审查者，将拉取请求视为对话。通过以与作者沟通的意图来审查拉取请求，你将能够确保你已经提出了相关的问题，并且因为你试图创建一个有意义的沟通桥梁，你不可避免地会更加关注。此外，写赞美的话可以在团队中建立健康的人际关系。
- en: Clearly indicate in your reviews which changes are going to prevent the pull
    request from getting your approval. This attitude helps teams avoid discussions
    about trivial suggestions that both sides do not consider to be relevant.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的审查中明确指出哪些更改将阻止拉取请求获得你的批准。这种态度有助于团队避免关于双方都不认为相关的琐碎建议的讨论。
- en: Do not review code linearly. Instead of skimming through multiple files, try
    to follow the author’s train of thought. Implementing changes is *not* a linear
    process, and, therefore, linear reviews do not allow reviewers to jump through
    the code’s dependency graph properly.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要线性地审查代码。与其浏览多个文件，不如尝试跟随作者的思路。实施更改不是一个线性过程，因此，线性审查不允许审查者正确地跳过代码的依赖图。
- en: Linting is a kind of static analysis process, similarly to type checking. Linters
    analyze the code you’ve written and validate whether it matches a configurable
    set of rules, thus indicating issues that could lead to bugs or inconsistencies.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linting是一种类似于类型检查的静态分析过程。Linters分析你编写的代码，并验证它是否与可配置的规则集匹配，从而指示可能导致错误或不一致的问题。
- en: Formatters focus exclusively on stylistic issues. They ensure that you’re following
    consistent code style and make code easier to read.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化器专注于风格问题。它们确保你遵循一致的代码风格，并使代码更容易阅读。
- en: Linters and formatters reduce the number of nitpicky comments in pull requests
    because code standards are automatically enforced and validated by machines rather
    than humans.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linters和formatters减少了拉取请求中的挑剔性评论，因为代码标准是由机器而不是人类自动执行和验证的。
- en: Monitoring allows you to understand how your software behaves when it’s in the
    hand of customers. Therefore, it helps you detect which are the false assumptions
    you’ve made in regard to how your program works.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控使你能够了解你的软件在客户手中的行为方式。因此，它有助于你检测你关于程序如何工作的错误假设。
- en: By monitoring your software, you can understand where its bottlenecks are and
    measure improvements, thus avoiding premature optimization and the overhead of
    a trial-and-error approach to software updates.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过监控你的软件，你可以了解其瓶颈在哪里，并衡量改进，从而避免过早优化和软件更新的试错方法的额外开销。
- en: Setting up alerting on top of your monitoring infrastructure helps ensure that
    your team will act promptly when the application’s business value is affected.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的监控基础设施之上设置警报有助于确保当应用程序的业务价值受到影响时，你的团队能够迅速采取行动。
- en: When writing documentation, focus on explaining the *intent* of the code instead
    of its inner workings so that you can keep your documentation lean.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写文档时，专注于解释代码的*意图*而不是其内部工作原理，这样你可以保持文档的简洁。
- en: You can bundle your documentation into your codebase using tools like JSDoc.
    These tools cause the code to become the single source of truth and diminish the
    time and effort necessary to update documentation.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用JSDoc等工具将文档捆绑到你的代码库中。这些工具使代码成为唯一的真理来源，并减少了更新文档所需的时间和精力。
- en: Writing documentation before you write code can help you elucidate what is it
    that you’re trying to achieve, because when doing so, you will focus on a module’s
    interface and intent instead of worrying too much about its implementation details.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编写代码之前编写文档可以帮助你阐明你试图实现的目标，因为这样做时，你会专注于模块的接口和意图，而不是过分担心其实现细节。
