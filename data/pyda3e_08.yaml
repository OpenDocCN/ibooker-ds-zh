- en: 5  Getting Started with pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5  使用pandas入门
- en: 原文：[https://wesmckinney.com/book/pandas-basics](https://wesmckinney.com/book/pandas-basics)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/pandas-basics](https://wesmckinney.com/book/pandas-basics)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个开放访问的网络版本*Python for Data Analysis第3版*现在作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣可用。如果您发现任何勘误，请[在此报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto制作的本站的某些方面与O''Reilly的印刷版和电子书版本的格式不同。'
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *pandas
    will be a major tool of interest throughout much of the rest of the book. It contains
    data structures and data manipulation tools designed to make data cleaning and
    analysis fast and convenient in Python. pandas is often used in tandem with numerical
    computing tools like NumPy and SciPy, analytical libraries like statsmodels and
    scikit-learn, and data visualization libraries like matplotlib. pandas adopts
    significant parts of NumPy's idiomatic style of array-based computing, especially
    array-based functions and a preference for data processing without `for` loops.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现这本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或再生产。代码示例采用MIT许可，可以在GitHub或Gitee上找到。*pandas将是本书剩余部分中的一个主要工具。它包含了专为在Python中快速方便地进行数据清洗和分析而设计的数据结构和数据操作工具。pandas经常与数值计算工具（如NumPy和SciPy）、分析库（如statsmodels和scikit-learn）以及数据可视化库（如matplotlib）一起使用。pandas采用了NumPy的很多习惯用法，特别是基于数组的计算和对数据处理的偏好，而不使用`for`循环。
- en: While pandas adopts many coding idioms from NumPy, the biggest difference is
    that pandas is designed for working with tabular or heterogeneous data. NumPy,
    by contrast, is best suited for working with homogeneously typed numerical array
    data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然pandas采用了许多来自NumPy的编码习惯，但最大的区别在于pandas是为处理表格或异构数据而设计的。相比之下，NumPy更适合处理同质类型的数值数组数据。
- en: Since becoming an open source project in 2010, pandas has matured into a quite
    large library that's applicable in a broad set of real-world use cases. The developer
    community has grown to over 2,500 distinct contributors, who've been helping build
    the project as they used it to solve their day-to-day data problems. The vibrant
    pandas developer and user communities have been a key part of its success.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自2010年成为开源项目以来，pandas已经发展成一个相当庞大的库，适用于广泛的实际用例。开发者社区已经发展到超过2500名不同的贡献者，他们在解决日常数据问题时一直在帮助构建这个项目。充满活力的pandas开发者和用户社区是其成功的关键部分。
- en: '*Note* *Many people don''t know that I haven''t been actively involved in day-to-day
    pandas development since 2013; it has been an entirely community-managed project
    since then. Be sure to pass on your thanks to the core development and all the
    contributors for their hard work!*  *Throughout the rest of the book, I use the
    following import conventions for NumPy and pandas:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *很多人不知道我自2013年以来并没有积极参与日常pandas的开发；从那时起，它一直是一个完全由社区管理的项目。请务必向核心开发人员和所有贡献者传达感谢他们的辛勤工作！*
    *在本书的剩余部分中，我使用以下的NumPy和pandas的导入约定：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Thus, whenever you see `pd.` in code, it’s referring to pandas. You may also
    find it easier to import Series and DataFrame into the local namespace since they
    are so frequently used:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当在代码中看到`pd.`时，它指的是pandas。您可能也会发现将Series和DataFrame导入到本地命名空间中更容易，因为它们经常被使用：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 5.1 Introduction to pandas Data Structures
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 pandas数据结构简介
- en: 'To get started with pandas, you will need to get comfortable with its two workhorse
    data structures: *Series* and *DataFrame*. While they are not a universal solution
    for every problem, they provide a solid foundation for a wide variety of data
    tasks.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用pandas，您需要熟悉其两个主要数据结构：*Series*和*DataFrame*。虽然它们并非适用于每个问题的通用解决方案，但它们为各种数据任务提供了坚实的基础。
- en: Series
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Series
- en: 'A Series is a one-dimensional array-like object containing a sequence of values
    (of similar types to NumPy types) of the same type and an associated array of
    data labels, called its *index*. The simplest Series is formed from only an array
    of data:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Series是一个一维数组样对象，包含一系列值（与NumPy类型相似的类型）和一个关联的数据标签数组，称为*索引*。最简单的Series是仅由数据数组形成的：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The string representation of a Series displayed interactively shows the index
    on the left and the values on the right. Since we did not specify an index for
    the data, a default one consisting of the integers `0` through `N - 1` (where
    `N` is the length of the data) is created. You can get the array representation
    and index object of the Series via its `array` and `index` attributes, respectively:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Series的交互式显示的字符串表示在左侧显示索引，右侧显示值。由于我们没有为数据指定索引，因此会创建一个默认索引，由整数`0`到`N-1`（其中`N`是数据的长度）组成。您可以通过其`array`和`index`属性分别获取Series的数组表示和索引对象：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result of the `.array` attribute is a `PandasArray` which usually wraps
    a NumPy array but can also contain special extension array types which will be
    discussed more in [Ch 7.3: Extension Data Types](/book/data-cleaning#pandas-ext-types).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`.array`属性的结果是一个`PandasArray`，通常包装了一个NumPy数组，但也可以包含特殊的扩展数组类型，这将在[Ch 7.3：扩展数据类型](/book/data-cleaning#pandas-ext-types)中更详细讨论。'
- en: 'Often, you''ll want to create a Series with an index identifying each data
    point with a label:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会希望创建一个带有标识每个数据点的索引的Series：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compared with NumPy arrays, you can use labels in the index when selecting
    single values or a set of values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与NumPy数组相比，当选择单个值或一组值时，可以在索引中使用标签：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here `["c", "a", "d"]` is interpreted as a list of indices, even though it contains
    strings instead of integers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`["c", "a", "d"]`被解释为索引列表，即使它包含字符串而不是整数。
- en: 'Using NumPy functions or NumPy-like operations, such as filtering with a Boolean
    array, scalar multiplication, or applying math functions, will preserve the index-value
    link:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy函数或类似NumPy的操作，例如使用布尔数组进行过滤、标量乘法或应用数学函数，将保留索引值链接：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way to think about a Series is as a fixed-length, ordered dictionary,
    as it is a mapping of index values to data values. It can be used in many contexts
    where you might use a dictionary:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将Series视为固定长度的有序字典的另一种方式，因为它是索引值到数据值的映射。它可以在许多上下文中使用，您可能会使用字典：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Should you have data contained in a Python dictionary, you can create a Series
    from it by passing the dictionary:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据包含在Python字典中，可以通过传递字典来创建一个Series：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A Series can be converted back to a dictionary with its `to_dict` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Series可以使用其`to_dict`方法转换回字典：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you are only passing a dictionary, the index in the resulting Series will
    respect the order of the keys according to the dictionary''s `keys` method, which
    depends on the key insertion order. You can override this by passing an index
    with the dictionary keys in the order you want them to appear in the resulting
    Series:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只传递一个字典时，生成的Series中的索引将遵循字典的`keys`方法的键的顺序，这取决于键插入顺序。您可以通过传递一个索引，其中包含字典键的顺序，以便它们出现在生成的Series中的顺序来覆盖这一点：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, three values found in `sdata` were placed in the appropriate locations,
    but since no value for `"California"` was found, it appears as `NaN` (Not a Number),
    which is considered in pandas to mark missing or *NA* values. Since `"Utah"` was
    not included in `states`, it is excluded from the resulting object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sdata`中找到的三个值被放置在适当的位置，但由于没有找到`"California"`的值，它显示为`NaN`（不是一个数字），在pandas中被视为标记缺失或*NA*值。由于`states`中没有包含`"Utah"`，因此它被排除在结果对象之外。
- en: 'I will use the terms “missing,” “NA,” or “null” interchangeably to refer to
    missing data. The `isna` and `notna` functions in pandas should be used to detect
    missing data:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用术语“missing”、“NA”或“null”来交替引用缺失数据。应该使用pandas中的`isna`和`notna`函数来检测缺失数据：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Series also has these as instance methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Series还具有这些作为实例方法：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I discuss working with missing data in more detail in [Ch 7: Data Cleaning
    and Preparation](/book/data-cleaning).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第7章：数据清洗和准备](/book/data-cleaning)中更详细地讨论处理缺失数据的工作。
- en: 'A useful Series feature for many applications is that it automatically aligns
    by index label in arithmetic operations:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，Series的一个有用特性是它在算术运算中自动按索引标签对齐：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data alignment features will be addressed in more detail later. If you have
    experience with databases, you can think about this as being similar to a join
    operation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对齐功能将在后面更详细地讨论。如果您有数据库经验，可以将其视为类似于连接操作。
- en: 'Both the Series object itself and its index have a `name` attribute, which
    integrates with other areas of pandas functionality:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Series对象本身和其索引都有一个`name`属性，它与pandas功能的其他区域集成：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A Series’s index can be altered in place by assignment:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Series的索引可以通过赋值来直接更改：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: DataFrame
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataFrame
- en: A DataFrame represents a rectangular table of data and contains an ordered,
    named collection of columns, each of which can be a different value type (numeric,
    string, Boolean, etc.). The DataFrame has both a row and column index; it can
    be thought of as a dictionary of Series all sharing the same index.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame表示数据的矩形表，并包含一个有序的、命名的列集合，每个列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引又有列索引；它可以被视为共享相同索引的一系列Series的字典。
- en: '*Note* *While a DataFrame is physically two-dimensional, you can use it to
    represent higher dimensional data in a tabular format using hierarchical indexing,
    a subject we will discuss in [Ch 8: Data Wrangling: Join, Combine, and Reshape](/book/data-wrangling)
    and an ingredient in some of the more advanced data-handling features in pandas.*  *There
    are many ways to construct a DataFrame, though one of the most common is from
    a dictionary of equal-length lists or NumPy arrays:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *虽然DataFrame在物理上是二维的，但您可以使用它来以分层索引的方式表示更高维度的数据，这是我们将在[第8章：数据整理：连接、合并和重塑](/book/data-wrangling)中讨论的一个主题，并且是pandas中一些更高级数据处理功能的一个组成部分。*  *有许多构建DataFrame的方法，尽管其中最常见的一种是从等长列表或NumPy数组的字典中构建：'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting DataFrame will have its index assigned automatically, as with
    Series, and the columns are placed according to the order of the keys in `data`
    (which depends on their insertion order in the dictionary):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的DataFrame将自动分配其索引，与Series一样，并且列根据`data`中键的顺序放置（取决于字典中的插入顺序）：
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Note* *If you are using the Jupyter notebook, pandas DataFrame objects will
    be displayed as a more browser-friendly HTML table. See [Figure 5.1](#fig-figure_pandas_df_html_table)
    for an example.*  *![](../Images/80bf6ca7e96e78f9839a73591d77f472.png)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *如果您正在使用Jupyter笔记本，pandas DataFrame对象将显示为更适合浏览器的HTML表格。请参见[图5.1](#fig-figure_pandas_df_html_table)作为示例。*  *![](../Images/80bf6ca7e96e78f9839a73591d77f472.png)'
- en: 'Figure 5.1: How pandas DataFrame objects look in Jupyter'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：Jupyter中pandas DataFrame对象的外观
- en: 'For large DataFrames, the `head` method selects only the first five rows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型DataFrame，`head`方法仅选择前五行：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, `tail` returns the last five rows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`tail`返回最后五行：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you specify a sequence of columns, the DataFrame’s columns will be arranged
    in that order:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定一系列列，DataFrame的列将按照该顺序排列：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you pass a column that isn’t contained in the dictionary, it will appear
    with missing values in the result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递一个字典中不包含的列，它将以缺失值的形式出现在结果中：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A column in a DataFrame can be retrieved as a Series either by dictionary-like
    notation or by using the dot attribute notation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame中的列可以通过类似字典的表示法或使用点属性表示法检索为Series：
- en: '[PRE22]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Note* *Attribute-like access (e.g., `frame2.year`) and tab completion of column
    names in IPython are provided as a convenience.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *提供类似属性访问（例如，`frame2.year`）和IPython中列名称的制表符补全作为便利。'
- en: '`frame2[column]` works for any column name, but `frame2.column` works only
    when the column name is a valid Python variable name and does not conflict with
    any of the method names in DataFrame. For example, if a column''s name contains
    whitespace or symbols other than underscores, it cannot be accessed with the dot
    attribute method.*  *Note that the returned Series have the same index as the
    DataFrame, and their `name` attribute has been appropriately set.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame2[column]`适用于任何列名，但只有当列名是有效的Python变量名且不与DataFrame中的任何方法名冲突时，`frame2.column`才适用。例如，如果列名包含空格或下划线以外的其他符号，则无法使用点属性方法访问。*
    *请注意，返回的Series具有与DataFrame相同的索引，并且它们的`name`属性已经适当设置。'
- en: 'Rows can also be retrieved by position or name with the special `iloc` and
    `loc` attributes (more on this later in [Selection on DataFrame with loc and iloc](#pandas-loc-iloc)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 行也可以通过特殊的`iloc`和`loc`属性按位置或名称检索（稍后在[使用loc和iloc在DataFrame上进行选择](#pandas-loc-iloc)中详细介绍）：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Columns can be modified by assignment. For example, the empty `debt` column
    could be assigned a scalar value or an array of values:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列可以通过赋值进行修改。例如，可以为空的`debt`列分配一个标量值或一个值数组：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you are assigning lists or arrays to a column, the value’s length must
    match the length of the DataFrame. If you assign a Series, its labels will be
    realigned exactly to the DataFrame’s index, inserting missing values in any index
    values not present:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当将列表或数组分配给列时，值的长度必须与DataFrame的长度相匹配。如果分配一个Series，其标签将被重新对齐到DataFrame的索引，插入任何不存在的索引值的缺失值：
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Assigning a column that doesn’t exist will create a new column.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个不存在的列将创建一个新列。
- en: 'The `del` keyword will delete columns like with a dictionary. As an example,
    I first add a new column of Boolean values where the `state` column equals `"Ohio"`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`del`关键字将像字典一样删除列。例如，首先添加一个新列，其中布尔值等于`"Ohio"`的`state`列：'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Caution* *New columns cannot be created with the `frame2.eastern` dot attribute
    notation.*  *The `del` method can then be used to remove this column:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告* *不能使用`frame2.eastern`点属性表示法创建新列。* *然后可以使用`del`方法删除此列：'
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Caution* *The column returned from indexing a DataFrame is a *view* on the
    underlying data, not a copy. Thus, any in-place modifications to the Series will
    be reflected in the DataFrame. The column can be explicitly copied with the Series’s
    `copy` method.*  *Another common form of data is a nested dictionary of dictionaries:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *从DataFrame索引返回的列是基础数据的*视图*，而不是副本。因此，对Series的任何原地修改都将反映在DataFrame中。可以使用Series的`copy`方法显式复制列。*
    *另一种常见的数据形式是嵌套字典的字典：'
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the nested dictionary is passed to the DataFrame, pandas will interpret
    the outer dictionary keys as the columns, and the inner keys as the row indices:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将嵌套字典传递给DataFrame，pandas将解释外部字典键为列，内部键为行索引：
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can transpose the DataFrame (swap rows and columns) with similar syntax
    to a NumPy array:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似于NumPy数组的语法转置DataFrame（交换行和列）：
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Warning* *Note that transposing discards the column data types if the columns
    do not all have the same data type, so transposing and then transposing back may
    lose the previous type information. The columns become arrays of pure Python objects
    in this case.*  *The keys in the inner dictionaries are combined to form the index
    in the result. This isn’t true if an explicit index is specified:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告* *请注意，如果列的数据类型不全都相同，则转置会丢弃列数据类型，因此转置然后再次转置可能会丢失先前的类型信息。在这种情况下，列变成了纯Python对象的数组。*
    *内部字典中的键被组合以形成结果中的索引。如果指定了显式索引，则这种情况不成立：'
- en: '[PRE31]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Dictionaries of Series are treated in much the same way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Series的字典以类似的方式处理：
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For a list of many of the things you can pass to the DataFrame constructor,
    see [Table 5.1](#tbl-table_dataframe_constructor).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可以传递给DataFrame构造函数的许多内容，请参见[表5.1](#tbl-table_dataframe_constructor)。
- en: 'Table 5.1: Possible data inputs to the DataFrame constructor'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：DataFrame构造函数的可能数据输入
- en: '| Type | Notes |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 注释 |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2D ndarray | A matrix of data, passing optional row and column labels |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 2D ndarray | 一组数据的矩阵，传递可选的行和列标签 |'
- en: '| Dictionary of arrays, lists, or tuples | Each sequence becomes a column in
    the DataFrame; all sequences must be the same length |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 数组、列表或元组的字典 | 每个序列都变成了DataFrame中的一列；所有序列必须具有相同的长度 |'
- en: '| NumPy structured/record array | Treated as the “dictionary of arrays” case
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| NumPy结构化/记录数组 | 被视为“数组的字典”情况 |'
- en: '| Dictionary of Series | Each value becomes a column; indexes from each Series
    are unioned together to form the result’s row index if no explicit index is passed
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| Series的字典 | 每个值都变成了一列；如果没有传递显式索引，则每个Series的索引被合并在一起以形成结果的行索引 |'
- en: '| Dictionary of dictionaries | Each inner dictionary becomes a column; keys
    are unioned to form the row index as in the “dictionary of Series” case |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 字典的字典 | 每个内部字典都变成了一列；键被合并以形成行索引，就像“Series的字典”情况一样 |'
- en: '| List of dictionaries or Series | Each item becomes a row in the DataFrame;
    unions of dictionary keys or Series indexes become the DataFrame’s column labels
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 字典或Series的列表 | 每个项目都变成了DataFrame中的一行；字典键或Series索引的并集成为DataFrame的列标签 |'
- en: '| List of lists or tuples | Treated as the “2D ndarray” case |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 列表或元组的列表 | 被视为“2D ndarray”情况 |'
- en: '| Another DataFrame | The DataFrame’s indexes are used unless different ones
    are passed |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 另一个DataFrame | 除非传递了不同的索引，否则将使用DataFrame的索引 |'
- en: '| NumPy MaskedArray | Like the “2D ndarray” case except masked values are missing
    in the DataFrame result |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| NumPy MaskedArray | 与“2D ndarray”情况类似，只是在DataFrame结果中缺少掩码值 |'
- en: 'If a DataFrame’s `index` and `columns` have their `name` attributes set, these
    will also be displayed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DataFrame的`index`和`columns`有设置它们的`name`属性，这些也会被显示出来：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unlike Series, DataFrame does not have a `name` attribute. DataFrame''s `to_numpy`
    method returns the data contained in the DataFrame as a two-dimensional ndarray:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与Series不同，DataFrame没有`name`属性。DataFrame的`to_numpy`方法将DataFrame中包含的数据作为二维ndarray返回：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the DataFrame’s columns are different data types, the data type of the returned
    array will be chosen to accommodate all of the columns:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DataFrame的列是不同的数据类型，则返回的数组的数据类型将被选择以容纳所有列：
- en: '[PRE35]******  ***### Index Objects'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]******  ***### 索引对象'
- en: 'pandas’s Index objects are responsible for holding the axis labels (including
    a DataFrame''s column names) and other metadata (like the axis name or names).
    Any array or other sequence of labels you use when constructing a Series or DataFrame
    is internally converted to an Index:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: pandas的Index对象负责保存轴标签（包括DataFrame的列名）和其他元数据（如轴名称）。在构建Series或DataFrame时使用的任何数组或其他标签序列都会在内部转换为Index：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Index objects are immutable and thus can’t be modified by the user:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Index对象是不可变的，因此用户无法修改它们：
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Immutability makes it safer to share Index objects among data structures:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性使得在数据结构之间共享Index对象更加安全：
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Caution* *Some users will not often take advantage of the capabilities provided
    by an Index, but because some operations will yield results containing indexed
    data, it''s important to understand how they work.*  *In addition to being array-like,
    an Index also behaves like a fixed-size set:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *一些用户可能不经常利用Index提供的功能，但由于一些操作会产生包含索引数据的结果，因此了解它们的工作原理是很重要的。* *除了类似数组，Index还表现得像一个固定大小的集合：'
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Unlike Python sets, a pandas Index can contain duplicate labels:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python集合不同，pandas的Index可以包含重复标签：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Selections with duplicate labels will select all occurrences of that label.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 具有重复标签的选择将选择该标签的所有出现。
- en: Each Index has a number of methods and properties for set logic, which answer
    other common questions about the data it contains. Some useful ones are summarized
    in [Table 5.2](#tbl-table_index_methods).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Index都有一些用于集合逻辑的方法和属性，可以回答关于其包含的数据的其他常见问题。一些有用的方法总结在[Table 5.2](#tbl-table_index_methods)中。
- en: 'Table 5.2: Some Index methods and properties'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Table 5.2: 一些索引方法和属性'
- en: '| Method/Property | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 方法/属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `append()` | Concatenate with additional Index objects, producing a new Index
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `append()` | 与其他Index对象连接，生成一个新的Index |'
- en: '| `difference()` | Compute set difference as an Index |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `difference()` | 计算索引的差集 |'
- en: '| `intersection()` | Compute set intersection |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `intersection()` | 计算集合交集 |'
- en: '| `union()` | Compute set union |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `union()` | 计算集合并 |'
- en: '| `isin()` | Compute Boolean array indicating whether each value is contained
    in the passed collection |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `isin()` | 计算布尔数组，指示每个值是否包含在传递的集合中 |'
- en: '| `delete()` | Compute new Index with element at Index `i` deleted |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `delete()` | 通过删除索引`i`处的元素来计算新的索引 |'
- en: '| `drop()` | Compute new Index by deleting passed values |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `drop()` | 通过删除传递的值来计算新的索引 |'
- en: '| `insert()` | Compute new Index by inserting element at Index `i` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `insert()` | 通过在索引`i`处插入元素来计算新的索引 |'
- en: '| `is_monotonic` | Returns `True` if each element is greater than or equal
    to the previous element |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `is_monotonic` | 如果每个元素大于或等于前一个元素则返回`True` |'
- en: '| `is_unique` | Returns `True` if the Index has no duplicate values |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `is_unique` | 如果索引没有重复值则返回`True` |'
- en: '| `unique()` | Compute the array of unique values in the Index |****  ***##
    5.2 Essential Functionality'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| `unique()` | 计算索引中唯一值的数组 |****  ***## 5.2 基本功能'
- en: This section will walk you through the fundamental mechanics of interacting
    with the data contained in a Series or DataFrame. In the chapters to come, we
    will delve more deeply into data analysis and manipulation topics using pandas.
    This book is not intended to serve as exhaustive documentation for the pandas
    library; instead, we'll focus on familiarizing you with heavily used features,
    leaving the less common (i.e., more esoteric) things for you to learn more about
    by reading the online pandas documentation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带领您了解与Series或DataFrame中包含的数据进行交互的基本机制。在接下来的章节中，我们将更深入地探讨使用pandas进行数据分析和操作的主题。本书不旨在作为pandas库的详尽文档，而是专注于让您熟悉常用功能，将不太常见的（即更神秘的）内容留给您通过阅读在线pandas文档来学习。
- en: Reindexing
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新索引
- en: 'An important method on pandas objects is `reindex`, which means to create a
    new object with the values rearranged to align with the new index. Consider an
    example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: pandas对象上的一个重要方法是`reindex`，它意味着创建一个新对象，其值重新排列以与新索引对齐。考虑一个例子：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Calling `reindex` on this Series rearranges the data according to the new index,
    introducing missing values if any index values were not already present:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Series上调用`reindex`会根据新索引重新排列数据，如果某些索引值之前不存在，则会引入缺失值：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For ordered data like time series, you may want to do some interpolation or
    filling of values when reindexing. The `method` option allows us to do this, using
    a method such as `ffill`, which forward-fills the values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有序数据如时间序列，当重新索引时可能需要进行一些插值或值填充。`method`选项允许我们使用`ffill`这样的方法来实现，它可以向前填充值：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With DataFrame, `reindex` can alter the (row) index, columns, or both. When
    passed only a sequence, it reindexes the rows in the result:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，`reindex`可以改变（行）索引、列或两者。当只传递一个序列时，它会重新索引结果中的行：
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The columns can be reindexed with the `columns` keyword:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`columns`关键字重新索引列：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because `"Ohio"` was not in `states`, the data for that column is dropped from
    the result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`"Ohio"`不在`states`中，所以该列的数据被从结果中删除。
- en: 'Another way to reindex a particular axis is to pass the new axis labels as
    a positional argument and then specify the axis to reindex with the `axis` keyword:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重新索引特定轴的另一种方法是将新的轴标签作为位置参数传递，然后使用`axis`关键字指定要重新索引的轴：
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See [Table 5.3](#tbl-table_reindex_function) for more about the arguments to
    `reindex`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[Table 5.3](#tbl-table_reindex_function)以了解有关`reindex`参数的更多信息。
- en: 'Table 5.3: `reindex` function arguments'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3：`reindex`函数参数
- en: '| Argument | Description |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `labels` | New sequence to use as an index. Can be Index instance or any
    other sequence-like Python data structure. An Index will be used exactly as is
    without any copying. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `labels` | 用作索引的新序列。可以是Index实例或任何其他类似序列的Python数据结构。Index将被完全使用，不会进行任何复制。
    |'
- en: '| `index` | Use the passed sequence as the new index labels. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 使用传递的序列作为新的索引标签。 |'
- en: '| `columns` | Use the passed sequence as the new column labels. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `columns` | 使用传递的序列作为新的列标签。 |'
- en: '| `axis` | The axis to reindex, whether `"index"` (rows) or `"columns"`. The
    default is `"index"`. You can alternately do `reindex(index=new_labels)` or `reindex(columns=new_labels)`.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | 要重新索引的轴，无论是`"index"`（行）还是`"columns"`。默认为`"index"`。您也可以使用`reindex(index=new_labels)`或`reindex(columns=new_labels)`。
    |'
- en: '| `method` | Interpolation (fill) method; `"ffill"` fills forward, while `"bfill"`
    fills backward. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `method` | 插值（填充）方法；`"ffill"`向前填充，而`"bfill"`向后填充。 |'
- en: '| `fill_value` | Substitute value to use when introducing missing data by reindexing.
    Use `fill_value="missing"` (the default behavior) when you want absent labels
    to have null values in the result. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `fill_value` | 重新索引时引入缺失数据时要使用的替代值。当您希望缺失标签在结果中具有空值时，请使用`fill_value="missing"`（默认行为）。
    |'
- en: '| `limit` | When forward filling or backfilling, the maximum size gap (in number
    of elements) to fill. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `limit` | 在向前填充或向后填充时，要填充的最大大小间隙（元素数量）。 |'
- en: '| `tolerance` | When forward filling or backfilling, the maximum size gap (in
    absolute numeric distance) to fill for inexact matches. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `tolerance` | 在向前填充或向后填充时，要填充的最大大小间隙（绝对数值距离）。 |'
- en: '| `level` | Match simple Index on level of MultiIndex; otherwise select subset
    of. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `level` | 在MultiIndex级别上匹配简单索引；否则选择子集。 |'
- en: '| `copy` | If `True`, always copy underlying data even if the new index is
    equivalent to the old index; if `False`, do not copy the data when the indexes
    are equivalent. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | 如果为`True`，即使新索引等效于旧索引，也始终复制基础数据；如果为`False`，当索引等效时不复制数据。 |'
- en: 'As we''ll explore later in [Selection on DataFrame with loc and iloc](#pandas-loc-iloc),
    you can also reindex by using the `loc` operator, and many users prefer to always
    do it this way. This works only if all of the new index labels already exist in
    the DataFrame (whereas `reindex` will insert missing data for new labels):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将在[使用loc和iloc在DataFrame上进行选择](#pandas-loc-iloc)中探讨的，您也可以通过使用`loc`运算符重新索引，许多用户更喜欢始终以这种方式进行操作。这仅在所有新索引标签已存在于DataFrame中时才有效（而`reindex`将为新标签插入缺失数据）：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Dropping Entries from an Axis
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从轴中删除条目
- en: 'Dropping one or more entries from an axis is simple if you already have an
    index array or list without those entries, since you can use the `reindex` method
    or `.loc`-based indexing. As that can require a bit of munging and set logic,
    the `drop` method will return a new object with the indicated value or values
    deleted from an axis:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经有一个不包含这些条目的索引数组或列表，那么从轴中删除一个或多个条目就很简单，因为您可以使用`reindex`方法或基于`.loc`的索引。由于这可能需要一些数据处理和集合逻辑，`drop`方法将返回一个新对象，其中包含从轴中删除的指定值或值：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With DataFrame, index values can be deleted from either axis. To illustrate
    this, we first create an example DataFrame:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame，可以从任一轴删除索引值。为了说明这一点，我们首先创建一个示例DataFrame：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Calling `drop` with a sequence of labels will drop values from the row labels
    (axis 0):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一系列标签调用`drop`将从行标签（轴0）中删除值：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To drop labels from the columns, instead use the `columns` keyword:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列中删除标签，而不是使用`columns`关键字：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also drop values from the columns by passing `axis=1` (which is like
    NumPy) or `axis="columns"`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过传递`axis=1`（类似于NumPy）或`axis="columns"`来从列中删除值：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Indexing, Selection, and Filtering
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引、选择和过滤
- en: 'Series indexing (`obj[...]`) works analogously to NumPy array indexing, except
    you can use the Series’s index values instead of only integers. Here are some
    examples of this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Series索引（`obj[...]`）的工作方式类似于NumPy数组索引，只是您可以使用Series的索引值而不仅仅是整数。以下是一些示例：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'While you can select data by label this way, the preferred way to select index
    values is with the special `loc` operator:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以通过标签这种方式选择数据，但选择索引值的首选方式是使用特殊的`loc`运算符：
- en: '[PRE54]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The reason to prefer `loc` is because of the different treatment of integers
    when indexing with `[]`. Regular `[]`-based indexing will treat integers as labels
    if the index contains integers, so the behavior differs depending on the data
    type of the index. For example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更喜欢`loc`的原因是因为在使用`[]`进行索引时，对整数的处理方式不同。如果索引包含整数，常规的`[]`索引将将整数视为标签，因此行为取决于索引的数据类型。例如：
- en: '[PRE55]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When using `loc`, the expression `obj.loc[[0, 1, 2]]` will fail when the index
    does not contain integers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`loc`时，当索引不包含整数时，表达式`obj.loc[[0, 1, 2]]`将失败：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since `loc` operator indexes exclusively with labels, there is also an `iloc`
    operator that indexes exclusively with integers to work consistently whether or
    not the index contains integers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`loc`运算符仅使用标签进行索引，因此还有一个`iloc`运算符，它仅使用整数进行索引，以便在索引包含整数或不包含整数时始终保持一致：
- en: '[PRE57]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Caution* *You can also slice with labels, but it works differently from normal
    Python slicing in that the endpoint is inclusive:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *您也可以使用标签进行切片，但与正常的Python切片不同，终点是包含的：'
- en: '[PRE58]*  *Assigning values using these methods modifies the corresponding
    section of the Series:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE58]*  *使用这些方法分配值会修改Series的相应部分：'
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Note* *It can be a common newbie error to try to call `loc` or `iloc` like
    functions rather than "indexing into" them with square brackets. The square bracket
    notation is used to enable slice operations and to allow for indexing on multiple
    axes with DataFrame objects.*  *Indexing into a DataFrame retrieves one or more
    columns either with a single value or sequence:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *尝试调用`loc`或`iloc`等函数而不是使用方括号“索引”可能是新手的常见错误。方括号表示用于启用切片操作并允许在DataFrame对象上的多个轴上进行索引。*  *在DataFrame中进行索引会检索一个或多个列，可以使用单个值或序列：'
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Indexing like this has a few special cases. The first is slicing or selecting
    data with a Boolean array:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种索引有一些特殊情况。第一个是使用布尔数组进行切片或选择数据：
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The row selection syntax `data[:2]` is provided as a convenience. Passing a
    single element or a list to the `[]` operator selects columns.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 行选择语法`data[:2]`是作为一种便利提供的。将单个元素或列表传递给`[]`运算符将选择列。
- en: 'Another use case is indexing with a Boolean DataFrame, such as one produced
    by a scalar comparison. Consider a DataFrame with all Boolean values produced
    by comparing with a scalar value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是使用布尔DataFrame进行索引，比如通过标量比较生成的DataFrame。考虑一个通过与标量值比较生成的全布尔值的DataFrame：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can use this DataFrame to assign the value 0 to each location with the value
    `True`, like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个DataFrame将值为`True`的位置赋值为0，就像这样：
- en: '[PRE63]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Selection on DataFrame with loc and iloc
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用loc和iloc在DataFrame上进行选择
- en: Like Series, DataFrame has special attributes `loc` and `iloc` for label-based
    and integer-based indexing, respectively. Since DataFrame is two-dimensional,
    you can select a subset of the rows and columns with NumPy-like notation using
    either axis labels (`loc`) or integers (`iloc`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与Series一样，DataFrame具有专门的属性`loc`和`iloc`，用于基于标签和基于整数的索引。由于DataFrame是二维的，您可以使用类似NumPy的符号使用轴标签（`loc`）或整数（`iloc`）选择行和列的子集。
- en: 'As a first example, let''s select a single row by label:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个示例，让我们通过标签选择单行：
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The result of selecting a single row is a Series with an index that contains
    the DataFrame''s column labels. To select multiple roles, creating a new DataFrame,
    pass a sequence of labels:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 选择单行的结果是一个带有包含DataFrame列标签的索引的Series。要选择多个行，创建一个新的DataFrame，传递一个标签序列：
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can combine both row and column selection in `loc` by separating the selections
    with a comma:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过用逗号分隔选择在`loc`中同时选择行和列：
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We''ll then perform some similar selections with integers using `iloc`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用`iloc`执行一些类似的整数选择：
- en: '[PRE67]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Both indexing functions work with slices in addition to single labels or lists
    of labels:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个索引函数都可以处理切片，除了单个标签或标签列表：
- en: '[PRE68]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Boolean arrays can be used with `loc` but not `iloc`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组可以与`loc`一起使用，但不能与`iloc`一起使用：
- en: '[PRE69]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There are many ways to select and rearrange the data contained in a pandas object.
    For DataFrame, [Table 5.4](#tbl-table_dataframe_loc_iloc) provides a short summary
    of many of them. As you will see later, there are a number of additional options
    for working with hierarchical indexes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以选择和重新排列pandas对象中包含的数据。对于DataFrame，[表5.4](#tbl-table_dataframe_loc_iloc)提供了许多这些方法的简要总结。正如您将在后面看到的，还有许多其他选项可用于处理分层索引。
- en: 'Table 5.4: Indexing options with DataFrame'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.4：DataFrame的索引选项
- en: '| Type | Notes |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 注释 |'
- en: '| --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `df[column]` | Select single column or sequence of columns from the DataFrame;
    special case conveniences: Boolean array (filter rows), slice (slice rows), or
    Boolean DataFrame (set values based on some criterion) |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `df[column]` | 从DataFrame中选择单个列或列序列；特殊情况便利：布尔数组（过滤行）、切片（切片行）或布尔DataFrame（根据某些条件设置值）
    |'
- en: '| `df.loc[rows]` | Select single row or subset of rows from the DataFrame by
    label |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `df.loc[rows]` | 通过标签从DataFrame中选择单行或行子集 |'
- en: '| `df.loc[:, cols]` | Select single column or subset of columns by label |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `df.loc[:, cols]` | 通过标签选择单个列或列子集 |'
- en: '| `df.loc[rows, cols]` | Select both row(s) and column(s) by label |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `df.loc[rows, cols]` | 通过标签选择行和列 |'
- en: '| `df.iloc[rows]` | Select single row or subset of rows from the DataFrame
    by integer position |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `df.iloc[rows]` | 通过整数位置从DataFrame中选择单行或行子集 |'
- en: '| `df.iloc[:, cols]` | Select single column or subset of columns by integer
    position |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `df.iloc[:, cols]` | 通过整数位置选择单个列或列子集 |'
- en: '| `df.iloc[rows, cols]` | Select both row(s) and column(s) by integer position
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `df.iloc[rows, cols]` | 通过整数位置选择行和列 |'
- en: '| `df.at[row, col]` | Select a single scalar value by row and column label
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `df.at[row, col]` | 通过行和列标签选择单个标量值 |'
- en: '| `df.iat[row, col]` | Select a single scalar value by row and column position
    (integers) |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `df.iat[row, col]` | 通过行和列位置（整数）选择单个标量值 |'
- en: '| `reindex` method | Select either rows or columns by labels |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `reindex`方法 | 通过标签选择行或列 |'
- en: Integer indexing pitfalls
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整数索引的陷阱
- en: 'Working with pandas objects indexed by integers can be a stumbling block for
    new users since they work differently from built-in Python data structures like
    lists and tuples. For example, you might not expect the following code to generate
    an error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数索引的pandas对象可能会成为新用户的绊脚石，因为它们与内置的Python数据结构（如列表和元组）的工作方式不同。例如，您可能不会期望以下代码生成错误：
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this case, pandas could “fall back” on integer indexing, but it is difficult
    to do this in general without introducing subtle bugs into the user code. Here
    we have an index containing `0`, `1`, and `2`, but pandas does not want to guess
    what the user wants (label-based indexing or position-based):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，pandas可能会“回退”到整数索引，但是在不引入对用户代码中微妙错误的情况下，通常很难做到这一点。在这里，我们有一个包含`0`、`1`和`2`的索引，但pandas不想猜测用户想要什么（基于标签的索引还是基于位置的）：
- en: '[PRE71]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'On the other hand, with a noninteger index, there is no such ambiguity:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于非整数索引，没有这种歧义：
- en: '[PRE72]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you have an axis index containing integers, data selection will always be
    label oriented. As I said above, if you use `loc` (for labels) or `iloc` (for
    integers) you will get exactly what you want:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有包含整数的轴索引，数据选择将始终是基于标签的。正如我上面所说的，如果您使用`loc`（用于标签）或`iloc`（用于整数），您将得到确切想要的结果：
- en: '[PRE73]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'On the other hand, slicing with integers is always integer oriented:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用整数进行切片始终是基于整数的：
- en: '[PRE74]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As a result of these pitfalls, it is best to always prefer indexing with `loc`
    and `iloc` to avoid ambiguity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些陷阱，最好始终优先使用`loc`和`iloc`进行索引，以避免歧义。
- en: Pitfalls with chained indexing
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链式索引的陷阱
- en: In the previous section we looked at how you can do flexible selections on a
    DataFrame using `loc` and `iloc`. These indexing attributes can also be used to
    modify DataFrame objects in place, but doing so requires some care.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了如何使用`loc`和`iloc`在DataFrame上进行灵活的选择。这些索引属性也可以用于就地修改DataFrame对象，但这样做需要一些小心。
- en: 'For example, in the example DataFrame above, we can assign to a column or row
    by label or integer position:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的DataFrame示例中，我们可以按标签或整数位置分配到列或行：
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A common gotcha for new pandas users is to chain selections when assigning,
    like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新的pandas用户来说，一个常见的坑是在赋值时链接选择，就像这样：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Depending on the data contents, this may print a special `SettingWithCopyWarning`,
    which warns you that you are trying to modify a temporary value (the nonempty
    result of `data.loc[data.three == 5]`) instead of the original DataFrame `data`,
    which might be what you were intending. Here, `data` was unmodified:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据内容的不同，这可能会打印一个特殊的`SettingWithCopyWarning`，它警告您正在尝试修改一个临时值（`data.loc[data.three
    == 5]`的非空结果），而不是原始DataFrame`data`，这可能是您的本意。在这里，`data`没有被修改：
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In these scenarios, the fix is to rewrite the chained assignment to use a single
    `loc` operation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，修复的方法是重写链接赋值，使用单个`loc`操作：
- en: '[PRE78]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: A good rule of thumb is to avoid chained indexing when doing assignments. There
    are other cases where pandas will generate `SettingWithCopyWarning` that have
    to do with chained indexing. I refer you to this topic in the online pandas documentation.**  **###
    Arithmetic and Data Alignment
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是在进行赋值时避免链接索引。还有其他情况下，pandas会生成`SettingWithCopyWarning`，这与链接索引有关。我建议您查阅在线pandas文档中的这个主题。**  **###
    算术和数据对齐
- en: 'pandas can make it much simpler to work with objects that have different indexes.
    For example, when you add objects, if any index pairs are not the same, the respective
    index in the result will be the union of the index pairs. Let’s look at an example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: pandas可以使处理具有不同索引的对象变得更简单。例如，当您添加对象时，如果任何索引对不相同，结果中的相应索引将是索引对的并集。让我们看一个例子：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Adding these yields:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们相加得到：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The internal data alignment introduces missing values in the label locations
    that don’t overlap. Missing values will then propagate in further arithmetic computations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内部数据对齐会在不重叠的标签位置引入缺失值。缺失值将在进一步的算术计算中传播。
- en: 'In the case of DataFrame, alignment is performed on both rows and columns:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，对齐是在行和列上执行的：
- en: '[PRE81]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Adding these returns a DataFrame with index and columns that are the unions
    of the ones in each DataFrame:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们相加返回一个DataFrame，其索引和列是每个DataFrame中的索引的并集：
- en: '[PRE82]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Since the `"c"` and `"e"` columns are not found in both DataFrame objects, they
    appear as missing in the result. The same holds for the rows with labels that
    are not common to both objects.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DataFrame对象中都没有找到`"c"`和`"e"`列，它们在结果中显示为缺失。对于标签不共同的行也是如此。
- en: 'If you add DataFrame objects with no column or row labels in common, the result
    will contain all nulls:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加没有共同列或行标签的DataFrame对象，结果将包含所有空值：
- en: '[PRE83]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Arithmetic methods with fill values
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有填充值的算术方法
- en: 'In arithmetic operations between differently indexed objects, you might want
    to fill with a special value, like 0, when an axis label is found in one object
    but not the other. Here is an example where we set a particular value to NA (null)
    by assigning `np.nan` to it:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同索引对象之间的算术操作中，当一个对象中找到一个轴标签而另一个对象中没有时，您可能希望填充一个特殊值，比如0。以下是一个示例，我们通过将`np.nan`赋值给它来将特定值设置为NA（null）：
- en: '[PRE84]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Adding these results in missing values in the locations that don’t overlap:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们相加会导致不重叠位置的缺失值：
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Using the `add` method on `df1`, I pass `df2` and an argument to `fill_value`,
    which substitutes the passed value for any missing values in the operation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`df1`上使用`add`方法，我传递`df2`和一个参数给`fill_value`，它会用传递的值替换操作中的任何缺失值：
- en: '[PRE86]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'See [Table 5.5](#tbl-table_flex_arith) for a listing of Series and DataFrame
    methods for arithmetic. Each has a counterpart, starting with the letter `r`,
    that has arguments reversed. So these two statements are equivalent:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[表5.5](#tbl-table_flex_arith)以获取有关算术的Series和DataFrame方法的列表。每个方法都有一个对应的方法，以字母`r`开头，参数顺序相反。因此，以下两个语句是等价的：
- en: '[PRE87]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Relatedly, when reindexing a Series or DataFrame, you can also specify a different
    fill value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，在重新索引Series或DataFrame时，您还可以指定不同的填充值：
- en: '[PRE88]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Table 5.5: Flexible arithmetic methods'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.5：灵活的算术方法
- en: '| Method | Description |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add, radd` | Methods for addition (+) |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `add, radd` | 加法方法（+）|'
- en: '| `sub, rsub` | Methods for subtraction (-) |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `sub, rsub` | 减法方法（-）|'
- en: '| `div, rdiv` | Methods for division (/) |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `div, rdiv` | 除法方法（/）|'
- en: '| `floordiv, rfloordiv` | Methods for floor division (//) |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `floordiv, rfloordiv` | 地板除法方法（//）|'
- en: '| `mul, rmul` | Methods for multiplication (*) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `mul, rmul` | 乘法方法（*）|'
- en: '| `pow, rpow` | Methods for exponentiation (**) |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `pow, rpow` | 指数方法（**）|'
- en: Operations between DataFrame and Series
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DataFrame和Series之间的操作
- en: 'As with NumPy arrays of different dimensions, arithmetic between DataFrame
    and Series is also defined. First, as a motivating example, consider the difference
    between a two-dimensional array and one of its rows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与不同维度的NumPy数组一样，DataFrame和Series之间的算术也是定义的。首先，作为一个激励性的例子，考虑一个二维数组和其一行之间的差异：
- en: '[PRE89]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When we subtract `arr[0]` from `arr`, the subtraction is performed once for
    each row. This is referred to as *broadcasting* and is explained in more detail
    as it relates to general NumPy arrays in [Appendix A: Advanced NumPy](/book/advanced-numpy).
    Operations between a DataFrame and a Series are similar:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从`arr`中减去`arr[0]`时，减法将针对每一行执行一次。这被称为*广播*，并且在[附录A：高级NumPy](/book/advanced-numpy)中更详细地解释了它与一般NumPy数组的关系。DataFrame和Series之间的操作类似：
- en: '[PRE90]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'By default, arithmetic between DataFrame and Series matches the index of the
    Series on the columns of the DataFrame, broadcasting down the rows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DataFrame和Series之间的算术会将Series的索引与DataFrame的列匹配，向下广播行：
- en: '[PRE91]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If an index value is not found in either the DataFrame’s columns or the Series’s
    index, the objects will be reindexed to form the union:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引值既不在DataFrame的列中，也不在Series的索引中找到，那么对象将被重新索引以形成并集：
- en: '[PRE92]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you want to instead broadcast over the columns, matching on the rows, you
    have to use one of the arithmetic methods and specify to match over the index.
    For example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在列上进行广播，匹配行，您必须使用其中一个算术方法并指定匹配索引。例如：
- en: '[PRE93]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The axis that you pass is the *axis to match on*. In this case we mean to match
    on the DataFrame’s row index (`axis="index"`) and broadcast across the columns.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递的轴是*要匹配的轴*。在这种情况下，我们的意思是匹配DataFrame的行索引（`axis="index"`）并在列之间广播。
- en: Function Application and Mapping
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数应用和映射
- en: 'NumPy ufuncs (element-wise array methods) also work with pandas objects:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ufuncs（逐元素数组方法）也适用于pandas对象：
- en: '[PRE94]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Another frequent operation is applying a function on one-dimensional arrays
    to each column or row. DataFrame’s `apply` method does exactly this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个频繁的操作是将一个一维数组上的函数应用于每列或每行。DataFrame的`apply`方法正是这样做的：
- en: '[PRE95]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here the function `f`, which computes the difference between the maximum and
    minimum of a Series, is invoked once on each column in `frame`. The result is
    a Series having the columns of `frame` as its index.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数`f`计算Series的最大值和最小值之间的差异，对`frame`中的每列调用一次。结果是一个具有`frame`列作为其索引的Series。
- en: 'If you pass `axis="columns"` to `apply`, the function will be invoked once
    per row instead. A helpful way to think about this is as "apply across the columns":'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`axis="columns"`传递给`apply`，则该函数将每行调用一次。将其视为"跨列应用"是一种有用的方式：
- en: '[PRE96]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Many of the most common array statistics (like `sum` and `mean`) are DataFrame
    methods, so using `apply` is not necessary.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 许多最常见的数组统计（如`sum`和`mean`）都是DataFrame方法，因此不需要使用`apply`。
- en: 'The function passed to `apply` need not return a scalar value; it can also
    return a Series with multiple values:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`apply`的函数不必返回标量值；它也可以返回具有多个值的Series：
- en: '[PRE97]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Element-wise Python functions can be used, too. Suppose you wanted to compute
    a formatted string from each floating-point value in `frame`. You can do this
    with `applymap`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用逐元素Python函数。假设您想要从`frame`中的每个浮点值计算格式化字符串。您可以使用`applymap`来实现：
- en: '[PRE98]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The reason for the name `applymap` is that Series has a `map` method for applying
    an element-wise function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`applymap`的命名原因是Series有一个`map`方法，用于应用逐元素函数：'
- en: '[PRE99]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Sorting and Ranking
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序和排名
- en: 'Sorting a dataset by some criterion is another important built-in operation.
    To sort lexicographically by row or column label, use the `sort_index` method,
    which returns a new, sorted object:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按某个标准对数据集进行排序是另一个重要的内置操作。要按行或列标签的字典顺序排序，请使用`sort_index`方法，该方法返回一个新的排序对象：
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'With a DataFrame, you can sort by index on either axis:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，您可以在任一轴上按索引排序：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The data is sorted in ascending order by default but can be sorted in descending
    order, too:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据按升序排序，但也可以按降序排序：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To sort a Series by its values, use its `sort_values` method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要按值对Series进行排序，请使用其`sort_values`方法：
- en: '[PRE103]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Any missing values are sorted to the end of the Series by default:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何缺失值都按顺序排在Series的末尾：
- en: '[PRE104]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Missing values can be sorted to the start instead by using the `na_position`
    option:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值也可以通过使用`na_position`选项将其排序到开头：
- en: '[PRE105]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When sorting a DataFrame, you can use the data in one or more columns as the
    sort keys. To do so, pass one or more column names to `sort_values`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在对DataFrame进行排序时，可以使用一个或多个列中的数据作为排序键。为此，请将一个或多个列名传递给`sort_values`：
- en: '[PRE106]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To sort by multiple columns, pass a list of names:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要按多个列排序，请传递一个名称列表：
- en: '[PRE107]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '*Ranking* assigns ranks from one through the number of valid data points in
    an array, starting from the lowest value. The `rank` methods for Series and DataFrame
    are the place to look; by default, `rank` breaks ties by assigning each group
    the mean rank:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*排名*从数组中的最低值开始，为数组中的每个有效数据点分配从1到数据点数量的等级。Series和DataFrame的`rank`方法是要查看的地方；默认情况下，`rank`通过为每个组分配平均等级来打破平局：'
- en: '[PRE108]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Ranks can also be assigned according to the order in which they’re observed
    in the data:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 排名也可以根据它们在数据中观察到的顺序进行分配：
- en: '[PRE109]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, instead of using the average rank 6.5 for the entries 0 and 2, they instead
    have been set to 6 and 7 because label 0 precedes label 2 in the data.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与使用条目0和2的平均等级6.5不同，它们分别设置为6和7，因为标签0在数据中位于标签2之前。
- en: 'You can rank in descending order, too:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以按降序排名：
- en: '[PRE110]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: See [Table 5.6](#tbl-table_pandas_rank) for a list of tie-breaking methods available.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[表5.6](#tbl-table_pandas_rank)以获取可用的平局破解方法列表。
- en: 'DataFrame can compute ranks over the rows or the columns:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame可以在行或列上计算排名：
- en: '[PRE111]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Table 5.6: Tie-breaking methods with rank'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.6：排名的平局破解方法
- en: '| Method | Description |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"average"` | Default: assign the average rank to each entry in the equal
    group |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `"average"` | 默认：为相等组中的每个条目分配平均等级 |'
- en: '| `"min"` | Use the minimum rank for the whole group |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `"min"` | 使用整个组的最小等级 |'
- en: '| `"max"` | Use the maximum rank for the whole group |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `"max"` | 使用整个组的最大等级 |'
- en: '| `"first"` | Assign ranks in the order the values appear in the data |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `"first"` | 按数据中值出现的顺序分配等级 |'
- en: '| `"dense"` | Like `method="min"`, but ranks always increase by 1 between groups
    rather than the number of equal elements in a group |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `"dense"` | 类似于`method="min"`，但等级总是在组之间增加1，而不是在组中相等元素的数量之间增加 |'
- en: Axis Indexes with Duplicate Labels
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有重复标签的轴索引
- en: 'Up until now almost all of the examples we have looked at have unique axis
    labels (index values). While many pandas functions (like `reindex`) require that
    the labels be unique, it’s not mandatory. Let’s consider a small Series with duplicate
    indices:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看过的几乎所有示例都具有唯一的轴标签（索引值）。虽然许多pandas函数（如`reindex`）要求标签是唯一的，但这并非强制要求。让我们考虑一个具有重复索引的小Series：
- en: '[PRE112]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `is_unique` property of the index can tell you whether or not its labels
    are unique:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的`is_unique`属性可以告诉您其标签是否唯一：
- en: '[PRE113]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Data selection is one of the main things that behaves differently with duplicates.
    Indexing a label with multiple entries returns a Series, while single entries
    return a scalar value:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 数据选择是与重复不同的主要行为之一。索引具有多个条目的标签返回一个Series，而单个条目返回一个标量值：
- en: '[PRE114]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This can make your code more complicated, as the output type from indexing can
    vary based on whether or not a label is repeated.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使您的代码变得更加复杂，因为根据标签是否重复，索引的输出类型可能会有所不同。
- en: 'The same logic extends to indexing rows (or columns) in a DataFrame:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑也适用于DataFrame中的行（或列）索引：
- en: '[PRE115]**  **## 5.3 Summarizing and Computing Descriptive Statistics'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE115]**  **## 5.3 总结和计算描述性统计'
- en: 'pandas objects are equipped with a set of common mathematical and statistical
    methods. Most of these fall into the category of *reductions* or *summary statistics*,
    methods that extract a single value (like the sum or mean) from a Series, or a
    Series of values from the rows or columns of a DataFrame. Compared with the similar
    methods found on NumPy arrays, they have built-in handling for missing data. Consider
    a small DataFrame:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: pandas对象配备了一组常见的数学和统计方法。其中大多数属于*减少*或*摘要统计*的类别，这些方法从Series中提取单个值（如总和或均值），或者从DataFrame的行或列中提取一系列值。与NumPy数组上找到的类似方法相比，它们内置了对缺失数据的处理。考虑一个小的DataFrame：
- en: '[PRE116]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Calling DataFrame’s `sum` method returns a Series containing column sums:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 调用DataFrame的`sum`方法会返回一个包含列和的Series：
- en: '[PRE117]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Passing `axis="columns"` or `axis=1` sums across the columns instead:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`axis="columns"`或`axis=1`会跨列求和：
- en: '[PRE118]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'When an entire row or column contains all NA values, the sum is 0, whereas
    if any value is not NA, then the result is NA. This can be disabled with the `skipna`
    option, in which case any NA value in a row or column names the corresponding
    result NA:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当整行或整列包含所有NA值时，总和为0，而如果任何值不是NA，则结果为NA。可以使用`skipna`选项禁用此功能，在这种情况下，行或列中的任何NA值都会使相应的结果为NA：
- en: '[PRE119]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Some aggregations, like `mean`, require at least one non-NA value to yield
    a value result, so here we have:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一些聚合，如`mean`，需要至少一个非NA值才能产生一个值结果，因此我们有：
- en: '[PRE120]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: See [Table 5.7](#tbl-table_pandas_reduction) for a list of common options for
    each reduction method.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表5.7](#tbl-table_pandas_reduction)以获取每种减少方法的常见选项列表。
- en: 'Table 5.7: Options for reduction methods'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.7：减少方法的选项
- en: '| Method | Description |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `axis` | Axis to reduce over; "index" for DataFrame’s rows and "columns"
    for columns |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | 要减少的轴；DataFrame的行为“index”，列为“columns” |'
- en: '| `skipna` | Exclude missing values; `True` by default |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `skipna` | 排除缺失值；默认为`True` |'
- en: '| `level` | Reduce grouped by level if the axis is hierarchically indexed (MultiIndex)
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `level` | 如果轴是分层索引（MultiIndex），则按级别减少 |'
- en: 'Some methods, like `idxmin` and `idxmax`, return indirect statistics, like
    the index value where the minimum or maximum values are attained:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法，如`idxmin`和`idxmax`，返回间接统计信息，如达到最小值或最大值的索引值：
- en: '[PRE121]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Other methods are *accumulations*:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法是*累积*：
- en: '[PRE122]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Some methods are neither reductions nor accumulations. `describe` is one such
    example, producing multiple summary statistics in one shot:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法既不是减少也不是累积。`describe`就是一个例子，一次生成多个摘要统计信息：
- en: '[PRE123]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'On nonnumeric data, `describe` produces alternative summary statistics:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非数字数据，`describe`会生成替代的摘要统计信息：
- en: '[PRE124]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: See [Table 5.8](#tbl-table_descriptive_stats) for a full list of summary statistics
    and related methods.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表5.8](#tbl-table_descriptive_stats)以获取摘要统计和相关方法的完整列表。
- en: 'Table 5.8: Descriptive and summary statistics'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.8：描述性和摘要统计
- en: '| Method | Description |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `count` | Number of non-NA values |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 非NA值的数量 |'
- en: '| `describe` | Compute set of summary statistics |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `describe` | 计算一组摘要统计信息 |'
- en: '| `min, max` | Compute minimum and maximum values |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `min, max` | 计算最小值和最大值 |'
- en: '| `argmin, argmax` | Compute index locations (integers) at which minimum or
    maximum value is obtained, respectively; not available on DataFrame objects |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `argmin, argmax` | 计算获得最小值或最大值的索引位置（整数），分别；在DataFrame对象上不可用 |'
- en: '| `idxmin, idxmax` | Compute index labels at which minimum or maximum value
    is obtained, respectively |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `idxmin, idxmax` | 计算获得最小值或最大值的索引标签 |'
- en: '| `quantile` | Compute sample quantile ranging from 0 to 1 (default: 0.5) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `quantile` | 计算从0到1范围的样本分位数（默认值：0.5） |'
- en: '| `sum` | Sum of values |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `sum` | 值的总和 |'
- en: '| `mean` | Mean of values |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 值的均值 |'
- en: '| `median` | Arithmetic median (50% quantile) of values |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `median` | 值的算术中位数（50%分位数） |'
- en: '| `mad` | Mean absolute deviation from mean value |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `mad` | 与均值的平均绝对偏差 |'
- en: '| `prod` | Product of all values |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `prod` | 所有值的乘积 |'
- en: '| `var` | Sample variance of values |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `var` | 值的样本方差 |'
- en: '| `std` | Sample standard deviation of values |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `std` | 值的样本标准差 |'
- en: '| `skew` | Sample skewness (third moment) of values |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `skew` | 值的样本偏度（第三时刻） |'
- en: '| `kurt` | Sample kurtosis (fourth moment) of values |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `kurt` | 值的样本峰度（第四时刻） |'
- en: '| `cumsum` | Cumulative sum of values |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `cumsum` | 值的累积和 |'
- en: '| `cummin, cummax` | Cumulative minimum or maximum of values, respectively
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `cummin, cummax` | 值的累积最小值或最大值，分别 |'
- en: '| `cumprod` | Cumulative product of values |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `cumprod` | 值的累积乘积 |'
- en: '| `diff` | Compute first arithmetic difference (useful for time series) |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `diff` | 计算第一个算术差异（对时间序列有用） |'
- en: '| `pct_change` | Compute percent changes |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `pct_change` | 计算百分比变化 |'
- en: Correlation and Covariance
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关性和协方差
- en: 'Some summary statistics, like correlation and covariance, are computed from
    pairs of arguments. Let’s consider some DataFrames of stock prices and volumes
    originally obtained from Yahoo! Finance and available in binary Python pickle
    files you can find in the accompanying datasets for the book:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 一些摘要统计信息，如相关性和协方差，是从一对参数计算得出的。让我们考虑一些股票价格和成交量的DataFrame，最初从Yahoo! Finance获取，并在本书的附带数据集中以二进制Python
    pickle文件的形式提供：
- en: '[PRE125]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'I now compute percent changes of the prices, a time series operation that will
    be explored further in [Ch 11: Time Series](/book/time-series):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我计算价格的百分比变化，这是一个时间序列操作，将在[第11章：时间序列](/book/time-series)中进一步探讨：
- en: '[PRE126]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `corr` method of Series computes the correlation of the overlapping, non-NA,
    aligned-by-index values in two Series. Relatedly, `cov` computes the covariance:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Series的`corr`方法计算两个Series中重叠的、非NA、按索引对齐的值的相关性。相关地，`cov`计算协方差：
- en: '[PRE127]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'DataFrame’s `corr` and `cov` methods, on the other hand, return a full correlation
    or covariance matrix as a DataFrame, respectively:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，DataFrame的`corr`和`cov`方法分别返回完整的相关性或协方差矩阵作为DataFrame：
- en: '[PRE128]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Using DataFrame’s `corrwith` method, you can compute pair-wise correlations
    between a DataFrame’s columns or rows with another Series or DataFrame. Passing
    a Series returns a Series with the correlation value computed for each column:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame的`corrwith`方法，您可以计算DataFrame的列或行与另一个Series或DataFrame之间的成对相关性。传递一个Series会返回一个Series，其中计算了每列的相关值：
- en: '[PRE129]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Passing a DataFrame computes the correlations of matching column names. Here,
    I compute correlations of percent changes with volume:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个DataFrame会计算匹配列名的相关性。在这里，我计算了百分比变化与成交量的相关性：
- en: '[PRE130]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Passing `axis="columns"` does things row-by-row instead. In all cases, the data
    points are aligned by label before the correlation is computed.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`axis="columns"`会逐行执行操作。在所有情况下，在计算相关性之前，数据点都会按标签对齐。
- en: Unique Values, Value Counts, and Membership
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 唯一值、值计数和成员资格
- en: 'Another class of related methods extracts information about the values contained
    in a one-dimensional Series. To illustrate these, consider this example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类相关方法提取一维Series中包含的值的信息。为了说明这些方法，考虑以下示例：
- en: '[PRE131]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The first function is `unique`, which gives you an array of the unique values
    in a Series:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是`unique`，它为您提供Series中唯一值的数组：
- en: '[PRE132]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The unique values are not necessarily returned in the order in which they first
    appear, and not in sorted order, but they could be sorted after the fact if needed
    (`uniques.sort()`). Relatedly, `value_counts` computes a Series containing value
    frequencies:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的值不一定按它们首次出现的顺序返回，也不按排序顺序返回，但如果需要的话可以在之后排序（`uniques.sort()`）。相关地，`value_counts`计算包含值频率的Series：
- en: '[PRE133]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The Series is sorted by value in descending order as a convenience. `value_counts`
    is also available as a top-level pandas method that can be used with NumPy arrays
    or other Python sequences:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Series按值降序排序以方便起见。`value_counts`也作为顶级pandas方法可用，可与NumPy数组或其他Python序列一起使用：
- en: '[PRE134]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '`isin` performs a vectorized set membership check and can be useful in filtering
    a dataset down to a subset of values in a Series or column in a DataFrame:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`isin`执行矢量化的成员检查，并且在将数据集过滤到Series或DataFrame中的值子集时可能很有用：'
- en: '[PRE135]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Related to `isin` is the `Index.get_indexer` method, which gives you an index
    array from an array of possibly nondistinct values into another array of distinct
    values:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 与`isin`相关的是`Index.get_indexer`方法，它从可能不同的值的数组中为另一个不同值的数组提供索引数组：
- en: '[PRE136]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: See [Table 5.9](#tbl-table_binning) for a reference on these methods.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些方法的参考，请参见[表5.9](#tbl-table_binning)。
- en: 'Table 5.9: Unique, value counts, and set membership methods'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.9：唯一值、值计数和成员资格方法
- en: '| Method | Description |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `isin` | Compute a Boolean array indicating whether each Series or DataFrame
    value is contained in the passed sequence of values |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `isin` | 计算一个布尔数组，指示每个Series或DataFrame值是否包含在传递的值序列中 |'
- en: '| `get_indexer` | Compute integer indices for each value in an array into another
    array of distinct values; helpful for data alignment and join-type operations
    |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `get_indexer` | 为数组中的每个值计算整数索引，以便将其对齐到另一个不同值的数组；有助于数据对齐和连接类型操作 |'
- en: '| `unique` | Compute an array of unique values in a Series, returned in the
    order observed |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `unique` | 计算Series中唯一值的数组，按观察顺序返回 |'
- en: '| `value_counts` | Return a Series containing unique values as its index and
    frequencies as its values, ordered count in descending order |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `value_counts` | 返回一个Series，其唯一值作为索引，频率作为值，按降序计数排序 |'
- en: 'In some cases, you may want to compute a histogram on multiple related columns
    in a DataFrame. Here’s an example:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在DataFrame中的多个相关列上计算直方图。以下是一个示例：
- en: '[PRE137]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We can compute the value counts for a single column, like so:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算单列的值计数，如下所示：
- en: '[PRE138]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To compute this for all columns, pass `pandas.value_counts` to the DataFrame’s
    `apply` method:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要为所有列计算此值，请将`pandas.value_counts`传递给DataFrame的`apply`方法：
- en: '[PRE139]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Here, the row labels in the result are the distinct values occurring in all
    of the columns. The values are the respective counts of these values in each column.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果中的行标签是所有列中出现的不同值。这些值是每列中这些值的相应计数。
- en: 'There is also a `DataFrame.value_counts` method, but it computes counts considering
    each row of the DataFrame as a tuple to determine the number of occurrences of
    each distinct row:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`DataFrame.value_counts`方法，但它计算考虑DataFrame的每一行作为元组的计数，以确定每个不同行的出现次数：
- en: '[PRE140]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In this case, the result has an index representing the distinct rows as a hierarchical
    index, a topic we will explore in greater detail in [Ch 8: Data Wrangling: Join,
    Combine, and Reshape](/book/data-wrangling).'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果具有一个表示不同行的索引作为层次索引，这是我们将在[第8章：数据整理：连接、合并和重塑](/book/data-wrangling)中更详细地探讨的一个主题。
- en: 5.4 Conclusion
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 结论
- en: In the next chapter, we will discuss tools for reading (or *loading*) and writing
    datasets with pandas. After that, we will dig deeper into data cleaning, wrangling,
    analysis, and visualization tools using pandas.*******
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用pandas读取（或*加载*）和写入数据集的工具。之后，我们将深入探讨使用pandas进行数据清洗、整理、分析和可视化的工具。
