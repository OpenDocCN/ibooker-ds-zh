- en: Unit 3\. Functions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元3. 函数
- en: Functions are a pretty fundamental construct for authoring applications. This
    is especially true in a language like JavaScript, which treats functions as first-class
    citizens. With ES2015 and later, many awesome features have been added to functions,
    including several completely new types of functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编写应用程序的一个相当基本的构造。这在像JavaScript这样的语言中尤其如此，因为JavaScript将函数视为一等公民。随着ES2015及以后的版本，许多令人惊叹的功能被添加到函数中，包括几种全新的函数类型。
- en: We’ll start the unit by taking a look at default parameters and rest. I think
    most programmers, at some point, have had the need for default parameters and
    likely worked around it by checking for a value and assigning one if `undefined`
    at the start of the function. The rest param is even more useful. Anyone who has
    used the `arguments` object before will be happy to use *rest*. Not only does
    rest render the arguments object obsolete, it allows you to combine it with other
    arguments, rather than always acting like a catchall as the `arguments` object
    does.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个单元的开始，通过查看默认参数和剩余参数。我认为大多数程序员在某个时候都曾需要默认参数，并且可能通过在函数开始时检查值并在`undefined`时分配一个值来解决这个问题。剩余参数甚至更有用。任何以前使用过`arguments`对象的人都会很高兴使用*剩余参数*。不仅剩余参数使`arguments`对象变得过时，它还允许你将其与其他参数结合使用，而不仅仅是像`arguments`对象那样总是充当一个通用的容器。
- en: We’ll then take a dive into destructuring function arguments, which can also
    be combined with default parameters. When you put these all together, you can
    make some pretty powerful function declarations. You can even simulate *named*
    parameters. So, no more passing `null` values to a function like `myFunc(null,
    null, 5)`, because you only need to specify the third argument (or fourth, fifth,
    and so on).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将深入研究解构函数参数，这也可以与默认参数结合使用。当你把这些都放在一起时，你可以创建一些相当强大的函数声明。你甚至可以模拟*命名参数*。所以，不再需要传递`null`值给像`myFunc(null,
    null, 5)`这样的函数，因为你只需要指定第三个参数（或者第四个、第五个，以此类推）。
- en: 'After looking at all the new things you can do with existing functions, we’ll
    look at two new types of functions: *arrow functions* and *generator functions*.
    Arrow functions are extremely useful in JavaScript, and you will find yourself
    using them daily once they’re in your repertoire. Generator functions, on the
    other hand, may not be something you need to reach for that often, but they’re
    a powerful new tool when needed.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看所有可以用现有函数完成的新功能之后，我们将探讨两种新的函数类型：*箭头函数*和*生成器函数*。箭头函数在JavaScript中非常有用，一旦它们成为你的技能库的一部分，你将发现自己每天都在使用它们。另一方面，生成器函数可能不是你经常需要使用的，但在需要时它们是一个强大的新工具。
- en: You’ll wrap up the unit by creating a simulation runner that pits prisoner simulations
    against each other in a Prisoner’s Dilemma scenario.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建一个模拟运行器来结束本单元的学习，该运行器在囚徒困境场景中将囚犯模拟相互对抗。
- en: Lesson 15\. Default parameters and rest
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15课. 默认参数和剩余参数
- en: After reading [lesson 15](kindle_split_026_split_000.xhtml#ch15), you will
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了[第15课](kindle_split_026_split_000.xhtml#ch15)之后，你将
- en: Know how to use default parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用默认参数
- en: Know how to gather parameters with the rest operator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用剩余操作符收集参数
- en: Know how to use rest to pass arguments between functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用剩余参数在函数之间传递参数
- en: 'Sometimes new language features provide ways to achieve things that were impossible
    or nearly impossible to do before. Other times they simply add a nicer way of
    achieving something that was already easily implemented. But just because something
    is easy to implement or requires few lines of code to do, doesn’t necessarily
    make it *readable*. That’s exactly what *default function parameters* and *rest
    parameters* do: they provide a more concise and much more readable way of achieving
    something.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时新的语言特性提供了实现以前不可能或几乎不可能实现的事情的方法。其他时候，它们只是提供了一种更优雅的实现已经容易实现的事情的方式。但仅仅因为某件事容易实现或需要很少的代码行数来完成，并不意味着它就一定*易于阅读*。这正是*默认函数参数*和*剩余参数*所做的：它们提供了一种更简洁、更易于阅读的实现方式。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: By looking at this implementation of the `pluck` function, can you quickly tell
    what it’s doing? That first line—what is it doing? That line requires too much
    thought. In its current state it probably needs a comment explaining what it does.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`pluck`函数的实现，你能快速判断它在做什么吗？那第一行——它在做什么？这一行需要太多的思考。在其当前状态下，它可能需要一条注释来解释它的作用。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 15.1\. Default parameters
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 默认参数
- en: 'Let’s imagine you’re building a website that shows the current president’s
    approval ratings over the course of their time in office. You want to build a
    chart function that will show the information in a line chart. You decide that
    800 by 400 is a good size for the chart, but you want to allow for setting custom
    sizes. For example, the 800 by 400 chart might be at the top with the national
    approval ratings, and then be broken down by state using charts that are only
    400 by 200\. You may end up writing a function like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你正在构建一个网站，该网站显示现任总统在其任期内的工作满意度。你想要构建一个图表函数，以折线图的形式显示这些信息。你决定 800x400 是图表的好大小，但你希望允许设置自定义大小。例如，800x400
    的图表可能位于顶部，显示全国满意度，然后通过只有 400x200 的图表按州细分。你可能会编写一个像这样的函数：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Chart is 800x400**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 图表大小为 800x400**'
- en: '***2* Chart is 400x200**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 图表大小为 400x200**'
- en: 'You can now achieve the same thing with default function parameters like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用如下默认函数参数实现相同的效果：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Chart is 800x400**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 图表大小为 800x400**'
- en: '***2* Chart is 400x200**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 图表大小为 400x200**'
- en: Notice how you used the expression `height = width / 2` right in your arguments
    list. You can actually use any expression in the assignment of a default parameter,
    and that expression will be evaluated at the time the function is evaluated. You
    can use any variables in scope, including preceding parameters. The context of
    the expression will always be the same context the function is invoked with, meaning
    any use of `this` will evaluate the same as it would inside the function body.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何在参数列表中直接使用表达式 `height = width / 2`。实际上，你可以在默认参数的赋值中使用任何表达式，并且该表达式将在函数评估时被评估。你可以使用作用域内的任何变量，包括前面的参数。表达式的上下文始终与函数调用的上下文相同，这意味着任何
    `this` 的使用都将与函数体内相同。
- en: Listing 15.1\. Accessing `this` in default parameters
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.1\. 在默认参数中访问 `this`
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* url is localhost/data.json**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 网址是 localhost/data.json**'
- en: '***2* url is www.example.com/data.json**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 网址是 www.example.com/data.json**'
- en: '***3* url is localhost/moredata.json**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 网址是 localhost/moredata.json**'
- en: When you first invoked `ajax.load()` without a parameter, the default checked
    `this.host` which was `localhost`, and the `url` parameter became `localhost/data.json`.
    You then changed the `host` property, so when you invoked the same function again,
    the default again checked `this.host` which now was `www.example.com`, so the
    `url` parameter became `www.example.com/data.json`. Finally, when you called `ajax.load('localhost/moredata.json')`,
    the default wasn’t used and the `url` parameter was set to `localhost/moredata.json`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次调用 `ajax.load()` 而不带参数时，默认选中 `this.host`，其值为 `localhost`，而 `url` 参数变为 `localhost/data.json`。然后你更改了
    `host` 属性，所以当你再次调用该函数时，默认再次选中 `this.host`，此时为 `www.example.com`，因此 `url` 参数变为
    `www.example.com/data.json`。最后，当你调用 `ajax.load('localhost/moredata.json')` 时，没有使用默认值，`url`
    参数被设置为 `localhost/moredata.json`。
- en: The parameter’s default value is tied to its index in the parameter list. You
    may be tempted to use a default value to make an optional param follow a required
    param, as in our range example. If two values are passed, then you want them to
    be `min` and `max`, respectively, but if only one value is passed, you want it
    to be the `max` with a `min` defaulted to 0\. As nice as this would be, this is
    not how default params work, as shown in the next listing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的默认值与其在参数列表中的索引相关联。你可能想使用默认值来使可选参数跟随必选参数，就像我们在范围示例中做的那样。如果传递了两个值，那么你希望它们分别是
    `min` 和 `max`，但如果只传递了一个值，你希望它是 `max`，而 `min` 默认为 0。虽然这听起来很棒，但默认参数的工作方式并非如此，如下一列表所示。
- en: Listing 15.2\. Mandatory parameters must precede optional ones
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.2\. 必选参数必须位于可选参数之前
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* min would be 5 and max would be 10.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 分钟将是 5，最大值将是 10。**'
- en: '***2* min would be 10 and max would be undefined.**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 最小值将是 10，最大值将是未定义。**'
- en: Because default params are tied to their index, you can’t use them to make a
    parameter optional unless it’s the last param. The params passed to the function
    are assigned by their index, so no matter what, the first value is going to be
    assigned to the `min`, and the second value will be assigned to the `max`. The
    only way you could set the `max` while using the default `min` would be if you
    invoked range like `range(undefined, 10)` because that maintains the correct indices
    for each param. The first param is `undefined` and so becomes the default value
    of 0; the second param is `10`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为默认参数与其索引相关联，除非它是最后一个参数，否则你不能使用它们来使参数可选。传递给函数的参数按其索引分配，所以无论如何，第一个值都将分配给 `min`，第二个值将分配给
    `max`。唯一能够设置 `max` 而使用默认的 `min` 的方法是通过调用 `range(undefined, 10)`，因为这保持了每个参数的正确索引。第一个参数是
    `undefined`，因此成为默认值 0；第二个参数是 `10`。
- en: With the power of expressions in default parameters, you could do something
    clever to check the length of the arguments and set the `min` param to the correct
    value conditionally, as shown in the next listing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 利用默认参数中的表达式功能，你可以做一些巧妙的事情来检查参数的长度，并条件性地将 `min` 参数设置为正确的值，如下一清单所示。
- en: Listing 15.3\. Fudging default parameters (not recommended!)
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 15.3\. 伪造默认参数（不推荐！）
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this `range` function, you first defined a `temp` param with a default value
    of `0`, then a `max` that defaults to the temp value. Finally you defined a `min`
    param that checks the length of `arguments` and conditionally defaults to 0 or
    `temp`. This works because of the following conditions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `range` 函数中，你首先定义了一个默认值为 `0` 的 `temp` 参数，然后是一个默认值为 `temp` 值的 `max`，最后定义了一个检查
    `arguments` 长度并条件性地默认为 0 或 `temp` 的 `min` 参数。这之所以可行，是因为以下条件：
- en: 'Invoked with `10`:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `10` 调用：
- en: '`temp` is set to 10.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temp` 被设置为 10。'
- en: '`max` defaults to `temp` so `max` is 10.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max` 默认为 `temp`，所以 `max` 为 10。'
- en: '`arguments.length` is not greater than 1 so `min` gets set to 0.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments.length` 不大于 1，所以 `min` 被设置为 0。'
- en: 'Effect: `min` is 0, `max` is 10.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响：`min` 为 0，`max` 为 10。
- en: 'Invoked with `5, 10`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `5, 10` 调用：
- en: '`temp` is set to 5.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temp` 被设置为 5。'
- en: '`max` is set to 10.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max` 被设置为 10。'
- en: '`arguments.length` is greater than 1 so `min` gets set to `temp` (5).'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments.length` 大于 1，所以 `min` 被设置为 `temp`（5）。'
- en: 'Effect: `min` is 5, `max` is 10.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响：`min` 为 5，`max` 为 10。
- en: 'Invoked with `5, 5`:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `5, 5` 调用：
- en: '`temp` is set to 5.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temp` 被设置为 5。'
- en: '`max` is set to 5.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max` 被设置为 5。'
- en: '`arguments.length` is greater than 1 so `min` gets set to `temp` (5).'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments.length` 大于 1，所以 `min` 被设置为 `temp`（5）。'
- en: 'Effect: `min` is 5, `max` is 5.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响：`min` 为 5，`max` 为 5。
- en: Even though this works, I would advice against code like this because it obscures
    what’s happening, wastes a param, and could lead to bugs if users of the function
    started invoking it with all three params. This was merely an exercise to demonstrate
    the possibilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样可行，但我建议不要使用这种代码，因为它会掩盖正在发生的事情，浪费了一个参数，并且如果函数的使用者开始用所有三个参数调用它，可能会导致错误。这只是一个练习，用来展示可能性。
- en: 'Notice how in [listing 15.3](kindle_split_026_split_001.xhtml#ch15ex03) you’re
    using the `arguments` object in the parameter list to calculate a default value.
    Remember, the expression used for a default param gets invoked in the context
    of the function body! Does this mean you can use other variables declared in the
    function body? Effectively no: remember in [lesson 4](kindle_split_013_split_000.xhtml#ch04)
    we talked about temporal dead zones. Other variables in the function body are
    technically in scope, but the’re in a temporal dead zone and can’t be accessed
    yet.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [清单 15.3](kindle_split_026_split_001.xhtml#ch15ex03) 中，你如何在参数列表中使用 `arguments`
    对象来计算默认值。记住，用于默认参数的表达式是在函数体上下文中调用的！这意味着你可以使用函数体中声明的其他变量吗？实际上不行：记住在 [第 4 课](kindle_split_013_split_000.xhtml#ch04)
    我们讨论了临时死区。函数体中的其他变量在技术上处于作用域内，但它们处于临时死区，还不能被访问。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 15.1**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.1**'
- en: '**[Q1:](kindle_split_026_split_001.xhtml#ch15qa2q0a1)**'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_026_split_001.xhtml#ch15qa2q0a1)**'
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following function invocation, what will be the value of the `args` parameter?
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下函数调用中，`args` 参数的值将是什么？
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 15.1 answer**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 15.1 答案**'
- en: '**[A1:](kindle_split_026_split_001.xhtml#ch15qa1q1)**'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_026_split_001.xhtml#ch15qa1q1)**'
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It will be 1\. Remember you called it with a value. So even though the default
    value creates an array from the arguments object, it doesn’t matter: the default
    doesn’t get calculated because a value was passed. If you want to create an array
    of the arguments, use the rest operator.'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它将是 1。记住你调用它时传了一个值。所以即使默认值从参数对象创建了一个数组，这也没有关系：由于传入了值，默认值不会被计算。如果你想创建一个参数的数组，请使用剩余操作符。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Usually default parameters allow you to use a sane default in the case that
    a value wasn’t given. This makes functions more useful, because falling back to
    a default is usually better than throwing an error (depending on the scenario).
    That isn’t the only thing you can do with default parameters though. In the next
    section we will explore using default parameters to prevent recalculating data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，默认参数允许你在未提供值的情况下使用合理的默认值。这使得函数更有用，因为回退到默认值通常比抛出错误要好（取决于场景）。但是，你还可以用默认参数做更多的事情。在下一节中，我们将探讨使用默认参数来防止重新计算数据。
- en: 15.2\. Using default params to skip recalculating values
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2\. 使用默认参数以避免重新计算值
- en: Remember that in the beginning of this lesson, you created an `approvalsChart`
    function to calculate approval ratings. You’re going to take it further and create
    a library for calculating the ratings and generating the charts. A first attempt
    may be something like this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在本课的开始，你创建了一个 `approvalsChart` 函数来计算批准评分。你将更进一步，创建一个用于计算评分和生成图表的库。第一次尝试可能如下所示。
- en: Listing 15.4\. Calling `getRatings` twice
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.4\. 两次调用 `getRatings`
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Calculates the ratings**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计算评分**'
- en: '***2* Calculates the ratings (again)**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 再次计算评分**'
- en: Notice how it ends up calling the `getRatings` method twice? If this method
    were resource-intensive it would make sense to avoid wasting the second computation.
    You can solve this with default params, as shown in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它最终调用了 `getRatings` 方法两次？如果这个方法很耗费资源，那么避免浪费第二次计算是有意义的。你可以通过以下列表中的默认参数来解决。
- en: Listing 15.5\. Calling `getRatings` only once
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. 只调用一次 `getRatings`
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now the methods `nationalRatings` and `stateRatings` call `getRatings` as a
    default parameter. This means that each function can be invoked by itself and
    it will calculate the ratings. But if you want to get both national and state,
    you can pre-calculate the ratings and pass the data to each method, preventing
    the extra calculation step.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方法 `nationalRatings` 和 `stateRatings` 将 `getRatings` 作为默认参数调用。这意味着每个函数都可以独立调用并计算评分。但如果你想同时获取国家和州的评分，你可以预先计算评分并将数据传递给每个方法，从而避免额外的计算步骤。
- en: Default params are a great way of handling expected parameters by ensuring they
    have values. They don’t offer much help with unexpected (or indeterminate) parameters,
    but for that you can use the new *rest* operator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数是处理预期参数的绝佳方式，确保它们有值。它们对处理意外（或不确定）的参数帮助不大，但你可以使用新的 *剩余* 操作符来做到这一点。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 15.2**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.2**'
- en: '**[Q1:](kindle_split_026_split_002.xhtml#ch15qa4q0a1)**'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_026_split_002.xhtml#ch15qa4q0a1)**'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following snippet what will be returned from `getC()`?
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`getC()` 将返回什么？
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 15.2 answer**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 15.2 答案**'
- en: '**[A1:](kindle_split_026_split_002.xhtml#ch15qa3q1)**'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_026_split_002.xhtml#ch15qa3q1)**'
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nothing, it will be a SyntaxError because `b` defaults to `c` but `c` is declared
    *after* `b`.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '无，它将是一个语法错误，因为 `b` 的默认值是 `c`，但 `c` 是在 `b` 之后声明的 *之后*。 '
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.3\. Gathering parameters with the rest operator
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3\. 使用剩余操作符收集参数
- en: 'Back in [lesson 9](kindle_split_019_split_000.xhtml#ch09), you learned how
    to get an array from the `arguments` object using `Array.from`. As useful as this
    is, there’s an even more convenient way to get the arguments as an array using
    rest:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 课](kindle_split_019_split_000.xhtml#ch09) 中，你学习了如何使用 `Array.from` 从 `arguments`
    对象中获取数组。虽然这很有用，但还有更方便的方法可以将参数作为数组获取，即使用剩余参数：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Gather arguments into array using Array.from**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 Array.from 将参数收集到数组中**'
- en: '***2* Gather arguments into array using rest**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用剩余参数收集参数**'
- en: 'The way rest works is by declaring a function param that starts with three
    dots. This is called a rest param, although the name of the param itself can be
    any valid variable name. This will group all the remaining params starting from
    the position of the rest param into an array. You can also only have one rest
    parameter and it must be the last argument in the list:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: rest 的工作方式是通过声明一个以三个点开始的函数参数。这被称为 rest 参数，尽管参数本身的名称可以是任何有效的变量名。这将把从 rest 参数位置开始的所有剩余参数组合成一个数组。你也可以只有一个
    rest 参数，并且它必须是列表中的最后一个参数：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* You have two children!**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你有两个孩子！**'
- en: '***2* You are married to Christina with two kids.**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你和克里斯蒂娜结婚，有两个孩子。**'
- en: The name comes from the idea that you first specify which arguments you want
    to put into individual variables, then specify the argument you want the rest
    of the params grouped into (see the following listing). Some languages, like Ruby,
    refer to this concept as a *splat*, but that’s most likely because those languages
    use an asterisk instead of three dots as the operator, and an asterisk resembles
    the shape of a splat.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称来源于首先指定你想放入单独变量的参数，然后指定你想将剩余参数组合在一起的参数（参见以下列表）。一些语言，如 Ruby，将这个概念称为 *splat*，但这很可能是由于这些语言使用星号而不是三个点作为操作符，而星号类似于
    splat 的形状。
- en: Listing 15.6\. Error occurs if you put params after rest in JavaScript
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. 在 JavaScript 中，如果在 rest 之后放置 params 会发生错误
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* SyntaxError: rest parameter must be last**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 语法错误：rest 参数必须是最后一个**'
- en: The rest param must come last in the arguments list or a syntax error is thrown.
    You may opine that this is the only logical way for rest params to work, but other
    languages, like CoffeeScript, for example, do allow for params to be specified
    after the rest param, as the following listing shows.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: rest 参数必须在参数列表的末尾，否则会抛出语法错误。你可能认为这是 rest 参数工作的唯一逻辑方式，但其他语言，例如 CoffeeScript，例如，允许在
    rest 参数之后指定参数，如下面的列表所示。
- en: Listing 15.7\. Params after rest in CoffeeScript
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.7\. CoffeeScript 中的 rest 之后放置 params
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* [ 1, [2, 3, 4], 5];**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [ 1, [2, 3, 4], 5];**'
- en: 'Now that you know how rest works, lets take a look at the priming function
    reimplemented using rest:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了 rest 的用法，让我们看看使用 rest 重新实现的 priming 函数：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At a glance, isn’t it much more readable? It no longer requires a comment to
    explain an obscure line of code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这不是更易于阅读吗？它不再需要注释来解释一行晦涩的代码。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 15.3**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.3**'
- en: '**[Q1:](kindle_split_026_split_003.xhtml#ch15qa6q0a1)**'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_026_split_003.xhtml#ch15qa6q0a1)**'
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the following `cssClass` function so that it generates a CSS class
    list by taking the first argument and adding it to the *rest* of the arguments.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现以下 `cssClass` 函数，使其通过将第一个参数添加到其余参数中生成 CSS 类列表。
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Should return “button button-danger button-medium”**'
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 应返回“button button-danger button-medium”**'
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 13.3 answer**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.3 答案**'
- en: '**[A1:](kindle_split_026_split_003.xhtml#ch15qa5q1)**'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_026_split_003.xhtml#ch15qa5q1)**'
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 15.4\. Using rest to pass arguments between functions
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4\. 使用 rest 在函数之间传递参数
- en: Imagine you’re using a library that does some image processing, but you need
    to hook into the processing function to add some logging. Many libraries provide
    middleware^([[1](kindle_split_026_split_004.xhtml#ch15fn01)]) for injecting code
    like this, but not all do; in such cases *monkey patching* will have to do. Monkey
    patching is the process of redefining a function to inject some custom logic before
    invoking the original function. In [listing 15.8](kindle_split_026_split_004.xhtml#ch15ex08)
    you monkey-patch the process function of a fictitious `imageDoctor` library and
    use rest to gather all the arguments and pass them along to the original function.
    This ensures that the original function is always invoked with the same arguments
    as the wrapping function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在使用一个进行图像处理的库，但你需要挂钩到处理函数以添加一些日志记录。许多库提供中间件^([[1](kindle_split_026_split_004.xhtml#ch15fn01)])
    来注入这样的代码，但并非所有库都这样做；在这种情况下，*猴子补丁* 将不得不使用。猴子补丁是指重新定义一个函数以在调用原始函数之前注入一些自定义逻辑的过程。在
    [列表 15.8](kindle_split_026_split_004.xhtml#ch15ex08) 中，你对一个虚构的 `imageDoctor` 库的处理函数进行猴子补丁，并使用
    rest 收集所有参数并将它们传递给原始函数。这确保了原始函数始终以与包装函数相同的参数调用。
- en: ¹
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Middleware are custom hooks provided by library authors that allow for injecting
    custom behaviors. Some JavaScript libraries that provide middleware are express.js
    ([http://expressjs.com/](http://expressjs.com/)) and redux.js ([http://redux.js.org/](http://redux.js.org/)).
    Also see [https://en.wikipedia.org/wiki/Middleware](https://en.wikipedia.org/wiki/Middleware).
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 中间件是由库作者提供的自定义钩子，允许注入自定义行为。一些提供中间件的 JavaScript 库有 express.js ([http://expressjs.com/](http://expressjs.com/))
    和 redux.js ([http://redux.js.org/](http://redux.js.org/))。另请参阅 [https://en.wikipedia.org/wiki/Middleware](https://en.wikipedia.org/wiki/Middleware)。
- en: Listing 15.8\. Using rest to forward parameters when monkey-patching
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.8：在 monkey-patching 时使用 rest 传递参数
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* First get a reference to the original method.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首先获取原始方法的引用。**'
- en: '***2* Define a new function that gathers all the arguments.**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个新的函数来收集所有参数。**'
- en: '***3* Inject your logging.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入你的日志。**'
- en: '***4* Return the result of the original function invoked with args.**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回原始函数调用 args 的结果。**'
- en: When we get into classes later in this book, you’ll learn about subclasses extending
    superclasses. When a subclass extends a superclass, it can override methods on
    the superclass. The overridden method can be invoked within the method that overrides
    it, and rest can again be used to handle the passing of arguments between the
    two.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书的后面部分介绍类时，你将学习关于子类扩展超类的内容。当一个子类扩展超类时，它可以覆盖超类上的方法。被覆盖的方法可以在覆盖它的方法中调用，并且
    rest 可以再次用来处理两个方法之间的参数传递。
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 15.4**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.4**'
- en: '**[Q1:](kindle_split_026_split_004.xhtml#ch15qa8q0a1)**'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_026_split_004.xhtml#ch15qa8q0a1)**'
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume you’re using a function called `ajax` to load data. Use rest to monkey-patch
    the function to log all its arguments.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你正在使用一个名为 `ajax` 的函数来加载数据。使用 rest 来 monkey-patch 这个函数以记录所有其参数。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 15.4 answer**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 15.4 答案**'
- en: '**[A1:](kindle_split_026_split_004.xhtml#ch15qa7q1)**'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_026_split_004.xhtml#ch15qa7q1)**'
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson you learned how to use default parameters and rest.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用默认参数和 rest。
- en: Default parameters allow for sane defaults.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数允许设置合理的默认值。
- en: Default parameters can be calculated using an expression.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数可以使用表达式来计算。
- en: Default parameter expressions are executed in the context of the function body.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数表达式在函数体内部执行。
- en: Default parameters are tied to their index in the arguments list.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数与其在参数列表中的索引相关联。
- en: Rest parameters gather all the remaining arguments as an array.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rest 参数将所有剩余的参数收集为一个数组。
- en: Rest parameters can be used to gather all arguments as an array.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rest 参数可以用来收集所有参数为一个数组。
- en: Rest parameters must be the last argument.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rest 参数必须是最后一个参数。
- en: There can only be one rest parameter per arguments list.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数列表中只能有一个 rest 参数。
- en: 'Let’s see if you got this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了：
- en: '**[Q15.1](kindle_split_050_split_010.xhtml#app01qa10q0a1)**'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q15.1](kindle_split_050_split_010.xhtml#app01qa10q0a1)**'
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function called `car` that allows you to create a `car` object. The
    function should accept the number of seats available as a parameter with a default
    value. The `car` object should have a `board` method that accepts a driver and
    any number of passengers using rest. The `board` method should then log who the
    driver is, who the passengers that fit are (according to the number of seats),
    and also list any passengers that could not fit.
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个名为 `car` 的函数，允许你创建一个 `car` 对象。该函数应接受一个参数，表示可用的座位数，并具有默认值。`car` 对象应有一个 `board`
    方法，该方法接受一个驾驶员和任意数量的乘客（使用 rest）。然后 `board` 方法应记录驾驶员是谁，哪些乘客可以乘坐（根据座位数），并列出无法乘坐的乘客。
- en: Lesson 16\. Destructuring parameters
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16课：解构参数
- en: After reading [lesson 16](kindle_split_027_split_000.xhtml#ch16), you will
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完第16课（[lesson 16](kindle_split_027_split_000.xhtml#ch16)）后，你将
- en: Know how to destructure array parameters
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何解构数组参数
- en: Know how to destructure object parameters
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何解构对象参数
- en: Know how to simulate named parameters
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何模拟命名参数
- en: Know how to create aliased parameters
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何创建别名参数
- en: In [lesson 11](kindle_split_021_split_000.xhtml#ch11) you learned about destructuring
    objects and arrays. These same principles can be used directly within the parameter
    list of a function. This makes array and object parameters easier to deal with
    and more self-documenting, and opens the door for useful techniques such as simulating
    named parameters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11课（[lesson 11](kindle_split_021_split_000.xhtml#ch11)）中，你学习了如何解构对象和数组。这些相同的原理可以直接应用于函数的参数列表中。这使得数组和对象参数更容易处理，并且更具自文档性，并为诸如模拟命名参数等有用的技术打开了大门。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: The following function takes three parameters. How would you go about making
    all of the parameters optional so the function could be called setting only the
    necessary values? For example, what if you only wanted to set the height and use
    a default width? How would the caller of the function specify that it just wants
    to specify the height? By name? What if it got the name wrong? For example, the
    caller might use `h` when the full word `height` was required.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受三个参数。你将如何使所有参数都成为可选的，以便函数可以只设置必要的值？例如，如果你只想设置高度并使用默认宽度怎么办？函数的调用者如何指定只想指定高度？通过名称？如果名称错误怎么办？例如，调用者可能使用
    `h` 而不是完整的单词 `height`。
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.1\. Destructuring array parameters
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1\. 解构数组参数
- en: Imagine you’re writing a program to compare the differences between two files.
    You’re using a library that provides a `diff` function that takes two strings
    and computes the difference between them. It returns an array with three values.
    The first value is the text that has been added. The second is the text that has
    been removed, and finally the third value is the text that has been modified.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在编写一个程序来比较两个文件之间的差异。你正在使用一个提供 `diff` 函数的库，该函数接受两个字符串并计算它们之间的差异。它返回一个包含三个值的数组。第一个值是已添加的文本。第二个是已删除的文本，最后第三个值是已修改的文本。
- en: Figure 16.1\. Figuring out which text has been added (green), changed (yellow),
    and deleted (red)
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.1\. 确定哪些文本已被添加（绿色）、更改（黄色）和删除（红色）
- en: '![](Images/16fig01_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig01_alt.jpg)'
- en: 'You need to write a function that can take these diffs and render a visualization,
    displaying them like in [figure 16.1](kindle_split_027_split_001.xhtml#ch16fig01).
    Let’s call this function `visualize`. If it were to accept three individual parameters—inserted,
    deleted, and modified—you could connect these two functions together like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编写一个函数，它可以接受这些差异并渲染一个可视化，就像在 [图 16.1](kindle_split_027_split_001.xhtml#ch16fig01)
    中显示的那样。让我们称这个函数为 `visualize`。如果它接受三个单独的参数——插入、删除和修改——你可以这样连接这两个函数：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works but it’s tedious having to extract the values out of the `diff`
    function just so you can pass them to the `visualize` function. A cleaner solution
    would be to make the `visualize` function’s input match the output of the `diff`
    function. Then connecting them would be much simpler:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但不得不从 `diff` 函数中提取值以便将它们传递给 `visualize` 函数，这很繁琐。一个更干净的方法是使 `visualize` 函数的输入与
    `diff` 函数的输出相匹配。然后连接它们会简单得多：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now the connection between the two functions is much cleaner. I would even
    make the argument that the code is more self-documenting, as it now reads *visualize
    diff,* which is exactly what you’re doing: visualizing the diff! But in order
    to make this possible, the `visualize` function now only takes one parameter,
    an array with the three values. So you have to reimplement your `visualize` function
    to take account of this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个函数之间的连接要干净得多。我甚至可以说，代码现在更具自文档性，因为它现在读作 *visualize diff*，这正是你正在做的事情：可视化差异！但是为了使这成为可能，`visualize`
    函数现在只接受一个参数，一个包含三个值的数组。所以你必须重新实现你的 `visualize` 函数来考虑这一点：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, you’ve moved the tedious extraction step from outside the function
    to inside it. Yes, it’s now much cleaner looking when you connect the `visualize`
    and `diff` functions together, but it comes at a cost of muddying up the implementation
    of the `visualize` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经将繁琐的提取步骤从函数外部移到了函数内部。是的，当你连接 `visualize` 和 `diff` 函数时，它现在看起来更干净，但这是以模糊化
    `visualize` 函数的实现为代价的。
- en: 'Hopefully you’re already thinking that you can clean this up using array destructuring
    like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经想到了，你可以使用数组解构来清理它，如下所示：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Destructure the diff parameter into the three values you need.**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 diff 参数解构为所需的三个值。**'
- en: 'If so, you’re correct! However, you can remove a step and make this even cleaner
    by doing the destructuring in the parameter list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，你是对的！然而，你可以通过在参数列表中进行解构来移除一个步骤，使它更加干净：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now you’ve successfully removed some of the cognitive load between connecting
    these two functions. You made the code more self-documenting and you did it without
    having to sacrifice readability elsewhere.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功消除了连接这两个函数之间的认知负担。你使代码更具自文档性，而且你做到了这一点，而无需在其他地方牺牲可读性。
- en: What if the `diff` function returned an object with `inserted`, `modified`,
    and `deleted` properties instead of an array? In the next section you’ll update
    your visualize function to handle such a case.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `diff` 函数返回一个具有 `inserted`、`modified` 和 `deleted` 属性的对象而不是数组怎么办？在下一节中，你将更新你的可视化函数以处理这种情况。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 16.1**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.1**'
- en: '**[Q1:](kindle_split_027_split_001.xhtml#ch16qa2q0a1)**'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_027_split_001.xhtml#ch16qa2q0a1)**'
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let say you are writing a widget library. You want to allow whoever installs
    your widget to be able to set the colors the widget uses. Implement the following
    `setColors` function so that it destructures the array of colors. Use any names
    you like for each of the three colors.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你正在编写一个小部件库。你希望允许安装你的小部件的人能够设置小部件使用的颜色。实现以下 `setColors` 函数，以便解构颜色数组。你可以为每个三种颜色使用你喜欢的名称。
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 16.1 answer**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.1 答案**'
- en: '**[A1:](kindle_split_027_split_001.xhtml#ch16qa1q1)**'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_027_split_001.xhtml#ch16qa1q1)**'
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.2\. Destructuring object parameters
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2. 解构对象参数
- en: 'In the previous section you worked with a `diff` function that returned an
    array containing the inserted, deleted, and modified lines between two files.
    But what if you updated the version of the `diff` library you were using and the
    function returned an object with inserted, deleted, and modified properties? How
    could you update your `visualize` function to correctly extract the data from
    the new format? The solution is almost exactly the same:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你使用了一个返回包含两个文件之间插入、删除和修改行的数组的 `diff` 函数。但如果你更新了你使用的 `diff` 库的版本，并且函数返回了一个具有插入、删除和修改属性的对象，你该如何更新你的
    `visualize` 函数以正确地从新格式中提取数据？解决方案几乎完全相同：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the only thing you had to change was that instead of wrapping
    your parameter list with `[` and `]` brackets, you swapped them out for `{` and
    `}` braces. Instead of grabbing values from an array by using their position in
    the array, you’re now grabbing particular properties from an object using the
    actual names of those properties.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你需要做的唯一改变是，不再用中括号 `[` 和 `]` 括起参数列表，而是用花括号 `{` 和 `}` 替换。不再通过在数组中的位置来获取值，而是现在通过属性的真正名称从对象中获取特定的属性。
- en: In the *array* destructuring, you can use whatever names you want as long as
    the position of the fields is correct. In the *object* destructuring, you can
    list the properties in any order, as long as the names match up correctly. This
    is just like regular object and array destructuring, only taking place in the
    parameter list of a function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组解构中，你可以使用你想要的任何名称，只要字段的顺序正确。在对象解构中，你可以以任何顺序列出属性，只要名称匹配正确。这就像常规的对象和数组解构一样，只是在函数的参数列表中发生。
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 16.2**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.2**'
- en: '**[Q1:](kindle_split_027_split_002.xhtml#ch16qa4q0a1)**'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_027_split_002.xhtml#ch16qa4q0a1)**'
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rewrite the `setColors` function to destructure colors using object destructuring.
    Remember: this time the names, not the order, must align.'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 `setColors` 函数重写为使用对象解构解构颜色。记住：这次不是顺序，而是名称必须对齐。
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 16.2 answer**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.2 答案**'
- en: '**[A1:](kindle_split_027_split_002.xhtml#ch16qa3q1)**'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_027_split_002.xhtml#ch16qa3q1)**'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.3\. Simulating named parameters
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3. 模拟命名参数
- en: 'Let’s imagine you’re writing a function to build a car. You decide that you
    want to let the caller of the function set the make, model, and year of the car,
    so you add a parameter for each:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你正在编写一个构建汽车的函数。你决定你想让函数的调用者设置汽车的制造商、型号和年份，所以你为每个参数添加了一个：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, you want each parameter to be optional and have a default value. You
    may think that since JavaScript now supports default values, it will solve your
    problem. But what if the caller only wants to set the year (the third parameter)?
    With default parameters, the first two must either be set or explicitly passed
    as `undefined`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你希望每个参数都是可选的，并且有一个默认值。你可能认为由于JavaScript现在支持默认值，它将解决你的问题。但如果调用者只想设置年份（第三个参数）怎么办？使用默认参数，前两个必须设置或明确传递为
    `undefined`：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is not ideal. You can use object destructuring in the parameter list to
    simulate *named parameters* (the ability to set parameters by name instead of
    position):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。你可以在参数列表中使用对象解构来模拟命名参数（通过名称而不是位置设置参数的能力）：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now it looks and behaves like you’re using named parameters, but in reality
    you’re just using a single parameter of an object, as shown in [figure 16.2](kindle_split_027_split_003.xhtml#ch16fig02).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它看起来和表现就像你正在使用命名参数一样，但实际上你只是在使用一个对象的单个参数，如图16.2所示。
- en: Figure 16.2\. Simulating named parameters
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.2\. 模拟命名参数
- en: '![](Images/16fig02.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig02.jpg)'
- en: 'You still need to figure out a way to set defaults for each. Since this is
    only one parameter you could default that parameter (the entire object) to an
    object with all the values preset:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要想出一个方法为每个设置默认值。由于这只有一个参数，你可以将这个参数（整个对象）默认为一个预设了所有值的对象：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But this will only work if no object is passed at all. By passing an object
    like `{ year: 1965 }`, even though it’s missing some desired keys, the parameter
    is still passed. Remember, in reality you’re only dealing with a single parameter,
    so the default does not get set:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '但这只会在没有传递任何对象的情况下工作。通过传递一个如 `{ year: 1965 }` 的对象，即使它缺少一些所需的键，参数仍然被传递。记住，实际上你只处理一个参数，所以默认值没有被设置：'
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* No parameter passed, so defaults to object with all values set**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 没有传递参数，所以默认为设置所有值的对象**'
- en: '***2* A parameter is passed, so the default isn’t used and you don’t get the
    make or model.**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 传递了参数，所以没有使用默认值，也没有得到制造商或型号。**'
- en: 'A better way is possible. You can actually destructure the object and give
    each individual key a default value independently:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更好的方法。实际上，你可以解构对象，并为每个单独的键独立地提供一个默认值：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* The year gets set while the make and model fall back to defaults.**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 年份被设置，而制造商和型号则回退到默认值。**'
- en: 'Now that you’re setting default values for each individual key that you’re
    destructuring, you can successfully set what values you want to change and have
    the others fall back to defaults. The only problem remaining is when you invoke
    the function without a parameter at all:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在为每个你正在解构的单独键设置默认值，你可以成功设置你想要更改的值，而其他值则回退到默认值。唯一剩下的问题是当你完全没有任何参数调用函数时：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* An error is thrown here because you attempt to destructure a missing
    object.**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这里抛出错误是因为你尝试解构一个缺失的对象。**'
- en: 'As it stands, you still need to call the function with an empty object like
    `car({})`, even when you don’t want to change any of the default values. This
    is because if you don’t pass in an object, the parameter will be `undefined` and
    you won’t be able to perform object destructuring on an `undefined` value. To
    fix this, you can continue to default each key to a specific value but also default
    the entire parameter to an empty object:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 按照现状，你仍然需要用一个空对象如 `car({})` 调用函数，即使你不想更改任何默认值。这是因为如果你没有传递一个对象，参数将是 `undefined`，你将无法在
    `undefined` 值上执行对象解构。为了解决这个问题，你可以继续将每个键默认为特定值，但也将整个参数默认为一个空对象：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* All values fall back to defaults.**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 所有值都回退到默认值。**'
- en: '***2* The year gets set while the make and model fall back to defaults.**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 年份被设置，而制造商和型号则回退到默认值。**'
- en: Now if you call the function without a parameter at all, it defaults to an empty
    object, and because the empty object is missing the make, model, and year, they
    all still fall back to their default values. And of course, if you do pass in
    an object, any of the missing keys get set to their respective default values.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你完全没有任何参数调用函数，它默认为一个空对象，由于空对象缺少制造商、型号和年份，它们都仍然回退到它们的默认值。当然，如果你传递了一个对象，任何缺失的键都会被设置为它们各自的默认值。
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 16.3**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查16.3**'
- en: '**[Q1:](kindle_split_027_split_003.xhtml#ch16qa6q0a1)**'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_027_split_003.xhtml#ch16qa6q0a1)**'
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a pagination function that simulates named parameters for `currentPage`
    and `resultsPerPage` and that default to 1 and 24 respectively.
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个分页函数，该函数模拟 `currentPage` 和 `resultsPerPage` 的命名参数，默认值分别为1和24。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 16.3 answer**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.3 答案**'
- en: '**[A1:](kindle_split_027_split_003.xhtml#ch16qa5q1)**'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_027_split_003.xhtml#ch16qa5q1)**'
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.4\. Creating aliased parameters
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4\. 创建别名参数
- en: 'Let’s imagine you have a function called `setCoordinates` that takes an object
    with latitude and longitude properties. The problem is that you’re using two different
    mapping libraries: one for rendering maps, another for doing reverse geo lookups.
    One uses the properties `lat` and `lon`, while the other uses `lat` and `lng`.
    Because of this, you want to make your function smart enough to handle both. You
    may be inclined to define your function like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你有一个名为`setCoordinates`的函数，它接受一个具有纬度和经度属性的对象。问题是你在使用两个不同的映射库：一个用于渲染地图，另一个用于反向地理查找。一个使用`lat`和`lon`属性，而另一个使用`lat`和`lng`属性。正因为如此，你希望你的函数足够智能，可以处理这两种情况。你可能倾向于这样定义你的函数：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Assign either coords.lng or coords.lon (whichever exists) to your variable.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将coords.lng或coords.lon（ whichever exists）分配给您的变量。**'
- en: 'You can use a combination of parameter destructuring and default values to
    do this as well:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过参数解构和默认值的组合来做这件事：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here you’re using destructuring to grab `lat`, `lon`, and `lng` directly. But
    you’re defaulting `lng` to `lon`; this means that no matter which one is given
    to you, you’ll be able to capture it as `lng`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用解构直接获取`lat`、`lon`和`lng`。但你将`lng`默认为`lon`；这意味着无论给你哪一个，你都能将其捕获为`lng`。
- en: 'If `lng` defaults to `lon` to create an alias, what if you actually want to
    set a real default value to `lng`? Well, since `lng` defaults to `lon`, you can
    simply add the default value to `lon`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lng`默认为`lon`以创建别名，那么如果你实际上想为`lng`设置一个真正的默认值，会怎样呢？嗯，由于`lng`默认为`lon`，你只需简单地将默认值添加到`lon`中：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now your function accepts `lon` or `lng` just as it did before, but this time
    it also defaults to a specific location (Atlanta). The way this works is that
    if `lng` is set, it doesn’t matter what `lon` is set to; you ignore it. If `lng`
    is not set, it defaults to `lon`. If `lon` is not set, it defaults to -84.3880,
    which transitively also makes `lng` default to -84.3880.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的函数接受`lon`或`lng`，就像之前一样，但这次它还默认到一个特定的位置（亚特兰大）。这样工作的方式是，如果设置了`lng`，那么`lon`设置成什么并不重要；你忽略它。如果`lng`没有设置，它默认为`lon`。如果`lon`没有设置，它默认为-84.3880，这间接地也使得`lng`默认为-84.3880。
- en: 'This useful technique can also be used without destructuring by using default
    values:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有用的技巧也可以通过使用默认值而不使用解构来使用：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice how you didn’t use the `{}`: which means this function doesn’t take
    a single object as a parameter and then destructure values from it like the previous
    one. This time, you’re actually accepting three different arguments and setting
    defaults for them in a similar way.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你没有使用`{}`：这意味着这个函数不像之前的那个函数那样接受一个对象作为参数，然后从中解构值。这次，你实际上接受了三个不同的参数，并以类似的方式为它们设置默认值。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.4**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.4**'
- en: '**[Q1:](kindle_split_027_split_004.xhtml#ch16qa8q0a1)**'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_027_split_004.xhtml#ch16qa8q0a1)**'
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this same technique to make a function that can take either `width` and
    `height` properties or `w` and `h` properties with a default size.
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用相同的技巧来创建一个可以接受`width`和`height`属性或`w`和`h`属性（具有默认大小）的函数。
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.4 answer**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.4 答案**'
- en: '**[A1:](kindle_split_027_split_004.xhtml#ch16qa7q1)**'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_027_split_004.xhtml#ch16qa7q1)**'
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned how to apply destructuring techniques to function
    parameters, including how to
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何将解构技术应用于函数参数，包括如何
- en: More elegantly connect the outputs of one function to the inputs of another.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更优雅地将一个函数的输出连接到另一个函数的输入。
- en: Make all arguments optional by simulating named parameters.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟命名参数，使所有参数都成为可选的。
- en: Make the names of arguments have aliases by combining destructuring with default
    values.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合解构与默认值，使参数的名称具有别名。
- en: 'Let’s see if you got this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q16.1](kindle_split_050_split_011.xhtml#app01qa11q0a1)**'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q16.1](kindle_split_050_split_011.xhtml#app01qa11q0a1)**'
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code, there are three functions. Each interacts with an internal
    map object, updating a different property. Combine these three functions into
    a single function called `updateMap` that simulates named parameters for `zoom`,
    `bounds`, and `coords`. Additionally, create an alias so that `coords` can also
    be set by the named `center`.
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在下面的代码中，有三个函数。每个都与一个内部映射对象交互，更新不同的属性。将这些三个函数合并成一个名为`updateMap`的单个函数，该函数模拟了`zoom`、`bounds`和`coords`的命名参数。此外，创建一个别名，以便`coords`也可以通过命名的`center`来设置。
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Lesson 17\. Arrow functions
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17课\. 箭头函数
- en: After reading [lesson 17](kindle_split_028_split_000.xhtml#ch17), you will
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了[第17课](kindle_split_028_split_000.xhtml#ch17)之后，你将
- en: Know how to make your code succinct with arrow functions
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用箭头函数使代码简洁
- en: Know how to maintain context with arrow functions
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用箭头函数保持上下文
- en: Arrow functions in JavaScript are directly inspired by the *fat arrow functions*
    of CoffeeScript. They behave similarly to CoffeeScript’s by providing a much more
    succinct way of writing a function expression and also maintaining their context
    (what `this` refers to). The syntax isn’t always the same as CoffeeScript’s but
    they are just as useful and a great addition that makes things like anonymous
    functions and inline callbacks much more elegant.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的箭头函数直接受到CoffeeScript中的*胖箭头函数*的启发。它们的行为与CoffeeScript类似，通过提供一种更简洁的方式来编写函数表达式，并保持它们的上下文（`this`指的是什么）。语法并不总是与CoffeeScript相同，但它们同样有用，并且是一个很好的补充，使得匿名函数和内联回调变得更加优雅。
- en: Sometimes extraneous syntax can make code much harder for the human mind to
    parse, because there are several extra pieces to think about. It’s not a hard
    and fast rule that few characters mean easy to understand. For example, single-letter
    variable names or overly clever _code golf_^([[1](kindle_split_028_split_000.xhtml#ch17fn01)])
    solutions are terrible to read. However, if you can convey a meaning eloquently
    with fewer characters, it’s almost always more understandable than it would be
    with more characters. The human brain has a hard time parsing lots of information
    at once, so the more noise you can reduce, the better.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有时多余的语法会使代码对人类思维来说难以解析，因为需要考虑的额外部分很多。并不是说字符越少就越容易理解。例如，单字母变量名或过于聪明的_代码高尔夫_([1](kindle_split_028_split_000.xhtml#ch17fn01))解决方案很难阅读。然而，如果您能用更少的字符传达一个含义，那么它通常比用更多的字符更容易理解。人类大脑很难一次性处理大量信息，所以您能减少的噪音越多，效果越好。
- en: ¹
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A game in which a programmer writes a program with as few characters as possible.
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个游戏中，程序员编写尽可能少的字符的程序。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Here’s some code that maps a set of numbers, applying an exponent to each of
    them. Notice how you’re using `that=this` to maintain context inside the anonymous
    function passed to `map`. The map function in particular accepts a second parameter
    that sets the context, but many functions don’t provide such a convenience, leaving
    developers to come up with work-arounds like the `that=this` used here. How many
    times have you had to write code like this? Wouldn’t it be nice if there were
    an elegant way to maintain the outer context?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码，它将一组数字映射到另一个集合，对每个数字应用指数。注意您是如何在传递给`map`的匿名函数中使用`that=this`来保持上下文的。特别是，`map`函数接受一个设置上下文的第二个参数，但许多函数不提供这种便利，让开发者不得不想出像这里使用的`that=this`这样的解决方案。您有多少次不得不编写这样的代码？如果有一种优雅的方式来保持外部上下文，那不是很好吗？
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.1\. Succinct code with arrow functions
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1\. 使用箭头函数编写简洁的代码
- en: 'The arrow function has a couple of different syntaxes depending on the number
    of arguments or the number of expressions in the function body. The most elegant
    is when there’s exactly one parameter and exactly one expression in the function
    body. The `double` function we just saw is such an example. It’s functionally
    equivalent to the function expression defined just before it. It has the syntax
    `singleParam => returnExpression`. If there isn’t exactly one param (either zero,
    or two or more), then the parameters must be wrapped in parentheses:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的语法取决于函数参数的数量或函数体中表达式的数量。最优雅的情况是当函数体中只有一个参数和一个表达式。我们刚才看到的`double`函数就是一个例子。它从功能上等同于其之前定义的函数表达式。其语法为`singleParam
    => returnExpression`。如果参数不是恰好一个（无论是零个、两个或更多），那么参数必须用括号括起来：
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Multiple parameters need to be wrapped in parentheses.**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 多个参数需要用括号括起来。**'
- en: '***2* You must use empty parentheses when there are no parameters.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当没有参数时，必须使用空括号。**'
- en: Figure 17.1\. Arrow function parentheses rules
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.1\. 箭头函数括号规则
- en: '![](Images/17fig01_alt.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/17fig01_alt.jpg)'
- en: 'You can still wrap a single paramemter in parentheses as well if desired (see
    [figure 17.1](kindle_split_028_split_001.xhtml#ch17fig01)). There are a couple
    of other situations when you must wrap your single parameter with parentheses
    if it’s a rest parameter or a destructured parameter:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您也可以将单个参数用括号括起来（参见[图17.1](kindle_split_028_split_001.xhtml#ch17fig01)）。还有一些其他情况下，如果参数是剩余参数或解构参数，您必须用括号将单个参数括起来：
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Correct syntax**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正确的语法**'
- en: '***2* Syntax error**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 语法错误**'
- en: '***3* Correct syntax**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 正确的语法**'
- en: '***4* Syntax error**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 语法错误**'
- en: 'If there’s more than one expression in the function body, it must be wrapped
    in curly braces:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数体中有多个表达式，则必须用花括号括起来：
- en: '[PRE48]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* First expression**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第一个表达式**'
- en: '***2* Second**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第二个**'
- en: 'This is similar to `if` statements and `for` loops, where the curly braces
    are optional only if the body (the code that would be inside the curly braces)
    is a single expression or statement. If there’s more than one expression or statement,
    then curly braces must be used:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`if`语句和`for`循环类似，其中花括号是可选的，只有当主体（花括号内的代码）是一个单独的表达式或语句时。如果有多个表达式或语句，则必须使用花括号：
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* This is part of the if statement.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是if语句的一部分。**'
- en: '***2* This is not part of the if statement.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这不是if语句的一部分。**'
- en: '***3* This is part of the function.**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这是函数的一部分。**'
- en: '***4* This is not part of the function.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这不是函数的一部分。**'
- en: 'When the curly braces are omitted, there’s an additional benefit besides not
    having to type the extra two characters: there’s an implicit `return` of the single
    expression. This implicit return of single expression arrow functions is elegant
    because it reads as the input value pointing to the return value. For example,
    a no-op function^([[2](kindle_split_028_split_001.xhtml#ch17fn02)]) would look
    like `x => x`, or a function that wraps its value in an array would look like
    `x => [x]`. See how it reads as `from => to` or `start => finish` or `give =>
    get`. This concise syntax has almost zero cognitive load, and is extremely easy
    to mentally parse while also being self-documenting.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当省略花括号时，除了不需要输入额外的两个字符外，还有一个额外的好处：隐式地返回单个表达式。这种单个表达式箭头函数的隐式返回是优雅的，因为它读起来就像输入值指向返回值。例如，一个无操作函数^([[2](kindle_split_028_split_001.xhtml#ch17fn02)])看起来像`x
    => x`，或者一个将值包裹在数组中的函数看起来像`x => [x]`。看看它如何读作`from => to`或`start => finish`或`give
    => get`。这种简洁的语法认知负荷几乎为零，同时也很容易在心理上解析，并且具有自文档化的特性。
- en: ²
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No operation, often used to allow hooking into functionality. See [https://en.wikipedia.org/wiki/NOP](https://en.wikipedia.org/wiki/NOP).
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无操作，常用于允许挂钩到功能。见[https://en.wikipedia.org/wiki/NOP](https://en.wikipedia.org/wiki/NOP)。
- en: 'Another scenario where arrow functions make code extremely concise is when
    you need to make a function that returns another function. Let’s say you want
    to make a function called `exponent` that takes a number and returns another function
    that will apply the exponent to a given base number:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个箭头函数使代码极其简洁的场景是当你需要创建一个返回另一个函数的函数时。比如说，你想创建一个名为`exponent`的函数，它接受一个数字并返回另一个函数，该函数将对给定的基数应用指数：
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* 25**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 25**'
- en: '***2* 125**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 125**'
- en: '***3* 625**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 625**'
- en: Also notice the `**` operator. This is a new operator introduced in ES2016 that
    applies an exponent. Previously you would have to use `Math.pow` to achieve the
    same thing.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`**`运算符。这是ES2016中引入的一个新运算符，用于应用指数。之前，你需要使用`Math.pow`来实现相同的功能。
- en: 'Let’s take a look at the ES5 equivalent implementation of this `exponent` function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个`exponent`函数的ES5等价实现：
- en: '[PRE51]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: I definitely think the arrow function version is much simpler and easier to
    read.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实认为箭头函数版本更简单、更容易阅读。
- en: 'In [lesson 15](kindle_split_026_split_000.xhtml#ch15) you defined a `pluck`
    function that grabs a specified set of values from an object. Here’s the original
    `pluck` function followed by a version using arrow functions:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15课](kindle_split_026_split_000.xhtml#ch15)中，你定义了一个`pluck`函数，该函数从对象中获取指定的值集。以下是原始的`pluck`函数，后面跟着使用箭头函数的版本：
- en: '[PRE52]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Doesn’t the latter version with the arrow function read more nicely? Higher-order
    functions like `map`, `reduce`, `filter`, and so on lend themselves to arrow functions
    beautifully. This is true even more so when those higher-order functions need
    to be executed in their containing context.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的版本不是读起来更顺口吗？像`map`、`reduce`、`filter`等高阶函数非常适合箭头函数。当这些高阶函数需要在它们的包含上下文中执行时，这一点尤其正确。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.1**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.1**'
- en: '**[Q1:](kindle_split_028_split_001.xhtml#ch17qa2q0a1)**'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_028_split_001.xhtml#ch17qa2q0a1)**'
- en: ''
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Convert the following summation function to use arrow functions:'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下求和函数转换为使用箭头函数：
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.1 answer**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.1 答案**'
- en: '**[A1:](kindle_split_028_split_001.xhtml#ch17qa1q1)**'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_028_split_001.xhtml#ch17qa1q1)**'
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.2\. Maintaining context with arrow functions
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2\. 使用箭头函数保持上下文
- en: 'Let’s take the `pluck` function from the previous section a little further.
    Instead of it getting the object to operate on as an argument, let’s assume a
    `Model` object that is a wrapper object for a record from a database. The `pluck`
    function will be a method on this model object. If you implemented it without
    any considerations for context, it would break when trying to refer to itself
    using the keyword `this` inside of a callback function:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨上一节中的`pluck`函数。而不是让它作为参数获取要操作的对象，让我们假设一个`Model`对象，它是数据库记录的包装对象。`pluck`函数将是这个模型对象上的一个方法。如果你在没有任何上下文考虑的情况下实现它，那么在回调函数内部使用关键字`this`引用自身时，它就会出错：
- en: '[PRE55]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* The keyword this does not point back to the model object.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 关键字this不会指向模型对象。**'
- en: 'A common convention that’s pretty ugly in my opinion is to first declare a
    variable called `that` and assign it to `this` so that, inside the callback function,
    you can still access the variable `that` even after losing context:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一个常见的约定相当丑陋，那就是首先声明一个名为`that`的变量并将其赋值给`this`，这样在回调函数内部，即使在失去上下文之后，你仍然可以访问变量`that`：
- en: '[PRE56]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Get a reference to this that the callback can use.**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取回调可以使用的this引用。**'
- en: '***2* Using the that reference**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用that引用**'
- en: 'This `that equals this` monkey business works, but it doesn’t make the code
    any more readable. There’s actually a final argument to most higher-order functions
    like this that allows for setting the invocation context. A better version would
    be like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`that equals this`的猴子业务是可行的，但它并没有使代码更易于阅读。实际上，大多数像这样的高阶函数都有一个最终参数，允许设置调用上下文。一个更好的版本可能是这样的：
- en: '[PRE57]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Setting the context to this (the model object)**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将上下文设置为this（模型对象）**'
- en: '***2* The this keyword now points to the Model object.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* this关键字现在指向Model对象。**'
- en: 'This is already much better than the `that equals this` solution, but you can
    skip this whole contextual step by using an arrow function. An arrow function’s
    context is bound directly to the context it’s defined in. What that means is the
    keyword `this` inside of an arrow function is always the same as it is outside
    of the arrow function. So a version using the arrow function would look like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经比`that equals this`解决方案好多了，但你可以通过使用箭头函数来跳过整个上下文步骤。箭头函数的上下文直接绑定到其定义的上下文。这意味着箭头函数内部的`this`关键字始终与箭头函数外部相同。所以使用箭头函数的版本看起来会是这样：
- en: '[PRE58]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* The this keyword still points to the model object.**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* this关键字仍然指向模型对象。**'
- en: 'Just for fun, compare this to how it might look with all of the JavaScript.
    Next features removed:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，比较一下它可能看起来像JavaScript。接下来移除的功能：
- en: '[PRE59]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Wow, what a difference it makes for the readability of even a small method like
    this. Imagine how much more readable an entire app could become, and you’re just
    getting started!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这对即使是这种小方法的可读性都有很大的影响。想象一下，如果整个应用程序的可读性会提高多少，而你只是刚刚开始！
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.2**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.2**'
- en: '**[Q1:](kindle_split_028_split_002.xhtml#ch17qa4q0a1)**'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_028_split_002.xhtml#ch17qa4q0a1)**'
- en: ''
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reimplement the exponent method from the priming exercise to use arrow functions.
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将预热练习中的指数方法重新实现为使用箭头函数。
- en: '|  |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.2 answer**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.2 答案**'
- en: '**[A1:](kindle_split_028_split_002.xhtml#ch17qa3q1)**'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_028_split_002.xhtml#ch17qa3q1)**'
- en: ''
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.3\. Arrow function gotchas
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3\. 箭头函数的注意事项
- en: 'An important thing we should note about arrow functions is that they’re always
    a function expression, not a function definition:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 关于箭头函数的一个重要注意事项是，它们始终是函数表达式，而不是函数定义：
- en: '[PRE61]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Function definition**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数定义**'
- en: '***2* Function expression**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数表达式**'
- en: '***3* Arrow function (equivalent to function expression)**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 箭头函数（相当于函数表达式）**'
- en: 'This means that arrow functions can’t hoist like function definitions:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着箭头函数不能像函数定义那样提升：
- en: '[PRE62]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Works because function definitions are hoisted**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为函数定义是提升的**'
- en: '***2* ReferenceError because constants can’t be accessed before being declared**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* ReferenceError，因为常量在声明之前不能被访问**'
- en: 'This throws a reference error because `const` and `let` variables can’t be
    accessed before they’re declared. But `var` variables can be accessed before they’re
    declared, yet are always `undefined`. So even if you used a `var` to create an
    arrow function, you would still get an error if you tried to use the arrow function
    before it was declared, only now it would be a type error:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这会抛出一个引用错误，因为`const`和`let`变量在声明之前不能被访问。但是`var`变量可以在声明之前被访问，但总是`undefined`。所以即使你使用`var`创建了一个箭头函数，如果你在它声明之前尝试使用箭头函数，你仍然会得到一个错误，但现在它将是一个类型错误：
- en: '[PRE63]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Works because function definitions are hoisted**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为函数定义是提升的**'
- en: '***2* TypeError undefined is not a function.**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 类型错误：undefined不是一个函数。**'
- en: 'There’s another common situation with arrow functions that can be puzzling.
    This is when you try to implicitly return an object literal from an arrow function.
    You would probably write something like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数还有一种常见的情况可能会让人困惑。这是当你尝试从箭头函数中隐式返回一个对象字面量时。你可能写成这样：
- en: '[PRE64]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* SyntaxError**'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 语法错误**'
- en: 'This would actually be a syntax error. Anytime the `=>` of the arrow function
    is followed by curly braces, it means that those curly braces are the opening
    and closing of the function body (no matter how many expressions). To get around
    this, you can wrap the object literal in parentheses:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会是一个语法错误。每当箭头函数的`=>`后面跟着大括号时，这意味着那些大括号是函数体的开始和结束（无论有多少表达式）。为了解决这个问题，你可以将对象字面量包裹在括号中：
- en: '[PRE65]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Works as expected**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 按预期工作**'
- en: 'Finally, arrow functions can’t have their context changed with `bind`, `call`,
    or `apply`. This means that if you’re using a library that attempts to change
    the context of callback functions, it could lead to bugs. For example, `jQuery`
    changes the context of functions supplied to `$.each()` so that `this` refers
    to the given DOM node like so:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，箭头函数不能通过`bind`、`call`或`apply`改变其上下文。这意味着如果你使用一个尝试改变回调函数上下文的库，可能会导致错误。例如，`jQuery`通过使用`call`或`apply`调用回调并设置上下文为给定的节点来改变传递给`$.each()`的函数的上下文，如下所示：
- en: '[PRE66]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* jQuery sets this to point to the individual span DOM node.**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* jQuery将其设置为指向单个span DOM节点。**'
- en: 'jQuery achieves this by invoking the callback with either `call` or `apply`
    and setting the context to the given node. If you were to use an arrow function,
    jQuery wouldn’t be able to change the context:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery通过调用回调并使用`call`或`apply`来设置上下文为给定的节点来实现这一点。如果你使用箭头函数，jQuery将无法改变上下文：
- en: '[PRE67]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* jQuery couldn’t set this so $(this) may not work.**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* jQuery无法设置此值，因此$(this)可能不起作用。**'
- en: If you can avoid these traps, arrow functions will become a great new tool in
    your developer tool belt.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够避免这些陷阱，箭头函数将成为你开发者工具包中的强大新工具。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 17.3**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.3**'
- en: '**[Q1:](kindle_split_028_split_003.xhtml#ch17qa6q0a1)**'
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_028_split_003.xhtml#ch17qa6q0a1)**'
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be logged to the console?
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将会在控制台输出什么？
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 17.3 answer**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.3 答案**'
- en: '**[A1:](kindle_split_028_split_003.xhtml#ch17qa5q1)**'
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_028_split_003.xhtml#ch17qa5q1)**'
- en: ''
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: undefined
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: undefined
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, you learned about the syntax and mechanics of arrow functions.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了箭头函数的语法和机制。
- en: Arrow functions are a concise way to write functions.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数是编写函数的一种简洁方式。
- en: Arrow functions use the operator `=>` after the arguments list, as opposed to
    the keyword `function` before the arguments list.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数在参数列表之后使用操作符`=>`，而不是在参数列表之前使用关键字`function`。
- en: An arrow function’s curly braces are optional when there’s only one expression
    in the function body.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数体中只有一个表达式时，箭头函数的大括号是可选的。
- en: Arrow functions implicitly `return` when the curly braces are omitted.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当省略大括号时，箭头函数隐式地`return`。
- en: An arrow function’s context (`this`) is bound to the context it’s defined in.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数的上下文（`this`）绑定到其定义的上下文中。
- en: 'Let’s see if you got this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q17.1](kindle_split_050_split_012.xhtml#app01qa12q0a1)**'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q17.1](kindle_split_050_split_012.xhtml#app01qa12q0a1)**'
- en: ''
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here you have a `translator` function that, when called with a country code,
    returns a template literal tagging function that translates interpolated values
    to the corresponding language using the `TRANSLATE` function. The `TRANSLATE`
    function is just a mock to test that the `translator` function works. Building
    an actual translating library is beyond the scope of this book. Reimplement the
    `translator` function to use arrow functions. There should be three total arrow
    functions used:'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一个`translator`函数，当用国家代码调用时，它会返回一个模板字面量标记函数，该函数使用`TRANSLATE`函数将插值值翻译成对应语言。`TRANSLATE`函数只是一个模拟，用于测试`translator`函数是否工作。构建实际的翻译库超出了本书的范围。重新实现`translator`函数以使用箭头函数。总共应该使用三个箭头函数：
- en: ''
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Lesson 18\. Generator functions
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18课\. 生成器函数
- en: After reading [lesson 18](kindle_split_029_split_000.xhtml#ch18), you will
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第18课](kindle_split_029_split_000.xhtml#ch18)后，你将
- en: Know how to define generator functions
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何定义生成器函数
- en: Know how to yield values from generator functions
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何从生成器函数中产生值
- en: Understand the generator function lifecycle
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解生成器函数的生命周期
- en: Generator functions are one of the harder things to comprehend among all the
    recent additions to JavaScript. They introduce a new form of code execution and
    processing that most JavaScript developers haven’t seen before. Generators aren’t
    new concepts, though—they’re already part of Python, C#, and other languages.
    This lesson is only meant to be a gentle introduction to the topic.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是JavaScript最近添加的较难理解的功能之一。它们引入了一种新的代码执行和处理形式，这是大多数JavaScript开发者以前没有见过的。尽管生成器不是新概念，但它们已经是Python、C#和其他语言的一部分。本课仅旨在对该主题进行温和的介绍。
- en: You’ll see how good generators are at creating lists, but that isn’t all generators
    are good for. That would be like saying objects are only useful for storing key/value
    pairs. To the contrary, generators, like objects, are a powerful multipurpose
    tool that can be used for all sorts of problems. For example, we’ll see how useful
    they can be for working with iterable and asynchronous tasks later on in [Units
    5](kindle_split_035.xhtml#part05) and [7](kindle_split_044.xhtml#part07). For
    now, though, you need to master the basics.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到生成器在创建列表方面的良好表现，但这并不是生成器的全部用途。这就像说对象只用于存储键/值对一样。相反，生成器，就像对象一样，是一种功能强大的多功能工具，可以用于各种问题。例如，我们将在[第5单元](kindle_split_035.xhtml#part05)和[第7单元](kindle_split_044.xhtml#part07)中看到，它们在处理可迭代和异步任务方面是多么有用。然而，目前，你需要掌握基础知识。
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Inside of a function, once you `return` a value, the rest of the function is
    no longer processed and the function exits. This means the `return` statement
    stops the function from going any further. What if you could return a value, but
    only pause the function at that point instead of exit, and then later tell the
    function to continue where it left off?
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，一旦你`return`一个值，函数的其余部分就不再处理，函数退出。这意味着`return`语句阻止函数继续执行。如果你可以返回一个值，但只在该点暂停函数而不是退出，然后稍后告诉函数从上次离开的地方继续，会怎么样呢？
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.1\. Defining generator functions
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1\. 定义生成器函数
- en: 'A generator function is a special type of function. It’s a factory for returning
    new generator objects. Each generator object returned from a generator function
    behaves according to the body of the function it came from. That is, the body
    of the generator function defines the blueprint for each generator that it returns:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是一种特殊类型的函数。它是一个返回新生成器对象的工厂。从生成器函数返回的每个生成器对象都根据其来源函数的主体行为。也就是说，生成器函数的主体定义了它返回的每个生成器的蓝图：
- en: '[PRE70]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* A generator function is denoted with an asterisk.**'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 生成器函数用星号表示。**'
- en: '***2* The generator function is invoked without new.**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 生成器函数调用时不使用new。**'
- en: 'To denote that a function is a generator function, it’s defined with an asterisk.
    The asterisk can either be touching the name of the function like in the above
    example or touching the keyword `function`, such as `function* ...`. It seems
    like the latter is becoming more popular, although I like the former because it’s
    consistent with concise generator functions on object literals. Finally, the asterisk
    can also have spaces on both sides, such as `function * myFunction`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个函数是生成器函数，它用星号定义。星号可以像上面的例子那样紧挨着函数名，或者紧挨着关键字`function`，如`function* ...`。后者似乎越来越受欢迎，尽管我喜欢前者，因为它与对象字面量上的简洁生成器函数保持一致。最后，星号也可以在两边都有空格，如`function
    * myFunction`：
- en: '[PRE71]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* A concise generator method on an object literal**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对象字面量上的简洁生成器方法**'
- en: 'The code inside the generator function behaves like a regular function with
    a single, albeit huge caveat: *yielding*. There’s a new keyword in JavaScript
    only to be used inside of a generator function: `yield`. This `yield` creates
    a two-way communication channel between the inside and outside of the function.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数内部的代码行为就像一个常规函数，尽管有一个巨大的前提：*yielding*。JavaScript中有一个新关键字，仅用于生成器函数内部：`yield`。这个`yield`在函数内部和外部之间创建了一个双向通信通道。
- en: 'Whenever a `yield` is encountered, the execution of the function halts, returning
    control back to the external code that invoked the function. The `yield` can also
    pass along a value to the outside process, similar to the `return` statement:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 每当遇到`yield`时，函数的执行会暂停，将控制权返回到调用函数的外部代码。`yield`还可以将值传递给外部进程，类似于`return`语句：
- en: '[PRE72]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* The execution will halt here and return the value Hello to the containing
    process.**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 执行将在这里暂停，并将值“Hello”返回给包含进程。**'
- en: 'Unlike the `return` statement, `yield` is actually an expression that can capture
    a value to be used later in the function:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 与`return`语句不同，`yield`实际上是一个表达式，可以捕获一个值以供函数稍后使用：
- en: '[PRE73]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Capturing a value from the containing process**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从包含进程捕获值**'
- en: This detail is important because it’s unlike anything else in JavaScript. When
    that `yield` occurs, the body of the function isn’t short-circuited, as happens
    when you `return` a value. Instead it halts, returns an object with `value` and
    `done` properties, then waits for the containing process to tell it to continue.
    At this time, the containing process may pass a value back in, which you capture
    here as the response. This is the two-way communication channel that generator
    functions create. See [figure 18.1](kindle_split_029_split_001.xhtml#ch18fig01).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这个细节很重要，因为它在JavaScript中是独一无二的。当发生`yield`时，函数体不会像`return`返回值时那样短路，而是暂停，返回一个带有`value`和`done`属性的对象，然后等待包含进程告诉它继续。此时，包含进程可能会传递一个值回来，你在这里捕获它作为响应。这是生成器函数创建的双向通信通道。见[图18.1](kindle_split_029_split_001.xhtml#ch18fig01)。
- en: 'If you’re confused, that’s OK: you need to understand how generators work from
    both the inside of the function and the external process before you can really
    begin to understand them. So far we’ve only talked about the internal behavior,
    which won’t make sense until contrasted with the external behavior. We’ll go over
    this next.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到困惑，那没关系：在真正开始理解它们之前，你需要从函数内部和外部进程两个方面理解生成器的工作方式。到目前为止，我们只讨论了内部行为，这只有在与外部行为对比时才有意义。我们将在下一节中讨论这一点。
- en: Figure 18.1\. A two-way communication channel
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.1. 双向通信通道
- en: '![](Images/18fig01_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/18fig01_alt.jpg)'
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 18.1**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查18.1**'
- en: '**[Q1:](kindle_split_029_split_001.xhtml#ch18qa2q0a1)**'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_029_split_001.xhtml#ch18qa2q0a1)**'
- en: ''
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which generator function declaration is using the correct syntax?
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个生成器函数声明使用了正确的语法？
- en: ''
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|  |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 18.1 answer**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.1 答案**'
- en: '**[A1:](kindle_split_029_split_001.xhtml#ch18qa1q1)**'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_029_split_001.xhtml#ch18qa1q1)**'
- en: ''
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They are all valid.
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们都是有效的。
- en: '|  |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 18.2\. Using generator functions
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2. 使用生成器函数
- en: 'When you invoke a generator function, you get back a new generator object.
    This generator object begins in a halted state and doesn’t do anything until you
    call `next()` on it, which instructs it to start executing the code in the body
    of the generator function:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个生成器函数时，你会得到一个新的生成器对象。这个生成器对象开始处于暂停状态，直到你调用它上的`next()`，这会指示它开始执行生成器函数体内的代码：
- en: '[PRE75]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* The log isn’t evaluated here.**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这里的日志没有被评估。**'
- en: '***2* The log isn’t evaluated here, either.**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这里的日志也没有被评估。**'
- en: '***3* Only now is the log evaluated.**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 现在才评估日志。**'
- en: 'If the generator function body encounters a `yield`, it will halt again and
    won’t continue until you call `next()` again on the generator object:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成器函数体遇到`yield`，它将再次暂停，并且不会继续，直到你在生成器对象上再次调用`next()`：
- en: '[PRE76]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* The first log now occurs and then the generator halts again at the yield.**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 现在发生第一条日志，然后生成器再次在`yield`处暂停。**'
- en: '***2* The second log now occurs.**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在发生第二条日志。**'
- en: 'Every time you call `next()`, you get back an object with two properties: a
    `value` property that contains any value that was yielded and a `done` property
    that indicates whether the generator is halted or finished. See the following
    listing and [figure 18.2](kindle_split_029_split_002.xhtml#ch18fig02).'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `next()` 时，你都会得到一个包含两个属性的对象：一个包含任何已产生值的 `value` 属性和一个指示生成器是否暂停或完成的 `done`
    属性。请参阅以下列表和 [图 18.2](kindle_split_029_split_002.xhtml#ch18fig02)。
- en: Listing 18.1\. A generator function in action
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.1\. 生成器函数的实际应用
- en: '[PRE77]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Started**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Started**'
- en: '***2* gotA: { value: “a”, done: false }**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* gotA: { value: “a”, done: false }**'
- en: '***3* receivedA: 1**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* receivedA: 1**'
- en: '***4* gotB: { value: “b”, done: false }**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* gotB: { value: “b”, done: false }**'
- en: '***5* receivedB: 2**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* receivedB: 2**'
- en: '***6* gotC { value: undefined, done: true }**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* gotC { value: undefined, done: true }**'
- en: Figure 18.2\. Generator function execution order
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.2\. 生成器函数执行顺序
- en: '![](Images/18fig02_alt.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/18fig02_alt.jpg)'
- en: Notice how the final object returned from the generator has `done` set to `true`
    and `value` set to `undefined`. `done` being true means that this generator has
    reached the end of its function and has no more code to execute. This can be used
    by code that’s trying to process the generator to determine when to stop calling
    `next()` on it. The only time the `value` property will have anything other than
    `undefined` when done is if the generator actually `return`ed (not yielded) a
    value at the end.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到生成器返回的最后一个对象将 `done` 设置为 `true`，将 `value` 设置为 `undefined`。`done` 为 `true`
    表示此生成器已到达其函数的末尾，没有更多的代码要执行。这可以由尝试处理生成器的代码用来确定何时停止对其调用 `next()`。只有当生成器在末尾实际 `return`（而不是
    `yield`）了一个值时，`value` 属性才会包含除 `undefined` 之外的内容。
- en: 'Conversely, notice how the `0` passed in to the initial `next()` was never
    used. This is because the first `next()` isn’t tied to a `yield` like all thereafter
    are. The first `next()` is what starts the generator from its initially halted
    state. If you do need to pass an initial value, you can do so using regular function
    parameters:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，请注意传递给初始 `next()` 的 `0` 从未被使用。这是因为第一个 `next()` 并不像之后的 `next()` 那样与 `yield`
    相关联。第一个 `next()` 是从其初始暂停状态启动生成器的。如果你确实需要传递一个初始值，你可以使用常规函数参数来这样做：
- en: '[PRE78]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: OK, that was a lot to grasp. Feel free to read through this section again or
    play with your own generator functions until it clicks. I don’t expect you to
    understand why or when you would use a generator function yet. You just had to
    get through all this completely new functionality before you could dive into some
    useful applications.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有很多东西需要理解。请随意再次阅读本节或玩自己的生成器函数，直到你理解为止。我不期望你理解为什么或何时会使用生成器函数。你只是必须完全理解所有这些全新的功能，然后你才能深入研究一些有用的应用。
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.2**'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.2**'
- en: '**[Q1:](kindle_split_029_split_002.xhtml#ch18qa4q0a1)**'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_029_split_002.xhtml#ch18qa4q0a1)**'
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a generator function that yields two different values before completing.
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个生成器函数，在完成前产生两个不同的值。
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.2 answer**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.2 answer**'
- en: '**[A1:](kindle_split_029_split_002.xhtml#ch18qa3q1)**'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_029_split_002.xhtml#ch18qa3q1)**'
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.3\. Creating infinite lists with generator functions
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3\. 使用生成器函数创建无限列表
- en: Some languages like Haskell allow for the creation of infinite lists because
    they are lazy evaluated. This means that technically the list contains infinite
    values, but each value is only allocated to memory when it’s requested. JavaScript,
    on the other hand, is eagerly evaluated. So if you tried to make an array with
    infinite values, it would attempt to add them all to memory until it ran out of
    memory. You can easily simulate this, though, with generator functions. Simulate
    an infinite list from 0 to infinity, as shown in the next listing.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如 Haskell，允许创建无限列表，因为它们是惰性求值的。这意味着从技术上讲，列表包含无限个值，但每个值只有在请求时才会分配到内存中。另一方面，JavaScript
    是急切求值的。所以如果你尝试创建一个包含无限值的数组，它将尝试将它们全部添加到内存中，直到耗尽内存。不过，你可以通过生成器函数轻松地模拟这一点。如下所示，模拟从
    0 到无穷大的无限列表。
- en: Listing 18.2\. Generating an infinite list with a generator function
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.2\. 使用生成器函数生成无限列表
- en: '[PRE80]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Logs 0**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Logs 0**'
- en: '***2* Logs 1**'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Logs 1**'
- en: '***3* Logs 2**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Logs 2**'
- en: As you continue to call `next()`, you get the next value from your infinite
    list. Also notice how you used a `while(true)` that you never stop. If this were
    a regular function, this would create an infinite loop and crash. However, since
    it encounters a `yield` each time, it halts and only yields a single value at
    a time. So you’re now lazily evaluating only the items that are requested.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续调用 `next()` 时，你会从你的无限列表中获取下一个值。同时注意你使用了 `while(true)` 而不会停止。如果这是一个常规函数，这将创建一个无限循环并崩溃。然而，由于每次都会遇到一个
    `yield`，它会停止并一次只产生一个值。所以你现在只是懒加载请求的项目。
- en: 'Define a small helper function to assist in taking values from your infinite
    lists:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个小的辅助函数来帮助你从无限列表中取值：
- en: '[PRE81]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* [0, 1, 2, 3, 4, 5, 6]**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [0, 1, 2, 3, 4, 5, 6]**'
- en: OK, now you’ll make a more interesting infinite list of numbers. The Fibonacci
    sequence begins with the numbers zero and one, and is defined by each integer
    being the sum of the previous two integers in the sequence. So if you start with
    `0` and `1`, it continues with `1`, `2`, `3`, `5`, `8` and so on, as shown in
    the next listing.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你将创建一个更有趣的无限数字列表。斐波那契序列以数字0和1开始，由序列中每个整数是前两个整数的和来定义。所以如果你从 `0` 和 `1` 开始，它将继续以
    `1`，`2`，`3`，`5`，`8` 等等，如下一列表所示。
- en: Listing 18.3\. Generating a Fibonacci sequence
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.3\. 生成斐波那契序列
- en: '[PRE82]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* First grab a reference to the unchanged next value.**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首先获取未更改的next值的引用。**'
- en: '***2* Add the unchanged prev value to next.**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将未更改的prev值加到next上。**'
- en: '***3* Finally, update prev to your tmp value.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 最后，将prev更新为你的tmp值。**'
- en: '***4* [1, 1, 2, 3, 5, 8, 13]**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* [1, 1, 2, 3, 5, 8, 13]**'
- en: 'Awesome! However, you can use array destructuring to update your `prev` and
    `next` values without having to rely on an intermediate `tmp` value:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！然而，你可以使用数组解构来更新你的 `prev` 和 `next` 值，而无需依赖于中间的 `tmp` 值：
- en: '[PRE83]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Hopefully by now you can see how easy it is to create a list with a generator.
    This is no accident, and you’ll soon discover why in [unit 5](kindle_split_035.xhtml#part05),
    which covers iteration.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，你可以看到使用生成器创建列表是多么容易。这不是偶然，你很快就会在 [单元5](kindle_split_035.xhtml#part05)
    中发现原因，该单元涵盖了迭代。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.3**'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查18.3**'
- en: '**[Q1:](kindle_split_029_split_003.xhtml#ch18qa6q0a1)**'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_029_split_003.xhtml#ch18qa6q0a1)**'
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement a generator function that creates an infinite list of all the natural
    odd numbers.
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现一个生成器函数，创建无限的自然奇数列表。
- en: '|  |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.3 answer**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.3 答案**'
- en: '**[A1:](kindle_split_029_split_003.xhtml#ch18qa5q1)**'
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_029_split_003.xhtml#ch18qa5q1)**'
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: This lesson presented a gentle introduction to the syntax and lifecycle of generator
    functions.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 本课介绍了生成器函数的语法和生命周期。
- en: A generator function is defined with a asterisk.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数用星号定义。
- en: A generator function returns a generator object.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数返回一个生成器对象。
- en: A generator can yield values with the `yield` keyword.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器可以使用 `yield` 关键字产生值。
- en: A generator pauses at each `yield` until told to continue by calling `next()`.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器在每个 `yield` 处暂停，直到通过调用 `next()` 来告诉它继续。
- en: You can pass values back to a generator as arguments to `next()`.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将值作为 `next()` 的参数传递给生成器。
- en: 'Let’s see if you got this:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q18.1](kindle_split_050_split_013.xhtml#app01qa13q0a1)**'
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q18.1](kindle_split_050_split_013.xhtml#app01qa13q0a1)**'
- en: ''
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a generator for an infinite list of dates. The first time `next()` is
    called, it should yield the current day. Each subsequent call should yield the
    next day. Alternatively, you could make the generator function accept an argument
    that tells it what date to start at and only default to the current day.
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个生成器，用于无限日期列表。第一次调用 `next()` 时，应该产生当前日期。后续的每次调用应该产生下一天。或者，你可以让生成器函数接受一个参数，告诉它从哪一天开始，默认为当前日期。
- en: 'Lesson 19\. Capstone: The prisoner’s dilemma'
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19课\. 核心课程：囚徒困境
- en: Let’s pretend you’ve been given the honor of organizing a hack-a-thon—a programming
    competition where competitors are given a coding challenge they’re expected to
    solve.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假装你被赋予了组织黑客马拉松的荣誉——这是一个编程竞赛，参赛者会被给予一个他们预期要解决的编码挑战。
- en: 'Being the lover of game theory that you are, you decide to use the prisoner’s
    dilemma as the challenge for the hack-a-thon. How did I know you are a lover of
    game theory, you ask? Ahem, *who isn’t?* But on the off chance that you’re not,
    I’ll explain the prisoner’s dilemma. Two prisoners are interrogated in separate
    rooms, each asked to snitch on the other prisoner. Exactly what happens when each
    prisoner snitches on the other changes depending on who tells the story, but the
    basic idea is this. The best outcome for both prisoners is if neither snitches
    on each other. If one snitches on the other, it’s good for the one who snitched
    but bad for the one getting snitched on. If they both snitch on each other, it’s
    bad for both, but less severe than being the only one getting snitched on. For
    the purpose of the hack-a-thon, you decide the outcomes are as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位游戏理论的爱好者，你决定使用囚犯困境作为黑客马拉松的挑战。你怎么知道你是一位游戏理论的爱好者呢？嗯，*谁不是呢？*但万一你不是，我会解释囚犯困境。两个囚犯被分别关在不同的房间里审问，每人被要求告密另一个囚犯。每个囚犯告密对方时发生的情况会根据讲述故事的人而变化，但基本想法是这样的。对两个囚犯来说最好的结果是他们都不告密。如果一个人告密了另一个人，这对告密者是有利的，但对被告密者是不利的。如果他们都告密了对方，这对双方都不好，但比只有一个人被告密的情况要轻。为了黑客马拉松，你决定结果如下：
- en: If both prisoners snitch, they each serve one year.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个囚犯都告密，他们每人将服刑一年。
- en: If only one prisoner snitches, that prisoner goes free and the other serves
    two years.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个囚犯告密，那么这个囚犯将被释放，而另一个囚犯将服刑两年。
- en: If neither prisoner snitches, they both go free.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个囚犯都没有告密，他们都将被释放。
- en: You’ll explain to each contestant that they need to program a prisoner that
    gets the fewest total years in prison after being pitted against the other contestants’
    prisoners. You decide that this is a great hack-a-thon problem because it doesn’t
    rely on subjective grading, but on a metric that no one can argue with.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 你将向每个参赛者解释，他们需要编写一个囚犯程序，该程序在与其他参赛者的囚犯对抗后，在监狱中的总刑期最少。你认为这是一个很好的黑客马拉松问题，因为它不依赖于主观评分，而是一个无人可以争论的指标。
- en: You want to do a proof of concept before the hack-a-thon to get an idea of the
    results you might see, so you need to
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在黑客马拉松之前做一个概念验证，以了解你可能会看到的结果，所以你需要
- en: 'Figure out the Prisoner API: what the interface of the individual prisoner
    looks like'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解囚犯API：单个囚犯界面的样子
- en: 'Figure out the Prisoner Factory API: what the interface for *generating* a
    prisoner looks like'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解囚犯工厂API：生成囚犯的接口是什么样的
- en: Build a couple of different prisoner factories to battle
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立几个不同的囚犯工厂进行对抗
- en: Build a simulation that takes two prisoners, compares their actions, and keeps
    score
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一个模拟，该模拟接受两个囚犯，比较他们的行为，并记录分数
- en: Build a way to present the scores at the end
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一种方式来展示最后的分数
- en: 19.1\. Generating prisoners
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1. 生成囚犯
- en: In order to run each prisoner through a simulation, each contestant’s submission
    would have to implement a common interface that all will adhere to. You need an
    interface for generating prisoners; you’ll call this the Prisoner Factory API.
    The Prisoner Factory API will produce prisoner objects. You need to figure out
    the interface of each prisoner as well. You’ll call this simply the Prisoner API.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行每个囚犯的模拟，每个参赛者的提交必须实现一个所有参赛者都将遵守的通用接口。你需要一个用于生成囚犯的接口；你将称之为囚犯工厂API。囚犯工厂API将生成囚犯对象。你还需要确定每个囚犯的接口。你将简单地称之为囚犯API。
- en: 'The Prisoner API is going to be really simple: it just needs a method called
    `snitch` that returns `true` or `false` indicating whether or not the prisoner
    snitched. You’ll also add another method called `sentencedTo` to each prisoner
    that will allow you to dole out a prison sentence to the prisoner. This won’t
    be a part of the API that you ask the contestants to build, though, because you
    don’t want the contestants handling the prison sentencing.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 囚犯API将会非常简单：只需要一个名为`snitch`的方法，该方法返回`true`或`false`，表示囚犯是否告密。你还会为每个囚犯添加另一个名为`sentencedTo`的方法，这将允许你为囚犯分配监狱刑期。不过，这不会是要求参赛者构建API的一部分，因为你不想让参赛者处理监狱判决。
- en: The Prisoner Factory API is a little more complicated because it should always
    generate a new prisoner for you to interrogate, but it needs to be able to allow
    the prisoners that are generated to adapt in real time. To do this, every time
    you request a prisoner from the factory, you’ll provide the factory with stats
    of how well they’ve done so far. The stats will be an array of numbers indicating
    the number of years each of the previous prisoners has been sentenced to. If there
    was no jail time served, it would be a 0\. This will allow the factories to adapt
    in real time, altering the prisoner they produce if they’re doing well or poorly.
    This means that for each interrogation, you’ll need to pass data (their stats)
    to the factory before getting back another prisoner object. For this two-way communication
    it makes sense to use a generator, since the generator can yield prisoners to
    your simulation and your simulation can pass back statistics (see [figure 19.1](kindle_split_030_split_001.xhtml#ch19fig01)).
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 犯人工厂API稍微复杂一些，因为它应该始终为你生成一个新的犯人进行审问，但它需要能够允许生成的犯人在实时中适应。为此，每次你从工厂请求犯人时，你将向工厂提供他们到目前为止的表现统计数据。这些统计数据将是一个数字数组，表示每个之前犯人被判刑的年数。如果没有服刑，则为0。这将允许工厂实时适应，根据表现的好坏调整他们产生的犯人。这意味着对于每次审问，你需要在得到另一个犯人对象之前向工厂传递数据（他们的统计数据）。对于这种双向通信，使用生成器是有意义的，因为生成器可以向你的模拟产生犯人，而你的模拟可以传递回统计数据（参见[图19.1](kindle_split_030_split_001.xhtml#ch19fig01)）。
- en: Figure 19.1\. Prisoner lifecycle
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.1\. 犯人生命周期
- en: '![](Images/19fig01.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/19fig01.jpg)'
- en: 'Define a generator that yields a prisoner:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个生成器，它产生一个犯人：
- en: '[PRE85]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This prisoner generator always yields a new prisoner. The prisoner is an object
    with a `snitch` method. The contestants won’t know how many times their submission
    is going to be run through the simulator, so it makes sense for this generator
    to yield an unlimited number of prisoners by using the never-ending `for(;;)`
    loop. You could test this out like so:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 这个犯人生成器始终产生一个新的犯人。犯人是一个具有`snitch`方法的对象。参赛者不知道他们的提交将要在模拟器中运行多少次，所以这个生成器通过使用永无止境的`for(;;)`循环来产生无限数量的犯人是有意义的。你可以这样测试：
- en: '[PRE86]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* true**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* true**'
- en: 'It appears this is a prisoner that always snitches. But you still need to pass
    the previous outcomes back. If you pass back an array of all the previous outcomes
    every time you call `next`, the prisoner generator can capture these when it yields
    like so:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这是一个总是告密的犯人。但你仍然需要传递之前的结果。每次调用`next`时，如果你传递回一个包含所有之前结果的数组，犯人生成器可以在它产生时捕获这些结果，如下所示：
- en: '[PRE87]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* The first prisoner yielded wouldn’t have any stats yet, so you default
    stats to an empty array.**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第一个产生的犯人还没有任何统计数据，所以你将默认统计数据设置为空数组。**'
- en: '***2* After each prisoner is yielded, you get back the stats from all previous
    outcomes.**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在每个犯人产生后，你会得到所有之前结果的数据。**'
- en: 'Now before yielding a prisoner, the code can take a look at the previous outcomes
    and use this information to guide its decision on whether or not to snitch. Of
    course, this always-snitching prisoner isn’t making use of these stats; you’re
    going to change that. Make a prisoner who snitches if they recently had to serve
    jail time, but who otherwise doesn’t snitch:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在产生犯人之前，代码可以查看之前的结果，并使用这些信息来指导其决定是否告密。当然，这个总是告密的犯人并没有利用这些统计数据；你将要改变这一点。创建一个犯人，如果他们最近服过刑，就会告密，否则不会告密：
- en: '[PRE88]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* If the prisoner went to jail last time, snitch; otherwise don’t.**'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果犯人上次去过监狱，就告密；否则不要。**'
- en: 'The final piece of the Prisoner Factory API is a way for the contestants to
    name their submission. This way your simulation can tell you which prisoner has
    won the contest. To achieve this, you decide that each Prisoner Factory should
    be an object with a `name` property and a `generator` property. So the previous
    example would be changed as shown it the next listing:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 犯人工厂API的最后一部分是让参赛者命名他们的提交。这样你的模拟就可以告诉你哪个犯人赢得了比赛。为了实现这一点，你决定每个犯人工厂都应该是一个具有`name`属性和`generator`属性的对象。所以之前的例子将按照下面的列表进行修改：
- en: Listing 19.1\. A Prisoner Factory with name and generator
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.1\. 带有名称和生成器的犯人工厂
- en: '[PRE89]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 19.2\. Getting prisoners to interact
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2\. 让犯人互动
- en: That about wraps up the Prisoner and Prisoner Factory APIs that each contestant
    needs to use to build their entry. Now you need a way to pit each prisoner against
    every other prisoner in an interrogation and see which one gets the least amount
    of prison time. To do this, define an `interrogate` function that takes two prisoners,
    asks each to snitch, and then doles out prison sentences, as shown in the following
    listing.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了每个参赛者需要使用的囚犯和囚犯工厂 API 来构建他们的参赛作品。现在您需要一种方法来将每个囚犯与其他囚犯进行审讯，并查看哪个囚犯获得的刑期最少。为此，定义一个
    `interrogate` 函数，该函数接受两个囚犯，要求每个囚犯告密，然后根据预定义的规则分配刑期，如下所示。
- en: Listing 19.2\. `interrogate` function pits two prisoners against each other
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.2\. `interrogate` 函数将两个囚犯置于对立面
- en: '[PRE90]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* They both snitched; each gets one year.**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 他们都告密了；每人一年。**'
- en: '***2* Only criminal snitched; they go free while accomplice gets two years.**'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 只有罪犯告密；他们获释，而同谋被判两年。**'
- en: '***3* Only accomplice snitched; they go free while criminal gets two years.**'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 只有同谋告密；他们获释，而罪犯被判两年。**'
- en: '***4* Neither snitched; they both go free.**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 都没有告密；他们都获释。**'
- en: This `interrogate` function takes two prisoners, asks each to snitch, and then
    doles out prison sentences according to the predefined rules. Notice that you’re
    now calling the `sentencedTo` method on each prisoner. Remember you didn’t want
    the contestants implementing this method themselves to spare them the urge to
    cheat, so you’ll need to add that method to each prisoner yourself.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `interrogate` 函数接受两个囚犯，要求每个囚犯告密，然后根据预定义的规则分配刑期。请注意，您现在正在对每个囚犯调用 `sentencedTo`
    方法。记住，您不希望参赛者自己实现此方法，以避免他们作弊的冲动，因此您需要自己将此方法添加到每个囚犯身上。
- en: 19.3\. Getting and storing the results
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3\. 获取和存储结果
- en: 'In order to attach your `sentencedTo` to each prisoner, you’ll write your own
    generator function that takes the Prisoner Factory as a parameter, internally
    grabs prisoners from the factory’s generator, and yields them after adding your
    `sentencedTo` method:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的 `sentencedTo` 方法附加到每个囚犯身上，您需要编写自己的生成器函数，该函数接受囚犯工厂作为参数，从工厂的生成器中内部获取囚犯，并在添加您的
    `sentencedTo` 方法后产出它们：
- en: '[PRE91]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* You can grab the name and generator directly with parameter destructuring.**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 您可以直接通过参数解构获取名称和生成器。**'
- en: '***2* The stats array will keep track of previous outcomes**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 统计数组将跟踪之前的成果**'
- en: '***3* By calling .slice you pass a copy.**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过调用 .slice，您传递了一个副本。**'
- en: '***4* Add the sentencedTo method to a copy of the prisoner.**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 sentencedTo 方法添加到囚犯的副本中。**'
- en: '***5* When the prisoner is sentenced, add it to your stats.**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当囚犯被判刑时，将其添加到您的统计数据中。**'
- en: '***6* Wrap your previous retaliate factory in your getPrisoners generator.**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将您之前的报复工厂包裹在您的 getPrisoners 生成器中。**'
- en: '***7* Grab prisoners just like before.**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 就像以前一样获取囚犯。**'
- en: '***8* The produced prisoners now have a sentencedTo method.**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 产生的囚犯现在有了 sentencedTo 方法。**'
- en: This function wraps the contestants’ code and yields each contestant’s prisoner
    after adding the needed `sentencedTo` method. The `sentencedTo` method adds the
    outcome (or sentence) to an array keeping track of all the outcomes. These are
    the stats that get passed back to the prisoners generator, allowing it to adapt.
    You call `stats.slice()` when passing them back to the contestant’s code. This
    makes a copy to make sure the contestant’s code cannot alter your statistics.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数封装了参赛者的代码，在添加所需的 `sentencedTo` 方法后，产出每个参赛者的囚犯。`sentencedTo` 方法将结果（或判决）添加到跟踪所有结果的数组中。这些是传递回囚犯生成器的统计数据，允许其适应。您在将它们传递回参赛者的代码时调用
    `stats.slice()`。这会创建一个副本，以确保参赛者的代码无法更改您的统计数据。
- en: Your simulation needs to be able to get the statistics and the name back from
    this function as well. That’s tricky because this function is yielding the prisoner
    every time you call `next`. You could make it yield the `name`, `stats`, and `prisoner`
    every single time, but that’s unnecessary as you really only need the name and
    stats once you’re done asking for prisoners. So when you’re done asking for prisoners,
    you can pass `true` in your last `next` invocation, indicating that you’re finished.
    That can tell the `getPrisoners` generator that you no longer want prisoners,
    and instead would like the stats and name of the prisoner you were testing, as
    shown in the next listing.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模拟需要能够从这个函数中获取统计数据和名称。这很棘手，因为这个函数每次调用`next`时都会产生囚犯。你可以让它每次都产生`name`、`stats`和`prisoner`，但这是不必要的，因为你一旦完成对囚犯的询问，实际上只需要名称和统计数据。所以当你完成对囚犯的询问时，你可以在最后的`next`调用中传递`true`，表示你已经完成。这可以告诉`getPrisoners`生成器你不再需要囚犯，而是希望得到你正在测试的囚犯的统计数据和名称，如下所示。
- en: Listing 19.3\. Getting stats and prisoner name from the generator
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.3. 从生成器获取统计数据和囚犯名称
- en: '[PRE92]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* A finished flag is captured after each yield.**'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每次yield后捕获一个完成标志。**'
- en: '***2* Break out of the for loop once finished.**'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 完成后跳出for循环。**'
- en: '***3* The final value will be the name and stats.**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 最终值将是名称和统计数据。**'
- en: 19.4\. Putting the simulation together
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4. 组合模拟
- en: Now you need to write a `test` function that actually does the simulation of
    taking the contestants’ prisoners and interrogating them against each other, as
    the next listing shows.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要编写一个`test`函数，实际上是对参赛者的囚犯进行模拟，将他们相互审问，如下所示。
- en: Listing 19.4\. Putting it all together
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.4. 组合所有内容
- en: '[PRE93]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* Use rest to get any number of prisoners to test.**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用休息时间让任意数量的囚犯进行测试。**'
- en: '***2* Map each prisoner with the getPrisoner wrapper.**'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用getPrisoner包装器映射每个囚犯。**'
- en: '***3* Break out of the loop after testing each prisoner against every other.**'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在测试每个囚犯与其他每个囚犯对抗后跳出循环。**'
- en: '***4* Get the final values and return them.**'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取最终值并返回。**'
- en: This `test` function uses rest to allow any number of contestants’ prisoners
    to be tested. By `pop`ing each prisoner out of the array and testing them against
    all the prisoners remaining in the array, you ensure that you test every prisoner
    against every other prisoner. You then push that prisoner onto a `tested` array
    so you can return the results at the end. Quickly define some other prisoners
    so you can test them against each other, as shown in the following listing.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`test`函数使用rest来允许测试任意数量的参赛者囚犯。通过`pop`每个囚犯出数组并测试他们与数组中剩余的所有囚犯对抗，你确保了测试每个囚犯与其他每个囚犯对抗。然后你将那个囚犯推入一个`tested`数组，以便你可以在最后返回结果。快速定义一些其他囚犯，以便你可以测试它们之间的对抗，如下所示。
- en: Listing 19.5\. Defining more prisoners
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.5. 定义更多囚犯
- en: '[PRE94]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now you have three other prisoners to pit against your retaliation prisoner:
    a `never` prisoner that never snitches, an `always` prisoner that always snitches,
    and a `rand` prisoner that randomly snitches. Lets see how they do against each
    other:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有三个其他囚犯来对抗你的报复囚犯：一个“永不”告密囚犯，一个“总是”告密囚犯，以及一个“随机”告密囚犯。让我们看看他们之间是如何对抗的：
- en: '[PRE95]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* [Object, Object, Object, Object]**'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [对象，对象，对象，对象]**'
- en: 19.5\. Which prisoner does best?
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5. 哪个囚犯表现最好？
- en: 'Woohoo! You successfully tested your prisoner entries (hopefully). But it was
    rather hard reading the results in their current format. Currently you get back
    an array of objects; each object has a name property array of all the results
    (each result being a number of years sentenced). It would be much easier to read
    if the result were a single object with the names of each prisoner type as keys
    and the sum of all the years sentenced as values. Write a helper function to convert
    your results into that format:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！你成功测试了你的囚犯输入（希望如此）。但是，以当前格式阅读结果相当困难。目前你得到的是一个对象数组；每个对象都有一个名为`name`的属性，包含所有结果（每个结果都是一个判决的年数）。如果结果是一个包含每个囚犯类型名称作为键和所有判决年数总和作为值的单个对象，那就容易阅读得多。编写一个辅助函数将你的结果转换为该格式：
- en: '[PRE96]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* Assign the property as the prisoner name using a computed property name.**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用计算属性名称将属性分配为囚犯名称。**'
- en: 'This `getScore` function takes the last yielded value from a prisoner, sums
    the total years, and returns an object with the prisoner name as the property
    and the sum as the value. You’ll need to update the `test` function to map each
    result into the `getScore` function to format it:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`getScore`函数从囚犯那里获取最后产生的值，计算总年数，并返回一个对象，其中囚犯名字作为属性，总和作为值。你需要更新`test`函数，将每个结果映射到`getScore`函数以进行格式化：
- en: '[PRE97]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run your test again:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的测试：
- en: '[PRE98]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* {random: 2, always: 0, never: 6, retaliate: 2}**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {random: 2, always: 0, never: 6, retaliate: 2}**'
- en: 'So far it looks like it pays to always snitch. But you can enhance your simulator
    by making each prisoner get interrogated by every other prisoner for 50 times
    instead of just once. And you’ll also make each prisoner get pitted against themself.
    First define a quick helper function to execute a callback 50 times:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，看起来总是告密是有利的。但你可以通过让每个囚犯被其他每个囚犯审问50次而不是一次来增强你的模拟器。你还将让每个囚犯与自身对抗。首先定义一个快速的帮助函数来执行回调50次：
- en: '[PRE99]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Finally, update the `test` function to make your final changes, as shown in
    the following listing.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`test`函数以进行最终更改，如下所示。
- en: Listing 19.6\. Interrogating the prisoners 50 times
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.6\. 对囚犯进行50次审问
- en: '[PRE100]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1* Your changes**'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你的更改**'
- en: 'Now you’re testing each prisoner against every other prisoner for 50 times,
    including testing against themselves. Run test one final time:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在对每个囚犯进行50次与其他囚犯的测试，包括自我测试。最后一次运行测试：
- en: '[PRE101]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1* {random: 187, always: 177, never: 156, retaliate: 90}**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {random: 187, always: 177, never: 156, retaliate: 90}**'
- en: Now it’s looking much better to retaliate. It makes sense that the only prisoner
    who made use of the stats ended up being the one with the best solution.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看来，报复似乎是个不错的选择。只有利用了统计数据的囚犯最终得到了最好的解决方案，这是有道理的。
- en: Summary
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this capstone you created a Prisoner’s Dilemma simulation runner. The point
    of the runner was to allow contests to program their own prisoner simulations,
    to see what kind of prisoner fares best in the prisoner dilemma scenario. You
    only made a few simple prisoner simulations; you could easily take this further
    by writing a more thoughtful prisoner simulation and see how well it does against
    the prisoner simulations you wrote in this capstone.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你创建了一个囚犯困境模拟运行器。运行器的作用是允许竞赛者编写自己的囚犯模拟程序，以查看哪种囚犯在囚犯困境场景中表现最好。你只编写了几个简单的囚犯模拟；你可以通过编写一个更深思熟虑的囚犯模拟来进一步扩展，看看它在你在这个项目中编写的囚犯模拟中的表现如何。
