- en: 'Chapter 9\. Testing microservices: Part 1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章。测试微服务：第1部分
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Effective testing strategies for microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的有效测试策略
- en: Using mocks and stubs to test a software element in isolation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟和存根来单独测试软件元素
- en: Using the test pyramid to determine where to focus testing efforts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试金字塔来确定测试努力的焦点
- en: Unit testing the classes inside a service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务内部对类进行单元测试
- en: 'FTGO, like many organizations, had adopted a traditional approach to testing.
    *Testing* is primarily an activity that happens after development. The FTGO developers
    throw their code over a wall to the QA team, who verify that the software works
    as expected. What’s more, most of their testing is done manually. Sadly, this
    approach to testing is broken—for two reasons:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO，像许多组织一样，已经采用了一种传统的测试方法。**测试**主要是在开发之后进行的活动。FTGO的开发者将他们的代码扔给QA团队，由他们验证软件是否按预期工作。更重要的是，他们的大部分测试都是手动进行的。遗憾的是，这种测试方法是有缺陷的——有两个原因：
- en: '***Manual testing is extremely inefficient*—** You should never ask a human
    to do what a machine can do better. Compared to machines, humans are slow and
    can’t work 24/7. You won’t be able to deliver software rapidly and safely if you
    rely on manual testing. It’s essential that you write automated tests.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动测试效率极低**—**你永远不应该要求人类去做机器能做得更好的事情。与机器相比，人类速度慢，不能24/7工作。如果你依赖手动测试，你将无法快速且安全地交付软件。编写自动化测试是至关重要的。**'
- en: '***Testing is done far too late in the delivery process*—** There certainly
    is a role for tests that critique an application after it’s been written, but
    experience has shown that those tests are insufficient. A much better approach
    is for developers to write automated tests as part of development. It improves
    their productivity because, for example, they’ll have tests that provide immediate
    feedback while editing code.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试在交付过程中的进行时间太晚**—**当然，在应用程序编写完成后对应用程序进行批评性测试是有其作用的，但经验表明，这些测试是不够的。一个更好的方法是让开发者将自动化测试作为开发的一部分来编写。这提高了他们的生产力，因为例如，他们会有在编辑代码时提供即时反馈的测试。**'
- en: In this regard, FTGO is a fairly typical organization. The Sauce Labs Testing
    Trends in 2018 report paints a fairly gloomy picture of the state of test automation
    ([https://saucelabs.com/resources/white-papers/testing-trends-for-2018](https://saucelabs.com/resources/white-papers/testing-trends-for-2018)).
    It describes how only 26% of organizations are mostly automated, and a minuscule
    3% are fully automated!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，FTGO是一个相当典型的组织。《Sauce Labs 2018年测试趋势报告》描绘了一个相当黯淡的测试自动化状态图景([https://saucelabs.com/resources/white-papers/testing-trends-for-2018](https://saucelabs.com/resources/white-papers/testing-trends-for-2018))。它描述了只有26%的组织大部分是自动化的，而仅有微乎其微的3%是完全自动化的！
- en: 'The reliance on manual testing isn’t because of a lack of tooling and frameworks.
    For example, JUnit, a popular Java testing framework, was first released in 1998\.
    The reason for the lack of automated tests is mostly cultural: “Testing is QA’s
    job,” “It’s not the best use of a developers’s time,” and so on. It also doesn’t
    help that developing a fast-running, yet effective, maintainable test suite is
    challenging. And, a typical large, monolithic application is extremely difficult
    to test.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对手动测试的依赖并不是因为缺乏工具和框架。例如，JUnit，一个流行的Java测试框架，最早在1998年发布。缺乏自动化测试的原因主要是文化上的：“测试是QA的工作”，“这不是开发者时间最好的使用方式”，等等。开发一个快速运行、有效且可维护的测试套件也是一个挑战。此外，一个典型的大型、单体应用程序非常难以测试。
- en: One key motivation for using the microservice architecture is, as described
    in [chapter 2](kindle_split_010.xhtml#ch02), improving testability. Yet at the
    same time, the complexity of the microservice architecture demands that you write
    automated tests. Furthermore, some aspects of testing microservices are challenging.
    That’s because we need to verify that services can interact correctly while minimizing
    the number of slow, complex, and unreliable end-to-end-tests that launch many
    services.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构的一个关键动机，如第2章所述，是提高可测试性。然而，同时，微服务架构的复杂性要求你编写自动化测试。此外，测试微服务的一些方面具有挑战性。这是因为我们需要验证服务可以正确交互，同时最大限度地减少启动许多服务的缓慢、复杂和不可靠的全链路测试的数量。
- en: This chapter is the first of two chapters on testing. It’s an introduction to
    testing. [Chapter 10](kindle_split_018.xhtml#ch10) covers more advanced testing
    concepts. The two chapters are long, but together they cover testing ideas and
    techniques that are essential to modern software development in general, and to
    the microservice architecture in particular.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于测试的两章中的第一章。它是测试的介绍。[第10章](kindle_split_018.xhtml#ch10)涵盖了更高级的测试概念。这两章篇幅较长，但结合起来，它们涵盖了现代软件开发中至关重要的测试思想和技巧，特别是针对微服务架构。
- en: 'I begin this chapter by describing effective testing strategies for a microservices-based
    application. These strategies enable you to be confident that your software works,
    while minimizing test complexity and execution time. After that, I describe how
    to write one particular kind of test for your services: unit tests. [Chapter 10](kindle_split_018.xhtml#ch10)
    covers the other kinds of tests: integration, component, and end-to-end.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章的开头描述了针对基于微服务应用程序的有效测试策略。这些策略使你能够确信你的软件是有效的，同时最大限度地减少测试复杂性和执行时间。之后，我描述了如何为你的服务编写一种特定的测试：单元测试。[第10章](kindle_split_018.xhtml#ch10)涵盖了其他类型的测试：集成、组件和端到端。
- en: Let’s start by taking a look at testing strategies for microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看微服务的测试策略开始。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Why an introduction to testing?**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么要介绍测试？**'
- en: You may be wondering why this chapter includes an introduction to basic testing
    concepts. If you’re already familiar with concepts such as the test pyramid and
    the different types of tests, feel free to speed-read this chapter and move onto
    the next one, which focuses on microservices-specific testing topics. But based
    on my experiences consulting for and training clients all over the world, a fundamental
    weakness of many software development organizations is the lack of automated testing.
    That’s because if you want to deliver software quickly and reliably, it’s *absolutely
    essential* to do automated testing. It’s the only way to have a short *lead time*,
    which is the time it takes to get committed code into production. Perhaps even
    more importantly, automated testing is essential because it forces you to develop
    a testable application. It’s typically very difficult to introduce automating
    testing into an already large, complex application. In other words, the fast track
    to monolithic hell is to not write automated tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么本章包括基本测试概念的介绍。如果你已经熟悉测试金字塔和不同类型的测试等概念，你可以快速阅读本章，然后继续阅读下一章，该章节专注于微服务特定的测试主题。但根据我为全球各地的客户咨询和培训的经验，许多软件开发组织的根本弱点是缺乏自动化测试。这是因为如果你想要快速且可靠地交付软件，进行自动化测试是**绝对必要的**。这是唯一能够缩短**前置时间**的方法，即把提交的代码放入生产所需的时间。也许更重要的是，自动化测试是必要的，因为它迫使你开发一个可测试的应用程序。通常，将自动化测试引入已经很大、很复杂的应用程序是非常困难的。换句话说，不编写自动化测试是通往单体地狱的快速途径。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.1\. Testing strategies for microservice architectures
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 微服务架构的测试策略
- en: Let’s say you’ve made a change to FTGO application’s `Order Service`. Naturally,
    the next step is for you to run your code and verify that the change works correctly.
    One option is to test the change manually. First, you run `Order Service` and
    all its dependencies, which include infrastructure services such as a database
    and other application services. Then you “test” the service by either invoking
    its API or using the FTGO application’s UI. The downside of this approach is that
    it’s a slow, manual way to test your code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你对FTGO应用程序的`Order Service`进行了更改。自然地，下一步是你运行你的代码并验证更改是否正确。一个选择是手动测试这个更改。首先，你运行`Order
    Service`及其所有依赖项，包括数据库和其他应用程序服务这样的基础设施服务。然后，通过调用其API或使用FTGO应用程序的用户界面来“测试”该服务。这种方法的不利之处在于，它是一种缓慢且手动的方式来测试你的代码。
- en: 'A much better option is to have automated tests that you can run during development.
    Your development workflow should be: edit code, run tests (ideally with a single
    keystroke), repeat. The fast-running tests quickly tell you whether your changes
    work within a few seconds. But how do you write fast-running tests? And are they
    sufficient or do you need more comprehensive tests? These are the kind of questions
    I answer in this and other sections in this chapter.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择是拥有可以在开发过程中运行的自动化测试。你的开发工作流程应该是：编辑代码，运行测试（理想情况下只需按一个键），重复。快速运行的测试可以在几秒钟内快速告诉你你的更改是否有效。但是，你该如何编写快速运行的测试？它们是否足够，或者你需要更全面的测试？这些问题就是我在这章和其他章节中回答的问题。
- en: I start this section with an overview of important automated testing concepts.
    We’ll look at the purpose of testing and the structure of a typical test. I cover
    the different types of tests that you’ll need to write. I also describe the test
    pyramid, which provides valuable guidance about where you should focus your testing
    efforts. After covering testing concepts, I discuss strategies for testing microservices.
    We’ll look at the distinct challenges of testing applications that have a microservice
    architecture. I describe techniques you can use to write simpler and faster, yet
    still-effective, tests for your microservices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我从这个部分开始，先概述一些重要的自动化测试概念。我们将探讨测试的目的和典型测试的结构。我涵盖了你需要编写的不同类型的测试。我还描述了测试金字塔，它提供了关于你应该在哪里集中测试努力的宝贵指导。在介绍测试概念之后，我将讨论测试微服务的策略。我们将探讨具有微服务架构的应用程序的独特挑战。我描述了你可以使用的技巧来编写更简单、更快，但仍然有效的微服务测试。
- en: Let’s take a look at testing concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看测试概念。
- en: 9.1.1\. Overview of testing
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 测试概述
- en: 'In this chapter, my focus is on automated testing, and I use the term *test*
    as shorthand for *automated test*. Wikipedia defines a *test case*, or test, as
    follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我的重点是自动化测试，我使用术语*测试*作为*自动化测试*的简称。维基百科将*测试用例*或测试定义为如下：
- en: '*A test case is a set of test inputs, execution conditions, and expected results
    developed for a particular objective, such as to exercise a particular program
    path or to verify compliance with a specific requirement.*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*测试用例是为特定目标开发的测试输入、执行条件和预期结果的一组，例如，为了执行特定的程序路径或验证符合特定的要求。*'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[https://en.wikipedia.org/wiki/Test_case](https://en.wikipedia.org/wiki/Test_case)*'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[https://en.wikipedia.org/wiki/Test_case](https://en.wikipedia.org/wiki/Test_case)*'
- en: In other words, the purpose of a test is, as [figure 9.1](#ch09fig01) shows,
    to verify the behavior of the System Under Test (SUT). In this definition, *system*
    is a fancy term that means the software element being tested. It might be something
    as small as a class, as large as the entire application, or something in between,
    such as a cluster of classes or an individual service. A collection of related
    tests form a *test suite*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，测试的目的，如图9.1所示，是验证被测系统（SUT）的行为。在这个定义中，*系统*是一个术语，意味着正在测试的软件元素。它可能小到是一个类，大到是整个应用程序，或者介于两者之间，例如类簇或单个服务。相关测试的集合形成一个*测试套件*。
- en: Figure 9.1\. The goal of a test is to verify the behavior of the system under
    test. An SUT might be as small as a class or as large as an entire application.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. 测试的目标是验证被测系统的行为。SUT（系统单元）可能小到是一个类，也可能大到是一个完整的应用程序。
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: Let’s first look at the concept of an automated test. Then I discuss the different
    kinds of tests that you’ll need to write. After that, I discuss the test pyramid,
    which describes the relative proportions of the different types of tests that
    you should write.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看自动化测试的概念。然后我将讨论你需要编写的不同类型的测试。之后，我将讨论测试金字塔，它描述了你应该编写的不同类型测试的相对比例。
- en: Writing automated tests
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写自动化测试
- en: Automated tests are usually written using a testing framework. JUnit, for example,
    is a popular Java testing framework. [Figure 9.2](#ch09fig02) shows the structure
    of an automated test. Each test is implemented by a test method, which belongs
    to a test class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试通常使用测试框架编写。例如，JUnit是一个流行的Java测试框架。[图9.2](#ch09fig02)显示了自动化测试的结构。每个测试都由一个属于测试类的测试方法实现。
- en: 'Figure 9.2\. Each automated test is implemented by a test method, which belongs
    to a test class. A test consists of four phases: *setup*, which initializes the
    test fixture, which is everything required to run the test; *execute*, which invokes
    the SUT; *verify*, which verifies the outcome of the test; and *teardown*, which
    cleans up the test fixture.'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2. 每个自动化测试都由一个属于测试类的测试方法实现。一个测试包括四个阶段：*设置*，初始化测试固定装置，这是运行测试所需的一切；*执行*，调用SUT；*验证*，验证测试的结果；以及*清理*，清理测试固定装置。
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig02_alt.jpg)'
- en: 'An automated test typically consists of four phases ([http://xunitpatterns.com/Four%20Phase%20Test.html](http://xunitpatterns.com/Four%20Phase%20Test.html)):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试通常由四个阶段组成([http://xunitpatterns.com/Four%20Phase%20Test.html](http://xunitpatterns.com/Four%20Phase%20Test.html))：
- en: '***Setup*—** Initialize the test fixture, which consists of the SUT and its
    dependencies, to the desired initial state. For example, create the class under
    test and initialize it to the state required for it to exhibit the desired behavior.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***设置*—** 初始化测试固定装置，该装置由SUT及其依赖项组成，到所需的初始状态。例如，创建正在测试的类并将其初始化到它需要展示所需行为的状态。'
- en: '***Exercise*—** Invoke the SUT—for example, invoke a method on the class under
    test.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***执行*—** 调用SUT——例如，在正在测试的类上调用一个方法。'
- en: '***Verify*—** Make assertions about the invocation’s outcome and the state
    of the SUT. For example, verify the method’s return value and the new state of
    the class under test.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***验证*—** 对调用的结果和SUT的状态进行断言。例如，验证方法的返回值和正在测试的类的新的状态。'
- en: '***Teardown*—** Clean up the test fixture, if necessary. Many tests omit this
    phase, but some types of database test will, for example, roll back a transaction
    initiated by the setup phase.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***清理*—** 如果需要，清理测试固定装置。许多测试省略了这个阶段，但某些类型的数据库测试，例如，会回滚由设置阶段启动的事务。'
- en: In order to reduce code duplication and simplify tests, a test class might have
    setup methods that are run before a test method, and teardown methods that are
    run afterwards. A test *suite* is a set of test classes. The tests are executed
    by a *test runner*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少代码重复并简化测试，测试类可能包含在测试方法之前运行的设置方法，以及在之后运行的清理方法。测试**套件**是一组测试类。测试由**测试运行器**执行。
- en: Testing using mocks and stubs
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用模拟和存根进行测试
- en: An SUT often has dependencies. The trouble with dependencies is that they can
    complicate and slow down tests. For example, the `OrderController` class invokes
    `OrderService`, which ultimately depends on numerous other application services
    and infrastructure services. It wouldn’t be practical to test the `OrderController`
    class by running a large portion of the system. We need a way to test an SUT in
    isolation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SUT通常有依赖项。依赖项的问题在于它们可能会使测试复杂化并减慢测试速度。例如，`OrderController`类调用`OrderService`，这最终依赖于许多其他应用程序服务和基础设施服务。通过运行系统的大部分内容来测试`OrderController`类并不实用。我们需要一种方法来单独测试SUT。
- en: The solution, as [figure 9.3](#ch09fig03) shows, is to replace the SUT’s dependencies
    with test doubles. A *test double* is an object that simulates the behavior of
    the dependency.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图9.3](#ch09fig03)所示，解决方案是用测试替身替换SUT的依赖项。测试替身是一个模拟依赖项行为的对象。
- en: Figure 9.3\. Replacing a dependency with a test double enables the SUT to be
    tested in isolation. The test is simpler and faster.
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3。用测试替身替换依赖项使得可以单独测试SUT。测试更简单，更快。
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3](Images/09fig03_alt.jpg)'
- en: 'There are two types of test doubles: stubs and mocks. The terms *stubs* and
    *mocks* are often used interchangeably, although they have slightly different
    behavior. A *stub* is a test double that returns values to the SUT. A *mock* is
    a test double that a test uses to verify that the SUT correctly invokes a dependency.
    Also, a mock is often a stub.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的测试替身：存根和模拟。术语*存根*和*模拟*通常可以互换使用，尽管它们的行为略有不同。存根是一个向SUT返回值的测试替身。模拟是一个测试使用的测试替身，用于验证SUT是否正确调用了依赖项。此外，模拟通常也是一个存根。
- en: Later on in this chapter, you’ll see examples of test doubles in action. For
    example, [section 9.2.5](#ch09lev2sec8) shows how to test the `OrderController`
    class in isolation by using a test double for the `OrderService` class. In that
    example, the `OrderService` test double is implemented using Mockito, a popular
    mock object framework for Java. [Chapter 10](kindle_split_018.xhtml#ch10) shows
    how to test `Order Service` using test doubles for the other services that it
    invokes. Those test doubles respond to command messages sent by `Order Service`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，您将看到测试替身在实际中的应用示例。例如，[第9.2.5节](#ch09lev2sec8)展示了如何通过使用`OrderService`类的测试替身来单独测试`OrderController`类。在那个例子中，`OrderService`测试替身是使用Mockito实现的，Mockito是一个流行的Java模拟对象框架。[第10章](kindle_split_018.xhtml#ch10)展示了如何使用测试替身测试`Order
    Service`，这些测试替身响应由`Order Service`发送的命令消息。
- en: Let’s now look at the different types of tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看不同的测试类型。
- en: The different types of tests
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试的不同类型
- en: 'There are many different types of tests. Some tests, such as performance tests
    and usability tests, verify that the application satisfies its quality of service
    requirements. In this chapter, I focus on automated tests that verify the functional
    aspects of the application or service. I describe how to write four different
    types of tests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多不同类型的测试。一些测试，如性能测试和可用性测试，验证应用程序是否满足其服务质量要求。在本章中，我专注于验证应用程序或服务功能方面的自动化测试。我描述了如何编写四种不同类型的测试：
- en: '***Unit tests*—** Test a small part of a service, such as a class.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单元测试***—**测试服务的一个小部分，例如一个类。'
- en: '***Integration tests*—** Verify that a service can interact with infrastructure
    services such as databases and other application services.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***集成测试***—**验证服务能否与基础设施服务（如数据库和其他应用程序服务）交互。'
- en: '***Component tests*—** Acceptance tests for an individual service.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组件测试***—**对单个服务的验收测试。'
- en: '***End-to-end tests*—** Acceptance tests for the entire application.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***端到端测试***—**对整个应用程序的验收测试。'
- en: They differ primarily in scope. At one end of the spectrum are unit tests, which
    verify behavior of the smallest meaningful program element. For an object-oriented
    language such as Java, that’s a class. At the other end of the spectrum are end-to-end
    tests, which verify the behavior of an entire application. In the middle are component
    tests, which test individual services. Integration tests, as you’ll see in the
    next chapter, have a relatively small scope, but they’re more complex than pure
    unit tests. Scope is only one way of characterizing tests. Another way is to use
    the test quadrant.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在范围上主要有所不同。在光谱的一端是单元测试，它验证最小有意义的程序元素的行为。对于像Java这样的面向对象语言来说，这相当于一个类。在光谱的另一端是端到端测试，它验证整个应用程序的行为。在中间是组件测试，它测试单个服务。在第10章中，您将看到集成测试的范围相对较小，但它们比纯单元测试更复杂。范围只是描述测试的一种方式。另一种方式是使用测试象限。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Compile-time unit tests**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译时单元测试**'
- en: Testing is an integral part of development. The modern development workflow
    is to edit code, then run tests. Moreover, if you’re a Test-Driven Development
    (TDD) practitioner, you develop a new feature or fix a bug by first writing a
    failing test and then writing the code to make it pass. Even if you’re not a TDD
    adherent, an excellent way to fix a bug is to write a test that reproduces the
    bug and then write the code that fixes it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发的一个组成部分。现代开发工作流程是先编辑代码，然后运行测试。此外，如果您是测试驱动开发（TDD）的实践者，您将首先编写一个失败的测试，然后编写代码使其通过，以此来开发新功能或修复错误。即使您不是TDD的忠实信徒，编写一个可以重现错误的测试，然后编写修复它的代码，也是一个修复错误的绝佳方法。
- en: The tests that you run as part of this workflow are known as *compile-time*
    tests. In a modern IDE, such as IntelliJ IDEA or Eclipse, you typically don’t
    compile your code as a separate step. Rather, you use a single keystroke to compile
    the code and run the tests. In order to stay in the flow, these tests need to
    execute quickly—ideally, no more than a few seconds.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此工作流程一部分运行的测试被称为*编译时*测试。在现代IDE，如IntelliJ IDEA或Eclipse中，您通常不会将代码作为单独的步骤进行编译。相反，您使用单个按键来编译代码并运行测试。为了保持流程，这些测试需要快速执行——理想情况下，不超过几秒钟。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using the test quadrant to categorize tests
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用测试象限对测试进行分类
- en: 'A good way to categorize tests is Brian Marick’s *test quadrant* ([www.exampler.com/old-blog/2003/08/21/#agile-testing-project-1](http://www.exampler.com/old-blog/2003/08/21/#agile-testing-project-1)).
    The test quadrant, shown in [figure 9.4](#ch09fig04), categorizes tests along
    two dimensions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对测试进行分类的好方法是布赖恩·马里克（Brian Marick）的*测试象限*（[www.exampler.com/old-blog/2003/08/21/#agile-testing-project-1](http://www.exampler.com/old-blog/2003/08/21/#agile-testing-project-1)）。测试象限，如图9.4所示，沿两个维度对测试进行分类：
- en: '***Whether the test is business facing or technology facing*—** A business-facing
    test is described using the terminology of a domain expert, whereas a technology-facing
    test is described using the terminology of developers and the implementation.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***测试是面向业务还是面向技术***—**面向业务的测试使用领域专家的术语进行描述，而面向技术的测试使用开发者和实现的术语进行描述。'
- en: '***Whether the goal of the test is to support programming or critique the application*—**
    Developers use tests that support programming as part of their daily work. Tests
    that critique the application aim to identify areas that need improvement.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***测试的目标是支持编程还是批评应用程序***—**开发者将支持编程的测试作为他们日常工作的一部分。批评应用程序的测试旨在识别需要改进的领域。'
- en: Figure 9.4\. The test quadrant categorizes tests along two dimensions. The first
    dimension is whether a test is business facing or technology facing. The second
    is whether the purpose of the test is to support programming or critique the application.
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4。测试象限根据两个维度对测试进行分类。第一个维度是测试是否面向业务或技术。第二个维度是测试的目的是支持编程还是评估应用程序。
- en: '![](Images/09fig04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04.jpg)'
- en: 'The test quadrant defines four different categories of tests:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试象限定义了四种不同的测试类别：
- en: '***Q1*—** Support programming/technology facing: unit and integration tests'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Q1*—** 支持面向编程/技术：单元和集成测试'
- en: '***Q2*—** Support programming/business facing: component and end-to-end test'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Q2*—** 支持面向编程/业务：组件和端到端测试'
- en: '***Q3*—** Critique application/business facing: usability and exploratory testing'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Q3*—** 评估面向应用/业务的：可用性和探索性测试'
- en: '***Q4*—** Critique application/technology facing: nonfunctional acceptance
    tests such as performance tests'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Q4*—** 评估面向应用/技术的：非功能性验收测试，例如性能测试'
- en: The test quadrant isn’t the only way of organizing tests. There’s also the test
    pyramid, which provides guidance on how many tests of each type to write.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 测试象限并不是组织测试的唯一方式。还有测试金字塔，它提供了关于需要编写多少种类型测试的指导。
- en: Using the test pyramid as a guide to focusing your testing efforts
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用测试金字塔作为指导来集中测试努力
- en: We must write different kinds of tests in order to be confident that our application
    works. The challenge, though, is that the execution time and complexity of a test
    increase with its scope. Also, the larger the scope of a test and the more moving
    parts it has, the less reliable it becomes. Unreliable tests are almost as bad
    as no tests, because if you can’t trust a test, you’re likely to ignore failures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写不同类型的测试，以确保我们的应用程序能够正常工作。然而，挑战在于测试的执行时间和复杂性与其范围成正比。此外，测试的范围越大，包含的移动部件越多，其可靠性就越低。不可靠的测试几乎和没有测试一样糟糕，因为如果你不相信一个测试，你很可能会忽略失败。
- en: On one end of the spectrum are unit tests for individual classes. They’re fast
    to execute, easy to write, and reliable. At the other end of the spectrum are
    end-to-end tests for the entire application. These tend to be slow, difficult
    to write, and often unreliable because of their complexity. Because we don’t have
    unlimited budget for development and testing, we want to focus on writing tests
    that have small scope without compromising the effectiveness of the test suite.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的一端是对单个类的单元测试。它们执行速度快，编写简单，且可靠。在光谱的另一端是对整个应用程序的端到端测试。这些测试通常很慢，难以编写，并且由于它们的复杂性，往往不可靠。由于我们开发和测试的预算是有限的，我们希望专注于编写范围小且不损害测试套件有效性的测试。
- en: The test pyramid, shown in [figure 9.5](#ch09fig05), is a good guide ([https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)).
    At the base of the pyramid are the fast, simple, and reliable unit tests. At the
    top of the pyramid are the slow, complex, and brittle end-to-end tests. Like the
    USDA food pyramid, although more useful and less controversial ([https://en.wikipedia.org/wiki/History_of_USDA_nutrition_guides](https://en.wikipedia.org/wiki/History_of_USDA_nutrition_guides)),
    the test pyramid describes the relative proportions of each type of test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔，如图9.5所示，是一个很好的指导([https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html))。金字塔的底部是快速、简单且可靠的单元测试。金字塔的顶部是缓慢、复杂且易碎的端到端测试。就像美国农业部食物金字塔一样，尽管更有用且争议较少([https://en.wikipedia.org/wiki/History_of_USDA_nutrition_guides](https://en.wikipedia.org/wiki/History_of_USDA_nutrition_guides))，测试金字塔描述了每种类型测试的相对比例。
- en: Figure 9.5\. The test pyramid describes the relative proportions of each type
    of test that you need to write. As you move up the pyramid, you should write fewer
    and fewer tests.
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5。测试金字塔描述了需要编写的每种类型测试的相对比例。随着你向上移动金字塔，你应该编写越来越少的测试。
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig05_alt.jpg)'
- en: The key idea of the test pyramid is that as we move up the pyramid we should
    write fewer and fewer tests. We should write lots of unit tests and very few end-to-end
    tests. As you’ll see in this chapter, I describe a strategy that emphasizes testing
    the pieces of a service. It even minimizes the number of component tests, which
    test an entire service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔的关键思想是，随着我们向上移动金字塔，我们应该编写越来越少的测试。我们应该编写大量的单元测试和非常少的端到端测试。正如你将在本章中看到的，我描述了一种强调测试服务各个部分的策略。它甚至最小化了组件测试的数量，这些测试针对整个服务。
- en: It’s clear how to test individual microservices such as `Consumer Service`,
    which don’t depend on any other services. But what about services such as `Order
    Service`, that do depend on numerous other services? And how can we be confident
    that the application as a whole works? This is the key challenge of testing applications
    that have a microservice architecture. The complexity of testing has moved from
    the individual services to the interactions between them. Let’s look at how to
    tackle this problem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试像`消费者服务`这样的单个微服务相对简单，因为它们不依赖于任何其他服务。但对于像`订单服务`这样的服务，它依赖于众多其他服务，我们该如何确保整个应用程序能够正常工作呢？这是测试具有微服务架构的应用程序的关键挑战。测试的复杂性已经从单个服务转移到它们之间的交互。让我们看看如何解决这个问题。
- en: 9.1.2\. The challenge of testing microservices
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 测试微服务的挑战
- en: Interprocess communication plays a much more important role in a microservices-based
    application than in a monolithic application. A monolithic application might communicate
    with a few external clients and services. For example, the monolithic version
    of the FTGO application uses a few third-party web services, such as Stripe for
    payments, Twilio for messaging, and Amazon SES for email, which have stable APIs.
    Any interaction between the modules of the application is through programming
    language-based APIs. Interprocess communication is very much on the edge of the
    application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的应用程序中，进程间通信比在单体应用程序中扮演着更加重要的角色。单体应用程序可能只与少数外部客户端和服务进行通信。例如，FTGO应用程序的单体版本使用了一些第三方网络服务，如Stripe用于支付、Twilio用于消息传递和Amazon
    SES用于电子邮件，它们都有稳定的API。应用程序模块之间的任何交互都是通过基于编程语言的API进行的。进程间通信在应用程序的边缘非常明显。
- en: In contrast, interprocess communication is central to microservice architecture.
    A microservices-based application is a distributed system. Teams are constantly
    developing their services and evolving their APIs. It’s essential that developers
    of a service write tests that verify that their service interacts with its dependencies
    and clients.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，进程间通信在微服务架构中至关重要。基于微服务的应用程序是一个分布式系统。团队不断开发他们的服务并演进他们的API。确保服务开发者编写的测试能够验证他们的服务与其依赖项和客户端的交互是至关重要的。
- en: As described in [chapter 3](kindle_split_011.xhtml#ch03), services communicate
    with each other using a variety of interaction styles and IPC mechanisms. Some
    services use request/response-style interaction that’s implemented using a synchronous
    protocol, such as REST or gRPC. Other services interact through request/asynchronous
    reply or publish/subscribe using asynchronous messaging. For instance, [figure
    9.6](#ch09fig06) shows how some of the services in the FTGO application communicate.
    Each arrow points from a consumer service to a producer service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](kindle_split_011.xhtml#ch03)所述，服务之间使用各种交互样式和进程间通信（IPC）机制进行通信。一些服务使用基于请求/响应的交互，这种交互通过同步协议实现，例如REST或gRPC。其他服务通过请求/异步回复或发布/订阅使用异步消息进行交互。例如，[图9.6](#ch09fig06)展示了FTGO应用中的一些服务是如何进行交互的。每个箭头都指向从消费者服务到生产者服务的方向。
- en: Figure 9.6\. Some of the interservice communication in the FTGO application.
    Each arrow points from a consumer service to a producer service.
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. FTGO应用程序中的一些服务间通信。每个箭头都指向从消费者服务到生产者服务的方向。
- en: '![](Images/09fig06_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig06_alt.jpg)'
- en: 'The arrow points in the direction of the dependency, from the consumer of the
    API to the provider of the API. The assumptions that a consumer makes about an
    API depend on the nature of the interaction:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头指向依赖的方向，从API的消费者到API的提供者。消费者对API的假设取决于交互的性质：
- en: '*REST client* → *service*—The API gateway routes requests to services and implements
    API composition.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REST客户端* → *服务*—API网关路由请求到服务并实现API组合。'
- en: '*Domain event consumer* → *publisher*—`Order History Service` consumes events
    published by `Order Service`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域事件消费者* → *发布者*—`订单历史服务`消费由`订单服务`发布的事件。'
- en: '*Command message requestor* → *replier*—`Order Service` sends command messages
    to various services and consumes the replies.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令消息请求者* → *回复者*—`订单服务`向各种服务发送命令消息并消费回复。'
- en: Each interaction between a pair of services represents an agreement or contract
    between the two services. `Order History Service` and `Order Service` must, for
    example, agree on the event message structure and the channel that they’re published
    to. Similarly, the API gateway and the services must agree on the REST API endpoints.
    And `Order Service` and each service that it invokes using asynchronous request/response
    must agree on the command channel and the format of the command and reply messages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 两个服务之间的每次交互代表两个服务之间的协议或合同。例如，`Order History Service`和`Order Service`必须就事件消息结构和发布到的通道达成一致。同样，API网关和这些服务必须就REST
    API端点达成一致。`Order Service`和它使用异步请求/响应调用的每个服务必须就命令通道和命令及回复消息的格式达成一致。
- en: As a developer of a service, you need to be confident that the services you
    consume have stable APIs. Similarly, you don’t want to unintentionally make breaking
    changes to your service’s API. For example, if you’re working on `Order Service`,
    you want to be sure that the developers of your service’s dependencies, such as
    `Consumer Service` and `Kitchen Service`, don’t change their APIs in ways that
    are incompatible with your service. Similarly, you must ensure that you don’t
    change the `Order Services`’s API in a way that breaks the `API Gateway` or `Order
    History Service`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务开发者，你需要确信你消费的服务具有稳定的API。同样，你也不想无意中破坏你服务API的兼容性。例如，如果你正在开发`Order Service`，你想要确保你的服务依赖项（如`Consumer
    Service`和`Kitchen Service`）的开发者不会以与你的服务不兼容的方式更改他们的API。同样，你必须确保你不会以破坏`API Gateway`或`Order
    History Service`的方式更改`Order Services`的API。
- en: One way to verify that two services can interact is to run both services, invoke
    an API that triggers the communication, and verify that it has the expected outcome.
    This will certainly catch integration problems, but it’s basically an end-to-end.
    The test likely would need to run numerous other transitive dependencies of those
    services. A test might also need to invoke complex, high-level functionality such
    as business logic, even if its goal is to test relatively low-level IPC. It’s
    best to avoid writing end-to-end tests like these. Somehow, we need to write faster,
    simpler, and more reliable tests that ideally test services in isolation. The
    solution is to use what’s known as *consumer-driven contract testing*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 验证两个服务可以交互的一种方法是在运行这两个服务的情况下，调用一个触发通信的API，并验证它具有预期的结果。这肯定会捕获集成问题，但基本上是一个端到端测试。测试可能需要运行这些服务的许多其他传递依赖项。测试还可能需要调用复杂的高级功能，如业务逻辑，即使其目标是测试相对低级的IPC。最好避免编写这样的端到端测试。我们
    somehow需要编写更快、更简单、更可靠的测试，理想情况下是独立测试服务。解决方案是使用所谓的*消费者驱动的合同测试*。
- en: Consumer-driven contract testing
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 消费者驱动的合同测试
- en: Imagine that you’re a member of the team developing `API Gateway`, described
    in [chapter 8](kindle_split_016.xhtml#ch08). The `API Gateway`’s `OrderServiceProxy`
    invokes various REST endpoints, including the `GET /orders/{orderId}` endpoint.
    It’s essential that we write tests that verify that `API Gateway` and `Order Service`
    agree on an API. In the terminology of consumer contract testing, the two services
    participate in a *consumer-provider relationship*. `API Gateway` is a consumer,
    and `Order Service` is a provider. A consumer contract test is an integration
    test for a provider, such as `Order Service`, that verifies that its API matches
    the expectations of a consumer, such as `API Gateway`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是第8章中描述的`API Gateway`团队的一员。[第8章](kindle_split_016.xhtml#ch08)。`API Gateway`的`OrderServiceProxy`调用各种REST端点，包括`GET
    /orders/{orderId}`端点。我们编写测试以验证`API Gateway`和`Order Service`是否就API达成一致至关重要。在消费者合同测试的术语中，这两个服务参与一个*消费者-提供者关系*。`API
    Gateway`是消费者，而`Order Service`是提供者。消费者合同测试是对提供者（如`Order Service`）的集成测试，它验证其API是否符合消费者的期望，例如`API
    Gateway`。
- en: A consumer contract test focuses on verifying that the “shape” of a provider’s
    API meets the consumer’s expectations. For a REST endpoint, a contract test verifies
    that the provider implements an endpoint that
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者合同测试专注于验证提供者API的“形状”是否符合消费者的期望。对于一个REST端点，合同测试验证提供者实现了一个端点，该端点
- en: Has the expected HTTP method and path
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有预期的HTTP方法和路径
- en: Accepts the expected headers, if any
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，接受预期的头信息
- en: Accepts a request body, if any
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，接受请求正文
- en: Returns a response with the expected status code, headers, and body
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回包含预期状态码、头信息和正文的响应
- en: It’s important to remember that contract tests don’t thoroughly test the provider’s
    business logic. That’s the job of unit tests. Later on, you’ll see that consumer
    contract tests for a REST API are in fact mock controller tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，合同测试并不彻底测试提供者的业务逻辑。这是单元测试的工作。稍后，您将看到消费者合同测试实际上是模拟控制器测试。
- en: The team that develops the consumer writes a contract test suite and adds it
    (for example, via a pull request) to the provider’s test suite. The developers
    of other services that invoke `Order Service` also contribute a test suite, as
    shown in [figure 9.7](#ch09fig07). Each test suite will test those aspects of
    `Order Service`’s API that are relevant to each consumer. The test suite for `Order
    History Service`, for example, verifies that `Order Service` publishes the expected
    events.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 开发消费者产品的团队编写一个合同测试套件，并将其（例如，通过拉取请求）添加到提供者的测试套件中。调用`Order Service`的其他服务的开发者也会贡献一个测试套件，如图9.7所示。每个测试套件将测试`Order
    Service` API与每个消费者相关的方面。例如，`Order History Service`的测试套件会验证`Order Service`是否发布了预期的事件。
- en: Figure 9.7\. Each team that develops a service that consumes `Order Service`’s
    API contributes a contract test suite. The test suite verifies that the API matches
    the consumer’s expectations. This test suite, along with those contributed by
    other teams, is run by `Order Service`’s deployment pipeline.
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7。每个开发消费`Order Service` API服务的团队贡献一个合同测试套件。该测试套件验证API是否符合消费者的期望。这个测试套件，以及其他团队贡献的测试套件，由`Order
    Service`的部署管道运行。
- en: '![](Images/09fig07_alt.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig07_alt.jpg)'
- en: These test suites are executed by the deployment pipeline for `Order Service`.
    If a consumer contract test fails, that failure tells the producer team that they’ve
    made a breaking change to the API. They must either fix the API or talk to the
    consumer team.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试套件由`Order Service`的部署管道执行。如果消费者合同测试失败，则该失败会告知生产团队他们对API进行了破坏性更改。他们必须修复API或与消费者团队沟通。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Consumer-driven contract test**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：消费者驱动的合同测试**'
- en: Verify that a service meets the expectations of its clients See [http://microservices.io/patterns/testing/service-integration-contract-test.html](http://microservices.io/patterns/testing/service-integration-contract-test.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 验证服务是否满足其客户端的期望，请参阅[http://microservices.io/patterns/testing/service-integration-contract-test.html](http://microservices.io/patterns/testing/service-integration-contract-test.html)。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Consumer-driven contract tests typically use testing by example. The interaction
    between a consumer and provider is defined by a set of examples, known as contracts.
    Each *contract* consists of example messages that are exchanged during one interaction.
    For instance, a contract for a REST API consists of an example HTTP request and
    response. On the surface, it may seem better to define the interaction using schemas
    written using, for example, OpenAPI or JSON schema. But it turns out schemas aren’t
    that useful when writing tests. A test can validate the response using the schema
    but it still needs to invoke the provider with an example request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者驱动的合同测试通常使用示例测试。消费者和提供者之间的交互由一组示例定义，称为合同。每个*合同*包含在一次交互过程中交换的示例消息。例如，一个REST
    API的合同包含一个示例HTTP请求和响应。表面上，使用例如OpenAPI或JSON schema编写的模式来定义交互可能看起来更好。但事实证明，当编写测试时，模式并不那么有用。测试可以使用模式验证响应，但仍需要使用示例请求调用提供者。
- en: What’s more, consumer tests also need example responses. That’s because even
    though the focus of consumer-driven contract testing is to test a provider, contracts
    are also used to verify that the consumer conforms to the contract. For instance,
    a consumer-side contract test for a REST client uses the contract to configure
    an HTTP stub service that verifies that the HTTP request matches the contract’s
    request and sends back the contract’s HTTP response. Testing both sides of interaction
    ensures that the consumer and provider agree on the API. Later on we’ll look at
    examples of how to write this kind of testing, but first let’s see how to write
    consumer contract tests using Spring Cloud Contract.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，消费者测试还需要示例响应。这是因为尽管消费者驱动的合同测试的重点是测试提供者，但合同也用于验证消费者是否符合合同。例如，一个REST客户端的消费者端合同测试使用合同配置一个HTTP存根服务，该服务验证HTTP请求是否与合同的请求匹配，并发回合同的HTTP响应。测试交互的双方确保消费者和提供者对API达成一致。稍后我们将探讨如何编写此类测试的示例，但首先让我们看看如何使用Spring
    Cloud Contract编写消费者合同测试。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Consumer-side contract test**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：消费者端合同测试**'
- en: Verify that the client of a service can communicate with the service. See [https://microservices.io/patterns/testing/consumer-side-contract-test.html](https://microservices.io/patterns/testing/consumer-side-contract-test.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 验证服务客户端能否与该服务通信。请参阅 [https://microservices.io/patterns/testing/consumer-side-contract-test.html](https://microservices.io/patterns/testing/consumer-side-contract-test.html)。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Testing services using Spring Cloud Contract
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Contract 测试服务
- en: Two popular contract testing frameworks are Spring Cloud Contract ([https://cloud.spring.io/spring-cloud-contract/](https://cloud.spring.io/spring-cloud-contract/)),
    which is a consumer contract testing framework for Spring applications, and the
    Pact family of frameworks ([https://github.com/pact-foundation](https://github.com/pact-foundation)),
    which support a variety of languages. The FTGO application is a Spring framework-based
    application, so in this chapter I’m going to describe how to use Spring Cloud
    Contract. It provides a Groovy domain-specific language (DSL) for writing contracts.
    Each contract is a concrete example of an interaction between a consumer and a
    provider, such as an HTTP request and response. Spring Cloud Contract code generates
    contract tests for the provider. It also configures mocks, such as a mock HTTP
    server, for consumer integration tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 两个流行的合同测试框架是 Spring Cloud Contract ([https://cloud.spring.io/spring-cloud-contract/](https://cloud.spring.io/spring-cloud-contract/))，这是一个针对
    Spring 应用的消费者合同测试框架，以及 Pact 框架家族([https://github.com/pact-foundation](https://github.com/pact-foundation))，它支持多种语言。FTGO
    应用程序是一个基于 Spring 框架的应用程序，因此在本章中，我将介绍如何使用 Spring Cloud Contract。它提供了一种 Groovy 领域特定语言
    (DSL) 用于编写合同。每个合同都是一个消费者和提供者之间交互的具体示例，例如 HTTP 请求和响应。Spring Cloud Contract 代码为提供者生成合同测试。它还配置了模拟，例如模拟
    HTTP 服务器，用于消费者集成测试。
- en: 'Say, for example, you’re working on `API Gateway` and want to write a consumer
    contract test for `Order Service`. [Figure 9.8](#ch09fig08) shows the process,
    which requires you to collaborate with `Order Service` teams. You write contracts
    that define how `API Gateway` interacts with `Order Service`. The `Order Service`
    team uses these contracts to test `Order Service`, and you use them to test `API
    Gateway`. The sequence of steps is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在处理 `API Gateway` 并想为 `Order Service` 编写一个消费者合同测试。![图 9.8](#ch09fig08) 显示了此过程，需要您与
    `Order Service` 团队协作。您编写定义 `API Gateway` 如何与 `Order Service` 交互的合同。`Order Service`
    团队使用这些合同来测试 `Order Service`，而您使用它们来测试 `API Gateway`。步骤顺序如下：
- en: You write one or more contracts, such as the one shown in [listing 9.1](#ch09ex01).
    Each contract consists of an HTTP request that `API Gateway` might send to `Order
    Service` and an expected HTTP response. You give the contracts, perhaps via a
    Git pull request, to the `Order Service` team.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您编写一个或多个合同，例如 [列表 9.1](#ch09ex01) 中所示。每个合同由 `API Gateway` 可能发送给 `Order Service`
    的 HTTP 请求和预期的 HTTP 响应组成。您通过 Git pull 请求等方式将这些合同提供给 `Order Service` 团队。
- en: The `Order Service` team tests `Order Service` using consumer contract tests,
    which Spring Cloud Contract code generates from contracts.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service` 团队使用消费者合同测试来测试 `Order Service`，这些测试由 Spring Cloud Contract
    代码从合同生成。'
- en: Figure 9.8\. The `API Gateway` team writes the contracts. The `Order Service`
    team uses those contracts to test `Order Service` and publishes them to a repository.
    The `API Gateway` team uses the published contracts to test `API Gateway`.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. `API Gateway` 团队编写合同。`Order Service` 团队使用这些合同来测试 `Order Service` 并将它们发布到存储库。`API
    Gateway` 团队使用发布的合同来测试 `API Gateway`。
- en: '![](Images/09fig08_alt.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/09fig08_alt.jpg)'
- en: The `Order Service` team publishes the contracts that tested `Order Service`
    to a Maven repository.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service` 团队将测试 `Order Service` 的合同发布到 Maven 存储库。'
- en: You use the published contracts to write tests for `API Gateway`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用发布的合同来编写 `API Gateway` 的测试。
- en: Because you test `API Gateway` using the published contracts, you can be confident
    that it works with the deployed `Order Service`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您使用发布的合同测试 `API Gateway`，您可以确信它与已部署的 `Order Service` 兼容。
- en: The contracts are the key part of this testing strategy. The following listing
    shows an example Spring Cloud Contract. It consists of an HTTP request and an
    HTTP response.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 合同是这个测试策略的关键部分。以下列表显示了一个示例 Spring Cloud Contract。它由一个 HTTP 请求和一个 HTTP 响应组成。
- en: Listing 9.1\. A contract that describes how `API Gateway` invokes `Order Service`
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 描述 `API Gateway` 如何调用 `Order Service` 的合同
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* The HTTP request’s method and path**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* HTTP 请求的方法和路径**'
- en: '***2* The HTTP response’s status code, headers, and body**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* HTTP 响应的状态码、头和正文**'
- en: The request element is an HTTP request for the REST endpoint `GET /orders/{orderId}`.
    The response element is an HTTP response that describes an `Order` expected by
    `API Gateway`. The Groovy contracts are part of the provider’s code base. Each
    consumer team writes contracts that describe how their service interacts with
    the provider and gives them, perhaps via a Git pull request, to the provider team.
    The provider team is responsible for packaging the contracts as a JAR and publishing
    them to a Maven repository. The consumer-side tests download the JAR from the
    repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请求元素是对REST端点`GET /orders/{orderId}`的HTTP请求。响应元素是描述`API Gateway`期望的`Order`的HTTP响应。Groovy合同是提供者代码库的一部分。每个消费者团队编写合同来描述他们的服务如何与提供者交互，并通过Git拉取请求，可能提供给提供者团队。提供者团队负责将合同打包成JAR文件，并发布到Maven仓库。消费者端测试从仓库下载JAR文件。
- en: Each contract’s request and response play dual roles of test data and the specification
    of expected behavior. In a consumer-side test, the contract is used to configure
    a stub, which is similar to a Mockito mock object and simulates the behavior of
    `Order Service`. It enables `API Gateway` to be tested without running `Order
    Service`. In the provider-side test, the generated test class invokes the provider
    with the contract’s request and verifies that it returns a response that matches
    the contract’s response. The next chapter discusses the details of how to use
    Spring Cloud Contract, but now we’re going to look at how to use consumer contract
    testing for messaging APIs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合同的请求和响应都扮演着测试数据和预期行为规范的双重角色。在消费者端测试中，合同被用来配置一个存根，这类似于Mockito模拟对象，并模拟`Order
    Service`的行为。它使得可以在不运行`Order Service`的情况下测试`API Gateway`。在提供者端测试中，生成的测试类使用合同的请求调用提供者，并验证它返回的响应与合同的响应相匹配。下一章将讨论如何使用Spring
    Cloud Contract的详细情况，但现在我们将看看如何使用消费者合同测试来测试消息API。
- en: Consumer contract tests for messaging APIs
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 消息API的消费者合同测试
- en: A REST client isn’t the only kind of consumer that has expectations of a provider’s
    API. Services that subscribe to domain events and use asynchronous request/response-based
    communication are also consumers. They consume some other service’s messaging
    API, and make assumptions about the nature of that API. We must also write consumer
    contract tests for these services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: REST客户端并不是唯一对提供者API有期望的消费者类型。订阅领域事件并使用基于异步请求/响应通信的服务也是消费者。它们消费其他服务的消息API，并对该API的性质做出假设。我们也必须为这些服务编写消费者合同测试。
- en: Spring Cloud Contract also provides support for testing messaging-based interactions.
    The structure of a contract and how it’s used by the tests depend on the type
    of interaction. A contract for domain event publishing consists of an example
    domain event. A provider test causes the provider to emit an event and verifies
    that it matches the contract’s event. A consumer test verifies that the consumer
    can handle that event. In the next chapter, I describe an example test.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Contract还提供了对基于消息交互的测试支持。合同的结构和测试如何使用它取决于交互的类型。领域事件发布的合同由一个示例领域事件组成。提供者测试导致提供者发出事件，并验证它是否与合同的事件匹配。消费者测试验证消费者能否处理该事件。在下一章中，我将描述一个示例测试。
- en: A contract for an asynchronous request/response interaction is similar to an
    HTTP contract. It consists of a request message and a response message. A provider
    test invokes the API with the contract’s request message and verifies that the
    response matches the contract’s response. A consumer test uses the contract to
    configure a stub subscriber, which listens for the contract’s request message
    and replies with the specified response. The next chapter discusses an example
    test. But first we’ll take a look at the deployment pipeline, which runs these
    and other tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 异步请求/响应交互的合同类似于HTTP合同。它由一个请求消息和一个响应消息组成。提供者测试使用合同的请求消息调用API，并验证响应是否与合同的响应匹配。消费者测试使用合同配置一个存根订阅者，该订阅者监听合同的请求消息，并以指定的响应进行回复。下一章将讨论一个示例测试。但在那之前，我们将看看运行这些和其他测试的部署管道。
- en: 9.1.3\. The deployment pipeline
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3. 部署管道
- en: Every service has a deployment pipeline. Jez Humble’s book, Continuous Delivery
    (Addison-Wesley, 2010) describes a *deployment pipeline* as the automated process
    of getting code from the developer’s desktop into production. As [figure 9.9](#ch09fig09)
    shows, it consists of a series of stages that execute test suites, followed by
    a stage that releases or deploys the service. Ideally, it’s fully automated, but
    it might contain manual steps. A deployment pipeline is often implemented using
    a Continuous Integration (CI) server, such as Jenkins.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都有一个部署管道。Jez Humble的书籍《持续交付》（Addison-Wesley，2010）将**部署管道**描述为将代码从开发者的桌面自动部署到生产环境的自动化过程。如图9.9所示，它由一系列执行测试套件的阶段组成，随后是一个发布或部署服务的阶段。理想情况下，它是完全自动化的，但它可能包含手动步骤。部署管道通常使用持续集成（CI）服务器，如Jenkins来实现。
- en: Figure 9.9\. An example deployment pipeline for `Order Service`. It consists
    of a series of stages. The pre-commit tests are run by the developer prior to
    committing their code. The remaining stages are executed by an automated tool,
    such as the Jenkins CI server.
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9\. `Order Service`的示例部署管道。它由一系列阶段组成。在提交代码之前，开发者会运行预提交测试。其余阶段由自动化工具执行，例如Jenkins
    CI服务器。
- en: '![](Images/09fig09_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig09_alt.jpg)'
- en: As code flows through the pipeline, the test suites subject it to increasingly
    more thorough testing in environments that are more production like. At the same
    time, the execution time of each test suite typically grows. The idea is to provide
    feedback about test failures as rapidly as possible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码通过管道流动，测试套件在更类似生产环境的环境中对其进行越来越彻底的测试。同时，每个测试套件的执行时间通常会增加。目的是尽可能快速地提供关于测试失败的反馈。
- en: 'The example deployment pipeline shown in [figure 9.9](#ch09fig09) consists
    of the following stages:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图9.9](#ch09fig09)所示的示例部署管道包括以下阶段：
- en: '***Pre-commit tests stage*—** Runs the unit tests. This is executed by the
    developer before committing their changes.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***预提交测试阶段*—** 运行单元测试。这是在开发者提交更改之前执行的。'
- en: '***Commit tests stage*—** Compiles the service, runs the unit tests, and performs
    static code analysis.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***提交测试阶段*—** 编译服务，运行单元测试，并执行静态代码分析。'
- en: '***Integration tests stage*—** Runs the integration tests.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***集成测试阶段*—** 运行集成测试。'
- en: '***Component tests stage*—** Runs the component tests for the service.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组件测试阶段*—** 运行服务的组件测试。'
- en: '***Deploy stage*—** Deploys the service into production.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***部署阶段*—** 将服务部署到生产环境中。'
- en: The CI server runs the commit stage when a developer commits a change. It executes
    extremely quickly, so it provides rapid feedback about the commit. The later stages
    take longer to run, providing less immediate feedback. If all the tests pass,
    the final stage is when this pipeline deploys it into production.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者提交更改时，CI服务器会运行提交阶段。它执行得非常快，因此可以快速提供关于提交的反馈。后续阶段运行时间更长，提供的即时反馈较少。如果所有测试都通过，最终阶段就是将此管道部署到生产环境中。
- en: In this example, the deployment pipeline is fully automated all the way from
    commit to deployment. There are, however, situations that require manual steps.
    For example, you might need a manual testing stage, such as a staging environment.
    In such a scenario, the code progresses to the next stage when a tester clicks
    a button to indicate that it was successful. Alternatively, a deployment pipeline
    for an on-premise product would release the new version of the service. Later
    on, the released services would be packaged into a product release and shipped
    to customers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，从提交到部署的整个部署管道是完全自动化的。然而，有些情况下需要手动步骤。例如，你可能需要一个手动测试阶段，比如预发布环境。在这种情况下，代码在测试人员点击按钮表示成功后进入下一阶段。或者，对于本地产品，部署管道会发布服务的新版本。稍后，发布的服务会被打包成产品版本并发送给客户。
- en: Now that we’ve looked at the organization of the deployment pipeline and when
    it executes the different types of tests, let’s head to the bottom of the test
    pyramid and look at how to write unit tests for a service.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了部署管道的组织结构和它执行不同类型测试的时间，让我们来看看测试金字塔的底部，看看如何为服务编写单元测试。
- en: 9.2\. Writing unit tests for a service
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 为服务编写单元测试
- en: Imagine that you want to write a test that verifies that the FTGO application’s
    `Order Service` correctly calculates the subtotal of an `Order`. You could write
    tests that run `Order Service`, invoke its REST API to create an `Order`, and
    check that the HTTP response contains the expected values. The drawback of this
    approach is that not only is the test complex, it’s also slow. If these tests
    were the compile-time tests for the `Order` class, you’d waste a lot of time waiting
    for it to finish. A much more productive approach is to write unit tests for the
    `Order` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个测试来验证FTGO应用的`Order Service`正确计算`Order`的小计。你可以编写运行`Order Service`、调用其REST
    API创建`Order`并检查HTTP响应包含预期值的测试。这种方法的一个缺点是测试既复杂又慢。如果这些测试是`Order`类的编译时测试，你会浪费很多时间等待它完成。一个更有效的方法是为`Order`类编写单元测试。
- en: As [figure 9.10](#ch09fig10) shows, unit tests are the lowest level of the test
    pyramid. They’re technology-facing tests that support development. A unit test
    verifies that a *unit*, which is a very small part of a service, works correctly.
    A unit is typically a class, so the goal of unit testing is to verify that it
    behaves as expected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图9.10](#ch09fig10)所示，单元测试是测试金字塔的最低层。它们是面向技术的测试，支持开发。单元测试验证一个*单元*（服务的一个非常小的部分）是否正确工作。一个单元通常是类，因此单元测试的目标是验证它是否按预期行为。
- en: Figure 9.10\. Unit tests are the base of the pyramid. They’re fast running,
    easy to write, and reliable. A solitary unit test tests a class in isolation,
    using mocks or stubs for its dependencies. A sociable unit test tests a class
    and its dependencies.
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10。单元测试是金字塔的基础。它们运行速度快，易于编写，且可靠。一个独立的单元测试在隔离的情况下测试一个类，使用模拟或存根来处理其依赖项。一个社交单元测试测试一个类及其依赖项。
- en: '![](Images/09fig10_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig10_alt.jpg)'
- en: 'There are two types of unit tests ([https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的单元测试([https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html))：
- en: '***Solitary unit test*—** Tests a class in isolation using mock objects for
    the class’s dependencies'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***独立单元测试*—** 使用模拟对象对类的依赖项进行隔离测试'
- en: '***Sociable unit test*—** Tests a class and its dependencies'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***社交单元测试*—** 测试一个类及其依赖项'
- en: The responsibilities of the class and its role in the architecture determine
    which type of test to use. [Figure 9.11](#ch09fig11) shows the hexagonal architecture
    of a typical service and the type of unit test that you’ll typically use for each
    kind of class. Controller and service classes are often tested using solitary
    unit tests. Domain objects, such as entities and value objects, are typically
    tested using sociable unit tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类的责任及其在架构中的作用决定了使用哪种类型的测试。[图9.11](#ch09fig11)展示了典型服务的六边形架构以及为每种类通常使用的单元测试类型。控制器和服务类通常使用独立单元测试进行测试。领域对象，如实体和价值对象，通常使用社交单元测试进行测试。
- en: Figure 9.11\. The responsibilities of a class determine whether to use a solitary
    or sociable unit test.
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.11。一个类的责任决定了是否使用独立或社交单元测试。
- en: '![](Images/09fig11_alt.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig11_alt.jpg)'
- en: 'The typical testing strategy for each class is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类典型的测试策略如下：
- en: Entities, such as `Order`, which as described in [chapter 5](kindle_split_013.xhtml#ch05)
    are objects with persistent identity, are tested using sociable unit tests.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体，如`Order`，如第5章所述（kindle_split_013.xhtml#ch05）是具有持久身份的对象，使用社交单元测试进行测试。
- en: Value objects, such as `Money`, which as described in [chapter 5](kindle_split_013.xhtml#ch05)
    are objects that are collections of values, are tested using sociable unit tests.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象，如`Money`，如第5章所述（kindle_split_013.xhtml#ch05）是值的集合，使用社交单元测试进行测试。
- en: Sagas, such as `CreateOrderSaga`, which as described in [chapter 4](kindle_split_012.xhtml#ch04)
    maintain data consistency across services, are tested using sociable unit tests.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传奇，如`CreateOrderSaga`，如第4章所述（kindle_split_012.xhtml#ch04），在服务之间维护数据一致性，使用社交单元测试进行测试。
- en: Domain services, such as `OrderService`, which as described in [chapter 5](kindle_split_013.xhtml#ch05)
    are classes that implement business logic that doesn’t belong in entities or value
    objects, are tested using solitary unit tests.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域服务，如`OrderService`，如第5章所述（kindle_split_013.xhtml#ch05）是实现不属于实体或值对象的业务逻辑的类，使用独立单元测试进行测试。
- en: Controllers, such as `OrderController`, which handle HTTP requests, are tested
    using solitary unit tests.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求的控制器，如`OrderController`，使用独立单元测试进行测试。
- en: Inbound and outbound messaging gateways are tested using solitary unit tests.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出消息网关使用单独的单元测试进行测试。
- en: Let’s begin by looking at how to test entities.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何测试实体。
- en: 9.2.1\. Developing unit tests for entities
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 为实体开发单元测试
- en: The following listing shows an excerpt of `OrderTest` class, which implements
    the unit tests for the `Order` entity. The class has an `@Before setUp()` method
    that creates an `Order` before running each test. Its `@Test` methods might further
    initialize `Order`, invoke one of its methods, and then make assertions about
    the return value and the state of `Order`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `OrderTest` 类的摘录，该类实现了 `Order` 实体的单元测试。该类有一个 `@Before setUp()` 方法，在运行每个测试之前创建一个
    `Order`。它的 `@Test` 方法可能会进一步初始化 `Order`，调用其方法之一，然后对返回值和 `Order` 的状态进行断言。
- en: Listing 9.2\. A simple, fast-running unit test for the `Order` entity
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 对 `Order` 实体的一个简单、快速运行的单元测试
- en: '[PRE1]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `@Test shouldCalculateTotal()` method verifies that `Order.getOrderTotal()`
    returns the expected value. Unit tests thoroughly test the business logic. They
    are sociable unit tests for the `Order` class and its dependencies. You can use
    them as compile-time tests because they execute extremely quickly. The `Order`
    class relies on the `Money` value object, so it’s important to test that class
    as well. Let’s see how to do that.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Test shouldCalculateTotal()` 方法验证 `Order.getOrderTotal()` 返回预期的值。单元测试彻底测试了业务逻辑。它们是针对
    `Order` 类及其依赖项的社交单元测试。你可以将它们用作编译时测试，因为它们执行得非常快。`Order` 类依赖于 `Money` 值对象，因此测试该类也很重要。让我们看看如何进行这项测试。'
- en: 9.2.2\. Writing unit tests for value objects
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 编写值对象的单元测试
- en: Value objects are immutable, so they tend to be easy to test. You don’t have
    to worry about side effects. A test for a value object typically creates a value
    object in a particular state, invokes one of its methods, and makes assertions
    about the return value. [Listing 9.3](#ch09ex03) shows the tests for the `Money`
    value object, which is a simple class that represents a money value. These tests
    verify the behavior of the `Money` class’s methods, including `add()`, which adds
    two `Money` objects, and `multiply()`, which multiplies a `Money` object by an
    integer. They are solitary tests because the `Money` class doesn’t depend on any
    other application classes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象是不可变的，因此它们通常很容易测试。你不必担心副作用。值对象的测试通常创建一个处于特定状态的值对象，调用其方法之一，并对返回值进行断言。[列表 9.3](#ch09ex03)
    显示了 `Money` 值对象的测试，它是一个表示货币值的简单类。这些测试验证了 `Money` 类的方法的行为，包括 `add()` 方法，它将两个 `Money`
    对象相加，以及 `multiply()` 方法，它将一个 `Money` 对象乘以一个整数。它们是单独的测试，因为 `Money` 类不依赖于任何其他应用程序类。
- en: Listing 9.3\. A simple, fast-running test for the `Money` value object
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 对 `Money` 值对象的一个简单、快速运行的测试
- en: '[PRE2]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Verify that two Money objects can be added together.**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 验证两个 Money 对象可以相加。**'
- en: '***2* Verify that a Money object can be multiplied by an integer.**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证一个 Money 对象可以乘以一个整数。**'
- en: Entities and value objects are the building blocks of a service’s business logic.
    But some business logic also resides in the service’s sagas and services. Let’s
    look at how to test those.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实体和值对象是服务业务逻辑的构建块。但一些业务逻辑也存在于服务的 sagas 和服务中。让我们看看如何测试这些内容。
- en: 9.2.3\. Developing unit tests for sagas
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 为 sagas 开发单元测试
- en: A saga, such as the `CreateOrderSaga` class, implements important business logic,
    so needs to be tested. It’s a persistent object that sends command messages to
    saga participants and processes their replies. As described in [chapter 4](kindle_split_012.xhtml#ch04),
    `CreateOrderSaga` exchanges command/reply messages with several services, such
    as `Consumer Service` and `Kitchen Service`. A test for this class creates a saga
    and verifies that it sends the expected sequence of messages to the saga participants.
    One test you need to write is for the happy path. You must also write tests for
    the various scenarios where the saga rolls back because a saga participant sent
    back a failure message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 saga，例如 `CreateOrderSaga` 类，实现了重要的业务逻辑，因此需要对其进行测试。它是一个持久对象，向 saga 参与者发送命令消息并处理它们的回复。如
    [第 4 章](kindle_split_012.xhtml#ch04) 所述，`CreateOrderSaga` 与多个服务（如 `Consumer Service`
    和 `Kitchen Service`）交换命令/回复消息。对这个类的测试创建了一个 saga 并验证它向 saga 参与者发送了预期的消息序列。你需要编写的一个测试是针对快乐路径的测试。你还必须编写针对
    saga 因为 saga 参与者发送了失败消息而回滚的各种场景的测试。
- en: One approach would be to write tests that use a real database and message broker
    along with stubs to simulate the various saga participants. For example, a stub
    for `Consumer Service` would subscribe to the `consumerService` command channel
    and send back the desired reply message. But tests written using this approach
    would be quite slow. A much more effective approach is to write tests that mock
    those classes that interact with the database and message broker. That way, we
    can focus on testing the saga’s core responsibility.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法可能是编写使用真实数据库和消息代理以及模拟来模拟各种传说参与者的测试。例如，`Consumer Service` 的模拟会订阅 `consumerService`
    命令通道并发送所需的回复消息。但使用这种方法编写的测试会相当慢。一个更有效的方法是编写模拟与数据库和消息代理交互的类的测试。这样，我们可以专注于测试传说的核心职责。
- en: '[Listing 9.4](#ch09ex04) shows a test for `CreateOrderSaga`. It’s a sociable
    unit test that tests the saga class and its dependencies. It’s written using the
    Eventuate Tram Saga testing framework ([https://github.com/eventuate-tram/eventuate-tram-sagas](https://github.com/eventuate-tram/eventuate-tram-sagas)).
    This framework provides an easy-to-use DSL that abstracts away the details of
    interacting with sagas. With this DSL, you can create a saga and verify that it
    sends the correct command messages. Under the covers, the Saga testing framework
    configures the Saga framework with mocks for the database and messaging infrastructure.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.4](#ch09ex04) 展示了对 `CreateOrderSaga` 的测试。这是一个社交单元测试，用于测试传说类及其依赖项。它使用
    Eventuate Tram Saga 测试框架编写（[https://github.com/eventuate-tram/eventuate-tram-sagas](https://github.com/eventuate-tram/eventuate-tram-sagas)）。此框架提供了一个易于使用的
    DSL，它抽象化了与传说交互的细节。使用此 DSL，您可以创建一个传说并验证它是否发送了正确的命令消息。在底层，传说测试框架使用数据库和消息基础设施的模拟配置了传说框架。'
- en: Listing 9.4\. A simple, fast-running unit test for `CreateOrderSaga`
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 对 `CreateOrderSaga` 的简单、快速运行的单元测试
- en: '[PRE3]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Create the saga.**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建传说。**'
- en: '***2* Verify that it sends a ValidateOrderByConsumer message to Consumer Service.**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证它是否向消费者服务发送了 ValidateOrderByConsumer 消息。**'
- en: '***3* Send a Success reply to that message.**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向该消息发送一个成功回复。**'
- en: '***4* Verify that it sends a CreateTicket message to Kitchen Service.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 验证它是否向厨房服务发送了 CreateTicket 消息。**'
- en: '***5* Send a failure reply indicating that Consumer Service rejected Order.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 发送一个失败回复，表明消费者服务拒绝了订单。**'
- en: '***6* Verify that the saga sends a RejectOrderCommand message to Order Service.**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证传说是否向订单服务发送了 RejectOrderCommand 消息。**'
- en: The `@Test shouldCreateOrder()` method tests the happy path. The `@Test shouldRejectOrderDueToConsumerVerificationFailed()`
    method tests the scenario where `Consumer Service` rejects the order. It verifies
    that `CreateOrderSaga` sends a `RejectOrderCommand` to compensate for the consumer
    being rejected. The `CreateOrderSagaTest` class has methods that test other failure
    scenarios.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Test shouldCreateOrder()` 方法测试了快乐路径。`@Test shouldRejectOrderDueToConsumerVerificationFailed()`
    方法测试了消费者服务拒绝订单的场景。它验证了 `CreateOrderSaga` 向消费者被拒绝进行补偿发送了 `RejectOrderCommand`。`CreateOrderSagaTest`
    类有测试其他失败场景的方法。'
- en: Let’s now look at how to test domain services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何测试领域服务。
- en: 9.2.4\. Writing unit tests for domain services
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4\. 编写领域服务的单元测试
- en: The majority of a service’s business logic is implemented by the entities, value
    objects, and sagas. Domain service classes, such as the `OrderService` class,
    implement the remainder. This class is a typical domain service class. Its methods
    invoke entities and repositories and publish domain events. An effective way to
    test this kind of class is to use a mostly solitary unit test, which mocks dependencies
    such as repositories and messaging classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的大部分业务逻辑是由实体、值对象和传说实现的。例如，`OrderService` 类这样的领域服务类实现了其余部分。这是一个典型的领域服务类。它的方法调用实体和存储库并发布领域事件。测试此类的一个有效方法是使用主要孤立的单元测试，该测试模拟了存储库和消息类等依赖项。
- en: '[Listing 9.5](#ch09ex05) shows the `OrderServiceTest` class, which tests `OrderService`.
    It defines solitary unit tests, which use Mockito mocks for the service’s dependencies.
    Each test implements the test phases as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.5](#ch09ex05) 展示了测试 `OrderService` 的 `OrderServiceTest` 类。它定义了孤立的单元测试，使用
    Mockito 模拟服务依赖项。每个测试按照以下方式实现测试阶段：'
- en: '***Setup*—** Configures the mock objects for the service’s dependencies'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***设置*—** 配置服务的依赖项的模拟对象'
- en: '***Execute*—** Invokes a service method'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***执行*—** 调用服务方法'
- en: '***Verify*—** Verifies that the value returned by the service method is correct
    and that the dependencies have been invoked correctly'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***验证*—** 验证服务方法返回的值是否正确，以及依赖项是否已正确调用'
- en: Listing 9.5\. A simple, fast-running unit test for the `OrderService` class
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. `OrderService` 类的一个简单、快速运行的单元测试
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Create Mockito mocks for OrderService’s dependencies.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为 OrderService 的依赖项创建 Mockito 模拟。**'
- en: '***2* Create an OrderService injected with mock dependencies.**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个注入了模拟依赖的 OrderService。**'
- en: '***3* Configure RestaurantRepository.findById() to return the Ajanta restaurant.**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置 RestaurantRepository.findById() 以返回 Ajanta 餐厅。**'
- en: '***4* Configure OrderRepository.save() to set Order’s ID.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 配置 OrderRepository.save() 以设置订单的 ID。**'
- en: '***5* Invoke OrderService.create().**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用 OrderService.create()。**'
- en: '***6* Verify that OrderService saved the newly created Order in the database.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证 OrderService 是否已将新创建的订单保存到数据库中。**'
- en: '***7* Verify that OrderService published an OrderCreatedEvent.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 验证 OrderService 是否发布了 OrderCreatedEvent。**'
- en: '***8* Verify that OrderService created a CreateOrderSaga.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 验证 OrderService 是否创建了一个 CreateOrderSaga。**'
- en: The `setUp()` method creates an `OrderService` injected with mock dependencies.
    The `@Test shouldCreateOrder()` method verifies that `OrderService.createOrder()`
    invokes `OrderRepository` to save the newly created `Order`, publishes an `OrderCreatedEvent`,
    and creates a `CreateOrderSaga`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()` 方法创建了一个注入了模拟依赖的 `OrderService`。`@Test shouldCreateOrder()` 方法验证 `OrderService.createOrder()`
    是否调用了 `OrderRepository` 来保存新创建的 `Order`，发布了一个 `OrderCreatedEvent`，并创建了一个 `CreateOrderSaga`。'
- en: Now that we’ve seen how to unit test the domain logic classes, let’s look at
    how to unit test the adapters that interact with external systems.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何对领域逻辑类进行单元测试，接下来让我们看看如何对与外部系统交互的适配器进行单元测试。
- en: 9.2.5\. Developing unit tests for controllers
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.5\. 开发控制器的单元测试
- en: Services, such as `Order Service`, typically have one or more controllers that
    handle HTTP requests from other services and the API gateway. A controller class
    consists of a set of request handler methods. Each method implements a REST API
    endpoint. A method’s parameters represent values from the HTTP request, such as
    path variables. It typically invokes a domain service or a repository and returns
    a response object. `OrderController`, for instance, invokes `OrderService` and
    `OrderRepository`. An effective testing strategy for controllers is solitary unit
    tests that mock the services and repositories.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 `Order Service` 这样的服务通常有一个或多个控制器来处理来自其他服务和 API 网关的 HTTP 请求。控制器类由一组请求处理方法组成。每个方法实现一个
    REST API 端点。方法参数代表 HTTP 请求中的值，例如路径变量。它通常调用领域服务或存储库并返回一个响应对象。例如，`OrderController`
    调用 `OrderService` 和 `OrderRepository`。对于控制器，一个有效的测试策略是单独的单元测试，模拟服务和存储库。
- en: You could write a test class similar to the `OrderServiceTest` class to instantiate
    a controller class and invoke its methods. But this approach doesn’t test some
    important functionality, such as request routing. It’s much more effective to
    use a mock MVC testing framework, such as Spring Mock Mvc, which is part of the
    Spring Framework, or Rest Assured Mock MVC, which builds on Spring Mock Mvc. Tests
    written using one of these frameworks make what appear to be HTTP requests and
    make assertions about HTTP responses. These frameworks enable you to test HTTP
    request routing and conversion of Java objects to and from JSON without having
    to make real network calls. Under the covers, Spring Mock Mvc instantiates just
    enough of the Spring MVC classes to make this possible.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个类似于 `OrderServiceTest` 类的测试类来实例化一个控制器类并调用其方法。但这种方法无法测试一些重要的功能，例如请求路由。使用模拟
    MVC 测试框架，例如 Spring Mock Mvc，它属于 Spring 框架的一部分，或者基于 Spring Mock Mvc 的 Rest Assured
    Mock MVC，效果会更好。使用这些框架编写的测试会模拟 HTTP 请求并对 HTTP 响应进行断言。这些框架使你能够在不进行实际网络调用的情况下测试 HTTP
    请求路由以及 Java 对象与 JSON 之间的转换。在底层，Spring Mock Mvc 仅实例化了足够的 Spring MVC 类以实现这一点。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Are these really unit tests?**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**这真的是单元测试吗？**'
- en: Because these tests use the Spring Framework, you might argue that they’re not
    unit tests. They’re certainly more heavyweight than the unit tests I’ve described
    so far. The Spring Mock Mvc documentation refers to these as out-of-servlet-container
    integration tests ([https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests)).
    Yet Rest Assured Mock MVC describes these tests as unit tests ([https://github.com/rest-assured/rest-assured/wiki/Usage#spring-mock-mvc-module](https://github.com/rest-assured/rest-assured/wiki/Usage#spring-mock-mvc-module)).
    Regardless of the debate over terminology, these are important tests to write.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试使用 Spring 框架，你可能会认为它们不是单元测试。它们当然比我之前描述的单元测试更重量级。Spring Mock Mvc 文档将这些测试称为出
    Servlet 容器集成测试（[https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests)）。然而，Rest
    Assured Mock MVC 将这些测试描述为单元测试（[https://github.com/rest-assured/rest-assured/wiki/Usage#spring-mock-mvc-module](https://github.com/rest-assured/rest-assured/wiki/Usage#spring-mock-mvc-module)）。无论术语上的争论如何，这些都是重要的测试。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Listing 9.6](#ch09ex06) shows the `OrderControllerTest` class, which tests
    `Order Service`’s `OrderController`. It defines solitary unit tests that use mocks
    for `OrderController`’s dependencies. It’s written using Rest Assured Mock MVC,
    which provides a simple DSL that abstracts away the details of interacting with
    controllers. Rest Assured makes it easy to send a mock HTTP request to a controller
    and verify the response. `OrderControllerTest` creates a controller that’s injected
    with Mockito mocks for `OrderService` and `OrderRepository`. Each test configures
    the mocks, makes an HTTP request, verifies that the response is correct, and possibly
    verifies that the controller invoked the mocks.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.6](#ch09ex06) 展示了 `OrderControllerTest` 类，它测试 `Order Service` 的 `OrderController`。它定义了使用
    `OrderController` 依赖项的模拟的独立单元测试。它使用 Rest Assured Mock MVC 编写，它提供了一个简单的 DSL，可以抽象出与控制器交互的细节。Rest
    Assured 使得向控制器发送模拟 HTTP 请求并验证响应变得容易。`OrderControllerTest` 创建了一个控制器，该控制器注入了 Mockito
    模拟的 `OrderService` 和 `OrderRepository`。每个测试配置模拟，发送 HTTP 请求，验证响应是否正确，并可能验证控制器是否调用了模拟。'
- en: Listing 9.6\. A simple, fast-running unit test for the `OrderController` class
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. `OrderController` 类的一个简单、快速运行的单元测试
- en: '[PRE5]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Create mocks for OrderController’s dependencies.**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为 OrderController 的依赖项创建模拟。**'
- en: '***2* Configure the mock OrderRepository to return an Order.**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置模拟的 OrderRepository 返回一个订单。**'
- en: '***3* Configure OrderController.**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置 OrderController。**'
- en: '***4* Make an HTTP request.**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 发送 HTTP 请求。**'
- en: '***5* Verify the response status code.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 验证响应状态码。**'
- en: '***6* Verify elements of the JSON response body.**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证 JSON 响应体的元素。**'
- en: The `shouldFindOrder()` test method first configures the `OrderRepository` mock
    to return an `Order`. It then makes an HTTP request to retrieve the order. Finally,
    it checks that the request was successful and that the response body contains
    the expected data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldFindOrder()` 测试方法首先配置 `OrderRepository` 模拟以返回一个 `Order`。然后它发送一个 HTTP
    请求以检索订单。最后，它检查请求是否成功，以及响应体是否包含预期的数据。'
- en: Controllers aren’t the only adapters that handle requests from external systems.
    There are also event/message handlers, so let’s talk about how to unit test those.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器不是唯一处理外部系统请求的适配器。还有事件/消息处理器，让我们谈谈如何对这些进行单元测试。
- en: 9.2.6\. Writing unit tests for event and message handlers
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.6\. 编写事件和消息处理器的单元测试
- en: Services often process messages sent by external systems. `Order Service`, for
    example, has `OrderEventConsumer`, which is a message adapter that handles domain
    events published by other services. Like controllers, message adapters tend to
    be simple classes that invoke domain services. Each of a message adapter’s methods
    typically invokes a service method with data from the message or event.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常处理外部系统发送的消息。例如，`Order Service` 有 `OrderEventConsumer`，这是一个消息适配器，用于处理其他服务发布的领域事件。像控制器一样，消息适配器通常是简单的类，调用领域服务。消息适配器的每个方法通常都会调用一个服务方法，并使用消息或事件中的数据。
- en: We can unit test message adapters using an approach similar to the one we used
    for unit testing controllers. Each test instances the message adapter, sends a
    message to a channel, and verifies that the service mock was invoked correctly.
    Behind the scenes, though, the messaging infrastructure is stubbed, so no message
    broker is involved. Let’s look at how to test the `OrderEventConsumer` class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与单元测试控制器类似的方法来单元测试消息适配器。每个测试实例化消息适配器，向通道发送消息，并验证服务模拟是否被正确调用。然而，在幕后，消息基础设施被模拟，因此没有涉及任何消息代理。让我们看看如何测试
    `OrderEventConsumer` 类。
- en: '[Listing 9.7](#ch09ex07) shows part of the `OrderEventConsumerTest` class,
    which tests `OrderEventConsumer`. It verifies that `OrderEventConsumer` routes
    each event to the appropriate handler method and correctly invokes `OrderService`.
    The test uses the Eventuate Tram Mock Messaging framework, which provides an easy-to-use
    DSL for writing mock messaging tests that uses the same given-when-then format
    as Rest Assured. Each test instantiates `OrderEventConsumer` injected with a mock
    `OrderService`, publishes a domain event, and verifies that `OrderEventConsumer`
    correctly invokes the service mock.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.7](#ch09ex07) 展示了 `OrderEventConsumerTest` 类的一部分，该类测试 `OrderEventConsumer`。它验证
    `OrderEventConsumer` 将每个事件路由到适当的手动方法，并正确调用 `OrderService`。该测试使用 Eventuate Tram
    Mock Messaging 框架，该框架提供了一个易于使用的 DSL，用于编写与 Rest Assured 相同的给定-当-然后格式模拟消息测试。每个测试实例化
    `OrderEventConsumer`，注入模拟 `OrderService`，发布一个领域事件，并验证 `OrderEventConsumer` 是否正确调用服务模拟。'
- en: Listing 9.7\. A fast-running unit test for the `OrderEventConsumer` class
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. `OrderEventConsumer` 类的快速运行的单元测试
- en: '[PRE6]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Instantiate OrderEventConsumer with mocked dependencies.**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用模拟依赖项实例化 OrderEventConsumer。**'
- en: '***2* Configure OrderEventConsumer domain handlers.**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置 OrderEventConsumer 领域处理器。**'
- en: '***3* Publish a RestaurantCreated event.**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发布一个 RestaurantCreated 事件。**'
- en: '***4* Verify that OrderEventConsumer invoked OrderService.createMenu().**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 验证 OrderEventConsumer 是否调用了 OrderService.createMenu().**'
- en: The `setUp()` method creates an `OrderEventConsumer` injected with a mock `OrderService`.
    The `shouldCreateMenu()` method publishes a `RestaurantCreated` event and verifies
    that `OrderEventConsumer` invoked `OrderService.createMenu()`. The `OrderEventConsumerTest`
    class and the other unit test classes execute extremely quickly. The unit tests
    run in just a few seconds.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()` 方法创建了一个注入了模拟 `OrderService` 的 `OrderEventConsumer`。`shouldCreateMenu()`
    方法发布了一个 `RestaurantCreated` 事件，并验证 `OrderEventConsumer` 调用了 `OrderService.createMenu()`。`OrderEventConsumerTest`
    类和其他单元测试类执行得非常快。单元测试只需几秒钟就能完成。'
- en: But the unit tests don’t verify that a service, such as `Order Service`, properly
    interacts with other services. For example, the unit tests don’t verify that an
    `Order` can be persisted in MySQL. Nor do they verify that `CreateOrderSaga` sends
    command messages in the right format to the right message channel. And they don’t
    verify that the `RestaurantCreated` event processed by `OrderEventConsumer` has
    the same structure as the event published by `Restaurant Service`. In order to
    verify that a service properly interacts with other services, we must write integration
    tests. We also need to write component tests that test an entire service in isolation.
    The next chapter discusses how to conduct those types of tests, as well as end-to-end
    tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但单元测试并没有验证服务，例如 `Order Service`，是否与其他服务正确交互。例如，单元测试没有验证 `Order` 是否可以持久化到 MySQL。也没有验证
    `CreateOrderSaga` 是否以正确的格式向正确的消息通道发送命令消息。而且它们也没有验证 `OrderEventConsumer` 处理的 `RestaurantCreated`
    事件的结构与 `Restaurant Service` 发布的事件相同。为了验证服务是否正确与其他服务交互，我们必须编写集成测试。我们还需要编写组件测试，以单独测试整个服务。下一章将讨论如何进行这些类型的测试，以及端到端测试。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Automated testing is the key foundation of rapid, safe delivery of software.
    What’s more, because of its inherent complexity, to fully benefit from the microservice
    architecture you *must* automate your tests.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试是快速、安全交付软件的关键基础。更重要的是，由于其固有的复杂性，为了充分利用微服务架构，您 *必须* 自动化您的测试。
- en: The purpose of a test is to verify the behavior of the system under test (SUT).
    In this definition, *system* is a fancy term that means the software element being
    tested. It might be something as small as a class, as large as the entire application,
    or something in between, such as a cluster of classes or an individual service.
    A collection of related tests form a test suite.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的目的是验证被测试系统（SUT）的行为。在这个定义中，“系统”是一个术语，意味着正在测试的软件元素。它可能小到是一个类，大到是整个应用程序，或者介于两者之间，比如一组类或一个单独的服务。相关测试的集合形成一个测试套件。
- en: 'A good way to simplify and speed up a test is to use test doubles. A test double
    is an object that simulates the behavior of a SUT’s dependency. There are two
    types of test doubles: stubs and mocks. A stub is a test double that returns values
    to the SUT. A mock is a test double that a test uses to verify that the SUT correctly
    invokes a dependency.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化并加速测试的一个好方法是使用测试替身。测试替身是一个模拟SUT（系统单元）依赖行为的对象。测试替身有两种类型：存根和模拟。存根是一种测试替身，它向SUT返回值。模拟是一种测试替身，测试用它来验证SUT是否正确调用了依赖。
- en: Use the test pyramid to determine where to focus your testing efforts for your
    services. The majority of your tests should be fast, reliable, and easy-to-write
    unit tests. You must minimize the number of end-to-end tests, because they’re
    slow, brittle, and time consuming to write.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试金字塔来确定为您的服务集中测试努力的地方。您的大多数测试应该是快速、可靠且易于编写的单元测试。您必须最小化端到端测试的数量，因为它们运行缓慢、脆弱，且编写起来耗时。
