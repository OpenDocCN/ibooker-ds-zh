- en: 8 Unicode and wide characters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 Unicode和宽字符
- en: In the beginning was Morse code, a simple method of translating electrical pulses—long
    and short—into a string of characters and readable text. Morse wasn’t the first
    electronic encoding method, but it’s perhaps the best known. Developed in 1840,
    it’s named after Samuel Morse, who helped invent the telegraph and who also bears
    an uncanny resemblance to *Lost in Space*’s Dr. Smith.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始是莫尔斯电码，这是一种将电脉冲——长和短——转换成字符串和可读文本的简单方法。莫尔斯并不是第一个电子编码方法，但它可能是最著名的。它在1840年开发，以塞缪尔·莫尔斯的名字命名，他帮助发明了电报，并且也与《太空迷航员》中的史密斯博士有惊人的相似之处。
- en: Some 30 years after Morse code came the Baudot code. Also used in telegraph
    communications, *Baudot* (baw-DOH) represents letters of the alphabet using a
    5-bit sequence. This code was later modified into Murray code for use on teletype
    machines with keyboards, as well as early computers. Then came IBM’s Binary Coded
    Decimal (BCD) for use on their mainframe computers. Eventually, the ASCII encoding
    standard ruled the computer roost until Unicode solved everyone’s text encoding
    problems in the late 20th century.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在莫尔斯电码之后的30年左右出现了博多电码。它也用于电报通信，*博多*（baw-DOH）使用5位序列来表示字母表中的字母。后来，这种代码被修改成默里电码，用于带有键盘的电传打字机和早期的计算机。然后是IBM的二元编码十进制（BCD），用于他们的主机计算机。最终，ASCII编码标准在20世纪末解决了所有人的文本编码问题。
- en: 'This chapter’s topic is character encoding, the art of taking an alphabet soup
    of characters and assigning them a code value for digital representation in a
    computer. The culmination of this effort is Unicode, which slaps a value to almost
    every imaginable written scribble in the history of mankind. To help explore Unicode
    in the C language, in this chapter you will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是字符编码，这是一种将字符的字母汤赋予代码值以在计算机中进行数字表示的艺术。这一努力的成果是Unicode，它几乎为人类历史上几乎所有的可想象书写文字赋予了值。为了帮助在C语言中探索Unicode，在本章中你将：
- en: Review various computer encoding systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习各种计算机编码系统
- en: Study ASCII text, code pages, and Unicode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究ASCII文本、代码页和Unicode
- en: Set the locale details for your programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的程序设置区域设置细节
- en: Understand different character types, such as UTF-8
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同的字符类型，例如UTF-8
- en: Work with wide characters and strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宽字符和字符串
- en: Perform wide character file I/O
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行宽字符文件I/O
- en: I really don’t see any new text-encoding format taking over from Unicode. It’s
    a solid system, with new characters assigned every year. Its only limitation seems
    to be its spotty implementation in various typefaces. Therefore, although you
    can program Unicode in a Linux terminal window, text output may not appear accurately.
    To best resolve this issue, ensure that your terminal program window lets you
    change fonts so that you can witness the interesting, weird, and impressive text
    Unicode can produce.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的看不到任何新的文本编码格式会取代Unicode。这是一个稳固的系统，每年都会分配新的字符。它唯一的限制似乎是在各种字体中的实施不完善。因此，尽管你可以在Linux终端窗口中编程Unicode，但文本输出可能不会准确显示。为了最好地解决这个问题，确保你的终端程序窗口允许你更改字体，这样你就可以见证Unicode可以产生的有趣、奇特和令人印象深刻的效果。
- en: 8.1 Text representation in computers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 计算机中的文本表示
- en: Computers understand numbers, bits organized into bytes dwelling in memory,
    manipulated by the processor, and stored long-term on media. The system really
    doesn’t care about text, and it’s totally ignorant of spelling. Still, to communicate
    with humans, many of these byte values correspond to printed characters. It’s
    the consistency of this character encoding that allows computers to communicate
    with humans and exchange information, despite their innate reluctance to do so.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机理解数字，这些数字以字节的形式组织在内存中，由处理器操作，并长期存储在媒体上。系统实际上并不关心文本，并且对拼写一无所知。尽管如此，为了与人类沟通，许多这些字节值对应于打印字符。正是这种字符编码的一致性使得计算机能够与人类沟通并交换信息，尽管它们天生并不愿意这样做。
- en: 8.1.1 Reviewing early text formats
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 复习早期文本格式
- en: The only time you hear about Morse code these days is in the movies. Something
    important must happen, and communications takes place only via tapping on a pipe
    or something equally desperate and silly. One of the characters responds with
    the cliché that their knowledge of Morse code is “rusty,” but the message is decoded,
    the audience impressed, and the day saved.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天你只有在电影中才会听到莫尔斯电码。一定发生了重要的事情，通信只能通过敲击管道或其他同样绝望和愚蠢的方式来进行。其中一个角色用陈词滥调回应说他们的莫尔斯电码知识“生疏了”，但信息被解码，观众印象深刻，这一天得以挽救。
- en: Morse code is composed of a series of dashes and dots, long or short pulses,
    to encode letters and numbers. No distinction is necessary between upper- and
    lowercase. Some common codes are known among nerds, such as S-O-S, though I can’t
    readily remember which triplex series of dots and dashes belongs to the S or O.
    I suppose I can look at table 8.1 to determine which is which.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔斯电码由一系列的短划线和点组成，长或短的脉冲，用于编码字母和数字。大小写之间没有区别。一些常见的代码在“极客”中是众所周知的，例如S-O-S，尽管我无法立即记住哪个三位点划组合属于S或O。我想我可以查看表8.1来确定哪个是哪个。
- en: Table 8.1 Morse code
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 摩尔斯电码
- en: '| Character | Code | Character | Code | Character | Code |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 代码 | 字符 | 代码 | 字符 | 代码 |'
- en: '| A | .- | M | -- | Y | -.-- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| A | .- | M | -- | Y | -.-- |'
- en: '| B | -... | N | -. | Z | --.. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| B | -... | N | -. | Z | --.. |'
- en: '| C | -.-. | O | --- | 1 | .----- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| C | -.-. | O | --- | 1 | .----- |'
- en: '| D | -.. | P | .--. | 2 | ..--- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| D | -.. | P | .--. | 2 | ..--- |'
- en: '| E | . | Q | --.- | 3 | ...-- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| E | . | Q | --.- | 3 | ...-- |'
- en: '| F | ..-. | R | .-. | 4 | ....- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| F | ..-. | R | .-. | 4 | ....- |'
- en: '| G | --. | S | ... | 5 | ..... |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| G | --. | S | ... | 5 | ..... |'
- en: '| H | .... | T | - | 6 | -.... |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| H | .... | T | - | 6 | -.... |'
- en: '| I | .. | U | ..- | 7 | --... |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| I | .. | U | ..- | 7 | --... |'
- en: '| J | .--- | V | ...- | 8 | ---.. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| J | .--- | V | ...- | 8 | ---.. |'
- en: '| K | -.- | W | .-- | 9 | ----. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| K | -.- | W | .-- | 9 | ----. |'
- en: '| L | .-.. | X | -..- | 0 | ----- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| L | .-.. | X | -..- | 0 | ----- |'
- en: I’ll avoid getting into the weeds with technical details about the length of
    a dash or dot and spaces and such. Though, one nerdy point I can bring up is that
    the encoding is designed so that frequently used letters have fewer units, such
    as E, T, I, A, N, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我将避免涉及有关划线或点的长度以及空格等技术细节的细节。尽管如此，我可以提出的一个“极客”观点是，编码设计得使得常用字母有更少的单位，例如E、T、I、A、N等等。
- en: The next listing shows the *toMorse()* function, which outputs a Morse code
    character string based on an input character. The character strings are stored
    in two *const char* arrays, matching the sequences A to Z for morse_alpha[] and
    0 to 9 for morse_digit[]. An *if-else* structure uses ctype functions to pull
    out alpha and numeric characters; all other characters are ignored.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了*toMorse()*函数，该函数根据输入字符输出摩尔斯电码字符串。字符字符串存储在两个*const char*数组中，分别对应morse_alpha[]的A到Z序列和morse_digit[]的0到9序列。一个*if-else*结构使用ctype函数提取字母和数字字符；所有其他字符都被忽略。
- en: Listing 8.1 The *toMorse()* function
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 *toMorse()*函数
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Arrays declared as *const char* to keep the code from otherwise messing with
    them; this type of construction dislikes being manipulated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数组声明为*const char*以防止代码在其它情况下修改它们；这种类型的结构不喜欢被操作。
- en: ❷ Pulls out alphabetic characters
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提取字母字符
- en: ❸ Converts to uppercase; Morse is case-insensitive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 转换为大写；摩尔斯电码不区分大小写。
- en: ❹ Subtracts the character from 'A' to obtain the proper array element offset
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从'A'减去字符以获得正确的数组元素偏移量
- en: ❺ Checks for digits 0 through 9
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查数字0到9
- en: ❻ Subtracts the digit from '0' to obtain the proper array element offset
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从'0'减去数字以获得正确的数组元素偏移量
- en: ❼ For spaces and newlines, outputs a newline
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 对于空格和换行符，输出换行符
- en: ❽ Ignores non-Morse characters; no output is generated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 忽略非摩尔斯字符；不生成输出。
- en: The *toMorse()* function is easily set into a filter, which translates text
    input into Morse code strings for output. Such a filter is found in the source
    code file morse_code_ filter.c, available in this book’s online repository.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*toMorse()*函数可以很容易地设置为一个过滤器，该过滤器将文本输入转换为摩尔斯电码字符串进行输出。这种过滤器可以在本书的在线仓库中找到的源代码文件morse_code_filter.c中找到。'
- en: Another text encoding scheme is Baudot. This term may be strange to you—unless
    you’re an old timer who once referred to your dial-up modem’s speed in “baud.”
    A 300-baud modem crept along at 300 characters per second. Because baud isn’t
    exactly a representation of characters per second, faster modems (and today’s
    broadband) are measured in bits per second (BPS) and not baud.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种文本编码方案是博多码。这个术语对你来说可能很陌生——除非你是那些曾经用“波特”来称呼他们的拨号调制解调器速度的老手。一个300波特调制解调器以每秒300个字符的速度缓慢移动。因为波特并不完全代表每秒字符数，所以更快的调制解调器（以及今天的宽带）是以每秒比特数（BPS）来衡量的，而不是波特。
- en: Anyway.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样。
- en: The Baudot scheme encodes text in 5-bit chunks. This code was adapted by engineer
    and inventor Donald Murray into Murray code for use on teletype machines. These
    machines featured a QWERTY keyboard and were often used as input devices for early
    computer systems. Specifically, Murray developed paper tape to store and read
    keystrokes. Holes punched in the paper tape represented characters, as illustrated
    in figure 8.1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Baudot方案以5位块对文本进行编码。这位工程师和发明家唐纳德·穆雷将此代码改编为Murray代码，用于电传打字机。这些机器具有QWERTY键盘，常被用作早期计算机系统的输入设备。具体来说，穆雷开发了纸带以存储和读取按键。纸带上的孔代表字符，如图8.1所示。
- en: '![08-01](Images/08-01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](Images/08-01.png)'
- en: Figure 8.1 Paper tape with holes punched representing Baudot-Murray code
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1带有孔的纸带，代表Baudot-Murray代码
- en: The International Telegraph Alphabet No. 2 (ITA2) standard for Baudot-Murray
    code was introduced in 1928\. In the United States, the standard is named US-TTY
    (TTY for teletype). Because it’s 5 bits wide, not enough values are available
    to handle the full character set. Therefore, the code requires a shift character
    to switch between the alpha and symbol sets.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Baudot-Murray代码的International Telegraph Alphabet No. 2 (ITA2)标准于1928年推出。在美国，该标准被称为US-TTY（TTY代表电传打字机）。由于它宽度为5位，无法提供足够的值来处理完整的字符集。因此，该代码需要一个转换字符来在字母和符号集之间切换。
- en: Table 8.2 lists the Baudot-Murray hexadecimal codes for alphanumeric characters,
    the letter set. The code 0x1B switches to the figure set characters, shown in
    table 8.3\. Code 0x1B or code 0x1F switches back.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2列出了字母集的Baudot-Murray十六进制代码。代码0x1B切换到数字集字符，如表8.3所示。代码0x1B或代码0x1F切换回。
- en: Table 8.2 Baudot-Murray codes for ITA2 and US-TTY, letter set
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 ITA2和US-TTY的Baudot-Murray代码，字母集
- en: '| Code | Character | Code | Character | Code | Character | Code | Character
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Code | Character | Code | Character | Code | Character | Code | Character
    |'
- en: '| 0x00 | \0 | 0x08 | \r | 0x10 | T | 0x18 | O |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 0x00 | \0 | 0x08 | \r | 0x10 | T | 0x18 | O |'
- en: '| 0x01 | E | 0x09 | D | 0x11 | Z | 0x19 | B |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | E | 0x09 | D | 0x11 | Z | 0x19 | B |'
- en: '| 0x02 | \n | 0x0A | R | 0x12 | L | 0x1A | G |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | \n | 0x0A | R | 0x12 | L | 0x1A | G |'
- en: '| 0x03 | A | 0x0B | J | 0x13 | W | 0x1B | shift |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 0x03 | A | 0x0B | J | 0x13 | W | 0x1B | shift |'
- en: '| 0x04 | space | 0x0C | N | 0x14 | H | 0x1C | M |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | space | 0x0C | N | 0x14 | H | 0x1C | M |'
- en: '| 0x05 | S | 0x0D | F | 0x15 | Y | 0x1D | X |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 0x05 | S | 0x0D | F | 0x15 | Y | 0x1D | X |'
- en: '| 0x06 | I | 0x0E | C | 0x16 | P | 0x1E | V |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 0x06 | I | 0x0E | C | 0x16 | P | 0x1E | V |'
- en: '| 0x07 | U | 0x0F | K | 0x17 | Q | 0x1F | del |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 0x07 | U | 0x0F | K | 0x17 | Q | 0x1F | del |'
- en: Table 8.3 Baudot-Murray codes for ITA2 and US-TTY, figure set
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3 ITA2和US-TTY的Baudot-Murray代码，数字集
- en: '| Code | Character | Code | Character | Code | Character | Code | Character
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Code | Character | Code | Character | Code | Character | Code | Character
    |'
- en: '| 0x00 | \0 | 0x08 | /r | 0x10 | 5 | 0x18 | 9 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 0x00 | \0 | 0x08 | /r | 0x10 | 5 | 0x18 | 9 |'
- en: '| 0x01 | 3 | 0x09 | $ | 0x11 | " | 0x19 | ? |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 3 | 0x09 | $ | 0x11 | " | 0x19 | ? |'
- en: '| 0x02 | \n | 0x0A | 4 | 0x12 | ) | 0x1A | & |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | \n | 0x0A | 4 | 0x12 | ) | 0x1A | & |'
- en: '| 0x03 | - | 0x0B | '' | 0x13 | 2 | 0x1B | shift |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 0x03 | - | 0x0B | '' | 0x13 | 2 | 0x1B | shift |'
- en: '| 0x04 | space | 0x0C | , | 0x14 | # | 0x1C | . |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | space | 0x0C | , | 0x14 | # | 0x1C | . |'
- en: '| 0x05 | \a | 0x0D | ! | 0x15 | 6 | 0x1D | / |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 0x05 | \a | 0x0D | ! | 0x15 | 6 | 0x1D | / |'
- en: '| 0x06 | 8 | 0x0E | : | 0x16 | 0 | 0x1E | ; |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 0x06 | 8 | 0x0E | : | 0x16 | 0 | 0x1E | ; |'
- en: '| 0x07 | 7 | 0x0F | ( | 0x17 | 1 | 0x1F | letters |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0x07 | 7 | 0x0F | ( | 0x17 | 1 | 0x1F | letters |'
- en: Don’t try to make sense of the character mapping used in Baudot-Murray. If you’re
    pleased with the way ASCII codes are organized (refer to chapter 5), the text
    encoding shown in tables 8.2 and 8.3 is particularly baffling. Keep in mind that
    these codes were created for consistency with earlier systems. Perhaps some sense
    is to be found in the encoding. Who knows?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图理解Baudot-Murray中使用的字符映射。如果你对ASCII代码的排列方式感到满意（参考第5章），那么表8.2和8.3中显示的文本编码尤其令人困惑。记住，这些代码是为了与早期系统保持一致性而创建的。也许在编码中可以找到一些道理。谁知道呢？
- en: I was all excited to write a program that translates between ASCII and Baudot-Murray
    encoding. The problem with such translation is that the resulting code is pretty
    much brute force, a character-to-character swap. Mix in the shifting character
    sets, and such a programming chore becomes a nightmare with no practical purpose.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常兴奋地想写一个程序来在ASCII和Baudot-Murray编码之间进行转换。这种转换的问题在于生成的代码几乎是暴力破解，字符到字符的交换。再加上字符集的转换，这样的编程任务变成了一个没有实际目的的噩梦。
- en: 8.1.2 Evolving into ASCII text and code pages
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 发展为ASCII文本和代码页
- en: 'Beyond the Baudot-Murray code used on teletype machines, IBM invented a text-encoding
    standard for its mainframes: Extended Binary Coded Decimal Interchange Code (EBCDIC).
    This scheme was one of the first 8-bit character encoding standards, though it
    was used primarily with IBM mainframes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在电传打字机上使用的Baudot-Murray代码之外，IBM为其大型机发明了一种文本编码标准：扩展二进制编码十进制交换码（EBCDIC）。这个方案是第一个8位字符编码标准之一，尽管它主要用于IBM大型机。
- en: For input, IBM systems used punch cards. Therefore, the EBCDIC encoding scheme
    was designed to allocate codes for characters with the goal of keeping the punched
    holes in the card from collecting in clusters. This approach was necessary to
    prevent the cards from tearing or the holes from connecting with each other. To
    meet this goal, the EBCDIC codes feature gaps in their sequences; many EBCDIC
    character codes are blank.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入，IBM系统使用穿孔卡片。因此，EBCDIC编码方案被设计出来，目的是为字符分配代码，目的是防止卡片上的穿孔孔洞聚集在一起。这种方法是必要的，以防止卡片撕裂或孔洞相互连接。为了达到这个目标，EBCDIC代码在其序列中具有间隔；许多EBCDIC字符代码是空白的。
- en: As computing moved away from punch cards, throngs of programmers rejoiced. A
    new encoding standard—ASCII—was developed by the American Standards Association
    in 1963\. A 7-bit standard, ASCII added logic and—more important—compassion to
    text encoding.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着计算从穿孔卡片转向，众多程序员欢呼雀跃。美国标准协会于1963年开发了新的编码标准——ASCII。这是一个7位标准，ASCII增加了逻辑性——更重要的是——对文本编码的同情心。
- en: The 7-bit ASCII code is still in use today, though bytes today are consistently
    composed of 8 bits. This extra bit means that modern computers can encode 256
    characters for a byte of data, only half of which (codes 0 through 127) are standardized
    by ASCII.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 7位ASCII代码至今仍在使用，尽管今天的字节始终由8位组成。这个额外的位意味着现代计算机可以为字节的数据编码256个字符，其中只有一半（代码0至127）由ASCII标准化。
- en: You can read more about having fun with ASCII in chapter 4\. My focus in this
    section is about character codes 128 through 255, the so-called extended ASCII
    character set.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第4章中了解更多关于ASCII的乐趣。本节的重点是关于128至255的字符代码，所谓的扩展ASCII字符集。
- en: Extended ASCII was never an official standard, nor was it consistent among all
    8-bit computers. These extra 128 characters in a byte were mapped to non-ASCII
    characters on various microcomputers in the late 1970s and early 1980s. Having
    the codes available meant that more symbols could be generated on a typical computer,
    including common characters such as ×, ÷, ±, Greek letters, fractions, accented
    characters, diglyphs, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展ASCII从未成为官方标准，而且在所有8位计算机之间也不一致。在20世纪70年代末和80年代初，这些额外的128个字符在字节中被映射到各种微型计算机上的非ASCII字符上。代码的可用性意味着在典型的计算机上可以生成更多符号，包括常见的字符，如×、÷、±、希腊字母、分数、带重音的字符、双字母符号等。
- en: Figure 8.2 lists the extended ASCII character set available on the original
    IBM PC series of computers back in the early 1980s. Though the variety of characters
    is rich, these 128 bonus symbols weren’t enough to represent every available or
    desired character—only a tease.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2列出了20世纪80年代初原始IBM PC系列计算机上可用的扩展ASCII字符集。尽管字符种类丰富，但这些128个额外符号仍不足以代表所有可用或期望的字符——这只是个开头。
- en: '![08-02](Images/08-02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![08-02](Images/08-02.png)'
- en: Figure 8.2 The original IBM PC “extended ASCII” character set
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 原始IBM PC“扩展ASCII”字符集
- en: To accommodate more characters, early computers used code pages. A *code page*
    represents a different collection of characters, for both ASCII (codes 0 through
    127) and the 8-bit character codes, 128 to 255.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了容纳更多字符，早期的计算机使用了代码页。*代码页*代表一组不同的字符，包括ASCII（代码0至127）和8位字符代码，128至255。
- en: The characters shown in figure 8.2 for codes 128 through 255 represent IBM PC
    code page 437\. Other code pages use different symbols. Eventually code pages
    were made available for specific foreign languages and alphabetic. Chinese, Japanese,
    Arabic, and other character sets are featured on various code pages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2中显示的128至255代码字符代表IBM PC代码页437。其他代码页使用不同的符号。最终，为特定外国语言和字母表制作了代码页。中文、日文、阿拉伯文和其他字符集在各种代码页上都有特色。
- en: Commands available in the venerable MS-DOS operating system allowed code page
    character sets to be switched, though the computer was still limited to using
    only one code page of characters at a time. In the system configuration file (CONFIG.SYS),
    the COUNTRY command set locale details, including available code pages. At the
    command prompt, the CHCP command is used to check the current code page as well
    as change the character set to a new code page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在古老的MS-DOS操作系统中有可用的命令允许切换代码页字符集，尽管计算机仍然限制在每次只能使用一个代码页的字符。在系统配置文件（CONFIG.SYS）中，COUNTRY命令设置区域详细信息，包括可用的代码页。在命令提示符下，使用CHCP命令来检查当前代码页以及将字符集更改为新的代码页。
- en: Linux doesn’t use code pages, mostly because it implements Unicode (see the
    next section). Windows, however, still uses the same extended ASCII code page
    as the original IBM PC. You can view these legacy characters when a program outputs
    character code values from 128 through 255.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Linux不使用代码页，主要是因为它实现了Unicode（见下一节）。然而，Windows仍然使用与原始IBM PC相同的扩展ASCII代码页。当程序输出从128到255的字符代码值时，你可以查看这些遗留字符。
- en: The source code in the following listing generates the contents of figure 8.2\.
    The core of the program consists of nested for loops that output rows and columns
    representing the traditional extended ASCII character set, or code page 1\. Formatting
    within the *printf()* statements ensure that the output appears in a handy table.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的源代码生成了图8.2的内容。程序的核心由嵌套的for循环组成，输出代表传统扩展ASCII字符集或代码页1的行和列。*printf()*语句中的格式化确保输出以方便的表格形式出现。
- en: Listing 8.2 Source code for extended_ascii.c
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 extended_ascii.c的源代码
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Six spaces to line up output
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用六个空格对齐输出
- en: ❷ Output header row
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出标题行
- en: ❸ Output left column
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出左侧列
- en: ❹ Inner loop that outputs characters, x+y, calculating proper offset
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 内部循环输出字符，计算正确的偏移量 x+y
- en: The program generated by the extended_ascii.c source code works best on Windows
    computers. If you run it under Linux or on a Mac, the table is empty or populated
    with question marks. The characters aren’t missing; they just aren’t generated
    in the Linux/Unix environment unless a specific locale is set in the code. The
    topic of setting a locale is covered later in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由extended_ascii.c源代码生成的程序在Windows计算机上运行效果最佳。如果你在Linux或Mac上运行它，表格将是空的或填充着问号。字符并没有丢失；只是在Linux/Unix环境中没有生成，除非在代码中设置了特定的区域设置。这一主题将在本章后面讨论。
- en: The tasks of swapping code pages and exploring extended ASCII character sets
    are no longer required to generate fancy text. With the advent of Unicode in the
    1990s, all the text encoding inconsistencies since the early telegraph days are
    finally resolved.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 交换代码页和探索扩展ASCII字符集的任务不再需要来生成花哨的文本。随着20世纪90年代Unicode的出现，自早期电报时代以来的所有文本编码不一致性终于得到了解决。
- en: 8.1.3 Diving into Unicode
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 深入Unicode
- en: Back in the 1980s, those computer scientists who sat around thinking of wonderful
    new things to do hit the jackpot. They considered the possibilities of creating
    a consistent way to encode text—not just ASCII or Latin alphabet characters, but
    every scribble, symbol, and gewgaw known on this planet, both forward and backward
    in time. The result, unveiled in the 1990s, is Unicode.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回到20世纪80年代，那些坐在那里思考如何做些新奇事情的计算科学家们撞上了好运。他们考虑了创建一种一致的方式来编码文本的可能性——不仅限于ASCII或拉丁字母字符，而是这个星球上已知的所有涂鸦、符号和装饰品，无论是过去还是现在。结果在20世纪90年代揭晓，那就是Unicode。
- en: The original intention of Unicode was to widen character width from 8 bits to
    16 bits. This change doesn’t double the number of characters—it increases possible
    character encodings from 256 to over 65,000\. But even this huge quantity wasn’t
    enough.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode的原始目的是将字符宽度从8位扩展到16位。这种变化并没有将字符数量翻倍——它将可能的字符编码从256增加到超过65,000。但即使这个巨大的数量也不够。
- en: Today, the Unicode standard encompasses millions of characters, including hieroglyphics
    and emojis, a sampling of which is shown in figure 8.3\. New characters are added
    all the time, almost every year. For example, in 2021, 838 new characters were
    added.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Unicode标准包括数百万个字符，包括象形文字和表情符号，其中一部分在图8.3中展示。新字符不断被添加，几乎每年都在增加。例如，在2021年，添加了838个新字符。
- en: '![08-03](Images/08-03.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![08-03](Images/08-03.png)'
- en: Figure 8.3 Various Unicode characters
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3各种Unicode字符
- en: 'The current code space for Unicode (as of 2022) consists of 1,114,111 code
    points. *Code space* is the entire spectrum of Unicode. You can think of *code
    points* as characters. Not every code point has a character assigned, however:
    many chunks of the code space are empty. Some code points are designed as overlays
    or macrons to combine with other characters. Of the plethora, the first 128 code
    points align with the ASCII standard.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 Unicode（截至 2022 年）的代码空间由 1,114,111 个代码点组成。*代码空间*是整个 Unicode 的范围。你可以将*代码点*视为字符。然而，并非每个代码点都分配了字符：代码空间中的许多块是空的。一些代码点被设计为覆盖或长音符号，以与其他字符结合。在众多代码点中，前
    128 个代码点与 ASCII 标准相一致。
- en: Unicode characters are referenced in the format U+*nnnn*, where *nnnn* is the
    hexadecimal value for the code point. The code space is organized into code panes
    representing various languages or scripts. Most web pages that reference Unicode
    characters, such as [unicode-table.com](http://unicode-table.com), use these code
    planes or blocks when you browse the collection of characters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符以 U+*nnnn* 的格式引用，其中 *nnnn* 是代码点的十六进制值。代码空间被组织成代表各种语言或文字的代码面板。大多数引用
    Unicode 字符的网页，如 [unicode-table.com](http://unicode-table.com)，在浏览字符集合时使用这些代码平面或块。
- en: 'To translate from a Unicode code point—say, U+2665—into a character in C, you
    must adhere to an encoding format. The most beloved of these encoding formats
    is the Unicode Transformation Format, UTF. Several flavors of UTF exist:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Unicode 代码点——比如 U+2665——转换为 C 中的字符，你必须遵循一种编码格式。这些编码格式中最受欢迎的是 Unicode 转换格式，UTF。存在几种
    UTF 的变体：
- en: UTF-8 uses 8-bit chunks (bytes) to hold character values, with multiple bytes
    containing the code for some values. The number of bytes varies, but they’re all
    8-bit chunks.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-8 使用 8 位块（字节）来存储字符值，多个字节包含某些值的代码。字节数量不同，但它们都是 8 位块。
- en: UTF-16 uses 16-bit chunks (words) to hold character values. This format isn’t
    as popular as UTF-8.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-16 使用 16 位块（单词）来存储字符值。这种格式不像 UTF-8 那样受欢迎。
- en: UTF-32 uses 32-bit chunks (long words). All characters are represented by 32
    bits whether or not they need the storage space. This format isn’t that popular
    because it occupies more space than many code points require.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-32 使用 32 位块（长单词）。所有字符都由 32 位表示，无论它们是否需要存储空间。这种格式并不那么受欢迎，因为它占用的空间比许多代码点所需的更多。
- en: These encoding formats play a role with setting the locale, which is the key
    to working with Unicode text in C. More information on the locale is offered in
    section 8.2.1
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编码格式在设置区域设置时发挥作用，这是在 C 中处理 Unicode 文本的关键。有关区域设置的更多信息，请参阅第 8.2.1 节。
- en: The character itself is described as a *wide character*, or a character that
    may require more than a single byte to generate output. This topic is covered
    later in section 8.2.2.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 字符本身被描述为*宽字符*，或可能需要多个字节来生成输出的字符。这个主题将在第 8.2.2 节中介绍。
- en: Finally, be aware that not every typeface supports the entire Unicode host.
    Missing characters are output as blanks, question marks, or boxes, depending on
    the font. You may encounter this problem when running some of the programs later
    in this chapter. The solution is to set another font for the terminal window or
    to configure the terminal window so that it’s capable of outputting Unicode text.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，并非每种字体都支持整个 Unicode 字体集。缺失的字符将根据字体以空格、问号或方框的形式输出。当你运行本章后面的某些程序时，可能会遇到这个问题。解决方案是为终端窗口设置另一种字体，或者配置终端窗口，使其能够输出
    Unicode 文本。
- en: 8.2 Wide character programming
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 宽字符编程
- en: Just outputting a wide character to the console doesn’t work. You can try. Maybe
    you’ll be lucky, especially in Windows. But to properly output and program Unicode
    text in your C programs, you must first set the locale. This setting informs the
    computer that the program is capable of handling wide characters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 仅将宽字符输出到控制台是不行的。你可以尝试。也许你会幸运，尤其是在 Windows 上。但要正确地在你的 C 程序中输出和编程 Unicode 文本，你必须首先设置区域设置。这个设置通知计算机程序能够处理宽字符。
- en: After setting the locale, the code must access and use wide characters for its
    text I/O. This process is how some text mode programs output fancy Unicode characters
    in a terminal window—and how email messages and even text messages show emojis
    and other fun characters. Your program can do so as well, once you learn the steps
    introduced in this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置区域设置后，代码必须访问和使用宽字符进行其文本 I/O。这个过程是某些文本模式程序如何在终端窗口中输出花哨的 Unicode 字符，以及电子邮件消息甚至短信显示表情符号和其他有趣字符的方式。一旦你学会了本节中介绍的步骤，你的程序也可以做到这一点。
- en: 8.2.1 Setting the locale
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 设置区域
- en: Locale settings in a program establish such details as language, date and time
    format, currency symbol, and others specific to a language or region. This function
    and its pals allow you to write programs for different regions while being lazy
    about researching, for example, the culture’s thousands separator or currency
    symbol.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的区域设置确定诸如语言、日期和时间格式、货币符号等特定于语言或地区的详细信息。此功能和它的伙伴允许你在不深入研究，例如，文化中的千位分隔符或货币符号的情况下编写适用于不同地区的程序。
- en: For wide character output, setting the proper locale allows your code to use
    wide characters—the Unicode character set. Yes, setting the locale is the secret.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于宽字符输出，设置正确的区域允许你的代码使用宽字符——Unicode 字符集。是的，设置区域是秘密。
- en: 'To view the current locale settings in the Linux environment, type the locale
    command in the terminal window. Here is the output I see:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 环境中查看当前的区域设置，请在终端窗口中输入 locale 命令。以下是看到的输出：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The UTF-8 character format is what allows Unicode text I/O—though to enable
    UTF-8 output in your code, you must use the *setlocale()* function, prototyped
    in the locale.h header file. Here is the format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 字符格式是允许 Unicode 文本输入/输出的格式——尽管要在代码中启用 UTF-8 输出，你必须使用在 locale.h 头文件中声明的
    *setlocale()* 函数。以下是格式：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first argument, category, is a defined constant representing which aspect
    of the locale you want to set. Use LC_ALL to set all categories. The LC_CTYPE
    category is specific to text.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，类别，是一个定义的常量，表示你想要设置的区域哪个方面。使用 LC_ALL 来设置所有类别。LC_CTYPE 类别专门用于文本。
- en: The second argument is a string to set the specific locale details. For example,
    for text you can specify "en_US.UTF-8", which activates the 8-bit Unicode character
    set for English. An empty string can also be specified.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是要设置的特定区域详细信息的字符串。例如，对于文本，你可以指定 "en_US.UTF-8"，这将激活英语的 8 位 Unicode 字符集。也可以指定一个空字符串。
- en: The *setlocale()* function returns a string representing the specific information
    requested. You need not use the string; setting the locale is good enough for
    wide character I/O.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*setlocale()* 函数返回一个表示请求的特定信息的字符串。你不需要使用该字符串；设置区域对于宽字符输入/输出就足够了。'
- en: Be aware that the *setlocale()* function isn’t available in some Windows compilers.
    The method for accessing Unicode characters in Windows is different from what’s
    described in this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*setlocale()* 函数在某些 Windows 编译器中不可用。在 Windows 中访问 Unicode 字符的方法与本章中描述的不同。
- en: The next listing shows a tiny program that uses the *setlocale()* function to
    output locale details—specifically, the character set in use. Line 8 uses the
    *setlocale()* function to return a string describing the current locale, saved
    in variable locale. A *printf()* statement outputs the locale string. Used in
    this way, the *setlocale()* function doesn’t change the locale settings; it only
    reports information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了一个使用 *setlocale()* 函数输出区域详细信息的微小程序——特别是正在使用的字符集。第 8 行使用 *setlocale()*
    函数返回一个描述当前区域的字符串，保存在变量 locale 中。一个 *printf()* 语句输出了区域字符串。以这种方式使用，*setlocale()*
    函数不会更改区域设置；它只报告信息。
- en: Listing 8.3 Source code for locale_function.c
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 locale_function.c 的源代码
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The *setlocale()* function requires the locale.h header file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *setlocale()* 函数需要 locale.h 头文件。
- en: ❷ Pointer to a string to retain the function’s output
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指向字符串的指针以保留函数的输出
- en: ❸ Synchronizes the GPU so that the work completes
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同步 GPU 以完成工作
- en: ❹ Outputs the locale details
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出区域详细信息
- en: 'Here is sample output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The C stands for the C language. If it doesn’t, it should. UTF-8 is the character
    encoding.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: C 代表 C 语言。如果不是，它应该是。UTF-8 是字符编码。
- en: After setting the locale, the next step to outputting Unicode characters is
    to understand the concept of wide characters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置区域后，输出 Unicode 字符的下一步是理解宽字符的概念。
- en: 8.2.2 Exploring character types
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 探索字符类型
- en: 'To invoke the magic that enables access to Unicode’s humongous character set,
    you must be familiar with the three types of characters used in computerdom:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用访问 Unicode 的巨大字符集的魔法，你必须熟悉计算机领域使用的三种字符类型：
- en: Single-byte characters
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单字节字符
- en: Wide characters
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽字符
- en: Multibyte characters
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多字节字符
- en: Single-byte characters provide the traditional way to generate text. These are
    8-bit values, the *char* data type, equal to a single byte of storage. Though
    *char* values range from 0 through 255 (unsigned), only values 0 through 127 are
    assigned characters using the ASCII standard.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 单字节字符提供了生成文本的传统方式。这些是8位值，*char*数据类型，等于一个字节的存储空间。尽管*char*值的范围从0到255（无符号），但只有0到127的值使用ASCII标准分配了字符。
- en: The wide character data type uses more than 8-bits to encode text. The number
    of bytes can vary, depending on the character. In C, the *wchar_t* data type handles
    wide characters, and the wide character (wchar) family of functions manipulates
    these characters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 宽字符数据类型使用超过8位来编码文本。字节数可能因字符而异。在C中，*wchar_t*数据类型处理宽字符，而宽字符（wchar）函数族操作这些字符。
- en: A multibyte character requires several bytes to represent the character. This
    description includes wide characters but also characters that require a prefix
    byte, or lead unit, and then another sequence of bytes to represent a single character.
    This type of multibyte character may be used in specific applications and computer
    platforms. It’s not covered in this book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 多字节字符需要几个字节来表示一个字符。这个描述包括宽字符，但也包括需要前缀字节或引导单元，然后是另一个字节序列来表示单个字符的字符。这种多字节字符可能用于特定的应用程序和计算机平台。本书不涉及此类内容。
- en: 'To represent a single-byte character, you use the *char* data type in C. For
    example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示单字节字符，你使用C中的*char*数据类型。例如：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The hash character is assigned to *char* variable hash. The character code is
    35 decimal, 23 hex.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希字符被分配给*char*变量hash。字符代码是35十进制，23十六进制。
- en: To represent wide characters, use the *wchar_t* data type. Its definition is
    found in the wchar.h header file, which must be included in your code. This header
    file also prototypes the various wide character functions. (See the next section.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示宽字符，请使用*wchar_t*数据类型。其定义可以在wchar.h头文件中找到，必须在你的代码中包含此头文件。此头文件还原型化了各种宽字符函数。（见下一节。）
- en: 'The following statement declares the wide character yen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句声明了宽字符yen：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Yen character ¥ is U+00a5\. This value is assigned to *wchar_t* variable
    yen. The compiler won’t let you assign the character directly:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 日元字符¥是U+00a5。这个值被分配给*wchar_t*变量yen。编译器不会让你直接分配字符：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The L prefix defines the character as long (wide). This prefix works like the
    L suffix applied to *long* integer values: 123L indicates the value 123 specified
    as a *long int* value. Although this L-prefix trick works with ASCII characters
    expressed as wide characters, your C compiler most likely chokes on the attempt
    to compile with such a character in the source code file; the warning I see is
    “Illegal character encoding.” Your editor also may not allow you to type or paste
    wide characters directly.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: L前缀将字符定义为长（宽）。这个前缀的作用类似于应用于*long*整数值的L后缀：123L表示123作为一个*long int*值指定的值。虽然这个L前缀技巧可以与表示为宽字符的ASCII字符一起工作，但你的C编译器很可能在尝试编译包含此类字符的源代码文件时失败；我看到的警告是“非法字符编码。”你的编辑器也可能不允许你直接输入或粘贴宽字符。
- en: 'The L prefix is also used to declare a wide character string. Here is a wide
    character string:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: L前缀也用于声明宽字符字符串。以下是一个宽字符字符串的例子：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The string above, "Hello, planet Earth!", is composed of wide characters, thanks
    to the L prefix. The *wchar_t* data type declares wide string howdy.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的字符串“Hello, planet Earth!”由宽字符组成，归功于L前缀。*wchar_t*数据类型声明了宽字符串howdy。
- en: 'As with single characters, you cannot insert special characters into a wide
    string. The following declaration is flagged as illegal character encoding:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与单字符一样，你不能在宽字符串中插入特殊字符。以下声明被标记为非法字符编码：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Such a string is instead composed in this manner:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的字符串可以这样组成：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Hex values above represent the characters dollar sign, yen, euro, and British
    pound, followed by the null character caboose to terminate the string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述十六进制值代表美元符号、日元、欧元和英镑字符，之后跟着空字符作为字符串的终止符。
- en: 'To output wide characters and wide strings, use the w*printf()* function. This
    function works like the standard library *printf()* function, though it deals
    with wide strings. Special placeholders are used for wide characters and wide
    strings:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出宽字符和宽字符串，请使用w*printf()*函数。这个函数与标准库的*printf()*函数类似，但它处理宽字符串。宽字符和宽字符串使用特殊的占位符：
- en: The %lc placeholder represents a single wide character.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%lc占位符代表一个宽字符。'
- en: The %ls placeholder represents a wide string.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%ls占位符代表宽字符串。'
- en: Lowercase L in the placeholder identifies the target variable as the wide or
    *wchar_t* data type. This character is analogous to the little L in the %ld placeholder
    for long decimal integer values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符中的小写 L 识别目标变量为宽字符或 *wchar_t* 数据类型。这个字符类似于 %ld 占位符中的小 L，用于表示长十进制整数值。
- en: 8.2.3 Generating wide character output
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 生成宽字符输出
- en: To output wide characters in C, you employ the functions declared in the wchar.h
    header file, which also conveniently defines the *wchar_t* data type. The functions
    parallel the standard string functions (from string.h), with most companion functions
    prefixed by a w or some other subtle difference. For example, the wide character
    version of *printf()* is *wprintf()*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C 中输出宽字符，你将使用在 wchar.h 头文件中声明的函数，该头文件还方便地定义了 *wchar_t* 数据类型。这些函数与标准字符串函数（来自
    string.h）平行，大多数伴随函数以 w 或其他细微差异为前缀。例如，宽字符版本的 *printf()* 是 *wprintf()*。
- en: Oh, and you need the locale.h header file because the wide character functions
    must be activated by first setting the locale. Refer to section 8.2.1 for details
    on using the *setlocale()* function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，你还需要 locale.h 头文件，因为宽字符函数必须首先设置区域设置才能激活。有关使用 *setlocale()* 函数的详细信息，请参阅第 8.2.1
    节。
- en: The next listing shows source code that uses the *wprintf()* function in the
    traditional “Hello, world!” type of program, with my own wide twist. The *setlocale()*
    function isn’t required because the output is ASCII, albeit wide ASCII, which
    is why the *wprintf()* formatting string is prefixed by an L (long, or wide character).
    The *stdio.h* header isn’t required because none of its functions appear in the
    code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了使用 *wprintf()* 函数的传统“Hello, world!”类型程序源代码，并加入了我自己的宽字符处理。由于输出是ASCII，尽管是宽ASCII，因此不需要
    *setlocale()* 函数。*stdio.h* 头文件也不需要，因为代码中没有使用其任何函数。
- en: Listing 8.4 Source code for hello_wworld01.c
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 hello_wworld01.c 的源代码
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Wide character definitions and functions
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 宽字符定义和函数
- en: ❷ The w*printf()* function is analogous to the *printf()* function. The L prefix
    is required for a string composed of wide characters. Even though the text here
    is ASCII, wide characters are used internally to represent the text.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ w*printf()* 函数类似于 *printf()* 函数。对于由宽字符组成的字符串，需要 L 前缀。尽管这里的文本是 ASCII，但内部使用宽字符来表示文本。
- en: 'Here is the program’s output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nothing surprising, but don’t let the lack of suspense lull you into a false
    sense of familiarity. To help ease you into the wide character functions, you
    can modify the code in two steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么令人惊讶的，但不要让缺乏悬念让你产生错误的熟悉感。为了帮助你轻松地使用宽字符函数，你可以分两步修改代码。
- en: 'First, set the string as its own declaration earlier in the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在代码中较早的位置将字符串设置为它的声明：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The *wchar_t* data type defines array hello[] composed of characters present
    in the wide string. If the L prefix is omitted, the compiler barfs up a data type
    mismatch error. Yes, it’s an error: the code won’t compile. To create a wide string,
    you need both the *wchar_t* data type and the L prefix on the text enclosed in
    double quotes.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*wchar_t* 数据类型定义了一个由宽字符串中的字符组成的数组 hello[]。如果省略 L 前缀，编译器会抛出一个数据类型不匹配错误。是的，这是一个错误：代码无法编译。要创建宽字符串，你需要
    *wchar_t* 数据类型和双引号中包含的文本上的 L 前缀。'
- en: 'Second, modify the *wprintf()* statement to output the string:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，修改 *wprintf()* 语句以输出字符串：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The L prefix is required for the formatting string, because all wide character
    functions deal with wide characters. The %ls placeholder represents a string of
    wide characters. Argument hello references the address of the wide hello[] array.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化字符串需要 L 前缀，因为所有宽字符函数都处理宽字符。%ls 占位符代表一个宽字符字符串。参数 hello 引用了宽字符 hello[] 数组的地址。
- en: These two updates to the hello_wworld01.c code are found in the online repository
    in the source code file hello_wworld02.c. The output is the same as from the first
    program.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对 hello_wworld01.c 代码的更新可以在在线存储库中的源代码文件 hello_wworld02.c 中找到。输出与第一个程序相同。
- en: To output a single wide character, use the *putwchar()* function. It works like
    putchar(), and it’s one of several wide character functions where the w is found
    in the middle of its name.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出单个宽字符，使用 *putwchar()* 函数。它的工作方式类似于 putchar()，并且是几个以 w 开头的宽字符函数之一。
- en: 'The code in the next listing outputs the four playing card suits: spades, hearts,
    clubs, and diamonds. Their Unicode values are assigned as elements of the suits[]
    array. The *setlocale()* function is required because these are not ASCII characters.
    Within the *for* loop, the *putwchar()* function outputs the characters. A final
    *putwchar()* function outputs a newline—a wide newline.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的代码输出四个扑克牌花色：黑桃、红心、梅花和方块。它们的Unicode值被分配为suits[]数组的元素。需要*setlocale()*函数，因为这些不是ASCII字符。在for循环中，*putwchar()*函数输出字符。最后的*putwchar()*函数输出一个换行符——宽换行符。
- en: Listing 8.5 Source code for suits.c
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 suits.c的源代码
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Unicode values for the four playing card suits
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 四个扑克牌花色的Unicode值
- en: ❷ The locale is set because these are not ASCII characters.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置区域设置，因为这些不是ASCII字符。
- en: ❸ The putwchar() function outputs each wide character value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ putwchar()函数输出每个宽字符值。
- en: 'Here is the code’s output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出：
- en: ♠♥♣♦
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ♠♥♣♦
- en: On my Linux systems, the output is monochrome. But on my Macintosh, the hearts
    and diamonds symbols are colored red. This difference is based on the font used.
    The Mac seems to have a better selection of Unicode characters available in its
    terminal window than are available in my Linux distro.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '在我的Linux系统中，输出是单色的。但在我的Macintosh上，红心和方块符号是红色的。这种差异基于所使用的字体。Mac似乎在其终端窗口中提供了比我的Linux发行版更好的Unicode字符选择。 '
- en: The code for suits.c illustrates how many Unicode strings are created and then
    output. The technique for creating the suits[] array is how you build a wide character
    string from scratch, though suits[] is a character array and not a string, which
    must be terminated with the null character.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: suits.c的代码示例说明了创建了多个Unicode字符串并输出。创建suits[]数组的技术是如何从头开始构建宽字符字符串，尽管suits[]是一个字符数组而不是字符串，它必须以空字符结尾。
- en: In the following listing, three Unicode strings are declared in the *main()*
    function. Each one ends with newline and null characters. The *fputws()* function
    sends the strings as the output to the *stdout* device (file handle, defined in
    stdio.h). This function is the equivalent of the *fputs()* function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，在*main()*函数中声明了三个Unicode字符串。每个字符串都以换行符和空字符结尾。*fputws()*函数将字符串作为输出发送到*stdout*设备（文件句柄，在stdio.h中定义）。这个函数与*fputs()*函数等效。
- en: Listing 8.6 Source code for wide_hello.c
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 wide_hello.c的源代码
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Required for the definition of *stdout*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义*stdout*所需的
- en: ❷ Each array is created as a string, including the newline and null characters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个数组都创建为一个字符串，包括换行符和空字符。
- en: ❸ The fputws() function requires a wide string and file handle as arguments.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ fputws()函数需要一个宽字符串和文件句柄作为参数。
- en: Figure 8.4 shows the output generated by the wide_hello.c program. This screenshot
    is from my Macintosh, where the Terminal app properly generates all the Unicode
    characters. The output looks similar in Linux, though under Windows 10 Ubuntu
    Linux, only the Cyrillic text is output; the rest of the text appears as question
    marks in boxes. These generic characters mean that the Unicode characters shown
    in figure 8.4 are unavailable in the terminal’s assigned typeface.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4显示了wide_hello.c程序生成的输出。这个截图来自我的Macintosh，其中终端应用程序正确地生成了所有Unicode字符。在Linux中输出看起来相似，但在Windows
    10 Ubuntu Linux中，只有西里尔文文本被输出；其余文本以方框中的问号出现。这些通用字符意味着图8.4中显示的Unicode字符在终端的指定字体中不可用。
- en: '![08-04](Images/08-04.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![08-04](Images/08-04.png)'
- en: Figure 8.4 The properly interpreted output of the wide_hello.c program
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 wide_hello.c程序的适当解释输出
- en: The inability of some typefaces to properly render portions of the Unicode character
    set is something you should always consider when coding wide text output.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字体无法正确渲染Unicode字符集的部分，这是你在编码宽文本输出时应该始终考虑的问题。
- en: Not every string you output requires all wide text characters, such as those
    strings shown in listing 8.6\. In fact, most often you may find a single character
    required in a string of otherwise typable, plain ASCII text. One way to sneak
    such a character into a string is demonstrated next. Here, the Yen character (¥)
    is declared on its own as *wchar_t* variable yen. This value is output in the
    *wprintf()* function by using the %lc placeholder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 并非你输出的每个字符串都需要所有宽字符文本字符，例如列表8.6中显示的字符串。实际上，你通常可能只在一个可打印的普通ASCII文本字符串中找到一个字符。下面演示了一种将此类字符偷偷放入字符串的方法。在这里，日元字符（¥）被声明为一个单独的*wchar_t*变量yen。这个值通过使用%lc占位符在*wprintf()*函数中输出。
- en: Listing 8.7 Source code for yen01.c
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 yen01.c的源代码
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The character is specified by its Unicode value, U-00A5.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 字符由其Unicode值指定，U-00A5。
- en: ❷ The %lc placeholder represents the wide character value in yen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ %lc占位符表示yen中的宽字符值。
- en: 'Here is the code’s output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的输出：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the code, I set the locale LC_CTYPE value to en_US.UTF-8, which is proper
    for the English language as it’s abused in the United States. You don’t need to
    set the Japanese locale (ja_JP.UTF-8) to output the character.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我将LC_CTYPE区域设置值设置为en_US.UTF-8，这对于英语语言是合适的，因为它在美国被广泛使用。你不需要设置日语区域设置（ja_JP.UTF-8）来输出字符。
- en: Another way to insert a non-ASCII Unicode character in a string is substitution.
    For example, you can create a wide character string of ASCII text, then plop in
    a specific character before the string is output.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中插入非ASCII Unicode字符的另一种方法是替换。例如，你可以创建一个ASCII文本的宽字符字符串，然后在字符串输出之前插入一个特定的字符。
- en: 'To modify listing 8.7, first you create a wide character string with a placeholder
    for the untypable Unicode character:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改列表8.7，首先创建一个包含不可输入Unicode字符占位符的宽字符字符串：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At element 13 in wide character string s[], I’ve used a dollar sign instead
    of the Yen sign I need. The next step is to replace this element with the proper
    wide character:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在宽字符字符串s[]的第13个元素中，我使用美元符号代替我需要的日元符号。下一步是将此元素替换为正确的宽字符：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This assignment works because all characters in string s[] are wide. Character
    code 0xa5 replaces the dollar sign. The string is then output with this statement:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务之所以有效，是因为字符串s[]中的所有字符都是宽字符。字符代码0xa5替换了美元符号。然后使用此语句输出字符串：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This update to the code is named yen02.c, and it’s found in this book’s online
    repository. If you perform a trick like this, ensure that you properly document
    what value 0xa5 is, so as not to confuse any other programmers who may later examine
    your code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更新被命名为yen02.c，并可在本书的在线仓库中找到。如果你进行这种技巧，确保正确记录0xa5的值，以免混淆可能后来检查你代码的其他程序员。
- en: Exercise 8.1
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.1
- en: 'Using the method described earlier, and available in the source code file yen02.c,
    substitute a Unicode (untypable) character in a string. Create a program that
    outputs this text:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面描述的方法，并在源代码文件yen02.c中可用，在字符串中替换一个Unicode（不可输入）字符。创建一个输出以下文本的程序：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Unicode value for the heart symbol is U+2665, shown earlier in the suits.c
    source code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 心形符号的Unicode值是U+2665，在suits.c源代码中之前已显示。
- en: My solution is available in the online repository as code_love.c.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案作为code_love.c在在线仓库中可用。
- en: 8.2.4 Receiving wide character input
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 接收宽字符输入
- en: Wide character input functions are prototyped in the wchar.h header file along
    with their output counterparts, covered in the preceding section. Like the wide
    character output functions, these input functions parallel those of standard input.
    For example, the *getwchar()* function receives wide character input just as the
    *getchar()* function receives normal character input. Or should it be called thin
    character input?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 宽字符输入函数在wchar.h头文件中定义，与它们的输出对应函数一起，在上一节中已介绍。与宽字符输出函数一样，这些输入函数与标准输入函数平行。例如，*getwchar()*函数接收宽字符输入，就像*getchar()*函数接收普通字符输入一样。或者应该称之为瘦字符输入？
- en: The tricky part about wide character input is how to generate the wide characters.
    Standard keyboard input works as it always does—the characters interpreted as
    their wide values. Some keyboards have Unicode character keys, such as the £ or
    € symbols. Check to see whether your Linux terminal program allows for fancy character
    input methods, often from a right-click menu. When these tools aren’t available
    to you, the only trick left is to copy and paste Unicode characters from elsewhere,
    such as a web page or the output of some Unicode-happy application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 宽字符输入的难点在于如何生成宽字符。标准键盘输入像往常一样工作——字符被解释为其宽值。一些键盘有Unicode字符键，例如£或€符号。检查你的Linux终端程序是否允许使用花哨的字符输入方法，通常可以通过右键菜单进行。当这些工具对你不可用时，剩下的唯一技巧是从其他地方复制和粘贴Unicode字符，例如网页或某些Unicode友好的应用程序的输出。
- en: The source code for mood.c is shown in the following listing. It uses the *getwchar()*
    function to process standard input, including wide characters. The single-character
    input is echoed back in the *wprintf()* statement. The %lc placeholder represents
    *wchar_t* variable mood.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: mood.c的源代码如下所示。它使用*getwchar()*函数处理标准输入，包括宽字符。单字符输入在*wprintf()*语句中被回显。%lc占位符代表*wchar_t*变量mood。
- en: Listing 8.8 Source code for mood.c
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 mood.c的源代码
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The single wide character variable mood holds input.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 单个宽字符变量 mood 持有输入。
- en: ❷ This string is ASCII, but the L prefix makes it composed of wide characters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个字符串是 ASCII 编码的，但 L 前缀使其由宽字符组成。
- en: ❸ Obtains a wide character from standard input and stores it in wchar_t variable
    mood
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从标准输入获取宽字符并将其存储在 wchar_t 变量 mood 中
- en: ❹ The %lc placeholder represents wide character mood.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ %lc 占位符代表宽字符 mood。
- en: 'The program created by mood.c reads from standard input, though any text you
    type is represented internally by using wide characters. Therefore, the program
    runs whether you type a Unicode character or any other keyboard character, as
    in this example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由 mood.c 创建的程序从标准输入读取，尽管你输入的任何文本在内部都使用宽字符表示。因此，无论你输入的是 Unicode 字符还是任何其他键盘字符，程序都会运行，如下例所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The true test, however, is to type a Unicode character, specifically an emoji.
    With some versions of Linux (not the Windows version), you can right-click (or
    control-click) in the terminal window to access emoji characters for input.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正的测试是输入一个 Unicode 字符，特别是表情符号。在某些 Linux 版本中（不是 Windows 版本），你可以在终端窗口中右键单击（或控制单击）以访问输入表情符号字符。
- en: In Windows, press the Windows and period keys on the keyboard to bring up an
    emoji palette. This trick works in the Ubuntu Linux shell window.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，按键盘上的 Windows 和点号键来弹出表情符号调色板。这个技巧在 Ubuntu Linux 的 shell 窗口中也有效。
- en: On the Macintosh, press the Ctrl+Command+Space keyboard shortcut to see a pop-up
    emoji palette, as shown in figure 8.5\. From this palette, you can choose an emoji
    to represent your mood, which then appears in the output string.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Macintosh 上，按 Ctrl+Command+Space 键盘快捷键可以看到一个弹出表情符号调色板，如图 8.5 所示。从该调色板中，你可以选择一个表情符号来代表你的心情，然后它就会出现在输出字符串中。
- en: '![08-05](Images/08-05.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![08-05](Images/08-05.png)'
- en: Figure 8.5 Using the Macintosh emoji input panel in the Terminal app
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 在终端应用中使用 Macintosh 表情符号输入面板
- en: As a last resort, you can copy and paste the desired character from another
    program or website. Providing that the terminal window’s typeface has the given
    character, it appears in the program’s output.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的手段，你可以从另一个程序或网站上复制并粘贴所需的字符。只要终端窗口的字型有该字符，它就会出现在程序的输出中。
- en: The *getwchar()* function deals with stream input the same way that *getchar()*
    does; it’s not an interactive function. Review chapter 4 for information on stream
    I/O in C. The same rules apply to wide characters as they do to the standard *char*
    data type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*getwchar()* 函数以与 *getchar()* 相同的方式处理流输入；它不是一个交互式函数。请参阅第 4 章以获取有关 C 中流 I/O
    的信息。对于宽字符，规则与标准 *char* 数据类型相同。'
- en: 'To read more than a single character, use the *fgetws()* function. This function
    is the wide character version of *fgets()*, with a similar set of arguments. Here
    is the *man* page format:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取多个字符，请使用 *fgetws()* 函数。这个函数是 *fgets()* 的宽字符版本，具有类似的参数集。以下是 *man* 页面的格式：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first argument is a *wchar_t* buffer to store input. Then comes the buffer
    size, which is the input character count minus one for the null character, which
    is automatically added, and finally, the file stream, such as stdin for standard
    input.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个 *wchar_t* 缓冲区，用于存储输入。然后是缓冲区大小，这是输入字符数减去一个空字符（自动添加），最后是文件流，例如 stdin
    用于标准输入。
- en: The *fgetws()* function returns the buffer’s address upon success or NULL otherwise.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*fgetws()* 函数在成功时返回缓冲区的地址，否则返回 NULL。'
- en: The source code for wide_string_in.c, illustrated in the next listing, shows
    how the *fgetws()* function is used. The wide character buffer input stores wide
    characters read from the standard input device (stdin). A *wprintf()* function
    outputs the characters stored in the input buffer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中展示的 wide_string_in.c 的源代码说明了如何使用 *fgetws()* 函数。宽字符缓冲区输入存储从标准输入设备（stdin）读取的宽字符。*wprintf()*
    函数输出存储在输入缓冲区中的字符。
- en: Listing 8.9 Source code for wide_in.c
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 wide_in.c 的源代码
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Required for the definition of *stdin*
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于定义 *stdin* 是必需的
- en: ❷ Uses a constant to set the buffer size
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用常量设置缓冲区大小
- en: ❸ Wide character input buffer
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 宽字符输入缓冲区
- en: ❹ Reads the size characters into the input buffer from standard input
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从标准输入将大小字符读入输入缓冲区
- en: ❺ Uses the %ls placeholder to output the wide character string
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 %ls 占位符输出宽字符字符串
- en: 'The program created from the wide_in.c source code works like any basic I/O
    program—something you probably wrote when you first learned to program C. The
    difference is that wide characters are read, stored, and output. So, you can get
    fancy with your text, as shown in this sample run:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从 wide_in.c 源代码创建的程序就像任何基本的 I/O 程序一样工作——这可能是你第一次学习 C 语言编程时编写的。区别在于读取、存储和输出的是宽字符。因此，你可以让你的文本变得复杂，如下面的示例运行所示：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As with standard input and the *fgets()* function, the newline character is
    retained in the input string. You see its effect on the output where the final
    single quote appears on the following line.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准输入和 *fgets()* 函数一样，换行符会保留在输入字符串中。你可以在输出中看到它的效果，最后的单引号出现在下一行。
- en: Another wide input function I reluctantly want to cover is *wscanf()*. This
    function is based on *scanf()*, which is perhaps my least favorite C language
    input function, though it does have its purposes. Still, the function is a booger
    to work with because you must get the input data just right or else the thing
    collapses like a professional soccer player with a hangnail.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我不情愿要介绍的宽输入函数是 *wscanf()*. 这个函数基于 *scanf()*，这可能是我最不喜欢的 C 语言输入函数，尽管它有其用途。然而，这个函数很难处理，因为你必须恰好获取输入数据，否则它就像一个有倒刺的专业足球运动员一样崩溃。
- en: 'Here is the man page for *wscanf()*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于 *wscanf()* 的手册页：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This format is identical to that of the *scanf()* function, though the formatting
    string (the first argument) is composed of wide characters. If you use this function,
    you will probably forget the L prefix on the formatting string at least once or
    twice.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式与 *scanf()* 函数相同，尽管格式化字符串（第一个参数）由宽字符组成。如果你使用这个函数，你可能会至少一次或两次忘记格式化字符串上的 L
    前缀。
- en: Listing 8.10 shows a silly I/O program, one that I may use in a beginner’s programming
    book. The only Unicode character involved is the British pound sign (£), which
    is declared early in the code. Otherwise, pay attention to how the *wscanf()*
    function uses the L prefix for its formatting string. All the statements output
    wide characters. Input can be in wide characters as well, though only ASCII digits
    0 through 9 hold any meaning to the code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 展示了一个愚蠢的 I/O 程序，我可能在初学者编程书中使用它。涉及的唯一 Unicode 字符是英镑符号 (£)，它在代码的早期被声明。否则，请注意
    *wscanf()* 函数如何使用 L 前缀来指定格式化字符串。所有语句都输出宽字符。输入也可以是宽字符，尽管只有 ASCII 数字 0 到 9 对代码有实际意义。
- en: Listing 8.10 Source code for wscanf.c
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 wscanf.c 的源代码
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ The pound character is defined as a *wchar_t* constant.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 英镑字符被定义为 *wchar_t* 常量。
- en: ❷ Just like a *scanf()* statement, but with a wide character formatting string
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 就像 *scanf()* 语句一样，但使用宽字符格式化字符串
- en: ❸ Random math, just to have the code do something
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 随机数学，只是为了让代码做些事情
- en: ❹ The %lc placeholder outputs the pound symbol; %.2f formats the amount to two
    decimal places.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `%lc` 占位符输出英镑符号；`%.2f` 将金额格式化为两位小数。
- en: 'Here is a sample run:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: They must be very nice crisps.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它们必须是很好吃的薯片。
- en: Exercise 8.2
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.2
- en: Source code file wide_in.c (listing 8.9) processes a string of input. But when
    the string is shorter than the maximum number of characters allowed, the newline
    is retained in the string. Your task is to modify the source code so that any
    newline in the string is removed from output.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码文件 wide_in.c（列表 8.9）处理输入字符串。但是当字符串的长度小于允许的最大字符数时，换行符会保留在字符串中。你的任务是修改源代码，以便从输出中移除字符串中的任何换行符。
- en: One way to accomplish this task is to write your own output function. That’s
    too easy. Instead, you must create a function that removes the newline added by
    the *fgetws()* function, effectively trimming the string.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个任务的其中一种方法是你编写自己的输出函数。这太简单了。相反，你必须创建一个函数，该函数可以移除由 *fgetws()* 函数添加的换行符，从而有效地裁剪字符串。
- en: My solution is available in this book’s online repository as wide_in_better.c.
    Please try this exercise on your own before you sneak a peek at my solution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案可以在本书的在线仓库中找到，名为 wide_in_better.c。请在查看我的解决方案之前，先自己尝试这个练习。
- en: 8.2.5 Working with wide characters in files
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.5 在文件中处理宽字符
- en: The wchar.h header file also defines wide character equivalents of file I/O
    functions available in the standard C library—for example, *fputwc()* to send
    a wide character to a stream, the equivalent of *fputc()*. These wide character
    functions are paired with the standard library file I/O functions, such as *fopen()*.
    This mixture creates an exciting pastiche of wide and nonwide characters, so mind
    your strings!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: wchar.h 头文件还定义了标准 C 库中可用的宽字符文件 I/O 函数的宽字符等效函数——例如，*fputwc()* 将宽字符发送到流中，相当于 *fputc()*.
    这些宽字符函数与标准库文件 I/O 函数配对，如 *fopen()*. 这种混合创造了一个激动人心的宽字符和非宽字符的混合，所以要注意你的字符串！
- en: As with standard I/O, your wide character file functions must set the locale.
    The file must be opened for reading, writing, or both. Wide character file I/O
    functions are used to put and get text from the file. The WEOF constant is used
    to identify the wide end-of-file character, *wint_t* data type. Once the file
    activity is done, the file is closed. This operation should be familiar to you
    if you’ve worked with file I/O in C.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准 I/O 一样，你的宽字符文件函数必须设置区域设置。文件必须以读取、写入或两者兼有的方式打开。宽字符文件 I/O 函数用于从文件中获取和放置文本。WEOF
    常量用于标识宽字符文件结束符，*wint_t* 数据类型。一旦文件活动完成，文件就会被关闭。如果你在 C 中处理过文件 I/O，这个操作应该很熟悉。
- en: 'As an example, consider code to output the 24 uppercase letters of the Greek
    alphabet, alpha to omega, Α (U+0391) to Ω (U+03A9), saving the alphabet to a file.
    The Unicode values increment successively for each letter, though a blank spot
    exists at code U+03A2\. These values parallel the lowercase Greek alphabet, which
    starts at U+03B1\. The uppercase blank spot keeps the upper- and lowercase values
    parallel, as two lowercase sigma characters are used in Greek. These Unicode values
    are represented by constants within the code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑输出希腊字母表的 24 个大写字母（alpha 到 omega，Α (U+0391) 到 Ω (U+03A9)），并将字母表保存到文件中的代码。Unicode
    值逐个递增，尽管存在空白区域 U+03A2。这些值与小写希腊字母表平行，它从 U+03B1 开始。大写空白区域保持了大小写值的平行，因为在希腊语中使用了两个小写
    sigma 字符。这些 Unicode 值在代码中通过常量表示：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After the file is created, the uppercase Greek characters are written to the
    file one at a time, using a *for* loop as shown in the next listing. Constants
    alpha and omega represent the first and last characters’ Unicode values. The *wchar_t*
    constant no_sigma is used in an *if* test with the loop so that its character
    (U+03A2, which is blank) is skipped.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '文件创建后，大写希腊字符逐个写入文件，使用下一个列表中显示的 *for* 循环。常量 alpha 和 omega 代表第一个和最后一个字符的 Unicode
    值。*wchar_t* 常量 no_sigma 在循环中的 *if* 测试中使用，以便跳过其字符（U+03A2，即空白）。 '
- en: Listing 8.11 A loop that writes the uppercase Greek alphabet to a file
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 将大写希腊字母写入文件的循环
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Lets the user know what’s going on
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通知用户正在发生的事情
- en: ❷ Loops through the Greek alphabet
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历希腊字母表
- en: ❸ Tests for the blank spot and . . .
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试空白区域和 ...
- en: ❹ . . . skips over this noncharacter, continuing the loop
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ ... 跳过这个非字符，继续循环
- en: ❺ Writes the Greek letter to the file (*FILE* pointer fp)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将希腊字母写入文件（*FILE* 指针 fp）
- en: ❻ Also sends the character to standard output
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 同时将字符发送到标准输出
- en: ❼ Writes a null character to the file so that wide string file input functions
    can be used to read it in later
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 向文件写入一个空字符，以便宽字符串文件输入函数可以在以后读取它
- en: 'The rest of the code, not shown in listing 8.11, is available in this book’s
    online repository in the source code file greek_write.c. Missing are the statements
    to open and close the file, along with various variable declarations. Here is
    sample output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 中未显示的其余代码，可在本书的在线仓库中找到，源代码文件为 greek_write.c。缺少打开和关闭文件的语句，以及各种变量声明。以下是示例输出：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the locale set, the file contains the Greek uppercase alphabet and not
    junk. Because the terminal window is intelligent enough to recognize Unicode,
    you can use the *cat* command to dump the file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了区域设置后，文件包含希腊大写字母而不是垃圾数据。因为终端窗口足够智能，可以识别 Unicode，所以你可以使用 *cat* 命令来转储文件：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The filename is alphabeta.wtxt. I made up the wtxt extension for a wide text
    file. You also see that the file’s content lacks a newline, which is why the command
    prompt ($) appears after the Omega.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名为 alphabeta.wtxt。我创造了 wtxt 扩展名用于宽文本文件。你也会看到文件内容缺少换行符，这就是为什么命令提示符 ($) 出现在
    Omega 之后。
- en: 'Here is output from the *hexdump* utility, to show the file’s raw bytes:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 *hexdump* 工具的输出，以显示文件的原始字节：
- en: '[PRE36]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Several approaches are possible for reading wide characters from a file. Because
    I wrote the null character at the end of the alphabet, you can use the *fgetws()*
    function to read in the line of text. This function is the wide character sibling
    of the *fgets()* function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取宽字符有几种方法。因为我将空字符写在了字母表的末尾，所以可以使用 *fgetws()* 函数来读取文本行。这个函数是 *fgets()* 函数的宽字符兄弟。
- en: The following listing shows the file-reading code, found in source code file
    greek_read01.c in this book’s online repository. Traditional file I/O commands
    open the file. The locale is set. Then the *fgetws()* function does its magic
    to read the uppercase alphabet wide string. The line is output, and the file is
    closed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了文件读取代码，位于本书在线仓库中源代码文件 greek_read01.c 中。传统的文件 I/O 命令打开文件。设置区域设置。然后 *fgetws()*
    函数执行其魔法，读取大写字母的宽字符串。输出该行，然后关闭文件。
- en: Listing 8.12 Source code for greek_read01.c
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 greek_read01.c 的源代码
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ The file to open
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要打开的文件
- en: ❷ Defines a constant for the input buffer
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义输入缓冲区的常量
- en: ❸ The wide character input buffer
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 宽字符输入缓冲区
- en: ❹ Opens the file for reading
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 打开文件进行读取
- en: ❺ Handles any errors
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理任何错误
- en: ❻ Lets the user know what’s going on
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 告诉用户正在发生什么
- en: ❼ Reads a line of text from the file (up to the null character)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 从文件中读取一行文本（直到空字符）
- en: ❽ Outputs the line read
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 输出读取的行
- en: 'Because the source code for greek_write.c adds a null character to the end
    of the alphabet, the *fgetws()* function in greek_read01.c reads text from the
    file in one chunk: like the *fgets()* function, *fgetws()* stops reading when
    it encounters the null byte, a newline, or the buffer fills. Here is the program’s
    output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 greek_write.c 的源代码在字母表末尾添加了一个空字符，所以 greek_read01.c 中的 *fgetws()* 函数会一次性从文件中读取文本：就像
    *fgets()* 函数一样，*fgetws()* 在遇到空字节、换行符或缓冲区填满时停止读取。以下是程序的输出：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To read one wide character at a time from a file, use the *fgetwc()* function,
    which is the wide character counterpart of *fgetc()*. Like *fgetc()*, the value
    returned by *fgetwc()* isn’t a character or even a wide character. It’s a wide
    integer. Here is the *fgetwc()* function’s *man* page format:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次从文件中读取一个宽字符，请使用 *fgetwc()* 函数，它是 *fgetc()* 的宽字符对应函数。与 *fgetc()* 一样，*fgetwc()*
    返回的值不是一个字符，甚至不是一个宽字符。它是一个宽整数。以下是 *fgetwc()* 函数的 *man* 页面格式：
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The function’s argument is an open file handle, or *stdin* for standard input.
    The value returned is of the *wint_t* data type. As with *fgetc()*, the reason
    is that the wide end-of-file marker, *WEOF*, can be encountered, which the *wchar_t*
    type doesn’t interpret properly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数是一个打开的文件句柄，或者 *stdin* 用于标准输入。返回的值是 *wint_t* 数据类型。与 *fgetc()* 一样，原因是宽字符文件结束标记
    *WEOF* 可能会被遇到，而 *wchar_t* 类型无法正确解释它。
- en: 'To modify the code from greek_read01.c to read single characters from the file,
    only a few changes are required:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 greek_read01.c 的代码修改为从文件中读取单个字符，只需要进行几个更改：
- en: 'The line[] buffer is removed, along with the length constant. In its place,
    a single *wint_t* variable is declared:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 移除了 line[] 缓冲区和长度常量。取而代之的是，声明了一个单个 *wint_t* 变量：
- en: '[PRE40]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To read from the file, the *fgetws()* statement, as well as the *wprintf()*
    statement, are replaced with these statements:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取，将 *fgetws()* 语句以及 *wprintf()* 语句替换为以下语句：
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The *while* loop’s condition both reads a character (a *wint_t* value) from
    the open file handle fp. This value is compared with *WEOF*, the wide character
    end-of-file marker. As long as the character isn’t the end of file, the loop repeats.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*while* 循环的条件从打开的文件句柄 fp 中读取一个字符（一个 *wint_t* 值）。这个值与宽字符文件结束标记 *WEOF* 进行比较。只要字符不是文件结束，循环就会重复。'
- en: The loop’s sole statement is putwchar(ch), which outputs the character read.
    A final *putwchar()* statement outputs a newline, cleaning up the output.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的唯一语句是 putwchar(ch)，它输出读取的字符。最后的 *putwchar()* 语句输出换行符，清理输出。
- en: 'The complete source code for greek_read02.c is available in this book’s online
    repository. The program’s output is the same as for the program version that used
    the *fgetws()* function to read the alphabet:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: greek_read02.c 的完整源代码可在本书在线仓库中找到。该程序的输出与使用 *fgetws()* 函数读取字母表的程序版本相同。
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Exercise 8.3
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.3
- en: Using my Greek alphabet programs as a guide, create code that writes the Cyrillic
    alphabet to a file. You can optionally write a program that reads in the Cyrillic
    alphabet from the file you create, though the *cat* command works just as well.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以我的希腊字母程序为指南，编写代码将西里尔字母表写入文件。你可以选择编写一个程序从你创建的文件中读取西里尔字母表，尽管*cat*命令同样有效。
- en: The first letter of the Cyrillic alphabet, A, is U+0410\. The last letter is
    Я, U+042F. These are the uppercase letters. Unlike Greek, no blanks are found
    in the Unicode sequence.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 西里尔字母表的第一字母A，其Unicode编码为U+0410。最后一个字母是Я，其Unicode编码为U+042F。这些都是大写字母。与希腊字母不同，Unicode序列中不包含空格。
- en: My solution is called cyrillic.c, and it’s available in this book’s online code
    repository.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案被称为cyrillic.c，并且可以在本书的在线代码仓库中找到。
