- en: 8 Working with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 使用 Kubernetes
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating Kubernetes YAML files from existing Podman pods and containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有的 Podman pods 和容器创建 Kubernetes YAML 文件
- en: Creating Podman containers and pods from a Kubernetes YAML file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Kubernetes YAML 文件创建 Podman 容器和 pods
- en: Shutting down and removing pods and containers using the Kubernetes YAML file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes YAML 文件关闭和删除 pods 和容器
- en: Building container images on the fly before launching pods and containers from
    a Kubernetes YAML file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从 Kubernetes YAML 文件启动 pods 和容器之前即时构建容器镜像
- en: Running Podman inside of a Podman and Kubernetes container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Podman 和 Kubernetes 容器内运行 Podman
- en: Some readers come to this chapter expecting to see how Podman can be used as
    the container engine for Kubernetes, similar to how it has used Docker in the
    past. While there have been some efforts to use Podman as the container engine
    for Podman (the kind project supports this), I do not generally recommend that
    you use Podman for this purpose. I recommend you use CRI-O described in appendix
    A, since it was built specifically to work with Kubernetes and shares the underlying
    libraries of Podman. Kubernetes is now discouraging users from using the Docker
    backend and encouraging them to use a CRI-O or containerd as a backend.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者期待在本章中看到如何将 Podman 用作 Kubernetes 的容器引擎，类似于它过去如何使用 Docker。虽然有一些努力将 Podman
    用作 Kubernetes 的容器引擎（例如，kind 项目支持这一点），但我通常不推荐您使用 Podman 来实现这一目的。我建议您使用附录 A 中描述的
    CRI-O，因为它专门为与 Kubernetes 一起工作而构建，并且与 Podman 共享底层库。现在 Kubernetes 正在劝阻用户使用 Docker
    后端，并鼓励他们使用 CRI-O 或 containerd 作为后端。
- en: This chapter covers using the same structured language with both Kubernetes
    and Podman as well as how to run Podman containers inside a Kubernetes cluster.
    You have learned how to create microservices as containers and pods from the command
    line using Podman. Often software developers and packagers need to take their
    applications and run them on multiple machines. You might want to take your web
    application and add a database backend. If the web application becomes popular,
    you will need to run multiple instances on different nodes. Wiring different microservices
    together and orchestrating all of them together is not something Podman does.
    This is where Kubernetes comes in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用与 Kubernetes 和 Podman 相同的结构化语言，以及如何在 Kubernetes 集群内运行 Podman 容器。您已经学习了如何使用
    Podman 从命令行创建作为容器和 pods 的微服务。通常，软件开发人员和打包人员需要将他们的应用程序部署到多台机器上。您可能想将您的 Web 应用程序添加一个数据库后端。如果
    Web 应用程序变得流行，您将需要在不同的节点上运行多个实例。将不同的微服务连接在一起并协调所有这些服务不是 Podman 能做到的。这正是 Kubernetes
    发挥作用的地方。
- en: In this chapter, you will learn about running these same containers and pods
    in Kubernetes. The kubernetes.io website says, “Kubernetes, also known as K8s,
    is an open-source system for automating deployment, scaling, and management of
    containerized applications.” I look at Kubernetes as the tool for running containers
    on multiple machines at the same time—a way to orchestrate large clusters of containerized
    microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在 Kubernetes 中运行这些相同的容器和 pods。kubernetes.io 网站表示，“Kubernetes，也称为
    K8s，是一个开源系统，用于自动化容器化应用程序的部署、扩展和管理。”我将 Kubernetes 视为在多台机器上同时运行容器的工具——一种协调大量容器化微服务集群的方式。
- en: One problem you may encounter is that most container development happens with
    tools like Podman and Docker, which use fairly simple command-line interfaces
    to create containers and pods. But Kubernetes uses a declarative language written
    in YAML files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的一个问题是，大多数容器开发都是使用 Podman 和 Docker 等工具进行的，这些工具使用相当简单的命令行界面来创建容器和 pods。但
    Kubernetes 使用的是以 YAML 文件编写的声明性语言。
- en: 'I will not be diving deep into how Kubernetes works in this chapter because
    there are already many in-depth books on the topic, including *Kubernetes in Action*
    by Marko Lukša (Manning, 2020) and *Kubernetes for Developers* by William Denniss
    (Manning, 2020), that describe all the features of Kubernetes. But I will be describing
    the developer language of Kubernetes: the Kubernetes YAML file.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在本章深入探讨 Kubernetes 的工作原理，因为已经有许多关于该主题的深入书籍，包括 Marko Lukša 的《Kubernetes in
    Action》（Manning，2020）和 William Denniss 的《Kubernetes for Developers》（Manning，2020），它们描述了
    Kubernetes 的所有功能。但我将描述 Kubernetes 的开发者语言：Kubernetes YAML 文件。
- en: Note The yaml.org website first describes YAML as the “YAML Ain’t Markup Language.”
    It further elaborates, “YAML is a human-friendly data serialization language for
    all programming languages.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：yaml.org 网站首先将 YAML 描述为“YAML Ain’t Markup Language”。它进一步阐述，“YAML 是一种适用于所有编程语言的友好数据序列化语言。”
- en: Translating command-line options to a structured language like YAML presents
    a barrier for developers moving from containers on a single node to containers
    running at scale. How do you specify volumes, the image to be used, the security
    constraints, the network ports, and so on? In section 8.2, you will learn to use
    Podman to take your locally created pods and containers to generate Kubernetes
    YAML files from them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将命令行选项转换为结构化语言如 YAML 对从单个节点上的容器迁移到大规模运行的容器中的开发者来说是一个障碍。你如何指定卷、要使用的镜像、安全约束、网络端口等等？在第
    8.2 节中，你将学习如何使用 Podman 将你本地创建的 pods 和容器转换为 Kubernetes YAML 文件。
- en: After writing and deploying your application in a pod using Kubernetes YAML
    files, users are likely to find problems with your application running within
    Kubernetes. Testing the application at scale can be difficult, and often you just
    want to run the application locally on your system, without having to set up and
    configure a Kubernetes cluster. In section 8.3, you will learn about `podman`
    `play` `kube`. This Podman command allows you to run the Kubernetes YAML file
    locally, without Kubernetes, so you can test and debug problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Kubernetes YAML 文件编写和部署你的应用程序后，用户可能会发现你的应用程序在 Kubernetes 中运行时存在问题。在规模上测试应用程序可能很困难，而且你通常只想在本地系统上运行应用程序，而不需要设置和配置
    Kubernetes 集群。在第 8.3 节中，你将了解 `podman` `play` `kube`。这个 Podman 命令允许你在没有 Kubernetes
    的情况下本地运行 Kubernetes YAML 文件，以便你可以测试和调试问题。
- en: The final part of this chapter will cover running Podman within containers,
    including running it within a Kubernetes cluster. Administrators, developers,
    and quality engineers need to test containers within their continuous integration
    (CI) systems using Podman. Often these CI systems are built on Kubernetes clusters.
    Section 8.4 teaches you different ways to run the Podman command within containers
    launched by Podman and Kubernetes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一部分将涵盖在容器中运行 Podman，包括在 Kubernetes 集群中运行它。管理员、开发人员和质量工程师需要使用 Podman 在他们的持续集成（CI）系统中测试容器。通常这些
    CI 系统建立在 Kubernetes 集群之上。第 8.4 节将教你如何在 Podman 和 Kubernetes 启动的容器中运行 Podman 命令的不同方法。
- en: 8.1 Kubernetes YAML files
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 Kubernetes YAML 文件
- en: The Kubernetes YAML file is the object used to launch pods and containers within
    Kubernetes. In chapter 5, you learned the configuration files used by Podman are
    written using TOML, which is very similar to YAML. Both configuration languages
    are attempting to be human readable. YAML relies on indenting substanzas, which
    is different syntax than you learned with TOML. You can go to the [yaml.org](http://yaml.org)
    website to learn more about the language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes YAML 文件是在 Kubernetes 中启动 pods 和容器的对象。在第 5 章中，你学习了 Podman 使用的配置文件是用
    TOML 编写的，它与 YAML 非常相似。这两种配置语言都试图做到人类可读。YAML 依赖于缩进子句，这与你学过的 TOML 语法不同。你可以访问 [yaml.org](http://yaml.org)
    网站了解更多关于这种语言的信息。
- en: If you are going to work a lot with Kubernetes YAML files, it is nice to have
    a text editor or IDE, like Visual Studio and VS Code, that can at least understand
    YAML; it is even better if it knows the Kubernetes language. Kubernetes YAML is
    descriptive and powerful. It allows you to model the desired state of your application
    in a declarative language. As stated in the introduction to this chapter, writing
    these YAML files is a barrier for developers to get through when moving their
    containers from a local system to Kubernetes. Most developers just web search
    an existing Kubernetes YAML file and then begin cutting and pasting their container
    command, image, and options into the YAML file. While this works, it can lead
    to unintended consequences—and often unnecessary work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算大量使用 Kubernetes YAML 文件，那么拥有一个至少能理解 YAML 的文本编辑器或 IDE，比如 Visual Studio 和
    VS Code，会很好；如果它还了解 Kubernetes 语言，那就更好了。Kubernetes YAML 是描述性和强大的。它允许你使用声明性语言来建模你应用程序的期望状态。正如本章引言中所述，编写这些
    YAML 文件是开发者在将容器从本地系统迁移到 Kubernetes 时需要克服的障碍。大多数开发者只是在网上搜索现有的 Kubernetes YAML 文件，然后将他们的容器命令、镜像和选项剪切粘贴到
    YAML 文件中。虽然这样做可以工作，但它可能导致意想不到的后果——并且通常是多余的工作。
- en: 'Scott McCarty, product manager of Podman, tossed out an idea: “What I would
    really like to do is help users get from Podman to orchestrating their containers
    with Kubernetes.” This led the Podman developers to create a new Podman command:
    `podman` `generate` `kube`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的产品经理 Scott McCarty 提出了一个想法：“我真正想做的就是帮助用户从 Podman 过渡到使用 Kubernetes 管理他们的容器。”这促使
    Podman 开发者创建了一个新的 Podman 命令：`podman` `generate` `kube`。
- en: 8.2 Generating Kubernetes YAML files with Podman
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用 Podman 生成 Kubernetes YAML 文件
- en: Imagine you want to take the containers you generated in the previous chapters
    and run them within Kubernetes. You need to write the Kubernetes YAML file to
    make this happen. Where should you start?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在Kubernetes中运行之前章节中生成的容器。你需要编写Kubernetes YAML文件来实现这一点。你应该从哪里开始？
- en: 'In this chapter, you will learn a new command: `podman` `generate` `kube`.
    This Podman command captures the description of local pods and containers and
    then translates them into Kubernetes YAML. This helps you transition to a more
    sophisticated orchestration environment like Kubernetes. The generated Kubernetes
    YAML file can then be used by Kubernetes commands to launch your pods and containers
    into a Kubernetes cluster.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习一个新命令：`podman` `generate` `kube`。这个Podman命令捕获本地pod和容器的描述，然后将它们转换为Kubernetes
    YAML格式。这有助于你过渡到更复杂的编排环境，如Kubernetes。生成的Kubernetes YAML文件可以由Kubernetes命令使用，以将你的pod和容器部署到Kubernetes集群中。
- en: You can re-create the containers or pods locally using Podman on the command
    line with the same Podman `run`, `create`, and `stop` commands you have learned
    in the previous chapters. Using the following commands, re-create the container
    you have been working with.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你在前几章中学到的相同的Podman `run`、`create`和`stop`命令，在命令行上重新创建容器或pod。使用以下命令重新创建你一直在使用的容器。
- en: 'First, remove the container if it exists using `podman` `rm`. You will introduce
    a new flag, `--ignore`, which tells the `podman` `rm` command not to report errors
    when the container does not exist. Then, re-create the container from the command
    line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`podman` `rm`删除容器（如果存在）。你将引入一个新的标志`--ignore`，它告诉`podman` `rm`命令在容器不存在时不报告错误。然后，从命令行重新创建容器：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, use the command `podman` `generate` `kube` `myapp` to generate the Kubernetes
    YAML file. Podman inspects the existing container or pod in its database for all
    of the fields required to run the container in Kubernetes and then populates them
    in the Kubernetes YAML file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用命令`podman` `generate` `kube` `myapp`生成Kubernetes YAML文件。Podman检查其数据库中现有的容器或pod，以获取在Kubernetes中运行容器所需的所有字段，并将它们填充到Kubernetes
    YAML文件中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 8.1 shows the result of a `podman` `generate` `kube` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1显示了`podman` `generate` `kube`命令的结果。
- en: '![](../../OEBPS/Images/08-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1](../../OEBPS/Images/08-01.png)'
- en: Figure 8.1 Shows the generated myapp.yaml file from the `myapp` container
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1展示了从`myapp`容器生成的`myapp.yaml`文件
- en: 'Examine parts of the YAML file. Understand that Kubernetes works with pods,
    even though you created a container, `podman` `generate` `kube`, that creates
    a pod specification. Podman names the pod `myapp-pod` and the container `myapp`
    within the specification, based on the name of the original container:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 检查YAML文件的各个部分。理解Kubernetes与pod协同工作，尽管你创建了一个容器，`podman` `generate` `kube`，它创建了一个pod规范。Podman根据原始容器的名称命名pod为`myapp-pod`，容器为`myapp`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice, in the containers section, that the image name, quay.io/rhatdan/myimage:
    latest, is recorded, which tells Kubernetes where to download the image for the
    container from. It also tells Kubernetes the command arguments to start the app
    within the container, /usr/bin/run-httpd:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在容器部分，记录了镜像名称`quay.io/rhatdan/myimage: latest`，这告诉Kubernetes从哪里下载容器的镜像。它还告诉Kubernetes在容器内启动应用程序的命令参数，即`/usr/bin/run-httpd`：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the same container section, you see that the Podman ports are recorded,
    `-p` `8080: 8080` `spec`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '在相同的容器部分，你可以看到Podman端口被记录，`-p` `8080: 8080` `spec`：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, at the end of the containers section, you see `securityContext`, which
    records that Podman, by default, drops three additional Linux capabilities: `CAP_MKNOD`,
    `CAP_NET_RAW`, and `CAP_AUDIT_WRITE`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在容器部分的末尾，你可以看到`securityContext`，它记录了Podman默认丢弃三个额外的Linux功能：`CAP_MKNOD`、`CAP_NET_RAW`和`CAP_AUDIT_WRITE`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most containers run fine without these Linux capabilities, but the OCI specification
    enables these three by default. This tells Kubernetes that this pod can run more
    securely without these capabilities, and Kubernetes will drop them. You can find
    out more about Linux capabilities by running the command `man` `capabilities`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器在没有这些Linux功能的情况下运行良好，但OCI规范默认启用这三个功能。这告诉Kubernetes，这个pod可以在没有这些功能的情况下更安全地运行，并且Kubernetes将丢弃它们。你可以通过运行命令`man`
    `capabilities`来了解更多关于Linux功能的信息。
- en: 'At this point, you can just run this Kubernetes YAML file in any Kubernetes
    cluster, usually running a command like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以在任何Kubernetes集群中运行这个Kubernetes YAML文件，通常运行以下命令：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Often you will have to add sophistication and orchestration to the YAML file
    and leverage advanced functions of Kubernetes. For example, the generated Kubernetes
    YAML file will only generate a single instance of your application. If you want
    to run multiple versions of your applications on different nodes, you could add
    a `replicas` option to your YAML file, as seen in figure 8.2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要在YAML文件中添加复杂性和编排，并利用Kubernetes的高级功能。例如，生成的Kubernetes YAML文件只会生成你应用程序的单个实例。如果你想在不同节点上运行你应用程序的多个版本，你可以在YAML文件中添加`replicas`选项，如图8.2所示。
- en: '![](../../OEBPS/Images/08-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/08-02.png)'
- en: Figure 8.2 The modified Kubernetes YAML file ready to run two replicas
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 修改后的Kubernetes YAML文件，准备运行两个副本
- en: The `replicas` flag tells Kubernetes that the myapp.yaml file wants to have
    two `myapp` pods running on two different nodes at all times. Replicas and other
    advanced Kubernetes features are out of the scope of Podman. The `podman` `play`
    `kube` command ignores these fields.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`replicas`标志告诉Kubernetes，myapp.yaml文件希望始终在两个不同的节点上运行两个`myapp` Pod。副本和其他高级Kubernetes功能超出了Podman的范围。`podman`
    `play` `kube`命令忽略这些字段。'
- en: 'Some notable `podman` `generate` `kube` options include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的`podman` `generate` `kube`选项包括以下内容：
- en: '`-f,` `--filename`—This writes output to the specified path.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f,` `--filename`—这会将输出写入指定的路径。'
- en: '`-s,` `--service`—This generates YAML for a Kubernetes service object.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s,` `--service`—这会为Kubernetes服务对象生成YAML。'
- en: Now that you have generated a Kubernetes YAML file, it’d be nice to be able
    to reverse the process. If you had a Kubernetes YAML file, you may want to generate
    Podman pods and containers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经生成了一个Kubernetes YAML文件，能够反转这个过程会很好。如果你有一个Kubernetes YAML文件，你可能希望生成Podman的Pod和容器。
- en: 8.3 Generating Podman pods and containers from Kubernetes YAML
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 从Kubernetes YAML生成Podman的Pod和容器
- en: 'Imagine you get a Kubernetes YAML file and want to examine it running locally.
    You could set up a local Kubernetes cluster, but it would be nice if you could
    just play the pods locally. Podman provides a command for doing this. The `podman`
    `play` `kube` command creates pods, containers, and volumes based on structured
    Kubernetes YAML files. The created pods and containers are automatically started.
    To test this, you can simply remove the container you created and then run the
    generated myapp.yaml file with the following commands:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你得到了一个Kubernetes YAML文件并想在本地上运行它进行检查。你可以设置一个本地的Kubernetes集群，但如果你能直接在本地上运行Pod会更好。Podman提供了一个执行此操作的命令。`podman`
    `play` `kube`命令根据结构化的Kubernetes YAML文件创建Pod、容器和卷。创建的Pod和容器会自动启动。为了测试这一点，你可以简单地删除你创建的容器，然后使用以下命令运行生成的myapp.yaml文件：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Kubernetes only runs pods with containers; it does not run just containers by
    themselves. When the `podman` `play` `kube` command reads the YAML, file it launches
    the pod along with the container. Notice in figure 8.3 that the `play` command
    created a Pod with your container along with the infra containers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes只运行带有容器的Pod；它不会单独运行容器。当`podman` `play` `kube`命令读取YAML文件时，它会启动Pod以及容器。注意图8.3中`play`命令创建了一个包含你的容器以及基础设施容器的Pod。
- en: '![](../../OEBPS/Images/08-03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/08-03.png)'
- en: Figure 8.3 The `myapp-pod` running with the `myapp` container and the infra
    container
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 `myapp-pod`与`myapp`容器和基础设施容器一起运行
- en: 'The `podman` `generate` `kube` command creates the pod named `myapp-pod`, based
    on the name within the myapp.yaml file. The names of the containers are generated
    by appending the name of the pod to the name of the container: `myapp-pod-myapp`.
    If the YAML file defines additional containers, they need to be labeled similarly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `generate` `kube`命令根据myapp.yaml文件中的名称创建名为`myapp-pod`的Pod。容器的名称通过将Pod的名称附加到容器名称来生成：`myapp-pod-myapp`。如果YAML文件定义了额外的容器，它们需要以类似的方式进行标记：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can display the pods running on your system with the `podman` `pod` `ps`
    command. Add the `--ctr-names` option to also list the containers running within
    the pod:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`podman` `pod` `ps`命令显示系统上运行的Pod。添加`--ctr-names`选项也可以列出Pod内运行的容器：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now examine the two containers running with the `podman` `ps` command, using
    the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查使用`podman` `ps`命令运行的两个容器，使用以下命令：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shut down the Pod and container with the `podman` `pod` `stop` command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`podman` `pod` `stop`命令关闭Pod和容器：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`podman` `play` `kube` can execute much more complex YAML files, including
    with multiple pods, volumes, and containers defined. In the previous simple example,
    you can just shut down the pod with the `podman` `pod` `stop` command, but when
    `podman` `play` `kube` generates multiple unique pods, it gets a little more complex
    to shut them down.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `play` `kube` 可以执行更复杂的 YAML 文件，包括定义了多个 pod、卷和容器的文件。在之前的简单示例中，你可以使用
    `podman` `pod` `stop` 命令来关闭 pod，但当 `podman` `play` `kube` 生成多个唯一的 pod 时，关闭它们会变得稍微复杂一些。'
- en: 8.3.1 Shutting down pods and containers based on a Kubernetes YAML file
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 基于Kubernetes YAML文件关闭 pod 和容器
- en: 'Although you can stop each pod started by `podman` `play` `kube`, sometimes
    you don’t only want to stop the pods and containers but actually remove them from
    the system. The `podman` `play` `kube` `--down` command tears down the pods that
    were created by a previous run of `play` `kube`. The pods are stopped and then
    removed. Any volumes created are left intact. Shut down the myapp.yaml pod created
    in the previous example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以停止 `podman` `play` `kube` 启动的每个 pod，但有时你不仅想要停止 pod 和容器，实际上还想从系统中删除它们。`podman`
    `play` `kube` `--down` 命令销毁 `play` `kube` 上一次运行创建的 pod。pod 被停止然后删除。任何创建的卷都保持完整。关闭之前示例中创建的
    myapp.yaml pod：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that Podman not only stopped the pod but also removed it. You can verify
    the pod is gone with the `podman` `pod` `ps` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Podman 不仅停止了 pod，还将其删除了。你可以使用 `podman` `pod` `ps` 命令来验证 pod 是否已消失：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This leaves you back in a state where you can run `podman` `play` `kube` again,
    which will create fresh pods and containers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你回到了可以再次运行 `podman` `play` `kube` 的状态，它将创建新的 pod 和容器：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This mimics what happens with Kubernetes running pods and containers. Kubernetes
    always creates pods and containers fresh and tears them down when it completes.
    The ability to generate all of the pods and containers from the YAML file and
    then remove them with the `--down` flag is similar to the workflow of `docker-compose`.
    Podman has the big advantage of using the same YAML file for running the pods
    and containers as in a multinode, orchestrated environment with Kubernetes. One
    other feature `docker-compose` has is the ability to build the images defined
    within the YAML file, which the Podman developers also added to `podman` `play`
    `kube`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这模仿了 Kubernetes 运行 pod 和容器时发生的情况。Kubernetes 总是创建新的 pod 和容器，并在完成时将其销毁。从 YAML
    文件生成所有 pod 和容器，然后使用 `--down` 标志将其删除的功能类似于 `docker-compose` 的工作流程。Podman 的一个重大优势是使用与在具有
    Kubernetes 的多节点编排环境中运行 pod 和容器相同的 YAML 文件。`docker-compose` 另一个具有的功能是能够构建 YAML
    文件中定义的镜像，Podman 开发者也将其添加到了 `podman` `play` `kube`。
- en: 8.3.2 Building images using Podman and Kubernetes YAML files
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用 Podman 和 Kubernetes YAML 文件构建镜像
- en: Users who were using `podman` `play` `kube` as a replacement for `docker-compose`
    requested Podman to add a feature to build images, rather than always pull them
    from a container registry. While Kubernetes does not support such a feature, Podman
    developers decided to add the `--build` flag to `podman` `play` `kube`. Because
    `podman` `build` can process Containerfiles or Dockerfiles, enhancing `podman`
    `play` `kube` was simple.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `podman` `play` `kube` 作为 `docker-compose` 替代品的用户请求 Podman 添加一个构建镜像的功能，而不是总是从容器仓库中拉取它们。虽然
    Kubernetes 不支持这样的功能，但 Podman 开发者决定向 `podman` `play` `kube` 添加 `--build` 标志。因为
    `podman` `build` 可以处理 Containerfile 或 Dockerfile，增强 `podman` `play` `kube` 是简单的。
- en: The idea is to create a containerized application via a container image that
    is produced on demand. Normal Kubernetes workflow requires developers to build
    the image using `podman` `build` and push it to a container registry using `podman`
    `push`, as you learned in chapter 2\. Then you can retrieve the image from the
    registry using `podman` `play` `kube`. The `podman` `play` `kube` `--build` option
    allows it to execute `podman` `build` internally and generate the image on demand,
    rather than forcing you to use a container registry.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是通过一个按需生成的容器镜像来创建容器化应用程序。正常的 Kubernetes 工作流程要求开发者使用 `podman` `build` 构建镜像，并使用
    `podman` `push` 将其推送到容器仓库，正如你在第 2 章中学到的。然后你可以使用 `podman` `play` `kube` 从仓库检索镜像。`podman`
    `play` `kube` `--build` 选项允许它内部执行 `podman` `build` 并按需生成镜像，而不是强迫你使用容器仓库。
- en: Note The `--build` option is not available with the remote Podman client, so
    you can’t use it on Mac or Windows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`--build` 选项在远程 Podman 客户端中不可用，因此你无法在 Mac 或 Windows 上使用它。
- en: 'In this example, you are going to re-create the Containerfile used in section
    6.1.3:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将重新创建 6.1.3 节中使用的 Containerfile：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Recall that this Containerfile builds a container image with systemd running
    as the init system and the HTTPD service running and listening on port `80`. First,
    remove all pods and containers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，这个 Containerfile 构建了一个以 systemd 作为 init 系统运行的容器镜像，HTTPD 服务在端口 `80` 上运行并监听。首先，删除所有
    pod 和容器：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now rebuild the `my-systemd` image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新构建 `my-systemd` 镜像：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now re-create a container on the image with the ./html directory (using a code
    example from section 3.1) mounted into the container:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新创建一个包含 ./html 目录的容器镜像（使用第 3.1 节的代码示例）：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now generate the Kubernetes YAML file using `podman` `generate` `kube`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '现在生成 Kubernetes YAML 文件，使用 `podman` `generate` `kube`:'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that this time Podman generated the YAML file with a volumes section
    for `html`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次 Podman 生成了包含 `html` 卷部分的 YAML 文件：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Get back to a fresh environment by removing all of the pods with the `podman`
    `pod` `rm` `--all` `--force` command. Remove all containers and images using the
    `podman` `rm` and `podman` `rmi` commands, so you can start with a clean slate:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `podman` `pod` `rm` `--all` `--force` 命令删除所有 pod，以回到一个干净的环境。使用 `podman` `rm`
    和 `podman` `rmi` 命令删除所有容器和镜像，以便您可以从头开始：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `podman` `play` `kube` `--build` command requires subdirectories matching
    the image names to exist for images to be built. Podman examines the Kubernetes
    YAML file for all images and then looks for the matching subdirectory. Each directory
    is treated as a context directory and should contain a Containerfile or a Dockerfile.
    Podman then executes `podman` `build` on each subdirectory. Since the YAML file
    needs the mysystemd image, you need to create a mysystemd directory and place
    the Containerfile in the directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `play` `kube` `--build` 命令需要存在与镜像名称匹配的子目录，以便构建镜像。Podman 检查 Kubernetes
    YAML 文件中的所有镜像，然后寻找匹配的子目录。每个目录都被视为上下文目录，应包含一个 Containerfile 或 Dockerfile。然后 Podman
    在每个子目录上执行 `podman` `build`。由于 YAML 文件需要 mysystemd 镜像，您需要创建一个 mysystemd 目录并将 Containerfile
    放入该目录：'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can now run `podman` `play` `kube` `--build`, and it will rebuild the container
    image and launch the Pod and containers for your application:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行 `podman` `play` `kube` `--build`，它将重新构建容器镜像并启动您的应用程序的 Pod 和容器：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Podman rebuilt the mysystemd image based on the mysystemd/Containerfile and
    then generated the `myapp-pod` pod and the `myapp` container for your application,
    without even reaching out to a container registry.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 基于mysystemd/Containerfile 重建了 mysystemd 镜像，然后为您的应用程序生成了 `myapp-pod` pod
    和 `myapp` 容器，甚至没有接触到容器注册库。
- en: 'You can share this YAML file and the mysystemd directory with other users,
    and they can build and launch your application all with Podman. Remember, though,
    if they wanted to launch it inside of Kubernetes, you need to push the built image
    to a container registry, and then edit the YAML file to point the image to the
    registry image. Now that you have been exposed to the integration of Podman with
    Kubernetes, I want to explore one last idea: running Podman within Podman and
    Kubernetes containers.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此 YAML 文件和 mysystemd 目录与其他用户共享，他们可以使用 Podman 构建和启动您的应用程序。不过，如果您想在 Kubernetes
    内部启动它，您需要将构建的镜像推送到容器注册库，然后编辑 YAML 文件以指向注册库中的镜像。现在您已经了解了 Podman 与 Kubernetes 的集成，我想探讨最后一个想法：在
    Podman 和 Kubernetes 容器内运行 Podman。
- en: 8.4 Running Podman within a container
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 在容器内运行 Podman
- en: Running Podman within a container, or within a Kubernetes cluster, is a common
    problem. Users want to be able to test container images and tools within CI/CD
    systems using containers. Often, they want to build container images with `podman`
    `build`. Sometimes, they just want to test a newer version of Podman than has
    been released within their distribution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内或 Kubernetes 集群内运行 Podman 是一个常见问题。用户希望在 CI/CD 系统中使用容器测试容器镜像和工具。通常，他们想使用
    `podman` `build` 构建容器镜像。有时，他们只想测试比他们发行版中发布的 Podman 更新版本的 Podman。
- en: 'One challenge with Podman is that it can be configured in so many different
    ways that users were looking for best practices for running Podman within a container.
    Because of this I, along with some of my colleagues, decided to create a container
    image, quay.io/podman`/`stable, which makes it easier to run Podman within a container.
    As you understand, Podman can run in two different modes: rootful and rootless.
    By default, Podman containers start as the container root within their user namespace.
    To help you understand running Podman within a container, you will first experiment
    with running Podman within Podman. Table 8.1 describes the different ways you
    can run a container within a container and the capabilities required to allow
    the internal Podman to execute a container.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的一大挑战是它可以以多种不同的方式配置，以至于用户在容器内运行 Podman 时寻找最佳实践。正因为如此，我以及我的几位同事决定创建一个容器镜像，quay.io/podman`/`stable，这使得在容器内运行
    Podman 更加容易。如您所知，Podman 可以以两种不同的模式运行：有根模式和 无根模式。默认情况下，Podman 容器在其用户命名空间内以容器根用户启动。为了帮助您理解在容器内运行
    Podman，您将首先尝试在 Podman 内运行 Podman。表 8.1 描述了您可以在容器内运行容器的方式以及允许内部 Podman 执行容器的所需能力。
- en: Table 8.1 Requirements for running Podman within a container
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 在容器内运行 Podman 的要求
- en: '| Host mode | Container mode | Capabilities | Explanation |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 主机模式 | 容器模式 | 能力 | 说明 |'
- en: '| Rootful | Rootful | `CAP_SYS_ADMIN` | Has full access to the host user’s
    namespace |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 有根模式 | 有根模式 | `CAP_SYS_ADMIN` | 具有对主机用户命名空间的完全访问权限 |'
- en: '| Rootful | Rootless | `CAP_SETUIDCAP_SETGID` | Runs in a separate user’s namespace
    based on /etc/subuid and /etc/subgid inside the container |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 有根模式 | 无根模式 | `CAP_SETUIDCAP_SETGID` | 在容器内部基于 /etc/subuid 和 /etc/subgid
    运行在单独的用户命名空间中 |'
- en: '| Rootless | Rootful | Namespaced `CAP_SYS_ADMIN` | Has full access to the
    user’s user namespace |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 无根模式 | 有根模式 | 命名空间 `CAP_SYS_ADMIN` | 具有对用户用户命名空间的完全访问权限 |'
- en: '| Rootless | Rootless | Namespaced `CAP_SETUID`, `CAP_SETGID` | Runs in a separate
    user namespace based on /etc/subuid and /etc/subgid inside the container. The
    user namespace must be a subset of the user namespace in which you are running
    the Podman command. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 无根模式 | 无根模式 | 命名空间 `CAP_SETUID`, `CAP_SETGID` | 在容器内部基于 /etc/subuid 和 /etc/subgid
    运行在单独的用户命名空间中。用户命名空间必须是您运行 Podman 命令的用户命名空间的子集。 |'
- en: 8.4.1 Running Podman within a Podman container
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 在 Podman 容器内运行 Podman
- en: 'In the first example, you will run a rootful Podman within a rootless container.
    You need to use the `--privileged` command because, to run successfully, Podman
    needs to be able to mount filesystems. When Podman is run as root, mounting requires
    the `CAP_SYS_ADMIN` capability, which is given by the `--privileged` option. Try
    it out by executing the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，您将在无根容器内运行有根 Podman。您需要使用 `--privileged` 命令，因为为了成功运行，Podman 需要能够挂载文件系统。当
    Podman 以 root 用户运行时，挂载需要 `CAP_SYS_ADMIN` 能力，这由 `--privileged` 选项提供。通过执行以下命令来尝试：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The quay.io/podman/stable image is also configured to run a rootless Podman
    within a Podman container. You can activate this behavior by adding running as
    the Podman user with the `--user` `podman` option. In this mode, Podman within
    the container needs `CAP_SETUID` and `CAP_SETGID` to set up the user namespace.
    Luckily, Podman gives this access to containers by default:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: quay.io/podman/stable 镜像还配置为在 Podman 容器内运行无根 Podman。您可以通过添加 `--user podman`
    选项以 Podman 用户身份运行来激活此行为。在此模式下，容器内的 Podman 需要 `CAP_SETUID` 和 `CAP_SETGID` 来设置用户命名空间。幸运的是，Podman
    默认将此访问权限提供给容器：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you really want to lock the container down, you can drop all capabilities
    other than `CAP_SETUID` and `CAP_SETGID`, using the `--cap-drop=all` `--cap-add`
    `CAP_SETUID,CAP_ SETGID` options:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想锁定容器，您可以使用 `--cap-drop=all` `--cap-add CAP_SETUID,CAP_SETGID` 选项来丢弃除 `CAP_SETUID`
    和 `CAP_SETGID` 之外的所有能力：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These examples, which show how you can run Podman within a Podman container,
    can also easily be done with Docker running Podman within a container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了如何在 Podman 容器内运行 Podman，同样也可以用 Docker 在容器内运行 Podman 来轻松实现。
- en: Note that Docker runs with a seccomp filter, which blocks the unshare and mount
    system calls. You need to either disable seccomp filtering in Docker—
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Docker 在运行时使用 seccomp 过滤器，该过滤器阻止了 unshare 和 mount 系统调用。您需要要么在 Docker 中禁用
    seccomp 过滤器——
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '—or run Docker with Podman’s seccomp filters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: —或者运行带有 Podman 的 seccomp 过滤器的 Docker：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, you learned about Podman integration with Kubernetes. In the
    next section, you will learn how to configure Podman to run within a Kubernetes
    pod or container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了 Podman 与 Kubernetes 的集成。在下一节中，您将学习如何配置 Podman 以在 Kubernetes pod 或容器中运行。
- en: 8.4.2 Running Podman within a Kubernetes pod
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 在 Kubernetes 容器中运行 Podman
- en: A common use case for CI/CD systems is using Podman to run containers within
    Kubernetes. As you learned, running Podman within a container requires either
    `CAP_SYS_ADMIN` for rootful containers or `CAP_SETUID` and `CAP_SETGID` to run
    in rootless mode. Understand that Podman containers almost always require more
    than one UID to run, especially when running `podman` `build`. Lots of Podman
    problems have been raised by users of Kubernetes attempting to run Podman in a
    locked-down Kubernetes container, with only one UID and without Linux capabilities.
    These containers are the default for OpenShift and lots of the cloud-based Kubernetes
    environments. Running a container engine like Podman in environments without some
    Linux capabilities and access to more than one UID is impossible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 系统的一个常见用例是使用 Podman 在 Kubernetes 中运行容器。正如你所学的，在容器中运行 Podman 需要 `CAP_SYS_ADMIN`
    权限用于 rootful 容器，或者 `CAP_SETUID` 和 `CAP_SETGID` 以 rootless 模式运行。理解 Podman 容器几乎总是需要多个
    UID 来运行，尤其是在运行 `podman build` 时。许多 Kubernetes 用户在尝试在锁定环境中的 Kubernetes 容器中运行 Podman，只有一个
    UID 且没有 Linux 权限时遇到了 Podman 问题。这些容器是 OpenShift 的默认设置，以及许多基于云的 Kubernetes 环境的默认设置。在没有某些
    Linux 权限和访问多个 UID 的情况下，在环境中运行容器引擎如 Podman 是不可能的。
- en: 'The equivalent version of running rootful Podman using the quay.io/podman/stable
    image within a `privileged` Kubernetes container can be launched with this Kubernetes
    YAML file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 quay.io/podman/stable 镜像在 `privileged` Kubernetes 容器中运行 rootful Podman 的等效版本可以通过以下
    Kubernetes YAML 文件启动：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, you can launch a rootless Podman within a Kubernetes container by
    using the following YAML file. Note that you specify the `runAsUser`: `1000` as
    the UID, not the `podman` user. Kubernetes does not support translating usernames
    within containers to UIDs:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，你可以通过以下 YAML 文件在 Kubernetes 容器中启动无根 Podman。请注意，你指定 `runAsUser`: `1000`
    作为 UID，而不是 `podman` 用户。Kubernetes 不支持在容器内将用户名转换为 UIDs：'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note See the following articles written by me along with my colleague, Urvashi
    Mohnani, that offer many more examples on running Podman within containers:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请参阅以下由我和我的同事 Urvashi Mohnani 撰写的文章，这些文章提供了更多关于在容器中运行 Podman 的示例：
- en: “How to Use Podman inside of a Container” ([http://mng.bz/vXDM](http://mng.bz/vXDM))
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何在容器中使用 Podman” ([http://mng.bz/vXDM](http://mng.bz/vXDM))
- en: “How to Use Podman inside of Kubernetes” ([http://mng.bz/49EV](http://mng.bz/49EV))
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何在 Kubernetes 中使用 Podman” ([http://mng.bz/49EV](http://mng.bz/49EV))
- en: As you can see, it is fairly easy to run Podman containers within Kubernetes,
    as long as you understand the Podman requirements. There is ongoing work within
    the Kubernetes community to take advantage of user namespaces, making it easier
    to run Podman containers within Kubernetes containers and making them more secure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只要理解 Podman 的要求，在 Kubernetes 中运行 Podman 容器相当容易。Kubernetes 社区正在进行工作，利用用户命名空间，使在
    Kubernetes 容器中运行 Podman 容器变得更加容易，并使它们更加安全。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `podman` `generate` `kube` command easily allows you to move locally running
    pods and containers into a Kubernetes YAML file suitable for running within a
    Kubernetes cluster.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman generate kube` 命令可以轻松地将本地运行的 pod 和容器移动到适合在 Kubernetes 集群中运行的 Kubernetes
    YAML 文件。'
- en: These YAML files can also be used to generate local pods and containers via
    the `podman` `play` `kube` command.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些 YAML 文件也可以通过 `podman play kube` 命令生成本地 pod 和容器。
- en: The `--down` option allows `podman` `play` `kube` to shut down all pods and
    containers launched by a previous `podman` `play` `kube` command.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--down` 选项允许 `podman play kube` 命令关闭由之前的 `podman play kube` 命令启动的所有 pod 和容器。'
- en: The `--build` option allows `podman` `play` `kube` to generate the container
    image defined within the Kubernetes YAML file based on a Containerfile/Dockerfile,
    eliminating the need to push the image to a container registry.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build` 选项允许 `podman play kube` 命令根据 Containerfile/Dockerfile 生成 Kubernetes
    YAML 文件中定义的容器镜像，从而消除了将镜像推送到容器注册库的需要。'
- en: '`podman` `play` `kube` is a suitable replacement for `docker-compose` because
    it shares the same YAML format as Kubernetes.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman play kube` 是 `docker-compose` 的合适替代品，因为它与 Kubernetes 使用相同的 YAML 格式。'
- en: Running Podman within Podman and Kubernetes containers is possible as long as
    you understand the Podman requirements for running in a locked-down environment.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要理解在锁定环境中运行 Podman 的要求，在 Podman 和 Kubernetes 容器中运行 Podman 是可能的。
