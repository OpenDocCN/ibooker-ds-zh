- en: 8 Unordered maps and coroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 无序映射和协程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Unordered maps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序映射
- en: Hashes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散列
- en: Coroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: 'In this chapter, we will make a matching-pennies game. The game has two players:
    us and the computer. We each have a coin and choose heads or tails. If the computer
    matches our choice, we lose. If the computer’s choice differs, we win. We can
    use a random distribution for the computer’s guess, so we don’t need much code
    for the first game.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将制作一个匹配便士游戏。这个游戏有两个玩家：我们和计算机。我们每人有一枚硬币，选择正面或反面。如果计算机匹配我们的选择，我们就会输。如果计算机的选择不同，我们就赢。我们可以使用随机分布来为计算机的猜测，因此我们不需要为第一场比赛编写很多代码。
- en: Once we have the initial matching-pennies game working, we’ll see whether the
    computer can predict our guess by building a mind-reading machine. To be honest,
    the computer won’t really be able to read our minds. Claude E. Shannon wrote a
    short paper in 1953 called “A Mind-Reading (?) Machine” (see [http://mng.bz/vPDp](http://mng.bz/vPDp)).
    The question mark in the title is deliberate. The game has been used for thought
    experiments in game theory and for psychology research. The mind reader needs
    to keep track of what has previously happened, so we’ll use the `std::unordered_map`
    to track the state. In chapter 7, we used an `std::map`. In this chapter, we’ll
    use an `std::unordered_map` for further practice. As we noted in chapter 7, the
    `std::map` needs an `operator<` defined for its keys. The `std::unordered_map`
    requires a `hash` and an equality operator, so we’ll learn about `std::hash` too.
    The computer will use the state to predict our next choice. When we’re done, we’ll
    wrap the code in a coroutine for extra practice.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使初始的匹配便士游戏运行起来，我们将通过构建一个读心机来查看计算机是否能够预测我们的猜测。说实话，计算机实际上并不能真正地读取我们的思想。克劳德·E·香农在1953年写了一篇名为“读心机（？）”的短文（见[http://mng.bz/vPDp](http://mng.bz/vPDp)）。标题中的问号是故意的。这个游戏已被用于博弈论中的思想实验和心理学研究。读心者需要跟踪之前发生的事情，因此我们将使用`std::unordered_map`来跟踪状态。在第7章中，我们使用了`std::map`。在这一章中，我们将使用`std::unordered_map`进行进一步练习。正如我们在第7章中提到的，`std::map`需要为它的键定义一个`operator<`。`std::unordered_map`需要一个`hash`和一个等价运算符，因此我们还将了解`std::hash`。计算机将使用状态来预测我们的下一个选择。完成之后，我们将代码包裹在一个协程中以进行额外练习。
- en: 8.1 Randomly generated matching pennies
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 随机生成的匹配便士游戏
- en: To get started, we will make the computer randomly generate a `0` or `1`, representing
    heads or tails, using an `std::uniform_int_distribution`. We also need user input.
    In chapter 3, we read numbers for the number-guessing game, so we need code similar
    to the function in listing 3.4\. That function tried to extract a number from
    a stream and returned an `std::optional`. In this case, we only want to accept
    `0` or `1`. Any other input means the player has given up. If we get the whole
    input as a string, we can compare the input with `"0"` or `"1"` and return an
    appropriate `optional<int>`. Any input other than `0` or `1` returns an empty
    `optional` to indicate that the player wants to stop.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将使计算机随机生成一个`0`或`1`，代表正面或反面，使用`std::uniform_int_distribution`。我们还需要用户输入。在第3章中，我们读取数字进行猜数字游戏，因此我们需要与列表3.4中的函数类似的代码。该函数试图从一个流中提取一个数字，并返回一个`std::optional`。在这种情况下，我们只想接受`0`或`1`。任何其他输入都意味着玩家已经放弃。如果我们得到整个输入作为一个字符串，我们可以将输入与`"0"`或`"1"`进行比较，并返回适当的`optional<int>`。任何不是`0`或`1`的输入返回一个空的`optional`，表示玩家想要停止。
- en: Listing 8.1 Reading an `optional` `0` or `1`
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 读取`optional` `0`或`1`
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ 0
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 0
- en: ❷ 1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 1
- en: ❸ Empty optional to indicate stopping
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 空的`optional`表示停止
- en: 'To build our pennies game, we need the computer to pick a random `0` or `1`,
    so we need a generator and a distribution:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的便士游戏，我们需要计算机随机选择`0`或`1`，因此我们需要一个生成器和分布：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To get the computer choice, we call `dist(gen)`. We compare the player and computer
    turns to decide who won. If we keep track of how many times the player wins and
    how many turns are taken, we can report some stats once the play stops. Pulling
    this together gives us a pennies game.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取计算机的选择，我们调用`dist(gen)`。我们比较玩家和计算机的回合来决定谁赢了。如果我们跟踪玩家赢的次数和回合数，我们就可以在游戏停止后报告一些统计数据。将这些内容整合在一起，我们就得到了一个便士游戏。
- en: Listing 8.2 A pennies game
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 便士游戏
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Track stats
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪统计数据
- en: ❷ Computer’s turn
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算机回合
- en: ❸ Player’s turn
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 玩家回合
- en: ❹ Stops if 0 or 1 is not chosen
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果没有选择`0`或`1`则停止
- en: ❺ Updates stats
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新统计数据
- en: We need to call the `pennies_game` function from a `main` function, and then
    we can play the game. The computer might win half the time on average. As it stands,
    this game isn’t that interesting. If two human opponents play, they will try to
    outsmart each other by being unpredictable. If the computer tracks our choices,
    we have more of a challenge. Let’s extend the game by allowing the computer to
    think, or at least base the prediction on previous moves. Can we manage to behave
    randomly and outdo the computer?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`main`函数中调用`pennies_game`函数，然后我们可以玩游戏。计算机平均可能会赢一半的时间。就目前而言，这个游戏并不那么有趣。如果两个对手都是人类，他们将通过不可预测的行为来试图智胜对方。如果计算机追踪我们的选择，我们面临更大的挑战。让我们通过允许计算机思考来扩展游戏，或者至少基于之前的移动来做出预测。我们能否设法表现得随机并打败计算机？
- en: 8.2 Matching pennies using an unordered_map
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用unordered_map进行匹配硬币
- en: Shannon tracked the state when a person played against his machine. Rather than
    tracking both the computer and player’s exact choices, he tracked whether a win
    or loss resulted in a change and whether that change resulted in a subsequent
    win or loss. For example, the person could lose, choose the same, and then lose
    again. This gives eight possible states, as shown in table 8.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 香农追踪一个人与他机器对战时的状态。他不是追踪计算机和玩家的确切选择，而是追踪赢或输是否导致改变，以及这种改变是否导致随后的赢或输。例如，这个人可能会输，选择相同，然后再次输。这给出了八种可能的状态，如表8.1所示。
- en: Table 8.1 The eight possible states in the pennies game
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 硬币游戏的八种可能状态
- en: '| Penultimate outcome | Choice | Last outcome |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 最后一次结果 | 选择 | 最后一次结果 | 结果 |'
- en: '| Lose | Same | Lose |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 同 | 输 |'
- en: '| Lose | Same | Win |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 同 | 赢 |'
- en: '| Lose | Change | Lose |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 变 | 输 |'
- en: '| Lose | Change | Win |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 变 | 赢 |'
- en: '| Win | Same | Lose |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 同 | 输 |'
- en: '| Win | Same | Win |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 同 | 赢 |'
- en: '| Win | Change | Lose |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 变 | 输 |'
- en: '| Win | Change | Win |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 变 | 赢 |'
- en: For each state, Shannon tracked the last two choices made by the player, noting
    whether they changed their turn or stuck with the same choice. If the two choices
    match, they form the prediction. If not, the mind reader makes a random choice.
    We could track every choice from the start of the game, but using the last two
    choices works well. Let’s think through what happens as we track the choices for
    each state. We will build up a pair of choices against state and use these to
    make a prediction if they match.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种状态，香农追踪玩家所做的最后两个选择，注意他们是否改变了他们的回合或坚持了相同的选择。如果两个选择匹配，它们形成预测。如果不匹配，占卜者做出随机选择。我们可以从游戏开始时追踪每一个选择，但使用最后两个选择效果很好。让我们思考一下追踪每个状态的选择会发生什么。我们将构建一对针对状态的选择，并使用这些来做出预测，如果它们匹配的话。
- en: Imagine we always choose heads, so we never change our minds. Can Shannon’s
    strategy figure out what we are doing? Over time, regardless of whether we win
    or lose, the choice in the middle of the table will always be Same, so only four
    rows get populated. Because we always play heads, the two last choices will eventually
    always be Same, leading to the Outcome column as shown in table 8.2.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们总是选择正面，所以我们从不改变主意。香农的策略能否找出我们在做什么？随着时间的推移，无论我们赢还是输，桌子中间的选择总是“同”，所以只有四行被填充。因为我们总是玩正面，所以最后两个选择最终总是“同”，导致结果列如表8.2所示。
- en: Table 8.2 The states and corresponding outcomes if we always choose heads
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 如果我们总是选择正面时的状态和对应结果
- en: '| State | Basis of prediction |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 预测基础 |'
- en: '| Penultimate outcome | Choice | Last outcome | Outcome |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 最后一次结果 | 选择 | 最后一次结果 | 结果 |'
- en: '| Lose | Same | Lose | Same, Same |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 同 | 输 | 同，同 |'
- en: '| Lose | Same | Win | Same, Same |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 同 | 赢 | 同，同 |'
- en: '| Lose | Change | Lose |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 变 | 输 |  |'
- en: '| Lose | Change | Win |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 输 | 变 | 赢 |  |'
- en: '| Win | Same | Lose | Same, Same |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 同 | 输 | 同，同 |'
- en: '| Win | Same | Win | Same, Same |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 同 | 赢 | 同，同 |'
- en: '| Win | Change | Lose |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 变 | 输 |  |'
- en: '| Win | Change | Win |  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 赢 | 变 | 赢 |  |'
- en: Any subsequent turn must correspond to one of the four populated rows because
    the choice will never change. The machine will find two matching outcomes of Same
    and predict that the player will choose the same, so it has seemingly read our
    minds. Were we to change our choice every time instead, the other four rows of
    the state table would eventually be populated with a pair of Changes, and again,
    the machine would predict correctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续的回合都必须对应于四个被填充的行之一，因为选择永远不会改变。机器将找到两个匹配的“同”结果并预测玩家将选择相同，因此它似乎已经读懂了我们的心思。如果我们每次都改变选择，状态表的其余四行最终将被填充成一对“变”，机器再次正确预测。
- en: 'It does take a while to populate the state table. Initially, none of the eight
    states has any entries, so the computer picks at random. Comparing this with the
    player’s choice tells us if the outcome is a win or a lose. We remember this outcome
    because it gives the first part of the state corresponding to the value for the
    first column. For the second turn, we still do not have any entries against the
    eight states to use for a prediction, so again, the computer picks at random,
    and the player takes a turn. We remembered the penultimate outcome and now know
    whether the player changed their mind and then won or lost. The extra information
    on this turn corresponds to the last two columns of the state:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 填充状态表确实需要一些时间。最初，八个状态中没有任何条目，所以计算机随机选择。将这个与玩家的选择进行比较，我们可以知道结果是一个胜利还是一个失败。我们记住这个结果，因为它给出了对应于第一列值的第一个状态的部分。对于第二次出牌，我们仍然没有针对八个状态的条目来用于预测，所以计算机再次随机选择，玩家进行一轮。我们记住了倒数第二个结果，现在知道玩家是否改变了主意，然后赢了或输了。这一轮的额外信息对应于状态表中的最后两列：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have a full current state, we are ready to add the first of the
    corresponding choices on the next turn. Again, the computer plays at random, but
    now we know whether the player sticks with the same choice or changes it. We record
    this as the first outcome against the previous state and then update the state
    that is ready for next time. In theory, the state might be the same as before,
    so on the next turn, we have a full pair for one row; otherwise, we have the start
    of a pair in another row. Over time, we will start filling in pairs of choices,
    meaning the computer may have matching outcomes against state and be able to make
    a prediction. The mind reader checks whether there is a matching pair in the state
    table for the current state. If so, the prediction is the value in the pair; otherwise,
    a random choice is made. The player makes their choice too, winning or losing.
    The state can then be updated, and the latest choice can be stored in the corresponding
    value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个完整的当前状态，我们准备在下一轮添加相应的第一个选择。同样，计算机随机出牌，但现在我们知道玩家是否坚持了同样的选择或改变了它。我们将这个记录为对前一个状态的第一种结果，然后更新为下一次准备的状态。理论上，状态可能和之前一样，所以在下一轮，我们可能有一对完整的条目在一行中；否则，我们可能在另一行中开始一对的选择。随着时间的推移，我们将开始填写选择对，这意味着计算机可能对状态有匹配的结果，并能够进行预测。读心者检查状态表中是否有与当前状态匹配的匹配对。如果有，预测就是该对中的值；否则，就随机选择。玩家也做出他们的选择，赢或输。然后可以更新状态，并将最新的选择存储在相应的值中。
- en: We noted that always switching or always choosing the same outcome would be
    detected by the machine. With a less obvious strategy, the eight states tracking
    the last two moves are too much to keep in our heads, so it’s hard to figure out
    what the machine is up to. The best way to outsmart the mind reader is by tracking
    the state ourselves so we know what it will predict and do the opposite. The mind
    reader is not reading the player’s mind, but it is difficult to track what it
    is doing, so it might give the impression of mind-reading or perhaps willfulness.
    Like many appearances of machine intelligence, what’s really going on is pattern
    matching or some kind of statistical analysis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，始终切换或始终选择相同的结果会被机器检测到。使用不那么明显的策略，跟踪最后两个移动的八个状态太多，难以记住，所以很难弄清楚机器在做什么。要战胜读心者，最好的办法是跟踪状态，这样我们就能知道它会预测什么，然后做相反的事情。读心者并不是在读取玩家的思想，但跟踪它的行为很难，所以它可能会给人一种读心或任性的印象。像许多机器智能的表象一样，真正发生的是模式匹配或某种类型的统计分析。
- en: Rather than using the last two states, we could keep every choice and use a
    majority, moving average, or other statistic to make a prediction. Shannon used
    a pair to keep the circuit he built small and simple but effective. Using the
    last two choices to make a prediction works surprisingly well, so let’s stick
    with Shannon’s original idea.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用最后两个状态，我们可以保留每一个选择，并使用多数、移动平均或其他统计方法来进行预测。香农使用一对来保持他构建的电路既小又简单但有效。使用最后两个选择进行预测出奇地有效，所以让我们坚持香农的原始想法。
- en: We can store the eight states in an associative container, using an `std::tuple`
    for the three-part key and an `std::pair` for the two outcomes. The tuple needs
    a win or lose, a choice of same or change, and another win or lose. A class enum
    would be a good way to represent these. We met scoped enumerations in chapter
    5 when we made suits for our card game. An enumeration is often clearer than a
    magic number because we can use a name to indicate the value, and a class enum
    is strongly typed, so it cannot be implicitly converted to an integer by mistake.
    The choice and outcome will be unknown initially, so we can use `Shrug` and `Unset`
    for these values. We only need to add the keyword `class` after `enum` to make
    scoped enums.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将八个状态存储在一个关联容器中，使用 `std::tuple` 作为三部分键，使用 `std::pair` 作为两个结果。元组需要一个赢或输，一个选择相同或改变，以及另一个赢或输。类枚举是表示这些的好方法。我们在第
    5 章制作扑克牌游戏套装时遇到了范围枚举。枚举通常比魔法数字更清晰，因为我们可以使用一个名称来表示值，并且类枚举是强类型的，因此它不能错误地隐式转换为整数。选择和结果最初是未知的，因此我们可以使用
    `Shrug` 和 `Unset` 来表示这些值。我们只需要在 `enum` 后面添加关键字 `class` 来创建范围枚举。
- en: Listing 8.3 Three possible choices and outcomes
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 三种可能的选择和结果
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The key for our state will be a tuple of an `Outcome`, a `Choice`, and another
    `Outcome`, indicating one of the rows from table 8.1, and the value will be a
    pair of `Choices`, so we need to include the `utility` and `tuple` headers. We
    could `typedef` the key and value to save typing `std::tuple<Outcome`, `Choice`,
    `Outcome>`, and `std::pair<Choice, Choice>` each time we use them. We can do better
    than `typedef`. C++11 introduced an *alias declaration*, allowing us to say `using`
    to introduce an alias for an existing type. We saw this in section 4.2.2 when
    we defined centuries and said `using centuries`. We can write
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们状态的关键将是一个包含 `Outcome`、`Choice` 和另一个 `Outcome` 的元组，表示表 8.1 中的某一行，而值将是一个 `Choices`
    对，因此我们需要包含 `utility` 和 `tuple` 头文件。我们可以为键和值使用 `typedef` 来节省每次使用时输入 `std::tuple<Outcome,
    Choice, Outcome>` 和 `std::pair<Choice, Choice>` 的麻烦。我们可以做得比 `typedef` 更好。C++11
    引入了 *别名声明*，允许我们使用 `using` 来为现有类型引入别名。我们在第 4.2.2 节中看到了这一点，当时我们定义了世纪并说 `using centuries`。我们可以写
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The alias declaration can be used for families of templates, so it is more general
    than a `typedef`, but they are equivalent if we specify all the template parameters.
    We will have further practice with the using declaration in the next chapter.
    For now, remember to prefer `using` to `typedef`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 别名声明可以用于模板族，因此它比 `typedef` 更通用，但如果我们指定所有模板参数，它们是等价的。我们将在下一章进一步练习使用声明。现在，请记住优先使用
    `using` 而不是 `typedef`。
- en: We have a key and value type for our state but need a container. We learned
    about the `std::map` in the last chapter and could use that again here. However,
    C++11 introduced *unordered* containers, which we can also use for a lookup table,
    so let’s find out how these containers work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了状态的关键和值类型，但需要一个容器。我们在上一章学习了 `std::map` 并可以再次在这里使用它。然而，C++11 引入了 *无序* 容器，我们也可以用于查找表，所以让我们来看看这些容器是如何工作的。
- en: 8.2.1 Unordered containers and std::hash
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 无序容器和 std::hash
- en: The `std::map` and `std::multimap`, along with `std::set` and `std::multiset`,
    are *ordered* associative containers using `std::less` as the default comparison
    for the ordering. As we learned in the last chapter, the elements are arranged
    in a balanced binary tree, so searching is `O(log(n))`. The unordered containers
    use an alternative data structure, called a hash table, which stores elements
    in slots or buckets. Let’s take a moment to learn about hash tables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`、`std::multimap` 以及 `std::set` 和 `std::multiset` 是使用 `std::less`
    作为排序默认比较的 *有序* 关联容器。正如我们在上一章所学，元素被排列在一个平衡的二叉树中，因此搜索是 `O(log(n))`。无序容器使用一个称为哈希表的不同数据结构，它将元素存储在槽或桶中。让我们花点时间来了解一下哈希表。'
- en: A hash table uses a `hash` function to calculate the index of an element, indicating
    which bucket it belongs to. The index allows us to jump straight to the bucket
    where an element belongs without having to walk down part of a tree, so searching
    a hash table might be even quicker than searching an `std::map` or other tree-based
    structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表使用 `hash` 函数来计算元素的索引，指示它属于哪个桶。索引允许我们直接跳转到元素所属的桶，而无需在树的一部分中遍历，因此搜索哈希表可能比搜索
    `std::map` 或其他基于树的结构的搜索更快。
- en: Now, two different elements might give the same `hash` value, known as a *collision*,
    so we may end up with more than one element in a specific bucket. A search then
    needs to check each element in the bucket to find a specific element, which slows
    things down slightly. For a good hash, we won’t get many collisions and will usually
    go straight to a bucket with a single element, but sometimes we might have to
    check a few elements in a bucket. In the worst case, we might have all our elements
    in a single bucket, so we would have complexity `O(n)`. However, for a decent
    `hash` function, we would expect one item per bucket, so the search is `O(1)`
    on average. In formal terms, we say the big-O or complexity is *amortized constant
    time*. Sometimes, the standard tells us the worst-case complexity for an operation,
    but sometimes it tells us the average or amortized time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个不同的元素可能具有相同的 `hash` 值，这被称为 *碰撞*，因此我们可能在特定的桶中有多个元素。搜索时需要检查桶中的每个元素以找到特定的元素，这会稍微减慢速度。对于一个好的哈希函数，我们不会得到很多冲突，通常可以直接访问只有一个元素的桶，但有时我们可能需要检查桶中的几个元素。在最坏的情况下，我们可能所有的元素都在一个桶中，因此我们的复杂度将是
    `O(n)`。然而，对于一个不错的 `hash` 函数，我们期望每个桶中只有一个项目，因此搜索的平均复杂度是 `O(1)`。在正式术语中，我们说大-O 或复杂度是
    *摊销常数时间*。有时，标准会告诉我们一个操作的最好情况复杂度，但有时它会告诉我们平均或摊销时间。
- en: Let’s visualize a hash table by mapping single characters’ keys to integer values.
    If we use the ASCII value of the lowercase version of the key for the `hash`,
    lower- and uppercase versions of the same letter will end up in the same bucket.
    If we add two elements, with keys `'c'` and `'d'`, we do not have a clash, so
    we have at most one ele-
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将单个字符键映射到整数值来可视化哈希表。如果我们使用键的小写版本的 ASCII 值作为 `hash`，则相同字母的大小写版本将结束在同一个桶中。如果我们添加两个元素，键为
    `'c'` 和 `'d'`，则没有冲突，所以我们最多只有一个元素。
- en: ment in a bucket. However, if we then add an element with key `'D'`, we have
    a clash because elements with key `'d'` and `'D'` go in the same bucket, as shown
    in figure 8.1.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个桶中存储元素。然而，如果我们随后添加一个键为 `'D'` 的元素，就会发生冲突，因为键为 `'d'` 和 `'D'` 的元素会存储在同一个桶中，如图
    8.1 所示。
- en: '![CH08_F01_Buontempo](../Images/CH08_F01_Buontempo.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Buontempo](../Images/CH08_F01_Buontempo.png)'
- en: Figure 8.1 Two hash tables, one without a collision and the second with a collision,
    meaning a bucket contains more than one element
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 两个哈希表，一个没有冲突，另一个有冲突，意味着一个桶包含多个元素
- en: To search for an element with a key of `'d'`, we need to check both elements
    in the second table. Now, a collision is not a disaster. We can still find the
    elements but get better performance with a better `hash` function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索键为 `'d'` 的元素，我们需要检查第二个表中的两个元素。现在，碰撞并不是灾难。我们仍然可以找到元素，但使用更好的 `hash` 函数可以获得更好的性能。
- en: C++11’s *unordered* containers are hash tables using `std::hash`, defined in
    the `functional` header, for the `hash` function. C++ provides specializations
    of `std::hash` for various types, including numeric types, as well as `std::string`
    and more (see [https://en.cppreference.com/w/cpp/utility/hash](https://en.cppreference.com/w/cpp/utility/hash)).
    If we want to put a type without a `hash` in an unordered container, we need to
    provide one. The type must support equality comparison too in case of `hash` collisions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 的 *unordered* 容器是使用 `std::hash` 的哈希表，定义在 `functional` 头文件中，作为 `hash` 函数。C++
    为各种类型提供了 `std::hash` 的特化，包括数值类型，以及 `std::string` 等（见 [https://en.cppreference.com/w/cpp/utility/hash](https://en.cppreference.com/w/cpp/utility/hash)）。如果我们想在无序容器中放置没有
    `hash` 的类型，我们需要提供一个。该类型还必须在 `hash` 冲突的情况下支持相等性比较。
- en: Let’s use an `std::unordered_map` from the `unordered_map` header for our state
    table. As with an `std::map`, this takes a `key` and a `value` type but also needs
    a `Hash` and a `KeyEqual` type. These default to `std::hash` and `std::equal_to`,
    along the lines of
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `unordered_map` 头文件中的 `std::unordered_map` 作为我们的状态表。与 `std::map` 一样，它需要一个
    `key` 和 `value` 类型，但还需要一个 `Hash` 和 `KeyEqual` 类型。这些默认为 `std::hash` 和 `std::equal_to`，类似于
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our key is an `std::tuple`, which supports `std::equal_to`. This was introduced
    in C++14 and defaults to a function object calling `operator==` on the given type.
    Comparing tuples works out of the box. Given two tuples
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的关键字是一个 `std::tuple`，它支持 `std::equal_to`。这是在 C++14 中引入的，默认为调用给定类型的 `operator==`
    的函数对象。比较元组是即插即用的。给定两个元组
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'we can check for equality:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查相等性：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is equivalent to
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we make an `std::equal_to` instance using `{}`, and then `std::equal_to`’s
    call operator invokes `operator==` by default. The default `KeyEqual` in the `unordered_map`
    class template therefore works for our key. However, `std::tuple` does not have
    a hash implementation, so we need to write our own. We can specialize the `struct`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`{}`创建一个`std::equal_to`实例，然后`std::equal_to`的调用操作符默认调用`operator==`。因此，`unordered_map`类模板中的默认`KeyEqual`适用于我们的键。然而，`std::tuple`没有哈希实现，因此我们需要自己编写。我们可以特殊化`struct`
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: for our tuple. By itself, the `struct` doesn’t do much. However, there are several
    specializations in the `functional` header providing an `operator()` `const`,
    taking a `Key`, and returning a `size_t`. Many of the operators are marked `noexcept`
    because they will not throw an exception. We will implement a specialization for
    the `state_t`. CppReference tells us we are allowed to inject a custom specialization
    of `std::hash` into the standard namespace (see [https://en.cppreference.com/w/cpp/utility/hash](https://en.cppreference.com/w/cpp/utility/hash)).
    We usually add code to our namespaces rather than namespace `std` to avoid clashing
    with standard code. Defining `std::hash` for a specific type is an exception.
    This means the `unordered_map` will find the specialization of `std::hash` for
    our key.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的元组。本身，这个`struct`并没有做什么。然而，`functional`头文件中有几个特殊化提供了`operator()` `const`，它接受一个`Key`并返回一个`size_t`。许多操作符被标记为`noexcept`，因为它们不会抛出异常。我们将为`state_t`实现一个特殊化。CppReference告诉我们，我们可以将自定义的`std::hash`特殊化注入到标准命名空间中（见[https://en.cppreference.com/w/cpp/utility/hash](https://en.cppreference.com/w/cpp/utility/hash)）。我们通常在我们的命名空间中添加代码，而不是在`namespace
    std`中，以避免与标准代码冲突。为特定类型定义`std::hash`是一个例外。这意味着`unordered_map`将找到我们键的`std::hash`特殊化。
- en: To specialize a template, we state the types we are special-casing. The `hash`
    only takes one type, `template<class Key>`, so we only have one type to special-case.
    We drop the `class Key` from the template head, leaving `template<>`, and we specify
    the type *after* the name in angle brackets, which gives us
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要特殊化一个模板，我们声明我们要特殊化的类型。`hash`只接受一个类型，`template<class Key>`，所以我们只有一个类型要特殊化。我们从模板头部删除`class
    Key`，留下`template<>`，并在尖括号中指定类型，这给我们
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our specialization needs an operator taking a key and returning a `size_t`.
    It needs to be `const`, and we can flag it as `noexcept`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特殊化需要一个接受键并返回`size_t`的操作符。它需要是`const`的，并且我们可以将其标记为`noexcept`：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our tuple has three enums, and the standard library provides specializations
    of `std::hash` for enumerations. We can write a `hash` function combining the
    individual elements’ hash values to provide the specialization for `std::hash<state_t>`.
    It would be nice to find a way to combine the hashes so we avoid a collision.
    Summing the hash values for
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的元组有三个枚举类型，标准库为枚举类型提供了`std::hash`的特殊化。我们可以编写一个`hash`函数，结合各个元素的哈希值，为`std::hash<state_t>`提供特殊化。如果能找到一个方法来组合哈希值，以避免冲突会很好。对于
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: would map to the same hash as
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 的哈希值之和会映射到与
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: causing a collision. We can do better if we can shift the hashes for each element
    using `operator<<`. We’ve used the stream insertion `operator<<` several times.
    The built-in arithmetic `operator<<` applies to numbers rather than streams, shifting
    the bits left (see [http://mng.bz/n1D5](http://mng.bz/n1D5)). Shifting the binary
    number `1,` `1` `<<` `1` gives `10` in binary because the one shifts left. If
    we then shift that once more, `2` `<<` `1`, we have `100` in binary. By not shifting
    the first elements, shifting the second element by one and shifting the last element
    by two, and then summing the three shifted hashes, we happen to avoid clashes
    for our keys. Our approach is no good in general. The more elements we try to
    combine, the greater chance of a collision, and the further left we shift, the
    more likely we are to end up with zeros. However, for our small number of `Outcome`s
    and `Choice`s, this approach does work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的哈希值，从而造成冲突。如果我们能使用`operator<<`对每个元素的哈希值进行位移，就能做得更好。我们已经多次使用过流插入`operator<<`。内置的算术`operator<<`适用于数字而不是流，它将位向左移动（见[http://mng.bz/n1D5](http://mng.bz/n1D5)）。将二进制数`1,`
    `1` `<<` `1`位移一次得到二进制数`10`，因为`1`向左移动了。如果我们再位移一次，`2` `<<` `1`，我们得到二进制数`100`。通过不位移第一个元素，将第二个元素位移一位，将最后一个元素位移两位，然后对这三个位移后的哈希值求和，我们恰好避免了键的冲突。我们的方法在一般情况下并不好。我们尝试组合的元素越多，冲突的可能性就越大，位移越向左，最终得到零的可能性就越高。然而，对于我们的少量`Outcome`s和`Choice`s，这种方法确实有效。
- en: We need to include the `functional` header for `std::hash`. The specialization
    for our tuple works as follows.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含 `functional` 头文件以使用 `std::hash`。我们元组的特化工作如下。
- en: Listing 8.4 Specializing `std::hash` for our state tuple
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 为我们的状态元组特化 `std::hash`
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Specializes std::hash for state_t
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为 state_t 特化 std::hash
- en: ❷ Implements operator()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实现 operator()
- en: ❸ Gets each element’s hash
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取每个元素的哈希
- en: ❹ Shifts and sums
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 移位和求和
- en: This will work for our specific-use case. WG21 has discussed hash combination
    functions (see [http://mng.bz/orDZ](http://mng.bz/orDZ)) and says that implementing
    a good `hash` function is not trivial. If we needed a more general way to combine
    fields into a suitable hash, the Boost library has a `hash_combine` method (see
    [http://mng.bz/6nre](http://mng.bz/6nre)). Boost is a free peer-reviewed library
    for C++ that has been around for a very long time. Many new C++ features started
    life in Boost, including smart pointers and the `optional`, `any`, and `variant`
    types. The library still includes many features that are not supported in C++
    yet but might be adopted one day. It’s big but worth having a look at if you’ve
    not seen it before.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适用于我们的特定用例。WG21 讨论了哈希组合函数（见 [http://mng.bz/orDZ](http://mng.bz/orDZ)）并说实现一个好的
    `hash` 函数并不简单。如果我们需要一个更通用的方法来组合字段以生成合适的哈希，Boost 库有一个 `hash_combine` 方法（见 [http://mng.bz/6nre](http://mng.bz/6nre)）。Boost
    是一个历史悠久、免费且经过同行评审的 C++ 库。许多新的 C++ 功能最初都是在 Boost 中出现的，包括智能指针和 `optional`、`any`
    以及 `variant` 类型。该库仍然包含许多 C++ 尚未支持但可能有一天会被采用的功能。它很大，但如果您以前从未见过它，那么值得一试。
- en: 'Armed with a `hash` function, we are ready to keep the state for our mind-reading
    machine in an `unordered_map`. After including the `unordered_map` header, we
    can write a function returning the initial state. The eight keys from table 8.1
    are represented in our `state_t` tuple. The tuple elements indicate a loss or
    win, followed by the player’s choice of Same or Swap, resulting in a win or lose.
    The corresponding values are a pair storing how the player chose on the last two
    occasions the state happened. Initially, there are no player choices to store,
    so we flag the state as unset, using a pair of `Shrug`s:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个 `hash` 函数后，我们就可以在 `unordered_map` 中保存心灵感应机器的状态了。在包含 `unordered_map` 头文件后，我们可以编写一个返回初始状态的函数。表
    8.1 中的八个键在 `state_t` 元组中表示。元组元素表示损失或胜利，然后是玩家选择“相同”或“交换”，结果是胜利或失败。相应的值是一个存储玩家在状态发生的前两次选择如何选择的对：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can initialize the `std::unordered_map` using initializer lists like we did
    for the `std::map` in the last chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用初始化列表来初始化 `std::unordered_map`，就像我们在上一章中为 `std::map` 所做的那样。
- en: Listing 8.5 An initial state table
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 初始状态表
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We tried to ensure we do not get hash collisions. For our eight states, a collision
    won’t noticeably slow the game down, but we can check that each bucket has at
    most one element. The `std::unordered_map` provides a `bucket_count`, which tells
    us how many buckets we have in total, and `bucket_size` function, which tells
    us how many items are in a specific bucket. We can write a `check_properties`
    function using `assert` to verify that we don’t have any clashes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图确保不会出现 hash 冲突。对于我们的八个状态，冲突不会明显减慢游戏速度，但我们可以检查每个桶中最多只有一个元素。`std::unordered_map`
    提供了一个 `bucket_count`，它告诉我们总共有多少个桶，以及一个 `bucket_size` 函数，它告诉我们特定桶中有多少个项。我们可以使用
    `assert` 来编写一个 `check_properties` 函数，以验证我们没有任何冲突。
- en: Listing 8.6 Checking that we have no `hash` collisions
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 检查是否存在 `hash` 冲突
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ At most one item per bucket
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个桶最多一个项
- en: The test passes, but our handcrafted `hash` function would potentially break
    if we added more states. Writing a `hash` function can be difficult.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了，但如果我们添加更多状态，我们手工制作的 `hash` 函数可能会出现问题。编写 `hash` 函数可能很困难。
- en: We can now start making predictions as a player makes a choice. Keeping the
    state separated from the mind-reading game means we can test our code more easily.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始根据玩家的选择进行预测。将状态与心灵感应游戏分开意味着我们可以更容易地测试我们的代码。
- en: 8.2.2 Using an unordered_map to make a prediction
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 使用 unordered_map 进行预测
- en: The mind reader either predicts a player’s choice based on the state table or
    makes a random choice. We’ll keep the state table in a class, providing a `getter`
    function and an `update` function, to use after each turn. We can use a private
    state table initialized with the `initial_state` function from listing 8.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 心灵感应者要么根据状态表预测玩家的选择，要么随机选择。我们将保持状态表在一个类中，提供 `getter` 函数和 `update` 函数，以便在每个回合后使用。我们可以使用一个由列表
    8.5 中的 `initial_state` 函数初始化的私有状态表。
- en: Listing 8.7 Class to track the game’s state
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 用于跟踪游戏状态的类
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Private state
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 私有状态
- en: ❷ Gets choices for a given state
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为给定状态获取选择
- en: ❸ Updates values when a turn is taken
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在回合中更新值
- en: We have eight valid states but need some warmup before we have a valid `state_t`
    to look up. For example, we will start with no turns and so have state
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有八个有效状态，但在我们有一个有效的 `state_t` 来查找之前需要一些预热。例如，我们将从没有回合开始，所以状态
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That state isn’t in table 8.1, so we’ll make the `choices` function return a
    pair of `Shrug`s in that case. We try to find a key in the lookup. The `find`
    method returns the `end` of the `unordered_map` if the element is not found, so
    we have an invalid state. If it is found, we return the corresponding value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该状态不在表 8.1 中，所以我们将使 `choices` 函数在这种情况下返回一对 `Shrug`s。我们尝试在查找中找到一个键。如果找不到元素，`find`
    方法返回 `unordered_map` 的 `end`，因此我们有一个无效状态。如果找到了，我们返回相应的值。
- en: Listing 8.8 Find the choices or return two `Shrug`s
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 查找选择或返回两个 `Shrug`s
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Tries to find the key
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试找到键
- en: ❷ In the warmup phase, so Shrug
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在预热阶段，所以 Shrug
- en: 'To update the state, we also need to be mindful of initial `state_t` not being
    in our state table. Again, we try to find the key:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态，我们还需要注意初始的 `state_t` 不在我们的状态表中。再次尝试找到键：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we have a valid state, we obtain the previous two choices from the iterator:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个有效状态，我们可以从迭代器中获取前两个选择：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then update the key with the new pair:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新键为新的一对：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In effect, updating the state ignores invalid states from the first few turns
    and only updates valid states.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，更新状态忽略了前几个回合中的无效状态，并且只更新有效状态。
- en: Listing 8.9 Updating choices for valid keys
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 更新有效键的选择
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Checks whether key exists
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查键是否存在
- en: ❷ Forms new pair of choices
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 形成新的选择对
- en: ❸ Updates lookup
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新查找
- en: We can use the `last_choices_t` returned by the `choices` to make a prediction,
    even for an initial invalid state. If the two elements match, we return that value;
    otherwise, we return `Choice::Shrug` to mean we cannot make a prediction. We returned
    a pair of `Shrug`s for an invalid state deliberately. Because they match, a `Shrug`
    is returned for an invalid state, so the mind reader knows to make a random choice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `choices` 返回的 `last_choices_t` 来做出预测，即使对于初始无效状态也是如此。如果两个元素匹配，我们返回该值；否则，我们返回
    `Choice::Shrug` 来表示我们无法做出预测。我们故意为无效状态返回了一对 `Shrug`s。因为它们匹配，所以对无效状态返回了 `Shrug`，这样心灵感应者就知道要随机选择。
- en: Listing 8.10 Choice from state
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 从状态中选择
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Matching, so return either value
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配，因此返回任意值
- en: ❷ Nonmatching, so can’t make a prediction
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 不匹配，因此无法做出预测
- en: We are now ready to build a mind reader. It will use our `State` class to make
    a prediction. The mind reader makes a prediction, and the player makes their choice.
    We then update the state table, ready to make a new prediction.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好构建一个心灵感应者。它将使用我们的 `State` 类来进行预测。心灵感应者做出预测，玩家做出选择。然后我们更新状态表，准备进行新的预测。
- en: 8.2.3 The mind reader game
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 心灵感应者游戏
- en: We can create a `mind` `reader` class using the `State` class we made in listing
    8.7\. We need a random flip for some states. We’ve used random numbers several
    times now using a generator and distribution. We can make a template class, taking
    these types so we can fake them in tests. When we tested our random blobs in listing
    6.12, we used a lambda that always returned `0` for the generator
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表 8.7 中创建的 `State` 类来创建一个 `mind` `reader` 类。对于某些状态，我们需要一个随机的翻转。我们已经使用生成器和分布使用随机数字几次了。我们可以创建一个模板类，接受这些类型，这样我们可以在测试中伪造它们。当我们测试列表
    6.12 中的随机块时，我们使用了一个总是返回 `0` 的 lambda 作为生成器
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and can do the same here. For the actual game, we use a proper generator and
    a distribution returning a `0` or `1`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以在这里做同样的事情。对于实际游戏，我们使用一个合适的生成器和返回 `0` 或 `1` 的分布：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the distribution and generator allows the mind reader to generate a random
    `0` or `1`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布和生成器允许心灵感应者生成一个随机的 `0` 或 `1`：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use that function to initialize a prediction variable:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用该函数来初始化一个预测变量：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The mind reader’s `prediction` will update after the player takes their turn,
    using the current state, so we need a `state` variable initialized with
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家走一步后，心灵感应者的`prediction`将更新，使用当前状态，因此我们需要一个初始化为
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will define the update function shortly. If it returns a `bool`, indicating
    a flip rather than a prediction, we can track how many guesses the mind reader
    made as we play the game. Our mind-reading class looks like this.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将定义更新函数。如果它返回一个`bool`，表示翻转而不是预测，我们可以在玩游戏时跟踪心灵感应者做了多少次猜测。我们的心灵感应器类看起来像这样。
- en: Listing 8.11 A mind-reading class
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 一个心灵感应器类
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Initially makes a random choice
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 最初做出随机选择
- en: ❷ Stores state and player’s turn
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储状态和玩家的回合
- en: When a player takes their turn, we update the mind reader, letting it know the
    player’s choice. First, the player’s choice either changed or not, so it can be
    used to update the current state using the function shown in listing 8.9\. We
    work out if the turn changed or not
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家走一步时，我们更新心灵感应者，让它知道玩家的选择。首先，玩家的选择要么改变了，要么没有改变，因此它可以用来使用列表8.9中显示的函数更新当前状态。我们计算出这一回合是否改变
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'and then update the state table accordingly:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后相应地更新状态表：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can then store the current `player_choice` in `previous_go` to be ready for
    next time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将当前的`player_choice`存储在`previous_go`中，以便下次使用。
- en: 'The current state has now changed, and a new prediction can be made, ready
    for the next turn. We update the state, shunting the previous win or lose to the
    front of the tuple and noting whether or not this turn was a change and whether
    or not it won:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态已经改变，可以做出新的预测，为下一回合做好准备。我们更新状态，将先前的输赢移到元组的开头，并注明这一回合是否改变以及是否获胜：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We look that state up in the table, `state_table.choices(state)`, and use the
    pair to decide a prediction method employing the function from listing 8.10\.
    We get a `Choice` back. For a `Shrug`, we flip the coin. For a `Change`, we want
    to switch a `0` with a `1` or vice versa so we can use the bitwise `operator^`,
    with `1`, which calculates `xor` of the choice with `1`, giving the opposite.
    If the prediction is Same, we know what the player chose this turn, so we update
    our prediction accordingly. We can do this in a new function in the `MindReader`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表中查找该状态，`state_table.choices(state)`，并使用列表8.10中的函数来决定一个预测方法。我们得到一个`Choice`。对于`Shrug`，我们抛硬币。对于`Change`，我们想要交换一个`0`和一个`1`或反之亦然，因此我们可以使用位运算符`^`，与`1`一起计算选择与`1`的异或，得到相反的结果。如果预测是Same，我们知道玩家这次选择了什么，因此我们可以相应地更新我们的预测。我们可以在`MindReader`的新函数中这样做。
- en: Listing 8.12 Updating the prediction
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 更新预测
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `update` function uses `update_prediction` after updating the state table
    and current state.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数在更新状态表和当前状态后使用`update_prediction`。'
- en: Listing 8.13 The mind reader’s `update` method
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 心灵感应者的`update`方法
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Updates the state table
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新状态表
- en: ❷ Updates state
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新状态
- en: ❸ Makes next prediction
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 做出下一个预测
- en: The game itself is now very like the pennies game we started with in listing
    8.2\. Rather than picking a random `0` or `1` in the main game loop, we need to
    consult the mind reader for a prediction. We will also track how many guesses
    there are and report that when the player stops.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏本身现在非常像我们在列表8.2中开始的便士游戏。在主游戏循环中，我们不需要随机选择`0`或`1`，而是需要咨询心灵感应者进行预测。我们还将跟踪猜测次数，并在玩家停止时报告。
- en: Listing 8.14 A mind-reading game
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 一个心灵感应器游戏
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Consults the mind reader
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 咨询心灵感应者
- en: ❷ Updates the mind reader
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新心灵感应者
- en: ❸ Reports guesses
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 报告猜测
- en: Call this from `main`, and see if you can outsmart the mind reader. If you track
    the state yourself, you can see what it will predict and win, but without pen
    and paper, you are likely to forget. It turns out it is very difficult to behave
    randomly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从`main`函数中调用此方法，看看你是否能比心灵感应者更聪明。如果你自己跟踪状态，你可以看到它会预测什么并赢得胜利，但没有纸笔，你很可能会忘记。结果证明，随机行为非常困难。
- en: We have a mind reader, and we can pack it up in a coroutine to learn about another
    new C++ feature.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个心灵感应者，我们可以将其打包到协程中，以了解另一个新的C++特性。
- en: 8.3 Coroutines
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 协程
- en: Coroutines were invented in the 1950s, and Melvin Conway coined the term in
    1958\. Later, in 1978, Tony Hoare described a type of coroutine called *communicating
    sequential processes* (CSP) in a paper in *Communications of the ACM* (see [https://dl.acm.org/doi/10.1145/359576.359585](https://dl.acm.org/doi/10.1145/359576.359585))
    and subsequently wrote a book of the same title in 1985\. He developed a concurrent
    programming language using sequential processes communicating through message
    passing. His approach avoids some common problems in concurrent code, such as
    deadlocks. His formal language allowed mathematical proof that such problems would
    not happen. At a very high level, the processes are functions with inputs and
    outputs. By wiring together inputs and outputs, several functions can run simultaneously
    without the need to protect shared memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是在 20 世纪 50 年代发明的，Melvin Conway 在 1958 年提出了这个术语。后来，在 1978 年，Tony Hoare 在 *Communications
    of the ACM* 的一篇论文中描述了一种名为 *communicating sequential processes*（CSP）的协程类型（参见 [https://dl.acm.org/doi/10.1145/359576.359585](https://dl.acm.org/doi/10.1145/359576.359585)），并在
    1985 年撰写了同名的书籍。他开发了一种使用通过消息传递进行通信的顺序过程进行并发编程的语言。他的方法避免了并发代码中的一些常见问题，例如死锁。他的形式化语言允许进行数学证明，证明这些问题不会发生。在非常高的层面上，这些过程是具有输入和输出的函数。通过连接输入和输出，几个函数可以同时运行，而无需保护共享内存。
- en: C++20 introduced Coroutines (see [http://mng.bz/5oEO](http://mng.bz/5oEO)).
    The support is relatively low level, so C++ coroutines often require a fair amount
    of boilerplate code. We can write a coroutine to yield the player’s choice and
    predictions. This will neither change the game nor harness the full power of asynchronous
    code, but we’ll discover what is required to build a coroutine and revise the
    rule of zero we learned about in chapter 6\. It’s worth having an overview of
    the building blocks needed even if we don’t use coroutines’ full potential.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了协程（参见 [http://mng.bz/5oEO](http://mng.bz/5oEO)）。对协程的支持相对较低级，因此 C++
    协程通常需要相当多的样板代码。我们可以编写一个协程来产生玩家的选择和预测。这既不会改变游戏，也不会发挥异步代码的全部威力，但我们将发现构建协程和修改第 6
    章中学习的零规则所需的内容。即使我们不使用协程的全部潜力，了解所需的构建块也是值得的。
- en: Coroutines are powerful and flexible. Suspending and resuming work, possibly
    on different threads, provides a type of parallelism. Lewis Baker wrote a series
    of blog posts going into a lot of detail (see [http://mng.bz/mjda](http://mng.bz/mjda)),
    and there are a lot of talks and blog posts on the internet about C++ coroutines
    because they are a big new feature that can be used in a variety of ways. Let’s
    learn the basics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 协程强大且灵活。挂起和恢复工作，可能在不同的线程上，提供了一种并行性。Lewis Baker 写了一系列博客文章，深入探讨了众多细节（参见 [http://mng.bz/mjda](http://mng.bz/mjda)），互联网上关于
    C++ 协程的讨论和博客文章也很多，因为它们是一个可以以多种方式使用的大新特性。让我们学习基础知识。
- en: 8.3.1 How to make a coroutine
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 如何创建协程
- en: 'A coroutine is a function containing one or more of the three keywords: `co_yield`,
    `co_await`, or `co_return`. *Yield* returns a value and *pauses* the function.
    The state of the coroutine is packaged up, allowing the suspended execution to
    continue later. An *await* expression calls an asynchronous operation and *resumes*
    when that completes. A *return* completes the function. Unlike a normal function,
    a coroutine’s lifetime is not tied to the caller. For example, the resumption
    can happen on a different thread. We won’t use that feature here but instead learn
    what we require to make a normal function into a coroutine. A coroutine function
    returns an object providing the required boilerplate, which allows the compiler
    to generate the coroutine code.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一个包含一个或多个三个关键字之一的函数：`co_yield`、`co_await` 或 `co_return`。*Yield* 返回一个值并*暂停*函数。协程的状态被封装起来，允许挂起的执行稍后继续。*await*
    表达式调用异步操作，并在该操作完成时*恢复*。*return* 完成函数。与普通函数不同，协程的生命周期并不绑定到调用者。例如，恢复可以发生在不同的线程上。我们在这里不会使用该功能，而是学习将普通函数转换为协程所需的内容。协程函数返回一个提供所需样板的对象，允许编译器生成协程代码。
- en: In most cases, we need to write code for the returned object, although C++23
    introduced `std::generator` ([http://mng.bz/7vmv](http://mng.bz/7vmv)), which
    provides a concrete type to return from a simple generator coroutine. CppReference
    gives sample code to output the letters of the alphabet from a coroutine called
    `letters`. The `letters` function is a coroutine because it uses `co_yield.` The
    function returns an `std::generator`, which provides what is required to wire
    up the initialization of the coroutine and handle the `co_yield`. The function
    has no `co_return`, which we noted completes a coroutine, so `letters` potentially
    generates an infinite sequence. We can call it as many times as we like. For example,
    we can use range’s `views` to obtain the first 26 letters via the `take` function.
    Unfortunately, `std::generator` isn’t widely supported yet, but Visual Studio
    2022 does provide an `experimental` version in the `experimental/generator` header.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们需要为返回的对象编写代码，尽管C++23引入了`std::generator`([http://mng.bz/7vmv](http://mng.bz/7vmv))，它提供了一个从简单的生成器协程返回的具体类型。CppReference提供了从名为`letters`的协程输出字母表的示例代码。`letters`函数是一个协程，因为它使用了`co_yield`。该函数返回一个`std::generator`，它提供了初始化协程和处理`co_yield`所需的内容。该函数没有`co_return`，我们注意到它完成了协程，因此`letters`可能生成一个无限序列。我们可以多次调用它。例如，我们可以使用range的`views`通过`take`函数获取前26个字母。不幸的是，`std::generator`尚未得到广泛支持，但Visual
    Studio 2022在`experimental/generator`头文件中提供了一个`experimental`版本。
- en: Listing 8.15 Using `std::generator`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 使用`std::generator`
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Uses experimental header
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用实验性头文件
- en: ❷ Coroutine returning a generator
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 协程返回生成器
- en: ❸ co_yield makes this function a coroutine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `co_yield`使这个函数成为协程。
- en: ❹ Calls the coroutine as often as we want
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 按照我们想要的次数调用协程
- en: Over time, we will probably see more concrete return objects for coroutines
    supported by the standard. For now, we usually have to write the boilerplate code
    ourselves, unless the `std::generator` is supported by our chosen compiler and
    works for our use case.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们可能会看到更多由标准支持的协程的具体返回对象。目前，我们通常不得不自己编写样板代码，除非我们选择的编译器支持`std::generator`并且适用于我们的用例。
- en: We will write a coroutine that `co_yields` a player’s input along with the mind
    reader’s prediction. The calling code will obtain and display the results. A coroutine
    version of our game is unnecessary, but understanding how to use this new C++
    feature will be informative. We will gradually build up the code required for
    a coroutine. So far, we have discovered that a coroutine
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个`co_yields`玩家输入和心灵感应者预测的协程。调用代码将获取并显示结果。我们的游戏不需要协程版本，但了解如何使用这个新的C++特性将是有益的。我们将逐步构建协程所需的代码。到目前为止，我们发现协程
- en: Is a function containing `co_yield`, `co_await`, or `co_return`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一个包含`co_yield`、`co_await`或`co_return`的函数
- en: Returns an object providing the required boilerplate
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个提供所需样板代码的对象
- en: Listing 8.15 has a `co_yield`, and the generator provides the required boilerplate.
    To make our game into a coroutine, we will
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15有一个`co_yield`，生成器提供了所需的样板代码。为了将我们的游戏转换为协程，我们将
- en: Write a function containing `co_yield` and `co_return` (section 8.3.2)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个包含`co_yield`和`co_return`的函数（第8.3.2节）
- en: Return a user defined class called `Task`, although any other name can be used
    (section 8.3.3)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个用户定义的名为`Task`的类，尽管可以使用任何其他名称（第8.3.3节）
- en: Implement a `promise_type`, which must be called that just because the compiler
    expects it (section 8.3.3)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`promise_type`，必须这样命名，因为编译器期望它（第8.3.3节）
- en: 'The `Task` and `promise_type` start, stop, and yield data from the coroutine
    function, so we will add details:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`和`promise_type`从协程函数中启动、停止并产生数据，因此我们将添加以下细节：'
- en: Creation and destruction of the `Task` and `promise_type` (section 8.3.4)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`和`promise_type`的创建和销毁（第8.3.4节）'
- en: Starting and stopping the coroutine and how to `co_yield` data or `co_return`
    (section 8.3.5)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止协程以及如何`co_yield`数据或`co_return`（第8.3.5节）
- en: To the `Task` itself, allowing the calling code to resume the coroutine after
    it has suspended until the game is done (section 8.3.6)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许调用代码在协程挂起后继续执行，直到游戏结束（第8.3.6节）
- en: We end with calling code using the `Task`, which gives us a new version of the
    game.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以调用代码使用`Task`结束，这为我们提供了一个游戏的新版本。
- en: 8.3.2 A coroutine function
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 协程函数
- en: In listing 8.14, we wrote a `mind_reader` function, handling user input, obtaining
    a prediction, and displaying outcomes. We will pull out the user input and predictions
    to form a coroutine. We need to include the `coroutine` header, and our new function
    will return an object that provides the boilerplate needed for a coroutine. Let’s
    call it a `Task` and implement it in the next section. We’ll start with the coroutine
    itself.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.14 中，我们编写了一个 `mind_reader` 函数，处理用户输入，获取预测并显示结果。我们将提取用户输入和预测以形成一个协程。我们需要包含
    `coroutine` 头文件，并且我们的新函数将返回一个提供协程所需样板代码的对象。让我们称它为 `Task` 并在下一节中实现它。我们将从协程本身开始。
- en: Like before, we create a `MindReader` object and loop while the user wants to
    play. Our coroutine will stop using `co_return` if the player gives up. Otherwise,
    we `co_yield` the player’s choice and the mind reader’s prediction. Adding `co_return`
    or `co_yield` to a function and returning a suitable object makes a coroutine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们创建一个 `MindReader` 对象，并在用户想要玩游戏时循环。如果玩家放弃，我们的协程将使用 `co_return` 停止。否则，我们
    `co_yield` 玩家的选择和心灵感应者的预测。将 `co_return` 或 `co_yield` 添加到函数并返回一个合适的对象，就可以创建一个协程。
- en: Listing 8.16 Our first coroutine
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 我们的第一个协程
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Forward-declares the Task we will implement shortly
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 前置声明我们将要实现的 Task
- en: ❷ Coroutine function returning a suitable object
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回合适对象的协程函数
- en: ❸ Stops if player gives up
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果玩家放弃，则停止
- en: ❹ Yields player’s turn and mind reader’s prediction
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 产生玩家的回合和心灵感应者的预测
- en: The compiler uses functions from the returned `Task` to wire up what’s needed
    for the yields and return, as well as making a *coroutine frame*. This packages
    up the function, allowing it to suspend when it hits a `co_XXX` function. When
    we yield a choice and a prediction, the coroutine is suspended until resumed.
    The coroutine then picks up on the next line, with the same state as when it was
    paused, updating the mind reader. If we debug the coroutine, we will seem to teleport
    into the middle of the `while` loop when we resume.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用返回的 `Task` 中的函数来连接所需的生成和返回，以及创建一个*协程帧*。这封装了函数，允许它在遇到 `co_XXX` 函数时挂起。当我们生成一个选择和一个预测时，协程将挂起直到恢复。协程然后从下一行开始，状态与它暂停时相同，更新心灵感应者。如果我们调试协程，当我们恢复时，我们似乎会瞬间出现在
    `while` 循环的中间。
- en: The coroutine state is usually dynamically allocated, so it is often described
    as *stackless*. In effect, a coroutine is a function bundled up as a dynamic object
    so that it can be paused (*suspended)* and *resumed* until completed. A coroutine
    can even be resumed on a different thread. The control passes between the caller
    and the coroutine, as figure 8.2 shows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态通常是动态分配的，因此它通常被描述为*无栈的*。实际上，协程是一个捆绑成动态对象的功能，以便它可以暂停（*挂起*）和*恢复*直到完成。协程甚至可以在不同的线程上恢复。控制权在调用者和协程之间传递，如图
    8.2 所示。
- en: '![CH08_F02_Buontempo](../Images/CH08_F02_Buontempo.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_Buontempo](../Images/CH08_F02_Buontempo.png)'
- en: Figure 8.2 A coroutine can be suspended and resumed as needed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 协程可以根据需要暂停和恢复。
- en: We forward-declared a `Task` to return from our coroutine, so let’s implement
    it next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前置声明了一个 `Task` 以从我们的协程返回，所以让我们接下来实现它。
- en: 8.3.3 The coroutine’s return object
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 协程的返回对象
- en: A coroutine’s return object is often described as a promise or task, but we
    are free to use any name we like. We’ll need to add several functions for our
    coroutine to work. The requirements vary, depending on each coroutine, but we
    always see two things. First, a *promise object*, which is used to send results
    or report exceptions to code outside the coroutine, and second, a coroutine handle,
    which is used inside the coroutine to resume execution or destroy the coroutine
    frame when finished.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的返回对象通常被描述为承诺或任务，但我们有权使用我们喜欢的任何名称。我们需要为我们的协程添加几个函数才能使其工作。具体要求因协程而异，但我们总是看到两件事。首先是一个*承诺对象*，它用于将结果或异常报告给协程外的代码，其次是一个协程句柄，它用于协程内部在完成时恢复执行或销毁协程帧。
- en: Let’s gradually build up our `Task`. The compiler requires something called
    `promise_type` inside our `Task`. We can either define a class separately and
    add a `using` declaration to the task, or we can define a class inline as a nested
    class in `Task`. We’ll use a nested class, so our `Task` returned by the coroutine
    starts like this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步构建我们的 `Task`。编译器要求在 `Task` 内部有一个名为 `promise_type` 的东西。我们既可以单独定义一个类并将其添加到任务中的
    `using` 声明中，也可以在 `Task` 中作为嵌套类内联定义一个类。我们将使用嵌套类，因此我们的协程返回的 `Task` 将像这样开始。
- en: Listing 8.17 Structure to wire up coroutine
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 连接协程的结构
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Task returned by listing 8.16
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列表 8.16 返回的任务
- en: ❷ Required structure
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所需结构
- en: The compiler uses the `Task`, which we returned from the `coroutine_game` in
    listing 8.16, and its `promise_type` to generate code. We need several more details
    in the `promise_type` and `Task` to make our `coroutine_game` compile. We could
    use any name for our return type, although `Task` is a commonly used name; however,
    we must have an associated class called `promise_type`. The `Task` and `promise_type`
    allow the coroutine to start, stop, and yield data. Let’s fill in the details.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用我们从列表 8.16 的 `coroutine_game` 返回的 `Task` 以及其 `promise_type` 来生成代码。我们需要在
    `promise_type` 和 `Task` 中添加更多细节，以便我们的 `coroutine_game` 能够编译。我们可以为我们的返回类型使用任何名称，尽管
    `Task` 是一个常用的名称；然而，我们必须有一个名为 `promise_type` 的相关类。`Task` 和 `promise_type` 允许协程开始、停止和产生数据。让我们填写这些细节。
- en: 8.3.4 RAII and the rule of zero
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 RAII 和零规则
- en: 'In listing 8.16, we wrote a coroutine returning the `Task` we just started
    creating. The code generated by a compiler for a coroutine gets a `Task` from
    the `promise_type` by calling a `get_return_object` function, something along
    the lines of this pseudocode:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.16 中，我们编写了一个返回我们刚刚开始创建的 `Task` 的协程。编译器为协程生成的代码通过调用一个 `get_return_object`
    函数从 `promise_type` 获取一个 `Task`，这个函数的伪代码如下：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We don’t create a `Task` directly. Only the `promise_type` does this in the
    `get_return_ object` function. As it stands, we could add a function to the promise_type:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有直接创建一个 `Task`。只有 `promise_type` 在 `get_return_object` 函数中这样做。目前，我们可以在 `promise_type`
    中添加一个函数：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, we can still create `Task`s anywhere, which aren’t of much use to anything
    other than the compiler. If we give `Task` a private constructor, the `promise_type`
    can make a task because we made it an inner class, but nothing else can.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以在任何地方创建 `Task`，这对除了编译器之外的其他东西没有多大用处。如果我们给 `Task` 一个私有构造函数，`promise_type`
    可以创建一个任务，因为我们将其作为内部类创建，但其他任何东西都不能。
- en: In addition, we noted the promise object sends results or reports exceptions
    to code outside the coroutine, and we use a coroutine handle to resume execution
    or destroy the coroutine frame when finished. Coroutines provide a `from_promise`
    method to obtain an `std::coroutine_handle`, so if we store a pointer to the `promise_
    type` in `Task`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还注意到承诺对象将结果或异常发送到协程外的代码，我们使用协程句柄来恢复执行或销毁协程帧。协程提供了一个 `from_promise` 方法来获取
    `std::coroutine_handle`，因此如果我们把 `promise_type` 的指针存储在 `Task` 中
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: we can contain a handle when needed with
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在需要时使用以下方式包含句柄
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, raw pointers are often troublesome. We don’t need to delete the pointer
    because the compiler deals with the coroutine’s lifetime for us, but we should
    call the `destroy` method when we’re done. If we add a destructor to `Task`, we
    can perform the necessary tidy-up using RAII. In the destructor, we could make
    a handle from the `promise` and call
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，原始指针通常很麻烦。我们不需要删除指针，因为编译器会为我们处理协程的生命周期，但当我们完成时应该调用 `destroy` 方法。如果我们给 `Task`
    添加一个析构函数，我们可以使用 RAII 执行必要的清理。在析构函数中，我们可以从 `promise` 创建一个句柄并调用
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However, chapter 6 told us that adding our own destructor blocks implicit moves
    but leaves copy operations available. Copying a `Task` is a potential resource
    leak. We can either explicitly delete the copies and default the moves or use
    a smart pointer for the promise pointer. Using a smart pointer means we no longer
    need a destructor to tidy up for us.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第 6 章告诉我们，添加我们自己的析构函数阻止了隐式移动，但保留了复制操作。复制 `Task` 可能会导致资源泄露。我们可以显式删除副本并使移动操作成为默认，或者使用智能指针来处理承诺指针。使用智能指针意味着我们不再需要一个析构函数来为我们清理。
- en: 'In chapter 6, we met `std::unique_ptr`. We accepted the default `"delete"`
    there because we had raw pointers we wanted to be deleted. Now we want something
    different to happen. Smart pointers take a type and a deleter, which defaults
    to calling `delete`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章中，我们遇到了 `std::unique_ptr`。我们当时接受默认的 `"delete"` 是因为我们想要删除原始指针。现在我们想要不同的行为。智能指针需要一个类型和一个删除器，默认情况下会调用
    `delete`：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Our deleter needs to call `destroy` on a handle obtained `from_promise` with
    our `promise_type` pointer. We can write a more general function for any promise
    type using a class template.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的需要调用 `destroy` 方法来处理从 `from_promise` 获取的句柄，句柄与我们的 `promise_type` 指针相关。我们可以使用类模板编写一个更通用的函数，适用于任何
    `promise` 类型。
- en: Listing 8.18 Custom `"deleter"`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 自定义 `"deleter"`
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Template function for any promise type
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任何 `promise` 类型的模板函数
- en: ❷ Gets handle from promise
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 `promise` 获取句柄
- en: ❸ Calls destroy if there is a handle
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果有句柄则调用 `destroy`
- en: 'We can then declare a family of templates utilizing the deleter with the `using`
    statement we met earlier. We use an `std::unique_ptr` of any type, `T`, with a
    `coro_ deleter<T>`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们之前遇到的 `using` 语句声明一个使用删除器的模板家族。我们使用任何类型 `T` 的 `std::unique_ptr`，带有
    `coro_deleter<T>`：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can now use a `promise_ptr` in the `Task` and rely on the rule of zero. There
    are no copies to delete or moves to default because we don’t have to define a
    destructor anymore, as the `std::unique_ptr` will do the tidying up for us.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `Task` 中使用 `promise_ptr` 并依赖零规则。因为没有必要再定义析构函数，因为 `std::unique_ptr`
    会为我们清理。
- en: We can now fill in a few more functions in `Task`. First, we add a private constructor
    taking a `promise_type` pointer and store that in a `promise_ptr`. We can then
    add a `get_return_object` function to the `promise_type` returning a `Task`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `Task` 中填充更多函数。首先，我们添加一个接受 `promise_type` 指针的私有构造函数，并将其存储在 `promise_ptr`
    中。然后，我们可以向 `promise_type` 添加一个返回 `Task` 的 `get_return_object` 函数。
- en: Listing 8.19 Structure to wire up coroutine
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 连接协程的结构
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Task only created by the promise_type
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只由 promise_type 创建 Task
- en: ❷ A smart pointer for RAII
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于 RAII 的智能指针
- en: ❸ Private constructor
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 私有构造函数
- en: We’ve written enough for a `Task` to be created and a coroutine handle destroyed
    when we’re done. We still need to add a few more functions to deal with what happens
    between creation and destruction. Let’s fill in the details to make the `co_yield`
    and `co_return` used in listing 8.16 work.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了足够的代码来创建 `Task` 和在完成时销毁协程句柄。我们仍然需要添加一些更多函数来处理创建和销毁之间的操作。让我们填写细节，以便使列表
    8.16 中使用的 `co_yield` 和 `co_return` 正常工作。
- en: 8.3.5 Filling in the promise_type
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.5 填充 `promise_type`
- en: 'Let’s begin with the `promise_type`. The compiler injects code based on functions
    in this class. We always need to define three functions stating what happens in
    the following cases:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `promise_type` 开始。编译器根据这个类中的函数注入代码。我们总是需要定义三个函数，说明以下情况会发生什么：
- en: When we first start the coroutine
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们首次启动协程时
- en: If an exception is thrown
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抛出异常
- en: When the coroutine stops
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当协程停止时
- en: 'Any uncaught exception in the body of the coroutine invokes an `unhandled_
    exception` method. The simplest implementation does nothing:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 协程体中任何未捕获的异常都会调用 `unhandled_exception` 方法。最简单的实现是不做任何事情：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Alternatively, we could log the problem and even call terminate.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以记录问题甚至调用终止。
- en: 'We also need methods called `initial_suspend` and `final_suspend` to indicate
    whether to suspend. As part of coroutines support, C++20 introduced two helper
    classes, `suspend_always` and `suspend_never`, to suspend or not, respectively.
    We want our coroutine to get the user input and prediction ready for the calling
    code, so we use `suspend_never` to indicate it should run initially:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要名为 `initial_suspend` 和 `final_suspend` 的方法来指示是否挂起。作为协程支持的一部分，C++20 引入了两个辅助类
    `suspend_always` 和 `suspend_never`，分别用于挂起或不挂起。我们希望我们的协程能够获取用户输入和预测，以便调用代码使用，所以我们使用
    `suspend_never` 来表示它应该最初运行：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice the `noexcept` we met in section 8.2.1 when we wrote a `hash` function.
    Never suspending is sometimes called a hot start, whereas pausing the coroutine
    initially is a cold start. When we’re finished, we always suspend to flag we are
    done:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在 8.2.1 节中编写的 `hash` 函数时遇到的 `noexcept`。从不挂起有时被称为热启动，而最初暂停协程则称为冷启动。当我们完成时，我们总是挂起以标记我们已经完成：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This sets a flag on the coroutine handle so the `Task` can see if the coroutine
    has finished.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这在协程句柄上设置了一个标志，这样 `Task` 就可以查看协程是否已完成。
- en: 'We have dealt with the start and end of the coroutine but have not provided
    code to handle `co_await`, `co_yield`, or `co_return` yet. Our coroutine in listing
    8.16 yields a choice from the player and a prediction:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了协程的开始和结束，但还没有提供处理 `co_await`、`co_yield` 或 `co_return` 的代码。列表 8.16 中的协程提供了玩家的选择和预测：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The compiler therefore hunts for a `yield_value` method returning a pair of
    `int`s in our `promise_type`. If we didn’t use `co_yield`, we would not need this
    method. We can store the `std::pair` of `ints` in the promise so the `Task` can
    access them and return them to the code outside the coroutine.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器会在我们的 `promise_type` 中寻找返回一对 `int` 的 `yield_value` 方法。如果我们没有使用 `co_yield`，我们就不需要这个方法。我们可以在承诺中存储
    `std::pair` 的 `int`，这样 `Task` 就可以访问它们并将它们返回到协程外的代码。
- en: 'After a yield, we suspend the coroutine and indicate this by returning `suspend_
    always` from the `yield_value` method:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `yield` 之后，我们挂起协程，并通过从 `yield_value` 方法返回 `suspend_always` 来表示这一点：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Control then returns to the calling code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 控制权返回到调用代码。
- en: 'We called `co_return` when a player gives up, so we need to add another function
    to the `promise_type`. The `co_return` can either be void or followed by an expression
    to return. Ours is `void`, so we need a `return_void` method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家放弃时，我们调用`co_return`，因此我们需要向`promise_type`添加另一个函数。`co_return`可以是空的，或者后面跟着一个表达式来返回。我们的`co_return`是空的，所以我们需要一个`return_void`方法：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we wanted to return a value, we would need a `return_value` function instead.
    Our complete promise type is as follows.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要返回一个值，我们需要一个`return_value`函数而不是`co_return`。我们的完整承诺类型如下。
- en: Listing 8.20 Complete promise type
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.20 完整的承诺类型
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Data
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数据
- en: ❷ Creates a Task
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建任务
- en: ❸ Starts up
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 启动
- en: ❹ Stops
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 停止
- en: ❺ Exception handling
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 异常处理
- en: ❻ Called by Task’s co_yield
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由Task的co_yield调用
- en: ❼ Called by Task’s co_return
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 由Task的co_return调用
- en: We are nearly done. The `promise_type` now has all the methods needed by the
    coroutine. The `Task` returned by the coroutine gives us a place to indicate the
    data in the promise and will resume the coroutine until it’s done. Let’s fill
    in these missing pieces.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。`promise_type`现在拥有了协程所需的所有方法。协程返回的`Task`为我们提供了一个地方来指示承诺中的数据，并将协程恢复到完成。让我们填补这些缺失的部分。
- en: 8.3.6 Filling in the Task type
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.6 填充`Task`类型
- en: 'To return the choice and prediction from the `Task`, we provide a getter function,
    obtaining the `std::pair` of data from the `promise_ptr`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Task`返回选择和预测，我们提供一个获取器函数，从`promise_ptr`获取数据的`std::pair`：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can check if the coroutine is finished by calling the handle’s `done` method.
    This flag is set to true when the `promise_type`''s `final_suspend` method is
    called and returns a `suspend_always`. We use the `from_promise` method to get
    the handle and then see if we’re done:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用句柄的`done`方法来检查协程是否完成。当`promise_type`的`final_suspend`方法被调用并返回`suspend_always`时，此标志被设置为true。我们使用`from_promise`方法来获取句柄，然后查看我们是否完成：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we used `co_yield` in listing 8.16, the coroutine paused. The calling
    code then does what it wants with the player’s choice and mind reader’s prediction,
    but it needs a way to resume the coroutine to get the next pair. We resume the
    coroutine by calling the handle’s `operator()()`. We can add a function to our
    `Task` called `next`, resuming the coroutine:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在列表8.16中使用`co_yield`时，协程暂停。然后调用代码使用玩家的选择和心灵感应者的预测做它想做的事情，但它需要一种方法来恢复协程以获取下一对。我们通过调用句柄的`operator()()`来恢复协程。我们可以在`Task`中添加一个名为`next`的函数，以恢复协程：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The calling code can then call `next` when it’s used the previous choice and
    prediction. Adding these new methods to `Task`, we have the following.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用代码使用之前的选项和预测时，它可以调用`next`。将这些新方法添加到`Task`中，我们得到以下内容。
- en: Listing 8.21 The coroutine's `Task` and `promise_type`
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.21 协程的`Task`和`promise_type`
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Task returned by coroutine in listing 8.16
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列表8.16中协程返回的任务
- en: ❷ promise_type from listing 8.20
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 列表8.20中的promise_type
- en: ❸ Lets calling code get data from promise
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 让调用代码从承诺中获取数据
- en: ❹ Lets calling code know if we’re done
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 让调用代码知道我们是否完成
- en: ❺ Resumes coroutine
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 恢复协程
- en: ❻ Smart pointer for RAII
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ RAII的智能指针
- en: ❼ Private constructor visible by promise_type
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ promise_type可见的私有构造函数
- en: Our `Task` is now complete, and we can use the coroutine.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Task`现在已经完成，我们可以使用协程。
- en: 8.3.7 A coroutine mind reader
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.7 一个协程心灵感应者
- en: To use our coroutine, we can use code similar to the original game in listing
    8.14, but the `MindReader` and user input are now bundled inside the `coroutine_game`.
    We call the coroutine using
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的协程，我们可以使用类似于列表8.14中原始游戏的代码，但现在`MindReader`和用户输入现在都包含在`coroutine_game`中。我们通过调用以下内容来调用协程：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We use the `Task` to control the coroutine. We loop until `done`, getting the
    player’s choice and prediction at each turn. This pauses the coroutine at the
    `co_yield`. Our calling code then gets control back and displays the results.
    By calling `next` on the `Task`, control then returns to the coroutine, and it
    picks up where it left off. Our calling code looks like this.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Task`来控制协程。我们循环直到`done`，在每一轮获取玩家的选择和预测。这将在`co_yield`处暂停协程。然后我们的调用代码重新获得控制权并显示结果。通过在`Task`上调用`next`，控制权随后返回到协程，并从上次离开的地方继续。我们的调用代码如下所示。
- en: Listing 8.22 A coroutine version of a mind reader
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.22 一个心灵感应者的协程版本
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ Gets the coroutine
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取协程
- en: ❷ Sees if the user stopped
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查用户是否停止
- en: ❸ Gets data from coroutine
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从协程中获取数据
- en: ❹ Lets coroutine resume
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 允许协程恢复
- en: Using a coroutine makes no difference to our mind reader, but we have used a
    frequently discussed feature from C++20\. We could extend this and write another
    coroutine to `co_await` input from `std::cin`, a function returning a random flip,
    or even another mind reader.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程对我们来说没有区别，但我们已经使用了 C++20 中经常讨论的一个特性。我们可以扩展这个特性，并编写另一个协程来 `co_await` 从 `std::cin`
    输入，一个返回随机翻转的函数，甚至另一个心灵感应者。
- en: 'Coroutines can be used in a variety of places, including asynchronous operations
    waiting on input or other resources. Andreas Fertig’s book *Programming with C++20:
    Concepts, Coroutines, Ranges, and More* (Fertig Publications, 2021) has a chapter
    devoted to parsing a byte stream with coroutines. He published an overview in
    Overload in 2022 (see [https://accu.org/journals/overload/30/168/fertig/](https://accu.org/journals/overload/30/168/fertig/)).
    Rayner Grimm lists several possible use cases on his blog, including event-driven
    programming and cooperative multitasking (see [http://mng.bz/qjPr](http://mng.bz/qjPr)).
    If a coroutine is suspended, another part of the program can then run instead,
    so coroutines offer a constrained concurrency model.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '协程可以在各种地方使用，包括等待输入或其他资源的异步操作。Andreas Fertig 的书 *Programming with C++20: Concepts,
    Coroutines, Ranges, and More* (Fertig Publications, 2021) 有一章专门介绍使用协程解析字节流。他在
    2022 年在 Overload 上发表了概述（见 [https://accu.org/journals/overload/30/168/fertig/](https://accu.org/journals/overload/30/168/fertig/)）。Rayner
    Grimm 在他的博客上列出了几个可能的用例，包括事件驱动编程和协作多任务（见 [http://mng.bz/qjPr](http://mng.bz/qjPr)）。如果一个协程被挂起，那么程序的其他部分就可以运行，因此协程提供了一个受限的并发模型。'
- en: We’ve been through many C++ features, and we are nearly done. We have used templates
    with parameter packs several times now, but we have not looked into how they work.
    Let’s round off our learning with a final chapter exploring templates further.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了许多 C++ 特性，我们几乎完成了。现在我们已经多次使用了模板参数包，但我们还没有探讨它们是如何工作的。让我们以最后一章进一步探索模板来结束我们的学习。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can alias a declaration with the keyword `using`, including families of templates.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用关键字 `using` 来给声明起别名，包括模板家族。
- en: C++’s unordered containers use hash tables.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的无序容器使用哈希表。
- en: Hash tables store elements in buckets and use a `hash` function to locate a
    bucket.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表将元素存储在桶中，并使用 `hash` 函数来定位桶。
- en: An `std::unordered_map` uses `std::hash` and `std::equal_to` for the keys by
    default.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 默认使用 `std::hash` 和 `std::equal_to` 作为键。'
- en: We can inject a `hash` function into `namespace` `std` to support a user-defined
    type in an `std::unordered_map`.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将 `hash` 函数注入到 `namespace` `std` 中，以支持在 `std::unordered_map` 中的用户定义类型。
- en: 'A C++ coroutine is a function containing one or more of the following three
    keywords: `co_yield`, `co_await`, or `co_return`.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 协程是一个包含一个或多个以下三个关键字之一的函数：`co_yield`、`co_await` 或 `co_return`。
- en: A coroutine can be suspended and resumed.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程可以被挂起和恢复。
- en: The return type of a coroutine is usually a user-defined type, containing functions
    required to start and stop the coroutine, as well as functions backing `co_yield`
    and `co_await` as needed.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程的返回类型通常是用户定义的类型，包含启动和停止协程所需的函数，以及根据需要支持 `co_yield` 和 `co_await` 的函数。
- en: C++23 introduced an `std::generator` for use as the return type of a coroutine,
    providing a potentially infinite sequence, but for other uses, we currently have
    to write our own promise or task, providing the required boilerplate code.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++23 引入了 `std::generator` 作为协程的返回类型，提供了一种可能无限长的序列，但对于其他用途，我们目前不得不自己编写承诺或任务，提供所需的样板代码。
- en: We used a *custom deleter* for `std::unique_ptr` to allow us to use the rule
    of zero.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为 `std::unique_ptr` 使用了 *自定义删除器*，以便我们可以使用零规则。
