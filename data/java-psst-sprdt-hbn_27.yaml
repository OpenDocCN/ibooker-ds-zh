- en: Appendix A. Maven
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. Maven
- en: Maven ([https://maven.apache.org](https://maven.apache.org)) can be regarded
    as a source-building *environment*. To better understand how Maven works, you
    need to understand the key points (principles) that stand behind Maven. From the
    very beginning of the Maven project, certain ground rules were created for software
    architecture. These rules aimed to simplify development with Maven and make it
    easier for developers to implement the build system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Maven ([https://maven.apache.org](https://maven.apache.org)) 可以被视为一个源构建 *环境*。为了更好地理解Maven的工作原理，你需要了解Maven背后的关键点（原则）。从Maven项目的开始，就为软件架构制定了一些基本规则。这些规则旨在简化使用Maven的开发，并使开发者更容易实现构建系统。
- en: 'One of the fundamental ideas of Maven is that the build system should be as
    simple as possible: software engineers should not spend a lot of time implementing
    the build system. It should be easy to start a new project from scratch and then
    to rapidly begin developing the software. This appendix describes the core Maven
    principles in detail and explains what they mean from a developer’s point of view.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Maven的一个基本思想是构建系统应该尽可能简单：软件工程师不应该花费大量时间来实现构建系统。应该能够轻松地从零开始启动一个新项目，然后快速开始软件开发。本附录详细描述了Maven的核心原则，并从开发者的角度解释了它们的含义。
- en: A.1 Convention over configuration
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 约定优于配置
- en: '*Convention* *over configuration* is a software design principle that aims
    to decrease the number of configurations a software engineer needs to make, instead
    of introducing conventional rules that we must follow strictly. This way, we can
    skip tedious project configuration and focus on the more important parts of our
    work.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*约定优于配置* 是一个软件设计原则，旨在减少软件工程师需要做出的配置数量，而不是引入我们必须严格遵循的常规规则。这样，我们可以跳过繁琐的项目配置，专注于我们工作的更重要部分。'
- en: Convention over configuration is one of the strongest principles of the Maven
    project. One example of its application is the folder structure for the build
    process. With Maven, all the directories we need are already defined for us. src/main/java/,
    for example, is the Maven convention for where Java code for the project resides,
    src/test/java is where the unit tests for the project reside, target is the build
    folder, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 约定优于配置是Maven项目中最强的原则之一。其应用的一个例子是构建过程的文件夹结构。使用Maven，我们需要的所有目录都已经为我们定义好了。例如，src/main/java/
    是Maven为项目Java代码指定的位置，src/test/java 是项目单元测试的位置，target 是构建文件夹，等等。
- en: 'That sounds great, but aren’t we losing the flexibility in the project? What
    if we want our source code to reside in another folder? Maven is easy to configure:
    it provides the convention, but we can override the convention at any point and
    use the configuration of our choice.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很棒，但我们不是在项目中失去了灵活性吗？如果我们想将源代码放在另一个文件夹中怎么办？Maven易于配置：它提供了约定，但我们可以在任何点上覆盖这些约定，并使用我们选择的配置。
- en: A.2 Strong dependency management
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 强依赖管理
- en: Strong dependency management is the second key point that Maven introduced.
    When the Maven project began, the de facto build system for Java projects was
    another build tool, Ant. With Ant, we have to distribute the dependencies of our
    project, which means each project must take care of the dependencies it requires,
    and the dependencies of a single project may be distributed across different locations.
    Also, the same dependency may be used by different projects but located in different
    places for each project, causing duplication of resources.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 强依赖管理是Maven引入的第二个关键点。当Maven项目开始时，Java项目的默认构建系统是另一个构建工具，Ant。使用Ant，我们必须分发我们项目的依赖项，这意味着每个项目都必须负责它所需的依赖项，而单个项目的依赖项可能分布在不同的位置。此外，相同的依赖项可能被不同的项目使用，但每个项目可能位于不同的位置，导致资源重复。
- en: 'Maven introduced the notion of a *central repository*: a location on the internet
    where all kinds of artifacts (dependencies) are stored. The Maven build tool resolves
    these artifacts by reading a project’s build descriptor, downloading the necessary
    versions of the artifacts, and including them in the classpath of the application.
    This way, we need to list our dependencies only once, in the dependencies section
    of our build descriptor. Here’s an example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Maven引入了 *中央仓库* 的概念：互联网上存储所有类型工件（依赖项）的位置。Maven构建工具通过读取项目的构建描述符，下载必要的工件版本，并将它们包含在应用程序的类路径中，来解析这些工件。这样，我们只需要在我们的构建描述符的依赖项部分列出一次依赖项。以下是一个示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Thereafter, we are free to build the software on any other machine. We don’t
    need to bundle the dependencies with our project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们可以在任何其他机器上自由构建软件。我们不需要将依赖项捆绑到我们的项目中。
- en: 'Maven also introduced the concept of the local repository: a folder on a hard
    disk (~/.m2/repository/ in UNIX and C:\Users\<UserName>\.m2\repository\ in Windows)
    where Maven keeps the artifacts that it downloads from the central repository.
    After we build our project, our artifacts are installed in the local repository
    for later use by other projects, which is simple and neat.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Maven还引入了本地仓库的概念：硬盘上的一个文件夹（UNIX中的 ~/.m2/repository/ 和 Windows中的 C:\Users\<UserName>\.m2\repository\），Maven将从中下载中央仓库中的工件。在我们构建项目之后，我们的工件将被安装在本地仓库中，以便其他项目稍后使用，这样既简单又整洁。
- en: A developer might join a project managed by Maven and need access only to the
    sources of the project. Maven downloads the needed dependencies from the central
    repository and brings them to the local repository, where they will be available
    for other projects that the same developer may work on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能加入由Maven管理的项目，并且只需要访问项目的源代码。Maven从中央仓库下载所需的依赖项，并将它们带到本地仓库，在那里它们将可供同一开发者可能工作的其他项目使用。
- en: A.3 Maven build lifecycles
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 Maven构建生命周期
- en: 'Another very strong principle in Maven is the *build lifecycle*. A Maven project
    is built around the idea of defining the process of building, testing, and distributing
    a particular artifact. A Maven project can produce only one artifact. This way,
    we can use Maven to build the project artifact, clean the project’s folder structure,
    or generate the project documentation. These are the three built-in Maven lifecycles:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Maven的另一个非常强的原则是*构建生命周期*。Maven项目围绕定义构建、测试和分发特定工件的过程构建。Maven项目只能生成一个工件。这样，我们可以使用Maven构建项目工件、清理项目的文件夹结构或生成项目文档。这些是三个内置的Maven生命周期：
- en: '*Default*—For generating the project artifact'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认*—用于生成项目工件'
- en: '*Clean*—For cleaning the project'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清理*—用于清理项目'
- en: '*Site*—For generating the project documentation'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*站点*—用于生成项目文档'
- en: Each of these lifecycles is composed of several phases. To navigate a certain
    lifecycle, the build follows its phases (see figure A.1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生命周期中的每一个都由几个阶段组成。要导航某个生命周期，构建过程将遵循其阶段（见图A.1）。
- en: '![](../../OEBPS/Images/APPA_F01_Tudose2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPA_F01_Tudose2.png)'
- en: Figure A.1 The phases of Maven’s default lifecycle, from validate to deploy
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1 Maven默认生命周期的阶段，从验证到部署
- en: 'These are the phases of the default lifecycle:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是默认生命周期的阶段：
- en: '*Validate*—Validate that the project is correct and all necessary information
    is available.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*验证*—验证项目是否正确，以及所有必要的信息是否可用。'
- en: '*Compile*—Compile the source code of the project.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编译*—编译项目的源代码。'
- en: '*Test*—Test the compiled source code using a suitable unit testing framework
    (perhaps JUnit 5, in this case). The test should not require the code to be packaged
    or deployed.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*测试*—使用合适的单元测试框架（例如，在这种情况下可能是JUnit 5）测试编译后的源代码。测试不应需要将代码打包或部署。'
- en: '*Package*—Package the compiled code in its distributable format, such as a
    .jar file.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*打包*—将编译后的代码打包成可分发格式，例如.jar文件。'
- en: '*Integration-test*—Process and deploy the package (if necessary) into an environment
    where integration tests can be run.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*集成测试*—在可以运行集成测试的环境中处理和部署包（如果需要）。'
- en: '*Verify*—Run any checks to verify that the package is valid and meets quality
    criteria.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*验证*—运行任何检查以验证包是否有效并满足质量标准。'
- en: '*Install*—Install the package in the local repository for use as a dependency
    in other projects locally.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*安装*—将包安装到本地仓库中，以便在本地项目中作为依赖项使用。'
- en: '*Deploy*—In an integration or release environment, copy the final package to
    the remote repository for sharing with other developers and projects.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*部署*—在集成或发布环境中，将最终包复制到远程仓库以与其他开发者和项目共享。'
- en: Here, again, is the convention-over-configuration principle promoted by Maven.
    These phases are already defined in the order in which they are listed here. Maven
    invokes these phases in a very strict order; the phases are executed sequentially,
    in the order in which they are listed here, to complete the lifecycle. If we invoke
    any of these phases—if we type `mvn` `compile` on the command line in our project
    home directory, for example—Maven first validates the project and then tries to
    compile the sources of the project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，再次强调 Maven 推崇的约定优于配置原则。这些阶段已经按照这里列出的顺序定义。Maven 以非常严格的顺序调用这些阶段；阶段按列表中的顺序依次执行，以完成生命周期。如果我们调用这些阶段中的任何一个——例如，在我们的项目主目录中键入
    `mvn compile`——Maven 首先验证项目，然后尝试编译项目的源代码。
- en: 'One last thing: it is useful to think of all these phases as extension points.
    We can attach additional Maven plugins to the phases and orchestrate the order
    and how these plugins are executed.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：将这些阶段视为扩展点是有用的。我们可以在这些阶段附加额外的 Maven 插件，并编排它们的执行顺序和方式。
- en: A.4 Plugin-based architecture
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 基于插件的架构
- en: The last feature of Maven that we will mention here is its plugin-based architecture.
    We mentioned that Maven is a source-building environment. More specifically, Maven
    is a plugin-execution source-building environment. The core of the project is
    very small, but the architecture of the project allows multiple plugins to be
    attached to the core. This way, Maven builds an environment in which different
    plugins can be executed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要提到的 Maven 的最后一个特性是其基于插件的架构。我们提到 Maven 是一个源构建环境。更具体地说，Maven 是一个插件执行源构建环境。项目的核心非常小，但项目的架构允许将多个插件附加到核心。这样，Maven
    构建了一个环境，其中可以执行不同的插件。
- en: 'Each phase in a given lifecycle has several plugins attached, and Maven invokes
    them when passing through the given phase in the order in which the plugins are
    declared. Here are some of the core Maven plugins:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的生命周期中，每个阶段都附加了多个插件，并且 Maven 按照插件声明的顺序在通过给定阶段时调用它们。以下是一些核心 Maven 插件：
- en: '*Clean*—Cleans up after the build'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清理*—在构建后进行清理'
- en: '*Compiler*—Compiles Java sources'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译器*—编译 Java 源代码'
- en: '*Deploy*—Deploys the built artifact to the remote repository'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*—将构建的工件部署到远程仓库'
- en: '*Install*—Installs the built artifact in the local repository'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装*—将构建的工件安装到本地仓库中'
- en: '*Resources*—Copies the resources to the output directory for inclusion in the
    .jar file'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源*—将资源复制到输出目录，以便包含在 .jar 文件中'
- en: '*Site*—Generates a site that includes information about the current project'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*站点*—生成包含当前项目信息的站点'
- en: '*Surefire*—Runs the JUnit tests in an isolated classloader'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Surefire*—在隔离的类加载器中运行 JUnit 测试'
- en: '*Verifier*—Verifies the existence of certain conditions (useful for integration
    tests)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证器*—验证某些条件是否存在（对集成测试很有用）'
- en: In addition to these core Maven plugins, other Maven plugins are available for
    many situations, such as WAR (for packaging a web application) and Javadoc (for
    generating project documentation).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些核心 Maven 插件之外，还有许多其他 Maven 插件可用于许多情况，例如 WAR（用于打包 Web 应用程序）和 Javadoc（用于生成项目文档）。
- en: 'Plugins are declared in the `plugins` section of the build configuration file,
    as in this example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在构建配置文件的 `plugins` 部分声明，如下例所示：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A plugin declaration can have a `groupId`, `artifactId`, and `version`. This
    way, the plugins look like dependencies. In fact, plugins are handled the same
    way as dependencies; they are downloaded to the local repository like dependencies.
    When we specify a plugin, the `groupId` and `version` parameters are optional;
    if we do not declare them, Maven looks for a plugin with the specified `artifactId`
    and one of the following `groupId`s: `org.apache.maven.plugins` or `org.codehaus.mojo`.
    As the version is optional, Maven tries to download the latest available plugin
    version. Specifying the plugin versions is highly recommended to prevent auto-updates
    and nonreproducible builds. We may have built our project with the most recently
    updated Maven plugin; but later, if another developer tries to make the same build
    with the same configuration, and if the Maven plugin has since been updated, using
    the most current update may result in a nonreproducible build.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 插件声明可以有一个`groupId`、`artifactId`和`version`。这样，插件看起来就像依赖项。实际上，插件的处理方式与依赖项相同；它们像依赖项一样被下载到本地仓库。当我们指定一个插件时，`groupId`和`version`参数是可选的；如果我们没有声明它们，Maven会寻找具有指定`artifactId`和以下`groupId`之一的插件：`org.apache.maven.plugins`或`org.codehaus.mojo`。由于版本是可选的，Maven会尝试下载最新可用的插件版本。指定插件版本强烈推荐，以防止自动更新和非可重复构建。我们可能已经使用最新更新的Maven插件构建了我们的项目；但后来，如果其他开发者尝试使用相同的配置进行相同的构建，并且如果Maven插件在此之后已被更新，使用最新的更新可能会导致非可重复构建。
- en: A.5 The Maven project object model (POM)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 Maven项目对象模型（POM）
- en: Maven has a build descriptor called pom.xml (short for *project object model*)
    by default. We do not imperatively specify the things we want to do; we declaratively
    specify general information for the project itself, as in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Maven默认有一个名为pom.xml的构建描述符（简称*项目对象模型*）。我们不是强制性地指定我们想要做的事情；我们声明性地指定项目本身的一般信息，如下所示。
- en: Listing A.1 Very simple pom.xml
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1 非常简单的pom.xml
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code looks really simple, doesn’t it? But one big question may arise:
    how is Maven capable of building source code with that little information?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来真的很简单，不是吗？但可能有一个大问题：Maven是如何仅凭这么少的信息就能构建源代码的？
- en: The answer lies in the inheritance feature of the pom.xml files. Every simple
    pom.xml inherits most of its functionality from a Super POM. As in Java, in which
    every class inherits certain methods from the `java.lang.Object` class, the Super
    POM empowers each pom.xml file with Maven features.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于pom.xml文件的继承功能。每个简单的pom.xml都从Super POM继承了大部分功能。就像在Java中，每个类都从`java.lang.Object`类继承某些方法一样，Super
    POM赋予了每个pom.xml文件Maven功能。
- en: To take the analogy between Java and Maven even further, Maven pom.xml files
    can inherit from one another; just as in Java, some classes can act as parents
    for others. If we want to use the pom from listing A.1 as our parent, all we have
    to do is change its `packaging` value to `pom`. Parent and aggregation (multimodule)
    projects can have `pom` only as a packaging value. We also need to define in our
    parent which modules are the children.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步类比Java和Maven，Maven的pom.xml文件可以相互继承；就像在Java中，一些类可以作为其他类的父类。如果我们想使用列表A.1中的pom作为我们的父pom，我们只需要将其`packaging`值更改为`pom`。父项目和聚合（多模块）项目只能将`pom`作为打包值。我们还需要在我们的父pom中定义哪些模块是子模块。
- en: Listing A.2 Parent pom.xml with a child module
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 包含子模块的父pom.xml
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing A.2 is an extension of listing A.1\. We declare that this `pom` is an
    aggregation module by declaring the package to be of `pom` type and adding a `modules`
    section. The modules section lists all the child modules that our module has by
    providing the relative path to the project folder (example-module in this case).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2是列表A.1的扩展。我们通过将包声明为`pom`类型并添加一个`modules`部分来声明这个`pom`是一个聚合模块。`modules`部分通过提供项目文件夹（在本例中为example-module）的相对路径来列出我们的模块拥有的所有子模块。
- en: The following listing shows the child pom.xml.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了子pom.xml。
- en: Listing A.3 A pom.xml that inherits the parent pom.xml
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.3 继承父pom.xml的pom.xml
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember that this pom.xml resides in the folder that the parent XML has declared
    (example-module in this case).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个pom.xml位于父XML声明的文件夹中（在本例中为example-module）。
- en: Two things are worth noticing here. First, because we inherit from some other
    pom, we don’t need to specify `groupId` and `version` for the child pom; second,
    Maven expects the values to be the same as in the parent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点值得关注。首先，因为我们从某个其他pom继承，所以我们不需要为子pom指定`groupId`和`version`；其次，Maven期望这些值与父pom中的值相同。
- en: 'Going further with the analogy of Java, it seems reasonable to ask what kinds
    of objects poms can inherit from their parents. Here are all the elements that
    a pom can inherit from its parent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步类比 Java，似乎有理由询问 pom 文件可以从其父文件继承哪些类型的对象。以下是 pom 文件可以从其父文件继承的所有元素：
- en: Dependencies
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项
- en: Developers and contributors
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者和贡献者
- en: Plugins and their configurations
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件及其配置
- en: Reports lists
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告列表
- en: Each of these elements specified in the parent pom is automatically specified
    in the child pom.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在父 pom 文件中指定的每个这些元素都会自动在子 pom 文件中指定。
- en: A.6 Installing Maven
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 安装 Maven
- en: 'Installing Maven is a three-step process:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Maven 是一个三步过程：
- en: Download the latest distribution from [https://maven.apache.org](https://maven.apache.org),
    and unzip/untar it in the directory of your choice.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://maven.apache.org](https://maven.apache.org) 下载最新发行版，并将其解压缩/解tar到您选择的目录中。
- en: Define an `M2_HOME` environment variable pointing to where you have installed
    Maven.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个指向您已安装 Maven 的位置的 `M2_HOME` 环境变量。
- en: Add `M2_HOME\bin` (`M2_HOME/bin` on UNIX) to your `PATH` environment variable
    so that you can type `mvn` from any directory.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `M2_HOME\bin` (`M2_HOME/bin` 在 UNIX 上) 添加到您的 `PATH` 环境变量中，这样您就可以在任何目录中输入 `mvn`。
