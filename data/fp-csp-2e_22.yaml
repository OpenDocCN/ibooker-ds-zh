- en: 18 Data streams and the Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 数据流和响应式扩展
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using `IObservable` to represent data streams
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IObservable` 来表示数据流
- en: Creating, transforming, and combining `IObservable`s
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、转换和组合 `IObservable`
- en: Knowing when you should use `IObservable`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解何时应该使用 `IObservable`
- en: 'If you’ve ever been to a financial hub like Wall Street or Canary Wharf, you’ve
    probably seen a *ticker board*, a luminous board displaying the latest price at
    which the most widely traded stocks are being traded. This is a good representation
    of a *data stream*: a stream of related values that are delivered through time.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经去过像华尔街或金丝雀码头这样的金融中心，你可能见过一个 *股票行情板*，一个显示最广泛交易的股票最新交易价格的发光板。这是一个很好的 *数据流*
    的表示：随时间传递的相关值的流。
- en: 'Traders (both human and algorithms) keep an eye on the prices so that they
    can *react* to price changes: if a stock’s price rises or falls to a given level,
    they may decide to buy or sell, according to their investment strategy. This is,
    in essence, how *reactive programming* works: you define and consume data streams,
    potentially transforming the data in the streams in interesting ways, and define
    how your program should react to the data it consumes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 交易员（无论是人类还是算法）都会关注价格，以便他们可以 *做出反应*：如果某只股票的价格上升到或下降到某个水平，他们可能会根据他们的投资策略决定买入或卖出。本质上，这就是
    *响应式编程* 的工作方式：你定义并消费数据流，可能以有趣的方式转换数据流中的数据，并定义你的程序应该如何对所消费的数据做出反应。
- en: For example, if you have an Internet of Things in your home, you may have sensors
    that broadcast certain parameters (like room brightness or temperatures) and devices
    that react to changes in those parameters (regulating the window shutters or the
    air conditioning).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你家里有物联网设备，你可能会有广播某些参数（如房间亮度或温度）的传感器，以及响应这些参数变化的设备（调节窗户百叶或空调）。
- en: Or, in an event-sourced system like I described in chapter 13, you can publish
    the events as a stream and define downstream processing of those events in order
    to, say, recompute an account’s balance with every transaction and send the account
    holder a notification if the balance turns negative.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在一个像我在第 13 章中描述的事件源系统中，你可以将事件作为流发布，并定义对那些事件的下游处理，以便在每次交易时重新计算账户余额，并在余额变为负数时向账户持有人发送通知。
- en: In this chapter, you’ll learn to model data streams with the `IObservable` interface
    and to use the Reactive Extensions (Rx) to create, transform, and combine `IObservable`s.
    We’ll also discuss what sort of scenarios benefit from using `IObservable`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 `IObservable` 接口来建模数据流，并使用响应式扩展（Rx）来创建、转换和组合 `IObservable`。我们还将讨论哪些场景从使用
    `IObservable` 中受益。
- en: Rx is a set of libraries for working with `IObservable`s, much like LINQ provides
    utilities for working with `IEnumerable`s. Rx is a rich framework, so thorough
    coverage is beyond the scope of this chapter. Instead, we’ll just look at some
    basic features and applications of `IObservable` and how it relates to other abstractions
    we’ve covered so far.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 是一组用于处理 `IObservable` 的库，就像 LINQ 提供了用于处理 `IEnumerable` 的实用工具一样。Rx 是一个丰富的框架，因此本章的范围无法涵盖其全面内容。相反，我们将仅查看一些基本功能和
    `IObservable` 的应用，以及它与我们之前所讨论的其他抽象之间的关系。
- en: 18.1 Representing data streams with IObservable
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 使用 IObservable 表示数据流
- en: 'If you think of an array as a sequence of values in space (space in memory,
    that is), then you can think of `IObservable` as a sequence of values in time:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将数组视为空间（内存中的空间）中值的序列，那么你可以将 `IObservable` 视为时间中的值的序列：
- en: With an `IEnumerable`, you can enumerate its values at your leisure.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IEnumerable`，你可以随意枚举其值。
- en: With an `IObservable`, you can observe the values as they come.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IObservable`，你可以观察值随它们到来。
- en: As with `IAsyncEnumerable`, which we discussed in chapter 16, `IObservable`
    is like an `IEnumerable` in that it contains several values, and it’s like a `Task`
    in that values are delivered asynchronously. Table 18.1 shows how `IObservable`
    relates to other abstractions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第 16 章中讨论的 `IAsyncEnumerable` 一样，`IObservable` 在包含多个值方面类似于 `IEnumerable`，而在值异步传递方面类似于
    `Task`。表 18.1 展示了 `IObservable` 与其他抽象之间的关系。
- en: Table 18.1 How `IObservable` compares with other abstractions
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18.1 `IObservable` 与其他抽象的比较
- en: '|  | Synchronous | Asynchronous |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  | 同步 | 异步 |'
- en: '| **Single value** | `T` | `Task<T>` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **单个值** | `T` | `Task<T>` |'
- en: '| **Multiple values** | `IEnumerable<T>` | `IAsyncEnumerable<T>``IObservable<T>`
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **多个值** | `IEnumerable<T>` | `IAsyncEnumerable<T>` | `IObservable<T>` |'
- en: '`IObservable` is, therefore, more general than both `IEnumerable` and `Task`.
    You can view `IEnumerable` as a special case of `IObservable` that produces all
    its values right away, and you can think of `Task` as a special case of `IObservable`
    that only produces a single value. What’s the difference between `IObservable`
    and `IAsyncEnumerable`, and why do we need both?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservable` 因此比 `IEnumerable` 和 `Task` 都更通用。你可以将 `IEnumerable` 视为 `IObservable`
    的一个特例，它立即产生所有值，而你可以将 `Task` 视为 `IObservable` 的另一个特例，它只产生单个值。`IObservable` 和 `IAsyncEnumerable`
    之间的区别是什么，为什么我们需要两者？'
- en: '`IAsyncEnumerable` is consumer-centric: the component that consumes the data
    asks the producer for some data and receives an async stream of values in return—the
    data is “pulled” by the consumer. The consumer *interacts* with the producer,
    hence the libraries developed to work with `IAsyncEnumerable` are called the *Interactive
    Extensions* (Ix). These packages are named `System .Interactive.*`. (`IAsyncEnumerable`
    itself is included in the BCL in the `System.Collections.Generic` namespace.)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerable` 以消费者为中心：消费数据的组件请求生产者一些数据，并返回一个异步值流——数据由消费者“拉取”。消费者与生产者交互，因此与
    `IAsyncEnumerable` 一起工作的库被称为 *交互式扩展（Interactive Extensions）*（Ix）。这些包命名为 `System.Interactive.*`。（`IAsyncEnumerable`
    本身包含在 `System.Collections.Generic` 命名空间中的 BCL 中。）'
- en: '`IObservable` is producer-centric: the consumer subscribes to the data, which
    is “pushed” out by the producer. The consumer merely *reacts* to the values it
    receives; hence the libraries developed to work with `IObservable` are called
    the *Reactive Extensions* (Rx). These packages are named `System.Reactive.*`.
    (`IObservable` itself is included in the BCL in the `System` namespace.)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObservable` 以生产者为中心：消费者订阅数据，数据由生产者“推送”出来。消费者仅仅对收到的值做出“反应”；因此，与 `IObservable`
    一起工作的库被称为 *响应式扩展（Reactive Extensions）*（Rx）。这些包命名为 `System.Reactive.*`。（`IObservable`
    本身包含在 `System` 命名空间中的 BCL 中。）'
- en: NOTE Both Rx and Ix are maintained by the .NET Foundation; they are open source
    and hosted at [https://github.com/dotnet/reactive](https://github.com/dotnet/reactive).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Rx 和 Ix 都由 .NET 基金会维护；它们是开源的，托管在 [https://github.com/dotnet/reactive](https://github.com/dotnet/reactive)。
- en: Rx has been around for many years (there are implementations of Rx not only
    in .NET but in many other languages), so there are more resources and know-how
    at your disposal. By comparison, async streams and Ix are a recent addition; and
    yet, because of native language support since C# 8 via the `yield return` and
    `await` keywords (which we saw in chapter 16), it feels easier to create and consume
    them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 已经存在很多年了（Rx 的实现不仅限于 .NET，还有许多其他语言），因此你可以利用更多的资源和专业知识。相比之下，异步流和 Ix 是最近才加入的；然而，由于
    C# 8 通过 `yield return` 和 `await` 关键字（我们在第 16 章中看到）提供了原生语言支持，因此创建和消费它们感觉更容易。
- en: 18.1.1 A sequence of values in time
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.1 时间序列的值
- en: The easiest way to develop an intuition about `IObservable` is through *marble
    diagrams*. Figure 18.1 shows a few examples. Each `IObservable` is represented
    with an arrow, representing time, and marbles, representing values produced by
    the `IObservable`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *宝石图（marble diagrams）* 是了解 `IObservable` 的最简单方式。图 18.1 展示了一些示例。每个 `IObservable`
    都用一个箭头表示时间，用宝石表示 `IObservable` 产生的值。
- en: '![](Images/CH18_F01_Buonanno2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_F01_Buonanno2.png)'
- en: Figure 18.1 Marble diagrams provide an intuitive way to understand `IObservable`s.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 宝石图提供了一种直观理解 `IObservable` 的方法。
- en: 'The image illustrates that an `IObservable` can produce three different kinds
    of messages:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像说明 `IObservable` 可以产生三种不同类型的消息：
- en: '`OnNext` signals a new value, so if your `IObservable` represents a stream
    of events, `OnNext` will be fired when an event is ready to be consumed. This
    is an `IObservable`’s most important message, and often the only one you’ll be
    interested in.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnNext` 信号表示新的值，所以如果你的 `IObservable` 表示事件流，当事件准备好被消费时，`OnNext` 将被触发。这是 `IObservable`
    最重要的消息，通常也是你唯一感兴趣的消息。'
- en: '`OnCompleted` signals that the `IObservable` is done and will signal no more
    values.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCompleted` 信号表示 `IObservable` 已完成，并将不再产生更多值。'
- en: '`OnError` signals that an error has occurred and provides the relevant `Exception`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnError` 信号表示发生了错误，并提供相关的 `Exception`。'
- en: The `IObservable` contract
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservable` 协议'
- en: 'The `IObservable` contract specifies that an `IObservable` should produce messages
    according to the following grammar:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservable` 协议指定 `IObservable` 应根据以下语法产生消息：'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is, an `IObservable` can produce an arbitrary number of `T`’s (`OnNext`),
    possibly followed by a single value indicating either successful completion (`OnCompleted`)
    or an error (`OnError`). This means that there are three possibilities in terms
    of completion. An `IObservable` can
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，一个 `IObservable` 可以产生任意数量的 `T`（`OnNext`），可能后跟一个表示成功完成（`OnCompleted`）或错误（`OnError`）的单个值。这意味着在完成方面有三种可能性。一个
    `IObservable` 可以
- en: Never complete
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永不完成
- en: Complete normally with a completion message
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常完成，带有完成消息
- en: Complete abnormally; in which case, it produces an `Exception`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常完成；在这种情况下，它产生一个 `Exception`
- en: An `IObservable` *never* produces any values after it’s completed regardless
    of whether it completes normally or with an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `IObservable` *永远*不会在完成之后产生任何值，无论它是正常完成还是出错完成。
- en: 18.1.2 Subscribing to an IObservable
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.2 订阅 IObservable
- en: Observ-*ables* work in tandem with observ-*ers*. Simply put,
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 观察-*ables* 与观察-*ers* 一起工作。简单来说，
- en: Observers produce values
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者产生值
- en: Observers consume them
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者消费它们
- en: 'If you want to consume the messages produced by an `IObservable`, you can create
    an observer and associate it with an `IObservable` via the `Subscribe` method.
    The simplest way to do this is by providing a callback that handles the values
    produced by the `IObservable` like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要消费 `IObservable` 产生的消息，你可以创建一个观察者并通过 `Subscribe` 方法将其与 `IObservable` 关联起来。最简单的方法是提供一个回调，该回调处理
    `IObservable` 产生的值，如下所示：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Exposes the `IObservable` interface
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 展示了 `IObservable` 接口
- en: ❷ Exposes the `Subscribe` extension method used below
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 展示了下面的 `Subscribe` 扩展方法
- en: When I say that `nums` “produces” an `int` value, all I really mean is that
    it calls the given function (in this case, `Console.WriteLine`) with the value.
    The result of the preceding code is that when `nums` produces an `int`, it’s printed
    out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说 `nums` “产生”一个 `int` 值时，我真正想说的是它调用给定的函数（在这种情况下，`Console.WriteLine`）并传递该值。前面代码的结果是当
    `nums` 产生一个 `int` 值时，它会被打印出来。
- en: 'I find the naming a bit confusing; you’d expect an `IObservable` to have an
    `Observe` method, but instead, it’s called `Subscribe`. Basically, you can think
    of the two as synonyms: an observer is a subscriber, and in order to observe an
    `IObservable` you subscribe to it.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得命名有点令人困惑；你可能会期望一个 `IObservable` 有一个 `Observe` 方法，但相反，它被称作 `Subscribe`。基本上，你可以把它们看作同义词：观察者是一个订阅者，为了观察一个
    `IObservable`，你需要订阅它。
- en: What about the other types of messages an `IObservable` can produce? You can
    provide handlers for those as well. For instance, the following listing shows
    a convenience method, `Trace`, that attaches an observer to an `IObservable`;
    this observer simply prints a diagnostic messages whenever the `IObservable` signals.
    We’ll use this method later for debugging.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `IObservable` 可以产生的其他类型消息是什么？你也可以为这些消息提供处理程序。例如，下面的列表显示了一个便利方法 `Trace`，它将一个观察者附加到一个
    `IObservable` 上；这个观察者简单地在每个 `IObservable` 信号时打印诊断消息。我们稍后会使用这个方法进行调试。
- en: Listing 18.1 Subscribing to the messages produced by an `IObservable`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.1 订阅 `IObservable` 产生的消息
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Subscribe` actually takes three handlers (all are optional arguments) to handle
    the different messages that an `IObservable<T>` can produce. It should be clear
    why the handlers are optional: if you don’t expect an `IObservable` to ever complete,
    there’s no point in providing an `onComplete` handler.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe` 实际上接受三个处理程序（所有都是可选参数）来处理 `IObservable<T>` 可以产生的不同消息。为什么处理程序是可选的应该很清楚：如果你不期望
    `IObservable` 任何时候都会完成，就没有必要提供 `onComplete` 处理程序。'
- en: A more OO option for subscribing is to call `Subscribe` with an `IObserver`,
    an interface that, unsurprisingly, exposes `OnNext`, `OnError`, and `OnCompleted`
    methods.[¹](#pgfId-1142554)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅的一个更面向对象的选择是使用 `IObserver` 接口调用 `Subscribe`，这个接口出人意料地暴露了 `OnNext`、`OnError`
    和 `OnCompleted` 方法。[¹](#pgfId-1142554)
- en: Also notice that `Subscribe` returns an `IDisposable` (the subscription). By
    disposing it, you unsubscribe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Subscribe` 返回一个 `IDisposable`（订阅）。通过释放它，你可以取消订阅。
- en: 'In this section, you’ve seen some of the basic concepts and terminology around
    `IObservable`. It’s a lot to absorb, but don’t worry, things will become clearer
    as you see some examples. These are the basic ideas to keep in mind:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了围绕 `IObservable` 的基本概念和术语。这需要吸收很多内容，但不用担心，随着你看到一些示例，事情会变得清晰。以下是一些需要记住的基本思想：
- en: Observables produce values; observers consume them.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象产生值；观察者消费它们。
- en: You associate an observer with an observable by using `Subscribe`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 `Subscribe` 将一个观察者与一个可观察对象关联起来。
- en: An observable produces a value by calling the observers’ `OnNext` handler.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可观察对象通过调用观察者的 `OnNext` 处理程序来产生一个值。
- en: 18.2 Creating IObservables
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 创建 `IObservables`
- en: You now know how to consume the data in a stream by subscribing to an `IObservable`.
    But how do you get an `IObservable` in the first place? The `IObservable` and
    `IObserver` interfaces are included in .NET Standard, but if you want to create
    or perform many other operations on `IObservable`s, you’ll typically use the Reactive
    Extensions (Rx) by installing the `System.Reactive` package.[²](#pgfId-1142574)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何通过订阅 `IObservable` 来消费流中的数据。但你是如何首先获得一个 `IObservable` 的呢？`IObservable`
    和 `IObserver` 接口包含在 .NET Standard 中，但如果你想要创建或对 `IObservable`s 执行许多其他操作，你通常会使用通过安装
    `System.Reactive` 包的响应式扩展 (Rx)。[²](#pgfId-1142574)
- en: The recommended way to create `IObservable`s is by using one of several dedicated
    methods included in the static `Observable` class; we’ll look at some next. I
    recommend you follow along in the REPL whenever possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `IObservable`s 的推荐方法是使用静态 `Observable` 类中包含的几个专用方法之一；我们将在下面看看。我建议你在可能的情况下始终在
    REPL 中跟随。
- en: 18.2.1 Creating a timer
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.1 创建一个计时器
- en: 'A timer can be modeled with an `IObservable` that signals at regular intervals.
    We can represent it with a marble diagram as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用一个每隔固定时间发出信号的 `IObservable` 来模拟计时器。我们可以用以下这样的宝石图来表示它：
- en: '![](Images/CH18_UN01_Buonanno2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN01_Buonanno2.png)'
- en: This is a good way to start experimenting with `IObservable`s because it’s simple
    but does include the element of time. The code in the following listing uses `Observable.Interval`
    to create a timer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种开始实验 `IObservable`s 的好方法，因为它简单但确实包含了时间的元素。以下列表中的代码使用 `Observable.Interval`
    创建了一个计时器。
- en: Listing 18.2 Creating an `IObservable` that signals every second
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.2 创建每秒发出信号的 `IObservable`
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we define `ticks` as an `IObservable` that will begin signaling after one
    second, producing a `long` counter value that increments every second, starting
    at 0\. Notice I said “will begin” signaling? The resulting `IObservable` is lazy,
    so unless there’s a subscriber, nothing will actually happen. Why talk, if nobody’s
    listening?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义 `ticks` 为一个 `IObservable`，它将在一秒后开始发出信号，产生一个每秒递增的 `long` 计数器值，从 0 开始。注意我说的是“将开始”发出信号？结果
    `IObservable` 是惰性的，所以除非有订阅者，实际上什么都不会发生。如果没有人听，为什么要说话呢？
- en: 'If we want to see some tangible results, we need to subscribe to the `IObservable`.
    We can do this with the `Trace` method defined earlier:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看到一些有形的结果，我们需要订阅 `IObservable`。我们可以使用之前定义的 `Trace` 方法来做这件事：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, you’ll start to see the following messages appear in the console,
    one second apart:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你将开始在控制台看到以下消息依次出现，每秒一条：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because this `IObservable` never completes, you’ll have to reset the REPL to
    stop the noise—sorry!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个 `IObservable` 从不完成，你将不得不重置 REPL 来停止噪音——抱歉！
- en: 18.2.2 Using Subject to tell an IObservable when it should signal
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.2 使用 `Subject` 来告诉 `IObservable` 它何时应该发出信号
- en: Another way to create an `IObservable` is by instantiating a `Subject`. A `Subject`
    is an `IObservable` you can imperatively tell to produce a value, which it will,
    in turn, push out to its observers. For example, the following listing shows a
    program that turns inputs from the console into values signaled by a `Subject`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `IObservable` 的另一种方式是通过实例化一个 `Subject`。`Subject` 是一个 `IObservable`，你可以命令式地告诉它产生一个值，然后它会反过来将其推送到它的观察者。例如，以下列表显示了一个程序，它将控制台输入转换为由
    `Subject` 信号化的值。
- en: Listing 18.3 Modeling user inputs as a stream
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.3 将用户输入建模为流
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a `Subject`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 `Subject`
- en: ❷ Subscribes to the `Subject`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 订阅到 `Subject`
- en: ❸ Tells the `Subject` to produce a value, which it pushes to its observers
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 告诉 `Subject` 产生一个值，并将其推送到其观察者
- en: ❹ Tells the `Subject` to signal completion
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 告诉 `Subject` 发出完成信号
- en: ❺ Leaving the using block disposes the subscription.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 离开 `using` 块将释放订阅。
- en: Every time the user types in some input, the code pushes that value to the `Subject`
    by calling its `OnNext` method. When the user types “q,” the code exits the `for`
    loop and calls the `Subject`'s `OnCompleted` method, signaling that the stream
    has ended. Here we’ve subscribed to the stream of inputs using the `Trace` method
    defined in listing 18.1, so we’ll get a diagnostic message printed for each user
    input.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户输入一些输入时，代码通过调用其 `OnNext` 方法将该值推送到 `Subject`。当用户输入“q”时，代码退出 `for` 循环并调用 `Subject`
    的 `OnCompleted` 方法，表示流已结束。在这里，我们已经使用列表 18.1 中定义的 `Trace` 方法订阅了输入流，因此对于每个用户输入，我们都会打印出诊断消息。
- en: 'An interaction with the program looks like this (user inputs in bold):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序的交互看起来像这样（用户输入以粗体显示）：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Avoid using `Subject`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`Subject`
- en: '`Subject` is useful for demonstrative purposes, but it works *imperatively*
    (you tell the `Subject` when to fire) and this goes somewhat counter to the *reactive*
    philosophy of Rx (you specify how to react to certain things when they happen).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`对于演示目的很有用，但它以命令式方式工作（你告诉`Subject`何时触发），这与Rx的*响应式*哲学（你指定在发生某些事情时如何响应）有些相悖。'
- en: For this reason, it’s recommended that you avoid `Subject`s whenever possible
    and instead use other methods such as `Observable.Create`, which you’ll see next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议尽可能避免使用`Subject`，而改用其他方法，例如`Observable.Create`，你将在下一节中看到。
- en: As an exercise, try to rewrite the code in listing 18.3 using `Observable.Create`
    to create an `IObservable` of user inputs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试使用`Observable.Create`重写列表18.3中的代码，以创建用户输入的`IObservable`。
- en: 18.2.3 Creating IObservables from callback-based subscriptions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.3 从基于回调的订阅创建`IObservables`
- en: If your system subscribes to an external data source, such as a message queue,
    event broker, or publisher/subscriber, you can model that data source as an `IObservable`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统订阅了外部数据源，例如消息队列、事件代理或发布/订阅，你可以将该数据源建模为`IObservable`。
- en: For example, Redis can be used as a publisher/subscriber. Redis’s API exposes
    a `Subscribe` method allowing you to register a callback that receives messages
    published on Redis on a given channel (a Redis channel is just a string; it allows
    subscribers to specify what messages they're interested in). The following listing
    shows how you can use `Observable.Create` to create an `IObservable` that will
    signal whenever messages are received from Redis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Redis可以用作发布/订阅。Redis的API公开了一个`Subscribe`方法，允许你注册一个回调，该回调接收在给定频道上发布到Redis的消息（Redis频道只是一个字符串；它允许订阅者指定他们感兴趣的哪些消息）。以下列表显示了如何使用`Observable.Create`创建一个在从Redis接收到消息时发出信号的`IObservable`。
- en: Listing 18.4 Creating an `IObservable` from messages published to Redis
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.4：从发布到Redis的消息创建`IObservable`
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Create takes an observer, so the given function is only called when a subscription
    is made.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Create`接受一个观察者，所以给定的函数只有在订阅时才会被调用。
- en: ❷ Converts from the callback-based implementation of `Subscribe` to values produced
    by the IObservable
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从基于回调的`Subscribe`实现转换为由`IObservable`产生的值
- en: ❸ Returns a function that will be called when the subscription is disposed
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个在订阅被释放时将被调用的函数
- en: 'The preceding method returns an `IObservable` that produces the values received
    from Redis on the given channel. You could use this as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法返回一个`IObservable`，它产生从给定频道接收到的Redis上的值。你可以这样使用它：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Gets an `IObservable` that signals when messages are published on the weather
    channel
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取一个在天气频道发布消息时发出信号的`IObservable`
- en: ❷ Subscribes to the `IObservable`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 订阅到`IObservable`
- en: ❸ Publishing a value causes `weatherUpdates` to signal; the `onNext` handler
    is called as a result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发布一个值会导致`weatherUpdates`发出信号；因此调用`onNext`处理程序。
- en: You may ask, “What have we gained exactly?” After all, we could have registered
    a callback using Redis’s `Subscribe` method to handle messages; instead, we now
    have an `IObservable` and need to `Subscribe` to it to handle messages. The point
    is, with an `IObservable`, we can leverage the many operators included in Rx (which
    we’ll discuss in section 18.3) as well as the schedulers (which are used to optimize
    performance and are beyond the scope of this chapter).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“我们到底获得了什么？”毕竟，我们本可以使用Redis的`Subscribe`方法注册一个回调来处理消息；相反，我们现在有一个`IObservable`，需要`Subscribe`到它来处理消息。关键是，有了`IObservable`，我们可以利用Rx中包含的许多操作符（我们将在第18.3节中讨论）以及调度器（用于优化性能，但超出了本章的范围）。
- en: 18.2.4 Creating IObservables from simpler structures
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.4 从更简单的结构创建`IObservables`
- en: I said that `IObservable<T>` is more general than a value `T`, a `Task<T>`,
    or an `IEnumerable <T>`, so let’s see how each of these can be promoted to an
    `IObservable`. This becomes useful if you want to combine one of these less powerful
    structures with an `IObservable`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过`IObservable<T>`比一个值`T`、一个`Task<T>`或一个`IEnumerable<T>`更通用，所以让我们看看每个这些如何提升为`IObservable`。如果你想要将其中一个较不强大的结构与`IObservable`结合使用，这会很有用。
- en: '`Return` allows you to lift a single value into an `IObservable` that looks
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Return`允许你将单个值提升到类似这样的`IObservable`：'
- en: '![](Images/CH18_UN02_Buonanno2.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_UN02_Buonanno2.png)'
- en: 'That is, it immediately produces the value and then completes. Here’s an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即，它立即产生值然后完成。这里有一个例子：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Return` takes a value, `T`, and lifts it into an `IObservable<T>`. This is
    the first container where the `Return` function is actually called `Return`!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Return` 接收一个值 `T` 并将其提升到 `IObservable<T>`。这是第一个 `Return` 函数实际上被命名为 `Return`
    的容器！'
- en: 'Let’s see about creating an `IObservable` from a single asynchronous value—a
    `Task`. Here, we have an `IObservable` that looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从一个单个异步值——一个 `Task` 创建 `IObservable`。这里，我们有一个看起来像这样的 `IObservable`：
- en: '![](Images/CH18_UN03_Buonanno2.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN03_Buonanno2.png)'
- en: 'After some time, we’ll get a single value, immediately followed by the signal
    for completion. In code, it looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，我们将得到一个单一值，紧接着是完成信号的信号。在代码中，它看起来像这样：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, an `IObservable` created from an `IEnumerable` looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从 `IEnumerable` 创建的 `IObservable` 看起来像这样：
- en: '![](Images/CH18_UN04_Buonanno2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN04_Buonanno2.png)'
- en: 'That is, it immediately produces all the values in the `IEnumerable` and completes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 即，它立即产生 `IEnumerable` 中的所有值并完成：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’ve now seen many, but not all, methods for creating `IObservable`s. You
    may end up creating `IObservable`s in other ways; for example, in GUI applications,
    you can turn events such as mouse clicks into event streams by using `Observable.FromEvent`
    and `FromEventPattern`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了创建 `IObservable` 的许多方法，但不是全部。你可能会以其他方式创建 `IObservable`；例如，在 GUI 应用程序中，你可以使用
    `Observable.FromEvent` 和 `FromEventPattern` 将鼠标点击等事件转换为事件流。
- en: 'Now that you know about creating and subscribing to `IObservable`, let’s move
    on to the most fascinating area: transforming and combining different streams.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何创建和订阅 `IObservable`，让我们继续探讨最迷人的领域：转换和组合不同的流。
- en: 18.3 Transforming and combining data streams
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 转换和组合数据流
- en: The power of using streams comes from the many ways in which you can combine
    them and define new streams based on existing ones. Rather than dealing with individual
    values in a stream (like in most event-driven designs), you deal with the stream
    as a whole.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流的强大之处在于你可以以多种方式组合它们，并基于现有的流定义新的流。你处理的是整个流，而不是流中的单个值（就像在大多数事件驱动设计中那样）。
- en: 'Rx offers a lot of functions (often called *operators*) to transform and combine
    `IObservable`s in a variety of ways. I’ll discuss the most commonly used ones
    and add a few operators of my own. You’ll recognize the typical traits of a functional
    API: purity and composability.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 提供了许多函数（通常称为 *算子*）以各种方式转换和组合 `IObservable`。我将讨论最常用的几个，并添加一些我自己的算子。你会认识到函数式
    API 的典型特征：纯净性和可组合性。
- en: 18.3.1 Stream transformations
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.1 流转换
- en: You can create new observables by transforming an existing observable in some
    way. One of the simplest operations is mapping. This is achieved with the `Select`
    method, which works (as with any other container) by applying the given function
    to each element in the stream, as figure 18.2 shows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以某种方式转换现有的可观察对象来创建新的可观察对象。其中最简单的操作是映射。这是通过 `Select` 方法实现的，它（就像任何其他容器一样）通过将给定的函数应用于流中的每个元素，如图
    18.2 所示。
- en: '![](Images/CH18_F02_Buonanno2.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_F02_Buonanno2.png)'
- en: Figure 18.2 `Select` maps a function onto a stream.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2 `Select` 将函数映射到流上。
- en: 'Here’s some code that creates a timer and then maps a simple function on it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些创建计时器并在其上映射简单函数的代码：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’re attaching an observer on the last line with the `Trace` method, so the
    preceding code will cause the following messages to be printed every second:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后一行使用 `Trace` 方法附加了一个观察者，因此前面的代码将导致以下消息每秒打印一次：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because `Select` follows the LINQ query pattern, we can write the same thing
    using LINQ:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Select` 遵循 LINQ 查询模式，我们可以用 LINQ 写出相同的内容：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using `Select`, we can rewrite our simple program that checks exchange rates
    (first introduced in listing 15.1) in terms of observables:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Select`，我们可以用可观察对象的形式重写我们的简单程序，该程序检查汇率（首次在列表 15.1 中介绍）：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The stream of values entered by the user
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用户输入的值流
- en: ❷ Maps user inputs to the corresponding retrieved values
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将用户输入映射到相应的检索值
- en: ❸ Subscribes to both streams to produce debug messages
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 订阅两个流以产生调试消息
- en: 'Here, `inputs` represents the stream of currency pairs entered by the user,
    and in `rates`, we map those pairs to the corresponding values retrieved from
    the web. We’re subscribing to both observables with the usual `Trace` method,
    so an interaction with this program could be as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`inputs` 代表用户输入的货币对流，而在 `rates` 中，我们将这些对映射到从网络检索到的相应值。我们使用常规的 `Trace` 方法订阅这两个可观察对象，因此与该程序的交互可能如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice, however, that in the code, we have a blocking call to `Result`. In a
    real application, we wouldn’t want to block a thread, so how could we avoid that?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在代码中，我们有一个阻塞调用到 `Result`。在实际应用中，我们不想阻塞一个线程，那么我们如何避免这种情况呢？
- en: 'We saw that a `Task` can easily be promoted to an `IObservable`. If we promote
    the `Task` of retrieving each rate from the remote API to an `IObservable` rather
    than waiting for its result, then we get an `IObservable` of `IObservable`s. Sound
    familiar? `Bind`! We can use `SelectMany` instead of `Select`, which flattens
    the result into a single `IObservable`. We can, therefore, rewrite the definition
    of the `rates` stream as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，一个 `Task` 可以很容易地提升为 `IObservable`。如果我们将获取每个远程API的速率的 `Task` 提升为 `IObservable`
    而不是等待其结果，那么我们得到一个 `IObservable` 的 `IObservable`s。听起来熟悉吗？`Bind`！我们可以使用 `SelectMany`
    来代替 `Select`，它将结果扁平化为单个 `IObservable`。因此，我们可以将 `rates` 流的定义重写如下：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Observable.FromAsync` promotes the `Task` returned by `GetRateAsync` to an
    `IObservable`, and `SelectMany` flattens all these `IObservable`s into a single
    `IObservable`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.FromAsync` 将 `GetRateAsync` 返回的 `Task` 提升为 `IObservable`，`SelectMany`
    将所有这些 `IObservable`s 扁平化为单个 `IObservable`。'
- en: 'Because it’s always possible to promote a `Task` to an `IObservable`, an overload
    of `SelectMany` exists that does just that (this is similar to how we overloaded
    `Bind` to work with an `IEnumerable` and an `Option`-returning function in section
    6.5). This means we can avoid explicitly calling `FromAsync` and return a `Task`
    instead. Furthermore, we can use a LINQ query:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总是可以将 `Task` 提升为 `IObservable`，因此 `SelectMany` 存在一个重载，它正是这样做的（这与我们在第6.5节中如何重载
    `Bind` 以与 `IEnumerable` 和返回 `Option` 的函数一起工作类似）。这意味着我们可以避免显式调用 `FromAsync` 并返回一个
    `Task`。此外，我们可以使用LINQ查询：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The program thus modified works the same way as before but without the blocking
    call to `Result`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此修改后的程序与之前的工作方式相同，但没有阻塞调用 `Result`。
- en: '`IObservable` also supports many of the other operations that are supported
    by `IEnumerable`, such as filtering with `Where`, `Take` (takes the first *n*
    values), `Skip`, `First`, and so on.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservable` 还支持许多由 `IEnumerable` 支持的其他操作，例如使用 `Where` 过滤、`Take`（获取前 *n* 个值）、`Skip`、`First`
    等。'
- en: 18.3.2 Combining and partitioning streams
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.2 合并和分区流
- en: There are also many operators that allow you to combine two streams into a single
    one. For example, `Concat` produces all the values of one `IObservable`, followed
    by all the values in another, as figure 18.3 shows.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多运算符允许您将两个流合并为一个。例如，`Concat` 产生一个 `IObservable` 的所有值，然后是另一个 `IObservable`
    中的所有值，如图18.3所示。
- en: '![](Images/CH18_F03_Buonanno2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_F03_Buonanno2.png)'
- en: Figure 18.3 `Concat` waits for an `IObservable` to complete and then produces
    elements from the other `IObservable`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 `Concat` 等待一个 `IObservable` 完成，然后从另一个 `IObservable` 产生元素。
- en: 'For instance, in our exchange rate lookup, we have an observable called `rates`
    with the retrieved rates. If we want an observable of all the messages the program
    should output to the console, this must include the retrieved rates but also an
    initial message prompting the user for some input. We can lift this single message
    into an `IObservable` with `Return` and then use `Concat` to combine it with the
    other messages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的汇率查找中，我们有一个名为 `rates` 的可观察对象，其中包含检索到的汇率。如果我们想要一个包含程序应输出到控制台的所有消息的可观察对象，这必须包括检索到的汇率，但还必须包括一个初始消息，提示用户输入。我们可以使用
    `Return` 将此单个消息提升到 `IObservable`，然后使用 `Concat` 将它与其他消息组合起来：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In fact, the need to provide a starting value for an `IObservable` is so common
    that there’s a dedicated function for it—`StartWith`. The preceding code is equivalent
    to this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，为 `IObservable` 提供起始值的需求如此普遍，以至于有一个专门的功能——`StartWith`。前面的代码等同于以下内容：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Whereas `Concat` waits for the left `IObservable` to complete before producing
    values from the right observable, `Merge` combines values from two `IObservables`
    without delay, as figure 18.4 shows.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `Concat` 在从右侧可观察对象产生值之前等待左侧 `IObservable` 完成，如图18.4所示。
- en: '![](Images/CH18_F04_Buonanno2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_F04_Buonanno2.png)'
- en: Figure 18.4 `Merge` merges two `IObservable`s into one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.4 `Merge` 将两个 `IObservable` 合并成一个。
- en: 'For example, if you have a stream of valid values and one of error messages,
    you could combine them with `Merge` as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个包含有效值和错误消息的流，您可以使用 `Merge` 将它们组合如下：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Just as you might want to merge values from different streams, the opposite
    operation—partitioning a stream according to some criterion—is also often useful.
    Figure 18.5 illustrates this.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能想要合并来自不同流的值一样，相反的操作——根据某些标准对流进行分区——也是非常有用的。图 18.5 说明了这一点。
- en: '![](Images/CH18_F05_Buonanno2.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_F05_Buonanno2.png)'
- en: Figure 18.5 Partitioning an `IObservable` according to a predicate
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5 根据谓词分区 `IObservable`
- en: '`Partition` returns a pair of `IObservable`s, so you can destructure it like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Partition` 返回一对 `IObservable`，因此您可以像这样解构它：'
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Partitioning an `IObservable` of values is roughly equivalent to an `if` when
    dealing with a single value, so it’s useful when you have a stream of values that
    you want to process differently, depending on some condition. For example, if
    you have a stream of messages and some criterion for validation, you can partition
    the stream into two streams of valid and invalid messages and process them accordingly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `IObservable` 的值进行分区大致相当于处理单个值时的 `if` 语句，因此当您有一个根据某些条件想要以不同方式处理的值流时，它是有用的。例如，如果您有一个消息流和一些验证标准，您可以将流分为两个流，一个是有效消息流，另一个是无效消息流，并相应地处理它们。
- en: 18.3.3 Error handling with IObservable
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.3 使用 IObservable 进行错误处理
- en: 'Error handling when working with `IObservable` works differently from what
    you might expect. In most programs, an uncaught exception either causes the whole
    application to crash or causes the processing of a single message/request to fail,
    while subsequent requests work fine. To illustrate how things work differently
    in Rx, consider this version of our program for looking up exchange rates:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `IObservable` 进行错误处理时，其工作方式可能与您预期的不同。在大多数程序中，未捕获的异常要么导致整个应用程序崩溃，要么导致单个消息/请求的处理失败，而后续请求则正常工作。为了说明在
    Rx 中事情是如何不同工作的，考虑我们查找汇率的程序版本：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The program captures three streams, each dependent on another (`outputs` is
    defined in terms of `rates`, and `rates` is defined in terms of `inputs`, as figure
    18.6 shows), and we’re printing diagnostic messages for all of them with `Trace`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序捕获了三个流，每个流都依赖于另一个（`outputs` 是基于 `rates` 定义的，而 `rates` 是基于 `inputs` 定义的，如图
    18.6 所示），我们使用 `Trace` 打印所有这些流的诊断信息。
- en: '![](Images/CH18_F06_Buonanno2.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_F06_Buonanno2.png)'
- en: Figure 18.6 Simple dataflow between three `IObservable`s
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6 三 `IObservable` 之间的简单数据流
- en: 'Now look what happens if you break the program by passing an invalid currency
    pair:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看如果您通过传递无效的货币对来破坏程序会发生什么：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What this shows is that once `rates` errors, it never signals again. This behavior
    is as specified in the `IObservable` contract (see the sidebar on “The `IObservable`
    contract”). As a result, everything downstream is also “dead.” But `IObservable`s
    upstream of the failed one are fine: `inputs` is still signaling, as would any
    other `IObservable`s defined in terms of `inputs`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明一旦 `rates` 发生错误，它就不再发出信号。这种行为符合 `IObservable` 协议的指定（参见关于“`IObservable` 协议”的侧边栏）。因此，所有下游的部分也都“死亡”。但是，失败的
    `IObservable` 上游部分是正常的：`inputs` 仍在发出信号，就像任何其他以 `inputs` 为定义的 `IObservable` 一样。
- en: To prevent your system from going into such a state, where a branch of the dataflow
    dies while the remaining graph keeps functioning, you can use the techniques you
    learned for functional error handling.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止您的系统进入这种状态，即数据流的一个分支死亡，而剩余的图仍然保持运行，您可以使用您学到的函数式错误处理技术。
- en: 'The following listing shows the implementation of `Safely`, a helper function
    included in `LaYumba.Functional` that allows you to safely apply a `Task`-returning
    function to each element in a stream. The result is a pair of streams: a stream
    of successfully computed values and a stream of exceptions.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `LaYumba.Functional` 中包含的辅助函数 `Safely` 的实现，该函数允许您安全地将返回 `Task` 的函数应用于流中的每个元素。结果是两个流：一个成功计算值的流和一个异常流。
- en: Listing 18.5 Safely performing a `Task` and returning two streams
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.5 安全执行 `Task` 并返回两个流
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Converts each `Task<R>` to a `Task<Exceptional<R>>` to get a stream of `Exceptional`s
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将每个 `Task<R>` 转换为 `Task<Exceptional<R>>` 以获取 `Exceptional` 流
- en: ❷ Partitions a stream of `Exceptional`s into successfully computed values and
    exceptions
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 `Exceptional` 流分区为成功计算值和异常
- en: 'For each `T` in the given stream, we apply the `Task`-returning function `f`.
    We then use the binary overload of `Map` defined in section 16.1.4 to convert
    each resulting `Task<R>` to a `Task<Exceptional<R>>`. This is where we gain safety:
    instead of an inner value `R` that throws an exception when it’s accessed, we
    have an `Exceptional<R>` in the appropriate state. `SelectMany` flattens away
    the `Task`s in the stream and returns a stream of `Exceptional`s. We can then
    partition this in successes and exceptions.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定流中的每个`T`，我们应用返回`Task`的函数`f`。然后，我们使用第16.1.4节中定义的二进制重载的`Map`将每个结果`Task<R>`转换为`Task<Exceptional<R>>`。这就是我们获得安全性的地方：而不是一个在访问时抛出异常的内值`R`，我们有一个处于适当状态的`Exceptional<R>`。`SelectMany`消除了流中的`Task`，并返回一个`Exceptional`的流。然后我们可以将它们分为成功和异常。
- en: 'With this in place, we can refactor our program to handle errors more gracefully:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以重构我们的程序以更优雅地处理错误：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 18.3.4 Putting it all together
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.4 整合一切
- en: The following listing showcases the various techniques you’ve learned in this
    section. It shows the exchange rates lookup program, refactored to safely handle
    errors, and without the debug information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了你在本节中学到的各种技术。它显示了重构以安全处理错误且没有调试信息的汇率查找程序。
- en: Listing 18.6 The program refactored to safely handle errors
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.6 重构以安全处理错误的程序
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The dataflow diagram in figure 18.7 shows the various `IObservable`s involved
    and how they depend on one another.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7中的数据流图显示了涉及的各个`IObservable`以及它们之间的依赖关系。
- en: '![](Images/CH18_F07_Buonanno2.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_F07_Buonanno2.png)'
- en: Figure 18.7 Dataflow with a separate branch for handling errors
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7 具有处理错误单独分支的数据流
- en: Notice how `Safely` allows us to create two branches, each of which can be processed
    independently until a uniform representation for both cases is obtained, and they
    can be merged.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Safely`如何允许我们创建两个分支，每个分支都可以独立处理，直到获得两种情况的一致表示，然后它们可以合并。
- en: 'This program nicely illustrates the three parts that typically compose a program
    that uses `IObservable`s:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序很好地说明了使用`IObservable`s的程序通常由三个部分组成：
- en: '*Set up the data sources*—In our case, this is captured by `inputs`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置数据源*——在我们的例子中，这由`inputs`捕获。'
- en: '*Process the data*—This is where you use functions like `Select`, `Merge`,
    and so on.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理数据*——这是你使用`Select`、`Merge`等函数的地方。'
- en: '*Consume the results*—Observers consume the most downstream `IObservable`s
    (in this case, `outputs`) to perform side effects.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费结果*——观察者消费最下游的`IObservable`s（在这种情况下，`outputs`）以执行副作用。'
- en: 18.4 Implementing logic that spans multiple events
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 实现跨越多个事件的逻辑
- en: So far I’ve mostly aimed at familiarizing you with `IObservable`s and the many
    operators that can be used with them. For this, I’ve used familiar examples like
    the exchange rates lookup. After all, given that you can promote any value `T`,
    `Task<T>`, or `IEnumerable<T>` to an `IObservable<T>`, you could pretty much write
    all of your code in terms of `IObservable`s! But should you?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我主要致力于让你熟悉`IObservable`s以及可以与它们一起使用的许多运算符。为此，我使用了像汇率查找这样的熟悉例子。毕竟，既然你可以将任何值`T`、`Task<T>`或`IEnumerable<T>`提升为`IObservable<T>`，你几乎可以用`IObservable`s来编写所有代码！但你应该这样做吗？
- en: The answer, of course, is probably not. The area in which `IObservable` and
    Rx really shine is when you can use them to write stateful programs without any
    explicit state manipulation. By *stateful programs*, I mean programs in which
    events aren’t treated independently; past events influence how new events are
    treated. In this section, you’ll see a few such examples.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，答案可能不是。`IObservable`和Rx真正发光的领域是当你可以使用它们来编写无需任何显式状态操作的状态程序时。通过*状态程序*，我指的是事件不是独立处理的程序；过去的事件会影响如何处理新事件。在本节中，你将看到一些这样的例子。
- en: 18.4.1 Detecting sequences of pressed keys
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4.1 检测按键序列
- en: At some point, you’ve probably written an event handler that listens to a user’s
    keypresses and performs some actions based on what key and key modifiers were
    pressed. A callback-based approach is satisfactory for many cases, but what if
    you want to listen to a specific sequence of keypresses? For example, say you
    want to implement some behavior when the user presses the combination Alt-K-B.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能编写了一个事件处理器，它监听用户的按键并基于按下的键和键修饰符执行一些操作。基于回调的方法对于许多情况来说是满意的，但如果你想监听特定的按键序列怎么办？例如，假设你想在用户按下组合键Alt-K-B时实现某些行为。
- en: In this case, pressing Alt-B should lead to different behavior, based on whether
    it was shortly preceded by the leading Alt-K, so keypresses can’t be treated independently.
    If you have a callback-based mechanism that deals with single keypressed events,
    you effectively need to set in motion a state machine when the user presses Alt-K,
    and then wait for the possible Alt-B that will follow, reverting to the previous
    state if no Alt-B is received in time. It’s actually pretty complicated!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，按下 Alt-B 应该导致不同的行为，这取决于它是否被先前的 Alt-K 短时间内跟随，因此按键不能独立处理。如果你有一个基于回调的机制来处理单个按键事件，那么当用户按下
    Alt-K 时，你实际上需要启动一个状态机，然后等待可能跟随的 Alt-B，如果在规定时间内没有收到 Alt-B，则回退到之前的状态。这实际上相当复杂！
- en: 'With `IObservable`, this can be solved much more elegantly. Let’s assume that
    we have a stream of keypress events, `keys`. We’re looking for two events—Alt-K
    and Alt-B—that happen on that same stream in quick succession. In order to do
    this, we need to explore how to combine a stream with itself. Consider the following
    diagram:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IObservable`，这个问题可以更优雅地解决。假设我们有一个按键事件的流，`keys`。我们正在寻找两个事件——Alt-K 和 Alt-B，它们在同一个流中快速连续发生。为了做到这一点，我们需要探索如何将一个流与自身组合。考虑以下图表：
- en: '![](Images/CH18_UN05_Buonanno2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN05_Buonanno2.png)'
- en: It’s important to understand this diagram. The expression `keys.Select(_ =>
    keys)` yields a new `IObservable` that maps each value produced by `keys` to `keys`
    itself. Therefore, when `keys` produces its first value, “a,” this new `IObservable`
    produces an `IObservable` that has all following values in `keys`. When `keys`
    produces its second value, “b,” the new `IObservable` produces another `IObservable`
    that has all the values that follow “b,” and so on.[³](#pgfId-1142965)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个图表非常重要。表达式 `keys.Select(_ => keys)` 产生一个新的 `IObservable`，它将 `keys` 产生的每个值映射到
    `keys` 本身。因此，当 `keys` 产生第一个值“a”时，这个新的 `IObservable` 产生一个包含 `keys` 中所有后续值的 `IObservable`。当
    `keys` 产生第二个值“b”时，这个新的 `IObservable` 产生另一个包含“b”之后所有值的 `IObservable`，依此类推。[³](#pgfId-1142965)
- en: 'Looking at the types can also help clarify this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 查看类型也可以帮助澄清这一点：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we use `SelectMany` instead, all these values are flattened into a single
    stream:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `SelectMany` 代替，所有这些值都会被展平到一个单一的流中：
- en: '![](Images/CH18_UN06_Buonanno2.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN06_Buonanno2.png)'
- en: 'Of course, if we’re looking for two consecutive keypresses, we don’t need *all*
    values that follow an item but just the next one. Instead of mapping each value
    to the whole `IObservable`, let’s reduce it to the first item with `Take`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们正在寻找两个连续的按键，我们不需要*所有*跟随一个项目的值，只需要下一个。而不是将每个值映射到整个 `IObservable`，让我们使用
    `Take` 减少到第一个项目：
- en: '![](Images/CH18_UN07_Buonanno2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN07_Buonanno2.png)'
- en: 'We’re getting close. Now, let’s make the following changes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近了。现在，让我们进行以下更改：
- en: Instead of ignoring the current value, pair it with the following value.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是忽略当前值，将其与下一个值配对。
- en: Use `SelectMany` to obtain a flat `IObservable`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SelectMany` 获取平展的 `IObservable`。
- en: Use LINQ syntax.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LINQ 语法。
- en: 'The resulting expression pairs each value in an `IObservable` with the previously
    emitted value:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表达式将 `IObservable` 中的每个值与其之前发出的值配对：
- en: '![](Images/CH18_UN08_Buonanno2.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN08_Buonanno2.png)'
- en: This is a pretty useful function in its own right, and I’ll call it `PairWithPrevious`.
    We’ll use it later.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当有用的函数，我将称之为 `PairWithPrevious`。我们稍后会使用它。
- en: But for this particular scenario, we only want pairs to be created if they’re
    sufficiently close in time. This can be achieved easily by using an overload of
    `Take` that takes a `Timespan` as the following listing shows.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于这个特定的场景，我们只想在时间上足够接近的情况下创建对。这可以通过使用 `Take` 的重载来实现，它接受一个 `Timespan` 作为以下列表所示。
- en: Listing 18.7 Detecting when the user presses the Alt-K-B key sequence
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.7 检测用户按下 Alt-K-B 键序列
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ For any keypress, pairs it with the next keypress that occurs within a half-second
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于任何按键，将其与在半秒内发生的下一个按键配对
- en: As you can see, the solution is simple and elegant. You can apply this approach
    to recognize more complex patterns within sequences of events—all without explicitly
    keeping track of state and introducing side effects!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，解决方案简单而优雅。你可以应用这种方法来识别事件序列中的更复杂模式——而无需显式跟踪状态和引入副作用！
- en: You’ve probably also realized that coming up with such a solution isn’t necessarily
    easy. It takes a while to get familiar with `IObservable` and its many operators,
    and to develop an understanding of how to use them.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也已经意识到，提出这样的解决方案并不一定容易。熟悉 `IObservable` 及其众多操作符需要一段时间，并且需要理解如何使用它们。
- en: 18.4.2 Reacting to multiple event sources
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4.2 对多个事件源做出反应
- en: Imagine we have a bank account denominated in Euros, and we’d like to keep track
    of its value in US Dollars. Both changes in balance and changes in the exchange
    rate cause the dollar balance to change. To react to changes from different streams,
    we could use `CombineLatest`, which takes the latest values from two observables
    when one of them signals, as figure 18.8 shows.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以欧元计价的银行账户，我们希望跟踪其美元价值。余额的变化和汇率的变化都会导致美元余额的变化。为了对来自不同流的变动做出反应，我们可以使用
    `CombineLatest`，它在一个 `IObservable` 信号时获取两个可观察对象的最新值，如图 18.8 所示。
- en: '![](Images/CH18_F08_Buonanno2.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_F08_Buonanno2.png)'
- en: Figure 18.8 `CombineLatest` signals whenever one of two `IObservable`s signals.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.8 `CombineLatest` 在两个 `IObservable` 中的任何一个发出信号时都会发出信号。
- en: 'Its usage would be as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法如下：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This works, but it doesn’t take into account the fact that the exchange rate
    is much more volatile than the account balance. In fact, if exchange rates come
    from the FX market, there may well be dozens or hundreds of tiny movements every
    second! Surely this level of detail isn’t required for a private client who wants
    to keep an eye on their finances. Reacting to each change in exchange rate would
    flood the client with unwanted notifications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但它没有考虑到汇率比账户余额波动性更大的事实。事实上，如果汇率来自外汇市场，每秒钟可能会有数十或数百次微小的变动！显然，对于想要关注其财务状况的私人客户来说，不需要这么详细的程度。对汇率每一次变动做出反应会向客户发送大量不想要的提醒。
- en: This is an example of an `IObservable` producing too much data (see the sidebar
    on “Backpressure”). For this, we can use `Sample`, an operator that takes an `IObservable`
    that acts as a data source, and another `IObservable` that signals *when* values
    should be produced. `Sample` is illustrated in figure 18.9.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `IObservable` 产生过多数据的例子（请参阅“背压”侧边栏）。为此，我们可以使用 `Sample` 操作符，它接受一个充当数据源的
    `IObservable`，以及另一个表示何时产生值的 `IObservable`。`Sample` 在图 18.9 中展示。
- en: '![](Images/CH18_F09_Buonanno2.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH18_F09_Buonanno2.png)'
- en: Figure 18.9 `Sample` produces the values from a source stream when a sampler
    stream signals.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9 `Sample` 在采样流信号时产生源流的值。
- en: In this scenario, we can create an `IObservable` that signals at 10-minute intervals
    and use it to sample the stream of exchange rates, as the following listing shows.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们可以创建一个每 10 分钟发出信号的 `IObservable`，并使用它来采样汇率流，如下所示。
- en: Listing 18.8 Sampling a value from an `IObservable` every 10 minutes
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.8 每 10 分钟从 `IObservable` 中采样一个值
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is another scenario in which our logic spans multiple events, and using
    Rx operators `CombineLatest` and `Sample` allows us to encode this logic without
    explicitly keeping any state.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们逻辑跨越多个事件场景的另一个例子，使用 Rx 操作符 `CombineLatest` 和 `Sample` 允许我们在不显式保持任何状态的情况下编码此逻辑。
- en: 'Backpressure: When an `IObservable` produces data too quickly'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 背压：当 `IObservable` 产生数据过快时
- en: When you iterate over the items in an `IEnumerable` or an `IAsyncEnumerable`,
    you’re “pulling” or requesting items, so you can process them at your own pace.
    With `IObservable`, items are “pushed” to you (the consuming code). If an `IObservable`
    produces values more rapidly than they can be consumed by the subscribed observers,
    this can cause excessive *backpressure*, causing strain on your system.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你迭代 `IEnumerable` 或 `IAsyncEnumerable` 中的项时，你是在“拉取”或请求项，因此你可以根据自己的节奏处理它们。使用
    `IObservable` 时，项是“推”给你的（消费代码）。如果一个 `IObservable` 产生的值比订阅的观察者能够消费的更快，这可能会导致过度的
    *背压*，从而对你的系统造成压力。
- en: 'To ease backpressure, Rx provides several operators:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解背压，Rx 提供了几个操作符：
- en: '`Throttle`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Throttle`'
- en: '`Sample`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sample`'
- en: '`Buffer`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buffer`'
- en: '`Window`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Window`'
- en: '`Debounce`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debounce`'
- en: Each has different behavior and several overloads, so we won’t discuss them
    in detail. The point is that with these operators, you can easily and declaratively
    implement logic like, “I want to consume items in batches of 10 at a time,” or
    “If a cluster of values come in quick succession, I only want to consume the last
    one.” Implementing such logic in a callback-based solution, where each value is
    received independently, would require you to manually keep some state.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有不同的行为和几个重载，所以我们不会详细讨论它们。重点是，使用这些算子，你可以轻松地声明式地实现逻辑，例如，“我想每次以 10 个批次的数量消费项目”，或者“如果一系列值快速连续到达，我只想要消费最后一个”。在基于回调的解决方案中实现这种逻辑，其中每个值都是独立接收的，你需要手动保持一些状态。
- en: 18.4.3 Notifying when an account becomes overdrawn
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4.3 当账户透支时通知
- en: For a final, more business-oriented example, imagine that in the context of
    the BOC application, we consume a stream of all transactions that affect bank
    accounts, and we want to send clients a notification if their account’s balance
    becomes negative.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个最终的、更面向业务的例子，想象一下在 BOC 应用程序的环境中，我们消费了影响银行账户的所有交易的流，并且我们希望在账户余额变为负数时向客户发送通知。
- en: An account’s balance is the sum of all the transactions that have affected it,
    so at any point, given a list of past `Transaction`s for an account, you could
    compute its current balance using `Aggregate`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 账户余额是所有影响它的交易的总和，因此在任何时候，给定一个账户过去 `Transaction` 的列表，你可以使用 `Aggregate` 计算其当前余额。
- en: 'There is an `Aggregate` function for `IObservable`; it waits for an `IObservable`
    to complete and aggregates all the values it produces into a single value. But
    this isn’t what we need: we don’t want to wait for the stream to complete, but
    to recompute the balance every time we receive a new `Transaction`. For this,
    we can use `Scan` (see figure 18.10), which is similar to `Aggregate` but aggregates
    all previous values with every new value that is produced.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `IObservable`，有一个 `Aggregate` 函数；它等待 `IObservable` 完成，并将它产生的所有值聚合成一个单一值。但这并不是我们需要的：我们不想等待流完成，而是每次接收到一个新的
    `Transaction` 时都重新计算余额。为此，我们可以使用 `Scan`（见图 18.10），它与 `Aggregate` 类似，但会聚合所有之前的值以及每次产生的新值。
- en: '![](Images/CH18_F10_Buonanno2.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_F10_Buonanno2.png)'
- en: Figure 18.10 `Scan` aggregates all values produced so far.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.10 `Scan` 聚合到目前为止产生的所有值。
- en: 'As a result, we can effectively use `Scan` to keep state. Given an `IObservable`
    of `Transaction`s affecting a bank account, we can use `Scan` to add up the amounts
    of all past transactions as they happen, obtaining an `IObservable` that signals
    with the new balance when the account balance changes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以有效地使用 `Scan` 来保持状态。给定影响银行账户的 `Transaction` 的 `IObservable`，我们可以使用 `Scan`
    来累加所有过去交易的数量，在账户余额发生变化时，获得一个发出新余额信号的 `IObservable`：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we have a stream of values representing an account’s current balance,
    we need to single out what changes in balance cause the account to “dip into the
    red,” going from positive to negative.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个表示账户当前余额的值流，我们需要单独识别哪些余额变化会导致账户“陷入赤字”，从正数变为负数。
- en: 'For this, we need to look at changes in the balance, and we can do this with
    `PairWithPrevious`, which signals the current value together with the previously
    emitted value. You saw the implementation of `PairWithPrevious` in section 18.4.1,
    but here it is again for reference:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要查看余额的变化，我们可以使用 `PairWithPrevious` 来做到这一点，它同时发出当前值和之前发出的值。你已经在 18.4.1
    节中看到了 `PairWithPrevious` 的实现，但这里再次提供以供参考：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is one of many examples of custom operations that can be defined in terms
    of existing operations. The preceding snippet also shows how you can use ASCII
    marble diagrams to document your code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是许多可以基于现有操作定义的自定义操作示例之一。前面的代码片段还展示了如何使用 ASCII 珠石图来记录你的代码。
- en: 'We can use `PairWithPrevious` to signal when an account dips into the red as
    follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `PairWithPrevious` 来发出当账户余额变为负数时的信号：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now let’s make things a bit closer to the real world. If your system receives
    a stream of transactions, this will probably include transactions for all accounts.
    Therefore, we must group them by account ID in order to correctly compute the
    balance. `GroupBy` works for `IObservable` similarly to how it does for `IEnumerable`,
    but it returns a stream of streams.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使事情更接近现实世界。如果你的系统接收到了一个交易流，这可能会包括所有账户的交易。因此，我们必须按账户 ID 对它们进行分组，以便正确计算余额。`GroupBy`
    对于 `IObservable` 的工作方式与 `IEnumerable` 类似，但它返回一个流流。
- en: '![](Images/CH18_UN09_Buonanno2.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH18_UN09_Buonanno2.png)'
- en: The following listing shows how to adapt the logic, assuming an initial stream
    of transactions for all accounts.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何适应逻辑，假设有一个所有账户的初始交易流。
- en: Listing 18.9 Signalling whenever an account becomes overdrawn
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.9 当账户透支时发出信号
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Includes transactions from all accounts
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含所有账户的交易
- en: ❷ Groups by account ID
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按账户 ID 分组
- en: ❸ Signals dips into the red for any particular account
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发出特定账户透支的信号
- en: ❹ Flattens the result into a single observable
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将结果扁平化为单个可观察对象
- en: ❺ Signals the ID of the offending account
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 发出违规账户的 ID
- en: Now we’re starting with a stream of `Transaction`s for all accounts, and we
    end up with a stream of `Guid`s that will signal whenever an account dips into
    the red, including the `Guid` identifying the offending account. Notice how this
    program is effectively keeping track of the balances of all accounts without the
    need for us to do any explicit state manipulation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从所有账户的交易流开始，最终得到一个 `Guid` 流，该流会在任何账户出现透支时发出信号，包括标识违规账户的 `Guid`。注意这个程序是如何有效地跟踪所有账户的余额，而无需我们进行任何显式的状态操作。
- en: 18.5 When should you use IObservable?
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 你应该在何时使用 IObservable？
- en: In this chapter, you’ve seen how you can use `IObservable` to represent data
    streams and Rx to create and manipulate `IObservable`s. There are many details
    and features of Rx that we haven’t discussed at all, but we’ve still covered enough
    ground for you to start using `IObservable`s and to further explore the features
    of Rx as needed.[⁴](#pgfId-1143147)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了如何使用 `IObservable` 来表示数据流，以及如何使用 Rx 创建和操作 `IObservable`s。Rx 有许多细节和特性我们还没有讨论，但我们已经涵盖了足够的内容，让你开始使用
    `IObservable`s 并根据需要进一步探索 Rx 的特性。[⁴](#pgfId-1143147)
- en: As you’ve seen, having an abstraction that captures a data stream enables you
    to detect patterns and specify logic that spans across multiple events within
    the same stream or across different streams. This is where I’d recommend using
    `IObservable`. The corollary is that, if your events can be handled independently,
    then you probably shouldn’t use `IObservable`s because using them will probably
    reduce the readability of your code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，拥有一个能够捕获数据流的抽象，使你能够检测模式并指定跨越同一流中多个事件或不同流的事件的逻辑。这就是我建议使用 `IObservable`
    的地方。其逆命题是，如果你的事件可以独立处理，那么你可能不应该使用 `IObservable`s，因为使用它们可能会降低你代码的可读性。
- en: An important thing to keep in mind is that because `OnNext` has no return value,
    an `IObservable` can only push data downstream and never receives any data back.
    Hence, `IObservable`s are best combined into *one-directional dataflows*. For
    instance, if you read events from a queue and write some data into a DB as a result,
    `IObservable` can be a good fit; likewise if you have a server that communicates
    with web clients via WebSockets, where messages are exchanged between client and
    server in a fire-and-forget fashion.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要事情是，由于 `OnNext` 没有返回值，`IObservable` 只能向下推送数据，而永远不会接收任何数据。因此，`IObservable`s
    最好组合成 *单向数据流*。例如，如果你从队列中读取事件并将一些数据写入数据库作为结果，`IObservable` 就是一个很好的选择；同样，如果你有一个通过
    WebSockets 与网络客户端通信的服务器，客户端和服务器之间以发送和忘记的方式交换消息，`IObservable` 同样适用。
- en: On the other hand, `IObservable`s are not well-suited to a request-response
    model such as HTTP. You could model the received requests as a stream and compute
    a stream of responses, but you’d then have no easy way to tie these responses
    back to the original requests.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`IObservable`s 并不适合像 HTTP 这样的请求-响应模型。你可以将接收到的请求建模为一个流，并计算一个响应流，但你将无法轻松地将这些响应与原始请求关联起来。
- en: Finally, if you have complex synchronization patterns that can’t be captured
    with the operators in Rx, and you need more fine-grained control over how messages
    are sequenced and processed, you may find the building blocks in the `System.DataFlow`
    namespace (based on in-memory queues) more appropriate.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有无法用 Rx 的操作符捕获的复杂同步模式，并且需要更精细地控制消息的顺序和处理方式，你可能会发现 `System.DataFlow` 命名空间（基于内存队列）中的构建块更合适。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '`IObservable<T>` represents a *stream* of `T`s, a sequence of values in time.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObservable<T>` 表示 `T` 的 *流*，即时间序列中的值序列。'
- en: An `IObservable` produces messages according to the grammar
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObservable` 根据语法产生消息'
- en: '[PRE37]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Writing a program with `IObservable`s involves three steps:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IObservable`s 编写程序涉及三个步骤：
- en: Create `IObservable`s using the methods in `System.Reactive.Linq .Observable`.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `System.Reactive.Linq .Observable` 中的方法创建 `IObservable`s。
- en: Transform and combine `IObservable`s using the operators in Rx or other operators
    you may define.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rx 或您可能定义的其他运算符转换和组合 `IObservable`。
- en: Subscribe to and consume the values produced by the `IObservable`.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅并消费 `IObservable` 生成的值。
- en: Associate an observer to an `IObservable` with `Subscribe`.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Subscribe` 将观察者关联到 `IObservable`。
- en: Remove an observer by disposing of the subscription returned by `Subscribe`.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处置 `Subscribe` 返回的订阅来移除观察者。
- en: Separate side effects (in observers) from logic (in stream transformations).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将副作用（在观察者中）与逻辑（在流转换中）分离。
- en: 'When deciding on whether to use `IObservable`, consider the following:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定是否使用 `IObservable` 时，请考虑以下因素：
- en: '`IObservable` allows you to specify logic that spans multiple events.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObservable` 允许您指定跨越多个事件的逻辑。'
- en: '`IObservable` is good for modeling unidirectional dataflows.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObservable` 适用于建模单向数据流。'
- en: '* * *'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ `IObserver` is the method declared in the `IObservable` interface. The overload
    that takes the callbacks is an extension method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObserver` 是在 `IObservable` 接口中声明的方法。接受回调的重载是一个扩展方法。'
- en: '² Rx includes several libraries. The main library, `System.Reactive`, bundles
    the packages you’ll most commonly need: `System.Reactive.Interfaces`, `System.Reactive.Core`,
    `System.Reactive.Linq`, and `System.Reactive.PlatformServices`. There are several
    other packages that are useful in more specialized scenarios, such as if you’re
    using Windows forms.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ² Rx 包含几个库。主要库 `System.Reactive` 打包了您最常需要的包：`System.Reactive.Interfaces`、`System.Reactive.Core`、`System.Reactive.Linq`
    和 `System.Reactive.PlatformServices`。还有几个在其他更专业场景中很有用的包，例如如果您正在使用 Windows forms。
- en: '³ Imagine what `keys.Select(_` `=>` `keys)` would look like if `keys` were
    an `IEnumerable`: for each value, you’d be taking the whole `IEnumerable`. In
    the end, you’d have an `IEnumerable` containing *n* replicas of `keys` (*n* being
    the length of `keys`). With `IObservable`, the behavior is different because of
    the element of time, so when you say, “Give me `keys`,” what you really get is
    all values `keys` will produce in the future.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `keys` 是一个 `IEnumerable`，那么 `keys.Select(_ => keys)` 会是什么样子：对于每个值，你都会获取整个
    `IEnumerable`。最终，你会得到一个包含 `keys` 的 *n* 个副本的 `IEnumerable`（*n* 是 `keys` 的长度）。由于
    `IObservable` 中存在时间元素，所以当你说“给我 `keys`”时，你实际上得到的是 `keys` 将在未来产生的所有值。
- en: '⁴ To give you an idea of what was not covered, there are many more operators
    along with important implementation details of Rx: schedulers (which determine
    how calls to observers are dispatched), *hot* versus *cold* observables (not all
    observables are lazy), and `Subject`s with different behaviors, for example.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 为了让您了解未涵盖的内容，还有许多其他运算符以及 Rx 的重要实现细节：调度器（确定如何调度对观察者的调用）、*热* 与 *冷* 观察者（并非所有观察者都是懒加载的），以及具有不同行为的
    `Subject` 等。
