- en: 13 Deploying your game to players’ devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 将你的游戏部署到玩家的设备
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building an application package for various platforms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为各种平台构建应用程序包
- en: Assigning build settings, such as the app icon or name
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配构建设置，如应用图标或名称
- en: Interacting with the web page for web games
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网页游戏页面交互
- en: Developing plugins for apps on mobile platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动平台上的应用程序开发插件
- en: 'Throughout this book, you’ve learned how to program various games within Unity,
    but the crucial last step has been missing so far: deploying those games to players.
    Until a game is playable outside the Unity editor, it’s of little interest to
    anyone other than the developer. Unity shines at this last step, with the ability
    to build applications for a huge variety of gaming platforms. This final chapter
    covers how to build games for these various platforms.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经学会了如何在Unity中编程各种游戏，但到目前为止，关键的最后一步一直缺失：将这些游戏部署给玩家。除非游戏可以在Unity编辑器之外运行，否则除了开发者之外，对任何人来说都毫无兴趣。Unity在最后一步中表现出色，能够为大量的游戏平台构建应用程序。最后一章将介绍如何为这些不同的平台构建游戏。
- en: When I speak of “building” for a platform, I’m referring to generating an application
    package that will run on that platform. On each platform (Windows, iOS, and so
    on), the exact form of a built application differs, but once the executable has
    been generated, that app package can be played without Unity and can be distributed
    to players. A single Unity project can be deployed to any platform without needing
    to be redone for each one.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提到“为平台构建”时，我指的是生成将在该平台上运行的应用程序包。在每个平台（Windows、iOS等）上，构建的应用程序的确切形式不同，但一旦生成了可执行文件，该应用程序包就可以在没有Unity的情况下播放，并且可以分发给玩家。单个Unity项目可以部署到任何平台，而无需为每个平台重新制作。
- en: This “build once, deploy anywhere” capability applies to the vast majority of
    features in your games, but not to everything. I would estimate that 95% of the
    code written in Unity (for example, almost everything we’ve done so far in this
    book) is platform-agnostic and will work just as well across all platforms. But
    a few specific tasks differ for different platforms, so we’ll go over those platform-specific
    areas of development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“一次构建，到处部署”的能力适用于你游戏中绝大多数功能，但并非所有功能。我估计在Unity中编写的95%的代码（例如，本书中到目前为止我们几乎做的一切）都是平台无关的，并且可以在所有平台上正常工作。但一些特定任务在不同平台上有所不同，所以我们将讨论这些特定平台的发展领域。
- en: 'Unity is capable of building apps for the following platforms:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity能够为以下平台构建应用程序：
- en: Windows PC
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows PC
- en: macOS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS
- en: Linux
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: WebGL
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL
- en: Android
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android
- en: iOS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS
- en: tvOS
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tvOS
- en: Oculus VR
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oculus VR
- en: VIVE VR
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VIVE VR
- en: Windows Mixed Reality
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows混合现实
- en: Microsoft HoloLens
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft HoloLens
- en: Magic Leap
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magic Leap
- en: 'In addition, by contacting the platform owners for access, Unity can even build
    for game consoles like these:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过联系平台所有者以获取访问权限，Unity甚至可以为像这样的游戏机构建：
- en: Xbox One
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xbox One
- en: Xbox Series X
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xbox Series X
- en: PlayStation 4
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PlayStation 4
- en: PlayStation 5
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PlayStation 5
- en: Nintendo Switch
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nintendo Switch
- en: Whew, that full list is really long! Frankly, that’s almost comically long,
    and way more than the supported platforms of most other game development tools
    out there. This chapter focuses especially on the first six platforms listed,
    because those platforms are of primary interest to the majority of people exploring
    Unity, but keep in mind how many options are available to you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁，这个完整的列表真的很长！坦白说，这几乎有点滑稽地长，远远超过了大多数其他游戏开发工具支持的平台。本章特别关注列出的前六个平台，因为这些平台对大多数探索Unity的人来说是最感兴趣的，但请记住你有多少选择。
- en: To see all these platforms, open the Build Settings window. That’s the window
    you used in the previous chapter to add scenes to be loaded; to access it, choose
    File > Build Settings. In chapter 12, you cared only about the list at the top,
    but now you want to pay attention to the buttons at the bottom (see figure 13.1).
    You’ll notice a lot of space taken up by the list of platforms; the currently
    active platform is indicated with the Unity icon.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有这些平台，请打开构建设置窗口。这就是你在上一章中用来添加要加载的场景的窗口；要访问它，请选择文件 > 构建设置。在第12章中，你只关心顶部的列表，但现在你想要注意底部的按钮（见图13.1）。你会注意到列表占用了很多空间；当前活动的平台由Unity图标指示。
- en: '![CH13_F01_Hocking3](../Images/CH13_F01_Hocking3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F01_Hocking3](../Images/CH13_F01_Hocking3.png)'
- en: Figure 13.1 The Build Settings window
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 构建设置窗口
- en: NOTE When installing Unity, Unity Hub asks which export modules you want, and
    you can build only the selected modules. If you later want to install a module
    you hadn’t selected initially, go to Installs in Unity Hub, click the three dots
    for the Unity version you want to modify, and then select Add Modules in the menu.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在安装Unity时，Unity Hub会询问你想要哪些导出模块，并且你只能构建所选的模块。如果你后来想要安装最初未选择的模块，请转到Unity Hub中的安装，点击你想要修改的Unity版本的三点，然后在菜单中选择添加模块。
- en: Also across the bottom of this window are the Player Settings and Build/Switch
    Platform buttons. Click Player Settings to view settings for the app in the Inspector,
    such as the name and icon for the app. The other button changes its label depending
    on which platform you select in the list of platforms. If you have the active
    platform selected, clicking Build launches the build process. For any other platform,
    clicking Switch Platform makes that the active platform that Unity is currently
    dealing with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口的底部还有玩家设置和构建/切换平台按钮。点击玩家设置可以查看检查器中应用程序的设置，例如应用程序的名称和图标。另一个按钮的标签会根据你在平台列表中选择的平台而变化。如果你已经选择了活动平台，点击构建将启动构建过程。对于任何其他平台，点击切换平台将使其成为Unity当前正在处理的活跃平台。
- en: WARNING When in a big project, switching platforms often takes quite a bit of
    time to complete; make sure you’re ready to wait. This is because Unity recompresses
    all assets (such as textures) in an optimal way for each platform.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在大型项目中，切换平台通常需要相当长的时间才能完成；请确保你已经准备好等待。这是因为Unity会以针对每个平台最优化的方式重新压缩所有资产（如纹理）。
- en: TIP Build And Run does the same thing as Build, plus it automatically runs the
    built application. I usually want to do that part manually, so I rarely use Build
    And Run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：构建并运行与构建做同样的事情，但它会自动运行构建的应用程序。我通常想手动完成这部分，所以我很少使用构建并运行。
- en: 'When you click Build, the first thing that comes up is a file selector so that
    you can tell Unity where to generate the app package. Once you select a file location,
    the build process starts. Unity creates an executable app package for the currently
    active platform. Let’s go over the build process for the most popular platforms:
    desktop, web, and mobile.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击构建时，首先出现的是一个文件选择器，这样你就可以告诉Unity在哪里生成应用程序包。一旦你选择了文件位置，构建过程就开始了。Unity为当前活动的平台创建一个可执行的应用程序包。让我们回顾一下最流行的平台的构建过程：桌面、网页和移动。
- en: '13.1 Start by building for the desktop: Windows, Mac, and Linux'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 首先为桌面构建：Windows、Mac和Linux
- en: The simplest place to start when first learning to build Unity games is by deploying
    to desktop computers—Windows PC, macOS, or Linux. Because Unity runs on desktop
    computers, that means you’ll build an app for the computer you’re already using.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当初学习如何构建Unity游戏时，最简单的地方是将游戏部署到桌面计算机——Windows PC、macOS或Linux。因为Unity在桌面计算机上运行，这意味着你将为正在使用的计算机构建应用程序。
- en: NOTE Open up any project to work with in this section. Seriously, any Unity
    project will work. In fact, I strongly suggest using a different project in every
    section to drive home the fact that Unity can build any project to any platform!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本节中，打开任何项目进行工作。说真的，任何Unity项目都可以。实际上，我强烈建议在每个部分使用不同的项目，以强调Unity可以构建任何平台上的任何项目！
- en: 13.1.1 Building the application
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 构建应用程序
- en: First choose File > Build Settings to open the Build Settings window. By default,
    the current platform will be set to PC, Mac, and Linux, but if that isn’t current,
    select the correct platform from the list and click Switch Platform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先选择文件 > 构建设置以打开构建设置窗口。默认情况下，当前平台将设置为PC、Mac和Linux，但如果不是当前设置，请从列表中选择正确的平台并点击切换平台。
- en: On the right-hand side of the window, you’ll notice the Target Platform menu.
    This menu lets you choose between Windows PC, macOS, and Linux. All three are
    treated as one platform in the list on the left-hand side, but these are very
    different platforms, so choose the correct one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的右侧，你会注意到目标平台菜单。这个菜单允许你选择Windows PC、macOS和Linux。在左侧的列表中，这三个平台被视为一个平台，但实际上它们是非常不同的平台，所以请选择正确的平台。
- en: Once you’ve chosen your desktop platform, click Build. As explained previously,
    a file dialog pops up, allowing you to choose where the built application will
    go. Then the build process starts; this could take a while for a big project,
    but the build process should be fast for the tiny demos you’ve been making.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了桌面平台，点击构建。如前所述，会弹出一个文件对话框，允许你选择构建的应用程序将去哪里。然后开始构建过程；对于大型项目，这可能需要一段时间，但对于你一直在制作的微型演示，构建过程应该很快。
- en: Custom post-build script
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义构建后脚本
- en: Although the basic build process works fine in most situations, you may want
    a series of steps to be taken (such as moving help files into the same directory
    as the application) every time you build your game. You can easily automate such
    tasks by programming them in a script that will execute after the build process
    completes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基本构建过程在大多数情况下都能正常工作，但您可能希望在构建游戏时每次都执行一系列步骤（例如，将帮助文件移动到与应用程序相同的目录）。您可以通过编写在构建过程完成后执行的脚本轻松自动化此类任务。
- en: 'First, create a new folder in the Project view and name that folder Editor;
    any scripts that affect Unity’s editor (and that includes the build process) must
    go in a folder named Editor. Create a new script named TestPostBuild in that folder
    and write the following code in it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目视图中创建一个新的文件夹，并将其命名为Editor；任何影响Unity编辑器（包括构建过程）的脚本都必须放在名为Editor的文件夹中。在该文件夹中创建一个名为TestPostBuild的新脚本，并在其中编写以下代码：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The [PostProcessBuild] directive tells the script to run the function that’s
    immediately after it. That function will receive the location of the built app;
    you could then use that location with the various filesystem commands provided
    by C#.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostProcessBuild]指令告诉脚本运行紧随其后的函数。该函数将接收构建应用程序的位置；然后您可以使用C#提供的各种文件系统命令使用该位置。'
- en: The application will appear in the location you chose; double-click it to run
    it, like any other program. Congrats, that was easy! Building applications is
    a snap, but the process can be customized in various ways; let’s look at how to
    adjust the build.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将出现在您选择的地点；双击它以运行，就像任何其他程序一样。恭喜，这很简单！构建应用程序非常简单，但过程可以通过多种方式自定义；让我们看看如何调整构建过程。
- en: TIP Quit full-screen games with Alt-F4 on Windows or Cmd-Q on Mac. Finished
    games should have a button that calls Application.Quit().
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在Windows上使用Alt-F4或在Mac上使用Cmd-Q退出全屏游戏。完成的游戏应该有一个调用Application.Quit()的按钮。
- en: '13.1.2 Adjusting player settings: Setting the game’s name and icon'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 调整玩家设置：设置游戏名称和图标
- en: Go back to the Build Settings window, but this time click Player Settings instead
    of Build. A huge list of settings will appear in the Inspector (see figure 13.2);
    these settings control multiple aspects of the built application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回构建设置窗口，但这次点击玩家设置而不是构建。在检查器中会出现一个巨大的设置列表（见图13.2）；这些设置控制构建应用程序的多个方面。
- en: '![CH13_F02_Hocking3](../Images/CH13_F02_Hocking3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F02_Hocking3](../Images/CH13_F02_Hocking3.png)'
- en: Figure 13.2 Player settings displayed in the Inspector
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 检查器中显示的玩家设置
- en: Because of the large number of settings, you’ll probably want to look them up
    in Unity’s manual. The relevant doc page is [http://mng.bz/4Koa](https://shortener.manning.com/4Koa).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置众多，您可能需要查阅Unity的手册。相关文档页面是[http://mng.bz/4Koa](https://shortener.manning.com/4Koa)。
- en: 'The first several settings at the top are easiest to understand: Company Name,
    Product Name, Version, and Default Icon. Type in values for the first three: Company
    Name is the name for your development studio, Product Name is the name of this
    specific game, and Version is a number designation to increase as you update the
    game. Then drag an image from the Project view (import an image into the project
    if needed) to set that image as the icon; when the app is built, this image will
    appear as the application’s icon.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的前几个设置最容易理解：公司名称、产品名称、版本和默认图标。为前三个输入值：公司名称是您的开发工作室名称，产品名称是这款特定游戏的名称，版本是随着游戏更新而增加的数字标识。然后从项目视图（如果需要，将图像导入到项目中）拖动一个图像，将其设置为图标；当应用程序构建时，此图像将作为应用程序的图标出现。
- en: Customizing the icon and name of the application is important for giving it
    a finished appearance. Another useful way of customizing the behavior of built
    applications is with platform-dependent code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义应用程序的图标和名称对于使其看起来完整很重要。另一种自定义构建应用程序行为的有用方法是使用平台相关代码。
- en: 13.1.3 Platform-dependent compilation
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.3 平台相关编译
- en: By default, all the code you write will run the same way on all platforms. But
    Unity provides compiler directives (known as *platform defines*) that cause different
    code to run on different platforms. You’ll find the full list of platform defines
    in the manual at [http://mng.bz/Qq4w](https://shortener.manning.com/Qq4w).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您编写的所有代码将在所有平台上以相同的方式运行。但Unity提供了编译器指令（称为*平台定义*），这些指令会导致不同的代码在不同的平台上运行。您可以在手册中找到平台定义的完整列表，手册地址是[http://mng.bz/Qq4w](https://shortener.manning.com/Qq4w)。
- en: As that page indicates, directives are available for every platform that Unity
    supports, allowing you to run separate code on every platform. Usually, the majority
    of your code doesn’t have to be inside platform directives, but occasionally small
    bits of the code need to run differently on different platforms. For example,
    some code assemblies exist on only one platform, so you need to have platform
    compiler directives around those commands. The following listing shows how to
    write such code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如该页面所示，每个Unity支持的平台都有可用的指令，允许你在每个平台上运行不同的代码。通常，你的大部分代码不需要在平台指令内，但偶尔代码的某些小部分需要在不同的平台上以不同的方式运行。例如，某些代码组件仅在单个平台上存在，因此你需要在这些命令周围有平台编译器指令。以下列表显示了如何编写此类代码。
- en: Listing 13.1 PlatformTest script showing how to write platform-dependent code
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 PlatformTest脚本展示如何编写平台相关代码
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This section runs only within the editor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此部分仅在编辑器内运行。
- en: ❷ Only in desktop/standalone applications
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅在桌面/独立应用程序中
- en: Create a script called PlatformTest and write the code from this listing in
    it. Attach that script to an object in the scene (any object will do for testing),
    and a small message will appear in the top-left of the screen. When you play the
    game within Unity’s editor, the message will say Running in Editor, but if you
    build the game and run the built application, the message will say Running on
    Desktop. Different code is being run in each case!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为PlatformTest的脚本，并将此列表中的代码写入其中。将此脚本附加到场景中的对象（任何对象都可以用于测试），屏幕左上角将出现一条小消息。当你使用Unity编辑器播放游戏时，消息将显示为在编辑器中运行，但如果你构建游戏并运行构建的应用程序，消息将显示为在桌面上运行。每种情况下都在运行不同的代码！
- en: 'For this test, you used the platform define that treats all desktop platforms
    as one, but as indicated on that doc page, separate platform defines are available
    for Windows, Mac, and Linux. In fact, there are platform defines for all the platforms
    supported by Unity so that you can run different code on each. Let’s move on to
    the next important platform: the web.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，你使用了将所有桌面平台视为一个平台的平台定义，但如该文档页面所示，Windows、Mac和Linux都有单独的平台定义。实际上，Unity支持的所有平台都有平台定义，这样你就可以在每个平台上运行不同的代码。让我们继续下一个重要的平台：网页。
- en: Quality settings
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 质量设置
- en: The built application is also affected by project settings located under the
    Edit menu. In particular, the visual quality of the final app can be tuned there.
    Go to Project Settings in the Edit menu to open that window, and then choose Quality
    from the menu along the left side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的应用程序还受位于编辑菜单下的项目设置的影响。特别是，最终应用程序的视觉质量可以在那里进行调整。转到编辑菜单中的项目设置以打开该窗口，然后从左侧菜单中选择质量。
- en: Quality settings appear in the right side of the window, and the most important
    settings are the grid of check marks at the top. The different platforms that
    Unity can target are listed as icons across the top, and the possible quality
    settings are listed along the side. The boxes are checked for quality settings
    available for that platform, and the check box is highlighted green for the setting
    being used. Most of the time, these settings default to Very Low, but you can
    change to Ultra quality if things look bad; if you click the down arrow underneath
    a platform’s column, a pop-up menu will appear.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 质量设置显示在窗口的右侧，最重要的设置是顶部的一排复选框网格。Unity可以针对的不同平台以图标形式列在顶部，可能的质量设置沿侧面列出。为该平台可用的质量设置已勾选，正在使用的设置复选框高亮显示为绿色。大多数情况下，这些设置默认为非常低，但如果东西看起来不好，你可以将其更改为超高质量；如果你点击平台列下的向下箭头，将出现一个弹出菜单。
- en: It seems a bit redundant that this UI has both check boxes and the Default menu,
    but there you have it. Different platforms often have different graphical capabilities,
    so Unity allows you to set different quality levels for different build targets
    (such as highest quality on desktop and lower quality on mobile).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI既有复选框又有默认菜单，这似乎有点多余，但就是这样。不同的平台通常有不同的图形能力，因此Unity允许你为不同的构建目标设置不同的质量级别（例如，桌面上的最高质量，移动设备上的较低质量）。
- en: '![CH13_UN01_Hocking3](../Images/CH13_UN01_Hocking3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_UN01_Hocking3](../Images/CH13_UN01_Hocking3.png)'
- en: Grid of quality settings in the Inspector
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器中的质量设置网格
- en: 13.2 Building for the web
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 为网页构建
- en: Although desktop platforms are the most basic targets to build for, another
    important platform for Unity games is the web. Games deployed to the web run within
    a web browser and can thus be played over the internet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然桌面平台是构建的基本目标，但对于 Unity 游戏，另一个重要的平台是网页。部署到网页上的游戏在网页浏览器中运行，因此可以通过互联网进行游戏。
- en: Unity Web Player vs. HTML5/WebGL
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Web Player 与 HTML5/WebGL 对比
- en: Initially, Unity had to deploy web builds in a form that played within a custom
    browser plugin. This had long been necessary because 3D graphics weren’t built
    into web browsers. Eventually, however, most browsers adopted WebGL, a standard
    for 3D graphics on the web. Technically, WebGL is separate from HTML5, but the
    two terms are related and are often used interchangeably when talking about 3D
    on the web.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Unity 必须以在自定义浏览器插件中播放的形式部署网页构建。这长期以来一直是必要的，因为 3D 图形并未内置到网页浏览器中。然而，最终，大多数浏览器都采用了
    WebGL，这是网页上 3D 图形的标准。技术上，WebGL 与 HTML5 是分开的，但这两个术语是相关的，并且在谈论网页上的 3D 时经常可以互换使用。
- en: For version 5, Unity added WebGL to the build platforms list, and a few versions
    later the browser plugin was dropped, making WebGL the sole avenue for web builds.
    In part, these changes in Unity’s web build were being driven by strategic decisions
    made within Unity (the company). But these changes were also being driven by pushes
    from browser makers, who are moving away from custom plugins and embracing HTML5/WebGL
    as the way to develop interactive web applications, including games.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本 5，Unity 将 WebGL 添加到了构建平台列表中，而在几个版本之后，浏览器插件被取消，使得 WebGL 成为网页构建的唯一途径。部分原因是
    Unity（公司）内部做出的战略决策推动了 Unity 网页构建的这些变化。但这些变化也受到了浏览器制造商的推动，他们正在远离自定义插件，并拥抱 HTML5/WebGL
    作为开发交互式网页应用（包括游戏）的方式。
- en: 13.2.1 Building the game embedded in a web page
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 在网页中嵌入游戏构建
- en: Open a different project (again, this is to emphasize that any project will
    work) and open the Build Settings window. Switch the platform to WebGL and then
    click the Build button. A file selector will come up; type in the name WebTest
    for this application, and change to a safe location (a location not within the
    Unity project) if necessary.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个不同的项目（再次强调，这是为了强调任何项目都可以使用），然后打开构建设置窗口。将平台切换到 WebGL，然后点击构建按钮。文件选择器将出现；为此应用程序输入名称
    WebTest，如果需要，更改到一个安全的位置（不在 Unity 项目内的位置）。
- en: The build process will now create a folder containing an index.html web page,
    as well as subfolders with all the game’s code and other assets. Open this web
    page, and the game should be embedded in the middle of the otherwise blank page.
    You will need to run the game from a web server, rather than simply opening index.html
    as a local file. Just as in chapter 10, you could use an existing web server if
    you already have a website, or you could test on http://localhost/ with something
    like XAMPP.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程现在将创建一个包含 index.html 网页的文件夹，以及包含所有游戏代码和其他资源的子文件夹。打开这个网页，游戏应该嵌入到原本空白的页面中间。您需要从
    Web 服务器上运行游戏，而不是简单地打开 index.html 作为本地文件。就像第 10 章中提到的那样，如果您已经有了网站，可以使用现有的 Web 服务器，或者您可以在
    http://localhost/ 上使用类似 XAMPP 的工具进行测试。
- en: NOTE You may need to adjust the settings of your web server for correct handling
    of compressed archives in the WebGL build. Unity’s manual ([http://mng.bz/XreG](https://shortener.manning.com/XreG))
    explains these server settings, but if you can’t adjust these for some reason
    (for example, the game will be on a third-party site that you cannot configure),
    you can also tell Unity to include a decompressor in the build. Turn on Decompressor
    Fallback in the Publishing Settings section of the WebGL player settings. This
    setting is off by default, because the browser’s decompression is better. Be warned
    though, because with this setting on, you won’t notice an improperly configured
    server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能需要调整您的 Web 服务器设置，以正确处理 WebGL 构建中的压缩存档。Unity 的手册（[http://mng.bz/XreG](https://shortener.manning.com/XreG)）解释了这些服务器设置，但如果您由于某种原因无法调整这些设置（例如，游戏将位于您无法配置的第三方网站上），您也可以告诉
    Unity 在构建中包含一个解压缩器。在 WebGL 播放器设置的发布设置部分开启解压缩器回退。此设置默认关闭，因为浏览器的解压缩更好。但请注意，当此设置开启时，您可能不会注意到服务器配置不当。
- en: There’s nothing particularly special about this web page; it’s just an example
    to test your game with. It’s possible to customize the code on that page or even
    provide your own web page (discussed later). One of the most important customizations
    to make is enabling communication between Unity and the browser, so let’s go over
    that next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网页没有什么特别之处；它只是一个用来测试你的游戏的示例。你可以自定义该页面的代码，甚至提供你自己的网页（稍后讨论）。最重要的自定义之一是启用Unity和浏览器之间的通信，所以让我们接下来看看这一点。
- en: 13.2.2 Communicating with JavaScript in the browser
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 与浏览器中的JavaScript通信
- en: 'A Unity web game can communicate with the browser (or rather with JavaScript
    running in the browser), and these messages can go in both directions: from Unity
    to the browser, and from the browser to Unity. To send messages to the browser,
    you write JavaScript code into a code library, and then Unity has special commands
    to use functions in that library.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity网页游戏可以与浏览器（或者更确切地说，与浏览器中运行的JavaScript）通信，这些消息可以双向传递：从Unity到浏览器，以及从浏览器到Unity。要向浏览器发送消息，你需要在代码库中编写JavaScript代码，然后Unity有特殊的命令来使用该库中的函数。
- en: Meanwhile, for messages from the browser, JavaScript in the browser identifies
    an object by name, and then Unity passes the message to the named object in the
    scene. Thus, you must have an object in the scene that will receive communications
    from the browser.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，对于来自浏览器的消息，浏览器中的JavaScript通过名称识别一个对象，然后Unity将消息传递到场景中命名的对象。因此，你必须有一个在场景中的对象，它将接收来自浏览器的通信。
- en: To demonstrate these tasks, create a new script in Unity called WebTestObject.
    Also create an empty object in the active scene called JSListener (the object
    in the scene must have that exact name, because that’s the name used by the JavaScript
    code in listing 13.4). Attach the new script to that object and then write in
    the code from this listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些任务，在Unity中创建一个名为WebTestObject的新脚本。同时，在活动场景中创建一个名为JSListener的空对象（场景中的对象必须具有该确切名称，因为这是列表13.4中JavaScript代码使用的名称）。将新脚本附加到该对象，然后编写此列表中的代码。
- en: Listing 13.2 WebTestObject script for testing communication with the browser
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.2 测试与浏览器通信的WebTestObject脚本
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Import the function from the JS library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从JS库导入函数。
- en: ❷ On mouse click, call the imported function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在鼠标点击时调用导入的函数。
- en: ❸ Display the message in top left of the screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在屏幕左上角显示消息。
- en: ❹ Function for the browser to call
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 浏览器调用的函数
- en: The main new bit is the DllImport command. That imports a function from the
    JavaScript library to use in C# code. That obviously implies you *have* a JavaScript
    library, so write that next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的新功能是DllImport命令。它将JavaScript库中的一个函数导入到C#代码中使用。这显然意味着你*有*一个JavaScript库，所以接下来编写它。
- en: 'First create the special folder to contain it: create a folder called Plugins,
    and within that create a folder called WebGL. Now put a file called WebTest that
    has the extension jslib (so WebTest.jslib) in the WebGL folder; the simplest way
    is to create a text file outside Unity, rename it, and then drag the file in.
    Unity will recognize that file as a JavaScript library, so write this code in
    it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个特殊的文件夹来包含它：创建一个名为Plugins的文件夹，并在其中创建一个名为WebGL的文件夹。现在在WebGL文件夹中放置一个名为WebTest的文件，扩展名为jslib（因此为WebTest.jslib）；最简单的方法是在Unity外创建一个文本文件，重命名它，然后将文件拖入。Unity会识别该文件为JavaScript库，因此在该文件中编写此代码。
- en: Listing 13.3 WebTest JavaScript library
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.3 WebTest JavaScript库
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The function imported and called from C#
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从C#导入并调用的函数
- en: The jslib file contains both a JavaScript object containing functions and the
    command to merge the custom object into Unity’s library manager. Note that the
    function written includes Pointer_stringify() besides standard JavaScript commands;
    when passing a string from Unity, it’s turned into a numeric identifier, so Unity
    provides that function to look up the string pointed to.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: jslib文件包含一个包含函数的JavaScript对象以及将自定义对象合并到Unity库管理器的命令。请注意，编写的函数除了标准的JavaScript命令外还包括Pointer_stringify()；当从Unity传递字符串时，它会被转换为一个数字标识符，因此Unity提供该函数来查找指向的字符串。
- en: Now build for the web again to see the new code in action. The WebTestObject
    in Unity calls a function in the JavaScript code when you click within the Unity
    game part of the web page; try clicking a few times, and you’ll see an alert box
    appear in the browser!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次为网页构建，以查看新代码的实际效果。当你在网页的Unity游戏部分内点击时，Unity中的WebTestObject会调用JavaScript代码中的函数；尝试点击几次，你会在浏览器中看到一个警告框出现！
- en: NOTE Unity also has Application.ExternalEval() for running code in the browser;
    ExternalEval runs arbitrary snippets of JavaScript, rather than calling defined
    functions. This method is deprecated and should be avoided, but sometimes its
    simplicity is useful, like reloading the page with just Application.ExternalEval("location.reload();").
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Unity 还提供了 Application.ExternalEval() 来在浏览器中运行代码；ExternalEval 运行任意的 JavaScript
    片段，而不是调用定义好的函数。这种方法已被弃用，应避免使用，但有时它的简单性很有用，比如使用 Application.ExternalEval("location.reload();")
    来重新加载页面。
- en: All right, you have tested communication from the Unity game to JavaScript in
    the web page, but the web page can also send a message back to Unity, so let’s
    do that too. This will involve new code and buttons on the page; fortunately,
    Unity provides an easy way to customize the web page. Specifically, Unity fills
    in a web page *template* when it builds to WebGL, and you can choose a custom
    template instead of the default one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经测试了从 Unity 游戏到网页中 JavaScript 的通信，但网页也可以向 Unity 发送消息，所以我们也来做这个。这会涉及到页面上的新代码和按钮；幸运的是，Unity
    提供了一种简单的方式来自定义网页。具体来说，Unity 在构建到 WebGL 时会填充一个网页 *模板*，你可以选择一个自定义模板而不是默认模板。
- en: The default templates can be found in the Unity installation folder (usually
    C:\Program Files\Unity\Editor\Data on Windows, or /Applications/Unity/Editor on
    Mac) under /WebGLSupport/BuildTools/WebGLTemplates. Open a template page in a
    text editor and you’ll see that a template is largely standard HTML and JavaScript,
    plus some special tags that Unity replaces with generated information. Although
    it’s best for you to leave Unity’s built-in templates alone, they (especially
    the *minimal* one) make a good base on which to build your own. You’ll copy the
    minimal template web page into the custom template you make.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板可以在 Unity 安装文件夹中找到（在 Windows 上通常是 C:\Program Files\Unity\Editor\Data，在 Mac
    上通常是 /Applications/Unity/Editor），位于 /WebGLSupport/BuildTools/WebGLTemplates 下。在文本编辑器中打开一个模板页面，你会看到模板主要是标准的
    HTML 和 JavaScript，还有一些 Unity 替换为生成信息的特殊标签。虽然最好让 Unity 的内置模板保持原样，但它们（尤其是 *最小* 的一个）可以作为构建你自己的良好基础。你将把最小模板网页复制到你创建的自定义模板中。
- en: In Unity’s Project view, create a folder called WebGLTemplates (no space) directly
    under Assets; that’s where custom templates go. Now create a subfolder within
    it named WebTest; that folder is for your new template. Put an index.html file
    in here (you can copy in the web page from the minimal template), open that in
    a text editor, and write this code in it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 的项目视图中，在 Assets 下的直接位置创建一个名为 WebGLTemplates 的文件夹（没有空格）；这是自定义模板存放的地方。现在在这个文件夹内创建一个名为
    WebTest 的子文件夹；这个文件夹用于你的新模板。在这里放入一个 index.html 文件（你可以从最小模板中复制网页），在文本编辑器中打开它，并写入以下代码。
- en: Listing 13.4 WebGL template to enable browser-Unity communication
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.4 WebGL 模板以启用浏览器-Unity 通信
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Making the page dark instead of white
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将页面改为深色而不是白色
- en: ❷ Button that calls the JavaScript function
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 JavaScript 函数的按钮
- en: ❸ SendMessage() points to the named object in Unity.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ SendMessage() 指向 Unity 中的命名对象。
- en: If you copied the minimal template, you’ll see that listing 13.4 simply adds
    a few lines there. The two important additions are a function in the script tag
    and an input button on the page; the added style changes the color of the page
    to make it easier to see the embedded game. The button’s HTML tag links to a JavaScript
    function, and that function calls SendMessage() on the Unity instance. This method
    calls a function on a named object within Unity; the first parameter is the name
    of the object, the second parameter is the name of the method, and the third parameter
    is a string to pass in while calling the method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你复制了最小模板，你会看到列表 13.4 只是在那里添加了几行。两个重要的新增内容是脚本标签中的一个函数和页面上的一个输入按钮；添加的样式改变了页面的颜色，使其更容易看到嵌入的游戏。按钮的
    HTML 标签链接到一个 JavaScript 函数，该函数在 Unity 实例上调用 SendMessage()。这种方法在 Unity 中调用一个命名对象的函数；第一个参数是对象的名称，第二个参数是方法的名称，第三个参数是在调用方法时传递的字符串。
- en: You’ve made your custom template, but you still have to tell Unity to use this
    template instead of the default. Open the Player Settings again (remember, click
    Player Settings in the Build Settings window) and find WebGL Template in the web
    settings (shown in figure 13.3). You’ll see that Default is currently selected,
    but WebTest (the template folder you created) is also on the list; click that
    one instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经制作了自定义模板，但你还必须告诉 Unity 使用这个模板而不是默认模板。再次打开 Player Settings（记住，在 Build Settings
    窗口中点击 Player Settings）并找到网页设置中的 WebGL Template（如图 13.3 所示）。你会看到当前选择的是默认，但 WebTest（你创建的模板文件夹）也在列表中；点击它。
- en: '![CH13_F03_Hocking3](../Images/CH13_F03_Hocking3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F03_Hocking3](../Images/CH13_F03_Hocking3.png)'
- en: Figure 13.3 WebGL Template setting
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 WebGL模板设置
- en: With the custom template selected, build to WebGL again. Open the generated
    web page, and this time a button is at the bottom of the page. Click the button
    and you’ll see the changed message displayed in Unity!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了自定义模板后，再次构建到WebGL。打开生成的网页，这次页面的底部有一个按钮。点击按钮，你将在Unity中看到显示的更改消息！
- en: 'That wraps up browser communication for web builds. On to the next important
    platform (or rather, set of platforms) for building apps: mobile.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了Web构建的浏览器通信。接下来是构建应用程序的下一个重要平台（或者更确切地说，是一组平台）：移动。
- en: '13.3 Building for mobile: iOS and Android'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 为移动构建：iOS和Android
- en: Mobile apps are another important build target for Unity. My gut impression
    (totally unscientific) is that most commercial games created using Unity are mobile
    games.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用是Unity的重要构建目标之一。我的直观印象（完全非科学的）是，大多数使用Unity创建的商业游戏都是移动游戏。
- en: DEFINITION *Mobile* is a category of handheld computing devices. The designation
    started with smartphones but now includes tablets. The two most widely used mobile
    computing platforms are iOS (from Apple) and Android (from Google).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** *移动* 是手持计算设备的一个类别。这个分类最初始于智能手机，但现在也包括平板电脑。最广泛使用的两个移动计算平台是iOS（来自苹果）和Android（来自谷歌）。'
- en: Setting up the build process for mobile apps is more complicated than either
    desktop or web builds, so this is another optional section—optional as in only
    read through it, without actually following the steps. I’ll still write as if
    you’re working along, but you’d have to buy a developer license for iOS and install
    all the developer tools for Android.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为移动应用设置构建过程比桌面或Web构建更复杂，因此这是一个可选的部分——可选的意思是，你可以阅读它，但实际上不需要遵循步骤。我仍然会像你正在一起工作一样写，但你需要购买iOS的开发者许可证并安装所有Android的开发者工具。
- en: WARNING Mobile devices undergo so much rapid change that the exact build process
    is likely to be slightly different by the time you read this. The high-level concepts
    are probably still true, but you should look at up-to-date documentation online
    for an exact rundown of the commands to execute and buttons to push. For starters,
    here are the doc pages from Apple ([https://developer .apple.com/documentation/xcode](https://developer.apple.com/documentation/xcode))
    and Google ([https://developer.android .com/studio/build](https://developer.android.com/studio/build)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** 移动设备经历了如此快速的变化，以至于在你看这篇文档的时候，确切的构建过程可能略有不同。高级概念可能仍然正确，但你应该查看在线的最新文档，以获取执行命令和按钮的详细说明。首先，这里有一些来自苹果([https://developer
    .apple.com/documentation/xcode](https://developer.apple.com/documentation/xcode))和谷歌([https://developer.android
    .com/studio/build](https://developer.android.com/studio/build))的文档页面。'
- en: Touch input
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸输入
- en: Input on mobile devices works differently than on desktop or the web. Mobile
    input is done by touching the screen, rather than with the mouse and keyboard.
    Unity has input functionality for handling touches, including code like Input.touchCount
    and Input.GetTouch().
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上的输入方式与桌面或Web不同。移动输入是通过触摸屏幕完成的，而不是通过鼠标和键盘。Unity具有处理触摸的输入功能，包括像Input.touchCount和Input.GetTouch()这样的代码。
- en: You may want to use these commands to write platform-specific code on mobile
    devices. Handling input that way can be a hassle, though, so code frameworks are
    available to streamline the use of touch input. For example, search on Unity’s
    Asset Store for Fingers or Lean Touch.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用这些命令在移动设备上编写特定平台的代码。然而，以这种方式处理输入可能会很麻烦，因此有代码框架可供简化触摸输入的使用。例如，在Unity的Asset
    Store上搜索Fingers或Lean Touch。
- en: All right, with those caveats out of the way, I’ll explain the overall build
    process for both iOS and Android. Keep in mind that these platforms occasionally
    change the details of the build process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，把这些注意事项放一边，我将解释iOS和Android的整体构建过程。记住，这些平台偶尔会改变构建过程的细节。
- en: 13.3.1 Setting up the build tools
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 设置构建工具
- en: Mobile devices are all separate from the computer you’re developing on, and
    that separateness makes the process of building and deploying to devices slightly
    more complex. You’ll need to set up a variety of specialized tools before you
    can click Build.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备都与你在其上开发的计算机分开，这种分离使得构建和部署到设备的过程稍微复杂一些。在点击构建之前，你需要设置各种专用工具。
- en: Setting up iOS build tools
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设置iOS构建工具
- en: At a high level, the process of deploying a Unity game on iOS requires first
    building an Xcode project from Unity and then building the Xcode project into
    an iOS application package (IPA) using Xcode. Unity can’t build the final IPA
    directly because all iOS apps have to go through Apple’s build tools. That means
    you need to install Xcode (Apple’s programming IDE), including the iOS SDK.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，在 iOS 上部署 Unity 游戏的过程首先需要从 Unity 构建一个 Xcode 项目，然后使用 Xcode 将该 Xcode 项目构建成一个
    iOS 应用程序包（IPA）。Unity 无法直接构建最终的 IPA，因为所有 iOS 应用都必须通过苹果的构建工具。这意味着您需要安装 Xcode（苹果的编程
    IDE），包括 iOS SDK。
- en: WARNING You have to be working on a Mac when deploying an iOS game—Xcode runs
    only on macOS. Developing a game within Unity can be done on either Windows or
    Mac, but building the iOS app must be done on a Mac.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** 部署 iOS 游戏时，您必须在 Mac 上工作——Xcode 仅在 macOS 上运行。在 Unity 内部开发游戏可以在 Windows
    或 Mac 上进行，但构建 iOS 应用必须在 Mac 上进行。'
- en: 'Get Xcode from Apple’s website, in the developer section: [https://developer.apple.com/xcode/](https://developer.apple.com/xcode/).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从苹果的网站上获取 Xcode，在开发者部分：[https://developer.apple.com/xcode/](https://developer.apple.com/xcode/).
- en: NOTE You need membership in the Apple Developer Program in order to sell your
    iOS game on the App Store. Apple’s developer program costs $99/year; enroll at
    [https://developer.apple.com/programs/](https://developer.apple.com/programs/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 您需要成为苹果开发者计划成员才能在 App Store 上销售您的 iOS 游戏。苹果的开发者计划费用为 99 美元/年；在 [https://developer.apple.com/programs/](https://developer.apple.com/programs/)
    注册。'
- en: Once Xcode is installed, launch it and open Preferences to add your developer
    account. You need to be logged in when Xcode accesses your account while building
    an app.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 安装完成后，启动它并打开首选项以添加您的开发者账户。当 Xcode 在构建应用程序时访问您的账户时，您需要登录。
- en: Now go back to Unity and switch to iOS. You need to adjust the Player settings
    for the iOS app (remember, open Build Settings and click Player Settings). You
    should already be on the iOS tab of the Player settings, but click the tab with
    an iOS icon if needed. Scroll down to Other Settings and then look for Identification.
    Bundle Identifier needs to be adjusted so that Apple will correctly identify the
    app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 Unity 并切换到 iOS。您需要调整 iOS 应用的播放器设置（记住，打开构建设置并点击播放器设置）。您应该已经在播放器设置的 iOS
    选项卡上，但如果需要，请点击带有 iOS 图标的选项卡。向下滚动到其他设置，然后查找识别。Bundle Identifier 需要调整，以便苹果能够正确识别应用程序。
- en: 'NOTE iOS calls it Bundle Identifier, and Android calls it Package Name, but
    naming otherwise works the same way on both platforms. The identifier should follow
    the same convention as that for any code package: all lowercase in the form com.companyname.productname.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** iOS 称之为 Bundle Identifier，而 Android 称之为 Package Name，但在两个平台上命名方式相同。标识符应遵循任何代码包的相同约定：所有小写，形式为
    com.companyname.productname。'
- en: Another important setting that applies to both iOS and Android is Version (this
    is the version number of the app). Most of the settings beyond that are platform-specific;
    for example, iOS added an additional build number, separate from the main version
    number. There’s also a setting for Scripting Backend; Mono was always used in
    the past, but the newer IL2CPP backend supports iOS updates, like 64-bit binaries.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个适用于 iOS 和 Android 的重要设置是版本（这是应用程序的版本号）。大多数超出该范围的设置都是平台特定的；例如，iOS 添加了一个额外的构建号，与主要版本号分开。还有一个脚本后端设置；过去总是使用
    Mono，但较新的 IL2CPP 后端支持 iOS 更新，如 64 位二进制文件。
- en: NOTE iOS builds from Unity don’t work with both real devices (iPhones and iPads)
    and iOS simulators. By default, iOS builds from Unity work only on real devices,
    but you can switch to building for simulators by scrolling down to Target SDK
    in Player settings. In practice, I’ve never had to do this, because all my “testing
    outside real device” work is done within Unity itself, and if I’m doing an iOS
    build, then I want to run it on an actual phone.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** iOS 从 Unity 构建的版本既不支持真实设备（iPhone 和 iPad）也不支持 iOS 模拟器。默认情况下，iOS 从 Unity
    构建的版本仅在真实设备上工作，但您可以通过在播放器设置中向下滚动到目标 SDK 来切换到为模拟器构建。实际上，我从未这样做过，因为我的所有“在真实设备之外”的测试工作都是在
    Unity 本身完成的，如果我要进行 iOS 构建，那么我想要在真正的手机上运行它。'
- en: Now click Build in the Build Settings window. Select the location for the built
    files, and that’ll generate an Xcode project in that location; you probably want
    to click the button to create a new folder and then choose that newly created
    folder.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构建设置窗口中点击构建。选择构建文件的存储位置，这将在此位置生成一个 Xcode 项目；您可能想要点击按钮创建一个新文件夹，然后选择该新创建的文件夹。
- en: The Xcode project that results can be modified directly if you want (simple
    modifications could be part of the post-build script). Regardless, open the Xcode
    project; the built folder has many files, but double-click the .xcodeproj file
    (it has an icon of a blueprint). Xcode will open with this project loaded. Unity
    already took care of most of the settings needed in the project, but you do need
    to adjust the provisioning profiles being used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的结果的 Xcode 项目可以修改（简单的修改可以是构建脚本的一部分）。无论如何，打开 Xcode 项目；构建文件夹中有许多文件，但双击 .xcodeproj
    文件（它有一个蓝图图标）。Xcode 将以加载此项目的方式打开。Unity 已经处理了项目中所需的大部分设置，但你确实需要调整正在使用的配置文件。
- en: iOS provisioning profiles
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 配置文件
- en: Of all the aspects of iOS development, provisioning profiles are the most unusual.
    In short, these are files used for identification and authorization. Apple tightly
    controls what apps can run on what devices; apps submitted to Apple for approval
    use special provisioning profiles that allow them to work through the App Store,
    whereas apps in development use provisioning profiles that are specific to registered
    devices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 开发的所有方面中，配置文件是最不寻常的。简而言之，这些是用于身份验证和授权的文件。苹果严格控制哪些应用程序可以在哪些设备上运行；提交给苹果进行审核的应用程序使用特殊的配置文件，允许它们通过
    App Store 运行，而开发中的应用程序使用特定于注册设备的配置文件。
- en: You’ll need to add both your iPhone’s UDID (an ID specific to your device) and
    the app’s ID (the Bundle Identifier in Unity) to your account on Apple’s website
    for iOS developers. For a complete explanation of this process, visit [https://developer.apple.com/support/code-signing/](https://developer.apple.com/support/code-signing/).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将你的 iPhone 的 UDID（一个特定于你的设备的 ID）和应用程序的 ID（Unity 中的包标识符）添加到苹果 iOS 开发者网站上的你的账户中。有关此过程的完整说明，请访问
    [https://developer.apple.com/support/code-signing/](https://developer.apple.com/support/code-signing/)。
- en: '![CH13_UN02_Hocking3](../Images/CH13_UN02_Hocking3.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_UN02_Hocking3](../Images/CH13_UN02_Hocking3.png)'
- en: Where to manage provisioning profiles in the iOS Dev Center
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 开发中心如何管理配置文件
- en: Xcode will attempt to set up the signing profiles automatically, so this is
    why you added your account in Preferences earlier. Select your app in the project
    list on the left-hand side of Xcode, and several tabs relevant to the selected
    project will appear. Click the tab for Signing & Capabilities and click the Team
    menu to select the team registered with Apple’s developer program (see figure
    13.4). If for some reason you don’t want Xcode to automatically manage signing,
    provisioning profiles can be adjusted manually by scrolling down to Signing in
    the Build Settings tab.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 将尝试自动设置签名配置文件，这就是为什么你之前在“首选项”中添加了你的账户。在 Xcode 左侧的项目列表中选择你的应用程序，与所选项目相关的几个选项卡将出现。点击“签名与能力”选项卡，然后点击“团队”菜单以选择注册在苹果开发者计划中的团队（见图
    13.4）。如果出于某种原因你不想让 Xcode 自动管理签名，可以在构建设置选项卡中向下滚动到“签名”手动调整配置文件。
- en: '![CH13_F04_Hocking3](../Images/CH13_F04_Hocking3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F04_Hocking3](../Images/CH13_F04_Hocking3.png)'
- en: Figure 13.4 Provisioning/signing settings in Xcode
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 Xcode 中的配置/签名设置
- en: 'Once the provisioning profiles are set, you’re ready to build the app. From
    the Product menu, choose either Run or Archive. The Product menu has a lot of
    options, including the tantalizingly named Build, but for our purposes, the two
    options that are useful are Run and Archive. Build generates executable files
    but doesn’t bundle them for iOS, whereas this is what Run and Archive do:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了配置文件，你就可以构建应用程序了。从“产品”菜单中选择运行或归档。产品菜单有很多选项，包括诱人的“构建”名称，但对我们来说，有用的两个选项是运行和归档。构建生成可执行文件，但不为
    iOS 打包，而运行和归档正是这样做的：
- en: Run will test the application on an iPhone connected to the computer with a
    USB cable.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行将在通过 USB 线缆连接到计算机的 iPhone 上测试应用程序。
- en: Archive will create an application package that can be sent to other registered
    devices (either for release, or testing via what Apple refers to as *ad hoc distribution*).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档将创建一个应用程序包，可以发送到其他注册的设备（无论是发布还是通过苹果所说的*临时分发*进行测试）。
- en: Archive doesn’t create the app package directly but rather creates a bundle
    in an intermediate stage between the raw code files and an IPA. The created archive
    will be listed in Xcode’s Organizer window; in that window, select the generated
    archive and click Distribute App on the right-hand side. After you click that,
    you’ll be asked if you want to distribute the app on the store or ad hoc.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 归档不会直接创建应用程序包，而是在原始代码文件和IPA之间的中间阶段创建一个包。创建的归档将列在Xcode的Organizer窗口中；在那个窗口中，选择生成的归档，然后在右侧点击分发应用程序。点击后，您将被询问是否要在商店或临时分发应用程序。
- en: If you choose ad hoc distribution, you’ll end up with an IPA file that can be
    sent to testers. You could send the file directly for them to install through
    iTunes, but it’s more convenient to set up a website to handle distributing and
    installing test builds. Alternatively, use TestFlight ([https://developer.apple.com/testflight/](https://developer.apple.com/testflight/))
    on builds that have been uploaded to the store but not submitted yet.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择临时分发，您将得到一个IPA文件，可以发送给测试人员。您可以直接发送文件让他们通过iTunes安装，但设置一个网站来处理分发和安装测试构建会更方便。或者，对于已上传到商店但尚未提交的构建，可以使用TestFlight
    ([https://developer.apple.com/testflight/](https://developer.apple.com/testflight/))。
- en: Setting up Android build tools
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Android构建工具
- en: Unlike iOS apps, Unity can generate the final Android application (either an
    APK, for Android application package, or AAB, for Android app bundle) directly.
    This requires pointing Unity to the Android SDK, which includes the necessary
    compiler. You could install the Android SDK along with the Android build module
    for Unity, or you could install it from within Android Studio and point to that
    file location in Unity’s preferences (see figure 13.5). You can download the Android
    build tools from [https://developer.android.com/studio](https://developer.android.com/studio).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS应用不同，Unity可以直接生成最终的Android应用程序（无论是APK，即Android应用包，还是AAB，即Android应用包），这需要将Unity指向Android
    SDK，其中包含必要的编译器。您可以选择在Unity中安装Android SDK以及Android构建模块，或者从Android Studio内部安装它，并在Unity的首选项中指向该文件位置（见图13.5）。您可以从[https://developer.android.com/studio](https://developer.android.com/studio)下载Android构建工具。
- en: '![CH13_F05_Hocking3](../Images/CH13_F05_Hocking3.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F05_Hocking3](../Images/CH13_F05_Hocking3.png)'
- en: Figure 13.5 Unity preference setting to point to Android SDK
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 Unity首选项设置以指向Android SDK
- en: After setting the Android SDK in Unity’s preferences, you need to specify the
    app’s identifier just as you did for iOS. You’ll find Package Name in Player Settings;
    set it to com.companyname.productname (as explained previously when setting the
    Bundle Identifier for iOS). Then click Build to start the process. As with all
    builds, Unity will first ask where to save the file. Then it’ll create an APK
    file in that location.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的首选项中设置Android SDK后，您需要指定与应用程序标识符，就像您为iOS所做的那样。您将在玩家设置中找到包名；将其设置为com.companyname.productname（如之前设置iOS的包标识符时所述）。然后点击构建以开始过程。与所有构建一样，Unity将首先询问文件保存位置。然后它将在该位置创建一个APK文件。
- en: Now that you have the app package, you must install it on a device. You can
    get the APK file onto an Android phone by downloading the file from the web (cloud
    storage like Google Drive is useful for this purpose) or by transferring the file
    via a USB cable connected to your computer (an approach referred to as *sideloading*).
    The details of how to transfer files via USB vary for every device, but once there,
    the files can be installed using a file manager app. I don’t know why file managers
    aren’t built into Android, but you can install one for free from the Google Play
    Store. Navigate to your APK file within the file manager and then install the
    app.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了应用程序包，必须在设备上安装它。您可以通过从网络（如Google Drive这样的云存储对这一目的很有用）下载文件或将文件通过连接到计算机的USB电缆（这种方法被称为*侧载*）传输到Android手机上，将APK文件安装到Android手机上。通过USB传输文件的具体细节因设备而异，但一旦文件到达那里，就可以使用文件管理器应用程序安装文件。我不知道为什么文件管理器没有内置到Android中，但您可以从Google
    Play Store免费安装一个。在文件管理器中导航到您的APK文件，然后安装应用程序。
- en: APK vs. AAB for Android builds
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Android构建的APK与AAB
- en: Since the inception of Android, applications have been distributed as APK (Android
    application package) files. However, Google has supported AAB (Android app bundle,
    an alternative kind of application file) for a little while now, and has started
    requiring that format for apps submitted to the Play Store. Instead of having
    support for every device baked into the single application package, app bundles
    allow the Play Store to instead generate a smaller application package designed
    just for the specific user to download, resulting in smaller files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Android诞生以来，应用程序都是以APK（Android应用程序包）文件的形式进行分发的。然而，谷歌已经支持AAB（Android应用包，一种替代的应用文件格式）有一段时间了，并且已经开始要求将此格式用于提交到Play
    Store的应用程序。应用包允许Play Store生成一个专为特定用户下载的小型应用程序包，而不是将每个设备的支持都嵌入到单个应用程序包中，从而生成更小的文件。
- en: Unity supports both formats in the Build Settings window. When you have the
    Android platform selected, look for the Build App Bundle check box; leave that
    off for APK, or turn that on for AAB. It’s generally better to build APK files
    while testing (since those are easier to install on testing devices) and then
    build AAB for the final version to submit to the Play Store.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在构建设置窗口中支持这两种格式。当您选择Android平台时，查找“构建应用包”复选框；对于APK，请取消选中该复选框，或者对于AAB，请选中该复选框。通常在测试时构建APK文件会更好（因为它们更容易在测试设备上安装），然后为最终版本提交到Play
    Store构建AAB。
- en: '![CH13_UN03_Hocking3](../Images/CH13_UN03_Hocking3.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_UN03_Hocking3](../Images/CH13_UN03_Hocking3.png)'
- en: Where to switch Android builds between APK and AAB
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在APK和AAB之间切换Android构建的位置
- en: As you can see, the basic build process for Android is a lot simpler than the
    build process for iOS. Unfortunately, the process of customizing the build and
    implementing plugins is more complicated than with iOS; you’ll learn how in a
    bit. But before that, let’s talk about texture compression.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Android的基本构建过程比iOS的构建过程简单得多。不幸的是，自定义构建和实现插件的流程比iOS复杂；您将在稍后了解如何操作。但在那之前，让我们先谈谈纹理压缩。
- en: 13.3.2 Texture compression
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 纹理压缩
- en: Assets can eat up a lot of memory, and this especially includes textures. To
    reduce their file size, you can compress assets in various ways, with pros and
    cons to each method. Because of these pros and cons, you may need to adjust how
    Unity compresses textures.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 资产可能会消耗大量内存，这尤其包括纹理。为了减少它们的文件大小，您可以通过各种方式压缩资产，每种方法都有其优缺点。由于这些优缺点，您可能需要调整Unity压缩纹理的方式。
- en: Managing texture compression on mobile devices is essential, though technically,
    textures are often compressed on other platforms too. But you don’t have to pay
    as much attention to compression on other platforms for various reasons—the chief
    one being that the platform is more technologically mature. On mobile devices,
    you need to pay closer attention to texture compression because the devices are
    touchier about this detail.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上管理纹理压缩是至关重要的，尽管从技术上讲，其他平台也经常压缩纹理。但您不必对其他平台的压缩那么关注，原因有很多——最主要的原因是平台在技术上更加成熟。在移动设备上，您需要更加关注纹理压缩，因为设备对这一细节更加敏感。
- en: Unity automatically compresses textures for you. In most development tools,
    you need to compress images yourself, but in Unity, you generally import uncompressed
    images, and then it applies image compression in the import settings for the image
    (see figure 13.6).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Unity会自动为您压缩纹理。在大多数开发工具中，您需要自己压缩图像，但在Unity中，您通常导入未压缩的图像，然后在图像的导入设置中应用图像压缩（见图13.6）。
- en: '![CH13_F06_Hocking3](../Images/CH13_F06_Hocking3.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F06_Hocking3](../Images/CH13_F06_Hocking3.png)'
- en: Figure 13.6 Texture compression settings in the Inspector
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 检查器中的纹理压缩设置
- en: 'The compression settings are different on different platforms, so Unity recompresses
    images when you switch platforms. Initially, the settings are default values,
    and you may need to adjust them for specific images and specific platforms. In
    particular, image compression is trickier on Android. This is mostly due to the
    fragmentation of Android devices: because all iOS devices use pretty much the
    same video hardware, iOS apps can have texture compression optimized for their
    graphics chips (the GPU). Android apps don’t enjoy the same uniformity of hardware,
    so their texture compression has to aim for the lowest common denominator.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩设置在不同平台上有所不同，因此当您切换平台时，Unity会重新压缩图像。最初，设置是默认值，您可能需要根据特定图像和特定平台进行调整。特别是，在Android上对图像压缩更为复杂。这主要是因为Android设备的碎片化：由于所有iOS设备都使用相当相同的视频硬件，iOS应用可以针对其图形芯片（GPU）进行纹理压缩优化。Android应用没有享受相同的硬件一致性，因此它们的纹理压缩必须针对最低的共同点。
- en: To be more specific, all iOS devices use (or rather used to use, and still maintain
    compatibility with) PowerVR GPUs. Thus, iOS apps can use optimized PowerVR Texture
    Compression (PVRTC) on all iOS devices, or even the newer ASTC format that is
    supported on all iPhones since version 6\. Some Android devices also use PowerVR
    chips, but they just as frequently use Adreno chips from Qualcomm, Mali GPUs from
    ARM, or other options. As a result, Android apps generally rely on Ericsson Texture
    Compression (ETC), a more generic compression algorithm supported by all Android
    devices. Unity defaults to ETC2 (the more advanced second version) for textures
    with an alpha channel, since the original ETC compression format doesn’t have
    an alpha channel, but note that older Android devices may not support ETC2.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，所有iOS设备都使用（或者更确切地说，曾经使用，并且仍然与PowerVR GPU保持兼容性）PowerVR GPU。因此，iOS应用可以在所有iOS设备上使用优化的PowerVR纹理压缩（PVRTC），或者甚至使用自iPhone
    6版本以来所有iPhone都支持的较新的ASTC格式。一些Android设备也使用PowerVR芯片，但它们同样频繁地使用来自高通的Adreno芯片、ARM的Mali
    GPU或其他选项。因此，Android应用通常依赖于爱立信纹理压缩（ETC），这是一种所有Android设备都支持的更通用的压缩算法。Unity默认为具有alpha通道的纹理使用ETC2（更先进的第二个版本），因为原始ETC压缩格式没有alpha通道，但请注意，较旧的Android设备可能不支持ETC2。
- en: This default works fairly well most of the time, but if you need to adjust compression
    on a texture, adjust the settings shown in figure 13.6\. Click the Android icon
    tab to override the default settings for that platform, and then use the Format
    menu to pick specific compression formats. In particular, you may find that certain
    key images need to be uncompressed; although their file size will be much larger,
    the image quality will be better. As long as you compress the majority of textures
    and choose uncompressed only on a case-by-case basis, the increased file size
    probably won’t be too bad. With that discussion out of the way, the final topic
    for mobile development is developing native plugins.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种默认设置在大多数情况下效果相当不错，但如果您需要调整纹理的压缩，请调整图13.6中显示的设置。点击Android图标标签页以覆盖该平台的默认设置，然后使用格式菜单选择特定的压缩格式。特别是，您可能会发现某些关键图像需要解压缩；尽管它们的文件大小会大得多，但图像质量会更好。只要您压缩大多数纹理，并且仅在特定情况下选择不压缩，增加的文件大小可能不会太糟糕。在讨论了这一点之后，移动开发的最后一个主题是开发本地插件。
- en: 13.3.3 Developing plugins
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 开发插件
- en: Unity has a huge amount of functionality built in, but that functionality is
    mostly limited to features common across all platforms. Taking advantage of platform-specific
    toolkits (such as Play Game Services on Android) often requires add-on plugins
    for Unity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Unity内置了大量的功能，但这些功能主要限于所有平台都通用的功能。利用特定平台的工具包（例如Android上的Play Game Services）通常需要为Unity添加插件。
- en: TIP A variety of premade mobile plugins are available for iOS- and Android-specific
    features; appendix D lists a few places to get mobile plugins. These plugins operate
    in the manner described here, except that the plugin code is already written for
    you.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 在iOS和Android特定功能方面，有多种预制的移动插件可供使用；附录D列出了几个获取移动插件的地方。这些插件以这里描述的方式运行，但插件代码已经为您准备好了。
- en: The process of communicating with mobile plugins is similar to the process of
    communicating with the browser. On the Unity side of things, special commands
    call functions within the plugin. On the plugin’s side, the plugin can use SendMessage()to
    send a message to an object in Unity’s scene. The exact code looks different on
    different platforms, but the general idea is always the same.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与移动插件通信的过程与与浏览器的通信过程类似。在 Unity 的那一侧，特殊的命令调用插件中的函数。在插件那一侧，插件可以使用 SendMessage()
    向 Unity 场景中的对象发送消息。在不同的平台上，具体的代码可能不同，但基本思想始终相同。
- en: WARNING Just as with the initial build process, the process for native development
    on mobile tends to change frequently—not so much the Unity end of the process,
    but the native code part. I’ll cover things at a high level, but you should look
    for up-to-date documentation online.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：就像初始构建过程一样，移动原生开发的过程往往会频繁变化——不是过程的一端，而是原生代码部分。我会从高层次上介绍这些内容，但你应该在网上查找最新的文档。
- en: Plugins for both platforms are put in the same place within Unity. If needed,
    create a folder in the Project view called Plugins; then, inside Plugins create
    a folder each for Android and iOS. Once they’re put into Unity, plugin files also
    have settings for the platforms they apply to. Normally, Unity figures this out
    automatically (iOS plugins are set to iOS, Android plugins are set to Android,
    and so on), but if necessary, look for these settings in the Inspector.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 两个平台的插件都在 Unity 中的同一位置。如果需要，在项目视图中创建一个名为 Plugins 的文件夹；然后在 Plugins 中为 Android
    和 iOS 各创建一个文件夹。一旦它们被放入 Unity 中，插件文件也有针对它们应用的平台的设置。通常，Unity 会自动处理这些设置（iOS 插件设置为
    iOS，Android 插件设置为 Android 等），但如果需要，请在检查器中查找这些设置。
- en: iOS plugins
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 插件
- en: The plugin is really just some native code that gets called by Unity. First,
    create a script in Unity to handle the native code; call this script TestPlugin
    (see the next listing).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 插件实际上只是被 Unity 调用的原生代码。首先，在 Unity 中创建一个脚本以处理原生代码；将这个脚本命名为 TestPlugin（参见下一列表）。
- en: Listing 13.5 TestPlugin script that calls iOS native code from Unity
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.5 调用 iOS 原生代码的 TestPlugin 脚本
- en: '[PRE5]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The object is created in this static function, so you don’t have to create
    it in the editor.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对象是在这个静态函数中创建的，因此你不必在编辑器中创建它。
- en: ❷ Tag that identifies section of code; the tag doesn’t do anything by itself.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标识代码段落的标签；标签本身并不做任何事情。
- en: ❸ Refer to the function in the iOS code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 参考iOS代码中的函数。
- en: ❹ Call this if the platform is IPhonePlayer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果平台是 IPhonePlayer，则调用此函数。
- en: First, note that the static Initialize() function creates a permanent object
    in the scene so that you don’t have to do it manually in the editor. You haven’t
    previously seen code to create an object from scratch because using a prefab is
    a lot simpler in most cases, but in this case, it’s cleaner to create the object
    in code (so that you can use the plugin script without editing the scene).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意静态 Initialize() 函数在场景中创建了一个永久对象，这样你就不必在编辑器中手动创建它。你之前没有看到过从头创建对象的代码，因为使用预制体在大多数情况下要简单得多，但在这个例子中，在代码中创建对象更干净（这样你就可以使用插件脚本而无需编辑场景）。
- en: The main wizardry going on here involves the DllImport and static extern commands.
    Those commands tell Unity to link up to functions in the native code you provide.
    Then you can use those referenced functions in this script’s methods (with a check
    to make sure the code is running on iPhone/iOS).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里进行的主要魔法涉及 DllImport 和 static extern 命令。这些命令告诉 Unity 连接到你提供的原生代码中的函数。然后你可以在这段脚本的函数中使用这些引用的函数（同时检查代码是否在
    iPhone/iOS 上运行）。
- en: Next, you’ll use these plugin functions to test them. Create a new script called
    MobileTestObject, create an empty object in the scene, and then attach the script
    to the object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用这些插件函数来测试它们。创建一个新的脚本名为 MobileTestObject，在场景中创建一个空对象，然后将脚本附加到该对象上。
- en: Listing 13.6 Using the plugin from MobileTestObject
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 从 MobileTestObject 使用插件
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Initialize the plugin at the beginning.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在开始时初始化插件。
- en: ❷ Respond to touch input.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 响应触摸输入。
- en: ❸ Display a message in the corner of the screen.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在屏幕角落显示一条消息。
- en: The script in this listing initializes the plugin object and then calls plugin
    methods in response to touch input. Once this is running on the device, you’ll
    see the test message in the corner change whenever you tap the screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的脚本初始化插件对象，然后根据触摸输入调用插件方法。一旦在设备上运行，你会在屏幕角落看到测试信息在每次点击屏幕时改变。
- en: The final thing left to do is to write the native code that TestPlugin references.
    Code on iOS devices is written using Objective C and/or C (or Swift, but we won’t
    be using that language), so you need both a .h header file and a .mm implementation
    file. As described earlier, they need to go in the Plugins/iOS/ folder in the
    Project view. Create TestPlugin.h and TestPlugin.mm there; in the .h file, write
    this code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是编写TestPlugin引用的原生代码。iOS设备上的代码使用Objective C和/或C（或Swift，但我们不会使用该语言），因此你需要一个.h头文件和一个.mm实现文件。如前所述，它们需要放在项目视图中的Plugins/iOS/文件夹中。在TestPlugin.h和TestPlugin.mm中创建它们；在.h文件中，编写此代码。
- en: Listing 13.7 TestPlugin.h header for iOS code
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.7 iOS代码的TestPlugin.h头文件
- en: '[PRE7]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Look for an explanation about iOS programming to understand what this header
    is doing; explaining iOS programming is beyond the scope of this book. Write the
    code from this listing in the .mm file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找关于iOS编程的解释来了解这个头文件的作用；解释iOS编程超出了本书的范围。将此列表中的代码写入.mm文件。
- en: Listing 13.8 TestPlugin.mm implementation
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.8 TestPlugin.mm实现
- en: '[PRE8]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, a detailed explanation of this code is a bit beyond this book’s scope.
    Note that many of the string functions are there to convert Unity’s representation
    of string data into the native code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，对这个代码的详细解释略超出了本书的范围。注意，许多字符串函数都是为了将Unity对字符串数据的表示转换为原生代码。
- en: TIP This sample communicates in only one direction, from Unity to the plugin.
    But the native code could also communicate to Unity by using the UnitySendMessage()
    method. You can send a message to a named object in the scene; during initialization,
    the plugin created TestPlugin_instance to send messages to.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 本示例仅在一个方向上进行通信，即从Unity到插件。但原生代码也可以通过使用UnitySendMessage()方法与Unity进行通信。你可以向场景中的命名对象发送消息；在初始化过程中，插件创建了TestPlugin_instance以发送消息。
- en: With the native code in place, you can build the iOS app and test it on a device.
    The message in the corner will initially be all lowercase; then tap the screen
    to watch the numbers displayed. Very cool!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生代码就绪后，你可以构建iOS应用并在设备上进行测试。角落的消息最初将全部为小写；然后点击屏幕，观察显示的数字。非常酷！
- en: For more information, visit [https://docs.unity3d.com/Manual/PluginsForIOS.html](https://docs.unity3d.com/Manual/PluginsForIOS.html).
    That’s how to make an iOS plugin, so let’s look at Android too.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问[https://docs.unity3d.com/Manual/PluginsForIOS.html](https://docs.unity3d.com/Manual/PluginsForIOS.html)。这是创建iOS插件的方法，那么让我们也看看Android。
- en: Android plugins
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Android插件
- en: To create an Android plugin, the Unity side of things is almost exactly the
    same. You don’t need to change MobileTestObject at all. Make the additions shown
    here in TestPlugin.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Android插件，Unity方面的操作几乎完全相同。你根本不需要修改MobileTestObject。在TestPlugin中添加这里显示的添加项。
- en: Listing 13.9 Modifying TestPlugin to use the Android plugin
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.9 修改TestPlugin以使用Android插件
- en: '[PRE9]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ AndroidJNI functionality provided by Unity
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Unity提供的AndroidJNI功能
- en: ❷ Name of the class you programmed; change this name as needed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你编写的类的名称；根据需要更改此名称。
- en: ❸ Unity creates an activity for the Android app.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Unity为Android应用创建一个Activity。
- en: ❹ Call to functions in plugin .jar
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用.plugin中的函数
- en: You’ll notice that most of the additions happen inside UNITY_ANDROID platform
    defines. As explained earlier in the chapter, these compiler directives cause
    code to apply only to certain platforms and are omitted on other platforms. Whereas
    the iOS code wasn’t doing anything that would break on other platforms (it won’t
    do anything, but it won’t cause errors, either), the code for Android plugins
    will compile only when Unity is set to the Android platform.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到大部分添加都是在UNITY_ANDROID平台定义内部发生的。正如本章前面所解释的，这些编译器指令使得代码仅适用于某些平台，在其他平台上被省略。而iOS代码没有做任何会在其他平台上出错的事情（它不会做任何事情，但也不会引起错误），Android插件的代码只有在Unity设置为Android平台时才会编译。
- en: In particular, note the calls to AndroidJNI. That’s the system within Unity
    for connecting to native Android. The other possibly confusing word that appears
    is Activity; in Android apps, an activity is an app process. The Unity game is
    an activity of the Android app, so the plugin code needs access to that activity
    to pass it around when needed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意对AndroidJNI的调用。这是Unity连接到原生Android的系统。另一个可能令人困惑的词是Activity；在Android应用中，Activity是一个应用进程。Unity游戏是Android应用的一个Activity，因此插件代码需要访问该Activity，以便在需要时传递它。
- en: Finally, you need the native Android code. Whereas iOS code is written in languages
    like Objective C and C, Android is programmed in Java (or Kotlin, but we’ll use
    Java). But you can’t simply provide the raw Java code for the plugin; the plugin
    must be a JAR packaged from the Java code. Here, again, the details of Android
    programming are out of scope for an introduction to Unity, but we’ll go over the
    basics briefly. First off, you should install Android Studio if you didn’t do
    so as part of downloading the Android SDK.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要原生 Android 代码。iOS 代码是用 Objective C 和 C 等语言编写的，而 Android 是用 Java（或 Kotlin，但我们将使用
    Java）编写的。但你不能简单地提供插件的原始 Java 代码；插件必须是从 Java 代码打包的 JAR。在这里，Android 编程的细节超出了 Unity
    介绍的范畴，但我们将简要介绍基础知识。首先，如果你在下载 Android SDK 时没有这样做，你应该安装 Android Studio。
- en: 'Figure 13.7 illustrates the steps to set up a plugin project in Android Studio
    (with screenshots from version 4.2.1):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 展示了在 Android Studio 中设置插件项目的步骤（包含来自版本 4.2.1 的截图）：
- en: Create a New Project by either selecting that in the startup window or going
    to File > New > New Project.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在启动窗口中选择或在文件 > 新建 > 新建项目下进行操作来创建一个新项目。
- en: In the New Project window that appears, select the No Activity template (since
    this is a plugin, not a standalone Android app) and click Next.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的“新建项目”窗口中，选择无活动模板（因为这是一个插件，而不是独立的 Android 应用程序）并点击下一步。
- en: Now name it TestPluginProj; for this test, it doesn’t matter what the Min SDK
    is, but leave Language as Java and take note of the project location because you’ll
    need to find it later. Click Finish to create the new project, and if there is
    a brief wait for loading, then click Finish again to dismiss the window.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将其命名为 TestPluginProj；对于这个测试，最小 SDK 版本不重要，但请记住项目位置，因为稍后你需要找到它。点击完成以创建新项目，如果需要加载，请再次点击完成以关闭窗口。
- en: Once the editor view appears, choose File > New > New Module to add a library.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦出现编辑视图，选择文件 > 新建 > 新模块以添加库。
- en: Select Android Library, name it testplugin, change Package Name to com.testcompany.testplugin,
    and then click Finish.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Android 库，命名为 testplugin，将包名改为 com.testcompany.testplugin，然后点击完成。
- en: With that module added, choose Build > Select Build Variant; in the panel that
    opens, click the Active Build Variant for TestPluginProj.testplugin and select
    Release.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了该模块后，选择构建 > 选择构建变体；在打开的面板中，点击 TestPluginProj.testplugin 的活动构建变体并选择发布。
- en: Now expand testplugin > java in the upper Project panel, right-click com.testcompany.testplugin,
    and choose New > Java Class.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在项目面板的上方展开 testplugin > java，右键单击 com.testcompany.testplugin，并选择新建 > Java
    类。
- en: A tiny window opens to configure the new class, so type the name TestPlugin
    and press Enter.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个小窗口以配置新类，因此输入名称 TestPlugin 并按 Enter。
- en: '![CH13_F07_Hocking3](../Images/CH13_F07_Hocking3.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F07_Hocking3](../Images/CH13_F07_Hocking3.png)'
- en: Figure 13.7 Setting up Android Studio to build a plugin
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 设置 Android Studio 以构建插件
- en: TestPlugin is currently empty, so write the plugin functions in it. Listing
    13.10 shows the Java code for the plugin.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: TestPlugin 目前为空，所以可以在其中编写插件函数。列表 13.10 展示了插件的 Java 代码。
- en: Listing 13.10 TestPlugin.java that compiles into a JAR
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.10 编译成 JAR 的 TestPlugin.java
- en: '[PRE10]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All right, now you can package this code into a JAR (or rather an Android Archive
    file, which contains the JAR). In the top menu, choose Build > Make Project. Once
    the build is complete, go to the project on your computer and find testplugin-release.aar
    in <*project location*>/testplugin/build/outputs/aar/. Drag the archive file into
    Unity’s Android plugins folder to import it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你可以将此代码打包成一个 JAR（或者更确切地说是一个包含 JAR 的 Android 存档文件）。在顶部菜单中，选择构建 > 生成项目。一旦构建完成，转到你的电脑上的项目，在
    <*项目位置*>/testplugin/build/outputs/aar/ 中找到 testplugin-release.aar。将存档文件拖到 Unity
    的 Android 插件文件夹中导入。
- en: Android’s manifest and resources folder
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的清单和资源文件夹
- en: It wasn’t required for this simple test plugin, but Android plugins often must
    edit the manifest file. All Android apps are controlled by a main configuration
    file called AndroidManifest.xml; Unity creates a basic manifest file if you don’t
    provide one, but you could provide one manually by putting it in Plugins/Android/
    alongside the plugin.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的测试插件来说，这不是必需的，但 Android 插件通常必须编辑清单文件。所有 Android 应用程序都受一个名为 AndroidManifest.xml
    的主要配置文件控制；如果你没有提供，Unity 会创建一个基本的清单文件，但你也可以手动提供一个，将其放在 Plugins/Android/ 与插件一起。
- en: Unity adds a Temp folder to the project while it runs, and Unity puts the generated
    manifest file in there (StagingArea/UnityManifest.xml) when an Android app is
    built. Copy that file to manually edit it; this chapter’s code download includes
    a sample manifest file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在运行时会向项目中添加一个Temp文件夹，当构建Android应用程序时，Unity会将生成的清单文件放在那里（StagingArea/UnityManifest.xml）。将此文件复制出来进行手动编辑；本章的代码下载包括一个示例清单文件。
- en: Similarly, there’s a folder called *res* where you can put resources like custom
    icons. To replace this generated folder with your own resources, you could create
    a res folder in the Android plug-ins folder.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有一个名为*res*的文件夹，你可以将自定义图标等资源放在那里。要用自己的资源替换这个生成的文件夹，你可以在Android插件文件夹中创建一个res文件夹。
- en: With the archive file in Plugins/Android, build the game and install it on a
    device, and the message will change whenever you tap the screen. Also, like the
    iOS plugin, an Android plugin could use UnityPlayer.UnitySendMessage()to communicate
    with the object in the scene. The Java code would need to import Unity’s Android
    Player library, which is contained in the Unity installation folder (again, usually
    C:\Program Files\ Unity\Editor\Data on Windows or /Applications/Unity/Editor on
    Mac) as /PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes/classes.jar.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Plugins/Android的存档文件中构建游戏，并将其安装到设备上，每次你点击屏幕时，消息都会改变。同样，像iOS插件一样，Android插件可以使用UnityPlayer.UnitySendMessage()与场景中的对象通信。Java代码需要导入Unity的Android
    Player库，该库位于Unity安装文件夹中（在Windows上通常是C:\Program Files\ Unity\Editor\Data，在Mac上通常是/Applications/Unity/Editor），路径为/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes/classes.jar。
- en: I know I glossed over a lot in developing Android libraries, but that’s because
    the process is both complicated and changes frequently. If you become advanced
    enough to develop plugins for your Android games, you’re going to have to look
    up documentation on Android’s developer website, as well as refer to Unity’s documentation
    at [http://mng.bz/yJKG](http://mng.bz/yJKG).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我在开发Android库时省略了很多内容，但这是因为这个过程既复杂又经常变化。如果你足够高级，可以开发Android游戏的插件，你将不得不在Android的开发者网站上查找文档，并参考Unity的文档，请参阅[http://mng.bz/yJKG](http://mng.bz/yJKG)。
- en: 13.4 Developing XR (both VR and AR)
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 开发XR（包括VR和AR）
- en: NOTE The initials *XR* stand for *extended reality*, a term that encompasses
    both *virtual reality* (VR) and *augmented reality* (AR). VR refers to immersing
    the user in a completely synthetic environment, while AR refers to adding computer
    graphics to the natural environment, but both fall under the umbrella of technologies
    that mediate the environment surrounding the user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：缩写*XR*代表*扩展现实*，这个术语包括*虚拟现实*（VR）和*增强现实*（AR）。VR指的是将用户完全沉浸在合成环境中，而AR指的是向自然环境添加计算机图形，但两者都属于调节用户周围环境的技术的范畴。
- en: XR is the last “platform” covered in this chapter. “Platform” is in quotes because
    XR isn’t technically considered a separate platform when building the application.
    Instead, XR support comes from plugin packages that can be added to the relevant
    build platforms, such as desktop VR or mobile AR. Let’s go over how this works,
    first for VR and then AR.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: XR是本章最后讨论的“平台”。“平台”这个词加了引号，因为XR在构建应用程序时并不被视为一个独立平台。相反，XR支持来自可以添加到相关构建平台（如桌面VR或移动AR）的插件包。让我们先了解一下这是如何工作的，首先是VR，然后是AR。
- en: 13.4.1 Supporting virtual reality headsets
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 支持虚拟现实头戴式设备
- en: The major VR devices on the market right now are Oculus Quest, HTC VIVE, Valve
    Index, and PlayStation VR. Ignoring PlayStation VR (since this book doesn’t cover
    console development), all the other devices are supported by adding a VR SDK to
    either Unity’s PC build target, or (in the case of Oculus Quest) to Android.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市场上主要的VR设备有Oculus Quest、HTC VIVE、Valve Index和PlayStation VR。忽略PlayStation
    VR（因为这本书不涵盖控制台开发），所有其他设备都是通过添加VR SDK到Unity的PC构建目标，或者（在Oculus Quest的情况下）到Android中支持的。
- en: A variety of such SDKs are available, distributed through Unity’s Package Manager.
    For example, browse the Unity Registry to find options like Oculus XR or Windows
    XR. Meanwhile, another attractive option offered to Unity developers is XR Interaction
    Toolkit, but that package is slightly harder to find. Because that package is
    still not considered complete (mostly incomplete in AR support, though; the VR
    support is pretty solid), it is considered a preview package. Packages designated
    as *preview* aren’t shown by default, but you can adjust the settings of the Package
    Manager window to show preview packages (see figure 13.8).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种这样的SDK可供选择，通过Unity的包管理器进行分发。例如，浏览Unity注册表以找到Oculus XR或Windows XR等选项。同时，Unity开发者还提供了一个有吸引力的选项，即XR交互工具包，但这个包稍微难找一些。因为这个包还不被认为完整（尽管在AR支持方面大部分不完整；VR支持相当稳固），它被视为预览包。默认情况下，标记为*预览*的包不会显示，但你可以通过调整包管理器窗口的设置来显示预览包（见图13.8）。
- en: '![CH13_F08_Hocking3](../Images/CH13_F08_Hocking3.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F08_Hocking3](../Images/CH13_F08_Hocking3.png)'
- en: Figure 13.8 How to see preview packages in Package Manager
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 如何在包管理器中查看预览包
- en: Once an XR package is installed, you must enable it in Project Settings (remember,
    that’s Edit > Project Settings) under XR Plug-in Management (shown in figure 13.9).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 安装XR包后，你必须在项目设置中启用它（记住，那是编辑 > 项目设置）在XR插件管理下（如图13.9所示）。
- en: '![CH13_F09_Hocking3](../Images/CH13_F09_Hocking3.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F09_Hocking3](../Images/CH13_F09_Hocking3.png)'
- en: Figure 13.9 XR Plugin Management in Project Settings
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 在项目设置中管理XR插件
- en: NOTE XR Plug-in Management is *itself* a package, although that should have
    been installed along with whatever other XR package you chose. If those settings
    aren’t appearing, though, you may need to install the package manually.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：XR插件管理*本身*是一个包，尽管它应该与你选择的任何其他XR包一起安装。如果那些设置没有出现，你可能需要手动安装该包。
- en: 'We’re not going to go over code for any specific VR device, because there are
    just too many options to cover. Instead, I encourage you visit the documentation
    for the relevant XR plugin:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍任何特定VR设备的代码，因为可供选择的选择太多。相反，我鼓励你访问相关XR插件的文档：
- en: 'XR Interaction Toolkit: [http://mng.bz/Mv67](http://mng.bz/Mv67)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'XR交互工具包: [http://mng.bz/Mv67](http://mng.bz/Mv67)'
- en: 'Oculus XR: [http://mng.bz/aZjz](http://mng.bz/aZjz)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Oculus XR: [http://mng.bz/aZjz](http://mng.bz/aZjz)'
- en: 'Windows XR: [http://mng.bz/g16l](http://mng.bz/g16l)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows XR: [http://mng.bz/g16l](http://mng.bz/g16l)'
- en: 'OpenXR: [http://mng.bz/ePNz](http://mng.bz/ePNz)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenXR: [http://mng.bz/ePNz](http://mng.bz/ePNz)'
- en: We *are*, however, going to implement a simple example to help explain AR.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将实现一个简单的示例来帮助解释AR。
- en: 13.4.2 AR Foundation for mobile Augmented Reality
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 移动增强现实AR基础库
- en: Unlike VR, augmented reality doesn’t necessarily imply a head-mounted display
    (HMD). It certainly *can* involve an HMD, and Unity supports devices like the
    HoloLens and Magic Leap. However, AR also is provided through mobile phones, what’s
    sometimes referred to as *handheld AR*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与VR不同，增强现实不一定意味着需要头戴式显示器（HMD）。当然，*可以*涉及HMD，Unity支持HoloLens和Magic Leap等设备。然而，AR也可以通过手机实现，有时被称为*手持增强现实*。
- en: Both Apple and Google provide SDKs for handheld AR on iOS and Android, respectively.
    Apple’s SDK is called ARKit, while Google provides ARCore. These libraries are
    specific to those platforms however, so Unity provides a cross-platform wrapper
    called *AR Foundation*. As a developer, it’s important to understand that you
    are working with ARKit or ARCore under the hood, but you code against the API
    of AR Foundation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果和谷歌分别为iOS和Android平台上的手持增强现实提供了SDK。苹果的SDK称为ARKit，而谷歌提供ARCore。然而，这些库是特定于这些平台的，因此Unity提供了一个名为*AR基础库*的跨平台包装器。作为开发者，重要的是要理解你实际上是在ARKit或ARCore的底层工作，但你编写的代码是针对AR基础库的API。
- en: To start with, create a new Unity project. In this new project, go to Package
    Manager and install AR Foundation, along with either ARKit XR or ARCore XR (or
    both!), depending on which mobile platform you are developing for. Then enable
    ARKit or ARCore in XR Plug-in Management (shown back in figure 13.9).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Unity项目。在这个新项目中，进入包管理器并安装AR基础库，同时根据你正在为哪个移动平台开发，安装ARKit XR或ARCore XR（或两者都安装！）。然后，在XR插件管理中启用ARKit或ARCore（如图13.9所示）。
- en: NOTE The face-tracking bit of ARKit has a separate package from the rest of
    ARKit. That’s because Apple will reject submitted apps that have code for face-tracking
    but aren’t actually doing facial AR. Thus, install only the main ARKit XR plug-in
    package if you aren’t doing facial AR, and install both packages if you are.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：ARKit 的面部跟踪部分有一个与 ARKit 其余部分分开的包。这是因为苹果会拒绝提交包含面部跟踪代码但实际并未进行面部 AR 的应用。因此，如果您不进行面部
    AR，请仅安装主要的 ARKit XR 插件包；如果您进行面部 AR，请安装两个包。
- en: ARKit and ARCore have requirements that must be met in the Player settings for
    the iOS and Android platforms (see figure 13.10a and b). On Android, first remove
    Vulkan from the list of Graphics APIs (select Vulkan and then click the minus
    button), then scroll down and change the Minimum API Level to 24\. On iOS, set
    the Minimum iOS Version to 11, make sure Architecture is set to ARM64, turn on
    the Requires ARKit setting, and enter a camera usage description (something like
    Camera required for AR).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit 和 ARCore 在 iOS 和 Android 平台上都有要求，必须在玩家设置中满足（见图 13.10a 和 b）。在 Android 上，首先从图形
    API 列表中移除 Vulkan（选择 Vulkan，然后点击减号按钮），然后向下滚动并将最小 API 级别更改为 24。在 iOS 上，将最小 iOS 版本设置为
    11，确保架构设置为 ARM64，打开需要 ARKit 设置，并输入相机使用描述（例如，用于 AR 的相机）。
- en: '![CH13_F10a_Hocking3](../Images/CH13_F10a_Hocking3.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F10a_Hocking3](../Images/CH13_F10a_Hocking3.png)'
- en: Figure 13.10a Adjust Android settings to support AR
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10a 调整 Android 设置以支持 AR
- en: '![CH13_F10b_Hocking3](../Images/CH13_F10b_Hocking3.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F10b_Hocking3](../Images/CH13_F10b_Hocking3.png)'
- en: Figure 13.10b Adjust iOS settings to support AR
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10b 调整 iOS 设置以支持 AR
- en: 'ARKit requires those iOS settings to function, and ARCore requires those Android
    settings. Having made all the necessary adjustments in Player settings, next set
    up the various objects needed in the scene. As depicted in figure 13.11, the steps
    to take are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit 需要这些 iOS 设置才能运行，ARCore 需要这些 Android 设置。在玩家设置中进行了所有必要的调整后，接下来设置场景中需要的各种对象。如图
    13.11 所示，步骤如下：
- en: From the GameObject menu, choose XR > AR Session.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GameObject 菜单中选择 XR > AR Session。
- en: Choose GameObject > XR > AR Session Origin.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 GameObject > XR > AR Session Origin。
- en: Choose GameObject > XR > AR Default Plane.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 GameObject > XR > AR 默认平面。
- en: Delete Main Camera (since Session Origin includes a camera set up for AR).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除主摄像头（因为会话原点已经包含了一个用于AR的摄像头设置）。
- en: Create an empty GameObject and name it Controllers.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 GameObject 并将其命名为 Controllers。
- en: Next, create a new C# script called PlaneTrackingController, and write listing
    13.11 into it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的 C# 脚本，命名为 PlaneTrackingController，并将列表 13.11 写入其中。
- en: Listing 13.11 PlaneTrackingController script that uses AR Foundation
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.11 使用 AR Foundation 的 PlaneTrackingController 脚本
- en: '[PRE11]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ This should be the plane prefab from XR objects, not just any game object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这应该是来自 XR 对象的平面预制件，而不仅仅是任何游戏对象。
- en: ❷ It would also work to add this component in the editor, but we’ll add it in
    code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 也可以在编辑器中添加此组件，但我们将通过代码添加。
- en: This script adds a component called ARPlaneManager to the session origin and
    then assigns a couple of settings to the plane manager, including which object
    to use for visualizing the detected plane. This component could have been added
    in the editor, but adding it in code affords more flexibility in controlling the
    AR.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本向会话原点添加了一个名为 ARPlaneManager 的组件，并为平面管理器分配了一些设置，包括用于可视化检测到的平面的对象。此组件可以在编辑器中添加，但通过代码添加提供了更多控制
    AR 的灵活性。
- en: Drag this script onto the Controllers object to link it as a component. Now
    (as figure 13.11 shows), drag AR Session Origin and AR Default Plane onto their
    component slots in the Inspector.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本拖到 Controllers 对象上，将其链接为组件。现在（如图 13.11 所示），将 AR Session Origin 和 AR Default
    Plane 拖到检查器中的组件槽位。
- en: '![CH13_F11_Hocking3](../Images/CH13_F11_Hocking3.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F11_Hocking3](../Images/CH13_F11_Hocking3.png)'
- en: Figure 13.11 Setting up objects in the scene for simple AR
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 简单 AR 场景中设置对象
- en: With everything in place, build the mobile app in order to see plane tracking
    functioning. Because PlaneTrackingController uses AR Foundation (rather than either
    ARKit or ARCore directly), the project should work on both iOS and Android. Once
    the app is running on your device, you should see something like figure 13.12
    when moving the camera around.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，构建移动应用以查看平面跟踪功能。由于 PlaneTrackingController 使用 AR Foundation（而不是 ARKit
    或 ARCore），项目应该能在 iOS 和 Android 上运行。一旦应用在您的设备上运行，您应该会在移动摄像头时看到类似于图 13.12 的内容。
- en: '![CH13_F12_Hocking3](../Images/CH13_F12_Hocking3.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F12_Hocking3](../Images/CH13_F12_Hocking3.png)'
- en: Figure 13.12 AR plane detection in action
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 AR 平面检测动作图
- en: Great, planar surfaces are being detected in the environment! However, right
    now nothing is going on other than that the computer detects surfaces. That is,
    nothing is being placed *on* the detected surface. AR Foundation provides several
    useful bits of functionality, not just plane tracking, and another useful feature
    is raycasting against detected AR surfaces. Follow listing 13.12 to add code for
    doing AR raycasting.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，环境中的平面正在被检测到！然而，目前除了计算机检测到表面之外，没有其他动作。也就是说，没有东西被放置在检测到的表面上。AR Foundation
    提供了几个有用的功能，不仅仅是平面跟踪，另一个有用的功能是对检测到的 AR 表面进行射线投射。按照列表 13.12 添加进行 AR 射线投射的代码。
- en: Listing 13.12 Adding raycasting to PlaneTrackingController
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.12 向 PlaneTrackingController 添加射线投射
- en: '[PRE12]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Add the new fields just under the existing manager.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在现有管理器下方添加新字段。
- en: ❷ Create an object to place on detected surfaces.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个要放置在检测到的表面上的对象。
- en: ❸ Call the Raycast method in response to user input.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在用户输入时调用 Raycast 方法。
- en: Deploy the app again onto your mobile device. This time, tap the detected plane,
    and a cube should appear, just like figure 13.13\. In this way, you are placing
    virtual objects around your real environment.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次将应用程序部署到您的移动设备上。这次，点击检测到的平面，应该会出现一个立方体，就像图 13.13 所示。这样，你就可以在你的真实环境中放置虚拟对象。
- en: '![CH13_F13_Hocking3](../Images/CH13_F13_Hocking3.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F13_Hocking3](../Images/CH13_F13_Hocking3.png)'
- en: Figure 13.13 A cube placed on the tracked plane
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 放置在跟踪平面上的立方体
- en: This example touches on only the very basics of AR Foundation. For more in-depth
    uses, refer to Unity’s manual ([http://mng.bz/p9aG](http://mng.bz/p9aG)) as well
    as the sample projects Unity has on GitHub ([http://mng.bz/YwpN](http://mng.bz/YwpN)).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子仅涉及 AR Foundation 的基础知识。对于更深入的使用，请参考 Unity 的手册（[http://mng.bz/p9aG](http://mng.bz/p9aG)）以及
    Unity 在 GitHub 上的示例项目（[http://mng.bz/YwpN](http://mng.bz/YwpN)）。
- en: Unity as a Library
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 作为库
- en: Ordinarily, Unity projects are deployed as self-contained apps, a configuration
    that makes perfect sense for games. However, Unity is increasingly being used
    for non-game XR development, and those users may want to integrate their Unity
    projects with an external app.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Unity 项目作为自包含的应用程序部署，这种配置对于游戏来说非常合理。然而，Unity 越来越多地被用于非游戏 XR 开发，这些用户可能希望将他们的
    Unity 项目与外部应用程序集成。
- en: 'For that reason, Unity now has the ability to deploy projects as a library
    to use in a larger app. The Unity as a Library capability supports both iOS and
    Android, enabling mobile developers to add augmented reality content (powered
    by AR Foundation) to their apps. For more information, follow these links:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Unity 现在能够将项目作为库部署，以便在更大的应用程序中使用。Unity 作为库的功能支持 iOS 和 Android，使移动开发者能够将增强现实内容（由
    AR Foundation 提供）添加到他们的应用程序中。更多信息，请点击以下链接：
- en: '[https://unity.com/features/unity-as-a-library](https://unity.com/features/unity-as-a-library)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unity.com/features/unity-as-a-library](https://unity.com/features/unity-as-a-library)'
- en: '[http://mng.bz/OQnn](https://shortener.manning.com/OQnn)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mng.bz/OQnn](https://shortener.manning.com/OQnn)'
- en: Congratulations, you’ve reached the end!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你已经到达了终点！
- en: Congratulations, you now know the steps for deploying a Unity game on most major
    platforms. The basic build process for all platforms is simple (just a single
    button), but customizing the app on various platforms can get complicated. Now
    you’re ready to get out there and build your own games!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你现在知道了在大多数主要平台上部署 Unity 游戏的步骤。所有平台的基本构建过程都很简单（只需一个按钮），但在各种平台上自定义应用程序可能会变得复杂。现在你准备好出去构建自己的游戏了！
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Unity can build executable applications for a huge variety of platforms, including
    desktop computers, mobile devices, and websites.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 可以为包括桌面计算机、移动设备和网站在内的各种平台构建可执行应用程序。
- en: A host of settings can be applied to builds, including details like the icon
    for the app and the name that appears.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将大量设置应用于构建，包括像应用程序图标和显示名称这样的细节。
- en: Web games can interact with the web page they’re embedded in, allowing for all
    kinds of interesting web apps.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页游戏可以与其嵌入的网页交互，从而允许各种有趣的网页应用程序。
- en: Unity supports custom plugins in order to extend its functionality.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 支持自定义插件以扩展其功能。
