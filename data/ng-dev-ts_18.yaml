- en: Appendix D. RxJS essentials
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录D. RxJS基础知识
- en: '*Synchronous programming* is relatively straightforward in that each line of
    your code is executed after the previous one. If you invoke a function in line
    25 that returns a value, you can use the returned value as an argument for the
    function invoked in line 26.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*同步编程*相对简单，因为你的代码的每一行都是在执行前一行之后。如果你在第25行调用一个返回值的函数，你可以将返回值用作第26行调用的函数的参数。'
- en: '*Asynchronous programming* dramatically increases code complexity. In line
    37, you can invoke an asynchronous function that will return the value sometime
    later. Can you invoke a function in line 38 that uses the value returned by the
    previous function? The short answer is, “It depends.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步编程*极大地增加了代码的复杂性。在第37行，你可以调用一个异步函数，该函数将在稍后返回值。你能否在第38行调用一个使用前一个函数返回值的函数？简短的答案是，“这取决于。”'
- en: This appendix is an introduction to the RxJS 6 library, which can be used with
    any JavaScript-based app. It shines when it comes to writing and composing asynchronous
    code. Because Angular uses the RxJS library internally, we decided to add a primer
    to this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录是RxJS 6库的介绍，该库可以与任何基于JavaScript的应用程序一起使用。它在编写和组合异步代码方面表现出色。因为Angular内部使用RxJS库，所以我们决定在这本书中添加一个入门指南。
- en: The first library of reactive extensions (Rx) was created by Erik Meijer in
    2009\. Rx.NET was meant to be used for apps written with Microsoft .Net technology.
    Then the Rx extensions were ported to multiple languages, and in the JavaScript
    world, RxJS 6 is the current version of this library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个反应式扩展库（Rx）是由Erik Meijer在2009年创建的。Rx.NET旨在用于使用Microsoft .Net技术的应用程序。然后Rx扩展被移植到多种语言中，在JavaScript领域，RxJS
    6是这个库的当前版本。
- en: '|  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though Angular depends on RxJS and can’t function without it, RxJS itself is
    an independent library that can be used in any JavaScript app.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular依赖于RxJS并且没有它无法工作，但RxJS本身是一个独立的库，可以在任何JavaScript应用程序中使用。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s see what being reactive means in programming by considering a simple
    example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个简单的例子来看看编程中的反应式意味着什么：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code adds the values of the variables `a1` and `b1`, and `c1` is equal
    to `6`. Now let’s add a couple of lines to this code, modifying the values of
    `a1` and `b1`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将变量`a1`和`b1`的值相加，`c1`等于`6`。现在让我们给这段代码添加几行，修改`a1`和`b1`的值：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the values of `a1` and `b1` change, `c1` doesn’t react to these changes,
    and its value is still `6`. You can write a function that adds `a1` and `b1` and
    invokes it to get the latest value of `c1`, but this would be an *imperative*
    style of coding, where you dictate when to invoke a function to calculate the
    sum.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当`a1`和`b1`的值发生变化时，`c1`不会对这些变化做出反应，其值仍然是`6`。你可以编写一个函数来添加`a1`和`b1`的值，并调用它以获取`c1`的最新值，但这将是一种*命令式*的编码风格，其中你指定何时调用函数来计算总和。
- en: Wouldn’t it be nice if `c2` were automatically recalculated upon any `a1` or
    `b1` changes? Think of a spreadsheet program like Microsoft Excel, where you could
    put a formula like `=sum(a1, b1)` into the C1 cell, and C1 would react immediately
    upon changes in A1 and B1\. In other words, you don’t need to click any button
    to refresh the value of C1—the data is pushed to this cell.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`c2`能在`a1`或`b1`发生变化时自动重新计算，那岂不是很好？想象一下像Microsoft Excel这样的电子表格程序，你可以在C1单元格中输入一个公式`=sum(a1,
    b1)`，当A1和B1发生变化时，C1会立即做出反应。换句话说，你不需要点击任何按钮来刷新C1的值——数据是推送到这个单元格的。
- en: In the *reactive* style of coding (as opposed to the imperative one), the changes
    in data drive the invocation of your code. Reactive programming is about creating
    responsive, event-driven applications, where an observable event stream is pushed
    to subscribers, who observe and handle the events.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在*反应式*编程风格中（与命令式相对），数据的变化驱动着代码的调用。反应式编程是关于创建响应式、事件驱动的应用程序，其中可观察的事件流被推送到订阅者，他们观察和处理这些事件。
- en: In software engineering, Observer/Observable is a well-known pattern and is
    a good fit in any asynchronous-processing scenario. But reactive programming is
    a lot more than just an implementation of the Observer/Observable pattern. Observable
    streams can be canceled, they can notify about the end of a stream, and the data
    pushed to the subscriber can be transformed on the way from the data producer
    to the subscriber by applying one or more composable operators.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，观察者/可观察对象是一个众所周知的模式，并且非常适合任何异步处理场景。但响应式编程远不止是观察者/可观察模式的实现。可观察流可以被取消，它们可以通知流的结束，并且从数据生产者到订阅者的数据推送过程中可以通过应用一个或多个可组合的算子进行转换。
- en: D.1\. Getting familiar with RxJS terminology
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1\. 熟悉RxJS术语
- en: We want to observe data, which means there’s a data producer—a server sending
    data using HTTP or WebSockets, a UI input field where a user enters some data,
    an accelerometer in a smartphone, and so on. An *observable* is a function (or
    object) that gets the producer data and pushes it to the subscriber(s). An *observer*
    is an object (or function) that knows how to handle data elements pushed by the
    observable, as shown in [figure D.1](#app04fig01).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要观察数据，这意味着存在一个数据生产者——一个使用HTTP或WebSockets发送数据的服务器，一个用户输入数据的UI输入字段，一个智能手机中的加速度计等等。一个*可观察对象*是一个函数（或对象），它获取生产者数据并将其推送到订阅者。一个*观察者*是一个对象（或函数），它知道如何处理可观察对象推送的数据，如图D.1所示。
- en: Figure D.1\. The data flow from observable to observers
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.1\. 从可观察对象到观察者的数据流
- en: '![](Images/dfig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig01_alt.jpg)'
- en: 'The main players of RxJS are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS的主要参与者如下：
- en: '***Observable*—** Data stream that pushes data over time'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可观察对象*—** 随时间推送数据的流'
- en: '***Observer*—** Consumer of an observable stream'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***观察者*—** 可观察流消费者'
- en: '***Subscriber*—** Connects observer with observable'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***订阅者*—** 将观察者与可观察对象连接'
- en: '***Operator*—** Function for en route data transformation'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***算子*—** 数据转换函数'
- en: We’ll introduce each of these players by showing multiple examples of their
    use. For complete coverage, refer to the RxJS documentation available at [http://reactivex.io/rxjs](http://reactivex.io/rxjs).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过展示这些参与者使用的多个示例来介绍每个参与者。要全面了解，请参阅可在[http://reactivex.io/rxjs](http://reactivex.io/rxjs)找到的RxJS文档。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Hot and cold observables**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**热和冷可观察对象**'
- en: 'There are two types of observables: hot and cold. The main difference is that
    a cold observable creates a data producer for each subscriber, whereas a hot observable
    creates a data producer first, and each subscriber gets the data from one producer,
    starting from the moment of subscription.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可观察对象：热和冷。主要区别在于，一个冷可观察对象为每个订阅者创建一个数据生产者，而一个热可观察对象首先创建一个数据生产者，每个订阅者从订阅的那一刻起从该生产者获取数据。
- en: 'Let’s compare watching a movie on Netflix to going into a movie theater. Think
    of yourself as an observer. Anyone who decides to watch *Mission: Impossible*
    on Netflix will get the entire movie, regardless of when they hit the play button.
    Netflix creates a new producer to stream a movie just for you. This is a cold
    observable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较在Netflix上观看电影和去电影院。把自己想象成一个观察者。任何决定在Netflix上观看*碟中谍*的人都会得到整部电影，无论他们何时按下播放按钮。Netflix为你创建一个新的生产者来流式传输电影。这是一个冷可观察对象。
- en: If you go to a movie theater and the showtime is 4 p.m., the producer is created
    at 4 p.m., and the streaming begins. If some people (subscribers) are late to
    the show, they miss the beginning of the movie and can only watch it starting
    from the moment of arrival. This is a hot observable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去电影院，放映时间是下午4点，那么生产者是在下午4点创建的，流式传输开始。如果有些人（订阅者）迟到，他们会错过电影的开始，只能从到达的那一刻开始观看。这是一个热可观察对象。
- en: A cold observable starts producing data when some code invokes a `subscribe()`
    function on it. For example, your app may declare an observable providing a URL
    on the server to get certain products. The request will be made only when you
    subscribe to it. If another script makes the same request to the server, it’ll
    get the same set of data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个冷可观察对象在代码调用其上的`subscribe()`函数时开始产生数据。例如，你的应用程序可能声明一个提供服务器上URL的可观察对象以获取某些产品。请求只有在订阅时才会进行。如果另一个脚本向服务器发出相同的请求，它将获得相同的数据集。
- en: A hot observable produces data even if no subscribers are interested in the
    data. For example, an accelerometer in your smartphone produces data about the
    position of your device, even if no app subscribes to this data. A server can
    produce the latest stock prices even if no user is interested in this stock.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 热可观察者即使在没有订阅者对数据感兴趣的情况下也会产生数据。例如，你的智能手机中的加速度计会产生关于设备位置的数据，即使没有应用程序订阅这些数据。服务器可以产生最新的股票价格，即使没有用户对这种股票感兴趣。
- en: Most of the examples in this appendix are about cold observables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录中的大多数示例都是关于冷可观察者。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: D.2\. Observable, observer, and subscriber
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2\. 可观察者、观察者和订阅者
- en: 'As stated earlier, an observable gets data from a data source (a socket, an
    array, UI events) one element at a time. To be precise, an observable knows how
    to do three things:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可观察者一次从数据源（一个套接字、一个数组、UI 事件）获取一个数据元素。更准确地说，可观察者知道如何做三件事：
- en: Emit the next element to the observer
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向观察者发出下一个元素
- en: Throw an error on the observer
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在观察者上抛出错误
- en: Inform the observer that the stream is over
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知观察者流已结束
- en: 'Accordingly, an observer object provides up to three callbacks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，观察者对象提供了最多三个回调函数：
- en: The function to handle the next element emitted by the observable
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可观察者发出的下一个元素的函数
- en: The function to handle errors thrown by the observable
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可观察者抛出错误的函数
- en: The function to handle the end of a stream
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理流结束的函数
- en: 'The subscriber connects an observable and observer by invoking the `subscribe()`
    method and disconnects them by invoking `unsubscribe()`. A script that subscribes
    to an observable has to provide the observer object that knows what to do with
    the produced elements. Let’s say you create an observable represented by the variable
    `someObservable` and an observer represented by the variable `myObserver`. You
    can subscribe to such an observable as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者通过调用 `subscribe()` 方法将可观察者与观察者连接起来，通过调用 `unsubscribe()` 方法断开连接。订阅可观察者的脚本必须提供知道如何处理产生的元素的观察者对象。假设你创建了一个由变量
    `someObservable` 表示的可观察者和一个由变量 `myObserver` 表示的观察者。你可以按如下方式订阅这样的可观察者：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To cancel the subscription, invoke the `unsubscribe()` method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消订阅，请调用 `unsubscribe()` 方法：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How can an observable communicate with the provided observer? By invoking the
    following functions on the observer object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察者如何与提供的观察者进行通信？通过在观察者对象上调用以下函数：
- en: '`next()`, to push the next data element to the observer'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`，用于将下一个数据元素推送到观察者'
- en: '`error()`, to push the error message to the observer'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error()`，用于将错误信息推送到观察者'
- en: '`complete()`, to send a signal to the observer about the end of a stream'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete()`，向观察者发送关于流结束的信号'
- en: You’ll see an example of using these functions in [section D.5](#app04lev1sec5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 [D.5 节](#app04lev1sec5) 中看到使用这些函数的示例。
- en: D.3\. Creating observables
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3\. 创建可观察者
- en: RxJS offers several ways of creating an observable, depending on the type of
    the data producer—for example, a data producer for a DOM event, a data collection,
    a custom function, a WebSocket, and more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 提供了多种创建可观察者的方式，具体取决于数据生产者的类型——例如，DOM 事件的 数据生产者、数据集合、自定义函数、WebSocket 等。
- en: 'Here are some examples of the API to create an observable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些创建可观察者的 API 示例：
- en: '**`of(1,2,3)`—** Turns the sequence of numbers into an `Observable`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`of(1,2,3)`—** 将数字序列转换为 `Observable`'
- en: '**`Observable.create(myObserver)`—** Returns an `Observable` that can invoke
    methods on `myObserver` that you’ll create and supply as an argument'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Observable.create(myObserver)`—** 返回一个 `Observable`，该 `Observable` 可以调用您创建并作为参数提供的
    `myObserver` 上的方法'
- en: '**`from(myArray)`—** Converts an array represented by the `myArray` variable
    into an `Observable`. You can also use any iterable data collection or a generator
    function as an argument of `from()`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`from(myArray)`—** 将由 `myArray` 变量表示的数组转换为 `Observable`。你还可以使用任何可迭代数据集合或生成函数作为
    `from()` 的参数。'
- en: '**`fromEvent(myInput, ''keyup'')`—** Converts the `keyup` event from an HTML
    element represented by `myInput` into an `Observable`. [Chapter 6](kindle_split_015.xhtml#ch06)
    has an example of using the `fromEvent()` API.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`fromEvent(myInput, ''keyup'')`—** 将由 `myInput` 表示的 HTML 元素的 `keyup` 事件转换为
    `Observable`。[第 6 章](kindle_split_015.xhtml#ch06) 中有一个使用 `fromEvent()` API 的示例。'
- en: '**`interval(1000)`—** Emits a sequential integer (0,1,2,3...) every second'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`interval(1000)`—** 每秒发出一个连续整数（0,1,2,3...）'
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: There’s a proposal for introducing `Observable` into future versions of ECMAScript.
    See [https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个提议要将`Observable`引入ECMAScript的未来版本。见[https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable)。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s create an observable that will emit 1, 2, and 3 and subscribe to this
    observable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个将发出1、2和3的可观察对象，并订阅此可观察对象。
- en: Listing D.1\. Emitting `1,2,3`
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.1\. 发出`1,2,3`
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Handles the value emitted by the observable**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理可观察对象发出的值**'
- en: '***2* Handles the error**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理错误**'
- en: '***3* Handles the stream completion message**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理流完成消息**'
- en: Note that you pass three fat-arrow functions to `subscribe()`. These three functions
    combined are the implementation of your observer. The first function will be invoked
    for each element emitted by the observable. The second function will be invoked
    in case of an error, providing the object representing the error. The third function
    takes no arguments and will be invoked when the observable stream is over. Running
    this code sample will produce the following output on the console:^([[1](#app04fn1)])
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你向`subscribe()`传递了三个胖箭头函数。这三个函数的组合是你的观察者的实现。第一个函数将为可观察对象发出的每个元素调用。第二个函数在发生错误时调用，提供表示错误的对象。第三个函数不接受任何参数，将在可观察对象流结束时调用。运行此代码示例将在控制台产生以下输出：^([[1](#app04fn1)])
- en: ¹
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/MwTz](http://mng.bz/MwTz). Open the console
    view at the bottom to see the output.'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/MwTz](http://mng.bz/MwTz)。打开底部的控制台视图以查看输出。
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In [appendix A](kindle_split_025.xhtml#app01), we discuss using the `Promise`
    object, which can invoke an event handler specified in the `then()` function only
    once. Think of a `subscribe()` method as a replacement of the `then()` invocation
    on a `Promise` object, but the callback for `subscribe()` is invoked not just
    once, but for each emitted value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录A](kindle_split_025.xhtml#app01)中，我们讨论了使用`Promise`对象，该对象只能调用在`then()`函数中指定的事件处理器一次。将`subscribe()`方法视为在`Promise`对象上调用`then()`的替代品，但`subscribe()`的回调不仅调用一次，而是对每个发出的值都调用一次。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: D.4\. Getting familiar with RxJS operators
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4\. 熟悉RxJS算子
- en: As data elements flow from an observable to an observer, you can apply one or
    more *operators*, which are functions that can process each element prior to supplying
    it to the observer. Each operator takes an observable as an input, performs its
    action, and returns a new observable as an output, as seen in [figure D.2](#app04fig02).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据元素从可观察对象流向观察者时，你可以应用一个或多个 *算子*，这些是可以在将元素提供给观察者之前处理每个元素的函数。每个算子接受一个可观察对象作为输入，执行其操作，并返回一个新的可观察对象作为输出，如[图D.2](#app04fig02)所示。
- en: 'Figure D.2\. An operator: observable in, observable out'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.2\. 算子：输入可观察对象，输出可观察对象
- en: '![](Images/dfig02_alt.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig02_alt.jpg)'
- en: Because each operator takes in an observable and creates an observable as its
    output, operators can be chained so that each observable element can go through
    several transformations prior to being handed to the observer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个算子接受一个可观察对象并创建一个可观察对象作为其输出，所以算子可以被链式调用，以便每个可观察对象元素在传递给观察者之前可以经过几个转换。
- en: RxJS offers about 100 various operators, and their documentation may not always
    be easy to understand. On the positive side, the documentation often illustrates
    operators with marble diagrams. You can get familiar with the syntax of marble
    diagrams at [http://mng.bz/2534](http://mng.bz/2534). [Figure D.3](#app04fig03)
    shows how the RxJS manual illustrates the `map` operator with a marble diagram
    (see [http://mng.bz/65G7](http://mng.bz/65G7)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS提供了大约100种不同的算子，它们的文档可能并不总是容易理解。从积极的一面来看，文档经常用宝石图来展示算子。你可以在[http://mng.bz/2534](http://mng.bz/2534)上熟悉宝石图的语法。[图D.3](#app04fig03)显示了RxJS手册如何使用宝石图来展示`map`算子（见[http://mng.bz/65G7](http://mng.bz/65G7)）。
- en: Figure D.3\. The map operator
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.3\. map算子
- en: '![](Images/dfig03_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig03_alt.jpg)'
- en: At the top, a marble diagram shows a horizontal line with shapes representing
    a stream of incoming observable elements. Next, there’s the illustration of what
    a particular operator does. At the bottom, you see another horizontal line depicting
    the outgoing observable stream after the operator has been applied. The vertical
    bar represents the end of the stream. When you look at the diagram, think of time
    as moving from left to right. First, the value 1 was emitted, then time went by,
    2 was emitted, then time went by, 3 was emitted, and then the stream ended.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，一个弹珠图显示了一条水平线，其中形状代表了一串传入的可观察元素流。接下来，展示了特定操作符的作用。在底部，你看到另一条水平线，表示应用操作符后的输出可观察流。垂直线代表流的结束。当你看这个图时，把时间想象成从左到右移动。首先，发出了值1，然后时间过去，发出了值2，然后时间过去，发出了值3，然后流结束。
- en: The `map` operator takes a transforming function as an argument and applies
    it to each incoming element. [Figure D.3](#app04fig03) shows the `map` operator
    that takes a value of each incoming element and multiplies it by 10.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`操作符接受一个转换函数作为参数，并将其应用于每个传入的元素。[图 D.3](#app04fig03) 展示了将每个传入元素的值乘以10的`map`操作符。'
- en: Now let’s get familiar with the marble diagram of the `filter` operator, shown
    in [figure D.4](#app04fig04). The `filter` operator takes a function predicate
    as an argument, which returns `true` if the emitted value meets the criteria,
    and `false` otherwise. Only the values that meet the criteria will make it to
    the subscriber. This particular diagram uses the fat-arrow function that checks
    whether the current element is an odd number. Even numbers won’t make it further
    down the chain to the observer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们熟悉一下`filter`操作符的弹珠图，如图 [D.4](#app04fig04) 所示。`filter`操作符接受一个函数谓词作为参数，如果发出的值满足条件则返回`true`，否则返回`false`。只有满足条件的值才会传递给订阅者。这个特定的图使用了粗箭头函数来检查当前元素是否为奇数。偶数不会进一步传递到链中的观察者。
- en: Figure D.4\. The filter operator
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.4\. filter操作符
- en: '![](Images/dfig04_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/dfig04_alt.jpg)'
- en: Operators are composable, and you can chain them so the item emitted by the
    observable can be processed by a sequence of operators before it reaches the observer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符是可组合的，你可以将它们链起来，以便可观察发出的项在到达观察者之前可以由一系列操作符处理。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Deprecated operator chaining**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**已弃用的操作符链式调用**'
- en: Prior to RxJS 6, you could chain operators using the dot between operators.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS 6之前，你可以使用操作符之间的点来链式调用操作符。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing D.2\. Dot-chainable operators
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.2\. 可链式操作符
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Applies the filter operator**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 应用filter操作符**'
- en: '***2* Dot-chains the map operator**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 点链式调用map操作符**'
- en: Starting with RxJS 6, the only way to chain operators is by using the `pipe()`
    method, passing to it comma-separated operators as arguments. The next section
    introduces *pipeable* operators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从RxJS 6开始，链式调用操作符的唯一方法是通过使用`pipe()`方法，将逗号分隔的操作符作为参数传递。下一节将介绍*可连接*操作符。
- en: D.4.1\. Pipeable operators
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.4.1\. 可连接操作符
- en: '*Pipeable* operators are those that can be chained using the `pipe()` function.
    We’ll talk about dot-chaining operators first to explain why pipeable operators
    were introduced in RxJS.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*可连接*操作符是那些可以使用`pipe()`函数链式调用的操作符。我们将首先讨论点链式操作符，以解释为什么在RxJS中引入了可连接操作符。'
- en: 'If you have RxJS prior to version 6 installed, you can import dot-chaining
    operators from the rxjs/add/operator directory. For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了版本6之前的RxJS，你可以从`rxjs/add/operator`目录导入点链式操作符。例如：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These operators patch the code of the `Observable.prototype` and become a part
    of this object. If you decide later on to remove, say, the `filter` operator from
    the code that handles the observable stream, but you forget to remove the corresponding
    import statement, the code that implements `filter` would remain a part of `Observable.prototype`.
    When bundlers tried to eliminate the unused code (*tree shaking*), they may decide
    to keep the code of the `filter` operator in the `Observable` even though it’s
    not being used in the app.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符修补了`Observable.prototype`的代码，并成为该对象的一部分。如果你后来决定从处理可观察流代码中移除，比如说`filter`操作符，但你忘记了移除相应的导入语句，那么实现`filter`的代码仍然会是`Observable.prototype`的一部分。当打包器尝试消除未使用的代码（*摇树优化*）时，它们可能会决定保留`Observable`中的`filter`操作符代码，即使它没有被应用在应用中。
- en: RxJS 5.5 introduced pipeable operators, pure functions that don’t patch the
    `Observable`. You can import operators using ES6 import syntax (for example, `import
    {map} from 'rxjs/operators'`) and then wrap them into a `pipe()` function that
    takes a variable number of parameters, or chainable operators.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 5.5 引入了可连接的操作符，这是不修改`Observable`的纯函数。您可以使用 ES6 导入语法（例如，`import {map} from
    'rxjs/operators'`）导入操作符，然后将它们包装到一个`pipe()`函数中，该函数接受可变数量的参数，或链式操作符。
- en: The subscriber in [listing D.2](#app04ex02) will receive the same data as the
    one in the sidebar “[Deprecated operator chaining](#app04sb02),” but it’s a better
    version from the tree-shaking perspective, because it uses pipeable operators.
    This listing includes import statements, assuming that RxJS is locally installed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 D.2](#app04ex02)中的订阅者将接收到与侧边栏“[已弃用的操作符链](#app04sb02)”中的相同数据，但这是一个更好的版本，从树摇的角度来看，因为它使用了可连接的操作符。此列表包括导入语句，假设
    RxJS 已本地安装。'
- en: Listing D.3\. Using pipeable operators
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.3\. 使用可连接的操作符
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Imports the from() function**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 from() 函数**'
- en: '***2* Imports pipeable operators from rxjs/operators instead of rxjs/add/operator**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 rxjs/operators 而不是 rxjs/add/operator 导入可连接的操作符**'
- en: '***3* Wraps pipeable operators into the pipe() function**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将可连接的操作符包装到 pipe() 函数中**'
- en: Now if you remove the line `filter` from [listing D.2](#app04ex02), the tree-shaking
    module of the bundlers (such as Webpack 4) can recognize that the imported function
    isn’t used, and the code of the `filter` operator won’t be included in the bundles.^([[2](#app04fn2)])
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您从[列表 D.2](#app04ex02)中删除`filter`行，打包器（如 Webpack 4）的树摇功能可以识别导入的函数没有被使用，并且`filter`操作符的代码将不会包含在包中.^([[2](#app04fn2)])
- en: ²
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/RqO5](http://mng.bz/RqO5).'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/RqO5](http://mng.bz/RqO5)。
- en: 'By default, the `from()` function returns a synchronous observable, but if
    you want an asynchronous one, use a second argument specifying an async scheduler:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`from()`函数返回一个同步的可观察对象，但如果您想要一个异步的，请使用第二个参数指定一个异步调度程序：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Making this change in the preceding code sample will print “This is the last
    line of the script” first and then will emit the beers info. You can read more
    about the scheduler at [http://mng.bz/744Y](http://mng.bz/744Y).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，进行此更改将首先打印“这是脚本的最后一行”，然后才会发出啤酒信息。您可以在[http://mng.bz/744Y](http://mng.bz/744Y)了解更多关于调度程序的信息。
- en: Now we’d like to introduce the `reduce` operator, which allows you to aggregate
    values emitted by an observable. A marble diagram of the `reduce` operator is
    shown in [figure D.5](#app04fig05). This diagram shows an observable that emits
    1, 3, and 5, and the `reduce` operator adds them up, producing the accumulated
    value of 9.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想介绍`reduce`操作符，它允许您聚合由可观察对象发出的值。`reduce`操作符的宝石图显示在[图 D.5](#app04fig05)中。此图显示了一个发出
    1、3 和 5 的可观察对象，`reduce`操作符将它们相加，产生累积值为 9。
- en: Figure D.5\. The reduce operator
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.5\. reduce 操作符
- en: '![](Images/dfig05_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig05_alt.jpg)'
- en: 'The `reduce` operator has two arguments: an accumulator function where we specify
    how to aggregate the values, and the initial (seed) value to be used by the accumulator
    function. [Figure D.5](#app04fig05) shows that 0 was used as an initial value,
    but if we changed it to 10, the accumulated result would be 19.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 操作符有两个参数：一个累加函数，其中我们指定如何聚合值，以及累加函数使用的初始（种子）值。[图 D.5](#app04fig05)
    显示使用了 0 作为初始值，但如果我们将其更改为 10，累积的结果将是 19。'
- en: 'As you see in [figure D.5](#app04fig05), the accumulator function also has
    two arguments:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[图 D.5](#app04fig05)中看到的那样，累加函数也有两个参数：
- en: '`acc` stores the currently accumulated value, which is available for each emitted
    element.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acc` 存储当前累积的值，该值对每个发出的元素都可用。'
- en: '`curr` stores the currently emitted value.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curr` 存储当前发出的值。'
- en: 'The following listing creates an observable from the `beers` array and applies
    two operators to each emitted element: `map` and `reduce`. The `map` operator
    takes a `beer` object and extracts its price, and the `reduce` operator adds the
    prices.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表创建了一个从`beers`数组中生成的可观察对象，并对每个发出的元素应用两个操作符：`map`和`reduce`。`map`操作符从一个`beer`对象中提取其价格，而`reduce`操作符则将这些价格相加。
- en: Listing D.4\. Using the `map` and `reduce` operators
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.4\. 使用 `map` 和 `reduce` 操作符
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Transforms the beer object into its price**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将啤酒对象转换为其价格**'
- en: '***2* Sums the prices**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 计算所有啤酒的总价**'
- en: '***3* Prints the total price of all beers**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印所有啤酒的总价**'
- en: 'Running this script will produce the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将生成以下输出：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this script, we were adding all prices, but we could apply any other calculations
    to the aggregate value, such as to calculate an average or maximum price.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们正在添加所有价格，但我们可以对聚合值应用任何其他计算，例如计算平均值或最大价格。
- en: The `reduce` operator emits the aggregated result when the observable completes.
    In this example, it happened naturally, because we created an observable from
    an array with a finite number of elements. In other scenarios, we’d need to invoke
    the `complete()` method on the observer explicitly; you’ll see how to do that
    in the next section.^([[3](#app04fn3)])
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当可观察对象完成时，`reduce`操作符会发出聚合结果。在这个例子中，这是自然发生的，因为我们从一个有限元素数量的数组创建了一个可观察对象。在其他场景中，我们需要显式调用观察者的`complete()`方法；你将在下一节中看到如何做到这一点.^([[3](#app04fn3)])
- en: ³
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/68fR](http://mng.bz/68fR).'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/68fR](http://mng.bz/68fR)。
- en: Code samples from this section have been turning the array into an observable,
    and magically pushing the array elements to the observer. In the next section,
    we’ll show you how to push elements by invoking the `next()` function on the observer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码示例已经将数组转换成可观察对象，并神奇地将数组元素推送到观察者。在下一节中，我们将向你展示如何通过在观察者上调用`next()`函数来推送元素。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Debugging observables**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试可观察对象**'
- en: The `tap` operator can perform a side effect (for example, log some data) for
    every value emitted by the source observable, but return an observable that’s
    identical to the source. In particular, these operators can be used for debugging
    purposes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`tap`操作符可以对源可观察的每个值执行副作用（例如，记录一些数据），但返回的观察者与源相同。特别是，这些操作符可以用于调试目的。'
- en: 'Say you have a chain of operators and want to see the observable values before
    and after a certain operator is applied. The `tap` operator will allow you to
    log the values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一系列操作符，并想在应用某个操作符前后查看可观察的值。`tap`操作符将允许你记录这些值：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, you print the emitted value before and after the `map` operator
    is applied. The `tap` operator doesn’t change the observable data—it passes it
    through to the next operator or the `subscribe()` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你在`map`操作符应用前后打印了发出的值。`tap`操作符不会改变可观察数据——它将其传递给下一个操作符或`subscribe()`方法。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: D.5\. Using an observer API
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5\. 使用观察者API
- en: 'An *observer* is an object that implements one or more of these functions:
    `next()`, `error()`, and `complete()`. Let’s use an object literal to illustrate
    an observer, but later in this section, we’ll use a simplified syntax with arrow
    functions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*观察者*是一个实现一个或多个这些函数的对象：`next()`、`error()`和`complete()`。让我们使用一个对象字面量来展示一个观察者，但稍后在本节中，我们将使用箭头函数的简化语法：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can create an observable with the `create` method, passing an argument that
    represents an observer. When an observable gets created, it doesn’t know yet which
    concrete object will be provided. That’ll be known later, at the time of subscription:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`create`方法创建一个可观察对象，传递一个表示观察者的参数。当可观察对象被创建时，它还不知道将提供哪个具体对象。这将在订阅时才知道：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This particular observable thinks “When someone subscribes to my beers, they’ll
    provide me with a concrete beer consumer, and I’ll push one beer object to this
    guy.” At the time of subscription, we’ll provide a concrete observer to our observable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的观察者认为“当有人订阅我的啤酒时，他们会提供一个具体的啤酒消费者，而我将向这个人推送一个啤酒对象。”在订阅时，我们将一个具体的观察者提供给我们的可观察对象：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The observer will get the beer and will print on the console something like
    this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者将获得啤酒，并在控制台打印类似以下内容：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next listing has a complete script that illustrates creation of the observer,
    the observable, and the subscription. The `getObservableBeer()` function creates
    and returns an observable that will loop through the array of beers and push each
    beer to the observer by invoking `next()`. After that, our observable will invoke
    `complete()` on the observer, indicating that there won’t be any more beers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表有一个完整的脚本，展示了创建观察者、可观察对象和订阅的过程。`getObservableBeer()`函数创建并返回一个可观察对象，该对象将遍历啤酒数组，并通过调用`next()`将每个啤酒对象推送到观察者。之后，我们的可观察对象将在观察者上调用`complete()`，表示不会有更多的啤酒。
- en: Listing D.5\. Using `Observable.create()`
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.5\. 使用`Observable.create()`
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Creates and returns the observable object**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建并返回可观察对象**'
- en: '***2* Pushes each beer to the observer**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将每个啤酒推送到观察者**'
- en: '***3* Pushes the end of the stream message to the observer**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将流结束消息推送到观察者**'
- en: '***4* Subscribes to the observable, providing the observer object in the form
    of three fat-arrow functions**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 订阅到可观察对象，以三个胖箭头函数的形式提供观察者对象**'
- en: The output of this script is shown next:^([[4](#app04fn4)])
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本输出的结果如下：^([[4](#app04fn4)])
- en: ⁴
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/Q7sb](http://mng.bz/Q7sb).'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/Q7sb](http://mng.bz/Q7sb).
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In our code sample, we were invoking `next()` and `complete()` on the observer.
    But keep in mind that an observable is just a data pusher, and there’s always
    a data producer (the array of beers, in our case) that may generate an error.
    In that case, we’d invoke `observer.error()`, and the stream would complete. There’s
    a way to intercept an error on the subscriber’s side to keep the streaming alive,
    discussed in [section D.9](#app04lev1sec9).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们在观察者上调用 `next()` 和 `complete()`。但请记住，可观察对象只是一个数据推送者，总有一个数据生产者（在我们的例子中是啤酒数组）可能会生成错误。在这种情况下，我们会调用
    `observer.error()`，并且流会完成。有一种方法可以在订阅者端拦截错误以保持流的状态，这在 [D.9 节](#app04lev1sec9) 中讨论。
- en: 'It’s important to note that our data producer (the array of beers) is created
    inside the `getObservableBeer()` observable, which makes it a cold observable.
    A WebSocket could be another example of the producer. Imagine we have a database
    of beers on the server, and we can request them over a WebSocket connection (we
    could use HTTP or any other protocol here):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们的数据生产者（啤酒数组）是在 `getObservableBeer()` 可观察对象内部创建的，这使得它成为一个冷可观察对象。WebSocket
    可以是另一个生产者的例子。想象一下，我们在服务器上有一个啤酒数据库，并且可以通过 WebSocket 连接请求它们（我们在这里可以使用 HTTP 或任何其他协议）：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With cold observables, each subscriber will get the same beers, regardless of
    the time of subscription, if the query criteria (in our case, show all beers)
    are the same.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于冷可观察对象，如果查询条件（在我们的例子中，显示所有啤酒）相同，每个订阅者将获得相同的啤酒，无论订阅的时间如何。
- en: D.6\. Using RxJS Subject
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.6\. 使用 RxJS Subject
- en: An RxJS `Subject` is an object that contains an observable and the observer(s).
    This means you can push the data to its observer(s) using `next()`, as well as
    subscribe to it. A `Subject` can have multiple observers, which makes it useful
    when you need to implement for *multicasting*—emitting a value to multiple subscribers,
    as shown in [figure D.6](#app04fig06).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS `Subject` 是一个包含可观察对象和观察者（s）的对象。这意味着你可以使用 `next()` 向其观察者（s）推送数据，也可以订阅它。`Subject`
    可以有多个观察者，这使得它在需要实现 *多播* 时很有用——向多个订阅者发送值，如图 D.6 所示。
- en: Figure D.6\. RxJS `Subject`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.6\. RxJS `Subject`
- en: '![](Images/dfig06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig06.jpg)'
- en: 'Say you have an instance of a `Subject` and two subscribers. If you push a
    value to the subject, each subscriber will receive it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `Subject` 的实例和两个订阅者。如果你向主题推送一个值，每个订阅者都会收到它：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The following example has one `Subject` with two subscribers. The first value
    is emitted to both subscribers, and then one of them unsubscribes. The second
    value is emitted to one active subscriber.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例有一个 `Subject` 和两个订阅者。第一个值被发送到两个订阅者，然后其中一个取消订阅。第二个值被发送到一个活跃的订阅者。
- en: Listing D.6\. One subject and two subscribers
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.6\. 一个主题和两个订阅者
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Creates the first subscriber**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建第一个订阅者**'
- en: '***2* Creates the second subscriber**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建第二个订阅者**'
- en: '***3* Pushes the value 123 to subscribers (we have two of them)**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向订阅者推送值 123（我们有两个订阅者）**'
- en: '***4* Unsubscribes the second subscriber**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 取消第二个订阅者的订阅**'
- en: '***5* Pushes the value 567 to subscribers (we have just one now)**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 向订阅者推送值 567（现在我们只有一个订阅者）**'
- en: Running this script produces the following output on the console:^([[5](#app04fn5)])
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本在控制台产生以下输出：^([[5](#app04fn5)])
- en: ⁵
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/jx16](http://mng.bz/jx16).'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/jx16](http://mng.bz/jx16).
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: There’s a naming convention to end the names of variables of type `Observable`
    or `Subject` with a dollar sign.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个命名约定，即以美元符号结束 `Observable` 或 `Subject` 类型的变量名。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now let’s consider a more practical example. A financial firm has traders who
    can place orders to buy or sell stocks. Whenever the trader places an order, it
    has to be given to two scripts (subscribers):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个更实际的例子。一家金融公司有交易员可以下单买卖股票。每当交易员下单时，它必须交给两个脚本（订阅者）：
- en: The script that knows how to place orders with a stock exchange
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何向证券交易所下订单的脚本
- en: The script that knows how to report each order to a trade commission that keeps
    track of all trading activities
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何向跟踪所有交易活动的交易委员会报告每个订单的脚本
- en: The following listing, written in TypeScript, shows how to ensure that both
    subscribers can receive orders as soon as a trader places them. We create an instance
    of `Subject` called `orders`, and whenever we invoke `next()` on it, both subscribers
    will receive the order.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单，用 TypeScript 编写，展示了如何确保当交易者放置订单时，两个订阅者都能立即收到订单。我们创建了一个名为 `orders` 的 `Subject`
    实例，并且每次我们调用它的 `next()` 方法时，两个订阅者都会收到订单。
- en: Listing D.7\. Broadcasting trade orders
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.7\. 广播交易订单
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Uses enums to declare which actions are allowed for orders**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用枚举声明允许订单执行的操作**'
- en: '***2* A class representing an order**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 代表订单的类**'
- en: '***3* A subject instance that works only with Order objects**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 仅与订单对象一起工作的主题实例**'
- en: '***4* A class representing a trader**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 代表交易者的类**'
- en: '***5* When an order is placed, pushes it to subscribers**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当订单被放置时，将其推送到订阅者**'
- en: '***6* A stock exchange subscriber**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 股票交易所订阅者**'
- en: '***7* A trade commission subscriber**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 交易佣金订阅者**'
- en: '***8* Places the first order**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 放置第一订单**'
- en: '***9* Places the second order**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 放置第二订单**'
- en: Running [listing D.6](#app04ex06) produces the following output:^([[6](#app04fn6)])
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [清单 D.6](#app04ex06) 产生以下输出:^([[6](#app04fn6)])
- en: ⁶
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/4PIH](http://mng.bz/4PIH).'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/4PIH](http://mng.bz/4PIH)。
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In [listing D.6](#app04ex06), we use TypeScript enums that allow us to define
    a limited number of constants. Placing the actions to buy or sell inside an `enum`
    provides additional type checking to ensure that our script uses only the allowed
    actions. If we used string constants like `"SELL"` or `"BUY"`, the developer could
    misspell a word (`"BYE"`) while creating an order. By declaring `enum Action`,
    we restrict possible actions to `Action.Buy` or `Action.Sell`. Trying to use `Action.Bye`
    results in a compilation error.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 D.6](#app04ex06) 中，我们使用了 TypeScript 枚举，这允许我们定义有限数量的常量。将买卖操作放在 `enum` 中提供了额外的类型检查，以确保我们的脚本只使用允许的操作。如果我们使用像
    `"SELL"` 或 `"BUY"` 这样的字符串常量，开发者在创建订单时可能会拼写错误（`"BYE"`）。通过声明 `enum Action`，我们限制可能的行为为
    `Action.Buy` 或 `Action.Sell`。尝试使用 `Action.Bye` 将导致编译错误。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: We wrote [listing D.6](#app04ex06) in TypeScript, but if you want to see its
    JavaScript version, run `npm install` and the `tsc` commands in the project that
    comes with this appendix. The original code is located in the subject-trader.ts
    file, and the compiled version is in subject-trader.js.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 TypeScript 编写了 [清单 D.6](#app04ex06)，但如果您想看到它的 JavaScript 版本，请在包含此附录的项目中运行
    `npm install` 和 `tsc` 命令。原始代码位于 subject-trader.ts 文件中，编译版本位于 subject-trader.js
    中。
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Chapter 6](kindle_split_015.xhtml#ch06) contains an example of using a `BehaviorSubject`—a
    special flavor of `Subject` that always emits its last or initial value to new
    subscribers.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](kindle_split_015.xhtml#ch06) 包含了一个使用 `BehaviorSubject` 的示例——这是 `Subject`
    的一个特殊版本，它总是将其最后或初始值发送给新订阅者。'
- en: D.7\. The flatMap operator
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.7\. `flatMap` 操作符
- en: In some cases, you need to treat each item emitted by an observable as another
    observable. The outer observable emits the inner observables. Does that mean you
    need to write nested `subscribe()` calls (one for the outer observable and another
    for the inner one)? No, you don’t. The `flatMap` operator autosubscribes to each
    item from the outer observable.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您需要将可观察对象发出的每个项视为另一个可观察对象。外部可观察对象发出内部可观察对象。这意味着您需要编写嵌套的 `subscribe()`
    调用（一个用于外部可观察对象，另一个用于内部可观察对象）吗？不，您不需要。`flatMap` 操作符会自动订阅外部可观察对象的每个项。
- en: Some operators are not explained well in RxJS documentation, and we recommend
    you refer to the general ReactiveX (reactive extensions) documentation for clarification.
    The `flatMap` operator is better explained at [http://mng.bz/7RQB](http://mng.bz/7RQB),
    which states that `flatMap` is used to “transform the items emitted by an observable
    into observables, then flatten the emissions from those into a single observable.”
    This documentation includes the marble diagram shown in [figure D.7](#app04fig07).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作符在 RxJS 文档中解释得不够好，我们建议您参考通用 ReactiveX (reactive extensions) 文档以获得澄清。`flatMap`
    操作符在 [http://mng.bz/7RQB](http://mng.bz/7RQB) 上有更好的解释，该文档指出 `flatMap` 用于“将可观察对象发出的项转换为可观察对象，然后将这些可观察对象的输出扁平化为单个可观察对象。”
    该文档包括图 D.7 中所示的宝石图。
- en: Figure D.7\. The `flatMap` operator
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.7\. `flatMap` 操作符
- en: '![](Images/dfig07_alt.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig07_alt.jpg)'
- en: As you see, the `flatMap` operator takes an emitted item from the outer observable
    (the circle) and unwraps its content (the inner observable of diamonds) into the
    flattened output observable stream. The `flatMap` operator merges the emissions
    of the inner observables, so their items may interleave.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`flatMap` 操作符从外部可观察对象（圆圈）中取出一个发出的项目，并将其内容（菱形内部的可观察对象）展开到扁平化的输出可观察对象流中。`flatMap`
    操作符合并内部可观察对象的发出，因此它们的项可能交错。
- en: '[Listing D.8](#app04ex08) has an observable that emits drinks, but this time
    it emits not individual drinks, but palettes. The first palette has beers, and
    the second, soft drinks. Each palette is an observable. We want to turn these
    two palettes into an output stream with individual beverages.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 D.8](#app04ex08) 有一个发出饮料的可观察对象，但这次它发出的是盘而不是单个饮料。第一个盘装的是啤酒，第二个是软饮料。每个盘都是一个可观察对象。我们希望将这些两个盘转换为包含单个饮料的输出流。'
- en: Listing D.8\. Unwrapping nested observables with `flatMap`
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.8\. 使用 `flatMap` 展开嵌套可观察对象
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Creates an async observable from beers**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从啤酒创建一个异步可观察对象**'
- en: '***2* Creates an async observable from soft drinks**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从软饮料创建一个异步可观察对象**'
- en: '***3* Emits the beers observable with next()**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 next() 发出啤酒可观察对象**'
- en: '***4* Emits the soft drinks observable with next()**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 next() 发出软饮料可观察对象**'
- en: '***5* Unloads drinks from pallets into a merged observable**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将饮料盘中的饮料卸载到合并的可观察对象中**'
- en: '***6* Subscribes to the merged observable**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 订阅到合并的可观察对象**'
- en: This script will produce output that may look as follows:^([[7](#app04fn7)])
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将产生如下所示的输出：^([[7](#app04fn7)])
- en: ⁷
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/F38l](http://mng.bz/F38l).'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/F38l](http://mng.bz/F38l)。
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Are there any other uses of the `flatMap` operator besides unloading palettes
    of drinks? Another scenario where you’d want to use `flatMap` is when you need
    to execute more than one HTTP request, in which the result of the first request
    should be given to the second one, as shown in the following listing. In Angular,
    HTTP requests return observables, and without `flatMap()`, this could be done
    (it a bad style) with nested `subscribe` calls.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了卸载饮料盘之外，`flatMap` 操作符还有其他用途吗？另一个您可能想要使用 `flatMap` 的场景是当您需要执行多个 HTTP 请求时，第一个请求的结果应该传递给第二个请求，如下面的列表所示。在
    Angular 中，HTTP 请求返回可观察对象，如果没有 `flatMap()`，这可以通过嵌套的 `subscribe` 调用来完成（这是一种不好的风格）。
- en: Listing D.9\. Subscribing to an HTTP request in Angular
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.9\. 在 Angular 中订阅 HTTP 请求
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `HttpClient.get()` method returns an `Observable`, and the better way to
    write the preceding code is by using the `flatMap` operator, which autosubscribes,
    unwraps the content of the first observable, and makes another HTTP request:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient.get()` 方法返回一个 `Observable`，更好的编写前面代码的方式是使用 `flatMap` 操作符，它会自动订阅，展开第一个可观察对象的内容，并执行另一个
    HTTP 请求：'
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because a `flatMap` is a special case of `map`, you can specify a transforming
    function while flattening observables into a common stream. In the preceding example,
    we transform the value `customer` into a function call `HttpClient.get()`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `flatMap` 是 `map` 的一个特例，您可以在将可观察对象扁平化到公共流时指定一个转换函数。在前面的例子中，我们将值 `customer`
    转换为一个函数调用 `HttpClient.get()`。
- en: 'Let’s consider one more example of using `flatMap`. This one is a modified
    version of the subject-trader example used earlier. This example is written in
    TypeScript, and it uses two `Subject` instances:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑使用 `flatMap` 的另一个例子。这是一个之前使用的主题-交易员示例的修改版本。这个例子是用 TypeScript 编写的，并使用了两个
    `Subject` 实例：
- en: '**`traders$`—** This `Subject` keeps track of traders.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`traders$`—** 这个 `Subject` 跟踪交易员。'
- en: '**`orders$`—** This `Subject` is declared inside the `Trader` class and keeps
    track of each order placed by a particular trader.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`orders$`—** 这个 `Subject` 在 `Trader` 类内部声明，并跟踪特定交易员放置的每个订单。'
- en: You’re the manager who wants to monitor all orders placed by all traders. Without
    `flatMap`, you’d need to subscribe to `traders$` (the outer observable) and create
    a nested subscription for `orders$` (the inner observable) that each subject has.
    Using `flatMap` allows you to write just one `subscribe()` call, which will be
    receiving the inner observables from each trader in one stream, as shown in the
    following listing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您是想要监控所有交易员下单的经理。没有 `flatMap`，您需要订阅 `traders$`（外部可观察对象）并为每个主题创建一个嵌套的 `orders$`（内部可观察对象）订阅。使用
    `flatMap` 允许您只写一个 `subscribe()` 调用，该调用将接收每个交易员的一个流中的内部可观察对象，如下面的列表所示。
- en: Listing D.10\. Two subjects and `flatMap`
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.10\. 两个主题和 `flatMap`
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Uses TypeScript enums to define action types**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 TypeScript 枚举来定义动作类型**'
- en: '***2* Declares the Subject for traders**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明交易者的 `Subject`**'
- en: '***3* Each trader has its own Subject for orders.**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个交易者都有自己的订单 `Subject`。**'
- en: '***4* Starts with the outer observable traders$**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从外部可观察对象 `traders$` 开始**'
- en: '***5* Extracts the inner observable from each Trader instance**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从每个交易者实例中提取内部可观察对象**'
- en: '***6* The function subscribe() receives a stream of orders.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 函数 `subscribe()` 接收一个订单流。**'
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The enum containing string constants defines the action types. You can read
    about TypeScript enums at [http://mng.bz/sTmp](http://mng.bz/sTmp).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 包含字符串常量的枚举定义了动作类型。您可以在 [http://mng.bz/sTmp](http://mng.bz/sTmp) 了解 TypeScript
    枚举。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this version of the program, the `Trader` class doesn’t have a `placeOrder()`
    method. We just have the trader’s `orders$` observable push the order to its observer
    by using the `next()` method. Remember, a `Subject` has both an observable and
    an observer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序版本中，`Trader` 类没有 `placeOrder()` 方法。我们只有通过 `orders$` 可观察对象使用 `next()` 方法将订单推送到其观察者。记住，`Subject`
    既有可观察对象也有观察者。
- en: 'The output of this program is shown next:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个展示的是这个程序的输出：
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our example, the subscriber prints the orders on the console, but in a real-world
    app, it could invoke another function that would place an order with the stock
    exchange for execution.^([[8](#app04fn8)])
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，订阅者将在控制台打印订单，但在现实世界的应用程序中，它可能调用另一个函数，该函数将订单提交给证券交易所执行。[8](#app04fn8)]
- en: ⁸
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/4qC3](http://mng.bz/4qC3).'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/4qC3](http://mng.bz/4qC3)。
- en: D.8\. The switchMap operator
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.8\. `switchMap` 操作符
- en: Whereas `flatMap` unwraps and merges *all the data* from the outer observable
    values, the `switchMap` operator handles the data from the outer observable but
    cancels the inner subscription being processed if the outer observable emits a
    new value. The `switchMap` operator is easier to explain with the help of its
    marble diagram, shown in [figure D.8](#app04fig08).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `flatMap` 会展开并合并外部可观察对象值中的 *所有数据*，而 `switchMap` 操作符处理外部可观察对象中的数据，如果外部可观察对象发出新值，则会取消正在处理的内部订阅。`switchMap`
    操作符更容易通过其水滴图来解释，如图 D.8 所示。
- en: Figure D.8\. The `switchMap` operator
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.8\. `switchMap` 操作符
- en: '![](Images/dfig08_alt.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig08_alt.jpg)'
- en: For those reading the printed edition of this book, we need to say that the
    circles in the outer observable are red, green, and blue (from left to right).
    The outer observable emits the red circle, and `switchMap` emits the items from
    the inner observable (red diamond and square) into the output stream. The red
    circle was processed without any interruptions because the green circle was emitted
    after the inner observable finished processing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于阅读本书印刷版的人来说，我们需要说明外部可观察对象中的圆圈是红色、绿色和蓝色（从左到右）。外部可观察对象发出红色圆圈，`switchMap` 将内部可观察对象的项目（红色菱形和正方形）发射到输出流中。红色圆圈在内部可观察对象完成处理之后没有中断地被处理，因为绿色圆圈是在内部可观察对象处理完成后发出的。
- en: The situation is different with the green circle. `switchMap` managed to unwrap
    and emit the green diamond, but the blue circle arrived *before* the green square
    was processed. The subscription to the green inner observable was cancelled, and
    the green square was never emitted into the output stream. The `switchMap` operator
    *switched* from processing the green inner observable to the blue one.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 情况与绿色圆圈不同。`switchMap` 成功展开了绿色菱形并发出它，但蓝色圆圈在绿色正方形被处理之前到达。绿色内部可观察对象的订阅被取消，绿色正方形从未被发射到输出流中。`switchMap`
    操作符 *切换* 到处理蓝色内部可观察对象。
- en: '[Listing D.11](#app04ex11) has two observables. The outer observable uses the
    `interval()` function and emits a sequential number every second. With the help
    of the `take` operator, we limit the emission to two values: `0` and `1`. Each
    of these values is given to the `switchMap` operator, and the inner observable
    emits three numbers with an interval of 400 ms.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 D.11](#app04ex11) 包含两个可观察对象。外部可观察对象使用 `interval()` 函数，每秒发出一个连续数字。借助 `take`
    操作符，我们限制其输出为两个值：`0` 和 `1`。这些值分别传递给 `switchMap` 操作符，内部可观察对象以 400 毫秒的间隔发出三个数字。'
- en: Listing D.11\. Two observables and `switchMap`
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 D.11\. 两个可观察对象和 `switchMap`
- en: '[PRE31]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Outer observable**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 外部可观察对象**'
- en: '***2* This take operator will take only the first two items from the stream.**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此 `take` 操作符将仅从流中获取前两个项目。**'
- en: '***3* Inner observable**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 内部可观察对象**'
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of [listing D.10](#app04ex10) is shown next:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个展示的是 [清单 D.10](#app04ex10) 的输出：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that the first inner observable didn’t emit its third value, `2`. Here’s
    the timeline:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个内部可观察对象没有发出其第三个值 `2`。以下是时间线：
- en: '**1**.  The outer observable emits `0` and the inner emits `0` 400 ms later.'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 外部可观察对象发出 `0`，内部在 400 毫秒后发出 `0`。'
- en: '**2**.  800 ms later, the inner observable emits `1`.'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 800 毫秒后，内部可观察对象发出 `1`。'
- en: '**3**.  In 1000 ms, the outer observable emits `1`, and the inner observable
    is unsubscribed.'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 1000 毫秒后，外部可观察对象发出 `1`，内部可观察对象被取消订阅。'
- en: '**4**.  The three inner emissions for the second outer value went uninterrupted
    because it didn’t emit any new values.'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 第二个外部值的三个内部发射没有中断，因为它没有发出任何新的值。'
- en: If you replace `flatMap` with `switchMap`, the inner observable will emit three
    values for each outer value, as shown here:^([[9](#app04fn9)])
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `flatMap` 替换为 `switchMap`，内部可观察对象将为每个外部值发出三个值，如下所示：^([[9](#app04fn9)])
- en: ⁹
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/Y9IA](http://mng.bz/Y9IA).'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/Y9IA](http://mng.bz/Y9IA)。
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The chances are slim that you’ll be writing outer and inner observables emitting
    integers. [Chapter 6](kindle_split_015.xhtml#ch06) explains a very practical use
    of the `switchMap` operator.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会编写发出整数的内外部可观察对象。[第 6 章](kindle_split_015.xhtml#ch06) 解释了 `switchMap` 操作符的一个非常实用的用途。
- en: Just think of a user who types in an input field (the outer observable), and
    HTTP requests are being made (inner observable) on each `keyup` event. The circles
    in [figure D.8](#app04fig08) are the three characters that the user is typing.
    The inner observables are HTTP requests issued for each character. If the user
    entered the third character while the HTTP request for the second one is still
    pending, the inner observable gets cancelled and discarded.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个用户在一个输入字段中输入（外部可观察对象），并且每次 `keyup` 事件都会发起 HTTP 请求（内部可观察对象）。[图 D.8](#app04fig08)
    中的圆圈是用户输入的三个字符。内部可观察对象是为每个字符发出的 HTTP 请求。如果用户在第二个 HTTP 请求尚未完成时输入了第三个字符，内部可观察对象将被取消并丢弃。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `interval()` function is handy if you want to invoke another function periodically
    based on a specified time interval. For example, `interval(1000).subscribe(n =>
    doSomething())` will result in calling the `doSomething()` function every second.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要根据指定的时间间隔定期调用另一个函数，`interval()` 函数很有用。例如，`interval(1000).subscribe(n =>
    doSomething())` 将导致每秒调用一次 `doSomething()` 函数。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: D.9\. Error handling with catchError
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.9\. 使用 `catchError` 处理错误
- en: The Reactive Manifesto (see [www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    declares that a reactive app should be resilient, which means the app should implement
    a procedure to keep it alive in case of a failure. An observable can emit an error
    by invoking the `error()` function on the observer, but when the `error()` method
    is invoked, the stream completes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 《响应式宣言》（见 [www.reactivemanifesto.org](http://www.reactivemanifesto.org)）声明，一个响应式应用应该是弹性的，这意味着应用应该实施一个程序来确保在出现故障时保持其存活。一个可观察对象可以通过在观察者上调用
    `error()` 函数来发出错误，但当调用 `error()` 方法时，流会完成。
- en: 'RxJS offers several operators to intercept and handle an error before it reaches
    the code in the `error()` method on the observer:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 提供了几个操作符来拦截和处理错误，在它到达观察者的 `error()` 方法上的代码之前：
- en: '**`catchError(error)`—** Intercepts an error, and you can implement some business
    logic to handle it'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`catchError(error)`—** 拦截错误，你可以实现一些业务逻辑来处理它'
- en: '**`retry(n)`—** Retries an erroneous operation up to *n* times'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`retry(n)`—** 重试错误操作最多 *n* 次'
- en: '**`retryWhen(fn)`—** Retries an erroneous operation as per the provided function'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`retryWhen(fn)`—** 根据提供的函数重试错误操作'
- en: Next, we’ll show you an example of using the pipeable `catchError` operator.
    Inside the `catchError` operator, you can check the error status and react accordingly.
    [Listing D.12](#app04ex12) shows how to intercept an error and, if the error status
    is 500, switch to a different data producer to get the cached data. If the received
    error status isn’t 500, this code will return an empty observable, and the stream
    of data will complete. In any case, the `error()` method on the observer won’t
    be invoked.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向你展示如何使用可连接的 `catchError` 操作符的例子。在 `catchError` 操作符内部，你可以检查错误状态并相应地做出反应。[列表
    D.12](#app04ex12) 展示了如何拦截错误，如果错误状态是 500，则切换到不同的数据生产者以获取缓存的数据。如果接收到的错误状态不是 500，此代码将返回一个空的观察者，数据流将完成。在任何情况下，观察者的
    `error()` 方法都不会被调用。
- en: Listing D.12\. Intercepting errors with `catchError`
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.12\. 使用 `catchError` 拦截错误
- en: '[PRE35]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Listing D.13](#app04ex13) shows the complete example, where we subscribe to
    the stream of beers from a primary source—`getData()`—which randomly generates
    an error with the status 500\. The `catchError` operator intercepts this error
    and switches to an alternate source: `getCachedData()`.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 D.13](#app04ex13) 展示了完整的示例，其中我们订阅了来自主数据源——`getData()`——的啤酒流，该流随机生成状态为 500
    的错误。`catchError` 操作符拦截此错误并切换到备用源：`getCachedData()`。'
- en: Listing D.13\. Implementing failover with `catchError`
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.13\. 使用 `catchError` 实现故障转移
- en: '[PRE36]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Emits the next beer from the primary data source**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从主数据源发出下一个啤酒**'
- en: '***2* Randomly generates the error with the status 500**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 随机生成状态为 500 的错误**'
- en: '***3* Intercepts the error before it reaches the observer**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在错误到达观察者之前拦截错误**'
- en: '***4* Fails over to the alternative data source**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 转换到备用数据源**'
- en: '***5* Doesn’t handle the non-500 errors; returns an empty observable to complete
    the stream**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 不处理非 500 状态的错误；返回一个空的 observable 以完成流**'
- en: '***6* The alternate data source for failover**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 备用数据源以实现故障转移**'
- en: The output of this program can look as follows:^([[10](#app04fn10)])
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出可能如下所示:^([[10](#app04fn10)])
- en: ^(10)
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/QBye](http://mng.bz/QBye).'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/QBye](http://mng.bz/QBye).
- en: '[PRE37]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
