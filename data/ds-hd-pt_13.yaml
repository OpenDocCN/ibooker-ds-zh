- en: Chapter 11\. Data Leakage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 数据泄露
- en: 'In “Leakage in Data Mining: Formulation, Detection, and Avoidance,” Shachar
    Kaufman et al. (2012) identify data leakage as one of the top 10 most common problems
    in data science. In my experience, it should rank even higher: if you have trained
    enough real-life models, it’s unlikely you haven’t encountered it.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在《数据挖掘中的泄漏：公式化、检测和避免》一书中，沙哈尔·考夫曼等人（2012）将数据泄露识别为数据科学中十大常见问题之一。根据我的经验，它应该排名更高：如果你已经训练了足够多的现实生活模型，那么你几乎不可能没有遇到它。
- en: This chapter is devoted to discussing data leakage, some symptoms, and what
    can be done about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于讨论数据泄露，一些症状以及可采取的措施。
- en: What Is Data Leakage?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是数据泄露？
- en: 'As the name suggests, *data leakage* occurs when some of the data used for
    training a model isn’t available when you deploy your model into production, creating
    subpar predictive performance in the latter stage. This usually happens when you
    train a model:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，*数据泄露*发生在你用于训练模型的一些数据在你将模型部署到生产环境时不可用，从而导致后者阶段的预测性能不佳。这通常发生在你训练一个模型时：
- en: Using data or metadata that won’t be available at the prediction stage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在预测阶段不可用的数据或元数据
- en: That is correlated with the outcome you want to predict
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你想要预测的结果相关
- en: That creates *unrealistically high* test-sample predictive performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会造成*过高*的测试样本预测性能
- en: 'The last item explains why leakage is a source of concern and frustration for
    data scientists: when you train a model, absent any data and model drift, you
    expect that the predictive performance on the test sample will extrapolate to
    the real world once you deploy the model in production. This won’t be the case
    if you have data leakage, and you (your stakeholders and the company) will suffer
    a big disappointment.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条说明了为什么数据泄露对数据科学家是一种担忧和沮丧的源头：当你训练一个模型时，在没有数据和模型漂移的情况下，你期望测试样本上的预测性能能够在你将模型投入生产后外推到真实世界。如果存在数据泄露，情况就不会如此，你（以及你的利益相关者和公司）将遭受重大失望。
- en: Let’s go through several examples to clarify this definition.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个例子来澄清这个定义。
- en: Outcome Is Also a Feature
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果也是一个特征
- en: 'This is a trivial example, but helps as a benchmark for more realistic examples.
    If you train a model like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但有助于作为更现实例子的基准。如果你像这样训练一个模型：
- en: <math alttext="y equals f left-parenthesis y right-parenthesis" display="block"><mrow><mi>y</mi>
    <mo>=</mo> <mi>f</mi> <mo>(</mo> <mi>y</mi> <mo>)</mo></mrow></math>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals f left-parenthesis y right-parenthesis" display="block"><mrow><mi>y</mi>
    <mo>=</mo> <mi>f</mi> <mo>(</mo> <mi>y</mi> <mo>)</mo></mrow></math>
- en: you’ll get perfect performance at the training stage, but needless to say, you
    won’t be able to make a prediction when your model is deployed in production (since
    the outcome is, by definition, not available at the time of prediction).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练阶段，你会得到完美的性能，但不用说，当你的模型部署到生产环境时，你将无法进行预测（因为结果在预测时是不可用的）。
- en: A Function of the Outcome Is Itself a Feature
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果本身就是一个特征
- en: A more realistic example is when one of the features is a function of the outcome.
    Suppose you want to make a prediction of next month’s revenue and, using the <math
    alttext="upper P times upper Q"><mrow><mi>P</mi> <mo>×</mo> <mi>Q</mi></mrow></math>
    decomposition described in [Chapter 2](ch02.html#ch02_decom_metrix), you include
    the unit price ( <math alttext="Revenue slash Sales"><mrow><mtext>Revenue</mtext>
    <mo>/</mo> <mtext>Sales</mtext></mrow></math> ) as a feature. Many times, the
    unit price calculation is done upstream, so you just end up using a table that
    contains prices without really knowing how they are calculated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更为现实的例子是，当一个特征是结果的函数时。假设你想要预测下个月的收入，并且使用在[第2章](ch02.html#ch02_decom_metrix)描述的上P乘以上Q分解包括单位价格（<math
    alttext="Revenue slash Sales"><mrow><mtext>Revenue</mtext> <mo>/</mo> <mtext>Sales</mtext></mrow></math>）作为一个特征。许多时候，单位价格的计算是在上游完成的，因此你最终只是使用一个包含价格的表，而不真正了解它们是如何计算的。
- en: Bad Controls
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不良控制
- en: As described in [Chapter 10](ch10.html#ch10_linreg), it’s good to include features
    that you may think help control for sources of variation, even if you don’t have
    a strong hypothesis for the underlying causal mechanism. This is generally true,
    unless you include *bad controls*, which are themselves outcomes affected by the
    features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第10章](ch10.html#ch10_linreg)所述，最好包括一些你认为有助于控制变异源的特征，即使你对底层因果机制没有强烈的假设。一般来说，这是正确的，除非你包括*不良控制*，这些控制本身受特征影响。
- en: 'Take these data generating processes (DGPs) as an example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以这些数据生成过程（DGPs）为例：
- en: <math alttext="StartLayout 1st Row 1st Column y Subscript t 2nd Column equals
    3rd Column f left-parenthesis bold x Subscript t minus 1 Baseline right-parenthesis
    plus epsilon Subscript t 2nd Row 1st Column z Subscript t 2nd Column equals 3rd
    Column g left-parenthesis y Subscript t Baseline right-parenthesis plus zeta Subscript
    t EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>y</mi>
    <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <msub><mi>𝐱</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ϵ</mi> <mi>t</mi></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mi>z</mi> <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi>g</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ζ</mi> <mi>t</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column y Subscript t 2nd Column equals
    3rd Column f left-parenthesis bold x Subscript t minus 1 Baseline right-parenthesis
    plus epsilon Subscript t 2nd Row 1st Column z Subscript t 2nd Column equals 3rd
    Column g left-parenthesis y Subscript t Baseline right-parenthesis plus zeta Subscript
    t EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>y</mi>
    <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <msub><mi>𝐱</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ϵ</mi> <mi>t</mi></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mi>z</mi> <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi>g</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ζ</mi> <mi>t</mi></msub></mrow></mtd></mtr></mtable></math>
- en: You may think that controlling for *z* when training a model to predict *y*
    can help you clean out some of the effects. Unfortunately, since *z* won’t be
    available at the time of prediction, and is correlated with *y*, you end up with
    a nontrivial example of data leakage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当训练模型预测*y*时，你可能会认为控制*z*可以帮助你清除一些影响。不幸的是，由于在预测时*z*不可用，并且与*y*相关，你最终得到一个数据泄漏的非平凡示例。
- en: Note that leakage here arises both from using information that’s not present
    at the time of prediction *and* from including the bad control. If *z* displays
    enough autocorrelation in time, even if you control for its lagged value ( <math
    alttext="z Subscript t minus 1"><msub><mi>z</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></math>
    ), you will still have unreasonably high predictive performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的泄漏是因为使用了预测时不可用的信息，以及包括了错误的控制。如果*z*在时间上显示足够的自相关性，即使你控制了它的滞后值（<math alttext="z
    Subscript t minus 1"><msub><mi>z</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></math>），你仍然会有不合理高的预测性能。
- en: Mislabeling of a Timestamp
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳的误标
- en: 'Suppose you want to measure the number of monthly active users in a given month.
    A typical query that would produce the desired metric looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想测量给定月份的月活跃用户数。一个典型的查询，将产生所需的指标如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here you have effectively labeled these customers using the beginning-of-month
    timestamp, which for many purposes might make sense. Alternatively, you could’ve
    labeled them using the end-of-period timestamp, which could also be appropriate
    for different use cases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有效地使用了月初时间戳来标记这些客户，对许多目的来说可能是有意义的。或者，你也可以使用周期结束时间戳来标记它们，这在不同的用例中也可能是合适的。
- en: The point is that the labeling choice may create data leakage if you incorrectly
    think that the metric was measured *before* the time suggested by your timestamp
    (so you would, in practice, be using information from the *future* to predict
    the *past*). This is a common problem encountered in practice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，如果你错误地认为指标是在你的时间戳建议的时间之前测量的（因此，在实践中，你会使用*未来*的信息来预测*过去*），那么标签选择可能会导致数据泄漏。这是实践中经常遇到的问题。
- en: Multiple Datasets with Sloppy Time Aggregations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个数据集具有松散的时间聚合
- en: 'Suppose you want to predict customer churn using a model like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用这样的模型来预测客户流失：
- en: <math alttext="Prob left-parenthesis c h u r n Subscript t Baseline right-parenthesis
    equals f left-parenthesis normal upper Delta sales Subscript t minus 1 Superscript
    t Baseline comma num period products Subscript t Baseline right-parenthesis" display="block"><mrow><mtext>Prob</mtext>
    <mrow><mo>(</mo> <mi>c</mi> <mi>h</mi> <mi>u</mi> <mi>r</mi> <msub><mi>n</mi>
    <mi>t</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>Δ</mi>
    <msubsup><mtext>sales</mtext> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow> <mi>t</mi></msubsup>
    <mo>,</mo> <mtext>num.</mtext> <msub><mtext>products</mtext> <mi>t</mi></msub>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Prob left-parenthesis c h u r n Subscript t Baseline right-parenthesis
    equals f left-parenthesis normal upper Delta sales Subscript t minus 1 Superscript
    t Baseline comma num period products Subscript t Baseline right-parenthesis" display="block"><mrow><mtext>Prob</mtext>
    <mrow><mo>(</mo> <mi>c</mi> <mi>h</mi> <mi>u</mi> <mi>r</mi> <msub><mi>n</mi>
    <mi>t</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>Δ</mi>
    <msubsup><mtext>sales</mtext> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow> <mi>t</mi></msubsup>
    <mo>,</mo> <mtext>num.</mtext> <msub><mtext>products</mtext> <mi>t</mi></msub>
    <mo>)</mo></mrow></mrow></math>
- en: 'There are two hypotheses at work here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个假设在起作用：
- en: Customers who have decreased their sales in the previous period are more likely
    to churn (they are effectively signaling their decreased engagement).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前一期中减少销售额的客户更有可能流失（他们实际上正在表明他们的参与度下降）。
- en: Customers with a deeper relationship with the company, as measured by the number
    of other products they are currently using, are less likely to churn.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与公司有更深入关系的客户（通过当前使用的其他产品数量衡量）更不容易流失。
- en: 'One possible cause for leakage occurs when the second feature includes information
    from the future, so that trivially, a customer who is active with one product
    next month *cannot* have churned. This might occur because you end up querying
    your data with something like the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏的一个可能原因是当第二个特征包含来自未来信息时，显然下个月与某一产品活跃的客户*不可能*已经流失。这可能是因为你最终查询数据时使用了如下代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The problem arises because the data scientist was sloppy when filtering the
    dates in each subquery.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在数据科学家在每个子查询中过滤日期时处理得不精细。
- en: Leakage of Other Information
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他信息的泄漏
- en: 'The previous examples dealt with leakage of data, either from the features
    or the outcome itself. In the definition, I also allowed for *metadata* leakage.
    This next example will help clarify what this means. In many ML applications,
    it’s normal to transform your data by standardizing it like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子处理了数据泄漏，要么是来自特征，要么是来自结果本身。在定义中，我还允许*元数据*泄漏。下一个例子将帮助澄清这是什么意思。在许多ML应用中，将数据标准化的方法如下：
- en: <math alttext="y Subscript s t d Baseline equals StartFraction y minus mean
    left-parenthesis y right-parenthesis Over std left-parenthesis y right-parenthesis
    EndFraction" display="block"><mrow><msub><mi>y</mi> <mrow><mi>s</mi><mi>t</mi><mi>d</mi></mrow></msub>
    <mo>=</mo> <mfrac><mrow><mi>y</mi><mo>-</mo><mtext>mean</mtext><mo>(</mo><mi>y</mi><mo>)</mo></mrow>
    <mrow><mtext>std</mtext><mo>(</mo><mi>y</mi><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y Subscript s t d Baseline equals StartFraction y minus mean
    left-parenthesis y right-parenthesis Over std left-parenthesis y right-parenthesis
    EndFraction" display="block"><mrow><msub><mi>y</mi> <mrow><mi>s</mi><mi>t</mi><mi>d</mi></mrow></msub>
    <mo>=</mo> <mfrac><mrow><mi>y</mi><mo>-</mo><mtext>mean</mtext><mo>(</mo><mi>y</mi><mo>)</mo></mrow>
    <mrow><mtext>std</mtext><mo>(</mo><mi>y</mi><mo>)</mo></mrow></mfrac></mrow></math>
- en: Suppose you standardize your *training* sample using the moments from the *complete*
    dataset, which of course includes the *test* sample. There are cases where these
    leaked moments provide extra information that won’t be available in production.
    I’ll provide an example later in this chapter that showcases this type of leakage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用来自*完整*数据集的时刻标准化*训练*样本，当然包括*测试*样本。有些情况下，这些泄漏的时刻提供了额外的信息，这些信息在生产中将不可用。在本章的后面我将提供一个示例，展示这种类型的泄漏。
- en: Detecting Data Leakage
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测数据泄漏
- en: If your model has *unreasonably superior* predictive performance, you should
    suspect that there’s data leakage. Not so long ago, a data scientist from my team
    was presenting the results from a classification model that had an area under
    the curve (AUC) of 1! You may recall that the AUC is bounded between 0 and 1,
    where an <math alttext="AUC equals 1"><mrow><mtext>AUC</mtext> <mo>=</mo> <mn>1</mn></mrow></math>
    means that you have a perfect prediction. This was clearly suspicious, to say
    the least.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模型具有*过于优越的*预测性能，您应怀疑存在数据泄露。不久前，我的团队中的一位数据科学家展示了一个分类模型的结果，其曲线下面积（AUC）为1！您可能还记得，AUC的范围在0到1之间，其中<math
    alttext="AUC equals 1"><mrow><mtext>AUC</mtext> <mo>=</mo> <mn>1</mn></mrow></math>表示完美预测。这显然是非常可疑的，至少可以这么说。
- en: These extreme cases of having a perfect prediction are quite rare. In classification
    settings, I get suspicious whenever I get an AUC > 0.8, but you shouldn’t take
    this as a law written in stone. It’s more of a personal heuristic that I’ve found
    useful and informative with the class of problems I have encountered in my career.^([1](ch11.html#id641))
    In regression settings it’s harder to come up with similar heuristics, since the
    most common performance metric, the mean square error, is bounded from below by
    zero, but it really depends on the scale of your outcome.^([2](ch11.html#id642))
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些完美预测的极端情况非常罕见。在分类设置中，当我获得AUC > 0.8时，我会感到怀疑，但您不应将其视为铁板一块的法律。对于我在职业生涯中遇到的问题类别，我发现这种个人启发式方法非常有用和信息性。^([1](ch11.html#id641))
    在回归设置中，要提出类似的启发法则要困难得多，因为最常见的性能指标，均方误差，从下方受到限制，但它确实取决于您结果的规模。^([2](ch11.html#id642))
- en: Ultimately, the best way to detect leakage is by comparing the real-life performance
    of a productive model with the test sample performance. If the latter is considerably
    larger, and you can rule out model or data drift, then you should look for sources
    of data leakage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，检测泄露的最佳方法是将生产模型的实际性能与测试样本性能进行比较。如果后者显著较大，并且您可以排除模型或数据漂移，则应寻找数据泄露的来源。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use your and your organization’s knowledge of the modeling problem at hand to
    decide what is a suspicious level of superior predictive performance. Many times,
    detecting data leakage only happens when you deploy a model in production and
    get subpar performance relative to that of your test sample.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 利用您和组织对手头建模问题的知识来决定何为异常优越的预测性能水平。许多时候，只有在将模型部署到生产环境并获得低于测试样本的性能时，才能检测到数据泄露。
- en: 'To show the improved performance from data leakage, I ran Monte Carlo (MC)
    simulations for two of the examples described earlier. [Figure 11-1](#ch11_leak_badcontrol)
    shows the impact of including a bad control: I train models with and without data
    leakage, and the plot shows the mean and 90% confidence intervals across MC simulations.
    The mean squared error (MSE) with leakage is around a quarter of when the bad
    control is not included. With [the code in the repo](https://oreil.ly/hi693),
    you can check that when the *bad control* is independent from the outcome, there’s
    no data leakage and the models have the same performance. You can also tweak the
    degree of autocorrelation to check that even a lagged bad control can create leakage.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示由数据泄露带来的性能改善，我对前述两个示例运行了蒙特卡罗（MC）模拟。[图 11-1](#ch11_leak_badcontrol) 显示了包含不良控制的影响：我分别训练了带有和不带数据泄露的模型，并且图中显示了在MC模拟中的均值和90%置信区间。在不良控制独立于结果时，MSE约为不包括不良控制时的四分之一。通过[存储库中的代码](https://oreil.ly/hi693)，您可以检查，即使滞后的不良控制也会造成泄露。
- en: '![bad control leakage](assets/dshp_1101.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![bad control leakage](assets/dshp_1101.png)'
- en: Figure 11-1\. Data leakage with a bad control
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. 不良控制下的数据泄露
- en: In the second example, I’ll show how bad standardization and leaking moments
    can affect the performance. [Figure 11-2](#ch11_leak_scaling) presents mean MSE
    as well as 90% confidence intervals from an MC simulation using the following
    DGP:^([3](ch11.html#id643))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我将展示标准化不良和泄露时刻如何影响性能。[图 11-2](#ch11_leak_scaling) 展示了使用以下 DGP 进行的 MC
    模拟的均方误差（MSE）以及 90% 置信区间：^([3](ch11.html#id643))
- en: <math alttext="StartLayout 1st Row 1st Column x Subscript t 2nd Column tilde
    3rd Column upper A upper R left-parenthesis 1 right-parenthesis with a trend 2nd
    Row 1st Column y Subscript t 2nd Column equals 3rd Column f left-parenthesis x
    Subscript t Baseline right-parenthesis plus epsilon Subscript t EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>x</mi> <mi>t</mi></msub></mtd>
    <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>A</mi> <mi>R</mi> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mtext>with</mtext> <mtext>a</mtext> <mtext>trend</mtext></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mi>y</mi> <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>t</mi></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ϵ</mi> <mi>t</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x Subscript t 2nd Column tilde
    3rd Column upper A upper R left-parenthesis 1 right-parenthesis with a trend 2nd
    Row 1st Column y Subscript t 2nd Column equals 3rd Column f left-parenthesis x
    Subscript t Baseline right-parenthesis plus epsilon Subscript t EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>x</mi> <mi>t</mi></msub></mtd>
    <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>A</mi> <mi>R</mi> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mtext>with</mtext> <mtext>a</mtext> <mtext>trend</mtext></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mi>y</mi> <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>t</mi></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ϵ</mi> <mi>t</mi></msub></mrow></mtd></mtr></mtable></math>
- en: I use the first half of the sample for training purposes and the second half
    to test the model. For the *leakage* condition, I standardize the features and
    outcome using the complete dataset mean and standard deviation; for the *no leakage*
    condition, I use the moments for each corresponding sample (train and test). As
    before, it’s quite manifest how the data leakage artificially improves the performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用样本的前半部分进行训练，后半部分用于测试模型。对于*泄露*条件，我使用完整数据集的均值和标准差对特征和结果进行标准化；对于*无泄露*条件，我使用每个相应样本（训练和测试）的瞬时。正如以前一样，数据泄露如何人为地提高了性能是非常明显的。
- en: '![scaling leakage](assets/dshp_1102.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![scaling leakage](assets/dshp_1102.png)'
- en: Figure 11-2\. Data leakage from incorrect scaling (MSE)
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-2\. 由于不正确的缩放导致的数据泄露（MSE）
- en: What’s the logic behind this type of leakage problem? I decided to include a
    time trend so that the mean and standard deviation from the complete dataset informs
    the algorithm *at training time* that the outcome and feature are increasing,
    thereby providing extra information that won’t be available when the model is
    deployed. Without a trend component the leakage disappears, as you can check with
    [the code in the repo](https://oreil.ly/hi693).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型泄露问题背后的逻辑是什么？我决定加入一个时间趋势，以便在训练时，完整数据集的均值和标准差通知算法结果和特征正在增加，从而提供额外信息，这在模型部署时将不可用。如果没有趋势组件，泄露就会消失，您可以通过[仓库中的代码](https://oreil.ly/hi693)进行检查。
- en: Complete Separation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全分离
- en: Before moving on, I want to discuss the topic of *complete or quasi-complete
    separation*. In classification models, you may have an unusually high AUC because
    of this phenomenon, and this may or may not signal data leakage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想讨论*完全或准完全分离*的话题。在分类模型中，由于这种现象，您可能会得到异常高的AUC值，这可能会或可能不会表明数据泄露。
- en: '*Complete separation* arises in the context of linear classification (think
    logistic regression) when a linear combination of the features perfectly predicts
    the outcome *y*. In cases like these, the minimum loss function (many times, the
    negative of the log likelihood function) doesn’t exist. This typically happens
    when the dataset is small, when you work with imbalanced data, or when you used
    a continuous variable and a threshold to create a categorical outcome *and* include
    the variable as a feature. In the latter case, there is data leakage.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全分离*出现在线性分类的背景下（考虑逻辑回归），当特征的线性组合完美预测结果*y*时。在这种情况下，最小损失函数（许多情况下是对数似然函数的负数）不存在。这通常发生在数据集较小、工作于不平衡数据或者使用连续变量和阈值创建分类结果*并*将变量作为特征时。在后一种情况下，存在数据泄露。'
- en: '*Quasi-complete separation* arises when a linear combination of the features
    perfectly predicts a *subset* of your observations. This is much more common,
    and may happen when you include one or several dummy variables that, when combined,
    create a subset of observations for which there’s a perfect prediction. In this
    case, you may need to check if there’s data leakage or not. For instance, it may
    be that there’s a business rule that says that cross-selling can only be offered
    to customers who live in a given state and if they have a minimum tenure. If you
    include tenure and state dummy variables, you will have quasi-complete separation
    and data leakage.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*准完全分离*是指特征的线性组合完美预测观察结果的*子集*。这种情况更为常见，可能是由于包含一个或多个虚拟变量，这些变量组合在一起会创建一个完美预测的观察子集。在这种情况下，您可能需要检查是否存在数据泄露。例如，可能存在一项业务规则，规定只有居住在特定州且有最低任职期的客户才能提供交叉销售。如果包括了任职期和州的虚拟变量，将会出现准完全分离和数据泄露的情况。'
- en: 'Let’s simulate a case where this happens by using a latent variable approach,
    as described in [Chapter 9](ch09.html#ch09_simulation). The data generating process
    is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用潜变量方法来模拟这种情况，如[第9章](ch09.html#ch09_simulation)所述。数据生成过程如下：
- en: <math alttext="StartLayout 1st Row 1st Column x 1 comma x 2 2nd Column tilde
    3rd Column upper N left-parenthesis 0 comma 1 right-parenthesis 2nd Row 1st Column
    z 2nd Column equals 3rd Column alpha 0 plus alpha 1 x 1 plus alpha 2 x 2 plus
    epsilon 3rd Row 1st Column y 2nd Column equals 3rd Column bold 1 Subscript z greater-than-or-equal-to
    0 4th Row 1st Column x Subscript 3 i 2nd Column equals 3rd Column StartLayout
    Enlarged left-brace 1st Row 1st Column 1 2nd Column Blank 3rd Column for i rand
    period selected from StartSet j colon y Subscript j Baseline equals 1 EndSet with
    probability p 2nd Row 1st Column 0 2nd Column Blank 3rd Column otherwise EndLayout
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd> <mtd><mo>∼</mo></mtd>
    <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>z</mi></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><msub><mi>α</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>α</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>α</mi>
    <mn>2</mn></msub> <msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo> <mi>ϵ</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>y</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><msub><mn
    mathvariant="bold">1</mn> <mrow><mi>z</mi><mo>≥</mo><mn>0</mn></mrow></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mi>x</mi> <mrow><mn>3</mn><mi>i</mi></mrow></msub></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mfenced close="" open="{" separators=""><mtable><mtr><mtd
    columnalign="left"><mn>1</mn></mtd> <mtd><mrow><mtext>for</mtext> <mi>i</mi> <mtext>rand.</mtext>
    <mtext>selected</mtext> <mtext>from</mtext> <mrow><mo>{</mo> <mi>j</mi> <mo>:</mo>
    <msub><mi>y</mi> <mi>j</mi></msub> <mo>=</mo> <mn>1</mn> <mo>}</mo></mrow> <mtext>with</mtext>
    <mtext>probability</mtext> <mi>p</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>0</mn></mtd>
    <mtd><mrow><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mtd></mtr></mtable></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 1 comma x 2 2nd Column tilde
    3rd Column upper N left-parenthesis 0 comma 1 right-parenthesis 2nd Row 1st Column
    z 2nd Column equals 3rd Column alpha 0 plus alpha 1 x 1 plus alpha 2 x 2 plus
    epsilon 3rd Row 1st Column y 2nd Column equals 3rd Column bold 1 Subscript z greater-than-or-equal-to
    0 4th Row 1st Column x Subscript 3 i 2nd Column equals 3rd Column StartLayout
    Enlarged left-brace 1st Row 1st Column 1 2nd Column Blank 3rd Column for i rand
    period selected from StartSet j colon y Subscript j Baseline equals 1 EndSet with
    probability p 2nd Row 1st Column 0 2nd Column Blank 3rd Column otherwise EndLayout
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd> <mtd><mo>∼</mo></mtd>
    <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>z</mi></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><msub><mi>α</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>α</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>α</mi>
    <mn>2</mn></msub> <msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo> <mi>ϵ</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>y</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><msub><mn
    mathvariant="bold">1</mn> <mrow><mi>z</mi><mo>≥</mo><mn>0</mn></mrow></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mi>x</mi> <mrow><mn>3</mn><mi>i</mi></mrow></msub></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mfenced close="" open="{" separators=""><mtable><mtr><mtd
    columnalign="left"><mn>1</mn></mtd> <mtd><mrow><mtext>for</mtext> <mi>i</mi> <mtext>rand.</mtext>
    <mtext>selected</mtext> <mtext>from</mtext> <mrow><mo>{</mo> <mi>j</mi> <mo>:</mo>
    <msub><mi>y</mi> <mi>j</mi></msub> <mo>=</mo> <mn>1</mn> <mo>}</mo></mrow> <mtext>with</mtext>
    <mtext>probability</mtext> <mi>p</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>0</mn></mtd>
    <mtd><mrow><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mtd></mtr></mtable></math>
- en: where <math alttext="bold 1 Subscript z greater-than-or-equal-to 0"><msub><mn
    mathvariant="bold">1</mn> <mrow><mi>z</mi><mo>≥</mo><mn>0</mn></mrow></msub></math>
    is an indicator variable that takes the value 1 when the condition on the subscript
    applies and 0 otherwise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math alttext="bold 1 Subscript z greater-than-or-equal-to 0"><msub><mn mathvariant="bold">1</mn>
    <mrow><mi>z</mi><mo>≥</mo><mn>0</mn></mrow></msub></math>是一个指示变量，当下标条件适用时取值为1，否则为0。
- en: 'The idea is simple: the true DGP is a binomial latent variable model with two
    covariates, but I create a third feature, used at training time, by randomly selecting
    without replacement from the observations with *y[i]* = 1\. This way I can simulate
    different degrees of separation, including the case of complete and no separation
    ( <math alttext="p equals 1"><mrow><mi>p</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    and <math alttext="p equals 0"><mrow><mi>p</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    , respectively). As usual, I train a logistic regression and a gradient boosting
    classifier (GBC) without metaparameter optimization.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 思路很简单：真实的DGP是一个具有两个协变量的二项潜变量模型，但我在训练时创建了第三个特征，通过从*y[i]* = 1的观测中无替换随机选择。这样我可以模拟不同程度的分离，包括完全分离和无分离的情况（
    <math alttext="p equals 1"><mrow><mi>p</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    和 <math alttext="p equals 0"><mrow><mi>p</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    ，分别）。通常，我训练一个逻辑回归和一个梯度提升分类器（GBC），而不进行元参数优化。
- en: I ran an MC simulation, and [Figure 11-3](#ch11_qcs_lift) plots the lift in
    median AUC on the test sample across all experiments, where I benchmark everything
    with respect to the case of no separation. You can see that separation creates
    an increased AUC of up to 10% to 15% relative to the baseline, depending on whether
    I use a logistic regression or GBC.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我进行了一次MC模拟，[图 11-3](#ch11_qcs_lift) 展示了在所有实验中测试样本上的中位数AUC提升，我将所有情况与无分离情况进行了基准测试。您可以看到，相对于基线情况，分离可以使AUC增加10%至15%，具体取决于是否使用逻辑回归或GBC。
- en: '![lift in auc separation](assets/dshp_1103.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![lift in auc separation](assets/dshp_1103.png)'
- en: Figure 11-3\. Lift in AUC for quasi-complete separation
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-3\. 准完全分离的AUC提升
- en: The lesson here is that separation increases the AUC in a classification setting,
    and this may indicate data leakage that needs to be inspected further.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，在分类设置中，分离增加了AUC，这可能表明需要进一步检查的数据泄露。
- en: Windowing Methodology
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口方法
- en: I will now describe a windowing methodology that should help reduce the likelihood
    of data leakage in your model. As described earlier, data leakage can occur for
    many different reasons, so this is in no way a bulletproof technique. Nonetheless,
    I’ve found that it helps you discipline the process of training a model, and reduces
    some of the most obvious risks of leakage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将描述一种窗口方法，可以帮助减少模型中数据泄露的可能性。如前所述，数据泄漏可能出现有许多不同的原因，因此这绝不是一种万无一失的技术。尽管如此，我发现它有助于规范训练模型的过程，并减少一些明显的泄露风险。
- en: 'As a starting point, I separate the learning process into two stages:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点是，我将学习过程分成两个阶段：
- en: Training stage
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 训练阶段
- en: This is the stage where you train a model by dividing your sample into training
    and testing, etc.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将样本分成训练和测试等的阶段。
- en: Scoring stage
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 评分阶段
- en: Once you’ve trained your model and you’ve deployed it in production, you use
    it to score a sample. It can be a one-at-a-time prediction, as in online, real-time
    scoring, or scoring of a larger sample.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您训练好模型并将其部署到生产环境中，您可以用它来对样本进行评分。可以是逐个预测，比如在线实时评分，或者对较大样本进行评分。
- en: It’s easy to forget, but in machine learning (ML), *the scoring stage reigns*.
    It’s so important that I devote [Chapter 12](ch12.html#ch12_productionML) to discuss
    some necessary properties and processes that need to be set up to ensure that
    this stage is at its best. For now, just remember that this stage is where most
    value is created, and since this should be your North Star, it should be granted
    nobility status.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记，在机器学习（ML）中，*评分阶段至关重要*。这么重要以至于我专门在[第12章](ch12.html#ch12_productionML)讨论了需要设置的一些必要属性和流程，以确保该阶段达到最佳状态。现在，只需记住，这个阶段是创造最大价值的地方，因此应被赋予贵族般的地位。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: In ML, the scoring stage takes the leading role, and everything else should
    be set up to maximize the quality and timeliness of the predictions of this stage.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，评分阶段起着主导作用，其他所有事情都应设置为最大化该阶段预测质量和及时性。
- en: '[Figure 11-4](#ch11_windows) shows how the window methodology works. The starting
    point is the scoring stage (downmost timeline). Suppose you want to make a prediction
    at time <math alttext="t Subscript p"><msub><mi>t</mi> <mi>p</mi></msub></math>
    . This time period serves to divide the world into two windows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-4](#ch11_windows) 展示了窗口方法的工作原理。起始点是评分阶段（最底部时间轴）。假设您想在时间 <math alttext="t
    Subscript p"><msub><mi>t</mi> <mi>p</mi></msub></math> 进行预测。这个时间段用来将世界分为两个窗口：'
- en: Prediction window
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 预测窗口
- en: You’re usually interested in predicting an event or a random variable associated
    to an event. For this you need to set up a prediction window for that event to
    occur ( <math alttext="t Subscript p Baseline comma t Subscript p Baseline plus
    upper P"><mrow><msub><mi>t</mi> <mi>p</mi></msub> <mo>,</mo> <msub><mi>t</mi>
    <mi>p</mi></msub> <mo>+</mo> <mi>P</mi></mrow></math> ]. For example, you want
    to predict if a customer will churn *in the next 30 days*. Or you want to predict
    your company’s revenue *during the first quarter of the year*. Or you may want
    to predict if a customer will rate a book or a movie in *the next two weeks after*
    finishing reading or watching it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你对事件或与事件相关的随机变量感兴趣。为此，您需要设置一个预测窗口，以便事件发生（ <math alttext="t Subscript p Baseline
    comma t Subscript p Baseline plus upper P"><mrow><msub><mi>t</mi> <mi>p</mi></msub>
    <mo>,</mo> <msub><mi>t</mi> <mi>p</mi></msub> <mo>+</mo> <mi>P</mi></mrow></math>
    ）。例如，您想预测客户是否会*在接下来的30天内流失*。或者您想预测公司在*年初的第一季度的收入*。或者您可能想预测客户*在阅读或观看书籍或电影后的接下来两周内*会对其进行评分。
- en: Observation window
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 观察窗口
- en: Once you define a time horizon for your prediction to be evaluated, you need
    to define how much history you want to include to inform your prediction [ <math
    alttext="t Subscript p Baseline minus upper O comma t Subscript p Baseline"><mrow><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo> <mi>O</mi> <mo>,</mo> <msub><mi>t</mi> <mi>p</mi></msub></mrow></math>
    ]. The name is derived from the fact that this, and only this, is the information
    we *observe* at scoring time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了评估预测的时间范围，您需要定义要包含多少历史信息以支持您的预测 [ <math alttext="t Subscript p Baseline
    minus upper O comma t Subscript p Baseline"><mrow><msub><mi>t</mi> <mi>p</mi></msub>
    <mo>-</mo> <mi>O</mi> <mo>,</mo> <msub><mi>t</mi> <mi>p</mi></msub></mrow></math>
    ]。其名称源自于这一点，因为这是我们在评分时*观察*到的唯一信息。
- en: 'Note that the prediction window is *open* on the left by design: this helps
    prevent data leakage as it explicitly separates what you observe at the time of
    prediction.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预测窗口在左侧是*开放*的设计：这有助于防止数据泄漏，因为它明确分离了您在预测时所观察到的内容。
- en: '![windowing methodology](assets/dshp_1104.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![窗口方法论](assets/dshp_1104.png)'
- en: Figure 11-4\. Windowing methodology
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-4\. 窗口方法论
- en: Let’s go through an example to ensure that these concepts are clear. I want
    to train a churn model that predicts for each customer the likelihood they will
    churn during the next month. Since the scoring stage reigns, suppose I want to
    score all of the active users *today* ( <math alttext="t Subscript p"><msub><mi>t</mi>
    <mi>p</mi></msub></math> ). By definition, the prediction window starts from tomorrow
    and ends one month from tomorrow. At that point I have to be able to assess whether
    any of the customers churned or not. To make this prediction, I will use the last
    three months of information, so this is my observation window. Any transformations
    of the features are restricted to this timeframe. For instance, I may think that
    the most recent past matters, so I can compute the ratio of weekly interactions
    four weeks ago to last week’s (if the ratio is larger than one, engagement increased
    this last month).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来确保这些概念清楚。我想要训练一个流失模型，预测每个客户在下个月内流失的可能性。由于评分阶段至上，假设我希望*今天*评分所有活跃用户（
    <math alttext="t Subscript p"><msub><mi>t</mi> <mi>p</mi></msub></math> ）。按照定义，预测窗口从明天开始，到明天后一个月结束。在那时，我必须能够评估客户是否有流失。为了进行这种预测，我将使用最近三个月的信息，这是我的观察窗口。任何特征的转换都限制在这个时间范围内。例如，我可能认为最近的过去很重要，因此我可以计算四周前的每周互动与上周的比率（如果比率大于一，则表示上个月的参与度增加）。
- en: Choosing the Length of the Windows
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择窗口长度
- en: You may wonder who chooses the lengths of the observation and prediction windows,
    and what considerations are taken into account. [Table 11-1](#table-11-1) summarizes
    some of the main considerations when deciding the lengths of both windows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道是谁选择观察和预测窗口的长度，并考虑了哪些因素。[表 11-1](#table-11-1) 总结了在确定这两个窗口长度时的一些主要考虑因素。
- en: Table 11-1\. Considerations when choosing window lengths
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1\. 选择窗口长度时的考虑因素
- en: '|  | Prediction (*P*) | Observation (*O*) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  | 预测 (*P*) | 观察 (*O*) |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Owner | Business - data scientist | Data scientist |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 拥有者 | 业务 - 数据科学家 | 数据科学家 |'
- en: '| Predictive performance | Feasibility of short- vs. long-term prediction |
    Relative weight of distant past |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 预测表现 | 短期与长期预测的可行性 | 远期过去的相对权重 |'
- en: '| Data | Historical data at your disposal | Historical data at your disposal
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 您可以使用的历史数据 | 您可以使用的历史数据 |'
- en: The length of the observation window is chosen by the data scientist, primarily
    based on the predictive performance of the model. For instance, is the recent
    past more predictive? The prediction window is primarily chosen by taking into
    account business considerations regarding the timeliness of a decision, and as
    such, it ought to be mostly owned by the business stakeholder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 观察窗口的长度由数据科学家选择，主要基于模型的预测性能。例如，最近的过去更具预测性吗？预测窗口主要是通过考虑业务决策的及时性而选择的，因此它应该主要由业务利益相关者拥有。
- en: It’s important to acknowledge that longer prediction windows are usually less
    risky, in the sense that it’s harder to be wrong (for example, predicting the
    existence of artificial general intelligence in the next one thousand years versus
    the next two years). But really short time horizons may be infeasible given the
    current granularity of your data (for example, predicting if a customer will churn
    in the next 10 minutes when you only have daily data).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，较长的预测窗口通常风险较小，因为更难出错（例如，在接下来的一千年内预测人工智能的存在与在接下来的两年内）。但在当前数据粒度下，真正短的时间视野可能是不可行的（例如，当您只有每日数据时，预测客户在接下来的10分钟内是否会流失）。
- en: Finally, the length of the prediction window affects how long the observation
    window must be. If the CFO asks me to predict revenue over the next five years,
    I can either have short observation windows and dynamic forecasts (where forecasts
    are used successively as features), or I can have a long enough observation window
    to make such a heroic forecast.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，预测窗口的长度会影响观察窗口的必要长度。如果首席财务官要求我预测未来五年的收入，我可以使用较短的观察窗口和动态预测（其中连续使用预测作为特征），或者我可以使用足够长的观察窗口来进行这样的英雄般预测。
- en: The Training Stage Mirrors the Scoring Stage
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练阶段镜像评分阶段
- en: 'Once these windows are defined at the scoring stage, you’re now ready to set
    up and define the training stage. As you might suspect from [Figure 11-4](#ch11_windows),
    the training stage should always mirror what happens in the later scoring stage:
    the observation and prediction windows for the training stage map one-to-one to
    those at the scoring stage, and are thus constrained by them.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些窗口在评分阶段被定义，您现在可以准备设置和定义训练阶段。正如您可能从[图 11-4](#ch11_windows)中推测到的那样，训练阶段应该始终与稍后评分阶段的情况相一致：训练阶段的观察和预测窗口与评分阶段的窗口一一映射，并因此受其约束。
- en: For instance, it’s quite customary that you want to train the model with the
    most recent data at your disposal. Since you’ll need <math alttext="upper P"><mi>P</mi></math>
    time periods to evaluate your prediction and <math alttext="upper O"><mi>O</mi></math>
    periods to create your features, this means that you need to set [ <math alttext="t
    Subscript p Baseline minus upper P minus upper O comma t Subscript p Baseline
    minus upper P"><mrow><msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo> <mi>P</mi>
    <mo>-</mo> <mi>O</mi> <mo>,</mo> <msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo>
    <mi>P</mi></mrow></math> ] as your training observation window, and ( <math alttext="t
    Subscript p Baseline minus upper P comma t Subscript p Baseline"><mrow><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo> <mi>P</mi> <mo>,</mo> <msub><mi>t</mi> <mi>p</mi></msub></mrow></math>
    ] as your training prediction window.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通常情况下，您希望使用手头最新的数据来训练模型。由于您需要<math alttext="upper P"><mi>P</mi></math>个时间段来评估您的预测，以及<math
    alttext="upper O"><mi>O</mi></math>个时间段来创建特征，这意味着您需要将[ <math alttext="t Subscript
    p Baseline minus upper P minus upper O comma t Subscript p Baseline minus upper
    P"><mrow><msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo> <mi>P</mi> <mo>-</mo> <mi>O</mi>
    <mo>,</mo> <msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo> <mi>P</mi></mrow></math>
    ]设为您的训练观察窗口，以及 ( <math alttext="t Subscript p Baseline minus upper P comma t Subscript
    p Baseline"><mrow><msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo> <mi>P</mi> <mo>,</mo>
    <msub><mi>t</mi> <mi>p</mi></msub></mrow></math> ] 作为您的训练预测窗口。
- en: 'Formally defining these windows helps you discipline and constrain what you
    expect to accomplish with the model. On the one hand, it ensures that only historical
    data is used for future predictions, preventing common leakage issues. You can
    see this more directly in the following equations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正式定义这些窗口有助于您约束和限制模型的预期成果。一方面，它确保只使用历史数据进行未来预测，避免常见的泄漏问题。您可以在以下方程中更直接地看到这一点：
- en: <math alttext="StartLayout 1st Row 1st Column Scoring 2nd Column colon 3rd Column
    y Subscript left-parenthesis t Sub Subscript p Subscript comma t Sub Subscript
    p Subscript plus upper P right-bracket Baseline equals f left-parenthesis upper
    X Subscript left-bracket t Sub Subscript p Subscript minus upper O comma t Sub
    Subscript p Subscript right-bracket Baseline right-parenthesis 2nd Row 1st Column
    Training 2nd Column colon 3rd Column y Subscript left-parenthesis t Sub Subscript
    p Subscript minus upper P comma t Sub Subscript p Subscript right-bracket Baseline
    equals f left-parenthesis upper X Subscript left-bracket t Sub Subscript p Subscript
    minus upper P minus upper O comma t Sub Subscript p Subscript minus upper P right-bracket
    Baseline right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mtext>Scoring</mtext></mrow></mtd> <mtd><mo>:</mo></mtd>
    <mtd columnalign="left"><mrow><msub><mi>y</mi> <mrow><mo>(</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>,</mo><msub><mi>t</mi> <mi>p</mi></msub> <mo>+</mo><mi>P</mi><mo>]</mo></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>X</mi> <mrow><mo>[</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo><mi>O</mi><mo>,</mo><msub><mi>t</mi> <mi>p</mi></msub>
    <mo>]</mo></mrow></msub> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mtext>Training</mtext></mrow></mtd>
    <mtd><mo>:</mo></mtd> <mtd columnalign="left"><mrow><msub><mi>y</mi> <mrow><mo>(</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo><mi>P</mi><mo>,</mo><msub><mi>t</mi> <mi>p</mi></msub>
    <mo>]</mo></mrow></msub> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>X</mi>
    <mrow><mo>[</mo><msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo><mi>P</mi><mo>-</mo><mi>O</mi><mo>,</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo><mi>P</mi><mo>]</mo></mrow></msub> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column Scoring 2nd Column colon 3rd Column
    y Subscript left-parenthesis t Sub Subscript p Subscript comma t Sub Subscript
    p Subscript plus upper P right-bracket Baseline equals f left-parenthesis upper
    X Subscript left-bracket t Sub Subscript p Subscript minus upper O comma t Sub
    Subscript p Subscript right-bracket Baseline right-parenthesis 2nd Row 1st Column
    Training 2nd Column colon 3rd Column y Subscript left-parenthesis t Sub Subscript
    p Subscript minus upper P comma t Sub Subscript p Subscript right-bracket Baseline
    equals f left-parenthesis upper X Subscript left-bracket t Sub Subscript p Subscript
    minus upper P minus upper O comma t Sub Subscript p Subscript minus upper P right-bracket
    Baseline right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mtext>Scoring</mtext></mrow></mtd> <mtd><mo>:</mo></mtd>
    <mtd columnalign="left"><mrow><msub><mi>y</mi> <mrow><mo>(</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>,</mo><msub><mi>t</mi> <mi>p</mi></msub> <mo>+</mo><mi>P</mi><mo>]</mo></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>X</mi> <mrow><mo>[</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo><mi>O</mi><mo>,</mo><msub><mi>t</mi> <mi>p</mi></msub>
    <mo>]</mo></mrow></msub> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mtext>Training</mtext></mrow></mtd>
    <mtd><mo>:</mo></mtd> <mtd columnalign="left"><mrow><msub><mi>y</mi> <mrow><mo>(</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo><mi>P</mi><mo>,</mo><msub><mi>t</mi> <mi>p</mi></msub>
    <mo>]</mo></mrow></msub> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>X</mi>
    <mrow><mo>[</mo><msub><mi>t</mi> <mi>p</mi></msub> <mo>-</mo><mi>P</mi><mo>-</mo><mi>O</mi><mo>,</mo><msub><mi>t</mi>
    <mi>p</mi></msub> <mo>-</mo><mi>P</mi><mo>]</mo></mrow></msub> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
- en: Implementing the Windowing Methodology
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施窗口化方法
- en: 'Once you have defined them, you can enforce these on your code with something
    like the following snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了这些窗口，您可以通过以下代码段在代码中加以实施：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Summing up, the window methodology helps you enforce a minimal requirement that
    you can only use the past to predict the future. Other causes of data leakage
    may still be present.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，窗口方法帮助你强制执行一个最小要求，即你只能使用过去来预测未来。数据泄漏的其他原因可能仍然存在。
- en: 'I Have Leakage: Now What?'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我有泄漏现象：现在怎么办？
- en: 'Once you have detected the source of leakage, the solution is to remove it
    and retrain your model. In some cases this is quite obvious, but in others it
    can take substantial time and effort. Here’s a list of things you can attempt
    to identify the source of leakage:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到泄漏源，解决方法是将其删除并重新训练模型。在某些情况下，这很明显，但在其他情况下可能需要大量时间和精力。以下是你可以尝试的一些事项来确定泄漏源：
- en: Check time windows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 检查时间窗口。
- en: Ensure that you’re always using past information to predict the future. This
    can be done by enforcing a strict time windowing process such as the one just
    described.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你始终使用过去的信息来预测未来。这可以通过执行严格的时间窗口处理过程来实现，例如刚刚描述的方法。
- en: Check any data transformations done and enforce best practices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检查已执行的任何数据转换，并实施最佳实践。
- en: A good practice is to use [scikit-learn pipelines](https://oreil.ly/iOEs1) or
    similar to ensure that the transformations are done with the correct datasets
    and that there are no leaking moments or metadata.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是使用[scikit-learn pipelines](https://oreil.ly/iOEs1)或类似工具，以确保转换是使用正确的数据集进行的，并且没有泄漏时刻或元数据。
- en: Ensure that you have thorough knowledge of the business processes behind the
    creation of the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你对数据创建背后的业务流程有深入的了解。
- en: The more you know about the processes behind the creation of your data, the
    easier it is to identify potential sources of leakage or quasi-complete separation
    in the case of classification models.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据创建过程背后的流程了解得越多，就越容易识别潜在的泄漏源或在分类模型的情况下几乎完全分离的情况。
- en: Iteratively remove features.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步删除特征。
- en: On a regular basis you should run a diagnostic check to identify the most predictive
    features (in some algorithms you can do this with [feature importance](https://oreil.ly/uW6PY)).
    Coupled with your knowledge of the business, this should help you identify if
    something looks *off*. You can also try iteratively removing the most important
    features to see if predictive performance changes dramatically in any iteration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定期进行诊断检查，以识别最具预测性的特征（在某些算法中，可以通过[特征重要性](https://oreil.ly/uW6PY)进行此操作）。结合你对业务的了解，这应该有助于确定是否有什么异常。你也可以尝试逐步删除最重要的特征，看看在任何迭代中预测性能是否会显著变化。
- en: Key Takeaways
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键要点
- en: 'These are the key takeaways from this chapter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本章的关键要点：
- en: Why care about data leakage?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要关注数据泄漏？
- en: Data leakage generates subpar predictive performance when the model is deployed
    in production, relative to the performance you would expect from your test sample.
    It creates organizational frustration, and you may even put at risk any stakeholder
    buy-in you may have.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型在生产中部署时，数据泄露会导致预测性能不佳，相对于你在测试样本中期望的表现。它会造成组织上的挫败感，甚至可能危及你可能已经获得的任何利益相关者的支持。
- en: Identifying leakage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 识别泄漏。
- en: A typical symptom of leakage is having *unusually high* predictive performance
    on your test sample. You must rely on your knowledge of the problem and the company’s
    experience with these models. It’s always a good practice to present your results
    to more experienced data scientists, and also discuss them with your business
    stakeholders. If you suspect there’s data leakage, you must start auditing your
    model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏的典型症状是在测试样本上具有*异常高*的预测性能。你必须依靠你对问题的了解以及公司对这些模型的经验。向更有经验的数据科学家展示你的结果并与业务利益相关者讨论总是一个良好的做法。如果你怀疑存在数据泄漏，你必须开始审计你的模型。
- en: Things to check if you suspect you have data leakage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑存在数据泄漏，需要检查的事项。
- en: Check if you have enforced a strict time windowing process that guarantees that
    you always predict the future with the past, and not the other way around. Also,
    check if you have any data transformations where moments or metadata might be
    leaking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否已经执行了严格的时间窗口处理过程，确保你总是用过去来预测未来，而不是反过来。同时，检查是否存在任何可能泄露时刻或元数据的数据转换。
- en: In ML, scoring reigns.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，得分至关重要。
- en: The litmus test for an ML model is its performance in production. You should
    direct all of your time and effort to ensure that this is the case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型的试金石是其在生产中的表现。你应该投入所有时间和精力来确保这一点。
- en: Further Reading
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In my opinion there isn’t much depth in most of the published accounts on data
    leakage found in published books (many mention it just in passing). You can find
    several useful blog posts on the web: for instance, Christopher Hefele’s comment
    on data leakage at the [ICML 2013 Whale Challenge](https://oreil.ly/j7B4l) or
    Prerna Singh’s post [“Data Leakage in Machine Learning: How It Can Be Detected
    and Minimize the Risk”](https://oreil.ly/G92H-).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，大多数关于数据泄露的已发表账户中并没有深入探讨（许多只是顺带提及）。你可以在网络上找到几篇有用的博客文章：例如，Christopher Hefele在[ICML
    2013鲸鱼挑战赛](https://oreil.ly/j7B4l)中对数据泄露的评论，或者Prerna Singh的文章[“机器学习中的数据泄露：如何检测和减少风险”](https://oreil.ly/G92H-)。
- en: 'Kaufman et al., “Leakage in Data Mining: Formulation, Detection, and Avoidance,”
    (*ACM Transactions on Knowledge Discovery from Data* 6 no. 4, 2012), is a must-read
    for anyone interested in understanding leakage. They categorize two types of data
    leakage as those coming from features and those coming from training examples.
    I decided to deviate a bit from this categorization.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kaufman等人的“数据挖掘中的泄露：制定、检测和避免”（《ACM数据挖掘知识发现交易》，2012年第6卷第4期）是任何对理解泄露感兴趣的人必读的。他们将数据泄露分类为来自特征和来自训练样本的两种类型。我决定在这个分类上做些偏离。
- en: On the problem of complete and quasi-complete separation, the classical reference
    is A. Albert and J. A. Anderson, “On the Existence of Maximum Likelihood Estimates
    in Logistic Regression Models” (*Biometrika* 71 no. 1, 1984). A textbook presentation
    can be found in Chapter 11 of Russell Davison and James MacKinnon, *Econometric
    Theory and Methods* (Oxford University Press).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全分离和准完全分离问题上，经典参考文献是A. Albert和J.A. Anderson的“关于逻辑回归模型中最大似然估计的存在性”（《生物统计学》1984年第71卷第1期）。在Russell
    Davison和James MacKinnon的《计量经济学理论与方法》（牛津大学出版社）第11章中可以找到教科书式的阐述。
- en: The problem of bad controls is well known in the literature of causal inference
    and causal machine learning. To the best of my knowledge, it was first labeled
    liked that by Angrist and Pischke in *Mostly Harmless Econometrics* (Princeton
    University Press). A more recent and systematic study can be found in Carlos Cinelli
    et al., “A Crash Course in Good and Bad Controls” (*Sociological Methods and Research*,
    2022). In this, chapter I used a rather loose version of the bad control definition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在因果推断和因果机器学习的文献中，坏控制问题是众所周知的。据我所知，安格里斯特和皮斯克在《大部分无害计量经济学》（普林斯顿大学出版社）中首次将其称为这样。关于更近期和系统的研究，可以参考Carlos
    Cinelli等人的“好控制和坏控制速成课程”（《社会学方法与研究》，2022年）。在这一章节中，我对坏控制的定义使用了一个相对宽松的版本。
- en: ^([1](ch11.html#id641-marker)) Also, remember that the AUC is sensitive to having
    imbalanced outcomes, so my heuristic really must be taken with a grain of salt,
    to say the least.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#id641-marker)) 此外，请记住AUC对于不平衡的结果很敏感，因此我的启发式方法确实必须谨慎对待，至少可以这么说。
- en: ^([2](ch11.html#id642-marker)) An alternative is to use the coefficient of determination
    or *R2* that is also bounded to the unit interval.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#id642-marker)) 另一个选择是使用决定系数或*R2*，它也被限制在单位间隔内。
- en: ^([3](ch11.html#id643-marker)) An *AR(1)* process is a time series with an autoregressive
    component of order 1\. You can check [Chapter 10](ch10.html#ch10_linreg) for more
    information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.html#id643-marker)) *AR(1)*过程是一个具有一阶自回归分量的时间序列。您可以查看[第10章](ch10.html#ch10_linreg)获取更多信息。
