- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Advanced components
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级组件
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: How to handle and optimize change detection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理和优化变更检测
- en: Communication between different components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同组件之间的通信
- en: Ways to style and different ways styles are encapsulated
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式化和样式封装的不同方式
- en: Rendering components dynamically on the fly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态即时渲染组件
- en: Chapter 4 covered many of the basics of components, but there is so much more!
    Here we’ll dive into additional capabilities that will come in handy as you build
    more interesting applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章涵盖了组件的许多基础知识，但还有更多内容！在这里，我们将深入研究在构建更有趣的应用程序时将派上用场的额外功能。
- en: We’ll look at how change detection works in more detail, and look at how to
    use the OnPush capability to reduce the amount of work Angular has to do to improve
    rendering efficiency.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地探讨变更检测的工作原理，并查看如何使用OnPush能力来减少Angular需要执行的工作量以提高渲染效率。
- en: Although components can use inputs and outputs, there are additional ways to
    have components talk to one another. We’ll look at why you might choose to use
    a different approach and how to implement it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件可以使用输入和输出，但还有其他方式让组件相互通信。我们将探讨为什么您可能选择使用不同的方法以及如何实现它。
- en: There are three primary ways to render styles for a component, and choosing
    different modes potentially has a significant impact on the way your components
    are displayed. You may want to internalize the CSS styling as much as possible,
    or you may not want any styling to be internalized, but to use the global CSS
    styles instead.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要方式为组件渲染样式，选择不同的模式可能会对组件的显示方式产生重大影响。您可能希望尽可能内部化CSS样式，或者您可能不想内部化任何样式，而是使用全局CSS样式。
- en: Finally, we’ll look at how to render a component dynamically, and why you might
    want to do that. It’s not very common, but there are moments where it’s useful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何动态渲染组件，以及为什么您可能想要这样做。这并不常见，但在某些时刻它是有用的。
- en: As discussed in chapter 4, I highly recommend that you keep your components
    focused. As we learn more about component capabilities, you’ll see that it’s important
    to avoid overloading your components.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如第4章所述，我强烈建议您保持组件的专注。随着我们更多地了解组件功能，您会发现避免过度加载组件非常重要。
- en: This chapter will continue with the example from chapter 4, so refer to it for
    how to set up the example. Everything will build upon what you learned, so the
    examples will be expanded to demonstrate more advanced capabilities of components.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续使用第4章的示例，因此请参考它以了解如何设置示例。所有内容都将建立在您所学的基础上，因此示例将扩展以展示组件的更多高级功能。
- en: I can say with almost 100% certainty that no component will use every single
    capability, because it would most likely not function. However, mastery of these
    additional concepts will help you write more complex and dynamic applications.
    Let’s start by taking a look at change detection and how to optimize performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以几乎100%的确定性说没有任何组件会使用每一个单独的能力，因为这很可能会使其无法正常工作。然而，掌握这些额外的概念将帮助您编写更复杂和动态的应用程序。让我们先从查看变更检测和如何优化性能开始。
- en: 5.1 Change detection and optimizations
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 变更检测与优化
- en: Angular ships with a change detection framework that determines when components
    need to be rendered if inputs have changed. Components need to react to changes
    made somewhere in the component tree, and the way they change is through inputs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular附带一个变更检测框架，该框架确定当输入发生变化时组件何时需要渲染。组件需要对其组件树中某处所做的更改做出反应，而它们改变的方式是通过输入。
- en: 'Changes are always triggered by some asynchronous activity, such as when a
    user interacts with the page. When these changes occur, there is a chance (though
    no guarantee) that the application state or data has changed. Here are some examples:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 变更总是由某些异步活动触发的，例如当用户与页面交互时。当这些变更发生时，应用程序状态或数据发生变化的机会（尽管没有保证）存在。以下是一些示例：
- en: A user clicks a button to trigger a form submission (user activity).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击按钮以触发表单提交（用户活动）。
- en: An interval fires every *x* seconds to refresh data (intervals or timers).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每隔*x*秒触发一个间隔来刷新数据（间隔或定时器）。
- en: Callbacks, observables, or promises are resolved (XHR requests, event streams).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调、可观察对象或承诺被解决（XHR请求、事件流）。
- en: These are all events or asynchronous handlers, but they may come from different
    sources. We’ll dig deeper into the way that observables and XHR requests behave
    in other chapters, but here we’re curious about how user actions and an interval
    trigger changes in Angular.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是事件或异步处理程序，但它们可能来自不同的来源。我们将在其他章节中深入探讨可观察对象和 XHR 请求的行为方式，但在这里我们好奇的是用户操作和间隔触发器如何在
    Angular 中引起变化。
- en: Angular has to know that an asynchronous activity occurred, but the `setInterval`
    and `setTimeout` APIs in JavaScript occur outside Angular’s awareness. Angular
    has monkey-patched the default implementation of `setInterval` and `setTimeout`
    to have them properly trigger Angular’s change detection when an interval or timeout
    is resolved. Likewise, when an event binding is handled in Angular, it knows to
    trigger change detection. There are some special things to do if you write code
    outside of Angular that needs to trigger change detection, but I won’t cover that
    here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 必须知道发生了异步活动，但 JavaScript 中的 `setInterval` 和 `setTimeout` API 是在 Angular
    的意识之外发生的。Angular 已经对 `setInterval` 和 `setTimeout` 的默认实现进行了猴子补丁，以便在间隔或超时解决时正确触发
    Angular 的变化检测。同样，当在 Angular 中处理事件绑定时，它知道要触发变化检测。如果你在 Angular 之外编写需要触发变化检测的代码，有一些特殊的事情要做，但这里不会涉及。
- en: One the change detection mechanism is triggered, it will start from the top
    of the component tree and check each node to see whether the component model has
    changed and requires rendering. That’s why input properties have to be made known
    to Angular, or it would fail to know how to detect changes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发变化检测机制，它将从组件树的顶部开始，检查每个节点以查看组件模型是否已更改并需要渲染。这就是为什么必须让输入属性为 Angular 所知，否则它将无法知道如何检测更改。
- en: 'Angular has two change detection modes: Default and OnPush. The Default mode
    will always check the component for changes on each change detection cycle. Angular
    has highly optimized this process so that it’s efficient to run these checks—within
    a couple milliseconds for most cases. That’s important when data is easily mutated
    between components, and it can be difficult to ensure that values haven’t changed
    around the application.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有两种变化检测模式：默认和 OnPush。默认模式将在每个变化检测周期中始终检查组件的变化。Angular 已经高度优化了此过程，使其运行这些检查非常高效——在大多数情况下只需几毫秒。当数据在组件之间容易突变时，这一点很重要，并且确保应用程序中的值没有变化可能很困难。
- en: You can also use the OnPush mode, which explicitly tells Angular that this component
    only needs to check for changes if one of the component inputs has changed. That
    means if a parent component hasn’t changed, it’s known that the child component’s
    inputs won’t change, so it can skip change detection on that component (and any
    grandchild components). Just because an input has changed doesn’t mean the component
    itself has to change; perhaps the input is an object with a changed property that
    the component doesn’t use. Keeping tracking of your data structures in your application
    can help to optimize when values are passed around and how change detection fires.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 OnPush 模式，该模式明确告诉 Angular，这个组件只有在其中一个组件输入发生变化时才需要检查变化。这意味着如果父组件没有变化，那么可以知道子组件的输入不会变化，因此可以跳过该组件（以及任何孙组件）的变化检测。仅仅因为输入发生了变化并不意味着组件本身必须发生变化；也许输入是一个具有变化属性的但组件不使用的对象。跟踪你的应用程序中的数据结构可以帮助优化值传递和变化检测触发的方式。
- en: Figure 5.1 illustrates the two types of change detection. Imagine there’s a
    component tree with two properties, and the property `'b'` is changed by some
    user input. The default mode will update the value in the component and then check
    all components underneath it for changes. The OnPush mode only checks child components
    that have an input binding specifically for the changed property and skips checking
    the other components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 展示了两种变化检测类型。想象有一个具有两个属性的组件树，属性 `'b'` 通过某些用户输入被更改。默认模式将在组件中更新值，然后检查其下所有组件的变化。OnPush
    模式只检查具有特定于更改属性的输入绑定的子组件，并跳过检查其他组件。
- en: '![c05-1.png](image_fi/293313c05/c05-1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![c05-1.png](image_fi/293313c05/c05-1.png)'
- en: '**Figure 5.1** Change detection starts at the top and goes down the tree by
    default, or with OnPush only goes down the tree with changed inputs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.1**  变化检测默认从顶部开始，按树形结构向下进行，或者使用 OnPush 仅在具有更改输入的树形结构中向下进行。'
- en: 'I recommend spending time reading about change detection in more detail from
    one of the people who helped create it, Victor Savkin: [https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c](https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议花时间阅读关于变更检测的详细信息，可以从帮助创建它的其中一人Victor Savkin那里了解：[https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c](https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c)。
- en: Our Nodes Row component is a candidate for using OnPush because everything comes
    into the component via an input and the component’s state is always linked to
    the values passed in (such as if the utilization is above 70% and the danger classes
    need to be applied). Open src/app/nodes-row/nodes-row.component.ts and we’ll make
    a minor adjustment (see the following listing) to enable OnPush for it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Nodes Row 组件是使用 OnPush 的候选者，因为所有内容都是通过输入进入组件的，并且组件的状态始终与传入的值相关联（例如，如果利用率超过
    70% 并且需要应用危险类）。打开 `src/app/nodes-row/nodes-row.component.ts`，我们将对其进行一些小的调整（见以下列表），以启用
    OnPush。
- en: '**Listing 5.1** Nodes Row component using OnPush'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表 5.1**] 使用 OnPush 的 Nodes Row 组件'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s it! Import and declare the component changeDetection property to OnPush,
    and your component is now only going through change detection when the inputs
    have changed. The strategy is a property of the component metadata, which is set
    to the Default mode by default (believe it or not!).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！导入并声明组件的 changeDetection 属性为 OnPush，现在你的组件只有在输入发生变化时才会进行变更检测。这种策略是组件元数据的一个属性，默认设置为默认模式（信不信由你！）。
- en: Now we can apply the same changes to our Metric component because it also only
    reflects the input values provided to it when rendered. Try to make the same change
    to that file yourself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将相同的更改应用到我们的 Metric 组件上，因为它在渲染时也只反映提供的输入值。试着亲自对那个文件做同样的更改。
- en: There’s another way to intercept and detect changes using the OnChanges lifecycle
    hook, and because we’re already intercepting the inputs with getter/setter methods
    in the Metric component, let’s modify it again to use OnChanges and OnPush mode.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OnChanges 生命周期钩子拦截和检测变更还有另一种方法，因为我们已经在 Metric 组件中通过 getter/setter 方法拦截了输入，所以让我们再次修改它以使用
    OnChanges 和 OnPush 模式。
- en: Open src/app/metric/metric.component.ts and update it to the code you see in
    [listing 5.2](#listing5.2). It replaces the getter and setter methods with an
    OnChanges lifecycle hook and also uses OnPush mode.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/metric/metric.component.ts` 并将其更新为你在[列表 5.2](#listing5.2)中看到的代码。它用
    OnChanges 生命周期钩子替换了 getter 和 setter 方法，并使用了 OnPush 模式。
- en: '[**Listing 5.2**](#listinganchor5.2) Metric component using OnPush mode and
    `OnChanges` lifecycle hook'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表 5.2**](#listinganchor5.2) 使用 OnPush 模式和 `OnChanges` 生命周期钩子的度量组件'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you implemented the OnPush mode yourself, it should start by importing the
    strategy helper and then adding the `changeDetection` property. Here you also
    import the `OnChanges` interface and declare the class to implement it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己实现了 OnPush 模式，它应该从导入策略辅助工具开始，然后添加 `changeDetection` 属性。在这里，你还需要导入 `OnChanges`
    接口并声明类以实现它。
- en: We still need to declare our input properties, so we go back to the previous
    way to declare them without the getter and setter methods. The `ngOnChanges` method
    implements the lifecycle hook for OnChanges, and it provides a single parameter
    as an object populated with any changed inputs, which then have their current
    and previous values available. For example, if only the `value` input was changed
    in the parent, then only the `change.value` property will be set on the lifecycle
    hook.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要声明我们的输入属性，所以我们回到之前的方法，不使用 getter 和 setter 方法来声明它们。`ngOnChanges` 方法实现了
    OnChanges 生命周期钩子，它提供了一个对象作为参数，该对象包含任何已更改的输入，然后可以访问它们的当前和先前值。例如，如果父组件中只更改了 `value`
    输入，那么在生命周期钩子上将只设置 `change.value` 属性。
- en: Inside the `OnChange` lifecycle hook, we run the same basic checks for whether
    the values are numeric or not, and if validation fails we reset the value. It
    should be noted that any changes to the inputs would propagate to any child components
    (should there be any). The value of using this approach is that we aren’t creating
    private properties while still intercepting and validating the inputs, and the
    logic doesn’t run when the component requests a property. It will only run the
    lifecycle hook for a component when the inputs have changed for that specific
    component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnChange`生命周期钩子内部，我们运行相同的检查以确定值是否为数值，如果验证失败，则重置值。需要注意的是，任何对输入的更改都会传播到任何子组件（如果有）。使用这种方法的价值在于，我们不是创建私有属性，同时拦截和验证输入，并且逻辑不会在组件请求属性时运行。它只会在特定组件的输入发生变化时为该组件运行生命周期钩子。
- en: If you ever need to run code every time that change detection is run on a component
    (regardless of whether you use OnPush or not), you can use the DoCheck lifecycle
    hook. This allows you to run some logic that can check for changes that exist
    in your component that Angular can’t detect automatically. If you need to trigger
    your own type of change detection, this is the lifecycle hook that will help you
    do that. It’s less commonly used, but do be aware of its existence for situations
    where OnChanges doesn’t get you what you need.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在每次在组件上运行变更检测时（无论是否使用OnPush），都可以使用DoCheck生命周期钩子。这允许你运行一些逻辑，可以检查Angular无法自动检测的组件中存在的更改。如果你需要触发你自己的类型的变化检测，这个生命周期钩子将帮助你做到这一点。它不太常用，但请务必注意其存在，以便在OnChanges无法满足你的需求的情况下使用。
- en: In this section we’ve optimized the Nodes Row and Metric components' change
    detection by only checking them when an input has changed. The Metric component
    also now uses the OnChanges lifecycle hook to validate inputs, which can be more
    efficient and hooks into the change detection lifecycle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过仅在输入发生变化时检查它们来优化了节点行和度量组件的变更检测。度量组件现在还使用OnChanges生命周期钩子来验证输入，这可以更高效，并挂钩到变更检测生命周期。
- en: 5.2 Communicating between components
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 组件间的通信
- en: There are a number of ways to communicate between components, and we’ve already
    gone into depth about inputs as a way to communicate data from a parent component
    to its child. That doesn’t give us a way to communicate back up to a parent, though,
    or to another component in the tree that isn’t a direct descendent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通信组件之间有几种方式，我们已经在输入作为从父组件向子组件传递数据的方式进行了深入探讨。但这并不给我们提供向上通信到父组件或树中的其他组件（如果不是直接后代）的方式。
- en: As you think about building your components, particularly ones that are highly
    modular, they will likely need to emit events when things happen so other components
    can easily take advantage of knowing when things are happening elsewhere. For
    example, you could create a tabs component and emit an event that describes what
    tab is currently visible. Another component might be interested in knowing when
    the tab selection changes so that you can update the state of that component,
    such as a nearby panel that has contextual help information based on the current
    tab.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑构建你的组件时，尤其是高度模块化的组件，它们在发生某些事情时可能会需要发出事件，以便其他组件可以轻松地利用知道其他地方正在发生的事情。例如，你可以创建一个标签组件，并发出一个描述当前可见标签的事件。另一个组件可能对知道标签选择何时发生变化感兴趣，这样你就可以更新该组件的状态，例如一个基于当前标签的上下文帮助信息的附近面板。
- en: You’ve seen inputs are the way to push data down the component tree to children,
    and events are the way to pass data and notifications up through the component
    tree to parents. When used this way, Angular considers these events outputs. We’re
    going to use outputs to inform parent components of when changes happen so we
    can react to those events.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到输入是推动数据沿着组件树向下传递给子组件的方式，而事件则是将数据和通知向上传递给父组件的方式。当以这种方式使用时，Angular将这些事件视为输出。我们将使用输出通知父组件何时发生变化，这样我们就可以对这些事件做出反应。
- en: 'Additionally, we’ll look at a couple ways to use other components in this section:
    using a View Child (which gives you access to a child component controller in
    a component controller) and using a local variable (which gives you access to
    a child component controller in a component’s template). Each has a different
    design and might work in more than one use case, but we’ll see each of them in
    action with our app.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在本节中探讨几种使用其他组件的方法：使用视图子组件（它让你访问组件控制器中的子组件控制器）和使用局部变量（它让你在组件的模板中访问子组件控制器）。每种方法都有不同的设计，可能在多个用例中都适用，但我们将通过我们的应用程序来展示每个方法的作用。
- en: Let’s take a look at our application component tree again, but this time we’ll
    annotate the inputs and communication flows ([figure 5.2](#figure5.2)). We want
    to make it possible to click a button in the Navbar component and have it generate
    the data in the dashboard (like a refresh button). The Navbar component and the
    Dashboard component are child components of the App component, so how can we get
    them to talk? It’s fairly simple using events and local template variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看我们的应用程序组件树，但这次我们将注释输入和通信流程([图5.2](#figure5.2))。我们希望能够点击Navbar组件中的按钮，使其在仪表板中生成数据（如刷新按钮）。Navbar组件和Dashboard组件是App组件的子组件，那么我们如何让它们进行通信呢？使用事件和局部模板变量来实现这一点相当简单。
- en: '![c05-2.png](image_fi/293313c05/c05-2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![c05-2.png](image_fi/293313c05/c05-2.png)'
- en: '[**Figure 5.2**](#figureanchor5.2) Components sharing data, emitting events,
    and accessing other components via local variables'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图5.2**](#figureanchor5.2) 组件共享数据、发出事件以及通过局部变量访问其他组件'
- en: In [figure 5.2](#figure5.2) you can see that the Dashboard component binds data
    into all child components, whereas the Nodes component also binds some data into
    its children. But all data flows from the Dashboard component down to children.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5.2](#figure5.2)中，你可以看到Dashboard组件将数据绑定到所有子组件，而Nodes组件也将一些数据绑定到其子组件。但所有数据都是从Dashboard组件流向子组件的。
- en: However, with the Navbar component we need a way to communicate with the Dashboard
    component to tell it to generate data again. We’ll use an output event `(onRefresh)`,
    which will alert the App component when the user clicks the refresh button. Then
    once the App component detects that the button was clicked, it can handle that
    event by telling the Dashboard to regenerate data, and it does that by referencing
    the Dashboard controller in the template using a local variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用Navbar组件时，我们需要一种与Dashboard组件通信的方式，告诉它再次生成数据。我们将使用一个输出事件`(onRefresh)`，当用户点击刷新按钮时，它会通知App组件。然后一旦App组件检测到按钮被点击，它可以通过告诉Dashboard重新生成数据来处理该事件，这是通过在模板中使用局部变量引用Dashboard控制器来实现的。
- en: 5.2.1 Output events and template variables
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 输出事件和模板变量
- en: To illustrate how this works, we need to make a few changes to our Navbar and
    App components. Let’s start by opening the src/app/navbar/navbar.component.ts
    file. We’ll need to declare an output event, like we declare an input, so that
    Angular understands how to register and handle that event, as shown in the following
    listing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点是如何工作的，我们需要对我们的Navbar和App组件做一些修改。让我们首先打开`src/app/navbar/navbar.component.ts`文件。我们需要声明一个输出事件，就像我们声明输入一样，这样Angular就能理解如何注册和处理该事件，如下面的列表所示。
- en: '**Listing 5.3** Navbar component using an output'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表5.3** 使用输出的Navbar组件'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We begin by importing the `Output` decorator and `EventEmitter` factory object.
    We need both of these to set up an output event. The `EventEmitter` is a special
    object that helps us emit custom events that work with Angular’s change detection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`Output`装饰器和`EventEmitter`工厂对象。我们需要这两个来设置输出事件。`EventEmitter`是一个特殊对象，它帮助我们发出与Angular的变更检测一起工作的自定义事件。
- en: Next, we declare a new property called `onRefresh` and add the `@Output()` decorator
    to it. This will alert Angular that there is now an event output based on the
    name of the property, which will allow us to then use event binding to listen
    for this event in our template, like `(onRefresh)="..expression.."`. As with the
    `@Input()` decorator, you could optionally pass an alias to change the event name
    that’s used for event binding.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个新的属性`onRefresh`，并给它添加`@Output()`装饰器。这将通知Angular现在有一个基于属性名称的事件输出，这将允许我们然后在模板中使用事件绑定来监听此事件，如`(onRefresh)="..expression.."`。与`@Input()`装饰器一样，你可以选择性地传递一个别名来更改用于事件绑定的事件名称。
- en: The output is typed to an `EventEmitter<null>` type, which means this variable
    will hold an `EventEmitter` that doesn’t emit any data. Optionally, it could declare
    to emit data, such as a date object that contains the moment the event was fired.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类型为`EventEmitter<null>`，这意味着这个变量将持有不发出任何数据的`EventEmitter`。可选地，它可以声明发出数据，例如包含事件触发时刻的日期对象。
- en: At this point we’ve wired up the output properly, but we still need to devise
    a way to emit refresh events. We’ve added the `refresh()` method to the Navbar
    component to call the `onRefresh.emit()` method that’s provided by the `EventEmitter`
    object. This is the line that will fire the event and alert the parent component
    that is listening.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经正确地连接了输出，但我们仍然需要想出一个方法来发出刷新事件。我们已经在Navbar组件中添加了`refresh()`方法来调用`EventEmitter`对象提供的`onRefresh.emit()`方法。这将触发事件并通知父组件，该组件正在监听。
- en: 'Now we need to add the click event binding to the Navbar button so it will
    trigger the custom output event. Open the src/app/navbar/navbar.component.html
    file and update the button line to have the click handler, as you see in the following
    code. It should call the `refresh()` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将点击事件绑定添加到Navbar按钮，以便它能够触发自定义输出事件。打开src/app/navbar/navbar.component.html文件，并更新按钮行以包含点击处理程序，如下所示。它应该调用`refresh()`方法：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Clicking the Reload button in the navbar will now trigger the `refresh()` method,
    which will then emit the custom output event `onRefresh`. You can see what happens
    in [figure 5.3](#figure5.3).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在navbar中点击“重新加载”按钮现在将触发`refresh()`方法，然后它会发出自定义输出事件`onRefresh`。您可以在[图5.3](#figure5.3)中看到发生了什么。
- en: '![c05-3.png](image_fi/293313c05/c05-3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![c05-3.png](image_fi/293313c05/c05-3.png)'
- en: '[**Figure 5.3**](#figureanchor5.3) Overview of component tree, how user clicks
    button and it triggers refresh of data via an output event'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图5.3**](#figureanchor5.3)  组件树概述，用户点击按钮并通过输出事件触发数据刷新'
- en: 'Our App component (the parent of both Navbar and Dashboard) is now being alerted
    when the user clicks the button, but we haven’t implemented an event binding to
    capture and respond to it. To do that, open the src/app/app.component.html file
    and modify it to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用组件（Navbar和Dashboard的父组件）现在在用户点击按钮时会收到警报，但我们还没有实现事件绑定来捕获和响应它。为了做到这一点，打开src/app/app.component.html文件，并修改它如下：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On the first line, we’ve added the event binding to react to the `onRefresh`
    output event when it fires, but it needs to call the method from the Dashboard
    component. Because the Dashboard component has the method to generate data, we
    need a way to call it from the App component. The second line adds `#dashboard`
    to the template on the Dashboard component. This denotes a local template variable,
    accessible as the variable `dashboard`, that references the Dashboard component
    controller so we can call methods from the Dashboard component—it allows us to
    call a method from the Dashboard component anywhere in the App component template,
    even though we aren’t inside the Dashboard component. But only public methods
    are available—private methods like `randomInteger()`, for example, aren’t available.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们添加了事件绑定以响应`onRefresh`输出事件，但它需要调用来自Dashboard组件的方法。因为Dashboard组件有生成数据的方法，我们需要一种从App组件调用它的方法。第二行在Dashboard组件的模板上添加了`#dashboard`。这表示一个局部模板变量，可以通过变量`dashboard`访问，它引用Dashboard组件控制器，这样我们就可以从Dashboard组件调用方法——它允许我们在App组件模板的任何地方调用来自Dashboard组件的方法，即使我们不在Dashboard组件内部。但只有公共方法可用——例如，像`randomInteger()`这样的私有方法不可用。
- en: If no components are listening to the event, then it *will not propagate* up
    the component tree. Output events only go to the parent component, unlike regular
    DOM events (such as click or keypress) that do propagate up the DOM tree.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有组件监听该事件，那么它*将不会*在组件树中传播。输出事件只发送到父组件，与像点击或按键这样的常规DOM事件（它们会沿着DOM树传播）不同。
- en: This event emitting trick lets us use one component in another part of the template,
    and in this case we use it to handle the `onRefresh` event by calling the `dashboard.generateData()`
    method from the Dashboard component. This is handy for accessing components that
    exist in the same template. The major negative is that it only allows you to access
    the component controller from the template and not from the controller, meaning
    the App component controller can’t call the Dashboard component methods directly.
    Luckily, there’s another way to reference another component using a View Child.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件发射技巧允许我们在模板的另一个部分使用一个组件，在这种情况下，我们使用它来处理`onRefresh`事件，通过从Dashboard组件调用`dashboard.generateData()`方法。这对于访问同一模板中存在的组件来说非常方便。主要的缺点是它只允许你从模板访问组件控制器，而不是从控制器访问，这意味着App组件控制器不能直接调用Dashboard组件的方法。幸运的是，还有另一种方法，即使用View
    Child来引用另一个组件。
- en: 5.2.2 View Child to reference components
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 使用View Child引用组件
- en: In order to access a child component’s controller inside a parent controller,
    we can leverage `ViewChild` to inject that controller into our component. This
    gives us a direct reference to the child controller so we can implement a call
    to the Dashboard component from the App component controller.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在父控制器内部访问子组件的控制器，我们可以利用`ViewChild`将这个控制器注入到我们的组件中。这为我们提供了对子控制器的直接引用，因此我们可以从App组件控制器实现调用Dashboard组件。
- en: '`ViewChild` is a decorator for a controller property, like `Inject` or `Output`,
    which tells Angular to fill in that property with a reference to a specific child
    component controller. It’s limited to injecting only children, so if you try to
    inject a component that isn’t a direct descendent, it will provide you with an
    undefined value.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChild`是一个控制器属性装饰器，类似于`Inject`或`Output`，它告诉Angular用对特定子组件控制器引用填充该属性。它仅限于注入子组件，所以如果你尝试注入一个不是直接后代的组件，它将提供一个未定义的值。'
- en: Let’s see this in action by updating our App component to get a reference to
    the Dashboard component and have it directly handle the `onRefresh` event from
    the Navbar. Open the src/app/app.component.ts file and replace it with what you
    see in [listing 5.4](#listing5.4).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新App组件来查看这个功能，使其获取Dashboard组件的引用并直接处理Navbar发出的`onRefresh`事件。打开src/app/app.component.ts文件，将其替换为[列表5.4](#listing5.4)中看到的内容。
- en: '[**Listing 5.4**](#listinganchor5.4) App component controller'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表5.4**](#listinganchor5.4) App组件控制器'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After we import the `ViewChild` decorator, we also need to import the `Dashboard­Component`
    itself. We need to make sure it’s available during compiling and that we can directly
    reference it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导入`ViewChild`装饰器之后，我们还需要导入`DashboardComponent`本身。我们需要确保它在编译期间可用，并且我们可以直接引用它。
- en: The App component then gets a single property, `dashboard`. The `@ViewChild()`
    decorator sits in front, and we pass a reference to the `DashboardComponent` so
    Angular knows exactly what component to use. We also give the property a type
    of `DashboardComponent` because it’s an instance of that controller.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，App组件获得一个单一的属性，`dashboard`。`@ViewChild()`装饰器位于前面，我们传递对`DashboardComponent`的引用，这样Angular就能确切知道要使用哪个组件。我们还给这个属性指定了`DashboardComponent`的类型，因为它是一个该控制器的实例。
- en: Finally, we add a `refresh()` method, which calls the Dashboard component controller
    to generate the data. Compared to the template variable approach, this gives us
    an opportunity for additional work that might be difficult or not possible in
    the template.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个`refresh()`方法，它调用Dashboard组件控制器来生成数据。与模板变量方法相比，这为我们提供了在模板中可能难以或不可能完成的工作的机会。
- en: 'We need to update the App component template to call the new controller method
    instead of using a template variable. Back in src/app/app.component.html, you
    should change the contents to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新App组件模板，以调用新的控制器方法而不是使用模板变量。回到src/app/app.component.html，你应该将内容更改为以下内容：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the template doesn’t have a reference to the Dashboard component, but instead
    calls the App component’s `refresh` method when the output event is fired. The
    result is the same—the Dashboard will generate a new set of data—but the approach
    is different.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模板不再引用Dashboard组件，而是当输出事件被触发时调用App组件的`refresh`方法。结果是相同的——Dashboard将生成一组新的数据——但方法不同。
- en: You may be wondering which approach you should use, and it largely boils down
    to where you want to store the logic. If you ever need to do anything more than
    access properties or methods of a child controller, you probably need to use the
    `ViewChild` approach. This does cause a coupling between the two components, which
    should be avoided when possible. But if you can reference a child controller and
    call a method directly in the template, it can save code and reduce coupling.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道应该使用哪种方法，这主要取决于你希望将逻辑存储在哪里。如果你需要做的不仅仅是访问子控制器的属性或方法，那么你可能需要使用`ViewChild`方法。这确实会在两个组件之间造成耦合，在可能的情况下应该避免。但如果可以直接在模板中引用子控制器并调用方法，这样可以节省代码并减少耦合。
- en: 5.3 Styling components and encapsulation modes
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 组件样式化和封装模式
- en: Angular can use different ways of rendering that change the way the component
    can be styled. Components are usually designed to manage their own state, and
    that includes the visual styling required for the component to display. There
    is almost always some kind of global CSS styling that you will apply to provide
    a functional base for your application default styling, but components can hold
    their own styles that are rendered in isolation from the rest of the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular可以使用不同的渲染方式，这会改变组件的样式化方式。组件通常被设计来管理自己的状态，这包括组件显示所需的视觉样式。几乎总是有一些全局CSS样式，你将应用它们来为你的应用程序提供默认样式的功能基础，但组件可以保留自己的样式，这些样式将在与应用程序其他部分隔离的情况下渲染。
- en: If you add CSS styles for a component, those styles aren’t globally exposed,
    and you will avoid having to deal with CSS rules from one component overriding
    another component. There’s a way to render component styles to the global styling
    that’s only recommended in a few situations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为组件添加CSS样式，这些样式不会全局暴露，你将避免处理来自一个组件的CSS规则覆盖另一个组件的情况。有一种方法可以将组件样式渲染到全局样式，但这只在少数情况下推荐使用。
- en: There are multiple ways to add styles to a component. It’s best to add your
    styles in the same way across all of your components because mixing and matching
    can have some interesting (and sometimes unexpected) side effects. It can also
    be potentially challenging if you use an external library that does something
    differently, so keep an eye on how your dependencies work to ensure they don’t
    conflict.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 向组件添加样式有多种方式。最好以相同的方式在你的所有组件中添加样式，因为混合和匹配可能会产生一些有趣（有时是意外的）副作用。如果你使用了一个执行不同操作的第三方库，这可能会带来潜在的挑战，所以请关注你的依赖项如何工作，以确保它们不会发生冲突。
- en: 5.3.1 Adding styles to a component
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 向组件添加样式
- en: Styles can be added several ways. You can always add CSS using a global approach,
    where you include a linked CSS file into your application index.html file or reference
    the file in the .angular-cli.json file `styles` property (which we already did
    for Ng-bootstrap). These styles are generic and will be applied to any matching
    elements in the page. That’s good for common and shared styling that needs to
    go everywhere, but not good when you want to have isolated components that define
    their own styling.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 样式可以通过多种方式添加。你始终可以使用全局方法添加CSS，即在应用程序的index.html文件中包含链接的CSS文件，或在`.angular-cli.json`文件的`styles`属性中引用该文件（我们已经为Ng-bootstrap做了这件事）。这些样式是通用的，并将应用于页面中任何匹配的元素。这对于需要到处使用的常见和共享样式来说很好，但当你想要有独立定义自己样式的组件时，这就不太好了。
- en: 'To better isolate our styling, we can use one of the following approaches—these
    are ways to add styles that are specific to a single component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地隔离我们的样式，我们可以使用以下方法之一——这些是添加特定于单个组件的样式的途径：
- en: '*Inline CSS* —Component templates can have inline CSS or style attributes to
    set the styles of the elements. These are the default ways to add style rules
    to HTML elements regardless of whether you’re using Angular.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内联CSS* — 组件模板可以包含内联CSS或style属性来设置元素的样式。这些是在使用Angular或其他技术时添加样式规则到HTML元素的默认方式。'
- en: '*Component-linked CSS* —Using the component’s `styleUrls` property with links
    to external CSS files. Angular will load the CSS file and inject the rules inside
    a `style` element for your app.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件链接CSS* — 使用组件的`styleUrls`属性和指向外部CSS文件的链接。Angular将加载CSS文件并将规则注入到你的应用的`style`元素中。'
- en: '*Component inline CSS* —Using the component’s `styles` property with an array
    of CSS rules, Angular will inject the rules inside a `style` element for your
    app.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件内联CSS* — 使用组件的`styles`属性和CSS规则数组，Angular会将规则注入到你的应用的`style`元素中。'
- en: 'Let’s take a look at how these different approaches can be used in an example.
    Here we have a simple component that has styling applied from five different approaches:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些不同的方法如何在示例中使用。这里有一个简单的组件，它从五个不同的方法中应用了样式：
- en: Global CSS rules
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局 CSS 规则
- en: Inline CSS`style` element
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联 CSS `style` 元素
- en: Inline `style` declaration
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联 `style` 声明
- en: Component `styles` property
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件 `styles` 属性
- en: Component `styleUrls` property linked to a CSS file
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件 `styleUrls` 属性链接到 CSS 文件
- en: 'We’ll modify the Reload button in the navbar to have a different background
    color so we can see how these different approaches get applied. We’ll start by
    adding some CSS to our CSS file that the CLI generates with each component, which
    is linked using the `styleUrls` property. Open the src/app/navbar/navbar.component.css
    file and add the following CSS rule to it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改导航栏中的 Reload 按钮以具有不同的背景颜色，这样我们就可以看到这些不同的方法是如何应用的。我们首先向 CLI 为每个组件生成的 CSS
    文件中添加一些 CSS，该文件通过 `styleUrls` 属性链接。打开 src/app/navbar/navbar.component.css 文件，并添加以下
    CSS 规则：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That overrides the global color set by the bootstrap CSS library and gives our
    button a red color (instead of the default green). Notice that the other buttons
    on the page (in the Nodes Row components) aren’t changed, even though they also
    have the `.btn` class applied. We’ll cover how that happens shortly, but that’s
    the visual result of Angular’s encapsulation features.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这覆盖了由 bootstrap CSS 库设置的全球颜色，并给我们的按钮一个红色（而不是默认的绿色）。注意，页面上的其他按钮（在 Nodes Row 组件中）没有改变，即使它们也应用了
    `.btn` 类。我们将在稍后解释这是如何发生的，但这是 Angular 封装功能的视觉结果。
- en: 'Next, we’ll add some styles by updating the component metadata in the src/app/navbar/navbar.component.ts
    file with the following `styles` property:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过更新 src/app/navbar/navbar.component.ts 文件中的组件元数据来添加一些样式，使用以下 `styles`
    属性：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `styles` property lets us provide an array of strings (here we’re using
    the backtick character to make a string literal) that should contain valid CSS
    rules. Now when you look at the application, it should appear to be a gray button.
    That means that styles inside the `styles` property will override anything from
    the CSS files loaded through the `styleUrls` property. The trick here is that
    whichever is declared last will win, so when you have both `styles` and `styleUrls`,
    the one declared last will override the first regardless of which one is used,
    due to the way the compiling works. (At time of writing, the CLI complains if
    you declare both `styles` and `styleUrls` in the CLI, but it still seems to work.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`styles` 属性让我们提供一组字符串（这里我们使用反引号字符来创建一个字符串字面量），这些字符串应包含有效的 CSS 规则。现在当你查看应用程序时，它应该看起来像是一个灰色按钮。这意味着
    `styles` 属性内的样式将覆盖通过 `styleUrls` 属性加载的 CSS 文件中的任何样式。这里的技巧是，最后声明的将获胜，所以当你既有 `styles`
    和 `styleUrls` 时，最后声明的将覆盖第一个，无论使用哪一个，这取决于编译的方式。（在撰写本文时，CLI 如果你在 CLI 中声明了 `styles`
    和 `styleUrls`，会发出警告，但它似乎仍然可以工作。）'
- en: 'Now open up the navbar template at src/app/navbar/navbar.component.html and
    add the following style element into the template:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 src/app/navbar/navbar.component.html 中的导航栏模板，并将以下样式元素添加到模板中：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you save this, the application will reload, and all of a sudden your button
    will now be blue, which means that inline style declarations will override any
    values provide via the `styles` or `styleUrls` properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，应用程序将重新加载，突然你的按钮现在变成了蓝色，这意味着内联样式声明将覆盖通过 `styles` 或 `styleUrls` 属性提供的任何值。
- en: 'The last way to add styles is directly on the element itself using the `style`
    attribute. While still in the component template, modify the button to include
    this inline CSS declaration to make the button purple:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 添加样式的最后一种方式是直接在元素本身上使用 `style` 属性。仍然在组件模板中，修改按钮以包含此内联 CSS 声明，使按钮变为紫色：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This exercise showed us that if a CSS rule is set with a different value in
    all of these places, you might be surprised which rule is applied. It should be
    noted that using the `!important` value will raise that particular rule above
    any others, should you dare to use it. Here’s the priority order in which the
    rules are applied if the same rule is declared in multiple places, with each item
    overriding any rules below it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习向我们展示了，如果 CSS 规则在所有这些地方都设置了不同的值，你可能会对哪个规则被应用感到惊讶。需要注意的是，使用 `!important`
    值将使该特定规则高于其他任何规则，如果你敢使用它的话。如果同一规则在多个地方声明，以下是根据规则应用的优先级顺序，每个项目都会覆盖其下方的规则：
- en: 1 Inline style attribute rules
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 内联样式属性规则
- en: 2 Inline style block rules in the template
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 模板中的内联样式块规则
- en: 3 Component `styles` rules or `styleUrls` rules (if both, then last declared
    has priority)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 组件`styles`规则或`styleUrls`规则（如果两者都有，则最后声明的具有优先级）
- en: 4 Global CSS rules
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4 全局CSS规则
- en: Declaring a rule using inline styles is always going to be the highest priority
    rule. This is probably expected because, except for when the `!important` value
    is declared, inline styles are given highest priority by the browser. The style
    block from the template is the next highest priority. Then the next highest are
    rules declared in the component `styles` array or `styleUrls` external files,
    and lastly any global styles.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联样式声明的规则始终是最高优先级的规则。这可能是预期的，因为除了声明`!important`值之外，内联样式通常由浏览器赋予最高优先级。模板中的样式块是下一个最高优先级。然后是组件`styles`数组或`styleUrls`外部文件中声明的规则，最后是全球样式。
- en: All CSS rules are added to the end of the document head inside a new `style`
    element. As the application is rendered, components will get loaded, and those
    styles will get added to the document head. But depending on the encapsulation
    mode, the way those styles are rendered can change the way those styles are processed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有CSS规则都添加到文档头部的新`style`元素中。当应用渲染时，组件将被加载，这些样式将被添加到文档头部。但根据封装模式的不同，这些样式的渲染方式可能会改变样式的处理方式。
- en: 'One important note: all these guidelines are based on using the CLI for building.
    It’s possible to change the build process and obtain different priorities or results,
    just so you’re aware. Now let’s look at how different encapsulation modes work
    and why we might want to change the default settings.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：所有这些指南都是基于使用CLI进行构建的。有可能改变构建过程并获得不同的优先级或结果，只是让你知道。现在让我们看看不同的封装模式是如何工作的，以及为什么我们可能想要更改默认设置。
- en: 5.3.2 Encapsulation modes
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 封装模式
- en: Angular wants to ensure that you can build modular components that can be easily
    shared. One key capability is the ability to ensure that CSS styling for a component
    doesn’t bleed over into the rest of the app, which is called *styling encapsulation*.
    Have you ever used a third-party library that included some CSS which conflicted
    with something else in your application and caused something to display improperly?
    Most likely you’ve run into this situation, and Angular offers some options to
    avoid it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Angular希望确保你可以构建模块化的组件，这些组件可以轻松共享。一个关键能力是确保组件的CSS样式不会溢出到应用的其余部分，这被称为*样式封装*。你有没有使用过包含一些CSS的第三方库，这些CSS与你的应用程序中的其他内容冲突，导致某些内容显示不正确？很可能是你遇到了这种情况，Angular提供了一些选项来避免这种情况。
- en: Until recently, there was no certain way to encapsulate CSS styling or HTML
    elements of a particular DOM element. The most common approach is to use specific
    class naming conventions, as are found in most popular CSS libraries. These conventions
    provide a specific nomenclature for CSS classes that limits the chances of the
    same class being used elsewhere. Although these might typically be effective,
    there’s no guarantee that class names or styles won’t collide, and it provides
    no encapsulation for inner HTML elements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，还没有确定的方法来封装特定DOM元素的CSS样式或HTML元素。最常见的方法是使用特定的类命名约定，正如在大多数流行的CSS库中找到的那样。这些约定为CSS类提供了一种特定的命名法，限制了相同类在其他地方被使用的可能性。尽管这些方法通常有效，但无法保证类名或样式不会冲突，并且它不会为内部HTML元素提供封装。
- en: Enter the Shadow DOM, the official native browser standard for encapsulating
    styles. Shadow DOM provides us with a good set of features to ensure that our
    styles don’t conflict and bleed in or out of a component, except that it might
    not be available on older browsers. If you need to brush up on Shadow DOM, refer
    to chapter 1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Shadow DOM，这是官方的浏览器原生封装样式标准。Shadow DOM为我们提供了一套良好的功能，以确保我们的样式不会冲突并渗入或渗出组件，尽管它可能不支持旧版浏览器。如果你需要复习Shadow
    DOM，请参考第1章。
- en: Angular comes with three encapsulation modes for a view. In the earlier styling
    example, you were using the default Emulated mode.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为视图提供了三种封装模式。在早期的样式示例中，你使用的是默认的模拟模式。
- en: '*None* —No encapsulation is used during rendering of the view, and the component
    DOM is subject to the normal rules of CSS. Templates aren’t modified when injected
    into the app except for the removal of any CSS style elements from the template
    to the document head.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*None* — 在视图渲染过程中没有使用封装，组件的DOM受CSS的正常规则约束。当模板注入到应用中时，不会修改模板，除了从模板中移除任何CSS样式元素到文档头部。'
- en: '*Emulated* —Emulated encapsulation is used to simulate styling encapsulation
    by adding unique CSS selectors to your CSS rules at runtime. CSS can cascade into
    the component easily from the global CSS rules.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟* — 模拟封装通过在运行时向 CSS 规则添加唯一 CSS 选择器来模拟样式封装。CSS 可以轻松地从全局 CSS 规则中级联到组件中。'
- en: '*Native* —Uses the native Shadow DOM for styling and markup encapsulation and
    provides the best encapsulation. All styles are injected inside the shadow root
    and are therefore localized to the component. None of the templates or styles
    declared for the component are visible outside the component.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原生* — 使用原生 Shadow DOM 进行样式和标记封装，并提供最佳的封装。所有样式都注入到 shadow root 中，因此本地化到组件。组件声明的任何模板或样式都不会在组件外部可见。'
- en: Each encapsulation mode applies styles in a different manner, so it’s important
    to understand how encapsulation modes and styling render the view. The order in
    which styles are applied remains constant regardless of which encapsulation mode
    is used, but the way in which the underlying styles are injected and modify the
    app does change.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每种封装模式以不同的方式应用样式，因此了解封装模式和样式渲染视图的方式很重要。无论使用哪种封装模式，应用样式的顺序都是一致的，但底层样式注入和修改应用的方式确实会改变。
- en: Now let’s take a closer look at the different modes, how they behave, and why
    you might decide to select a different mode than the default mode. As we look
    at each mode, try setting the mode in the Metric component and inspecting the
    output as it’s rendered in the page to see how it adds styles into the document
    head.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看不同的模式，它们的行为方式，以及为什么你可能决定选择不同于默认模式的模式。当我们查看每种模式时，尝试在 Metric 组件中设置模式，并检查它在页面中渲染时的输出，以了解它是如何将样式添加到文档头部的。
- en: No encapsulation mode
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无封装模式
- en: If you use no encapsulation by setting in the component, you’ll bypass any native
    or emulated Shadow DOM features. It will render the component into the HTML document
    as is, as if you had written the HTML markup directly into the body yourself.
    This is the default mode for components without any styles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在组件中未设置封装，你将绕过任何原生或模拟的 Shadow DOM 功能。它将组件渲染到 HTML 文档中，就像你直接将 HTML 标记写入 body
    一样。这是没有样式的组件的默认模式。
- en: 'To set this mode, you would use the `encapsulation` property of the component
    metadata to set it like so—of course, you’ll need to import the `ViewEncapsulation`
    enum from `@angular/core`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置此模式，你需要使用组件元数据的 `encapsulation` 属性来设置，当然，你需要从 `@angular/core` 中导入 `ViewEncapsulation`
    枚举：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the mode is set, any styles you declare for the component will be hoisted
    up from the component template into the document head, and this is the only real
    modification made to the markup. The `style` element is moved into the document
    head as is, which is a way of injecting global CSS rules. It’s possible another
    component rendered later would inject a competing CSS rule, so render order matters
    as well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了模式，为组件声明的任何样式都将从组件模板提升到文档头部，这是对标记的唯一实际修改。`style` 元素以原样移动到文档头部，这是一种注入全局
    CSS 规则的方式。另一个稍后渲染的组件可能会注入一个竞争 CSS 规则，因此渲染顺序也很重要。
- en: 'Here’s a summary of reasons why you might use, or avoid using, components with
    no encapsulation mode:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里总结了为什么你可能使用或避免使用无封装模式的组件的原因：
- en: '*Styles bleed out* —Sometimes applications are designed with CSS libraries
    where encapsulating the internal styling of each component is unnecessary or undesired.
    If you don’t put styles into your components, then encapsulation may not be necessary.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式泄漏* — 有时应用程序设计时使用了 CSS 库，其中封装每个组件的内部样式是不必要或不受欢迎的。如果你没有将样式放入你的组件中，那么封装可能不是必要的。'
- en: '*Global styles bleed in* —The global background style for a header element
    is applied because of the lack of encapsulation, which may or may not be desired
    behavior.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局样式泄漏* — 由于缺乏封装，标题元素的全球背景样式被应用，这可能或可能不是期望的行为。'
- en: '*Templates are unmodified* —Because this mode injects the template as is (after
    relocating the styles), your DOM elements won’t have any special transformations
    applied.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模板未修改* — 因为这种模式以原样注入模板（在重新定位样式之后），你的 DOM 元素将不会应用任何特殊转换。'
- en: When using no encapsulation mode, you can’t use any of the special Shadow DOM
    selectors like `:host` or `::shadow`. These have no context because no Shadow
    DOM (native or emulated) features are enabled.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无封装模式时，你不能使用任何特殊的 Shadow DOM 选择器，如 `:host` 或 `::shadow`。因为这些选择器没有上下文，因为没有启用任何
    Shadow DOM（原生或模拟）功能。
- en: Now let’s look at the emulated mode and see how it behaves in comparison.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看模拟模式，并比较其行为。
- en: Emulated Shadow DOM encapsulation mode
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟 Shadow DOM 封装模式
- en: Emulated mode applies some transformations to any styles by adding unique attributes
    to HTML markup and CSS rules to increase the specificity of the CSS rules by making
    them unique. Because this isn’t a true encapsulation, it’s referred to as *emulated*,
    but it has many of the same benefits. This is the default mode for Angular components
    that have any styles declared (regardless of how they’re declared in the component).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟模式通过向 HTML 标记和 CSS 规则添加独特属性来对任何样式应用一些转换，通过使它们独特来增加 CSS 规则的特定性。因为这不是真正的封装，所以被称为
    *模拟*，但它具有许多相同的优点。这是 Angular 组件的默认模式，无论它们如何在组件中声明样式（无论它们如何在组件中声明）。
- en: 'Emulated mode is primarily about preventing styles in the component from bleeding
    out to the global rules (which happens when no encapsulation is used). In order
    to accomplish this, the view will render the template and styles with unique attributes
    to increase the specificity of the CSS rules inside the component. Emulated mode
    is the default mode, but if you want to explicitly declare it, you would set the
    property on the component metadata:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟模式主要关于防止组件中的样式泄漏到全局规则（当不使用封装时会发生这种情况）。为了实现这一点，视图将通过使用独特的属性来渲染模板和样式，以增加组件内部
    CSS 规则的特定性。模拟模式是默认模式，但如果你想显式声明它，你会在组件元数据上设置该属性：
- en: '`encapsulation: ViewEncapsulation.Emulated`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`encapsulation: ViewEncapsulation.Emulated`。'
- en: During the render, the styles are first extracted from the component template
    or component properties. Then a unique attribute is generated, something similar
    to `_ngcontent-ofq-3`. It uses the `_ngcontent` prefix with a unique ending so
    each component can have a unique CSS selector. Multiple instances of the same
    component have the same unique attribute. Lastly, the view renders by adding the
    unique attribute to the component DOM nodes and adding it into the CSS selector
    rules.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染过程中，样式首先从组件模板或组件属性中提取出来。然后生成一个独特的属性，类似于 `_ngcontent-ofq-3`。它使用 `_ngcontent`
    前缀和一个独特的后缀，以便每个组件都可以有一个独特的 CSS 选择器。相同组件的多个实例具有相同的独特属性。最后，视图通过向组件 DOM 节点添加独特属性并将其添加到
    CSS 选择器规则中来渲染。
- en: 'Here’s a quick overview of the behaviors of emulated encapsulation mode and
    why you would (or wouldn’t) want to use it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要概述一下模拟封装模式的行为以及你为什么想要（或不想）使用它：
- en: '*Styles are isolated* —The rendering of the styles and markup adds the unique
    attributes to ensure that CSS rules don’t collide with global styles.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式隔离* — 样式和标记的渲染会添加独特的属性，以确保 CSS 规则不与全局样式冲突。'
- en: '*Styles bleed in* —The global styling can still bleed into the component, which
    can be useful to allow a common styling to be shared. It also could conflict with
    the component if a rule is added somewhere globally that you didn’t intend to
    bleed into the component.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式泄漏* — 全局样式仍然可以泄漏到组件中，这可以用来允许共享常见的样式。如果全局规则中添加了规则，而你不想让它们泄漏到组件中，这可能会与组件冲突。'
- en: '*Unique selectors* —The rendered DOM gets a unique attribute, which means if
    you have global styles that you want to apply into the component, you’ll need
    to write CSS selectors accordingly.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*独特选择器* — 渲染的 DOM 获得一个独特的属性，这意味着如果你想在组件中应用全局样式，你需要相应地编写 CSS 选择器。'
- en: Now let’s finish the encapsulation modes by looking at the native mode and how
    it uses Shadow DOM.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过查看原生模式及其如何使用 Shadow DOM 来完成封装模式的讨论。
- en: Native Shadow DOM encapsulation mode
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原生 Shadow DOM 封装模式
- en: The Shadow DOM is a powerful tool for encapsulating markup and styles from the
    rest of the application. Angular can use Shadow DOM to inject all the content
    instead of putting it into the primary document. This means that the template
    and the styles are truly isolated from the rest of the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow DOM 是一种强大的工具，用于封装从应用其余部分中分离的标记和样式。Angular 可以使用 Shadow DOM 将所有内容注入，而不是将其放入主文档中。这意味着模板和样式确实与应用的其余部分隔离。
- en: Native browser support for Shadow DOM is limited and can be checked at [http://caniuse.com/#feat=shadowdom](http://caniuse.com/#feat=shadowdom).
    The benefits of Shadow DOM may not extend to all the browsers you need to support,
    but there is also a good polyfill to backfill the support at [http://webcomponents.org/polyfills/shadow-dom/](http://webcomponents.org/polyfills/shadow-dom/).
    Even with a polyfill, older browsers may not be supported, so you should consider
    all of your needs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 原生浏览器对 Shadow DOM 的支持有限，可以在 [http://caniuse.com/#feat=shadowdom](http://caniuse.com/#feat=shadowdom)
    检查。Shadow DOM 的好处可能不会扩展到你需要支持的 所有浏览器，但有一个很好的 polyfill 可以在 [http://webcomponents.org/polyfills/shadow-dom/](http://webcomponents.org/polyfills/shadow-dom/)
    中提供支持。即使有 polyfill，较旧的浏览器可能仍然不受支持，因此你应该考虑所有需求。
- en: While the component renders, it creates a shadow root in the component. The
    template is injected into the shadow root, along with the styles from the sibling
    and any parent component. As far as the rest of the document goes, this shadow
    root protects the contents from being visible to anything outside of the component.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件渲染时，它会在组件中创建一个 shadow root。模板被注入到 shadow root 中，以及来自兄弟和任何父组件的样式。对于文档的其余部分，这个
    shadow root 保护了内容不被组件外部可见。
- en: Angular intends that nested components should be able to share styling, but
    with the shadow root, Angular makes those styles available to the component by
    injecting them into the shadow root as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 希望嵌套组件能够共享样式，但通过 shadow root，Angular 通过将它们注入到 shadow root 中使这些样式对组件可用。
- en: 'Here’s a summary of the way that the native mode works and why you might or
    might not want to use it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对原生模式工作方式及其为什么可能或可能不想使用它的总结：
- en: '*Uses Shadow DOM* —For true encapsulation, the native option is the best bet.
    It will protect your components from the styles of the document and encapsulate
    the markup as well.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Shadow DOM* — 对于真正的封装，原生选项是最好的选择。它将保护你的组件免受文档样式的干扰，并将标记封装起来。'
- en: '*Parent and sibling styles bleed in* —Due to the way Angular renders the component,
    it also injects the parent and sibling components’ styles, which can cause issues
    like styles bleeding in (which you might not want).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*父级和兄弟级样式渗透* — 由于 Angular 渲染组件的方式，它还会注入父级和兄弟级组件的样式，这可能导致样式渗透（你可能不希望发生）的问题。'
- en: '*Limited support* —Browser support for Shadow DOM is limited and may require
    the use of a polyfill to allow its use in applications.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有限支持* — 浏览器对 Shadow DOM 的支持有限，可能需要使用 polyfill 来允许其在应用程序中使用。'
- en: So far, we’ve looked at how to bind data into the view from the component. This
    is important to allow us to inject data and modify properties of the view dynamically.
    We also looked at how to use event bindings to call from the view back to the
    component, which can be used to update values or call methods. And we’ve looked
    at the various ways to style a component and how to encapsulate styles.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何将数据绑定到组件的视图中。这对于动态注入数据和修改视图属性非常重要。我们还探讨了如何使用事件绑定从视图回调到组件，这可以用来更新值或调用方法。我们还探讨了样式化组件和封装样式的各种方法。
- en: We’ve covered a lot of ground, but now we’re going to look at Angular directives
    and pipes. They provide additional options to modify the display of data or elements
    in our view and add additional logic to templates.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了很多内容，但现在我们将探讨 Angular 指令和管道。它们提供了修改我们视图中数据或元素显示的额外选项，并为模板添加了额外的逻辑。
- en: 5.4 Dynamically rendering components
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 动态渲染组件
- en: Applications sometimes need to dynamically render a component based on the current
    application state. You may not always know what component needs to be on the screen,
    or perhaps the user interactions call for a new component to display in the page.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有时需要根据当前应用程序状态动态渲染组件。你可能不知道屏幕上需要哪个组件，或者可能是用户交互需要在新页面上显示新的组件。
- en: There are a few fairly common situations that you’ve seen where a dynamic component
    is often a good solution. For example
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些相当常见的情况，在这些情况下，动态组件通常是一个很好的解决方案。例如
- en: Modals that display over the page with dynamic content
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示动态内容的页面模态
- en: Alerts that conditionally display
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件显示的警报
- en: Carousel or tabs that might dynamically expand the amount of content
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会动态扩展内容量的轮播或选项卡
- en: Collapsible content that needs to be removed afterward
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要之后删除的折叠内容
- en: 'These situations all have something in common: They don’t always need to be
    on the screen or are dependent on conditions outside of their own power. Angular
    gives us the ability to use lower-level APIs to call, that let us render a component
    that doesn’t already exist in a template, on demand.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况都有一个共同点：它们不一定需要在屏幕上，或者依赖于它们自身能力之外的条件。Angular 给我们使用较低级别的 API 的能力，这些 API 允许我们按需渲染一个模板中尚未存在的组件。
- en: I’ll show two examples of using ng-bootstrap to generate a modal and then talk
    about how to do it all ourselves using Angular’s APIs to create an alert component.
    With ng-bootstrap, most of the magic is hidden behind a helpful service, but it
    will give us the ability to quickly get the capability working before we build
    it by hand.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示两个使用 ng-bootstrap 生成模态框的示例，然后讨论如何使用 Angular 的 API 创建一个警报组件来自行完成所有操作。使用 ng-bootstrap，大部分魔法都隐藏在一个有用的服务背后，但它将使我们能够在手动构建之前快速获得所需的功能。
- en: 5.4.1 Using the Ng-bootstrap modal for dynamic components
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 使用 Ng-bootstrap 模态框动态组件
- en: 'Let’s start by generating a new component. This component is going to show
    details about the node when you click the View button in the Nodes Row component.
    We’re going to call this the Nodes Detail component:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从生成一个新的组件开始。这个组件将在你点击节点行组件中的查看按钮时显示节点的详细信息。我们将称这个组件为节点详情组件：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now replace the component’s controller, found in src/app/nodes-detail/nodes-detail.component.ts,
    with the code in [listing 5.5](#listing5.5). This controller has similar logic
    to determine whether the node exceeds its utilization or not. This is the component
    that will open inside the modal and won’t be loaded until called for.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用代码替换组件的控制器，该控制器位于 src/app/nodes-detail/nodes-detail.component.ts，替换为[列表 5.5](#listing5.5)中的代码。这个控制器有类似的逻辑来判断节点是否超出了其利用率。这是将在模态框内部打开的组件，并且只有在被调用时才会加载。
- en: '[**Listing 5.5**](#listinganchor5.5) Nodes Detail component controller'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表 5.5**](#listinganchor5.5) 节点详情组件控制器'
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Ng-bootstrap library provides a useful service called NgbActiveModal, which
    is an instance of the modal controller that loads the Nodes Detail component.
    It will allow us to dismiss the modal when we like, either on demand or based
    on user action. This will be more apparent when we add the template for this component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ng-bootstrap 库提供了一个有用的服务，名为 NgbActiveModal，它是模态控制器的实例，用于加载节点详情组件。它将允许我们在需要时关闭模态框，无论是按需还是基于用户操作。当我们添加这个组件的模板时，这一点将更加明显。
- en: Unlike other components so far, this component won’t be called from a parent’s
    template. But we will need to pass it an input for the data, so we still need
    to declare the input property.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止的其他组件不同，这个组件将不会从父模板中调用。但我们需要传递一个数据输入给它，所以我们仍然需要声明输入属性。
- en: Now we need the template to make the component functional. Open src/app/nodes-detail/nodes-detail.component.html
    and replace the existing code with the following listing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要模板来使组件功能化。打开 src/app/nodes-detail/nodes-detail.component.html，并用以下列表替换现有的代码。
- en: '**Listing 5.6** Nodes Detail component template'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 5.6** 节点详情组件模板'
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There’s a lot of markup here needed for the display of a modal with bootstrap’s
    CSS styling, but it has a modal header with a title and close button and a body
    containing two Metric components. Notice that we can use any components that have
    been registered with our Application module inside of a dynamic component, which
    is handy.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有很多标记需要用于显示带有 Bootstrap CSS 样式的模态框，但它有一个包含标题和关闭按钮的模态框头部，以及包含两个度量组件的主体。请注意，我们可以在动态组件内部使用任何已注册到我们的应用程序模块中的组件，这很方便。
- en: Remember in our controller we had a property named `activeModal`, and it was
    an instance of the NgbActiveModal service. We use that in the template to call
    the `dismiss` method, which will close the modal itself. This is why we included
    that property in our controller. You can also see how the `node` property, which
    is our only input binding, is used to display data or pass data into the other
    components.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在我们的控制器中有一个名为 `activeModal` 的属性，它是一个 NgbActiveModal 服务的实例。我们在模板中使用它来调用 `dismiss`
    方法，这将关闭模态框本身。这就是为什么我们在控制器中包含了这个属性。您还可以看到 `node` 属性，这是我们的唯一输入绑定，它被用来显示数据或将数据传递到其他组件。
- en: 'The contents of this component are fairly similar to the rest of the application,
    so we don’t need to spend time on it. What we’re now interested in is how to trigger
    the modal to open from the Nodes Row component. Open the src/app/nodes-row/nodes-row.component.html
    file and add the following event binding to the button:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的内容与应用程序的其他部分相当相似，所以我们不需要在上面花费时间。我们现在感兴趣的是如何从 Nodes Row 组件触发模态的打开。打开 `src/app/nodes-row/nodes-row.component.html`
    文件，并在按钮中添加以下事件绑定：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we need to open src/app/nodes-row/nodes-row.component.ts and implement this
    new method. The code in the following listing contains the updated controller,
    and changes are annotated for you.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要打开 `src/app/nodes-row/nodes-row.component.ts` 并实现这个新方法。以下列表中的代码包含了更新的控制器，并且变更已经为您标注。
- en: '**Listing 5.7** Nodes Row component template additions for modal'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 5.7**  Nodes Row 组件模板中添加的模态'
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we import the NgbModal service that will allow us to create a new modal.
    We saw the NgbActiveModal service in the Nodes Detail component, which, once the
    modal and its component has been created, will allow the Nodes Detail component
    to reference the active modal instance. We need to import the Nodes Detail component
    as well. The constructor also sets the `modalService` property with an instance
    of the NgbModal service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入 NgbModal 服务，这将允许我们创建一个新的模态。我们在 Nodes Detail 组件中看到了 NgbActiveModal 服务，一旦模态及其组件被创建，它将允许
    Nodes Detail 组件引用活动的模态实例。我们还需要导入 Nodes Detail 组件。构造函数还将 `modalService` 属性设置为 NgbModal
    服务的实例。
- en: In the `open()` method, we pass in a reference to the node data to use. Then
    we create a new modal instance using the `modalService`, which takes as a parameter
    the component to be rendered in the modal. It stores a reference to this newly
    created component in the `componentInstance` property, which allows us to set
    the `node` input binding that was passed in during the click.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `open()` 方法中，我们传递一个节点数据的引用以供使用。然后我们使用 `modalService` 创建一个新的模态实例，该实例将渲染的组件作为参数。它将新创建的组件的引用存储在
    `componentInstance` 属性中，这使得我们可以设置在点击时传入的 `node` 输入绑定。
- en: That wires up all we need to trigger the modal from the Nodes Row component.
    But if you try it, the modal doesn’t work quite yet because there are a few minor
    details we need to implement that will allow us to open this modal.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就连接了我们触发模态所需的所有内容。但是，如果您尝试它，模态可能还不会正常工作，因为还有一些小的细节需要实现，这将允许我们打开这个模态。
- en: 'First, open the src/app/dashboard/dashboard.component.html file and add the
    following code line to the bottom of the template—we need to give the Modal service
    a place to render the component:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `src/app/dashboard/dashboard.component.html` 文件，并在模板底部添加以下代码行——我们需要为 Modal
    服务提供一个渲染组件的位置：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is a placeholder template element that has the NgbModalContainer directive
    on it, which tells Ng-bootstrap where in the template to render this component.
    Components have to be rendered somewhere in the template, and this is Ng-bootstrap’s
    way of defining the location to render.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个占位符模板元素，它上面有 NgbModalContainer 指令，这告诉 Ng-bootstrap 在模板中的哪个位置渲染此组件。组件必须在模板的某个位置进行渲染，这是
    Ng-bootstrap 定义渲染位置的方式。
- en: 'Secondly, we need to add a new entry to our App module. When the CLI processes
    Angular, it needs to know what components might be rendered dynamically because
    it will process them differently. Open the src/app/app.module.ts file and add
    a new line to the NgModule decorator:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要向我们的 App 模块添加一个新的条目。当 CLI 处理 Angular 时，它需要知道可能被动态渲染的组件有哪些，因为它将不同地处理它们。打开
    `src/app/app.module.ts` 文件，并在 NgModule 装饰器中添加一行新内容：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Entry components are any components that need to be rendered dynamically in
    the browser, which will also include components that are linked to routes (more
    on this in chapter 7). The CLI will try to optimize components by default and
    not include the component factory class. But to dynamically render, the component
    factory class is needed to render, so this tells the CLI compiler how to properly
    process it during build time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 条目组件是指需要在浏览器中动态渲染的任何组件，这还包括与路由链接的组件（关于这一点将在第 7 章中详细介绍）。CLI 默认会尝试优化组件，并且不包含组件工厂类。但是，为了动态渲染，需要组件工厂类来渲染，因此这告诉
    CLI 编译器如何在构建时正确处理它。
- en: This example is a bit specific for Ng-bootstrap’s implementation of the modal,
    so it will only get us so far in understanding how to build our own dynamic components.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子对于 Ng-bootstrap 的模态实现来说有点具体，所以它只能让我们对如何构建自己的动态组件有有限的了解。
- en: 5.4.2 Dynamically creating a component and rendering it
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 动态创建组件并渲染
- en: The Ng-bootstrap modal example is a nice way to create a modal, but it abstracts
    some of the capability away from us. We want to see how it works directly and
    will build upon the knowledge of our components that we have so far to create
    our own dynamically rendered component.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Ng-bootstrap模态示例是一个创建模态的好方法，但它抽象了一些能力。我们想直接看到它是如何工作的，并将基于我们到目前为止对组件的了解来创建我们自己的动态渲染组件。
- en: 'When we dynamically render a component, Angular needs a few things. It needs
    to know what component to render, where to render it, and where it can get a copy
    of it. This all happens during the compilation process for any template, but in
    this case we have no template and have to invoke the APIs ourselves. These are
    the Angular capabilities we’ll use to handle this process:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们动态渲染一个组件时，Angular需要一些东西。它需要知道要渲染哪个组件，在哪里渲染它，以及它可以从哪里获取它的副本。所有这些都在任何模板的编译过程中发生，但在这个情况下我们没有模板，必须自己调用API。我们将使用以下Angular功能来处理此过程：
- en: '`ViewContainerRef`—This is a reference to an element in the application that
    Angular understands and that gives us a reference point to where we can render
    our component.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewContainerRef`——这是对Angular理解的应用程序中元素的引用，它为我们提供了一个可以渲染组件的参考点。'
- en: '`ViewChild`—This will give us the ability to reference an element in our controller
    as a `ViewContainerRef` type, giving us access to APIs needed to render components.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewChild`——这将使我们能够将控制器中的元素引用为`ViewContainerRef`类型，从而获得渲染组件所需的API访问权限。'
- en: '`ComponentFactoryResolver`—An Angular service that gets us the component factory
    (which is needed to render) for any component that has been added to the entry
    components list.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComponentFactoryResolver`——这是一个Angular服务，它为我们提供任何已添加到入口组件列表中的组件的组件工厂（这是渲染所必需的）。'
- en: As we build our example, you’ll see these three capabilities working together.
    We’re going to build an alert box that appears when the data is refreshed and
    then removes itself after a certain amount of time. This will give us insight
    into how to dynamically render a component and remove it from the page, which
    accomplishes much the same thing as what you get from the Ng-bootstrap modal service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的示例时，您将看到这三个功能协同工作。我们将构建一个当数据刷新时出现的警告框，并在一段时间后自行消失。这将让我们了解如何动态渲染组件并将其从页面上删除，这与你从Ng-bootstrap模态服务中获得的效果非常相似。
- en: 'Start by generating a new component. From the CLI, run the following command
    to set up this new component:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成一个新的组件。从命令行运行以下命令来设置这个新组件：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The template for this component is going to be simple; it has some bootstrap-flavored
    markup that makes an alert box and binds the date of the last refresh. Open src/app/alert/alert.component.html
    and replace its contents with the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的模板将会很简单；它包含一些带有bootstrap风格的标记，用于创建一个警告框并绑定最后刷新的日期。打开src/app/alert/alert.component.html文件，并用以下内容替换其内容：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Likewise, the component controller is going to be empty except for a single
    input property. Open src/app/alert/alert.component.ts and replace its contents
    with the code from the following listing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，组件控制器将除了单个输入属性外为空。打开src/app/alert/alert.component.ts文件，并用以下列表中的代码替换其内容。
- en: '**Listing 5.8** Alert component controller'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 5.8**  警告组件控制器'
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So far, so good. There’s nothing special about this component that we haven’t
    already seen in this chapter, so I’m going to move to the next step. Because this
    component will be dynamically rendered, we need to add it to the list of `entryComponents`,
    so open up src/app/app.modules.ts again and add it to the list. At this point,
    our component itself is ready to be dynamically rendered:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。这个组件没有我们在这个章节中没有看到过的特殊之处，所以我将进入下一步。因为这个组件将会被动态渲染，我们需要将其添加到`entryComponents`列表中，所以再次打开src/app/app.modules.ts文件，并将其添加到列表中。到这一点，我们的组件本身已经准备好被动态渲染了：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can start to work on the mechanics that will trigger the rendering of
    the component out to the screen. As with the modal example, we’ll need to create
    a template element in our application that can be used to render out, so open
    the src/app/dashboard/dashboard.component.html file and update it to have the
    following template:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始工作，触发组件在屏幕上渲染的机制。与模态示例类似，我们需要在我们的应用程序中创建一个模板元素，以便用于渲染，因此打开src/app/dashboard/dashboard.component.html文件，并更新它以包含以下模板：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `#alertBox` attribute is another template local variable that we can use
    to identify this element later on. This will be the element that we render the
    component alongside. Open up the src/app/app.component.ts file and replace it
    with the code from the following listing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`#alertBox` 属性是另一个模板局部变量，我们可以用它来稍后识别这个元素。这将是我们渲染组件旁边的元素。打开 src/app/app.component.ts
    文件，并用以下列表中的代码替换它。'
- en: '**Listing 5.9** App component controller'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 5.9**  应用程序组件控制器'
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This might look complicated at first, so let’s break it down. It’s fairly plain
    how it’s working and constructed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来很复杂，所以让我们分解一下。它的工作方式和构造方式相当简单。
- en: First we must import a few additional objects, and we’ll look at their roles
    as we go along. We also import the Alert component itself so we can properly reference
    it during rendering.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须导入一些额外的对象，我们将在进行过程中查看它们的角色。我们还导入了 Alert 组件本身，这样我们就可以在渲染期间正确地引用它。
- en: We then add two properties, with `alertRef` being a component reference to the
    Alert component (which is the declared typing). We will want to have this reference
    so we can keep track of the alert and later remove it if we want. The second property
    is another View Child, called `alertBox`. The ViewChild syntax is different because
    it allows us to pass in a string to reference a local template variable by that
    name and then “read” it as a particular type of entity—in this case, a `ViewContainerRef`.
    It will get the element based on the template variable and then parse it as a
    `ViewContainerRef` type. This will give us access to a critical API shortly. These
    are only properties, though. So far, nothing has been instantiated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加两个属性，`alertRef` 是指向 Alert 组件的组件引用（这是声明的类型）。我们希望有这个引用，这样我们就可以跟踪警报，并在需要时将其删除。第二个属性是另一个视图子组件，称为
    `alertBox`。`ViewChild` 语法不同，因为它允许我们传入一个字符串来通过该名称引用一个本地模板变量，然后“读取”它作为特定类型的实体——在这种情况下，是一个
    `ViewContainerRef`。它将根据模板变量获取元素，并将其解析为 `ViewContainerRef` 类型。这将使我们能够访问一个关键的 API。这些只是属性，到目前为止，还没有实例化。
- en: The constructor sets the `ComponentFactoryResolver` property to the Factory
    Resolver service, which is what we’ll need in order to look up a copy of the component
    factory class before rendering it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将 `ComponentFactoryResolver` 属性设置为工厂解析器服务，这是我们渲染组件之前查找组件工厂类副本所需的。
- en: The primary magic of this occurs inside the `alert()` method. We’ll walk through
    this line by line. First, it looks to see if there is already something stored
    on the `alertRef` (meaning the Alert component has already been created), and
    if so it skips past the creation of another alert and moves on to update the binding.
    But if no Alert component exists yet, it uses the `ComponentFactoryResolver.resolveComponentFactory()`
    method to get an instance of the component factory (it seems a bit redundant,
    but it’s the API name). At this point, the component will be available in its
    raw form (not yet rendered).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要魔法发生在 `alert()` 方法内部。我们将逐行分析。首先，它检查是否已经在 `alertRef` 上存储了某些内容（这意味着 Alert
    组件已经被创建），如果是这样，它就会跳过创建另一个警报，并继续更新绑定。但是，如果还没有 Alert 组件，它就使用 `ComponentFactoryResolver.resolveComponentFactory()`
    方法来获取组件工厂的实例（这似乎有点多余，但这是 API 名称）。此时，组件将以原始形式（尚未渲染）可用。
- en: The next line uses the `alertBox` to create the component from the factory instance
    we received previously. Remember, `alertBox` is the instance of the element where
    we will inject the component, wrapped in a `ViewContainerRef` instance. At this
    point, the component will be rendered into the template where the template element
    was declared.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用 `alertBox` 从我们之前收到的工厂实例创建组件。记住，`alertBox` 是我们将注入组件的元素的实例，它被 `ViewContainerRef`
    实例包装。此时，组件将被渲染到声明模板元素的模板中。
- en: The next two lines (outside of the conditional) set the binding data for the
    component and then trigger change detection to run. Because we changed binding
    data manually, we need to alert Angular to check something (this was asynchronous
    from Angular’s typical rendering process!).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行（在条件之外）设置了组件的绑定数据，然后触发变更检测以运行。因为我们手动更改了绑定数据，所以我们需要通知 Angular 检查某些内容（这不同于
    Angular 的典型渲染过程！）。
- en: Lastly, a timeout is set to call the `deleteAlert` method after five seconds
    so the alert doesn’t remain on the screen forever. If we look at this method more
    closely, you can see it will check if there is an existing instance of an Alert
    component. If so, it will use the `destroy()` method that all components have
    to remove it from the page.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置一个超时，在五秒后调用`deleteAlert`方法，这样警报就不会永远留在屏幕上。如果我们更仔细地查看这个方法，你可以看到它将检查是否存在警报组件的现有实例。如果是的话，它将使用所有组件都有的`destroy()`方法将其从页面上移除。
- en: If you’re trying to run this example, you’ll find it doesn’t work yet. We’ve
    missed an important step! Nowhere do we call the App component’s `alert()` method,
    so it won’t appear. To do that, we’ll emit an event from the Dashboard component
    that will fire when data is generated, along with the timestamp when it was updated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行这个示例，你会发现它还没有工作。我们遗漏了一个重要的步骤！我们没有任何地方调用应用程序组件的`alert()`方法，所以它不会出现。为了做到这一点，我们将从仪表板组件中发出一个事件，当数据生成时触发，同时附带更新时的戳记。
- en: 'Open up src/app/dashboard/dashboard.component.ts. We’re going to add a new
    output event. Be sure to import the `Output` and `EventEmitter` objects at the
    top of the file. Then add a new property like you see here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/app/dashboard/dashboard.component.ts`。我们将添加一个新的输出事件。确保在文件顶部导入`Output`和`EventEmitter`对象。然后添加一个新属性，就像你在这里看到的那样：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now inside the `generateData()` method add this line to the end of the method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`generateData()`方法中，将此行添加到方法末尾：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This sets up a new output event from the Dashboard component, and this time
    we’re passing some data during the emit phase. We can capture this information
    in the App component and use it to pass into our Alert component. This is simple
    now—all we have to do is update the src/app/app.component.html file one more time
    by adding an event binding to the Dashboard component:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这在仪表板组件中设置了一个新的输出事件，并且这次我们在发射阶段传递了一些数据。我们可以在应用程序组件中捕获这些信息，并将其传递给我们的警报组件。现在这很简单——我们只需要再次更新`src/app/app.component.html`文件，通过添加一个事件绑定到仪表板组件：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Voila! Our Alert component should now appear after every data generation event,
    regardless of whether you click the button in the top right or wait 15 seconds
    for it to automatically regenerate. It will also automatically close the alert
    after five seconds.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的警报组件现在应该在每次数据生成事件后出现，无论你是否点击右上角的按钮，还是等待15秒自动重新生成。它还会在五秒后自动关闭警报。
- en: That was a whirlwind tour of dynamic components. There are several different
    ways to generate a component besides this one, but this is a solid approach that
    you can use in your own applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对动态组件的一次快速浏览。除了这种方法之外，还有几种不同的方法可以生成组件，但这是一个你可以用在你的应用程序中的可靠方法。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We’ve been busy in this chapter. We covered a lot of content about components,
    how they work, their various capabilities, and much more. Here’s what we talked
    about in this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中非常忙碌。我们涵盖了关于组件的大量内容，包括它们的工作原理、各种功能以及更多。以下是本章中我们讨论的内容：
- en: We looked at change detection in more detail, along with how to leverage the
    OnPush mode to better optimize when a component is rendered.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更详细地研究了变更检测，以及如何利用`OnPush`模式更好地优化组件渲染时的性能。
- en: 'We looked at several lifecycle event handlers. There are a number of other
    ones that have their own use cases as well:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了几个生命周期事件处理器。还有许多其他的事件处理器，它们也有自己的用例：
- en: The OnInit lifecycle hook fires only once after the constructor and when the
    input properties are available.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInit`生命周期钩子在构造函数之后以及输入属性可用时只触发一次。'
- en: The OnChanges lifecycle hook fires whenever an input property changes.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnChanges`生命周期钩子在输入属性更改时触发。'
- en: The OnDestroy lifecycle hook fires whenever a component is about to be removed
    from the page.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`生命周期钩子在组件即将从页面上移除时触发。'
- en: We talked about how to communicate between components using output properties
    and the built-in `EventEmitter`, and how to reference child components as a View
    Child.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了如何使用输出属性和内置的`EventEmitter`在组件之间进行通信，以及如何将子组件作为视图子组件引用。
- en: We talked about the styling of components using CSS in various ways and how
    different encapsulation modes can affect the way that content is rendered on the
    page.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了使用CSS对组件进行样式设计，以及不同的封装模式如何影响页面上的内容渲染方式。
- en: We finished by looking at how to render out components dynamically, with two
    examples. The first was a prebuilt service using the Ng-bootstrap modal service
    to render our component on demand, whereas the second was managed entirely by
    us.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过两个示例来结束本次讨论，展示了如何动态渲染组件。第一个示例是一个预构建的服务，使用 Ng-bootstrap 模态服务按需渲染我们的组件，而第二个示例则完全由我们自行管理。
