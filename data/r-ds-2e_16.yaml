- en: Chapter 13\. Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 数字
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Numeric vectors are the backbone of data science, and you’ve already used them
    a bunch of times earlier in the book. Now it’s time to systematically survey what
    you can do with them in R, ensuring that you’re well situated to tackle any future
    problem involving numeric vectors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数值向量是数据科学的支柱，你已经在本书的前面多次使用过它们。现在是时候系统地调查你在R中可以用它们做什么，以确保你能够很好地解决涉及数值向量的任何未来问题。
- en: We’ll start by giving you a couple of tools to make numbers if you have strings
    and then go into a little more detail on [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml).
    Then we’ll dive into various numeric transformations that pair well with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml),
    including more general transformations that can be applied to other types of vectors
    but are often used with numeric vectors. We’ll finish off by covering the summary
    functions that pair well with [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    and show you how they can also be used with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从几个工具开始，如果你有字符串，可以将它们转换为数字，然后更详细地讨论[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)。接下来，我们将深入探讨与[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)配对的各种数字转换，包括更一般的转换，这些转换可以应用于其他类型的向量，但通常与数字向量一起使用。最后，我们将介绍与[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)配对良好的汇总函数，并展示它们如何与[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)一起使用。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: This chapter mostly uses functions from base R, which are available without
    loading any packages. But we still need the tidyverse because we’ll use these
    base R functions inside of tidyverse functions such as [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    and [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml). Like in
    the previous chapter, we’ll use real examples from nycflights13, as well as toy
    examples made with [`c()`](https://rdrr.io/r/base/c.xhtml) and [`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要使用基本的R函数，这些函数无需加载任何包。但我们仍然需要tidyverse，因为我们将在tidyverse函数内部使用这些基本的R函数，比如[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)和[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)。就像在上一章中一样，我们将使用来自nycflights13的真实示例，以及使用[`c()`](https://rdrr.io/r/base/c.xhtml)和[`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml)创建的玩具示例。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Making Numbers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作数字
- en: 'In most cases, you’ll get numbers already recorded in one of R’s numeric types:
    integer or double. In some cases, however, you’ll encounter them as strings, possibly
    because you’ve created them by pivoting from column headers or because something
    has gone wrong in your data import process.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你将得到已记录在R的数值类型（整数或双精度）中的数字。然而，在某些情况下，你可能会遇到它们作为字符串，可能是因为你通过列标题进行了旋转，或者是因为在数据导入过程中出了问题。
- en: 'readr provides two useful functions for parsing strings into numbers: [`parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    and [`parse_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml).
    Use [`parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    when you have numbers that have been written as strings:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: readr提供了两个将字符串解析为数字的有用函数：[`parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)和[`parse_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)。当你有以字符串形式编写的数字时，请使用[`parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use [`parse_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)
    when the string contains non-numeric text that you want to ignore. This is particularly
    useful for currency data and percentages:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串包含你想要忽略的非数值文本时，请使用[`parse_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)。这对货币数据和百分比特别有用：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Counts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数
- en: 'It’s surprising how much data science you can do with just counts and a little
    basic arithmetic, so dplyr strives to make counting as easy as possible with [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml).
    This function is great for quick exploration and checks during analysis:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过计数和一点基本算术，你可以做多少数据科学工作，所以dplyr致力于通过[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)尽可能地简化计数。这个函数非常适合在分析过程中进行快速探索和检查：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (Despite the advice in [Chapter 4](ch04.xhtml#chp-workflow-style), we usually
    put [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml) on a single
    line because it’s usually used at the console for a quick check that a calculation
    is working as expected.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: （尽管在[第四章](ch04.xhtml#chp-workflow-style)中的建议中，我们通常将[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)放在单行上，因为它通常用于控制台，用于快速检查计算是否按预期工作。）
- en: 'If you want to see the most common values, add `sort = TRUE`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看最常见的值，请添加`sort = TRUE`：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And remember that if you want to see all the values, you can use `|> View()`
    or `|> print(n = Inf)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的是，如果想查看所有的值，可以使用`|> View()`或`|> print(n = Inf)`。
- en: 'You can perform the same computation “by hand” with [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml),
    [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml), and [`n()`](https://dplyr.tidyverse.org/reference/context.xhtml).
    This is useful because it allows you to compute other summaries at the same time:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)、[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)和[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)手动执行相同的计算。这很有用，因为它允许您同时计算其他摘要信息：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml) is a special summary
    function that doesn’t take any arguments and instead accesses information about
    the “current” group. This means that it works only inside dplyr verbs:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)是一个特殊的汇总函数，不接受任何参数，而是访问有关“当前”组的信息。这意味着它仅在dplyr动词内部工作：'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are a couple of variants of [`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)
    and [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml) that you might
    find useful:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[`n()`](https://dplyr.tidyverse.org/reference/context.xhtml)和[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)有几个变体可能对您有用：'
- en: '`n_distinct(x)` counts the number of distinct (unique) values of one or more
    variables. For example, we could figure out which destinations are served by the
    most carriers:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_distinct(x)`计算一个或多个变量的不同（唯一）值的数量。例如，我们可以弄清楚哪些目的地由最多的航空公司服务：'
- en: '[PRE7]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A weighted count is a sum. For example, you could “count” the number of miles
    each plane flew:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加权计数是一个总和。例如，您可以“计算”每架飞机飞行的英里数：
- en: '[PRE8]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Weighted counts are a common problem, so [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)
    has a `wt` argument that does the same thing:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加权计数是一个常见的问题，因此[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)具有`wt`参数，执行相同的操作：
- en: '[PRE9]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can count missing values by combining [`sum()`](https://rdrr.io/r/base/sum.xhtml)
    and [`is.na()`](https://rdrr.io/r/base/NA.xhtml). In the `flights` dataset this
    represents flights that are cancelled:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合[`sum()`](https://rdrr.io/r/base/sum.xhtml)和[`is.na()`](https://rdrr.io/r/base/NA.xhtml)，可以统计缺失值。在`flights`数据集中，这表示取消的航班：
- en: '[PRE10]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Exercises
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: How can you use [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)
    to count the number rows with a missing value for a given variable?
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何使用[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)计算具有给定变量的缺失值的行数？
- en: 'Expand the following calls to [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)
    to instead use [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml),
    [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml), and [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml):'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下对[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)的调用扩展为使用[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)、[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)和[`arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)：
- en: '`flights |> count(dest, sort = TRUE)`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flights |> count(dest, sort = TRUE)`'
- en: '`flights |> count(tailnum, wt = distance)`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flights |> count(tailnum, wt = distance)`'
- en: Numeric Transformations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值转换
- en: Transformation functions work well with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    because their output is the same length as the input. The vast majority of transformation
    functions are already built into base R. It’s impractical to list them all, so
    this section will show the most useful ones. As an example, while R provides all
    the trigonometric functions that you might dream of, we don’t list them here because
    they’re rarely needed for data science.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 转换函数与[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)很搭配，因为它们的输出与输入长度相同。绝大多数转换函数已经内置在基础R中。列出它们是不切实际的，因此本节将展示最有用的函数。例如，虽然R提供了您可能梦想的所有三角函数，但我们在这里没有列出它们，因为在数据科学中很少需要它们。
- en: Arithmetic and Recycling Rules
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术和循环规则
- en: We introduced the basics of arithmetic (`+`, `-`, `*`, `/`, `^`) in [Chapter 2](ch02.xhtml#chp-workflow-basics)
    and have used them a bunch since. These functions don’t need a huge amount of
    explanation because they do what you learned in grade school. But we need to briefly
    talk about the *recycling rules*, which determine what happens when the left and
    right sides have different lengths. This is important for operations like `flights
    |> mutate(air_time = air_time / 60)` because there are 336,776 numbers on the
    left of `/` but only one on the right.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.xhtml#chp-workflow-basics)中介绍了算术的基础（`+`, `-`, `*`, `/`, `^`），并在之后的很多地方使用过它们。这些函数不需要太多的解释，因为它们就是你在小学学到的内容。但我们需要简要谈谈*循环规则*，这些规则决定了当左右两侧的长度不同时会发生什么。这对于像
    `flights |> mutate(air_time = air_time / 60)` 这样的操作非常重要，因为左侧有336,776个数字，但右侧只有1个。
- en: 'R handles mismatched lengths by *recycling*, or repeating, the short vector.
    We can see this in operation more easily if we create some vectors outside of
    a data frame:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: R 通过 *循环* 或重复来处理不匹配的长度。如果我们在数据框之外创建一些向量，我们可以更容易地看到它的运作方式：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Generally, you want to recycle only single numbers (i.e., vectors of length
    1), but R will recycle any shorter length vector. It usually (but not always)
    gives you a warning if the longer vector isn’t a multiple of the shorter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你只想要循环单个数字（即长度为1的向量），但 R 会循环任何较短的向量。如果较长的向量不是较短向量的整数倍，通常（但不总是）会给出一个警告：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These recycling rules are also applied to logical comparisons (`==`, `<`, `<=`,
    `>`, `>=`, `!=`) and can lead to a surprising result if you accidentally use `==`
    instead of `%in%` and the data frame has an unfortunate number of rows. For example,
    take this code, which attempts to find all flights in January and February:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环规则也适用于逻辑比较（`==`, `<`, `<=`, `>`, `>=`, `!=`），如果你意外地使用 `==` 而不是 `%in%`，并且数据框的行数不恰当，可能会导致令人惊讶的结果。例如，看下这段代码，试图找出所有一月和二月的航班：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code runs without error, but it doesn’t return what you want. Because of
    the recycling rules, it finds flights in odd-numbered rows that departed in January
    and flights in even numbered rows that departed in February. Unfortunately, there’s
    no warning because `flights` has an even number of rows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以无误地运行，但它并没有返回你想要的结果。因为循环规则的存在，它会找到奇数行中在一月出发的航班和偶数行中在二月出发的航班。不幸的是，由于 `flights`
    有偶数行，所以并不会有任何警告。
- en: To protect you from this type of silent failure, most tidyverse functions use
    a stricter form of recycling that recycles only single values. Unfortunately,
    that doesn’t help here, or in many other cases, because the key computation is
    performed by the base R function `==`, not [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护你免受这种无声失败，大多数 tidyverse 函数使用一种更严格的循环形式，只会循环单个值。不幸的是，在这里或其他许多情况下，这并没有起到作用，因为关键的计算是由基本的
    R 函数 `==` 而不是 [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)
    执行的。
- en: Minimum and Maximum
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小值和最大值
- en: 'The arithmetic functions work with pairs of variables. Two closely related
    functions are [`pmin()`](https://rdrr.io/r/base/Extremes.xhtml) and [`pmax()`](https://rdrr.io/r/base/Extremes.xhtml),
    which when given two or more variables will return the smallest or largest value
    in each row:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 算术函数可以使用变量对。两个密切相关的函数是 [`pmin()`](https://rdrr.io/r/base/Extremes.xhtml) 和 [`pmax()`](https://rdrr.io/r/base/Extremes.xhtml)，当给定两个或多个变量时，它们将返回每行中的最小值或最大值：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that these are different from the summary functions [`min()`](https://rdrr.io/r/base/Extremes.xhtml)
    and [`max()`](https://rdrr.io/r/base/Extremes.xhtml), which take multiple observations
    and return a single value. You can tell that you’ve used the wrong form when all
    the minimums and all the maximums have the same value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些函数与 [`min()`](https://rdrr.io/r/base/Extremes.xhtml) 和 [`max()`](https://rdrr.io/r/base/Extremes.xhtml)
    这些汇总函数不同，后者取多个观察值并返回一个值。如果所有的最小值和最大值都相同，那么你可以知道已经选择了错误的形式：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Modular Arithmetic
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模运算
- en: 'Modular arithmetic is the technical name for the type of math you did before
    you learned about decimal places, i.e., division that yields a whole number and
    a remainder. In R, `%/%` does integer division, and `%%` computes the remainder:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算是你在学习小数位之前所做的数学的技术名称，即能够得到一个整数和余数的除法。在 R 语言中，`%/%` 执行整数除法，而 `%%` 计算余数：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Modular arithmetic is handy for the `flights` dataset, because we can use it
    to unpack the `sched_dep_time` variable into `hour` and `minute`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `flights` 数据集来说，模运算对于解压 `sched_dep_time` 变量为 `hour` 和 `minute` 很方便：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can combine that with the `mean(is.na(x))` trick from [“Summaries”](ch12.xhtml#sec-logical-summaries)
    to see how the proportion of cancelled flights varies over the course of the day.
    The results are shown in [Figure 13-1](#fig-prop-cancelled).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其与[“总结”](ch12.xhtml#sec-logical-summaries)中的`mean(is.na(x))`技巧结合起来，以查看一天中取消航班的比例如何变化。结果显示在[图 13-1](#fig-prop-cancelled)中。
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![A line plot showing how proportion of cancelled flights changes over the
    course of the day. The proportion starts low at around 0.5% at 6 a.m., then steadily
    increases over the course of the day until peaking at 4% at 7 p.m. The proportion
    of cancelled flights then drops rapidly getting down to around 1% by midnight.](assets/rds2_1301.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![一条折线图显示一天中取消航班比例的变化。这个比例从早上6点的约0.5%开始，然后在一天的过程中稳步增加，直到晚上7点的4%左右。然后，取消航班的比例迅速下降，到午夜左右约为1%。](assets/rds2_1301.png)'
- en: Figure 13-1\. A line plot with scheduled departure hour on the x-axis, and proportion
    of cancelled flights on the y-axis. Cancellations seem to accumulate over the
    course of the day until 8 p.m., and very late flights are much less likely to
    be cancelled.
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-1\. 一条折线图，x 轴为计划出发小时，y 轴为取消航班的比例。取消似乎随着一天的进行而累积，直到晚上8点，而非常晚的航班则取消的可能性要小得多。
- en: Logarithms
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数
- en: 'Logarithms are an incredibly useful transformation for dealing with data that
    ranges across multiple orders of magnitude and for converting exponential growth
    to linear growth. In R, you have a choice of three logarithms: [`log()`](https://rdrr.io/r/base/Log.xhtml)
    (the natural log, base e), [`log2()`](https://rdrr.io/r/base/Log.xhtml) (base
    2), and [`log10()`](https://rdrr.io/r/base/Log.xhtml) (base 10). We recommend
    using [`log2()`](https://rdrr.io/r/base/Log.xhtml) or [`log10()`](https://rdrr.io/r/base/Log.xhtml).
    [`log2()`](https://rdrr.io/r/base/Log.xhtml) is easy to interpret because a difference
    of 1 on the log scale corresponds to doubling on the original scale, and a difference
    of -1 corresponds to halving, whereas [`log10()`](https://rdrr.io/r/base/Log.xhtml)
    is easy to back-transform because, for example, 3 is 10^3 = 1000\. The inverse
    of [`log()`](https://rdrr.io/r/base/Log.xhtml) is [`exp()`](https://rdrr.io/r/base/Log.xhtml);
    to compute the inverse of [`log2()`](https://rdrr.io/r/base/Log.xhtml) or [`log10()`](https://rdrr.io/r/base/Log.xhtml),
    you’ll need to use `2^` or `10^`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对数是处理跨越多个数量级的数据和将指数增长转换为线性增长的非常有用的转换。在 R 中，您可以选择三种对数：[`log()`](https://rdrr.io/r/base/Log.xhtml)（自然对数，以e为底），[`log2()`](https://rdrr.io/r/base/Log.xhtml)（以2为底），以及[`log10()`](https://rdrr.io/r/base/Log.xhtml)（以10为底）。我们推荐使用[`log2()`](https://rdrr.io/r/base/Log.xhtml)或[`log10()`](https://rdrr.io/r/base/Log.xhtml)。[`log2()`](https://rdrr.io/r/base/Log.xhtml)易于解释，因为对数尺度上的1的差异对应于原始尺度上的加倍，-1的差异对应于减半，而[`log10()`](https://rdrr.io/r/base/Log.xhtml)易于反向转换，例如，3是10^3
    = 1000。[`log()`](https://rdrr.io/r/base/Log.xhtml)的反函数是[`exp()`](https://rdrr.io/r/base/Log.xhtml)；要计算[`log2()`](https://rdrr.io/r/base/Log.xhtml)或[`log10()`](https://rdrr.io/r/base/Log.xhtml)的反函数，您需要使用`2^`或`10^`。
- en: Rounding
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 舍入
- en: 'Use `round(x)` to round a number to the nearest integer:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`round(x)`将数字舍入到最近的整数：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can control the precision of the rounding with the second argument, `digits`.
    `round(x, digits)` rounds to the nearest `10^-n`, so `digits = 2` will round to
    the nearest 0.01\. This definition is useful because it implies `round(x, -3)`
    will round to the nearest thousand, which indeed it does:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用第二个参数`digits`来控制舍入的精度。`round(x, digits)`会舍入到最近的`10^-n`，因此`digits = 2`将会舍入到最近的0.01。这个定义很有用，因为它意味着`round(x,
    -3)`将会舍入到最近的千位数，实际上确实是这样：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There’s one weirdness with [`round()`](https://rdrr.io/r/base/Round.xhtml)
    that seems surprising at first glance:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[`round()`](https://rdrr.io/r/base/Round.xhtml) 在第一次看起来似乎有些奇怪：'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[`round()`](https://rdrr.io/r/base/Round.xhtml) uses what’s known as “round
    half to even” or Banker’s rounding: if a number is halfway between two integers,
    it will be rounded to the *even* integer. This is a good strategy because it keeps
    the rounding unbiased: half of all 0.5s are rounded up, and half are rounded down.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[`round()`](https://rdrr.io/r/base/Round.xhtml) 使用的是“四舍五入到偶数”或“银行家舍入”：如果一个数字正好处于两个整数之间，它将被舍入到*偶数*整数。这是一个很好的策略，因为它保持了舍入的公正性：所有的0.5都会被舍入为上整数和下整数的一半。'
- en: '[`round()`](https://rdrr.io/r/base/Round.xhtml) is paired with [`floor()`](https://rdrr.io/r/base/Round.xhtml),
    which always rounds down, and [`ceiling()`](https://rdrr.io/r/base/Round.xhtml),
    which always rounds up:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[`round()`](https://rdrr.io/r/base/Round.xhtml) 与[`floor()`](https://rdrr.io/r/base/Round.xhtml)（总是向下舍入）和[`ceiling()`](https://rdrr.io/r/base/Round.xhtml)（总是向上舍入）配对使用：'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These functions don’t have a `digits` argument, so you can instead scale down,
    round, and then scale back up:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数没有`digits`参数，因此您可以缩小、四舍五入，然后再放大：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use the same technique if you want to [`round()`](https://oreil.ly/YcbwN)
    to a multiple of some other number:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对一个数四舍五入到另一个数的倍数，可以使用相同的技巧：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Cutting Numbers into Ranges
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数字切割成范围
- en: 'Use [`cut()`](https://rdrr.io/r/base/cut.xhtml)^([1](ch13.xhtml#idm44771298681152))
    to break up (aka *bin*) a numeric vector into discrete buckets:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`cut()`](https://rdrr.io/r/base/cut.xhtml)^([1](ch13.xhtml#idm44771298681152))将数值向量分成离散的桶（又称*bin*）：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The breaks don’t need to be evenly spaced:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 断点不需要均匀间隔：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can optionally supply your own `labels`. Note that there should be one less
    `labels` than `breaks`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择提供自己的`labels`。注意`labels`应比`breaks`少一个。
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Any values outside of the range of the breaks will become `NA`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 超出断点范围的任何值将变为`NA`：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See the documentation for other useful arguments such as `right` and `include.lowest`,
    which control if the intervals are `[a, b)` or `(a, b]` and if the lowest interval
    should be `[a, b]`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其他有用参数的文档，例如`right`和`include.lowest`，它们控制间隔是`[a, b)`还是`(a, b]`以及最低间隔是否应为`[a,
    b]`。
- en: Cumulative and Rolling Aggregates
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 累积和滚动聚合
- en: 'Base R provides [`cumsum()`](https://rdrr.io/r/base/cumsum.xhtml), [`cumprod()`](https://rdrr.io/r/base/cumsum.xhtml),
    [`cummin()`](https://rdrr.io/r/base/cumsum.xhtml), and [`cummax()`](https://rdrr.io/r/base/cumsum.xhtml)
    for running, or cumulative, sums, products, and mins and maxes. dplyr provides
    [`cummean()`](https://dplyr.tidyverse.org/reference/cumall.xhtml) for cumulative
    means. Cumulative sums tend to come up the most in practice:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R提供[`cumsum()`](https://rdrr.io/r/base/cumsum.xhtml)，[`cumprod()`](https://rdrr.io/r/base/cumsum.xhtml)，[`cummin()`](https://rdrr.io/r/base/cumsum.xhtml)，以及[`cummax()`](https://rdrr.io/r/base/cumsum.xhtml)用于累积求和、乘积、最小值和最大值。dplyr提供[`cummean()`](https://dplyr.tidyverse.org/reference/cumall.xhtml)用于累积均值。累积求和在实践中经常出现：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you need more complex rolling or sliding aggregates, try the [slider package](https://oreil.ly/XPnjF).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更复杂的滚动或滑动聚合，请尝试[slider包](https://oreil.ly/XPnjF)。
- en: Exercises
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Explain in words what each line of the code used to generate [Figure 13-1](#fig-prop-cancelled)
    does.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释用于生成[图 13-1](#fig-prop-cancelled)的每行代码的功能。
- en: What trigonometric functions does R provide? Guess some names and look up the
    documentation. Do they use degrees or radians?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R提供哪些三角函数？猜测一些名称并查阅文档。它们使用角度还是弧度？
- en: 'Currently `dep_time` and `sched_dep_time` are convenient to look at but hard
    to compute with because they’re not really continuous numbers. You can see the
    basic problem by running the following code; there’s a gap between each hour:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前`dep_time`和`sched_dep_time`方便查看，但难以计算，因为它们不是真正的连续数。可以通过运行以下代码看到基本问题；每个小时之间存在间隙：
- en: '[PRE30]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Convert them to a more truthful representation of time (either fractional hours
    or minutes since midnight).
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将它们转换为更真实的时间表示（分数小时或自午夜以来的分钟）。
- en: Round `dep_time` and `arr_time` to the nearest five minutes.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dep_time`和`arr_time`四舍五入到最接近的五分钟。
- en: General Transformations
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般转换
- en: The following sections describe some general transformations that are often
    used with numeric vectors but can be applied to all other column types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分描述了一些通常用于数值向量的一般转换，但可以应用于所有其他列类型。
- en: Ranks
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等级
- en: dplyr provides a number of ranking functions inspired by SQL, but you should
    always start with [`dplyr::min_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml).
    It uses the typical method for dealing with ties, e.g., 1st, 2nd, 2nd, 4th.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr提供了许多受SQL启发的排名函数，但您应始终从[`dplyr::min_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml)开始。它使用处理并列的典型方法，例如，第1、第2、第2、第4。
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the smallest values get the lowest ranks; use `desc(x)` to give the
    largest values the smallest ranks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最小值获得最低的等级；使用`desc(x)`将最大值获得最小的等级：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If [`min_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml) doesn’t
    do what you need, look at the variants [`dplyr::row_number()`](https://dplyr.tidyverse.org/reference/row_number.xhtml),
    [`dplyr::dense_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml),
    [`dplyr::percent_rank()`](https://dplyr.tidyverse.org/reference/percent_rank.xhtml),
    and [`dplyr::cume_dist()`](https://dplyr.tidyverse.org/reference/percent_rank.xhtml).
    See the documentation for details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`min_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml) 不符合你的需求，请查看其变体
    [`dplyr::row_number()`](https://dplyr.tidyverse.org/reference/row_number.xhtml)，[`dplyr::dense_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml)，[`dplyr::percent_rank()`](https://dplyr.tidyverse.org/reference/percent_rank.xhtml)
    和 [`dplyr::cume_dist()`](https://dplyr.tidyverse.org/reference/percent_rank.xhtml)。详细信息请参阅文档。
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can achieve many of the same results by picking the appropriate `ties.method`
    argument to base R’s [`rank()`](https://rdrr.io/r/base/rank.xhtml); you’ll probably
    also want to set `na.last = "keep"` to keep `NA`s as `NA`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择适当的 `ties.method` 参数来实现与基础 R 的 [`rank()`](https://rdrr.io/r/base/rank.xhtml)
    类似的结果；你可能还希望设置 `na.last = "keep"` 来保留 `NA` 作为 `NA`。
- en: '[`row_number()`](https://dplyr.tidyverse.org/reference/row_number.xhtml) can
    also be used without any arguments when inside a dplyr verb. In this case, it’ll
    give the number of the “current” row. When combined with `%%` or `%/%`, this can
    be a useful tool for dividing data into similarly sized groups:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[`row_number()`](https://dplyr.tidyverse.org/reference/row_number.xhtml) 在
    dplyr 动词内部没有任何参数时也可以使用。在这种情况下，它将给出“当前”行的编号。与 `%%` 或 `%/%` 结合使用时，这对于将数据分成大小相似的组是一个有用的工具：'
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Offsets
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏移
- en: '[`dplyr::lead()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml) and
    [`dplyr::lag()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml) allow you
    to refer the values just before or just after the “current” value. They return
    a vector of the same length as the input, padded with `NA`s at the start or end:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[`dplyr::lead()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml) 和 [`dplyr::lag()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml)
    允许你引用“当前”值之前或之后的值。它们返回与输入相同长度的向量，在开头或结尾用 `NA` 填充：'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`x - lag(x)` gives you the difference between the current and previous value:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x - lag(x)` 给出当前值与前一个值之间的差异：'
- en: '[PRE36]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`x == lag(x)` tells you when the current value changes:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x == lag(x)` 告诉你当前值何时发生变化：'
- en: '[PRE37]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can lead or lag by more than one position by using the second argument,
    `n`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用第二个参数 `n` 来引导或滞后超过一个位置：
- en: Consecutive Identifiers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续标识符
- en: 'Sometimes you want to start a new group every time some event occurs. For example,
    when you’re looking at website data, it’s common to want to break up events into
    sessions, where you begin a new session after a gap of more than `x` minutes since
    the last activity. For example, imagine you have the times when someone visited
    a website:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望在某个事件发生时开始一个新的组。例如，在查看网站数据时，常常希望将事件分割成会话，即在距离上次活动超过 `x` 分钟的间隔后开始一个新会话。例如，假设你有访问网站时间的记录：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You’ve computed the time between each event and figured out if there’s a gap
    that’s big enough to qualify:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经计算了每个事件之间的时间，并找出是否存在足够大的间隙来满足条件：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But how do we go from that logical vector to something that we can [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)?
    [`cumsum()`](https://rdrr.io/r/base/cumsum.xhtml), from [“Cumulative and Rolling
    Aggregates”](#sec-cumulative-and-rolling-aggregates), comes to the rescue as gap,
    i.e., `has_gap` is `TRUE`, will increment `group` by one ([“Numeric Summaries
    of Logical Vectors”](ch12.xhtml#sec-numeric-summaries-of-logicals)):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如何将逻辑向量转换为可以 [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)
    的内容？[`cumsum()`](https://rdrr.io/r/base/cumsum.xhtml)，来自[“Cumulative and Rolling
    Aggregates”](#sec-cumulative-and-rolling-aggregates)，在存在间隙时，即 `has_gap` 为 `TRUE`
    时，将组递增一次（“Numeric Summaries of Logical Vectors”](ch12.xhtml#sec-numeric-summaries-of-logicals)）：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another approach for creating grouping variables is [`consecutive_id()`](https://dplyr.tidyverse.org/reference/consecutive_id.xhtml),
    which starts a new group every time one of its arguments changes. For example,
    inspired by [this StackOverflow question](https://oreil.ly/swerV), imagine you
    have a data frame with a bunch of repeated values:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分组变量的另一种方法是 [`consecutive_id()`](https://dplyr.tidyverse.org/reference/consecutive_id.xhtml)，它在其参数变化时开始一个新的组。例如，受[这个
    StackOverflow 问题](https://oreil.ly/swerV)的启发，假设你有一个包含大量重复值的数据框：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you want to keep the first row from each repeated `x`, you could use [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml),
    [`consecutive_id()`](https://dplyr.tidyverse.org/reference/consecutive_id.xhtml),
    and [`slice_head()`](https://dplyr.tidyverse.org/reference/slice.xhtml):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保留每个重复的`x`的第一行，可以使用[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml)、[`consecutive_id()`](https://dplyr.tidyverse.org/reference/consecutive_id.xhtml)和[`slice_head()`](https://dplyr.tidyverse.org/reference/slice.xhtml)：
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Exercises
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Find the 10 most delayed flights using a ranking function. How do you want to
    handle ties? Carefully read the documentation for [`min_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用排名函数找出延误最严重的10个航班。你想如何处理并列情况？仔细阅读[`min_rank()`](https://dplyr.tidyverse.org/reference/row_number.xhtml)的文档。
- en: Which plane (`tailnum`) has the worst on-time record?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪架飞机（`tailnum`）的准点记录最差？
- en: What time of day should you fly if you want to avoid delays as much as possible?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望尽可能避免延误，你应该在一天中的什么时段飞行？
- en: What does `flights |> group_by(dest) |> filter(row_number() < 4)` do? What does
    `flights |> group_by(dest) |> filter(row_number(dep_delay) < 4)` do?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flights |> group_by(dest) |> filter(row_number() < 4)`是什么意思？`flights |> group_by(dest)
    |> filter(row_number(dep_delay) < 4)`又是什么意思？'
- en: For each destination, compute the total minutes of delay. For each flight, compute
    the proportion of the total delay for its destination.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个目的地，计算延误的总分钟数。对于每次航班，计算其目的地总延误的比例。
- en: 'Delays are typically temporally correlated: even once the problem that caused
    the initial delay has been resolved, later flights are delayed to allow earlier
    flights to leave. Using [`lag()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml),
    explore how the average flight delay for an hour is related to the average delay
    for the previous hour.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延误通常具有时间相关性：即使解决了导致初始延误的问题，稍后的航班也会延误以便让早期的航班起飞。使用[`lag()`](https://dplyr.tidyverse.org/reference/lead-lag.xhtml)，探索每小时的平均航班延误与前一个小时的平均延误之间的关系。
- en: '[PRE43]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Look at each destination. Can you find flights that are suspiciously fast (i.e.,
    flights that represent a potential data entry error)? Compute the air time of
    a flight relative to the shortest flight to that destination. Which flights were
    most delayed in the air?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看每个目的地。你能找到那些飞行速度异常快的航班吗（即可能表示数据输入错误的航班）？计算每个目的地的航空时间相对于最短航班的情况。哪些航班在空中延误最严重？
- en: Find all destinations that are flown by at least two carriers. Use those destinations
    to come up with a relative ranking of the carriers based on their performance
    for the same destination.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所有由至少两家航空公司飞行的目的地。利用这些目的地来根据相同目的地的表现对航空公司进行相对排名。
- en: Numeric Summaries
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字摘要
- en: Just using the counts, means, and sums that we’ve introduced already can get
    you a long way, but R provides many other useful summary functions. Here is a
    selection that you might find useful.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用我们已经介绍过的计数、均值和求和就可以走得很远，但是R提供了许多其他有用的摘要函数。以下是一些你可能会发现有用的选择。
- en: Center
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心
- en: 'So far, we’ve mostly used [`mean()`](https://rdrr.io/r/base/mean.xhtml) to
    summarize the center of a vector of values. As we’ve seen in [“Case Study: Aggregates
    and Sample Size”](ch03.xhtml#sec-sample-size), because the mean is the sum divided
    by the count, it is sensitive to even just a few unusually high or low values.
    An alternative is to use the [`median()`](https://rdrr.io/r/stats/median.xhtml),
    which finds a value that lies in the “middle” of the vector, i.e., 50% of the
    values are above it and 50% are below it. Depending on the shape of the distribution
    of the variable you’re interested in, mean or median might be a better measure
    of center. For example, for symmetric distributions we generally report the mean,
    while for skewed distributions we usually report the median.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多数使用[`mean()`](https://rdrr.io/r/base/mean.xhtml)来总结值向量的中心。正如我们在[“案例研究：聚合和样本大小”](ch03.xhtml#sec-sample-size)中所看到的，因为均值是总和除以计数，它对于少数异常高或低值也很敏感。另一个选择是使用[`median()`](https://rdrr.io/r/stats/median.xhtml)，它找到一个位于向量“中间”的值，即有50%的值高于它，50%的值低于它。根据你感兴趣的变量分布形状，均值或中位数可能是更好的中心测量。例如，对于对称分布，通常报告均值，而对于偏斜分布，通常报告中位数。
- en: '[Figure 13-2](#fig-mean-vs-median) compares the mean to the median departure
    delay (in minutes) for each destination. The median delay is always smaller than
    the mean delay because flights sometimes leave multiple hours late, but they never
    leave multiple hours early.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](#fig-mean-vs-median) 比较每个目的地的平均和中位离港延误时间（以分钟为单位）。中位数延误时间始终小于平均延误时间，因为航班有时会晚数小时，但它们不会提前数小时。'
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![All points fall below a 45° line, meaning that the median delay is always
    less than the mean delay. Most points are clustered in a dense region of mean
    [0, 20] and median [0, 5]. As the mean delay increases, the spread of the median
    also increases. There are two outlying points with mean ~60, median ~50, and mean
    ~85, median ~55.](assets/rds2_1302.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![所有点都落在45°线以下，这意味着中位数延误始终小于平均延误。大多数点聚集在平均值 [0, 20] 和中位数 [0, 5] 的密集区域。随着平均延误的增加，中位数的散布也增加。有两个离群点，平均延误约为60，中位数约为50，平均延误约为85，中位数约为55。](assets/rds2_1302.png)'
- en: Figure 13-2\. A scatterplot showing the differences of summarizing hourly departure
    delay with median instead of mean.
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-2\. 散点图显示了使用中位数而不是平均数总结每小时离港延误的差异。
- en: You might also wonder about the *mode*, or the most common value. This is a
    summary that works well only for very simple cases (which is why you might have
    learned about it in high school), but it doesn’t work well for many real datasets.
    If the data is discrete, there may be multiple most common values, and if the
    data is continuous, there might be no most common value because every value is
    ever so slightly different. For these reasons, the mode tends not to be used by
    statisticians, and there’s no mode function included in base R.^([2](ch13.xhtml#idm44771297333504))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想知道*众数*，即最常见的值。这是一个仅对非常简单情况有效的摘要（这就是为什么您可能在高中学习过它），但它不适用于许多实际数据集。如果数据是离散的，则可能存在多个最常见值，如果数据是连续的，则可能不存在最常见值，因为每个值都可能略有不同。因此，统计学家不倾向于使用众数，并且基本的
    R 中也没有众数功能。^([2](ch13.xhtml#idm44771297333504))
- en: Minimum, Maximum, and Quantiles
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小值、最大值和分位数
- en: 'What if you’re interested in locations other than the center? [`min()`](https://rdrr.io/r/base/Extremes.xhtml)
    and [`max()`](https://rdrr.io/r/base/Extremes.xhtml) will give you the largest
    and smallest values. Another powerful tool is [`quantile()`](https://rdrr.io/r/stats/quantile.xhtml),
    which is a generalization of the median: `quantile(x, 0.25)` will find the value
    of `x` that is greater than 25% of the values, `quantile(x, 0.5)` is equivalent
    to the median, and `quantile(x, 0.95)` will find the value that’s greater than
    95% of the values.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对中心以外的位置感兴趣，会怎样？[`min()`](https://rdrr.io/r/base/Extremes.xhtml) 和 [`max()`](https://rdrr.io/r/base/Extremes.xhtml)
    将为您提供最大和最小值。另一个强大的工具是 [`quantile()`](https://rdrr.io/r/stats/quantile.xhtml)，它是中位数的一般化：`quantile(x,
    0.25)` 将找到大于25%值的 `x` 值，`quantile(x, 0.5)` 等同于中位数，而 `quantile(x, 0.95)` 将找到大于95%值的值。
- en: For the `flights` data, you might want to look at the 95% quantile of delays
    rather than the maximum, because it will ignore the 5% of most delayed flights,
    which can be quite extreme.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`flights`数据，您可能希望查看延误的95%分位数，而不是最大值，因为它会忽略5%的最延误航班，这可能相当极端。
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Spread
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散布
- en: Sometimes you’re not so interested in where the bulk of the data lies, but in
    how it is spread out. Two commonly used summaries are the standard deviation,
    `sd(x)`, and the inter-quartile range, [`IQR()`](https://rdrr.io/r/stats/IQR.xhtml).
    We won’t explain [`sd()`](https://rdrr.io/r/stats/sd.xhtml) here since you’re
    probably already familiar with it, but [`IQR()`](https://rdrr.io/r/stats/IQR.xhtml)
    might be new—it’s `quantile(x, 0.75) - quantile(x, 0.25)` and gives you the range
    that contains the middle 50% of the data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您对数据的大部分位于何处不感兴趣，而是关心其如何分布。两个常用的摘要是标准差，`sd(x)`，和四分位距，[`IQR()`](https://rdrr.io/r/stats/IQR.xhtml)。我们不会在这里解释[`sd()`](https://rdrr.io/r/stats/sd.xhtml)，因为您可能已经熟悉它，但[`IQR()`](https://rdrr.io/r/stats/IQR.xhtml)可能是新的——它是`quantile(x,
    0.75) - quantile(x, 0.25)`，给出包含数据中间50%的范围。
- en: 'We can use this to reveal a small oddity in the `flights` data. You might expect
    the spread of the distance between origin and destination to be zero, since airports
    are always in the same place. But the following code reveals a data oddity for
    airport [EGE](https://oreil.ly/Zse1Q):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来揭示`flights`数据中的一个小怪现象。您可能期望起始点和目的地之间的距离分布为零，因为机场始终在同一位置。但以下代码显示了有关机场[EGE](https://oreil.ly/Zse1Q)的数据异常：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Distributions
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布
- en: It’s worth remembering that all of the summary statistics described earlier
    are a way of reducing the distribution to a single number. This means they’re
    fundamentally reductive, and if you pick the wrong summary, you can easily miss
    important differences between groups. That’s why it’s always a good idea to visualize
    the distribution before committing to your summary statistics.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，前面描述的所有汇总统计都是将分布简化为一个单一数字的方法。这意味着它们基本上是还原的，如果选择了错误的汇总统计，可能会轻易地忽略掉不同组之间的重要差异。这就是为什么在确定汇总统计之前，始终建议先可视化分布的原因。
- en: '[Figure 13-3](#fig-flights-dist) shows the overall distribution of departure
    delays. The distribution is so skewed that we have to zoom in to see the bulk
    of the data. This suggests that the mean is unlikely to be a good summary, and
    we might prefer the median instead.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-3](#fig-flights-dist)显示了出发延误的整体分布。分布如此倾斜，以至于我们必须放大才能看到大部分数据。这表明平均值不太可能是一个好的汇总，我们可能更喜欢中位数。'
- en: '![Two histograms of `dep_delay`. On the left, it''s very hard to see any pattern
    except that there''s a very large spike around zero, the bars rapidly decay in
    height, and for most of the plot, you can''t see any bars because they are too
    short to see. On the right, where we''ve discarded delays of greater than two
    hours, we can see that the spike occurs slightly below zero (i.e. most flights
    leave a couple of minutes early), but there''s still a very steep decay after
    that. ](assets/rds2_1303.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![`dep_delay`的两个直方图。左边，除了在零附近有一个非常大的峰值外，几乎看不到任何模式，柱状图的高度迅速下降，并且大部分情况下，你看不到任何柱状图，因为它们太短了。右边，我们丢弃了超过两小时的延误，可以看到峰值略低于零（即大多数航班提前几分钟离开），但之后仍然有非常陡的下降。](assets/rds2_1303.png)'
- en: Figure 13-3\. (Left) The histogram of the full data is extremely skewed, making
    it hard to get any details. (Right) Zooming into delays of less than two hours
    makes it possible to see what’s happening with the bulk of the observations.
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-3。 （左）完整数据的直方图极度偏斜，很难得到任何细节。（右）缩放到延误小于两小时，可以看到大部分观测数据的情况。
- en: It’s also a good idea to check that distributions for subgroups resemble the
    whole. In the following plot, 365 frequency polygons of `dep_delay`, one for each
    day, are overlaid. The distributions seem to follow a common pattern, suggesting
    it’s fine to use the same summary for each day.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，检查子组的分布是否类似于整体分布也是一个好主意。在下面的图中，365个`dep_delay`的频率多边形，每天一个，重叠在一起。分布似乎遵循一个共同的模式，表明可以为每天使用相同的汇总方法。
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![The distribution of `dep_delay` is highly right skewed with a strong peak
    slightly less than 0\. The 365 frequency polygons are mostly overlapping forming
    a thick black bland.](assets/rds2_13in01.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![`dep_delay`的分布是右偏的，略低于0，有一个明显的峰值。365个频率多边形大部分重叠，形成一个厚重的黑色带。](assets/rds2_13in01.png)'
- en: 'Don’t be afraid to explore your own custom summaries specifically tailored
    for the data that you’re working with. In this case, that might mean separately
    summarizing the flights that left early versus the flights that left late, or
    given that the values are so heavily skewed, you might try a log transformation.
    Finally, don’t forget what you learned in [“Case Study: Aggregates and Sample
    Size”](ch03.xhtml#sec-sample-size): whenever creating numerical summaries, it’s
    a good idea to include the number of observations in each group.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕探索适用于你正在处理的数据的自定义汇总方法。在这种情况下，可能意味着分别汇总提前离开和延迟离开的航班，或者考虑到值非常倾斜，可以尝试对数转换。最后，不要忘记在[“案例研究：聚合和样本大小”](ch03.xhtml#sec-sample-size)中学到的内容：每当创建数值汇总时，最好包括每个组中的观测数。
- en: Positions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置
- en: 'There’s one final type of summary that’s useful for numeric vectors but also
    works with every other type of value: extracting a value at a specific position:
    `first(x)`, `last(x)`, and `nth(x, n)`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种最终的汇总类型对于数值向量很有用，但也适用于任何其他类型的值：提取特定位置的值：`first(x)`、`last(x)` 和 `nth(x, n)`。
- en: 'For example, we can find the first and last departure for each day:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以找到每天的第一个和最后一个出发时间：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: (Note that because dplyr functions use `_` to separate components of function
    and arguments names, these functions use `na_rm` instead of `na.rm`.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，因为 dplyr 函数使用 `_` 来分隔函数和参数名称的组件，这些函数使用 `na_rm` 而不是 `na.rm`。）
- en: 'If you’re familiar with `[`, which we’ll come back to in [“Selecting Multiple
    Elements with [”](ch27.xhtml#sec-subset-many), you might wonder if you ever need
    these functions. There are three reasons: the `default` argument allows you to
    provide a default if the specified position doesn’t exist, the `order_by` argument
    allows you to locally override the order of the rows, and the `na_rm` argument
    allows you to drop missing values.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 `[`，我们将在 [“使用 [ 选择多个元素”](ch27.xhtml#sec-subset-many) 中回到它，您可能会想知道是否需要这些函数。有三个理由：`default`
    参数允许您在指定的位置不存在时提供默认值，`order_by` 参数允许您在本地覆盖行的顺序，`na_rm` 参数允许您删除缺失值。
- en: 'Extracting values at positions is complementary to filtering on ranks. Filtering
    gives you all variables, with each observation in a separate row:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置值提取与排名过滤互补。过滤会给您所有的变量，每个观察值分别在一行中：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With mutate()
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mutate()
- en: 'As the names suggest, the summary functions are typically paired with [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml).
    However, because of the recycling rules we discussed in [“Arithmetic and Recycling
    Rules”](#sec-recycling), they can also be usefully paired with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml),
    particularly when you want do some sort of group standardization. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，摘要函数通常与 [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    配对使用。但是，由于我们在 [“算术和回收规则”](#sec-recycling) 中讨论的回收规则，它们也可以与 [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    有用地配对使用，特别是当您想要进行某种组标准化时。例如：
- en: '`x / sum(x)`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`x / sum(x)`'
- en: Calculates the proportion of a total.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算总量的比例。
- en: '`(x - mean(x)) / sd(x)`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`(x - mean(x)) / sd(x)`'
- en: Computes a Z-score (standardized to mean 0 and standard deviation 1).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 Z 得分（标准化为均值 0 和标准偏差 1）。
- en: '`(x - min(x)) / (max(x) - min(x))`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`(x - min(x)) / (max(x) - min(x))`'
- en: Standardizes to range [0, 1].
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化为范围 [0, 1]。
- en: '`x / first(x)`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`x / first(x)`'
- en: Computes an index based on the first observation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基于第一个观察值计算指数。
- en: Exercises
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Brainstorm at least five ways to assess the typical delay characteristics of
    a group of flights. When is [`mean()`](https://rdrr.io/r/base/mean.xhtml) useful?
    When is [`median()`](https://rdrr.io/r/stats/median.xhtml) useful? When might
    you want to use something else? Should you use arrival delay or departure delay?
    Why might you want to use data from `planes`?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一组航班的典型延迟特征进行至少五种评估方式的头脑风暴。[`mean()`](https://rdrr.io/r/base/mean.xhtml) 什么时候有用？[`median()`](https://rdrr.io/r/stats/median.xhtml)
    什么时候有用？什么时候可能需要使用其他方法？应该使用到达延误还是出发延误？为什么可能要使用 `planes` 的数据？
- en: Which destinations show the greatest variation in air speed?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些目的地显示出空速变化最大？
- en: Create a plot to further explore the adventures of EGE. Can you find any evidence
    that the airport moved locations? Can you find another variable that might explain
    the difference?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图表来进一步探索 EGE 的冒险。您能找到机场是否搬迁的证据吗？您能找到另一个可能解释差异的变量吗？
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You’re already familiar with many tools for working with numbers, and after
    reading this chapter you now know how to use them in R. You also learned a handful
    of useful general transformations that are commonly, but not exclusively, applied
    to numeric vectors such as ranks and offsets. Finally, you worked through a number
    of numeric summaries and discussed a few of the statistical challenges that you
    should consider.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了许多处理数字的工具，在阅读本章后，您现在知道如何在 R 中使用它们。您还学习了一些有用的一般转换，这些转换通常但不专门应用于数值向量，例如排名和偏移量。最后，您处理了许多数字摘要，并讨论了一些您应该考虑的统计挑战。
- en: Over the next two chapters, we’ll dive into working with strings with the stringr
    package. Strings are a big topic, so they get two chapters, one on the fundamentals
    of strings and one on regular expressions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将深入介绍使用 stringr 包处理字符串。字符串是一个大主题，因此它们有两章，一章讲述字符串的基础知识，另一章讲述正则表达式。
- en: ^([1](ch13.xhtml#idm44771298681152-marker)) ggplot2 provides some helpers for
    common cases in [`cut_interval()`](https://ggplot2.tidyverse.org/reference/cut_interval.xhtml),
    [`cut_number()`](https://ggplot2.tidyverse.org/reference/cut_interval.xhtml),
    and [`cut_width()`](https://ggplot2.tidyverse.org/reference/cut_interval.xhtml).
    ggplot2 is an admittedly weird place for these functions to live, but they are
    useful as part of histogram computation and were written before any other parts
    of the tidyverse existed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.xhtml#idm44771298681152-marker)) ggplot2 在 [`cut_interval()`](https://ggplot2.tidyverse.org/reference/cut_interval.xhtml)、[`cut_number()`](https://ggplot2.tidyverse.org/reference/cut_interval.xhtml)
    和 [`cut_width()`](https://ggplot2.tidyverse.org/reference/cut_interval.xhtml)
    中提供了一些常见情况的辅助功能。ggplot2 作为这些函数存在的地方确实有些奇怪，但它们作为直方图计算的一部分非常有用，并且在 tidyverse 的其他部分存在之前就已编写完成。
- en: ^([2](ch13.xhtml#idm44771297333504-marker)) The [`mode()`](https://rdrr.io/r/base/mode.xhtml)
    function does something quite different!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.xhtml#idm44771297333504-marker)) [`mode()`](https://rdrr.io/r/base/mode.xhtml)
    函数的功能完全不同！
