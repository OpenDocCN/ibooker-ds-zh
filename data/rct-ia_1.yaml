- en: Part 2\. Components and data in React
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. React中的组件和数据
- en: In [part 1](kindle_split_010.xhtml#part01), you looked at React at a high level,
    took a whirlwind tour through some of its APIs, and built a handful of components.
    Hopefully this gave you a better overall sense of what React is and how it works
    as a technology. But a quick tour won’t allow you to take full advantage of React
    so you can build robust, dynamic user interfaces with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一部分](kindle_split_010.xhtml#part01)中，您从高层次了解了React，快速浏览了一些其API，并构建了一些组件。希望这能给您一个更好的整体感觉，了解React是什么以及它作为一项技术是如何工作的。但快速浏览并不能让您充分利用React，以便您可以用它构建健壮、动态的用户界面。
- en: That’s where [part 2](#part02) comes in. In [part 2](#part02), you’ll start
    to explore React more thoroughly and take a careful look at its APIs. We’ll look
    at how you can create components and some of the different types of components
    that you can create. In [chapter 3](kindle_split_014_split_000.xhtml#ch03), we’ll
    look at how data flows through a React application. This will help you understand
    how React works with data in components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正是[第二部分](#part02)的用武之地。在[第二部分](#part02)中，您将开始更深入地探索React，并仔细查看其API。我们将探讨您如何创建组件以及您可以创建的不同类型的组件。在第3章（kindle_split_014_split_000.xhtml#ch03）中，我们将探讨数据如何在React应用中流动。这将帮助您了解React如何在组件中处理数据。
- en: 'In [chapter 4](kindle_split_015_split_000.xhtml#ch04), you’ll look at lifecycle
    methods in React and start to build a project that you’ll focus on for the rest
    of the book: a social networking app called Letters Social. If you want to peek
    ahead at the final project you can visit [https://social.react.sh](https://social.react.sh).
    [Chapter 4](kindle_split_015_split_000.xhtml#ch04) will help you understand the
    React Component API and show you how to get set up to build the Letters Social
    project.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_015_split_000.xhtml#ch04)中，您将了解React中的生命周期方法，并开始构建您将在本书的剩余部分关注的工程项目：一个名为Letters
    Social的社会化应用。如果您想提前查看最终项目，可以访问[https://social.react.sh](https://social.react.sh)。第4章将帮助您理解React组件API，并展示如何设置构建Letters
    Social项目。
- en: In [chapters 5](kindle_split_016_split_000.xhtml#ch05) and [6](kindle_split_017_split_000.xhtml#ch06),
    we’ll look at forms in React. Forms are an important part of most web applications,
    and we’ll explore how they can work in React. You’ll add forms to Letters Social
    and create a user interface that allows users to create posts and integrate Mapbox
    to add mapped locations to posts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_016_split_000.xhtml#ch05)和[第6章](kindle_split_017_split_000.xhtml#ch06)中，我们将探讨React中的表单。表单是大多数Web应用的一个重要部分，我们将探讨它们如何在React中工作。您将为Letters
    Social添加表单，并创建一个允许用户创建帖子并集成Mapbox以添加地图位置的界面。
- en: In [chapters 7](kindle_split_018_split_000.xhtml#ch07) and [8](kindle_split_019_split_000.xhtml#ch08),
    we’ll dive into routing. Routing is another critical part of modern front-end
    web applications. You’ll build a router from scratch with React and add multiple
    pages to Letters Social. Towards the end of the chapter, you’ll integrate Firebase
    so users can log into your application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_018_split_000.xhtml#ch07)和[第8章](kindle_split_019_split_000.xhtml#ch08)中，我们将深入探讨路由。路由是现代前端Web应用的另一个关键部分。您将使用React从头开始构建一个路由器，并为Letters
    Social添加多个页面。在章节的末尾，您将集成Firebase，以便用户可以登录到您的应用。
- en: As we wrap up [part 2](#part02) in [chapter 9](kindle_split_020_split_000.xhtml#ch09),
    we’ll focus on testing. Testing is an important part of all software and React
    is no different. You’ll explore using Jest and Enzyme, among other tools, to test
    your React components.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第9章](kindle_split_020_split_000.xhtml#ch09)中结束[第二部分](#part02)时，我们将专注于测试。测试是所有软件的重要部分，React也不例外。您将探索使用Jest和Enzyme等工具来测试您的React组件。
- en: Chapter 3\. Data and data flow in React
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. React中的数据和数据流
- en: '*This chapter covers*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Mutable and immutable state
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变和不可变状态
- en: Stateful and stateless components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态和无状态组件
- en: Component communication
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件通信
- en: One-way data flow
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向数据流
- en: '[Chapter 2](kindle_split_012_split_000.xhtml#ch02) was a whirlwind tour of
    React. We spent some time learning about React at a high level, looked at some
    of the concepts behind its design and API, and we even went through building a
    simple comment box with React components. In [chapter 4](kindle_split_015_split_000.xhtml#ch04)
    you’ll start to work more extensively with components and start building the Letters
    Social sample project. But before you do that, you need to know a little bit more
    about how to work with data in React and understand how it flows in React applications.
    That’s what this chapter is about.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](kindle_split_012_split_000.xhtml#ch02) 对 React 进行了一次快速浏览。我们花了一些时间从高层次上学习
    React，探讨了其设计和 API 背后的某些概念，甚至还通过 React 组件构建了一个简单的评论框。在 [第四章](kindle_split_015_split_000.xhtml#ch04)
    中，你将开始更深入地使用组件，并开始构建 Letters Social 示例项目。但在你这样做之前，你需要了解一些关于如何在 React 中处理数据以及它在
    React 应用程序中如何流动的知识。这正是本章的内容。'
- en: 3.1\. Introducing state
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 引入状态
- en: '[Chapter 2](kindle_split_012_split_000.xhtml#ch02) gave you a few glimpses
    of working with data in React components, but we’ll need to spend more time focusing
    on it if you want to build more substantial React applications. In this section,
    you’ll learn about the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](kindle_split_012_split_000.xhtml#ch02) 给了你一些在 React 组件中处理数据的初步了解，但如果你想构建更实质性的
    React 应用程序，我们需要花更多的时间专注于这一点。在本节中，你将学习以下内容：'
- en: State
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: How React handles state
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 如何处理状态
- en: How data flows through components
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据如何在组件间流动
- en: Modern web applications are usually built as data-first applications. Granted,
    there are many static sites (my blog is one—[https://ifelse.io](https://ifelse.io)),
    but even these are updated over time and generally considered to be in a different
    category from modern web applications. Most web apps that people use on a regular
    basis are highly dynamic and filled with data that changes over time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用程序通常被构建为以数据为先的应用程序。诚然，有许多静态网站（我的博客就是一个——[https://ifelse.io](https://ifelse.io)），但这些网站随着时间的推移也会更新，并且通常被认为与现代网络应用程序属于不同的类别。人们日常使用的多数网络应用程序都是高度动态的，并且充满了随时间变化的数据。
- en: Think of an application like Facebook. As a social network, data is the lifeblood
    of everything it’s useful for. It provides a variety of ways to interact with
    other people over the internet, and all these ways are done via modifying and
    receiving data in your browser (or other platforms). Many other applications contain
    incredibly complex data which needs to be represented in a UI that people can
    understand and easily use. Developers also need to be able to maintain and reason
    about these interfaces and how data flows through them, so how an application
    deals with data is as important as its ability to handle changing data over time.
    The sample application you’ll start building in the next chapter, Letters Social
    (check it out at [https://social.react.sh](https://social.react.sh)), will use
    lots of changing data, though it won’t be nearly as complex as most consumer or
    business apps. I’ll be more explicit about it in this chapter, but we’ll continue
    to learn about working with data in React for the rest of the book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Facebook 这样的应用程序为例。作为一个社交网络，数据是它所有有用功能的生命线。它提供了多种方式在互联网上与其他人互动，而这些所有方式都是通过在浏览器（或其他平台）中修改和接收数据来实现的。许多其他应用程序包含极其复杂的数据，这些数据需要以人们可以理解和轻松使用的方式在
    UI 中表示。开发者还需要能够维护和推理这些界面以及数据如何通过它们流动，因此应用程序处理数据的能力与它处理随时间变化的数据的能力一样重要。你将在下一章开始构建的示例应用程序
    Letters Social（可在 [https://social.react.sh](https://social.react.sh) 查看它），将使用大量变化的数据，尽管它不会像大多数消费者或商业应用程序那样复杂。我将在本章中对此进行更明确的说明，但我们将继续学习如何在
    React 中处理数据，直到本书的结尾。
- en: 3.1.1\. What is state?
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1. 什么是状态？
- en: 'Let’s take a brief and simplified look at state so you can have a better understanding
    of it when we look at state in React. If you’ve never explicitly thought or heard
    about state in a program before, you’ve probably at least seen it before. Most
    of the programs you’ve written probably had some kind of state to them. If you’ve
    ever worked with a front-end framework like Vue, Angular, or Ember, you’ve almost
    certainly written UIs that had some aspect of state to them. React components
    can have state, too. But what exactly are we talking about when we say *state*?
    Try this definition:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下状态，这样当我们研究 React 中的状态时，你可以有更好的理解。如果你以前从未明确思考或听说过程序中的状态，你可能至少见过它。你编写的大多数程序可能都有某种状态。如果你曾经使用过
    Vue、Angular 或 Ember 这样的前端框架，你几乎肯定编写过具有状态方面的 UI。React 组件也可以有状态。但当我们说 *状态* 时，我们究竟在说什么呢？尝试这个定义：
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: State
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态
- en: All the information a program has access to at a given instant in time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在某一时刻可访问的所有信息。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That’s a simplified definition that probably ignores some academic nuances,
    but it’s good enough for our purposes. Many papers have been written by scholars
    dedicated to precisely defining state in computer systems, but for us state is
    the information at an instant in time that a program has access to. This includes,
    among other things, all the values you can reference without doing any further
    assignment or calculation at a given moment in time—in other words, it’s a snapshot
    of what you know about a program at an instant.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简化的定义，可能忽略了某些学术上的细微差别，但对于我们的目的来说已经足够好了。许多学者都撰写了论文，致力于精确地定义计算机系统中的状态，但对我们来说，状态是指程序在某一时刻可访问的信息。这包括，但不仅限于，在某一时刻你可以引用的所有值，而不需要做任何进一步的赋值或计算——换句话说，它是对你在某一时刻对程序了解的快照。
- en: For example, this might include any variables you previously created or other
    available values. When you change a variable (and aren’t just using it to get
    at a value), you change the state of a program, and it’s no longer the same as
    it was before. You can retrieve state at a given moment by only fetching or getting
    values, but when you change something over time, the state of a program has changed.
    Technically, the underlying state of your machine is changing every moment you’re
    using it, but we’re only concerned with the state of your program here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这可能包括你之前创建的任何变量或其他可用的值。当你改变一个变量（而不仅仅是获取其值）时，你改变了程序的状态，它就不再是之前的状态了。你可以在某一时刻通过仅获取或获取值来检索状态，但当你随着时间的推移改变某些东西时，程序的状态就发生了变化。技术上讲，你的机器的底层状态在你使用它的每一刻都在变化，但我们只关心程序的状态。
- en: Let’s look at some code and step through simplified program state in the nest
    listing. We won’t go into all the underlying allocations or processes that happen
    behind the scenes—we’re just trying to think more explicitly about the data in
    our programs so that thinking about React components will be easier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下一些代码，并逐步分析下一列表中的简化程序状态。我们不会深入探讨幕后发生的所有底层分配或过程——我们只是试图更明确地思考程序中的数据，以便在思考
    React 组件时更容易。
- en: Listing 3.1\. Simple program state
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 简单程序状态
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Store a string in a variable called letters.**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在名为 letters 的变量中存储一个字符串。**'
- en: '***2* Split the letters into an array of strings.**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将字母拆分成一个字符串数组。**'
- en: '***3* Print out a message.**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印一条消息。**'
- en: '***4* Print out each letter.**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印出每个字母。**'
- en: '[Listing 3.1](kindle_split_014_split_001.xhtml#ch03ex01) shows a simple script
    that does some basic assignment and manipulation of data and logs it out. It’s
    boring, but we can use it to learn more about state. JavaScript employs what are
    called *run to completion* semantics, meaning that programs will be executed from
    top to bottom, in the order that you think they would be. JavaScript engines will
    often optimize your code in a way that you might not expect, but it should still
    run in a way consistent with your original code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.1](kindle_split_014_split_001.xhtml#ch03ex01) 展示了一个简单的脚本，它执行了一些基本的数据赋值和操作，并将结果输出。这很无聊，但我们可以用它来学习更多关于状态的知识。JavaScript
    使用所谓的 *运行至完成* 语义，这意味着程序将从上到下，按照你认为的顺序执行。JavaScript 引擎通常会以你意想不到的方式优化你的代码，但它仍然应该以与你的原始代码一致的方式运行。'
- en: Try reading the code in [listing 3.1](kindle_split_014_split_001.xhtml#ch03ex01)
    from top to bottom, one line at a time. If you want to use the browser debugger
    to do this, head to [https://codesandbox.io/s/n9mvol5x9p](https://codesandbox.io/s/n9mvol5x9p).
    The dev tools for your browser should open up, and you can step through each line
    of the code and see all the variable assignments and more.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从上到下逐行阅读 [清单 3.1](kindle_split_014_split_001.xhtml#ch03ex01) 中的代码。如果你想使用浏览器调试器来做这件事，请访问
    [https://codesandbox.io/s/n9mvol5x9p](https://codesandbox.io/s/n9mvol5x9p)。你的浏览器开发工具应该会打开，你可以逐行执行代码并查看所有变量赋值等信息。
- en: 'For our purposes, let’s consider each line of code to be a moment in time.
    Working with our simplified definition of state as “all the information available
    to a program at a given moment in time,” how would you describe the state of the
    application at each given moment? Note that we’re keeping things simple and omitting
    things like closures, garbage collection, and so on:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，让我们考虑每一行代码都是一个时间点。根据我们对状态的简化定义“在给定时间点程序可用的所有信息”，你将如何描述在每一个给定时刻应用程序的状态？请注意，我们保持简单，省略了闭包、垃圾回收等：
- en: '`letters` is a variable with a string “Letters” assigned to it.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`letters` 是一个被赋予字符串 “Letters” 的变量。'
- en: '`splitLetters` is created by splitting every character from `letters`, which
    is still available.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`splitLetters` 是通过从 `letters` 中拆分每个字符创建的，`letters` 仍然可用。'
- en: All information from steps 1 and 2 is still available; a message is sent to
    the console.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤 1 和 2 中的所有信息仍然可用；一条消息被发送到控制台。
- en: Our program iterates over each item in the array and logs out a character. This
    process will probably occur over several moments in time, so the program also
    has the information available from the `Array.forEach` method available to it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的程序遍历数组中的每个项目并输出一个字符。这个过程可能会在几个时间点发生，因此程序也有 `Array.forEach` 方法提供的信息。
- en: As the program moved forward in execution, the state changed over time, and
    more information became available because you haven’t deleted anything or changed
    references. [Table 3.1](kindle_split_014_split_001.xhtml#ch03table01) shows how
    the available information increases as the program moves forward in time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序执行向前推进，状态随时间变化，并且由于你没有删除任何内容或更改引用，更多信息变得可用。[表 3.1](kindle_split_014_split_001.xhtml#ch03table01)
    展示了随着程序随时间向前推进，可用信息是如何增加的。
- en: Table 3.1\. State step-by-step
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. 逐步状态
- en: '| Step | State available to program |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 程序可用的状态 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | letters = “Letters” |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1 | letters = “Letters” |'
- en: '| 2 | letters = “Letters” splitLetters = [“L”, “e”, “t”, “t”, “e”, “r”, “s”]
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 2 | letters = “Letters” splitLetters = [“L”, “e”, “t”, “t”, “e”, “r”, “s”]
    |'
- en: '| 3 | letters = “Letters” splitLetters = [“L”, “e”, “t”, “t”, “e”, “r”, “s”]
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 3 | letters = “Letters” splitLetters = [“L”, “e”, “t”, “t”, “e”, “r”, “s”]
    |'
- en: '| 4 | letters = “Letters” splitLetters = [“L”, “e”, “t”, “t”, “e”, “r”, “s”]
    for sub-steps 0 through the length of splitLetters: letter = “L” (then “e”, “t”,
    etc.) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 4 | letters = “Letters” splitLetters = [“L”, “e”, “t”, “t”, “e”, “r”, “s”]
    for sub-steps 0 through the length of splitLetters: letter = “L” (然后 “e”, “t”,
    等。) |'
- en: Try walking through some of your own code and thinking about what information
    is available to the program at each line. We tend to simplify our code—and rightly
    so, because we don’t have to think about every possible dimension of it at once—but
    there can be a nontrivial amount of information available even for simpler programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试遍历你自己的代码并思考在每一行程序中可用的信息是什么。我们倾向于简化我们的代码——这是正确的，因为我们不必一次性考虑它的每一个可能的维度——但对于更简单的程序，也可能有大量的信息可用。
- en: One takeaway we can reflect on is that when a running program becomes reasonably
    complex (as even most simple UIs can tend to be), reasoning about it can become
    difficult. By that I mean that the complexity of a system can be hard to keep
    in your head all at once, and the logic in a system can make it hard to think
    through. This is true for most programs, but when it comes to building UIs, it
    can be especially difficult.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反思的一个观点是，当运行中的程序变得相对复杂（即使是大多数简单的 UI 也可能如此），推理它可能会变得困难。我的意思是，系统的复杂性可能很难一次性全部记住，系统中的逻辑可能会使思考变得困难。这对大多数程序都适用，但当涉及到构建
    UI 时，这可能会特别困难。
- en: 'The UI for modern browser apps often represents the intersection of a multitude
    of technologies, including servers providing data, styling and layout APIs, JavaScript
    frameworks, browser APIs, and so on. Advances in UI frameworks have aimed to simplify
    this problem, but it remains a challenge. The challenge often only increases with
    the greater expectations people have for web apps as these apps become more and
    more widespread and embedded in society and daily life. If React is to be useful,
    it will need to help us by reducing or shielding us from the immensely complex
    state of some modern UIs. I hope you’ll come to see that React does do this. But
    how? One way is by providing two specific APIs to work with data: props and state.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器应用的UI通常代表了多种技术的交集，包括提供数据、样式和布局API的服务器，JavaScript框架，浏览器API等等。UI框架的进步旨在简化这个问题，但它仍然是一个挑战。随着人们对Web应用期望的不断提高，这些应用变得越来越普遍，并嵌入到社会和日常生活中，这个挑战通常只会加剧。如果React要变得有用，它将需要通过减少或保护我们免受某些现代UI的极其复杂的状态的影响来帮助我们。我希望你能看到React确实做到了这一点。但它是如何做到的呢？一种方法是通过提供两个特定的API来处理数据：props和state。
- en: 3.1.2\. Mutable and immutable state
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 可变和不可变状态
- en: 'In React applications, there are two primary ways that you can work with state
    in components: through state that you can change, and through state that you shouldn’t.
    We’re oversimplifying here: there are many types of data and state that will exist
    in your application. You could represent data in many different ways, like binary
    trees, Maps or Sets, or regular JavaScript objects. But the way that you can communicate
    and interact with state in your React components fall into these two categories.
    In React, these are known as *state* (data you can change within a component)
    and *props* (data a component receives that shouldn’t be changed by the component).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用中，你可以通过两种主要方式在组件中处理状态：通过你可以改变的状态，以及通过你不应该改变的状态。这里我们过于简化了：你的应用中将有多种类型的数据和状态存在。你可以用许多不同的方式表示数据，比如二叉树、Maps或Sets，或者常规的JavaScript对象。但你在React组件中与状态通信和交互的方式可以分为这两类。在React中，这些被称为*状态*（组件内可以改变的数据）和*属性*（组件接收的数据，不应该被组件改变）。
- en: You may have heard of state and props referred to as being mutable and immutable.
    That’s partly true, because JavaScript doesn’t natively support truly immutable
    objects (outside of, maybe, Symbols). In React components, state is generally
    mutable, and props shouldn’t be changed. Let’s explore the ideas of mutability
    and immutability a little more before we dive all the way into React-specific
    APIs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过状态和属性被称为可变和不可变。这在某种程度上是正确的，因为JavaScript本身不支持真正的不可变对象（也许除了Symbols）。在React组件中，状态通常是可变的，而属性不应该被改变。在我们深入探讨React特定的API之前，让我们更深入地探讨可变性和不可变性的概念。
- en: You saw in [chapter 2](kindle_split_012_split_000.xhtml#ch02) that when we call
    state mutable we mean we can overwrite or update that data (for example, a variable
    that you can overwrite). Immutable state, on the other hand, can’t be changed.
    There are also immutable data structures, which can be changed but only in controlled
    ways (this is sort of how the state API works in React). When you work with Redux
    in [chapters 10](kindle_split_022_split_000.xhtml#ch10) and [11](kindle_split_023_split_000.xhtml#ch11),
    you’ll emulate immutable data structures.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第2章](kindle_split_012_split_000.xhtml#ch02)中看到，当我们说状态是可变的，我们的意思是我们可以覆盖或更新那些数据（例如，可以覆盖的变量）。另一方面，不可变状态是不可变的。也存在不可变的数据结构，这些数据结构可以改变，但只能以受控的方式进行（这有点像是React中状态API的工作方式）。当你使用Redux在[第10章](kindle_split_022_split_000.xhtml#ch10)和[第11章](kindle_split_023_split_000.xhtml#ch11)时，你会模拟不可变数据结构。
- en: 'We can slightly expand our notions of mutable and immutable to include their
    corresponding data structure types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微扩展我们对可变和不可变概念的理解，包括它们对应的数据结构类型：
- en: '***Immutable*—** An immutable, persistent data structure supports multiple
    versions over time but can’t be directly overwritten; immutable data structures
    are generally persistent.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***不可变*—** 不可变、持久的数据结构在一段时间内支持多个版本，但不能直接被覆盖；不可变数据结构通常是持久的。'
- en: '***Mutable*—** A mutable, ephemeral data structure supports only a single version
    over time; mutable data structures are overwritten when they change and don’t
    support additional versions.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可变*—** 可变、短暂的数据结构在一段时间内只支持一个版本；当可变数据结构发生变化时，会被覆盖，并且不支持额外的版本。'
- en: '[Figure 3.1](kindle_split_014_split_001.xhtml#ch03fig01) visualizes these ideas.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](kindle_split_014_split_001.xhtml#ch03fig01) 展示了这些概念。'
- en: Figure 3.1\. Persistence and ephemerality in immutable and mutable data structures.
    Immutable or persistent data structures usually record a history and don’t change
    but rather make versions of what changed over time. Ephemeral data structures,
    on the other hand, usually don’t record history and get wiped out with each update.
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 不可变和可变数据结构中的持久性和短暂性。不可变或持久的数据结构通常记录历史并保持不变，但会创建随时间变化的内容的版本。另一方面，短暂的数据结构通常不记录历史，并且每次更新都会被清除。
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig01_alt.jpg)'
- en: 'Another way to think of the difference between immutable and mutable data structures
    is to think of each as having different capacities or memories. Ephemeral data
    structures only have the capacity to store a moment’s worth of data, whereas persistent
    data structures can keep track of changes over time. This is where the immutability
    of immutable data structures becomes clearer: only copies of state are made—they’re
    not replaced. The old state is replaced by the new one, but the data isn’t replaced.
    [Figure 3.2](kindle_split_014_split_001.xhtml#ch03fig02) shows how changes are
    made.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考不可变数据结构和可变数据结构之间区别的方法是，将它们视为具有不同的容量或内存。短暂的数据结构只能存储一瞬间的数据，而持久的数据结构可以跟踪随时间的变化。这就是不可变数据结构的不可变性变得更为清晰的地方：只有状态副本被创建——它们不会被替换。旧状态被新状态所取代，但数据本身并没有被替换。[图3.2](kindle_split_014_split_001.xhtml#ch03fig02)展示了如何进行更改。
- en: Figure 3.2\. Handling changes with mutable and immutable data. Ephemeral data
    structures don’t have versions, so when you make changes to them, all previous
    state is gone. You could say that they live in the moment, whereas immutable data
    structures are able to persist over time.
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 使用可变和不可变数据结构处理更改。短暂的数据结构没有版本，所以当你对它们进行更改时，所有之前的状态都会消失。你可以这样说，它们活在当下，而不可变数据结构能够随着时间的推移而持续存在。
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig02_alt.jpg)'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Another way you can think of immutability versus mutability is by thinking of
    the difference between Save and Save As. With many computer programs, you can
    save a file as it is at the moment or save a copy of the current file under a
    different name. Immutability is similar in that when you save to it, you’re saving
    a copy, whereas mutable data can be overwritten in-place.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考不可变性与可变性之间区别的方法是，将其与“保存”和“另存为”之间的区别相比较。在许多计算机程序中，你可以以当前状态保存文件，或者以不同的名称保存当前文件的副本。不可变性与此类似，当你保存到它时，你是在保存一个副本，而可变数据可以在原地被覆盖。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Even though JavaScript doesn’t support truly immutable data structures natively,
    React exposes component state in a mutable way (changeable via `setState`) and
    props as read-only. There’s a lot more to immutability and immutable data structures
    in general, but we don’t need to concern ourselves with them much more than we
    already have. If you’re still curious to learn more, an entire body of academic
    research is focused on this sort of question. There are also ways you can use
    immutable data structures extensively throughout your JavaScript apps (React or
    not) with libraries like Immutable JS (see [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/)
    for more information), but in React we’ll only deal with the props and state APIs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript本身不支持真正的不可变数据结构，但React以可变的方式（通过`setState`进行更改）暴露组件状态，并将属性作为只读。关于不可变性和不可变数据结构，还有很多其他内容，但我们不需要比我们已经了解的更多地去关心它们。如果你仍然好奇想了解更多，有一整个学术研究领域都专注于这类问题。还有方法可以在你的JavaScript应用程序（无论是否是React）中广泛使用不可变数据结构（例如，使用Immutable
    JS库，更多信息请参阅[https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/)），但在React中，我们只会处理属性和状态API。
- en: 3.2\. State in React
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. React中的状态
- en: You’ve learned a little bit more about state and (im)mutability. How does all
    this fit into React? Well, we’ve already seen a little of the props and state
    APIs in the last chapter, so you can probably guess that they must be important
    parts of how you build components. In fact, they’re the two main ways that React
    components deal with data and communicate with each other.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对状态和（不可）可变性有了更多的了解。所有这些如何与React结合？嗯，我们在上一章已经看到了一些关于属性和状态API的内容，所以你可能已经猜到它们一定是构建组件的重要部分。实际上，它们是React组件处理数据和相互通信的两种主要方式。
- en: '3.2.1\. Mutable state in React: Component state'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. React中的可变状态：组件状态
- en: Let’s start with the state API. Although we can say that all components have
    some kind of “state” (the general concept) to them, not all components in React
    have local component state. From here on out, when I refer to state I’m talking
    about the React API, not the general concept. Components that inherit from the
    `React.Component` class will get access to this API. React will create and keep
    track of a backing instance for components created in this way. These components
    will also get access to a series of lifecycle methods discussed in the next chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从状态 API 开始。虽然我们可以这样说，所有组件都有某种“状态”（一般概念），但并非 React 中的所有组件都有本地组件状态。从现在开始，当我提到状态时，我指的是
    React API，而不是一般概念。继承自 `React.Component` 类的组件将获得访问此 API 的权限。React 将为以这种方式创建的组件创建并跟踪一个后端实例。这些组件还将获得下一章中讨论的一系列生命周期方法的访问权限。
- en: You can access state in your components that inherit from `React.Component`
    via `this.state`. In this case, `this` refers to the instance of the class, and
    `state` is the special property that React will keep track of for you. You might
    think you can update `state` just by assigning to it or by mutating a property
    in it, but that’s not the case. Let’s look at an example of component state in
    a simple React component in the following listing. You can create this code on
    your local machine or, even more easily, at [https://codesandbox.io/s/ovxpmn340y](https://codesandbox.io/s/ovxpmn340y).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `this.state` 访问继承自 `React.Component` 的组件中的状态。在这种情况下，`this` 指的是类的实例，而 `state`
    是 React 将为你跟踪的特殊属性。你可能认为你可以通过直接赋值或修改其中的属性来更新 `state`，但这并不是情况。让我们看看以下列表中一个简单 React
    组件的组件状态示例。你可以在你的本地机器上创建此代码，或者更简单地在 [https://codesandbox.io/s/ovxpmn340y](https://codesandbox.io/s/ovxpmn340y)
    上创建。
- en: Listing 3.2\. Using `setState` to modify component state
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 使用 `setState` 修改组件状态
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Create a React component that will have access to persistent component
    state over time—don’t forget to bind your class methods to the component instance.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个将在一段时间内访问持久组件状态的 React 组件——别忘了将你的类方法绑定到组件实例上。**'
- en: '***2* Provide an initial state for the component so that attempts to access
    it in render() don’t return undefined values or throw errors.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为组件提供一个初始状态，以便在 render() 中访问它时不会返回 undefined 值或抛出错误。**'
- en: '***3* Our first look at setState, the special API for modifying component state;
    call setState with a callback function that returns a new state object for React
    to use.**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 我们第一次看到 `setState`，这是修改组件状态的特殊 API；调用 `setState` 并传入一个回调函数，该函数返回一个新状态对象供
    React 使用。**'
- en: '***4* Bind the name-revealing function to the click event emitted by the button.**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将揭示名称的函数绑定到按钮发出的点击事件上。**'
- en: '***5* Render top-level components to an HTML element at the topmost level of
    an application—identify your container however you like, as long as ReactDOM can
    find it.**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将顶层组件渲染到应用程序最顶层的 HTML 元素中——你可以按你喜欢的方式标识容器，只要 ReactDOM 能够找到它。**'
- en: '[Listing 3.2](kindle_split_014_split_002.xhtml#ch03ex02) creates a simple component
    that will reveal a secret name when you click a button using `setState` to update
    the component state. Notice that `setState` is available on `this` because the
    component inherits from the `React.Component` class.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.2](kindle_split_014_split_002.xhtml#ch03ex02) 创建了一个简单的组件，当你点击按钮并使用 `setState`
    更新组件状态时，它会揭示一个秘密名称。注意，`setState` 在 `this` 上可用，因为该组件继承自 `React.Component` 类。'
- en: When you click the button, a click event will be fired, and the function you’ve
    told React to respond with will be executed. When it’s executed, it will call
    the `setState` method with an object as a parameter. That object has a property,
    `name`, that points to a string. React will schedule an update to state. When
    this work has occurred, `React DOM` will update the DOM if necessary. Your `render`
    function will be called again, but this time with a different value available
    to the JSX expression syntax (`{}`) that contains `this.state.name`. It will read
    “Mark” instead of “top secret!” and my secret identity will be blown!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击按钮时，将触发一个点击事件，React 将执行你告诉它响应的函数。当它执行时，它将使用一个对象作为参数调用 `setState` 方法。该对象有一个
    `name` 属性，指向一个字符串。React 将安排更新状态。当这项工作完成后，`React DOM` 将根据需要更新 DOM。你的 `render` 函数将被再次调用，但这次将使用不同的值提供给
    JSX 表达式语法（`{}`）中的 `this.state.name`。它将读取“Mark”而不是“绝密！”我的秘密身份就会被揭露！
- en: Usually, you want to use `setState` sparingly when possible due to the performance
    and complexity hit you incur (React has to keep track of something else for you,
    and you have to mentally keep track of another piece of data). There are patterns
    that enjoy significant popularity in the React community that allow you to rarely
    use component state at all (including Redux, Mobx, Flux, and others), and these
    are great to explore as options for your application—in fact, we’ll look at Redux
    in [chapters 10](kindle_split_022_split_000.xhtml#ch10) and [11](kindle_split_023_split_000.xhtml#ch11).
    Although it’s better to usually use a stateless functional component, or rely
    on a pattern like Redux, using the setState API isn’t a bad practice by itself—it’s
    still the main API in React for changing data in a component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当可能时，你应该尽量少用`setState`，因为这样会带来性能和复杂性的影响（React需要为你跟踪其他东西，而你也需要在心理上跟踪另一份数据）。在React社区中，有一些流行的模式允许你几乎不用组件状态（包括Redux、Mobx、Flux等），这些模式作为你应用程序的选项是很好的探索对象——实际上，我们将在第[10章](kindle_split_022_split_000.xhtml#ch10)和第[11章](kindle_split_023_split_000.xhtml#ch11)中查看Redux。尽管通常最好使用无状态函数组件，或者依赖像Redux这样的模式，但使用`setState`
    API本身并不是一个坏习惯——它仍然是React中更改组件数据的主要API。
- en: Before moving on, it’s important to note that you should never directly modify
    `this.state` in React components. If you try to modify `this.state` directly,
    calling `setState()` afterwards could replace the mutation you made, and—even
    worse—React won’t have any idea about the change you made to state. Even though
    you can think about component state as something you can change, you should treat
    the `this.state` objects as if they’re immutable within your components (like
    props).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，重要的是要注意，你永远不应该在React组件中直接修改`this.state`。如果你尝试直接修改`this.state`，调用`setState()`之后可能会替换你所做的修改，甚至更糟糕的是——React将无法了解你对状态所做的更改。尽管你可以将组件状态视为可以改变的东西，但你应该将`this.state`对象视为在你的组件内部不可变的（就像props一样）。
- en: This is also important because `setState()` doesn’t immediately mutate `this.state`.
    Instead, it creates a pending state *transition* (more on rendering and change
    detection in the next chapter). Accessing `this.state` after calling this method
    can potentially return the existing value. All these things make for potentially
    tricky debugging situations, so just use `setState()` to mutate component state.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很重要，因为`setState()`并不会立即修改`this.state`。相反，它创建了一个挂起的*状态转换*（关于渲染和变更检测的更多内容将在下一章中介绍）。在调用此方法之后访问`this.state`可能会返回现有值。所有这些因素都可能造成潜在的调试难题，所以请尽量使用`setState()`来修改组件状态。
- en: Even in a small interaction like the one in [listing 3.2](kindle_split_014_split_002.xhtml#ch03ex02),
    there’s quite a bit going on. We’ll keep breaking down all the various steps that
    occur when React performs updates on your components in future chapters, but for
    the moment it’s important to look more closely at your component’s `render` method.
    Note that even though you performed a state mutation and changed data around,
    it happened in a relatively understandable and predictable way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在[列表3.2](kindle_split_014_split_002.xhtml#ch03ex02)中的这样一个小型交互中，也有很多事情在进行。我们将在未来的章节中继续分解React在更新你的组件时发生的所有各种步骤，但此刻重要的是更仔细地看看你的组件的`render`方法。请注意，尽管你执行了状态突变并更改了数据，但它以一种相对可理解和可预测的方式进行。
- en: Even better, you could declare what you wanted your component’s appearance and
    structure to look like once. You didn’t have to do tons of extra work for the
    two different states it could exist in (with or without the top-secret name revealed).
    React handled all underlying state binding and update procedures, and you only
    had to say, “The name should go here.” React helped by not forcing you to think
    about every piece of state at every point in time, like you had to in [section
    3.1.1](kindle_split_014_split_001.xhtml#ch03lev2sec1).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以一次性声明你想要的组件外观和结构的样子。你不必为它可能存在的两种不同状态做大量的额外工作（有或没有透露秘密名称）。React处理了所有底层状态绑定和更新过程，而你只需要说，“名字应该在这里。”React通过不强迫你在每个时间点都考虑每一块状态，就像在[3.1.1节](kindle_split_014_split_001.xhtml#ch03lev2sec1)中必须做的那样，来帮助你。
- en: 'Let’s look at the setState API a little more closely. It’s the primary way
    for changing dynamic state in React components, and you’ll use it often in your
    application. Let’s look at the method signature to see what you need to pass to
    it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`setState` API。它是更改React组件中动态状态的主要方式，你将在你的应用程序中经常使用它。让我们看看方法签名，看看你需要传递给它什么：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`setState` takes a function to use to set the new state for the component and
    an optional `callback` function. The `updater` function has this signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`setState` 接收一个用于设置组件新状态的函数以及一个可选的 `callback` 函数。`updater` 函数具有以下签名：'
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With past versions of React you could pass an object instead of a function
    as the first argument to `setState`. A key difference from current versions of
    React (16 and up) is that it could imply that `setState` was synchronous in nature,
    whereas what happens is that React will schedule a change to state. The `callback`
    format better communicates this idea and is generally more consistent with React’s
    overall declarative asynchronous paradigms: you allow the system (React) to schedule
    updates where order but not time are guaranteed. This is in line with a more declarative
    approach to UI and is generally much easier to think about than having to imperatively
    specify updates to data at different times (often a source of race conditions).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 的早期版本中，你可以将一个对象而不是函数作为 `setState` 的第一个参数传递。与当前版本的 React（16 及以上）的一个关键区别是，它可能意味着
    `setState` 是同步的，而实际上，React 会安排状态的变化。`callback` 格式更好地传达了这一概念，并且通常与 React 的整体声明式异步范式更一致：你允许系统（React）安排更新，其中顺序但不是时间是有保证的。这与对
    UI 的更声明式方法相一致，并且通常比在特定时间强制指定数据更新的命令式方法更容易思考。
- en: If you need to make an update to state that depends on the current state or
    props, you can access those through the `prevState` and `props` arguments. That’s
    often useful when you want to do something like toggle a Boolean and need to know
    the exact last value before performing an update.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更新状态，该更新依赖于当前状态或属性，你可以通过 `prevState` 和 `props` 参数访问它们。当你想要执行类似切换布尔值并需要知道在执行更新之前的确切最后值时，这通常很有用。
- en: Let’s focus on the mechanics of `setState` a little more. Using the object returned
    from your `updater` function, it performs a shallow merge into current state.
    This means you can yield an object and React will merge top-level properties on
    the object into state. For example, say you have an object with properties `A`
    and `B`. `B` has some deeply nested properties to it, and `A` is just a string
    (`'hi!'`). Because a shallow merge is being performed, only the top-level properties
    and what they reference will get preserved, not every part of `B`. React won’t
    find some deeply nested property of `B` for you to update. One way around this
    is to make a copy of the object, deeply update it, and then use that. You can
    also use a library like `immutable.js` ([https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/))
    to make working with data structures in React easier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地关注 `setState` 的机制。使用从你的 `updater` 函数返回的对象，它将对当前状态执行浅合并。这意味着你可以提供一个对象，React
    将合并对象上的顶级属性到状态中。例如，假设你有一个具有属性 `A` 和 `B` 的对象。`B` 有一些深层嵌套的属性，而 `A` 只是一个字符串（`'hi!'`）。由于正在执行浅合并，只有顶级属性及其引用将被保留，而不是
    `B` 的每个部分。React 不会为你找到 `B` 的某些深层嵌套属性以供更新。一种解决方法是对对象进行复制，深度更新它，然后使用它。你也可以使用像 `immutable.js`（[https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/））这样的库来使在
    React 中处理数据结构更容易。
- en: setState is a straightforward API to use; you give your ReactClass component
    some data to merge into the current state, and React will handle it for you. And
    if you need to listen for the completion of the process for some reason, you can
    hook into it with the optional `callback` function. [Listing 3.3](kindle_split_014_split_002.xhtml#ch03ex03)
    shows an example of a `setState` shallow merge in action. As before, you can easily
    create and run your React component on CodeSandbox at [https://codesandbox.io/s/0myo6ny4ww](https://codesandbox.io/s/0myo6ny4ww).
    This should save you the trouble of having to set everything up on your machine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`setState` 是一个使用简单的 API；你给你的 ReactClass 组件提供一些要合并到当前状态中的数据，React 会为你处理。如果你需要出于某种原因监听过程的完成，你可以通过可选的
    `callback` 函数连接到它。[列表 3.3](kindle_split_014_split_002.xhtml#ch03ex03) 展示了 `setState`
    浅合并的一个示例。像之前一样，你可以在 CodeSandbox 上轻松创建和运行你的 React 组件，网址为 [https://codesandbox.io/s/0myo6ny4ww](https://codesandbox.io/s/0myo6ny4ww)。这应该可以节省你在机器上设置一切的麻烦。'
- en: Listing 3.3\. Shallow merging with `setState`
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 使用 `setState` 进行浅合并
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* name exists in the initial state under the user property...**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用户属性下的初始状态中存在一个名称...**'
- en: '***2* ...but not in the state you’re setting—if it had been a level up, a shallow
    merge wouldn’t have worked.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* ...但不在你设置的状态中——如果它高一个层级，浅合并就不会起作用。**'
- en: Forgetting about shallow merges can be a common source of bugs when first learning
    React. In this example, when you click the button the `name` property nested within
    the `user` key of the initial state will be overwritten because it doesn’t exist
    in the new state. You wanted to keep both pieces of state, but one ended up overwriting
    the other.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 React 的初期忘记浅合并可能会成为常见的错误来源。在这个例子中，当你点击按钮时，初始状态中嵌套在 `user` 键下的 `name` 属性将被覆盖，因为在新状态中它不存在。你想要保留这两部分状态，但最终一个覆盖了另一个。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking about the setState API**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 setState API 的思考**'
- en: This chapter has talked about React’s component API for managing state in components.
    One of the things mentioned has been that you need to modify state through the
    setState API, not directly. Why do you think that would be a problem and why won’t
    that work? Try it out at [https://codesandbox.io/s/j7p824jxnw](https://codesandbox.io/s/j7p824jxnw).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 React 组件中管理状态的组件 API。提到的一点是，你需要通过 `setState` API 来修改状态，而不是直接修改。你认为这会是什么问题，为什么不会起作用？尝试在
    [https://codesandbox.io/s/j7p824jxnw](https://codesandbox.io/s/j7p824jxnw) 中试试。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '3.2.2\. Immutable state in React: Props'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. React 中的不可变状态：Props
- en: We’ve talked about how React lets you work with data in a mutable way via state
    and `setState`, but what about immutable data in React? In React, props are the
    primary way to pass immutable data. Any component can receive props (not just
    those that inherit from `React.Component`) and use them in their `constructor`,
    `render`, and `lifecycle` methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 React 如何通过状态和 `setState` 让你以可变的方式处理数据，但 React 中的不可变数据呢？在 React 中，props
    是传递不可变数据的主要方式。任何组件都可以接收 props（不仅仅是继承自 `React.Component` 的组件）并在它们的 `constructor`、`render`
    和 `lifecycle` 方法中使用它们。
- en: Props in React are more or less immutable. You can use libraries and other tools
    to emulate immutable data structures in your components, but the React props API
    is semi-immutable by itself. React uses the native JavaScript `Object.freeze`
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze))
    method if available to prevent new properties from being added to it or existing
    properties from being removed. `Object.freeze` also prevents existing properties
    (or their enumerability, configurability, or writability) from being changed and
    prevents the prototype from being changed, too. This goes a long way toward preventing
    you from mutating the `props` object, but it’s not technically a truly immutable
    object (although you can essentially think of it that way).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: React 中的 props 大概是不可变的。你可以使用库和其他工具在你的组件中模拟不可变的数据结构，但 React 的 props API 本身是半不可变的。如果可用，React
    会使用原生的 JavaScript `Object.freeze` 方法([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze))
    来防止向其添加新属性或从其移除现有属性。`Object.freeze` 还防止现有属性（或它们的枚举性、可配置性或可写性）被更改，并防止原型被更改。这有助于防止你修改
    `props` 对象，但这在技术上并不是一个真正的不可变对象（尽管你可以基本上这样认为）。
- en: Props are data that gets passed to React components, either from a parent or
    from the `defaultProps` static method on the component itself. Whereas component
    state is localized to a single component, props are usually passed from a parent
    component. If you’re thinking, “Can I use state in a parent component to pass
    props to a child component?” you’re onto something. State in one component can
    be props for another.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Props 是传递给 React 组件的数据，无论是从父组件还是从组件本身的 `defaultProps` 静态方法。而组件状态是局部化的，仅限于单个组件，props
    通常是从父组件传递的。如果你在想，“我能否在父组件中使用状态来传递 props 给子组件？”你是对的。一个组件的状态可以是另一个组件的 props。
- en: 'Props are usually passed in JSX as attributes, but if you’re using `React.createElement`
    you can pass them directly into a child component via that interface. You can
    pass any valid JavaScript data as a prop to another component—even other components
    (which are only classes after all). Once props are passed into a component for
    use, you shouldn’t change them from within the component. You can try, but you’ll
    probably get a nice error like `Uncaught TypeError: Cannot assign to read-only
    property ''<myProperty>'' of object ''#<Object>''`—or worse, your React app won’t
    work as expected because you’re violating the expected use.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'Props通常作为属性传递给JSX，但如果你使用`React.createElement`，你可以通过该接口直接将它们传递给子组件。你可以将任何有效的JavaScript数据作为prop传递给另一个组件——甚至其他组件（毕竟它们只是类）。一旦props被传递给组件以供使用，你不应该从组件内部更改它们。你可以尝试，但你可能会得到一个像`Uncaught
    TypeError: Cannot assign to read-only property ''<myProperty>'' of object ''#<Object>''`这样的错误——或者更糟，你的React应用可能不会按预期工作，因为你违反了预期的使用。'
- en: '[Listing 3.4](kindle_split_014_split_002.xhtml#ch03ex04) in the next section
    shows some ways you can access props and how not to assign to them. As noted before,
    properties can change over time, but not from within the component. This is part
    of one-way data flow—a topic covered in later chapters. In short, *one-way* means
    changing data flows down through components from parent components to children.
    A parent component using state (inheriting from `React.Component`) can change
    its state, and that changed state can be what is passed down as properties to
    child components, thus changing properties.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分中的[列表3.4](kindle_split_014_split_002.xhtml#ch03ex04)展示了你可以如何访问props以及如何不将它们分配给它们。正如之前所述，属性可能会随时间变化，但不是从组件内部。这是单向数据流的一部分——这是后续章节中讨论的主题。简而言之，*单向*意味着数据从父组件流向子组件，通过组件向下流动。使用状态（从`React.Component`继承）的父组件可以更改其状态，并且这种更改后的状态可以作为属性传递给子组件，从而改变属性。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Calling setState in a render method**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**在render方法中调用setState**'
- en: We’ve established that `setState` is how you can update a component’s state.
    Where can you call `setState`? We’ll look at which points of the component lifecycle
    allow you to call `setState` in the next chapter, but for now let’s focus on just
    the `render` method. What do you think happens when `setState` is called in a
    component’s `render` method? Try it at [https://codesandbox.io/s/48zv2nwqww](https://codesandbox.io/s/48zv2nwqww).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定`setState`是更新组件状态的方法。你可以在哪里调用`setState`？我们将在下一章中探讨哪些组件生命周期点允许你调用`setState`，但现在是时候专注于`render`方法了。你认为在组件的`render`方法中调用`setState`会发生什么？尝试在[https://codesandbox.io/s/48zv2nwqww](https://codesandbox.io/s/48zv2nwqww)中试试。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '3.2.3\. Working with props: PropTypes and default props'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3. 与props一起工作：PropTypes和默认props
- en: 'When working with props, you have a few APIs available to you that can help
    you during development: PropTypes and default props. PropTypes provides a typechecking
    functionality in which you can specify what sort of props your component will
    expect to receive when used. You can specify data types and even tell the component
    consumer what sort of shape of data they need to provide (an object with a user
    property that has certain keys, for example). In past versions of React, PropTypes
    was part of the core `React` library, but now lives alone as the `prop-types`
    package ([https://github.com/facebook/prop-types](https://github.com/facebook/prop-types)).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用props时，你有一些API可用，这些API可以在开发过程中帮助你：PropTypes和默认props。PropTypes提供了一种类型检查功能，你可以指定组件在使用时预期接收到的props类型。你可以指定数据类型，甚至告诉组件消费者他们需要提供的数据形状（例如，一个具有用户属性且具有某些键的对象）。在React的早期版本中，PropTypes是核心`React`库的一部分，但现在它作为一个独立的`prop-types`包存在([https://github.com/facebook/prop-types](https://github.com/facebook/prop-types))。
- en: The `prop-types` library isn’t magic—it’s a set of functions and properties
    that can help do typechecking on inputs. It’s also not specific to React—you could
    just as easily use it in another library where you wanted to do typechecking on
    inputs. You could, for example, bring `prop-types` into another component-driven
    framework similar to React, like Preact ([https://preactjs.com](https://preactjs.com)),
    and use it similarly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`prop-types`库并不是魔法——它是一组函数和属性，可以帮助对输入进行类型检查。它也不特定于React——你同样可以在其他库中使用它，如果你想在输入上进行类型检查的话。例如，你可以将`prop-types`引入另一个类似于React的组件驱动框架，如Preact([https://preactjs.com](https://preactjs.com))，并类似地使用它。'
- en: To set PropTypes for a component, you provide a static property on the class
    called `propTypes`. Notice in [listing 3.4](kindle_split_014_split_002.xhtml#ch03ex04)
    that the name of the static property you set on a component class is lowercase,
    whereas the name of the object you access from the `prop-types` library is uppercase
    (`PropTypes`). To specify which props your component needs, you add the name of
    the prop you want to validate and assign it a property from the `prop-types` library’s
    default export (`import PropTypes from 'prop-types'`). Using PropTypes, you can
    declare just about any type, shape, and requirement type (optional or mandatory)
    for your props.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要为组件设置 PropTypes，您需要在类上提供一个名为 `propTypes` 的静态属性。注意在 [列表 3.4](kindle_split_014_split_002.xhtml#ch03ex04)
    中，您在组件类上设置的静态属性名称为小写，而您从 `prop-types` 库访问的对象名称为大写 (`PropTypes`)。要指定组件需要的 props，您添加您想要验证的
    prop 名称，并将其分配给 `prop-types` 库默认导出的属性（`import PropTypes from 'prop-types'`）。使用
    PropTypes，您可以声明几乎任何类型的 props、形状和要求类型（可选或必需）。
- en: Another tool you can use to make your development experience easier is default
    props. Remember how you can provide an initial state to your component using the
    class `constructor`? You can do something similar for props, too. You can provide
    a static property called `defaultProps` to provide default props to your component.
    Using default props can be helpful to ensure that your component will have what
    it needs to run, even if someone using the component forgets to provide a prop
    to it. The following listing shows an example of using PropTypes and default props
    in a component. Run the code at [https://codesandbox.io/s/31ml5pmk4m](https://codesandbox.io/s/31ml5pmk4m).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以帮助您使开发体验更轻松的工具是默认 props。还记得您如何可以使用类 `constructor` 为组件提供一个初始状态吗？您也可以为 props
    做类似的事情。您可以为组件提供一个名为 `defaultProps` 的静态属性，以提供默认 props。使用默认 props 可以帮助确保您的组件将拥有运行所需的一切，即使使用组件的人忘记提供
    prop。
- en: Listing 3.4\. Immutable props in React components
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. React 组件中的不可变 props
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Specify an object with a “shape.”**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定一个具有“形状”的对象。**'
- en: '***2* You can chain any propTypes with isRequired to make sure a warning is
    shown if the prop isn’t shown.**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您可以将任何与 isRequired 连接的 propTypes 链接起来，以确保如果属性未显示时显示警告。**'
- en: 3.2.4\. Stateless functional components
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以下列表展示了在组件中使用 PropTypes 和默认 props 的示例。在 [https://codesandbox.io/s/31ml5pmk4m](https://codesandbox.io/s/31ml5pmk4m)
    运行代码。
- en: What do you do if you want to create a simple component that only uses props
    and no state? It turns out this is a common use case, especially with some of
    the common React-friendly application architectural patterns that we’ll explore
    later in the book, like Flux and Redux. In these cases, you often want to keep
    state in a centralized location and not distributed across your components. But
    only using props is also useful in other situations. It would be nice to incur
    less of a resource usage penalty for your app if React didn’t have to manage a
    backing instance for you.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个仅使用 props 而不使用状态的简单组件，您会怎么做？实际上，这是一个常见的用例，尤其是在本书后面将要探讨的一些常见的 React 友好的应用程序架构模式中，如
    Flux 和 Redux。在这些情况下，您通常希望将状态保存在集中位置，而不是分散在您的组件中。但仅使用 props 在其他情况下也很有用。如果 React
    不必为您管理后端实例，那么您的应用程序的资源使用惩罚将会更小。
- en: 'As it turns out, there is a type of component you can create that only uses
    props: a stateless functional component. These components are sometimes called
    *stateless* components, *functional* components, and other similar names by developers,
    which can make it hard to keep track of what’s being talked about. They usually
    mean the same thing: a React component that doesn’t inherit from `React.Component`
    and therefore doesn’t get access to component state or other lifecycle methods.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您可以创建一种仅使用 props 的组件：一个无状态函数组件。这些组件有时被开发者称为 *无状态* 组件、*函数* 组件和其他类似名称，这可能会让人难以跟踪正在讨论的内容。它们通常意味着同一件事：一个不继承自
    `React.Component` 的 React 组件，因此无法访问组件状态或其他生命周期方法。
- en: 'A stateless functional component is, not surprisingly, just that: a component
    that doesn’t have access to or use the React state API (or the other methods inherited
    from `React.Component`). It is stateless not because it doesn’t have any kind
    of (general) state whatsoever, but because it doesn’t get a backing instance that
    React will manage for you. This means no lifecycle methods (covered in [Chapter
    4](kindle_split_015_split_000.xhtml#ch04)), no component state, and potentially
    less memory.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态函数组件，不出所料，就是这样：一个没有访问或使用React状态API（或从`React.Component`继承的其他方法）的组件。它之所以是无状态的，并不是因为它完全没有任何类型的（一般）状态，而是因为它没有React为你管理的后端实例。这意味着没有生命周期方法（在第4章中介绍），没有组件状态，并且可能占用更少的内存。
- en: Stateless functional components are functional because they can be written as
    named functions or anonymous function expressions assigned to a variable. They
    only take props and, because they return the same output based on a given input,
    are essentially considered pure. This makes them fast, as React will potentially
    be able to make optimizations by avoiding unnecessary lifecycle checks or memory
    allocations. The following listing shows a simple example of a stateless functional
    component. Run the code at [https://codesandbox.io/s/l756002969](https://codesandbox.io/s/l756002969).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态函数组件之所以是函数式的，是因为它们可以被编写为命名函数或匿名函数表达式，并分配给一个变量。它们只接受props，并且因为它们基于给定的输入返回相同的输出，所以本质上被认为是纯函数。这使得它们运行速度快，因为React可能会通过避免不必要的生命周期检查或内存分配来进行优化。以下列表展示了无状态函数组件的一个简单示例。在[https://codesandbox.io/s/l756002969](https://codesandbox.io/s/l756002969)运行代码。
- en: Listing 3.5\. Stateless functional components
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5. 无状态函数组件
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Stateless functional components can be created with functions or anonymous
    functions.**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无状态函数组件可以用函数或匿名函数创建。**'
- en: '***2* For either form of stateless functional component, you can specify propTypes
    and default props as properties on the function or variable.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于无状态函数组件的任何形式，你都可以在函数或变量上指定propTypes和默认props作为属性。**'
- en: Stateless functional components can be powerful, especially when used in combination
    with a parent component that has a backing instance. Rather than having to set
    state across multiple components, you can create a single stateful parent component
    and use lightweight child components for the rest. In [chapters 10](kindle_split_022_split_000.xhtml#ch10)
    and [11](kindle_split_023_split_000.xhtml#ch11), we’ll look at using Redux to
    take this pattern to a whole new level. In React applications that use Redux,
    you usually end up creating fewer stateful components (although there are still
    cases where this makes sense) and instead centralize state in a single location
    (the store).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态函数组件可以非常强大，尤其是在与具有后端实例的父组件结合使用时。你不必在多个组件之间设置状态，可以创建一个单一的状态父组件，并使用轻量级的子组件来完成其余工作。在第10章和第11章中，我们将探讨如何使用Redux将这种模式提升到一个全新的水平。在使用Redux的React应用程序中，你通常创建较少的状态组件（尽管仍然有一些情况这样做是有意义的），并将状态集中在一个单一的位置（存储库）。
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using state in one component to modify props in another**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**在一个组件中使用状态来修改另一个组件的props**'
- en: This chapter has talked about props and state as the primary ways you can work
    with and pass around data in React components. You should never directly modify
    either state or props, but with `setState` you can tell React to update a component’s
    state. How would you use state in one component to modify the props in another?
    Head to [https://codesandbox.io/s/38zq71q75](https://codesandbox.io/s/38zq71q75)
    to try it out.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经讨论了props和状态作为你在React组件中处理和传递数据的主要方式。你不应该直接修改状态或props，但使用`setState`你可以告诉React更新组件的状态。你将如何在一个组件中使用状态来修改另一个组件的props？前往[https://codesandbox.io/s/38zq71q75](https://codesandbox.io/s/38zq71q75)尝试一下。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3\. Component communication
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 组件通信
- en: When you built your simple comment box component, you saw that you can create
    components from other components. That’s one reason why React is great. You can
    easily build other components from subcomponents while keeping things nicely bundled
    up. You’re also easily able to express *is-a* and *has-a* relationships between
    components. That means you can think about components as *having a* part to them
    as well as *being a* certain thing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建简单的评论框组件时，您可以看到您可以从其他组件中创建组件。这就是React很棒的一个原因。您可以从子组件轻松构建其他组件，同时保持事物很好地捆绑在一起。您还很容易表达组件之间的“是”和“有”的关系。这意味着您可以将组件视为既有“部分”也有“特定事物”。
- en: It’s great that you can mix and match components and flexibly build things,
    but how do you get them to talk to each other? Many frameworks and libraries offer
    a framework-specific method to get different parts of the application to talk
    to each other. In Angular.js or Ember.js, you may have heard of or used a service
    to communicate between different parts of your application. Usually these are
    broadly available, long-lived objects that you can store state in and access from
    different parts of your application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合和匹配组件并灵活地构建事物，但这如何使它们相互通信呢？许多框架和库提供了一种特定于框架的方法，使应用程序的不同部分能够相互通信。在Angular.js或Ember.js中，您可能听说过或使用过服务来在应用程序的不同部分之间进行通信。通常这些是广泛可用、长期存在的对象，您可以在其中存储状态并在应用程序的不同部分访问它们。
- en: 'Does React use services or something similar? No. In React, if you want components
    to communicate with each other, you pass props, and when you pass props, you’re
    doing two simple things:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: React使用服务或类似的东西吗？不。在React中，如果您想让组件相互通信，您传递props，当您传递props时，您正在做两件简单的事情：
- en: Accessing data in the parent (either state or props)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问父组件中的数据（无论是状态还是属性）
- en: Passing that data to a child component
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该数据传递给子组件
- en: The following listing shows an example of both the parent-child relationship
    you’re familiar with and the owner-ownee relationship. Run it at [https://codesandbox.io/s/pm18mlz8jm](https://codesandbox.io/s/pm18mlz8jm).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了您熟悉的父子关系以及所有者-被所有者关系。在[https://codesandbox.io/s/pm18mlz8jm](https://codesandbox.io/s/pm18mlz8jm)运行它。
- en: Listing 3.6\. Passing props from parent to child
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6. 从父组件向子组件传递属性
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Create a stateless functional component that returns an example image.**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个无状态的函数组件，返回一个示例图像。**'
- en: '***2* Remember, you can still specify default props and propTypes even on stateless
    functional components.**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 记住，即使在无状态的函数组件上，您也可以指定默认属性和propTypes。**'
- en: '***3* UserCard is a parent to UserProfile and UserProfileLink.**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* UserCard是UserProfile和UserProfileLink的父组件。**'
- en: 3.4\. One-way data flow
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 单向数据流
- en: 'If you’ve developed web applications using frameworks before, you may be familiar
    with the term *two-way data binding*. Data binding is the process that establishes
    a connection between the application UI and other data. In practice, this is often
    manifested as something like a library or framework connecting app data like models
    (a user) to the user interface and keeps them in sync. They’re synchronized and
    are therefore bound together. Another way to think of this that’ll be more helpful
    in React is as a *projection*: UI is the data projected into a view, and when
    the data changes, the view changes, as illustrated in [figure 3.3](kindle_split_014_split_004.xhtml#ch03fig03).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过框架开发过Web应用程序，您可能对术语“双向数据绑定”很熟悉。数据绑定是建立应用程序UI与其他数据之间连接的过程。在实践中，这通常表现为类似库或框架连接应用程序数据（如模型（用户））到用户界面并保持它们同步的东西。它们是同步的，因此被绑定在一起。在React中，另一种更有帮助的思考方式是将其视为“投影”：UI是将数据投影到视图中的数据，当数据发生变化时，视图也会随之变化，如图3.3所示。
- en: Figure 3.3\. Data binding usually refers to the process of setting up a connection
    between data in your app and the view (the display of that data). Another way
    to think of this is as a projection of the data into something the user can see
    (for example, a view).
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3. 数据绑定通常指的是在您的应用程序数据和视图（数据的显示）之间建立连接的过程。另一种思考方式是将数据投影到用户可以看到的东西上（例如，一个视图）。
- en: '![](Images/03fig03.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig03.jpg)'
- en: 'Another way to think about data binding is as data *flow*: how does data move
    through different parts of your application? Essentially, you’re asking, “What
    can update what, from where, and how?” It’s important to understand how the tools
    you’re using shape, manipulate, and move data around if you want to use them well.
    Different libraries and frameworks take different approaches to data flow (React
    is no different in having its own opinion about how to do this).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考数据绑定的方式是数据*流动*：数据是如何在应用程序的不同部分之间移动的？本质上，你是在问，“什么可以更新什么，从哪里，以及如何？”如果你想要有效地使用这些工具，了解这些工具如何塑造、操作和移动数据是非常重要的。不同的库和框架对数据流采取了不同的方法（React在这方面也不例外，它有自己的看法）。
- en: In React, data flows in one direction. That means that rather than flow between
    entities in a horizontal way where each can update the other, a hierarchy is established.
    You can pass data through components but can’t reach out and modify the state
    or props of other components without passing props. You also can’t modify the
    data in a parent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，数据单向流动。这意味着，而不是在实体之间以水平方式流动，每个实体都可以更新另一个实体，而是建立了一个层次结构。你可以通过组件传递数据，但不能伸手修改其他组件的状态或属性，除非传递属性。你也不能修改父组件中的数据。
- en: But you can pass data back up the hierarchy via callbacks. When a parent receives
    a callback from a child component, it can change its data and send the changed
    data back down to the child components. Even in this scenario with callbacks,
    data still flows downwards in aggregate and remains determined by the parent passing
    that data down. That’s why we say that in React data flows unidirectionally, as
    shown in [figure 3.4](kindle_split_014_split_004.xhtml#ch03fig04).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以通过回调函数将数据向上传递到层次结构的更高层。当一个父组件从子组件接收到回调时，它可以更改其数据并将更改后的数据向下发送给子组件。即使在有回调的这种场景中，数据总体上仍然向下流动，并且由传递数据的父组件决定。这就是为什么我们说在React中数据是单向流动的，如图3.4所示[figure
    3.4](kindle_split_014_split_004.xhtml#ch03fig04)。
- en: Figure 3.4\. Data flows one way in React. Props are passed from parent to child
    (from owner to ownee), and children can’t edit the state or props of a parent
    component. Each component that has a backing instance can modify its own state
    but can’t modify anything outside itself apart from setting the props of one of
    its children.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4. React中数据单向流动。属性从父组件传递到子组件（从所有者传递到拥有者），子组件不能编辑父组件的状态或属性。每个具有后端实例的组件可以修改自己的状态，但不能修改自身之外的东西，除了设置其子组件的属性。
- en: '![](Images/03fig04.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig04.jpg)'
- en: Unidirectional flow is especially helpful in building UIs because it tends to
    make it easier to think about the way data moves through an application. Thanks
    to the hierarchy of components and the way props and state are localized to components,
    it’s generally easier to predict how data moves through an application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 单向流在构建用户界面（UIs）时特别有用，因为它往往使人们更容易思考数据在应用程序中的流动方式。由于组件的层次结构和属性（props）以及状态（state）在组件中的局部化，通常更容易预测数据在应用程序中的流动方式。
- en: It might sound nice in some ways to eschew this hierarchy and have the freedom
    to modify whatever you want from any part of your application, but in practice
    that tends to lead to applications that are hard to think about and can result
    in difficult debugging situations. Later chapters will explore architectural patterns
    like Flux and Redux that allow you to maintain a unidirectional data flow paradigm
    while coordinating actions that can occur across components or across your application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，避免这种层次结构并拥有从应用程序的任何部分修改任何内容的自由可能听起来很吸引人，但在实践中，这往往会导致难以思考的应用程序，并可能导致难以调试的情况。后面的章节将探讨像Flux和Redux这样的架构模式，这些模式允许你在协调跨组件或跨应用程序的操作的同时，保持单向数据流范式。
- en: 3.5\. Summary
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 摘要
- en: 'This chapter discussed the following topics:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了以下主题：
- en: State is the information available to a program at a given moment in time.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是程序在某一时刻可用的信息。
- en: Immutable state doesn’t change, whereas mutable state does change.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变状态不会改变，而可变状态会改变。
- en: Persistent, immutable data structures don’t change—they only record their changes
    and make copies of themselves.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久的不变数据结构不会改变——它们只记录它们的更改并复制自己。
- en: Ephemeral, mutable data structures are wiped out when they’re updated.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它们被更新时，短暂的可变数据结构会被清除。
- en: React uses both mutable (local component state) and pseudo-immutable data (props).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React使用可变数据（本地组件状态）和伪不可变数据（属性）。
- en: Props are pseudo-immutable and should not be modified once set.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是伪不可变的，一旦设置就不应该修改。
- en: Component state is tracked by a backing instance and can be modified with `setState`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件状态由一个后端实例跟踪，并且可以通过`setState`进行修改。
- en: '`setState` performs a shallow merge of data and updates your component’s state,
    preserving any top-level properties that aren’t overwritten.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setState`执行数据的浅层合并并更新你的组件状态，保留任何未被覆盖的顶层属性。'
- en: Data flows one way in React, from parents to children. Children can yield back
    data to a parent via a callback, but they can’t directly modify the parent’s state,
    and a parent can’t directly modify a child’s state. Component interaction is done
    via props instead.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中，数据单向流动，从父组件流向子组件。子组件可以通过回调向父组件返回数据，但不能直接修改父组件的状态，父组件也不能直接修改子组件的状态。组件交互是通过props完成的。
- en: In [chapter 4](kindle_split_015_split_000.xhtml#ch04), we’ll build on your knowledge
    of state in React and look at how to use lifecycle methods to hook into React’s
    render and update process. We’ll also start to explore change detection in React
    and you’ll start to build out the Letters Social app using your newly learned
    React skills!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章](kindle_split_015_split_000.xhtml#ch04)中，我们将基于你对React中状态的了解，探讨如何使用生命周期方法来挂钩React的渲染和更新过程。我们还将开始探索React中的变化检测，你将开始使用新学的React技能构建Letters
    Social应用程序！
- en: Chapter 4\. Rendering and lifecycle methods in React
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：React中的渲染和生命周期方法
- en: '*This chapter covers*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Getting set up with the application repository
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序仓库
- en: The rendering process
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染过程
- en: Lifecycle methods
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: Updating React components
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新React组件
- en: Creating a newsfeed using React
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React创建新闻源
- en: In this chapter, you’re going to start to pull together some of the concepts
    and skills we’ve covered so far to create your first React app. In past chapters,
    we’ve talked about dealing with data in React and the different ways that you
    can work with mutable (changeable) and immutable (unchangeable) data. But to build
    even more robust components, you need to take advantage of the full component
    API, dive into lifecycle methods, and learn about the rendering process in React.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开始整合我们之前所涵盖的一些概念和技能，以创建你的第一个React应用程序。在之前的章节中，我们讨论了在React中处理数据以及你可以以不同方式处理可变（可更改）和不可变（不可更改）数据。但要构建更健壮的组件，你需要充分利用完整的组件API，深入了解生命周期方法，并学习React中的渲染过程。
- en: We’ll take a look at *rendering*, the process that React uses to turn your data
    into a user interface, and some ways to interact with a component over its lifecycle,
    called *lifecycle methods*. You’ll combine this with some of what you already
    know about reading and modifying data in React (props and state), updating your
    component state, and passing data to different components.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨*渲染*，这是React将你的数据转换为用户界面的过程，以及一些与组件在其生命周期中交互的方法，称为*生命周期方法*。你将结合你已知的关于在React中读取和修改数据（props和state）的知识，更新你的组件状态，并将数据传递到不同的组件。
- en: 4.1\. Getting set up with the Letters Social repo
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 配置Letters Social仓库
- en: 'In this chapter, you’re going to start building the application Letters Social.
    We’ll pretend that we’re a startup focusing on creating the next great social
    networking application. Our company, Letters—ingeniously named to differentiate
    us from web giants like Alphabet—is working on Social. You’ll use React to build
    this application over the course of the book. By the end of the book, Letters
    Social will be using server-side rendering, Redux, and React. The application,
    shown in [figure 4.1](kindle_split_015_split_001.xhtml#ch04fig01), supports a
    few features worth noting here so you know what you’ll be building over the course
    of the book:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开始构建应用程序Letters Social。我们将假装我们是一家初创公司，专注于创建下一个伟大的社交网络应用程序。我们的公司，Letters——巧妙地命名以区别于像Alphabet这样的网络巨头——正在开发Social。你将在本书的过程中使用React来构建这个应用程序。到本书结束时，Letters
    Social将使用服务器端渲染、Redux和React。该应用程序，如图4.1所示（kindle_split_015_split_001.xhtml#ch04fig01），支持一些值得注意的功能，以便你知道你将在本书的过程中构建什么：
- en: Creating posts that have text
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含文本的帖子
- en: Adding locations to posts with Mapbox
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mapbox向帖子添加位置
- en: Liking and commenting on posts
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点赞和评论帖子
- en: Providing OAuth authentication via GitHub and Firebase
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GitHub和Firebase提供OAuth身份验证
- en: Displaying posts in a newsfeed
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新闻源中显示帖子
- en: Using basic pagination
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本分页
- en: Figure 4.1\. Letters Social, the React app that you’ll be building in this book.
    You can check out its source code at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)
    and the app at [https://social.react.sh](https://social.react.sh).
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1. Letters Social，您将在本书中构建的React应用程序。您可以在[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)查看其源代码，并在[https://social.react.sh](https://social.react.sh)查看应用程序。
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig01_alt.jpg)'
- en: We’ll go through each of these features in this and the following chapters.
    To make things easier for you, I’ve created a Git branch for [chapters 4](kindle_split_015_split_000.xhtml#ch04)
    through [12](kindle_split_024_split_000.xhtml#ch12). Each chapter (or paired chapters
    in some cases) represents the code as it stands at the end of that chapter. For
    example, if you check out the Git branch for [chapters 5](kindle_split_016_split_000.xhtml#ch05)
    and [6](kindle_split_017_split_000.xhtml#ch06), you’ll have the code for the end
    of those chapters. This will let you look ahead if you like, and you can start
    from any chapter. If you wanted to work through [chapter 9](kindle_split_020_split_000.xhtml#ch09)
    (covering testing React applications), for instance, you could check out the code
    for [chapters 7](kindle_split_018_split_000.xhtml#ch07) and [8](kindle_split_019_split_000.xhtml#ch08)
    and start from there. I’ve tried to make it as easy as possible for you to check
    out code, but you can use the Git repository and branches however you’d like.
    Feel free to open pull requests with questions or fork it to use as a starting
    place for new features you want to add to the app.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章和下一章中逐一介绍这些功能。为了使您更容易理解，我已为第4章至第12章（kindle_split_015_split_000.xhtml#ch04
    至 kindle_split_024_split_000.xhtml#ch12）创建了Git分支。每个章节（在某些情况下是成对的章节）代表了该章节结束时的代码状态。例如，如果您检查第5章（kindle_split_016_split_000.xhtml#ch05）和第6章（kindle_split_017_split_000.xhtml#ch06）的Git分支，您将拥有这些章节结束时的代码。这将让您可以提前查看，并且可以从任何章节开始。如果您想学习第9章（kindle_split_020_split_000.xhtml#ch09）（涵盖测试React应用程序），例如，您可以检查第7章（kindle_split_018_split_000.xhtml#ch07）和第8章（kindle_split_019_split_000.xhtml#ch08）的代码，并从那里开始。我已经尽力使您检查代码变得尽可能容易，但您可以使用Git仓库和分支以您喜欢的方式使用。如果您有任何问题，请随时通过pull
    requests提出，或者将其fork作为添加新功能的起点。您也可以通过README与我联系，如果您有任何问题（或者只是喜欢这本书！）。您可以通过README这样做。
- en: You can also read some basic documentation about the files in the source code
    at [https://docs.react.sh](https://docs.react.sh). It’s not comprehensive, but
    if you’d like to get a sense of the code and you like JSDoc-style documentation,
    the docs will be a good place to go. The README for the repo also lists a number
    of helpful resources. As always, feel free to reach out to me if you have questions
    (or if you just like the book!). You can do that through the README.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://docs.react.sh](https://docs.react.sh)阅读一些关于源代码中文件的基本文档。它不是全面的，但如果您想了解代码并喜欢JSDoc风格的文档，这些文档将是一个不错的选择。仓库的README也列出了许多有用的资源。一如既往，如果您有任何问题，请随时联系我（或者只是喜欢这本书！）。您可以通过README这样做。
- en: 4.1.1\. Getting the source code
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1. 获取源代码
- en: 'To get the source code, go to [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    This is the repository where all the source code related to the book is stored.
    There are several other repos in the React in Action GitHub Organization, so feel
    free to check those out, too. The main source code is in the [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    Head there and either download the source or use the following command to clone
    the repository:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取源代码，请访问[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)。这是存储与本书相关的所有源代码的仓库。React
    in Action GitHub 组织中还有其他几个仓库，您也可以随意查看。主要源代码位于[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)。前往该地址，您可以下载源代码或使用以下命令克隆仓库：
- en: '[PRE8]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That will clone the repository in the current directory and switch to the start
    branch (the starting branch for the project). The next step is to install dependencies.
    We’ll use npm ([www.npmjs.com](http://www.npmjs.com)) in this book for the sake
    of consistency, but if you prefer to use yarn (another dependency management library
    that wraps npm, at [https://yarnpkg.com](https://yarnpkg.com)), you can do that,
    too. You’ll just need to ensure that you install with yarn, not npm.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中克隆仓库并切换到起始分支（项目的起始分支）。下一步是安装依赖项。为了保持一致性，本书中将使用 npm ([www.npmjs.com](http://www.npmjs.com))，但如果你更喜欢使用
    yarn（另一个包装 npm 的依赖管理库，位于 [https://yarnpkg.com](https://yarnpkg.com)），你也可以这样做。你只需确保使用
    yarn 而不是 npm 进行安装。
- en: 'All the modules you’ll need for the entire book should be included in package.json
    in the application source. To install, run the following command in the source
    code directory:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的所有模块都应该包含在应用程序源代码的 package.json 中。要安装，请在源代码目录中运行以下命令：
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That will install all the dependencies you’ll need. If you change versions of
    node (via nvm or another means), you’ll need to reinstall your node modules because
    different versions of node will compile different modules differently (like node-sass).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装你需要的所有依赖项。如果你更改了 node 的版本（通过 nvm 或其他方式），你需要重新安装你的 node 模块，因为不同版本的 node 会以不同的方式编译不同的模块（如
    node-sass）。
- en: 4.1.2\. Which version of node should I use?
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2. 我应该使用哪个版本的 node？
- en: This is a good time to talk about which version of node to use. I recommend
    using the latest stable version. At the time of writing, that was the 8.X release
    line. I won’t support versions of node earlier than 6.X, and it makes more sense
    to support 8.X or greater since this isn’t a business or production environment
    where you can’t easily switch between versions without extensive testing. Node
    8.X also uses a newer version of npm and contains significant speed improvements
    made to the underlying V8 engine.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论应该使用哪个版本的 node 的好时机。我建议使用最新稳定版本。在撰写本文时，那是 8.X 版本线。我不会支持低于 6.X 的 node 版本，而且支持
    8.X 或更高版本更有意义，因为这不是一个商业或生产环境，你无法在不进行大量测试的情况下轻松切换版本。Node 8.X 还使用了更新的 npm 版本，并包含了对底层
    V8 引擎的重大速度改进。
- en: If you don’t have one of these versions of node on your computer, head to [https://nodejs.org](https://nodejs.org)
    to download a copy of the latest stable version of node. Another option is to
    use the nvm command-line tool to install copies of node locally and be able to
    switch between them. You can check out the nvm tool at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你电脑上没有这些版本的 node，请访问 [https://nodejs.org](https://nodejs.org) 下载最新稳定版本的 node。另一个选项是使用
    nvm 命令行工具在本地安装 node 的副本，并能够在它们之间切换。你可以在 [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    查看 nvm 工具。
- en: Different versions of node support different features of JavaScript, so it’s
    important to know what the version you’re using supports. If you’d like to know
    more about which features yours supports and which versions others do (or will),
    check out [http://node.green](http://node.green) to see feature implementation
    across versions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不同版本的 node 支持不同的 JavaScript 功能，因此了解你使用的版本支持哪些功能很重要。如果你想了解更多关于你的版本支持哪些功能以及其他版本支持哪些（或将要支持哪些）的信息，请访问
    [http://node.green](http://node.green) 以查看不同版本的功能实现。
- en: 4.1.3\. Note on tooling and CSS
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3. 工具和 CSS 的注意事项
- en: As I mention in other places in this book, tooling around JavaScript applications
    can be a complex and fast-moving target. It’s also a domain that deserves its
    own treatment. For these reasons, I won’t be covering how to set up things like
    Webpack, Babel, or other tools. The application source code has a development
    and build process in place, and you’re free to explore the configuration I’ve
    set up, but that’s outside the scope of this book, so I won’t be covering it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本书的其他地方提到的，围绕 JavaScript 应用程序的工具可能是一个复杂且快速变化的目标。这也是一个值得单独讨论的领域。出于这些原因，我不会介绍如何设置
    Webpack、Babel 或其他工具。应用程序源代码已经实现了开发和构建过程，你可以自由探索我设置的配置，但这超出了本书的范围，因此我不会涉及它。
- en: Another point worth making is about CSS. I’ve already covered the ways you work
    with inline styles in React, but CSS is also generally out of the scope of this
    book. For that reason, I’ve created all the styles you’ll need. Any UI markup
    you see has styles created for it. Some styles depend on certain types or hierarchies,
    so if you move different elements around or change CSS class names, you can expect
    the app to look broken. My aim is to give you one less thing to think about while
    learning React, but if you’re interested in playing around with the app’s styling,
    go right ahead.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点是关于CSS的。我已经介绍了您在React中处理内联样式的方法，但CSS通常也不在本书的范围之内。因此，我为您创建了所有需要的样式。您看到的任何UI标记都有为其创建的样式。某些样式依赖于特定的类型或层次结构，因此如果您移动不同的元素或更改CSS类名，您可能会发现应用看起来破损。我的目标是让您在学习React时少考虑一件事情，但如果您对玩转应用样式感兴趣，请随意进行。
- en: 4.1.4\. Deploying
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 部署
- en: The app running at [https://social.react.sh](https://social.react.sh) is deployed
    to [https://zeit.co](https://zeit.co), but if, for some reason in the future,
    circumstances arise that require a change, I’ll keep the app running at whatever
    cloud solution makes the most sense at the time. You don’t need to be concerned
    with what the app is hosted on. If at the end of the book you find yourself wanting
    to fork and add to the app for your own learning and enjoyment, you’ll need to
    determine the best way to deploy the app for yourself. Fortunately, the build
    and runtime processes are straightforward, so you should find it relatively easy
    to deploy somewhere else.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在[https://social.react.sh](https://social.react.sh)的应用已部署到[https://zeit.co](https://zeit.co)，但如果未来由于某些原因需要更改，我会根据当时最合理的云解决方案来保持应用运行。您无需担心应用托管在何处。如果在书的结尾您想对应用进行分支并添加以供自己学习和娱乐，您需要确定最适合自己部署应用的最佳方式。幸运的是，构建和运行过程都很直接，因此您应该会发现将其部署到其他地方相对容易。
- en: 4.1.5\. The API server and database
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5\. API服务器和数据库
- en: 'To prevent you from having to run a database like MongoDB or PostgreSQL, we’ll
    use a simulated REST API via the `JSON-server` library ([https://github.com/typicode/json-server](https://github.com/typicode/json-server)).
    I’ve made some modifications to the default server (which you can see in the db
    folder of the repo) that help make the project a little bit easier. Rather than
    work with a database, you’ll get a lightweight database that works by reading
    and modifying a JSON file. To create sample data or reset your application data,
    you can run this command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免您需要运行像MongoDB或PostgreSQL这样的数据库，我们将通过`JSON-server`库（[https://github.com/typicode/json-server](https://github.com/typicode/json-server)）使用模拟REST
    API。我对默认服务器（您可以在仓库的db文件夹中看到）进行了一些修改，这有助于使项目变得更容易一些。您将不会与数据库交互，而是得到一个轻量级的数据库，它通过读取和修改JSON文件来工作。要创建示例数据或重置应用程序数据，您可以运行以下命令：
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That will overwrite the existing JSON database and replace it with new sample
    data (the users, posts, and comments are all *Star Wars*-themed—may the Force
    be with you). In later chapters, you’ll be able to create a user in the database
    after you log in. If you rerun the database `seed` command, your user will get
    overwritten, and you’ll have to log out and log back in to get things fixed. That
    shouldn’t happen, and you probably won’t need to run the database command more
    than once, but you should be aware of what it means to reset your data just in
    case.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将覆盖现有的JSON数据库，并用新的示例数据（用户、帖子以及评论都是基于*星球大战*主题——愿原力与你同在）替换它。在后续章节中，您在登录后将在数据库中创建一个用户。如果您重新运行数据库`seed`命令，您的用户将被覆盖，您需要注销并重新登录以解决问题。这种情况不应该发生，您可能不需要多次运行数据库命令，但您应该了解重置数据意味着什么，以防万一。
- en: I’ve included a number of helpers to make it easier to make requests to the
    API. You can see these functions in src/shared/http.js. I’m making use of the
    `isomorphic-fetch` library ([https://github.com/matthew-andrews/isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch))
    because it mirrors the standard Fetch API available in browsers, but also runs
    on the server. I’ll assume you have some experience with an HTTP library in the
    browser, but if not you can use the included helper files as a way to start learning
    about the Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我包含了一些辅助工具，以便更容易地向 API 发送请求。你可以在 src/shared/http.js 中看到这些函数。我正在使用 `isomorphic-fetch`
    库（[https://github.com/matthew-andrews/isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)），因为它反映了浏览器中可用的标准
    Fetch API，但也可以在服务器上运行。我将假设你有一些在浏览器中使用 HTTP 库的经验，如果没有，你可以使用包含的辅助文件作为学习 Fetch API
    的起点（[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)）。
- en: 4.1.6\. Running the app
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.6. 运行应用程序
- en: 'The easiest way to get started running the app in development mode will be
    to run the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 开始以开发模式运行应用程序的最简单方法将是运行以下命令：
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are other commands you can use, too, but the main one you’ll want is
    `dev`. To see the other available commands, you can run this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用其他命令，但你会想要的主要是 `dev`。要查看其他可用的命令，你可以运行以下命令：
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That should list every available command for the repository. Feel free to try
    each of them to see how they fit in. The main two you’ll be concerned with, though,
    are `npm run dev` and `npm run db:seed`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会列出仓库中每个可用的命令。你可以随意尝试每个命令，看看它们如何适应。不过，你主要关心的将是 `npm run dev` 和 `npm run db:seed`。
- en: 4.2\. The render process and lifecycle methods
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2. 渲染过程和生命周期方法
- en: If you’ve cloned the repository and installed the dependencies, you should have
    everything you need. Before you start building Letters Social, though, you’ll
    need to take a look at rendering and lifecycle methods. These are key features
    of React, and once you know them you’ll be better equipped to start building the
    Letters Social application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库并安装了依赖项，你应该拥有所需的一切。不过，在你开始构建 Letters Social 之前，你需要查看渲染和生命周期方法。这些是
    React 的关键特性，一旦你了解了它们，你将更有能力开始构建 Letters Social 应用程序。
- en: 4.2.1\. Introducing lifecycle methods
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1. 介绍生命周期方法
- en: In [chapter 2](kindle_split_012_split_000.xhtml#ch02), you saw that you can
    create and assign functions as handlers for events (clicks, form submissions,
    and so on) inside your components. That’s useful because you can create dynamic
    components that respond to user events (a key aspect of any modern web application).
    But what if you want something more? With just this as a feature, it seems like
    you’re still working with regular old HTML and JavaScript. Say you want to get
    user data from an API or read a cookie for later use, all without waiting for
    a user-initiated event. These are routine things you’ll need to do in web applications—you’ll
    want to do them automatically in some cases, so where would those sorts of things
    happen? The answer is lifecycle methods.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_012_split_000.xhtml#ch02) 中，你了解到你可以在组件内部创建并分配函数作为事件（点击、表单提交等）的处理程序。这很有用，因为你可以创建动态组件，它们可以响应用户事件（任何现代网络应用的关键方面）。但如果你想要更多呢？仅仅作为一个特性，似乎你仍然在使用常规的
    HTML 和 JavaScript。比如说，你想从 API 获取用户数据或读取 cookie 以供以后使用，所有这些都不需要等待用户触发的事件。这些是在网络应用中需要做的常规事情——在某些情况下，你可能希望自动执行这些操作，那么这些事情会在哪里发生呢？答案是生命周期方法。
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Lifecycle methods* are special methods attached to class-based React components
    that will be executed at specific points in a component’s lifecycle. A *lifecycle*
    is a way of thinking about a component. A component with a lifecycle has a metaphorical
    “life”—it has at least a beginning, middle, and end. This mental model makes thinking
    about a component easier and gives you context about where a component is in terms
    of its life. Lifecycle methods aren’t unique to React; many UI technologies employ
    them due to their intuitive and useful nature. The main parts of a React component’s
    life are mounting, updating, and unmounting. [Figure 4.2](kindle_split_015_split_002.xhtml#ch04fig02)
    shows an overview of a component lifecycle and the rendering process (how React
    manages your components over time).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*生命周期方法* 是附加到基于类型的 React 组件上的特殊方法，它们将在组件生命周期的特定点执行。*生命周期* 是思考组件的一种方式。具有生命周期的组件有一个比喻性的“生命”——它至少有一个开始、中间和结束。这种思维模型使思考组件变得更加容易，并为你提供了关于组件在其生命周期中的位置的上下文。生命周期方法并非
    React 独有；许多 UI 技术由于它们的直观和有用性而采用它们。React 组件生命的主要部分是挂载、更新和卸载。[图 4.2](kindle_split_015_split_002.xhtml#ch04fig02)
    展示了组件生命周期和渲染过程（React 如何随时间管理你的组件）的概述。'
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 4.2\. Overview of React. React will render (create, manage) components
    and create user interfaces from them.
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. React 概览。React 将渲染（创建、管理）组件，并从中创建用户界面。
- en: '![](Images/04fig02_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02_alt.jpg)'
- en: I’ve mentioned lifecycle methods in past chapters, but now it’s time to really
    dive in to them to get a sense of what they are and how you can use them. To get
    started, think about React at a high level again. Take a look at the top of [figure
    4.2](kindle_split_015_split_002.xhtml#ch04fig02) to refresh your memory. I’ve
    talked about state in React, creating components with `React.createElement` and
    JSX, but we still need to look at the lifecycle methods in depth.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我在过去几章中提到了生命周期方法，但现在是我们真正深入探讨它们，以了解它们是什么以及如何使用它们的时候了。为了开始，再次从高层次上思考 React。看看
    [图 4.2](kindle_split_015_split_002.xhtml#ch04fig02) 的顶部，以刷新你的记忆。我谈到了 React 中的状态，使用
    `React.createElement` 和 JSX 创建组件，但我们仍然需要深入探讨生命周期方法。
- en: Let’s jog your memory from past chapters and review some concepts. What is rendering?
    One definition of *render* is “to cause to be or become; to make.” For our purposes,
    you can think of rendering as what React does in creating and managing a user
    interface for you. It’s the work of getting your application onto the screen.
    It’s React taking your components and turning them into a UI.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从过去的章节中唤醒你的记忆，并回顾一些概念。什么是渲染？*渲染* 的一种定义是“使成为或变为；使”。就我们的目的而言，你可以将渲染视为 React
    为你创建和管理用户界面所做的事情。它是将你的应用程序显示在屏幕上的工作。这是 React 将你的组件转换为 UI 的过程。
- en: You can hook into this process using the lifecycle methods you’re learning about
    in this chapter. These methods give you the flexibility to do what you need to
    at the right moment of a component’s lifetime. They’re only available to components
    that are created from classes that extend the `React.Component` abstract base
    class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用本章中学习的生命周期方法钩入此过程。这些方法为你提供了在组件生命周期的正确时刻执行所需操作的灵活性。它们仅适用于从扩展 `React.Component`
    抽象基类的类创建的组件。
- en: Stateless functional components, discussed at the end of [chapter 3](kindle_split_014_split_000.xhtml#ch03),
    don’t have lifecycle methods available to them. You also can’t use `this.setState`
    inside them because they don’t have backing instances; React doesn’t keep track
    of any internal state for them. They can still have their data updated by a parent
    via props, but you don’t get access to lifecycle methods. That may seem like a
    hindrance or like they’re less powerful, but in many cases they’re all you need.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](kindle_split_014_split_000.xhtml#ch03) 的末尾讨论的无状态函数组件没有可用的生命周期方法。你也不能在它们内部使用
    `this.setState`，因为它们没有后盾实例；React 不跟踪它们的任何内部状态。它们仍然可以通过父组件的 props 更新其数据，但你无法访问生命周期方法。这可能看起来像是一种阻碍，或者像它们功能较弱，但在许多情况下，它们就是你需要的所有东西。
- en: 4.2.2\. Types of lifecycle methods
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 生命周期方法的类型
- en: 'This section looks at the different lifecycle methods provided by React in
    different groups and discusses what each one does. Lifecycle methods can be broken
    into two main groups:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨 React 在不同组中提供的不同生命周期方法，并讨论每个方法的作用。生命周期方法可以分为两大类：
- en: '***Will methods*—** Called right before something happens'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****方法*——** 在某件事情发生前立即调用'
- en: '***Did methods*—** Called right after something happens'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****方法*——** 在某件事情发生后立即调用'
- en: There are also a few other methods that don’t fit into either of these groups.
    They’re related to initialization and error handling, and one is for updating.
    Most of the methods are did and will types, however.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他方法不适合归入上述任何一类。它们与初始化和错误处理有关，其中一个是用于更新的。然而，大多数方法都是did和will类型。
- en: 'We can further break them down into several more types based on what part of
    the lifecycle they’re related to (see [figure 4.3](kindle_split_015_split_002.xhtml#ch04fig03)).
    Components have four main parts of their lifecycle and corresponding lifecycle
    methods for each:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据它们与生命周期哪个部分相关进一步将它们细分为更多类型（参见[图4.3](kindle_split_015_split_002.xhtml#ch04fig03)）。组件有四个主要的生命周期部分，以及对应的生命周期方法：
- en: '***Initialization*—** When a component class is being instantiated.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***初始化*—** 当一个组件类被实例化时。'
- en: '***Mounting*—** A component is being inserted into the DOM.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***挂载*—** 一个组件正在被插入到DOM中。'
- en: '***Updating*—** A component is being updated with new data via state or props.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更新*—** 一个组件通过状态或属性使用新数据更新。'
- en: '***Unmounting*—** A component is being removed from the DOM.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***卸载*—** 一个组件正在从DOM中移除。'
- en: Figure 4.3\. Overview of the rendering process and a component’s lifecycle.
    This is the process that React uses as it manages your components for you. The
    three main parts of a component’s life are when it’s mounting, mounted, and unmounting.
    A component is mounting when it’s being inserted into the DOM, mounted once it
    is, and unmounting when it’s being removed.
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 渲染过程和组件生命周期的概述。这是React为你管理组件所使用的过程。组件的三个主要生命阶段是挂载、已挂载和卸载。组件挂载时正在被插入到DOM中，一旦插入，就变为已挂载，当它被移除时，就处于卸载状态。
- en: '![](Images/04fig03_alt.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03_alt.jpg)'
- en: There are lifecycle methods that will be called during initialization as well
    as before and after component mounting, updating, and unmounting. There aren’t
    that many of these methods, especially when compared to other libraries and frameworks,
    but it can be easy to mix them up when you’re learning React. Forming meaningful
    mental groups for them will help you navigate the different parts of the render
    process. [Figure 4.4](kindle_split_015_split_002.xhtml#ch04fig04) shows an overview
    of the whole rendering process in React, which we’ll look at more closely over
    the course of this chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化、挂载、更新和卸载期间，都会调用一些生命周期方法。这些方法并不多，尤其是与其他库和框架相比，但在学习React时，很容易混淆它们。为它们形成有意义的心理分组将帮助你导航渲染过程的各个部分。[图4.4](kindle_split_015_split_002.xhtml#ch04fig04)显示了React整个渲染过程的概述，我们将在本章的其余部分更详细地探讨它。
- en: Figure 4.4\. Overview of a component lifecycle in React. `ReactDOM` renders
    a component and certain lifecycle methods are called as React manages your component.
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. React中组件生命周期的概述。`ReactDOM`渲染一个组件，当React管理你的组件时，会调用某些生命周期方法。
- en: '![](Images/04fig04_alt.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig04_alt.jpg)'
- en: Remember, thinking of user interfaces and components in terms of a lifecycle
    isn’t unique to React or JavaScript. Other technologies have adopted this idea
    with great success and sometimes even after being inspired by React ([http://componentkit.org](http://componentkit.org),
    for example). But these specific lifecycle methods *are* unique to React. To explore
    these methods, you’ll create two simple components—a parent and child—that will
    implement all the lifecycle methods we’ll look at. Head to [https://codesandbox.io/s/2vxn9251xy](https://codesandbox.io/s/2vxn9251xy)
    to see how to add these components. You can still download the code from the CodeSandbox
    and use your browser’s developer tools to inspect the console. [Listing 4.1](kindle_split_015_split_002.xhtml#ch04ex01)
    shows the basic setup for these components.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，将用户界面和组件视为生命周期的一部分并不特指React或JavaScript。其他技术也成功采用了这一理念，有时甚至是在受到React的启发之后（例如[http://componentkit.org](http://componentkit.org)）。但这些特定的生命周期方法**是**React独有的。要探索这些方法，你需要创建两个简单的组件——一个父组件和一个子组件——它们将实现我们将要查看的所有生命周期方法。前往[https://codesandbox.io/s/2vxn9251xy](https://codesandbox.io/s/2vxn9251xy)查看如何添加这些组件。你仍然可以从CodeSandbox下载代码，并使用浏览器开发者工具检查控制台。[列表4.1](kindle_split_015_split_002.xhtml#ch04ex01)显示了这些组件的基本设置。
- en: Listing 4.1\. Exploring lifecycle methods
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 探索生命周期方法
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Declare a child component.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个子组件。**'
- en: '***2* Set up propTypes as a static method on the class.**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在类上设置propTypes作为静态方法。**'
- en: '***3* Set default props—normally you’d set this as an object and not a function,
    but you’re using an immediately executing function to inject the console.log statement.**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置默认属性——通常你会将其设置为对象而不是函数，但在这里你使用立即执行函数来注入 console.log 语句。**'
- en: '***4* Create a parent component.**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个父组件。**'
- en: '***5* Bind the onInputChange method in the constructor so you can reference
    the method within render and have it point to the class instance, not definition.**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在构造函数中绑定 onInputChange 方法，这样你就可以在 render 中引用该方法，并使其指向类实例，而不是定义。**'
- en: '***6* Update state with the data from the form input.**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用表单输入中的数据更新状态。**'
- en: '***7* Render the child component within the parent.**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在父组件中渲染子组件。**'
- en: '***8* Use React DOM to render the parent component.**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 使用 React DOM 渲染父组件。**'
- en: You don’t need your components to do much for you to explore how lifecycle methods
    work. Here you’ve set up a parent and child. The parent component listens for
    changes to an input field and provides new props to the child component via state.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要你的组件为你做很多事情来探索生命周期方法的工作方式。在这里，你已经设置了一个父组件和一个子组件。父组件监听输入字段的更改，并通过状态向子组件提供新的属性。
- en: 4.2.3\. Initial and “will” methods
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 初始和“将要”方法
- en: 'The first group of lifecycle-related properties to explore are the initial
    properties of a component. These include two properties you’ve already learned
    about: `defaultProps` and `state` (initial). These properties help provide initial
    data to your component. Let’s revisit these quickly before moving on:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要探索的一组与生命周期相关的属性是组件的初始属性。这些包括你已经了解的两个属性：`defaultProps` 和 `state`（初始）。这些属性有助于为你的组件提供初始数据。在继续之前，让我们快速回顾一下：
- en: '`defaultProps`—A static property that provides the default props for a component.
    Sets on `this.props` if that prop is not set by the parent component, is accessed
    before any components are mounted, and can’t rely on `this.props.` or `this.state`.
    Because `defaultProps` is a static property, it’s accessed from the class, not
    instances.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultProps`——一个静态属性，为组件提供默认属性。如果父组件没有设置该属性，则设置在 `this.props` 上，在挂载任何组件之前访问，并且不能依赖于
    `this.props.` 或 `this.state`。因为 `defaultProps` 是一个静态属性，所以它从类中访问。'
- en: '`state` *(initial)*—The value of this property in the constructor will be the
    initial value set for the state of your component. That’s especially helpful when
    you need to provide placeholder content, set default values, or the like. It’s
    similar to default props with the exception that the data is expected to be mutated
    and only available on components that inherit from `React.Component`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state` *(初始)*——在构造函数中此属性的值将是为你组件的状态设置的初始值。这在需要提供占位符内容、设置默认值等情况非常有用。它与默认属性类似，但数据预期会被修改，并且仅在继承自
    `React.Component` 的组件上可用。'
- en: Even though setting initial state and props isn’t done with special methods
    from the React `Component` class (they use the JavaScript `constructor` method),
    they’re still part of the component lifecycle. It’s easy to accidentally exclude
    them in your mind, but they play an important role in providing data for your
    components.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 即使设置初始状态和属性不是通过 React `Component` 类的特殊方法完成的（它们使用 JavaScript `constructor` 方法），它们仍然是组件生命周期的一部分。很容易在心中不小心忽略它们，但它们在为组件提供数据方面发挥着重要作用。
- en: To help illustrate the order of rendering and the various lifecycle methods
    we’ll look at, you’ll next create two simple components that you can specify lifecycle
    methods on. You’ll create a parent component and a child component so you can
    see not only the order in which different methods are called, but also how that
    order is worked out between parents and children. To keep things simple, you’ll
    only be logging information out to the developer console. [Figure 4.5](kindle_split_015_split_002.xhtml#ch04fig05)
    shows what you’ll be able to see in your developer console once you’re done.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明渲染顺序和不同的生命周期方法，你接下来将创建两个简单的组件，你可以在这些组件上指定生命周期方法。你将创建一个父组件和一个子组件，这样你不仅可以看到不同方法调用的顺序，还可以看到这种顺序如何在父组件和子组件之间确定。为了使事情简单，你将只将信息输出到开发者控制台。[图
    4.5](kindle_split_015_split_002.xhtml#ch04fig05) 展示了你完成后的开发者控制台将能够看到的内容。
- en: Figure 4.5\. Output from the sample components once they’ve been fleshed out.
    A lifecycle method will trigger a message being logged to the console at each
    step, along with any arguments available to those methods. You can see the lifecycle
    methods in action at [https://codesandbox.io/s/2vxn9251xy](https://codesandbox.io/s/2vxn9251xy).
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 样本组件一旦被完善后的输出。生命周期方法会在每个步骤触发一个消息被记录到控制台，以及任何可用的方法参数。你可以在[https://codesandbox.io/s/2vxn9251xy](https://codesandbox.io/s/2vxn9251xy)看到生命周期方法的作用。
- en: '![](Images/04fig05_alt.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig05_alt.jpg)'
- en: 4.2.4\. Mounting components
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 挂载组件
- en: Now that you’ve created your parent and child components, let’s look at mounting.
    *Mounting* is the process of React inserting a component into the DOM. Remember,
    components only exist in the virtual DOM until React creates them in the real
    DOM. See [figure 4.6](kindle_split_015_split_002.xhtml#ch04fig06) for an overview
    of mounting and the rendering process for the parent and child components. Mounting
    methods will let you “hook” into the beginning and end of a component’s life and
    are only fired once because, by definition, there can only be one beginning and
    end to a component.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了父组件和子组件，让我们看看挂载。*挂载*是React将组件插入DOM的过程。记住，组件只存在于虚拟DOM中，直到React在真实DOM中创建它们。参见[图4.6](kindle_split_015_split_002.xhtml#ch04fig06)以了解挂载和父组件及子组件渲染过程的概述。挂载方法将允许你“钩入”组件生命的开始和结束，并且只会触发一次，因为根据定义，组件只有一个开始和结束。
- en: Figure 4.6\. The rendering process as it applies to the sample parent and child
    components
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 样本父组件和子组件的渲染过程
- en: '![](Images/04fig06_alt.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig06_alt.jpg)'
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: Mounting is the process of React inserting your components into the real DOM.
    Once done, your component is “ready,” and it’s often a good time to do things
    like perform HTTP calls or read cookies. At this point you’ll also be able to
    access the DOM element via something called a *ref*, discussed in future chapters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载是React将你的组件插入真实DOM的过程。一旦完成，你的组件就“准备好”了，通常这是一个执行HTTP调用或读取cookie的好时机。在这个时候，你也将能够通过一个称为*ref*的东西访问DOM元素，这将在未来的章节中讨论。
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you look back at [figure 4.3](kindle_split_015_split_002.xhtml#ch04fig03),
    you’ll notice that you only have one opportunity to change state before a component
    is mounted. You can do that by using `componentWillMount`, which will provide
    the opportunity to set state or perform other actions before your component mounts.
    Any changes to state within this method won’t trigger a rerender, unlike other
    updates to state that will trigger the update process seen earlier. It’s important
    to know which methods trigger a rerender and which don’t so you can understand
    how your app will behave as well as debug it if something goes wrong. [Figure
    4.7](kindle_split_015_split_002.xhtml#ch04fig07) shows the mounting methods in
    the context of the lifecycle overview we’ve been working with.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下[图4.3](kindle_split_015_split_002.xhtml#ch04fig03)，你会注意到在组件挂载之前，你只有一个机会改变状态。你可以通过使用`componentWillMount`来实现，这将为你提供一个在组件挂载之前设置状态或执行其他操作的机会。在这个方法中状态的变化不会触发重新渲染，这与会触发之前看到的更新过程的其它状态更新不同。了解哪些方法会触发重新渲染以及哪些不会，这对于理解你的应用行为以及调试出错时非常有用。[图4.7](kindle_split_015_split_002.xhtml#ch04fig07)展示了在我们在其中工作的生命周期概述背景下挂载方法。
- en: Figure 4.7\. Mounting methods in the context of the larger lifecycle process.
    Components are added to the DOM, and as they are, several specific methods are
    fired along the way.
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7\. 在更大的生命周期过程中挂载方法。组件被添加到DOM中，在这个过程中会触发几个特定的方法。
- en: '![](Images/04fig07_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig07_alt.jpg)'
- en: The next method I’ll cover is `componentDidMount`. When React calls this method,
    you have the opportunity to use `componentDidMount` as well as access refs on
    components. In this method, you have access to component state and props as well
    as the knowledge that your component is ready for updates. That means it’s a good
    place to do things like update your component state with data coming back from
    a network request. It’s also a great place to work with third-party libraries
    that depend on the DOM, like jQuery and others.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我接下来要介绍的方法是`componentDidMount`。当React调用这个方法时，你有机会使用`componentDidMount`以及访问组件的refs。在这个方法中，你可以访问组件的状态和属性，以及你的组件已经准备好更新的知识。这意味着这是一个用从网络请求返回的数据更新组件状态的好地方。这也是与依赖于DOM的第三方库（如jQuery和其他库）一起工作的好地方。
- en: If you execute handlers or other functions in other methods (like `render()`),
    you’ll end up with unpredictable and unexpected results due to how React works.
    Render methods need to be *pure* (consistent based on a given input) and are usually
    called many times over the lifetime of a component. React may even batch updates
    together, so you can’t guarantee that a render will happen at a given time.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其他方法（如`render()`）中执行处理程序或其他函数，由于React的工作方式，你可能会得到不可预测和意外的结果。渲染方法需要是*纯*的（基于给定输入的一致性），并且通常在组件的生命周期中多次调用。React甚至可能将更新批处理在一起，因此你不能保证渲染会在特定时间发生。
- en: Now that we’ve looked at some of the methods related to mounting, you’ll add
    them to your components so we can see the component lifecycle. The next listing
    shows how you can add these mounting methods to your components.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了一些与挂载相关的方 法，你将把它们添加到你的组件中，这样我们就可以看到组件的生命周期。下一个列表显示了如何将挂载方法添加到你的组件中。
- en: Listing 4.2\. Mounting methods
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. 挂载方法
- en: '[PRE14]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Add component-DidMount and componentWillMount to the child component.**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将component-DidMount和componentWillMount添加到子组件中。**'
- en: '***2* Add component-DidMount and componentWillMount to the parent component.**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将component-DidMount和componentWillMount添加到父组件中。**'
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pondering mounting**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**深思渐增**'
- en: What does it mean that a component has *mounted*?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 组件已*挂载*意味着什么？
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.2.5\. Updating methods
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.5\. 更新方法
- en: 'Once your component is mounted and in the DOM, you’ll want to update it. In
    [chapter 3](kindle_split_014_split_000.xhtml#ch03), you saw that you can use `this.setState()`
    to perform a shallow merge of new data into the component state, but more than
    that goes on when you trigger an update. React provides several methods you can
    use to hook into the update process: `shouldComponentUpdate`, `componentWillUpdate`,
    and `componentDidUpdate`. [Figure 4.8](kindle_split_015_split_002.xhtml#ch04fig08)
    shows the updating portion of the overall lifecycle chart we looked at earlier.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的组件挂载并在DOM中，你将想要更新它。在[第3章](kindle_split_014_split_000.xhtml#ch03)中，你看到可以使用`this.setState()`将新数据浅度合并到组件状态中，但当你触发更新时，还有更多的事情发生。React提供了几个你可以用来钩入更新过程的方法：`shouldComponentUpdate`、`componentWillUpdate`和`componentDidUpdate`。[图4.8](kindle_split_015_split_002.xhtml#ch04fig08)显示了之前查看的整体生命周期图中的更新部分。
- en: Figure 4.8\. Updating lifecycle methods. When a component is being updated,
    several hooks fire that let you determine whether the component should be updated
    at all, how to update, and when the update is done.
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8\. 更新生命周期方法。当一个组件正在更新时，会触发几个钩子，这些钩子让你确定组件是否应该更新，如何更新，以及何时完成更新。
- en: '![](Images/04fig08_alt.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig08_alt.jpg)'
- en: Unlike with other methods we’ve seen so far, you’re given the option to control
    whether an update should occur. Another difference between the “update” methods
    and those related to mounting is that they provide arguments for props and state.
    You can use these to determine whether an update should occur or to react to changes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的其他方法不同，你可以选择是否应该发生更新。更新方法和与挂载相关的方法之间的另一个区别是，它们为props和state提供了参数。你可以使用这些参数来确定是否应该发生更新或对变化做出反应。
- en: If `shouldComponentUpdate` returns `false` for some reason, `render()` is skipped
    until the next state change. This means you can prevent your component from unnecessarily
    updating. Because the component won’t update, the next methods, `componentWillUpdate`
    and `componentDidUpdate`, won’t be called.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因`shouldComponentUpdate`返回`false`，则`render()`将跳过，直到下一个状态变化。这意味着你可以防止你的组件不必要地更新。因为组件不会更新，所以下一个方法`componentWillUpdate`和`componentDidUpdate`将不会被调用。
- en: Unless you specify otherwise, `shouldComponentUpdate` will always return `true`,
    but if you’re careful to always treat state as immutable and to read only from
    props and state in `render()`, then you can override `shouldComponentUpdate` with
    an implementation that compares the old props and state to their replacements.
    That can be useful for performance tuning but should be treated as an escape hatch.
    React already employs sophisticated and advanced methods to determine what should
    be updated and when.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确指定，否则`shouldComponentUpdate`将始终返回`true`，但如果你总是小心地对待状态为不可变，并且在`render()`中只从props和状态中读取，那么你可以使用比较旧props和状态与其替代品的实现来覆盖`shouldComponentUpdate`。这可能对性能调整很有用，但应被视为一个逃生口。React已经采用了复杂和高级的方法来确定什么应该更新以及何时更新。
- en: If you do end up using `shouldComponentUpdate`, it should be in a case where
    those methods aren’t sufficient for some reason. That doesn’t mean you should
    never use it, but you probably won’t need to when first starting out with React.
    Like all the lifecycle methods, it’s provided to you but should only be used when
    necessary. The next listing shows an example of React’s update-related lifecycle
    methods.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您最终确实使用了 `shouldComponentUpdate`，那么它应该是在这些方法不足以满足某些原因的情况下。这并不意味着您永远不应该使用它，但您在刚开始使用
    React 时可能不需要它。像所有生命周期方法一样，它是提供给您的，但只有在必要时才应使用。下一个列表显示了 React 的与更新相关的生命周期方法的示例。
- en: Listing 4.3\. Updating methods
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 更新方法
- en: '[PRE15]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Add update methods to the child component so you can inspect the update
    process on a single component.**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将更新方法添加到子组件中，以便您可以检查单个组件的更新过程。**'
- en: '***2* Add update methods to the child component so you can inspect the update
    process on a single component.**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将更新方法添加到子组件中，以便您可以检查单个组件的更新过程。**'
- en: Now that you’ve specified update methods for your components, try running them
    again and type something into the text box. You’ll see a cascading output in the
    developer console ([listing 4.4](kindle_split_015_split_002.xhtml#ch04ex04) shows
    what the components should output). Take a minute to look at the order of rendering.
    Notice anything? The order should cohere with what you’ve learned so far in this
    chapter, but now you get to see how child and parent component ordering matters.
    You may remember from [chapter 2](kindle_split_012_split_000.xhtml#ch02) that
    React is recursive in how it forms a tree and renders things—it will exhaustively
    examine every part of your components by asking about each component and all of
    its children.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为您的组件指定了更新方法，再次运行它们并在文本框中输入一些内容。您将在开发者控制台中看到级联输出（[列表 4.4](kindle_split_015_split_002.xhtml#ch04ex04)
    显示了组件应该输出的内容）。花一分钟时间看看渲染的顺序。您注意到什么了吗？顺序应该与您在本章中学到的内容一致，但现在您可以看到子组件和父组件的顺序是如何重要的。您可能还记得从[第
    2 章](kindle_split_012_split_000.xhtml#ch02)中，React 在形成树和渲染事物时是递归的——它将通过询问每个组件及其所有子组件来彻底检查您的组件的每个部分。
- en: 'Because it knows everything it needs to know about your component tree, React
    can intelligently create components for you in the proper order. You’ll notice
    in [listing 4.4](kindle_split_015_split_002.xhtml#ch04ex04) that a child component’s
    mounting occurs before its parent’s. This makes sense if you think about what
    mounting means for the parent: children have to be created before the parent component’s
    mounting can be considered complete. If the child didn’t yet exist, the parent
    couldn’t be said to be mounted.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它知道关于您的组件树所需的所有信息，React 可以智能地按正确顺序为您创建组件。您会在[列表 4.4](kindle_split_015_split_002.xhtml#ch04ex04)中注意到，子组件的挂载发生在其父组件之前。如果您考虑挂载对父组件的意义，这就有道理了：在父组件的挂载被认为完成之前，必须先创建子组件。如果子组件尚未存在，则不能说父组件已挂载。
- en: 'You’ll also note that when an update occurs, you’ll see the child component
    receive props because the prop of that child has been changed by the parent via
    `this.setState()`. From there, the updating methods run in order: `shouldComponentUpdate`,
    `componentWillUpdate`, `componentDidUpdate`. If you for some reason told the component
    not to update by returning `false` from `shouldComponentUpdate`, those steps would
    have been skipped.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，当发生更新时，您会看到子组件接收属性，因为该子组件的属性已被父组件通过 `this.setState()` 改变。从那里开始，更新方法按顺序运行：`shouldComponentUpdate`、`componentWillUpdate`、`componentDidUpdate`。如果您出于某种原因告诉组件不要更新，通过从
    `shouldComponentUpdate` 返回 `false`，这些步骤就会被跳过。
- en: Listing 4.4\. Component update output with text entered
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 输入文本的组件更新输出
- en: '[PRE16]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* “Mark” was pasted in so you don’t trigger a whole series of updates for
    every letter.**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “Mark” 被粘贴进去，这样您就不会为每个字母触发一系列更新。**'
- en: 4.2.6\. Unmounting methods
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.6\. 卸载方法
- en: Just as we could listen for the mounting of a component, we can listen for its
    unmounting. *Unmounting* is the process of removing a component from the DOM.
    If your application is written all with React, a *router* (explored in [chapters
    8](kindle_split_019_split_000.xhtml#ch08) and [9](kindle_split_020_split_000.xhtml#ch09))
    will remove components as you move between different pages. But you can also use
    React to integrate with other frameworks and libraries, so you might need to perform
    some other actions when your component unmounts (maybe clearing an interval, toggling
    a setting, and so on). Regardless of what it is, you can take advantage of `componentWillUnmount`
    to do any cleanup you need to when a component is being removed. [Figure 4.9](kindle_split_015_split_002.xhtml#ch04fig09)
    illustrates how the unmounting process happens.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以监听组件的挂载一样，我们也可以监听其卸载。**卸载**是从 DOM 中移除组件的过程。如果你的应用完全使用 React 编写，一个**路由器**（在第
    8 章 [chapters 8](kindle_split_019_split_000.xhtml#ch08) 和第 9 章 [chapters 9](kindle_split_020_split_000.xhtml#ch09)
    中探讨）会在你切换到不同页面时移除组件。但你也可以使用 React 与其他框架和库集成，因此你可能需要在组件卸载时执行一些其他操作（比如清除一个间隔，切换一个设置等）。无论是什么，你都可以利用
    `componentWillUnmount` 在组件被移除时执行任何必要的清理。图 4.9 [Figure 4.9](kindle_split_015_split_002.xhtml#ch04fig09)
    展示了卸载过程是如何发生的。
- en: 'Figure 4.9\. `React DOM` is responsible for mounting and unmounting components.
    Mounting is the process of inserting your components into the DOM and unmounting
    is the opposite: the process of removing your components from the DOM. Once components
    are unmounted, they no longer exist in the DOM.'
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. `React DOM` 负责组件的挂载和卸载。挂载是将组件插入 DOM 的过程，而卸载则是其相反过程：从 DOM 中移除组件的过程。一旦组件被卸载，它们就不再存在于
    DOM 中。
- en: '![](Images/04fig09_alt.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.9](Images/04fig09_alt.jpg)'
- en: Based on how mounting has worked so far, you might expect a `componentDidUnmount`
    method to be available, but there isn’t one. That’s because once a component is
    removed, its life is over and thus it shouldn’t be able to do anything from beyond
    the grave. Let’s add the `componentWillUnmount` to our running example so we can
    get the full picture of a component’s lifecycle.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 根据到目前为止挂载的工作方式，你可能会期望有一个 `componentDidUnmount` 方法可用，但实际上并没有。这是因为一旦组件被移除，它的生命周期就结束了，因此它不应该能够从坟墓之外做任何事情。让我们将
    `componentWillUnmount` 添加到我们的运行示例中，以便我们可以全面了解组件的生命周期。
- en: Listing 4.5\. Unmounting
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 卸载
- en: '[PRE17]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Add the componentWill-Unmount method to the parent and child components.**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 将 `componentWillUnmount` 方法添加到父组件和子组件中。**'
- en: 4.2.7\. Catching errors
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.7\. 捕获错误
- en: Error handling is a first-class part of writing clean programs. So far, we haven’t
    seen any special methods in React for dealing with errors. If you’ve worked with
    React for a long time, you may remember that previous versions of React would
    lock up the entire app if an error occurred in a React component’s `render` or
    lifecycle methods. This was often a source of frustration, as it meant that an
    uncaught error could lock up the entire application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是编写清晰程序的重要组成部分。到目前为止，我们还没有看到 React 中处理错误的任何特殊方法。如果你长期使用 React，你可能还记得 React
    的早期版本，如果 React 组件的 `render` 或生命周期方法中发生错误，整个应用会锁定。这通常是一个令人沮丧的原因，因为它意味着一个未捕获的错误可能会锁定整个应用。
- en: More recent versions of React introduced a new concept called *error boundaries*
    to help deal with this. If an uncaught exception is thrown within a component’s
    `constructor`, `render`, or lifecycle methods, React will unmount the component
    and its children from the DOM. That may seem confusing at first, but the benefit
    it offers is the ability to isolate errors in components from breaking the rest
    of the app.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版本的 React 引入了一个名为 **错误边界** 的新概念，以帮助处理这种情况。如果一个未捕获的异常在组件的 `constructor`、`render`
    或生命周期方法中抛出，React 将从 DOM 中卸载该组件及其子组件。一开始这可能看起来有些困惑，但它的好处是能够将组件中的错误隔离，从而避免破坏应用的其他部分。
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Differences among components**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件之间的差异**'
- en: What are some of the differences between React components created from the abstract
    base class `React.Component` and components created from plain functions without
    inheritance?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件从抽象基类 `React.Component` 创建和从没有继承的纯函数创建之间有哪些不同之处？
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can handle these errors by using another method that your components inherit
    from `React.Component`: `componentDidCatch`. The semantics of the method are similar
    to the `try...catch` behavior you’d see in JavaScript. `componentDidCatch` gives
    you access to the error being thrown and an error message. Using these you can
    ensure your components appropriately respond to errors. In a larger application,
    you might use this method to set up error state for individual components (maybe
    a widget, card, or other component) or at an application level. The following
    listing shows how to add the `componentDidCatch` method to the parent component.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用组件从 `React.Component` 继承的另一个方法来处理这些错误：`componentDidCatch`。该方法的意义与您在 JavaScript
    中看到的 `try...catch` 行为类似。`componentDidCatch` 允许您访问抛出的错误和错误消息。使用这些信息，您可以确保组件适当地响应错误。在更大的应用程序中，您可能使用此方法为单个组件（可能是一个小部件、卡片或其他组件）或应用程序级别设置错误状态。以下列表显示了如何将
    `componentDidCatch` 方法添加到父组件中。
- en: Listing 4.6\. Handling errors
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 处理错误
- en: '[PRE18]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Bind the class method.**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定类方法。**'
- en: '***2* Toggle state so you throw an error.**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 切换状态以抛出错误。**'
- en: '***3* Throw an error in the render method.**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 render 方法中抛出错误。**'
- en: '***4* Add a componentDidCatch method to the parent and use it to update component
    state.**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在父组件中添加 componentDidCatch 方法并使用它来更新组件状态。**'
- en: '***5* If an error is thrown, display the error and error message.**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果抛出错误，显示错误和错误消息。**'
- en: We’ve looked at the different lifecycle methods provided to you by React and
    seen how you can use them in a variety of situations. If it seems like there are
    a lot of methods to keep track of, you’ll be relieved to know that these make
    up the majority of the API for React components (you can also use [table 4.1](kindle_split_015_split_002.xhtml#ch04table01)
    as a cheat sheet). The core React API doesn’t have much more than what we’ve covered
    so far. What’s more, you don’t have to use every one of these methods; use what
    you need. [Table 4.1](kindle_split_015_split_002.xhtml#ch04table01) shows a summary
    of the methods covered so far (note that `render` isn’t included).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 React 提供给您不同的生命周期方法，并看到了您如何在各种情况下使用它们。如果您觉得有太多方法需要跟踪，您会很高兴地知道这些方法构成了
    React 组件 API 的主要部分（您也可以使用 [表 4.1](kindle_split_015_split_002.xhtml#ch04table01)
    作为速查表）。核心 React API 不会有我们之前所涵盖的更多内容。更重要的是，您不必使用这些方法中的每一个；使用您需要的。[表 4.1](kindle_split_015_split_002.xhtml#ch04table01)
    展示了迄今为止涵盖的方法的总结（请注意，`render` 没有包括在内）。
- en: Table 4.1\. Summary of React component lifecycle methods
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. React 组件生命周期方法总结
- en: '|   | Initial | Will | Did |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|   | 初始 | 将要 | 已做 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Mounting** | defaultProps *Arguments*—None, static property *What*—Static
    version accessed many times. Sets values to this.props if that prop isn’t set
    by the parent component. *When*—Invoked when a component is created and can’t
    rely on this.props. Returned complex objects are shared across instances, not
    copied. | componentWillMount *Arguments*—None *What*—Allows you to operate on
    component data before the mounting process happens. For example, if you call setState
    within this method, render() will see the updated state and will be executed only
    once despite the state change. “Last chance” to change initial render data. *When*—Invoked
    once, both on the client and server ([chapter 12](kindle_split_024_split_000.xhtml#ch12)
    covers server rendering), immediately before the initial rendering occurs. | componentDidMount
    *Arguments*—None *What*—Invoked once the component has been inserted into the
    DOM. At this point, you can access refs (a way to access the underlying DOM representation
    discussed in future chapters). Often a good place to perform “impure” actions
    like integrating with other JavaScript libraries, setting timers (via set-Timeout
    or set-Interval), or sending HTTP requests. We’ll often use this method to replace
    placeholder data in our components. *When*—Invoked once, only on the client (not
    on the server!), immediately after the initial rendering occurs. The componentDidMount()
    method of child components is invoked before that of parent components. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **挂载** | defaultProps *参数*—无，静态属性 *功能*—多次访问的静态版本。如果父组件没有设置该属性，则将其值设置为this.props。
    *何时*—在组件创建时调用，此时不能依赖于this.props。返回的复杂对象在实例之间共享，而不是复制。 | componentWillMount *参数*—无
    *功能*—允许你在挂载过程发生之前操作组件数据。例如，如果你在这个方法中调用setState，render()将看到更新的状态，并且尽管状态已更改，但只会执行一次。“最后的机会”来更改初始渲染数据。
    *何时*—在客户端和服务器上仅调用一次（[第12章](kindle_split_024_split_000.xhtml#ch12)涵盖了服务器渲染），在初始渲染发生之前立即调用。
    | componentDidMount *参数*—无 *功能*—在组件被插入到DOM中后立即调用。此时，你可以访问refs（在未来的章节中讨论的访问底层DOM表示的方法）。通常是一个执行“不纯”操作的好地方，如与其他JavaScript库集成、设置定时器（通过setTimeout或setInterval）或发送HTTP请求。我们经常使用这个方法来替换组件中的占位符数据。
    *何时*—在客户端上仅调用一次（不在服务器上！），在初始渲染发生之后立即调用。子组件的componentDidMount()方法在父组件之前调用。 |'
- en: '| **Updating** | shouldComponentUpdate *Arguments*—nextProps, nextState *What*—If
    shouldComponentUpdate returns false, then render() will be completely skipped
    until the next state change. Also, componentWillUpdate and componentDidUpdate
    won’t be called. Useful as “escape hatch” for advanced performance tuning. *When*—Invoked
    before rendering when new props or state are being received by your component.
    Not called for the initial render. | componentWillReceiveProps *Arguments*—nextProps:
    Object *What*—Use this as an opportunity to react to a prop transition before
    render() is called by updating the state using this.setState(). The old props
    can be accessed via this.props. Calling this.setState() within this function won’t
    trigger an additional render. *When*—Invoked when a component is receiving new
    props. This method isn’t called for the initial render. | componentDidUpdate *Arguments*—prev-Props:
    Object, prevState: Object *What*—Invoked immediately after the component’s updates
    are flushed to the DOM. This method isn’t called for the initial render. *When*—Use
    this as an opportunity to operate on the DOM when the component has been updated.
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| **更新** | shouldComponentUpdate *参数*—nextProps, nextState *功能*—如果shouldComponentUpdate返回false，则render()将完全跳过，直到下一个状态变化。此外，componentWillUpdate和componentDidUpdate也不会被调用。作为高级性能调优的“逃生门”。
    *何时*—在组件接收到新属性或状态之前调用渲染时被调用。对于初始渲染不会调用。 | componentWillReceiveProps *参数*—nextProps:
    对象 *功能*—在调用render()之前，利用这个机会在渲染之前对属性转换做出反应，可以通过使用this.setState()更新状态。旧属性可以通过this.props访问。在这个函数内部调用this.setState()不会触发额外的渲染。
    *何时*—当组件接收到新属性时被调用。对于初始渲染不会调用此方法。 | componentDidUpdate *参数*—prevProps: 对象，prevState:
    对象 *功能*—在组件的更新被刷新到DOM之后立即调用。对于初始渲染不会调用此方法。 *何时*—在组件更新后，利用这个机会操作DOM。 |'
- en: '|   |   | componentWillUpdate *Arguments*—nextProps: Object, nextState: Object
    *What*—Use this as an opportunity to perform preparation before an update occurs.
    You can’t use setState(). *When*—Invoked immediately before rendering when new
    props or state are being received. Not called for the initial render. componentWillUnmount
    *Arguments*—None *What*—Perform any necessary cleanup in this method, such as
    invalidating timers or cleaning up any DOM elements that were created in componentDidMount.
    *When*—Invoked immediately before a component is unmounted. |   |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `componentWillUpdate` *参数*—nextProps: 对象, nextState: 对象 *作用*—利用这个机会在更新发生之前进行准备。你不能使用setState()。
    *触发时机*—在接收到新属性或状态时，立即在渲染之前调用。对于初始渲染不会调用。 `componentWillUnmount` *参数*—无 *作用*—在这个方法中执行任何必要的清理工作，例如取消定时器或清理在`componentDidMount`中创建的任何DOM元素。
    *触发时机*—在组件卸载之前立即调用。 |   |'
- en: '| **Errors** | componentDidCatch *Arguments*—error, errorInfo *What*—Handles
    errors in components. React will unmount components that occur in and below the
    tree where the error occurred. *When*—Called on an error in constructor, lifecycle,
    or render methods |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **错误** | `componentDidCatch` *参数*—error, errorInfo *作用*—处理组件中的错误。React 将卸载发生错误的树中及其下方的组件。
    *触发时机*—在构造函数、生命周期方法或渲染方法中发生错误时调用 |'
- en: 4.3\. Starting to create Letters Social
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 开始创建 Letters Social
- en: Now that you know a little bit more about React’s lifecycle methods and what
    they do, let’s put those skills to use. You’re going to start building out the
    Letters Social application. If you haven’t already, make sure you read the first
    section of this chapter so you know how to use the Letters Social repository.
    You should be on the start branch when starting out, but if you want to skip to
    the end of the chapter you can check out the chapter-4 branch (`git checkout chapter-4`).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 React 的生命周期方法和它们的作用有了更多的了解，让我们将这些技能付诸实践。你将开始构建 Letters Social 应用程序。如果你还没有，请确保你已经阅读了本章的第一部分，以便了解如何使用
    Letters Social 仓库。当你开始时，你应该在 start 分支上，但如果你想跳到本章的结尾，你可以检出 chapter-4 分支（`git checkout
    chapter-4`）。
- en: 'Up to this point you’ve been running most of your code in the browser on CodeSandbox.
    That’s been fine for learning, but you’re going to switch context and start creating
    files on your local computer. You’ll want to use the Webpack build process included
    with the repository, for a few reasons:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在 CodeSandbox 的浏览器上运行大部分代码。这对于学习来说是可以的，但你现在将切换上下文，开始在本地计算机上创建文件。你将想要使用仓库中包含的
    Webpack 构建过程，原因有以下几点：
- en: The ability to write JavaScript in many files that are output in one or a small
    handful of files that have automatically resolved dependencies and import order
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在许多文件中编写 JavaScript，这些文件输出为一个或少数几个文件，这些文件已经自动解决了依赖关系和导入顺序
- en: The ability to handle and process different types of files (like SCSS or font
    files)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理和加工不同类型的文件（如 SCSS 或字体文件）
- en: To utilize other build tools like Babel so you can write modern JavaScript that
    will run on older browsers
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了利用像 Babel 这样的其他构建工具，这样你就可以编写能在旧浏览器上运行的现代 JavaScript
- en: To optimize JavaScript by removing dead code and minifying it
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移除死代码和压缩来优化 JavaScript
- en: Webpack is an incredibly powerful tool used by many teams and companies. As
    stated earlier in the chapter, I won’t be covering how to use it in this book.
    One of my hopes for you in this book is to not have to learn React and every related
    build tool. There’s simply too much complexity going on at once instead of making
    learning easy. But you can learn more about it if you choose. The build process
    included in the source code can be understood if you spend some time reading about
    Webpack at [https://webpack.js.org](https://webpack.js.org).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是一个由许多团队和公司使用的强大工具。正如本章前面所述，我不会在这本书中介绍如何使用它。我在这本书中的一个希望是，你不需要学习 React
    和每个相关的构建工具。一次学习太多的复杂性，而不是让学习变得容易。但如果你选择，你可以了解更多关于它的信息。如果你花些时间阅读关于 Webpack 的内容，就可以理解源代码中包含的构建过程。[https://webpack.js.org](https://webpack.js.org)。
- en: You’ll start building Letters Social by creating an App component and a main
    index file that will serve as the entry point into the app (where `React DOM`’s
    `render` method is called). The App component will house some logic for fetching
    posts from the API and will render a number of Post components—you’ll create the
    component for posts next. The repository also contains a number of components
    that you won’t have to create yourself. You’ll use these now and in future chapters.
    The following listing shows the entrypoint file, src/index.js.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建一个 App 组件和一个主索引文件来开始构建 Letters Social，这个索引文件将作为进入应用程序的入口点（在这里调用 `React
    DOM` 的 `render` 方法）。App 组件将包含从 API 获取帖子的逻辑，并将渲染多个 Post 组件——你将在下一章创建帖子组件。仓库还包含了一些你不需要自己创建的组件。你现在将使用这些组件，并在未来的章节中使用。以下列表显示了入口点文件，src/index.js。
- en: Listing 4.7\. Main app file (src/index.js)
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 主应用程序文件（src/index.js）
- en: '[PRE19]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Import React and the render method from React DOM—this file will be where
    the main call to React DOM’s render method will be.**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 React DOM 中导入 React 和 render 方法——这个文件将是调用 React DOM 的 render 方法的主体调用所在的地方。**'
- en: '***2* Import the default export from the App component—you’ll create this in
    the next listing.**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 App 组件中导入默认导出——你将在下一列表中创建它。**'
- en: '***3* Import some files related to error reporting, a service worker register,
    and styling (handled by repository setup).**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入一些与错误报告、服务工作者注册和样式（由仓库设置处理）相关的文件。**'
- en: '***4* Call render with the main app on a target element (the HTML template
    can be found in src/index.ejs).**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用目标元素（HTML 模板可在 src/index.ejs 中找到）调用 render，以渲染主应用程序。**'
- en: The main app file contains references to some styling that Webpack can import
    as well as the main call to `React DOM`’s `render` method. This is the main place
    your React app will “start.” When the script is executed by the browser, it will
    render the main app and React will take over. Without this call, your app won’t
    be executed. You might remember from past chapters that you called this at the
    bottom of a main app file. It’s no different here, really—your app is going to
    be comprised of many different files that Webpack will know how to bring together
    (thanks to your `import`/`export` statements) and run in the browser.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序文件包含一些样式引用，Webpack 可以导入，以及调用 `React DOM` 的 `render` 方法的主体调用。这是你的 React
    应用程序“开始”的地方。当脚本由浏览器执行时，它将渲染主应用程序，React 将接管。如果没有这个调用，你的应用程序将不会执行。你可能还记得从前几章中，你在主应用程序文件的底部调用了这个方法。实际上并没有什么不同——你的应用程序将由许多不同的文件组成，Webpack
    将知道如何将它们（多亏了你的 `import`/`export` 语句）组合在一起并在浏览器中运行。
- en: Now that you have an entry point for your app, let’s create the main App component.
    You can place this file in the src directory as src/app.js. You’ll sketch out
    a basic skeleton for the App component and then fill it in as you go. In this
    chapter, your goal is to get the main app running and displaying a number of posts.
    In the next chapter you’ll start to flesh out more functionality and add the ability
    to create posts as well as add locations to posts. You’ll keep adding functionality
    to the app as you explore different topics in React like testing, routing, and
    application architecture (using Redux). The following listing shows the basics
    of the App component.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了应用程序的入口点，让我们创建主 App 组件。你可以将此文件放在 src 目录中，作为 src/app.js。你将为 App 组件草拟一个基本框架，然后在过程中填充它。在本章中，你的目标是让主应用程序运行并显示多个帖子。在下一章中，你将开始实现更多功能，并添加创建帖子以及添加位置到帖子的能力。随着你在
    React 中探索不同的主题，如测试、路由和应用程序架构（使用 Redux），你将不断向应用程序添加功能。以下列表显示了 App 组件的基本内容。
- en: Listing 4.8\. Creating the App component (src/app.js)
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 创建 App 组件（src/app.js）
- en: '[PRE20]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Import the libraries you’ll need for the App component.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你需要的库用于 App 组件。**'
- en: '***2* Import the error message and loader components to use.**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入要使用的错误信息和加载器组件。**'
- en: '***3* Import the Letters API module for use in creating and fetching posts.**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入用于创建和获取帖子的 Letters API 模块。**'
- en: '***4* Import the preexisting Ad, Welcome, and Navbar components.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导入现有的 Ad、Welcome 和 Navbar 组件。**'
- en: '***5* Set up initial state for the component—you’ll keep track of posts and
    an endpoint to hit for more posts.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 为组件设置初始状态——你将跟踪帖子以及获取更多帖子的端点。**'
- en: '***6* If loading, render a loader and not the app body.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果正在加载，则渲染加载器而不是应用程序主体。**'
- en: '***7* Render the Welcome and Ad components.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 渲染 Welcome 和 Ad 组件。**'
- en: '***8* This is where you’ll add components for displaying posts.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 这是你添加用于显示帖子的组件的地方。**'
- en: '***9* Export the App component.**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 导出 App 组件。**'
- en: 'With that, you can run the development command (`npm run dev`) and your app
    should at least boot up and be available in the browser. If you haven’t already,
    make sure you run `npm run db:seed` at least once to generate sample data for
    your database. Running `npm run dev` will do a few things for you:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你可以运行开发命令 (`npm run dev`)，你的应用至少应该能够启动并在浏览器中可用。如果你还没有这样做，请确保至少运行一次 `npm
    run db:seed` 以生成数据库的示例数据。运行 `npm run dev` 会为你做几件事情：
- en: Start up the Webpack build process and development server
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Webpack 构建过程和开发服务器
- en: Start the JSON-server API so you can respond to network requests
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 JSON-server API 以响应网络请求
- en: Create a development server (useful for server-side rendering in [chapter 12](kindle_split_024_split_000.xhtml#ch12))
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个开发服务器（在 [第 12 章](kindle_split_024_split_000.xhtml#ch12) 中用于服务器端渲染）
- en: Hot-reload your app when changes occur (so you don’t have to refresh the app
    every time you save a file)
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生更改时热重载你的应用（这样你就不必每次保存文件时都刷新应用）
- en: Notify you of build errors (these should show up in the command line and the
    browser if and when they occur)
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知你构建错误（这些错误应该在命令行和浏览器中显示，如果发生的话）
- en: When the app is up and running in development mode, you should be able to view
    the running app at http://localhost:3000\. The API server is running at http://localhost:3500
    if you want to make requests to it using things like Postman ([www.getpostman.com](http://www.getpostman.com))
    or just want to navigate to different resources using your browser.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用以开发模式运行时，你应该能够在 http://localhost:3000 上查看正在运行的应用。如果你想要使用 Postman ([www.getpostman.com](http://www.getpostman.com))
    或只是想通过浏览器导航到不同的资源，API 服务器正在运行在 http://localhost:3500。
- en: With those logistical matters out of the way, you should add the ability to
    fetch post to the App component. To do that, you’ll need to send a network request
    to the Letters Social API using the Fetch API (bundled up in the API module you
    pulled in). Right now, your component doesn’t do much. You haven’t defined any
    lifecycle methods outside of the `constructor` and `render` methods, so the component
    doesn’t have any data to work with. You need to fetch data from the API and then
    update component state with that data. You’ll also add an error boundary so that
    if your component encounters an error you can show an error message instead of
    the entire app unmounting. The next listing shows how to add the class methods
    to the App component.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这些后勤问题之后，你应该将获取帖子的能力添加到 App 组件中。为此，你需要使用 Fetch API（包含在你拉入的 API 模块中）向 Letters
    Social API 发送网络请求。目前，你的组件没有做太多。你还没有在 `constructor` 和 `render` 方法之外定义任何生命周期方法，因此组件没有可以工作的数据。你需要从
    API 获取数据，然后使用这些数据更新组件状态。你还将添加一个错误边界，以便在组件遇到错误时显示错误消息而不是整个应用卸载。下一个列表显示了如何向 App
    组件添加类方法。
- en: Listing 4.9\. Fetching data when the App component mounts
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 当 App 组件挂载时获取数据
- en: '[PRE21]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Bind class method and use it to fetch posts from the API when the component
    mounts.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定类方法并在组件挂载时使用它从 API 获取帖子。**'
- en: '***2* Set up an error boundary for the app so you can handle errors.**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为应用设置一个错误边界以便处理错误。**'
- en: '***3* Fetch posts using the included API module.**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用包含的 API 模块获取帖子。**'
- en: '***4* The API module uses the Fetch API, so you need to unwrap the JSON response.**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* API 模块使用 Fetch API，因此你需要解包 JSON 响应。**'
- en: '***5* The Letters Social API returns pagination information in headers, so
    you can use the parse-link-header to pull the URL for the next page of posts out.**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* The Letters Social API 在头部返回分页信息，因此你可以使用 parse-link-header 来提取下一页帖子的
    URL。**'
- en: '***6* Add the new posts to state and ensure they’re sorted correctly.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将新帖子添加到状态中，并确保它们被正确排序。**'
- en: '***7* Update the endpoint state.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 更新端点状态。**'
- en: '***8* If there’s an error, update component state.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果有错误，更新组件状态。**'
- en: '***9* Now that you have it defined, assign the getPosts method to the load
    more event handler.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 现在你已经定义了它，将 getPosts 方法分配给加载更多事件处理程序。**'
- en: The app should fetch posts when it mounts now and keep that data in its local
    component state. Next, you need to create a Post component that will house post
    data. You’ll create the Post component from a set of preexisting components that
    came with the source code. These are mainly stateless functional components, and
    you’ll build on them over the rest of the book. Take a look at the src/components/post
    directory to familiarize yourself with them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用应该在挂载时获取帖子，并保持其本地组件状态。接下来，你需要创建一个 Post 组件来存放帖子数据。你将从源代码中附带的一组预存组件创建 Post
    组件。这些主要是无状态的函数组件，你将在本书的其余部分在此基础上构建。查看 src/components/post 目录以熟悉它们。
- en: Your posts will also fetch their own content so you can move the Post component
    around in future chapters and render it on its own. The App component makes a
    request to get posts, but all it really cares about is the ID and date of a post,
    whereas the Post component itself will be responsible for loading the rest of
    its content. Another way to do this would be to have the App component be responsible
    for all data fetching and just pass data to the post. One upside to this approach
    is that fewer network requests are made. You’ll make the post responsible for
    additional data fetching for the purposes of illustration and because we’re still
    focusing on learning lifecycle methods, but I wanted to point out another approach
    to be clear. The following listing shows the Post component. Create it in src/components/post/Post.js.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你的帖子也将获取它们自己的内容，这样你可以在未来的章节中移动 Post 组件并单独渲染它。App 组件会发起请求获取帖子，但它真正关心的是帖子的 ID
    和日期，而 Post 组件本身将负责加载其余内容。另一种方法是让 App 组件负责所有数据获取，并将数据传递给帖子。这种方法的优点是网络请求更少。为了说明目的，我们将使帖子负责额外的数据获取，因为我们仍然专注于学习生命周期方法，但我想要指出另一种方法以保持清晰。以下列表显示了
    Post 组件。在 src/components/post/Post.js 中创建它。
- en: Listing 4.10\. Creating the Post component (src/components/post/Post.js)
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 创建 Post 组件（src/components/post/Post.js）
- en: '[PRE22]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Import the API module so you can fetch a post.**'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 API 模块，以便可以获取帖子。**'
- en: '***2* Import the constituent components for Post.**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 Post 的组成部分。**'
- en: '***3* You need lifecycle methods, so extend React.Component.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你需要生命周期方法，所以扩展 React.Component。**'
- en: '***4* Declare propTypes.**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明 prop 类型。**'
- en: '***5* Define a constructor so you can set state and bind class methods.**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 定义构造函数，以便可以设置状态和绑定类方法。**'
- en: '***6* Set initial state.**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 设置初始状态。**'
- en: '***7* Bind class method.**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 绑定类方法。**'
- en: '***8* Load a post on mount.**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 在挂载时加载帖子。**'
- en: '***9* Use the API to fetch a single post and update state.**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 使用 API 获取单个帖子并更新状态。**'
- en: '***10* If the post hasn’t loaded yet, show a loader component.**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 如果帖子尚未加载，则显示加载组件。**'
- en: '***11* Set up the mock data for your CommentBox component.**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 为 CommentBox 组件设置模拟数据。**'
- en: The last thing you need to do is to actually iterate over the posts so they
    get displayed. Remember that the way to display a dynamic list of components is
    to construct an array (either through `Array.map` or another method) and use that
    in a JSX expression. Also, don’t forget that React requires you to pass a key
    prop to each item being iterated so it knows which components to update in a dynamic
    list. This is true for any array of components that you return in a `render` method.
    The next listing shows how to update the `render` method of the App component
    to iterate over posts.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是迭代帖子以便它们被显示。记住，显示动态组件列表的方法是构造一个数组（通过 `Array.map` 或其他方法），并在 JSX 表达式中使用它。此外，不要忘记
    React 需要你为迭代的每个项目传递一个 key 属性，以便它知道在动态列表中更新哪些组件。这对于在 `render` 方法中返回的任何组件数组都是正确的。下一个列表显示了如何更新
    App 组件的 `render` 方法以迭代帖子。
- en: Listing 4.11\. Iterating over Post components (src/app.js)
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 迭代 Post 组件（src/app.js）
- en: '[PRE23]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Import the Post component.**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Post 组件。**'
- en: '***2* Iterate over the posts you fetched and render a Post component for each
    one.**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 迭代你获取的帖子并为每个帖子渲染一个 Post 组件。**'
- en: '***3* Don’t forget to add a key prop to each item that you’re iterating over.**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不要忘记为迭代的每个项目添加一个 key 属性。**'
- en: With that, you’re rendering out posts and have a start on Letters Social, as
    shown in [figure 4.10](kindle_split_015_split_003.xhtml#ch04fig10). There’s lots
    of room for improvements, certainly, but you’re on your way. We’ll look at adding
    posts and adding locations to posts in the next chapter. We’ll also explore using
    refs—a way to access underlying DOM elements from your React components.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你正在渲染帖子，并开始了Letters Social的构建，如图4.10所示。当然，还有很多改进的空间，但你已经在路上了。在下一章中，我们将探讨添加帖子以及为帖子添加位置。我们还将探索使用refs——一种从你的React组件访问底层DOM元素的方法。
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Uncaught errors**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**未捕获的错误**'
- en: What happens when an uncaught error occurs in a React component? Are there ways
    to handle the error?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当React组件中发生未捕获的错误时会发生什么？有处理错误的方法吗？
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 4.10\. Our first pass at Letters Social. Posts are rendering, and you
    can load more. In the next chapter, you’ll add the ability to create posts with
    locations.
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.10。我们对Letters Social的第一次尝试。帖子正在渲染，你可以加载更多。在下一章中，你将添加创建带位置帖子的功能。
- en: '![](Images/04fig10_alt.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig10_alt.jpg)'
- en: 4.4\. Summary
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 概述
- en: 'Let’s go over what you’ve learned in this chapter:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章所学的内容：
- en: React components are created from JavaScript classes that inherit from the `React.Component`
    class and that have a lifecycle you can hook into. This means they have a beginning,
    middle, and end of their time being managed by React. Because they inherit from
    the `React.Component` abstract base class, they also have access to special React
    APIs that stateless functional components don’t.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件是由继承自`React.Component`类并具有可钩入生命周期的JavaScript类创建的。这意味着它们在React管理它们的时间中有开始、中间和结束。由于它们继承自`React.Component`抽象基类，它们还可以访问无状态函数组件没有的特殊React
    API。
- en: React provides lifecycle methods that you can use to hook into different parts
    of a component’s lifetime. This lets your app act appropriately at different parts
    of React’s process of managing the UI. These lifecycle methods don’t all have
    to be used and should only be brought in when you need them. Many times, all you’ll
    need is a stateless functional component.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React提供了生命周期方法，你可以使用它们来钩入组件生命周期的不同部分。这意味着你的应用程序可以在React管理UI的过程中适当行动。这些生命周期方法并不都需要使用，并且只有在需要时才应该引入。很多时候，你可能只需要一个无状态函数组件。
- en: 'React provides a method for handling errors that occur in your component’s
    `constructor`, `render`, or lifecycle methods: `componentDidCatch`. Using this
    method, you can create *error boundaries* in your application. These behave like
    `try...catch` statements in JavaScript. When an error is caught by React, it will
    unmount the component where the error occurred and its children from the DOM to
    promote render stability and prevent an entire app from breaking.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React提供了一种处理在组件的`constructor`、`render`或生命周期方法中发生的错误的方法：`componentDidCatch`。使用此方法，你可以在应用程序中创建*错误边界*。这些行为类似于JavaScript中的`try...catch`语句。当React捕获到错误时，它将卸载发生错误的组件及其子组件从DOM中，以促进渲染稳定性并防止整个应用程序崩溃。
- en: You’ve started building Letters Social, the project we’ll use to explore topics
    in React for the rest of the book. The final version of the project is available
    online at [https://social.react.sh](https://social.react.sh), and the source can
    be found at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经开始构建Letters Social，这是我们将在本书的剩余部分探索React主题的项目。项目的最终版本可在网上找到，网址为[https://social.react.sh](https://social.react.sh)，源代码可在[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)找到。
- en: In the next chapter, you’ll start to add more functionality to Letters Social.
    We’ll focus on adding the ability to create posts dynamically and even add locations
    to posts using Mapbox.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始为Letters Social添加更多功能。我们将专注于添加动态创建帖子的功能，甚至可以使用Mapbox为帖子添加位置。
- en: Chapter 5\. Working with forms in React
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章. 在React中使用表单
- en: '*This chapter covers*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using forms in React
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中使用表单
- en: Controlled and uncontrolled form components in React
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的受控和非受控表单组件
- en: Validating and sanitizing data in React
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中验证和清理数据
- en: 'By this point, you’ve gotten some basics for building simple components with
    React: lifecycle hooks, PropTypes, and much of the top-level component API. You’ve
    had a taste of the fundamentals and can do basic things like update local component
    state and pass data between components using props. You’ve also been introduced
    to component structure, ways to think in terms of components, and lifecycle methods.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经为使用React构建简单组件获得了一些基础知识：生命周期钩子、PropTypes以及大部分顶级组件API。您已经尝到了基础知识的味道，可以做一些基本的事情，比如更新本地组件状态和通过props在组件之间传递数据。您还介绍了组件结构、以组件为单位的思考方式以及生命周期方法。
- en: In this chapter, you’ll put more of that knowledge to work and really start
    building out the sample app, Letters Social. You’ll be creating a component that
    users can use to create new posts for Letters Social. First, we’ll explore the
    overall problem and review the data requirements. Then we’ll talk about forms
    in React and you’ll build out the functionality for the component. By the end
    of this chapter, you’ll have learned how to use forms in your React applications.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将应用更多知识，并真正开始构建Letters Social示例应用。您将创建一个用户可以使用它来为Letters Social创建新帖子的组件。首先，我们将探讨整体问题并回顾数据需求。然后，我们将讨论React中的表单，并构建组件的功能。到本章结束时，您将学会如何在React应用中使用表单。
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How do I get the code for this chapter?**'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapter 4](kindle_split_015_split_000.xhtml#ch04)
    (if you followed along and built out the examples yourself) or check out the chapter-specific
    branch (chapter-5-6).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，您可以通过访问GitHub仓库[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)来获取本章的源代码。如果您想从一张白纸开始学习本章内容并跟随操作，您可以使用[第4章](kindle_split_015_split_000.xhtml#ch04)中的现有代码（如果您跟随操作并自行构建了示例）或检出特定章节的分支（chapter-5-6）。
- en: 'Remember, each branch corresponds to the code at the end of the chapter (for
    example, chapter-5-6 corresponds to the code as it will be at the end of [chapters
    5](kindle_split_016_split_000.xhtml#ch05) and [6](kindle_split_017_split_000.xhtml#ch06)).
    You can execute one of the following terminal commands in the directory of your
    choice to get the code for the current chapter. If you don’t have the repository
    at all, type the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应于章节末尾的代码（例如，chapter-5-6对应于[第5章](kindle_split_016_split_000.xhtml#ch05)和[第6章](kindle_split_017_split_000.xhtml#ch06)末尾的代码）。您可以在您选择的目录中执行以下终端命令之一来获取当前章节的代码。如果您根本没有任何仓库，请输入以下命令：
- en: '[PRE24]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you already have the repository cloned:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经克隆了仓库：
- en: '[PRE25]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能是从其他章节来到这里的，所以确保您已经安装了所有正确的依赖项总是一个好主意：
- en: '[PRE26]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1\. Creating posts in Letters Social
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 在Letters Social中创建帖子
- en: So far, your React application, Letters, doesn’t do much except let you read
    things. A read-only social network is really more like a library, and that’s not
    what your fictional investors want. The first feature you need to create is to
    the ability to create posts. You’ll be creating functionality for users to create
    posts with forms and display them in the newsfeed. To get started, let’s review
    the data requirements and get an overview of the problem so you understand exactly
    what you need to accomplish.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的React应用Letters除了让您阅读内容之外，并没有做什么。一个只读的社会网络实际上更像是一个图书馆，而这并不是您虚构的投资者想要的。您需要创建的第一个功能是创建帖子的能力。您将为用户创建使用表单创建帖子并显示在新闻源中的功能。为了开始，让我们回顾数据需求并概述问题，以便您确切了解需要完成什么。
- en: 5.1.1\. Data requirements
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 数据需求
- en: You’ll be starting to use some browser HTTP libraries to send data to your fake
    API server. You probably already know at least a little bit about how these work
    and how to communicate with RESTful and other sorts of web APIs from JavaScript,
    so I won’t cover it in depth. If you don’t have experience with HTTP in the browser
    or communication with servers, there are many excellent resources available, for
    example, *JavaScript Application Design* by Nicolas G. Bevacqua (Manning, 2015).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始使用一些浏览器HTTP库向你的模拟API服务器发送数据。你可能已经对它们的工作原理以及如何从JavaScript中与RESTful和其他类型的Web
    API进行通信有所了解，所以这里不会深入讲解。如果你在浏览器中使用HTTP或与服务器通信方面没有经验，有许多优秀的资源可供参考，例如Nicolas G. Bevacqua的《JavaScript应用程序设计》（Manning，2015年）。
- en: When working with APIs, you usually need to send data that fulfills a contract
    of sorts. If a database is expecting user info, you may be required to include
    things like your name, email, and perhaps a profile picture. Your data will usually
    need to have a particular shape to it, or the server will reject it. One of the
    first things you should to is figure out how exactly your data needs to look for
    the server to be happy.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当与API一起工作时，你通常需要发送满足某种合同的数据。如果数据库期望用户信息，你可能需要包括你的姓名、电子邮件，也许还有个人照片。你的数据通常需要具有特定的形状，否则服务器会拒绝它。你应该做的第一件事就是弄清楚你的数据需要以何种方式呈现，以便服务器满意。
- en: '[Listing 5.1](kindle_split_016_split_001.xhtml#ch05ex01) shows the basic schema
    for posts in Letters Social. We’re using a simple JavaScript class here because
    that’s what the server will actually use. When creating a post, the payload you
    send to the server needs to have most of the things defined in the schema. Note
    that your post can have a number of useful properties on it, including a location—you’ll
    create a location-adding feature in [chapter 6](kindle_split_017_split_000.xhtml#ch06).
    The server will assign some smart defaults for properties you don’t specify but
    will ignore other properties that aren’t defined. One thing you won’t need to
    do in the browser is create a unique ID—the server can do that on its own.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.1](kindle_split_016_split_001.xhtml#ch05ex01)显示了Letters Social中帖子的基本模式。这里我们使用一个简单的JavaScript类，因为服务器实际上会使用它。在创建帖子时，你发送给服务器的有效负载需要包含模式中定义的大部分内容。请注意，你的帖子可以包含许多有用的属性，包括位置——你将在第6章中创建一个添加位置的功能。服务器将为未指定的属性分配一些智能默认值，但会忽略未定义的其他属性。在浏览器中，你不需要创建一个唯一的ID——服务器可以自己完成这项工作。'
- en: Listing 5.1\. Post schema (db/models.js)
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 帖子模式（db/models.js）
- en: '[PRE27]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 5.1.2\. Component overview and hierarchy
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 组件概述和层次结构
- en: Now that you know a little about the data you’ll be able to work with, you can
    start to think about how you might be able to express this data in component form.
    There are plenty of examples of the sort of social networking app you’re creating,
    so it shouldn’t be hard to think of examples you’ve seen. [Figure 5.1](kindle_split_016_split_001.xhtml#ch05fig01)
    shows the final product that you’re building toward, so we can look at that for
    some initial inspiration.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对将要处理的数据有所了解，你可以开始思考如何以组件形式表达这些数据。有许多关于你正在创建的社交网络应用的例子，所以思考你看到的例子应该不难。[图5.1](kindle_split_016_split_001.xhtml#ch05fig01)显示了你正在努力构建的最终产品，我们可以从中获得一些初步的灵感。
- en: Figure 5.1\. The final Letters Social app you’ll be building. Can you see any
    ways you can break things out into components?
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 你将构建的最终Letters Social应用程序。你能看到任何可以将事物分解为组件的方法吗？
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig01_alt.jpg)'
- en: 'I talked about establishing component hierarchy and relationships earlier in
    the book and emphasized their importance in creating apps with React. We’ll do
    that again here before you start creating your component. Here’s what you have
    so far in your Letters app:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书前面讨论了建立组件层次结构和关系，并强调了它们在创建React应用程序中的重要性。在你开始创建组件之前，我们再次强调这一点。以下是你在Letters应用程序中目前拥有的内容：
- en: Post data available to use from the API; some posts have images, others have
    links
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API可用的数据；一些帖子包含图片，其他帖子包含链接
- en: User data for each post, with some avatar info
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个帖子的用户数据，包括一些头像信息
- en: An App component that serves as the catch-all component for the entire application
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个充当整个应用程序的通用组件的App组件
- en: A Post component that you use as you iterate over the data from the API
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Post组件，你将使用它迭代API中的数据
- en: You need to add the ability to create posts, and these posts can have locations
    associated with them as well as text content. You’ll need to let the user pick
    this location and then display that location in each of the posts in the newsfeed.
    Where should the CreatePost component live? Based on the mockups and the user
    needs, it seems like it makes sense to place it as a sibling to the iterated posts,
    all within the main App component, as illustrated in [figure 5.2](kindle_split_016_split_001.xhtml#ch05fig02).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加创建帖子的功能，这些帖子可以与位置相关联，以及文本内容。你需要让用户选择这个位置，然后在新闻源中的每个帖子中显示该位置。CreatePost
    组件应该放在哪里？根据原型和用户需求，它似乎应该作为迭代帖子的兄弟元素存在，所有这些都位于主 App 组件中，如 [图 5.2](kindle_split_016_split_001.xhtml#ch05fig02)
    所示。
- en: Figure 5.2\. Existing and future components. You’ve created Post and App components
    that fetch and iterate over data. The Create Post component will exist outside
    components used to display posts.
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 现有和未来的组件。你已经创建了 Post 和 App 组件，用于获取和遍历数据。Create Post 组件将存在于用于显示帖子的组件之外。
- en: '![](Images/05fig02.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02.jpg)'
- en: Let’s see how to create the skeleton for your component. You’ll put in just
    the basics of a component that will render a basic element out, import the right
    tools, export the `Component` class, and set up PropTypes to be defined later.
    The following listing shows how to create this basic skeleton.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建组件的骨架。你只需输入组件的基本元素，导入正确的工具，导出 `Component` 类，并设置 PropTypes 以供以后定义。以下列表显示了如何创建这个基本骨架。
- en: Listing 5.2\. Creating a component skeleton (src/components/post/Create.js)
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 创建组件骨架 (src/components/post/Create.js)
- en: '[PRE28]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Import React and the PropTypes object so you can use it.**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 React 和 PropTypes 对象以便使用它。**'
- en: '***2* Create a React component.**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个 React 组件。**'
- en: '***3* Declare PropTypes as a static property on the class.**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在类上声明 PropTypes 作为静态属性。**'
- en: '***4* Set up the constructor—you’ll use this later.**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置构造函数——你稍后会用到它。**'
- en: '***5* Export the component so you can use it elsewhere.**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导出组件以便在其他地方使用。**'
- en: 5.2\. Forms in React
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. React 中的表单
- en: Both components you’re building in this chapter involve the use of forms. Web
    forms are still similar to paper forms—they’re a structured means of receiving
    and recording input. With paper, you use a pen or pencil to record information.
    With browser forms, you use a keyboard, mouse, and files on your computer to capture
    information. There are a number of form elements that you are probably familiar
    with, like `input`, `select`, and `textarea`, among others.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你构建的两个组件都涉及表单的使用。Web 表单仍然类似于纸质表单——它们是接收和记录输入的结构化方式。用纸张时，你用钢笔或铅笔记录信息。用浏览器表单时，你用键盘、鼠标和电脑上的文件来捕获信息。你可能熟悉许多表单元素，如
    `input`、`select` 和 `textarea` 等。
- en: Most web applications involve forms to one degree or another. I’ve never worked
    on an application that was deployed to production that didn’t involve forms of
    some kind. I’ve also found that forms sometimes have a bad reputation for being
    difficult to work with. Perhaps it’s for this reason that many frameworks have
    implemented a “magic” approach to forms that seeks to ease the burden on the developer.
    React doesn’t take a magical approach, but it can make forms easier to work with.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序在某种程度上都涉及表单。我从未参与过没有涉及任何形式的应用程序的生产部署。我还发现，表单有时因为难以处理而名声不佳。也许正因为如此，许多框架都实施了一种“魔法”方法来处理表单，旨在减轻开发者的负担。React
    并不采用魔法方法，但它可以使表单更容易处理。
- en: 5.2.1\. Getting started with forms
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 开始使用表单
- en: There’s no standard way to do forms across front-end frameworks. In some frameworks
    and libraries, you can set up a form *model* that’s updated as the user changes
    form values and has special methods built into it for detecting when a form is
    in different states. Others implement different paradigms and techniques when
    it comes to forms. What they all have in common is that they do forms slightly
    differently.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端框架中处理表单没有标准方法。在某些框架和库中，你可以设置一个表单 *模型*，该模型在用户更改表单值时更新，并且其中内置了特殊方法来检测表单处于不同状态。其他框架在处理表单时实施不同的范例和技术。它们共同的特点是它们以不同的方式处理表单。
- en: What should we make of the different approaches? Is one better than another?
    It’s hard to say whether one is fundamentally better than another, but sometimes
    “easier to use” approaches can obscure the underlying mechanisms and logic from
    you. That’s not always a bad thing—sometimes you don’t need visibility into the
    inner workings of the framework. But you do need to have a sufficient understanding
    to support a mental model that will let you create maintainable code and fix bugs
    when they arise. That’s where React shines, in my opinion. By not giving you too
    much “magic” when it comes to forms, you get a nice middle ground between having
    to know too much and knowing too little about the forms.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何看待不同的方法？哪一个更好？很难说哪一个在本质上比另一个更好，但有时“更容易使用”的方法可能会掩盖你背后的机制和逻辑。这并不总是坏事——有时你不需要了解框架的内部工作。但你需要有足够的理解来支持一个心理模型，这将让你能够创建可维护的代码并在出现问题时修复错误。在我看来，这正是React的亮点。在表单方面，它没有给你太多“魔法”，这让你在知道太多和知道太少之间找到了一个很好的平衡。
- en: 'Fortunately, the mental model for forms in React is more of what you’ve already
    learned. There’s no special set of APIs to use—forms are just more of what we’ve
    seen so far in React: components! You use components, state, and props to create
    forms. Because we’re building on previous learning, let’s review some parts of
    React’s mental model before moving on:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React中表单的心理模型更像是你已经学过的。没有特殊的API集可以使用——表单只是我们在React中看到的东西的更多内容：组件！你使用组件、状态和属性来创建表单。因为我们是在之前的学习基础上构建的，所以在继续之前，让我们回顾一下React心理模型的一些部分：
- en: 'Components have two main ways of working with data: state and props.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件有两种主要的数据处理方式：状态和属性。
- en: Because they’re JavaScript classes, components can have custom class methods
    in addition to lifecycle hooks that can be used to respond to events and for just
    about anything else.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们是JavaScript类，组件除了可以用来响应事件和做其他任何事情的生命周期钩子外，还可以有自定义类方法。
- en: As you might for regular DOM elements, you can listen for events like clicks,
    input changes, and other events in React components.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像对待常规DOM元素一样，你可以在React组件中监听事件，如点击、输入更改和其他事件。
- en: Parent components (such as form elements) can provide callback methods as props
    to child components, making it possible for components to communicate with each
    other.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件（如表单元素）可以通过属性向子组件提供回调方法，使组件之间能够相互通信。
- en: You’ll use these familiar React ideas as you build out your component for creating
    posts.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建创建帖子的组件时，你会使用这些熟悉的React思想。
- en: 5.2.2\. Form elements and events
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 表单元素和事件
- en: 'To create a post, you’ll need to make sure that the post is persisted to your
    database, that the post UI is updated, and that you update the list of posts for
    the user. First, you’ll scaffold out the form elements that you’ll build, just
    as you might if you were building out a regular HTML form. There’s not much to
    the markup—you’re only receiving one input and don’t need to display much else.
    The following listing shows the very beginnings of the component: rendering a
    `textarea` input.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个帖子，你需要确保帖子被持久化到你的数据库中，帖子用户界面得到更新，并且你更新了用户的帖子列表。首先，你将构建表单元素，就像你构建一个常规HTML表单一样。标记并不复杂——你只接收一个输入，不需要显示其他内容。以下列表显示了组件的初始阶段：渲染一个`textarea`输入。
- en: Listing 5.3\. Adding to your CreatePost component (src/components/post/Create.js)
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 向你的 CreatePost 组件添加内容（src/components/post/Create.js）
- en: '[PRE29]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that you’ve created the bare-bones markup for your basic form, you can start
    to wire things up. You may remember from earlier chapters that React lets you
    interact with events like you would in regular browser JavaScript. It lets you
    listen for regular events like clicks, scrolls, and others and react (no pun intended)
    to them. You’ll take advantage of these events as you work with your forms.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的基本表单创建了基本的标记，你可以开始连接这些元素。你可能还记得，从前面的章节中，React让你以与常规浏览器JavaScript相同的方式与事件交互。它让你监听常规事件，如点击、滚动等，并对它们做出反应。当你处理表单时，你会利用这些事件。
- en: '|  |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve worked on front-end applications for some time, you’ll know that there
    are many inconsistencies between different browsers, especially when it comes
    to events. In addition to all the other goodness you get from it, React also does
    a lot of work to abstract over these differences in browser implementations. That’s
    a benefit that doesn’t get much attention, but it can be an incredible help. Not
    having to worry as much about the differences between browsers tends to let you
    focus more on other areas of your app and generally results in happier developers.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从事前端应用开发一段时间，你会知道不同浏览器之间有很多不一致性，尤其是在事件方面。除了从它那里获得的所有其他好处之外，React还做了很多工作来抽象化浏览器实现中的这些差异。这是一个不太引起注意的好处，但它可以是一个难以置信的帮助。不必过多担心浏览器之间的差异通常会让你更多地关注应用程序的其他领域，并且通常会导致开发者更加快乐。
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Many different events can occur in the browser as a result of user interaction—including
    mouse moves, keyboard typing, clicks, and more. We’re concerned with a few of
    these types of events in particular when it comes to your app. For our purposes,
    you want to listen with two main event handlers—`onChange` and `onClick`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户交互，浏览器可以发生许多不同的事件——包括鼠标移动、键盘输入、点击等。在我们的应用中，我们特别关注这些类型的一些事件。对于我们的目的，你想要通过两个主要的事件处理程序——`onChange`和`onClick`——来监听：
- en: '**`onChange`—** This is fired when an input element changes. You can access
    the new value of the form element using `event.target.value`.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`onChange`—** 当输入元素发生变化时，这个事件会被触发。你可以使用`event.target.value`访问表单元素的新的值。'
- en: '**`onClick`—** This is fired when an element is clicked. You’ll listen for
    this so you can know when a user wants to send a post to the server.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`onClick`—** 当一个元素被点击时，这个事件会被触发。你会监听这个事件，以便知道用户何时想要将帖子发送到服务器。'
- en: Next you’ll assign some event handlers for these events. For now, you’ll put
    in some console logging side effects for these functions so we can observe them
    being fired. You’ll replace these with real functionality later. The following
    listing shows how you can set up the event handlers by binding them in the component
    class constructor and then assigning them in the components.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将为这些事件分配一些事件处理程序。目前，你将把这些函数放入一些控制台日志副作用中，这样我们就可以观察它们何时被触发。稍后，你会用真实的功能替换这些函数。以下列表显示了如何通过在组件类构造函数中绑定它们，然后在组件中分配它们来设置事件处理程序。
- en: Listing 5.4\. Adding to your CreatePost component (src/components/post/Create.js)
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. 向CreatePost组件添加功能（src/components/post/Create.js）
- en: '[PRE30]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Bind class methods for handling submission and post changes.**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定处理提交和帖子更改的类方法。**'
- en: '***2* Declare method on class to be used when update occurs to body text (the
    onChange event)**'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在类上声明当正文文本（即onChange事件）更新时要使用的方法。**'
- en: '***3* Declare method for handling submission event, and React will pass event
    to handler**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明处理提交事件的函数，React会将事件传递给处理程序**'
- en: '***4* Pass event handlers to the button and textarea components.**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将事件处理程序传递给按钮和文本区域组件。**'
- en: '***5* Value of component will be read from component state**'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 组件的值将从组件状态中读取**'
- en: Event handlers receive a synthetic event as an argument, and we have access
    to a number of available properties on the synthetic event. [Table 5.1](kindle_split_016_split_002.xhtml#ch05table01)
    shows some of the properties you can access on a synthetic event. By *synthetic*
    event, I mean that React translates the browser event into something you can work
    with in your React components.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序接收一个合成事件作为参数，并且我们可以访问合成事件上的许多可用属性。[表5.1](kindle_split_016_split_002.xhtml#ch05table01)
    展示了你可以访问的合成事件的一些属性。通过“合成”事件，我的意思是React将浏览器事件转换为你在React组件中可以操作的东西。
- en: Table 5.1\. Properties and methods available on a synthetic event in React
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.1\. React中合成事件可用的属性和方法
- en: '| Property | Return type |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 返回类型 |'
- en: '| --- | --- |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| bubbles | boolean |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| bubbles | boolean |'
- en: '| cancelable | boolean |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| cancelable | boolean |'
- en: '| currentTarget | DOMEventTarget |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| currentTarget | DOMEventTarget |'
- en: '| defaultPrevented | boolean |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| defaultPrevented | boolean |'
- en: '| eventPhase | number |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| eventPhase | number |'
- en: '| isTrusted | boolean |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| isTrusted | boolean |'
- en: '| nativeEvent | DOMEvent |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| nativeEvent | DOMEvent |'
- en: '| preventDefault() |   |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| preventDefault() |   |'
- en: '| isDefaultPrevented() | boolean |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| isDefaultPrevented() | boolean |'
- en: '| stopPropagation() |   |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| stopPropagation() |   |'
- en: '| isPropagationStopped() | boolean |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| isPropagationStopped() | boolean |'
- en: '| target | DOMEventTarget |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| target | DOMEventTarget |'
- en: '| timeStamp | number |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| timeStamp | number |'
- en: '| type | string |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| type | string |'
- en: 'Before we move on, try something: add `console.log(event)` to the post component’s
    change event handler. If you type something into the `textarea` element and open
    the developer console for your browser, you should see messages being logged out
    (see [figure 5.3](kindle_split_016_split_002.xhtml#ch05fig03) for an example).
    If you inspect these objects or try accessing some of the properties in [table
    5.1](kindle_split_016_split_002.xhtml#ch05table01), you should get back information
    about the event. For our purposes, we’ll be concerned with the `target` property
    that you get back. Remember, `event.target` is just a reference to the DOM element
    that dispatched the event, as it would be in normal JavaScript.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，尝试一下：将 `console.log(event)` 添加到帖子组件的更改事件处理程序中。如果你在 `textarea` 元素中输入一些内容并打开浏览器开发者控制台，你应该会看到消息被记录出来（见[图5.3](kindle_split_016_split_002.xhtml#ch05fig03)以获取示例）。如果你检查这些对象或尝试访问[表5.1](kindle_split_016_split_002.xhtml#ch05table01)中的某些属性，你应该会得到关于事件的详细信息。对我们来说，我们将关注返回的
    `target` 属性。记住，`event.target` 只是对触发事件的DOM元素的引用，就像在正常的JavaScript中一样。
- en: Figure 5.3\. React passes a synthetic event to event handlers that you set up.
    It’s a *normalized* event, meaning you can access the same properties and data
    as you would for a regular browser event.
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. React将一个合成事件传递给你设置的事件处理程序。它是一个*标准化*的事件，这意味着你可以访问与常规浏览器事件相同的属性和数据。
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: 5.2.3\. Updating state in forms
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 在表单中更新状态
- en: 'You can listen for events now and watch as your component listens to updates
    and submission events, but you’re not doing anything with the data yet. You need
    to do something with the events to update your application state. This is the
    key way you work with forms in React: by receiving events from event handlers
    and then using data from those events to update state or props.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以监听事件，并观察你的组件如何监听更新和提交事件，但你还没有对数据进行任何操作。你需要对事件进行处理以更新你的应用程序状态。这是你在React中使用表单的关键方式：通过接收事件处理程序的事件，然后使用这些事件的数据来更新状态或属性。
- en: 'State and props are the two main ways that React lets you work with data. Right
    now, if you try to type something into the form, nothing happens. That may seem
    like an error at first, but it’s just React doing its job. Think about it: when
    you’re changing the value of the input, you’re mutating the DOM, and part of React’s
    main job is to make sure that the DOM stays in sync with the in-memory version
    of the DOM that gets created from your components.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和属性是React让你处理数据的两种主要方式。现在，如果你尝试在表单中输入一些内容，什么都不会发生。一开始这可能看起来像是一个错误，但这只是React在执行其工作。想想看：当你改变输入的值时，你正在修改DOM，React的主要工作之一就是确保DOM与从你的组件创建的内存中DOM版本保持同步。
- en: Because you haven’t changed anything in the in-memory DOM (no state was updated),
    React won’t update the actual DOM with any changes. That’s a great example of
    React in action, doing its job perfectly. If you were able to update the form
    values, you’d be inadvertently putting yourself in a tricky situation where things
    are out of sync and you’d need to go back to older ways of doing things (which
    is what React improves on in the first place).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你还没有在内存中的DOM中做任何改变（没有更新状态），React不会用任何更改来更新实际的DOM。这是一个React完美执行其工作的绝佳例子。如果你能够更新表单值，你可能会无意中把自己置于一个复杂的情况中，其中事物不同步，你需要回到更老的方式去做事情（这正是React最初改进的地方）。
- en: To update state, you’ll listen for the event emitted by React when the input
    value changes. When this event is emitted, you’ll extract a value from it and
    use that value to update component state. That gives you the opportunity to control
    every step of the update process.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态，你需要监听React在输入值改变时发出的事件。当这个事件被发出时，你会从中提取一个值，并使用这个值来更新组件状态。这给了你控制更新过程每个步骤的机会。
- en: Let’s see how to put this into practice. [Listing 5.5](kindle_split_016_split_002.xhtml#ch05ex05)
    shows how to set up event handlers to listen to and update the state of your components
    when a user changes a data value. Later, you’ll use the `event.target` reference
    you worked with before and access the `value` property to update your state with
    the value from the `textarea` element.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将其付诸实践。[列表5.5](kindle_split_016_split_002.xhtml#ch05ex05)展示了如何设置事件处理程序来监听和更新用户更改数据值时组件的状态。稍后，你将使用之前工作过的
    `event.target` 引用并访问 `value` 属性来使用 `textarea` 元素中的值更新你的状态。
- en: Listing 5.5\. Updating component state using inputs (src/components/post/Create.js)
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5\. 使用输入更新组件状态（src/components/post/Create.js）
- en: '[PRE31]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Grab value of textarea element from value property of DOM element (what
    you want to update state with)**'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 DOM 元素的值属性中获取 textarea 元素的值（您想用其更新状态）**'
- en: '***2* Use that value to set state and update it with new value**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用该值设置状态，并使用新值更新它**'
- en: '***3* To see updated state, hit form submission button and inspect developer
    console**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 要查看更新后的状态，请点击表单提交按钮并检查开发者控制台**'
- en: '***4* New value for textarea element is provided to element**'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为 textarea 元素提供新的值**'
- en: 5.2.4\. Controlled and uncontrolled components
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4\. 受控和非受控组件
- en: This approach to updating component state in forms—tightly controlling how updates
    occur by using events and event handlers to update state—is probably the more
    common way to handle forms in React. Components that are designed with this process
    in mind are generally known as *controlled* components. That’s because we tightly
    control the component and how state is changed. But there’s another way of designing
    components that use forms, known as *uncontrolled* components. [Figure 5.4](kindle_split_016_split_002.xhtml#ch05fig04)
    shows an overview of how controlled and uncontrolled components work and illustrates
    some of their differences.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在表单中更新组件状态的方法——通过使用事件和事件处理程序来紧密控制更新发生的方式——可能是处理 React 中表单的更常见方式。设计有此考虑的组件通常被称为
    *受控* 组件。这是因为我们紧密控制组件以及状态如何改变。但还有另一种设计使用表单的组件的方法，称为 *非受控* 组件。[图 5.4](kindle_split_016_split_002.xhtml#ch05fig04)
    展示了受控和非受控组件的工作概述，并说明了它们的一些区别。
- en: Figure 5.4\. Controlled components listen for events emitted by a DOM element,
    operate on the emitted data, and then update the component state and set the value
    of the element. This keeps everything in the domain of the component and creates
    a unified state universe. Uncontrolled components maintain their own internal
    state and create a situation where a microcosm exists within the component, cutting
    off access to and control of that state.
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 受控组件监听由 DOM 元素发出的事件，操作发出数据，然后更新组件状态并设置元素的值。这使一切都在组件的领域内，并创建了一个统一的状态宇宙。非受控组件维护其自己的内部状态，并在组件内创建了一个微观世界，切断了对该状态访问和控制。
- en: '![](Images/05fig04.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04.jpg)'
- en: In an uncontrolled component, rather than use a `value` property to set data,
    the component maintains its own internal state. You can still listen for updates
    to the input using an event handler, but you’ll no longer manage the state of
    the input. [Listing 5.6](kindle_split_016_split_002.xhtml#ch05ex06) shows an example
    of using an uncontrolled component approach. We’ll stick to using controlled components
    in this book, but it’s important to at least know what this pattern looks like
    in practice.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在非受控组件中，而不是使用`value`属性来设置数据，组件维护其自己的内部状态。您仍然可以使用事件处理程序监听输入的更新，但您将不再管理输入的状态。[列表
    5.6](kindle_split_016_split_002.xhtml#ch05ex06) 展示了使用非受控组件方法的一个示例。本书我们将坚持使用受控组件，但至少要知道这种模式在实际中的样子。
- en: Listing 5.6\. Using uncontrolled components (src/components/post/Create.js)
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 使用非受控组件（src/components/post/Create.js）
- en: '[PRE32]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Your handlers are the same as before, but the effect that changing state
    has won’t be the same.**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 您的处理程序与之前相同，但改变状态的效果将不会相同。**'
- en: '***2* As noted, there’s now no value element that will listen to the component
    state.**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如前所述，现在没有任何值元素会监听组件状态。**'
- en: 5.2.5\. Form validation and sanitization
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5\. 表单验证和清理
- en: One important part of using forms to record and store user input is letting
    users know when they’re violating any validation rules you’ve set up and when
    they’re doing anything to provide data that doesn’t satisfy your application.
    Hopefully, the server applications that receive data from your client-side application
    will have strict data-validation and sanitization procedures in place—you can’t
    rely on a browser app to do all the work in this area. And even if you have good
    data sanitization and validation in place on your server, you still need to provide
    and enforce good data practices on the front end in order to help users, to add
    another level of defense against bad actors, and to promote data integrity. If
    you don’t, you could potentially have confused users, security holes, and meaningless
    data—all things you don’t want.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单记录和存储用户输入的一个重要部分是让用户知道他们何时违反了你设定的验证规则，以及何时提供不满足你应用程序的数据。希望接收来自你客户端应用程序数据的服务器应用程序已经实施了严格的数据验证和清理程序——你不能依赖浏览器应用程序在这个领域做所有的工作。即使你在服务器上实施了良好的数据清理和验证，你仍然需要在前端提供和执行良好的数据实践，以帮助用户，增加对恶意行为者的另一层防御，并促进数据完整性。如果不这样做，你可能会遇到困惑的用户、安全漏洞和没有意义的数据——这些都是你不想看到的事情。
- en: As we’ve seen so far, using forms to update component state involves state,
    props, and component methods, like much else in React. To add validation and sanitization
    to your component, you need to hook into the update process. To that end, you’ll
    be writing general-purpose validation and sanitization functions that could be
    used anywhere you can use JavaScript and probably in most other front-end frameworks.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用表单更新组件状态涉及到状态、属性和组件方法，就像React中的许多其他方面一样。为了给你的组件添加验证和清理，你需要挂钩到更新过程。为此，你将编写通用的验证和清理函数，这些函数可以在任何可以使用JavaScript的地方使用，也许在大多数其他前端框架中也可以使用。
- en: '|  |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking about React events and forms**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于React事件和表单的思考**'
- en: Take a minute to think about what you’ve learned about events and forms in React
    so far. Are events in React any different from the events you’d deal with in the
    browser? How are they different, if at all?
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间思考一下你到目前为止在React中学到的关于事件和表单的知识。React中的事件与你在浏览器中处理的事件有何不同？如果有的话，它们是如何不同的？
- en: '|  |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Fortunately, the CreatePost component you’re creating doesn’t require extensive
    validation. You only need to check for a maximum length and do some additional
    validation so the component won’t submit empty posts to the API server. We’re
    using a simple server setup for the purposes of learning and local development,
    so it will accept most payloads without doing much validation. Writing applications
    on the server is another domain outside the scope of this book, so I’ll only focus
    on validation and sanitization on the browser.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你正在创建的CreatePost组件不需要大量的验证。你只需要检查最大长度并进行一些额外的验证，以确保组件不会向API服务器提交空帖子。我们使用简单的服务器设置用于学习和本地开发，因此它将接受大多数有效载荷而不进行太多验证。在服务器上编写应用程序是本书范围之外的另一个领域，所以我将只关注浏览器上的验证和清理。
- en: 'You need to ask yourself a few questions when setting up validation for forms
    and inputs in your applications:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置应用程序中表单和输入的验证时，你需要问自己几个问题：
- en: What are the data requirements for the application?
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的数据需求是什么？
- en: Based on these constraints, how can you help your users provide meaningful data?
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据这些限制，你如何帮助用户提供有意义的资料？
- en: Are there ways you can eliminate inconsistencies in data that users provide?
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有办法消除用户提供的数据中的不一致性吗？
- en: First, you need to find out what the data requirements set by the business or
    application back end (if one exists) are. You should start there because that
    knowledge will help you establish basic guidelines for how to treat your data.
    Because we’ve already established that your server will willingly accept most
    things and we’ve set out the basic data types for a post, we can move on the next
    question.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要找出业务或应用后端（如果有的话）设定的数据需求。你应该从这里开始，因为这方面的知识将帮助你建立如何处理数据的基本指南。因为我们已经确定你的服务器会乐意接受大多数东西，并且我们已经为帖子设定了基本的数据类型，我们可以继续下一个问题。
- en: Based on the constraints you have, how can you best help your users provide
    meaningful data and have a good experience in your app? That usually involves
    checking data for things like size, character type, maybe file type for file uploads,
    and more. Right now, your CreatePost component is fairly benign, and there’s not
    much to validate beyond length. Next you’ll check for a minimum and maximum length
    and only let the user submit their post if valid. The following listing shows
    how to set up some basic validation for your component.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的限制，你如何最好地帮助你的用户提供有意义的资料，并在你的应用中获得良好的体验？这通常涉及到检查数据的大小、字符类型，也许对于文件上传，还需要检查文件类型等。目前，你的CreatePost组件相对无害，除了长度之外没有太多需要验证的。接下来，你将检查最小和最大长度，并且只有当内容有效时才允许用户提交帖子。以下列表展示了如何为你的组件设置一些基本的验证。
- en: Listing 5.7\. Adding basic validation (src/components/post/Create.js)
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. 添加基本验证（src/components/post/Create.js）
- en: '[PRE33]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Create a simple valid property in local component state**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在本地组件状态中创建一个简单的有效属性**'
- en: '***2* Determine validity of post by setting max length here—280 demonstrates
    usage, but users sometimes want posts to be long**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过在此处设置最大长度来确定帖子的有效性——280展示了用法，但用户有时希望帖子更长**'
- en: '***3* Create a new post object.**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个新的帖子对象。**'
- en: 'We’ve worked on answering the first two questions (data constraints and validation).
    Now we can approach the final aspect: eliminating data inconsistencies with (very)
    basic data sanitization. Whereas validation is asking the user for *certain* data,
    sanitization is ensuring that the data you get back is safe and in the right format,
    and that it exists in a way that it can be persisted. Information security is
    a huge and very important field, and this book can’t begin to really go into proper
    data handling for security—but we can tackle one smaller area for Letters: offensive
    content.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了前两个问题（数据约束和验证）。现在我们可以着手解决最后一个方面：通过（非常）基本的数据清理来消除数据不一致性。验证是要求用户提供*某些*数据，而清理则是确保你得到的数据是安全的，并且格式正确，以及以某种方式存在，可以持久化。信息安全是一个庞大且非常重要的领域，这本书无法真正深入探讨正确的数据处理方法——但我们可以在Letters这个较小的领域进行探讨：攻击性内容。
- en: You’ll use a JavaScript module called bad-words, available from npm (the main
    JavaScript module registry and service—learn more at [www.npmjs.com/about](http://www.npmjs.com/about)),
    to help us out. It should already be installed in your project. bad-words takes
    in a string and replaces any words found on a blacklist (you can create your own
    and substitute it for the default if you prefer) with asterisks. The example illustrated
    in the following listing is mostly contrived, but at the very least you can prevent
    people from posting potentially offensive content on the public app ([https://social.react.sh](https://social.react.sh)).
    Remember, this a very contrived example and isn’t in any way suggesting or endorsing
    any kind of censorship.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用一个名为bad-words的JavaScript模块，它可以从npm（主要的JavaScript模块注册和服务——更多信息请访问[www.npmjs.com/about](http://www.npmjs.com/about)）获取，来帮助我们。它应该已经安装在你的项目中。bad-words接受一个字符串，并将黑名单上找到的任何单词替换为星号。以下列表中的示例主要是虚构的，但至少你可以防止人们在公共应用([https://social.react.sh](https://social.react.sh))上发布可能具有攻击性的内容。记住，这是一个非常虚构的例子，并且绝对没有暗示或支持任何形式的审查。
- en: Listing 5.8\. Adding basic content sanitization (src/components/post/Create.js)
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 添加基本内容清理（src/components/post/Create.js）
- en: '[PRE34]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Import default object from bad-words module**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从bad-words模块导入默认对象**'
- en: '***2* Use a constructor to create new instance of filter**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用构造函数创建新的过滤器实例**'
- en: '***3* Pass form value into the .clean() method of filter and use returned value
    to set state**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将表单值传递给过滤器的 .clean() 方法，并使用返回的值设置状态**'
- en: 5.3\. Creating new posts
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 创建新帖子
- en: Now that you’re performing some basic validation and sanitization of posts,
    you’ll want to create them by sending them to the server. We’re going to introduce
    slightly greater complexity to achieve this, so we’ll go over each step briefly
    and then look at an illustration of what the process will look like all put together.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在对帖子进行一些基本的验证和清理，你将想要通过将它们发送到服务器来创建它们。我们将引入稍微复杂一些的复杂性来实现这一点，所以我们将简要介绍每个步骤，然后查看整个过程的示意图。
- en: To send your post up to the API, you’ll need to do the following things, in
    addition to what the CreatePost component is already doing, which includes keeping
    track of state, doing some basic validation, and performing some basic content
    sanitization.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的帖子发送到 API，你除了需要做 CreatePost 组件已经做的事情（包括跟踪状态、进行一些基本验证和执行一些基本内容清理）之外，还需要做以下几件事情。
- en: 'Next, you’ll need to do the following to send the data up to your API:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要做以下事情来将数据发送到你的 API：
- en: Capture the user input to be used as the post, updating state and performing
    the data-checking logic you’ve implemented so far.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获用户输入作为帖子内容，更新状态并执行你迄今为止实现的数据检查逻辑。
- en: Call an event handler function passed from the parent component (the main App
    component in this case) as a prop and give the post data to it.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个从父组件（在这个例子中是主 App 组件）传递过来的事件处理函数作为 props，并将帖子数据传递给它。
- en: Reset the CreatePost component’s state.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置 CreatePost 组件的状态。
- en: In the parent component, use the data passed from the CreatePost child component
    to perform an HTTP `POST` to the server.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父组件中，使用从 CreatePost 子组件传递的数据对服务器执行 HTTP `POST` 操作。
- en: Update the local component state with the new post you receive from the server.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从服务器接收的新帖子更新本地组件状态。
- en: To get a better grasp on what you’ll be doing, see the illustration in [figure
    5.5](kindle_split_016_split_003.xhtml#ch05fig05).
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地理解你将要做什么，请参阅 [图 5.5](kindle_split_016_split_003.xhtml#ch05fig05) 中的插图。
- en: Figure 5.5\. The CreatePost component overview. The CreatePost component receives
    a function as a prop, uses its internal state as an input for that function, and
    calls it when the user clicks Submit. That function, passed from the parent App
    component, sends the data to the API, updates the local posts, and initiates a
    refresh of posts from the API.
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. CreatePost 组件概述。CreatePost 组件接收一个作为 props 的函数，使用其内部状态作为该函数的输入，并在用户点击提交时调用它。这个函数是从父
    App 组件传递过来的，它将数据发送到 API，更新本地帖子，并从 API 初始化帖子刷新。
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: You’ll start by adding a function that will handle post submission in the parent
    component (App.js). There are several parts to this function, so you’ll add them
    one at a time and we’ll go through each. [Listing 5.9](kindle_split_016_split_003.xhtml#ch05ex09)
    shows how to add the post submission function to the main App component.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从在父组件（App.js）中添加一个处理提交后操作的功能开始。这个功能有几个部分，所以你会逐个添加它们，并且我们会逐一讲解。[列表 5.9](kindle_split_016_split_003.xhtml#ch05ex09)
    展示了如何将提交后操作功能添加到主 App 组件中。
- en: Listing 5.9\. Handling post submissions (src/app.js)
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 处理帖子提交（src/app.js）
- en: '[PRE35]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Import the Letters API module.**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Letters API 模块。**'
- en: '***2* Concat the new post and make sure posts are sorted.**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 连接新的帖子并确保帖子排序。**'
- en: You’ve set up the post-creation handler function in the parent component, but
    it won’t do anything at this point because nothing ever calls it. That’s because
    you need to give it to its child component (the CreatePost component you’ve been
    working on). Remember how you can pass data from parent to child as props? You
    can pass functions, too. That’s crucial because it allows components to cooperate
    and work together. Even though components can interact, they’re not so intertwined
    or coupled that you could never move them around; the CreatePost component could
    just as easily be moved to another part of the application and emit the same data
    to another handler. [Listing 5.10](kindle_split_016_split_003.xhtml#ch05ex10)
    shows an example of passing callbacks as props.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在父组件中设置了帖子创建处理函数，但在这个阶段它不会做任何事情，因为没有东西调用它。这是因为你需要将其传递给其子组件（你一直在工作的 CreatePost
    组件）。还记得你可以如何将数据从父组件传递到子组件作为 props 吗？你也可以传递函数。这是至关重要的，因为它允许组件协作并一起工作。尽管组件可以交互，但它们并不是那么紧密地交织或耦合，以至于你永远不能移动它们；CreatePost
    组件同样可以被移动到应用程序的另一个部分，并向另一个处理程序发出相同的数据。[列表 5.10](kindle_split_016_split_003.xhtml#ch05ex10)
    展示了将回调函数作为 props 传递的示例。
- en: '|  |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Controlled and uncontrolled components**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**受控和非受控组件**'
- en: What are some of the differences between controlled and uncontrolled components
    in React? What determines whether a component is considered controlled or uncontrolled?
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 React 中受控组件和非受控组件之间的区别？什么决定了组件被认为是受控的还是非受控的？
- en: '|  |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 5.10\. Passing callbacks as props (src/app.js)
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 通过 props 传递回调函数（src/app.js）
- en: '[PRE36]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Import the component for use.**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入组件以供使用。**'
- en: '***2* Pass the handlePostSubmit function using props.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 props 传递 handlePostSubmit 函数。**'
- en: At this point, you’ve set up the basics of the event handler in the parent component
    and are passing it into the child component. That helps you separate concerns—the
    CreatePost component is only responsible for bundling up some post data and then
    sending it to the parent component to do what it wants with it, namely, sending
    it off to the API. [Chapter 6](kindle_split_017_split_000.xhtml#ch06) covers that
    and more.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经在父组件中设置了事件处理器的基础，并将其传递给子组件。这有助于你分离关注点——CreatePost 组件只负责打包一些帖子数据，然后将其发送到父组件，由父组件决定如何处理这些数据，即将其发送到
    API。[第 6 章](kindle_split_017_split_000.xhtml#ch06) 讨论了这一点以及更多内容。
- en: 5.4\. Summary
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 概述
- en: 'Here are the main things you learned in this chapter:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章你学到的主要内容：
- en: 'Forms are handled in React much like any other component: you can use events
    and event handlers to pass data around and submit data.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中处理表单的方式与处理任何其他组件类似：你可以使用事件和事件处理器来传递数据并提交数据。
- en: React doesn’t provide any “magic” ways to work with forms. Forms are just components.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 不提供任何“魔法”方式来处理表单。表单只是组件。
- en: Form validation and sanitization work within the same React mental model of
    events, component updates, rerendering, state and props, and so on.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单验证和清理工作在相同的 React 思维模型中，包括事件、组件更新、重新渲染、状态和 props 等。
- en: You can pass functions as props between components, which is a powerful and
    useful design pattern that prevents coupled components but promotes component
    communication.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在组件之间传递函数作为 props，这是一个强大且有用的设计模式，它可以防止组件耦合但促进组件通信。
- en: Data validation and sanitization aren’t “magic”—React lets you use regular JavaScript
    and libraries to work with your data.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证和清理不是“魔法”——React 允许你使用常规 JavaScript 和库来处理你的数据。
- en: In the next chapter, you’ll build on what you’ve created here and start to integrate
    a third-party library with React to add maps to your app.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将在此基础上继续构建，并开始将第三方库与 React 集成，以在你的应用中添加地图。
- en: Chapter 6\. Integrating third-party libraries with React
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章. 将第三方库与 React 集成
- en: '*This chapter covers*'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Sending form data in JSON format to a remote API
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 JSON 格式向远程 API 发送表单数据
- en: Building some new kinds of components, including a location-picker, type-ahead,
    and a display map
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一些新的组件，包括位置选择器、自动完成和显示地图
- en: Integrating your React app with Mapbox to search locations and display maps
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的 React 应用程序与 Mapbox 集成以搜索位置和显示地图
- en: In [chapter 5](kindle_split_016_split_000.xhtml#ch05), we started looking at
    forms and how they work in React. You added event handlers to update component
    state in the CreatePost component. In this chapter, you’ll build on that previous
    work and work on adding the ability to create new posts. You’ll start interacting
    more with the JSON API that provided posts to render in the last chapter.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](kindle_split_016_split_000.xhtml#ch05) 中，我们开始探讨表单及其在 React 中的工作方式。你在
    CreatePost 组件中添加了事件处理器来更新组件状态。在本章中，你将在此基础上继续工作，并尝试添加创建新帖子的功能。你将开始与在上一章中提供帖子的 JSON
    API 进行更多交互。
- en: Often, you’ll build React applications in a context that involves non-React
    libraries that also work with the DOM. These might include things like jQuery,
    jQuery plugins, or even other front-end frameworks. We’ve seen that React manages
    the DOM for you and that this can simplify how you think about user interfaces.
    There are still times, though, where you need to interact with the DOM, and it’s
    often in the context of third-party libraries that use it. We’ll explore some
    ways you can go about doing that with React in this chapter as you add Mapbox
    maps to posts in Letters Social.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在涉及非 React 库的上下文中构建 React 应用程序，这些库也使用 DOM。这些可能包括 jQuery、jQuery 插件，甚至是其他前端框架。我们已经看到
    React 为你管理 DOM，这可以简化你对用户界面的思考。然而，仍然有一些时候你需要与 DOM 交互，这通常是在使用 DOM 的第三方库的上下文中。在本章中，我们将探讨一些方法，在添加
    Mapbox 地图到 Letters Social 帖子时，如何使用 React 来实现这一点。
- en: '|  |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How do I get the code for this chapter?**'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapter 4](kindle_split_015_split_000.xhtml#ch04)
    (if you followed along and built out the examples yourself) or check out the chapter
    branch (chapter-5-6).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以通过访问 GitHub 仓库[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)来查看本章的源代码。如果你想从这个章节开始一个全新的起点并跟随，你可以使用你从[第
    4 章](kindle_split_015_split_000.xhtml#ch04)（如果你跟随并自己构建了示例）或检出章节分支（chapter-5-6）。
- en: Remember, each branch corresponds to the code at the end of the chapter or chapters
    indicated—for example, the branch chapter-5-6 corresponds to the code as it will
    be at the end of this chapter. You can execute one of the following terminal commands
    in the directory of your choice to get the code for the current chapter.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应于章节末尾或指示的章节中的代码——例如，分支 chapter-5-6 对应于本章末尾的代码。你可以在你选择的目录中执行以下终端命令来获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本没有任何仓库，请输入以下内容：
- en: '[PRE37]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you already have the repository cloned:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库：
- en: '[PRE38]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从其他章节来到这里，所以始终确保你有所有正确的依赖项安装：
- en: '[PRE39]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1\. Sending posts to the Letters Social API
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 向 Letters 社交 API 发送帖子
- en: As you’ll recall from [chapter 2](kindle_split_012_split_000.xhtml#ch02), you
    created a comment box component that allowed you to add comments. It persisted
    these locally, only in memory—the moment you refresh the page, any comments you
    added are gone because they live and die with the state of the page at a given
    time. You could have chosen to take advantage of local or session storage or used
    another browser-based storage technology (such as cookies, IndexedDB, WebSQL,
    and so on). Those would still keep everything local, however.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，从[第 2 章](kindle_split_012_split_000.xhtml#ch02)，你创建了一个允许你添加评论的评论框组件。它将这些评论本地持久化，仅在内存中——当你刷新页面时，你添加的任何评论都会消失，因为它们与给定时间点的页面状态共存亡。你可以选择利用本地或会话存储，或者使用其他基于浏览器的存储技术（如
    cookies、IndexedDB、WebSQL 等）。然而，这些仍然会将所有内容保持本地化。
- en: What you’ll do is send the post data formatted as JSON to your API server, as
    shown in [listing 6.1](kindle_split_017_split_001.xhtml#ch06ex01). It will handle
    storing the post and responding with the new data. When you cloned the repository,
    there were already-created functions in the shared/http folder that you can use
    for the Letters Social project. You’re using the `isomorphic-fetch` library for
    network requests. It follows the Fetch API of the browser but has the advantage
    that it can work on the server, too.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要做的是将帖子数据格式化为 JSON 发送到你的 API 服务器，如[列表 6.1](kindle_split_017_split_001.xhtml#ch06ex01)所示。它将处理存储帖子并响应新数据。当你克隆仓库时，在共享/http
    文件夹中已经存在可以用于 Letters 社交项目的已创建函数。你正在使用 `isomorphic-fetch` 库进行网络请求。它遵循浏览器的 Fetch
    API，但具有优势，它也可以在服务器上工作。
- en: Listing 6.1\. Sending posts to the server (src/components/ app.js)
  id: totrans-627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 向服务器发送帖子（src/components/app.js）
- en: '[PRE40]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Use the Letters API to create the post.**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 Letters API 创建帖子。**'
- en: '***2* Get the JSON response.**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取 JSON 响应。**'
- en: '***3* Using the new post, update state.**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用新的帖子更新状态。**'
- en: '***4* Make sure posts are sorted using Lodash’s orderBy method.**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 确保帖子使用 Lodash 的 orderBy 方法排序。**'
- en: '***5* Set the error state, if any.**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果有错误状态，请设置它。**'
- en: 'With that, you only have one last thing to do: invoke the post creation method
    inside the child component. You’ve already passed it in, so it’s a simple matter
    of ensuring that the click event triggers an invocation of the parent method and
    the post data gets passed along. The following listing shows how to call the method
    passed as a prop inside the child component.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你只剩下一件事要做：在子组件中调用帖子创建方法。你已经传递了它，所以只需确保点击事件触发父方法的调用，并将帖子数据传递下去。以下列表显示了如何在子组件中调用作为
    prop 传递的方法。
- en: Listing 6.2\. Calling functions passed via props
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 通过 props 调用函数
- en: '[PRE41]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Prevent default event and create an object to send to the parent component**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 阻止默认事件并创建一个发送给父组件的对象**'
- en: '***2* Make sure you have a callback function to work with.**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保你有一个回调函数来处理。**'
- en: '***3* Invoke onSubmit callback passed via props from the parent component,
    passing in new post**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用通过 props 从父组件传递的 onSubmit 回调，传入新帖子**'
- en: '***4* Reset state to initial form so user has visual cue that post was submitted**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将状态重置为初始形式，以便用户有视觉提示表示帖子已提交**'
- en: Now, if you run the application in development mode using `npm run dev`, you
    should be able to add posts! They should appear in your feed right away, but if
    you refresh your page, you should still be able to see your added post. It won’t
    have a profile image or link preview like others, but you’ll be adding those features
    in later chapters.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用 `npm run dev` 在开发模式下运行应用程序，您应该能够添加帖子！它们应该立即出现在您的源中，但如果您刷新页面，您仍然应该能够看到您添加的帖子。它不会有像其他人那样的个人资料图片或链接预览，但您将在后面的章节中添加这些功能。
- en: 6.2\. Enhancing your component with maps
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 使用地图增强您的组件
- en: Now that you’ve added the ability to create posts to your app and send them
    to the server, you can move on to enhancing it a bit. The fictional investors
    for Letters Social have been using Facebook and Twitter and have noticed that
    these let you add locations to your posts. They really want Letters Social to
    have this capability, so you’ll be adding the ability to select and display locations
    when choosing a post. You’ll also reuse the map display component so that the
    posts in a user’s newsfeed can show a location. [Figure 6.1](kindle_split_017_split_002.xhtml#ch06fig01)
    shows what you’ll be building.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为您的应用程序添加了创建帖子并将其发送到服务器的功能，您可以继续增强它。Letters Social 的虚构投资者一直在使用 Facebook
    和 Twitter，并注意到这些平台允许您在帖子中添加位置。他们非常希望 Letters Social 具有这种功能，因此您将添加选择和显示位置的功能，以便在选择帖子时使用。您还将重用地图显示组件，以便在用户的新闻源中显示位置。[图
    6.1](kindle_split_017_split_002.xhtml#ch06fig01) 展示了您将要构建的内容。
- en: Figure 6.1\. What you’ll create for Letters Social. You’ll enhance the current
    ability to post so users can add a location to their posts. Once you’re done,
    you’ll be able to search for and choose locations when creating posts.
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 您将为 Letters Social 创建的内容。您将增强当前的发帖能力，以便用户可以在帖子中添加位置。一旦完成，您在创建帖子时将能够搜索和选择位置。
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01_alt.jpg)'
- en: You might have noticed in [figure 6.1](kindle_split_017_split_002.xhtml#ch06fig01)
    that you’re going to use Mapbox to create your maps. Mapbox is a mapping and geoservices
    platform that provides an incredible variety of map and location-related services.
    You can customize maps with data, create different styles of maps and overlays,
    do geographic search, add navigation, and more. I can’t cover even close to all
    of what Mapbox does, but if you’d like to learn more, head to [www.mapbox.com](http://www.mapbox.com).
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在 [图 6.1](kindle_split_017_split_002.xhtml#ch06fig01) 中，您将使用 Mapbox
    创建地图。Mapbox 是一个地图和地理服务平台，提供了一系列令人难以置信的地图和位置相关服务。您可以使用数据自定义地图，创建不同风格的地图和覆盖层，进行地理搜索，添加导航等等。我无法涵盖
    Mapbox 所做的所有事情，但如果您想了解更多信息，请访问 [www.mapbox.com](http://www.mapbox.com)。
- en: 6.2.1\. Creating the DisplayMap component using refs
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 使用 refs 创建 DisplayMap 组件
- en: You’ll need a way to display a location to the user both when they’re picking
    a location for a new post and when a post renders in their newsfeed. We’re going
    to see how to create a component that will serve both purposes so you can reuse
    your code. You may not always be able to do this because each place where a map
    is needed may have different demands. But for this case, sharing the same component
    will work and will save you extra effort. Start by creating a new file called
    src/components/map/DisplayMap.js. You’ll put both our map-related components in
    this directory.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一种方式向用户展示位置，无论是他们在为新帖子选择位置时，还是当帖子在他们的新闻源中渲染时。我们将看到如何创建一个组件，它将服务于这两个目的，这样您就可以重用您的代码。您可能并不总是能够这样做，因为每个需要地图的地方可能有不同的需求。但在这个案例中，共享相同的组件将有效，并且可以为您节省额外的工作。首先，创建一个名为
    src/components/map/DisplayMap.js 的新文件。您将把我们的所有地图相关组件放在这个目录中。
- en: 'Where’s the Mapbox library coming from? In most other cases, we’ve used libraries
    that we installed from npm. You’ll use the Mapbox npm module in the next section,
    but you’ll use a different library to create the maps. If you look in the HTML
    template included with the source code (src/index.ejs), you’ll see a reference
    to the Mapbox JS library (`mapbox.js`):'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: Mapbox 库是从哪里来的？在大多数其他情况下，我们使用的是从 npm 安装的库。您将在下一节中使用 Mapbox npm 模块，但您将使用不同的库来创建地图。如果您查看源代码中包含的
    HTML 模板（src/index.ejs），您将看到对 Mapbox JS 库（`mapbox.js`）的引用：
- en: '[PRE42]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will give your React app the ability to work with the Mapbox JS SDK. Note
    that the Mapbox JS SDK requires a Mapbox token to work. I’ve included a public
    token in the application source code for Letters Social so you don’t need a Mapbox
    account. If you have an account or want to create one for the purposes of customization,
    you can add your token by changing values in the config directory of the application
    source.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使您的 React 应用程序能够与 Mapbox JS SDK 一起工作。请注意，Mapbox JS SDK 需要一个 Mapbox 令牌才能运行。我在
    Letters Social 的应用程序源代码中包含了一个公共令牌，因此您不需要 Mapbox 账户。如果您有账户或想为了定制目的创建一个账户，您可以通过更改应用程序源代码中的配置目录中的值来添加您的令牌。
- en: There are often situations when you’re working on a project or feature that
    requires you to integrate React with a non-React library. You might be working
    with something like Mapbox (as you are in this chapter), or it could be another
    third-party library that wasn’t written with React in mind. Given how React DOM
    manages the DOM for you, you may wonder if this is something you can even do.
    The good news is that React provides some nice escape hatches that make working
    with these sorts of libraries possible.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在您正在工作的项目或功能中，通常会有需要您将 React 与非 React 库集成的情形。您可能正在处理像 Mapbox（正如您在本章中所做的那样）这样的东西，或者可能是另一个没有考虑到
    React 的第三方库。鉴于 React DOM 为您管理 DOM，您可能会想知道您是否可以这样做。好消息是 React 提供了一些很好的逃生舱，使得与这些库一起工作成为可能。
- en: 'This is where refs come into play. I’ve briefly mentioned refs in past chapters,
    but they’ll be especially useful here. A *ref* is React’s way of giving you access
    to the underlying DOM node. Refs can be useful in React, but you shouldn’t overuse
    them. We still want to use state and props as the primary means for making our
    apps interactive and for working with data. But there are good cases where refs
    are useful, including the following:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引用发挥作用的地方。我在前面的章节中简要提到了引用，但在这里它们将特别有用。*引用*是 React 提供您访问底层 DOM 节点的方式。引用在 React
    中可能很有用，但您不应过度使用它们。我们仍然想使用状态和属性作为使我们的应用程序交互和与数据交互的主要手段。但有一些很好的用例，其中引用很有用，包括以下内容：
- en: To manage focus and imperatively interact with media elements like `<video>`
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了管理焦点和命令式地与媒体元素如 `<video>` 交互
- en: To imperatively trigger animations
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了命令式地触发动画
- en: To interact with third-party libraries that use the DOM outside of React (this
    is our use case)
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与在 React 之外使用 DOM 的第三方库交互（这是我们用例）
- en: 'How do you use refs in React? In past versions, you would add a string attribute
    to React elements (`<div ref="myref"></div>`), but the new approach is to use
    an inline callback, like so:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何在 React 中使用引用？在过去的版本中，您会给 React 元素添加一个字符串属性（`<div ref="myref"></div>`），但新的方法是使用内联回调，如下所示：
- en: '[PRE43]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When you want to refer to the underlying DOM element, you can reference it from
    your class. You can interact with it in the `ref` callback function, but most
    of the time you’ll want to store the reference on your component class so it’s
    available elsewhere.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要引用底层的 DOM 元素时，您可以从您的类中引用它。您可以在 `ref` 回调函数中与之交互，但大多数时候您会想要在您的组件类中存储引用，以便在其他地方可用。
- en: 'I should note a few things. You can’t use refs in React on a stateless functional
    component from the outside because that component doesn’t have a backing instance.
    For example, this won’t work:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出几点。您不能在 React 中的无状态函数组件外部使用引用，因为该组件没有后端实例。例如，这不会工作：
- en: '[PRE44]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But if the component is a class, you get a ref to the component because it does
    have a backing instance. You can also pass refs as props to components that consume
    them. Most of the time, you’ll only want to use refs when you need direct access
    to a DOM node, so this use case probably won’t come up often unless you’re building
    a library that needs refs to work.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果组件是一个类，您将获得组件的引用，因为它确实有一个后端实例。您还可以将引用作为属性传递给消耗它们的组件。大多数时候，您只会想要在您需要直接访问 DOM
    节点时使用引用，所以除非您正在构建一个需要引用来工作的库，否则这种用例可能不会经常出现。
- en: You’re going to use refs to interact with the Mapbox JavaScript SDK. Mapbox’s
    library handles creating a map for you and setting up lots of things like event
    handlers, UI controls, and more on the map. Its map API requires using either
    a DOM element reference or an ID to search the DOM for. You’ll use a ref. The
    following listing shows the skeleton of your DisplayMap component.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用引用与 Mapbox JavaScript SDK 进行交互。Mapbox 的库负责为您创建地图，并在地图上设置许多事情，如事件处理程序、UI
    控件等。它的地图 API 需要使用 DOM 元素引用或 ID 来在 DOM 中搜索。您将使用引用。以下列表显示了您的 DisplayMap 组件的骨架。
- en: Listing 6.3\. Adding refs to your map component (src/components/map/DisplayMap.js)
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 向您的地图组件添加引用（src/components/map/DisplayMap.js）
- en: '[PRE45]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Return an array of elements from render**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从渲染中返回元素数组**'
- en: '***2* DOM element that Mapbox will use to create your map**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Mapbox 将用于创建您的地图的 DOM 元素**'
- en: This is a good start in getting your map to work with React. Next, you’ll need
    to use the Mapbox JS API to create the map. You’ll create a method that will use
    the ref you stored on the class. You’ll also need to set up some default properties
    and state so the map has a default area to pan to and doesn’t start by showing
    the entire world. You’ll record a few pieces of state in the component, including
    whether the map has loaded and some location information (latitude, longitude,
    and place name). Note how it’s a fairly trivial matter to interact with another
    JavaScript library through React. The hardest part has been using refs, but besides
    that, the libraries can pretty easily be made to work together. The following
    listing shows how to set up the DisplayMap component.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使地图与 React 一起工作方面的一个良好开端。接下来，您需要使用 Mapbox JS API 创建地图。您将创建一个方法，该方法将使用您在类中存储的引用。您还需要设置一些默认属性和状态，以便地图有一个默认区域可以平移，并且不会一开始就显示整个世界。您将在组件中记录一些状态，包括地图是否已加载以及一些位置信息（纬度、经度和地点名称）。注意，通过
    React 与另一个 JavaScript 库交互是一件相当简单的事情。最难的部分是使用引用，但除此之外，库可以相当容易地协同工作。以下列表显示了如何设置
    DisplayMap 组件。
- en: Listing 6.4\. Creating a map with Mapbox (src/components/map/DisplayMap.js)
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 使用 Mapbox 创建地图（src/components/map/DisplayMap.js）
- en: '[PRE46]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Set up initial state**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置初始状态**'
- en: '***2* Bind the ensureMapExists class method.**'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 绑定 ensureMapExists 类方法。**'
- en: '***3* Mapbox uses a library called Leaflet (hence the “L”).**'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Mapbox 使用一个名为 Leaflet 的库（因此有“L”）。**'
- en: '***4* Check to see if the map has location information to work with—if it does,
    set up the map.**'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 检查地图是否有可用于工作的位置信息——如果有，设置地图。**'
- en: '***5* Make sure you don’t accidentally re-create the map if you’ve already
    loaded.**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 确保您不会意外地重新创建已加载的地图。**'
- en: '***6* Create new map with Mapbox and store reference to it on component (you’re
    disabling map features you don’t need)**'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用 Mapbox 创建新地图并在组件中存储对其的引用（您正在禁用不需要的地图功能）**'
- en: '***7* Set map view to latitude and longitude your component received**'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将地图视图设置为组件接收到的纬度和经度**'
- en: '***8* Update state so you know the map loaded**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 更新状态以便您知道地图已加载**'
- en: 'Your component should now display a map that’s good enough for display-only
    purposes. Remember, though, that you want to create a map component that you can
    indicate specific locations on and update for the user when they’re picking a
    new location. You’ll need to do some more work to enable these features: adding
    methods for adding a marker to the map, updating the map position, and ensuring
    that the map gets updated correctly. The following listing shows how to add these
    methods to your component.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 您的组件现在应显示一个仅用于显示目的的足够好的地图。不过，请记住，您想要创建一个可以指示特定位置并在用户选择新位置时更新给用户的地图组件。您需要做更多工作以启用这些功能：添加向地图添加标记的方法、更新地图位置以及确保地图正确更新。以下列表显示了如何将这些方法添加到您的组件中。
- en: Listing 6.5\. A dynamic map (src/components/map/DisplayMap.js)
  id: totrans-680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 一个动态地图（src/components/map/DisplayMap.js）
- en: '[PRE47]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Bind class methods**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定类方法**'
- en: '***2* Tell Mapbox to invalidate size of your map, preventing map from displaying
    incorrectly when hiding/showing it**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 告诉 Mapbox 使您的地图大小无效，防止在隐藏/显示地图时显示不正确**'
- en: '***3* When location to display changes, you need to respond accordingly**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当要显示的位置发生变化时，您需要相应地做出反应**'
- en: '***4* If you have a location, check current and previous location to see if
    properties are the same—if not, you can update map**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果您有一个位置，检查当前位置和上一个位置以查看属性是否相同——如果不相同，您可以更新地图**'
- en: '***5* Add a marker to the map when it is first created**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在地图首次创建时添加标记**'
- en: '***6* Update the map’s view and your component state accordingly.**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 根据需要更新地图视图和组件状态。**'
- en: '***7* Update an existing marker instead of creating one every time.**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 更新现有标记而不是每次都创建一个。**'
- en: '***8* Create a marker and add it to the map.**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 创建标记并将其添加到地图中。**'
- en: 'You may have noticed a pattern here as you’ve added each method to the component:
    do something with a third-party library, teach React about it, repeat. That’s
    usually how integration with third-party libraries goes in my experience. You
    tend to want to find an integration point where you can get data out of the library
    or use its API to tell it to do things—but all within React. There are many exceptions
    where it can be incredibly difficult, but in my experience, the combination of
    React’s refs and general JavaScript interoperability make working with non-React
    libraries not as bad as it could otherwise be (and I hope you find the same in
    your future React apps).'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给组件添加每个方法时，你可能已经注意到了一个模式：使用第三方库做些事情，教 React 了解它，然后重复。这通常是我经验中与第三方库集成的做法。你通常会想要找到一个集成点，你可以从中获取库的数据或使用它的
    API 来告诉它做事情——但所有这些都在 React 中完成。有许多例外，其中可能非常困难，但根据我的经验，React 的 refs 和一般的 JavaScript
    互操作性使得与非 React 库一起工作并不像其他情况下那样糟糕（并且我希望你在未来的 React 应用中也找到同样的感觉）。
- en: There’s still at least one improvement you can make to your component. Mapbox
    also allows you to generate static images of maps based on geographic information.
    This can be useful for situations where you might not want to load an interactive
    map. You’ll add this feature as a fallback so that users can see a map right away.
    This will be useful in [chapter 12](kindle_split_024_split_000.xhtml#ch12) when
    you’ll be doing server-side rendering. The server will generate markup that won’t
    call any mounting-related methods, so users will still be able to see a location
    for posts even before the app has fully loaded.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对你的组件进行至少一项改进。Mapbox 还允许你根据地理信息生成地图的静态图像。这在某些情况下可能很有用，你可能不想加载交互式地图。你将添加这个功能作为备用，以便用户可以立即看到地图。这将在第
    12 章（[kindle_split_024_split_000.xhtml#ch12](kindle_split_024_split_000.xhtml#ch12)）中很有用，那时你将进行服务器端渲染。服务器将生成不会调用任何挂载相关方法的标记，因此即使在应用完全加载之前，用户仍然可以看到帖子中的位置。
- en: You’ll also need to add one minor bit of UI to your map component so that the
    map can display the name of its location in display-only mode. We previously mentioned
    that you’d be adding a sibling to the main elements, and that’s why you were returning
    an array of elements. This is where you’ll add this small bit of markup. The following
    listing shows how to add the image fallback and location name display to your
    component.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在你的地图组件中添加一点小的 UI，以便地图可以在仅显示模式下显示其位置名称。我们之前提到过，你将向主要元素添加一个兄弟元素，这就是为什么你返回了一个元素数组。这就是你将添加这个小标记的地方。以下列表显示了如何向你的组件添加图像备用和位置名称显示。
- en: Listing 6.6\. Adding a fallback map image (src/components/map/DisplayMap.js)
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 添加备用地图图像（src/components/map/DisplayMap.js）
- en: '[PRE48]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Bind the class method.**'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定类方法。**'
- en: '***2* Use latitude and longitude to generate an image URL from Mapbox.**'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用经纬度从 Mapbox 生成图像 URL。**'
- en: '***3* Display the location image.**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示位置图像。**'
- en: '***4* If you’re in display-only mode, show a location name and indicator.**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果你处于仅显示模式，显示位置名称和指示器。**'
- en: 6.2.2\. Creating the LocationTypeAhead component
  id: totrans-699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 创建 LocationTypeAhead 组件
- en: 'You can display maps in your app, but you’ll still can’t do anything to create
    them. You need to build another component to support that feature: a *location
    type-ahead*. In the next section, you’ll use this component in the CreatePost
    component you’ve been working with to allow users to search for locations. This
    component will use the browser Geolocation APIs as well as the Mapbox APIs to
    search for locations.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的应用中显示地图，但你仍然无法创建它们。你需要构建另一个组件来支持这个功能：一个 *位置自动完成* 组件。在下一节中，你将使用这个组件在你的
    CreatePost 组件中，以便用户可以搜索位置。这个组件将使用浏览器地理位置 API 以及 Mapbox API 来搜索位置。
- en: You can get started by creating another file, src/components/map/LocationTypeAhead.js.
    [Figure 6.2](kindle_split_017_split_002.xhtml#ch06fig02) shows the type-ahead
    component you’ll create in this section.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建另一个文件开始，src/components/map/LocationTypeAhead.js。![图 6.2](Images/06fig02_alt.jpg)展示了你将在本节中创建的自动完成组件。
- en: Figure 6.2\. A location type-ahead component you can use along with your map
    component to let the user add locations to their posts
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图 6.2](Images/06fig02_alt.jpg) 一个你可以与你的地图组件一起使用，让用户向他们的帖子添加位置的自动完成组件'
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig02_alt.jpg)'
- en: 'Here’s the basic functionality your component will have by the time it’s done:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的组件将具有以下基本功能：
- en: Display a list of locations for a user to select
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个位置列表供用户选择
- en: Yield the selected location to a parent component for use
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选定的位置传递给父组件以供使用
- en: Use the Mapbox and Geolocation APIs to let users pick their current location
    or search by address
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mapbox 和地理位置 API 允许用户选择他们的当前位置或通过地址搜索
- en: Next, you’ll get started by creating a skeleton of what your component will
    look like. [Listing 6.7](kindle_split_017_split_002.xhtml#ch06ex07) shows the
    first sketch of it. You’ll be using Mapbox again, but this time you’re using a
    different set of APIs. You used the map-display API in the last section, but here
    you’ll use the set of Mapbox APIs that let users do *reverse geocoding*, which
    is a fancy way of saying “search for a real location by text.” The Mapbox module
    is already installed with the project and will use the same public Mapbox key
    to work. If you previously added in your API key, the app configuration should
    use the same key here.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将开始创建组件的骨架，以确定其外观。[列表 6.7](kindle_split_017_split_002.xhtml#ch06ex07) 展示了它的第一个草图。你将再次使用
    Mapbox，但这次你将使用一组不同的 API。在上一个章节中，你使用了地图显示 API，但在这里你将使用一组允许用户进行 *反向地理编码* 的 Mapbox
    API，这是一种更复杂的说法，即“通过文本搜索真实位置”。Mapbox 模块已经与项目一起安装，并将使用相同的公共 Mapbox 密钥来工作。如果你之前添加了你的
    API 密钥，应用程序配置应在此处使用相同的密钥。
- en: '|  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mapbox alternatives**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mapbox 替代方案**'
- en: You’ve used Mapbox in this chapter, but there are other mapping libraries out
    there, such as Google maps. How would you go about switching out Mapbox for Google
    Maps? What would you have to do differently?
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中使用了 Mapbox，但还有其他映射库，例如 Google 地图。你将如何切换 Mapbox 为 Google 地图？你需要做哪些不同的操作？
- en: '|  |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 6.7\. The beginnings of the LocationTypeAhead component
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. LocationTypeAhead 组件的起点
- en: '[PRE49]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Import Mapbox.**'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Mapbox。**'
- en: '***2* Expose two methods, one for location update and one for location selection.**'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 暴露两个方法，一个用于位置更新，一个用于位置选择。**'
- en: '***3* Set up initial state**'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置初始状态**'
- en: '***4* Create an instance of the Mapbox client.**'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建 Mapbox 客户端实例。**'
- en: '***5* Return an array of elements that will be the markup for your type-ahead
    component. You’ll need to implement all of the methods referenced in event handlers
    (onChange, onClick, and so on).**'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回一个元素数组，这些元素将是你类型预测组件的标记。你需要实现事件处理器中引用的所有方法（onChange、onClick 等）。**'
- en: Now you can start filling out the methods you referenced in the `render` method
    of the component. Note that you want a way to handle a change in search text,
    a button that will allow you to choose a location, and an icon that’ll let the
    user pick their current location. I’ll cover that functionality next; for now,
    you need methods that will let a user search for locations using text and choose
    a location. [Listing 6.8](kindle_split_017_split_002.xhtml#ch06ex08) shows how
    to add these methods. Where are these locations going to come from? You’re going
    to use the Mapbox API to search for locations based on what the user types and
    use those results to show them addresses. This is just one way you can use Mapbox.
    You can do the opposite, too—put in coordinates and turn it into an address. You’ll
    use that feature in the next listing to work with the Geolocation API.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始填写你在组件的 `render` 方法中引用的方法。请注意，你需要一种处理搜索文本变化的方法、一个允许你选择位置按钮，以及一个允许用户选择当前位置的图标。我将在下一部分介绍该功能；现在，你需要允许用户通过文本搜索位置并选择位置的方法。[列表
    6.8](kindle_split_017_split_002.xhtml#ch06ex08) 展示了如何添加这些方法。这些位置将从哪里来？你将使用 Mapbox
    API 根据用户输入搜索位置，并使用这些结果显示地址。这是你可以使用 Mapbox 的方法之一。你也可以做相反的操作——输入坐标并将其转换为地址。你将在下一个列表中使用该功能来处理地理位置
    API。
- en: Listing 6.8\. Searching for locations (src/components/map/LocationTypeAhead.js)
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 搜索位置（src/components/map/LocationTypeAhead.js）
- en: '[PRE50]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Bind class methods.**'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定类方法。**'
- en: '***2* When the component unmounts, reset the search.**'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当组件卸载时，重置搜索。**'
- en: '***3* When a location is selected, update local component state**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当选择位置时，更新本地组件状态**'
- en: '***4* At the same time, pass location up to parent via a props callback**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 同时，通过 props 回调将位置传递给父组件**'
- en: '***5* Pull text off the event you receive when a user types into search box**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从用户在搜索框中输入时接收的事件中提取文本**'
- en: '***6* Use Mapbox client to search for locations using user’s text**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用 Mapbox 客户端通过用户的文本搜索位置**'
- en: '***7* Don’t do anything if no results**'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 如果没有结果，则不执行任何操作**'
- en: '***8* Transform Mapbox results into a format you can more easily use in your
    component.**'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 将 Mapbox 结果转换为你在组件中更容易使用的格式。**'
- en: '***9* Update state with new locations**'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 使用新位置更新状态**'
- en: '***10* Allow resetting component state (see componentWillUnmount)**'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 允许重置组件状态（见 componentWillUnmount）**'
- en: '***11* When location is selected, pass currently selected location up**'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 当位置被选中时，将当前选中位置传递上去**'
- en: Next, you want to let the user choose their current location for a post. To
    do that, you’ll use the browser Geolocation API. It’s okay if you haven’t worked
    with the Geolocation API before. For a long time it was a bleeding-edge feature,
    and you could only use it on certain browsers. Now it’s gained wide adoption and
    is more broadly useful.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要让用户选择他们用于帖子的当前位置。为此，你将使用浏览器地理位置API。即使你之前没有使用过地理位置API，这也是可以的。在很长一段时间里，它是一个前沿特性，你只能在某些浏览器上使用它。现在它已经得到了广泛的应用，并且更加有用。
- en: 'The Geolocation API does pretty much what you think it might: you can ask the
    user whether you can use their location in your app. Nearly all browsers support
    the Geolocation API at this point ([http://caniuse.com/#feat=geolocation](http://caniuse.com/#feat=geolocation)),
    so you can take advantage of it and let a user choose the current location for
    a post. Note that the Geolocation API can only be used in secure contexts, so
    if you try to deploy Letters Social to an unsecured host, it won’t work.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置API基本上做了你想象中的事情：你可以询问用户是否可以在你的应用中使用他们的位置。到目前为止，几乎所有浏览器都支持地理位置API ([http://caniuse.com/#feat=geolocation](http://caniuse.com/#feat=geolocation))，因此你可以利用它并让用户选择用于帖子的当前位置。请注意，地理位置API只能在安全上下文中使用，所以如果你尝试将
    Letters Social 部署到未加密的主机，它将无法工作。
- en: 'You’ll need to use the Mapbox API again, since all the Geolocation API gives
    you back is coordinates. Remember how you used the user’s text to search for locations
    in Mapbox? You can do the inverse: provide coordinates to Mapbox and get back
    matching addresses. The following listing shows how to use the Geolocation and
    Mapbox APIs to let the user choose their current location for a post.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要再次使用 Mapbox API，因为地理位置API返回的只是坐标。记得你是如何使用用户的文本在 Mapbox 中搜索位置的？你可以做相反的事情：向
    Mapbox 提供坐标，并获取匹配的地址。下面的列表显示了如何使用地理位置和 Mapbox API 让用户选择他们用于帖子的当前位置。
- en: Listing 6.9\. Adding Geolocation (src/components/map/LocationTypeAhead.js)
  id: totrans-737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 添加地理位置（src/components/map/LocationTypeAhead.js）
- en: '[PRE51]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Bind class method**'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定类方法**'
- en: '***2* Check to see if browser supports geolocation**'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查浏览器是否支持地理位置**'
- en: '***3* Get current position of user’s device**'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取用户设备的当前位置**'
- en: '***4* This will yield back coordinates that you can use.**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这将返回你可以使用的坐标。**'
- en: '***5* Use Mapbox to geocode the coordinates and return early if nothing is
    found.**'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 Mapbox 对坐标进行地理编码，如果未找到任何内容则提前返回。**'
- en: '***6* Get first (closest) feature to use**'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 获取第一个（最近的）特征来使用**'
- en: '***7* Pull out latitude and longitude**'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 提取纬度和经度**'
- en: '***8* Create location payload to use and update component state with it**'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 创建用于的定位有效载荷并使用它来更新组件状态**'
- en: '***9* Call the handleLocationUpdate prop with new location**'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 调用带有新位置的 handleLocationUpdate 属性**'
- en: '***10* Options to pass to Geolocation API**'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 传递给地理位置API的选项**'
- en: Your component can search Mapbox for locations and let the user pick their own
    location via the Geolocation API. But it’s not showing anything to the user yet,
    so you’ll fix that next. You’re going to need to use the location results so the
    user can click to select one, as shown in the following listing.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组件可以搜索 Mapbox 中的位置，并让用户通过地理位置API选择自己的位置。但是目前还没有向用户显示任何内容，所以你将解决这个问题。你需要使用位置结果，以便用户可以点击选择一个，如下面的列表所示。
- en: Listing 6.10\. Displaying results to the user (src/components/map/LocationTypeAhead.js)
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 向用户显示结果（src/components/map/LocationTypeAhead.js）
- en: '[PRE52]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* If there’s a search query and you have matching results, show results.**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果有搜索查询并且你有匹配的结果，则显示结果。**'
- en: '***2* Map over locations you got back from Mapbox.**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历从 Mapbox 返回的位置。**'
- en: '***3* If user clicks a location, set that to selected location**'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果用户点击位置，将其设置为选中位置**'
- en: '***4* Don’t forget to key components you’re iterating over.**'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不要忘记为迭代的组件设置键。**'
- en: '***5* Display location name**'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示位置名称**'
- en: '***6* If there aren’t locations and a search query, don’t do anything.**'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果没有位置和搜索查询，则不执行任何操作。**'
- en: 6.2.3\. Updating CreatePost and adding maps to posts
  id: totrans-758
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 更新 CreatePost 并在帖子中添加地图
- en: Now that you’ve created the LocationTypeAhead and DisplayMap components, you
    can integrate these into the CreatePost component you’ve been working with. This
    will tie together the functionality you’ve created and allow the user to create
    posts that have a location. Remember how the CreatePost component passes its data
    back up to a parent component to do the actual post creation? You’ll do the same
    thing with the type-ahead and DisplayMap components, but from the CreatePost.
    They’ll work together but not be so tied to each other that you can’t move them
    around or use them elsewhere.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了 LocationTypeAhead 和 DisplayMap 组件，可以将这些组件集成到您一直在工作的 CreatePost 组件中。这将结合您创建的功能，并允许用户创建带有位置的文章。还记得
    CreatePost 组件如何将数据传递回父组件以执行实际的文章创建吗？您将与 type-ahead 和 DisplayMap 组件做同样的事情，但它们将来自
    CreatePost。它们将协同工作，但不会如此紧密地绑定在一起，以至于您不能移动它们或在其他地方使用它们。
- en: You need to update your CreatePost component to work with the LocationTypeAhead
    and DisplayMap components you created earlier—which, remember, yield and receive
    a location, respectively. You’ll keep track of a location in the CreatePost component
    and use the two components you recently created as a source and destination of
    the location data. The following listing shows how to add the methods you’ll need
    to add locations to posts.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新 CreatePost 组件以与您之前创建的 LocationTypeAhead 和 DisplayMap 组件一起工作——记住，它们分别产生和接收位置。您将在
    CreatePost 组件中跟踪位置，并使用您最近创建的两个组件作为位置数据源和目的地。以下列表显示了如何添加您需要添加到文章中的方法。
- en: Listing 6.11\. Handling locations in CreatePost (src/components/post/Create.js)
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 在 CreatePost 中处理位置（src/components/post/Create.js）
- en: '[PRE53]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Add keys to state so you can keep track of location and related data;
    set up some default location data**'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为状态添加键，以便您可以跟踪位置和相关数据；设置一些默认位置数据**'
- en: '***2* Bind class methods**'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 绑定类方法**'
- en: '***3* Allow user to remove location from their post**'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 允许用户从他们的文章中删除位置**'
- en: '***4* When submitting a post, add location to payload if present**'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 提交文章时，如果存在，则将位置添加到有效负载中**'
- en: '***5* Handle a location update from the LocationTypeAhead component.**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 处理来自 LocationTypeAhead 组件的位置更新。**'
- en: '***6* Toggle showing the location picker**'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 切换显示位置选择器**'
- en: The CreatePost component can now work with locations, so you need to add in
    the UI to make it happen. Once you add in the associated UI for adding a location,
    you’ll find that the `render` method has become a little cluttered. This isn’t
    necessarily a bad thing, and the markup isn’t so complicated that you have to
    refactor anything (I’ve worked with `render` methods that are hundreds of lines
    long), but it’s a good opportunity to explore a different technique for rendering
    in React component—which I call *subrendering*.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: CreatePost 组件现在可以与位置一起工作，因此您需要添加 UI 来实现这一功能。一旦添加了添加位置的关联 UI，您会发现 `render` 方法变得有些杂乱。这并不一定是一件坏事，标记并不是那么复杂，以至于您需要重构任何东西（我处理过数百行长的
    `render` 方法），但这是一个探索 React 组件不同渲染技术的良好机会——我称之为 *子渲染*。
- en: '|  |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using refs elsewhere**'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**在其他地方使用 refs**'
- en: We’ve spent some time exploring how to use refs in React in this chapter. Can
    you think of other libraries or situations where refs might come in handy? Have
    you worked on any projects in the past that might require using refs to be integrated
    with React?
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经花了一些时间探讨如何在 React 中使用 refs。您能想到其他库或情况，其中 refs 可能会很有用吗？您在过去的项目中是否使用过
    refs 来与 React 集成？
- en: '|  |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A *subrender* method involves breaking part of your `render` method into a class
    method on the component (or a function anywhere, really) and then invoking that
    within a JSX expression in the main `render` method. You can use this technique
    if you need to break up a larger `render` method, need to isolate the logic for
    a particular part of the rendered UI, or for other reasons. You’ll probably find
    other cases where it’s useful, but the key takeaway is that you can break up your
    render into multiple parts that don’t have to be other components. The following
    listing illustrates breaking up a `render` method into smaller parts.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '*子渲染* 方法涉及将您的 `render` 方法的一部分拆分到组件（或任何地方的函数）上的类方法中，然后在主 `render` 方法中的 JSX 表达式中调用它。如果您需要拆分较大的
    `render` 方法，需要隔离渲染 UI 的特定部分的逻辑，或出于其他原因，可以使用此技术。您可能会发现其他有用的情况，但关键要点是您可以拆分渲染为多个部分，这些部分不必是其他组件。以下列表说明了如何将
    `render` 方法拆分为更小的部分。'
- en: Listing 6.12\. Adding a subrender method (src/components/post/Create.js)
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 在组件中添加子渲染方法（src/components/post/Create.js）
- en: '[PRE54]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Bind class method in constructor**'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在构造函数中绑定类方法**'
- en: '***2* If a location is selected, show button that allows users to remove their
    location**'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果选择了位置，则显示允许用户移除其位置的按钮**'
- en: '***3* Bind removeLocation method and display current location**'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 绑定移除位置方法并显示当前位置**'
- en: '***4* Show button that will toggle location picker components**'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示将切换位置选择器组件的按钮**'
- en: '***5* Show right text and use right bound method based on location state**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 根据位置状态显示正确文本并使用正确边界方法**'
- en: '***6* Invoke subrender method**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 调用子渲染方法**'
- en: '***7* Show or hide location picker components depending on state**'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 根据状态显示或隐藏位置选择器组件**'
- en: '***8* Show location picker components if a location isn’t selected**'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果未选择位置，则显示位置选择器组件**'
- en: Finally, you need to add the maps to posts that have locations on them. You’ve
    already done the work of building out the DisplayMap component and making sure
    it can work in display-only mode, so all you need to do is include it in the Post
    component. The following listing shows how to do that.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将地图添加到具有位置的帖子中。你已经完成了构建 DisplayMap 组件并确保它可以在仅显示模式下工作的工作，所以你只需要将其包含在 Post
    组件中。以下列表显示了如何做到这一点。
- en: Listing 6.13\. Adding maps to your posts (src/components/post/Post.js)
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. 在帖子中添加地图（src/components/post/Post.js）
- en: '[PRE55]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Import the DisplayMap component for use.**'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 DisplayMap 组件以供使用。**'
- en: '***2* If post has location associated with it, show it and turn on displayOnly
    mode**'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果帖子与位置相关联，则显示它并打开 displayOnly 模式**'
- en: With that, you’ve added the ability to add and display locations on posts for
    your users. Your investors will surely be happy and impressed by such a game-changing
    feature!
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你为用户添加了在帖子中添加和显示位置的功能。你的投资者们一定会因为这样一个改变游戏规则的功能而感到高兴和印象深刻！
- en: Figure 6.3\. The final product of your work in this chapter. You users can create
    posts and add locations to them.
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 本章工作的最终产品。你的用户可以创建帖子并将位置添加到它们中。
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig03_alt.jpg)'
- en: 6.3\. Summary
  id: totrans-793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 摘要
- en: 'Here’s what you learned in this chapter:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你学到了以下内容：
- en: In React, a *ref* is a reference to an underlying DOM element. Refs can be useful
    when you need an escape hatch and need to work with libraries that work with the
    DOM outside of React.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中，*ref* 是对底层 DOM 元素的引用。当你需要一个逃生舱并需要与在 React 之外与 DOM 一起工作的库一起工作时，refs
    非常有用。
- en: Components can be controlled or uncontrolled. *Controlled* components give you
    full control over the state of the component and involve a complete cycle of listening
    for and then setting an input’s value. *Uncontrolled* components maintain their
    own state internally and don’t provide insight or control.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可以是受控的或不受控的。*受控*组件让你完全控制组件的状态，并涉及一个完整的周期，即监听并设置输入值。*不受控*组件在内部维护自己的状态，不提供洞察或控制。
- en: Integrating React components with third-party libraries that also use the DOM
    is often possible through the use of refs. Refs can act as escape hatches when
    you need to reach out and interact with DOM elements.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 refs，通常可以将 React 组件与也使用 DOM 的第三方库集成。当你需要接触并交互 DOM 元素时，refs 可以作为逃生舱。
- en: In the next chapter, you’ll start to add complexity to and create basic routing
    for your app so you have the possibility of multiple pages.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始为你的应用程序添加复杂性并创建基本路由，以便你有多个页面的可能性。
- en: Chapter 7\. Routing in React
  id: totrans-799
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. React 中的路由
- en: '*This chapter covers*'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: More advanced component design and use
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的组件设计和使用
- en: Enabling multi-page React applications with routing
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用具有路由的多页 React 应用程序
- en: Building a router from scratch with React
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 从零开始构建路由器
- en: In this chapter, you’re going to start making your app more robust and scalable
    by adding routing. *Routing* means users will be able to navigate to different
    sections of the app using URLs. The app has been limited to only one page until
    now, which would hamper growth when you add sections to it. Larger applications
    would especially suffer from overcrowding without routing or another mechanism
    to give the app manageable hierarchy. We’ll see how to solve this problem for
    your application using React. You’ll build a simple router from scratch in order
    to better understand how you can do routing with React applications.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过添加路由来开始使你的应用更加健壮和可扩展。*路由*意味着用户将能够通过URL导航到应用的不同部分。到目前为止，应用仅限于一个页面，当你添加部分时，这会阻碍其增长。没有路由或其他机制来提供可管理的层次结构，大型应用会特别受拥挤的影响。我们将看到如何使用React为你的应用解决这个问题。你将从头开始构建一个简单的路由器，以便更好地理解你如何使用React应用进行路由。
- en: '|  |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**How do I get the code for this chapter?**'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapters 5](kindle_split_016_split_000.xhtml#ch05)
    and [6](kindle_split_017_split_000.xhtml#ch06) (if you followed along and built
    out the examples yourself) or check out the chapter-specific branch (chapter-7-8).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以通过访问GitHub仓库[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)来获取本章的源代码。如果你想从一张白纸开始学习本章，并跟随操作，你可以使用[第5章](kindle_split_016_split_000.xhtml#ch05)和[第6章](kindle_split_017_split_000.xhtml#ch06)（如果你跟随并自己构建了示例）中的现有代码，或者检出特定章节的分支（chapter-7-8）。
- en: Remember, each branch corresponds to the code at the end of the chapter (for
    example, the branch chapter-7-8 corresponds to the code as it will be at the end
    of these chapters). You can execute one of the following terminal commands in
    the directory of your choice to get the code for the current chapter.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应于章节末尾的代码（例如，分支chapter-7-8对应于这些章节末尾的代码）。你可以在你选择的目录中执行以下终端命令之一来获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本就没有仓库，请输入以下命令：
- en: '[PRE56]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you already have the repository cloned:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库：
- en: '[PRE57]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能是从另一章来到这里的，所以确保你已经安装了所有正确的依赖项总是一个好主意：
- en: '[PRE58]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.1\. What is routing?
  id: totrans-816
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 什么是路由？
- en: To really get into routing, we first have to have some idea of what it is. Routing
    is a key part of all websites and web applications in one way or another. It plays
    a central role in the simplest static HTML pages and the most complex React web
    applications. Routing comes into play pretty much anytime you want to map a URL
    to an action. Most applications are chock full of URL links because links are
    the de facto way of moving around on the web. Think about how effective a system
    for finding something a URL has become—they’re in use almost everywhere. Why are
    they so useful for finding things on the web? Maybe because we’re used to routing
    systems like addresses, and even though URLs don’t require turn-by-turn directions,
    they help us find what we’re looking for—in this case, apps or resources instead
    of locations.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正了解路由，我们首先必须对它有一个概念。路由以某种方式是所有网站和Web应用的基石。它在最简单的静态HTML页面和最复杂的React Web应用中都扮演着核心角色。几乎在任何你想将URL映射到操作的时候，路由都会发挥作用。大多数应用都充满了URL链接，因为链接是网上移动的既定方式。想想看，一个用于查找东西的系统——URL已经变得多么有效——它们几乎无处不在。为什么它们在网络上查找东西时如此有用？可能是因为我们习惯了像地址这样的路由系统，即使URL不需要逐个方向指示，它们也帮助我们找到我们想要的东西——在这种情况下，是应用或资源而不是位置。
- en: '|  |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Routing* can have many different meanings and implementations. For our purposes,
    it’s a system for resource navigation. In the abstract, routing is probably a
    familiar idea to you and is common in web engineering. If you’re working in the
    browser, you’re familiar with routing as it relates to URLs and resources in the
    browser (paths to images, scripts, and so on). On the server, routing can be a
    focus on matching incoming request paths (like [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem))
    to resources from a database. You’re learning how to use React, so routing in
    this book will usually mean matching components (the resources people want) to
    a URL (the way of telling the system what they want).'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由*可以有多个不同的含义和实现。就我们的目的而言，它是一个资源导航系统。在抽象层面，路由可能是一个您熟悉的概念，在Web工程中很常见。如果您在浏览器中工作，您熟悉与URL和浏览器中的资源（图像、脚本等的路径）相关的路由。在服务器上，路由可以专注于匹配传入请求路径（如[https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem)）到数据库中的资源。您正在学习如何使用React，因此本书中的路由通常意味着将组件（人们想要的资源）与URL（告诉系统他们想要的方式）匹配。'
- en: '|  |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Routing is an important part of web applications. Say you want to build a web
    app where users can create custom fundraising pages to raise money for causes
    that are important to them. In that case, you’ll need routing for quite a few
    reasons:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是Web应用的重要组成部分。比如说，您想要构建一个Web应用，让用户可以创建自定义筹款页面来为对他们重要的原因筹集资金。在这种情况下，您将需要路由，出于以下几个原因：
- en: In general, so people can provide external links to your web app. URLs leading
    to permanent resources should be long-lasting and keep a consistent structure
    over time.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，这样人们才能提供指向您的Web应用的链接。指向永久资源的URL应该是持久且随时间保持一致结构的。
- en: Public fundraising pages need to be reliably accessible to everyone, so you
    need a URL that will route them to the right page.
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共筹款页面需要可靠地供每个人访问，因此您需要一个将它们引导到正确页面的URL。
- en: Different parts of the admin interface will require it. Users need to be able
    to move forward and backward in their browsing history.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理界面的不同部分将需要它。用户需要能够在其浏览历史中前后移动。
- en: Different parts of your site will need their own URLs so you can easily route
    people to the right section (for example, /settings, /profile, /pricing, and so
    on).
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您网站的不同部分将需要它们自己的URL，这样您就可以轻松地将人们引导到正确的部分（例如，/settings、/profile、/pricing等等）。
- en: Breaking up your code by page helps promote modularity, so you can break up
    your app as well. Along with dynamic content, that can in turn reduce the size
    of the app that has to be loaded at a given point.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过页面分割代码有助于提高模块化，因此您也可以将应用分割开来。结合动态内容，这反过来可以减少在特定点必须加载的应用的大小。
- en: 7.1.1\. Routing in modern front-end web applications
  id: totrans-828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1. 现代前端Web应用中的路由
- en: In the past, the basic architecture of a web application involved a different
    approach to routing than the modern way. The older approach involved the server
    (think something created in Python, Ruby, or, PHP) generating HTML markup and
    sending it down to the browser. A user might fill out a form with some data, send
    it back up to the server, and wait for a response. This was revolutionary in making
    the web more powerful because you could modify data instead of only viewing it.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，Web应用的基本架构涉及的路由方法与现代方式不同。较老的方法涉及服务器（比如用Python、Ruby或PHP创建的东西）生成HTML标记并发送到浏览器。用户可能会填写一个包含一些数据的表单，将其发送回服务器，并等待响应。这在使网络更强大方面是革命性的，因为您可以修改数据而不是仅仅查看它。
- en: Since then, web services have undergone many developments in design and construction.
    Nowadays, JavaScript frameworks and browser technology are advanced enough that
    web applications can have a more distinct client-server split. The client app
    (all in-browser) is sent down by the server and then effectively “takes over.”
    The server is then responsible for sending down raw data, usually in the form
    of JSON. [Figure 7.1](kindle_split_018_split_001.xhtml#ch07fig01) illustrates
    and compares how these two generic architectures work.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，Web服务在设计和管理方面经历了许多发展。如今，JavaScript框架和浏览器技术已经足够先进，Web应用可以实现更明显的客户端-服务器分离。客户端应用（全部在浏览器中）由服务器发送，然后有效地“接管”。服务器随后负责发送原始数据，通常是JSON形式。图7.1[Figure
    7.1](kindle_split_018_split_001.xhtml#ch07fig01)展示了并比较了这两种通用架构的工作方式。
- en: Figure 7.1\. Comparing slightly older and modern web application architectures.
    In the old way, dynamic content would be generated on the server. The server would
    usually fetch data from a database and use it to populate an HTML view that would
    be sent down to the client. Now there is more application logic on the client
    that gets managed by JavaScript (in this case, React). The server initially sends
    down the HTML, JavaScript, and CSS assets, but after that, the client React app
    takes over. From there, unless a user manually refreshes the page, the server
    will only have to send down raw JSON data.
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 比较稍微旧一些和现代的 Web 应用程序架构。在旧的方式中，动态内容会在服务器上生成。服务器通常会从数据库中获取数据，并使用它来填充一个将被发送到客户端的
    HTML 视图。现在，客户端有更多的应用程序逻辑，由 JavaScript（在这种情况下，是 React）管理。服务器最初发送 HTML、JavaScript
    和 CSS 资产，但之后，客户端 React 应用程序接管。从那时起，除非用户手动刷新页面，否则服务器只需发送原始 JSON 数据。
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-832
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: 'So far, you’ve been using a modern architecture to build the learning app,
    Letters Social. A node.js server sends down the HTML, JavaScript, and CSS that
    you need for your app. Once that’s loaded, though, React takes over. Further requests
    for data are sent to the sample API server. But you’re missing a key part of that
    architecture: client-side routing.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用现代架构来构建学习应用程序 Letters Social。一个 node.js 服务器发送你应用程序所需的 HTML、JavaScript
    和 CSS。一旦加载，React 就接管了。进一步的数据请求被发送到示例 API 服务器。但你缺少架构中的一个关键部分：客户端路由。
- en: '|  |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Ruminating on routing**'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于路由的沉思**'
- en: Take a second to reflect on routing before we dive deeper into building your
    router with React. What are some other examples of routing you’ve encountered
    in past projects? What are some other uses for routing?
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入构建你的 React 路由器之前，花点时间思考一下路由。你在过去的项目中遇到过哪些其他的路由示例？路由还有哪些其他用途？
- en: '|  |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2\. Creating a router
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 创建路由器
- en: 'You’ll build a simple router from scratch using components in order to better
    understand how you can do routing with React applications. Here’s how you’ll proceed
    at a high level:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从头开始使用组件构建一个简单的路由器，以便更好地理解你如何使用 React 应用程序进行路由。以下是你将采取的步骤概述：
- en: You’ll create two components, Router and Route, that will be used together to
    accomplish client-side routing.
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将创建两个组件，Router 和 Route，它们将一起使用以实现客户端路由。
- en: The Router component will be comprised of Route components.
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由组件将由路由组件组成。
- en: Each Route will represent a URL path (/, /posts/123) and map a component to
    that URL. When your users visit /, they’ll see a component for that.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个路由将代表一个 URL 路径（/、/posts/123）并将组件映射到该 URL。当你的用户访问 / 时，他们将看到一个对应的组件。
- en: The Router component will look like a normal React component (it’ll have a `render`
    method and component methods and use JSX) but will let you map components to URLs.
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由组件将看起来像一个正常的 React 组件（它将有一个 `render` 方法、组件方法和使用 JSX），但它将允许你将组件映射到 URL。
- en: The Route components can specify parameters like `/users/:user`, where the `:user`
    syntax will denote a value passed to the component.
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由组件可以指定参数，如 `/users/:user`，其中 `:user` 语法将表示传递给组件的值。
- en: You’ll also create a Link component that will enable navigation with your client-side
    router.
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还将创建一个链接组件，它将使你能够使用客户端路由器进行导航。
- en: If that doesn’t all make perfect sense yet, don’t worry. We’ll work through
    each step in turn. Let’s look at an example of what you’ll be working towards
    as you build the router.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些内容还没有完全理解，请不要担心。我们将逐一处理每个步骤。让我们看看你构建路由时将努力实现的一个示例。
- en: '[Listing 7.1](kindle_split_018_split_002.xhtml#ch07ex01) shows the Router component
    you’ll build being used in its final form. It’s easy to read through and think
    about: you have a router with routes that are tied to a component. Routing doesn’t
    necessarily have to be hierarchical—you could create chaos and arbitrarily nest
    resources—but often is. That means it can map relatively easily to React’s composition
    semantics. If you were starting React for the absolute first time, a routing example
    like the one in the following listing might be one of the easiest components to
    understand right away.'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.1](kindle_split_018_split_002.xhtml#ch07ex01) 展示了你将构建的路由组件在其最终形式下的使用情况。阅读起来很容易，你可以思考一下：你有一个带有与组件相关联的路由的路由器。路由不一定是分层的——你可以创建混乱并任意嵌套资源——但通常是这样的。这意味着它可以相对容易地映射到
    React 的组合语义。如果你是第一次开始学习 React，那么下面列表中的路由示例可能是你能够立即理解的最容易的组件之一。'
- en: Listing 7.1\. Router end result (src/index.js)
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 路由最终结果（src/index.js）
- en: '[PRE59]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Router component handles storing routes and returning the proper component
    for use in rendering**'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 路由器组件负责存储路由并返回用于渲染的正确组件**'
- en: '***2* Each Route component receives a path and a component and matches them
    together, and you can nest several components within each other.**'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个路由组件接收一个路径和一个组件，并将它们匹配起来，您可以在它们内部嵌套多个组件。**'
- en: '***3* You can pass in parameters to component paths that represent dynamic
    values, meaning you can get data back from your routes and use it in components.**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 您可以向组件路径传递参数，这些参数代表动态值，这意味着您可以从路由中获取数据并将其用于组件。**'
- en: This sort of router structure is easy to read and think about. It’s also fairly
    well established in React applications, thanks to `React Router`. You’ll follow
    suit and build your router with the same basic API in mind. As you do that, we’ll
    draw inspiration and take direction from a small, lightweight router library created
    by TJ Holowaychuk, called `react-enroute`. With this library you can explore routing
    in React without having to re-create an entire open source library like `React
    Router`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这种路由结构易于阅读和思考。由于 `React Router` 的存在，它在 React 应用程序中也非常成熟。您将遵循同样的基本 API 来构建您的路由器。在这个过程中，我们将从由
    TJ Holowaychuk 创建的一个小型、轻量级路由库中汲取灵感，这个库叫做 `react-enroute`。使用这个库，您可以在 React 中探索路由，而无需重新创建像
    `React Router` 这样的整个开源库。
- en: We know some more about what you’ll be building and how it should look in use,
    but where do we start? We start with children.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对您将要构建的内容以及它在使用中的样子有更多的了解，但我们应该从哪里开始呢？我们从 `children` 开始。
- en: 7.2.1\. Component routing
  id: totrans-855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 组件路由
- en: No, you won’t be enlisting youngsters to implement routing in your app. Instead,
    you’ll be using the special component prop `children`. You may remember the `children`
    prop from past chapters, where it was part of the signature for `React.createElement(type,
    props, children)` or as the special prop with which you can compose components.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 不，您不会招募年轻人来实现您应用程序中的路由。相反，您将使用特殊的组件属性 `children`。您可能还记得 `children` 属性，在之前的章节中，它是
    `React.createElement(type, props, children)` 签名的一部分，或者作为可以组合组件的特殊属性。
- en: 'Before, you only cared about children from an input perspective: you would
    pass in components to another component to compose them together. Now you’re going
    to access children from within a component and use components themselves to set
    up your routes. This is where you can start to do the work of mapping components
    to URLs. If routing in web development is the mapping of URLs to behaviors or
    views, then routing in React is the mapping of URLs to particular components.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，您只从输入的角度关心 `children`：您会将组件传递给另一个组件以组合它们。现在，您将从一个组件内部访问 `children` 并使用组件本身来设置您的路由。这就是您开始将组件映射到
    URL 的工作的地方。如果网络开发中的路由是将 URL 映射到行为或视图，那么 React 中的路由就是将 URL 映射到特定组件。
- en: 7.2.2\. Creating the <Route /> component
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 创建 <Route /> 组件
- en: You’re going to create a Router component that will use child components to
    match URL routes to components and render them out. If you’re having a hard time
    thinking about what this will look like, remember that we’ll go through each step
    deliberately, and you don’t have to fully get everything from the start.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建一个路由器组件，它将使用子组件将 URL 路由与组件匹配并渲染它们。如果您在思考这将是什么样子时遇到困难，请记住，我们将有意识地逐步进行，您不需要一开始就完全理解所有内容。
- en: '[Listing 7.2](kindle_split_018_split_002.xhtml#ch07ex02) showed two types of
    components: Router and Route. Let’s start with the Route components, which you
    can use to associate components with routes. [Listing 7.2](kindle_split_018_split_002.xhtml#ch07ex02)
    shows how to create the Route component. There may not appear to be much to it,
    but as you’ll see shortly, that’s fine. The Router component will do most of the
    heavy lifting, whereas the Route component will serve mainly as a data container
    for your mappings of URLs and components.'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.2](kindle_split_018_split_002.xhtml#ch07ex02) 展示了两种组件类型：路由器（Router）和路由（Route）。让我们从路由组件开始，您可以使用它来将组件与路由关联起来。[列表
    7.2](kindle_split_018_split_002.xhtml#ch07ex02) 展示了如何创建路由组件。它看起来可能没有太多内容，但正如您很快就会看到的，这是可以的。路由器组件将承担大部分繁重的工作，而路由组件将主要作为您对
    URL 和组件映射的数据容器。'
- en: Listing 7.2\. Creating a Route component (src/components/router/Route.js)
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 创建路由组件（src/components/router/Route.js）
- en: '[PRE60]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Bring in invariant library so you can ensure that the Route component
    never gets rendered, or if it does, you’ll throw an error**'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 引入 invariant 库以确保路由组件永远不会被渲染，或者如果它被渲染了，您将抛出一个错误**'
- en: '***2* Each Route takes a path and a function, so specify these props using
    PropTypes.**'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个路由都包含一个路径和一个函数，因此请使用 PropTypes 指定这些属性。**'
- en: '***3* The entire Route component is just a function that returns a call to
    the invariant library—if ever called, error is thrown and you’ll know things aren’t
    behaving correctly**'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 整个路由组件只是一个返回 invariant 库调用的函数——如果被调用，将抛出错误，你知道事情没有按正确的方式运行**'
- en: '***4* Use a named export to make component available to outside modules**'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用命名导出使组件对外部模块可用**'
- en: You probably noticed that you’re importing a new library here, called `invariant`.
    This is a simple tool you’ll use to ensure that errors get thrown if certain conditions
    aren’t met. To use it, you pass in a value and a message. If that value is *falsey*
    (`null`, `0`, `undefined`, `NaN`, `''`(empty string), or `false`), it will throw
    an error. The `invariant` library is often used in React, so if you ever see a
    warning or error message in the developer tools console that says something like
    “invariant violation,” it’s probably involved. You’ll use it here to make sure
    the Route component doesn’t render anything.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这里导入了一个新的库，名为 `invariant`。这是一个简单的工具，你将用它来确保在特定条件不满足时抛出错误。要使用它，你需要传入一个值和一个消息。如果该值是
    *falsey* (`null`、`0`、`undefined`、`NaN`、`''`(空字符串) 或 `false`)，它将抛出错误。`invariant`
    库在 React 中经常被使用，所以如果你在开发者工具控制台中看到类似“invariant violation”的警告或错误消息，那么它可能就是相关的。你将在这里使用它来确保路由组件不会渲染任何内容。
- en: That’s right—the Route component won’t render anything. If it does, the `invariant`
    tool will throw an error. That might sound like a weird thing to do at first.
    After all, you’ve been doing lots of rendering in your components so far. But
    it’s just a way of grouping routes and components together in a way that React
    can understand and that you can take advantage of. You’ll use the Route components
    to store props and pass in the children you want. This will become clearer as
    you build out your Router component, but take a look at [figure 7.2](kindle_split_018_split_002.xhtml#ch07fig02)
    before moving on to check your understanding.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此——路由组件不会渲染任何内容。如果它确实渲染了，`invariant` 工具将抛出错误。一开始这可能听起来有些奇怪。毕竟，到目前为止，你已经在组件中做了很多渲染。但这只是将路由和组件分组在一起的一种方式，React
    可以理解，你也可以利用这种方式。你将使用路由组件来存储属性并传递你想要的子组件。随着你构建路由器组件，这将会变得更加清晰，但在继续之前，请先查看[图 7.2](kindle_split_018_split_002.xhtml#ch07fig02)
    以检查你的理解。
- en: 'Figure 7.2\. Overview of how Route and Router components will work. The Router,
    which you’ll build in the next section, has Route components as its children.
    Each of these components uses two props: a `path` string and a component. The
    `<Router/>` will use each `<Route/>` to match a URL and render the right component.
    Because everything is a React component, you can pass in props to your router
    when rendering and use those as the initial application state for top-level data
    like user, authentication state, and more.'
  id: totrans-869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 路由和路由组件将如何工作的概述。路由器（你将在下一节中构建），其子组件是路由组件。这些组件中的每一个都使用两个属性：一个 `path`
    字符串和一个组件。`<Router/>` 将使用每个 `<Route/>` 来匹配 URL 并渲染正确的组件。因为一切都是 React 组件，你可以在渲染时传递属性给路由器，并使用这些属性作为顶级数据（如用户、认证状态等）的初始应用程序状态。
- en: '![](Images/07fig02_alt.jpg)'
  id: totrans-870
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig02_alt.jpg)'
- en: 7.2.3\. Starting to build the <Router/> component
  id: totrans-871
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 开始构建 <Router/> 组件
- en: To get started working on the Router, you’ll need to go through the basics of
    creating a component again. This should be familiar by now, although you’ll eventually
    build a component that does some unique things you haven’t seen so far. The good
    news is that you don’t have to do anything “magic” to create your router. You’re
    going to be working with React components, adding some logic to the Router component,
    and then using it as the main component that your app renders.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建路由器，你需要再次通过创建组件的基础知识。现在这应该很熟悉了，尽管你最终将构建一个做一些你之前没有见过的独特事情的组件。好消息是，你不需要做任何“魔法”来创建你的路由器。你将使用
    React 组件，向路由器组件添加一些逻辑，然后将其用作你的应用程序渲染的主要组件。
- en: This might not seem like a big deal. You may be thinking, “Okay, so it’s a component.
    This is React, after all, so that seems...normal?” I’m pointing it out because
    it’s a good example of something powerful and flexible that you can do with “just”
    React that isn’t something you might immediately think of doing. You don’t need
    any brand-new tools. You just need to find a way to record a mapping of URLs and
    components and then a way to interact with the right browser APIs. Now you can
    get to building this thing.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是什么大问题。你可能正在想，“好吧，那是一个组件。毕竟这是React，所以这似乎...很正常？”我指出这一点是因为它是一个很好的例子，展示了你可以用“仅仅”React做到的强大而灵活的事情，而这些事情你可能不会立即想到去做。你不需要任何全新的工具。你只需要找到一种方法来记录URL和组件的映射，然后找到一种方法与正确的浏览器API交互。现在你可以开始构建这个事物了。
- en: '|  |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What about React Router?**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于React Router呢？**'
- en: You might have heard of `React Router` before if you’ve worked with React at
    all. It’s one of the most popular React projects in open source and is by far
    the most popular routing solution for React applications. You may wonder why you
    don’t just install `React Router` and learn how to use that API. You could do
    that, but I think you’d miss out on the chance to see how you can do things with
    React components that you might not expect (such as mapping URLs to components!).
    You’ll learn far more from building something yourself than you will by simply
    installing something with npm.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过React，你可能听说过`React Router`。它是开源中最受欢迎的React项目之一，也是React应用程序中最受欢迎的路由解决方案。你可能想知道为什么你不直接安装`React
    Router`并学习如何使用该API。你可以这样做，但我认为你会错过看到你可以如何使用React组件做一些你可能不会想到的事情的机会（比如将URL映射到组件！）。通过自己构建一些东西，你将学到比简单地使用npm安装东西多得多的东西。
- en: Now, this is different from what you would probably do if you were in a business
    situation or any kind of production environment. As helpful as building your own
    router from scratch might be, your primary role as an engineer is (almost always)
    to deliver value to the company, and you can do that most effectively by either
    building or using tools that are well tested, performant, and easy to work with.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这与你在商业环境或任何生产环境中可能做的事情不同。尽管从头开始自己构建路由器可能很有帮助，但作为工程师，你的主要角色（几乎总是）是为公司创造价值，而你可以通过构建或使用经过良好测试、性能良好且易于工作的工具来实现这一点。
- en: With that in mind, you and your team would probably choose to use `React Router`
    instead of building your own. It’s often a better engineering and business decision
    to choose a well-maintained, popular, open source library that fits your needs.
    When we discuss server-side rendering in [chapter 12](kindle_split_024_split_000.xhtml#ch12),
    you’ll swap out your router for `React Router` so we can take advantage of some
    its features.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你和你的团队可能会选择使用`React Router`而不是自己构建。选择一个维护良好、受欢迎的开源库来满足你的需求，通常是一个更好的工程和商业决策。当我们讨论第12章中的服务器端渲染时，你会用`React
    Router`替换你的路由器，这样我们可以利用它的一些特性。
- en: '|  |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Listing 7.3](kindle_split_018_split_002.xhtml#ch07ex03) shows how to scaffold
    out the Router component. There’s little out of the ordinary here aside from the
    `routes` property that gets set up on the component. Notice that because you don’t
    want to do anything to change the routes on the fly, you’re not storing the routes
    in React’s local component state. There may be some cases where you’d want to
    dynamically change the routes at runtime, such as a user actively customizing
    the app or something similar. In those cases, you could use the component’s `state`
    interface. You don’t have that need here, so you’ll stick the routes on the component.'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.3](kindle_split_018_split_002.xhtml#ch07ex03)展示了如何构建路由器组件。这里除了在组件上设置的`routes`属性之外，没有太多不寻常的地方。注意，因为你不想在运行时对路由做任何更改，所以你不会在React的本地组件状态中存储路由。可能有一些情况，你希望在运行时动态更改路由，比如用户正在积极自定义应用程序或类似的事情。在这些情况下，你可以使用组件的`state`接口。这里你没有这样的需求，所以你将路由放在组件上。'
- en: Listing 7.3\. Scaffolding out the Router (src/components/router/Router.js)
  id: totrans-881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 构建路由器（src/components/router/Router.js）
- en: '[PRE61]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* The Router component will have a render() method.**'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 路由组件将有一个render()方法。**'
- en: '***2* You’ll store the routes on the router component in an object.**'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你将在路由组件中存储路由到一个对象中。**'
- en: '***3* Specify PropTypes—the router will receive children and a location to
    work with.**'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 指定PropTypes——路由器将接收子组件和一个位置来工作。**'
- en: Now that you have the bare bones of your Router component, you can start adding
    some utilities that you’ll use later in the core methods of the component.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了 Router 组件的基本框架，你可以开始添加一些你将在组件的核心方法中使用的工具。
- en: When working with routes, there are a few things you’ll need to do. If you looked
    carefully at [listing 7.2](kindle_split_018_split_002.xhtml#ch07ex02), you probably
    saw that you could pass in `path` props that didn’t all have a `/` before them.
    That may seem like a minor thing, but you need to make sure that users of the
    router can do this. You also need to make sure that any double `//` get removed
    if a user were to include too many forward slashes either by accident or as a
    result of nesting routes.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理路由时，你需要做一些事情。如果你仔细看了[列表 7.2](kindle_split_018_split_002.xhtml#ch07ex02)，你可能注意到你可以传递没有前面带有
    `/` 的 `path` 属性。这可能看起来像一件小事，但你需要确保路由的使用者可以这样做。你还需要确保如果用户不小心或由于路由嵌套而包含过多的斜杠，任何双
    `//` 都会被移除。
- en: Let’s see how to create two helper utilities to address these issues. First,
    you want to create a utility for cleaning a path. This will use a simple regular
    expression to replace any double forward slashes with a single one. If you’re
    not familiar with regular expressions, you can find many good resources to learn
    more about them online. They’re a powerful way of matching patterns in text and
    are key to many forms of software development. But they can also seem obscure
    and difficult to reason about or learn. Fortunately for us, you’re only using
    a simple regular expression to find and replace any double forward slashes (`//`).
    The next listing shows how to implement the simple `cleanPath` method. Note that
    sanitizing strings with regular expressions can be tricky, so don’t expect every
    case you encounter to be this straightforward.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建两个辅助工具来解决这些问题。首先，你需要创建一个用于清理路径的工具。这将使用一个简单的正则表达式来将任何双斜杠替换为单个斜杠。如果你不熟悉正则表达式，你可以在网上找到许多很好的资源来了解更多关于它们的信息。它们是匹配文本中模式的一种强大方式，并且对于许多形式的软件开发至关重要。但它们也可能显得晦涩难懂，难以推理或学习。幸运的是，你只需要使用一个简单的正则表达式来查找和替换任何双斜杠（`//`）。下一个列表展示了如何实现简单的
    `cleanPath` 方法。请注意，使用正则表达式清理字符串可能很棘手，因此不要期望你遇到的每个情况都这么简单。
- en: Listing 7.4\. Adding the cleanPath utility to the Router (src/components/router/Router.js)
  id: totrans-889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 向 Router 添加 cleanPath 工具（src/components/router/Router.js）
- en: '[PRE62]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* cleanPath uses String.replace to remove any double slash characters from
    the path (/).**'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* cleanPath 使用 String.replace 从路径中移除任何双斜杠字符（/）。**'
- en: We won’t go too deep into regular expressions because they deserve serious,
    in-depth treatment, but we can at least note a few things. First, the basic regex
    syntax in JavaScript is two forward slashes with an expression inside `/<regular
    expression>/`. Second, although the `\/\/` series of characters looks arcane and,
    frankly, kind of like a W, it’s only two forward slashes (`//`) with escape characters
    (`/`) added so they don’t get interpreted as comments or anything else. Finally,
    the `g` character added to the end of the regular expression is a flag meaning
    *match all occurrences*. To learn more about regular expressions, head to [http://regexr.com/3eg8l](http://regexr.com/3eg8l)
    for detailed insights about what each part of a regular expression means and to
    practice matching different patterns.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨正则表达式，因为它们值得进行严肃的深入处理，但我们至少可以注意几点。首先，JavaScript 中的基本正则表达式语法是两个斜杠，其中包含一个在
    `/<正则表达式>/` 内的表达式。其次，尽管 `\/\/` 这一系列字符看起来很神秘，坦白说，有点像 W，但它只是两个斜杠（`//`）加上转义字符（`/`），这样它们就不会被解释为注释或其他内容。最后，添加到正则表达式末尾的
    `g` 字符是一个标志，表示*匹配所有出现*。要了解更多关于正则表达式的信息，请访问[http://regexr.com/3eg8l](http://regexr.com/3eg8l)，以获取关于正则表达式每个部分含义的详细见解，并练习匹配不同的模式。
- en: Now that you can clean occurrences of `//`, you need to handle a few other situations
    for the routes you add. You’ll call this utility `normalizeRoute` because it will
    ensure that parent and child routes get created as the right strings with a forward
    slash if and where necessary. This function will take a path and an optional parent.
    With these two inputs, you can handle a few situations. The following listing
    shows how the `normalizeRoute` method will work.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以清理 `//` 的出现，你需要处理你添加的路由的几个其他情况。你可以称这个工具为 `normalizeRoute`，因为它将确保父路由和子路由在必要时以带有斜杠的正确字符串创建。这个函数将接受一个路径和一个可选的父路径。有了这两个输入，你可以处理几种情况。以下列表展示了
    `normalizeRoute` 方法将如何工作。
- en: Listing 7.5\. Creating the normalizeRoute utility (src/components/router/Router.js)
  id: totrans-894
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 创建 normalizeRoute 工具（src/components/router/Router.js）
- en: '[PRE63]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Function receives path and parent object—the route property is a path
    string.**'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数接收路径和父对象——路由属性是一个路径字符串。**'
- en: '***2* If the path is just a /, you can just return it—we don’t need to join
    it with a parent.**'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果路径只是 /，你可以直接返回它——我们不需要将它与父路径连接。**'
- en: '***3* If no parent is provided, you can just return the path since there’s
    nothing to join it with.**'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果没有提供父路径，你可以直接返回路径，因为没有东西可以与之连接。**'
- en: '***4* If there is a parent, you add the path to the parent’s path by joining
    them together.**'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果有父路径，你可以通过将它们连接起来将路径添加到父路径上。**'
- en: 7.2.4\. Matching URL paths and parameterized routing
  id: totrans-900
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 匹配 URL 路径和参数化路由
- en: You’ve got some helper tools created, but you aren’t doing any routing yet.
    To start matching URLs to components, you need to add routes to your router. How
    are you going to do that? Essentially, you need to find a way to render a given
    component based on what the current URL is—the “matching” part I keep talking
    about. That may not sound like a lot of work, but more than a few steps are involved.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一些辅助工具，但目前还没有进行任何路由。为了开始匹配 URL 到组件，你需要向你的路由器添加路由。你打算怎么做到这一点？本质上，你需要找到一种方法，根据当前的
    URL 渲染给定的组件——这就是我一直在说的“匹配”部分。这可能听起来工作量不大，但实际上涉及到的步骤不止几个。
- en: 'First, let’s look at a key component of a front-end routing system for the
    browser: *path matching*. You need some way to evaluate path strings and turn
    them into meaningful data you can use. To accomplish this, you’ll use a small
    package called `enroute`, which is itself a tiny router you’ll use to match paths
    to your components. Internally, `enroute` converts strings into regular expressions
    that can be used to match strings (for example, the URLS you’ll be checking against).
    You can also use it to specify path *parameters* so you can create a path like
    `/users/:user` and get access to the user ID in `/users/1234` as something like
    `route.params.user` in your code. This approach is common, and you may have seen
    something similar if you’ve ever worked with express.js.'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看浏览器前端路由系统的一个关键组件：*路径匹配*。你需要某种方法来评估路径字符串并将它们转换为你可以使用的有意义的数据。为了实现这一点，你将使用一个小型包
    `enroute`，它本身就是一个微型的路由器，你可以用它来匹配路径到你的组件。内部，`enroute` 将字符串转换为可以用于匹配字符串的正则表达式（例如，你将要检查的
    URL）。你还可以用它来指定路径 *参数*，这样你就可以创建一个像 `/users/:user` 这样的路径，并在 `/users/1234` 中访问用户
    ID，就像在代码中的 `route.params.user` 一样。这种方法很常见，如果你曾经使用过 express.js，你可能见过类似的东西。
- en: The ability to parameterize URLs is useful because that way you can treat the
    URL like another form of data input you can pass to a router. URLs are powerful,
    and making them dynamic is part of the reason why. URLs can be meaningful and
    allow users to visit resources directly without having to first visit one page
    and then navigate several more times to get where they want to go.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 能够参数化 URL 很有用，因为这样你可以将 URL 视为另一种可以传递给路由器的数据输入形式。URL 很强大，使它们动态化是其中的一个原因。URL 可以有意义，并允许用户直接访问资源，而无需首先访问一个页面，然后导航多次才能到达他们想去的地方。
- en: You won’t use the full capabilities of parameterizing your routes, but let’s
    look at a few examples to make sure you know what you’re working toward. [Table
    7.1](kindle_split_018_split_002.xhtml#ch07table01) shows a couple examples of
    URL paths that might be useful in a common web application.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会使用参数化路由的全部功能，但让我们看看几个例子，以确保你知道你正在努力实现什么。[表 7.1](kindle_split_018_split_002.xhtml#ch07table01)
    展示了几个在常见网络应用中可能有用的 URL 路径示例。
- en: Table 7.1\. Examples of common routes with parameters
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 带参数的常见路由示例
- en: '| Route | Example use |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '| 路由 | 示例用途 |'
- en: '| --- | --- |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| / | Home page for the app. |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '| / | 应用的主页。|'
- en: '| /profile | Profile page for a user; shows settings. |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| /profile | 用户的个人资料页面；显示设置。|'
- en: '| /profile/settings | Settings route; a child of the profile page; shows user-related
    settings. |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| /profile/settings | 设置路由；是个人资料页面的子路由；显示用户相关设置。|'
- en: '| /posts/:postID | postID made available to code; example route would be /posts/2391448\.
    Useful if you wanted to create publicly available links to particular posts. |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '| /posts/:postID | postID 可用于代码；示例路由为 /posts/2391448。如果你想要创建指向特定帖子的公开链接，这很有用。|'
- en: '| /users/:userID | :userID is a path parameter; useful to show a particular
    user based on their ID. |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| /users/:userID | :userID 是路径参数；根据 ID 显示特定用户很有用。|'
- en: '| /users/:userID/posts | Show all posts for a user; the :userID part of the
    URL is dynamic and made available in your code. |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| /users/:userID/posts | 显示某个用户的全部帖子；URL中的`:userID`部分是动态的，并在您的代码中可用。 |'
- en: 'You’re only taking advantage of one aspect of parameterized routing here with
    the `:name` syntax, but there are tools that will let you do much more than that.
    If you’re interested in learning more about parameterized routing, check out the
    `path-to-regexp` library, available at [www.npmjs.com/package/path-to-regexp](http://www.npmjs.com/package/path-to-regexp).
    This is a great tool, and there are others we could spend time looking into, but
    we need to focus on the task at hand: routing with React.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里仅利用了参数化路由的一个方面，即使用`:name`语法，但有一些工具可以让您做更多的事情。如果您想了解更多关于参数化路由的信息，请查看`path-to-regexp`库，可在[www.npmjs.com/package/path-to-regexp](http://www.npmjs.com/package/path-to-regexp)找到。这是一个非常好的工具，我们还可以花时间研究其他工具，但我们需要专注于当前的任务：使用React进行路由。
- en: The important takeaway about these routing tools (`enroute` and `path-to-regexp`)
    is that you’re going to use them to help match URLs and work with some path parameters
    in URLs. It doesn’t matter so much for now which tool you use or if you want to
    go build your own; you just need something that lets you focus on the fundamentals.
    One of the beautiful things about React is that you’re free to make your own informed
    decision about which routing tools you want to use when you’re building your own
    applications.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由工具（`enroute`和`path-to-regexp`）的重要收获是您将使用它们来帮助匹配URL并处理URL中的某些路径参数。目前来说，您使用哪个工具或者是否想自己构建并不那么重要；您只需要一个能让您专注于基础的工具。React的一个美妙之处在于，当您构建自己的应用程序时，您可以自由地根据自己的信息做出决定，选择想要使用的路由工具。
- en: '|  |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pondering parameters**'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '**思考参数**'
- en: Parameterizing routes is often a useful way of getting data into your application.
    Can you think of other ways you might use route parameters besides getting the
    post ID?
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化路由通常是一种将数据引入应用程序的有用方式。您能想到除了获取帖子ID之外，您可能还会用路由参数做些什么吗？
- en: '|  |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll be using your URL-matching library (`enroute`) to determine which route
    to render, so next you’ll get that set up on your component. Right now, the Router
    component has a `render` method that doesn’t do anything, so that seems like a
    good place to start. The following listing shows how to integrate `enroute` with
    your router and the resulting changes to the `render` method.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用您的URL匹配库（`enroute`）来确定要渲染哪个路由，因此接下来您将在组件上设置它。目前，Router组件的`render`方法没有任何作用，所以这似乎是一个很好的起点。以下列表显示了如何将`enroute`与路由器集成以及`render`方法的相应更改。
- en: Listing 7.6\. Finished Router (src/components/router/Router.js)
  id: totrans-921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 完成的Router（src/components/router/Router.js）
- en: '[PRE64]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* enroute is a tiny functional router you use to match URL strings and
    parameterize routes.**'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* enroute是一个小巧的功能性路由器，您用它来匹配URL字符串和参数化路由。**'
- en: '***2* Set propTypes as a static class property.**'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将PropTypes作为静态类属性设置。**'
- en: '***3* Set up component’s initial state and initialize enroute**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置组件的初始状态并初始化enroute**'
- en: '***4* Routes will end up as object with your URL paths for keys.**'
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 四条路由最终将作为对象出现，其键为您的URL路径。**'
- en: '***5* Pass routes into enroute, and Render will use return value of enroute
    to match URLs to components.**'
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将路由传递给enroute，Render将使用enroute的返回值来匹配URL到组件。**'
- en: '***6* Pass in the current location to the router as a prop.**'
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将当前位置作为prop传递给路由器。**'
- en: '***7* Use invariant to make sure that you don’t forget to provide a location.**'
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用invariant确保您没有忘记提供位置。**'
- en: '***8* Lastly, and most importantly, you want to use the router to match a location
    and return the corresponding component.**'
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 最后，也是最重要的，您想要使用路由器来匹配位置并返回相应的组件。**'
- en: You didn’t add that much code, but some of the most important parts of the router
    are now in place. Right now, there aren’t any routes for `enroute` to work with,
    but the basic mechanics are there. You want to try to find a component associated
    with a route and then use the router to render that. In the next section, you’ll
    create those routes so your router can use them.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 您并没有添加太多代码，但路由器中一些最重要的部分现在已经就位。目前，没有为`enroute`提供任何路由，但基本机制已经存在。您想要尝试找到与路由关联的组件，然后使用路由器来渲染它。在下一节中，您将创建这些路由，以便路由器可以使用它们。
- en: 7.2.5\. Adding routes to the Router component
  id: totrans-932
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5\. 向Router组件添加路由
- en: 'To add a route to the router, you need two things: the right URL string to
    use and the component for that URL. You’ll create a method on the Router component
    that will let you tie these two things together: `addRoute`. If you take a quick
    look at the `enroute` usage example at [https://github.com/lapwinglabs/enroute](https://github.com/lapwinglabs/enroute),
    you’ll see how `enroute` works. It takes an object with URL strings for keys and
    functions for values, and when one of the paths is matched, it invokes the function
    and passes in some extra data. [Listing 7.7](kindle_split_018_split_002.xhtml#ch07ex07)
    shows how you’d use the `enroute` library without React. With `enroute` you can
    match functions that take parameters and any additional data to URL strings.'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 要将路由添加到路由器，您需要两样东西：要使用的正确URL字符串和该URL的组件。您将在Router组件上创建一个方法，让您可以将这两者结合起来：`addRoute`。如果您快速查看[https://github.com/lapwinglabs/enroute](https://github.com/lapwinglabs/enroute)上的`enroute`使用示例，您将看到`enroute`是如何工作的。它接受一个对象，该对象以URL字符串为键，以函数为值，当匹配到其中一个路径时，它将调用该函数并传递一些额外的数据。[列表7.7](kindle_split_018_split_002.xhtml#ch07ex07)显示了如何在不使用React的情况下使用`enroute`库。使用`enroute`，您可以匹配接受参数和任何附加数据的函数到URL字符串。
- en: Listing 7.7\. Route configuration example (src/components/router/Router.js)
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 路由配置示例（src/components/router/Router.js）
- en: '[PRE65]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Two parameters are used: route parameters (like /users/:user) and any
    additional data you pass in.**'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用了两个参数：路由参数（如 /users/:user）和您传入的任何附加数据。**'
- en: '***2* Pass in an object with paths and functions that you’ve created to handle
    those paths.**'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 传入一个包含路径和函数的对象，这些函数用于处理这些路径。**'
- en: '***3* To use, pass in a location and any additional data and the right function
    will be executed.**'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用时，传入一个位置和任何附加数据，正确的函数将被执行。**'
- en: Now that you have some idea of how `enroute` works apart from React, let’s see
    how to integrate it into your router and give it some life. Instead of returning
    an object as you did in the preceding listing, you want to return a component.
    But you currently have no way to get to the paths or components for your routes.
    Remember how you created a Route component that would store them but didn’t render
    anything? You need to get access to that data from your parent component (Router).
    That means you’re going to need to use the `children` property.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对`enroute`除了React之外的工作方式有了些了解，让我们看看如何将其集成到您的路由器中并给它一些活力。与前面列表中返回对象的方式不同，您想要返回一个组件。但您目前没有访问路由的路径或组件的方法。还记得您创建了一个用于存储它们的Route组件，但没有渲染任何内容吗？您需要从父组件（Router）获取这些数据。这意味着您将需要使用`children`属性。
- en: '|  |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ve seen how you can compose components together in React to create new components
    by creating parent and child relationships between components. So far, you’ve
    only used children “externally” by nesting components within each other. Any time
    you’ve been nesting and composing components, you’ve been utilizing React’s concept
    of children. But you haven’t dynamically accessed any of those nested children
    from a parent component yet. You can access the children passed into a parent
    on the component’s props as, you guessed it, `children`.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何在React中将组件组合在一起，通过在组件之间创建父子关系来创建新的组件。到目前为止，您只是通过将组件嵌套在彼此内部来“外部”使用子组件。每次您在嵌套和组合组件时，您都在利用React的子组件概念。但您还没有从父组件动态访问任何嵌套子组件。您可以通过组件的props中的`children`来访问传递给父组件的子组件，正如您所猜的，就是`children`。
- en: '|  |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The `children` prop that’s available on every React component or element is
    what we call an *opaque* data structure because it, unlike almost everything else
    in React, isn’t just an array or plain old JavaScript object. This may change
    in future versions of React, but in the meantime, it means there are a few tools
    provided by React that let you work with the `children` prop. A number of methods
    are available from `React.Children` you can use to work with the `children` opaque
    data structure, including the following:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 每个React组件或元素上可用的`children`属性被称为*不透明*数据结构，因为它与React中的几乎所有其他内容不同，它不是一个数组或普通的JavaScript对象。这可能在React的将来版本中改变，但与此同时，这意味着React提供了一些工具，让您可以处理`children`属性。`React.Children`提供了一些方法，您可以使用它们来处理`children`不透明数据结构，包括以下内容：
- en: '**`React.Children.map`—** Similar to `Array.map` in native JavaScript, this
    invokes a function on every immediate child within `children` (meaning it won’t
    traverse every possible descendent component, just direct descendants) and returns
    an array of the elements it traverses. Returns `null` or `undefined` rather than
    an empty array if `children` is `null` or `undefined`:'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`React.Children.map`—** 与原生JavaScript中的`Array.map`类似，这个方法在`children`中的每个直接子元素上调用一个函数（这意味着它不会遍历每个可能的子组件，只是直接子元素）并返回它遍历的元素数组。如果`children`是`null`或`undefined`，则返回`null`或`undefined`而不是空数组：'
- en: '[PRE66]'
  id: totrans-946
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**`React.Children.forEach`—** Similar to the way that `React.Chidlren.map`
    works, but it doesn’t return an array:'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`React.Children.forEach`—** 与`React.Children.map`的工作方式类似，但它不返回数组：'
- en: '[PRE67]'
  id: totrans-948
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**`React.Children.count`—** Returns the total number of components found in
    `children`. Equal to the number of times either `React.Children.map` or `React.Children.forEach`
    would invoke their callback on the same elements:'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`React.Children.count`—** 返回在`children`中找到的组件总数。等于`React.Children.map`或`React.Children.forEach`在相同元素上调用其回调的次数：'
- en: '[PRE68]'
  id: totrans-950
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**`React.Children.only`—** Returns the only child in `children` or throws an
    error:'
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`React.Children.only`—** 返回`children`中的唯一子元素或抛出错误：'
- en: '[PRE69]'
  id: totrans-952
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**`React.Children.toArray`—** Returns `children` as a flat array with keys
    assigned to each child:'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`React.Children.toArray`—** 将`children`作为带有每个子元素键的扁平数组返回：'
- en: '[PRE70]'
  id: totrans-954
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Because you want to add route information to `this.routes` on the Router component,
    you’ll use `React.Children.forEach` to iterate over each of the children of Router
    (remember, those are the Route components) and get access to their props. You’ll
    use these props to set up your routes and tell `enroute` which component should
    be rendered at which URL.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想在Router组件的`this.routes`上添加路由信息，所以你会使用`React.Children.forEach`来遍历Router的每个子元素（记住，那些是Route组件），并获取它们的属性。你将使用这些属性来设置你的路由并告诉`enroute`在哪个URL渲染哪个组件。
- en: '|  |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**“Self-eradicating” components in React**'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**“React中的自我消除组件”**'
- en: 'When React 16 came out, it enabled components to return arrays from render.
    This was previously impossible, but it opens up some interesting possibilities.
    One of them is the idea of a *self-destructing* or *self-eradicating*^([[1](kindle_split_018_split_002.xhtml#ch07fn1)])
    component. Previously, when you could only return a single node from any given
    component, you would often find yourself wrapping components in divs or spans
    just to get valid JavaScript output. A common scenario would look something like
    this:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 当React 16发布时，它使组件能够在渲染时返回数组。这之前是不可能的，但它开启了一些有趣的可能性。其中之一是*自我销毁*或*自我消除*^([[1](kindle_split_018_split_002.xhtml#ch07fn1)])组件的想法。之前，当你只能从任何给定组件返回单个节点时，你经常会发现自己将组件包裹在div或span中，只是为了得到有效的JavaScript输出。一个常见的场景可能看起来像这样：
- en: ¹
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Big thanks to Ben Ilegbodu for first introducing this idea to me!
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常感谢Ben Ilegbodu首先向我介绍这个想法！
- en: '[PRE71]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Top-level components, side-by-side, laid out with Flexbox (or CSS grids)**'
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用Flexbox（或CSS网格）并排排列的顶级组件**'
- en: '***2* Wrapper div added because User, Group, and Org can’t be returned together
    in JavaScript—it doesn’t support multiple return values**'
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加包装div是因为在JavaScript中，User、Group和Org不能一起返回——它不支持多个返回值**'
- en: This was a source of much annoyance for many teams, although it certainly didn’t
    stop people from using React. One major sort of problem it creates, though, isn’t
    merely the fact that the wrapping div seems unnecessary. As you can see here,
    the app is laid out using Flexbox (or some other CSS layout API that would break
    in this scenario).
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 这对许多团队来说是一个很大的烦恼，尽管这当然没有阻止人们使用React。尽管如此，它造成的一个主要问题并不仅仅是包裹div看起来似乎是不必要的。正如你所看到的，应用程序是使用Flexbox（或某些其他CSS布局API，在这种情况下会中断）布局的。
- en: The problem that the wrapping div creates is that it forces you to move components
    up a level so they aren’t grouped within a single node. There are certainly other
    reasons this caused problems or forced workarounds, but this is one that I’ve
    encountered many times.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 包裹div造成的问题在于它迫使你将组件提升一个级别，这样它们就不会在单个节点中分组。当然，还有其他原因导致问题或强制采取折衷方案，但这是我多次遇到的一个问题。
- en: 'With the advent of React 16 and following, though, it became possible to return
    arrays, so now we have a way around this. React 16 introduced many other powerful
    features, but this one was a welcome change. Developers can now do something like
    this:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着React 16及其后续版本的推出，现在可以返回数组，因此我们找到了一种绕过这个问题的方法。React 16引入了许多其他强大的功能，但这个变化是受欢迎的。开发者现在可以这样做：
- en: '[PRE72]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This component acts as a sort of pass-through, getting out of the way or “self-eradicating”
    as it renders its children. Using this approach, you can maintain component separation
    without having to hedge on things like your CSS layout technique. The same scenario
    might look something like this with a “self-eradicating” component:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件充当一种传递组件，在渲染其子组件时让路或“自我消除”。使用这种方法，你可以在不涉及CSS布局技术等事项的情况下保持组件分离。具有“自我消除”组件的相同场景可能如下所示：
- en: '[PRE73]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|  |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Remember, `enroute` expects you to give a function to each route so it can pass
    in parameter information and other data to it. This function is where you’ll tell
    React to create a component and handle rendering additional child components.
    [Listing 7.8](kindle_split_018_split_002.xhtml#ch07ex08) shows how to add the
    `addRoute` and `addRoutes` methods to your component. `addRoutes` uses `React.Children.forEach`
    to iterate over the child Route components, grab their data, and set up the route
    for `enroute` to use. This is the core body of the router—once you implement this,
    the router will be up and running!
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`enroute` 预期你为每个路由提供一个函数，以便它可以传递参数信息和其它数据给它。这个函数是你在其中告诉 React 创建组件并处理渲染额外子组件的地方。[列表
    7.8](kindle_split_018_split_002.xhtml#ch07ex08) 展示了如何将 `addRoute` 和 `addRoutes`
    方法添加到你的组件中。`addRoutes` 使用 `React.Children.forEach` 遍历子 Route 组件，获取它们的数据，并为 `enroute`
    设置路由。这是路由器的核心部分——一旦你实现了这个，路由器就会启动并运行！
- en: '|  |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**props.children**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**props.children**'
- en: We talked about React’s `props.children` in this chapter. Are there any differences
    between `props.children` and other props? Why might there be any differences?
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论了 React 的 `props.children`。`props.children` 和其他属性之间有什么区别？为什么可能会有区别？
- en: '|  |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 7.8\. The `addRoute` and `addRoutes` methods (src/components/router/Router.js)
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. `addRoute` 和 `addRoutes` 方法 (src/components/router/Router.js)
- en: '[PRE74]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Use destructuring to get component, path, and children props.**'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用解构来获取组件、路径和子组件属性。**'
- en: '***2* Make sure every Route has a path and component prop or throw an error.**'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保每个 Route 都有一个路径和组件属性，否则抛出错误。**'
- en: '***3* render is a function you’ll give to enroute that takes route-related
    params and additional data.**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* render 是一个你将给 enroute 的函数，它接受与路由相关的参数和额外数据。**'
- en: '***4* Merge together props from parent with child component**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 合并父组件和子组件的属性**'
- en: '***5* Create a new component with merged props.**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个新的组件，并合并属性。**'
- en: '***6* If there’s a parent, invoke render method of parent parameter but with
    children you’ve created**'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果有父组件，调用父参数的 render 方法，但使用你创建的子组件**'
- en: '***7* Use normalizeRoute helper to make sure the URL path gets set up right**'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用 normalizeRoute 辅助函数确保 URL 路径设置正确**'
- en: '***8* If there are more nested children on current Route component, repeat
    process and pass in route and parent component**'
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果当前路由组件有更多嵌套子组件，重复此过程，并传入路由和父组件**'
- en: '***9* Use cleanPath utility to create path on routes object and assign your
    finished function to it**'
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 使用 cleanPath 工具在路由对象上创建路径，并将你的完成函数分配给它**'
- en: Whew! There was a lot going on in those few lines of code. Feel free to go back
    over it a couple of times to make sure you feel comfortable with the concepts.
    Once you add the `addRoutes` method, we’ll recap the steps and review with a visualization.
    But first you’ll add the `addRoutes` method. Comparatively, it’s quite short.
    The following listing shows how to implement it.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！在这些代码行中发生了很多事情。请随意多次回顾它，以确保你对这些概念感到舒适。一旦你添加了 `addRoutes` 方法，我们将回顾步骤并使用可视化进行复习。但首先，你需要添加
    `addRoutes` 方法。相对而言，它相当简短。以下列表展示了如何实现它。
- en: Listing 7.9\. The `addRoutes` method (/components/router/Router.js)
  id: totrans-989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. `addRoutes` 方法 (/components/router/Router.js)
- en: '[PRE75]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Even though addRoutes gets used in the addRoute method, add it to component’s
    constructor to kick off setting up routes.**'
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 即使 `addRoutes` 在 `addRoute` 方法中使用，也要将其添加到组件的构造函数中以启动设置路由。**'
- en: '***2* addRoutes method gets used in addRoute any time there are additional
    children to iterate over**'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 `addRoutes` 方法中使用时，如果有额外的子组件要遍历**'
- en: '***3* Use React.Children.forEach utility to iterate over each of the children,
    then invoke addRoute for each child Route component.**'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 React.Children.forEach 工具遍历每个子组件，然后为每个子 Route 组件调用 addRoute。**'
- en: Figure 7.3\. The process of adding routes to your router. For each Route component
    found within your Router component, pull off the path and component props and
    then use those to create a function you can pair with a URL path for `enroute`
    to use. If there are child components for a Route, run the same process for those
    before moving on. When done, the `routes` property will have all the right routes
    set up.
  id: totrans-994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3. 向你的路由器添加路由的过程。对于在 Router 组件中找到的每个 Route 组件，提取路径和组件属性，然后使用这些属性创建一个可以与
    URL 路径配对的函数，供 `enroute` 使用。如果 Route 有子组件，则在继续之前对那些子组件运行相同的过程。完成后，`routes` 属性将设置所有正确的路由。
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03_alt.jpg)'
- en: With that, your router is complete and ready to roll. The next listing shows
    the Router component in its final state with helper tools (path normalization,
    invariant uses) left out for brevity. In the next chapter, you’ll put the Router
    component to use.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你的路由器就完成了，准备投入使用。接下来的列表显示了最终状态的 Router 组件，为了简洁起见，省略了辅助工具（路径规范化、不变使用）。在下一章中，你将开始使用
    Router 组件。
- en: Listing 7.10\. Finished Router (src/components/router/Router.js)
  id: totrans-997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10. 完成的 Router（src/components/router/Router.js）
- en: '[PRE76]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 7.3\. Summary
  id: totrans-999
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 摘要
- en: 'In this chapter, you started turning your React application from a simple page
    with some components into a more robust application that handles routing and route
    configuration. We covered quite a lot of ground and explored an advanced use of
    components to build an entire router from the ground up:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始将你的 React 应用程序从带有一些组件的简单页面转变为一个更健壮的应用程序，该应用程序处理路由和路由配置。我们覆盖了很多内容，并探讨了组件的高级用法，从头开始构建整个路由器：
- en: Routing in modern client applications doesn’t require you to perform a complete
    page reload. Instead, it can be handled with client-side applications like React.
    This can decrease browser load time and potentially server load, too.
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代客户端应用程序中，路由不需要你执行完整的页面刷新。相反，它可以由像 React 这样的客户端应用程序处理。这可以减少浏览器加载时间，也可能减少服务器负载。
- en: React doesn’t have a built-in routing library like some frameworks do. Instead,
    you’re free to either pick one from the community or build your own from scratch
    (like you did!).
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 没有像某些框架那样内置的路由库。相反，你可以自由地从社区中选择一个，或者从头开始构建自己的路由（就像你做的那样！）。
- en: React provides you with several utilities to work with the opaque `children`
    data structure. You can iterate over multiple components, check to see how many
    there are, and more.
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 为你提供了几个与不透明的 `children` 数据结构一起工作的实用工具。你可以遍历多个组件，检查它们的数量，等等。
- en: You can use the routing setup you created to dynamically change which children
    are rendered inside of a component. You’re listening for changes in the browser’s
    location and rendering using that data.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用你创建的路由设置动态地更改组件内部渲染的子组件。你正在监听浏览器位置的变化，并使用这些数据来渲染。
- en: In the next chapter, you’ll use your Router and add authentication to your app
    with Firebase.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用你的 Router 并使用 Firebase 为你的应用程序添加身份验证。
- en: Chapter 8\. More routing and integrating Firebase
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章. 更多路由和集成 Firebase
- en: '*This chapter covers*'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using the router you built in [chapter 7](kindle_split_018_split_000.xhtml#ch07)
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你在 [第 7 章](kindle_split_018_split_000.xhtml#ch07) 中构建的路由器
- en: Creating routing-related components like Router, Route, and Link
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建与路由相关的组件，如 Router、Route 和 Link
- en: Working with the HTML5 History API to enable push-state routing
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML5 历史API来启用 push-state 路由
- en: Reusing components
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用组件
- en: Integrating user authentication and Firebase
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成用户身份验证和 Firebase
- en: In the last chapter, you built a simple router from scratch in order to better
    understand how you can do routing with React applications. In this chapter, you’ll
    start to use the router you built and break up the Letters Social app into better
    sections. By the end of the chapter, you’ll be able to navigate around your app,
    view individual post pages, and perform user authentication.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你从头开始构建了一个简单的路由器，以便更好地理解如何在 React 应用程序中实现路由。在这一章中，你将开始使用你构建的路由器，并将 Letters
    Social 应用程序拆分成更好的部分。到本章结束时，你将能够导航你的应用程序，查看单个帖子页面，并执行用户身份验证。
- en: '|  |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**How do I get the code for this chapter?**'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapters 5](kindle_split_016_split_000.xhtml#ch05)
    and [6](kindle_split_017_split_000.xhtml#ch06) (if you followed along and built
    out the examples yourself) or check out the chapter-specific branch (chapter-7-8).
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，您可以通过访问GitHub仓库[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)来查看本章的源代码。如果您想从一张白纸开始学习本章内容并跟随操作，可以使用您从[第5章](kindle_split_016_split_000.xhtml#ch05)和[第6章](kindle_split_017_split_000.xhtml#ch06)（如果您跟随并自己构建了示例）中现有的代码，或者查看特定章节的分支（chapter-7-8）。
- en: Remember, each branch corresponds to the code at the end of the chapter (for
    example, the branch chapter-7-8 corresponds to the code as it will be at the end
    of this chapter). You can execute one of the following terminal commands in the
    directory of your choice to get the code for the current chapter.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应着章节末尾的代码（例如，分支chapter-7-8对应着本章末尾的代码）。您可以在您选择的目录中执行以下终端命令之一来获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您根本没有任何仓库，请输入以下内容：
- en: '[PRE77]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you already have the repository cloned:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经克隆了仓库：
- en: '[PRE78]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能是从其他章节来到这里的，所以确保您已经安装了所有正确的依赖项总是一个好主意：
- en: '[PRE79]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|  |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1\. Using the router
  id: totrans-1025
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 使用路由器
- en: In the last chapter, you built a working router with React. In a situation where
    you’re working on a React app in a production setting, you’ll probably want to
    opt for something like React Router. Fortunately, React Router follows a very
    similar API, but it also comes with more advanced features that let you do even
    more with routing. Maybe you don’t need all those features, though, and something
    like you’ve built is enough. That’s perfectly fine—pick the tools that best suit
    the problems you’re solving, not the ones with the most GitHub stars or Hacker
    News upvotes. Your needs will change in [chapter 12](kindle_split_024_split_000.xhtml#ch12)
    as we tackle server-side rendering, so we’ll switch to React Router in that chapter.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您使用React构建了一个工作路由器。在您在生产环境中开发React应用的情况下，您可能会选择像React Router这样的工具。幸运的是，React
    Router遵循一个非常相似的API，但它还提供了更多高级功能，让您能够进行更复杂的路由操作。不过，也许您并不需要所有这些功能，您构建的类似工具已经足够了。这完全没问题——选择最适合您解决问题的工具，而不是那些GitHub星标最多或Hacker
    News投票最高的工具。随着我们在第12章中处理服务器端渲染，您的需求将会变化，因此我们将在这章中切换到React Router。
- en: Let’s get started using your shiny new router. First you need to hook up the
    router to the HTML5 History API ([https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History))
    so you can take advantage of navigation that doesn’t require a full page reload.
    You’ll use *push state* navigation because you don’t need to hit the server every
    time for a full page refresh. But you could also use hash-based routing (see [https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md)
    for more).
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用您的新鲜路由器。首先，您需要将路由器连接到HTML5历史API([https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History))，以便利用无需完整页面重新加载的导航。您将使用*push
    state*导航，因为您不需要每次都击中服务器进行完整页面的刷新。但您也可以使用基于hash的路由（更多内容请参阅[https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md)）。
- en: We won’t spend much time exploring the HTML5 APIs, because they deserve their
    own treatment. You’ll use the well-known `history` library, available on npm at
    [www.npmjs.com/package/history](http://www.npmjs.com/package/history). This library
    will let you work with the History API in a reliable and predictable way across
    browsers. To make sure it’s installed, run `npm install --save history`. Once
    you’ve installed it, you’ll need to make some changes to your index.js file that
    currently serves as the root of the entire app. Until now, this file was where
    React DOM would render your whole app to a DOM element. But you have routing enabled,
    and your Router component expects a location (see [chapter 7](kindle_split_018_split_000.xhtml#ch07)).
    You need to find a way to feed it that location and take advantage of the HTML5
    History API using the `history` library, and index.js is the perfect place to
    do this.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会花太多时间探索HTML5 API，因为它们值得单独处理。您将使用在npm上可用的知名`history`库，网址为[www.npmjs.com/package/history](http://www.npmjs.com/package/history)。这个库将让您以可靠和可预测的方式跨浏览器使用History
    API。为了确保它已安装，请运行`npm install --save history`。一旦安装，您需要修改index.js文件，该文件目前是整个应用程序的根。到目前为止，该文件是React
    DOM将您的整个应用程序渲染到DOM元素的地方。但是您启用了路由，并且您的Router组件期望一个位置（见[第7章](kindle_split_018_split_000.xhtml#ch07)）。您需要找到一种方法来提供该位置，并利用`history`库的HTML5
    History API，而index.js是做这件事的完美地方。
- en: '|  |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Comparing client-side and server-side routing**'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较客户端和服务器端路由**'
- en: Take a moment to consider the differences between client-side routing and client-server
    URL-based routing. What is one of the primary differences between client-side
    routing and server-side routing?
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间考虑客户端路由和基于客户端-服务器URL的路由之间的区别。客户端路由和服务器端路由之间主要区别之一是什么？
- en: '|  |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In addition to taking advantage of `history`, you’ll need to set up your routes.
    To do so, you’ll need to refactor some of your components, which should give you
    a sense of the benefits of composability and modularity in React. You’ll move
    things around but won’t have to fundamentally change the way your components work.
    Let’s see how to fix the App component first. It needs to serve as a container
    for the child routes because you want every page to have the same sidebars and
    navigation bar, changing only what gets passed into the `children` prop. [Figure
    8.1](kindle_split_019_split_001.xhtml#ch08fig01) shows an example of what this
    looks like.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 除了利用`history`之外，您还需要设置您的路由。为此，您需要重构一些组件，这将使您感受到React中可组合性和模块化的好处。您将移动一些内容，但不需要从根本上改变组件的工作方式。让我们首先看看如何修复App组件。它需要作为一个容器来容纳子路由，因为您希望每个页面都有相同的侧边栏和导航栏，只有传递给`children`属性的内容会改变。[图8.1](kindle_split_019_split_001.xhtml#ch08fig01)展示了这种外观的示例。
- en: Figure 8.1\. The boxed area in the screenshot above will change based on what
    view you decide to render based on a URL. Over time, you may even do more nesting
    and expand that area to include the sidebars so you can maintain the same navigation
    bar across pages and have other routes that have dynamic areas in them.
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 上面的截图中的方框区域将根据您根据URL决定渲染的视图而变化。随着时间的推移，您甚至可以进行更多嵌套并扩展该区域以包括侧边栏，这样您就可以在页面之间保持相同的导航栏，并拥有具有动态区域的其它路由。[图8.1](kindle_split_019_split_001.xhtml#ch08fig01)展示了这种外观的示例。
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-1035
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: To achieve this sort of nesting, you need to refactor the App component to dynamically
    show `children`, as shown in [listing 8.1](kindle_split_019_split_001.xhtml#ch08ex01).
    Fortunately, you won’t end up deleting much of the work we’ve done—you’ll just
    move it around. As you refactor, you’re going to do some reorganization of your
    app files. Create a new directory in `src` called `pages`. You’ll be putting components
    here that tend to only contain other components and provide them with data. I’ll
    talk about this idea more when we start exploring React application architecture
    in later chapters.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种嵌套，您需要重构App组件以动态显示`children`，如[列表8.1](kindle_split_019_split_001.xhtml#ch08ex01)所示。幸运的是，您不会删除我们完成的大部分工作——您只需移动它。在重构过程中，您将对您的应用程序文件进行一些重组。在`src`中创建一个名为`pages`的新目录。您将在这里放置那些通常只包含其他组件并提供数据的组件。当我们在后面的章节中开始探索React应用程序架构时，我会更多地讨论这个想法。
- en: Listing 8.1\. Refactoring the App component (src/app.js)
  id: totrans-1037
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 重构App组件（src/app.js）
- en: '[PRE80]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Set up top-level error boundary using componentDidCatch so you can display
    error if something goes wrong**'
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用componentDidCatch设置顶级错误边界，以便在出现错误时显示错误**'
- en: '***2* Render the error, if any.**'
  id: totrans-1040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果有错误，则渲染错误。**'
- en: '***3* Pass user props in—you’ll use this when you integrate Firebase.**'
  id: totrans-1041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 传递用户属性——当你集成 Firebase 时将使用它。**'
- en: '***4* If app is in a loading state, render the loader**'
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果应用处于加载状态，则渲染加载器**'
- en: '***5* Use props.children to output the currently active route.**'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 props.children 输出当前激活的路由。**'
- en: You need to create a component for the main page so users can see the posts.
    Create a file called home.js and place it in the pages directory. This component
    should look familiar—it was the main component you had before breaking things
    into pages. [Listing 8.2](kindle_split_019_split_001.xhtml#ch08ex02) shows the
    Home component with the method logic you’ve implemented before commented out for
    brevity. Remember, as with all chapters, you can check out different branches
    for each chapter if you want to see how the app has changed or how it’ll be at
    the end of the chapter at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个主页面组件，以便用户可以看到帖子。创建一个名为 home.js 的文件，并将其放置在 pages 目录中。这个组件看起来应该很熟悉——它是你在将内容拆分为页面之前的主要组件。[列表
    8.2](kindle_split_019_split_001.xhtml#ch08ex02) 显示了带有之前实现的方法逻辑的注释的 Home 组件。记住，就像所有章节一样，如果你想查看应用程序如何变化或章节末尾的样子，你可以查看每个章节的不同分支，可以在
    [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)
    上查看。
- en: Listing 8.2\. The refactored Home component (src/pages/Home.js)
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. 重新构建的 Home 组件（src/pages/Home.js）
- en: '[PRE81]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* Don’t forget to adjust import paths—the component lives in a different
    directory.**'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不要忘记调整导入路径——组件位于不同的目录。**'
- en: '***2* Logic for these is exactly the same—you’re only moving components around
    to accommodate new hierarchy.**'
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于这些，逻辑完全相同——你只是在移动组件以适应新的层次结构。**'
- en: '***3* Logic for these is exactly the same—you’re only moving components around
    to accommodate new hierarchy.**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对于这些，逻辑完全相同——你只是在移动组件以适应新的层次结构。**'
- en: Now that you have your Home component moved around, you’re ready to configure
    your routes and hook up the `history` tool so your router can respond to browser
    location changes. It’s often helpful to make a single module available to other
    parts of your application as a utility so you don’t duplicate work. You’ll do
    this more later in the book, and you’ve probably done this on your own, too. You’ll
    do that with the `history` library, as shown in the next listing, because you
    want to eventually use it to (among other things) create links that work with
    your Router and don’t have to be normal `<a href=""></>` tags.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 Home 组件移动到位，你就可以配置你的路由并将 `history` 工具连接起来，以便你的 Router 能够响应用户浏览器位置的变化。通常，将单个模块作为实用工具提供给应用程序的其他部分，以便你不必重复工作是有帮助的。你将在本书的后面部分做更多这样的操作，你可能也已经自己这样做过了。你将使用
    `history` 库来做这件事，如以下列表所示，因为你最终想用它（以及其他事情）来创建与你的 Router 一起工作的链接，而无需是正常的 `<a href=""></>`
    标签。
- en: Listing 8.3\. Setting up the history library (src/history/history.js)
  id: totrans-1051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 设置历史库（src/history/history.js）
- en: '[PRE82]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Make a single instance of history library available to your app.**'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建历史库的单个实例以供你的应用程序使用。**'
- en: '***2* Export navigate method and history instance (in case you need direct
    access later).**'
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导出 navigate 方法和历史实例（以防你以后需要直接访问）。**'
- en: Now that you have `history` set up, you can set up the rest of index.js and
    configure your Router. The following listing shows how to do that.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了 `history`，你可以设置 index.js 的其余部分并配置你的 Router。以下列表显示了如何进行操作。
- en: Listing 8.4\. Setting up index.js for routing (src/index.js)
  id: totrans-1056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 为路由设置 index.js（src/index.js）
- en: '[PRE83]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* Import React DOM.**'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 React DOM。**'
- en: '***2* Import App, Home, Router, and Route components.**'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 App、Home、Router 和 Route 组件。**'
- en: '***3* Import history utility you just created**'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入你刚刚创建的历史实用工具**'
- en: '***4* Create a function you’ll call to render your app; wrap React DOM’s render
    method so you can pass location data and a callback.**'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个你将调用的函数来渲染你的应用；包装 React DOM 的 render 方法，以便你可以传递位置数据和回调函数。**'
- en: '***5* Use JSX spread operator to “fill in” location state as props for your
    Router**'
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 JSX 扩展运算符将位置状态作为属性传递给你的 Router**'
- en: '***6* Create route for App and Home components**'
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 为 App 和 Home 组件创建路由**'
- en: '***7* Render app to target DOM element in index.html**'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将应用渲染到 index.html 中的目标 DOM 元素**'
- en: '***8* Create a state object to keep track of location and user**'
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 创建一个状态对象来跟踪位置和用户**'
- en: '***9* Fire when location changes and update router, causing application to
    re-render with new state data**'
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 当位置变化时触发，并更新 Router，使应用程序使用新的状态数据重新渲染**'
- en: '***10* Render the app.**'
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 渲染应用。**'
- en: 8.1.1\. Creating a page for a post
  id: totrans-1068
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 创建帖子页面
- en: You’re routing! At this point, you’ve done a lot to get routing enabled and
    working in your app. But you haven’t done anything to let the user move around
    different parts of your application. At this point, your app will probably start
    to have more pages and subsections of pages. If you were building out a more complicated
    version of a social networking app, you’d probably have sections for a profile
    page, user settings, messages, and more. But in this case, all you need to do
    is display individual posts. How are you going to do this? You’ll start with the
    URL. Remember the `/posts/:postID` route used a few times in examples so far?
    Your post pages are going to live at this URL.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在设置路由！在这个阶段，你已经做了很多工作来启用并使你的应用中的路由工作。但你还没有做任何事情来让用户能够在你的应用的不同部分之间移动。在这个阶段，你的应用可能会开始有更多的页面和页面子部分。如果你正在构建一个更复杂的社会化网络应用的版本，你可能会有个人资料页面、用户设置、消息等部分。但在这个案例中，你所需要做的只是显示单个帖子。你打算怎么做呢？你会从URL开始。还记得到目前为止在示例中多次使用的`/posts/:postID`路由吗？你的帖子页面将位于这个URL。
- en: You’ll get started by creating a page component for individual posts. In earlier
    chapters, you built a Post component that would fetch its data once it was loaded,
    so creating this single-post page shouldn’t be too much trouble. You want to create
    a new component for this page, ensure the post is included, and make sure you
    map it to the route correctly. One thing that will be different is where you get
    the post ID from. Rather than an initial fetch from the server, you’ll pull it
    from the URL. You used a special syntax to set up the URL, and the router will
    make that parameterized route data available to your component. The following
    listing shows how to set up the single-post page.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从创建一个用于单个帖子的页面组件开始。在前面章节中，你构建了一个Post组件，它在加载后会获取其数据，因此创建这个单个帖子页面不应该有太多麻烦。你想要为这个页面创建一个新的组件，确保帖子被包含在内，并确保你正确地将它映射到路由。将会有所不同的一点是，你将从哪里获取帖子ID。而不是从服务器进行初始获取，你将从URL中拉取它。你使用了一种特殊的语法来设置URL，并且路由将使参数化路由数据对组件可用。以下列表显示了如何设置单个帖子页面。
- en: Listing 8.5\. Creating the SinglePost component (src/pages/Post.js)
  id: totrans-1071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 创建SinglePost组件（src/pages/Post.js）
- en: '[PRE84]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Import Post component you created in earlier chapters**'
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入在前面章节中创建的Post组件**'
- en: '***2* Get the post ID off the props passed in by router**'
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从路由传递的props中获取帖子ID**'
- en: Now that you have a component to use, you can integrate it back into your router
    so users will be able to navigate to individual posts. [Listing 8.6](kindle_split_019_split_001.xhtml#ch08ex06)
    shows how to add the Single-Post component to your router. Notice that you’re
    taking advantage of the *parameterized* routing we’ve seen in router examples
    so far. The `:post` part of the path is what gets provided to your component in
    the `params` prop.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个组件可以使用，你可以将其集成回路由中，这样用户就可以导航到单个帖子。[列表8.6](kindle_split_019_split_001.xhtml#ch08ex06)显示了如何将Single-Post组件添加到你的路由中。注意，你正在利用我们迄今为止在路由示例中看到的参数化路由。路径中的`:post`部分是作为`params`属性提供给你的组件的。
- en: Listing 8.6\. Adding individual posts to the router (src/index.js)
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. 将单个帖子添加到路由中（src/index.js）
- en: '[PRE85]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Import SinglePost component for use in your router**'
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为你的路由导入SinglePost组件**'
- en: '***2* Configure SinglePost route using special parameterized routing syntax
    (:post)**'
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用特殊的参数化路由语法（:post）配置SinglePost路由**'
- en: 8.1.2\. Creating a <Link/> component
  id: totrans-1080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 创建一个<Link/>组件
- en: If you run your app in development mode and try clicking around, you’ll notice
    that even though you still have routes set up for individual posts, you can’t
    get there without knowing the ID of the post in the first place and then putting
    that in the URL. That’s not very useful, is it?
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以开发模式运行你的应用并尝试点击，你会注意到尽管你仍然为单个帖子设置了路由，但如果你不知道帖子的ID，你无法到达那里，然后将它放入URL中。这并不是很有用，对吧？
- en: You need to create a custom Link component that will work with your `history`
    tool and your Router—otherwise, users will probably abandon your app quickly,
    and your investors will be sad. How can you enable this? A regular anchor tag
    `(<a href="/">Link!</a>`) won’t do because it will try to reload the entire page,
    which you don’t want. You might also want to create links from things that aren’t
    anchor tags at all, such as a post in a list or anything you don’t want to wrap
    in an anchor tag.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个自定义的链接组件，使其与你的`history`工具和路由器一起工作——否则，用户可能会很快放弃你的应用，你的投资者也会感到难过。你该如何实现这一点？普通的锚点标签`(<a
    href="/">链接！</a>)`是不够的，因为它会尝试重新加载整个页面，而这不是你想要的。你也可能想要从根本不是锚点标签的东西中创建链接，比如列表中的帖子或你不想用锚点标签包裹的东西。
- en: '|  |'
  id: totrans-1083
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Accessibility* is the degree to which an interface is usable by someone. You’ve
    probably heard people talk about “web accessibility” before, but you may not know
    much about it. That’s okay—it’s easy to learn. You want to make sure your app
    is usable by as many people as possible, whether they’re using it with a mouse
    and keyboard, screen reader, or other devices. I just mentioned making arbitrary
    elements of an application navigable using a Link component—something that should
    be done with care when approaching things from an accessibility standpoint. With
    that in mind, I wanted to briefly mention accessibility with regard to this book.
    Because building accessible web applications is a huge and important topic, it’s
    beyond the scope of this book. There are companies, apps, and hobby projects that
    consider it as a first-class dimension of engineering. Although you may be able
    to reference the source code for Letters Social as a collection of ways to build
    apps using React components, we haven’t handled all the different accessibility
    concerns that would come up for your app. To learn more about accessibility on
    the web, check out the WAI-ARIA authoring practices ([www.w3.org/WAI/PF/aria-practices](http://www.w3.org/WAI/PF/aria-practices))
    or the MDN documentation on ARIA ([https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)).
    Ari Rizzitano has also put together an excellent talk on this topic with a special
    focus on accessibility in React, called “Building Accessible Components” ([https://speakerdeck.com/arizzitano/building-accessible-components](https://speakerdeck.com/arizzitano/building-accessible-components)).'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '*可访问性*是指界面可被某人使用的程度。你可能之前听说过人们谈论“网络可访问性”，但你可能对此了解不多。没关系——这很容易学习。你想要确保你的应用尽可能多的人可以使用，无论他们是用鼠标和键盘、屏幕阅读器还是其他设备。我刚刚提到了使用链接组件使应用中的任意元素可导航——在从可访问性的角度考虑事情时，这应该谨慎进行。考虑到这一点，我想简要地提及一下这本书的可访问性。因为构建可访问的Web应用是一个庞大且重要的主题，它超出了这本书的范围。有些公司、应用和爱好项目将其视为工程的第一等维度。尽管你可以将Letters
    Social的源代码作为使用React组件构建应用的多种方式的集合来参考，但我们并没有处理你应用中可能出现的所有不同的可访问性问题。想了解更多关于网络可访问性的信息，请查看WAI-ARIA创作实践([www.w3.org/WAI/PF/aria-practices](http://www.w3.org/WAI/PF/aria-practices))或MDN关于ARIA的文档([https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA))。Ari
    Rizzitano还就这个主题准备了一场精彩的演讲，特别关注React中的可访问性，名为“构建可访问组件”([https://speakerdeck.com/arizzitano/building-accessible-components](https://speakerdeck.com/arizzitano/building-accessible-components))。'
- en: '|  |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You’ll need to use your `history` utility again here and integrate it into
    a Link component that you can use to enable push-state linking inside of your
    application. Remember the `navigate` function you exposed earlier? Using this
    function, you can now programmatically tell the `history` library to change the
    location for the user. To turn this functionality into a component, you’ll use
    some React utilities to wrap other components in a clickable Link component. You’ll
    use `React.cloneElement` to create a copy of the target element and then attach
    a click handler that will perform navigation. The signature for `React.cloneElement`
    looks like this:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要再次使用你的`history`实用工具，并将其集成到一个你可以用来在应用内部启用push-state链接的链接组件中。还记得你之前暴露的`navigate`函数吗？使用这个函数，你现在可以编程地告诉`history`库更改用户的位置。要将这个功能转换成一个组件，你将使用一些React实用工具将其他组件包裹在一个可点击的链接组件中。你将使用`React.cloneElement`来创建目标元素的副本，然后附加一个点击处理程序，该处理程序将执行导航。`React.cloneElement`的签名看起来像这样：
- en: '[PRE86]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: It takes an element to clone, the `props` to merge into the new element, and
    any `children` it should have. You’ll use this utility to clone the component
    that you want to turn into a Link. And you’ll need to make sure the Link component
    only has a single child, so you’ll bring back the `React.Children.only` tool from
    earlier in the chapter. All together, these tools will let you turn other components
    into Link components that help the user get around your app. The following listing
    shows how to create the Link component.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个要克隆的元素、要合并到新元素中的 `props` 以及它应该拥有的任何 `children`。你将使用这个实用工具来克隆你想要转换为 Link
    的组件。并且你需要确保 Link 组件只有一个子节点，所以你将回过头来使用本章早些时候的 `React.Children.only` 工具。所有这些工具加在一起，将让你能够将其他组件转换为
    Link 组件，帮助用户在应用中导航。以下列表显示了如何创建 Link 组件。
- en: Listing 8.7\. Creating the Link component (src/components/router/Link.js)
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 创建 Link 组件（src/components/router/Link.js）
- en: '[PRE87]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* Import the libraries you’ll need.**'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你需要的库**'
- en: '***2* Reuse the history tool you’ve been working with.**'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 重复使用你一直在使用的工具**'
- en: '***3* to and children props will hold target URL and component you’re Link-ifying,
    respectively.**'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* to 和 children props 将分别持有目标 URL 和你正在 Link-化的组件**'
- en: '***4* Clone children of Link component to wrap only one node (it can have children)**'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 克隆 Link 组件的子组件，仅包裹一个节点（它可以有子节点）**'
- en: '***5* In props object, pass onClick handler that will navigate to URL using
    history**'
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在 props 对象中传递一个点击处理函数，该函数将使用历史记录导航到 URL**'
- en: '***6* Define propTypes**'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 定义 propTypes**'
- en: '***7* Import the libraries you’ll need.**'
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 导入你需要的库**'
- en: '***8* Reuse the history tool you’ve been working with.**'
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 重复使用你一直在使用的工具**'
- en: '***9* to and children props will hold target URL and component you’re Link-ifying,
    respectively.**'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* to 和 children props 将分别持有目标 URL 和你正在 Link-化的组件**'
- en: '***10* Clone children of Link component to wrap only one node (it can have
    children)**'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 克隆 Link 组件的子组件，仅包裹一个节点（它可以有子节点）**'
- en: '***11* In props object, pass onClick handler that will navigate to URL using
    history**'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 在 props 对象中传递一个点击处理函数，该函数将使用历史记录导航到 URL**'
- en: '***12* Define propTypes**'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 定义 propTypes**'
- en: To integrate the Link component, you can wrap individual posts in the reusable
    Post component and make sure Link gets a `to` prop that will send the user to
    the right page (see previous Note on accessibility). You can follow this same
    pattern to wrap other components in a similar manner and turn them into Link-ified
    components. The following listing shows how to integrate the Link component.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成 Link 组件，你可以将单个帖子包裹在可重用的 Post 组件中，并确保 Link 获得一个 `to` prop，这将使用户导航到正确的页面（参见之前的关于可访问性的说明）。你可以遵循相同的模式以类似的方式包裹其他组件，并将它们转换为
    Link-化的组件。以下列表显示了如何集成 Link 组件。
- en: Listing 8.8\. Integrating the Link component (src/components/post/Post)
  id: totrans-1105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. 集成 Link 组件（src/components/post/Post）
- en: '[PRE88]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Import Link component; alias it as RouterLink to avoid naming conflict
    with Link component used in our posts**'
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Link 组件；将其别名为 RouterLink 以避免与我们在帖子中使用的 Link 组件命名冲突**'
- en: '***2* Wrap section of Post component you want to be linkable and give it the
    right ID**'
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将你想要可链接的 Post 组件的部分包裹起来，并给它正确的 ID**'
- en: With that, you’ve fully integrated the Router into your application. Users can
    now view individual posts, which is great for sharing and focusing on one at a
    time. Your investors will be suitably impressed and excited to invest in your
    next round of fundraising. You’re not done yet, though. In the next section we’ll
    discuss what to do when you can’t match a URL to a component.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已完全将 Router 集成到你的应用中。现在用户可以查看单个帖子，这对于分享和一次关注一个帖子来说非常好。你的投资者会对你的下一轮融资感到满意并兴奋。然而，你还没有完成。在下一节中，我们将讨论当你无法将
    URL 与组件匹配时应该做什么。
- en: '|  |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Adding more links**'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加更多链接**'
- en: 'Try finding some other areas in the app that might make for good Link candidates
    and use the Link component to turn them into links. *Hint*: How will users get
    back to the home page after navigating to an individual post? As you go through,
    try to think about the user’s experience as they move around the application.
    What would make sense to them? Which ones did you turn into Links? Are there cases
    where you turned things into Links that weren’t already anchor tags? Check out
    the single post page in the application source code to see an example of adding
    a simple back button.'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在应用程序中找到可能成为良好链接候选者的其他区域，并使用链接组件将它们转换为链接。**提示**：用户在导航到单个帖子后如何返回主页？随着你继续前进，试着考虑用户在应用程序中移动时的用户体验。对他们来说什么是有意义的？你将哪些转换为链接？有没有将某些内容转换为链接，而这些内容原本不是锚点标签的情况？查看应用程序源代码中的单个帖子页面，以查看添加简单返回按钮的示例。
- en: '|  |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1.3\. Creating a <NotFound/> component
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 创建<NotFound/>组件
- en: Try navigating to `/oops` in the Letters app and see what happens. Nothing?
    Yep, that’s what should happen based on your code, but it isn’t what you want
    for users. Right now, your Router component doesn’t handle any “not found” or
    “catch-all” routes. You want to be kind to your users and assume that at some
    point they (or you) might make a mistake and try to navigate to a route that doesn’t
    exist in your app. To address that, you’ll create a simple NotFound component
    and configure it when creating an instance of your Router. The following listing
    shows how to create the NotFound component.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在Letters应用程序中导航到`/oops`，看看会发生什么。什么都没有？是的，根据你的代码，应该是这样，但这不是你希望用户看到的结果。目前，你的Router组件不处理任何“未找到”或“通配符”路由。你希望对用户友好，并假设他们（或你）可能在某个时候犯错并尝试导航到应用程序中不存在的路由。为了解决这个问题，你将创建一个简单的NotFound组件，并在创建Router实例时进行配置。以下列表显示了如何创建NotFound组件。
- en: Listing 8.9\. Creating the NotFound component (src/pages/404.js)
  id: totrans-1116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9\. 创建NotFound组件（src/pages/404.js）
- en: '[PRE89]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* Import Link component you created so users can get back to home page**'
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你创建的链接组件，以便用户可以返回主页**'
- en: '***2* No need for component state, so create a stateless functional component**'
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不需要组件状态，因此创建一个无状态函数组件**'
- en: '***3* Use Link component to let users go back to home page**'
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用链接组件让用户返回主页**'
- en: 'Now that the NotFound component exists, you need to integrate it into your
    Router configuration. You may be wondering how you’re going to tell the Router
    that it should send users to the NotFound component. The answer is to use the
    `*` character when configuring a router. That character says “match anything,”
    and if you put it at the end of your configuration, any routes that haven’t been
    matched to anything else will go there. Be sure to note that the order here matters:
    if you put the catch-all route too high up, it’ll match anything and not work
    like you’d want it to. The following listing shows how to configure more routes
    for your router.'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在NotFound组件已经存在，你需要将其集成到你的路由配置中。你可能想知道你将如何告诉路由器它应该将用户发送到NotFound组件。答案是，在配置路由时使用`*`字符。该字符表示“匹配任何内容”，如果你将其放在配置的末尾，任何未匹配到其他内容的路由都将被发送到那里。务必注意这里的顺序：如果你将通配符路由放置得太高，它将匹配任何内容，而不是你想要的方式。以下列表显示了如何为你的路由器配置更多路由。
- en: Listing 8.10\. Adding individual posts to the router (src/index.js)
  id: totrans-1122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.10\. 将单个帖子添加到路由器（src/index.js）
- en: '[PRE90]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* Import the NotFound component.**'
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入NotFound组件。**'
- en: '***2* Set up route for NotFound component so it serves as a catch-all route**'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为NotFound组件设置路由，使其作为通配符路由**'
- en: 8.2\. Integrating Firebase
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 集成Firebase
- en: 'With your router fully built and functioning, there’s one more area we want
    to tackle in this chapter that we couldn’t have before: enabling user login and
    authentication. You’ll do this using the popular and easy-to-use “back-end as
    a service” platform Firebase ([https://firebase.google.com](https://firebase.google.com)).
    Firebase offers services that abstract away or take the place of a back-end API
    that handles user data, authentication, and other concerns. For our purposes,
    you can think of it as a drop-in replacement for a back-end API.'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的路由器完全构建并运行之后，我们想要在本章中解决的一个新领域是：启用用户登录和身份验证。你将使用流行的易于使用的“后端即服务”平台Firebase
    ([https://firebase.google.com](https://firebase.google.com)) 来完成这项工作。Firebase提供的服务可以抽象或取代处理用户数据、身份验证和其他关注点的后端API。就我们的目的而言，你可以将其视为后端API的即插即用替代品。
- en: You won’t be using it to completely replace the back end of your application
    (you’re still using your API server), but you will be using Firebase to handle
    user login and user management. To get started with Firebase, head to [https://firebase.google.com](https://firebase.google.com)
    and create an account if you don’t have one already. Once you’re signed up, go
    to the Firebase console at [https://console.firebase.google.com](https://console.firebase.google.com)
    and create a new project to use in Letters Social. Once you’ve done that, click
    the Add Firebase to Your Web App button to open up a modal overlay. You’ll see
    some configuration information for your app that you’ll use in just a bit. See
    [figure 8.2](kindle_split_019_split_002.xhtml#ch08fig02).
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 您不会用它来完全替换应用程序的后端（您仍在使用您的 API 服务器），但您将使用 Firebase 来处理用户登录和用户管理。要开始使用 Firebase，请访问
    [https://firebase.google.com](https://firebase.google.com)，如果您还没有账户，请创建一个账户。一旦您注册，请转到
    Firebase 控制台 [https://console.firebase.google.com](https://console.firebase.google.com)，并为
    Letters Social 创建一个新项目。一旦完成，点击“将 Firebase 添加到您的 Web 应用”按钮以打开一个模态覆盖层。您将看到一些用于您应用程序的配置信息，您将在稍后使用这些信息。请参阅[图
    8.2](kindle_split_019_split_002.xhtml#ch08fig02)。
- en: Figure 8.2\. The Firebase console. Create a new project to be used with your
    instance of the Letters Social app.
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2\. Firebase 控制台。为您的 Letters Social 应用程序实例创建一个新项目。
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig02_alt.jpg)'
- en: Once you’ve created a project and have access to your project configuration
    values, you’re ready to get started. The Firebase SDK is already installed with
    the sample application code, so you can move ahead and create a new file called
    core.js in a new backend directory inside of src (src/backend/core.js). [Listing
    8.11](kindle_split_019_split_002.xhtml#ch08ex11) shows how you’ll set up core.js
    with the values from the app configuration. I’ve included the public Firebase
    API key in the source code so you can run the app without an account, but if you
    want to replace it with your own, you can easily change the values in the config
    directory.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了项目并有权访问您的项目配置值，您就可以开始操作了。Firebase SDK 已经与示例应用程序代码一起安装，因此您可以继续操作并创建一个名为
    core.js 的新文件，位于 src 中的新后端目录内（src/backend/core.js）。[列表 8.11](kindle_split_019_split_002.xhtml#ch08ex11)
    展示了您将如何使用应用程序配置值设置 core.js。我已经在源代码中包含了公共 Firebase API 密钥，以便您可以在没有账户的情况下运行应用程序，但如果您想用自己的替换它，您可以轻松地更改配置目录中的值。
- en: Listing 8.11\. Configuring the Firebase back end (src/backend/core.js)
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 配置 Firebase 后端（src/backend/core.js）
- en: '[PRE91]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* Values are injected by Webpack—change values in config directory if you
    want to include your own**'
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 值由 Webpack 注入—如果您想包含自己的值，请在配置目录中更改值**'
- en: '***2* Initialize Firebase with your credentials.**'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用您的凭据初始化 Firebase。**'
- en: '***3* Export configured firebase instance for use elsewhere**'
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将配置好的 Firebase 实例导出以供其他地方使用**'
- en: Because you’ll be using Firebase for authentication, you’ll need to set up some
    code that will let you take advantage of that functionality. To get started, pick
    a platform to use for your authentication, as shown in [figure 8.3](kindle_split_019_split_002.xhtml#ch08fig03).
    Choosing GitHub, Facebook, Google, or Twitter will let users that already have
    one of those accounts sign in without having to manage another username/login
    combination. I suggest picking GitHub because you and most people who will see
    your app will likely have GitHub accounts, but you’re completely free to set up
    one or more of the other platforms to use. I’ll use GitHub in our examples for
    simplicity. Once you’ve decided, click the provider and follow the instructions
    to get the platform set up.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您将使用 Firebase 进行身份验证，所以您需要设置一些代码，以便您可以利用该功能。要开始，请选择用于身份验证的平台，如图 8.3 所示。[链接](https://wiki.example.org/feynmans_learning_method)。选择
    GitHub、Facebook、Google 或 Twitter 将允许已经拥有这些账户的用户无需管理另一个用户名/登录组合即可登录。我建议选择 GitHub，因为您和大多数将看到您的应用程序的人可能都有
    GitHub 账户，但您完全可以自由地设置一个或多个其他平台。为了简单起见，我将使用 GitHub 作为我们的示例。一旦您做出决定，点击提供者并按照说明设置平台。
- en: Figure 8.3\. Setting up an authentication method with Firebase. Navigate to
    the Authentication section and pick any of the social providers. Then follow the
    instructions for the social authenticator you picked and make sure Firebase has
    access to the right credentials to authenticate with your chosen platform.
  id: totrans-1138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 使用 Firebase 设置身份验证方法。导航到身份验证部分并选择任何社交提供者。然后按照您选择的社交验证器的说明操作，并确保 Firebase
    有权访问正确的凭据以与您选择的平台进行身份验证。
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-1139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig03_alt.jpg)'
- en: Once you’ve set up the platform of your choice for use with Firebase, you’ll
    need to set up some more code that will let you interact with `firebase` to perform
    user login. Firebase comes with built-in tools that let you authenticate with
    a variety of social platforms. I’ll be using GitHub, as mentioned, but you’re
    free to use whichever provider or providers you set up on your own. They all follow
    the same pattern (for example, create a provider object, set up the scope, and
    so on). You can find more about the authentication services offered by Firebase
    at [https://firebase.google.com/docs/auth/](https://firebase.google.com/docs/auth/).
    The next listing shows setting up the authentication utilities in `src/backend/auth.js`.
    You’ll create functions for getting the user and token and logging in and out.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为 Firebase 设置了所选平台，你还需要设置一些代码，以便你可以与 `firebase` 交互以执行用户登录。Firebase 内置了各种社交平台的身份验证工具。如前所述，我将使用
    GitHub，但你也可以自由使用你自行设置的任何提供者或提供者。它们都遵循相同的模式（例如，创建提供者对象，设置作用域等）。你可以在 [https://firebase.google.com/docs/auth/](https://firebase.google.com/docs/auth/)
    上找到有关 Firebase 提供的认证服务的更多信息。以下列表显示了在 `src/backend/auth.js` 中设置认证工具。
- en: Listing 8.12\. Setting up authentication tools (src/backend/auth.js)
  id: totrans-1141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. 设置认证工具（src/backend/auth.js）
- en: '[PRE92]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Import Firebase library you’ve recently configured**'
  id: totrans-1143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你最近配置的 Firebase 库**'
- en: '***2* Use Firebase to set up GitHub authentication provider**'
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 Firebase 设置 GitHub 身份验证提供者**'
- en: '***3* Create function that wraps Firebase logout method**'
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个包装 Firebase 登出方法的函数**'
- en: '***4* Create simple loginWith-Github utility that returns a Firebase authentication
    action Promise**'
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个简单的 loginWith-Github 工具，它返回一个 Firebase 身份验证操作 Promise**'
- en: '***5* Create wrapper method to get Firebase user**'
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个包装方法以获取 Firebase 用户**'
- en: '***6* You’ll need the token later, so create a method that helps you get it.**'
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 你稍后会需要这个令牌，所以创建一个帮助你获取它的方法。**'
- en: Now that we have everything set up and ready, we can create a new component
    that will handle login. Create a new file called src/pages/Login.js. Here, we’ll
    create a straightforward component that tells your user how they can log in to
    Letter Social. The following listing shows the Login page component.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，可以创建一个新的组件来处理登录。创建一个名为 src/pages/Login.js 的新文件。在这里，我们将创建一个简单的组件，告诉用户如何登录到
    Letter Social。以下列表显示了登录页面组件。
- en: Listing 8.13\. The Login component (src/pages/Login.js)
  id: totrans-1150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 登录组件（src/pages/Login.js）
- en: '[PRE93]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* Import libraries you’ll need for this component**'
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入此组件所需的库**'
- en: '***2* Create and bind login method**'
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建并绑定登录方法**'
- en: '***3* Use wrapper method you created earlier to log in with GitHub**'
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用你之前创建的包装方法使用 GitHub 登录**'
- en: '***4* Render Welcome component (included in source code) or whatever else you’d
    like**'
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 渲染欢迎组件（包含在源代码中）或你想要的任何其他组件**'
- en: '***5* Ensure login method will be called when user clicks login button**'
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 确保当用户点击登录按钮时调用登录方法**'
- en: 8.2.1\. Ensuring a user is logged in
  id: totrans-1157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 确保用户已登录
- en: Your last task is to make sure an unauthenticated user is redirected to the
    login page. For the current state of your app, it would make little difference
    whether a user is logged in or out because they can only see dummy data that isn’t
    related to anything in real life (they’ll just be happy to see all the random
    Star Wars quotes and avatars). But in a production situation, it’s likely that
    a user absolutely needs to only be able to see data if they have an account and
    are logged in. This is a basic requirement of almost all web applications, and
    though we won’t focus on security here, we do need to make sure a user can only
    see the social network if they’re logged in.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最后一个任务是确保未认证的用户被重定向到登录页面。对于你当前的应用状态，用户是否登录几乎没有区别，因为他们只能看到与现实生活中无关的虚拟数据（他们只会高兴地看到所有随机的星球大战引言和头像）。但在生产环境中，很可能用户绝对需要只能在他们有账户并登录的情况下才能看到数据。这是几乎所有网络应用的基本要求，尽管我们不会在这里关注安全性，但我们确实需要确保用户只有在登录的情况下才能看到社交网络。
- en: There are different approaches to making this functionality possible. In more
    robust and developed tools like React Router, there are *hooks* you can execute
    when a particular route is navigated to—you can check to see if the user is logged
    in and can proceed. This is only one approach, and you don’t have hooks functionality
    set up in your Router component, but you can add some logic to your main file
    (index.js) to check for a user’s presence and determine where they should be routed.
    You’ll transition to using React Router and these hooks in later chapters. You
    also need to add the Login component to your Router.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一功能有不同方法。在更健壮和成熟的工具如React Router中，当导航到特定路由时，你可以执行*钩子*——你可以检查用户是否已登录并继续。这只是其中一种方法，你的Router组件中并没有设置hooks功能，但你可以在主文件（index.js）中添加一些逻辑来检查用户的存在并确定他们应该被路由到何处。你将在后面的章节中过渡到使用React
    Router和这些钩子。你还需要将登录组件添加到你的Router中。
- en: '|  |'
  id: totrans-1160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Firebase alternatives**'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firebase替代方案**'
- en: We’re using Firebase in this book as a “back-end as a service.” That dramatically
    simplifies things for learning purposes, but it’s not necessarily how you might
    approach things on a team. Without having to go into depth, what do you think
    would take the place of Firebase for your application?
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用Firebase作为“后端即服务”。这对于学习目的来说大大简化了事情，但并不一定是团队中处理事情的方式。不深入探讨，你认为在你的应用程序中，什么会取代Firebase？
- en: '|  |'
  id: totrans-1163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When a user signs in, you want to make sure that they also get recorded with
    your API. We’re using Firebase for authentication, but you still want to store
    the user’s information so they can create posts and comments and can like posts
    (you’ll add comment and like functionality in later chapters). You’ll need to
    account for whether a user exists and, if they don’t, create them as a user in
    your system. The authentication logic you’ll build out will take all this into
    account. We’ll also slightly modify the browser history listener function so it
    can redirect people based on whether or not they’re logged in.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，你想要确保他们也通过你的API被记录下来。我们正在使用Firebase进行身份验证，但你仍然想要存储用户信息，以便他们可以创建帖子、发表评论，并可以点赞（你将在后面的章节中添加评论和点赞功能）。你需要考虑用户是否存在，如果他们不存在，就在你的系统中创建一个用户。你将要构建的认证逻辑将考虑所有这些因素。我们还将稍微修改浏览器历史监听器函数，以便根据用户是否登录来重定向用户。
- en: The following listing shows how to add this logic and modify the history listener
    in the main index file for your app (src/index.js).
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何在主索引文件（src/index.js）中添加此逻辑并修改历史监听器。
- en: Listing 8.14\. Adding the Login container to the Router (src/index.js)
  id: totrans-1166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.14\. 将登录容器添加到路由器（src/index.js）
- en: '[PRE94]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* Add Login page to your routes**'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将登录页面添加到你的路由中**'
- en: '***2* Keep track of user and update state object you created accordingly**'
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 跟踪用户并相应地更新你创建的状态对象**'
- en: '***3* In your history listener, check to see first if there’s a Firebase user**'
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在你的历史监听器中，首先检查是否有Firebase用户**'
- en: '***4* Use async function to respond to Firebase user state changing**'
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用异步函数响应Firebase用户状态变化**'
- en: '***5* If no user, update state and render app appropriately**'
  id: totrans-1172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果没有用户，更新状态并适当地渲染应用**'
- en: '***6* If there is a user, get their token using await and Firebase utility
    we created**'
  id: totrans-1173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果有用户，使用await和Firebase工具获取他们的令牌**'
- en: '***7* Try to load user from our API**'
  id: totrans-1174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 尝试从我们的API加载用户**'
- en: '***8* Declare a user variable to assign to**'
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 声明一个用户变量进行分配**'
- en: '***9* If no user, you need to sign them up**'
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 如果没有用户，你需要注册他们**'
- en: '***10* Create user payload your API will understand**'
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 创建你的API能理解的用户负载**'
- en: '***11* Send request to API and use the response**'
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 向API发送请求并使用响应**'
- en: '***12* If user already exists, use them for rendering app**'
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 如果用户已存在，使用他们渲染应用**'
- en: '***13* Push user to the main page**'
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13* 将用户推送到主页**'
- en: '***14* Update app state**'
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***14* 更新应用状态**'
- en: '***15* Render app with new state**'
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***15* 使用新状态渲染应用**'
- en: Now your users can sign in and have an account created for them on the fly.
    You should update the navbar so they know how to do that and so they can see the
    logout option, too. You may remember that you were passing in a `user` prop to
    the Navbar component earlier in the chapter even though it didn’t exist yet. Now
    that it does, the Navbar component can conditionally show different views based
    on their authentication state. The following listing shows how to make these changes
    to the Navbar component.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以登录，并且可以即时为他们创建账户。你应该更新导航栏，让他们知道如何做，并且他们也可以看到注销选项。你可能记得，在本章的早期阶段，你甚至还没有存在时，就已经向
    Navbar 组件传递了一个 `user` prop。现在它存在了，Navbar 组件可以根据他们的认证状态有条件地显示不同的视图。以下列表显示了如何对 Navbar
    组件进行这些更改。
- en: Listing 8.15\. Updating the Navbar component with (src/components/nav/navbar.js)
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 使用（src/components/nav/navbar.js）更新 Navbar 组件
- en: '[PRE95]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* If user is authenticated, show info about their profile (name, profile
    picture)**'
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果用户已认证，显示他们的个人资料信息（姓名、个人照片）**'
- en: '***2* Give user option to log out (using Firebase utility we created earlier)**'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提供用户注销选项（使用我们之前创建的 Firebase 工具）**'
- en: '***3* If they’re not logged in, show a helpful link.**'
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果他们未登录，显示一个有用的链接。**'
- en: '***4* Declare proptypes**'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明 prop 类型**'
- en: '***5* Export component for use**'
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导出组件以供使用**'
- en: 8.3\. Summary
  id: totrans-1191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 摘要
- en: 'In this chapter, you started using the Router component you built, added a
    few more routing-related components to your application, did some refactoring,
    and added user authentication with Firebase. Here are some things to take away:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始使用你构建的 Router 组件，向你的应用程序添加了一些更多与路由相关的组件，进行了一些重构，并使用 Firebase 添加了用户认证。以下是一些需要记住的事情：
- en: Firebase is a “back-end-as-a-service” tool that lets you authenticate users,
    store data, and more. It can get you pretty far without having to do any back-end
    development and is a great place to start for many hobby projects.
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase 是一个“后端即服务”工具，它允许你验证用户、存储数据等。它可以在不进行任何后端开发的情况下让你走得很远，并且对于许多业余项目来说是一个很好的起点。
- en: You can integrate browser history APIs with your router. This also enables you
    to create Link components that don’t require a full page reload in lieu of regular
    anchor tags.
  id: totrans-1194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将浏览器历史 API 与你的路由器集成。这也使你能够创建不需要完整页面重新加载的 Link 组件，而不是常规的锚点标签。
- en: Firebase can handle authentication and user session data for you. We’ll explore
    more advanced methods of handling changing state like this in later chapters when
    we look at Flux, Redux, and even using Firebase on the server for server-side
    rendering.
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase 可以为你处理认证和用户会话数据。当我们在后续章节中探讨 Flux、Redux 以及在服务器端渲染中使用 Firebase 时，我们将探索处理此类变化状态的高级方法。
- en: Testing is an incredibly important part of developing good software. In the
    next chapter, we’ll look at testing your React component using Jest and Enzyme.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发良好软件的一个极其重要的部分。在下一章中，我们将探讨如何使用 Jest 和 Enzyme 测试你的 React 组件。
- en: Chapter 9\. Testing React components
  id: totrans-1197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章\. 测试 React 组件
- en: '*This chapter covers*'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Testing front-end applications
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试前端应用程序
- en: Setting up testing for React
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 React 的测试
- en: Testing React components
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 React 组件
- en: Setting up test coverage
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试覆盖率
- en: 'In the last chapter, you added some significant functionality to your application.
    It now has routing and user state, and you’ve broken it up into smaller pieces.
    You even added some basic authentication so users could log in using their GitHub
    profile. Your application is starting to look more robust, even if it’s probably
    not going to worry anyone at Facebook or Twitter. You can do lots more with React
    than you could when we first started. But as we’ve focused on learning the basics,
    we’ve omitted an important part of the development process: *testing*.'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你向你的应用程序添加了一些重要的功能。现在它有了路由和用户状态，并且你将其分解成更小的部分。你甚至添加了一些基本的认证，以便用户可以使用他们的
    GitHub 个人资料登录。尽管你的应用程序可能不会让 Facebook 或 Twitter 的人担心，但它开始看起来更健壮了。你可以用 React 做的事情比我们最初开始时多得多。但因为我们专注于学习基础知识，所以我们省略了开发过程中的一个重要部分：*测试*。
- en: I didn’t cover testing from the start to spare you the mental overload of learning
    React and testing fundamentals at the same time. But that doesn’t mean it’s an
    unimportant part of either learning or web development. In this chapter, we’ll
    focus on testing because it’s a fundamental part of developing high-quality software
    solutions. Instead of demonstrating tests for every single one of your components,
    though, we’ll go through a representative sample so you’ll understand the important
    principles at work and be able to write your own tests.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有从一开始就介绍测试，以避免你在学习React和测试基础的同时承受心理负担。但这并不意味着它是学习或Web开发中不重要的一部分。在本章中，我们将专注于测试，因为它高质量软件开发解决方案的基本组成部分。然而，我们不会为每个组件演示测试，而是通过一个代表性样本，让你理解正在工作的基本原则，并能够编写自己的测试。
- en: By the end of this chapter, you’ll understand some of the basic principles of
    testing web applications. You’ll also have set up tests and a test runner, worked
    with Jest, Enzyme, and the React test renderer, and learned to use and understand
    test coverage tools. You’ll be equipped to start testing your applications, which
    will add another level of confidence to your React development skills.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解一些测试Web应用程序的基本原则。你还将设置测试和测试运行器，与Jest、Enzyme和React测试渲染器一起工作，并学会使用和理解测试覆盖率工具。你将准备好开始测试你的应用程序，这将为你React开发技能增加另一个信心层次。
- en: '|  |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**How do I get the code for this chapter?**'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapters 7](kindle_split_018_split_000.xhtml#ch07)
    and [8](kindle_split_019_split_000.xhtml#ch08) (if you followed along and built
    out the examples yourself) or check out the chapter-specific branch (chapter-9).
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以通过访问GitHub仓库[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)来检查本章的源代码。如果你想从一张白纸开始学习本章，并跟随操作，你可以使用你现有的代码从[第7章](kindle_split_018_split_000.xhtml#ch07)和[第8章](kindle_split_019_split_000.xhtml#ch08)（如果你跟随并自己构建了示例）或检出特定章节的分支（chapter-9）。
- en: Remember, each branch corresponds to the code at the end of the chapter (for
    example, the branch chapter-7 corresponds to the code as it will be at the end
    of this chapter). You can execute one of the following terminal commands in the
    directory of your choice to get the code for the current chapter.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应于章节末尾的代码（例如，分支chapter-7对应于本章末尾的代码）。你可以在你选择的目录中执行以下终端命令之一来获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本就没有仓库，请输入以下内容：
- en: '[PRE96]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If you already have the repository cloned:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库：
- en: '[PRE97]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从另一章来到这里，所以始终确保你已经安装了所有正确的依赖项：
- en: '[PRE98]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '|  |'
  id: totrans-1216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Testing in software development is the process of validating assumptions. For
    example, say you’re building an application (like Medium, Ghost, or WordPress)
    that lets users write and create blog posts. Users pay a monthly fee and get the
    hosting and the tools to run their own blog. When creating the front-end of the
    application, there are several key things it *must* do (among others), including
    correctly displaying those posts and letting users edit them.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的测试是验证假设的过程。例如，假设你正在构建一个应用程序（如Medium、Ghost或WordPress），允许用户撰写和创建博客文章。用户支付月费，并获得托管和运行自己博客的工具。在创建应用程序的前端时，它必须完成几个关键任务（以及其他任务），包括正确显示这些文章并允许用户编辑它们。
- en: How can you be sure your app is doing what it needs to do? You can try it out
    yourself and see if it works. Click around, edit things, and use the application
    in as many ways as you can think of. This manual process works reasonably well
    and is a first line of defense against bugs and regressions. You should always
    take care to inspect what you’re working on, but you can’t test things quickly
    and or in a perfectly consistent manner.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何确保你的应用程序正在做它需要做的事情？你可以亲自尝试并看看它是否工作。四处点击，编辑内容，尽可能多地以你想到的方式使用应用程序。这种手动过程效果相当不错，是防止错误和回归的第一道防线。你应该始终注意检查你正在工作的内容，但你无法快速或以完全一致的方式测试事物。
- en: Also, as your application grows, the number of situations and features you’ll
    need to manually test increases at an incredible rate. I’ve worked on applications
    with thousands of tests, but there are many applications where that number would
    be easily dwarfed. The React library itself has 4,855 tests at the time of writing.
    There’s no chance someone wanting to test React would be able to validate by hand
    the assumptions involved in all those tests.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着你的应用程序增长，你需要手动测试的情况和功能数量将以惊人的速度增加。我参与过拥有数千个测试用例的应用程序，但还有很多应用程序，其测试用例数量会被轻易超越。在撰写本文时，React
    库本身就有 4,855 个测试用例。想要测试 React 的人几乎不可能手动验证所有这些测试用例中涉及的假设。
- en: 'Fortunately, instead of testing everything by hand, you can use software to
    test software. Computers excel where we fail in at least two important areas:
    speed and consistency. We can use software to test our code in ways that we never
    could by hand, even with an army of people trying things out in every possible
    way. You may be thinking, “My project is small and really straightforward—there’s
    not much that could go wrong.” But even as great as your coding skills may be,
    bugs are inevitable. Your apps will break and work in unpredictable ways when
    you change things (and sometimes even when you don’t).'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必手动测试一切，你可以使用软件来测试软件。计算机在至少两个重要领域胜过我们：速度和一致性。我们可以使用软件以我们无法手动完成的方式测试我们的代码，即使有成千上万的人以各种可能的方式尝试。你可能认为，“我的项目很小，非常直接——不太可能出错。”但即使你的编码技能再高，错误是不可避免的。当你改变某些内容时（有时甚至没有改变），你的应用程序会崩溃并以不可预测的方式运行。
- en: But instead of despairing about the inevitability of bugs, we can accept that
    they’ll happen and take steps to minimize their impact and frequency. That’s where
    testing comes in. You may have some general idea about what testing is, but to
    get started we’ll need to explore some different types of testing. Bear in mind
    that the world of testing is huge, and I can’t cover even close to everything
    here. I won’t be doing any in-depth coverage of testing as a domain. I also won’t
    be deeply covering several types of testing, including integration testing, regression
    testing, testing automation, and others. But by the end of the chapter, you should
    be familiar enough to get started testing React components in a few different
    ways.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不必对错误的不可避免性感到绝望，我们可以接受它们会发生，并采取措施来最小化它们的影响和频率。这就是测试的用武之地。你可能对测试有一些大致的了解，但为了开始，我们需要探索一些不同的测试类型。请记住，测试的世界非常庞大，我无法在这里涵盖所有内容。我不会深入探讨测试作为一个领域。我也不会深入探讨几种测试类型，包括集成测试、回归测试、测试自动化等。但到本章结束时，你应该足够熟悉，可以以几种不同的方式开始测试
    React 组件。
- en: 9.1\. Types of testing
  id: totrans-1222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 测试类型
- en: 'As I said, testing software is the process of using software to validate your
    assumptions. Because you’re using software to test software, you’ll ultimately
    be using the same primitives you use when building software: Booleans, numbers,
    strings, functions, objects, and the like. It’s important to remember that there’s
    no magic here—just more code.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，测试软件是使用软件来验证你的假设的过程。因为你使用软件来测试软件，你最终会使用在构建软件时使用的相同基本元素：布尔值、数字、字符串、函数、对象等。重要的是要记住，这里没有魔法——只是更多的代码。
- en: There are different types of testing, and you’ll use a few to test your React
    application. They encompass different aspects of an application, and when used
    together and in the right proportions, they should give you a significant degree
    of confidence in your application. Different types of tests address different
    parts and scopes of an application. A well-tested app will test the individual
    units of functionality that make up the basic parts of the app. It will also test
    the collections of these units of functionality and, at the highest level, the
    points at which everything comes together (such as the user interface).
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有多种类型，你将使用其中几种来测试你的 React 应用程序。它们涵盖了应用程序的不同方面，当共同使用并保持适当的比例时，它们应该能给你对应用程序的信心带来显著提升。不同类型的测试针对应用程序的不同部分和范围。一个经过良好测试的应用程序将测试构成应用程序基本部分的各个功能单元。它还将测试这些功能单元的集合，在最高层次上，测试所有事物汇聚的点（例如用户界面）。
- en: 'Here are a few types of testing:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些测试类型：
- en: '***Unit*—** Unit tests focus on individual units of functionality. For example,
    say you have a utility method for fetching new posts from the server. A unit test
    will focus only on that one function. It doesn’t care about anything else. Like
    components, these tests allow for refactoring and promote modularity.'
  id: totrans-1226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单元*—** 单元测试关注功能单元。例如，假设你有一个从服务器获取新帖子的实用方法。单元测试将只关注那个函数。它不关心其他任何事情。像组件一样，这些测试允许重构并促进模块化。'
- en: '***Service*—** Service tests focus on bundles of functionality. This part of
    the “testing spectrum” can include a variety of granularities and focuses. The
    point, though, is that you’re testing things that aren’t at the highest level
    (see integration tests, next) or the lowest levels of functionality. An example
    of a service test might be something like a tool that uses several units of functionality
    but is not itself at the level of an integration test.'
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***服务*—** 服务测试关注功能集合。这部分“测试光谱”可以包括各种粒度和焦点。然而，重点是你在测试的不是最高级别（参见下一节的集成测试）或功能最低级别的东西。一个服务测试的例子可能是一个使用几个功能单元但本身不在集成测试级别的工具。'
- en: '***Integration*—** Integration tests focus on an even higher level of testing:
    the integration of various parts of an application. They test the way that services
    and lower-level functionality come together. Typically, these tests test an application
    through its user interface, not through the individual code behind the user interface.
    These tests may simulate clicks, user input, and other interactions that drive
    the application.'
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***集成*—** 集成测试关注更高的测试级别：应用程序各个部分的集成。它们测试服务和较低级别功能如何结合在一起。通常，这些测试通过用户界面测试应用程序，而不是通过用户界面背后的单个代码。这些测试可能模拟点击、用户输入和其他驱动应用程序的交互。'
- en: You may be wondering what these tests will look like in code; we’ll get into
    that shortly, but first we need to talk about how these tests work together in
    the overall testing approach. If you’ve done testing before, you may have heard
    of the *testing pyramid*. This pyramid, illustrated in [figure 9.1](kindle_split_020_split_001.xhtml#ch09fig01),
    generally refers to the proportion of different types of tests you should write.
    In this chapter, you’ll only be writing unit tests for your components.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这些测试在代码中会是什么样子；我们很快就会讨论这个问题，但首先我们需要谈谈这些测试如何在整体测试方法中协同工作。如果你之前做过测试，你可能听说过*测试金字塔*。这个金字塔，如图[图9.1](kindle_split_020_split_001.xhtml#ch09fig01)所示，通常指的是你应该编写不同类型测试的比例。在本章中，你将只为你的组件编写单元测试。
- en: Figure 9.1\. The testing pyramid is a way of guiding how many and which types
    of tests you write as you test your applications. Notice that certain types of
    tests take longer and are thus more “expensive” in terms of time (and therefore
    also financial cost).
  id: totrans-1230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1。测试金字塔是一种指导你在测试应用程序时编写多少以及哪些类型测试的方法。请注意，某些类型的测试需要更长的时间，因此在时间（以及因此财务成本）方面更为“昂贵”。
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1](Images/09fig01_alt.jpg)'
- en: 9.1.1\. Why test?
  id: totrans-1232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1。为什么要测试？
- en: There are some software development paradigms where testing is a “first-class
    citizen” of the entire development process. That means testing is important, is
    considered at the beginning and throughout the development process, and usually
    plays a role in determining when something is considered complete. Granted, the
    consensus is that testing is a good thing for software development, but there
    are certain paradigms where it takes on a central role. For example, you may have
    heard of *test-driven development* (TDD). When practicing TDD, as its name suggests,
    the very process of writing software is driven by testing. When working, a developer
    will usually write a *failing* test (a test that makes assertions that haven’t
    yet been met), write just enough code to get it to pass, refactor any duplication,
    and then move on to the next feature, repeating the process.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些软件开发范例中，测试是整个开发过程中的“一等公民”。这意味着测试非常重要，在开发过程的开始和整个过程中都被考虑，通常在确定何时认为某项工作已完成时发挥作用。诚然，共识是测试对软件开发来说是一件好事，但某些范例中，测试扮演了核心角色。例如，你可能听说过*测试驱动开发*（TDD）。在实践TDD时，正如其名所示，编写软件的过程是由测试驱动的。在工作时，开发者通常会编写一个*失败的测试*（一个尚未满足断言的测试），编写足够的代码使其通过，重构任何重复的部分，然后继续下一个功能，重复这个过程。
- en: 'Although you don’t have to be a strict practitioner of TDD to write great software,
    consider some of the benefits before moving on. If you’re already wise to the
    upsides of testing, feel free to move on to the next section where we get started
    with testing in React. But I want to ask an important question: why do we test
    at all?'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不必是TDD的严格实践者才能编写出优秀的软件，但在继续前进之前，考虑一下测试的一些好处。如果你已经了解了测试的优势，请随意进入下一节，我们将开始学习在React中进行测试。但我想问一个重要的问题：我们为什么要进行测试？
- en: First and foremost, we want to write software that works. There are so many
    interconnected parts of modern software that it would be foolish to assume that
    every part of the software stack will reliably work all the time. Things will
    break, and it’s better to assume things will fail than to assume they’ll work
    all the time. We can do our part to minimize the ways that our own software can
    break by testing our assumptions. Testing forces you to visit (or revisit) your
    assumptions about your software. You walk it through the different cases it can
    handle and ensure that it handles them all appropriately.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望编写出能够正常工作的软件。现代软件有许多相互关联的部分，假设软件堆栈的每个部分都会始终可靠地工作是不明智的。事情会出错，与其假设它们会一直工作，不如假设它们会失败。我们可以通过测试我们的假设来尽我们的一份力，以减少我们的软件可能出错的方式。测试迫使你审视（或重新审视）你对软件的假设。你通过不同的案例来测试它，并确保它能够适当地处理所有这些案例。
- en: Secondly, the process of testing your software tends to help you write better
    code. Going through the process of writing out your tests encourages you to think
    through what your code does, especially if you do it beforehand (as in TDD). Though
    it’s far less preferable, you can write tests after the fact, too, which is better
    than having no tests at all. Going through the process of testing will help you
    better understand the code you write and will validate assumptions you and others
    make about how things work.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，测试你的软件的过程往往有助于你编写更好的代码。通过编写测试的过程会促使你思考你的代码做了什么，尤其是如果你在编写代码之前就做这件事（如在TDD中）。尽管这远不如前者可取，你也可以事后编写测试，这比完全没有测试要好。通过测试的过程将帮助你更好地理解你编写的代码，并验证你和其他人对事物工作方式的假设。
- en: Third, integrating testing into your software development workflow means you
    can release code more frequently. You may have heard people in the tech industry
    mention “shipping often” before. That usually means releasing software incrementally
    and frequently. In the past, companies tended to only release software after an
    extensive process and only several times a year (or at least relatively infrequently).
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，将测试集成到你的软件开发工作流程中意味着你可以更频繁地发布代码。你可能之前在技术行业的人士中听说过“频繁发布”这个词。这通常意味着软件的增量发布和频繁发布。在过去，公司倾向于在经过广泛的过程后仅发布软件，而且一年中只有几次（或者至少相对较少）。
- en: 'Thinking has changed today, and people have realized that incremental iteration
    leads to generally better results for software: you can get feedback from users
    and others on it sooner, experiment more easily, and more. The confidence you
    can have in a well-tested app is a key part of this process. Using *continuous
    integration* (CI) or *continuous deployment* tools like Circle CI ([https://circleci.com](https://circleci.com)),
    Travis CI ([https://travis-ci.org](https://travis-ci.org)), or others, you can
    make testing part of the deployment process for your software. The idea is this:
    *if the tests pass, it gets deployed*. These tools usually run your tests in a
    pristine environment and, if they pass, send the code off to whatever system runs
    your application. [Figure 9.2](kindle_split_020_split_001.xhtml#ch09fig02) shows
    the process that the Letters Social app uses to get tested and deployed.'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，人们的想法已经改变，他们已经意识到增量迭代通常会使软件的结果更好：你可以更快地从用户和其他人那里获得反馈，更容易地进行实验，等等。对经过良好测试的应用程序的信心是这个过程的关键部分。使用*持续集成*（CI）或*持续部署*工具，如Circle
    CI ([https://circleci.com](https://circleci.com))、Travis CI ([https://travis-ci.org](https://travis-ci.org))或其他工具，你可以将测试作为软件部署过程的一部分。其理念是这样的：*如果测试通过，它就会被部署*。这些工具通常在一个干净的环境中运行你的测试，如果测试通过，就会将代码发送到运行你的应用程序的任何系统。[图9.2](kindle_split_020_split_001.xhtml#ch09fig02)展示了Letters
    Social应用用于测试和部署的过程。
- en: Figure 9.2\. The Letters Social deploy pipeline. A CI build process is triggered
    when I (or anyone who contributes to the repository) *push* code. The CI provider
    (Circle, in this case) uses Docker containers to run your tests quickly and reliably.
    If the tests pass, the code will be deployed to whatever service you use to run
    your code. In our case, that’s Now.
  id: totrans-1239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2. 社交信件部署流程。当我（或任何贡献于该仓库的人）*推送*代码时，会触发 CI 构建。CI 提供商（在本例中为 Circle）使用 Docker
    容器快速且可靠地运行你的测试。如果测试通过，代码将被部署到运行你的代码所使用的任何服务。在我们的例子中，那就是 Now。
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-1240
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2. 社交信件部署流程](Images/09fig02_alt.jpg)'
- en: Finally, tests also help you when going back and refactoring your code or moving
    it around. Say, for example, your requirements change, and you need to move some
    components around. If you’ve kept your components modular and they have good tests,
    moving them should be easy. Untested code can be moved around, of course, but
    you have much less of a firm idea of whether it broke other parts of your system
    than you do when your code is tested.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试在你回过头来重构代码或移动代码时也会帮助你。比如说，如果你的需求改变了，你需要移动一些组件。如果你保持了组件的模块化并且它们有良好的测试，移动它们应该很容易。当然，未测试的代码也可以移动，但当你测试代码时，你对系统其他部分是否损坏的把握比没有测试时要小得多。
- en: 'There’s more to be said about the benefits and theory of testing in software,
    but it’s beyond the scope of this book. If you want to learn more, I recommend
    checking out *The Art of Unit Testing*, *Second Edition* (Manning Publications,
    2013) by Roy Osherove and *Growing Object-Oriented Software: Guided by Tests*
    by Nat Pryce and Steve Freeman (Addison-Wesley, 2009).'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件测试的好处和理论还有更多要说的，但这超出了本书的范围。如果你想了解更多，我推荐阅读 Roy Osherove 的 *《单元测试的艺术》（第二版）*（Manning
    Publications，2013）和 Nat Pryce 及 Steve Freeman 的 *《通过测试指导面向对象软件增长》*（Addison-Wesley，2009）。
- en: 9.2\. Testing React components with Jest, Enzyme, and React-test-renderer
  id: totrans-1243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 使用 Jest、Enzyme 和 React-test-renderer 测试 React 组件
- en: Testing software is just more software, made from the same primitives and basic
    elements that your normal programs are, though people have developed special tools
    to aid in the testing process. You could try to create the necessary tools to
    run all your tests, but the open source community has already put an incredible
    amount of work into a huge number of powerful tools—so you’ll use those instead.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件只是更多的软件，由与你的正常程序相同的原语和基本元素组成，尽管人们已经开发了特殊工具来帮助测试过程。你可以尝试创建运行所有测试所需的工具，但开源社区已经投入了大量的工作，开发出大量强大的工具——所以你会使用那些工具。
- en: 'You’ll need a few types of libraries to test your React applications:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要几种类型的库来测试你的 React 应用程序：
- en: '***Test runner*—** You’ll need something to run your tests. Most tests could
    be executed as regular JavaScript files, but you’ll want to take advantage of
    some of the added features of test runners, such as running more than one test
    at a time and reporting back error or success information in a nicer way. For
    this book, you’ll use Jest for most aspects of your testing. Jest is a testing
    library developed by engineers at Facebook. Some popular alternatives with fewer
    features built in that you might consider include Mocha ([https://mochajs.org](https://mochajs.org))
    and Jasmine ([https://jasmine.github.io](https://jasmine.github.io)). Jest is
    often used for testing React apps, but adapters are being created for other frameworks,
    too. The source code includes a setup file (test/setup.js) that invokes the adapter
    for React.'
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***测试运行器*—** 你需要一些东西来运行你的测试。大多数测试可以作为常规 JavaScript 文件执行，但你可能想利用测试运行器的一些附加功能，例如同时运行多个测试并以更优雅的方式报告错误或成功信息。对于本书，你将使用
    Jest 来测试的大多数方面。Jest 是由 Facebook 的工程师开发的测试库。一些具有较少内置功能的流行替代品，你可能可以考虑包括 Mocha ([https://mochajs.org](https://mochajs.org))
    和 Jasmine ([https://jasmine.github.io](https://jasmine.github.io))。Jest 通常用于测试
    React 应用程序，但也在为其他框架创建适配器。源代码包括一个设置文件（test/setup.js），它调用 React 的适配器。'
- en: '***Test doubles*—** When writing tests, you want to avoid tying your tests
    to other fragile or unpredictable parts of your infrastructure as much as possible;
    other tools you rely on should be *mocked out*—replaced with a “fake” function
    that behaves in an expected way. Testing this way promotes a focus on the code
    under test and modularity because your tests aren’t tied to the exact structure
    of your code at a given time. You’ll use Jest for mocking and test doubles, but
    there are other libraries that also do this, such as Sinon ([http://sinonjs.org](http://sinonjs.org)).'
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***测试替身*—** 在编写测试时，你希望尽可能避免将你的测试与你的基础设施中其他脆弱或不可预测的部分绑定；你依赖的其他工具应该被*模拟*—用“假”函数替换，该函数以预期的行为运行。这种方式进行测试可以促进对测试代码的关注和模块化，因为你的测试不会绑定到给定时间点的代码的确切结构。你将使用Jest进行模拟和测试替身，但还有其他库也做这件事，例如Sinon
    ([http://sinonjs.org](http://sinonjs.org))。'
- en: '***Assertion libraries*—** You can use JavaScript to make assertions about
    your code (for example, does *X* equal *Y*?), but there are plenty of edge cases
    that you’ll need to account for. Developers have created solutions to make writing
    assertions about your code easier. Jest comes with assertion methods built in,
    so you’ll rely on those.'
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***断言库*—** 你可以使用JavaScript来对你的代码进行断言（例如，*X* 是否等于 *Y*？），但你需要考虑到很多边缘情况。开发者已经创建了解决方案，使编写关于你代码的断言变得更容易。Jest内置了断言方法，所以你会依赖这些方法。'
- en: '***Environment helpers*—** Running tests on code that needs to run in a browser
    environment places slightly different demands on you. The browser environment
    is unique and includes things like the DOM, user events, and other normal parts
    of web applications. These testing tools will help ensure that you can successfully
    emulate a browser environment. You’ll be using Enzyme and the React test renderer
    to aid in testing your React components. Enzyme makes testing React components
    easier. It provides a robust API that lets you query for different types of components
    and HTML elements, set and get props of components, inspect and set component
    state, and more. The React test renderer does similar things and can also generate
    snapshots of your components. We won’t go into every aspect of Enzyme or the React
    test renderer APIs, but feel free to explore more at [http://airbnb.io/enzyme](http://airbnb.io/enzyme)
    and [www.npmjs.com/package/react-test-renderer](http://www.npmjs.com/package/react-test-renderer).'
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***环境助手*—** 在需要运行在浏览器环境中的代码上运行测试，对你提出了一些略微不同的要求。浏览器环境是独特的，包括DOM、用户事件和Web应用的正常部分。这些测试工具将帮助确保你可以成功模拟浏览器环境。你将使用Enzyme和React测试渲染器来帮助测试你的React组件。Enzyme使测试React组件变得更容易。它提供了一个强大的API，让你可以查询不同类型的组件和HTML元素，设置和获取组件的props，检查和设置组件状态，等等。React测试渲染器做类似的事情，也可以生成组件的快照。我们不会深入探讨Enzyme或React测试渲染器API的每个方面，但你可以自由探索更多内容，请参阅[http://airbnb.io/enzyme](http://airbnb.io/enzyme)和[www.npmjs.com/package/react-test-renderer](http://www.npmjs.com/package/react-test-renderer)。'
- en: '***Framework-specific libraries*—** There are libraries specifically made for
    React (or other frameworks) that make writing tests for a particular framework
    easier. These abstractions are usually developed to aid in the testing of a library
    or framework and handle setting up anything needed by the framework. In React,
    almost everything is “just JavaScript,” so there’s still little “magic” to be
    seen even in these tools.'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***框架特定库*—** 有专门为React（或其他框架）制作的库，这些库使编写特定框架的测试变得更容易。这些抽象通常是为了帮助测试库或框架而开发的，并处理设置框架所需的所有内容。在React中，几乎一切都是“仅仅是JavaScript”，所以即使在这些工具中，也几乎看不到什么“魔法”。'
- en: '***Coverage tools*—** Thanks to the deterministic nature of code, people have
    figured out ways to determine which parts of your code are “covered” by tests.
    That’s great because you can get a metric that serves as a guideline in determining
    how well tested your code is. It’s no substitute for logic and basic analysis
    (100% code coverage doesn’t mean you can’t have bugs), but it can guide how you
    test your code. You’ll use Jest’s built-in coverage tool, which utilizes a popular
    tool called Istanbul ([https://github.com/gotwarlost/istanbul](https://github.com/gotwarlost/istanbul)).'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***覆盖率工具*—** 由于代码的确定性，人们已经找到了确定你的代码哪些部分被测试“覆盖”的方法。这很好，因为你可以得到一个指标，作为确定你的代码测试得有多好的指南。它不能替代逻辑和基本分析（100%的代码覆盖率并不意味着你不能有错误），但它可以指导你如何测试代码。你将使用Jest内置的覆盖率工具，该工具利用了一个流行的工具Istanbul
    ([https://github.com/gotwarlost/istanbul](https://github.com/gotwarlost/istanbul))。'
- en: Next, you’ll get started by installing the tools you’ll be using for your tests.
    If you cloned the book repository from GitHub, these tools should already be installed.
    Make sure to run `npm install` again when changing chapters to make sure you have
    all the libraries for that chapter.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将开始安装你将用于测试的工具。如果你从 GitHub 克隆了本书的仓库，这些工具应该已经安装。确保在更换章节时再次运行 `npm install`，以确保你有该章节的所有库。
- en: 9.3\. Writing your first tests
  id: totrans-1253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 编写你的第一个测试
- en: Once you’ve installed the tools you’ll need, you’re ready to start writing some
    tests. In this section, you’re going to set up commands to run your tests and
    start testing some basic React components. You’ll make assertions about your components
    and look at ways to test rendered output of components.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了你需要的工具，你就可以开始编写一些测试了。在本节中，你将设置运行测试的命令并开始测试一些基本的 React 组件。你将对组件进行断言并查看测试组件渲染输出的方法。
- en: But before diving in, I should note a few things about Jest and where the code
    for your tests will run. Jest can be configured to run in different environments
    depending on the sort of tests you’re writing. If you’re writing tests for React
    applications that run in the browser, you’ll want to tell Jest that so it can
    provide the virtual browser environment you need to properly emulate a real browser.
    Jest uses another library, `jsdom`, to accomplish that. If you’re writing tests
    for node.js applications, you don’t want the extra memory and baggage of the `jsdom`
    environment—you just want to test your server-side code. Jest is configured to
    run browser-oriented tests by default, so you don’t need to override anything.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入之前，我应该注意一些关于 Jest 以及你的测试代码将运行在哪里的事情。Jest 可以根据你编写的测试类型配置在不同的环境中运行。如果你正在编写在浏览器中运行的
    React 应用程序的测试，你将希望告诉 Jest 这样做，以便它能够提供你需要的虚拟浏览器环境来正确模拟真实浏览器。Jest 使用另一个库 `jsdom`
    来实现这一点。如果你正在编写针对 node.js 应用程序的测试，你不需要 `jsdom` 环境的额外内存和负担——你只想测试你的服务器端代码。Jest 默认配置为运行面向浏览器的测试，所以你不需要覆盖任何内容。
- en: '|  |'
  id: totrans-1256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Reviewing types of testing**'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '**审查测试类型**'
- en: There are a few different types of testing. To review, try matching the type
    with the description of the type of testing.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的测试类型。为了复习，尝试将类型与测试类型的描述相匹配。
- en: Unit
  id: totrans-1259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元
- en: Service
  id: totrans-1260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务
- en: Integration
  id: totrans-1261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 积分
- en: __ Complex, often brittle tests that take a long time to write and run. They
    test the way different systems work together at a high level. There are often
    fewer of these types of tests than others.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: __ 复杂、通常脆弱的测试，编写和运行它们需要很长时间。它们测试不同系统在高级别上如何协同工作。这类测试通常比其他类型的测试少。
- en: __ Less complex tests that test the way a particular system works, but without
    interacting with other systems.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: __ 较简单的测试，测试特定系统的工作方式，但不与其他系统交互。
- en: __ Low-level, focused tests that focus on testing small bits of functionality.
    These should be the most numerous tests in a suite.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: __ 低级、专注于测试小块功能的测试。这些应该是套件中最多的测试。
- en: '|  |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3.1\. Getting started with Jest
  id: totrans-1266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 开始使用 Jest
- en: To run your tests, as mentioned, you’ll use Jest. You can run Jest from the
    command line, and it will execute your tests, so you’re going to add a script
    to your package.json file so you can run it. The next listing shows how to add
    the custom script to your package.json. If you cloned the repository from GitHub,
    this script should already be available.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，如前所述，你将使用 Jest。你可以从命令行运行 Jest，它将执行你的测试，所以你需要在 package.json 文件中添加一个脚本来运行它。下一个列表显示了如何将自定义脚本添加到
    package.json 中。如果你从 GitHub 克隆了仓库，这个脚本应该已经可用。
- en: Listing 9.1\. Setting up a custom npm script (package.json)
  id: totrans-1268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 设置自定义 npm 脚本（package.json）
- en: '[PRE99]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '***1* Run your tests and output test coverage.**'
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 运行测试并输出测试覆盖率。**'
- en: '***2* Run the tests in watch mode.**'
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在监视模式下运行测试。**'
- en: '***3* Configure Jest; some testing helpers and stubs are included with the
    sample code.**'
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置 Jest；一些测试辅助工具和存根包含在示例代码中。**'
- en: Now that you have a command in place to run your tests (`npm test`), try it
    out. You shouldn’t get any helpful info back yet because there are no tests to
    run (Jest should warn you accordingly in your terminal). You can also run `npm
    run test:w` to run Jest in watch mode. That’s helpful when you don’t want to manually
    run your tests every time. Jest’s immersive watch mode makes it especially useful
    to work with—it will do some work to run only tests that relate to changed files.
    That’s helpful if you have a large test suite and don’t want to run every test
    every time. You can also provide regex patterns or search by text string to run
    only particular tests.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个命令来运行你的测试（`npm test`），试试看。你还不应该得到任何有用的信息，因为还没有测试可以运行（Jest 应该在你的终端中相应地警告你）。你也可以运行
    `npm run test:w` 来在监视模式下运行 Jest。当你不想每次都手动运行测试时，这很有帮助。Jest 的沉浸式监视模式使其特别有用——它将只运行与更改的文件相关的测试。如果你有一个大的测试套件并且不想每次都运行每个测试，这很有帮助。你还可以提供正则表达式模式或通过文本字符串搜索来运行特定的测试。
- en: '|  |'
  id: totrans-1274
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Tooling matters**'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具很重要**'
- en: Testing libraries and even testing as a whole sometimes get last consideration
    when it comes to evaluating libraries. That’s unfortunate for at least two reasons.
    First, unusable testing libraries can make it more difficult for teams to buy
    into testing their code, potentially causing them to forgo it altogether. That,
    in turn, generally results in code that’s harder to maintain, less stable, and
    more difficult to work with overall.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估库时，测试库甚至整个测试有时会被放在最后考虑。这至少有两个不幸的原因。首先，不可用的测试库可能会使团队更难接受测试他们的代码，这可能导致他们完全放弃测试。反过来，这通常会导致代码更难以维护、更不稳定，并且整体上更难以工作。
- en: Another downside is that if you or your team spends a lot of time writing tests,
    your tools can have a substantial impact on your time. That can quickly translate
    to money lost by the business because its engineers are taking longer to do the
    work they need to do. I’ve seen both results firsthand. If testing wasn’t considered
    a top priority from the beginning, it became more and more difficult over time
    and was treated as a “one day” kind of thing. The result was code that could be
    more difficult to change with confidence because assumptions about functionality
    were no longer backed by tests.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，如果你或你的团队花费大量时间编写测试，你的工具可能会对你的时间产生重大影响。这可能会迅速转化为业务因工程师完成工作所需时间更长而损失的钱。我亲眼见证了这两种结果。如果测试从一开始就没有被视为首要任务，那么随着时间的推移，它变得越来越困难，并被视为“某天”的事情。结果是代码可能更难以有信心地进行更改，因为关于功能性的假设不再由测试支持。
- en: Another reason it pays to treat your testing tools as important is that if you
    do test your code, a significant time investment will be involved. If you have
    flaky tests or a testing setup that takes a long time to run, you can end up losing
    large chunks of time on a daily basis. There’s no magic solution to this problem,
    but treating your testing tools and setup as first-class issues will often help
    you greatly in the long run.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是将你的测试工具视为重要的事情是，如果你确实测试了你的代码，这将涉及大量的时间投资。如果你有不可靠的测试或测试设置需要很长时间才能运行，你可能会在每天的基础上失去大量时间。这个问题没有神奇的解决方案，但将你的测试工具和设置视为一等事项通常会从长远来看极大地帮助你。
- en: '|  |'
  id: totrans-1279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3.2\. Testing a stateless functional component
  id: totrans-1280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 测试无状态功能组件
- en: Time to get started writing some tests. First, we’ll focus on a relatively straightforward
    example of testing a component. You’re going to test the Content component. It
    doesn’t do much; it just handles rendering a paragraph with content inside of
    it. The next listing shows the structure of the component.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编写一些测试了。首先，我们将关注一个相对简单的组件测试示例。你将测试内容组件。它并不做什么；它只是处理渲染包含内容的段落。下一个列表显示了组件的结构。
- en: Listing 9.2\. Content component (src/components/post/Content.test.js)
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 内容组件（src/components/post/Content.test.js）
- en: '[PRE100]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1* Component takes in post props object and uses content property of post
    to render paragraph element**'
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组件接收帖子属性对象并使用帖子的内容属性来渲染段落元素**'
- en: '***2* It assigns content class to paragraph**'
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为段落分配内容类别**'
- en: '***3* Inner content of paragraph element is content from post**'
  id: totrans-1286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 段落元素的内部内容是帖子内容**'
- en: '***4* Component is exported—important because you’ll need to import component
    in your tests**'
  id: totrans-1287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 组件已导出——这很重要，因为你在测试中需要导入组件**'
- en: One of the first things you can do when starting to write tests is to think
    about what assumptions you want to validate. That is, once all the tests pass,
    they should confirm certain things to you and act as a sort of guarantee. In fact,
    one of my favorite things about tests is that I rely on them to fail when I’m
    making changes to a particular feature or part of a system. They back up my assumption
    that the changes I made represent a change to the application or system. This
    makes me much more comfortable when writing my code because on the one hand I
    have a record of how things were supposed to work beforehand, and on the other
    because I can get a sense of how my changes affect the application as a whole.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写测试时，你可以做的第一件事是考虑你想要验证哪些假设。也就是说，一旦所有测试通过，它们应该向你确认某些事情，并作为一种保证。事实上，我最喜欢测试的一点是，我依赖它们在我对某个特定功能或系统的一部分进行更改时失败。这证实了我的假设，即我所做的更改代表了应用程序或系统的更改。这使得我在编写代码时感到更加舒适，因为一方面，我有关于事情应该如何工作的记录，另一方面，我可以了解我的更改对应用程序整体的影响。
- en: Let’s look at your component and think about how you might test it. There are
    a few assumptions you want to validate about this component. For one, it needs
    to render some content that got passed in as a prop. It also needs to assign a
    class name to a paragraph element. Aside from that, there’s not much to the component
    that you need to focus on. These things should be enough to get you started writing
    a test.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你的组件，并思考你可能会如何测试它。关于这个组件，你想要验证的一些假设。首先，它需要渲染作为 prop 传递的一些内容。它还需要将类名分配给一个段落元素。除此之外，这个组件没有太多需要你关注的地方。这些应该足以让你开始编写测试。
- en: You may notice that “React works properly” isn’t one of the things you’re trying
    to test here. We also excluded things like “A function can be executed,” “The
    JSX transpiler will work,” and some other fundamental assumptions about the technologies
    you’re using. These things are important to test, but the tests you’re writing
    could never adequately or accurately validate these assumption. These other projects
    are responsible for writing their own tests and ensuring that they work. This
    underscores the importance of choosing software that’s reliable, well-tested,
    and kept up-to-date. If you have serious doubts about React’s reliability, those
    doubts may be unfounded. Although not perfect, React is used on some of the most
    popular web apps in the world, including Facebook.com and Netflix.com, to name
    two. There are certainly bugs, but it’s highly unlikely that you’d encounter them
    in our straightforward situation.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，“React 运作正常”并不是你在这里试图测试的事情之一。我们还排除了诸如“函数可以被执行”、“JSX 编译器将正常工作”以及关于你所使用技术的某些其他基本假设。这些事情确实很重要，但你所编写的测试永远无法充分或准确地验证这些假设。这些其他项目负责编写自己的测试并确保它们能够正常工作。这强调了选择可靠、经过良好测试并保持更新的软件的重要性。如果你对
    React 的可靠性有严重的怀疑，这些怀疑可能是没有根据的。尽管并非完美，但 React 被用于世界上一些最受欢迎的 Web 应用程序中，包括 Facebook.com
    和 Netflix.com，仅举两个例子。当然，肯定存在一些错误，但你几乎不可能在我们的简单情况下遇到它们。
- en: 'You know a few things about the component you want to validate, but you could
    have also gone about this the other way if you were starting from scratch and
    had written the test first. You may have thought to yourself, “We need a component
    that displays content, has a certain type, and has a certain class name so our
    CSS works.” You may have then proceeded to write the test that would validate
    these conditions. You’re going about it the other way due to how you’ve been learning
    about React, but you can see how starting with a test can make things easy: you
    start out by having to think through and plan your component. As mentioned, test-driven
    development (TDD) is a school of thought that makes writing tests first a central
    part of software development.'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 你对想要验证的组件了解一些情况，但如果你是从零开始并且首先编写了测试，你也可以采取另一种方式。你可能这样想过：“我们需要一个显示内容的组件，具有特定的类型和类名，以便我们的
    CSS 能够正常工作。”然后你可能继续编写验证这些条件的测试。由于你学习 React 的方式，你采取了另一种方式，但你可以看到从测试开始如何使事情变得简单：你开始时必须思考并规划你的组件。如前所述，测试驱动开发（TDD）是一种思想流派，它将编写测试作为软件开发的核心部分。
- en: Let’s see how to test this component. To do that, you’ll need to write a test
    *suite*, which is a group of tests. Individual tests make *assertions* (statements
    about code that can be true or false) to validate assumptions. For example, a
    test for your component would *assert* that the right class name is set up. If
    any of your assertions fail, the test fails. That’s how you know something has
    inadvertently changed or no longer works in your app. [Listing 9.3](kindle_split_020_split_003.xhtml#ch09ex03)
    shows how to set up the skeleton of the test.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何测试这个组件。为了做到这一点，你需要编写一个测试 *套件*，它是一组测试。单个测试会做出 *断言*（关于代码的陈述，可以是真或假），以验证假设。例如，对你的组件的测试会
    *断言* 正确的类名已设置。如果你的任何断言失败，测试就会失败。这就是你知道你的应用中某些东西意外改变或不再工作的方式。[列表9.3](kindle_split_020_split_003.xhtml#ch09ex03)
    展示了如何设置测试的骨架。
- en: Notice that the file for the component ends with *.test.js*. That’s a convention
    that you can choose to follow if you like. Jest will look for files that end in
    .spec.js or .test.js and run those tests by default. If you choose to follow a
    different convention, you’ll need to explicitly tell Jest about which files you
    want to run by adding them to the command line invocation (`jest --watch ./my.cool.test.file.js`,
    for example). You’ll follow the .test.js convention for all your tests.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，组件的文件以*.test.js*结尾。这是一个你可以选择遵循的约定。Jest会寻找以.spec.js或.test.js结尾的文件，并默认运行这些测试。如果你选择遵循不同的约定，你需要明确告诉Jest你想要运行哪些文件，通过将它们添加到命令行调用中（例如，`jest
    --watch ./my.cool.test.file.js`）。你将遵循.test.js约定来运行所有测试。
- en: It’s also good to note where the test files are placed. Some people choose to
    place all their tests in a “mirror” directory called test, usually located in
    the root directory of their project. For every file that gets tested, they’ll
    create a corresponding file in the test directory. That’s a fine way to structure
    things, but you can also locate your test files right next to their source files.
    You’ll go with this method, but either way is perfectly fine.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意测试文件的位置。有些人选择将所有测试放在一个名为“mirror”的目录中，通常位于项目的根目录。对于每个要测试的文件，他们会在test目录中创建一个相应的文件。这是一种很好的组织方式，但你也可以将测试文件放在它们的源文件旁边。你将采用这种方法，但两种方式都完全可行。
- en: Listing 9.3\. Test skeleton for Content component (src/components/post/Content.test.js)
  id: totrans-1295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. Content组件的测试骨架（src/components/post/Content.test.js）
- en: '[PRE101]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1* Import React.**'
  id: totrans-1297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入React。**'
- en: '***2* Import related helper methods**'
  id: totrans-1298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入相关的辅助方法**'
- en: '***3* Import component to be tested**'
  id: totrans-1299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入要测试的组件**'
- en: '***4* Jest uses Jasmine-style ([https://jasmine.github.io/](https://jasmine.github.io/))
    methods like describe to group tests.**'
  id: totrans-1300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Jest使用类似describe的Jasmine风格([https://jasmine.github.io/](https://jasmine.github.io/))方法来分组测试。**'
- en: '***5* An actual test—the it function is also provided globally by jest**'
  id: totrans-1301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 真实测试——jest也全局提供了it函数**'
- en: 'You may have noticed that there’s nothing special about the `describe` functions
    so far. They’re primarily for organization and for ensuring that you can split
    your tests into the appropriate chunks to test different parts of your code. It
    may not seem like a huge need for such a small file, but I’ve worked with test
    files that are 2,000–3,000 lines long (or more), and I can speak from experience:
    readable tests help make good tests.'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，到目前为止`describe`函数没有什么特别之处。它们主要用于组织和确保你可以将测试分割成适当的块来测试代码的不同部分。这可能看起来对于这样一个小的文件来说不是特别需要，但我处理过长达2,000-3,000行（或更多）的测试文件，我可以从经验中讲：可读的测试有助于编写好的测试。
- en: '|  |'
  id: totrans-1303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Write clean tests!**'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写干净的测试！**'
- en: Have you ever read test code that hasn’t gotten the same treatment as the code
    that it’s testing? I’ve had this happen to me more than once. It can be confusing
    or even frustrating to read through test code that isn’t clean. Tests are just
    more code, so they still need to be clean and readable, right? I’ve already mentioned
    in this chapter that testing can sometimes take second priority to writing application
    code. Test code can be treated as a task that has to be done or even a barrier
    between you and the application code, and so standards are lowered. This tendency
    can be easy to slip into, but the reality is that poorly written tests can be
    as bad as poorly written application code. Tests should serve as another form
    of documentation for your code, and one that still has to be read by developers.
    Remember that test code should still be clean code.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经阅读过那些没有得到与被测试代码相同待遇的测试代码？这种情况发生在我身上不止一次。阅读不干净的测试代码可能会让人感到困惑，甚至沮丧。测试代码只是更多的代码，它们仍然需要保持整洁和可读性，对吧？在本章中，我已经提到测试有时可能会被编写应用程序代码的优先级所压倒。测试代码可能被视为一项必须完成的任务，甚至是你与应用程序代码之间的障碍，因此标准会降低。这种倾向很容易陷入，但现实是，编写糟糕的测试代码和编写糟糕的应用程序代码一样糟糕。测试应该成为你代码的另一种文档形式，而且这种文档开发者仍然需要阅读。记住，测试代码仍然应该是干净的代码。
- en: '|  |'
  id: totrans-1306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Jest will look for files to test and then execute these different `describe`
    and `it` functions, calling the callback functions you’ve provided to them. But
    what do you need to put inside them? You need to set up *assertions*. To do that,
    you need something to assert on. This is where Enzyme comes in; it lets you create
    a testable version of your component that you can inspect and make assertions
    about. You’ll use Enzyme’s *shallow rendering*, which will create a lightweight
    version of your component that doesn’t perform full mounting or insertion into
    the DOM. You also need to provide some *mock* (fake) data for the component to
    use. The next listing shows how to add the test version of the component to your
    test suite. Before you start writing your tests, make sure to run the `npm run
    test:w` command in your terminal to start the test runner.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: Jest会查找要测试的文件，然后执行这些不同的`describe`和`it`函数，调用你提供给它们的回调函数。但你需要将什么放入其中呢？你需要设置*断言*。为此，你需要一些可以断言的东西。这就是Enzyme发挥作用的地方；它允许你创建一个可测试的组件版本，你可以检查并对其做出断言。你将使用Enzyme的*浅渲染*，这将创建一个轻量级的组件版本，它不会执行完整的挂载或插入到DOM中。你还需要为组件提供一些*模拟*（虚假）数据。下面的列表显示了如何将组件的测试版本添加到你的测试套件中。在你开始编写测试之前，请确保在终端中运行`npm
    run test:w`命令以启动测试运行器。
- en: Listing 9.4\. Shallow rendering (src/components/post/Content.test.js)
  id: totrans-1308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 浅渲染（src/components/post/Content.test.js）
- en: '[PRE102]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Create dummy post object that component can use**'
  id: totrans-1310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个组件可以使用的虚拟帖子对象**'
- en: '***2* Perform shallow rendering of component and save returned wrapper for
    later use**'
  id: totrans-1311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对组件进行浅渲染并保存返回的包装器以供以后使用**'
- en: You now have a test component set up that you can make assertions about. To
    do this, you’ll use the built-in `expect()` function from Jest. If you were using
    a different assertion library, you might use something else. Remember from earlier
    that these assertion libraries are for making assertions easier. For example,
    checking whether an object is *deeply equal* (meaning equal in every one of its
    properties) can be an involved task. When writing your tests, you shouldn’t be
    focusing on implementing tons of new functionality just to write them—you should
    be focusing on the code under test. Assertion helpers and open source libraries
    make that easier.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了一个可以对其做出断言的测试组件。为此，你将使用Jest内置的`expect()`函数。如果你使用的是不同的断言库，你可能需要使用其他函数。记得之前提到的，这些断言库是为了让断言更容易。例如，检查一个对象是否*深度相等*（意味着在它的每个属性上都是相等的）可能是一个复杂的过程。在编写测试时，你不应该专注于实现大量新功能来编写测试，而应该专注于被测试的代码。断言辅助工具和开源库使得这一点更容易实现。
- en: 'To test the component at hand, you want to make a few assertions we mused about
    earlier: class name, inner content, and element type. You’ll also create a snapshot
    test using the React test renderer. *Snapshot testing* is a feature of Jest that
    allows you to test the render output of your components in a unique way. Snapshot
    testing is closely related to *visual regression testing*, a process where the
    visual output of an application can be compared and checked for differences.'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试当前组件，你想要做出我们之前提到的几个断言：类名、内部内容，和元素类型。你还将使用React测试渲染器创建快照测试。*快照测试*是Jest的一个特性，它允许你以独特的方式测试组件的渲染输出。快照测试与*视觉回归测试*密切相关，这是一个过程，其中应用程序的视觉输出可以进行比较和检查差异。
- en: If a difference in images is found, you know that your test failed and needs
    adjusting or at least that the output snapshot needs to be updated. Rather than
    images, Jest will create JSON outputs for tests and store them in specially named
    directories. These should be added to version control along with all your other
    code. The following listing shows how to use Jest, Enzyme, and the React test
    renderer to make those assertions.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现图像有差异，你知道你的测试失败了，需要调整，或者至少输出快照需要更新。与图像不同，Jest将为测试创建JSON输出，并将它们存储在特别命名的目录中。这些应该与你的所有其他代码一起添加到版本控制中。以下列表显示了如何使用Jest、Enzyme和React测试渲染器来做出这些断言。
- en: Listing 9.5\. Making assertions (src/components/post/Content.test.js)
  id: totrans-1315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. 做出断言（src/components/post/Content.test.js）
- en: '[PRE103]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '***1* Import enzyme and react-test-renderer.**'
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入酶和react-test-renderer。**'
- en: '***2* Import component you want to test**'
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入你想要测试的组件**'
- en: '***3* Use Jasmine-style describe function to group tests together**'
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用Jasmine风格的describe函数来分组测试**'
- en: '***4* Create mock post**'
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建模拟帖子**'
- en: '***5* Use Enzyme’s shallow method to render component**'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用Enzyme的浅渲染方法来渲染组件**'
- en: '***6* Create snapshot test using Jest and react-test-renderer**'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用Jest和react-test-renderer创建快照测试**'
- en: If your test runner is running, you should see a passing result from Jest. The
    Jest command-line tools have greatly improved since the test runner came out,
    and you should be able to see important information about your tests in the terminal.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试运行器正在运行，你应该在终端中看到Jest的通过结果。自从测试运行器推出以来，Jest的命令行工具已经得到了极大的改进，你应该能够在终端中看到有关你的测试的重要信息。
- en: 9.3.3\. Testing the CreatePost component without Enzyme
  id: totrans-1324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. 不使用Enzyme测试CreatePost组件
- en: Now that you have your first test working, you can move on to testing more complex
    components. For the most part, testing React components should be straightforward.
    If you find yourself creating a component that has tons of functionality built
    into it and subsequently huge tests associated with it, you may want to consider
    breaking it into several components (although that’s not always possible).
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个测试工作正常，你可以继续测试更复杂的组件。就大部分而言，测试React组件应该是直接的。如果你发现自己创建了一个具有大量功能并且相应地具有巨大测试的组件，你可能想要考虑将其拆分成几个组件（尽管这并不总是可能的）。
- en: The next component you want to test, the CreatePost component, has more functionality
    than the Content component did, and your tests will need to address this added
    functionality. [Listing 9.6](kindle_split_020_split_003.xhtml#ch09ex06) shows
    the CreatePost component so you can review it before writing out tests for it.
    The CreatePost component is used by the Home component to trigger the submission
    of new posts. It renders out a `textarea` that gets updated when the user types
    in it and a button that submits the form with data when a user clicks it. When
    the user clicks, it invokes a callback function passed by a parent component.
    You can test all these assumptions and make sure that things work as you expect.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来想要测试的组件，CreatePost组件，比Content组件具有更多的功能，你的测试将需要处理这些新增的功能。[列表9.6](kindle_split_020_split_003.xhtml#ch09ex06)展示了CreatePost组件，以便你在编写测试之前可以查看它。CreatePost组件由Home组件用来触发新帖子的提交。它渲染出一个`textarea`，当用户输入时它会更新，并且有一个按钮，当用户点击时，它会提交包含数据的表单。当用户点击时，它调用由父组件传递的回调函数。你可以测试所有这些假设，并确保一切按预期工作。
- en: Listing 9.6\. CreatePost component (src/components/post/Create.js)
  id: totrans-1327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. CreatePost组件（src/components/post/Create.js）
- en: '[PRE104]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This was a slightly more complicated component than you created in previous
    chapters. With it you can create posts and add a location to those posts. In my
    experience, testing larger and more complex components further highlights the
    importance of clean, readable tests. If you can’t read or reason through your
    test file, how is a future-you or another developer going to?
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 这比你在前几章中创建的组件稍微复杂一些。使用它，你可以创建帖子并为这些帖子添加位置。根据我的经验，测试更大和更复杂的组件进一步突出了清晰、可读的测试的重要性。如果你无法阅读或推理你的测试文件，未来的你或其他开发者将如何做到呢？
- en: '[Listing 9.7](kindle_split_020_split_003.xhtml#ch09ex07) shows a suggested
    skeleton of tests for the CreatePost component. You don’t have enough methods
    to make it difficult to read through the tests, but if a component had more to
    it, you might even add nested `describe` blocks to make it easier to reason about.
    The functions in [listing 9.7](kindle_split_020_split_003.xhtml#ch09ex07) will
    be executed by the test runner (Jest in this case), and within those tests you
    can make your assertions. Most tests follow this same sort of pattern. You import
    the code under test, mock out any dependencies to isolate your tests to one unit
    of functionality (hence *unit tests*), and then a test runner and assertion library
    will work together to run your tests.'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.7](kindle_split_020_split_003.xhtml#ch09ex07) 展示了为 CreatePost 组件建议的测试框架。你的方法并不多，所以阅读测试不会很困难，但如果组件更复杂，你甚至可以添加嵌套的
    `describe` 块来使推理更容易。列表 9.7 中的函数将由测试运行器（在本例中为 Jest）执行，在这些测试中，你可以进行断言。大多数测试都遵循这种类似的模式。你导入要测试的代码，模拟任何依赖项以隔离测试到单个功能单元（因此称为
    *单元测试*），然后测试运行器和断言库将一起运行你的测试。'
- en: Listing 9.7\. Testing the CreatePost component (src/components/post/Create.test.js)
  id: totrans-1331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 测试 CreatePost 组件（src/components/post/Create.test.js）
- en: '[PRE105]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '***1* Using one describe call here, but in larger test files you can have many
    and even nest them**'
  id: totrans-1333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在这里使用一个 describe 调用，但在更大的测试文件中可以有多个，甚至可以嵌套**'
- en: '***2* Create a test for each method in your component, including a snapshot
    to ensure it renders correctly**'
  id: totrans-1334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为你的组件中的每个方法创建一个测试，包括一个快照以确保它正确渲染**'
- en: If you follow a consistent pattern of considering each part of your component
    that needs to be tested, you’ll be more thorough in developing and testing your
    components. Feel free to follow whatever structure makes the most sense to you—this
    is just one that has been helpful for me and for teams I’ve been on. I’ve also
    found it helpful to start writing tests by writing out the different `describe`
    and `test` blocks for a component or module before writing any other tests. I
    find that I can more easily think through the cases I want to cover (with an error,
    without an error, with a condition, and so on) if I’m doing that all at once.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循一个一致的考虑每个需要测试的组件部分的模式，你将在开发和测试组件时更加全面。请随意遵循对你最有意义的结构——这只是对我以及我所在团队有帮助的一个例子。我还发现，在编写任何其他测试之前，先为组件或模块编写不同的
    `describe` 和 `test` 块来编写测试是有帮助的。我发现，如果一次性做所有这些，我可以更容易地思考我想覆盖的情况（有错误、无错误、有条件等）。
- en: '|  |'
  id: totrans-1336
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What about other types of testing?**'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于其他类型的测试呢？**'
- en: You may be wondering about testing such things as user flows, cross-browser
    testing, and other types of testing I’m not covering here. These other sorts of
    testing will generally be focused on by an engineer or engineering team dedicated
    to specialized forms of testing. QA teams and SETs (*software engineers in test*)
    will generally have a host of specialized tools that allow them to take your application
    and simulate all the complicated flows that might exist.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道关于用户流程、跨浏览器测试以及其他我没有在这里涵盖的测试类型。这些其他类型的测试通常由专注于特定测试形式的工程师或工程团队关注。QA 团队和
    SET（*软件测试工程师*）通常有一系列专门的工具，允许他们模拟你的应用程序，并模拟可能存在的所有复杂的流程。
- en: 'These types of testing (*integration testing*) may involve the interaction
    of one or more disparate systems. If you remember the testing pyramid from [figure
    9.1](kindle_split_020_split_001.xhtml#ch09fig01), these tests can take a lot of
    time to write, are hard to maintain, and tend to cost a lot of money. When you
    think of “testing front-end applications,” you may think these sorts of tests
    are what would be involved. We’ve seen that this isn’t the case (most tests that
    non-QA engineers write are unit or low-level integration tests). If you’re interested
    in learning more about these sorts of tools, here are a few you could use as a
    springboard to learn more about higher-level testing:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 这类测试（*集成测试*）可能涉及一个或多个不同系统的交互。如果你还记得[图9.1](kindle_split_020_split_001.xhtml#ch09fig01)中的测试金字塔，这些测试可能需要花费很多时间来编写，难以维护，并且往往成本高昂。当你想到“测试前端应用”时，你可能认为这些测试会涉及其中。但我们已经看到情况并非如此（非QA工程师编写的多数测试是单元测试或低级集成测试）。如果你对这类工具感兴趣并想了解更多，以下是一些你可以作为学习高级测试的跳板：
- en: '*Selenium*—[www.seleniumhq.org](http://www.seleniumhq.org)'
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Selenium*—[www.seleniumhq.org](http://www.seleniumhq.org)'
- en: '*Puppeteer*—[https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)'
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Puppeteer*—[https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)'
- en: '*Protractor*—[www.protractortest.org/#/](http://www.protractortest.org/#/)'
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Protractor*—[www.protractortest.org/#/](http://www.protractortest.org/#/)'
- en: '|  |'
  id: totrans-1343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With this skeleton setup in place, you can begin testing the CreatePost component,
    starting with the constructor. Remember, the constructor is where initial state
    gets set up, class methods get bound, and other setup can occur. To test this
    part of the CreatePost component, we need to introduce another tool I mentioned
    earlier: Sinon. You need some test functions that you can give to your component
    for use that aren’t dependent on other modules. With Jest you can create mock
    functions for your test that help keep your tests focused on the component itself
    and prevent you from tying all your code together. Remember how I said tests should
    break when you change your code? That’s true, but changing one test also shouldn’t
    break other tests. As with regular code, your tests should be decoupled and only
    care about the slice of code they’re testing.'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这个骨架之后，你可以开始测试CreatePost组件，从构造函数开始。记住，构造函数是初始状态设置、类方法绑定和其他设置发生的地方。为了测试CreatePost组件的这一部分，我们需要引入我之前提到的一个工具：Sinon。你需要一些测试函数，你可以将它们提供给组件使用，这些函数不依赖于其他模块。使用Jest，你可以创建模拟函数来帮助你的测试专注于组件本身，并防止你将所有代码绑定在一起。记得我之前说过测试应该在代码更改时中断吗？这是真的，但更改一个测试也不应该破坏其他测试。就像常规代码一样，你的测试应该是解耦的，并且只关心它们正在测试的代码片段。
- en: Jest’s mock functions not only help us isolate our code, they help us make more
    assertions. You can make assertions about how your component used the `mock` function,
    whether it was called, what arguments it was called with, and more. The following
    listing shows setting up the snapshot test for your component and mocking some
    basic props your component needs using Jest.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: Jest的模拟函数不仅帮助我们隔离代码，还帮助我们做出更多断言。你可以对组件如何使用`mock`函数做出断言，包括它是否被调用，调用时传递了什么参数，等等。以下列表展示了如何为你的组件设置快照测试，并使用Jest模拟一些组件所需的基本属性。
- en: Listing 9.8\. Writing your first test (src/components/post/Create.test.js)
  id: totrans-1346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 编写你的第一个测试（src/components/post/Create.test.js）
- en: '[PRE106]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Use jest.mock function to tell Jest to use a mock instead of the module
    when running tests**'
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用jest.mock函数告诉Jest在运行测试时使用模拟而不是模块**'
- en: '***2* Create test block within outer describe block you created earlier**'
  id: totrans-1349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在你之前创建的外部describe块内创建测试块**'
- en: '***3* Create mock props object and use Jest’s to create mock function**'
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建模拟属性对象并使用Jest创建模拟函数**'
- en: '***4* Use React test renderer to create your component and pass in props**'
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用React测试渲染器创建你的组件并传递属性**'
- en: '***5* Call toJSON method to generate a snapshot**'
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用toJSON方法生成快照**'
- en: '***6* Assert that snapshot matches**'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 断言快照匹配**'
- en: Now that you have one test under your belt, you can test some other aspects
    of the component. The component is primarily responsible for allowing users to
    create posts and attach locations to them, so you need to test those areas of
    functionality. You’ll start by testing post creation. The next listing shows how
    to test post creator methods in your component.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了一次测试，你可以测试组件的其他方面。该组件主要负责允许用户创建帖子并将位置附加到它们上，因此你需要测试这些功能区域。你将从测试帖子创建开始。下面的列表显示了如何在你的组件中测试帖子创建方法。
- en: Listing 9.9\. Testing post creation (src/components/post/Create.test.js)
  id: totrans-1355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 测试帖子创建（src/components/post/Create.test.js）
- en: '[PRE107]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '***1* Create mock set of props to use**'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个模拟的props集以使用**'
- en: '***2* Mock setState so you can make sure your component calls it and that updating
    post updates state in the right way.**'
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模拟setState以确保你的组件调用它，并且更新帖子正确地更新了状态。**'
- en: '***3* Directly instantiate component and call its methods**'
  id: totrans-1359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 直接实例化组件并调用其方法**'
- en: '***4* Assert that your component invokes the right methods and that method
    updated state correctly**'
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 断言你的组件调用了正确的方法，并且该方法正确地更新了状态**'
- en: '***5* Create another mock event to simulate what your component will receive
    from an event**'
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建另一个模拟事件来模拟你的组件将接收的事件**'
- en: '***6* Mock setState again.**'
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 再次模拟setState。**'
- en: '***7* Instantiate another component and set state of component to simulate
    user entering post content**'
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 实例化另一个组件并将组件的状态设置为模拟用户输入帖子内容**'
- en: '***8* Directly modify component’s state (for testing purposes)**'
  id: totrans-1364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 直接修改组件的状态（用于测试目的）**'
- en: '***9* Handle post submission with mock event you created and assert that mocks
    were called**'
  id: totrans-1365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 使用你创建的模拟事件处理帖子提交并断言模拟被调用**'
- en: Finally, you want to test the remainder of the component’s functionality. Aside
    from letting users create posts, the CreatePost component also handles the user
    picking a location. Other components handle updating the location via callbacks
    passed as props, but you still need to test the component methods on CreatePost
    related to this feature.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你想要测试组件的其余功能。除了让用户创建帖子外，CreatePost组件还处理用户选择位置。其他组件通过作为props传递的回调处理更新位置，但你仍然需要测试与该功能相关的CreatePost组件的方法。
- en: Remember you implemented a subrender method on CreatePost, which you used to
    make reading the `render` method’s output of CreatePost easier and to reduce clutter.
    You can test this in a similar way that you’ve been testing components with Enzyme
    or the React test renderer. The following listing shows the rest of the tests
    for the CreatePost component.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你已经在CreatePost上实现了一个子渲染方法，你使用它来简化读取CreatePost的`render`方法输出，并减少混乱。你可以用类似测试使用Enzyme或React测试渲染器组件的方式测试它。下面的列表显示了CreatePost组件的其余测试。
- en: Listing 9.10\. Testing post creation (src/components/post/Create.test.js)
  id: totrans-1368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 测试帖子创建（src/components/post/Create.test.js）
- en: '[PRE108]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1* Mock setState**'
  id: totrans-1370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模拟setState**'
- en: '***2* Invoke handleRemove-Location function**'
  id: totrans-1371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用handleRemove-Location函数**'
- en: '***3* Assert that you updated state in correct manner**'
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 断言你以正确的方式更新了状态**'
- en: '***4* Repeat same process for rest of your component methods**'
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 对组件的其余方法重复相同的过程**'
- en: '***5* Repeat same process for rest of your component methods**'
  id: totrans-1374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 对组件的其余方法重复相同的过程**'
- en: '***6* Create another snapshot test for subrender method you created**'
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 为你创建的子渲染方法创建另一个快照测试**'
- en: 9.3.4\. Test coverage
  id: totrans-1376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 测试覆盖率
- en: Now that you’ve gotten your hands dirty testing some components, let’s look
    at test coverage and see what progress you’ve made. In your terminal, stop the
    test runner and execute the command shown in the next listing. This command will
    turn on the coverage option included in Jest.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经测试了一些组件，让我们来看看测试覆盖率，看看你取得了哪些进展。在你的终端中，停止测试运行器并执行下一个列表中显示的命令。此命令将打开Jest中包含的覆盖率选项。
- en: Listing 9.11\. Enabling test coverage (project root)
  id: totrans-1378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. 启用测试覆盖率（项目根目录）
- en: '[PRE109]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Once your test runner finishes executing tests, it should output a colored table
    that should look something like [figure 9.3](kindle_split_020_split_003.xhtml#ch09fig03)
    (with less coverage). The figure shows the Jest coverage output with annotations
    about each of the columns. There are different forms of readable code coverage
    reports (HTML, for example), but the terminal output is most useful during development
    because it provides immediate feedback.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试运行器执行完测试，它应该输出一个彩色表格，看起来可能像[图9.3](kindle_split_020_split_003.xhtml#ch09fig03)（覆盖率较低）。该图显示了带有每列注释的Jest覆盖率输出。有不同形式的可读性代码覆盖率报告（例如HTML），但在开发期间，终端输出最有用，因为它提供了即时反馈。
- en: Figure 9.3\. Test coverage output from Jest shows coverage stats for the different
    files in your project. Each column reflects a different aspect of coverage. For
    each type of coverage, Jest shows a percentage covered. Statements and functions
    are simply JavaScript statements and functions, whereas branches are logical branches.
    If your test doesn’t address one part of an if statement, that should be reflected
    in the code coverage both in the uncovered lines column and in the percent-covered
    stat for branches.
  id: totrans-1381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. Jest的测试覆盖率输出显示了项目中不同文件的覆盖率统计。每一列反映覆盖率的不同方面。对于每种覆盖率类型，Jest都会显示覆盖的百分比。语句和函数仅仅是JavaScript语句和函数，而分支是逻辑分支。如果你的测试没有覆盖if语句的一部分，这应该在代码覆盖率中的未覆盖行列和分支的百分比覆盖率中反映出来。
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-1382
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig03_alt.jpg)'
- en: Istanbul is the tool generating the stats in [figure 9.3](kindle_split_020_split_003.xhtml#ch09fig03).
    If you want to see more detailed coverage information, open the coverage directory
    that should have been generated by the `jest` command that included the coverage
    option. In this directory, Istanbul should have created a few files. If you open
    ./coverage/lcov-report/index.html in a browser, you should see something like
    [figure 9.4](kindle_split_020_split_003.xhtml#ch09fig04).
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: Istanbul是生成[图9.3](kindle_split_020_split_003.xhtml#ch09fig03)中统计的工具。如果你想看到更详细的覆盖率信息，打开由包含覆盖率选项的`jest`命令生成的覆盖率目录。在这个目录中，Istanbul应该创建了一些文件。如果你在浏览器中打开./coverage/lcov-report/index.html，你应该会看到类似[图9.4](kindle_split_020_split_003.xhtml#ch09fig04)的内容。
- en: Figure 9.4\. Istanbul generates coverage metadata in computer-readable and human-readable
    formats. The coverage report shown here is useful for more detailed exploration
    of code coverage. You can even sort by different columns and prioritize files
    with low coverage. Note that there are columns for statements, branches (if/else
    statements), functions (which functions were called), and lines (lines of code).
  id: totrans-1384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. Istanbul以计算机可读和人类可读的格式生成覆盖率元数据。这里显示的覆盖率报告对于更详细地探索代码覆盖率很有用。你甚至可以根据不同的列进行排序，并优先考虑覆盖率低的文件。请注意，有关于语句、分支（if/else语句）、函数（调用了哪些函数）和行（代码行）的列。
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-1385
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04_alt.jpg)'
- en: The Istanbul output is useful, but you can also drill down into different files
    and get more in-depth information about individual files. Each file should display
    information about how many times different lines were covered and which ones weren’t.
    Most of the time the top-level summary is good enough, but sometimes you may want
    to inspect individual reports, like the one in [figure 9.5](kindle_split_020_split_003.xhtml#ch09fig05).
    When I’m writing tests, I like to take at least one look at these files once I’ve
    covered all my cases to make sure I didn’t miss any edge cases or logical branches.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: Istanbul的输出很有用，但你也可以深入到不同的文件中，获取关于单个文件更深入的信息。每个文件都应该显示不同行被覆盖的次数以及哪些行没有被覆盖。大多数情况下，顶层摘要就足够了，但有时你可能想检查单个报告，就像[图9.5](kindle_split_020_split_003.xhtml#ch09fig05)中的那样。当我编写测试时，我喜欢在覆盖所有用例后至少查看一次这些文件，以确保我没有错过任何边缘情况或逻辑分支。
- en: Figure 9.5\. Individual file coverage report generated by Istanbul. You can
    see how many times different lines were or weren’t covered and get a sense for
    exactly which parts of your code were covered.
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 由Istanbul生成的单个文件覆盖率报告。您可以看到不同行被覆盖或未被覆盖的次数，并了解代码中哪些部分被覆盖。
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-1388
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig05_alt.jpg)'
- en: Test coverage is an important and useful tool for software development, but
    don’t treat it as a magical guarantee that your code works. You can get to 100%
    coverage and still have code that breaks. You can technically also have code that
    works with 0% code coverage. *Coverage* is about making sure your tests are executing
    all the different parts of your code—not guaranteeing a lack of errors or things
    like performance—but it’s useful for that and should be treated as an important
    data point when considering how “complete” your code is. I’ve been on teams where
    our definition of success for a particular user story or task included, among
    other things, code coverage above 80% and no decreased coverage overall. Use coverage
    as a guideline for which parts of your code you have or haven’t tested and to
    check your testing progress.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率是软件开发的重要且有用的工具，但不要将其视为代码工作的神奇保证。你可以达到100%的覆盖率，但代码仍然可能出错。技术上，你也可以有0%代码覆盖率但代码仍然可以工作。*覆盖率*
    是确保你的测试正在执行代码的所有不同部分——不是保证没有错误或性能等问题——但它对此很有用，并且应该被视为考虑代码“完整性”时的重要数据点。我曾加入过一些团队，我们的成功定义包括，在特定用户故事或任务中，除了其他事项外，代码覆盖率超过80%且总体覆盖率没有下降。将覆盖率用作指南，以确定你的代码哪些部分已经或尚未测试，并检查你的测试进度。
- en: '|  |'
  id: totrans-1390
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Considering coverage**'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑覆盖率**'
- en: We talked about test coverage in this chapter. Does 100% test coverage mean
    that your code is perfect? What role should code coverage play in your testing?
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论了测试覆盖率。100%的测试覆盖率是否意味着你的代码是完美的？代码覆盖率在测试中应该扮演什么角色？
- en: '|  |'
  id: totrans-1393
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.4\. Summary
  id: totrans-1394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 摘要
- en: 'In this chapter, you learned about some of the principles behind testing and
    how to test React applications:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了测试背后的某些原则以及如何测试React应用程序：
- en: '*Testing* is the process of validating assumptions made about software. It
    helps you better plan your components, prevents breakage in the future, and helps
    increase confidence in your code. It also plays an important role in a rapid development
    process.'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试* 是验证关于软件所做假设的过程。它帮助你更好地规划组件，防止未来出现故障，并有助于提高你对代码的信心。它在快速开发过程中也发挥着重要作用。'
- en: Manual testing doesn’t scale well because no number of people could ever quickly
    or adequately test complex software well.
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试扩展性不好，因为无论多少人，都无法快速或充分地测试复杂的软件。
- en: We use a variety of tools in the software testing process, ranging from tools
    that run our tests to tools that determine how much of our code is covered by
    tests.
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在软件测试过程中，我们使用各种工具，从运行我们的测试的工具到确定我们的代码有多少被测试覆盖的工具。
- en: Different types of tests should occur in different proportions. *Unit* tests
    should be the most common and are easy, cheap, and quick to write. *Integration*
    tests test the interaction of many different parts of the system and can be brittle
    and take longer to write. They should be less common.
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的测试应以不同的比例出现。*单元* 测试应该是最常见的，它们容易编写、成本低、速度快。*集成* 测试测试系统的许多不同部分的交互，可能很脆弱，编写时间较长。它们应该较少出现。
- en: You can test React components using a variety of tools. Because they’re just
    functions, you could test them strictly as such. But tools like Enzyme make testing
    React components easier.
  id: totrans-1400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用各种工具测试React组件。因为它们只是函数，你可以严格地按这种方式测试它们。但像Enzyme这样的工具使测试React组件变得更容易。
- en: Clean tests, like any clean code, are easy to read and well organized and use
    appropriate proportions of unit, service, and integration tests. They should provide
    meaningful assurance that things function in a particular manner and should guarantee
    that changes to your component can be evaluated.
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁的测试，就像任何清洁的代码一样，易于阅读和良好组织，并使用适当的单元、服务和集成测试比例。它们应该提供有意义的保证，说明事物以特定方式运行，并应保证你的组件更改可以被评估。
- en: In the next chapter, we’ll look at a more robust implementation of the Letters
    Social app and explore the Redux architectural pattern. Before moving on, see
    if you can keep honing your testing skills and get test coverage for the app up
    above 90%!
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Letters Social应用程序的更健壮的实现，并探索Redux架构模式。在继续之前，看看你是否能继续磨练你的测试技能，并将应用程序的测试覆盖率提高到90%以上！
