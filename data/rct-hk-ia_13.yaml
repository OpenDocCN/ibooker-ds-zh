- en: 11 Code splitting with Suspense
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 使用Suspense进行代码拆分
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Importing code dynamically with the `import` function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import`函数动态导入代码
- en: Loading components when they’re needed with `React.lazy`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`React.lazy`按需加载组件
- en: Specifying fallback UI declaratively with `Suspense` components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Suspense`组件声明性地指定回退UI
- en: Understanding how `lazy` and `Suspense` work together
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`lazy`和`Suspense`如何协同工作
- en: Specifying error fallback UI declaratively with error boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误边界声明性地指定错误回退UI
- en: It’s common for app users to interact with some components more than others.
    In the bookings app, for example, users often visit the Bookings page without
    switching to the Bookables or Users pages, and on the Bookables page they may
    never bring up the New or Edit forms. To manage the amount of code loaded by the
    browser at any one time, we can use a technique called *code splitting*; rather
    than loading all of an app’s code at once, we load it in *chunks*, as it’s needed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 应用用户通常与某些组件的交互比与其他组件更多。例如，在预订应用中，用户经常访问预订页面而不切换到可预订或用户页面，在可预订页面上，他们可能永远不会打开新建或编辑表单。为了管理浏览器在任何时候加载的代码量，我们可以使用一种称为*代码拆分*的技术；而不是一次性加载应用的所有代码，我们按需加载它为*块*。
- en: So far in this book, all of our examples have used *static imports*. At the
    top of each JavaScript file, we include `import` statements to specify *dependencies*,
    the code in external files that the current file uses. At build time, bundlers
    like webpack inspect our code, follow the paths to the imported files, and generate
    a *bundle*, a file that contains all the code the app actually uses. Our web pages
    then request the bundle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的所有示例都使用了*静态导入*。在每个JavaScript文件顶部，我们包含`import`语句来指定*依赖项*，即当前文件使用的来自外部文件的代码。在构建时，webpack等打包工具检查我们的代码，跟踪导入文件的路径，并生成一个*包*，一个包含应用实际使用所有代码的文件。然后，我们的网页请求这个包。
- en: This *tree-shaking process*, which avoids duplicate code and discards unused
    code, can help keep the bundle well organized and as small as possible. For larger
    applications and/or slower connections, “as small as possible” can still be big
    enough to take a while to load. Maybe loading all of the code up front isn’t the
    best idea. If parts of the app are less likely to be used or contain particularly
    bulky components, it can be helpful to reduce the size of the initial bundle and
    then load further bundles only when the user visits a certain route or initiates
    a particular interaction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*摇树优化过程*，它避免了重复代码并丢弃未使用的代码，可以帮助保持包的良好组织并尽可能小。对于较大的应用和/或较慢的连接，"尽可能小"仍然可能足够大，需要一段时间才能加载。也许一开始就加载所有代码并不是最好的主意。如果应用的部分不太可能被使用或包含特别庞大的组件，减少初始包的大小并在用户访问特定路由或发起特定交互时才加载进一步的包可能是有帮助的。
- en: 'In React, we work with components. We want to dynamically import some components
    into our applications only when they’re needed. But React calls the components
    when it’s time to render them. If the component isn’t loaded when it’s time to
    render it, what should React do? We don’t want the whole app to pause and wait
    for the component. For bigger components or those that don’t usually take part
    in initial user interactions, we can do these four things:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，我们与组件一起工作。我们希望在需要时才动态地将一些组件导入到我们的应用中。但React在渲染它们的时间调用组件。如果组件在渲染时未加载，React应该怎么做？我们不希望整个应用暂停等待组件。对于较大的组件或那些通常不参与初始用户交互的组件，我们可以做以下四件事：
- en: Load the component code only when we try to render the component.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在我们尝试渲染组件时加载组件代码。
- en: Show a placeholder while the component loads.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件加载时显示占位符。
- en: Continue rendering the rest of the app.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续渲染应用的其余部分。
- en: Replace the placeholder with the component after it’s loaded.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加载完成后，用组件替换占位符。
- en: In this chapter, we look at how to put those four points into action by using
    React’s `lazy` method and `Suspense` component. Our discussion of placeholder
    UI will also lead us to *error boundaries*, a way of giving React something to
    render if errors occur. First up, it’ll be useful to understand how JavaScript
    lets us import code dynamically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用React的`lazy`方法和`Suspense`组件来探讨如何将这些四点付诸实践。我们对占位符UI的讨论也将引导我们到*错误边界*，这是一种在发生错误时给React提供渲染内容的方式。首先，了解JavaScript如何让我们动态导入代码将很有用。
- en: 11.1 Importing code dynamically with the import function
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 使用导入函数动态导入代码
- en: 'In this section, we look at dynamically importing JavaScript from one module
    into another. We won’t be using React, but the concepts are important for when
    we come to dynamically load components in our React apps. There are four subsections:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨从模块中动态导入JavaScript到另一个模块。我们不会使用React，但这些概念对于我们在React应用中动态加载组件时非常重要。共有四个小节：
- en: Setting up a web page to load JavaScript when a button is clicked
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置网页在点击按钮时加载JavaScript
- en: Making JavaScript available from a file using default and named exports
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认和命名导出从文件中使JavaScript可用
- en: Using static imports to load JavaScript
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态导入加载JavaScript
- en: Calling the `import` function to dynamically load JavaScript
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`import`函数动态加载JavaScript
- en: 11.1.1 Setting up a web page to load JavaScript when a button is clicked
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 设置网页在点击按钮时加载JavaScript
- en: Say we have an app that displays a button. When we click the button, two messages
    are displayed, as shown in figure 11.1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个显示按钮的应用。当我们点击按钮时，会显示两条消息，如图11.1所示。
- en: '![](../Images/11-1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-1.png)'
- en: Figure 11.1 Clicking the button shows two messages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 点击按钮显示两条消息。
- en: 'To demonstrate module importing, let’s split the app into three files: index.html,
    index.js, and helloModule.js. The following listing shows the HTML, including
    the button, two paragraphs to hold the two messages, and a script element to load
    the code file, index.js, that’ll wire up the button to display the messages.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示模块导入，让我们将应用拆分为三个文件：index.html、index.js和helloModule.js。以下列表显示了HTML，包括按钮、两个段落以保存两条消息，以及一个脚本元素以加载将按钮连接到显示消息的代码文件index.js。
- en: '*Live*: [https://vg0ke.csb.app](https://vg0ke.csb.app), *Code*: [https://codesandbox.io/s/jsstaticimport-vg0ke](https://codesandbox.io/s/jsstaticimport-vg0ke)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时查看*: [https://vg0ke.csb.app](https://vg0ke.csb.app), *代码*: [https://codesandbox.io/s/jsstaticimport-vg0ke](https://codesandbox.io/s/jsstaticimport-vg0ke)'
- en: Listing 11.1 An HTML file for displaying two messages (index.html)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 用于显示两条消息的HTML文件（index.html）
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Include a button to display the two messages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含一个按钮以显示两条消息。
- en: ❷ Include paragraph elements as targets for the messages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含段落元素作为消息的目标。
- en: ❸ Load the script that’ll wire up the button.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 加载将按钮连接起来的脚本。
- en: We don’t yet have the index.js file, but we do know that it’ll use some handy
    utility functions for injecting text into existing HTML elements. The utility
    functions live in their own module. Let’s see that module and how it makes the
    functions available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有index.js文件，但我们知道它将使用一些方便的实用函数来将文本注入现有的HTML元素。这些实用函数位于它们自己的模块中。让我们看看这个模块以及它是如何使函数可用的。
- en: 11.1.2 Using default and named exports
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 使用默认和命名导出
- en: Our handy utility functions live in a JavaScript module, helloModule.js. The
    module is shown in the following listing and uses the `export` and `default` keywords
    to specify values that other files will be able to import. One of the messaging
    functions is the default export, and the other is a named export.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方便的实用函数位于JavaScript模块helloModule.js中。该模块如下所示，并使用`export`和`default`关键字指定其他文件可以导入的值。其中一个消息函数是默认导出，另一个是命名导出。
- en: '*Live*: [https://vg0ke.csb.app](https://vg0ke.csb.app), *Code*: [https://codesandbox.io/s/jsstaticimport-vg0ke](https://codesandbox.io/s/jsstaticimport-vg0ke)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时查看*: [https://vg0ke.csb.app](https://vg0ke.csb.app), *代码*: [https://codesandbox.io/s/jsstaticimport-vg0ke](https://codesandbox.io/s/jsstaticimport-vg0ke)'
- en: Listing 11.2 Creating a module with default and named exports (helloModule.js)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 创建具有默认和命名导出的模块（helloModule.js）
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Make the sayMessage function the default export.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将sayMessage函数设为默认导出。
- en: ❷ Make the sayHi function a named export.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将sayHi函数设为命名导出。
- en: Files can have a single default export and multiple named exports. They don’t
    have to export everything, only those values (in our case, functions) that they
    want other files to be able to import. We have our super-handy, message-injecting
    functions ready to go, so let’s get importing!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以有一个默认导出和多个命名导出。它们不需要导出所有内容，只需导出那些它们希望其他文件能够导入的值（在我们的例子中是函数）。我们准备好了超级方便的消息注入函数，所以让我们开始导入吧！
- en: 11.1.3 Using static imports to load JavaScript
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 使用静态导入加载JavaScript
- en: Our app performs the vital task of showing messages when the user clicks a button.
    The last file we need, index.js, sets up an event handler to wire up the button
    with the action of displaying the messages. But it doesn’t start from scratch;
    we have some handy utility functions available, after all. So index.js imports
    the messaging functions from the helloModule.js module and calls them from the
    event handler. The standard approach to importing values exported from other modules
    is to import them statically at the top of a file, as shown in the following listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，我们的应用程序执行显示消息的关键任务。我们需要最后一个文件，即`index.js`，它设置一个事件处理器来将按钮与显示消息的动作连接起来。但它不是从头开始的；毕竟我们有一些方便的实用函数可用。因此，`index.js`从`helloModule.js`模块导入消息函数，并在事件处理器中调用它们。从其他模块导入导出值的标准方法是在文件顶部静态导入，如下面的列表所示。
- en: '*Live*: [https://vg0ke.csb.app](https://vg0ke.csb.app), *Code*: [https://codesandbox.io/s/jsstaticimport-vg0ke](https://codesandbox.io/s/jsstaticimport-vg0ke)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时演示*: [https://vg0ke.csb.app](https://vg0ke.csb.app)，*代码*: [https://codesandbox.io/s/jsstaticimport-vg0ke](https://codesandbox.io/s/jsstaticimport-vg0ke)'
- en: Listing 11.3 Static import (index.js)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 静态导入（index.js）
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Import the two messaging functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入两个消息函数。
- en: ❷ Call the imported functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用导入的函数。
- en: ❸ Call the handler when the button is clicked.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当按钮被点击时调用处理器。
- en: We assign the default export from `helloModule` to the local `showMessage` variable
    (we can choose the variable name), and assign the named export, `sayHi`, to a
    local variable using the matching variable name between curly braces—it’s named
    `sayHi` in helloModule.js, so we have to use `sayHi` in index.js.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`helloModule`模块的默认导出分配给本地变量`showMessage`（我们可以选择变量名），并将命名导出`sayHi`分配给一个使用匹配括号内变量名的本地变量——在`helloModule.js`中它被命名为`sayHi`，因此我们在`index.js`中必须使用`sayHi`。
- en: That all works as expected; it’s a simple example. But say the module we want
    to import is a much bigger file (at least pretend it is for now), and say, too,
    that most users don’t click the button very often. Can we avoid loading the hefty
    module unless it’s needed? That would really help us load the main app more quickly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都按预期工作；这是一个简单的例子。但是，如果我们想导入的模块是一个更大的文件（至少现在假装是这样），而且大多数用户不太经常点击按钮，我们能避免在不需要时加载这个庞大的模块吗？这将真正帮助我们更快地加载主应用程序。
- en: 11.1.4 Calling the import function to dynamically load JavaScript
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4 使用导入函数动态加载JavaScript
- en: How about loading the code that the button uses only if the button is clicked?
    The following listing shows index.js loading code dynamically with the `import`
    function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有当按钮被点击时才加载按钮使用的代码怎么办？以下列表显示了`index.js`如何使用`import`函数动态加载代码。
- en: '*Live*: [https://n41cc.csb.app/](https://n41cc.csb.app/), *Code*: [https://codesandbox.io/s/jsdynamicimport-n41cc](https://codesandbox.io/s/jsdynamicimport-n41cc)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时演示*: [https://n41cc.csb.app/](https://n41cc.csb.app)，*代码*: [https://codesandbox.io/s/jsdynamicimport-n41cc](https://codesandbox.io/s/jsdynamicimport-n41cc)'
- en: Listing 11.4 Dynamically loading code with the import function (index.js)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 使用导入函数动态加载代码（index.js）
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Call the import function to dynamically load a module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用导入函数以动态加载一个模块。
- en: ❷ Assign the module to a local variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将模块分配给一个本地变量。
- en: ❸ Use the module properties to call the exported functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用模块属性调用导出的函数。
- en: 'There’s no need to load a big file if it won’t be used, so the module is loaded
    only when the button is clicked. The `handleClick` function uses the `import`
    function to load the module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不会使用，就没有必要加载一个大文件，因此模块只有在点击按钮时才会加载。`handleClick`函数使用`import`函数来加载模块：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `import` function returns a promise that resolves to the exported module.
    We call the promise’s `then` method to work with the module after it’s loaded:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`函数返回一个解析为导出模块的promise。我们调用promise的`then`方法在模块加载后与之交互：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we can use `async/await` syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`async/await`语法：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The exported values (both functions, in our case) are available as properties
    of the `module` object. The default export is assigned to the `default` property,
    and named exports are assigned to properties of the same name. The helloModule.js
    file has a default export and a `sayHi` named export, so these are available as
    `module.default` and `module.sayHi`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的值（在我们的例子中是函数）作为`module`对象的属性可用。默认导出分配给`default`属性，命名导出分配给同名属性。`helloModule.js`文件有一个默认导出和一个名为`sayHi`的命名导出，因此这些作为`module.default`和`module.sayHi`可用：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rather than calling the functions as methods of the module object, we can destructure
    the module object as shown in the following listing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下列表所示那样解构模块对象，而不是将函数作为模块对象的函数调用。
- en: Listing 11.5 Destructuring module properties from a dynamic import
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 从动态导入中解构模块属性
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Destructure the module, assigning exported functions to local variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解构模块，将导出的函数分配给局部变量。
- en: ❷ Use the local variables to call the exported functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用局部变量调用导出的函数。
- en: 'Within the destructuring, we assign the default export to a variable with a
    more appropriate name, `showMessage`. Again, the `async/await` version is quite
    clean:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在解构过程中，我们将默认导出分配给一个更合适的变量名，`showMessage`。再次强调，`async/await`版本相当简洁：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, that’s a quick introduction to dynamic imports. But we want to dynamically
    import React components; how can we delay the importing of components without
    breaking React’s rendering process? Now that we need the knowledge, let’s load
    up the lowdown on lazy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是对动态导入的快速介绍。但是，我们想要动态导入React组件；如何在不破坏React渲染过程的情况下延迟组件的导入？现在我们需要这些知识，让我们来了解一下关于懒加载的详细信息。
- en: 11.2 Importing components dynamically with lazy and Suspense
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用`lazy`和`Suspense`动态导入组件
- en: In the preceding section, we used the `import` function to dynamically load
    JavaScript code. We loaded the code only when it was needed, when the user clicked
    a button. But we were also in control of rendering; we imperatively attached event
    handlers and tweaked the DOM with calls to `addEventListener` and `getElementById`
    and by setting the `innerHTML` property.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了`import`函数来动态加载JavaScript代码。我们仅在需要时加载代码，即用户点击按钮时。但我们也在控制渲染；我们通过调用`addEventListener`和`getElementById`以及设置`innerHTML`属性来强制性地附加事件处理程序并调整DOM。
- en: 'When working with React, we should concentrate on updating the state and let
    React manage the DOM. How can we combine lazily loading components with React’s
    need to control the rendering process? We need some way of declaratively letting
    React know what to do if a component it wants to render is not yet ready. This
    section looks at the two pieces we can use to solve the problem, first separately
    and then together, before applying the solution to the bookings app example. Our
    four subsections are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React工作时，我们应该专注于更新状态，让React管理DOM。如何将懒加载组件与React需要控制渲染过程的需求结合起来？我们需要一种方法，以声明方式让React知道如果它想要渲染的组件尚未准备好，应该怎么做。本节将探讨我们可以用来解决问题的两个部分，首先是分别探讨，然后一起探讨，最后将解决方案应用于预订应用示例。我们的四个小节如下：
- en: Converting a component to a lazy component with the `lazy` function
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lazy`函数将组件转换为懒加载组件
- en: Specifying fallback content with the `Suspense` component
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Suspense`组件指定回退内容
- en: Understanding how `lazy` and `Suspense` work together
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`lazy`和`Suspense`如何协同工作
- en: Code splitting an app on its routes
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用的路线上进行代码拆分
- en: First, we have a date with an overlarge calendar component in a news app. In
    its case, laziness is a virtue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在一个新闻应用中，我们有一个带有过大日历组件的日期。在这种情况下，懒惰是一种美德。
- en: 11.2.1 Converting a component to a lazy component with the lazy function
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 使用`lazy`函数将组件转换为懒加载组件
- en: Say we have an app in the company that shows the latest company news and announcements.
    Coworkers check the app all the time to keep up-to-date. The app also includes
    a full-featured calendar component that can either be viewed on the main page
    along with the other content or opened in its own view.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们公司有一个应用，显示最新的公司新闻和公告。同事们经常检查这个应用以保持最新。该应用还包括一个功能齐全的日历组件，它可以在主页上与其他内容一起查看，或者在其自己的视图中打开。
- en: However, coworkers check the calendar only from time to time. Rather than including
    the calendar component code when the app first loads, we want to load the calendar
    code only when a user clicks a Show Calendar button. Figure 11.2 roughly illustrates
    the setup, with a region for the main app and two ways of opening the calendar.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同事们只是偶尔检查日历。我们不想在应用首次加载时包含日历组件代码，而只想在用户点击显示日历按钮时加载日历代码。图11.2大致说明了设置，包括主应用区域和两种打开日历的方式。
- en: '![](../Images/11-2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-2.png)'
- en: Figure 11.2 Our company news app loads the `Calendar` component code only when
    a user clicks one of the Show Calendar buttons.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 我们的公司新闻应用仅在用户点击其中一个显示日历按钮时加载`Calendar`组件代码。
- en: We’ll use the same component, `CalendarWrapper`, for the two calendar regions
    under the main app (but imagine one would open the calendar in place and the other
    would replace the current view). The following listing shows the JSX for the app’s
    UI with a main region and the two calendar regions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的组件`CalendarWrapper`作为主应用程序下的两个日历区域（但想象一个会在当前位置打开日历，另一个会替换当前视图）。以下列表显示了应用程序UI的JSX，包括主区域和两个日历区域。
- en: Listing 11.6 The app includes a main region and two calendar regions
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.6 应用程序包括一个主区域和两个日历区域
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code for a `CalendarWrapper` component is in the following listing. The
    component starts by displaying the Show Calendar button. When a user clicks the
    button, `CalendarWrapper` switches to displaying a `LazyCalendar` component.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中的`CalendarWrapper`组件代码。组件首先显示“显示日历”按钮。当用户点击按钮时，`CalendarWrapper`切换到显示`LazyCalendar`组件。
- en: Listing 11.7 A component with a button for displaying the calendar
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 包含显示日历按钮的组件
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Include a lazily loaded component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含一个延迟加载的组件。
- en: 'Listing 11.7 uses the `LazyCalendar` component, a special component that isn’t
    imported until it’s rendered for the first time. But where does that come from?
    Assuming we already have a `Calendar` component in a module called Calendar.js,
    we can combine a dynamic import with React’s `lazy` function to convert `Calendar`
    into `LazyCalendar`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7使用了`LazyCalendar`组件，这是一个特殊的组件，它直到首次渲染时才被导入。但它是从哪里来的？假设我们已经在名为Calendar.js的模块中有一个`Calendar`组件，我们可以结合动态导入和React的`lazy`函数将`Calendar`转换为`LazyCalendar`：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We pass `lazy` a function that returns a promise. More generally, the process
    looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`lazy`一个返回承诺的函数。更一般地说，这个过程看起来像这样：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Create a function that returns a promise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个返回承诺的函数。
- en: ❷ Pass the promise-generating function to React.lazy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将生成承诺的函数传递给React.lazy。
- en: We pass `lazy` a function, `getPromise`, that React calls when it’s time to
    render the component for the first time. The `getPromise` function returns a promise
    that resolves to a module. The module’s default export must be a component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`lazy`一个函数`getPromise`，当React需要首次渲染该组件时调用。`getPromise`函数返回一个解析为模块的承诺。模块的默认导出必须是一个组件。
- en: But we don’t have a `Calendar` module (we’re imagining it to be a large file)
    so, for the sake of our example, and to reinforce the idea that modules are objects
    with default and named properties, let’s mock up a module and make it lazy by
    using the following code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们没有`Calendar`模块（我们想象它是一个大文件），所以为了我们的示例，并加强模块是具有默认和命名属性的对象的这一概念，让我们模拟一个模块，并使用以下代码使其延迟加载。
- en: Listing 11.8 Creating a pretend module and making its component lazy
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 创建一个模拟模块并使其组件延迟加载
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Assign a function component to the default property.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将一个函数组件分配给默认属性。
- en: ❷ Return a promise that resolves to our module.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个解析为我们模块的承诺。
- en: ❸ Create a lazy component by passing getPromise to lazy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过将`getPromise`传递给`lazy`来创建一个延迟加载的组件。
- en: 'Great! We have all the pieces in place to try out our first lazy component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经准备好所有部件来尝试我们的第一个延迟加载组件：
- en: A “huge” calendar component (`()` `=>` `<div>Big` `Calendar</div>`)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“巨大的”日历组件(`()` `=>` `<div>Big` `Calendar</div>`)
- en: A module with the calendar component assigned to its default property
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日历组件分配给其默认属性的模块
- en: A promise that resolves to the module (after three seconds)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解析为模块的承诺（三秒后）
- en: A function, `getPromise`, that creates and returns the promise
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个创建并返回承诺的函数`getPromise`
- en: A lazy component, `LazyCalendar`, created by passing `getPromise` to `lazy`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`getPromise`传递给`lazy`创建的延迟组件`LazyCalendar`
- en: A wrapper component, `CalendarWrapper`, that shows `LazyCalendar` only after
    a user clicks a button
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包装组件`CalendarWrapper`，仅在用户点击按钮后显示`LazyCalendar`
- en: An `App` component that includes two `CalenderWrapper` components
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含两个`CalenderWrapper`组件的`App`组件
- en: The following listing puts all the pieces into place. It’s part of a React application
    on CodeSandbox. The code to create and use the lazy component is in bold.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表将所有部件放在一起。它是CodeSandbox上的一个React应用程序的一部分。创建和使用延迟组件的代码以粗体显示。
- en: '*Live*: [https://9qj5f.csb.app](https://9qj5f.csb.app), *Code*: [https://codesandbox.io/s/lazycalendarnosuspense-9qj5f](https://codesandbox.io/s/lazycalendarnosuspense-9qj5f)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*: [https://9qj5f.csb.app](https://9qj5f.csb.app)，*代码*: [https://codesandbox.io/s/lazycalendarnosuspense-9qj5f](https://codesandbox.io/s/lazycalendarnosuspense-9qj5f)'
- en: Listing 11.9 Running our app with a lazy component
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 使用延迟组件运行我们的应用程序
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Set a component as the default export from a module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将组件作为模块的默认导出。
- en: ❷ Resolve a promise with the module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用模块解析一个promise。
- en: ❸ Convert the component-resolving promise into a lazy component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将组件解析的promise转换为懒加载组件。
- en: ❹ Use the lazy component like any other component.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如同其他组件一样使用懒加载组件。
- en: 'Remember, for real modules we use a dynamic import; we pass `lazy` a function
    that calls the `import` function. So, if the `Calendar` component is the default
    export from a Calendar.js module, we’d create the lazy component like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于真正的模块，我们使用动态导入；我们传递一个函数给`lazy`，该函数调用`import`函数。所以，如果`Calendar`组件是从Calendar.js模块的默认导出，我们会创建懒加载组件如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But wait! If you follow the link to CodeSandbox and click one of the Show Calendar
    buttons, you’ll see we have a problem, an evil error! (Actually, like most React
    errors, it’s quite a friendly error; it tells us exactly what we have to do.)
    The error is shown in figure 11.3\. It tells us to “Add a <Suspense fallback=.
    . .> component higher in the tree to provide a loading indicator or placeholder
    to display.” Let’s follow its advice.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！如果你点击链接到CodeSandbox并点击其中一个显示日历按钮，你会看到一个问题，一个邪恶的错误！（实际上，就像大多数React错误一样，它相当友好；它告诉我们确切需要做什么。）错误如图11.3所示。它告诉我们“在树中添加一个`<Suspense
    fallback=. . .>`组件，以提供加载指示器或占位符来显示。”让我们遵循它的建议。
- en: '![](../Images/11-3.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-3.png)'
- en: 'Figure 11.3  Our app starts out fine, but clicking a Show Calendar button causes
    an error: “A React component suspended while rendering, but no fallback UI was
    specified.”'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3  我们的应用一开始运行良好，但点击显示日历按钮会导致错误：“渲染时挂起的React组件，但没有指定回退UI。”
- en: 11.2.2 Specifying fallback content with the Suspense component
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 使用Suspense组件指定回退内容
- en: It takes time to load a component, and our imaginary `Calendar` component code
    is a big, beefy file. What should our app do when it’s time to show the calendar
    but it hasn’t yet loaded? We need some kind of loading indicator to let the user
    know the calendar is on the way. Maybe something as simple as in figure 11.4,
    just text saying “Loading . . . ”.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 加载组件需要时间，我们想象的`Calendar`组件代码是一个大而健壮的文件。当需要显示日历但尚未加载时，我们的应用应该做什么？我们需要某种类型的加载指示器来让用户知道日历正在路上。可能就像图11.4中那样简单，只是显示“加载中...”这样的文本。
- en: '![](../Images/11-4.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-4.png)'
- en: Figure 11.4 When the user first clicks the Show Calendar button, the app displays
    a loading indicator until the component has loaded.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 当用户第一次点击显示日历按钮时，应用显示加载指示器，直到组件加载完成。
- en: 'Fortunately, as the error in figure 11.3 points out, React provides an easy
    way to specify fallback UI: the `Suspense` component. Use the `Suspense` component
    to wrap UI that contains one or more lazy components in its tree:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如图11.3中的错误所指出的，React提供了一个简单的方式来指定回退UI：`Suspense`组件。使用`Suspense`组件来包装包含一个或多个懒加载组件的UI：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Use the `fallback` prop to specify what you want the `Suspense` component to
    render until all its lazy descendants have returned some UI. In the following
    listing, we wrap both `CalendarWrapper` components in their own `Suspense` component
    so that the app knows what to do if one of the wrapper’s `LazyCalendar` components
    is loading.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fallback`属性指定`Suspense`组件在所有懒加载子组件返回一些UI之前要渲染的内容。在下面的列表中，我们将两个`CalendarWrapper`组件都包装在自己的`Suspense`组件中，这样应用就知道如果其中一个包装器的`LazyCalendar`组件正在加载时应该做什么。
- en: '*Live*: [https://h0hgg.csb.app](https://h0hgg.csb.app), *Code*: [https://codesandbox.io/s/lazycalendar-h0hgg](https://codesandbox.io/s/lazycalendar-h0hgg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*: [https://h0hgg.csb.app](https://h0hgg.csb.app)，*代码*: [https://codesandbox.io/s/lazycalendar-h0hgg](https://codesandbox.io/s/lazycalendar-h0hgg)'
- en: Listing 11.10 Wrapping both calendar regions in `Suspense` components
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.10 使用`Suspense`组件包装两个日历区域
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Wrap UI that contains lazy components in Suspense components.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将包含懒加载组件的UI包装在Suspense组件中。
- en: ❷ Use the fallback prop to specify placeholder UI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用fallback属性指定占位符UI。
- en: If you follow the link to the new version on CodeSandbox and click the Show
    Calendar button, you’ll see the “Loading . . . ” fallback from figure 11.4 for
    three seconds and then the `Calendar` component will render, saying, “Big Calendar,”
    as shown in figure 11.5.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击CodeSandbox上的新版本链接并点击显示日历按钮，你会看到图11.4中的“加载中...”回退持续三秒钟，然后`Calendar`组件将渲染，显示“大日历”，如图11.5所示。
- en: '![](../Images/11-5.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-5.png)'
- en: Figure 11.5 Once the `Calendar` component has loaded, it replaces the fallback
    content.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 一旦`Calendar`组件加载，它将替换回退内容。
- en: Once the `Calendar` component has loaded, it doesn’t need to load again, so
    clicking the second Show Calendar button will immediately render the second `Calendar`
    component. In listing 11.10, each `CalendarWrapper` component is wrapped in its
    own `Suspense` component. But a single `Suspense` component might be all you need.
    The following code snippet shows a single `Suspense` component for both `CalendarWrapper`
    components.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Calendar`组件加载完成，它就不需要再次加载，因此点击第二个显示日历按钮将立即渲染第二个`Calendar`组件。在列表11.10中，每个`CalendarWrapper`组件都被包裹在其自己的`Suspense`组件中。但可能只需要一个`Suspense`组件。以下代码片段显示了两个`CalendarWrapper`组件的单个`Suspense`组件。
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you wrap both components in this way, clicking a Show Calendar button for
    the first time will display the shared “Loading . . . ” fallback shown in figure
    11.6.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以这种方式包裹两个组件，第一次点击显示日历按钮将显示图11.6中所示的共享“加载中...”回退内容。
- en: '![](../Images/11-6.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-6.png)'
- en: Figure 11.6 Multiple components can be wrapped in a single `Suspense` component.
    The fallback content is shown if any descendant is loading.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 多个组件可以包裹在单个`Suspense`组件中。如果任何子组件正在加载，将显示回退内容。
- en: When a lazy component is first rendered, React will look all the way up the
    component tree and use the first `Suspense` component that it finds. That `Suspense`
    component will render its fallback UI in place of its children. If no `Suspense`
    component is found, React will throw the error we saw back in figure 11.3.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当懒加载组件首次渲染时，React会沿着组件树向上查找，并使用它找到的第一个`Suspense`组件。该`Suspense`组件将渲染其回退UI以替换其子组件。如果没有找到`Suspense`组件，React将抛出我们在图11.3中看到的错误。
- en: The ability to specify fallback UI separate from the components that are loading
    gives us greater flexibility when tweaking our UI for the best possible user experience.
    But how do the separate components work together? How exactly does React look
    up the component tree for a `Suspense` component? What mechanism do lazy components
    use to either render a loaded component or pass rendering to parents? Well, I’m
    here to help. I’ll tell you how they do it, and that’s a promise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 能够指定与加载组件分开的回退UI，这在我们调整UI以获得最佳用户体验时提供了更大的灵活性。但是，这些单独的组件是如何协同工作的？React是如何查找`Suspense`组件的组件树的？懒加载组件使用什么机制来渲染已加载的组件或将渲染传递给父组件？嗯，我就在这里帮助你们。我会告诉你们它们是如何做到的，这是一个承诺。
- en: 11.2.3 Understanding how lazy and Suspense work together
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 理解懒加载和Suspense如何协同工作
- en: 'We can think of lazy components as having an internal status of uninitialized,
    pending, resolved, or rejected. When React first tries to render a lazy component,
    the component is uninitialized but has a promise-returning function React calls
    to load the module. For example, here the promise-returning function is `getPromise`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将懒加载组件视为具有内部状态：未初始化、挂起、已解析或拒绝。当React首次尝试渲染懒加载组件时，组件处于未初始化状态，但React会调用一个返回promise的函数来加载模块。例如，这里的返回promise的函数是`getPromise`：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The promise should resolve to a module whose `default` property is the component.
    Once it’s resolved, React can set the status of the lazy component to `resolved`
    and return the component, ready to be rendered, something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个promise应该解析为一个模块，其`default`属性是组件。一旦解析完成，React可以将懒加载组件的状态设置为`已解析`并返回组件，准备渲染，类似于以下这样：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `else` clause contains the key to communicating with `Suspense` components
    further up the tree: if the promise has not resolved, React will `throw` it, just
    as you’d throw an error. `Suspense` components are set up to catch promises, rendering
    fallback UI if the promise is pending.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`子句包含了与树中更上层的`Suspense`组件通信的关键：如果promise尚未解析，React将`抛出`它，就像你会抛出一个错误一样。`Suspense`组件被设置为捕获promise，如果promise处于挂起状态，则渲染回退UI。'
- en: To recap, table 11.1 shows the steps React takes when it encounters a lazy component
    in the tree. It performs the first action it can.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，表11.1显示了React在树中遇到懒加载组件时采取的步骤。它执行它能够执行的第一步操作。
- en: Table 11.1 The steps React takes when it encounters a lazy component
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 React遇到懒加载组件时采取的步骤
- en: '| If the LazyComponent object contains | Actions |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 如果LazyComponent对象包含 | 动作 |'
- en: '| A component | Call the component. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 调用组件。 |'
- en: '| An unresolved promise | Throw the promise. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 未解析的promise | 抛出promise。 |'
- en: '| A function that returns a promise | Call the function to get the promise.Store
    the promise in the `LazyComponent` object.Call the promise’s `then` method so
    that when the promise resolves, the component is stored in the `LazyComponent`
    object.Throw the promise. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 一个返回 Promise 的函数 | 调用函数以获取 Promise。将 Promise 存储在 `LazyComponent` 对象中。调用 Promise
    的 `then` 方法，以便当 Promise 解析时，组件存储在 `LazyComponent` 对象中。抛出 Promise。|'
- en: Seasoned promise-wranglers may be wondering what happens if the promise is rejected,
    maybe because of a network error. `Suspense` components don’t handle the UI for
    errors; that’s the remit of the error boundary, which we discuss in section 11.3\.
    Before that, let’s split the booking app into lazy-loaded routes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的 Promise 管理员可能会想知道如果 Promise 被拒绝会发生什么，可能是因为网络错误。`Suspense` 组件不处理错误 UI；这是错误边界的工作范围，我们在第
    11.3 节中讨论。在此之前，让我们将预订应用程序拆分为懒加载路由。
- en: 11.2.4 Code splitting an app on its routes
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 在其路由上拆分应用程序的代码
- en: You now know how to split our app into separate bundles by lazy-loading some
    of the components. There’s no need to load a lot of code if it’s not going to
    be used. Instead, as the user opts to use certain functionality, the code for
    that functionality can be loaded, with some fallback UI displayed while it loads.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道如何通过懒加载一些组件将我们的应用程序拆分为单独的包。如果代码不会被使用，就没有必要加载大量代码。相反，当用户选择使用某些功能时，可以加载该功能的代码，同时显示一些回退
    UI 以在加载时显示。
- en: Our booking app example is already split into separate routes for bookings,
    bookables, and users. The routes seem like a sensible place to start splitting
    our code. The following listing updates the `App` component, lazy-loading each
    page component and wrapping the `Routes` component in a `Suspense` component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的预订应用程序示例已经根据预订、可预订项目和用户拆分为单独的路由。路由似乎是开始拆分代码的合理位置。下面的列表更新了 `App` 组件，懒加载每个页面组件，并将
    `Routes` 组件包裹在 `Suspense` 组件中。
- en: 'Branch: 1101-lazy-suspense, File: /src/components/App.js'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1101-lazy-suspense，文件：/src/components/App.js
- en: Listing 11.11 Lazy-loading page components in `App`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 在 `App` 中懒加载页面组件
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Import the lazy function and the Suspense component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入懒加载函数和 `Suspense` 组件。
- en: ❷ Lazy-load the three page components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 懒加载三个页面组件。
- en: ❸ Wrap the page routes in a Suspense component with PageSpinner fallback.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将页面路由包裹在带有 `PageSpinner` 回退的 `Suspense` 组件中。
- en: ❹ Use the lazy-loaded page components just like any other.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 就像使用任何其他懒加载页面组件一样使用。
- en: Now, if a user first visits the Users page, say, only the code for the `App`
    component, the `UsersPage` component, and their dependencies is loaded. Code for
    `BookingsPage` and `BookablesPage` is not included. While the components load,
    our usual `PageSpinner` component is rendered under the top menu bar.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户首先访问用户页面，比如，只有 `App` 组件、`UsersPage` 组件及其依赖项的代码被加载。`BookingsPage` 和 `BookablesPage`
    的代码不包括在内。在组件加载时，我们的常用 `PageSpinner` 组件在顶部菜单栏下渲染。
- en: The `BookablesPage` component includes some nested routes, and the user might
    navigate directly to any one of them without choosing to visit the others. Loading
    all of the code at once is unnecessary, so let’s get lazy once again in the following
    listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesPage` 组件包含一些嵌套路由，用户可能直接导航到其中的任何一个，而无需选择访问其他路由。一次性加载所有代码是不必要的，所以让我们在下面的列表中再次进行懒加载。'
- en: 'Branch: 1101-lazy-suspense, File: /src/components/Bookables/BookablesPage.js'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1101-lazy-suspense，文件：/src/components/Bookables/BookablesPage.js
- en: Listing 11.12 Lazy-loading nested components for `BookablesPage`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 为 `BookablesPage` 懒加载嵌套组件
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Lazy-load the components.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 懒加载组件。
- en: ❷ Use the components in exactly the same way as before.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按照之前完全相同的方式使用组件。
- en: This time, we don’t wrap the routes in a `Suspense` component. Our existing
    fallback in `App` will happily deal with any *suspending* components (components
    that throw pending promises) below it in the tree. The `PageSpinner` is an appropriate
    fallback because all three components—`BookablesView`, `BookablesEdit`, and `BookablesNew`—are
    page-level components. They all replace whatever was on the page before them (excluding
    the ever-present menu bar at the top). Feel free to experiment with adding `Suspense`
    components around the nested routes; a “Loading Edit Form . . . ” message might
    be useful.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不在路由中包裹 `Suspense` 组件。我们现有的 `App` 中的回退将愉快地处理树中任何正在挂起的组件（抛出挂起 Promise 的组件）。`PageSpinner`
    是一个合适的回退，因为三个组件——`BookablesView`、`BookablesEdit` 和 `BookablesNew`——都是页面级组件。它们都替换了它们之前的页面上的任何内容（不包括顶部始终存在的菜单栏）。请随意尝试在嵌套路由周围添加
    `Suspense` 组件；一条“正在加载编辑表单……”的消息可能很有用。
- en: '`Suspense` components handle pending promises. What happens when a component
    throws a rejected promise or, more conventionally, throws an error while rendering?
    If `Suspense` components don’t want to know, what does? It’s time to set some
    boundaries for those pesky errors.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suspense` 组件处理挂起的承诺。当组件抛出一个拒绝的承诺或更传统地，在渲染时抛出错误时会发生什么？如果 `Suspense` 组件不想知道，那会是谁呢？是时候为那些讨厌的错误设定一些边界了。'
- en: 11.3 Catching errors with error boundaries
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用错误边界捕获错误
- en: React doesn’t provide a component for catching errors thrown in child components.
    But it does provide a couple of life-cycle methods that class components can implement
    if they want to catch and report errors. If one of your class components implements
    one or both of those methods, it is considered an *error boundary*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: React 没有提供用于捕获子组件抛出的错误的组件。但它确实提供了一些生命周期方法，类组件可以实现这些方法来捕获和报告错误。如果你的一个类组件实现了其中之一或两个方法，它就被认为是**错误边界**。
- en: If you wrap all or part of the component tree in the error boundary, it will
    render fallback UI if one of the wrapped components throws an error. Figure 11.7
    shows the kind of fallback UI we might use in the bookings app if an error is
    thrown by one of the page components or one of their descendants.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将组件树的全部或部分包裹在错误边界中，如果其中一个包装组件抛出错误，它将渲染回退用户界面。图 11.7 显示了在页面组件或其子组件之一抛出错误时，预订应用程序可能使用的回退用户界面类型。
- en: '![](../Images/11-7.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-7.png)'
- en: Figure 11.7 Rather than unmounting the app, an error boundary can show some
    fallback UI if an error occurs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 与卸载应用程序不同，如果发生错误，错误边界可以显示一些回退用户界面。
- en: 'Say we have such an error boundary component, `ErrorBoundary`, and we want
    it to catch errors for any of our routes in the bookings app. We want to be able
    to specify where the error boundary goes, and which components are replaced by
    the fallback UI when an error is thrown. We want to use `ErrorBoundary` like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个这样的错误边界组件 `ErrorBoundary`，我们希望它能够捕获预订应用程序中任何路由的错误。我们希望能够指定错误边界的位置，以及当抛出错误时哪些组件被回退
    UI 替换。我们希望像这样使用 `ErrorBoundary`：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Leave some UI outside the error boundary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在错误边界之外留下一些 UI。
- en: ❷ Use an error boundary to catch errors from wrapped components.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用错误边界来捕获包装组件中的错误。
- en: ❸ Catch promises from wrapped components.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 捕获包装组件中的承诺。
- en: ❹ Render wrapped components when all is well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当一切正常时渲染包装组件。
- en: Only the page components are replaced by the fallback; the app continues to
    show the menu in the `header` element, as you can see at the top of figure 11.7\.
    The figure also shows the fallback UI, the message “Something went wrong,” that
    the app displays in response to an error in a child component.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只有页面组件被回退替换；应用程序继续在 `header` 元素中显示菜单，如图 11.7 的顶部所示。该图还显示了回退 UI，应用程序在子组件中发生错误时显示的消息“出了点问题”。
- en: But where does that UI come from? And what are the life-cycle methods we have
    to implement in our error boundary class component? A good place to start (as
    always) is in the React docs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但那个 UI 从哪里来？我们在错误边界类组件中必须实现哪些生命周期方法？（一如既往地）一个好的起点是查看 React 文档。
- en: 11.3.1 Checking out the error boundary example in the React docs
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 检查 React 文档中的错误边界示例
- en: To catch any errors thrown when our child components render, we need a class
    component that implements one or both of the life-cycle methods `getDerivedStateFromError`
    and `componentDidCatch`. The following listing shows an error boundary component
    that implements those methods, from the React docs on reactjs.org. It has the
    hardcoded fallback UI shown in figure 11.7.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获子组件渲染时抛出的任何错误，我们需要一个实现了生命周期方法 `getDerivedStateFromError` 和 `componentDidCatch`
    的类组件。以下列表展示了来自 reactjs.org 的 React 文档中实现这些方法的错误边界组件。它显示了图 11.7 中显示的硬编码的回退用户界面。
- en: 'React docs: [https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: React 文档：[https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)
- en: Listing 11.13 The `ErrorBoundary` component on reactjs.org
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 reactjs.org 上的 `ErrorBoundary` 组件
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Extend React’s Component class to create an error boundary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 React 的 Component 类扩展以创建一个错误边界。
- en: ❷ Include a hasError property in state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在状态中包含一个 hasError 属性。
- en: ❸ Return new state when an error is caught.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当捕获到错误时返回新状态。
- en: ❹ Logs errors if they are caught.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果捕获到错误，则记录错误。
- en: ❺ Renders fallback UI if there’s an error.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果有错误，则渲染回退 UI。
- en: ❻ Render the wrapped components if there’s no error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果没有错误，则渲染包装组件。
- en: 'The component manages state with a `hasError` property that flags whether or
    not the component has caught an error. The `componentDidCatch` method also logs
    any error information to an external logging service. Finally, the `render` method
    returns the wrapped components or, if the `getDerivedStateFromError` method has
    set the error flag to `true`, hardcoded fallback UI:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用`hasError`属性管理状态，该属性标记组件是否捕获了错误。`componentDidCatch`方法还将任何错误信息记录到外部日志服务。最后，`render`方法返回包裹的组件，或者如果`getDerivedStateFromError`方法已将错误标志设置为`true`，则返回硬编码的回退UI：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But listing 11.13 is just an example error boundary. Let’s make our own.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但列表11.13只是一个示例错误边界。让我们自己创建一个。
- en: 11.3.2 Creating our own error boundary
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 创建我们自己的错误边界
- en: The error boundary from the React docs is just one possibility. We may want
    something tailored more to our apps. The fallback UI in figure 11.8, for example,
    includes an instruction for the user to “Try reloading the page.”
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: React文档中的错误边界只是一个可能性。我们可能想要为我们的应用定制更多。例如，图11.8中的回退UI包括一个指示用户“尝试重新加载页面”的说明。
- en: '![](../Images/11-8.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-8.png)'
- en: Figure 11.8 Our `ErrorBoundary` component allows us to specify custom UI as
    the fallback when an error occurs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 我们的`ErrorBoundary`组件允许我们在发生错误时指定自定义UI作为回退。
- en: Rather than just switching one hardcoded message for another, let’s have a go
    at implementing an error boundary that lets us specify different fallbacks each
    time we use it. The following listing shows just such a component. We’re not going
    to log any errors, so we leave out the `componentDidCatch` method, and users of
    the component can specify UI in a `fallback` prop.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅切换一个硬编码的消息，让我们尝试实现一个错误边界，这样我们就可以在每次使用时指定不同的回退。下面的列表显示了一个这样的组件。我们不会记录任何错误，因此省略了`componentDidCatch`方法，并且组件的使用者可以在`fallback`属性中指定UI。
- en: 'Branch: 1102-error-boundary, File: /src/components/UI/ErrorBoundary.js'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1102-error-boundary，文件：/src/components/UI/ErrorBoundary.js
- en: Listing 11.14 A simple, customizable `ErrorBoundary` component
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 一个简单、可定制的`ErrorBoundary`组件
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Get the wrapped components from props.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从props中获取包裹的组件。
- en: ❷ Get the fallback from props, or use a default fallback.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从props中获取回退，或使用默认回退。
- en: ❸ Render the fallback or the wrapped components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 渲染回退或包裹的组件。
- en: We’ll put the new error boundary to use straightaway in the bookings app, as
    a catchall for errors thrown on any of our three pages. In the following listing,
    the `App` component now wraps the `Suspense` and `Routes` components with `ErrorBoundary`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即在预订应用中使用新的错误边界，作为对任何三个页面抛出的错误的通用捕获。在下面的列表中，`App`组件现在使用`ErrorBoundary`包裹了`Suspense`和`Routes`组件。
- en: 'Branch: 1102-error-boundary, File: /src/components/App.js'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1102-error-boundary，文件：/src/components/App.js
- en: Listing 11.15 `App` with an error boundary
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.15 带有错误边界的`App`
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Import our error boundary.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们的错误边界。
- en: ❷ Wrap the main routes in the error boundary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将主要路由包裹在错误边界中。
- en: ❸ Provide some fallback UI.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提供一些回退UI。
- en: ❹ Maybe include advice on what to do.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 可能包括一些操作建议。
- en: ❺ Wrap the main routes in the error boundary.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将主要路由包裹在错误边界中。
- en: 'We wrap the app’s main routes in an error boundary. To test it out, let’s throw
    an error from a descendant component. In the `BookableForm` component, just before
    it returns its UI, add this line:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用的主要路由包裹在一个错误边界中。为了测试它，让我们从一个子组件抛出一个错误。在`BookableForm`组件中，在其返回UI之前，添加以下行：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, reload the app, navigate to the Bookables page, and click the New button
    under the list of bookables or the Edit button at the top right of the bookable
    details header. Dismiss the error overlay shown in figure 11.9; it’s added by
    Create React App and won’t appear in production. You should see the fallback UI
    in figure 11.8.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新加载应用，导航到可预订页面，然后在可预订列表下点击“新建”按钮或点击可预订详情页顶部的右上角的“编辑”按钮。关闭图11.9中显示的错误覆盖层；这是由Create
    React App添加的，在生产环境中不会出现。你应该看到图11.8中的回退UI。
- en: '![](../Images/11-9.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-9.png)'
- en: Figure 11.9 In development mode, Create React App’s server overlays the page
    with an error message. Press Esc or click the X to dismiss the overlay, revealing
    the error boundary’s fallback UI.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 在开发模式下，Create React App的服务器使用错误消息覆盖页面。按Esc键或点击X以关闭覆盖层，显示错误边界的回退UI。
- en: If a single page of an app includes multiple components and the failure of one
    component doesn’t break the others—the user can keep using the page—then consider
    wrapping that component in its own error boundary. There’s no need to bar users
    from working functionality elsewhere when error boundaries can safely quarantine
    wobbly widgets. It would be nice to be able to stabilize the wobbly ones, though,
    and we can further customize our error boundary components to make it easier to
    recover from errors.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用的单页包含多个组件，并且一个组件的失败不会影响其他组件——用户可以继续使用该页面——那么考虑将该组件包裹在其自己的错误边界中。当错误边界可以安全地隔离不稳定的组件时，没有必要阻止用户在其他地方使用功能。不过，如果能稳定这些不稳定的组件就更好了，我们可以进一步自定义错误边界组件，使其更容易从错误中恢复。
- en: 11.3.3 Recovering from errors
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 从错误中恢复
- en: Asking users to refresh the page is one approach that might work for errors
    not caught lower down the component tree. But, especially for error boundaries
    around specific widgets within the main app, like chat windows or stock tickers,
    or social media streams, you might want to give the users a button to click to
    try resetting or reloading a specific component within the app. In chapter 12,
    we’ll use a prebuilt error boundary package from npm called `react-error-boundary`.
    It provides handy extra functionality to make its error boundary more flexible
    and reusable. Check it out on GitHub at [https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要求用户刷新页面是处理组件树下方未捕获的错误可能有效的一种方法。但是，特别是对于主应用中特定小部件周围的错误边界，如聊天窗口或股票行情，或社交媒体流，您可能希望给用户提供一个按钮来尝试重置或重新加载应用中的特定组件。在第
    12 章中，我们将使用从 npm 下载的预构建错误边界包 `react-error-boundary`。它提供了方便的额外功能，使其错误边界更加灵活和可重用。在
    GitHub 上查看它：[https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary)。
- en: Chapter 12 continues this chapter’s theme of giving React something to render
    while it waits for the final UI to be ready. Rather than waiting for components
    to load, we’ll be waiting for data or images. Join me there for our first explorations
    of experimental React features.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12 章继续本章的主题，即当 React 等待最终 UI 准备就绪时，给它一些可以渲染的内容。我们不会等待组件加载，而是等待数据或图像。加入我，我们将探索实验性的
    React 功能。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Include dependencies as static imports at the top of a JavaScript file. Bundlers
    like webpack can then perform tree shaking to create a bundle, a single file containing
    all the code that the app uses.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件的顶部将依赖项作为静态导入。像 webpack 这样的打包器可以执行摇树优化来创建一个包，一个包含应用使用所有代码的单个文件。
- en: 'To load JavaScript dependencies only in response to a user action or other
    event, dynamically load modules with the `import` function:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了仅在用户操作或其他事件响应时加载 JavaScript 依赖项，使用 `import` 函数动态加载模块：
- en: '[PRE30]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The dynamic import returns a promise that returns a module. Access default
    and named exports on the module object:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态导入返回一个返回模块的承诺。在模块对象上访问默认和命名导出：
- en: '[PRE31]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use `React.lazy` to load components only when they are first rendered. Pass
    `lazy` a function that returns the promise from a dynamic import. The promise
    must resolve to a module whose default property is a component:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `React.lazy` 仅在组件首次渲染时加载组件。将 `lazy` 传递一个返回动态导入承诺的函数。承诺必须解析到一个模块，其默认属性是一个组件：
- en: '[PRE32]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Use `Suspense` components to tell React what to render while waiting for lazy
    components to load. (`Suspense` components catch pending promises thrown by not-yet-loaded
    components.)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Suspense` 组件来告诉 React 在等待懒加载组件加载时应该渲染什么。(`Suspense` 组件捕获尚未加载的组件抛出的挂起承诺。)
- en: '[PRE33]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use error boundary components to tell React what to render if an error occurs
    while rendering a child component. Error boundaries are class components that
    implement one or both of the life-cycle methods `getDerivedStateFromError` and
    `componentDidCatch`:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误边界组件来告诉 React 在渲染子组件时发生错误时应该渲染什么。错误边界是实现了 `getDerivedStateFromError` 和 `componentDidCatch`
    生命周期方法之一的类组件：
- en: '[PRE34]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Customize error boundaries to provide tailored fallback UI and error-recovery
    strategies.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义错误边界以提供定制的回退 UI 和错误恢复策略。
