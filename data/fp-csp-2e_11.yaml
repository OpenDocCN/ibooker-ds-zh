- en: 8 Functional error handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 函数式错误处理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Representing alternative outcomes with `Either`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Either` 表示替代结果
- en: Chaining operations that may fail
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接可能失败的操作
- en: Distinguishing business validation from technical errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分业务验证和技术错误
- en: 'Error handling is an important part of our applications. It’s also one aspect
    in which the functional and imperative programming styles differ starkly:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是我们应用程序的重要部分。它也是函数式和命令式编程风格差异显著的一个方面：
- en: '*Imperative programming uses special statements like* `throw` *and* `try-catch`*,
    which disrupt the normal program flow.* This introduces side effects as discussed
    in section 3.1.1.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令式编程使用特殊的语句如* `throw` *和* `try-catch`*，这会打断正常的程序流程。* 这引入了在第 3.1.1 节中讨论的副作用。'
- en: '*Functional programming strives to minimize side effects, so throwing exceptions
    is generally avoided.* Instead, if an operation can fail, it should return a representation
    of its outcome, including an indication of success or failure, as well as its
    result (if successful) or some error data otherwise. In other words, errors in
    FP are just *payload*.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式编程力求最小化副作用，因此通常避免抛出异常。* 相反，如果一个操作可能失败，它应该返回其结果的表示，包括成功或失败的指示，以及（如果成功）其结果或一些错误数据。换句话说，FP
    中的错误只是 *负载*。'
- en: There are lots of problems with the imperative, exception-based approach. It
    has been said that `throw` has similar semantics to `goto`, and this begs the
    question of why imperative programmers have banished `goto` but not `throw`.[¹](#pgfId-1110828)
    There’s also a lot of confusion around when to use exceptions and when to use
    other error-handling techniques.[²](#pgfId-1110831) I feel that the functional
    approach brings a lot more clarity to the complex area of error handling, and
    I hope to convince you of this through the examples in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 基于命令式的异常处理方法存在许多问题。有人说过 `throw` 与 `goto` 具有相似的语义，这引发了一个问题：为什么命令式程序员禁止使用 `goto`
    但没有禁止 `throw`。[¹](#pgfId-1110828) 关于何时使用异常和何时使用其他错误处理技术也存在很多混淆。[²](#pgfId-1110831)
    我认为函数式方法为复杂的错误处理领域带来了更多的清晰度，我希望通过本章的示例来说服你。
- en: We’ll look at how the functional approach can be put into practice and how you
    can use the function signature to declare that the function can fail—namely, by
    returning a type that includes error information in its payload. Errors can then
    be consumed in the calling function just like any other value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将函数式方法付诸实践，以及如何使用函数签名来声明函数可能失败——即通过返回一个在其负载中包含错误信息的类型。然后，错误可以在调用函数中像任何其他值一样被消费。
- en: 8.1 A safer way to represent outcomes
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 一种更安全的表示结果的方法
- en: 'In previous chapters, you saw that you could use `Option` not only to represent
    the absence of a value but also the absence of a *valid* value. You can use `Some`
    to signal that everything went OK and `None` to signal that something went wrong.
    In other words, functional error handling can sometimes be satisfactorily achieved
    by using the `Option` type. Here are a couple of examples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到可以使用 `Option` 不仅表示值的缺失，也表示有效值的缺失。你可以使用 `Some` 来表示一切顺利，使用 `None` 来表示出错。换句话说，函数式错误处理有时可以通过使用
    `Option` 类型来满意地实现。以下是一些示例：
- en: '*Parsing a string into a number*—Return `None` to indicate that the given string
    wasn’t a valid representation for a number.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将字符串解析为数字*——返回 `None` 以指示给定的字符串不是数字的有效表示。'
- en: '*Retrieving an item from a collection*—Return `None` to indicate that no suitable
    item was found.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从集合中检索一个项目*——返回 `None` 以指示没有找到合适的项。'
- en: In scenarios like these, there’s really only one way for the function to fail
    to compute a valid result and that’s represented with `None`. Functions that return
    `Option<T>` rather than just `T` are acknowledging in their signature that the
    operation may fail. One way to look at it is that, along with the result `T`,
    they return some extra payload (namely, the `isSome` flag in our implementation
    of `Option`) that signals success or failure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，函数无法计算有效结果的方式只有一个，即用 `None` 表示。返回 `Option<T>` 而不是 `T` 的函数在其签名中承认操作可能失败。一种看待它的方法是，除了结果
    `T` 之外，它们还返回一些额外的负载（即我们 `Option` 实现中的 `isSome` 标志），这表示成功或失败。
- en: What if there are several ways in which an operation could fail? What if, for
    instance, the BOC application receives a complex request, such as a request to
    make a money transfer? Surely the user would need to know not only whether the
    transfer was successfully booked but also, in case of failure, the reason(s) for
    failure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个操作有几种可能失败的方式呢？比如，如果BOC应用程序收到一个复杂的请求，比如一个转账请求，用户当然需要知道转账是否成功预订，而且在失败的情况下，还需要知道失败的原因。
- en: In such scenarios, `Option` is too limited because it doesn’t convey any details
    about why an operation has failed. Accordingly, we’ll need a richer way to represent
    outcomes—one that includes information about what exactly has gone wrong.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Option`太有限了，因为它不传达任何关于操作失败原因的详细信息。因此，我们需要一种更丰富的方式来表示结果——它包括关于到底出了什么问题的信息。
- en: 8.1.1 Capturing error details with Either
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 使用`Either`捕获错误细节
- en: 'A classic functional approach to this problem is to use the `Either` type that,
    in the context of an operation with two possible outcomes, captures details about
    the outcome that has taken place. By convention, the two possible outcomes are
    indicated with `Left` and `Right` (as figure 8.1 shows), likening the `Either`-producing
    operation to a *fork*: things can go one way or another.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题的一个经典函数式方法是使用`Either`类型，在操作有两个可能结果的情况下，它捕获了已发生的结果的详细信息。按照惯例，两个可能的结果用`Left`和`Right`表示（如图8.1所示），将`Either`生成操作比作一个*分叉点*：事情可以朝一个方向或另一个方向发展。
- en: '![](Images/CH08_F01_Buonanno2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH08_F01_Buonanno2.png)'
- en: Figure 8.1 `Either` represents one of two possible outcomes. It indicates that
    a computation could potentially result in a `Left` or a `Right`. The image depicts
    an example in which the left branch is taken.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 `Either`表示两种可能的结果之一。它表明计算可能产生`Left`或`Right`。图像描述了一个例子，其中选择了左侧分支。
- en: 'Although `Left` and `Right` can be seen in a neutral light, by far the most
    common use of `Either` is to represent the outcome of an operation that may fail,
    in which case, `Left` is used to indicate failure and `Right` to indicate success.
    So, remember this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Left`和`Right`可以从一个中性的角度来看，但到目前为止，`Either`最常见的使用是表示可能失败的操作的结果，在这种情况下，`Left`用来表示失败，`Right`用来表示成功。所以，记住这个：
- en: '`Right` = all right'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Right` = 没问题'
- en: '`Left` = something wrong'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Left` = 出了问题'
- en: In this biased acceptation, `Either` is just like an `Option` that has been
    enriched with some data about the error. An `Option` can be in the `None` or `Some`
    state, and `Either` can similarly be in the `Left` or `Right` state, as summarized
    in table 8.1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种有偏见的接受中，`Either`就像是一个增加了错误信息的`Option`。`Option`可以是`None`或`Some`状态，而`Either`也可以类似地处于`Left`或`Right`状态，如表8.1所示。
- en: Table 8.1 `Option` and `Either` can both represent possible failure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 `Option`和`Either`都可以表示可能的失败。
- en: '|  | Failure | Success |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  | 失败 | 成功 |'
- en: '| `Option<T>` | `None` | `Some<T>` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Option<T>` | `None` | `Some<T>` |'
- en: '| `Either<L, R>` | `Left<L>` | `Right<R>` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `Either<L, R>` | `Left<L>` | `Right<R>` |'
- en: If `Option` can be symbolically defined as
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Option`可以象征性地定义为
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'then `Either` can similarly be defined like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`Either`可以类似地这样定义：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that `Either` has two generic parameters. It can be in one of two states:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Either`有两个泛型参数。它可以处于两种状态之一：
- en: '`Left(L)` wraps a value of type `L`, capturing details about the error.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Left(L)`封装了一个类型为`L`的值，捕获了关于错误的详细信息。'
- en: '`Right(R)` wraps a value of type `R`, representing a successful result.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Right(R)`封装了一个类型为`R`的值，代表一个成功的结果。'
- en: Let’s see how an `Option`-based interface can differ from an `Either`-based
    one. Imagine you’re doing some DIY and go to the store to get a tool you need.
    If the item isn’t available, an `Option`-based shopkeeper would just say, “Sorry,
    it’s not available”—and that would be it. An `Either`-based shopkeeper would give
    you more information such as, “We’re out of stock until next week,” or “This product
    has been discontinued”; you could then base further decisions on this information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于`Option`的接口如何与基于`Either`的接口不同。想象一下，你正在做一些DIY，去商店买你需要的一个工具。如果这个商品没有货，一个基于`Option`的店主可能会说，“抱歉，这个商品没有货”——然后就没有然后了。一个基于`Either`的店主会给你更多信息，比如，“我们下周才有货，”或者“这个产品已经停产”；然后你可以根据这些信息做出进一步的决策。
- en: What about a deceiving shopkeeper who, having run out of stock, will sell you
    a product that looks just like the one you’re after but which will explode in
    your face when you put it to use? That’s the exception-throwing interface as figure
    8.2 depicts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个欺骗性的店主，在库存耗尽后，会卖给你一个看起来和你想要的完全一样的产品，但当你使用它时会在你面前爆炸？这就是图 8.2 描述的异常抛出接口。
- en: '![](Images/CH08_F02_Buonanno2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F02_Buonanno2.png)'
- en: Figure 8.2 Which shop would you prefer as a client?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 你作为客户会喜欢哪个商店？
- en: Because the definition of `Either` is so similar to `Option`, it can be implemented
    using the same techniques. In my `LaYumba.Functional` library, I have defined
    a type `Left<L>` that wraps an `L` and can be implicitly converted to an `Either<L,`
    `R>` for any type `R`. Similarly for `Right<R>`. For convenience, values of type
    `L` and `R` are also implicitly convertible to `Either<L, R>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Either` 的定义与 `Option` 非常相似，所以可以使用相同的技巧来实现。在我的 `LaYumba.Functional` 库中，我定义了一个类型
    `Left<L>`，它可以包装一个 `L` 并可以隐式转换为任何类型 `R` 的 `Either<L, R>`。同样对于 `Right<R>`。为了方便，类型
    `L` 和 `R` 的值也可以隐式转换为 `Either<L, R>`。
- en: 'You can see the full implementation in the code samples, but I won’t include
    it here because there’s nothing new about the implementation of `Option`, compared
    to what was discussed in section 5.3\. Instead, let’s play around with `Either`
    in the REPL. As usual, you need to start by referencing `LaYumba.Functional`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码示例中看到完整的实现，但在这里我不会包括它，因为与第 5.3 节中讨论的 `Option` 的实现相比，没有什么是新的。相反，让我们在 REPL
    中玩一玩 `Either`。像往常一样，你需要首先引用 `LaYumba.Functional`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now create some `Either`s:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一些 `Either`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates an `Either` in the `Right` state
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个处于 `Right` 状态的 `Either`
- en: ❷ Creates an `Either` in the `Left` state
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个处于 `Left` 状态的 `Either`
- en: 'That was easy! You use the `Right` function to wrap, say, an `int` into a `Right<int>`,
    which is implicitly convertible into an `Either<L,` `int>` for any `L` (this is
    similar to how I used the `NoneType` for creating `Option`s in the `None` state)
    and similarly for `Left`. Now, let’s write a function that uses `Match` to compute
    a different value depending on the state of an `Either`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！你使用 `Right` 函数来包装，比如一个 `int` 到 `Right<int>`，它可以隐式转换为任何 `L` 的 `Either<L,
    int>`（这类似于我如何使用 `NoneType` 在 `None` 状态下创建 `Option`），同样对于 `Left` 也是如此。现在，让我们编写一个使用
    `Match` 来根据 `Either` 的状态计算不同值的函数：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that you know how to create and consume an `Either`, let’s look at a slightly
    more interesting example. Imagine a function that performs a simple calculation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建和消费一个 `Either`，让我们看看一个稍微更有趣的例子。想象一个执行简单计算的函数：
- en: '*f*(*x*, *y*) → sqrt(*x* / *y*)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*, *y*) → sqrt(*x* / *y*)'
- en: For the calculation to be performed correctly, we need to ensure that *y* is
    nonzero and that the ratio *x*/*y* is non-negative. If one of these conditions
    isn’t met, we’d like to know which one. So the calculation returns, let’s say,
    a `double` in the happy path and a `string` with an error message otherwise. That
    means the return type of this function should be `Either<string, double>`—remember,
    the successful type is the one on the right. The following listing shows the implementation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确执行计算，我们需要确保 *y* 不为零，并且 *x*/*y* 的比率是非负的。如果这些条件中有一个不满足，我们想知道是哪一个。所以计算返回，比如说，一个
    `double` 在快乐路径上，否则返回一个带有错误消息的 `string`。这意味着这个函数的返回类型应该是 `Either<string, double>`——记住，成功的类型是右侧的类型。下面的列表显示了实现。
- en: Listing 8.1 Capturing error details with `Either`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 使用 `Either` 捕获错误详情
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The signature of `Calc` clearly declares that it will return a structure, wrapping
    as either a string or a double. Indeed, the implementation returns either a string
    (an error message) or a double (the result of the computation). In either case,
    the returned value is implicitly converted into a suitably populated `Either`.
    Let’s test it out in the REPL:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calc` 的签名清楚地声明它将返回一个结构，该结构可以是字符串或双精度浮点数。确实，实现返回的是字符串（错误消息）或双精度浮点数（计算结果）。在任何情况下，返回的值都隐式转换为适当填充的
    `Either`。让我们在 REPL 中测试一下：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because `Either` is so similar to `Option`, you might guess that the core functions
    you’ve seen in relation to `Option` will have counterparts for `Either`. Let’s
    find out.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Either` 与 `Option` 非常相似，你可能猜到你在与 `Option` 相关的核心函数将会有 `Either` 的对应函数。让我们找出答案。
- en: 8.1.2 Core functions for working with Either
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 用于处理 Either 的核心函数
- en: 'As with `Option`, we can define `Map`, `ForEach`, and `Bind` in terms of `Match`.
    Because the `Left` case is used to signal failure, the computation is skipped
    in the `Left` case:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Option`一样，我们可以用`Match`来定义`Map`、`ForEach`和`Bind`。因为`Left`情况用于表示失败，所以在`Left`情况下会跳过计算：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ In the `Left` case, the computation is skipped and the `Left` value is passed
    along.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在`Left`情况下，计算被跳过，并将`Left`值传递下去。
- en: There are a couple of things to point out here. In all cases, the function is
    applied *only* if the `Either` is `Right`.[³](#pgfId-1110969) This means that
    if we think of `Either` as a fork, then when we take the left path, we miss out
    on all the computations that lie ahead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事情。在所有情况下，函数只会在`Either`是`Right`时应用。[³](#pgfId-1110969) 这意味着如果我们把`Either`看作一个分叉点，那么当我们选择左边的路径时，就会错过所有后续的计算。
- en: 'Also notice that when you use `Map` and `Bind`, the `R` type changes: just
    as `Option<T>` is a functor on `T`, `Either<L,` `R>` is a functor on `R`, meaning
    that you can use `Map` to apply functions to `R`. The `L` type, on the other hand,
    remains the same.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，当你使用`Map`和`Bind`时，`R`类型会改变：正如`Option<T>`是`T`上的函子一样，`Either<L, R>`是`R`上的函子，这意味着你可以使用`Map`来对`R`应用函数。另一方面，`L`类型保持不变。
- en: 'What about `Where`? Remember, you can call `Where` with a predicate and filter
    out the inner value of an `Option` if it fails to satisfy the predicate:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Where`？记住，你可以用谓词调用`Where`，并在它不满足谓词时过滤出`Option`的内部值：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With `Either`, you can’t do that. Failure to meet a condition should yield
    a `Left`, but because `Where` takes a predicate and a predicate only returns a
    Boolean, there’s no value of type `L` available if the predicate fails. It’s probably
    easiest to see this if you try to implement `Where` for `Either`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Either`，你不能这样做。如果条件不满足，应该返回一个`Left`，但由于`Where`需要一个谓词，而谓词只返回布尔值，所以如果谓词失败，就没有可用的`L`类型值。如果你尝试为`Either`实现`Where`，这可能是最容易理解的。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, if the `Either` is `Right` but its inner value doesn’t satisfy
    the predicate, you should return a `Left`. There is, however, no available value
    of type `L` with which you could populate a `Left`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果`Either`是`Right`但它的内部值不满足谓词，你应该返回一个`Left`。然而，没有可用的`L`类型值可以填充一个`Left`。
- en: 'You’ve just learned that `Where` is less general than `Map` and `Bind`: it
    can only be defined for structures where a zero value exists (such as an empty
    sequence for `IEnumerable` or `None` for `Option`). There’s no zero value for
    `Either<L, R>` because `L` is an arbitrary type. You can only cause an `Either`
    to fail by explicitly creating a `Left` or by calling `Bind` with a function that
    may return a suitable `L` value. You’ll see this in practice in the next example,
    where I’ll show you an `Option`-based implementation and an `Either`-based one
    side by side.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚了解到`Where`不如`Map`和`Bind`通用：它只能定义在存在零值的结构中（例如`IEnumerable`的空序列或`Option`的`None`）。对于`Either<L,
    R>`来说，没有零值，因为`L`是一个任意类型。你只能通过显式创建一个`Left`或通过调用可能返回适当`L`值的函数的`Bind`来使`Either`失败。你将在下一个示例中看到这一点，我将展示一个基于`Option`的实现和一个基于`Either`的实现并排。
- en: 8.1.3 Comparing Option and Either
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 比较`Option`和`Either`
- en: Imagine we’re modeling a recruitment process. We’ll start with an `Option`-based
    implementation in which `Some(Candidate)` represents a candidate that has passed
    the interview process so far, whereas `None` represents rejection. The following
    listing shows this implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在模拟一个招聘流程。我们将从一个基于`Option`的实现开始，其中`Some(Candidate)`代表已经通过面试流程的候选人，而`None`代表拒绝。下面的列表显示了这种实现。
- en: Listing 8.2 `Option`-based implementation modeling the recruitment process
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 基于`Option`的招聘流程实现
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The recruitment process consists of a technical test first and then an interview.
    Fail the test and the interview won’t take place. But even prior to the test,
    we’ll check that the candidate is eligible. With `Option`, we can apply the `IsEligible`
    predicate with `Where` so that if the candidate isn’t eligible, the subsequent
    steps won’t take place.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 招聘流程首先是一个技术测试，然后是面试。如果测试失败，面试就不会进行。但在测试之前，我们会检查候选人是否有资格。使用`Option`，我们可以用`Where`应用`IsEligible`谓词，这样如果候选人没有资格，后续步骤就不会进行。
- en: Now imagine that HR isn’t happy to just know whether a candidate has passed
    or not; they also want to know the reasons for the rejection because this information
    allows them to refine the recruitment process. We can refactor to an `Either`-based
    implementation, capturing the reasons for rejection with a `Rejection` object
    as in the following listing. The `Right` type is a `Candidate` as before, and
    the `Left` type is `Rejection`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，人力资源部门不仅想知道候选人是否通过，还想知道拒绝的原因，因为这项信息允许他们改进招聘流程。我们可以重构为基于`Either`的实现，使用`Rejection`对象捕获拒绝的原因，如下面的列表所示。`Right`类型与之前一样是`Candidate`，而`Left`类型是`Rejection`。
- en: Listing 8.3 An equivalent `Either`-based implementation
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 等价的基于`Either`的实现
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Turns the predicate into an `Either`-returning function
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将谓词转换为返回`Either`的函数
- en: ❷ Applies `CheckEligibility` using `Bind`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用`Bind`应用`CheckEligibility`
- en: We now need to be more explicit about failing the `IsEligible` test, so we turn
    this predicate into an `Either`-returning function, `CheckEligibility`. This provides
    a suitable `Left` value (the `Rejection`) for when the predicate isn’t passed.
    We can now compose `CheckEligibility` into the workflow using `Bind`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更明确地表达`IsEligible`测试失败的情况，因此我们将这个谓词转换为一个返回`Either`的函数，即`CheckEligibility`。这为谓词未通过时提供了一个合适的`Left`值（即`Rejection`）。现在我们可以使用`Bind`将`CheckEligibility`组合到工作流程中。
- en: Notice that the `Either`-based implementation is more verbose. This makes sense
    because we choose `Either` when we need to be explicit about failure conditions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到基于`Either`的实现更为冗长。这很合理，因为我们选择`Either`是为了明确地表达失败条件。
- en: 8.2 Chaining operations that may fail
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 连接可能失败的运算
- en: '`Either` lends itself particularly well to representing a chain of operations
    where any operation may cause a deviation from the happy path. For example, once
    every so often, you prepare your boyfriend or girlfriend’s favorite dish. The
    workflow may look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`特别适合表示可能引起从快乐路径偏离的操作链。例如，偶尔你会为你的男朋友或女朋友准备他们最喜欢的菜肴。工作流程可能看起来像这样：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At each step of the way, something can go wrong: you could oversleep, you could
    wake up to stormy weather that prevents you from getting to the shops, you could
    get distracted and let everything burn. . . . In short, only if *everything* goes
    well do you get to a happy meal together (see figure 8.3).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，都可能出错：你可能睡过头，你可能醒来时遇到暴风雨，这阻止了你去商店，你可能分心，让一切都烧毁了……简而言之，只有当*一切*顺利时，你才能一起享受快乐的餐点（见图8.3）。
- en: '![](Images/CH08_F03_Buonanno2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F03_Buonanno2.png)'
- en: Figure 8.3 If everything goes according to plan . . .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 如果一切按计划进行……
- en: Using `Either`, we can model the preceding workflow. The following listing shows
    how to implement this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Either`，我们可以模拟前面的工作流程。下面的列表展示了如何实现这一点。
- en: Listing 8.4 Using `Bind` to chain several `Either`-returning functions
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 使用`Bind`连接多个返回`Either`的函数
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remember from the definition of `Bind` that if the state is `Left`, the `Left`
    value just gets passed along. In the preceding listing, when we say `ComplainAbout(reason)`,
    the `reason` is whatever failed in *any* of the previous steps: if we failed to
    wake up, `ComplainAbout` receives the reason for that; likewise, if we failed
    to shop, and so on.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从`Bind`的定义中，如果状态是`Left`，则`Left`值只是被传递下去。在先前的列表中，当我们说`ComplainAbout(reason)`时，`reason`是之前任何步骤中失败的原因：如果我们没有醒来，`ComplainAbout`会接收到那个原因；同样，如果我们没有去购物，等等。
- en: The previous tree-like diagram is a correct, logical representation of the workflow.
    Figure 8.4 shows another way to look at it, which is closer to the implementation
    details.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的树形图是工作流程的正确、逻辑表示。图8.4展示了另一种看待它的方法，这更接近实现细节。
- en: '![](Images/CH08_F04_Buonanno2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F04_Buonanno2.png)'
- en: Figure 8.4 Chaining `Either`-returning functions
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 连接返回`Either`的函数
- en: Each function returns a two-part structure, the `Either`, and is chained with
    the next function via `Bind`. F# evangelist Scott Wlaschin likens a workflow obtained
    by chaining several `Either`-returning functions to a two-track system:[⁴](#pgfId-1111093)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都返回一个两部分的结构，即`Either`，并通过`Bind`与下一个函数连接。F# 拥护者 Scott Wlaschin 将通过连接多个返回`Either`的函数获得的工作流程比作一个双轨系统：[⁴](#pgfId-1111093)
- en: There’s a *main track* (the happy path), going from `R1` to `Rn`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个*主轨道*（即快乐路径），从`R1`到`Rn`。
- en: There’s an auxiliary, *parallel track*, on the `Left` side.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Left`侧有一个辅助的、*并行轨道*。
- en: If you’re on the `Right` track, with each function application, you will either
    proceed along the `Right` track or be diverted to the `Left` track.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你处于 `Right` 轨道，每次函数应用时，你将要么沿着 `Right` 轨道继续前进，要么被引导到 `Left` 轨道。
- en: Once you’re on the `Left` track, you stay on it until the end of the road.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你处于 `Left` 轨道，你将一直保持在轨道上直到路的尽头。
- en: '`Match` is the end of the road, where the disjunction of the parallel tracks
    takes place.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Match` 是路的尽头，在这里并行轨道的分离发生。'
- en: 'Although the “favorite dish” example is rather frivolous, it’s representative
    of many programming scenarios. For example, imagine a stateless server that, upon
    receiving a request, must perform the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个“最喜欢的菜肴”例子相当轻率，但它代表了众多编程场景。例如，想象一个无状态服务器，在收到请求后，必须执行以下步骤：
- en: Validate the request
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证请求
- en: Load the model from the DB
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库加载模型
- en: Make changes to the model
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对模型进行更改
- en: Persist changes
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持久化更改
- en: Any of these operations could potentially fail, and failure at any step should
    prevent the workflow from continuing. Furthermore, the response should potentially
    include details about the success or failure of the requested operation, alerting
    the client as appropriate. Next, we’ll look at using `Either` in such a scenario.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的任何一个都可能失败，并且任何步骤的失败都应阻止工作流程继续。此外，响应可能包含有关请求操作成功或失败详情的信息，并适当地提醒客户端。接下来，我们将看看在这样场景中使用
    `Either`。
- en: '8.3 Validation: A perfect use case for Either'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 验证：Either 的完美用例
- en: 'Let’s revisit the scenario of requesting a money transfer, but in this case,
    we’ll address a simplified scenario in which a client explicitly requests a transfer
    to be carried out on some future date. The application should do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视请求货币转账的场景，但在这个情况下，我们将处理一个简化的场景，其中客户端明确请求在未来某一天执行转账。应用程序应该执行以下操作：
- en: Validate the request
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证请求
- en: Store the transfer details for future execution
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储转账详情以供将来执行
- en: Return a response with an indication of success or details of any failure
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个表示成功或任何失败详情的响应
- en: We can model the fact that the operation may fail with `Either`. If the transfer
    request is successfully stored, there’s no meaningful data to return to the client,
    so the `Right` type parameter will be `Unit`. What should the `Left` type be?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `Either` 来模拟操作可能失败的事实。如果转账请求成功存储，就没有有意义的数据返回给客户端，所以 `Right` 类型参数将是 `Unit`。那么
    `Left` 类型应该是什么？
- en: 8.3.1 Choosing a suitable representation for errors
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 选择合适的错误表示
- en: Let’s look at a few types you could use to capture error details. You saw that
    when applying functions to `Either` via `Map` or `Bind`, the `Right` type changes,
    but the `Left` type remains the same. So once you choose a type for `Left`, this
    type remains the same throughout the workflow.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些你可以用来捕获错误详情的类型。当你通过 `Map` 或 `Bind` 将函数应用于 `Either` 时，`Right` 类型会改变，但
    `Left` 类型保持不变。所以一旦你为 `Left` 选择了一个类型，这个类型在整个工作流程中保持不变。
- en: 'I’ve used `string` in some of the previous examples, but this seems limiting;
    you might want to add more structured details about the errors. What about `Exception`?
    It’s a base class that can be extended with arbitrarily rich subtypes. Here, however,
    the semantics are wrong: `Exception` denotes that something exceptional has occurred.
    Instead, here we’re coding for errors that are “business as usual.”'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的例子中使用了一些 `string`，但这似乎限制性太强；你可能想添加更多关于错误的详细结构化信息。关于 `Exception` 怎么样？它是一个可以扩展为任意丰富子类型的基类。然而，这里的语义是错误的：`Exception`
    表示发生了异常。相反，这里我们正在为“常规业务”中的错误进行编码。
- en: I’ve included a simple base `Error` type in the next listing, exposing just
    a `Message` property. You can extend this for specific errors.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我在下一个列表中包含了一个简单的基 `Error` 类型，仅暴露一个 `Message` 属性。你可以为特定错误扩展这个类型。
- en: Listing 8.5 A base class for representing failure
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 表示失败的基础类
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although, strictly speaking, the representation of `Error` is part of the domain,
    this is a general enough requirement that I’ve added the type to my functional
    library. My recommended approach is to create *one type for each type of error*.
    For example, the next listing provides some error types we’ll need in order to
    represent some cases of failed validation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然严格来说，`Error` 的表示是领域的一部分，但这是一个足够通用的要求，我已经将这个类型添加到了我的功能库中。我的推荐方法是**为每种错误类型创建一个类型**。例如，下面的列表提供了一些我们需要用来表示一些验证失败情况的错误类型。
- en: Listing 8.6 Distinct types capture details about specific errors
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 独特类型捕获特定错误的详细信息
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And, for convenience, we’ll add a static class, `Errors`. It contains factory
    functions for creating specific `Error`s:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将添加一个静态类，`Errors`。它包含用于创建特定 `Error` 的工厂函数：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a trick that will help us keep the code where the business decisions
    are made cleaner, as you’ll see in a moment. It also provides good documentation:
    `Errors` effectively gives you an overview of all the specific errors defined
    for the domain.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个技巧，将有助于我们保持业务决策处的代码更干净，正如你一会儿会看到的。它还提供了良好的文档：`Errors` 有效地为你提供了所有为该领域定义的特定错误的概述。
- en: 8.3.2 Defining an Either-based API
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 定义基于 `Either` 的 API
- en: 'Let’s assume that the details about the transfer request are captured in a
    DTO of type `MakeTransfer` (see listing 3.6): this is what we receive from the
    client, and it’s the input data for our workflow. We can also establish that the
    workflow should return an `Either<Error,` `Unit>` when there’s no data (in case
    of success) or an `Error` with details (in case of failure). That means the main
    function we need to implement to perform this workflow has this signature:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设关于转账请求的详细信息被捕获在一个类型为 `MakeTransfer` 的 DTO 中（见列表 3.6）：这是我们从客户端接收到的，也是我们工作流程的输入数据。我们还可以确定，当没有数据（在成功的情况下）或带有详细信息的错误（在失败的情况下）时，工作流程应返回
    `Either<Error, Unit>`。这意味着我们需要实现的主要函数来执行此工作流程具有以下签名：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’re now ready to introduce a skeleton of the implementation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好介绍实现的大致框架：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Uses `Bind` to chain two operations that may fail
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `Bind` 来链式执行两个可能失败的运算
- en: ❷ Uses `Either` to acknowledge that validation may fail
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 `Either` 来承认验证可能会失败
- en: ❸ Uses `Either` to acknowledge that persisting the request may fail
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `Either` 来承认持久化请求可能会失败
- en: 'The `Handle` method defines the high-level workflow: first validate, then persist.
    Both `Validate` and `Save` return an `Either` to acknowledge that the operation
    may fail. Also note that the return type of `Validate` is `Either<Error,` `MakeTransfer>`.
    That is, we need the `MakeTransfer` command on the right side so that the transfer
    data is available and can be piped to `Save`. Next, let’s add some validation.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handle` 方法定义了高级工作流程：首先验证，然后持久化。`Validate` 和 `Save` 都返回 `Either` 来承认运算可能会失败。注意，`Validate`
    的返回类型是 `Either<Error, MakeTransfer>`。这意味着我们需要在右侧的 `MakeTransfer` 命令，以便转账数据可用，并可以传递给
    `Save`。接下来，让我们添加一些验证。'
- en: 8.3.3 Adding validation logic
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 添加验证逻辑
- en: 'Let’s start by validating a couple of simple conditions about the request:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先验证请求的一些简单条件：
- en: The date for the transfer should be in the future.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转账的日期应该在将来。
- en: The provided BIC code should be in the right format.[⁵](#pgfId-1111196)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的 BIC 代码应该符合正确的格式。[⁵](#pgfId-1111196)
- en: You’ve already seen the logic for this validation in section 3.3.2\. However,
    back then we wrote functions that returned a Boolean, indicating whether the `MakeTransfer`
    was valid. Now, we want to return an `Either` to capture details of what validation
    failed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 3.3.2 节中看到了这个验证的逻辑。然而，当时我们编写了返回布尔值的函数，表示 `MakeTransfer` 是否有效。现在，我们想要返回一个
    `Either` 来捕获验证失败的具体细节。
- en: 'We can have a function perform each validation. The typical scheme will be
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让一个函数执行每个验证。典型的方案如下：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '❶ Success: the original request is wrapped in an `Either` in the `Right` state.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 成功：原始请求被封装在 `Either` 的 `Right` 状态中。
- en: '❷ Failure: the error is wrapped in an `Either` in the `Left` state.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 失败：错误被封装在 `Either` 的 `Left` 状态中。
- en: That is, each validator function takes a request as input and returns *either*
    the (validated) command *or* the appropriate error.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 即，每个验证函数都接受一个请求作为输入，并返回 *either*（要么）验证后的命令 *or* 相应的错误。
- en: Each validation function is a world-crossing function (going from a normal value,
    `MakeTransfer`, to an elevated value, `Either<Error,` `MakeTransfer>`), so we
    can combine several of these functions using `Bind`. The following listing shows
    how to do this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个验证函数都是一个跨界函数（从一个普通值 `MakeTransfer` 到一个提升值 `Either<Error, MakeTransfer>`），因此我们可以使用
    `Bind` 组合这些函数中的几个。以下列表显示了如何做到这一点。
- en: Listing 8.7 Chaining several validation functions with `Bind`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 使用 `Bind` 链式连接多个验证函数
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Lifts the command into an `Either`
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将命令提升到 `Either`
- en: ❷ Applies all subsequent operations that can fail with `Bind`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 `Bind` 应用所有后续可能失败的运算
- en: In summary, use `Either` to acknowledge that *an* operation may fail and `Bind`
    to chain *several* operations that may fail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用 `Either` 来承认 *一个* 运算可能会失败，并使用 `Bind` 来链式执行 *多个* 可能失败的运算。
- en: Now that our workflow nicely captures the possibility of failure with `Either`,
    how do we relay this information, say, to the HTTP client that made the request?
    We’ll look at this next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的工作流程已经很好地用`Either`捕获了失败的可能性，我们如何将此信息传达给请求的HTTP客户端？我们将在下一节探讨这个问题。
- en: 8.4 Representing outcomes to client applications
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 向客户端应用程序表示结果
- en: 'You’ve now seen quite a few use cases for `Option` and `Either`. Both types
    can be seen as representing outcomes: in the case of `Option`, `None` can signify
    failure; in the case of `Either`, it’s `Left`. We’ve defined `Option` and `Either`
    as C# types, but in this section, you’ll see how you can translate them for the
    outside world.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了`Option`和`Either`的许多用例。这两种类型都可以看作是表示结果：在`Option`的情况下，`None`可以表示失败；在`Either`的情况下，它是`Left`。我们已经将`Option`和`Either`定义为C#类型，但在本节中，你将看到如何将它们转换为外部世界。
- en: Although we’ve defined `Match` for both types, we’ve used it quite rarely, relying
    instead on `Map`, `Bind`, and `Where` to define workflows. Remember, the *key
    difference* here is that the latter work “within the abstraction” (you start with,
    say, `Option<T>` and end up with an `Option<R>`). `Match`, on the other hand,
    allows you to “leave the abstraction” (you start with `Option<T>` and end up with
    an `R`). Figure 8.5 shows this process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经为这两种类型定义了`Match`，但我们使用它相当少，而是依赖于`Map`、`Bind`和`Where`来定义工作流程。记住，这里的*关键区别*在于后者在抽象内部工作（你从`Option<T>`开始，并以`Option<R>`结束）。另一方面，`Match`允许你“离开抽象”（你从`Option<T>`开始，并以`R`结束）。图8.5展示了这个过程。
- en: '![](Images/CH08_F05_Buonanno2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F05_Buonanno2.png)'
- en: Figure 8.5 With `Option` and `Either`, `Match` is used to leave the abstraction.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 使用`Option`和`Either`，`Match`用于离开抽象。
- en: As a general rule, once you’ve introduced an abstraction like `Option`, it’s
    best to stick with it as long as possible. What does *as long as possible* mean?
    Ideally, it means that you’ll leave the abstract world when you cross application
    boundaries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，一旦你引入了像`Option`这样的抽象，最好尽可能长时间地坚持使用它。*尽可能长时间*是什么意思？理想情况下，这意味着当你跨越应用边界时，你会离开抽象世界。
- en: It’s good practice to design applications with some separation between the application
    core (which contains services and domain logic) and an outer layer (which contains
    a set of adapters through which your application interacts with the outside world).
    You can see your application as an orange, where the skin is composed of a layer
    of adapters, as figure 8.6 shows.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序时，在应用核心（包含服务和领域逻辑）和外部层（包含一组适配器，通过这些适配器你的应用程序与外部世界交互）之间保持一些分离是良好的实践。你可以将你的应用程序看作是一个橙子，其中皮肤由一层适配器组成，如图8.6所示。
- en: '![](Images/CH08_F06_Buonanno2.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F06_Buonanno2.png)'
- en: Figure 8.6 The outer layer of an application consists of adapters.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 应用程序的外部层由适配器组成。
- en: Abstractions such as `Option` and `Either` are useful within the application
    core, but they may not translate well to the message contract expected by the
    interacting applications. Thus, the outer layer is where you need to leave the
    abstraction and translate to the representation expected by your client applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 像`Option`和`Either`这样的抽象在应用核心中很有用，但它们可能无法很好地映射到交互应用期望的消息合约。因此，外部层是你需要离开抽象并转换为客户端应用程序期望的表示的地方。
- en: 8.4.1 Exposing an Option-like interface
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 暴露类似`Option`的接口
- en: Imagine an API that, given a *ticker* (an identifier for a stock or other financial
    instrument, such as AAPL, GOOG, or MSFT), returns details about the requested
    financial instrument. Within the application core, you’ve implemented a function
    that does this; its signature is
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个API，给定一个*股票代码*（股票或其他金融工具的标识符，例如AAPL、GOOG或MSFT），返回有关请求的金融工具的详细信息。在应用核心中，你已经实现了一个执行此操作的功能；其签名是
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can’t know whether the string given as a ticker actually identifies an existing
    instrument, so you’ve used `Option` to model this. Next, let’s expose this data
    to the outer world. You can do this by defining an endpoint on an ASP.NET MVC
    controller.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法知道给定的股票代码字符串是否确实标识了一个现有的工具，因此你使用了`Option`来建模这种情况。接下来，让我们将此数据暴露给外部世界。你可以通过在ASP.NET
    MVC控制器上定义一个端点来实现这一点。
- en: The API returns, let’s say, JSON over HTTP (a format and protocol that doesn’t
    deal in `Option`s), so the controller needs to act as an adapter that can translate
    `Option` into something that’s supported by that protocol. Namely, if no instrument
    exists for the given ticker, we’ll return an HTTP response with a code of 404
    (Not Found) as the following listing shows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: API 返回，比如说，通过 HTTP 的 JSON（一种不处理 `Option` 的格式和协议），因此控制器需要充当一个适配器，可以将 `Option`
    转换为该协议支持的内容。也就是说，如果给定的股票代码没有对应的工具，我们将返回一个状态码为 404（未找到）的 HTTP 响应，如下列表所示。
- en: Listing 8.8 Translating `None` to status code 404
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 将 `None` 映射到状态码 404
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Maps `None` to a 404
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 `None` 映射到 404
- en: ❷ Maps `Some` to a 200
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 `Some` 映射到 200
- en: Note that because `NotFound` and `Ok`, which are inherited from `ControllerBase`,
    return different implementations of `IActionResult`, we must explicitly declare
    `IActionResult` as a type parameter for `Match`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 `NotFound` 和 `Ok`（都继承自 `ControllerBase`）返回不同的 `IActionResult` 实现，我们必须显式声明
    `IActionResult` 作为 `Match` 的类型参数。
- en: Point-free style
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无参数风格
- en: 'The body of `GetInstrumentDetails` can be written more tersely:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInstrumentDetails` 的主体可以写得更加简洁：'
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: (Or even more tersely without the parameter names.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: （或者甚至可以更简洁地不带参数名称。）
- en: This style of omitting the explicit parameter is sometimes called *point-free*
    because the data points are omitted. It’s a bit daunting at first, but it’s cleaner
    once you get used to it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种省略显式参数的风格有时被称为**无参数风格**，因为省略了数据点。一开始可能会有些令人畏惧，但一旦习惯了，就会更加简洁。
- en: You’ve now seen how you can take a workflow modeled with an `Option`-based interface
    and expose it through an HTTP API. Next, let’s see an `Either`-based interface.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何使用基于 `Option` 的接口来建模工作流程，并通过 HTTP API 暴露它。接下来，让我们看看基于 `Either` 的接口。
- en: 8.4.2 Exposing an Either-like interface
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 暴露类似 `Either` 的接口
- en: Just like with `Option`, once you’ve lifted your value to the elevated world
    of `Either`, it’s best to stay there until the end of the workflow. But all good
    things must come to an end, so at some point, you’ll need to leave your application
    domain and expose a representation of your `Either` to the external world.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Option` 一样，一旦你的值提升到 `Either` 的更高层次，最好一直保持在那里，直到工作流程结束。但所有美好的事物都有尽头，所以你最终需要离开你的应用程序领域，并将你的
    `Either` 的表示暴露给外部世界。
- en: Let’s go back to the banking scenario we looked at in this chapter—that of a
    request from a client to book a transfer on a future date. Our core functionality
    returns an `Either<Error, Unit>`, and we must translate that to, say, JSON over
    HTTP.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章中讨论的银行场景——即客户请求在未来日期进行转账的场景。我们的核心功能返回一个 `Either<Error, Unit>`，我们必须将其转换为，比如说，通过
    HTTP 的 JSON。
- en: 'One approach is similar to what we just looked at for `Option`: we can use
    HTTP status code 400 to signal that we received a bad request. The following listing
    demonstrates this approach.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法与我们刚才查看的 `Option` 类似：我们可以使用 HTTP 状态码 400 来表示我们收到了一个无效请求。以下列表展示了这种方法。
- en: Listing 8.9 Translating `Left` to status code 400
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 将 `Left` 映射到状态码 400
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This works. The only downside is that the convention of how business validation
    relates to HTTP error codes is shaky. Some people will argue that 400 signals
    a *syntactically* incorrect request and not a *semantically* incorrect request,
    as is the case here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。唯一的缺点是关于业务验证如何与 HTTP 错误码相关联的约定并不稳固。有些人会争论说 400 表示一个**语法上**错误的请求，而不是像这里这样的**语义上**错误的请求。
- en: In situations of concurrency, a request that was valid at the time it was sent
    may no longer be valid by the time the server receives it (for example, the account
    balance may have gone down). Does a 400 convey this?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发情况下，一个在发送时有效的请求在服务器收到时可能不再有效（例如，账户余额可能已经下降）。400 状态码是否传达了这一点？
- en: Instead of trying to figure out which HTTP status code best suits a particular
    error scenario, another approach is to return a representation of the outcome
    in the response. We’ll explore this option next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图确定哪个 HTTP 状态码最适合特定的错误场景，另一种方法是返回响应中的结果表示。我们将在下一节中探讨这个选项。
- en: 8.4.3 Returning a result DTO
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 返回结果 DTO
- en: This approach involves always returning a successful status code (because, at
    a low level, the response was correctly received and processed), along with an
    arbitrarily rich representation of the outcome in the response body. The following
    listing shows a simple data transfer object (DTO) representing the result of processing
    the request, including its left and right components.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法涉及始终返回成功的状态码（因为，在底层，响应已被正确接收和处理），以及响应体中任意丰富的结果表示。以下列表显示了一个简单的数据传输对象（DTO），它表示处理请求的结果，包括其左右组件。
- en: Listing 8.10 DTO representing the outcome serialized in the response
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 表示响应中序列化结果的 DTO
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This `ResultDto` is similar to `Either`. But unlike `Either`, whose internal
    values are only accessible via higher-order functions, the DTO exposes them for
    easy serialization and access on the client side. We can then define a utility
    function that translates an `Either` to a `ResultDto`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `ResultDto` 与 `Either` 类似。但与 `Either` 不同，其内部值只能通过高阶函数访问，而 DTO 则将其暴露出来，以便于客户端的序列化和访问。然后我们可以定义一个实用函数，将
    `Either` 转换为 `ResultDto`：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we can just expose the `Result` in our API method. The next listing shows
    how to do this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需在我们的 API 方法中公开 `Result` 即可。接下来的列表显示了如何做到这一点。
- en: Listing 8.11 Returning error details as part of a successful response payload
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 将错误详情作为成功响应负载的一部分返回
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Overall, this approach means less code in your endpoints. More importantly,
    it means you’re not relying on the idiosyncrasies of the HTTP protocol in your
    representation of results but can, instead, create the structure that best suits
    you to represent whatever you choose to see as `Left`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这种方法意味着你的端点代码更少。更重要的是，这意味着你不需要依赖 HTTP 协议的怪癖来表示结果，而是可以创建最适合你的结构来表示你选择看到的
    `Left`。
- en: In the end, both approaches are viable and both are used in APIs in the wild.
    Which approach you choose has more to do with API design than with FP. The point
    is that you’ll generally have to make some choices when exposing to client applications
    outcomes that you can model with `Either` in your application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两种方法都是可行的，并且在实际的 API 中都被使用。你选择哪种方法更多与 API 设计有关，而不是与函数式编程（FP）有关。关键是，当你向客户端应用程序公开可以用
    `Either` 在你的应用程序中建模的结果时，你通常必须做出一些选择。
- en: I’ve illustrated “lowering” values from abstractions through the example of
    an HTTP API because this is such a common requirement, but the concepts don’t
    change if you expose another kind of endpoint. In summary, use `Match` if you’re
    in the skin of the orange; stay with the juicy abstractions within the core of
    the orange.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过 HTTP API 的例子说明了“降低”抽象中的值，因为这是一个非常常见的需求，但如果你暴露另一种类型的端点，这些概念并不会改变。总的来说，如果你处于橙子的皮层，使用
    `Match`；在橙子的核心中保持多汁的抽象。
- en: 8.5 Variations on the Either theme
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 基于 `Either` 的变体
- en: '`Either` takes us a long way toward functional error handling. In contrast
    to exceptions, which cause the program to “jump” out of its normal execution flow
    and into an exception-handling block somewhere up the stack, `Either` maintains
    the normal program execution flow and, instead, returns a representation of the
    outcome.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 将我们引向功能错误处理的深处。与导致程序“跳”出其正常执行流程并进入堆栈中某处的异常处理块的异常不同，`Either` 维持正常的程序执行流程，并返回结果的表现形式。'
- en: 'There’s a lot to like about `Either`. There are also some possible objections:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 有很多值得喜欢的地方。也有一些可能的反对意见：'
- en: '`Bind` doesn’t change the `Left` type, so how you compose functions that return
    an `Either` with a different `Left` type?'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind` 不改变 `Left` 类型，那么你如何组合返回不同 `Left` 类型的 `Either` 函数？'
- en: Always having to specify two generic arguments makes the code too verbose.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是必须指定两个泛型参数使得代码过于冗长。
- en: The names `Either`, `Left`, and `Right` are too cryptic. Can’t we have something
    more user-friendly?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either`、`Left` 和 `Right` 的名字太晦涩了。我们能不能有更用户友好的名字？'
- en: In this section, I’ll address these concerns. You’ll see how they can be mitigated
    with some variations on the `Either` theme.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解决这些担忧。你会看到如何通过 `Either` 主题的一些变体来减轻这些问题。
- en: 8.5.1 Changing between different error representations
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 在不同的错误表示之间切换
- en: As you saw, `Map` and `Bind` allow you to change the `R` type but not the `L`
    type. Although having a homogeneous representation for errors is preferable, it
    may not always be possible. What if you write a library where the `L` type is
    always `Error`, and someone else writes a library where it’s always `string`?
    How can you to integrate the two?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Map` 和 `Bind` 允许你更改 `R` 类型，但不能更改 `L` 类型。尽管具有统一的错误表示方式更可取，但这可能并不总是可能的。如果你编写了一个库，其中
    `L` 类型始终为 `Error`，而另一个人编写了一个库，其中它始终为 `string`，你该如何整合这两个库呢？
- en: 'It turns out this can be resolved simply with an overload of `Map`, which allows
    you to apply a function to the left value *as well as* the right one. This overload
    takes an `Either<L,` `R>` and then not one but two functions: one of type `(L`
    `→` `LL)`, which is applied to the left value (if present), and another one of
    type `(R` `→` `RR)`, which is applied to the right value,'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上可以通过 `Map` 的一个重载来解决，它允许你将函数应用于左值和右值。这个重载接受一个 `Either<L, R>`，然后不是一个是两个函数：一个类型为
    `(L → LL)` 的函数，它应用于左值（如果存在），另一个类型为 `(R → RR)` 的函数，它应用于右值，
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This variation of `Map` allows you to arbitrarily change both types so that
    you can interoperate between functions where the `L` types are different.[⁶](#pgfId-1111402)
    Here’s an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `Map` 的变体允许你任意更改两种类型，这样你就可以在 `L` 类型不同的函数之间进行互操作。[⁶](#pgfId-1111402) 以下是一个示例：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ `L` is `string`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `L` 表示 `string`。
- en: ❷ `L` is `Error`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `L` 表示 `Error`。
- en: ❸ Translates from `string` to `Error`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 `string` 转换为 `Error`
- en: If possible, it’s best to avoid the noise and stick to a consistent representation
    for errors. Different representations, though, aren’t a stumbling block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，最好避免噪音并坚持一致的错误表示。不同的表示方式，尽管如此，并不是一个障碍。
- en: 8.5.2 Specialized versions of Either
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 Either 的专用版本
- en: Let’s look at the other shortcomings of using `Either` in C#.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在 C# 中使用 `Either` 的其他缺点。
- en: 'First, having two generic arguments adds noise to the code.[⁷](#pgfId-1111431)
    For example, imagine you want to capture multiple validation errors and, for this,
    you choose `IEnumerable<Error>` as your `Left` type. You’d end up with signatures
    that look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有两个泛型参数会增加代码的噪音。[⁷](#pgfId-1111431) 例如，想象你想捕获多个验证错误，为此你选择 `IEnumerable<Error>`
    作为你的 `Left` 类型。你最终会得到这样的签名：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You now have to read through three things (`Either`, `IEnumerable`, and `Error`)
    before you get to the most meaningful part—the desired return type `Rates`. Compared
    to signatures that say nothing about failure, which we discussed in section 4.2.3,
    it seems we’ve fallen into the opposite extreme.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须阅读三个东西（`Either`、`IEnumerable` 和 `Error`），才能到达最有意义的部分——所需的返回类型 `Rates`。与我们在
    4.2.3 节中讨论的没有任何关于失败信息的签名相比，这似乎是我们陷入了对立面。
- en: Second, the names `Either`, `Left`, and `Right` are too abstract. Software development
    is complex enough, so we should opt for the most intuitive names possible.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，`Either`、`Left` 和 `Right` 的名称过于抽象。软件开发本身就足够复杂，因此我们应该选择最直观的名称。
- en: Both issues can be addressed by using more specialized versions of `Either`
    that have a fixed type to represent failure (hence, a single generic parameter)
    and more user-friendly names. Note that such variations on `Either` are common
    but not standardized. You’ll find a multitude of different libraries and tutorials
    that each have their own minor variations in terminology and behavior.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用具有固定类型来表示失败（因此，单个泛型参数）和更友好的名称的更专用版本的 `Either` 来解决这两个问题。请注意，这种 `Either`
    的变体很常见，但尚未标准化。你会发现许多不同的库和教程，每个都有自己的术语和行为的小变化。
- en: For this reason, I thought it best to first give you a thorough understanding
    of `Either`, which is ubiquitous and well established in the literature and will
    allow you to grasp any variations you may encounter. (You can then choose the
    representation that serves you best, or even implement your own type for representing
    outcomes if you’re so inclined.)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我认为最好首先让你彻底理解 `Either`，它在文献中无处不在且已建立，这将使你能够掌握你可能会遇到的任何变体。（然后你可以选择最适合你的表示，或者如果你愿意，甚至可以为你自己的结果表示实现自己的类型。）
- en: '`LaYumba.Functional` includes the following two variations for representing
    outcomes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`LaYumba.Functional` 包含以下两种表示结果的变体：'
- en: '`Validation<T>`—You can think of this as an `Either` that has been *particularized*
    to `IEnumerable<Error>`:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Validation<T>`——你可以将其视为一个特定于 `IEnumerable<Error>` 的 `Either`：'
- en: '[PRE31]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Validation` is like an `Either`, where the failure case is fixed to `IEnumerable<Error>`,
    making it possible to capture multiple validation errors.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Validation`类似于`Either`，其中失败情况被固定为`IEnumerable<Error>`，这使得能够捕获多个验证错误。'
- en: '`Exceptional<T>`—Here, failure is fixed to `System.Exception`:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exceptional<T>`—在这里，失败被固定为`System.Exception`：'
- en: '[PRE32]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Exceptional` can be used as a bridge between an exception-based API and functional
    error handling.'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Exceptional`可以用作基于异常的API和函数式错误处理之间的桥梁。'
- en: Table 8.2 shows these variations side by side.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2展示了这些变化并排。
- en: Table 8.2 Some particularized versions of `Either` and their state names
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 `Either`的一些特定版本及其状态名称
- en: '| Type | Success case | Failure case | Failure type |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 成功情况 | 失败情况 | 失败类型 |'
- en: '| `Either<L, R>` | `Right` | `Left` | `L` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `Either<L, R>` | `Right` | `Left` | `L` |'
- en: '| `Validation<T>` | `Valid` | `Invalid` | `IEnumerable<Error>` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `Validation<T>` | `Valid` | `Invalid` | `IEnumerable<Error>` |'
- en: '| `Exceptional<T>` | `Success` | `Exception` | `Exception` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Exceptional<T>` | `Success` | `Exception` | `Exception` |'
- en: These new types have friendlier, more intuitive names than `Either`. And because
    the `Left` type is static, it won’t clutter your method signatures. You’ll see
    an example of using them next.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新类型比`Either`有更友好、更直观的名称。而且因为`Left`类型是静态的，它不会使你的方法签名变得杂乱。你将在下一个示例中看到它们的使用。
- en: 8.5.3 Refactoring to Validation and Exceptional
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 重构为验证和异常处理
- en: Let’s go back to the scenario of a user booking a money transfer for future
    execution. Previously, we modeled the simple workflow that included validation
    and persistence (both of which could fail) with `Either`. Let’s now see how the
    implementation would change by using the more specific `Validation` and `Exceptional`
    instead.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到用户为未来执行预订货币转账的场景。之前，我们用`Either`模拟了包含验证和持久化（两者都可能失败）的简单工作流程。现在，让我们看看使用更具体的`Validation`和`Exceptional`如何改变实现。
- en: A function that performs validation should, naturally, yield a `Validation`.
    In our scenario, its type would be
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 执行验证的功能函数应该自然地产生一个`Validation`。在我们的场景中，其类型会是
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because `Validation` is just like `Either`, particularized to the `Error` type,
    the implementation of the validation functions would be the same as in the previous
    `Either`-based implementation except for the change in signature. Here’s an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Validation`就像`Either`一样，特定于`Error`类型，验证函数的实现将与之前的基于`Either`的实现相同，除了签名的变化。以下是一个示例：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Wraps the command in a `Validation` in the `Valid` state
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在“有效”状态下将命令封装在`Validation`中
- en: ❷ Wraps an `Error` in a `Validation` in the `Invalid` state
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在“无效”状态下将一个`Error`封装在`Validation`中
- en: In line with previous implementations, I’ve defined `Valid` as a function that
    takes a `T` and lifts it into a `Validation<T>` in the `Valid` state and similarly
    for `Invalid`, which takes one or more `Error`s. Implicit conversion is also defined,
    so in the previous example, you could omit the calls to `Valid` and `Invalid`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的实现一致，我定义了`Valid`为一个函数，它接受一个`T`并将其提升到`Validation<T>`的“有效”状态，同样对于`Invalid`，它接受一个或多个`Error`。隐式转换也被定义，所以在前面的例子中，你可以省略对`Valid`和`Invalid`的调用。
- en: Bridging between an exception-based API and functional error handling
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于异常的API和函数式错误处理之间架桥
- en: Next, let’s look at persistence. Unlike validation, failure here would indicate
    a fault in the infrastructure or configuration or another technical error. We
    consider such errors exceptional, so we can model this with `Exceptional`:[⁸](#pgfId-1111508)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看持久化。与验证不同，这里的失败将表明基础设施或配置或另一个技术错误。我们把这些错误视为异常，因此我们可以用`Exceptional`来模拟这种情况：[⁸](#pgfId-1111508)
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The following listing shows what the implementation of `Save` could look like.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了`Save`实现的可能形式。
- en: Listing 8.12 Translating an `Exception`-based API to an `Exceptional` value
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 将基于异常的API转换为`Exceptional`值
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ The return type acknowledges the possibility of an exception.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回类型承认异常的可能性。
- en: ❷ The call to a third-party API that throws an exception is wrapped in a `try`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将抛出异常的第三方API调用封装在`try`中。
- en: ❸ The exception will be implicitly converted and wrapped in an `Exceptional`in
    the `Exception` state.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 异常将在“异常”状态下隐式转换为并封装在`Exceptional`中。
- en: ❹ The returned `Unit` will be converted into an `Exceptional` in the `Success`
    state.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回的`Unit`将在“成功”状态下转换为`Exceptional`。
- en: 'Notice that the scope of the `try`-`catch` is as small as possible: we want
    to catch any exceptions that may be raised when connecting to the database and
    immediately translate to the functional style, wrapping the result in an `Exceptional`.
    As usual, implicit conversion creates an appropriately initialized `Exceptional`.
    Notice also how this pattern allows us to go from a third-party exception-throwing
    API to a functional API, where errors are handled as payload and the possibility
    of errors is reflected in the return type.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`try`-`catch`的范围尽可能小：我们希望捕获在连接数据库时可能抛出的任何异常，并立即将其转换为函数式风格，将结果包裹在`Exceptional`中。像往常一样，隐式转换创建了一个适当初始化的`Exceptional`。注意这种模式如何使我们能够从第三方抛出异常的API转换到函数式API，其中错误被处理为负载，错误的可能性反映在返回类型中。
- en: Failed validation vs. technical errors
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 验证失败与技术错误
- en: 'Failed validation and technical errors should be handled differently. The nice
    thing about using `Validation` and `Exceptional` is that they have distinct semantic
    connotations:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 验证失败和技术错误应该被不同地处理。使用`Validation`和`Exceptional`的好处是它们具有不同的语义含义：
- en: '`Validation` denotes possible business rule violations.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Validation`表示可能违反的业务规则。'
- en: '`Exceptional` denotes possible unexpected technical errors.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exceptional`表示可能出现的意外技术错误。'
- en: 'We’ll now look at how using these different representations allows us to handle
    each case appropriately. We still need to combine validation and persistence,
    which is done in `Handle` here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何使用这些不同的表示方法来适当地处理每个案例。我们仍然需要将验证和持久性结合起来，这在这里通过`Handle`完成：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Combines validation and persistence
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 结合验证和持久性
- en: ❷ Top-level validation function combining various validation rules
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 结合各种验证规则的顶级验证函数
- en: 'Because `Validate` returns a `Validation`, whereas `Save` returns an `Exceptional`,
    we can’t compose these types with `Bind`. But that’s OK: we can use `Map` instead
    and end up with the return type `Validation<Exceptional<Unit>>`. This is a nested
    type, expressing the fact that we’re combining the *effect* of validation (we
    may get validation errors instead of the desired return value) with the *effect*
    of exception handling (even after validation passes, we may get an exception instead
    of the return value).[⁹](#pgfId-1111566)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Validate`返回一个`Validation`，而`Save`返回一个`Exceptional`，所以我们不能使用`Bind`来组合这些类型。但这是可以的：我们可以使用`Map`，最终得到返回类型`Validation<Exceptional<Unit>>`。这是一个嵌套类型，表示我们正在结合验证的效果（我们可能会得到验证错误而不是期望的返回值）和异常处理的效果（即使验证通过，我们可能仍然会得到异常而不是返回值）。[⁹](#pgfId-1111566)
- en: As a result, `Handle` is acknowledging that the operation may fail for business
    reasons, as well as technical reasons by “stacking” the two monadic effects. Figure
    8.7 illustrates how in both cases we express errors by including them as part
    of the payload.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，`Handle`通过“堆叠”两个单子效果来承认操作可能因为业务原因或技术原因而失败。图8.7说明了在两种情况下我们如何通过将错误包含在负载中来表达错误。 '
- en: '![](Images/CH08_F07_Buonanno2.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F07_Buonanno2.png)'
- en: Figure 8.7 In functional error handling, errors are treated as part of the returned
    payload.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 在功能错误处理中，错误被视为返回负载的一部分。
- en: To complete the end-to-end scenario, we need only add the entry point. This
    is where the controller receives a `MakeTransfer` command from the client, invokes
    `Handle` as defined previously, and translates the resulting `Validation<Exceptional-<Unit>>`
    into a result to send back to the client. This is shown in the following listing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成端到端场景，我们只需要添加入口点。这是控制器从客户端接收`MakeTransfer`命令的地方，调用之前定义的`Handle`，并将结果`Validation<Exceptional-<Unit>>`转换为发送回客户端的结果。这将在下面的列表中展示。
- en: Listing 8.13 Different treatments for validation and exceptional errors
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 验证和异常错误的处理方式
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Unwraps the value inside the `Validation`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解包`Validation`内部的值
- en: ❷ If validation fails, sends a 400
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果验证失败，发送400状态码
- en: ❸ Unwraps the value inside the `Exceptional`
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 解包`Exceptional`内部的值
- en: ❹ If persistence fails, sends a 500
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果持久性失败，发送500状态码
- en: 'Here we use two nested calls to `Match` to first unwrap the value inside the
    `Validation` and then the value inside the `Exceptional`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用两个嵌套的`Match`调用，首先解包`Validation`内部的值，然后是`Exceptional`内部的值：
- en: If validation fails, we send a 400, which includes the full details of the validation
    errors, so that the user can address them.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证失败，我们发送一个包含验证错误全部详情的400状态码，以便用户可以处理这些问题。
- en: If persistence fails, on the other hand, we don’t want to send the details to
    the user. Instead, we return a 500 with a more generic error type (this is also
    a good place to log the exception).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果持久化失败，我们不想将详细信息发送给用户。相反，我们返回一个带有更通用错误类型的 500 状态码（这也是记录异常的好地方）。
- en: As you can see, an explicit return type from each of the functions involved
    allows you to clearly distinguish and customize how you treat failures related
    to business rules versus those related to technical issues.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个相关函数的显式返回类型允许你清楚地区分和定制你如何处理与业务规则相关的失败与与技术问题相关的失败。
- en: In summary, `Either` gives you an explicit, functional way to handle errors
    without introducing side effects, unlike throwing/catching exceptions. But as
    our relatively simple banking scenario illustrates, using specialized versions
    of `Either`, like `Validation` and `Exceptional`, leads to an even more expressive
    and readable implementation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Either` 提供了一种明确的功能方式来处理错误，而不引入副作用，这与抛出/捕获异常不同。但正如我们相对简单的银行场景所说明的，使用 `Either`
    的专用版本，如 `Validation` 和 `Exceptional`，会导致更具有表达性和可读性的实现。
- en: 8.5.4 Leaving exceptions behind?
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.4 留下异常？
- en: In this chapter, you’ve gained a solid understanding of the ideas behind functional
    error handling.[^(10)](#pgfId-1111624) You may feel this is a radical departure
    from the exception-based approach and, indeed, it is!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经对功能错误处理的理念有了坚实的理解。[^(10)](#pgfId-1111624) 你可能会觉得这与基于异常的方法有很大的不同，确实如此！
- en: 'I mentioned that throwing exceptions disrupts the normal program flow, introducing
    side effects. More pragmatically, it makes your code more difficult to maintain
    and reason about: if a function throws an exception, the only way to analyze the
    implications of this for the application is to follow all possible code paths
    into the function and then look for the first exception handler up the stack.
    With functional error handling, errors are just part of the return type of the
    function, so you can still reason about the function in isolation.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到抛出异常会中断正常的程序流程，引入副作用。更实际地说，它使得你的代码更难以维护和推理：如果一个函数抛出异常，分析这种异常对应用程序的影响的唯一方法就是跟踪所有可能的代码路径进入该函数，然后查找堆栈中的第一个异常处理器。在功能错误处理中，错误只是函数返回类型的一部分，因此你仍然可以独立地推理函数。
- en: Having realized the detrimental effects of using exceptions, several younger
    programming languages such as Go, Elixir, and Elm have embraced the idea that
    errors should simply be treated as values so that equivalents to the `throw` and
    `try`-`catch` statements are used only rarely (Elixir) or are absent from the
    language altogether (Go, Elm). The fact that C# includes exceptions doesn’t mean
    you need to use them for error handling; instead, you can use functional error
    handling within your application and use adapter functions to convert the outcomes
    of calls to exception-based APIs to something like `Exceptional` as shown previously.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 已经意识到使用异常的负面影响后，一些较新的编程语言，如 Go、Elixir 和 Elm，都接受了这样的观点：错误应该简单地被视为值，因此 `throw`
    和 `try`-`catch` 语句的等价物只被很少使用（Elixir）或者根本不包含在语言中（Go、Elm）。C# 包含异常并不意味着你需要使用它们来处理错误；相反，你可以在应用程序中使用功能错误处理，并使用适配器函数将基于异常的
    API 调用的结果转换为类似于前面所示 `Exceptional` 的东西。
- en: 'Are there any cases in which exceptions are still useful? I believe so:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有任何情况下异常仍然有用？我相信是这样的：
- en: '*Developer errors*—For example, if you’re trying to remove an item from an
    empty list or if you’re passing a `null` value to a function that requires that
    value, it’s OK for that function or for the list implementation to throw an exception.
    Such exceptions are never meant to be caught and handled in the calling code;
    they indicate that the application logic is wrong.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发者错误*——例如，如果你试图从一个空列表中删除一个项目，或者如果你将 `null` 值传递给需要一个值的函数，该函数或列表实现抛出异常是可以接受的。这种异常永远不会被调用代码捕获和处理；它们表明应用程序逻辑有误。'
- en: '*Configuration errors*—For example, if an application relies on a message bus
    to connect to other systems and can’t effectively perform anything useful unless
    connected, failure to connect to the bus upon startup should result in an exception.
    The same applies if a critical piece of configuration like a database connection
    string is missing. These exceptions should only be thrown upon initialization
    and aren’t meant to be caught (other than possibly in an outermost, application-wide
    handler), but should, rightly, cause the application to crash.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置错误*——例如，如果一个应用程序依赖于消息总线来连接到其他系统，并且除非连接，否则无法有效地执行任何有用的操作，那么在启动时无法连接到总线应该导致异常。如果缺少像数据库连接字符串这样的关键配置项，也适用同样的情况。这些异常应该在初始化时抛出，并且不打算被捕获（除了可能在最外层的、应用程序范围内的处理程序中），但应该正确地导致应用程序崩溃。'
- en: Exercises
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a `ToOption` extension method to convert an `Either` into an `Option`;
    if present, the left value is thrown away. Then write a `ToEither` method to convert
    an `Option` into an `Either` with a suitable parameter that can be invoked to
    obtain the appropriate `Left` value if the `Option` is `None`. (Tip: start by
    writing the function signatures in arrow notation.)'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`ToOption`扩展方法，将`Either`转换为`Option`；如果存在，左值将被丢弃。然后编写一个`ToEither`方法，将`Option`转换为具有适当参数的`Either`，如果`Option`为`None`，则可以调用该参数以获取适当的`Left`值。（提示：首先用箭头符号编写函数签名。）
- en: Take a workflow where two or more functions that return an `Option` are chained
    using `Bind`. Then change the first of the functions to return an `Either`. This
    should cause compilation to fail. `Either` can be converted into an `Option` (as
    you saw in the previous exercise), so write extension overloads for `Bind`. That
    way, functions returning `Either` and `Option` can be chained with `Bind`, yielding
    an `Option`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个工作流程，其中两个或多个返回`Option`的函数使用`Bind`进行链式调用。然后将第一个函数改为返回`Either`。这应该会导致编译失败。`Either`可以转换为`Option`（如你在上一个练习中看到的），因此为`Bind`编写扩展重载。这样，返回`Either`和`Option`的函数可以使用`Bind`进行链式调用，产生一个`Option`。
- en: Write a function with the signature
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个具有以下签名的函数
- en: '[PRE39]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: which runs the given function in a `try`-`catch`, returning an appropriately
    populated `Exceptional`.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数在`try`-`catch`块中运行给定的函数，返回一个适当填充的`Exceptional`。
- en: Write a function with the signature
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个具有以下签名的函数
- en: '[PRE40]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: which runs the given function in a `try`-`catch`, returning an appropriately
    populated `Either`.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数在`try`-`catch`块中运行给定的函数，返回一个适当填充的`Either`。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Use `Either` to represent the result of an operation with two different possible
    outcomes, typically success or failure. An `Either` can be in one of two states:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Either`来表示具有两种不同可能结果的操作的结果，通常是成功或失败。`Either`可以处于两种状态之一：
- en: '`Left` indicates failure and contains error information for an unsuccessful
    operation.'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Left`表示失败，并包含不成功操作的错误信息。'
- en: '`Right` indicates success and contains the result of a successful operation.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Right`表示成功，并包含成功操作的结果。'
- en: 'Interact with `Either` using the equivalents of the core functions already
    seen with `Option`:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与`Option`中已看到的核心函数等效的函数与`Either`进行交互：
- en: '`Map` and `Bind` apply the mapped/bound function *if* the `Either` is in the
    `Right` state; otherwise, they just pass along the `Left` value.'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`和`Bind`仅在`Either`处于`Right`状态时应用映射/绑定函数；否则，它们只是传递`Left`值。'
- en: '`Match` allows you to handle the `Right` and `Left` cases differently.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Match`允许你分别处理`Right`和`Left`情况。'
- en: '`Where` is not readily applicable; if you want to filter out certain `Right`
    values according to a predicate, use `Bind` instead, providing a function that
    yields a suitable `Left` value if the predicate fails.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where`不适用；如果你要根据谓词过滤出某些`Right`值，请使用`Bind`代替，提供一个在谓词失败时产生适当`Left`值的函数。'
- en: '`Either` is particularly useful for combining several validation functions
    with `Bind` or, more generally, for combining several operations, each of which
    can fail.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either`特别适用于将多个验证函数与`Bind`结合使用，或者更一般地，用于将多个可能失败的操作组合在一起。'
- en: Because `Either` is rather abstract and because of the syntactic overhead of
    its two generic arguments, in practice, it’s better to use a particularized version
    of `Either`, such as `Validation` and `Exceptional`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`Either`相当抽象，并且由于其两个泛型参数的语法开销，在实践中，最好使用`Either`的特定版本，例如`Validation`和`Exceptional`。
- en: When working with functors and monads, prefer using functions that stay within
    the abstraction, like `Map` and `Bind`. Use the downward-crossing `Match` function
    as little or as late as possible.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与函子和单子一起工作时，最好使用保持在抽象内部的函数，例如`Map`和`Bind`。尽可能少或尽可能晚地使用向下交叉的`Match`函数。
- en: '* * *'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ In fact, I think `throw` is much worse than `goto`. The latter at least jumps
    to a well-defined location; with `throw`, you don’t really know what code will
    execute next unless you explore all possible paths into the code where `throw`
    occurs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 事实上，我认为`throw`比`goto`更糟糕。后者至少跳到了一个定义良好的位置；而`throw`，除非你探索了`throw`发生的代码中所有可能的路径，否则你真的不知道接下来会执行什么代码。
- en: ² These include returning a special value indicating an error or returning an
    object representing the outcome of the operation, which is the approach I’ll pursue
    in this chapter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ² 这些包括返回一个特殊值来指示错误或返回表示操作结果的物体，这是我在本章中要采取的方法。
- en: ³ This is what’s called a *biased* implementation of `Either`. There are also
    different, *unbiased* implementations of `Either` that aren’t used to represent
    error/success disjunctions but two equally valid paths. In practice, the biased
    implementations are much more widely used.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这被称为`Either`的*有偏*实现。还有不同的、*无偏*的`Either`实现，它们不用于表示错误/成功分离，而是表示两个同样有效的路径。在实践中，有偏的实现被广泛使用。
- en: ⁴ I encourage you to look at his “Railway Oriented Programming” article and
    video conference available on his site at [http://fsharpforfunandprofit.com/rop/](http://fsharpforfunandprofit.com/rop/).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 我鼓励您查看他网站上关于“面向铁路的编程”的文章和视频会议，网址为[http://fsharpforfunandprofit.com/rop/](http://fsharpforfunandprofit.com/rop/)。
- en: ⁵ The BIC code, also known as SWIFT code, is a standard identifier for a bank
    branch.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ BIC代码，也称为SWIFT代码，是银行分支的标准标识符。
- en: ⁶ Because there’s no shortage of terminology in FP, functors for which a `Map`
    in this form is defined are called *bifunctors*. The idea is that functors have
    an inner value, whereas bifunctors have two (or one of two) inner values. Bifunctors
    can then have the functions `RightMap` (which is the same as `Map`), `LeftMap`
    (which maps a function onto the left value), and `BiMap` (which is identical to
    the overload of `Map` I’ve just shown).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ 由于函数式编程（FP）中的术语并不匮乏，因此定义了这种形式的`Map`的函子被称为*双函子*。其理念是函子有一个内部值，而双函子有两个（或两个中的一个）内部值。双函子可以有`RightMap`（与`Map`相同）、`LeftMap`（将函数映射到左值）和`BiMap`（与刚刚展示的`Map`的重载相同）这样的函数。
- en: ⁷ You can look at this as a shortcoming of `Either` or of C#’s type system.
    `Either` is successfully used in the ML languages where types can (nearly) always
    be inferred, so even complex generic types don’t add any noise to the code. This
    is a classic example showing that although the principles of FP are language-independent,
    they need to be adapted based on the strengths and weaknesses of each particular
    language.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 你可以将其视为`Either`或C#类型系统的不足。`Either`在可以（几乎）总是推断类型的ML语言中成功使用，因此即使复杂的泛型类型也不会给代码带来任何噪音。这是一个经典例子，说明尽管函数式编程的原则是语言无关的，但它们需要根据每种特定语言的优势和劣势进行调整。
- en: ⁸ In this context, *exceptional* doesn’t necessarily mean *occurring rarely*;
    it denotes a technical error as opposed to an error from the point of view of
    the business logic.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ⁸ 在这个上下文中，*异常*不一定意味着*很少发生*；它表示技术错误，而不是从业务逻辑的角度来看的错误。
- en: ⁹ Remember, these are monadic effects not side effects, but in FP-speak, they’re
    simply called *effects*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ⁹ 记住，这些是单子效应而不是副作用，但在FP的术语中，它们简单地被称为*效应*。
- en: ^(10) We’ll revisit error handling in part 3 in the context of laziness and
    asynchrony, but the fundamental aspects have all been covered in this chapter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^(10) 我们将在第3部分中回顾错误处理，背景是惰性和异步，但本章已经涵盖了所有基本方面。
