- en: Appendix. PowerShell cheat sheet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录。PowerShell速查表
- en: This is our opportunity to assemble a lot of the little *gotchas* into a single
    place. If you’re ever having trouble remembering what something is or does, flip
    to this appendix first.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将许多小*陷阱*集中在一个地方的机会。如果你曾经遇到困难，记不起某个东西是什么或做什么，首先翻到这个附录。
- en: A.1 Punctuation
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 标点符号
- en: 'PowerShell is full of punctuation, and much of it has a different meaning in
    the help files than it does in the shell itself. Here’s what it all means within
    the shell:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell充满了标点符号，其中许多在帮助文件中的含义与在shell本身中的含义不同。以下是它们在shell中的含义：
- en: '*Backtick* (`` ` ``)—PowerShell’s escape character. It removes the special
    meaning of any character that follows it. For example, a space is normally a separator,
    which is why `cd c:\Program Files` generates an error. Escaping the space, ``cd
    c:\Program` Files``, removes that special meaning and forces the space to be treated
    as a literal, so the command works.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反引号* (``` ` ``)——PowerShell的转义字符。它移除了其后任何字符的特殊含义。例如，空格通常是一个分隔符，这就是为什么`cd c:\Program
    Files`会生成错误。转义空格，`cd c:\Program` `Files`，移除了这种特殊含义并强制空格被视为一个字面量，因此命令可以正常工作。'
- en: '*Tilde* (`~`)—When the tilde is used as part of a path, it represents the current
    user’s home directory, as defined in the `UserProfile` environment variable.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*波浪号* (`~`)——当波浪号用作路径的一部分时，它代表当前用户的家目录，如`UserProfile`环境变量中定义的那样。'
- en: '*Parentheses* `( )`—These are used in a couple of ways:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*括号* `( )`——它们有几种用法：'
- en: 'Just as in math, parentheses define the order of execution. PowerShell executes
    parenthetical commands first, from the innermost parentheses to the outermost.
    This is a good way to run a command and have its output feed the parameter of
    another command: `Get-Service -computerName (Get-Content c:\computernames.txt)`.'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像数学一样，括号定义了执行顺序。PowerShell首先执行括号内的命令，从最内层的括号到最外层的括号。这是一种运行命令并将输出传递给另一个命令的参数的好方法：`Get-Service
    -computerName (Get-Content c:\computernames.txt)`。
- en: 'Parentheses also enclose the parameters of a method, and they must be included
    even if the method doesn’t require any parameters: `$mystring.replace(''ship'',''spaceship'')`
    for example, or `Delete()`.'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号也包含了方法的参数，即使方法不需要任何参数也必须包含它们：例如，`$mystring.replace('ship','spaceship')` 或
    `Delete()`。
- en: '*Square brackets* `[]`—These have two main uses in the shell:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方括号* `[]`——在shell中有两个主要用途：'
- en: 'They contain the index number when you want to refer to a single object within
    an array or collection: `$services[2]` gets the third object from `$services`
    (indexes are always zero-based).'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要引用数组或集合中的单个对象时，它们包含索引号：`$services[2]`从`$services`获取第三个对象（索引始终从0开始）。
- en: They contain a data type when you’re casting a piece of data as a specific type.
    For example, `$myresult / 3 -as [int]` casts the result as a whole number (integer),
    and `[xml]$data = Get-Content data.xml` will read the contents of `Data.xml` and
    attempt to parse it as a valid XML document.
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将数据转换为特定类型时，它们包含数据类型。例如，`$myresult / 3 -as [int]`将结果转换为整数（整数），而`[xml]$data
    = Get-Content data.xml`将读取`Data.xml`的内容并尝试将其解析为有效的XML文档。
- en: '*Curly braces* `{}`—Also called *curly brackets*, these have three uses:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大括号* `{}`——也称为*大括号*，它们有三个用途：'
- en: 'They contain blocks of executable code or commands, called *script blocks*.
    These are often fed to parameters that expect a script block or a filter block:
    `Get-Service | Where-Object { $_.Status -eq ''Running'' }`.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包含可执行代码块或命令，称为*脚本块*。这些通常被提供给期望脚本块或过滤器块的参数：例如，`Get-Service | Where-Object {
    $_.Status -eq 'Running' }`。
- en: 'They contain the key-value pairs that make up a new hash table. The opening
    brace is always preceded by an `@` sign. In the following example, we use braces
    both to enclose the hash table key-value pairs (of which there are two) and to
    enclose an expression script block, which is the value for the second key, `e:
    $hashtable = @{l=''Label'';e={expression}}`.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '它们包含组成新哈希表的键值对。开括号总是由一个`@`符号 precedes。在以下示例中，我们使用大括号来包围哈希表的键值对（有两个），以及包围一个表达式脚本块，这是第二个键`e:
    $hashtable = @{l=''Label'';e={expression}}`的值。'
- en: 'When a variable name contains spaces or other characters normally illegal in
    a variable name, braces must surround the name: `${My Variable}`.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当变量名包含空格或其他在变量名中通常非法的字符时，必须用大括号包围名称：`${My Variable}`。
- en: '*Single quotation marks* (`''`)—These contain string values. PowerShell doesn’t
    look for the escape character, nor does it look for variables, inside single quotes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单引号* (`''`)——它们包含字符串值。PowerShell在单引号内不寻找转义字符，也不寻找变量。'
- en: '*Double quotation marks* (`"`)—These contain string values. PowerShell looks
    for escape characters and the `$` character inside double quotes. Escape characters
    are processed, the characters following a `$` symbol (alphanumeric characters)
    are taken as a variable name, and the contents of that variable are substituted.
    For example, if the variable `$one` contains the value `World`, then ``$two =
    "Hello $one `n"`` will contain `Hello World` and a carriage return (`` `n `` is
    a carriage return).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双引号* (`"`)—这些包含字符串值。PowerShell在双引号内查找转义字符和`$`字符。转义字符被处理，跟随`$`符号（字母数字字符）的字符被视为变量名，并替换该变量的内容。例如，如果变量`$one`包含值`World`，那么`$two
    = "Hello $one `n"`将包含`Hello World`和一个换行符（` `n ``是换行符）。'
- en: '*Dollar sign* (`$`)—This tells the shell that the following alphanumeric characters
    represent a variable name. This can be tricky when working with cmdlets that manage
    variables. Supposing that `$one` contains the value `two`, then `New-Variable
    -name $one -value ''Hello''` will create a new variable named `two`, with the
    value `Hello`, because the dollar sign tells the shell that you want to use the
    contents of `$one`. In contrast, `New-Variable -name one -value ''Hello''` would
    create a new variable, `$one`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*美元符号* (`$`)—这告诉shell，接下来的字母数字字符代表一个变量名。当与处理变量的cmdlet一起工作时，这可能会很棘手。假设`$one`包含值`two`，那么`New-Variable
    -name $one -value ''Hello''`将创建一个名为`two`的新变量，其值为`Hello`，因为美元符号告诉shell你想使用`$one`的内容。相比之下，`New-Variable
    -name one -value ''Hello''`将创建一个新变量`$one`。'
- en: '*Percent sign* (`%`)—This is an alias for the `ForEach-Object` cmdlet. It’s
    also the modulus operator, returning the remainder from a division operation.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*百分号* (`%`)—这是`ForEach-Object` cmdlet的别名。它也是取模运算符，返回除法操作的余数。'
- en: '*Question mark* (`?`)—This is an alias for the `Where-Object` cmdlet.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*问号* (`?`)—这是`Where-Object` cmdlet的别名。'
- en: '*Right angle bracket* (`>`)—This is a sort of alias for the `Out-File` cmdlet.
    It’s not technically a true alias, but it does provide for cmd.exe-style file
    redirection: `dir > files.txt`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*右尖括号* (`>`)—这是一种`Out-File` cmdlet的别名。它不是真正的别名，但它确实提供了cmd.exe风格的文件重定向：`dir
    > files.txt`。'
- en: '*Math operators* (`+`, `-`, `*`, `/`, and `%`)—These function as standard arithmetic
    operators. Note that `+` is also used for string concatenation.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数学运算符* (`+`, `-`, `*`, `/`, 和 `%`)—这些作为标准算术运算符。请注意，`+`也用于字符串连接。'
- en: '*Dash, or hyphen* (`-`)—This precedes both parameter names and many operators,
    such as `-computerName` or `-eq`. It also separates the verb and noun components
    of a cmdlet name, as in `Get-Content`, and serves as the subtraction arithmetic
    operator.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*破折号或连字符* (`-`)—它位于参数名称和许多运算符之前，例如`-computerName`或`-eq`。它还分隔cmdlet名称的动词和名词部分，如`Get-Content`，并作为减法算术运算符。'
- en: '*At sign* (`@`)—This sign has four uses in the shell:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*at符号* (`@`)—在shell中有四种用途：'
- en: It precedes a hash table’s opening curly brace (see curly braces in this list).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它位于哈希表开括号之前（参见此列表中的括号）。
- en: 'When used before parentheses, it encloses a comma-separated list of values
    that form an array: `$array = @(1,2,3,4)`. Both the `@` sign and the parentheses
    are optional, because the shell will normally treat any comma-separated list as
    an array anyway.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在括号之前使用时，它包围一个由逗号分隔的值列表，这些值形成一个数组：`$array = @(1,2,3,4)`。`@`符号和括号都是可选的，因为shell通常将任何由逗号分隔的列表视为数组。
- en: It denotes a here-string, which is a block of literal string text. A here-string
    starts with `@"` and ends with `"@`, and the closing mark must be on the beginning
    of a new line. Run `help about_quoting_rules` for more information and examples.
    Here-strings can also be defined using single quotes.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它表示一个here-string，即一组字面字符串文本。here-string以`@"`开始，以`"@"`结束，并且结束标记必须位于新行的开头。运行`help
    about_quoting_rules`获取更多信息及示例。here-string也可以使用单引号定义。
- en: It is PowerShell’s splat operator. If you construct a hash table in which the
    keys match parameter names, and those values’ keys are the parameters’ values,
    then you can splat the hash table to a cmdlet. Run `help about_splatting` to learn
    more.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是PowerShell的splat运算符。如果你构建一个键与参数名称匹配的哈希表，并且那些值的键是参数的值，那么你可以将哈希表splat到cmdlet中。运行`help
    about_splatting`了解更多信息。
- en: '*Ampersand* (`&`)—This is PowerShell’s invocation operator, instructing the
    shell to treat something as a command and to run it. For example, `$a = "Dir"`
    places the string `Dir` into the variable `$a`. Then `& $a` will run the `Dir`
    command.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与号* (`&`)—这是PowerShell的调用运算符，指示shell将某物视为命令并运行它。例如，`$a = "Dir"`将字符串`Dir`放入变量`$a`中。然后`&
    $a`将运行`Dir`命令。'
- en: '*Semicolon* (`;`)—This is used to separate two independent PowerShell commands
    that are included on a single line: `Dir ; Get-Process` will run `Dir` and then
    `Get-Process`. The results are sent to a single pipeline, but the results of `Dir`
    aren’t piped to `Get-Process`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分号* (`;`)—这用于分隔单行上包含的两个独立的 PowerShell 命令：`Dir ; Get-Process` 将运行 `Dir` 然后运行
    `Get-Process`。结果被发送到单个管道，但 `Dir` 的结果不会传递到 `Get-Process`。'
- en: '*Pound sign, or hash tag* (`#`)—This is used as a comment character. Any characters
    following `#`, to the next carriage return, are ignored by the shell. The angle
    brackets (`<` and `>`) are used as part of the tags that define a block comment:
    Use `<#` to start a block comment and `#>` to end one. Everything within the block
    comment will be ignored by the shell.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*井号，或哈希标签* (`#`)—这用作注释字符。任何跟在 `#` 后面，直到下一个换行符的字符都将被 shell 忽略。尖括号 (`<` 和 `>`)
    用作定义块注释的标签的一部分：使用 `<#` 开始一个块注释，使用 `#>` 结束一个。块注释中的所有内容都将被 shell 忽略。'
- en: '*Equals sign* (`=`)—This is the assignment operator, used to assign a value
    to a variable: `$one = 1`. It isn’t used for quality comparisons; use `-eq` instead.
    Note that the equals sign can be used in conjunction with a math operator: `$var
    +=5` will add `5` to whatever is currently in `$var`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等号* (`=`)—这是赋值运算符，用于将值赋给变量：`$one = 1`。它不用于质量比较；请使用 `-eq`。请注意，等号可以与数学运算符一起使用：`$var
    +=5` 将 `5` 添加到 `$var` 当前包含的内容中。'
- en: '*Pipe* (`|`)—This is used to convey the output of one cmdlet to the input of
    another. The second cmdlet (the one receiving the output) uses pipeline parameter
    binding to determine which parameter or parameters will receive the piped-in objects.
    Chapters 6 and 10 have discussions of this process.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管道* (`|`)—这用于将一个 cmdlet 的输出传递到另一个 cmdlet 的输入。第二个 cmdlet（接收输出的 cmdlet）使用管道参数绑定来确定哪些参数或参数将接收管道中的对象。第
    6 章和第 10 章有关于此过程的讨论。'
- en: '*Forward or backward slash* (`/`, `\`)—These are used as division operators
    in mathematical expressions; either the forward slash (`/`) or backslash (`\`)
    can be used as a path separator in file paths: C:\Windows is the same as C:\Windows.
    The backslash is also used as an escape character in WMI filter criteria and in
    regular expressions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正斜杠或反斜杠* (`/`, `\`)—这些在数学表达式中用作除法运算符；无论是正斜杠 (`/`) 还是反斜杠 (`\`) 都可以用作文件路径中的路径分隔符：C:\Windows
    与 C:\Windows 相同。反斜杠还用作 WMI 过滤条件中的转义字符和在正则表达式中的转义字符。'
- en: '*Period* (.)—This has three main uses:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*句号* (.)—它有三个主要用途：'
- en: 'It’s used to indicate that you want to access a member, such as a property
    or method, or an object: `$_.Status` will access the `Status` property of whatever
    object is in the `$_` placeholder.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于表示你想访问一个成员，例如属性或方法，或一个对象：`$_.Status` 将访问 `$_` 占位符中任何对象的 `Status` 属性。
- en: 'It’s used to dot-source a script, meaning that the script will be run within
    the current scope, and anything defined by that script will remain defined after
    the script completes: `. c:\myscript.ps1.`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于 dot-source 一个脚本，意味着该脚本将在当前作用域内运行，并且在该脚本完成后定义的任何内容都将保持定义：`. c:\myscript.ps1.`
- en: Two dots (`..`) form the range operator, which is discussed later in this appendix.
    You will also see two dots used to refer to the parent folder in the filesystem,
    such as in the ..\ path.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个点 (`..`) 形成范围运算符，这在附录的后面部分有讨论。你还会看到两个点用于在文件系统中引用父文件夹，例如在 ..\ 路径中。
- en: '*Comma* (`,`)—Outside quotation marks, the comma separates the items in a list
    or array: `"One",2,"Three",4`. It can be used to pass multiple static values to
    a parameter that can accept them: `Get-Process -computername Server1, Server2,Server3`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逗号* (`,`)—在引号之外，逗号用于分隔列表或数组中的项：`"One",2,"Three",4`。它可以用来向可以接受它们的参数传递多个静态值：`Get-Process
    -computername Server1, Server2,Server3`。'
- en: '*Colon* ( `:` )—The colon (technically, two colons) is used to access static
    members of a class; this gets into .NET Framework programming concepts; `[-datetime]::now`
    is an example (although you could achieve that same task by running `Get-Date`).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冒号* (`:` )—冒号（技术上，是两个冒号）用于访问类的静态成员；这涉及到 .NET 框架编程概念；`[-datetime]::now` 是一个例子（尽管你可以通过运行
    `Get-Date` 完成相同的任务）。'
- en: '*Exclamation point* (!)—This is an alias for the `-not` Boolean operator.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*感叹号* (!)—这是 `-not` 布尔运算符的别名。'
- en: We think the only piece of punctuation on a US keyboard that PowerShell doesn’t
    actively use for something is the caret (`^`), although those do get used in regular
    expressions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，在美式键盘上，PowerShell 没有积极使用的唯一标点符号是插入符 (`^`)，尽管这些在正则表达式中确实被使用。
- en: A.2 Help file
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 帮助文件
- en: 'Punctuation within the help file takes on slightly different meanings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文件中的标点符号具有略微不同的含义：
- en: '*Square brackets* `[]`—When square brackets surround any text, it indicates
    that the text is optional. That might include an entire parameter (`[-Name <string>]`),
    or it might indicate that a parameter is positional and that the name is optional
    (`[-Name] <string>`). It can also indicate both that a parameter is optional and,
    if used, can be used positionally (`[[-Name] <string>]`). If you’re in any doubt,
    it’s always legal to use the parameter name.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方括号* `[]`—当方括号包围任何文本时，表示该文本是可选的。这可能包括整个参数（`[-Name <string>]`），或者它可能表示参数是位置性的，名称是可选的（`[-Name]
    <string>`）。它还可以表示参数是可选的，如果使用，则可以按位置使用（`[[-Name] <string>]`）。如果你有任何疑问，使用参数名称总是合法的。'
- en: '*Adjacent square brackets* `[]`—These indicate that a parameter can accept
    multiple values (`<string[]>` instead of `<string>`).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相邻方括号* `[]`—这表示参数可以接受多个值（`<string[]>`而不是`<string>`）。'
- en: '*Angle brackets* `< >`—These surround data types, indicating what kind of value
    or object a parameter expects: `<string>`, `<int>`, `<process>`, and so forth.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尖括号* `< >`—这些包围数据类型，表示参数期望的值或对象类型：`<string>`、`<int>`、`<process>`等等。'
- en: Always take the time to read the full help (add `-full` to the `help` command),
    because it provides maximum detail as well as, in most cases, usage examples.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总是花时间阅读完整的帮助信息（在`help`命令中添加`-full`），因为它提供了最大细节，以及在大多数情况下，使用示例。
- en: A.3 Operators
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 操作符
- en: 'PowerShell doesn’t use the traditional comparison operators found in most programming
    languages. Instead, it uses these:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 不使用大多数编程语言中找到的传统比较运算符。相反，它使用这些：
- en: '`-eq`—Equality (`-ceq` for case-sensitive string comparisons).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-eq`—相等（对于大小写敏感的字符串比较，使用`-ceq`）。'
- en: '`-ne`—Inequality (`-cne` for case-sensitive string comparisons).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ne`—不等式（对于大小写敏感的字符串比较，使用`-cne`）。'
- en: '`-ge`—Greater than or equal to (`-cge` for case-sensitive string comparisons).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge`—大于或等于（对于大小写敏感的字符串比较，使用`-cge`）。'
- en: '`-le`—Less than or equal to (`-cle` for case-sensitive string comparisons).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le`—小于或等于（对于大小写敏感的字符串比较，使用`-cle`）。'
- en: '`-gt`—Greater than (`-cgt` for case-sensitive string comparisons).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt`—大于（对于大小写敏感的字符串比较，使用`-cgt`）。'
- en: '`-lt`—Less than (`-clt` for case-sensitive string comparisons).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt`—小于（对于大小写敏感的字符串比较，使用`-clt`）。'
- en: '`-contains`—Returns `True` if the specified collection contains the object
    specified (`$collection -contains $object`); `-notcontains` is the reverse.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-contains`—如果指定的集合包含指定的对象，则返回`True`（`$collection -contains $object`）；`-notcontains`是相反的。'
- en: '`-in`—Returns `True` if the specified object is in the specified collection
    (`$object -in $collection`); `-notin` is the reverse.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-in`—如果指定的对象在指定的集合中，则返回`True`（`$object -in $collection`）；`-notin`是相反的。'
- en: 'Logical operators are used to combine multiple comparisons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符用于组合多个比较：
- en: '`-not`—Reverses `True` and `False` (the `!` symbol is an alias for this operator).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-not`—反转`True`和`False`（`!`符号是该操作符的别名）。'
- en: '`-and`—Both subexpressions must be `True` for the entire expression to be `True`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-and`—整个表达式为`True`，如果两个子表达式都必须为`True`。'
- en: '`-or`—Either subexpression can be `True` for the entire expression to be `True`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-or`—整个表达式为`True`，如果任一子表达式为`True`。'
- en: 'In addition, there are operators that perform specific functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些执行特定功能的操作符：
- en: '`-join`—Joins the elements of an array into a delimited string.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-join`—将数组的元素连接为一个分隔的字符串。'
- en: '`-split`—Splits a delimited string into an array.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-split`—将分隔的字符串拆分为数组。'
- en: '`-replace`—Replaces occurrences of one string with another.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-replace`—将一个字符串的 occurrence 替换为另一个字符串。'
- en: '`-is`—Returns `True` if an item is of the specified type (`$one -is [int]`).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-is`—如果项目是指定的类型，则返回`True`（`$one -is [int]`）。'
- en: '`-as`—Casts the item as the specified type (`$one -as [int]`).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-as`—将项目转换为指定的类型（`$one -as [int]`）。'
- en: '`..`—Is a range operator; `1..10` returns 10 objects, 1 through 10.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`..`—是范围操作符；`1..10`返回10个对象，从1到10。'
- en: '`-f`—Is the format operator, replacing placeholders with values: `"{0}, {1}"
    -f "Hello","World"`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`—是格式化操作符，用值替换占位符：`"{0}, {1}" -f "Hello","World"`。'
- en: A.4 Custom property and column syntax
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 自定义属性和列语法
- en: 'In several chapters, we showed you how to define custom properties by using
    `Select-Object`, or custom columns and list entries by using `Format-Table` and
    `-Format-List`, respectively. Here’s that hash table syntax—you do this for each
    custom property or column:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个章节中，我们向您展示了如何使用`Select-Object`定义自定义属性，或者使用`Format-Table`和`-Format-List`分别定义自定义列和列表条目。以下是该散列表语法——您为每个自定义属性或列这样做：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both of the keys, `Label` and `Expression`, can be abbreviated as `l` and `e`,
    respectively (be sure to type a lowercase *L* and not the number 1; you could
    also use `n` for `Name`, in place of the lowercase *L*):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 两个键，`Label`和`Expression`，可以分别缩写为`l`和`e`（务必输入小写的*L*，而不是数字1；您也可以使用`n`代替小写的*L*）：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the expression, the `$_` placeholder can be used to refer to the current
    object (such as the current table row, or the object to which you’re adding a
    custom property):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式内部，可以使用`$_`占位符来引用当前对象（例如当前表行或您要添加自定义属性的对象）：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both `Select-Object` and the `Format-` cmdlets look for the `n` (or `name` or
    `label` or `l`) key and the `e` key; the `Format-` cmdlets can also use `width`
    and `align` (those are for `-Format-Table` only) and `formatstring`. Read the
    help for `Format-Table` for examples.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select-Object`和`Format-` cmdlet都寻找`n`（或`name`、`label`或`l`）键和`e`键；`Format-`
    cmdlet还可以使用`width`和`align`（这些仅用于`-Format-Table`）和`formatstring`。阅读`Format-Table`的帮助以获取示例。'
- en: A.5 Pipeline parameter input
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 管道参数输入
- en: 'In chapter 10, you learned that there are two types of parameter binding: `ByValue`
    and `ByPropertyName`. `ByValue` occurs first, and `ByPropertyName` occurs only
    if `ByValue` doesn’t work.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，您了解到有两种类型的参数绑定：`ByValue`和`ByPropertyName`。`ByValue`首先发生，而`ByPropertyName`只有在`ByValue`不起作用时才会发生。
- en: For `ByValue`, the shell looks at the type of the object that’s piped in. You
    can discover that type name by piping the object to `gm` yourself. The shell then
    looks to see whether any of the cmdlet’s parameters accept that type of input
    and are configured to accept pipeline input `ByValue`. It’s not possible for a
    cmdlet to have two parameters binding the same data type in this fashion. In other
    words, you shouldn’t see a cmdlet that has two parameters, each of which accepts
    `<string>` input and both of which accept pipeline input `ByValue`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ByValue`，shell会查看管道输入对象的类型。您可以通过将对象管道到`gm`来发现该类型名称。然后shell会检查是否有任何cmdlet的参数接受这种类型的输入，并配置为接受管道输入`ByValue`。在这种情况下，一个cmdlet不可能有两个参数绑定相同的数据类型。换句话说，您不应该看到一个cmdlet有两个参数，每个参数都接受`<string>`输入，并且都接受管道输入`ByValue`。
- en: If `ByValue` doesn’t work, the shell switches to `ByPropertyName`. Here it looks
    at the properties of the piped-in object and attempts to find parameters with
    the exact same names that can accept pipeline input `ByPropertyName`. If the piped-in
    object has properties `Name`, `Status`, and `ID`, the shell will look to see whether
    the cmdlet has parameters named `Name`, `Status`, and `ID`. Those parameters must
    also be tagged as accepting pipeline input `ByPropertyName`, which you can see
    when reading the full help (add `-full` to the `help` command).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ByValue`不起作用，shell将切换到`ByPropertyName`。在这里，它会查看管道输入对象的属性，并尝试找到具有完全相同名称的参数，这些参数可以接受管道输入`ByPropertyName`。如果管道输入对象具有`Name`、`Status`和`ID`属性，shell将检查cmdlet是否有名为`Name`、`Status`和`ID`的参数。这些参数还必须标记为接受管道输入`ByPropertyName`，您可以在阅读完整帮助时看到这一点（在`help`命令中添加`-full`）。
- en: 'Let’s look at how PowerShell does this. For this example, we’ll refer to the
    first cmdlet and second cmdlet, assuming you have a command that looks something
    like `Get-Service | Stop-Service` or `Get-Service | Stop-Process`. PowerShell
    follows this process:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看PowerShell是如何做到这一点的。对于这个例子，我们将参考第一个cmdlet和第二个cmdlet，假设您有一个类似于`Get-Service
    | Stop-Service`或`Get-Service | Stop-Process`的命令。PowerShell遵循以下过程：
- en: 'What is the `TypeName` of the objects produced by the first cmdlet? You can
    pipe the results of the cmdlet to `Get-Member` on your own to see this. For multipart
    type names such as `System.Diagnostics.Process`, remember just that last bit:
    `Process`.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个cmdlet产生的对象的`TypeName`是什么？您可以将cmdlet的结果管道到`Get-Member`来查看这一点。对于多部分类型名称，如`System.Diagnostics.Process`，只需记住最后那部分：`Process`。
- en: 'Do any parameters of the second cmdlet accept the kind of object produced by
    the first cmdlet (read the full help for the second cmdlet to determine this:
    `help <cmdlet name> -full`)? If so, do they also accept that input from the pipeline
    using the `ByValue` technique? This is shown in the help file’s detailed information
    for each parameter.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个cmdlet的任何参数接受第一个cmdlet产生的对象类型吗（阅读第二个cmdlet的完整帮助以确定这一点：`help <cmdlet name>
    -full`）？如果是这样，它们也使用`ByValue`技术从管道接受该输入吗？这可以在每个参数的帮助文件的详细信息中看到。
- en: If the answer to step 2 is yes, then the entire object produced by the first
    cmdlet will be attached to the parameter identified in step 2\. You’re finished—do
    not continue to step 4\. But if the answer to step 2 is no, continue to step 4.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果步骤2的回答是肯定的，那么第一个cmdlet产生的整个对象将被附加到步骤2中指定的参数。你已经完成了——不要继续到步骤4。但如果步骤2的回答是否定的，继续到步骤4。
- en: Consider the objects produced by the first cmdlet. What properties do those
    objects have? You can see this, again, by piping the first cmdlet’s output to
    `Get-Member`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑第一个cmdlet产生的对象。这些对象有哪些属性？你可以通过将第一个cmdlet的输出通过管道传递到`Get-Member`来查看这一点。
- en: Consider the parameters of the second cmdlet (you’ll need to read the full help
    again). Are there any parameters that (a) have the same name as one of the properties
    from step 4, and (b) accept pipeline input using the `ByPropertyName` technique?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑第二个cmdlet的参数（你需要再次阅读完整的帮助）。是否有任何参数（a）与步骤4中的某个属性同名，并且（b）使用`ByPropertyName`技术接受管道输入？
- en: If any parameters meet the criteria in step 5, the properties’ values will be
    attached to the same-named parameters, and the second cmdlet will run. If there
    are no matches between property names and `ByPropertyName`-enabled parameters,
    the second cmdlet will run with no pipeline input.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何参数符合步骤5中的标准，属性值将被附加到同名参数，第二个cmdlet将运行。如果属性名称与`ByPropertyName`启用的参数之间没有匹配，第二个cmdlet将不带管道输入运行。
- en: Keep in mind that you can always manually enter parameters and values on any
    command. Doing so will prevent that parameter from accepting pipeline input in
    any way, even if it would normally have done so.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以在任何命令中手动输入参数和值。这样做将防止该参数以任何方式接受管道输入，即使它通常可以这样做。
- en: A.6 When to use `$_`
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 何时使用`$_`
- en: 'This is probably one of the most confusing things about the shell: when is
    the `$_` placeholder permitted? As we learned earlier, the `$_` is a placeholder
    for the next object in the pipeline.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是关于壳（shell）最令人困惑的事情之一：何时允许使用`$_`占位符？正如我们之前所学的，`$_`是管道中下一个对象的占位符。
- en: 'This placeholder works only when the shell is explicitly looking for it and
    is prepared to fill it in with something. Generally speaking, that happens only
    within a script block that’s dealing with pipeline input, in which case the `$_`
    placeholder will contain one pipeline input object at a time. You’ll run across
    this in a few places:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个占位符仅在shell明确寻找它并准备用某物填充它时才有效。一般来说，这种情况只发生在处理管道输入的脚本块中，在这种情况下，`$_`占位符每次将包含一个管道输入对象。你会在几个地方遇到这种情况：
- en: 'In the filtering script block used by `Where-Object`:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Where-Object`使用的过滤脚本块中：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the script blocks passed to `ForEach-Object`, such as the main `Process`
    script block typically used with the cmdlet:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传递给`ForEach-Object`的脚本块中，例如通常与cmdlet一起使用的默认`Process`脚本块：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `Process` script block of a filtering function or an advanced function.
    *Learn PowerShell Toolmaking in a Month of Lunches* by Don Jones and Jeffery Hicks
    (Manning, 2012), discusses these.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过滤函数或高级函数的`Process`脚本块中。Don Jones和Jeffery Hicks的《一个月午餐中的PowerShell工具制作》（Manning,
    2012）讨论了这些内容。
- en: In the expression of a hash table that’s being used to create a custom property
    or table column.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用于创建自定义属性或表列的哈希表表达式中。
- en: In every one of those cases, `$_` occurs only within the curly braces of a script
    block. That’s a good rule to remember for figuring out when it’s okay to use `$_`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，`$_`仅在脚本块的括号内出现。这是一个很好的规则，可以帮助你确定何时可以使用`$_`。
