- en: 3 Measuring customers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 测量客户
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Measuring counts, averages, and totals of customer events
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量客户事件的计数、平均值和总和
- en: Running QA tests on metrics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指标上运行QA测试
- en: Choosing time periods and timestamps for metrics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择指标的时间段和时间戳
- en: Measuring how long a customer has been using a service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量客户使用服务的时间长度
- en: Measuring subscription metrics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量订阅指标
- en: If you are operating a product or service with repeated interactions with users
    or customers, then you should be collecting data about those interactions in a
    data warehouse. Interactions in this context means interactions between the user
    and the product, service, or platform. (It can also include interactions with
    other users, mediated by the platform.) It is common to refer to such interactions
    as events for short, because interactions tracked in a data warehouse invariably
    have a timestamp telling you when they happened.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运营一个与用户或客户有重复互动的产品或服务，那么你应该在数据仓库中收集这些互动的数据。在这个背景下，互动指的是用户与产品、服务或平台之间的互动。（也可以包括通过平台介导的其他用户之间的互动。）通常将这些互动简称为事件，因为数据仓库中跟踪的互动通常都有一个时间戳，告诉你它们发生的时间。
- en: DEFINITION Event —Any fact about user behavior, stored in the data warehouse
    with a specific timestamp.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：事件——关于用户行为的任何事实，存储在数据仓库中，并带有特定的时间戳。
- en: I am not going to teach you how to collect that data, but I am going to teach
    you how to put that data to good use. The first step in using raw data to fight
    churn is to turn the event data into a set of measurements that summarize the
    events and collectively produce a profile of the users’ behaviors. These measurements
    are often called behavioral metrics, or just metrics, for short.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会教你如何收集这些数据，但我会教你如何有效地利用这些数据。使用原始数据对抗流失的第一步是将事件数据转换为一系列总结事件并共同描绘用户行为轮廓的测量值。这些测量值通常被称为行为指标，或简称指标。
- en: DEFINITION Metric —Any summary measurement of user behavior. Metrics also have
    a timestamp, although they summarize behavior over more than just one point in
    time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：指标——对用户行为的任何总结性测量。指标也有时间戳，尽管它们总结的是超过一个时间点的行为。
- en: 'Turning related events into measurements is necessary because each event is
    like one tiny dot in a big picture: by itself, one event usually doesn’t mean
    much. But while we need to zoom out from each individual interaction, we are not
    going to zoom out very far. Each measurement is made individually for each customer,
    and it is made repeatedly over their lifetime as a customer. That’s because user
    engagement and churn are dynamic processes for each individual, and you need to
    watch how those metrics change over the subscriber’s lifetime to understand subscriber
    engagement.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关事件转换为测量是必要的，因为每个事件就像一个大画面中的一个微小点：单独来看，一个事件通常意义不大。但尽管我们需要从每个单独的互动中退出来，我们不会退得太远。每个测量都是针对每个客户单独进行的，并且在他们作为客户的整个生命周期中反复进行。这是因为用户参与度和流失是每个个体的动态过程，你需要观察这些指标在订阅者生命周期中的变化，以了解订阅者参与度。
- en: To teach this subject, I assume you have collected events but have not done
    behavioral measurements on them. If you don’t have your own data, there is a simulation
    program in this book’s downloadable code that creates artificial data for you
    to run the code on. See the code at [www.manning.com/books/fighting-churn-with-data](http://www.manning.com/books/fighting-churn-with-data)
    and [https://github.com/carl24k/fight-churn/tree/master/data-generation](https://github.com/carl24k/fight-churn/tree/master/data-generation)
    and the detailed instructions in the README file. Run the script to install the
    schema (`fight-churn/` `data-generation/churndb.py`), and then run the simulation
    that generates customers, subscriptions, and events on an imaginary social network
    (`fight-churn/data-generation/churnsim.py`). If you already generated data to
    run the examples in chapter 2, you’re good!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了教授这个主题，我假设你已经收集了事件，但还没有对它们进行行为测量。如果你没有自己的数据，这本书的可下载代码中有一个模拟程序为你生成人工数据，以便你在代码上运行。请参阅[www.manning.com/books/fighting-churn-with-data](http://www.manning.com/books/fighting-churn-with-data)和[https://github.com/carl24k/fight-churn/tree/master/data-generation](https://github.com/carl24k/fight-churn/tree/master/data-generation)中的代码以及README文件中的详细说明。运行脚本安装模式（`fight-churn/`
    `data-generation/churndb.py`），然后运行在虚构社交网络上生成客户、订阅和事件的模拟（`fight-churn/data-generation/churnsim.py`）。如果你已经生成了用于运行第2章示例的数据，那么你已经准备好了！
- en: If you work with a live product or service and are already making behavioral
    measurements, you are going to learn some new ideas for metrics and techniques
    to check the quality of your data; it will not be hard to use your existing measurements
    in the analysis. If you work at a live service and are not collecting data yet,
    you will achieve an excellent understanding of what kind of data to collect. In
    relation to the book’s overall scenario, this chapter covers calculating behavioral
    metrics from an event data warehouse (figure 3.1, explained in chapter 1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在与一个活的产品或服务合作，并且已经进行行为测量，你将学习一些关于指标和检查数据质量的技术的新想法；将现有的测量应用于分析不会很难。如果你在一个活的服务中工作，但尚未收集数据，你将获得关于收集何种数据的卓越理解。与本书的整体场景相关，本章涵盖了从事件数据仓库计算行为指标（图3.1，在第1章中解释）。
- en: '![](../Images/3-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-01.png)'
- en: Figure 3.1 This chapter’s place in the process of fighting churn with data
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1本章在用数据对抗流失的过程中的位置
- en: 'This is a big chapter, and not only in terms of length: good behavioral metrics
    are the most important step in a successful churn analysis, and this chapter explains
    a lot of the pitfalls that can prevent you from getting the best results:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很大的章节，不仅从长度上讲：良好的行为指标是成功流失分析中最重要的一步，本章解释了许多可能阻止你获得最佳结果的陷阱：
- en: In section 3.1, we start with a brief overview of the concept behind making
    behavioral metrics from events.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3.1节中，我们从一个关于从事件制作行为指标的概念的简要概述开始。
- en: Section 3.2 introduces a typical or minimal database schema for an event data
    warehouse, which is used in the SQL programs for the rest of the book.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.2节介绍了一个典型或最小的事件数据仓库数据库模式，该模式用于本书其余部分的SQL程序。
- en: 'Beginning in section 3.3, you learn the most universally useful behavioral
    metrics: counts, averages, and totals measured over specific windows in time.
    I also teach you some best practices regarding measuring behaviors that follow
    weekly cycles and timestamping metric measurements.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从3.3节开始，你将学习最通用的行为指标：在特定时间窗口内测量的计数、平均值和总和。我还教你一些关于测量遵循每周周期和指标测量时间戳的最佳实践。
- en: In sections 3.4-3.6, you learn more practical details about how to calculate
    the metrics introduced in section 3.3.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3.4-3.6节中，你将学习更多关于如何计算3.3节中引入的指标的实际细节。
- en: Along with learning about calculating metrics, it is only appropriate that you
    learn to check the results by running quality assurance (QA) tests. This is necessary
    because customer event data in data warehouses is often unreliable. This unreliability
    can manifest in different ways; for example, events can be lost on the network
    before they reach the data warehouse. In general, event data does not receive
    a lot of scrutiny, so the data person doing a churn analysis might be the first
    person to check if event data fields are correct.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习如何计算指标外，学习通过运行质量保证（QA）测试来检查结果也是合适的。这是必要的，因为数据仓库中的客户事件数据通常不可靠。这种不可靠性可能以不同的方式表现出来；例如，事件在网络传输到数据仓库之前可能会丢失。一般来说，事件数据不会受到很多审查，因此进行流失分析的数据人员可能是第一个检查事件数据字段是否正确的人。
- en: 'Section 3.7 introduces time-series QA tests for metrics. The QA reveals a common
    challenge: not all events are equally frequent, so no single time frame works
    well for all types of events.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.7节介绍了针对指标的时序QA测试。QA揭示了常见的挑战：并非所有事件都同样频繁，因此没有单一的时间框架适用于所有类型的事件。
- en: Section 3.8 shows some basic QA on the events that helps to clarify the situation
    as far as event frequency.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.8节展示了关于事件的一些基本QA，有助于澄清事件频率的情况。
- en: In section 3.9, I show you how to use the event QA to solve the problem of selecting
    a metric time frame.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3.9节中，我向你展示如何使用事件QA解决选择指标时间框架的问题。
- en: NOTE This discussion is out of order from real-world practice. Normally, you
    do event QA first and then calculate metrics, but I want to dive in and show you
    what the metrics look like before getting into the details of QA.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这次讨论的顺序与实际应用不符。通常，你首先进行事件QA，然后计算指标，但我想先展示指标的样子，然后再深入QA的细节。
- en: 'At the end of the chapter, we change gears:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们转换了方向：
- en: 'In section 3.10, you learn how to make an important measurement of each customer:
    how long they have been customers on the current subscription (or the current
    engagement, when there is not a subscription). This is called the customer or
    account tenure (not age) so that it is not confused with the customer’s actual
    age.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3.10节中，你将学习如何对每个客户进行一项重要的测量：他们在当前订阅（或在没有订阅的情况下，当前参与）中的客户时长。这被称为客户或账户任期（而非年龄），以免与客户的实际年龄混淆。
- en: Section 3.11 presents a technique to take data from subscriptions and turn it
    into metrics that are comparable with other behavioral metrics.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3.11节介绍了一种从订阅中提取数据并将其转换为与其他行为指标可比较的指标的技术。
- en: Feature engineering vs. metric design
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 特征工程与指标设计
- en: People trained in data science, machine learning, or statistics call the topic
    I just described feature engineering. The problem with the term feature engineering
    is that it is easily confused with software product features and creating such
    features through software engineering. Instead, I’ll stick to language business
    users understand and call this process metric design.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接受过数据科学、机器学习或统计学培训的人将我刚才描述的主题称为特征工程。特征工程这个术语的问题在于它很容易与软件产品功能和通过软件工程创建这些功能混淆。相反，我将坚持使用商业用户能够理解的语言，并将这个过程称为指标设计。
- en: WARNING The term feature engineering can be confusing to people not trained
    in data science, machine learning, or statistics. Avoid it when talking to your
    business colleagues; use metric design instead. This is especially true at software
    companies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：术语“特征工程”对于没有接受过数据科学、机器学习或统计学培训的人来说可能会感到困惑。在与您的商业同事交谈时，请避免使用该术语；改用指标设计。这在软件公司尤其如此。
- en: 3.1 From events to metrics
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 从事件到指标
- en: 'In this section, I first introduce the concept of turning events into metrics
    without any code, and then I show you the SQL. Imagine you are collecting login
    events in your data warehouse, and you want to turn them into usable information.
    For each user, you have a series of events, as illustrated in the top half of
    figure 3.2\. To start, we focus on only the series for a single event: logins.
    In typical online product scenarios, there are many types of events, and the events
    can occur at any time. For some types of events, there can even be multiple events
    at the same time. To find subscribers’ comparable metrics, use a time period to
    make the measurements, as illustrated in the bottom half of figure 3.2.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我首先介绍将事件转换为指标的概念，而不需要任何代码，然后向您展示SQL。想象一下，你正在收集数据仓库中的登录事件，并希望将其转换为可用的信息。对于每个用户，你有一系列事件，如图3.2的上半部分所示。首先，我们只关注单个事件的系列：登录。在典型的在线产品场景中，有许多类型的事件，事件可以随时发生。对于某些类型的事件，甚至可以同时发生多个事件。为了找到订阅者的可比较指标，使用时间段进行测量，如图3.2的下半部分所示。
- en: '![](../Images/3-02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2](../Images/3-02.png)'
- en: Figure 3.2 Events transformed into time-windowed metrics
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 事件转换为时间窗口指标
- en: A time period in this context means a range of time (a start time and an end
    time) in which to measure data. But these periods are defined relative to the
    observation time of each measurement, so a time period is usually described by
    its duration or length.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，时间段指的是一个时间范围（一个开始时间和一个结束时间），用于测量数据。但这些时间段是相对于每个测量的观测时间来定义的，因此时间段通常用其持续时间或长度来描述。
- en: DEFINITION Time period—In an event-based metric calculation, the window of time
    within which events are used for the measurement. Time periods are described by
    their duration because the specific window for each measurement (the start and
    end times) is determined relative to the measurement date.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：时间段——在基于事件的指标计算中，用于测量的事件的时间窗口。时间段以其持续时间来描述，因为每个测量（开始和结束时间）的具体窗口是相对于测量日期确定的。
- en: For example, a metric with a four-week period like the one in figure 3.2 makes
    repeated measurements within windows that are four weeks long. The metric calculation
    may be to count the number of events in each resulting window, or more complex
    measurements can be used, as described later in the chapter. I define all my metric
    periods as an even number of weeks; I explain why in section 3.4.1.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图3.2中具有四周周期的指标在四个周长的窗口内进行重复测量。指标计算可能是计算每个结果窗口中的事件数量，或者可以使用更复杂的测量，如本章后面所述。我将所有指标周期定义为偶数周；我在第3.4.1节中解释了原因。
- en: Also note that these metrics are calculated on the day after the period ends,
    so the observation of events is complete. For example, on January 29, you can
    calculate the number of logins per subscriber in the four weeks covering January
    1-28\. Then, on February 26, you can measure the number of logins for the four
    weeks from January 29-February 25, and so on. I return to this discussion in detail
    in section 3.4.2.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，这些指标是在周期结束后的一天计算的，因此事件观察是完整的。例如，在 1 月 29 日，您可以计算涵盖 1 月 1 日至 28 日的四周内每个订阅者的登录次数。然后，在
    2 月 26 日，您可以测量从 1 月 29 日至 2 月 25 日的四周内的登录次数，依此类推。我将在 3.4.2 节中详细讨论这个问题。
- en: 3.2 Event data warehouse schema
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 事件数据仓库架构
- en: This chapter examines how to calculate metrics with code; but to lay the groundwork,
    I need to explain how events are stored in a data warehouse. There are many types
    of data warehouses, and I assume you can query the data warehouse with SQL. You
    can use a transactional SQL database as your event data warehouse as long as the
    data is not too big. The examples in this book were generated in Postgres (or
    PostgreSQL).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何使用代码计算指标；但为了打下基础，我需要解释事件如何在数据仓库中存储。数据仓库有很多种类型，我假设您可以使用 SQL 查询数据仓库。只要数据量不是很大，您可以使用事务
    SQL 数据库作为事件数据仓库。本书中的示例是在 Postgres（或 PostgreSQL）中生成的。
- en: 'Table 3.1 shows the key elements of a typical event data schema. This schema
    is used for all the SQL code listings related to events. (See the book’s downloadable
    code for detailed instructions on how to set up a database with this schema and
    populate it with simulated data.) The following is the typical minimum set of
    fields for this kind of table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 展示了典型事件数据架构的关键元素。此架构用于所有与事件相关的 SQL 代码列表。（有关如何使用此架构设置数据库以及如何用模拟数据填充数据库的详细说明，请参阅本书的可下载代码。）以下此类表典型的最小字段集包括：
- en: '`account_id`—An identifier for the account holder or user, required to track
    events back to the customer who created them.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account_id`—账户持有人或用户的标识符，用于将事件追踪回创建它们的客户。'
- en: '`event_type_id`—Because events generally have many types, this is the foreign
    key to a separate table describing the types.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_type_id`—由于事件通常有多种类型，这是到描述类型的单独表的键外键。'
- en: '`event_time`—A timestamp, which every event must have.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_time`—一个时间戳，每个事件都必须有。'
- en: 'Table 3.2 shows an associated event type table so the string names for events
    are not duplicated (for performance reasons, as is standard practice in a database
    or data warehouse). In summary, an event is something (the event type ID) that
    happens to someone (the account ID) at some time (the event time). The following
    additional fields can also be included in such a table but are not required:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 展示了一个相关的事件类型表，以便事件的字符串名称不会重复（出于性能原因，这是数据库或数据仓库中的标准做法）。总之，事件是发生在某人（账户 ID）身上（事件类型
    ID）的某事（事件时间）。以下附加字段也可以包含在此类表中，但不是必需的：
- en: '`event_id`—Unique identifiers for events may or may not be included in a data
    warehouse. It’s not relevant for the analysis because there is normally no uniqueness
    constraint on events.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_id`—事件在数据仓库中可能包含或不包含唯一标识符。对于分析来说，这并不相关，因为事件通常没有唯一约束。'
- en: '`user_id`—A user ID can be present (in addition to an account ID), especially
    in services where there are multiple individuals associated with a single account.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`—用户 ID 可以存在（除了账户 ID 之外），尤其是在有多个个人与单个账户关联的服务中。'
- en: '`event_data`—Events often have a large number of optional data fields that
    provide additional information about the events. These are most often numeric
    but can include textual information as well.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_data`—事件通常有许多可选数据字段，这些字段提供了关于事件的额外信息。这些字段通常是数字，但也可能包括文本信息。'
- en: If you are familiar with data warehouses, you can see that the schema for events
    is pretty typical of any fact table, except that numeric data fields for events
    are optional (they are often required for some types of data warehouses).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉数据仓库，您会看到事件架构与任何事实表架构非常典型，只是事件的数据字段是可选的（在某些类型的数据仓库中通常需要这些数字字段）。
- en: Table 3.1 Typical event data schema
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 典型事件数据架构
- en: '| Column | Type | Notes |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `account_id` | `integer` or `char` |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `account_id` | `integer` 或 `char` |  |'
- en: '| `event_type_id` | `integer` or `char` | Key for `event_type_name` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `event_type_id` | `integer` 或 `char` | `event_type_name` 的键 |'
- en: '| `event_time` | `timestamp` |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `event_time` | `timestamp` |  |'
- en: '| `event_id` | `integer` or `char` | Optional |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `event_id` | `integer` 或 `char` | 可选 |'
- en: '| `user_id` | `integer` or `char` | Optional |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `user_id` | `integer` 或 `char` | 可选 |'
- en: '| `event_data_1` | `float` or `char` | Optional |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `event_data_1` | `float` 或 `char` | 可选 |'
- en: '| `. . .` |  |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `. . .` |  |  |'
- en: '| `event_data_n` | `float` or `char` | Optional |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `event_data_n` | `float` 或 `char` | 可选 |'
- en: Table 3.2 Typical event type data schema
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 典型事件类型数据模式
- en: '| Column | Type | Notes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `event_type_name` | `char` | Unique |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `event_type_name` | `char` | 唯一 |'
- en: '| `event_type_id` | `integer` or `char` | Key for `event_type_name` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `event_type_id` | `integer` 或 `char` | `event_type_name` 的键 |'
- en: 3.3 Counting events in one time period
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 在一个时间周期内计数事件
- en: 'Figure 3.3 is a continuation of the scenario illustrated in figure 3.2: it
    shows the details of calculating a metric for one account and one event based
    on the event schema in table 3.1\. Each event in the table is mapped to a corresponding
    time period, and the total count is the result for that period. Because the periods
    do not overlap, each event is counted only once. The calculation is repeated for
    every event and account, which would be tedious if you were planning to do this
    by hand or even in a spreadsheet. Fortunately, SQL offers a concise language for
    expressing and implementing this type of calculation.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3是图3.2中场景的延续：它显示了基于表3.1中事件模式计算一个账户和一个事件的指标细节。表中的每个事件都映射到一个对应的时间段，总计数是该时间段的结果。因为时间段不重叠，每个事件只计算一次。对于每个事件和账户都会重复计算，如果你打算手动或甚至在电子表格中做这项工作，将会很繁琐。幸运的是，SQL提供了一种简洁的语言来表达和实现此类计算。
- en: 'Performing these calculations at scale involves a challenge you saw in chapter
    2: this data is likely to be big. Just like calculating churn rates, we do all
    the work in the data warehouse with SQL, rather than extracting data and then
    working on it in a programming language like Python.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模上进行这些计算涉及你在第2章中看到的一个挑战：这些数据可能很大。就像计算流失率一样，我们使用SQL在数据仓库中完成所有工作，而不是提取数据然后在Python这样的编程语言中处理它。
- en: NOTE This is another place where you may be used to performing such computations
    in a procedural language, but I ask that you reserve judgment and learn what a
    powerful tool SQL can be for this kind of calculation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这又是一个你可能习惯于在过程性语言中执行此类计算的地方，但我要求你保留判断，并学习SQL如何成为此类计算的有力工具。
- en: 'Listing 3.1 shows the SQL to count the number of events within a single time
    frame (like that illustrated in figure 3.2). The main steps in the query are as
    follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1显示了在单一时间框架内计数事件数量的SQL（如图3.2所示）。查询的主要步骤如下：
- en: Set the date to make the measurement, using a common table expression (CTE,
    introduced in chapter 2).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用公共表表达式（CTE，在第2章中介绍）设置测量日期。
- en: Select all the events in the time frame with the correct type.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择具有正确类型的时间框架内的所有事件。
- en: Aggregate-count the events by account.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按账户聚合计数事件。
- en: '![](../Images/3-03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-03.png)'
- en: Figure 3.3 Metric calculation from an event schema
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 从事件模式进行指标计算
- en: If you created the simulated social network dataset, it includes an event for
    users liking posts. Listing 3.1 shows the query for counting these events, and
    figure 3.4 illustrates the result. For each account that made any likes within
    28 days prior to the metric calculation rate, there is one count.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了模拟的社会网络数据集，它包括用户喜欢帖子的一个事件。列表3.1显示了计数这些事件的查询，图3.4展示了结果。对于在指标计算率前28天内对任何帖子进行过点赞的每个账户，都有一个计数。
- en: '![](../Images/3-04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-04.png)'
- en: Figure 3.4 Result of the event count SQL (listing 3.1) on the simulated social
    network dataset-like event. Your results will differ because the data was randomly
    simulated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4展示了在模拟的社会网络数据集上执行事件计数SQL（列表3.1）的结果。你的结果将不同，因为数据是随机模拟的。
- en: Listing 3.1 Counting the number of events in a time window
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 在时间窗口内计数事件数量
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① This CTE sets the date used to calculate the measurement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE设置了用于计算测量的日期。
- en: ② Selects the account, the date, and the count
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ② 选择账户、日期和计数
- en: ③ Sets the period for which the measurement is made
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置测量的周期
- en: ④ Using “greater than but not equal to” avoids double counting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用“大于但不等于”避免重复计数。
- en: ⑤ Selects the event we are making the measurement for
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 选择我们进行测量的事件
- en: ⑥ The GROUP BY aggregation yields one measurement per account.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ GROUP BY 聚合函数为每个账户产生一个测量值。
- en: 'Run listing 3.1 to see the result on your own data. If you have generated the
    default simulated dataset and set up the environment as specified in the README,
    you can run the listing with this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 3.1 以查看你自己的数据结果。如果你已经生成了默认的模拟数据集并按照 README 文件中指定的设置配置了环境，你可以使用以下命令运行列表：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The wrapper program prints the SQL before it connects to the database, executes
    the query, and prints some of the results. If you don’t want to use the wrapper
    program, the source code for listing 3.1 can be found in fight-churn/listings/chap3
    in the book’s code. Note that the listing code is stored as a template with bind
    variables (beginning with `%`); you can modify the bind variables and run the
    query with the SQL tool of your choice. Your result will look similar to figure
    3.4, but not exactly the same, because the data is randomly simulated.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 包装程序在连接到数据库、执行查询并打印一些结果之前打印 SQL。如果你不想使用包装程序，列表 3.1 的源代码可以在书籍代码的 fight-churn/listings/chap3
    中找到。请注意，列表代码存储为带有绑定变量（以 `%` 开头）的模板；你可以修改绑定变量，并使用你选择的 SQL 工具运行查询。你的结果将类似于图 3.4，但并不完全相同，因为数据是随机模拟的。
- en: 'If you are familiar with SQL, you might have some questions about that query:
    why do I use the date condition “less than or equal to” for the end of the window
    but “greater than and not equal to” at the end of the query? Why not use the “between”
    syntax? This is to avoid double-counting any events on the boundary if you make
    repeated measurements. A related question might be why I don’t use SQL window
    functions to calculate the results. The reason is that SQL window functions usually
    operate on a fixed number of records, but the number of events within a given
    date range is not fixed. The boundary for the window is set by the date condition,
    not the number of events in the window.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 SQL，你可能会对那个查询有一些疑问：为什么我在窗口的末尾使用“小于或等于”的日期条件，但在查询的末尾使用“大于且不等于”？为什么不使用“between”语法？这是为了避免在重复测量时在边界上重复计算任何事件。一个相关的问题可能是为什么我不使用
    SQL 窗口函数来计算结果。原因是 SQL 窗口函数通常在固定数量的记录上操作，但给定日期范围内的活动数量是不固定的。窗口的边界是由日期条件设置的，而不是窗口中的事件数量。
- en: 3.4 Details of metric period definitions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 指标周期定义的细节
- en: Now that you know how to calculate a metric, I’ll discuss choosing metric periods.
    These details may seem trivial, but you would be surprised how much they can impact
    the effectiveness of your analysis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何计算指标，我将讨论选择指标周期。这些细节可能看起来微不足道，但你可能会惊讶它们对分析有效性的影响有多大。
- en: 3.4.1 Weekly behavioral cycles
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 周行为周期
- en: You are probably wondering why I have used metric measurements calculated over
    four-week periods and not calendar months. To understand this, you need to realize
    that human activities follow a weekly cycle, so it is likely that the events in
    your data warehouse also follow a weekly cycle. If your product is something that
    people use for work, then most events will occur on Monday through Friday, and
    Saturday and Sunday will have fewer events. On the other hand, if your product
    is something people use for leisure, like watching videos or playing a game, then
    the heaviest use will be on Friday through Sunday, and Monday through Thursday
    may be relatively slow.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我使用了四周期的指标测量，而不是日历月份。为了理解这一点，你需要意识到人类活动遵循一个周周期，因此你的数据仓库中的事件也可能遵循一个周周期。如果你的产品是人们用于工作的事物，那么大多数事件将在周一至周五发生，而周六和周日将会有较少的事件。另一方面，如果你的产品是人们用于休闲的事物，如观看视频或玩游戏，那么最频繁的使用将在周五至周日，而周一至周四可能相对较慢。
- en: The reason to use metrics with periods defined as an even number of weeks is
    that every measurement window used to make a calculation has the same number of
    high- and low-usage days. For example, imagine a consumer product with peak usage
    on the weekend. Months that have five weekends will appear to have around 20%
    more events than months with only four weekends. But it would be a mistake to
    think this represents a real increase in usage because it is an artifact of the
    fact that the measuring windows are not even.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义为偶数周的周期指标的原因是，每个用于计算的测量窗口都有相同数量的高使用日和低使用日。例如，想象一个周末使用量最高的消费者产品。有五个周末的月份看起来比只有四个周末的月份有大约
    20% 的更多事件。但认为这代表实际使用量的增加是错误的，因为这是由测量窗口不均匀的事实造成的。
- en: TIP Most human behaviors follow weekly cycles. Consequently, for metrics using
    a period of one month or less, it is best to measure using time windows that are
    multiples of seven days.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**技巧**：大多数人类行为遵循每周周期。因此，对于使用一个月或更短周期的指标，最好使用7天的倍数时间窗口进行测量。'
- en: 'The user behavior on Klipfolio is a perfect example of weekly behavioral cycles.
    Klipfolio is a software as a service (SaaS) company that allows businesses to
    create online dashboards of their key metrics (introduced in chapter 1). The weekly
    cycle of business-to-business (B2B) software use is illustrated in figure 3.5,
    which shows the number of dashboard views per day for Klipfolio. It is obvious
    that usage is significantly higher on weekdays and much slower on the weekend:
    on average, weekdays have 40% more dashboard views than weekends.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Klipfolio上的用户行为是每周行为周期的完美例子。Klipfolio是一家软件即服务（SaaS）公司，允许企业创建其关键指标的在线仪表板（在第1章中介绍）。图3.5展示了Klipfolio每日仪表板查看次数的每周周期，它显示了商业对商业（B2B）软件使用的每周周期。很明显，在工作日使用量显著更高，而在周末使用量则慢得多：平均而言，工作日比周末有40%更多的仪表板查看次数。
- en: '![](../Images/3-05.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-05.png)'
- en: Figure 3.5 Klipfolio’s total dashboard views per day
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 Klipfolio每日总仪表板查看次数
- en: 'That said, note that making measurements in even numbers of weeks is important
    for small measurement windows: if the measurement period is more than around 12
    weeks, then adding or subtracting one weekend will not make much difference. For
    example, for one-year measurements, there is no reason to choose 52 weeks, or
    364 days, rather than 365 days.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，请注意，在偶数周进行测量对于小测量窗口来说很重要：如果测量周期超过大约12周，那么增加或减少一个周末不会产生太大影响。例如，对于一年的测量，没有必要选择52周，或364天，而不是365天。
- en: 3.4.2 Timestamps for metric measurements
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 指标测量的时间戳
- en: Another important issue is how measurements are timestamped.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是测量如何进行时间戳。
- en: DEFINITION Timestamp —A single date and time to represent the metric, which
    is a calculation made on events in a time window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 时间戳——代表指标的单个日期和时间，该指标是在时间窗口内的事件上进行的计算。'
- en: 'Measurements like this need to have a timestamp representing the period they
    cover because you make the measurements repeatedly and analyze how they change
    over time. A seemingly trivial but actually subtle point is as follows. Suppose
    you measure the number of logins:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测量需要有一个时间戳来表示它们覆盖的时期，因为你会反复进行测量并分析它们随时间的变化。一个看似微不足道但实际上很微妙的问题是以下内容。假设你测量登录次数：
- en: You measure all events from January 1 through January 28 (inclusive).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你测量从1月1日到1月28日（包括）的所有事件。
- en: You make the measurement on January 29.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在1月29日进行测量。
- en: Which date do you timestamp that measurement with?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该用哪一天的时间戳来标记那个测量？
- en: January 1
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1月1日
- en: January 28
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1月28日
- en: January 29
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1月29日
- en: Some other option
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些其他选项
- en: 'Best practice is to timestamp the metric with the date/time immediately after
    the measurement period: in this case, January 29 at midnight for the January 1-28
    measurement. This is a convention, and it may seem arbitrary, but the wrong choice
    leads to undesirable complications. There are a few reasons you will need to synchronize
    the measurements to make a snapshot of a customer at a single point in time. Making
    a synchronized snapshot is easiest if you timestamp at the end of the observation
    window because then you just select all the metrics for the same timestamp.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在测量周期结束后立即用日期/时间标记指标：在这种情况下，对于1月1日至28日的测量，午夜是1月29日。这是一个惯例，它可能看起来是任意的，但错误的选择会导致不希望出现的复杂情况。有几个原因你需要同步测量以在某个时间点创建客户的快照。如果在观察窗口结束时标记时间戳，那么创建同步快照就最容易，因为那时你只需选择相同时间戳的所有指标。
- en: TAKEAWAY The best choice for the timestamp on behavioral metrics is the date
    and time on which the measurement of the customer would be made, assuming it was
    calculated in real time, at the earliest time possible. This is true even if the
    measurement is calculated at a later date.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点**：对于行为指标的时间戳，最佳选择是客户测量时的时间日期，假设它是实时计算，尽可能早的时间。即使测量是在稍后的日期计算的，这也适用。'
- en: 'The problems with the alternatives are these:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案的问题如下：
- en: Using the start date of the window as the timestamp causes problems if you use
    windows of different lengths in a single analysis. In that case, you need to calculate
    the synchronization date from the timestamp plus the time period.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在单个分析中使用不同长度的窗口，以窗口的开始日期作为时间戳会导致问题。在这种情况下，你需要从时间戳加上时间周期计算同步日期。
- en: The time you make the measurement is not a good timestamp because it could be
    days or months after the fact, which introduces uncertainty.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你进行测量的时间不是一个好的时间戳，因为它可能是几天或几个月之后，这引入了不确定性。
- en: Using the last day (at midnight) of the measurement period as a timestamp is
    subtly misleading in that it implies you could observe the full period measurement
    when there is still one day remaining. If you timestamp the measurement 24 hours
    before it is complete and then need to sync the measurements with other data sources,
    it can introduce subtle errors.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测量期最后一天（午夜）作为时间戳是微妙地误导性的，因为它暗示你可以在还有一天剩余的情况下观察到整个周期的测量值。如果你在测量完成前24小时进行时间戳，然后需要与其他数据源同步测量值，可能会引入微小的错误。
- en: This day-after period timestamp convention may be a bit confusing at first because
    many people timestamp measurements for a calendar month with the first of the
    month, even though the measurement is not made until the first of the next month.
    (It might confuse other people in your organization who are used to that way of
    thinking.) The same goes for using four-week periods rather than calendar months.
    But four-week “months” and day-after timestamping facilitate the analysis, and
    I recommend them as best practice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在测量后一天的时期使用时间戳的惯例可能一开始会有些令人困惑，因为许多人使用月初作为日历月的测量时间戳，即使测量是在下一个月的第一天进行的。（这可能会使习惯于这种思维方式的其他组织成员感到困惑。）同样，使用四周期而不是日历月也是如此。但是四周“月份”和测量后一天的时间戳有助于分析，我建议将其作为最佳实践。
- en: 3.5 Making measurements at different points in time
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 在不同时间点进行测量
- en: To understand churn, you need to compare measurements of subscriber behavior
    at different points in their life cycle. This requires a slightly more advanced
    metric calculation technique than the one you just learned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解客户流失，你需要比较他们在生命周期不同点的客户行为测量值。这需要比你刚刚学到的稍微高级一点的指标计算技术。
- en: 3.5.1 Overlapping measurement windows
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 重叠测量窗口
- en: 'To compare customer behavioral measurements as they change over the customer
    life cycle, you need to repeat the metric calculation at regularly spaced points
    in time. However, there is a problem with the simple approach shown in figure
    3.2: if you literally followed that approach, you would update the metric only
    once every four weeks. Four-week intervals between measurements are not very dynamic.
    A lot can happen in four weeks, and you might have to check on your customers’
    behavior more often. Figure 3.6 illustrates the solution. The answer is to repeat
    the four-week measurements at more frequent intervals: in this case, weekly.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较客户行为测量值随客户生命周期变化的情况，你需要定期在时间上重复计算指标。然而，图3.2中显示的简单方法存在问题：如果你真的遵循这种方法，你将每四周只更新一次指标。四周的测量间隔并不非常动态。在四周内可能发生很多事情，你可能需要更频繁地检查客户的行为。图3.6说明了解决方案。答案是更频繁地重复四周测量：在这种情况下，每周。
- en: '![](../Images/3-06.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-06.png)'
- en: Figure 3.6 Calculating metrics with overlapping time windows
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 使用重叠时间窗口计算指标
- en: 'As shown in figure 3.6, the resulting four-week windows overlap. You can also
    see that the measurement gradually tracks between the monthly measurements shown
    in figure 3.2\. For subscriber 1, the first four-week, non-overlapping measurements
    are 2, 4, 2\. The overlapping measurements include intermediate points where the
    value was 3: 2, 3, 4, 3, 2, representing the transition period.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.6所示，产生的四周窗口重叠。您还可以看到，测量值逐渐跟踪图3.2中显示的月度测量值。对于用户1，前四周的非重叠测量值是2，4，2。重叠的测量值包括值为3的中间点：2，3，4，3，2，代表过渡期。
- en: Details of the calculation illustrated in figure 3.6 are shown in figure 3.7
    for the first four periods. Because the calculation windows overlap, the fourth
    period has an end date that is just four weeks after the end date of the first
    period. Also, each event is part of the count in multiple periods. With a four-week
    window staggered one week apart, every event will be counted in four periods,
    although this fact is not apparent from the abbreviated example in figure 3.7\.
    But as in the example calculation with non-overlapping periods (figure 3.7), each
    event is mapped into the time periods based on the beginning and end dates (of
    the periods), and the result for each period is the total count. Even more so
    than for the non-overlapping periods, this is not a calculation you would want
    to do by hand! But, remarkably, the SQL that does this metric calculation for
    overlapping periods is no more complex than for calculating non-overlapping periods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6中展示的计算细节在图3.7中展示了前四个周期。由于计算窗口重叠，第四期的结束日期正好是第一期结束日期后的四周。此外，每个事件都是多个周期计数的一部分。使用每周错开一周的四周窗口，每个事件将在四个周期中被计数，尽管这一点在图3.7的简略示例中并不明显。但就像非重叠周期的示例计算（图3.7）一样，每个事件都是根据周期（的开始和结束日期）映射到时间周期中的，每个周期的结果是总计数。对于非重叠周期来说，这不是你想要手动进行的计算！但是，令人惊讶的是，用于重叠周期指标计算的SQL并不比计算非重叠周期更复杂。
- en: '![](../Images/3-07.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-07.png)'
- en: Figure 3.7 Simple metric calculation with overlapping time windows
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 使用重叠时间窗口的简单指标计算
- en: Listing 3.2 shows the SQL that implements such measurements, and a sample result
    for the simulated churn dataset is shown in figure 3.8\. Unlike the result of
    the single-day query (listing 3.1 and figure 3.4), there are now multiple results
    for each account, but only the first few are shown. Also, each measurement is
    timestamped with the time at the end of the measurement period.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2展示了实现此类测量的SQL，以及模拟流失数据集的示例结果如图3.8所示。与单日查询的结果（列表3.1和图3.4）不同，现在每个账户都有多个结果，但只显示了其中几个。此外，每个测量都带有测量周期结束时间的戳记。
- en: '![](../Images/3-08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-08.png)'
- en: Figure 3.8 Result of a multidate event count with SQL (listing 3.2) on the simulated
    social network dataset-like event
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 使用SQL（列表3.2）在模拟社交网络数据集类似事件上的多日期事件计数结果
- en: 'The main steps in listing 3.2 are basically the same as in listing 3.1, but
    now the SQL works on a range of dates:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2中的主要步骤基本上与列表3.1相同，但现在SQL在日期范围内工作：
- en: Choose the sequence of dates to make the measurement. These dates are closer
    to each other than the intended period size.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用于测量的日期序列。这些日期比预期的周期大小更接近。
- en: For each measurement date, select the events within the time period associated
    with that measurement.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个测量日期，选择与该测量相关的时间段内的事件。
- en: Aggregate-count the events by account and measurement date.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按账户和测量日期对事件进行聚合计数。
- en: For step 1, the SQL in listing 3.2 uses the `generate_series` function to create
    a CTE containing a list of the calculation dates. With this list of metric dates
    included in the join with the event table, you calculate the count for every account
    and every measurement date by including the measurement date in both the `SELECT`
    and `GROUP` `BY` statements. As a result, the query calculates the metrics for
    an entire sequence of measurement dates at once.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于步骤1，列表3.2中的SQL使用了`generate_series`函数来创建一个包含计算日期列表的CTE。通过将这个包含指标日期的列表包含在事件表的连接中，你可以在`SELECT`和`GROUP
    BY`语句中都包含测量日期，从而为每个账户和每个测量日期计算计数。因此，查询一次计算整个测量日期序列的指标。
- en: Listing 3.2 Calculating metrics with overlapping windows
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 使用重叠窗口计算指标
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① CTE for the end dates of the windows for metric calculation
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ① 指标计算窗口的结束日期的CTE
- en: ② Postgres function to generate a series of values
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ② 生成一系列值的Postgres函数
- en: ③ Selects the account, time, and measurement
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 选择账户、时间和测量
- en: ④ Joins on date_vals CTE to set the dates
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过date_vals CTE连接来设置日期
- en: ⑤ Events are within four weeks of the measurement date.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 事件在测量日期前后四周内。
- en: ⑥ Both the account ID and the date are in the GROUP BY clause.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 账户ID和日期都包含在GROUP BY子句中。
- en: ⑦ Sorts the results for readability
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 对结果进行排序以提高可读性
- en: 'Run listing 3.2 to see the result. If you are using the simulated churn data
    and the Python wrapper program, run this command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表3.2以查看结果。如果你使用模拟流失数据和Python包装程序，请运行以下命令：
- en: '[PRE3]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of running listing 3.2 should be similar to figure 3.8, but not exactly
    the same, due to randomness in the simulation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表3.2的结果应该类似于图3.8，但由于模拟中的随机性，并不完全相同。
- en: Alternatives to the generate_series function
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: generate_series函数的替代方案
- en: In the code examples in this book, I use the Postgres function `generate_series`
    to create sequences of dates that are equally spaced. However, other database
    systems do not support this function. The same goal can be achieved by creating
    a regular (permanent) table and filling it with the desired date sequence in a
    one-time load. Also, if you search the internet for “alternatives to generate_series
    on XXX” where XXX is the database or data warehouse of your choice, you might
    find system-specific implementations. I apologize to non-Postgres users for the
    lack of generality, but the `generate_series` function is useful for teaching
    because one short line of code is all it takes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码示例中，我使用Postgres函数`generate_series`来创建等间隔的日期序列。然而，其他数据库系统可能不支持此函数。可以通过创建一个常规（永久）表并在一次性加载中填充所需的日期序列来实现相同的目标。此外，如果您在互联网上搜索“XXX上的generate_series替代方案”，其中XXX是您选择的数据库或数据仓库，您可能会找到特定于系统的实现。我为非Postgres用户缺乏通用性表示歉意，但`generate_series`函数对于教学很有用，因为它只需要一行简短的代码。
- en: 3.5.2 Timing metric measurements
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 时间度量指标测量
- en: 'In this book, I generally demonstrate techniques using weekly updated measurements
    for the same reason mentioned in section 3.4: human behavior generally follows
    weekly cycles. But for products where the typical customer lifetime is very short
    (less than a few months), it might be necessary to update the measurements more
    frequently.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我通常使用每周更新的测量值来展示技术，这与第3.4节中提到的原因相同：人类行为通常遵循每周周期。但对于典型客户生命周期非常短（少于几个月）的产品，可能需要更频繁地更新测量值。
- en: TIP For products where a typical customer lifetime is a few months or less,
    you may need to update metrics every day. But for products where a customer’s
    typical lifetime is several months or more, it is usually adequate to calculate
    metrics once a week.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 对于典型客户生命周期为几个月或更短的产品，您可能需要每天更新指标。但对于客户典型生命周期为几个月或更长的产品，通常每周计算一次指标就足够了。
- en: For products where customer lifetime is even longer, maybe many years, it might
    be adequate to update the measurements only once a month (or at four-week intervals).
    This is a judgment call you need to make based on the dynamism of your situation;
    it has to do with how long it takes a typical customer to see value from your
    product (or fail to see value) and decide to churn (or not). In any event, all
    the same analytic techniques apply, just on different time scales. Most people
    overestimate the need for real-time (frequent) updates to measurements like these.
    Usually, retention and churn is a war waged over weeks, months, or years; it is
    not common for it to come down to rapid up-to-the-minute information and interventions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户生命周期甚至更长的产品，可能只需要每月更新一次测量值（或每四周一次）。这取决于您根据具体情况做出的判断；它与典型客户看到产品价值（或未能看到价值）并决定流失（或不流失）所需的时间有关。无论如何，所有相同的分析技术都适用，只是时间尺度不同。大多数人高估了这些测量值实时（频繁）更新的需求。通常，保留和流失之战是在几周、几个月或几年中进行的；它不太可能归结为快速的信息和干预。
- en: Another important issue is when to make your measurements. As mentioned previously,
    consumer products are usually used most heavily on the weekends, while business
    products are used most heavily during the week. So, it is usually best to make
    consumer product measurements at the beginning of the week on Monday or midnight
    Tuesday, so they capture the most recent weekend’s activity. For business products,
    it is best to measure on the weekend, either Saturday or Sunday, so the measurement
    reflects the most recent complete work week.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是何时进行测量。如前所述，消费者产品通常在周末使用最为频繁，而商业产品则在工作日使用最为频繁。因此，通常最好在周一或周二午夜进行消费者产品的测量，以便捕捉到最新的周末活动。对于商业产品，最好在周末进行测量，无论是周六还是周日，以便测量结果反映最新的完整工作周。
- en: TIP Measure products used for entertainment once a week on Monday or Tuesday
    at midnight to capture the entire previous weekend’s activity. Measure products
    used for work on Friday or Saturday at midnight to capture the entire previous
    five-day work week.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 每周周一或周二午夜测量用于娱乐的产品，以捕捉整个上一个周末的活动。周五或周六午夜测量用于工作的产品，以捕捉整个上一个五天的工作周。
- en: 3.5.3 Saving metric measurements
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 保存度量测量值
- en: 'Looking at listing 3.2 and the result of the query in figure 3.8, you might
    be thinking this type of measurement could produce a lot of data. No problem!
    You have a data warehouse, right? Metric calculations should be inserted back
    into the data warehouse for storage until later analysis. A typical schema for
    storing metrics is illustrated in table 3.3\. The SQL code listings related to
    metrics use this schema. (See the book’s code for detailed instructions on how
    to set up a database with this schema and populate it with simulated data.) The
    following are the typical fields:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表 3.2 和图 3.8 中的查询结果，你可能认为这种测量会产生大量数据。没问题！你有一个数据仓库，对吧？度量计算应该被插入回数据仓库进行存储，以备后续分析。表
    3.3 展示了存储度量的典型模式。与度量相关的 SQL 代码列表使用此模式。（请参阅本书的代码，以获取有关如何设置具有此模式的数据库以及如何用模拟数据填充它的详细说明。）以下是一些典型字段：
- en: '`account_id`—An identifier for the account holder or user. Account IDs are
    required to track metrics back to the customers who created them. This is the
    first part of the composite primary key.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account_id`—账户持有者或用户的标识符。账户 ID 是追踪度量回到创建它们的客户所必需的。这是复合主键的第一部分。'
- en: '`metric_name_id`—Metrics generally have many types, and there is typically
    a foreign key to a separate table describing the types. This is the second part
    of the composite primary key.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metric_name_id`—度量通常有多种类型，通常有一个外键指向一个描述类型的单独表。这是复合主键的第二部分。'
- en: '`metric_time`—Every metric must have a timestamp, as described in section 3.5.1\.
    This is the third and final part of the composite primary key.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metric_time`—每个度量都必须有一个时间戳，如 3.5.1 节所述。这是复合主键的第三和最后一部分。'
- en: '`value`—A numeric value for the metric.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`—度量的数值。'
- en: '`user_id`—In addition to account IDs, user IDs may be present in services where
    multiple individuals are associated with a single account.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`—除了账户 ID 之外，用户 ID 可能存在于与单个账户关联多个个人的服务中。'
- en: There is also an associated metric name table (shown in table 3.4) so that the
    string names of the metrics are not duplicated (for performance reasons, as is
    standard practice in a database or data warehouse). The schema for metrics is
    similar to the schema for events (table 3.1), which makes sense because both are
    fact tables in a data warehouse.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个相关的度量名称表（如表 3.4 所示），以确保度量的字符串名称不会重复（出于性能原因，这是数据库或数据仓库中的标准做法）。度量的模式与事件的模式（表
    3.1）类似，这是有道理的，因为两者都是数据仓库中的事实表。
- en: 'One important difference between metrics and events is that metrics should
    have a composite primary key consisting of the `account_id`, `metric_name_id`,
    and `metric_time` fields. That means the combination of the account, the metric,
    and the time of measurement must be unique: only one measurement for each account
    at any given time. Another difference between the metric and event schemas is
    that while an event can have no data fields or an arbitrary assortment of data
    fields associated with each action, a metric always has exactly one data field:
    the metric value.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 度量和事件之间的重要区别之一是，度量应该有一个由 `account_id`、`metric_name_id` 和 `metric_time` 字段组成的复合主键。这意味着账户、度量以及测量时间的组合必须是唯一的：在任何给定时间，每个账户只有一个测量值。度量与事件模式之间的另一个区别是，虽然事件可以没有数据字段或与每个操作相关联的任意组合的数据字段，但度量始终只有一个数据字段：度量值。
- en: Table 3.3 Typical metric data schema
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3 典型度量数据模式
- en: '| Column | Type | Notes |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `account_id` | `integer` or `char` | Composite primary key 1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `account_id` | `integer` 或 `char` | 复合主键 1 |'
- en: '| `metric_name_id` | `integer` or `char` | Composite primary key 2; foreign
    key for `metric_name` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `metric_name_id` | `integer` 或 `char` | 复合主键 2；`metric_name` 的外键 |'
- en: '| `metric_time` | `timestamp` | Composite primary key 3 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `metric_time` | `timestamp` | 复合主键 3 |'
- en: '| `value` | `float` |  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `value` | `float` |  |'
- en: '| `user_id` | `integer` or `char` | Optional |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `user_id` | `integer` 或 `char` | 可选 |'
- en: If your data warehouse supports inserting `SELECT` statement results directly
    back into the data warehouse, then saving the metric results is easy, as illustrated
    in listing 3.3\. The code in listing 3.3 is just the same as that in listing 3.2
    but with the `INSERT` keyword that turns it into an SQL `INSERT` statement. If
    your database does not support `INSERT` `SELECT` statements, then the normal practice
    is to save the result from a query like listing 3.2 in a delimited (comma-separated
    values) text file and then load that back into the data warehouse using whatever
    mechanism the data warehouse provides.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据仓库支持直接将`SELECT`语句的结果插入数据仓库，那么保存度量结果很容易，如列表3.3所示。列表3.3中的代码与列表3.2中的代码相同，只是添加了`INSERT`关键字，将其转换为SQL
    `INSERT`语句。如果您的数据库不支持`INSERT` `SELECT`语句，那么常规做法是将列表3.2中的查询结果保存到以分隔符（逗号分隔值）分隔的文本文件中，然后使用数据仓库提供的任何机制将该文件加载回数据仓库。
- en: Table 3.4 Associated metric name data schema
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4 关联的度量名称数据模式
- en: '| Column | Type | Notes |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `metric_name` | `char` | Unique |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `metric_name` | `char` | 唯一 |'
- en: '| `metric_name_id` | `integer` or `char` | Key for `metric_name` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `metric_name_id` | `integer` 或 `char` | `metric_name` 的键 |'
- en: Listing 3.3 Inserting metric calculations into the data warehouse
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 将度量计算插入数据仓库
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算日期。
- en: ② Inserts the result of the SELECT into the metric table
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将SELECT的结果插入度量表
- en: ③ Includes the ID for the metric, which we assume is 0
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 包含度量值的ID，我们假设为0
- en: ④ The rest of the SELECT statement is the same as listing 3.2.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ④ SELECT语句的其余部分与列表3.2相同。
- en: Run listing 3.3 and see that it writes to your own database schema. If you are
    using the simulated data and the Python wrapper program, use the command
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表3.3并查看它是否写入您自己的数据库模式。如果您正在使用模拟数据和Python包装程序，请使用以下命令
- en: '[PRE5]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that there is no output other than the line printed by the Python wrapper
    program. The result is that data is saved in the database. You should select the
    result from the database with a query against the metric table: for example, `SELECT`
    `*` `FROM` `metric` `limit` `10;`. The result of such a query should look like
    the sample in figure 3.8.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了Python包装程序打印的行之外，没有其他输出。结果是数据已保存到数据库中。您应该通过针对度量表的查询来选择结果：例如，`SELECT` `*`
    `FROM` `metric` `limit` `10;`。此类查询的结果应类似于图3.8中的示例。
- en: Remember that you can run this listing only once, unless you change the configuration
    or clean the results out of the database. After you have inserted results for
    one metric for particular accounts on particular dates, you can’t reinsert new
    results for the same accounts and dates. If you insert values for a new metric,
    you also need to make a one-time insert into the metric name table (table 3.4).
    This statement is short and well known to anyone with basic SQL knowledge, but
    sample code is shown in listing 3.4 for the sake of completeness.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您只能运行此列表一次，除非您更改配置或从数据库中清除结果。在为特定日期特定账户插入一个度量值的结果后，您不能为相同的账户和日期重新插入新的结果。如果您为新的度量值插入值，您还需要一次性将度量名称表（表3.4）中的名称插入。此语句对任何具有基本SQL知识的人来说都很短且众所周知，但为了完整性，示例代码在列表3.4中给出。
- en: If you inserted a metric with listing 3.3, you must also insert the name by
    running listing 3.4 to run later listings in this chapter. Run listing 3.4 using
    the Python wrapper program and the parameter `—listing` `4`, or make an equivalent
    insert through an SQL tool of your choice. Note that you should never insert the
    same metric name or ID twice. (In a relational database, a key constraint should
    prevent this. The best practice in a relational database is to insert the metric
    name first and use a foreign key constraint on the metric table to prevent loading
    metrics with no name.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用列表3.3插入了一个度量值，您还必须通过运行列表3.4来插入名称，以便运行本章后面的列表。使用Python包装程序和参数`—listing`
    `4`运行列表3.4，或者通过您选择的SQL工具进行等效插入。请注意，您不应两次插入相同的度量名称或ID。（在关系型数据库中，键约束应防止这种情况。在关系型数据库中的最佳实践是首先插入度量名称，并在度量表上使用外键约束来防止加载没有名称的度量。）
- en: Listing 3.4 Inserting a metric name into the data warehouse
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 将度量名称插入数据仓库
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before moving on, I want to call your attention to the fact that the metric
    calculation in listing 3.3 does not insert zeros for accounts with no events.
    This is a natural product of the inner join on events, and you might not have
    paid attention to it. It is not much more difficult to define a count metric that
    produces zeros for accounts with no events, but storing zero-count metrics scales
    badly when the number of accounts is large, and events can be rare. You could
    even end up storing mostly zeros! The approach I take is to not store the zeros
    on counts in the data warehouse; then, during the analysis phase (beginning in
    the next chapter), I generate zeros when needed to analyze accounts with no events.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想提醒您注意，列表 3.3 中的指标计算没有为没有事件的账户插入零。这是事件内连接的自然产物，您可能没有注意到这一点。定义一个对于没有事件的账户产生零的计数指标并不困难，但当账户数量很大且事件很少时，存储零计数指标的性能会很差。您甚至可能最终存储了大部分零！我采取的方法是在数据仓库中不存储计数中的零；然后，在分析阶段（从下一章开始），我需要分析没有事件的账户时生成零。
- en: 3.5.4 Saving metrics for the simulation examples
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 保存模拟示例的指标
- en: 'By running listings 3.3 and 3.4, you should have inserted one event count metric
    for the number of likes into the database and a name in the `metric_name` table:
    `likes _permonth`. There are seven more events in the simulated social network
    dataset: dislike, post, new friend, unfriend, adview, message, and reply. The
    metrics on these events are used for examples in the rest of this chapter and
    the book, so you should insert them into your own database before moving on. To
    make it easy to do, the listing wrapper program includes the required alternative
    versions of listings 3.3 and 3.4\. To run them, add the `—version` flag and a
    list of version numbers to the execution command. Also, you can run listings 3.3
    and 3.4 together by listing both numbers after the `—listing` flag. To run listings
    3.3 and 3.4 and insert the next seven count metrics for the simulation, use this
    command with the wrapper script:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行列表 3.3 和 3.4，您应该在数据库中插入了一个事件计数指标，用于表示点赞数量，并在 `metric_name` 表中有一个名称：`likes_permonth`。模拟社交网络数据集中还有七个其他事件：不喜欢、帖子、新朋友、解除好友、广告查看、消息和回复。这些事件的指标将用于本章和本书的其余部分中的示例，因此您在继续之前应该将它们插入到自己的数据库中。为了便于操作，列表包装程序包括了所需的列表
    3.3 和 3.4 的替代版本。要运行它们，请在执行命令中添加 `—version` 标志和版本号列表。此外，您可以通过在 `—listing` 标志后列出两个数字来一起运行列表
    3.3 和 3.4。要使用包装脚本运行列表 3.3 和 3.4 并插入模拟的下一个七个计数指标，请使用以下命令：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To insert so many metrics will take at least 10 minutes on most systems, so
    this is a good time to take a coffee break. (You might want to run just one first,
    to see how long it takes on your system.) Note that the prior runs of listings
    3.3 and 3.4 were considered version 1, so the additional metrics start at version
    2\. More instructions for running the listings are in the README file at the root
    of the GitHub repository.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统中插入这么多指标至少需要 10 分钟，所以这是一个喝咖啡的好时机。（您可能想先运行一个，看看在您的系统上需要多长时间。）请注意，列表 3.3
    和 3.4 的先前运行被认为是版本 1，所以附加指标从版本 2 开始。有关运行列表的更多说明，请参阅 GitHub 仓库根目录下的 README 文件。
- en: 3.6 Measuring totals and averages of event properties
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 测量事件属性的总额和平均值
- en: 'So far, we’ve looked only at metrics that are simple counts of events; but
    when events have data in additional fields, you will probably want to summarize
    that data in the metric. The most typical case is when an event has a numeric
    value associated with it. Some of the most typical cases are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了事件简单计数的指标；但当事件有附加字段中的数据时，您可能希望在该指标中总结这些数据。最典型的情况是事件与一个数值相关联。以下是一些最典型的情况：
- en: The event has a duration in time such as the length of a session or playback
    of some media.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件在时间上有一个持续时间，例如会话长度或某些媒体的播放。
- en: The event has a monetary value such as a retail purchase or an overage charge.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件有一个货币价值，例如零售购买或超额费用。
- en: 'In such scenarios, the most common metrics are one of these:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最常见的指标之一如下：
- en: The total value of all the events
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有事件的总体价值
- en: The average value per event
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个事件的平均值
- en: 'Either one of these (and many others) can be calculated with similar SQL, shown
    in listing 3.5 for the case of a total, assuming the events have a field called
    `time_spent`. The metric represents the total time each user spends in this type
    of session during a four-week period. The steps in the metric calculation are
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些（以及许多其他）都可以使用类似的SQL计算，如列表3.5所示，假设事件有一个名为`time_spent`的字段。该指标表示每个用户在四周期间此类会话中花费的总时间。指标计算的步骤如下：
- en: Choose the sequence of dates to make the measurement.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择测量日期的序列。
- en: For each measurement date, select the events within the time window associated
    with that measurement.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个测量日期，选择与该测量相关的时间窗口内的活动。
- en: Sum the time-spent field from the events grouped by account and measurement
    date.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对按账户和测量日期分组的活动求`time_spent`字段的和。
- en: The SQL is almost identical to listing 3.2 for the event count metric. The only
    difference is in the `SELECT` statement, where rather than counting the number
    of events with the `COUNT(*)` aggregate function, the SQL sums the total of the
    `time_spent` field with the aggregate function `SUM(time_spent``)`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: SQL几乎与事件计数指标的列表3.2相同。唯一的区别在于`SELECT`语句，而不是使用`COUNT(*)`聚合函数来计数事件数量，SQL使用聚合函数`SUM(time_spent)`来计算`time_spent`字段的总量。
- en: 'Versature (introduced in chapter 1) is a provider of unified telecommunication
    services for businesses. As a unified communications provider, one of its most
    important events is voice calls that have a duration stored in a field attached
    to each event. A few lines of example output from running listing 3.5 on Versature’s
    local-call event are shown in figure 3.9\. The result in figure 3.9 appears similar
    to the output of count metrics in figure 3.8, but the metric value is not the
    count of events in the time window: it is the total of the time-spent quantity
    field in those events.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Versature（在第1章中介绍）是一家为企业提供统一电信服务提供商。作为统一通信提供商，其最重要的一个事件是存储在每个事件附加字段中的通话持续时间。运行列表3.5在Versature本地呼叫事件上的几个示例输出显示在图3.9中。图3.9中的结果看起来与图3.8中计数指标的结果相似，但指标值不是时间窗口内事件的数量：它是这些事件中`time_spent`数量字段的总量。
- en: '![](../Images/3-09.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-09.png)'
- en: Figure 3.9 Result of total duration SQL listing 3.5 for Versature's local-call
    event
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 Versature本地呼叫事件的SQL列表3.5的总持续时间结果
- en: At the time of this writing, the default simulated data does not include event
    properties, so you can’t run this on simulated data out of the box. That said,
    the simulation code can be extended to include event properties. I encourage you
    to do so and then make a pull request to share your work. Although you cannot
    run listing 3.5 on the simulation, it is provided as an example to use with your
    own data that includes event properties.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，默认的模拟数据不包括事件属性，因此您无法直接在模拟数据上运行此操作。尽管如此，模拟代码可以被扩展以包括事件属性。我鼓励您这样做，然后提交一个拉取请求来分享您的工作。虽然您无法在模拟上运行列表3.5，但它被提供作为使用包含事件属性的您自己的数据的示例。
- en: Listing 3.5 Measuring a sum of an event property
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 测量事件属性的总和
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算所需的日期。
- en: ② Assumes the event has a duration data field, and SUMs over events
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ② 假设事件有一个持续时间数据字段，并对事件进行求和
- en: ③ The date criterion is the same as in listing 3.2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 日期标准与列表3.2相同。
- en: ④ Otherwise the SELECT statement is the same as for the count metric.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 否则，`SELECT`语句与计数指标相同。
- en: 3.7 Metric quality assurance
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 指标质量保证
- en: Now that you’ve learned how to calculate a few metrics, I need to take a step
    back and teach you some basic techniques to check the results. In the previous
    sections, I have shown you only a few examples of the output results, but spot-checking
    a few lines of results is not an adequate method for assuring the quality of behavioral
    metrics. In case you didn’t catch the last sentence, let me repeat.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何计算一些指标，我需要退一步教您一些基本技巧来检查结果。在前面的章节中，我只展示了输出结果的一些示例，但抽查几行结果并不能充分保证行为指标的质量。如果您没有注意到最后一句话，让我重复一遍。
- en: WARNING Spot-checking a few rows of results is not an adequate method of assuring
    the quality of behavioral metrics.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：抽查几行结果并不能充分保证行为指标的质量。
- en: Why? You can see from a few lines of code that the formula is correct, right?
    But your concern is not just the correctness of the code, as in an ordinary programming
    project. Your concern is also problems like missing or bad data in some accounts
    but not others, which you would miss by just spot-checking a few rows. There are
    many ways to assure the quality of behavioral metrics, and I will present a few
    right here, along with suggestions for what to do about some common problems.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？你可以从几行代码中看到公式是正确的，对吧？但你的担忧不仅仅是代码的正确性，就像在普通编程项目中一样。你的担忧还包括一些账户中缺失或不良数据，而不仅仅是通过抽查几行就能发现。有许多方法可以确保行为度量的质量，我将在下面介绍几种，并就一些常见问题提出建议。
- en: 3.7.1 Testing how metrics change over time
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 测试度量随时间变化的情况
- en: One important way to check metrics for problems is to look at how the results
    change over time. This can be done with an aggregate query that selects the count,
    average, minimum, and maximum separately for each date. This doesn’t tell you
    everything about the values of the metric, but it should alert you to any major
    issues because such problems usually result in unusual movements in one of these
    summary statistics. An example of a plot of this result is shown in figure 3.10,
    which was created for the `like_per_month` metric from the simulated social network.
    The random simulation data shows less variability than a real churn dataset, so
    I’ll show you real examples from case studies after a quick look at the code in
    listings 3.6 and 3.7\. As you will see, one listing is a SQL `SELECT` statement
    to get the data from the database, and the other is a short Python listing to
    make the plot.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 检查度量问题的一个重要方法是通过查看结果随时间的变化情况。这可以通过一个聚合查询来完成，该查询分别对每个日期选择计数、平均值、最小值和最大值。这并不能告诉你关于度量值的所有信息，但它应该会提醒你任何重大问题，因为此类问题通常会导致这些汇总统计中的一个出现异常变动。图3.10展示了这种结果的示例图，该图是为模拟社交网络中的`like_per_month`度量创建的。随机模拟数据比真实的流失数据集变化更少，所以我在快速查看列表3.6和3.7中的代码后，将向您展示案例研究中的真实示例。您将看到，一个列表是一个从数据库获取数据的SQL
    `SELECT`语句，另一个是一个简短的Python列表，用于生成图表。
- en: 'Listing 3.6 shows a query to select the count and average value of one metric
    over the entire range of dates calculated. Note that listing 3.6 takes a slightly
    indirect approach:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6显示了一个查询，用于选择一个度量在整个日期范围内的计数和平均值。请注意，列表3.6采取了一种稍微间接的方法：
- en: Create a CTE of the dates to check.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建要检查的日期的CTE。
- en: Create a CTE of the metric being tested.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建要测试的度量的CTE。
- en: Use an outer join to calculate the result.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用外连接来计算结果。
- en: '![](../Images/3-10.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图3-10](../Images/3-10.png)'
- en: Figure 3.10 Metric quality assurance using time-series statistics
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 使用时间序列统计进行度量质量保证
- en: 'It might seem like there is a simpler alternative, which is to make a single
    aggregate `SELECT` statement on the metric table, grouping by the `metric_time`
    column. The reason for the indirect approach is that it gives a result even for
    days when no metrics were calculated: for a date with no metrics, the result is
    null for the average and zero for the count. Rows like that in the result make
    it easy to detect days when no metrics at all were calculated. In contrast, if
    an aggregate query were made on the metric table alone, there would be no result
    at all for days when there were no metrics. When missing days don’t produce rows
    in the result, it is easy to miss days when no metrics were calculated.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来有一个更简单的替代方案，那就是在度量表上执行一个单一的聚合`SELECT`语句，按`metric_time`列进行分组。间接方法的原因是，即使在没有计算度量值的日子里也能得到结果：对于没有度量的日期，平均值为null，计数为零。结果中的此类行使得检测没有计算任何度量的日子变得容易。相比之下，如果仅对度量表进行聚合查询，那么在没有度量值的日子里将没有任何结果。当缺失的日子在结果中不产生行时，很容易错过没有计算度量的日子。
- en: TIP When you quality-check metric results, always use methods that make it obvious
    when results are not produced in addition to when bad results are produced. That
    means picking the dates to check independently from the data being checked.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当你检查度量结果的质量时，除了检查结果是否产生不良结果外，还要使用使结果未产生时显而易见的方法。这意味着检查日期应独立于被检查的数据。
- en: 'Run listing 3.6 on the simulated data using the Python wrapper program with
    these arguments:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python包装程序和以下参数在模拟数据上运行列表3.6：
- en: '[PRE9]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 3.6 Measuring the average, min, max, and count of a metric over time
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 测量度量随时间变化的平均、最小、最大和计数
- en: '[PRE10]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算所需的日期。
- en: ② Selects the metrics into a CTE for the final SELECT
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将指标选择到 CTE 中进行最终 SELECT
- en: ③ Selects the average and number calculated with aggregate functions
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 选择使用聚合函数计算的平均值和数量
- en: ④ Left outer join so the query has a result for every day
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 左外连接，以便查询对每一天都有一个结果
- en: ⑤ Groups by calc_date
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 按 calc_date 分组
- en: ⑥ Orders by calc_date to make the result more readable
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 按 calc_date 排序以使结果更易读
- en: The code to make the metric QA plot in figure 3.10 is in listing 3.7\. To begin,
    listing 3.7 loads the result of the query (listing 3.6) into a Pandas `DataFrame`.
    After that, the listing uses the `matplotlib.pyplot` package to draw and save
    the plot. Because there are four nearly identical subplots, a helper function
    is used to make each one.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 制作图 3.10 中指标 QA 图的代码在列表 3.7 中。首先，列表 3.7 将查询结果（列表 3.6）加载到 Pandas `DataFrame`
    中。之后，列表使用 `matplotlib.pyplot` 包绘制并保存图表。因为有四个几乎相同的子图，所以使用了一个辅助函数来制作每一个。
- en: Listing 3.7 Plotting the metric QA stats over time
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 随时间绘制指标 QA 统计图
- en: '[PRE11]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Takes kwargs for default arguments from the SQL listings
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 SQL 列表中获取默认参数的 kwargs
- en: ② This is the file saved by listing 3.6.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这是列表 3.6 保存的文件。
- en: ③ Loads the data file into a DataFrame
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将数据文件加载到 DataFrame 中
- en: ④ Opens a figure
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打开一个图形
- en: ⑤ Uses the helper function to make subplots
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用辅助函数制作子图
- en: ⑥ Annotates the plots
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 注释图表
- en: ⑦ Saves the plots
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 保存图表
- en: 'Note that you run the Python listing the same way as the SQL listings. To run
    listing 3.7, use the following command to the Python wrapper program:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运行 Python 列表的方式与 SQL 列表相同。要运行列表 3.7，请使用以下命令对 Python 包装程序进行操作：
- en: '[PRE12]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The program makes a printout showing the location of the figure it saved. For
    example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 程序打印出它保存的图形的位置。例如：
- en: '[PRE13]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It should be equivalent to figure 3.10\. If you want to run the QA on the other
    metrics, there are other prepared versions of the command configuration for you
    to use. First, use this command to extract the data for all the metrics:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该等同于图 3.10。如果您想对其他指标运行 QA，还有其他准备好的命令配置供您使用。首先，使用此命令提取所有指标的数据：
- en: '[PRE14]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command makes the plots for the other metrics:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为其他指标生成图表：
- en: '[PRE15]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 3.7.2 Metric quality assurance (QA) case studies
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 指标质量保证（QA）案例研究
- en: 'Figure 3.11 illustrates the result of running the metric QA query shown in
    listing 3.6 on one of the Klipfolio application metrics: the count of Klip overlay
    events per month (when a user has applied a layer over a Klip). Figure 3.11 shows
    that for real metrics, the results for the average and maximum aren’t as smooth
    as for the simulation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 展示了在 Klipfolio 应用程序指标（当用户在 Klip 上应用图层时）上运行列表 3.6 中显示的指标 QA 查询的结果：每月 Klip
    叠加事件的数量。图 3.11 显示，对于真实指标，平均数和最大值的结果不如模拟时平滑。
- en: '![](../Images/3-11.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-11.png)'
- en: Figure 3.11 Results of a time-series QA on a healthy metric for Klipfolio
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 对 Klipfolio 健康指标的时序 QA 结果
- en: 'Figure 3.12 illustrates one example of a QA result when something is wrong:
    missing data was simulated by deleting one month of data for an event. (For an
    explanation of a regular metric QA, see figure 3.11.) Broadly (introduced in chapter
    1) is a mobile-first communications platform that ensures businesses looks great
    online. A customer-promoter event occurs when a customer writes a positive review,
    and customer-promoters per month is an important metric of customer success for
    the product. Normally, the average and number calculated for the metric are mildly
    variable over the year, but when data is missing, both of these QA measurements
    fall. They continue to fall until the metric calculation window passes the period
    of missing data. The maximum value of the metric is normally more varied, but
    in this case, the fall due to the missing data is even greater.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 展示了当出现问题时 QA 结果的一个示例：通过删除一个事件的一个月数据来模拟缺失数据。（有关常规指标 QA 的解释，请参阅图 3.11。）Broadly（在第
    1 章中介绍）是一个以移动端为先的通讯平台，确保企业在线看起来很棒。当客户撰写正面评论时，就会发生客户推广活动，而每月的客户推广者数量是产品客户成功的重要指标。通常，对于该指标计算的平均值和数量在一年中略有变化，但数据缺失时，这两个
    QA 测量值都会下降。它们会继续下降，直到指标计算窗口超过缺失数据的时期。指标的峰值通常变化更大，但在此情况下，由于缺失数据导致的下降甚至更大。
- en: '![](../Images/3-12.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-12.png)'
- en: Figure 3.12 Results of a time-series QA on a metric with missing event data
    for Broadly
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 对具有缺失事件数据的指标进行时间序列 QA 的结果
- en: When data for an event is missing, the maximum, average, and number calculated
    for a metric all decline. If the missing period were longer, those values would
    reach zero when there are no events in the metric measurement window; as it is,
    the period used to calculate the metric is longer than the period of the missing
    data, so the metrics do not all go to zero.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件数据缺失时，一个指标的极大值、平均值和计算出的数量都会下降。如果缺失的期间更长，那么在指标测量窗口中没有事件时，这些值会达到零；实际上，用于计算指标的期间比缺失数据的期间长，因此并非所有指标都会降到零。
- en: 'Figure 3.13 illustrates a second example of a QA result for Versature, where
    something is actually wrong: extreme values were inserted into an event property
    field. As mentioned earlier, a local-call event is logged in the database when
    a customer places a local call, and the total local-call time summed over a three-month
    period is an important metric for Versature’s accounts. Normally, the average
    and maximum for the metric are pretty constant over the year, with an increase
    during the end of the year. But when there are extreme values in the duration
    field, both QA measurements jump. The impact of the bad data is greatest in the
    maximum values and more muted in the average. The impact on the average value
    could almost be mistaken for normal variability, except for the sudden and discontinuous
    nature of the change. The extreme field values have no impact on either the number
    calculated or the minimum values. If the extreme values were negative, then the
    impact would show up as a minimum rather than a maximum value.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13展示了Versature的一个QA结果的第二个例子，其中实际上存在错误：极端值被插入到事件属性字段中。如前所述，当客户发起本地通话时，会在数据库中记录一个本地通话事件，而过去三个月内总通话时间是对Versature账户的一个重要指标。通常，该指标的年均值和最大值相对稳定，年末会有所增加。但是，当持续时间字段中出现极端值时，QA测量值都会上升。不良数据对最大值的影响最大，对平均值的影响较小。对平均值的影响几乎可以误认为是正常的变化，除了变化的突然性和不连续性。极端字段值对计算出的数量或最小值没有影响。如果极端值是负数，那么影响将表现为最小值而不是最大值。
- en: '![](../Images/3-13.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13](../Images/3-13.png)'
- en: Figure 3.13 Example results of time-series QA on a metric with extreme values
    for Versature
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 Versature指标具有极端值的时间序列QA示例结果
- en: Figure 3.13 illustrates the impact of erroneous extreme values on a metric calculation
    by showing the QA result (on the left) before and after several extreme amounts
    in the local-call duration data are inserted into the event database (on the right).
    When there are extreme (positive) values in an event data field, the biggest impact
    is on the maximum value, and there is more of a muted impact on the average value.
    If the extreme outliers were negative, the impact would be on the minimum value,
    which is unaffected in this case. The jump in the metric values lasts as long
    as the outliers are in the metric calculation window.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13通过展示QA结果（在左侧）在将几个极端的本地通话持续时间数据插入事件数据库（在右侧）前后的影响，说明了错误极端值对指标计算的影响。当事件数据字段中存在极端（正值）时，最大的影响是对最大值，对平均值的影响较小。如果极端异常值是负数，那么影响将体现在最小值上，但在此情况下最小值未受到影响。指标值的跳跃持续的时间与异常值在指标计算窗口中的持续时间相同。
- en: 3.7.3 Checking how many accounts receive metrics
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.3 检查接收指标的账户数量
- en: Another important question for QA is what percentage of the total population
    of active accounts has each metric. Listing 3.6 looks at the number of accounts
    with the metric over time, which can show temporal anomalies, but it would not
    detect an error where some accounts never have events for a metric. Checking the
    fraction of customers that receive a metric value and seeing whether it is lower
    or higher than you expect is an important test.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: QA的另一个重要问题是每个指标占活跃账户总人口的百分比。列表3.6查看随着时间的推移具有该指标的账户数量，这可以显示时间异常，但它不会检测到某些账户从未为指标产生事件的情况。检查收到指标值的客户比例，并查看它是否低于或高于预期，是一个重要的测试。
- en: The SQL in listing 3.8 calculates what percentage of all active accounts received
    a result for each metric in a given time range. The average, minimum, and maximum
    values are also calculated. An example of the result for running listing 3.8 for
    the simulated social network is shown in figure 3.14\. Most metrics cover nearly
    all accounts (90%+), except for `unfriend_permonth`, which only 59% of accounts
    have received. Does that seem correct, or is it more likely a data problem? It
    might be correct because you expect most people to post and view ads every day
    but not to unfriend people frequently.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8中的SQL计算了在给定时间范围内所有活跃账户中每个指标的结果的百分比。还计算了平均值、最小值和最大值。模拟社交网络运行列表3.8的结果示例如图3.14所示。大多数指标覆盖了几乎所有账户（90%+），除了`unfriend_permonth`，只有59%的账户收到。这看起来正确吗，还是更可能是数据问题？这可能是因为你预计大多数人每天都会发布和查看广告，但不太可能频繁地删除好友。
- en: '![](../Images/3-14.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-14.png)'
- en: Figure 3.14 Result of counting the percent of accounts with a metric (listing
    3.8) for the simulated dataset
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 模拟数据集中计算具有指标的账户百分比（列表3.8）的结果
- en: 'The steps in calculating the percentage of accounts with the metric are as
    follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 计算具有指标的账户百分比的步骤如下：
- en: Pick a time frame. The query makes one overall measurement for this window (not
    a day-by-day calculation like listing 3.6).
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个时间段。查询为该窗口进行一次整体测量（不是像列表3.6那样的每日计算）。
- en: Count the number of accounts that had active subscriptions in the time window.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在时间窗口内具有活跃订阅的账户数量。
- en: Count the number of accounts that had each type of metric in the time window.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在时间窗口内具有每种类型指标的账户数量。
- en: Calculate the percent of accounts that had each type of metric by dividing the
    result of step 3 by the result of step 2.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将步骤3的结果除以步骤2的结果来计算具有每种类型指标的账户的百分比。
- en: Measure other statistics of the metrics in the time window.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间窗口内测量指标的其他统计数据。
- en: 'The SQL in listing 3.8 uses two common table expressions (CTEs):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8中的SQL使用了两个常见的表表达式（CTE）：
- en: '`date_range`—Sets the start and end date for the calculation'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date_range`—设置计算的起始和结束日期'
- en: '`account_count`—Calculates the total number of accounts active within the time
    frame'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account_count`—计算在指定时间框架内活跃的账户总数'
- en: The final result is calculated by an aggregation to count the number of accounts
    with events and divide that by the result of the `account_count` CTE to get the
    percentage.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果通过聚合计算具有事件的账户数量，然后除以`account_count` CTE的结果，以获得百分比。
- en: Listing 3.8 Measuring the percent of accounts with metrics (metric coverage)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 测量具有指标的账户百分比（指标覆盖率）
- en: '[PRE16]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① This CTE sets the start and end for the QA.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE设置QA的起始和结束。
- en: ② This CTE counts the number of accounts.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ② 此CTE计算账户数量。
- en: ③ Counts the number of accounts with subscriptions
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算具有订阅的账户数量
- en: ④ Selects all accounts that were active
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 选择所有活跃的账户
- en: ⑤ Counts the number of accounts that had values for the metric
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 计算具有指标值的账户数量
- en: ⑥ From the account _count CTE
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 来自账户计数CTE
- en: ⑦ Divides the count of the metric by the count of subscribers
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将指标的计数除以订阅者的计数
- en: ⑧ The standard aggregate function for the average
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 平均值的标准聚合函数
- en: ⑨ The standard aggregate function for the min
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 最小值的标准聚合函数
- en: ⑩ The standard aggregate function for the max
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 最大值的标准聚合函数
- en: ⑪ Cross-join that duplicates the account count on every row
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 交叉连接，每行重复账户计数
- en: ⑫ Limits to the time period specified by the date-range CTE
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 限制到由日期范围CTE指定的时间段
- en: ⑬ Sets a join on subscriptions
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 在订阅上设置连接
- en: Run listing 3.8 to confirm the result and check that all your metrics have calculated
    properly. If you are using the Python wrapper program, run it with the arguments
    `—chapter` `3` `—listing` `8`. The result is saved in a CSV file and should look
    similar to figure 3.14.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表3.8以确认结果并检查所有指标是否已正确计算。如果您正在使用Python包装程序，请使用参数`—chapter` `3` `—listing`
    `8`运行它。结果保存在CSV文件中，应类似于图3.14。
- en: 3.8 Event QA
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 事件QA
- en: In the last section, I showed you how to QA metrics and the percentage of accounts
    with a metric, but what about the events? If you check the events first, you have
    a better idea of what you are going to get with the metrics, and it might even
    change the way you decide to calculate the metrics. (I show some techniques to
    do this in the next section.) You’ve seen how to calculate a few metrics, but
    I am teaching this out of order from the way you would do it in practice.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我向您展示了如何查询指标以及具有指标的账户百分比，但事件呢？如果您首先检查事件，您将更好地了解指标将提供什么，甚至可能会改变您决定计算指标的方式。（我将在下一节中展示一些实现这一点的技术。）您已经看到了如何计算一些指标，但我正在以不同于实际操作的方式教授这些内容。
- en: TIP Spend some time checking the quality of your event data before you dive
    into calculating metrics. This book teaches the steps in a mixed-up order to show
    you the end result first. The correct order is (1) event QA (this section), (2)
    calculate metrics (sections 3.5 and 3.6), and (3) metric QA (section 3.7).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在深入计算指标之前，花些时间检查事件数据的质量。本书以混合的顺序教授步骤，以便首先展示最终结果。正确的顺序是（1）事件质量分析（本节），（2）计算指标（第3.5节和第3.6节），以及（3）指标质量分析（第3.7节）。
- en: 3.8.1 Checking how events change over time
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.1 检查事件随时间的变化情况
- en: 'Figure 3.15 demonstrates a simple time-series summary QA on an event: counting
    the total number of events per day over all accounts. You already saw that most
    real events follow weekly cycles (figure 3.5), and the simulation was designed
    to reproduce that kind of behavior. In a moment, I’ll show you the results from
    more case studies, but first let’s look at the code that produces such figures
    (listing 3.9).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15演示了对事件进行简单时间序列质量分析的示例：计算所有账户每天的总事件数。您已经看到，大多数真实事件遵循每周周期（图3.5），模拟也是为了重现这种行为。稍后我将向您展示更多案例研究的成果，但首先让我们看看生成此类图形的代码（列表3.9）。
- en: '![](../Images/3-15.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-15.png)'
- en: Figure 3.15 Result of counting like events per day (listing 3.9) on the simulated
    dataset
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15每日计数类似事件的结果（列表3.9）在模拟数据集上
- en: Listing 3.9 takes advantage of the techniques you saw in earlier sections. A
    CTE with a sequence of generated dates (described in section 3.4) is used in an
    outer join with event data to ensure that every date has a result from the QA
    query, even if there are no events.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9利用了您在前面章节中看到的技术。使用一个包含生成日期序列（在第3.4节中描述）的CTE与事件数据进行外连接，以确保每个日期都有质量查询的结果，即使没有事件也是如此。
- en: Listing 3.9 QA check of events per day
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9事件每日质量检查
- en: '[PRE17]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算日期。
- en: ② Casts event times to dates
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将事件时间转换为日期
- en: ③ Sums the number of events
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 求事件数的总和
- en: ④ If the events have numeric properties, sums the properties
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果事件具有数值属性，则对属性求和
- en: ⑤ A left join on the date series ensures a result for every date.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 对日期序列进行左连接以确保每个日期都有结果。
- en: ⑥ Selects the event that is being checked
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 选择正在检查的事件
- en: ⑦ Groups by calculation date
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 按计算日期分组
- en: 'Run listing 3.9 on the simulated dataset to confirm that it works with your
    data. Doing so makes a CSV file with one event count per row. The program prints
    a line saying what it has done:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟数据集上运行列表3.9以确认它是否与您的数据兼容。这样做将创建一个包含每行一个事件计数的CSV文件。程序会打印一行说明它所执行的操作：
- en: '[PRE18]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The script to make the plot (like figure 3.15) is shown in listing 3.10\. This
    listing uses a Pandas `DataFrame` to load the data and a standard `matplotlib.pyplot`
    plot. To make the dates on the x-axis readable, a filter is created using a lambda
    that selects dates ending in 01, which are the first of each month (2020-02-01,
    2020-03-01, etc.). That list of filtered dates is passed to the `matplotlib.pyplot`
    `xticks` function.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 制作图表的脚本（如图3.15所示）在列表3.10中展示。此列表使用Pandas `DataFrame`加载数据，并使用标准的`matplotlib.pyplot`进行绘图。为了使x轴上的日期可读，创建了一个使用lambda的过滤器，该过滤器选择以01结尾的日期，即每月的第一天（2020-02-01，2020-03-01等）。将过滤后的日期列表传递给`matplotlib.pyplot`的`xticks`函数。
- en: Listing 3.10 Plotting the number of events per day
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10绘制每日事件数
- en: '[PRE19]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① The path to the data saved by listing 3.9
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ① 列表3.9保存数据的路径
- en: ② Reads the data into a DataFrame
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将数据读入DataFrame
- en: ③ Plots the number of events vs. the date
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 绘制事件数与日期的关系图
- en: ④ Sets a y-axis limit based on the maximum
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 根据最大值设置y轴限制
- en: ⑤ Rotates the x-axis date labels
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 旋转x轴日期标签
- en: ⑥ Makes a list of first-of-month dates for x-axis labels
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 为x轴标签创建每月第一天的日期列表
- en: ⑦ Ensures that all axis labels are visible
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 确保所有轴标签都可见
- en: ⑧ Saves the result
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 保存结果
- en: 'If you are using the Python wrapper program, you can run listings 3.9 and 3.10
    together to create the data and the plot with one command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Python包装程序，你可以一起运行列表3.9和3.10来创建数据和图表，只需一条命令即可：
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The program prints the location of the figure it saved; it should be equivalent
    to figure 3.10\. If you want to run the QA on the other metrics, there are other
    prepared versions of the command configuration for you to use. First use this
    command to create the counts for all of the events:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会打印出它保存的图形位置；它应该等同于图3.10。如果你想对其他指标进行QA测试，还有其他准备好的命令配置供你使用。首先使用以下命令创建所有事件的计数：
- en: '[PRE21]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that this might take a little longer than the QA on the metrics because
    it has to aggregate events for every day. The following commands will make the
    plots for the other metrics:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这可能比指标的QA测试花费的时间要长一些，因为它需要每天汇总事件。以下命令将为其他指标创建图表：
- en: '[PRE22]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To illustrate how you can discover missing events, figure 3.16 shows a real
    case study (from Broadly) of the output from running the QA query in listing 3.9
    on the true customer-promoter events (when a customer writes a positive review)
    and also when one month of events was deliberately deleted (the same deletions
    used in figure 3.12). It is usually easy to notice such problems if you take the
    time to look, although it can be more of a challenge to recognize the problem
    if data is missing for a short amount of time.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何发现缺失的事件，图3.16展示了从列表3.9中运行QA查询的真实客户推广事件（当客户撰写正面评论时）的输出，以及故意删除了一个月的事件（与图3.12中使用的相同删除操作）。如果你花时间检查，通常很容易注意到这样的问题，尽管如果数据缺失时间较短，识别问题可能更具挑战性。
- en: '![](../Images/3-16.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-16.png)'
- en: Figure 3.16 Counting events per day for Broadly customer-promoter events
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 广泛客户推广事件每天事件计数
- en: To illustrate how you can discover outlier values in an event field, figure
    3.17 shows a second example (for Versature) of the output of running the QA query
    in listing 3.9 with data in its true state and also after extreme values were
    deliberately added. These are the same changes used to make the example in figure
    3.13\. A local-call event is logged in the database when a customer places a local
    call, and the database has a field that stores the duration of the call. Extreme
    values in an event field don’t affect the count of events but are usually obvious
    if you plot the sum of the event field (the total call duration) or some other
    aggregate function of the event field.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何在事件字段中发现异常值，图3.17展示了第二个示例（针对Versature），展示了在列表3.9中运行QA查询的输出，其中数据处于真实状态，以及故意添加极端值后的状态。这些是用于制作图3.13示例的相同更改。当客户拨打本地电话时，会在数据库中记录一个本地通话事件，数据库有一个存储通话持续时间的字段。事件字段中的极端值不会影响事件计数，但如果你在事件字段的和（总通话时长）或事件字段的某些其他聚合函数上绘制图表，通常很容易发现这些值。
- en: '![](../Images/3-17.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-17.png)'
- en: Figure 3.17 QA of events per day for Versature local calls
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 Versature本地通话每天事件QA结果
- en: 3.8.2 Checking events per account
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.2 检查每个账户的事件
- en: Another important check on events is to look at the overall number of events
    and how many there are per account. You should do this to assess the overall number
    and type of events. This is similar to checking the percent of accounts with metrics,
    as shown in the previous section.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对事件的重要检查之一是查看事件的总数以及每个账户的事件数量。你应该这样做来评估事件的总数和类型。这与检查具有指标的账户百分比类似，如前文所述。
- en: An example of the output of this check is shown in figure 3.18 for the social
    network simulation. The figure shows that the average account has around 75 like
    events per month but fewer than one unfriend event. This explains why there were
    fewer accounts with unfriend-per-month metrics (figure 3.13). Only around one-third
    of the accounts had a nonzero value for the metric, which is consistent with the
    events per account per month.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本检查的输出示例如图3.18所示，用于社交网络模拟。该图显示，平均账户每月有大约75个点赞事件，但少于一个取消好友事件。这解释了为什么有较少的账户具有每月取消好友指标（图3.13）。只有大约三分之一的账户的指标值不为零，这与每月每个账户的事件数一致。
- en: '![](../Images/3-18.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-18.png)'
- en: Figure 3.18 Result of counting events per account per month with listing 3.11
    for the simulated social network
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 使用列表3.11按月计数每个账户的事件结果
- en: 'Listing 3.11 contains the SQL to calculate the number of events per account
    and convert it into a count per month. The steps in the calculation are as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 包含计算每个账户的事件数并将其转换为每月计数的 SQL 代码。计算步骤如下：
- en: Pick a time window.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个时间窗口。
- en: Count the number of accounts that had active subscriptions in the time window.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在时间窗口内拥有活跃订阅的账户数量。
- en: Count the total number of events in the time window.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算时间窗口内的总事件数。
- en: 'Divide the total number of events twice:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将总事件数除以两次：
- en: Divide the total number of events by the number of accounts.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将总事件数除以账户数。
- en: Divide the total number of events by the number of months that were measured.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将总事件数除以测量的月份数。
- en: 'This procedure results in an average count of events per account per month.
    The start of the calculation is the same as that in listing 3.8, which calculated
    metrics per account. The only new trick here is in the final `SELECT` statement
    that makes the measurement: it also selects the number of months in the time frame
    and divides the result by that.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程导致每个账户每月的平均事件计数。计算的起点与列表 3.8 相同，该列表计算了每个账户的指标。这里唯一的技巧是在最终的 `SELECT` 语句中，它也选择了时间框架中的月份数，并将结果除以该数。
- en: Listing 3.11 Measuring the average number of events per account
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 测量每个账户的平均事件数
- en: '[PRE23]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① This CTE sets the start and end date for the QA.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此 CTE 设置 QA 的起始和结束日期。
- en: ② This CTE determines the number of accounts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ② 此 CTE 确定账户数量。
- en: ③ Counts the total number of events
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 计算总事件数
- en: ④ Number of accounts from the account_count CTE
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从 account_count CTE 中获取账户数量
- en: ⑤ Divides events by accounts to get events per account
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将事件数除以账户数以获取每个账户的事件数
- en: ⑥ Divides the number of days to get the count of four-week months
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将天数除以以获取四周月份的计数
- en: ⑦ Divides the events per account by the number of months
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将每个账户的事件数除以月份数
- en: ⑧ Cross join that duplicates the account count on every row
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 对每行重复账户数量的交叉连接
- en: ⑨ Limits the measurement to the chosen date range
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将测量限制在所选日期范围内
- en: ⑩ GROUP BY that includes all nonaggregated terms in the SELECT
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ GROUP BY 包括 SELECT 中所有非聚合项
- en: ⑪ Orders events so the most common appear at the top of the list
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 对事件进行排序，使最常见的出现在列表顶部
- en: This section is about QA, which means checking for problems; but in this case,
    considering the number of unfriend events from the example, it seems there is
    no problem. Maybe it’s just that people don’t unfriend their friends that much.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于 QA，即检查问题；但在这个例子中，考虑到未友好的事件数量，似乎没有问题。也许只是人们不太会频繁地取消好友关系。
- en: When you see a low number of events per account per month, you need to use your
    knowledge of the product to know whether it is a problem. There is no absolute
    standard across all products, because there are many products that should see
    near-constant user interaction, while there are others where you would expect
    interactions with the product only a few times a year. If you don’t have the expertise
    to judge whether the number of events per account is low or high, then you need
    to talk to other people in your organization and get them to help. That might
    not be advice that some data people want to hear, so let me repeat it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到每月每个账户的事件数量较少时，你需要运用你对产品的了解来判断是否是问题。在所有产品中并没有绝对的标准，因为有些产品应该看到几乎恒定的用户互动，而有些产品你可能会期望一年中只与产品互动几次。如果你没有足够的专业知识来判断每个账户的事件数量是低还是高，那么你需要与组织中的其他人交谈，并请他们帮忙。这可能是某些数据人员不想听到的建议，所以让我再重复一遍。
- en: TIP If your knowledge of the business is not good enough to judge whether the
    observed counts of events per month is reasonable, then you must get help from
    someone in your organization who does. Do this before you spend a lot of time
    calculating behavioral metrics and doing churn analysis.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你的业务知识不足以判断每月观察到的每个账户的事件数是否合理，那么你必须从组织中的某个人那里获得帮助。在你花费大量时间计算行为指标和进行流失分析之前，请这样做。
- en: A table like that in figure 3.18 is usually sufficient to communicate this information
    to the business. If there are a lot of events, you should sort them by frequency
    to show the most frequent events at the top, because those are the ones your audience
    is most likely to be familiar with. Even someone who is familiar with their product
    might not know about rare events. This is doubly true if the events do not have
    intuitive type names, which is often the case for software and internet services
    where the event can be a user hitting a particular URL.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18中的表格通常足以将此类信息传达给业务部门。如果有大量事件，你应该按频率排序，以便将最频繁的事件放在最上面，因为这些是观众最可能熟悉的事件。即使熟悉他们产品的某人可能也不知道这些罕见事件。如果事件没有直观的类型名称，这种情况在软件和互联网服务中很常见，事件可以是用户点击特定的URL。
- en: Run listing 3.11 to confirm the result on your own data. If you are using the
    Python wrapper program, do this by changing the argument to `—chapter` `3` `—listing`
    `11`. The result will look similar to figure 3.18 but not exactly the same, due
    to the randomness in the simulation.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表3.11以确认你自己的数据结果。如果你使用Python包装程序，可以通过将参数更改为`—chapter` `3` `—listing` `11`来完成此操作。结果将类似于图3.18，但并不完全相同，因为模拟中存在随机性。
- en: Automatic anomaly detection for QA
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: QA的自动异常检测
- en: It’s worth pointing out that there are methods to automatically detect data
    quality problems like those mentioned in this section. Automatic detection of
    data problems is a field known as anomaly detection. My approach of generating
    a bunch of plots and viewing them manually is pretty inefficient in comparison!
    But the truth is, I never bother with automatic anomaly detection for a typical
    churn analysis. For one thing, if there are dozens of events and metrics (fewer
    than 100), it doesn’t take long to look at all of them. I script the generation
    of a set of plots like the ones shown in this section, and then I flip through
    them quickly with an image viewer.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，有方法可以自动检测本节中提到的数据质量问题。自动检测数据问题是一个称为异常检测的领域。与手动生成大量图表并逐一查看相比，我的方法相当低效！但事实是，我从未为典型的流失分析烦恼过自动异常检测。一方面，如果有几十个事件和指标（少于100个），查看所有这些事件并不需要很长时间。我编写了生成一组如图3.18所示图表的脚本，然后使用图像查看器快速浏览它们。
- en: It’s easy to detect anomalies visually—arguably more effective than almost any
    algorithm. The other reason I recommend the manual approach is that it’s a good
    way to get to know your data. You might discover useful patterns or relationships
    that you would miss if you relied on an algorithm. That said, if you have more
    than around 100 events or metrics, you might need to use a fully automated approach,
    but automatic anomaly detection is beyond the scope of this book.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化检测异常很容易——可以说是比几乎所有算法都有效。我推荐手动方法的其他原因是，这是一种了解你数据的好方法。你可能会发现一些有用的模式或关系，如果你依赖算法，可能会错过这些。话虽如此，如果你有超过大约100个事件或指标，你可能需要使用完全自动化的方法，但自动异常检测超出了本书的范围。
- en: 3.9 Selecting the measurement period for behavioral measurements
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 选择行为测量的测量周期
- en: Let’s say you know this business, and you know that an event like unfriend is
    rare, so seeing a small number of events per account per month like the unfriend
    event in figure 3.18 is okay. Does that mean everything is okay with having only
    59% of accounts getting a value for the metric in any given month? (That result
    is in figure 3.14.) Not quite. There isn’t anything wrong with the data, but there
    is something that could be better about the measurement.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你了解这个业务，你知道像“取消好友”这样的事件是很少发生的，所以看到每个月每个账户只有少量事件（如图3.18中的取消好友事件）是可以接受的。这意味着只有59%的账户在任何给定月份获得该指标值就一切都好吗？（该结果如图3.14所示。）并不完全是这样。数据本身并没有问题，但测量方面可能还有改进的空间。
- en: 'Here’s the idea: if an event is rare, use a longer period in the metric definition.
    That way, you can catch more customers in the measurement and can compare more
    accounts on that behavior. Remember that the metric calculation in listing 3.2
    uses only a 28-day (four-week) period. As it stands, all accounts that had no
    events of a rare type in the last 28 days have 0 in the metric. On the other hand,
    if you measure the metric with a longer period, there might be some accounts that
    have the event only every couple of months, which were missed with the 28-day
    period but will be picked up with the longer period. At the same time, there might
    be some accounts that have the rare event every month, and they will have an even
    higher count of the metric if you use the longer period.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个想法：如果一个事件很少发生，在指标定义中使用更长的时间周期。这样，你可以在测量中捕捉到更多的客户，并且可以比较更多账户的行为。记住，列表3.2中的指标计算只使用了28天（四周）的时间周期。目前来看，所有在过去28天内没有发生罕见类型事件的账户在指标中显示为0。另一方面，如果你使用更长的时间周期来衡量指标，可能会有一些账户每隔几个月才发生一次事件，这些事件在28天周期中被遗漏，但会在更长的时间周期中被捕捉到。同时，可能会有一些账户每月发生罕见事件，如果你使用更长的时间周期，它们的指标计数将会更高。
- en: TAKEAWAY Use longer measurement periods when making metrics on rare events.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: TAKEAWAY 在制作罕见事件的指标时，使用更长的测量周期。
- en: 'What’s a good period to choose? Like many things in fighting churn with data,
    there is no strict rule; there are only guidelines. Choosing the measurement period
    is a trade-off between the responsiveness of the behavioral metric to changes
    in time and the sensitivity of the behavioral metric at picking up accounts with
    rare events. Responsiveness of the behavioral metric means the metric for an account
    changes rapidly if that account’s event level decreases or increases. For example,
    if you use a one-year (365-day) period for calculating a metric and update it
    every day, then each day, only 1/365 of the data going into the metric has changed.
    As a result, if someone has a high level of the event in the earlier part of the
    year but the level has fallen off to zero, it will take a long time before the
    person has a low value of the metric. To summarize:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 选择多长的周期合适？像在用数据对抗流失中做很多事情一样，没有严格的规定；只有一些指导原则。选择测量周期是在行为指标对时间变化的响应性和在捕捉罕见事件账户的敏感性之间进行权衡。行为指标的响应性意味着如果一个账户的事件水平下降或上升，该账户的指标会迅速变化。例如，如果你使用一年（365天）的时间周期来计算指标，并且每天更新它，那么每天只有1/365的数据进入指标发生变化。因此，如果有人在年初事件水平较高，但水平下降到零，那么这个人需要很长时间才能使指标的值变低。总结如下：
- en: Behavioral metrics with short time periods are more responsive to changes in
    behavior but less sensitive at picking up accounts with low event levels.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短时间周期的行为指标对行为变化的响应较快，但在捕捉事件水平较低的用户账户方面较不敏感。
- en: Behavioral metrics with long time periods are less responsive to changes in
    behavior but more sensitive at picking up accounts with low event levels.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间周期的行为指标对行为变化的响应较慢，但在捕捉事件水平较低的用户账户方面更为敏感。
- en: 'Which should you choose? Based on the frequency of events, I use a rule of
    thumb for the minimum time period you should observe events to make a behavioral
    metric: pick the period to be at least twice the time it takes for an average
    account to have one event. But due to the weekly behavioral cycle that I mentioned
    in section 3.4, the period should never be less than a week, no matter how frequent
    the events. And (usually) you should never take a behavioral measurement longer
    than a year (more about this in the moment). For example, if there is one event
    per account per month, use at least two months for measurement. If there are two
    events per account per month, it’s okay to go down to one month. By following
    this guideline, it’s likely that most accounts have at least one event in the
    time period.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 应该选择哪个周期？根据事件发生的频率，我使用一个经验法则来确定你应该观察事件的最小时间周期以制作行为指标：选择的时间周期至少是平均账户发生一次事件所需时间的两倍。但由于我在3.4节中提到的每周行为周期，周期不应少于一周，无论事件发生的频率如何。而且（通常）你不应该进行超过一年的行为测量（更多关于这一点将在后面讨论）。例如，如果每个账户每月发生一次事件，至少使用两个月进行测量。如果每个账户每月发生两次事件，使用一个月也是可以的。遵循这一指南，大多数账户在时间周期内至少发生一次事件的可能性很大。
- en: TIP The minimum time period for a metric should be at least twice the time it
    takes an average account to have one event.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 指标的最小时间周期应至少是平均账户发生一次事件所需时间的两倍。
- en: The minimum observation periods recommended by the rule of thumb are summarized
    in table 3.5.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 规则经验法推荐的最低观察期总结在表3.5中。
- en: Table 3.5 Minimum behavioral measurement period (rules of thumb)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5 最小行为测量周期（规则经验法）
- en: '| Events per account per month | Number of months: one event | Minimum measurement
    period |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 每月每账户的事件数 | 月份：一个事件 | 最低测量周期 |'
- en: '| >8 | < 0.1 | 1 week |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| >8 | < 0.1 | 1 week |'
- en: '| 8 | 0.125 | 1 week |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0.125 | 1 week |'
- en: '| 4 | 0.25 | 2 weeks |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.25 | 2 weeks |'
- en: '| 2 | 0.5 | 1 month |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.5 | 1 month |'
- en: '| 1 | 1 | 2 months |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 2 months |'
- en: '| 0.5 | 2 | 4 months |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 | 2 | 4 months |'
- en: '| 0.333 | 3 | 6 months |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 0.333 | 3 | 6 months |'
- en: '| 0.25 | 4 | 8 months |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 0.25 | 4 | 8 months |'
- en: '| 0.1666 | 6 | 12 months |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 0.1666 | 6 | 12 months |'
- en: '| < 0.1666 | > 6 | 12 months |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| < 0.1666 | > 6 | 12 months |'
- en: The behavioral measurement rules of thumb in table 3.5 set a minimum, and in
    general, you shouldn’t measure behavior with longer than a one-year period. But
    what is a good trade-off between responsiveness and sensitivity within that range?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5中的行为测量规则经验法设定了一个最低标准，通常情况下，你不应该用超过一年的周期来测量行为。但在那个范围内，响应性和敏感性之间的良好权衡是什么？
- en: For subscriptions with a fixed term like a month or a year, behavioral measurements
    should be similar in time scale to the term of the subscription. If you sell one-year
    subscriptions, you should probably use a one-year time period for behavioral measurements;
    and if you sell a one-month subscription, you should use a one-month time period
    for behavioral measurements. The reason for this is to make your behavioral measurements
    reflect the experience that the customer received from the service over the term
    of the subscription. That said, the experience of the service may be most important
    near the end of the term, because that will be more immediate in the customer’s
    mind when it is time for renewal. If you want to use something like three to six
    months to measure behavior on a one-year subscription, that makes sense, but don’t
    use a one-month metric for one-year subscriptions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像一个月或一年这样的固定期限订阅，行为测量应该在时间尺度上与订阅期限相似。如果你销售一年期的订阅，你可能应该使用一年的时间周期进行行为测量；如果你销售一个月的订阅，你应该使用一个月的时间周期进行行为测量。这样做的原因是为了让你的行为测量反映客户在订阅期限内从服务中获得的经验。话虽如此，服务体验可能在期限结束时最为重要，因为那时它将在客户心中更加直接，当是时候续订时。如果你想用三到六个月的时间来测量一年期订阅的行为，这是有道理的，但不要为一年期订阅使用一个月的指标。
- en: What if the product has no fixed-term subscriptions? Then you should aim to
    make your behavioral measurements using a period that is around one-quarter to
    one-half of the typical time a subscriber remains active. If customers typically
    stick around for six months, use a one- or two-month behavioral measurement. If
    a customer usually stays only one month, then make behavioral measurements over
    just a week or two, subject to the minimum shown in table 3.5\. The rationale
    here is that you should make measurements on a short enough time scale that you
    have completed the measurement period before the average customer might consider
    churning.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果产品没有固定期限的订阅呢？那么你应该旨在使用大约是典型订阅者活跃时间四分之一到一半的周期来进行行为测量。如果客户通常会在六个月内保持活跃，使用一或两个月的周期进行行为测量。如果客户通常只停留一个月，那么只需在一周或两周内进行行为测量，但必须遵守表3.5中显示的最低标准。这里的理由是，你应该在足够短的时间尺度上进行测量，以确保在平均客户可能考虑流失之前完成测量周期。
- en: 'You should scale the measurement period based on the frequency of the event.
    That’s good advice, but it has one problem: if you choose different measurement
    periods for different events, it’s going to be confusing. This is especially true
    if you have a lot of events. Do you have to set your observation period to be
    suitable for the rarest event you are interested in? A problem with this approach
    is that if you use a lengthy period to measure behavior, it takes a long time
    before you have a valid measurement for a new account. In chapter 7, I show that
    you can have the best of both worlds: measure some behaviors over long time periods
    and others over shorter periods and still present them in an interpretable way
    as averages.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该根据事件发生的频率来调整测量周期。这是很好的建议，但它有一个问题：如果你为不同的事件选择不同的测量周期，那将会很令人困惑。这尤其在你有很多事件时更为明显。你是否必须将观察周期设置得适合你感兴趣的罕见事件？这种方法的缺点是，如果你使用一个漫长的周期来测量行为，那么在为新账户获得有效测量之前需要很长时间。在第7章中，我将展示你可以拥有两全其美的方法：在长时间内测量一些行为，在较短时间内测量其他行为，并且仍然以平均数的方式呈现它们，以便于解释。
- en: 3.10 Measuring account tenure
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 测量账户期限
- en: So far, we have considered behavioral measurements based only on events. But
    there are important measurements of customers that are based not on events but
    instead on subscriptions. The length of time an account has been a customer or
    active user is one such measurement. I refer to the length of time an account
    has been a customer as the account tenure rather than something along the lines
    of account age because age can be confused with the actual age of a person (or
    company).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了基于事件的行性行为测量。但是，还有一些重要的客户测量是基于订阅而非事件。账户成为客户或活跃用户的时间长度就是这样的一个测量。我把账户成为客户的时间长度称为账户期限，而不是像账户年龄这样的东西，因为年龄可能会与人的实际年龄（或公司的年龄）混淆。
- en: 'Account tenure is important in analyzing churn because it can relate to churn
    in significant ways: there can be particular points in the customer life cycle
    when churn is most (or least) likely, or churn can generally decrease (or increase)
    with longer account tenure. I show you how to do those analyses in chapter 5;
    for now, you will learn how to calculate account tenure.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 账户期限在分析流失率时很重要，因为它可以以显著的方式与流失率相关：在客户生命周期中可能存在某些点，流失最（或最不）可能发生，或者流失率可能会随着账户期限的延长而普遍降低（或增加）。在第5章中，我将向你展示如何进行这些分析；现在，你将学习如何计算账户期限。
- en: 3.10.1 Account tenure definition
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.1 账户期限定义
- en: Account tenure would be easy to calculate if every account had only one subscription
    (or period of activity, if there are no formal subscriptions). This is the duration
    of time from the start of the subscription to the time the tenure measurement
    is made. But tenure calculations are more complicated in the multisubscription
    context (or in “messy” subscriptions). You don’t just want the time since the
    current subscription started, because the customer might have had earlier subscriptions
    in an uninterrupted sequence. In that case, it makes sense to consider them all
    as one big subscription for the tenure measurement. If the account was active
    in the distant past and then churned, that would not count as an “old” customer
    because they have not been active the whole time. If an old customer signs up
    anew after an extended absence, they are more like a new customer, so tenure should
    measure only the current subscription. Figure 3.19 shows an account tenure definition
    for a hypothetical case of multiple subscriptions.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个账户只有一个订阅（或如果没有正式的订阅，则为活动周期），那么计算账户期限将很容易。这是从订阅开始到期限测量时的时间长度。但在多订阅的背景下（或“混乱”的订阅中），期限计算会更复杂。你不仅想要从当前订阅开始的时间，因为客户可能有一个不间断的早期订阅序列。在这种情况下，将它们都视为一个大的订阅期限测量是有意义的。如果账户在遥远的过去活跃过，然后流失，那么这不会算作“老”客户，因为他们并没有一直活跃。如果一个老客户在长期缺席后重新注册，他们更像是一个新客户，因此期限应该只测量当前订阅。图3.19展示了多订阅假设情况下的账户期限定义。
- en: '![](../Images/3-19.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-19.png)'
- en: Figure 3.19 Account tenure with multiple subscriptions
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 多订阅账户的账户期限
- en: At the same time, it is often a good idea to allow small gaps between subscriptions
    and still consider it a continuous subscription for the tenure measurement. For
    example, suppose an account fails to renew because the credit card on file was
    out-of-date; the account subsequently updates the card and signs up again a few
    days later. A few days or a one-week gap in the subscription probably should not
    alter the tenure measurement because they are not really a newly signed-up customer.
    On the other hand, if there is a multimonth gap (or longer) in the subscription,
    it is fairer to consider the new subscription as being a fresh start for the customer
    and for the tenure calculation.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，通常允许订阅之间存在小的间隔，同时仍然将其视为连续订阅以进行任职测量是个好主意。例如，假设一个账户未能续订是因为文件中的信用卡已过期；账户随后更新了卡片并在几天后再次注册。订阅中的几天或一周的间隔可能不应该改变任职测量，因为它们并不是真正的新注册客户。另一方面，如果订阅中存在数月（或更长时间）的间隔，那么将新的订阅视为客户和任职计算的全新开始是公平的。
- en: The exact amount of gap required to consider an account new for tenure calculation
    depends on the business. For monthly subscriptions, a gap of up to a month is
    usually acceptable. For annual subscriptions, gaps of a month or two or even up
    to four can be considered short enough lapses in the subscription to still be
    ignored for tenure calculation purposes.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到为任职计算而将账户视为新账户所需的确切间隔量取决于业务。对于月度订阅，通常可以接受一个月的间隔。对于年度订阅，一个月或两个月的间隔，甚至多达四个月的间隔可以被认为是订阅中断的足够短的时间，仍然可以忽略不计，用于任职计算。
- en: DEFINITION Account tenure —The length of time a customer uses a product on their
    current, uninterrupted sequence of subscriptions or their current uninterrupted
    period of activity, possibly including a relatively short time gap between subscriptions
    or activity.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 账户任职——客户在其当前不间断的订阅序列或当前不间断的活动期间使用产品的时长，可能包括订阅或活动之间的相对较短的时间间隔。'
- en: Figure 3.19 shows that at some observation time, the account is in the middle
    of its fourth subscription. There is no gap between subscription 3 and subscription
    4, a small (allowable) gap between subscription 2 and subscription 3, and a large
    gap between subscription 1 and subscription 2\. The tenure is the time from the
    start of subscription 2 up to the time when the observation is made.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19显示，在某个观察时间点，账户正处于其第四个订阅的中间。订阅3和订阅4之间没有间隔，订阅2和订阅3之间有一个小的（允许的）间隔，而订阅1和订阅2之间有一个大的间隔。任职时间是从订阅2开始到观察时的时间。
- en: More details of a tenure calculation based on the illustration in figure 3.19
    are shown in figure 3.20\. The tenure starts at 0 on the start of the first subscription
    and increases by one each day until the first subscription ends in churn. After
    churn, the tenure is not defined at all; it is not even zero. Tenure is defined
    and begins accumulating again only when a new subscription starts. The calculation
    on any given date counts the number of days since the relevant subscription start
    date. As with most metric calculations, this calculation would be tedious or impossible
    to perform by hand for every account. But, again, SQL provides a way to perform
    the calculation for arbitrarily complex subscription scenarios.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图3.19中说明的任职计算的更多细节显示在图3.20中。任职从第一个订阅的开始为0，每天增加1，直到第一个订阅因流失而结束。在流失之后，任职不再定义；甚至不是零。只有当新的订阅开始时，任职才被定义并重新开始积累。任何给定日期的计算会计算自相关订阅开始日期以来的天数。与大多数指标计算一样，对于每个账户，这种计算可能很繁琐或无法手动完成。但是，SQL再次提供了一个执行任意复杂订阅场景计算的方法。
- en: '![](../Images/3-20.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-20.png)'
- en: Figure 3.20 Example of an account tenure calculation
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20展示了基于图3.19中说明的账户任职计算示例
- en: 3.10.2 Recursive table expressions for account tenure
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.2 账户任职的递归表表达式
- en: 'Calculating account tenure in the multisubscription case requires an advanced
    feature of SQL known as recursive common table expressions (recursive CTEs). As
    the name implies, recursive CTEs allow `SELECT` statements to run recursively
    when building a result set. Recursive CTEs are similar to standard CTEs but differ
    in that they have two parts:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在多订阅情况下计算账户任职需要SQL的一个高级功能，称为递归公用表表达式（recursive CTEs）。正如其名称所暗示的，递归CTEs允许在构建结果集时递归地运行`SELECT`语句。递归CTEs与标准CTEs类似，但不同之处在于它们有两个部分：
- en: A main or “anchor” `SELECT` statement that defines the columns of the CTE and
    fills the table with an initial result set.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主或“锚点”`SELECT` 语句，定义 CTE 的列并使用初始结果集填充表。
- en: A recursive `SELECT` statement that adds more rows to the CTE by running repeatedly
    until no more rows are produced. The recursive `SELECT` statement can reference
    both the current result set in the CTE and other tables that are available in
    the schema.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个递归的 `SELECT` 语句，通过重复执行直到不再产生更多行，向 CTE 中添加更多行。递归的 `SELECT` 语句可以引用 CTE 中的当前结果集以及架构中可用的其他表。
- en: 'That might sound abstract, but the problem of calculating account tenure from
    multiple subscriptions will make a recursive SQL calculation concrete. Here is
    the recursive strategy for finding the earliest start date of any subscription
    that is in an uninterrupted sequence with the current subscription, up to an allowed
    gap of one month:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很抽象，但计算来自多个订阅的账户服务期的难题将使递归 SQL 计算变得具体。以下是找到任何与当前订阅具有不间断序列且允许一个月间隔的最早订阅起始日期的递归策略：
- en: Create the CTE by selecting the currently active subscription with the minimum
    start date (if there are multiple currently active subscriptions) for every account.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为每个账户选择具有最小起始日期（如果有多个当前活跃订阅）的当前活跃订阅来创建 CTE。
- en: Select any other subscriptions for the same account with earlier start dates
    and end dates that are up to one month before the current earliest start date
    for the same account.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择具有较早起始日期和结束日期的其他相同账户订阅，这些日期在相同账户当前最早起始日期之前最多一个月。
- en: 'If step 2 is repeated until there are no earlier subscription start dates,
    then the subscription with the earliest start date in the CTE is the one you are
    looking for: the earliest start date of any subscription that forms an uninterrupted
    sequence of subscriptions with the current subscription. Finding the earliest
    subscription start date fits easily into the framework of recursive CTEs.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果步骤 2 重复进行，直到没有更早的订阅起始日期，那么 CTE 中最早起始日期的订阅就是你要找的：与当前订阅形成不间断订阅序列的任何订阅的最早起始日期。找到最早的订阅起始日期很容易适应递归
    CTE 的框架。
- en: 'Figure 3.21 shows an example of how the recursive approach operates on the
    hypothetical multisubscription scenario in figures 3.19 and 3.20\. The following
    are the steps for finding the earliest start date through recursion:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 展示了递归方法在图 3.19 和 3.20 中的假设多订阅场景中的操作示例。以下是通过递归找到最早起始日期的步骤：
- en: On initialization, the start date of subscription 5 (1-Sep) is entered into
    the CTE table for this account, which is current because it starts before the
    current date and has an end date after the current date.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化时，订阅 5 的起始日期（1-Sep）被输入到该账户的 CTE 表中，这是当前的，因为它在当前日期之前开始，并且结束日期在当前日期之后。
- en: On the first iteration of the recursive step, the start date (1-Aug) of subscription
    4 is entered into the CTE because its end date is after the start date of subscription
    5, but the start date is earlier.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在递归步骤的第一迭代中，订阅 4 的起始日期（1-Aug）被输入到 CTE 中，因为其结束日期在订阅 5 的起始日期之后，但起始日期更早。
- en: On the second iteration of the recursive step, the start date of subscription
    3 (1-Jul) is entered into the CTE because its end date is after the start date
    of subscription 4, but the start date is earlier.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在递归步骤的第二迭代中，订阅 3 的起始日期（1-Jul）被输入到 CTE 中，因为其结束日期在订阅 4 的起始日期之后，但起始日期更早。
- en: On the third iteration of the recursive step, the start date of subscription
    2 (15-Apr) is entered into the CTE because the gap is small and the end date of
    subscription 2 is still close enough to the start date of subscription 3.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在递归步骤的第三次迭代中，订阅 2 的起始日期（15-Apr）被输入到 CTE 中，因为间隔很小，并且订阅 2 的结束日期仍然足够接近订阅 3 的起始日期。
- en: On the fourth iteration of the recursive step, no more rows are entered into
    the table for this account because the end date of subscription 1 is too far from
    the start of subscription 2\. The recursive `SELECT` statement can make additional
    results for other accounts, but this account is finished.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在递归步骤的第四次迭代中，由于订阅 1 的结束日期与订阅 2 的起始日期相距太远，因此不再向该账户的表中输入更多行。递归 `SELECT` 语句可以为其他账户生成额外的结果，但此账户已完成。
- en: After the recursion completes, the minimum start date in the CTE for the hypothetical
    account is the start date of subscription 2.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归完成后，假设账户的 CTE 中的最小起始日期是订阅 2 的起始日期。
- en: The time from that earliest date to the present is the account tenure. This
    process of identifying current subscriptions and working backward to the corresponding
    earliest start date with a recursive SQL program allows the account tenure calculation
    to be performed efficiently for any number of accounts and subscriptions.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个最早日期到现在的这段时间是账户任期。这个过程通过递归SQL程序识别当前订阅并回溯到相应的最早开始日期，允许对任何数量的账户和订阅进行高效的账户任期计算。
- en: '![](../Images/3-21.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-21.png)'
- en: Figure 3.21 Account tenure recursion calculation example
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 账户任期递归计算示例
- en: 3.10.3 Account tenure SQL program
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.3 账户任期SQL程序
- en: Listing 3.12 shows the SQL that performs the account tenure measurements. Now
    that you know the computation strategy, I will explain a few more details about
    the recursive CTE with reference to the listing. First a note about recursive
    CTEs in general.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12显示了执行账户任期度量的SQL。现在您已经了解了计算策略，我将根据列表解释一些关于递归CTE的更多细节。首先，关于递归CTE的一般说明。
- en: NOTE The `RECURSIVE` keyword appears after the `WITH` keyword for all CTEs even
    though the first CTE might not be the recursive one.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于所有CTE，`RECURSIVE`关键字都出现在`WITH`关键字之后，即使第一个CTE可能不是递归的。
- en: 'Turning to the details of listing 3.12:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是列表3.12的细节：
- en: The first CTE, `date_range`, sets the date of the tenure calculation.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个CTE，`date_range`，设置了任期计算的日期。
- en: The second CTE, `earlier_starts`, is the recursive one. I chose the name `earlier_starts`
    for it because it recursively finds earlier start dates for subscriptions on the
    same account.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个CTE，`earlier_starts`，是递归的。我选择这个名字是因为它递归地找到同一账户的订阅的较早开始日期。
- en: The first half of `earlier_starts` selects the minimum start date of any currently
    active subscription from the subscription table. To select active subscriptions,
    the query uses the usual check that a subscription is active if it starts before
    the calculation date and ends on some future date (or has no defined end).
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`earlier_starts`的前半部分从订阅表中选择了任何当前活跃订阅的最小开始日期。为了选择活跃订阅，查询使用了通常的检查，即如果订阅在计算日期之前开始并在某个未来的日期结束（或者没有定义的结束日期），则该订阅是活跃的。'
- en: After the first part of `earlier_starts` are some important SQL keywords.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`earlier_starts`的第一部分之后是一些重要的SQL关键字。
- en: NOTE Between the two parts of the recursive CTE is the `UNION` keyword. It specifies
    that the results from the recursive query are merged without duplicates with the
    results already in the CTE. The alternative, which is not used, is `UNION` `ALL`,
    which preserves duplicates.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：在递归CTE的两个部分之间是`UNION`关键字。它指定递归查询的结果与CTE中已有的结果合并，不重复。未使用的替代方案是`UNION ALL`，它保留重复项。
- en: The second, recursive part of `earlier_starts` finds subscriptions starting
    earlier that also meet the end-date condition. To do so, it uses an inner join
    between the subscription table and the current CTE result set. The recursive part
    of the CTE joins on account IDs because the search for earlier start dates is
    performed separately for each account.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个，`earlier_starts`的递归部分，寻找那些开始日期更早且也满足结束日期条件的订阅。为了做到这一点，它使用订阅表和当前CTE结果集之间的内部连接。CTE的递归部分通过账户ID进行连接，因为对较早开始日期的搜索是针对每个账户分别进行的。
- en: The final query after all the CTEs is an aggregation over the result in the
    recursive CTE, selecting the earliest start date as well as calculating the days
    since the earliest start in the current CTE.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有CTE之后的最终查询是对递归CTE中的结果进行聚合，选择最早开始日期以及在当前CTE中计算自最早开始以来的天数。
- en: Listing 3.12 Measuring account tenure with a recursive CTE
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 使用递归CTE测量账户任期
- en: '[PRE24]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① The RECURSIVE keyword goes at the beginning.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ① RECURSIVE关键字位于开头。
- en: ② This CTE sets the date for which to calculate.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ② 此CTE设置了要计算的日期。
- en: ③ Initializes with start_dates of current subscriptions
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用当前订阅的开始日期初始化
- en: ④ Adds results to the CTE without duplication
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将结果添加到CTE中，不重复
- en: ⑤ Inserts new account IDs and start dates
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 插入新的账户ID和开始日期
- en: ⑥ The new records must be for the same account.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 新记录必须是同一账户的。
- en: ⑦ Subscriptions that start before the one that was already entered
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 开始日期早于已输入的订阅的订阅
- en: ⑧ New records must have an end date that is within a short gap.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 新记录必须有一个在短暂间隔内的结束日期。
- en: ⑨ For each account, selects the earliest start date
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 对于每个账户，选择最早开始日期
- en: ⑩ The time from the earliest start to the calculation date
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 从最早开始日期到计算日期的时间
- en: ⑪ Cross join that duplicates the calc_date on every row
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 交叉连接在每一行上重复calc_date
- en: ⑫ GROUP BY of all the nonaggregate terms in the SELECT
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ `SELECT` 中所有非聚合项的 `GROUP BY`
- en: Figure 3.22 shows an example of the result of running listing 3.12\. The output
    shows `SELECT`s from different ranges of accounts and their tenure. The calculation
    is made for May 6, 2020, and at that point, the oldest subscribers go back to
    January 2020 and have tenure of around 100 days. For more recent dates, there
    are new accounts that have tenures of just a few days.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 展示了运行列表 3.12 的结果示例。输出显示了来自不同账户范围及其任期的 `SELECT`s。计算是在 2020 年 5 月 6 日进行的，当时最老的订阅者可以追溯到
    2020 年 1 月，任期约为 100 天。对于更近的日期，有新账户，其任期仅为几天。
- en: '![](../Images/3-22.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-22.png)'
- en: Figure 3.22 Result of running the account tenure calculation
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 运行账户任期计算的结果
- en: Run listing 3.12 and see that you get a similar result on your own data. If
    you are using the simulated data and the Python wrapper program, then you need
    to update the parameter to listing 3.12\. The result will look similar to figure
    3.22.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 3.12 并查看你自己的数据是否得到类似的结果。如果你使用的是模拟数据和 Python 包装程序，那么你需要更新列表 3.12 的参数。结果将类似于图
    3.22。
- en: 'Listing 3.12 and figure 3.22 show the earliest start date to illustrate the
    tenure calculation. In fact, the goal is to run the calculation like a metric
    and insert it into the metric table so that the tenure calculations for a range
    of dates are available for use in further metric calculations and analysis (discussed
    in later chapters). To insert the account tenure calculation into the metric schema,
    a few changes are needed to make listing 3.12 more like the other metric calculations:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 和图 3.22 展示了最早开始日期以说明任期计算。实际上，目标是像度量一样运行计算并将其插入到度量表中，以便在后续的度量计算和分析（将在后面的章节中讨论）中使用一系列日期的任期计算。要将账户任期计算插入到度量模式中，需要对列表
    3.12 进行一些修改，使其更像其他度量计算：
- en: Make the calculation for a sequence of dates instead of just one calculation
    date by using a sequence of dates in the `calc_date` CTE.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在 `calc_date` CTE 中使用一系列日期，而不是仅使用一个计算日期，来对一系列日期进行计算。
- en: The calculation date must go in the recursive CTE `SELECT` statements and joins.
    Otherwise, the recursive CTE is unchanged.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算日期必须放在递归 CTE `SELECT` 语句和连接中。否则，递归 CTE 保持不变。
- en: Do not select the earliest start in the final `SELECT`; rather, select the calculation
    date. This is the measurement observation timestamp for insertion into the metric
    table.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最终的 `SELECT` 中不要选择最早开始日期；相反，选择计算日期。这是插入度量表中的测量观察时间戳。
- en: If your data warehouse supports `INSERT` `SELECT`s, the appropriate `INSERT`
    statements are also needed (see listing 3.3).
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据仓库支持 `INSERT` `SELECT`s，则需要相应的 `INSERT` 语句（参见列表 3.3）。
- en: A SQL program that has these modifications and that calculates the metric and
    inserts it into the database is shown in listing 3.13\. Run listing 3.13 to insert
    the metric (we analyze it with the others in later chapters). If you are using
    the wrapper program to run the listings, the command is
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经过这些修改的 SQL 程序，它计算度量并将其插入到数据库中，如列表 3.13 所示。运行列表 3.13 以插入度量（我们将在后面的章节中与其他度量一起分析它）。如果你使用的是包装程序来运行列表，则命令是
- en: '[PRE25]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This inserts the account tenure measurement into your local database; you’ll
    have to use a SQL query (or the metric QA query in listing 3.6) to check the result.
    Note that as with listing 3.3, you can run this listing only once, unless you
    change the configuration or clean the results from the database. Finally, insert
    the name for the new metric (`account_tenure`) in the metric name table. To do
    that, you need to reuse listing 3.4\. To make this easier to do, the code that
    runs the listings has another version of the listing 3.4 parameters that are already
    set up for you: rerun listing 3.4, but add the parameter `—version` `11` to the
    executable command:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这将账户任期测量值插入到你的本地数据库中；你需要使用 SQL 查询（或列表 3.6 中的度量 QA 查询）来检查结果。注意，与列表 3.3 一样，除非你更改配置或从数据库中清理结果，否则只能运行此列表一次。最后，将新度量（`account_tenure`）的名称插入到度量名称表中。为此，你需要重用列表
    3.4。为了使这更容易完成，运行列表的代码有另一个版本的列表 3.4 参数，这些参数已经为你设置好了：重新运行列表 3.4，但将参数 `—version`
    `11` 添加到可执行命令中：
- en: '[PRE26]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing 3.13 `INSERT` `SELECT` SQL to calculate and save account tenure as a
    metric
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 用于计算并保存账户任期作为度量的 `INSERT` `SELECT` SQL
- en: '[PRE27]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① The RECURSIVE keyword goes at the beginning.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ① `RECURSIVE` 关键字位于开头。
- en: ② This CTE contains the dates for the calculation.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ② 此 CTE 包含计算所需的日期。
- en: ③ This CTE is mostly the same as in listing 3.12.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 此 CTE 与列表 3.12 中的基本相同。
- en: ④ Starts an entry in the recursive CTE for every date
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为每个日期在递归CTE中开始一个条目
- en: ⑤ Applies the subscription activity condition separately per date
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 分别按日期应用订阅活动条件
- en: ⑥ Metric dates have to be included in the recursive SELECT.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 指标日期必须包含在递归SELECT中。
- en: ⑦ The INSERT statement is mostly the same as for earlier metrics.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ INSERT语句与之前指标的语句大致相同。
- en: ⑧ Enters the account tenure metric as the metric ID 8
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将账户使用期限指标作为指标ID 8输入
- en: ⑨ The value of the tenure is calculated separately for each metric date.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用期限的值是针对每个指标日期单独计算的。
- en: Calculating account tenure for nonsubscription products and services
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 计算非订阅产品和服务的账户使用期限
- en: If you are working on a product without subscriptions (ad-supported, retail,
    nonprofit, and others), it is still important to analyze and understand how account
    tenure relates to churn. The only difference is that, rather than working from
    subscriptions to measure tenure, you work from events to determine how long someone
    has been with the product. If you are thinking that something like the tenure
    calculation described here should work for events, you are correct; the program
    is shown in the next chapter (section 4.3). The account tenure algorithm described
    here is an important part of creating churn analysis datasets for nonsubscription
    products.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个没有订阅功能的产品（如广告支持、零售、非营利性等），仍然重要的是要分析和理解账户使用期限与流失率之间的关系。唯一的区别是，你并不是从订阅来衡量使用期限，而是从事件来决定某人使用产品的时长。如果你认为这里描述的使用期限计算方法也适用于事件，你是正确的；程序将在下一章（4.3节）中展示。这里描述的账户使用期限算法是非订阅产品创建流失分析数据集的重要组成部分。
- en: 'If your product doesn’t have subscriptions, this would be a good time to skip
    ahead to chapter 4 and learn more, because the next section is on metrics that
    are specific to subscription products. But start at the beginning in chapter 4:
    the techniques in section 4.3 build on sections 4.1 and 4.2.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的产品没有订阅功能，这是一个跳到第4章并了解更多信息的好时机，因为下一节是关于特定于订阅产品的指标。但请从第4章的开始部分开始：4.3节中的技术建立在4.1节和4.2节的基础上。
- en: 3.11 Measuring MRR and other subscription metrics
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.11 测量MRR和其他订阅指标
- en: Other important measurements of customers are made from their subscriptions,
    like account tenure, but depend on the details of the subscriptions, not only
    on the subscription start and end dates. Like the account tenure measurement,
    these measurements are conceptually straightforward and don’t require much calculation
    if every customer has one (and only one) subscription. However, as usual, things
    become complicated when customers can have more than one subscription over time
    or more than one subscription at the same time. I will demonstrate general techniques
    that work with any kind of “messy” subscription data you might encounter, and
    you can choose to simplify the approach if the condition of your data warrants.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要的客户测量指标来自他们的订阅，如账户使用期限，但这些指标依赖于订阅的细节，而不仅仅是订阅的开始和结束日期。像账户使用期限测量一样，这些测量在概念上简单直接，如果每个客户只有一个（且仅有一个）订阅，就不需要太多计算。然而，正如通常情况一样，当客户在一段时间内或同一时间拥有多个订阅时，事情会变得复杂。我将展示适用于任何类型“混乱”订阅数据的一般技术，如果你认为你的数据条件允许，你可以选择简化这种方法。
- en: 3.11.1 Calculating MRR as a metric
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11.1 将MRR作为指标计算
- en: When customers pay for subscriptions, the total monthly recurring revenue (MRR)
    is an important measurement. You might not think of MRR as a measurement but see
    it instead as a simple fact. Figure 3.23 illustrates that whenever there is a
    possibility of multiple subscriptions with potentially different prices, MRR is
    something you need to measure at different points in time, just like a regular
    behavioral measurement.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户为订阅付费时，总月度经常性收入（MRR）是一个重要的测量指标。你可能不会将MRR视为一个测量指标，而是将其视为一个简单的事实。图3.23说明了，每当存在多个可能具有不同价格的订阅的可能性时，MRR是你需要在不同的时间点测量的，就像常规的行为测量一样。
- en: Because you have no guarantee of what subscription(s) an account has at any
    given time, the MRR at every point you are interested in must be computed separately.
    And because the cost of multiple subscriptions adds up, the calculation sums the
    total MRR for all subscriptions active on any given date. The example in figure
    3.23 illustrates how changes in MRR can occur when an old subscription ends or
    a new subscription begins.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您无法保证账户在任何给定时间拥有哪些订阅，因此您必须单独计算您感兴趣的每个点的MRR。并且因为多个订阅的成本会累加，所以计算会汇总任何给定日期上所有活跃订阅的总MRR。图3.23中的示例说明了当旧订阅结束或新订阅开始时，MRR如何发生变化。
- en: '![](../Images/3-23.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-23.png)'
- en: Figure 3.23 Monthly recurring revenue (MRR) metric calculation
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 每月经常性收入（MRR）指标计算
- en: 'The figure illustrates how the MRR changes over time:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 该图说明了MRR随时间的变化：
- en: The customer starts with the base plan (MRR = 19).
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户从基础计划开始（MRR = 19）。
- en: The customer temporarily churns (MRR = 0).
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户暂时流失（MRR = 0）。
- en: The customer signs up again with the base plan (MRR = 19).
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户再次使用基础计划注册（MRR = 19）。
- en: The customer purchases the add-on (MRR = 33).
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户购买了附加功能（MRR = 33）。
- en: Before the add-on expires, the customer upgrades to the premium plan (MRR =
    43).
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附加功能到期之前，客户升级到高级计划（MRR = 43）。
- en: The add-on subscription expires (MRR = 29).
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加订阅过期（MRR = 29）。
- en: 'Although MRR can change at any time, if you are calculating all the other behavioral
    measurements on a weekly basis (as advised in section 3.5.1), it is sufficient
    to calculate the MRR for all accounts on those dates when you are making the other
    metric calculations. Listing 3.14 shows the SQL query that calculates the total
    MRR for all accounts on a sequence of dates defined like any other metric. The
    strategy to calculate the MRR is as follows:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MRR可以随时变化，但如果您每周计算其他行为度量（如第3.5.1节中建议的），那么在您进行其他指标计算的那些日期上计算所有账户的MRR就足够了。列表3.14显示了计算一系列日期上所有账户总MRR的SQL查询。计算MRR的策略如下：
- en: Define a fixed sequence of measurement dates using `generate_series` (see the
    sidebar on alternatives to generate the series function in section 3.4 if you
    are using a database other than Postgres).
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`generate_series`定义一个固定的测量日期序列（如果使用除Postgres以外的数据库，请参阅第3.4节侧边栏中关于生成序列函数的替代方案）。
- en: Join the subscriptions with the dates to find all subscriptions active on each
    date. A subscription is active if the start date is on or before the measurement
    date and if the end date is after the measurement date (or there is no end date).
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将订阅与日期连接起来，以找到每个日期上所有活跃的订阅。如果订阅的开始日期在或早于测量日期，并且结束日期在测量日期之后（或者没有结束日期），则该订阅是活跃的。
- en: Use a standard aggregation to sum the total MRR for all the subscriptions on
    each date.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准聚合来汇总每个日期上所有订阅的总MRR。
- en: Listing 3.14 SQL to calculate MRR as a metric
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 计算MRR作为指标的SQL
- en: '[PRE28]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算日期。
- en: ② For each account and date, sums the total MRR
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ② 对于每个账户和日期，汇总总MRR
- en: ③ Limits to subscriptions that begin by the measurement date
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 限制到在测量日期之前开始的订阅
- en: ④ Limits to subscriptions that end after the measurement date
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 限制到在测量日期之后结束的订阅
- en: ⑤ Aggregates the total on each account and date
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 在每个账户和日期上汇总总金额
- en: There is no sample output for listing 3.14\. By now, you know there would be
    an MRR result for each account and date. At the time of this writing, the default
    simulated data includes only one subscription per account and only one MRR (price).
    So you can run listing 3.14, but if you are using the default simulated data,
    the results will not be very interesting. For real companies, MRR often varies
    across accounts, and it is rare to see changes in the MRR of individual accounts.
    Such changes occur only when the subscription plan(s) for the account changes
    in between the two measurement dates.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14没有示例输出。到现在为止，您知道每个账户和日期都会有MRR结果。在撰写本文时，默认模拟数据仅包含每个账户的一个订阅和一个MRR（价格）。因此，您可以运行列表3.14，但如果您使用默认模拟数据，结果可能不会很有趣。对于真实公司，MRR通常在不同账户之间变化，并且很少看到单个账户MRR的变化。这种变化仅在两个测量日期之间账户的订阅计划发生变化时才会发生。
- en: While this approach to calculating MRR may seem excessively complex or expensive
    to compute, it is much faster than calculating event-based metrics because customers
    usually have fewer subscriptions than events. It also might seem inefficient to
    store MRR that doesn’t change often in a table with weekly (or daily) updates.
    This is a fair criticism, but in practice, it’s just one more metric stored in
    a data warehouse that typically houses dozens (or more) of metrics throughout
    the analysis process. The benefit of storing the MRR metric in a common format
    with the other behavioral metrics outweighs any downside. It makes it much easier
    to integrate MRR with the other behavioral metrics, as demonstrated in the next
    two chapters.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种计算月均收入的方法可能看起来过于复杂或计算成本高昂，但它比计算基于事件的指标要快得多，因为客户通常的订阅数量比事件少。此外，将不经常变化的月均收入存储在每周（或每日）更新的表中可能看起来效率低下。这是一个合理的批评，但在实践中，这只是存储在数据仓库中的另一个指标，而数据仓库通常在整个分析过程中包含数十（或更多）个指标。将月均收入指标以与其他行为指标相同的格式存储的好处超过了任何缺点。正如下一章所展示的，这使得将月均收入与其他行为指标集成变得更加容易。
- en: 3.11.2 Subscriptions for specific amounts
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11.2 特定金额的订阅
- en: So far, while discussing subscriptions, I have not talked about the details
    of what the subscriptions are for. Or rather, the subscriptions have been presented
    as being for products that have names but no other facts or distinguishing details.
    But many subscriptions are for something specific, in the sense that the subscription
    entitles the user to a fixed allowance of a certain type of product usage.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在讨论订阅时，我还没有谈到订阅的具体用途细节。或者更确切地说，订阅被展示为是为了那些有名称但没有其他事实或区分细节的产品。但许多订阅是为了某些具体的东西，从订阅赋予用户一定类型产品使用固定配额的意义上来说。
- en: For example, in SaaS, it is common that a subscription is for a certain number
    of seats, meaning the maximum allowed number of users. For telecommunications
    and the Internet of Things (IoT), there is often a set number of handsets or devices,
    or possibly data or bandwidth allowances. To refer to such properties of subscriptions
    generically, it is common to call what the subscription is for the unit of the
    subscription, and the number of units is the quantity.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在SaaS中，订阅通常是针对一定数量的座位，这意味着允许的最大用户数。在电信和物联网（IoT）中，通常有一组固定的手机或设备，或者可能是数据或带宽配额。为了泛指订阅的这些属性，通常将订阅所针对的东西称为订阅的单位，而单位的数量是数量。
- en: DEFINITIONS Unit—For a subscription, a specific type of entitlement offered
    by the subscription. Quantity—How many units a subscriber is entitled to.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：单位——对于订阅，由订阅提供的特定类型的权利。数量——订阅者有权获得多少单位。
- en: Table 3.6 shows an expanded subscription table schema that you can use when
    subscriptions have associated units and quantities. This schema for subscriptions
    adds a text field to describe the units and a numeric field to represent the quantity.
    Note that in this schema, each subscription is for only a single type of unit,
    but in practice, multiple types of units can be sold together. If multiple types
    of units are sold together, it usually makes sense to enter them as separate subscriptions
    in the schema with the same start and end date. In the terminology of subscription
    business management software systems, each individual sale of some number of units
    for a specific time period is often referred to as a charge segment, a rate plan
    charge, or just a charge.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.6显示了当订阅与关联的单位和数量相关联时可以使用的扩展订阅表模式。这个订阅模式增加了一个文本字段来描述单位，以及一个数字字段来表示数量。请注意，在这个模式中，每个订阅只为单一类型的单位，但在实践中，可以一起销售多种类型的单位。如果一起销售多种类型的单位，通常在模式中以单独的订阅形式输入它们，并具有相同的开始和结束日期。在订阅业务管理软件系统的术语中，对于特定时间段内某些数量单位的单个销售通常被称为收费段、费率计划收费或仅仅是收费。
- en: DEFINITION Charge segment —A single recurring contract for a certain quantity
    of some units. Also referred to as a rate plan charge or just a charge.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：收费段——对于一定数量某些单位的单一周期性合同。也称为费率计划收费或仅仅是收费。
- en: If charge segment terminology is used, then a subscription is defined as a set
    of related charge segments. For simplicity and consistency, in this book I will
    refer to each such entry in the subscription table as a subscription but with
    the understanding that customers can have multiple subscriptions at any point
    in time. This is largely a matter of semantics concerning the parts and the whole
    of the various recurring products sold to the customer.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用收费段术语，则订阅被定义为相关收费段的一组。为了简单和一致性，在这本书中，我将把订阅表中此类条目称为订阅，但理解客户在任何时间点都可以有多个订阅。这主要是一个关于客户销售的各种周期性产品的部分与整体语义问题。
- en: Table 3.6 Subscription table schema with units, quantity, and billing period
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.6 带有单位、数量和计费周期的订阅表架构
- en: '| Column | Type | Notes |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `subscription_id` | `integer` or `char` | Standard subscription fields introduced
    in chapter 2 |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| `subscription_id` | `integer` 或 `char` | 在第2章中引入的标准订阅字段 |'
- en: '| `account_id` | `integer` or `char` |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| `account_id` | `integer` 或 `char` |'
- en: '| `product_id` | `integer` or `char` |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `product_id` | `integer` 或 `char` |'
- en: '| `start_date` | `date` |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `start_date` | `date` |'
- en: '| `end_date` | `date` |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `end_date` | `date` |'
- en: '| `mrr` | `double precision` |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `mrr` | `double precision` |'
- en: '| `quantity` | `integer` or `double` | How many units this subscription is
    for |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `quantity` | `integer` 或 `double` | 此订阅的单位数量 |'
- en: '| `units` | `char` or `text` | Units of this subscription |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `units` | `char` 或 `text` | 此订阅的单位 |'
- en: '| `billing_period_(months``)` | `integer` | How many months apart the customer
    is invoiced |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `billing_period_(months``)` | `integer` | 客户被开具发票的月份数间隔 |'
- en: 3.11.3 Calculating subscription unit quantities as metrics
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11.3 将订阅单位数量作为指标计算
- en: The point of introducing subscriptions with a number of units now is that the
    quantity a customer has subscribed to for each type of unit is an important metric,
    just like the MRR. Calculating unit quantity metrics relies on almost the same
    calculation.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在引入具有多个单位的订阅的目的在于，客户为每种单位类型订阅的数量是一个重要的指标，就像MRR一样。计算单位数量指标依赖于几乎相同的计算。
- en: 'One difference with the MRR calculation is that instead of summing the MRR
    field, the quantity field is summed. And when there is more than one type of unit,
    there must be an additional constraint to select the right unit: there should
    be one metric for each type of unit sold. The strategy to calculate subscription
    unit quantities is as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 与MRR计算的一个不同之处在于，不是对MRR字段求和，而是对数量字段求和。并且当存在多种类型的单位时，必须有一个额外的约束来选择正确的单位：每种单位类型应该有一个度量指标。计算订阅单位数量的策略如下：
- en: Define a fixed sequence of measurement dates using `generate_series` (see the
    sidebar on alternatives to generate the series function in section 3.5.1 if you
    are using a database other than Postgres).
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `generate_series` 定义一个固定的测量日期序列（如果使用除Postgres以外的数据库，请参阅3.5.1节侧边栏中关于生成序列函数的替代方案）。
- en: Join the subscriptions with the dates to find all the subscriptions active on
    each date. A subscription is active if the start date is on or before the measurement
    date and if the end date is after the measurement date or if there is no end date.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将订阅与日期连接起来，以找到每个日期上所有活跃的订阅。一个订阅是活跃的，如果其开始日期在或早于测量日期，并且结束日期在测量日期之后，或者如果没有结束日期。
- en: Limit the subscriptions to those with the correct type of units.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制订阅为具有正确类型单位的订阅。
- en: Use a standard aggregation to sum the total quantity for all matching subscriptions
    on each date.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准聚合对每个日期上所有匹配的订阅的总数量进行求和。
- en: The SQL to calculate subscription unit quantities is shown in listing 3.15\.
    As promised, it is similar to the MRR metric calculation in listing 3.14\. You
    might wonder why, when summing the unit quantities, I use aggregate SQL that sums
    the total if there are multiple subscriptions. Shouldn’t there be only one subscription
    for each type of unit? Actually, a quantity increase is a very common type of
    add-on subscription. If a customer needs more units, and they are midway through
    an existing subscription, rather than end-dating the original subscription and
    entering a new one, it is often easier to make a second subscription for the additional
    units with its own price and start and end date. This is what motivates calculating
    unit quantities as metrics that can vary over time and calculating the metric
    with an aggregation.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 计算订阅单位数量的SQL在列表3.15中显示。正如承诺的那样，它与列表3.14中的MRR指标计算类似。您可能会想知道，在求和单位数量时，我为什么使用聚合SQL来求总和，而不是每种单位类型只有一个订阅？实际上，数量增加是一种非常常见的附加订阅类型。如果客户需要更多单位，并且他们正处于现有订阅的中途，而不是结束原始订阅并开始新的订阅，那么通常更容易为额外单位创建一个带有自己价格和开始和结束日期的第二个订阅。这就是为什么将单位数量作为可以随时间变化的指标来计算，并使用聚合来计算指标的原因。
- en: Listing 3.15 SQL to calculate total unit quantity as a metric
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 计算总单位数量作为指标的SQL
- en: '[PRE29]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算所需的日期。
- en: ② Sums the total quantity for the subscription
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ② 对订阅的总数量进行求和
- en: ③ Limits to subscriptions that begin by the measurement date
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 对测量日期之前开始的订阅进行限制
- en: ④ Limits to subscriptions that end after the measurement date
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 对测量日期之后结束的订阅的限制
- en: ⑤ Limits to units of Seat
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 对座位单位进行限制
- en: ⑥ Totals each account and date
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 对每个账户和日期进行总计
- en: 'The default simulated data does not include subscription units or quantities,
    so you can’t run this on simulated data. This example is just meant to show you
    how to do it when you have your own data that includes unit quantities. But the
    simulation code can be extended to include these kinds of details: I encourage
    you to do so as an exercise.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的模拟数据不包括订阅单位或数量，因此您无法在模拟数据上运行此操作。这个例子只是为了向您展示当您拥有包含单位数量的自己的数据时如何操作。但模拟代码可以扩展以包括这些细节：我鼓励您作为练习这样做。
- en: 3.11.4 Calculating the billing period as a metric
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11.4 将计费周期作为指标计算
- en: 'Table 3.5 shows an expanded subscription table schema. In the last section,
    we looked at making metrics from the subscription unit quantity. Table 3.5 has
    one more element that is often relevant when looking at churn: the billing period
    for the subscription.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5显示了扩展的订阅表模式。在上一个部分，我们讨论了如何从订阅单位数量中创建指标。表3.5还有一个在查看流失时通常相关的元素：订阅的计费周期。
- en: DEFINITION Billing period—Measures how often the customer is billed. Billing
    every month is defined as a billing period of 1; annual billing (billing every
    12 months) is a billing period of 12; and so on.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：计费周期—衡量客户被计费的频率。每月计费定义为计费周期为1；年度计费（每12个月计费一次）为计费周期为12；依此类推。
- en: 'The billing period can be important because subscribers with different payment
    frequencies can churn at different rates. It is often (but not always) the case
    that people on longer payment cycles (annual, for example) churn less than people
    on shorter payment cycles (monthly, for example). This is especially true when
    payment is made in advance of service, and it can be difficult or impossible for
    customers to obtain a refund, so they are less likely to churn midterm. Annual
    billing usually comes with a discount to entice customers to make the large payment
    in advance: the question for the subscription business is whether the discount
    offered is justified by the lower churn rate. You will learn how to answer this
    question when we look at the impact of the billing period on churn in the next
    chapter and customer lifetime value in chapter 8.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 计费周期可能很重要，因为具有不同支付频率的订阅者可能会以不同的速率流失。通常情况下（但不总是如此），处于较长期限支付周期（例如年度）的人比处于较短期限支付周期（例如每月）的人流失率低。当付款在服务之前进行时，这一点尤其正确，因为客户很难或无法获得退款，因此他们不太可能在中途流失。年度计费通常伴随着折扣，以吸引客户提前支付大额款项：对于订阅业务来说，问题是提供的折扣是否由较低的流失率所证明。当我们在下一章中查看计费周期对流失的影响以及第8章中的客户终身价值时，您将学习如何回答这个问题。
- en: The billing period can and should be treated like any metric based on subscriptions.
    It should be calculated from an aggregation on the subscriptions at the same interval
    as behavioral metrics so that it can be easily combined with other metrics in
    a churn analysis. The SQL for calculating the billing period as a metric is shown
    in listing 3.16\. It has a lot in common with the subscription metrics shown earlier
    in this section (MRR and unit quantities). One novel point regarding the billing
    period metric is that the aggregation to combine multiple billing periods on different
    subscriptions is not a sum. This is because having two 12-month (annual) billing
    periods, for example, at the same time does not make a 24-month billing period;
    billing periods on different subscriptions are not additive.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 计费周期可以并且应该像基于订阅的任何指标一样处理。它应该从与行为指标相同的间隔对订阅进行聚合计算，以便可以轻松地与其他指标结合进行客户流失分析。计算计费周期作为指标的SQL语句显示在列表3.16中。它与本节前面（MRR和单位数量）显示的订阅指标有很多共同之处。关于计费周期指标的一个新颖点是，将不同订阅上的多个计费周期组合的聚合不是求和。这是因为同时有两个12个月（年度）计费周期，例如，并不会形成一个24个月的计费周期；不同订阅上的计费周期不是累加的。
- en: Having multiple subscriptions on different billing cycles is rare. Most customers
    pay on the same billing cycle with a single invoice even when they have multiple
    subscription products. That is definitely the best practice because customers
    prefer simpler billing! But some kind of aggregation is necessary in the metric
    calculation to guarantee that there is one result per account per measurement
    date, even if there is more than one subscription active. The choices for the
    aggregation are the minimum billing period, the average billing period, or the
    maximum billing period. All of these choices return the single correct billing
    period when all subscriptions have the same period, and they return a number bounded
    by the minimum and maximum billing period in use. In listing 3.16, I choose the
    minimum because if a customer gets a bill every month (billing period 1), they
    are probably going to behave like a customer who gets a bill every month even
    if they also have other products that bill on a longer cycle.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的计费周期上有多个订阅是罕见的。即使客户有多个订阅产品，大多数客户也会在同一个计费周期内支付单一发票。这绝对是最佳实践，因为客户更喜欢简单的计费方式！但指标计算中需要某种聚合，以确保每个账户在每个测量日期只有一个结果，即使有多个活跃的订阅。聚合的选择是最小计费周期、平均计费周期或最大计费周期。所有这些选择在所有订阅具有相同周期时都返回单个正确的计费周期，并且它们返回一个介于最小和最大计费周期之间的数值。在列表3.16中，我选择了最小值，因为如果客户每月收到账单（计费周期1），他们可能表现得像一个每月收到账单的客户，即使他们还有其他按更长周期计费的产品。
- en: Listing 3.16 SQL to calculate billing period as a metric
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.16 计算计费周期作为指标的SQL
- en: '[PRE30]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① This CTE contains the dates for the calculation.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含计算日期。
- en: ② For each account and date, sums the total quantity
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ② 对于每个账户和日期，总计总量
- en: ③ Limits to subscriptions that begin by the measurement date
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 以测量日期开始的订阅限制
- en: ④ Limits to subscriptions that end after the measurement date
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在测量日期之后结束的订阅限制
- en: ⑤ Totals on each account and date
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 每个账户和日期的总计
- en: You can run listing 3.14 by following the instructions in the book’s code, but
    if you are using the default simulated data, then the results might not be very
    interesting. At the time of this writing, the default simulated data includes
    only one billing period (monthly), but it will show you that every account always
    has a billing period of one month. That said, the simulation code can be extended
    to include details like varied billing periods. I encourage you to do so as an
    exercise and then make a pull request to share your work.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过遵循书中代码的说明来运行列表3.14，但如果您使用的是默认的模拟数据，那么结果可能不太有趣。在撰写本文时，默认的模拟数据仅包括一个计费周期（每月），但它会向您显示每个账户始终有一个一个月的计费周期。话虽如此，模拟代码可以扩展以包括像变化计费周期这样的细节。我鼓励您作为练习这样做，然后提交一个拉取请求来分享您的工作。
- en: Software frameworks for automating metric calculation
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 用于自动化指标计算的软件框架
- en: 'If it’s not obvious already, I have to give you some bad news: generating and
    saving a lot of metrics that are counts, averages, and totals of customer events
    gets tedious pretty quickly. If you have more than a few types of events, use
    software to automate as much of this process as possible. If you haven’t already
    worked on this kind of project, I should warn you that it’s usually much more
    work than you imagine because invariably, you don’t just calculate metrics once.
    You end up calculating them many times as you and other people in your organization
    consider different choices and correct problems found by QA tests. For the simulation,
    you don’t have to deal with all that because it’s just a simple simulation and
    I have set up reasonable metrics for you.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还不明显，我必须告诉你一些坏消息：生成和保存大量指标（如客户事件的计数、平均值和总和）会很快变得乏味。如果你有超过几种事件类型，请使用软件尽可能自动化这个过程。如果你还没有从事过这类项目，我应该警告你，这通常比你想象的要多的工作，因为不可避免的是，你不仅仅计算一次指标。你最终会在你和其他组织成员考虑不同的选择和纠正
    QA 测试中发现的问题时多次计算它们。对于模拟，你不必处理所有这些，因为它只是一个简单的模拟，我已经为你设置了合理的指标。
- en: WARNING In a real-life case study, you will probably calculate your metrics
    many times as you test and fix multiple versions.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 在实际案例研究中，你可能需要在测试和修复多个版本时多次计算你的指标。
- en: TAKEAWAY Automation is key to successfully iterating on a variety of metrics
    over the lifetime of an effort to fight churn with data.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收要点 自动化是成功迭代各种指标以对抗客户流失的关键。
- en: 'The Python script that runs the listings is an example of such an automated
    framework, but it’s not optimized for the task of calculating metrics. A metric
    calculation software framework should include the following features, at a minimum:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表的 Python 脚本是这种自动化框架的示例，但它不是针对计算指标的任务进行优化的。一个指标计算软件框架至少应包括以下特性：
- en: Storing metric SQL programs generically so the same SQL can be used to calculate
    metrics on many different events by binding event IDs as the variables and parameterizing
    options like the time period in the metric calculation
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以通用方式存储指标 SQL 程序，以便可以使用相同的 SQL 通过绑定事件 ID 作为变量和参数化选项（如指标计算中的时间周期）来计算许多不同事件上的指标
- en: Handling the details of inserting generated metrics, including names, into the
    data warehouse
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理将生成的指标（包括名称）插入数据仓库的细节
- en: Removing old results when a metric is recalculated
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指标重新计算时删除旧结果
- en: The program wrapper was written to demonstrate a wide variety of listings, and
    it accomplishes the first goal but not the second. More advanced metric-calculation
    frameworks might include features like controlling date ranges for metric calculations
    and automatically updating metrics when new event data arrives in the data warehouse.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包装器被编写来演示各种列表，它实现了第一个目标但没有实现第二个。更高级的指标计算框架可能包括控制指标计算日期范围和自动更新数据仓库中新事件数据到达时的指标等特性。
- en: 'How to design and implement better metric-calculation frameworks is beyond
    the scope of this book because that is a software engineering exercise that depends
    on the particular use case. This book is about data analytics and data science.
    But I have posted another example of a metric-calculation framework written in
    Python in the GitHub repository that goes with this book: [https://github.com/carl24k/fight-churn/tree/master/
    metric-framework](https://github.com/carl24k/fight-churn/tree/master/metric-framework).
    I used that framework for the customer case studies before I decided what the
    book listings would be, and it is more specialized for metrics.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设计和实现更好的指标计算框架超出了本书的范围，因为这取决于特定用例的软件工程练习。本书是关于数据分析和数据科学的。但我已经在 GitHub 仓库中发布了另一个用
    Python 编写的指标计算框架的示例：[https://github.com/carl24k/fight-churn/tree/master/metric-framework](https://github.com/carl24k/fight-churn/tree/master/metric-framework)。在我决定书中的列表之前，我使用了这个框架进行客户案例研究，并且它更专注于指标。
- en: Summary
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Behavioral measurements, also known as metrics, summarize each customer’s events
    at a point in time or at many points in time.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测量，也称为指标，总结每个客户在某个时间点或多个时间点的事件。
- en: Metrics make customer accounts comparable by providing a behavioral profile.
    This is necessary because the events for different accounts occur at different
    rates and disparate times.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标通过提供行为概要使客户账户可比较。这是必要的，因为不同账户的事件发生速率和不同时间各不相同。
- en: Common metrics are measured over time periods ranging from weeks to a year.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见度量标准是在从周到一年不等的时间周期内测量的。
- en: For measurements using a time period of one month or less, it is best to use
    multiples of seven days because nearly all human activities follow weekly cycles.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用一个月或更短时间周期的测量，最好使用七天的倍数，因为几乎所有的人类活动都遵循每周周期。
- en: Common metrics include
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见度量标准包括
- en: Count of events
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件计数
- en: Averages of event properties like duration, dollar value, or size
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件属性（如持续时间、美元价值或大小）的平均值
- en: Totals (sums) of event properties like duration, dollar value, or size
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件属性（如持续时间、美元价值或大小）的总计（总和）
- en: All the common metrics can be calculated with aggregate SQL `SELECT` statements.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有常见度量标准都可以使用聚合SQL `SELECT`语句计算。
- en: All events and metrics need to be tested for quality assurance (QA) because
    event data is not always reliable and metric calculations can contain bugs.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有事件和度量标准都需要进行质量保证（QA）测试，因为事件数据并不总是可靠的，度量计算可能包含错误。
- en: 'The correct procedure for calculating metrics is as follows:'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算度量标准的正确程序如下：
- en: Run QA tests on the event data.
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对事件数据进行QA测试。
- en: Calculate metrics.
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算度量标准。
- en: Run QA tests on the metrics.
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对度量标准进行QA测试。
- en: An important QA test on metrics is how the number of metrics calculated and
    the average, minimum, and maximum values change over time.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于度量标准的一个重要QA测试是计算出的度量标准数量以及平均、最小和最大值随时间的变化。
- en: Another important QA test on metrics is what percent of active accounts have
    nonzero values for the metric and what average, minimum, and maximum measurements
    are found for all customers.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个关于度量的重要QA测试是，有多少百分比的活动账户的度量值不为零，以及对于所有客户，平均、最小和最大测量值是多少。
- en: An important QA test on events is to calculate the average number of events
    per account per month and confirm this agrees with the opinion of experts in the
    business.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于事件的一个重要QA测试是计算每个账户每月的平均事件数量，并确认这与业务专家的意见一致。
- en: The time period of observation for making event measurements needs to be longer
    when events are rare.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件很少发生时，进行事件测量的观察时间周期需要更长。
- en: Account tenure measures how long an account has been a customer in its current
    period of subscription or activity, ignoring older periods of subscription or
    activity that are not continuous with the present one.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户任期衡量账户在其当前订阅或活动期间作为客户的时间长度，忽略与当前不连续的较老订阅或活动期间。
- en: When accounts can have multiple subscriptions (or churn and re-sign up), then
    account tenure should be calculated with a recursive common table expression (CTE).
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当账户可以有多个订阅（或流失和重新注册）时，则账户任期应使用递归公用表表达式（CTE）来计算。
- en: When accounts can have multiple subscriptions at different prices, then the
    monthly recurring revenue should be calculated as a metric based on subscriptions
    at the same frequency as event-based metrics.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当账户可以有多个不同价格的订阅时，则月度经常性收入应基于与基于事件的指标相同频率的订阅来计算作为度量标准。
- en: Subscriptions can entitle a user to a specific amount of a product or feature.
    The amount is known as the quantity, and the product or feature is known as the
    unit of the subscription.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅可以赋予用户特定数量的产品或功能。这个数量被称为数量，而产品或功能被称为订阅的单位。
- en: When subscriptions can have different quantities and/or units, then the unit
    quantities for each customer should be calculated as a metric based on subscriptions
    at the same frequency as event-based metrics.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订阅可以有不同数量和/或单位时，每个客户的单位数量应基于与基于事件的指标相同频率的订阅来计算作为度量标准。
- en: Subscriptions can have different billing periods, meaning the length of time
    between payments (monthly, annual, and so on).
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅可以有不同计费周期，这意味着支付之间的时间长度（每月、每年等）。
- en: When subscriptions can have different billing periods, then the billing period
    of each customer should be calculated as a metric based on the subscriptions at
    the same frequency as event-based metrics.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订阅可以有不同计费周期时，则每个客户的计费周期应基于与基于事件的指标相同频率的订阅来计算作为度量标准。
