- en: 1 Introducing C# and .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 介绍C#和.NET
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding what C# and .NET are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解C#和.NET是什么
- en: Learning why you would use C# for your projects (and why you wouldn’t)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习为什么要在你的项目中使用C#（以及为什么不用）
- en: Switching to C# and how to get started
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向C#以及如何入门
- en: 'Another book on C#, you say? Yes, another one. Plenty of books are written
    about C# and .NET, but this book has one fundamental difference: I wrote this
    book to help you develop clean, idiomatic C# code in your day-to-day life. This
    book is not a reference book but rather a practical guide. This book does not
    cover things like how to write an `if` statement, what a method signature is,
    or what an object is. We are not concerned about syntax but instead focus on concepts
    and ideas. There is a difference between knowing the syntax of a language and
    being able to write clean, idiomatic code. After going through this book, that
    is exactly what you will be able do. Whatever your background is and whatever
    programming languages you know, as long as you understand object-oriented programming,
    this book helps you shift into the C# and .NET ecosystem, as shown in figure 1.1.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一本关于C#的书，你说？是的，又一本。关于C#和.NET的书已经有很多了，但本书有一个基本的不同点：我写这本书是为了帮助你开发在日常生活中的干净、惯用的C#代码。本书不是一本参考书，而是一本实用指南。本书不涵盖如何编写`if`语句、方法签名是什么或对象是什么等内容。我们不关心语法，而是关注概念和想法。知道一种语言的语法和能够编写干净、惯用的代码之间存在差异。在阅读完这本书后，你将能够做到这一点。无论你的背景如何，无论你了解哪些编程语言，只要你能理解面向对象编程，这本书就能帮助你过渡到C#和.NET生态系统，如图1.1所示。
- en: '![](../Images/01_01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01_01.png)'
- en: Figure 1.1 Every chapter introduction contains a progress diagram, which allows
    you to quickly figure out where you are in the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 每章引言都包含一个进度图，这让你可以快速了解你在书中的位置。
- en: 'What do organizations like Microsoft, Google, and the US government have in
    common? They all use C#—and for good reason. But why? C# is just another programming
    language. It bears similarities to Java and C++, allows for both object-oriented
    and functional programming, and enjoys wide support from a large open source community.
    Great. Now, why should you care? In this chapter, we’ll explore that question
    in depth, but let me reveal a couple of spoilers: C# excels at allowing you to
    create scalable software. To start writing C#, all you need is the .NET SDK of
    your choice (more on that in chapter 2) and perhaps an IDE. The language and runtime
    are open source.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微软、谷歌和美国政府等组织有什么共同之处？它们都使用C#——而且有充分的理由。但为什么呢？C#只是另一种编程语言。它与Java和C++相似，允许进行面向对象和函数式编程，并且得到了一个大型开源社区的广泛支持。很好。那么，你为什么要关心这个呢？在本章中，我们将深入探讨这个问题，但让我先透露一些预告：C#擅长让你创建可扩展的软件。要开始编写C#，你只需要选择你喜欢的.NET
    SDK（关于这一点，请参阅第2章）以及可能需要一个IDE。语言和运行时都是开源的。
- en: 'Any time you look online for C#, chances are, you come across the .NET Framework.
    You can think about the .NET Framework as your warm blanket, a warm fire, and
    a mug of hot chocolate on a winter day, providing you with everything you need:
    libraries that encapsulate low-level Windows APIs, expose commonly used data structures
    and provide wrappers for complicated algorithms. Daily development in C# almost
    certainly involves the .NET Framework, .NET Core, or .NET 5, so we’ll explore
    these frameworks where appropriate.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在网上查找C#时，很可能会遇到.NET框架。你可以把.NET框架想象成你的温暖毯子、温暖的火炉和冬天的热巧克力杯，为你提供你需要的一切：封装低级Windows
    API的库、公开常用数据结构并为复杂算法提供包装器。在C#的日常开发中，几乎肯定会涉及到.NET框架、.NET Core或.NET 5，因此我们将根据需要探讨这些框架。
- en: Figure 1.2 shows where this book’s topics fit in a general .NET web architecture.
    It also shows the architecture we use to completely rewrite an existing application,
    which we’ll start in chapter 5 (the green/dashed arrows indicate this path).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2显示了本书的主题在一般.NET网络架构中的位置。它还显示了我们将用于完全重写现有应用的架构，我们将在第5章开始介绍（绿色/虚线箭头表示此路径）。
- en: '![](../Images/01_02.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01_02.png)'
- en: Figure 1.2 An example of a typical web service architecture on a Microsoft stack.
    This book follows the approach shown by the green/dashed arrows. This book covers
    the presentation, business logic, and data access layers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 在Microsoft堆栈上典型网络服务架构的示例。本书遵循绿色/虚线箭头所示的方法。本书涵盖了表示层、业务逻辑层和数据访问层。
- en: 'For those of you with prior experience in C#: this book sits between beginner
    and advanced resources. With the skills taught in this book, you can bridge the
    knowledge gap and prepare yourself for advanced skills. The first two chapters
    may seem a bit basic to you, but I invite you to not skim over these. It is always
    good to refresh your knowledge.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在C#方面有先验经验的你们来说，这本书位于初学者和高级资源之间。通过这本书教授的技能，你可以填补知识差距，并为高级技能做好准备。前两章可能对你们来说有点基础，但我邀请你们不要匆匆略过。时常刷新你的知识总是好的。
- en: 1.1 Why work in C#?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 为什么选择C#？
- en: If you are already familiar with a programming language other than C# and like
    using it, why should you use C#? Perhaps you were hired by a company that uses
    only C#. Or maybe you just want to see what all the fuss is about.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉除了C#以外的其他编程语言并且喜欢使用它，为什么你应该使用C#呢？也许你是被一家只使用C#的公司雇佣的。或者也许你只是想看看所有这些喧嚣究竟是怎么回事。
- en: 'I promise not to repeatedly tell you that C# is a “strongly typed object-oriented
    programming language that enables cross-platform development of scalable enterprise
    software.” You are likely aware of that, and it is hardly the most exciting sentence
    to dissect. In this section, we cover the buzzwords in that definition once and
    do not touch on it again. At the risk of sounding like I’m employed by Microsoft’s
    marketing department, for the rest of this section, we’ll focus on the following
    highlights and use cases of C#:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我保证不会反复告诉你C#是一种“强类型面向对象编程语言，它使跨平台开发可扩展的企业软件成为可能。”你可能已经知道了这一点，而且这几乎不是最激动人心的句子来剖析。在本节中，我们一次性覆盖了那个定义中的术语，并且不再涉及。冒着听起来像是在微软市场营销部门工作的风险，在本节的剩余部分，我们将关注以下C#的亮点和用例：
- en: C# (and the .NET ecosystem) enables the development of software in an economical
    way. Economical solutions are important because enterprise development is the
    bread and butter of C#.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#（以及.NET生态系统）以经济的方式使软件开发成为可能。经济解决方案很重要，因为企业开发是C#的精髓。
- en: C# can improve code stability and is maintainable because of its support for
    self-documenting code, secure libraries, and ease of use.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#可以通过支持自文档化代码、安全库和易用性来提高代码的稳定性并使其可维护。
- en: C# is developer friendly and easy to use. There’s nothing worse than discovering
    that the programming language you want to use does not have good support for the
    things you love (such as a stable package manager, good support for unit testing,
    and a cross-platform runtime).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#对开发者友好且易于使用。没有什么比发现你想要使用的编程语言没有对你所喜爱的功能（例如稳定的包管理器、良好的单元测试支持以及跨平台运行时）提供良好支持更糟糕的了。
- en: Of course, writing scalable, maintainable, and developer-friendly “clean code”
    can be done in most (if not all) programming languages. The difference lies in
    the developer experience. Some languages are really good at guiding you in writing
    clean code, whereas others are not. C# is not perfect, but it does try to help
    you in this regard.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在大多数（如果不是所有）编程语言中都可以编写可扩展、可维护且对开发者友好的“清洁代码”。区别在于开发者体验。有些语言在引导你编写清洁代码方面做得非常好，而有些则不然。C#并不完美，但它确实试图在这方面帮助你。
- en: '1.1.1 Reason 1: C# is economical'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 原因1：C#经济高效
- en: C# is free to use and develop in. The language and platform are fully open source,
    all documentation is free, and most tooling has free options. For example, a common
    C# setup includes an installation of C# 8, .NET 5, and Visual Studio Community.
    All these are free and used in this book. No license fee is required for the runtime,
    and you can deploy the end product wherever you want.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C#的使用和开发是免费的。语言和平台是完全开源的，所有文档都是免费的，大多数工具都有免费选项。例如，常见的C#配置包括安装C# 8、.NET 5和Visual
    Studio Community。所有这些都是免费的，并在本书中使用。运行时不需任何许可费用，你可以将最终产品部署到你想要的地方。
- en: '1.1.2 Reason 2: C# is maintainable'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 原因2：C#可维护
- en: When we talk about maintainability in this book, we mean the ability to fix
    bugs, change functionality, and address other issues without unintended side effects.
    This sounds like an obvious requirement for any programming language, but it is
    very hard to implement. C# has features that improve the maintainability (and,
    therefore, safe extensibility) of large codebases. Think, for example, about generics
    and Language-Integrated Query (LINQ). We’ll discuss these two things throughout
    the book, but they are examples of the platform exposing functionalities that
    can help you write better code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这本书中谈论可维护性时，我们指的是在不产生意外副作用的情况下修复错误、更改功能以及解决其他问题的能力。这听起来像是任何编程语言的明显要求，但实际上很难实现。C#具有提高大型代码库可维护性（因此，安全可扩展性）的功能。例如，考虑泛型和语言集成查询（LINQ）。我们将在整本书中讨论这两件事，但它们是平台暴露的功能的例子，可以帮助你编写更好的代码。
- en: 'For a company, maintainability might not be the number one priority on the
    surface, but if you develop code that is maintainable (meaning clean code that
    is easily extendable and backed by tests), development costs drop. Development
    costs dropping when writing maintainable code may seem counterintuitive at first:
    maintainable code takes longer to write and architect, driving up the initial
    costs of development. However, imagine what happens after a little while when
    a user discovers a bug or they want an additional feature. If we write maintainable
    code, we can quickly and easily find the bug (and fix it). Adding the feature
    is simpler because the codebase is extensible. If we can easily extend and fix
    a codebase, development costs go down.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一家公司来说，表面上，可维护性可能不是首要任务，但如果你开发了可维护的代码（意味着易于扩展且由测试支持的干净代码），开发成本就会降低。一开始，编写可维护代码时开发成本的降低可能看起来有些不合逻辑：可维护的代码需要更长的时间来编写和设计，从而增加了开发的初始成本。然而，想象一下，当用户发现一个错误或他们想要一个额外的功能时，过了一段时间会发生什么。如果我们编写可维护的代码，我们可以快速轻松地找到错误（并修复它）。添加功能更简单，因为代码库是可扩展的。如果我们能够轻松扩展和修复代码库，开发成本就会降低。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: Open/Closed Principle
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则
- en: In 1988, the French computer scientist Bertrand Meyer (creator of the Eiffel
    programming language) released a book called *Object-Oriented Software Construction*
    (Prentice Hall, 1988). The release of Meyer’s book was a pivotal moment in the
    history of object-oriented programming and design, because in it, he introduced
    the Open/Closed Principle (OCP). The OCP is aimed at improving the maintainability
    and flexibility of software designs. Meyer says the OCP means that “software entities
    (classes, modules, functions, etc.) should be open for extension, but closed for
    modification.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 1988年，法国计算机科学家贝尔特朗·梅耶（Eiffel编程语言的创造者）出版了一本名为《面向对象软件构造》（Prentice Hall，1988年）的书。梅耶的书的发布是面向对象编程和设计历史上的一个转折点，因为在这本书中，他引入了开闭原则（OCP）。OCP旨在提高软件设计的可维护性和灵活性。梅耶说，OCP意味着“软件实体（类、模块、函数等）应该是可扩展的，但应该是封闭的以修改。”
- en: 'But what does the OCP mean in practical terms? To examine that, let’s apply
    the OCP to a class: we deem a class “open” for extension and “closed” to modification
    if we can add functionality to the class without changing the existing functionality
    (and, therefore, potentially breaking parts of our code). If you abide by that
    rule, the odds of you introducing a regression (or new bug) in the existing code
    are much smaller than if you try to force in the bug fix or new feature with no
    regard for maintainability and extensibility. When you work with code that is
    more complicated (and coupled; discussed in chapter 8), you are more likely to
    introduce new bugs due to misunderstanding the side effects of your changes. This
    is what we want to avoid at all costs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但在实际意义上，OCP（开闭原则）意味着什么？为了检验这一点，让我们将OCP应用于一个类：如果我们能够在不改变现有功能（因此，可能破坏代码的某些部分）的情况下向类中添加功能，我们认为这个类是“开放”于扩展的，并且是“封闭”于修改的。如果你遵守这个规则，你引入回归（或新错误）的可能性比试图强制修复错误或添加新功能而不考虑可维护性和可扩展性的可能性要小得多。当你处理更复杂（并且耦合；在第8章中讨论）的代码时，你更有可能因为误解你更改的副作用而引入新的错误。这是我们无论如何都要避免的事情。
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '1.1.3 Reason 3: C# is developer friendly and easy to use'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 第3个原因：C#对开发者友好且易于使用
- en: Enterprise development is the bread and butter of C# development and where C#
    and .NET shine. What would your ideal codebase look like in an enterprise environment?
    Perhaps you would like a codebase that is easily navigable with a solid package
    manager and backed by tests (unit, integration, and smoke). Let’s also throw in
    excellent documentation and cross-platform support.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 企业开发是 C# 开发的基础，也是 C# 和 .NET 发挥优势的地方。在你的理想代码库中，企业环境会是什么样子？也许你希望代码库易于导航，拥有可靠的包管理器，并支持测试（单元、集成和冒烟测试）。让我们再添加优秀的文档和跨平台支持。
- en: DEFINITION *Self-documenting code* means code that is written clearly enough
    that we need no comments to explain the logic. The code documents itself. For
    example, if you have a method called `DownloadDocument`, others can have some
    inkling of what it does. There is no need to add a comment saying that the logic
    inside the method downloads a document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 自我文档化的代码意味着代码编写得足够清晰，以至于我们不需要注释来解释逻辑。代码本身就是文档。例如，如果你有一个名为 `DownloadDocument`
    的方法，其他人可以大致了解它的功能。不需要添加注释来说明方法内部逻辑是下载文档。'
- en: To top things off, perhaps we can have good integration with a cloud service
    for continuous integration and delivery (CI/CD). A pragmatic view tells us that
    the likelihood of you having such a codebase is not very high. Of course, this
    wish list is unrealistic for most scenarios. However, if you want to do some of
    these things (or all of them, if you are adventurous), C# does not work against
    you. It offers existing workflows, functionalities, and native libraries to get
    you 99% of the way there.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了锦上添花，也许我们可以与云服务进行良好的集成，以实现持续集成和持续交付（CI/CD）。实用主义观点告诉我们，你拥有如此代码库的可能性并不高。当然，这个愿望清单对于大多数场景来说是不切实际的。然而，如果你想做一些这些事情（如果你喜欢冒险，甚至所有这些），C#
    不会成为你的障碍。它提供了现有的工作流程、功能性和原生库，让你达到 99% 的目标。
- en: Developers coming from a language such as Java should see some similarities
    in the project structure. Although some differences exist, they are not large.
    We’ll discuss the C# project structure in depth throughout the book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Java 等语言的开发者可能会在项目结构中看到一些相似之处。尽管存在一些差异，但它们并不大。我们将在本书中深入讨论 C# 项目结构。
- en: .NET also has support for several popular testing frameworks. Microsoft provides
    the Visual Studio Unit Testing Framework, which contains (and by extension is
    sometimes called) MSTest. MSTest is just the command-line runner for the Visual
    Studio Unit Testing Framework. Other commonly used testing frameworks are xUnit
    and NUnit. You can also find support for mocking frameworks such as Moq (Moq is
    similar to Java’s Mockito or Go’s GoMock. We’ll learn more about using Moq with
    unit tests in section 10.3.3.), SpecFlow (behavior-driven development similar
    to Cucumber), NFluent (a fluent assertion library), FitNesse, and many more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 还支持几个流行的测试框架。Microsoft 提供了 Visual Studio 单元测试框架，其中包含（并且有时也被称为）MSTest。MSTest
    只是 Visual Studio 单元测试框架的命令行运行器。其他常用的测试框架包括 xUnit 和 NUnit。你还可以找到对模拟框架的支持，如 Moq（Moq
    与 Java 的 Mockito 或 Go 的 GoMock 类似。我们将在第 10.3.3 节中学习如何使用 Moq 进行单元测试），SpecFlow（类似于
    Cucumber 的行为驱动开发），NFluent（一个流畅断言库），FitNesse，以及许多其他框架。
- en: Last, you can run C# on a host of platforms, albeit with some limitations (some
    older platforms are restricted to older versions of C# and the .NET Framework).
    With .NET 5, you can run the same code on Windows 10, Linux, and macOS. This functionality
    got its start as .NET Core, a spinoff of the .NET Framework that has since merged
    with .NET Framework (and other frameworks) to create .NET 5\. You can even run
    C# code on iOS and Android through Xamarin and on PlayStation, Xbox, and Nintendo
    Switch platforms through Mono.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在众多平台上运行 C#，尽管有一些限制（一些较老的平台仅限于较老的 C# 版本和 .NET Framework）。使用 .NET 5，你可以在
    Windows 10、Linux 和 macOS 上运行相同的代码。这种功能最初起源于 .NET Core，它是 .NET Framework 的一个分支，后来与
    .NET Framework（以及其他框架）合并，形成了 .NET 5。你甚至可以通过 Xamarin 在 iOS 和 Android 上运行 C# 代码，通过
    Mono 在 PlayStation、Xbox 和 Nintendo Switch 平台上运行。
- en: 1.2 Why not work in C#?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 为什么不使用 C#？
- en: 'C# isn’t the best choice for everybody under every circumstance. It is imperative
    that you choose the best tool for the job. C# works well in a wide variety of
    situations, but a few use cases you might not want to use C# and .NET for follow:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C# 并不是在所有情况下都是最佳选择。务必选择最适合工作的工具。C# 在各种情况下都表现良好，但以下是一些你可能不想使用 C# 和 .NET 的用例：
- en: Operating system development
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统开发
- en: Real-time operating system–driven code (embedded development)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时操作系统驱动的代码（嵌入式开发）
- en: Numerical computing
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值计算
- en: Let’s examine briefly why C# might not be an ideal fit for these use cases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地探讨一下为什么C#可能不适合这些用例。
- en: 1.2.1 Operating system development
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 操作系统开发
- en: Operating system (OS) development is an incredibly important corner of software
    engineering, yet not many people develop OSes. Developing an OS takes a lot of
    time and commitment, with codebases routinely going into millions of lines of
    code, developed and maintained over many years and sometimes decades.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（OS）开发是软件工程中一个极其重要的领域，但并不是很多人开发操作系统。开发操作系统需要大量的时间和承诺，代码库通常包含数百万行代码，这些代码在多年甚至几十年内开发和维护。
- en: The main reason C# is not suitable for OS development comes down to spotty support
    for manual memory management (unmanaged code) and C#’s compilation process. Although
    C# allows the use of pointers when using “unsafe” mode, it does not rival a programming
    language like C in ease of use for manual memory management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C#不适合操作系统开发的主要原因归结为对手动内存管理（未管理代码）的支持不完整以及C#的编译过程。尽管C#在“不安全”模式下允许使用指针，但它在使用手动内存管理方面的易用性并不像C语言那样。
- en: Another problem with using C# to develop an OS is its partial reliance on a
    just-in-time (JIT) compiler (more on this in chapter 2). Imagine having to run
    your operating system through a virtual machine. Performance would be a problem
    because the virtual machine has to play catch-up all the time to run the JIT-compiled
    code, which is similar to what happens when .NET code runs on your machine. This
    critique means that a fully statically compiled language is a better fit for OS
    development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C#开发操作系统的问题之一是其对即时编译器（JIT）的局部依赖（更多内容在第2章中介绍）。想象一下，你必须通过虚拟机运行你的操作系统。性能将是一个问题，因为虚拟机必须不断追赶以运行JIT编译的代码，这与.NET代码在你的机器上运行时发生的情况类似。这种批评意味着，一个完全静态编译的语言更适合操作系统开发。
- en: Yet, examples of OSes developed in higher-level languages do exist. For example,
    Pilot-OS (created by Xerox PARC in 1977) was written in Mesa,[¹](#pgfId-1172231)
    a predecessor of Java.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确实存在使用高级语言开发的操作系统（OS）的例子。例如，Pilot-OS（由施乐帕克研究中心在1977年创建）是用Mesa编写的，[¹](#pgfId-1172231)它是Java的前身。
- en: If you want to learn more about operating system development, the wiki for the
    osdev.org community is an excellent resource ([wiki.osdev.org](http://wiki.osdev.org)).
    There you can find guides to get started, tutorials, and reading suggestions.
    Resources for learning C include Jens Gustedt’s *Modern C* (Manning, 2019) and
    the classic book, *The C Programming Language*, by Brian Kernighan and Dennis
    Ritchie (Prentice Hall, 1988).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于操作系统开发的信息，osdev.org社区维基是一个极好的资源（[wiki.osdev.org](http://wiki.osdev.org)）。在那里你可以找到入门指南、教程和阅读建议。学习C的资源包括Jens
    Gustedt的《现代C》（Manning，2019年）和经典书籍《C程序设计语言》，由Brian Kernighan和Dennis Ritchie所著（Prentice
    Hall，1988年）。
- en: 1.2.2 Real-time operating system embedded development in C#
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 C#中的实时操作系统嵌入式开发
- en: Similar to OS development (section 1.2.1), real-time operating system (RTOS)–driven
    code, which you most often find in embedded systems, experiences large performance
    issues when run through a virtual machine. An RTOS scans code linearly, in real
    time, and executes the instructions at a configurable interval ranging from one
    operation per second to many times per microsecond, depending on the wishes of
    the developer and the capabilities of the microcontroller or programmable logic
    controller (PLC) the code runs on. A virtual machine gets in the way of true real-time
    execution due to added latency and overhead at run time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统（OS）开发（第1.2.1节）类似，实时操作系统（RTOS）驱动的代码，你通常在嵌入式系统中找到，当通过虚拟机运行时，会经历很大的性能问题。RTOS线性地、实时地扫描代码，并在可配置的间隔内执行指令，这个间隔从每秒一个操作到每微秒多次操作不等，具体取决于开发者的意愿和代码运行的微控制器或可编程逻辑控制器（PLC）的能力。由于虚拟机在运行时增加了延迟和开销，它阻碍了真正的实时执行。
- en: 'If you want to learn more about RTOS-driven code and embedded development,
    you can check out several highly regarded books, such as David E. Simon’s *An
    Embedded Software Primer* (Addison-Wesley Professional, 1999), or Elecia White’s
    *Making Embedded Systems: Design Patterns for Great Software* (O’Reilly Media,
    2011).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于实时操作系统（RTOS）驱动的代码和嵌入式开发的信息，你可以查看几本备受推崇的书籍，例如David E. Simon的《嵌入式软件入门》（Addison-Wesley
    Professional，1999年），或者Elecia White的《制作嵌入式系统：优秀软件的设计模式》（O’Reilly Media，2011年）。
- en: 1.2.3 Numerical computing and C#
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 数值计算和C#
- en: '*Numerical computing* (also called *numerical analysis*) concerns the study,
    development, and analysis of algorithms. People (usually computer scientists or
    mathematicians) working in numerical computing use numerical approximation to
    solve problems in just about every branch of science and engineering. From a programming
    language perspective, it presents unique challenges and considerations. Every
    programming language can evaluate mathematical statements and formulas, yet some
    are specifically built for this purpose.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值计算*（也称为 *数值分析*）涉及算法的研究、开发和分析。在数值计算领域工作的个人（通常是计算机科学家或数学家）使用数值近似来解决科学和工程几乎每个分支的问题。从编程语言的角度来看，它提出了独特的挑战和考虑。每种编程语言都可以评估数学语句和公式，但有些是专门为此目的构建的。'
- en: Consider plotting graphs. C# can absolutely handle plotting, but what performance
    and ease of use does C# offer when compared with something like MATLAB? (MATLAB
    is both a computing environment and a programming language created by MathWorks.)
    The short answer is that it doesn’t compare. Graphics programming in C# sees you
    working in either something like WPF (which uses Direct3D), OpenGL, DirectX, or
    a different third-party graphics library (usually aimed at video games). With
    MATLAB, you have a language that ties into an environment built to render complicated
    3-D graphs. You can literally call `plot(x, y)`, and MATLAB plots your graph for
    you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑绘制图表。C# 完全可以处理绘图，但与 MATLAB 等工具相比，C# 在性能和易用性方面提供了什么？(MATLAB 是 MathWorks 创建的既是一个计算环境又是一种编程语言。)简短的答案是，它们不可比。在
    C# 中进行图形编程，你将工作在类似于 WPF（使用 Direct3D）、OpenGL、DirectX 或不同的第三方图形库（通常针对视频游戏）的环境中。使用
    MATLAB，你有一个与一个构建来渲染复杂 3-D 图形的语言绑定在一起的环境。你可以直接调用 `plot(x, y)`，MATLAB 会为你绘制图表。
- en: 'So, C# can do numerical computing but does not offer the same ease of use as
    a language with high-level libraries and abstractions dealing with graph plotting
    as MATLAB does. If it interests you to learn more about MATLAB or numerical computing,
    some available resources on these topics include Richard Hamming’s *Numerical
    Methods for Scientists and Engineers* (Dover Publications, 1987), Amos Gilat’s
    *MATLAB: An Introduction with Applications* (Wiley, 2016), and the Cody tutorial
    program for MATLAB ([https://www.mathworks.com/matlabcentral/cody](https://www.mathworks.com/matlabcentral/cody)).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C# 可以进行数值计算，但与 MATLAB 这样的具有高级库和抽象处理图形绘制的语言相比，并不提供相同的易用性。如果你对学习更多关于 MATLAB
    或数值计算感兴趣，这些主题的一些可用资源包括 Richard Hamming 的 *《科学家和工程师的数值方法》*（Dover Publications，1987年），Amos
    Gilat 的 *《MATLAB：应用入门》*（Wiley，2016年），以及 MATLAB 的 Cody 教程程序（[https://www.mathworks.com/matlabcentral/cody](https://www.mathworks.com/matlabcentral/cody)）。
- en: 1.3 Switching to C#
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 转向 C#
- en: Because of the similarity among languages, developers with a good understanding
    of the syntax of a Java virtual machine (JVM) language (most notably Java, Scala,
    and Kotlin) or C++ may have an easier time with this book than somebody coming
    from a non-C-style language, non-virtual-machine-esque-based language, or web
    and cloud-focused languages such as Dart, Ruby, or Go. Coming from a non-C-style
    language background does not mean that C# is impossible to understand. You may
    find yourself rereading some passages twice, but in the end, you’ll get there
    just fine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言之间的相似性，对 Java 虚拟机 (JVM) 语言（尤其是 Java、Scala 和 Kotlin）或 C++ 语法有良好理解的开发者，与来自非
    C 风格语言、非虚拟机类似语言或 Dart、Ruby 或 Go 等关注网络和云的语言的背景的人相比，可能会更容易理解这本书。来自非 C 风格语言背景并不意味着
    C# 就不可能理解。你可能会发现自己需要反复阅读一些段落两次，但最终你会顺利地理解它。
- en: If you come from an interpreted language such as Python, the .NET compilation
    process may seem odd at first. Languages within the confines of .NET use a two-step
    compilation process. First, code is compiled statically to a lower-level language
    called Common Intermediate Language (CIL, IL, or MSIL for short; MS for Microsoft—it
    is somewhat similar to Java bytecode, for the Java developers among us), which
    in turn compiles just-in-time (JIT) to native code when the .NET runtime executes
    the code on the host. All this might sound like a lot to digest suddenly, but
    in a few chapters, you will understand it all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 Python 这样的解释型语言，.NET 编译过程可能一开始看起来很奇怪。.NET 限制内的语言使用两步编译过程。首先，代码被静态编译到一个称为公共中间语言
    (CIL，IL 或 MSIL 的简称；MS 代表 Microsoft——对于 Java 开发者来说，它与 Java 字节码有些相似)，然后当 .NET 运行时在宿主上执行代码时，它会即时编译
    (JIT) 到本地代码。所有这些可能听起来突然有很多要消化，但在几章之后，你就会理解这一切。
- en: If you come from a scripting language such as JavaScript, static typing might
    seem to limit and frustrate you. But once you get used to knowing what your type
    is at all times, I think you’ll like it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自像 JavaScript 这样的脚本语言，静态类型可能看起来会限制并让您感到沮丧。但一旦您习惯了始终知道您的类型是什么，我认为您会喜欢它的。
- en: And if you come from a language such as Go or Dart, where native libraries are
    sometimes hard to find, .NET 5 may surprise you with its rich store of libraries.
    By providing functions for most things you can think of, the .NET libraries are
    your primary source for functionality. A lot of applications written with .NET
    never use any third-party libraries.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自像 Go 或 Dart 这样的语言，其中原生库有时难以找到，.NET 5 可能会因其丰富的库存储而让您感到惊讶。通过提供您能想到的大多数功能的功能，.NET
    库是您功能的主要来源。许多用 .NET 编写的应用程序从未使用过任何第三方库。
- en: To get the housekeeping out of the way, let’s discuss tooling. We will not dive
    into how to install an IDE or the .NET SDK in this chapter. If you have not installed
    a .NET SDK or an IDE and want some help, you can find a couple of quick installation
    guides in appendix C. To follow along with this book, you need to install the
    latest versions of the .NET Framework and .NET 5\. In this book, we’ll start with
    an old codebase that uses the .NET Framework. Because of that, we’ll use the .NET
    Framework to run that old codebase as we migrate the code to .NET 5.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不必要的麻烦，让我们先讨论一下工具。在本章中，我们不会深入讨论如何安装 IDE 或 .NET SDK。如果您尚未安装 .NET SDK 或 IDE
    并需要一些帮助，您可以在附录 C 中找到一些快速安装指南。为了跟随本书的内容，您需要安装 .NET Framework 和 .NET 5 的最新版本。在本书中，我们将从一个使用
    .NET Framework 的旧代码库开始。正因为如此，我们在将代码迁移到 .NET 5 的过程中将使用 .NET Framework 来运行那个旧代码库。
- en: As mentioned earlier, C# is open source and maintained by the community with
    help from Microsoft. You don’t need to pay for a runtime, SDK, or IDE license.
    Concerning IDEs, Visual Studio (the IDE we’ll use in the examples in this book)
    has a free Community edition that you can use to develop personal projects and
    open source software. If you like your current IDE, chances are you can find a
    C# plugin for it. You can also use the command line to compile, run, and test
    C# projects, although I encourage you to give the dedicated C# tooling (Visual
    Studio) a chance because it provides the smoothest experience and easiest route
    to writing idiomatic C# code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C# 是开源的，由社区维护，并得到微软的支持。您不需要为运行时、SDK 或 IDE 许可证付费。关于 IDE，Visual Studio（本书示例中将使用的
    IDE）有一个免费的社区版，您可以使用它来开发个人项目和开源软件。如果您喜欢您当前的 IDE，那么您很可能可以找到适用于它的 C# 插件。您还可以使用命令行来编译、运行和测试
    C# 项目，尽管我鼓励您尝试一下专门的 C# 工具（Visual Studio），因为它提供了最流畅的体验和编写惯用 C# 代码的最简单途径。
- en: Many concepts and techniques you have picked up elsewhere transfer to C#, but
    some don’t. C# has matured more on the backend than it has on the frontend, because
    it is traditionally mostly used for that purpose. A historical focus on backend
    development for C# does not mean that the frontend experience is any less impressive.
    You can write a full-stack application in C# without the need to touch JavaScript.
    Although this book focuses on backend development, many of the concepts taught
    here help you on the frontend as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您在其他地方学到的许多概念和技术可以转移到 C# 中，但也有一些不行。C# 在后端比在前端更加成熟，因为它传统上主要用于这个目的。C# 对后端开发的历史关注并不意味着前端体验有任何不令人印象深刻的地方。您可以使用
    C# 编写全栈应用程序，而无需接触 JavaScript。尽管本书侧重于后端开发，但这里教授的许多概念对前端开发也有帮助。
- en: Have you ever come across a monster method with five nested `for` loops, a bunch
    of hardcoded numbers (so-called magic numbers), and more comments than code? Imagine
    you are a new developer who just joined a team. How would you feel when you boot
    up your IDE, pull down the source code, and see this method? Despair would not
    quite cover it. Now imagine that you placed all the individual actions in your
    monster method in their own small methods (perhaps fewer than 5 to 10 lines of
    code). What would your monster method look like? Instead of being a bunch of difficult-to-follow
    conditionals and assignments, with no clear path to understanding unless you have
    specific domain knowledge, the code almost reads like a narrative. If you name
    your methods well, your main method should read like a recipe that even the worst
    cooks can follow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经遇到过一种包含五个嵌套的`for`循环、一堆硬编码的数字（所谓的魔法数字）以及比代码还多的注释的“怪物方法”？想象一下，你是一名刚刚加入团队的新开发者。当你启动你的集成开发环境（IDE），下载源代码，并看到这个方法时，你会作何感想？绝望可能都无法完全概括你的感受。现在想象一下，如果你将你的“怪物方法”中的所有单个操作都放在它们自己的小方法中（可能少于5到10行代码）。你的“怪物方法”会是什么样子？它不再是难以跟随的条件和赋值语句的集合，除非你有特定的领域知识，否则没有明确的路径可以理解，代码几乎就像一个叙述。如果你给你的方法取好名字，你的主方法应该像一份食谱，即使是糟糕的厨师也能遵循。
- en: When I mention “clean code,” I am referring to the coding practices evangelized
    by Robert C. Martin in his videos ([https://cleancoders.com/videos](https://cleancoders.com/videos))
    and books *Clean Code* (Prentice Hall, 2008), *Clean Architecture* (Prentice Hall,
    2017), and, with Micah Martin, *Agile Principles, Patterns, and Practices in C#*
    (Pearson, 2006), and as well as through his compilation of the “SOLID” principles
    (Single Responsibility Principle, Open/ Closed Principle, Liskov Substitution
    Principle, Interface Segregation Principle, and Dependency Inversion Principle).
    I explain clean code principles fully when they come up in the book along with
    practical information on how to actually use them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提到“清洁代码”时，我指的是由Robert C. Martin在他的视频（[https://cleancoders.com/videos](https://cleancoders.com/videos)）和书籍《Clean
    Code》（Prentice Hall, 2008）、《Clean Architecture》（Prentice Hall, 2017），以及与Micah
    Martin合著的《Agile Principles, Patterns, and Practices in C#》（Pearson, 2006）中宣扬的编码实践，以及他汇编的“SOLID”原则（单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）。当这些原则在书中出现时，我会全面解释清洁代码原则，并附带如何实际使用它们的实用信息。
- en: At the end of the day, why bother writing clean code? Clean code works like
    a washing machine for bugs and incorrect functionality. If we put our codebase
    in the clean code washing machine, as shown in figure 1.3, we see that once you
    refactor something to be more “clean,” bugs come out and incorrect functionality
    stares at you with no place to hide. After all, “it all comes out in the wash.”
    Of course, it is also risky to refactor production code; often unintended side
    effects are introduced. This makes it difficult for management to approve big
    refactors without added functionality. However, with the right tools (some of
    which are discussed in this book), you can minimize the chances of negative side
    effects and improve the quality of the codebase.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到头来，为什么还要编写清洁代码呢？清洁代码就像一个用于错误和不正确功能的洗衣机。如果我们把我们的代码库放入图1.3所示的清洁代码洗衣机中，我们会看到，一旦你重构某样东西使其更加“清洁”，错误就会显现出来，不正确的功能会毫无藏身之处地盯着你。毕竟，“所有的东西都会在洗涤中显现出来。”当然，重构生产代码也有风险；常常会引入意外的副作用。这使得管理层在没有增加功能的情况下很难批准大的重构。然而，有了正确的工具（本书中讨论了一些），你可以最大限度地减少负面副作用的可能性，并提高代码库的质量。
- en: '![](../Images/01_03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3](../Images/01_03.png)'
- en: Figure 1.3 Clean code is like a washing machine for your code. It takes your
    dirty laundry (your code), adds soap and water (clean code principles), and separates
    the dirt from the clothes (separates the bugs from the code). What it leaves you
    with are clothes (code) with less dirt (bugs) than you started with.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 清洁代码就像你的代码的洗衣机。它将你的脏衣服（你的代码）放入，加入肥皂和水（清洁代码原则），并将污垢从衣服中分离出来（将错误从代码中分离出来）。它留给你的衣服（代码）比开始时更干净（错误更少）。
- en: This book contains sidebars with information on clean code topics. If the sidebars
    are clean code related, I denote them as such and explain both the concepts and
    how to apply them to the real world. Appendix B contains a clean code checklist.
    You can use the checklist to determine whether you need to refactor existing code.
    The checklist serves as a reminder for some of the more forgettable (but still
    important) concepts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书包含了关于代码整洁性的侧边栏信息。如果侧边栏与代码整洁性相关，我会将其标记为相关内容，并解释这些概念以及如何将它们应用到现实世界中。附录B包含了一个代码整洁性检查清单。你可以使用这个清单来判断是否需要对现有代码进行重构。这个清单可以作为一些容易忘记（但仍然重要）的概念的提醒。
- en: 1.4 What you will learn in this book
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 你将在本书中学到什么
- en: 'This book will teach you to write idiomatic and clean C# code. It does not
    teach the C# language, .NET 5, or programming from the ground up. We follow a
    pratical approach: a business scenario in which we refactor an old API to be more
    clean and secure. Along the way, you’ll learn many things. A few highlights follow:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将教你编写符合习惯用法和整洁性的C#代码。它不教授C#语言、.NET 5或从头开始的编程。我们采用一种实用方法：在一个业务场景中，我们将旧API重构得更加整洁和安全。在这个过程中，你会学到很多东西。以下是一些亮点：
- en: Taking an old codebase and refactoring it for security, performance, and cleanliness
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对旧代码库进行重构以提高安全性、性能和整洁性
- en: Writing self-documenting code that can pass any code review
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自文档化的代码，使其能够通过任何代码审查
- en: Using test-driven development to write unit tests alongside your implementation
    code
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试驱动开发与实现代码并行编写单元测试
- en: Safely connecting to a cloud database through Entity Framework Core
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Entity Framework Core安全地连接到云数据库
- en: Introducing clean code principles into an existing codebase
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码整洁性原则引入现有代码库
- en: Reading Common Intermediate Language and explaining the C# compilation process
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读通用中间语言并解释C#编译过程
- en: So, what do you need to know to get the most out of this book? The expectation
    is that you understand the basic principles of object-oriented programming (inheritance,
    encapsulation, abstraction, and polymorphism) and are familiar with another programming
    language that supports developing code through an object-oriented approach (be
    it C++, Go, Python, or Java).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为了充分利用这本书，你需要了解哪些内容呢？预期是，你理解面向对象编程的基本原则（继承、封装、抽象和多态），并且熟悉支持通过面向对象方法开发代码的另一种编程语言（无论是C++、Go、Python还是Java）。
- en: After reading this book, you’ll write clean, secure, testable C# code that follows
    good object-oriented design principles. Additionally, you’ll be ready to further
    deepen your knowledge in C# through advanced resources. Some suggested readings
    for after this book are Jon Skeet’s *C# in Depth*, 4th edition (Manning, 2019),
    Jeffrey Richter’s *CLR via C#*, 4th edition (Microsoft Press, 2012), Bill Wagner’s
    *Effective C#*, 2nd edition (Microsoft Press, 2016), Dustin Metzgar’s *.NET Core
    in Action* (Manning, 2018), John Smith’s *Entity Framework Core in Action*, 2nd
    edition (Manning, 2021), and Andrew Lock’s *ASP.NET Core in Action*, 2nd edition
    (Manning, 2021).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书后，你将能够编写符合良好面向对象设计原则的整洁、安全、可测试的C#代码。此外，你将准备好通过高级资源进一步深化你的C#知识。本书之后的一些推荐阅读包括Jon
    Skeet的《C#深度探索》第4版（Manning，2019年），Jeffrey Richter的《CLR via C#》第4版（Microsoft Press，2012年），Bill
    Wagner的《Effective C#》第2版（Microsoft Press，2016年），Dustin Metzgar的《.NET Core in Action》（Manning，2018年），John
    Smith的《Entity Framework Core in Action》第2版（Manning，2021年），以及Andrew Lock的《ASP.NET
    Core in Action》第2版（Manning，2021年）。
- en: 1.5 What you will not learn in this book
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 你在本书中不会学到什么
- en: This book aims to fill the gap between beginner and advanced C# resources. With
    that goal come some consequences regarding what assumptions I make about your
    understanding of C# and programming. As briefly discussed here, I expect you to
    have some professional programming experience and that you are comfortable with
    either the basics of C# or a different object-oriented programming language.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在填补初学者和高级C#资源之间的差距。为此，我对你对C#和编程的理解做出了一些假设。正如在此简要讨论的，我预期你有一些专业的编程经验，并且对C#的基础知识或另一种面向对象编程语言感到舒适。
- en: 'What do I mean by that? To get the most out of this book, you should understand
    object-oriented principles and be able to develop basic applications or APIs in
    your favorite programming language. As a result, this book does not teach you
    some of the following topics often present in a beginner programming book:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我这是什么意思？为了最大限度地利用这本书，你应该理解面向对象原则，并且能够使用你喜欢的编程语言开发基本的应用程序或API。因此，这本书不会教授一些通常出现在初学者编程书中的以下主题：
- en: The C# language itself. This is not a book along the lines of Code C# from Scratch.
    Instead, I teach you how to take your existing C# or object-oriented programming
    knowledge to the next level.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#语言本身。这不是一本从零开始学习C#的书籍。相反，我教你如何将你现有的C#或面向对象编程知识提升到下一个层次。
- en: Syntax around conditionals and branching statements not specific to C# (`if`,
    `for`, `foreach`, `while`, `do-while`, etc.).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与条件语句和分支语句相关的语法，这些语句不是特定于C#的（`if`、`for`、`foreach`、`while`、`do-while`等）。
- en: What polymorphism, encapsulation, and inheritance are (although we use these
    concepts regularly in this book).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性、封装和继承是什么（尽管我们在本书中经常使用这些概念）。
- en: What a class is and how we model real-world objects through classes.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类以及我们如何通过类来模拟现实世界的对象。
- en: What a variable is, or how to assign a value to one.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是什么，或者如何给一个变量赋值。
- en: If you are new to programming, I highly recommend going through a book such
    as Jennifer Greene’s *Head First C#*, 4th edition (O’Reilly, 2020) or Harold Abelson,
    Gerald Jay Sussman, and Julie Sussman’s *Structure and Interpretation of Computer
    Programs*, 2nd edition (The MIT Press, 1996)[²](#pgfId-1172317) before reading
    this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个编程新手，我强烈推荐在阅读这本书之前，先阅读像Jennifer Greene的《Head First C#》第4版（O’Reilly，2020年）或Harold
    Abelson、Gerald Jay Sussman和Julie Sussman的《计算机程序的结构与解释》第2版（麻省理工学院出版社，1996年）这样的书籍[²](#pgfId-1172317)。
- en: 'This book also doesn’t cover these more specialized ways to use C#:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本书也没有涵盖这些更专业的C#使用方式：
- en: Microservice architecture. This book does not go into depth on what microservices
    are and how to use them. Microservice architecture is very much the trend and
    is useful in many use cases but is not related to C# or how you code like a pro.
    Three wonderful resources to learn more about microservices are Chris Richardson’s
    *Microservices Patterns* (Manning, 2018), Prabath Siriwardena and Nuwan Dias’s
    *Microservices Security in Action* (Manning, 2019), and Christian Horsdal Gammelgaard’s
    *Microservices in .NET Core* (Manning, 2020).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构。本书并没有深入探讨微服务是什么以及如何使用它们。微服务架构是一个非常流行的趋势，在许多用例中都很有用，但它与C#或如何像专业人士一样编码无关。学习更多关于微服务的三个优秀资源是Chris
    Richardson的《Microservices Patterns》（Manning，2018年），Prabath Siriwardena和Nuwan Dias的《Microservices
    Security in Action》（Manning，2019年），以及Christian Horsdal Gammelgaard的《Microservices
    in .NET Core》（Manning，2020年）。
- en: How to use C# with containerized environments such as Kubernetes and/or Docker.
    Although very practical and used in many enterprise development environments,
    knowing how to use Kubernetes or Docker does not guarantee you can “code like
    a pro” in C#. To learn more about these technologies, see Marko Lukša’s *Kubernetes
    in Action*, 2nd edition (Manning, 2021), Elton Stoneman’s *Learn Docker in a Month
    of Lunches* (Manning, 2020), and Ashley Davis’s *Bootstrapping Microservices with
    Docker, Kubernetes, and Terraform* (Manning, 2021).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Kubernetes和/或Docker等容器化环境中使用C#。尽管非常实用并且在许多企业级开发环境中使用，但知道如何使用Kubernetes或Docker并不能保证你能在C#中“像专业人士一样编码”。要了解更多关于这些技术，请参阅Marko
    Lukša的《Kubernetes in Action》第2版（Manning，2021年），Elton Stoneman的《Learn Docker in
    a Month of Lunches》（Manning，2020年），以及Ashley Davis的《Bootstrapping Microservices
    with Docker, Kubernetes, and Terraform》（Manning，2021年）。
- en: Concurrency with C# beyond multithreading and locks (discussed inchapter 6).
    We often find this topic in highly threaded and performance-critical scenarios.
    Most developers don’t work with such code much. If you do find yourself in that
    position, an excellent resource to learn more about concurrent programming in
    C# is Joe Duffy’s *Concurrent Programming on Windows* (Addison-Wesley, 2008).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越多线程和锁的C#并发（在第6章中讨论）。我们经常在高度线程化和性能关键的场景中遇到这个话题。大多数开发者并不经常与这样的代码打交道。如果你发现自己处于那种位置，学习更多关于C#并发编程的绝佳资源是Joe
    Duffy的《Windows上的并发编程》（Addison-Wesley，2008年）。
- en: The deep internal details of either the CLR or the .NET Framework themselves.
    Although the CLR and .NET 5 are interesting, knowing every little detail about
    them is of little practical use for most developers. This book covers the CLR
    and .NET Framework in some detail but stops where things get unpractical or unwieldy.
    The “bible” for the CLR and .NET Framework is Jeffrey Richter’s *CLR via C#*,
    4th edition (Microsoft Press, 2012).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR或.NET Framework本身的深层内部细节。尽管CLR和.NET 5很有趣，但了解它们的每一个细节对大多数开发者来说几乎没有实际用途。本书对CLR和.NET
    Framework进行了详细阐述，但停止在事情变得不实用或不便处理的地方。“CLR和.NET Framework的圣经”是Jeffrey Richter的《CLR
    via C#》第4版（微软出版社，2012年）。
- en: You have two ways to read this book. The recommended way is to read the entire
    book, front to back and in order. If you are interested only in refactoring and
    best practices, you can just read parts 3 through 6.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两种阅读这本书的方式。推荐的方式是从头到尾、按顺序阅读整本书。如果您只对重构和最佳实践感兴趣，您只需阅读第3部分至第6部分即可。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This book doesn’t cover “Programming 101.” It assumes knowledge of object-oriented
    programming. This allows us to focus on practical concepts.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书不涵盖“编程101”。它假设您已经了解面向对象编程。这使得我们可以专注于实际概念。
- en: C# and .NET 5 shine at scalable enterprise development with a focus on stability
    and maintainability. This makes C# and .NET a perfect platform of choice for both
    companies and individual developers.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#和.NET 5在可扩展的企业开发方面表现出色，重点在于稳定性和可维护性。这使得C#和.NET成为公司和个人开发者理想的选择平台。
- en: C# and .NET 5 do not shine at operating system development, RTOS-embedded development,
    or numerical computing (or analysis). For those tasks, C and MATLAB fit better.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#和.NET 5在操作系统开发、RTOS-嵌入式开发或数值计算（或分析）方面并不出色。对于这些任务，C和MATLAB更为合适。
- en: '* * *'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)The name “Mesa” is a pun, referring to the programming language being high
    level, just like an isolated, elevated hill with a flat top.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）名称“Mesa”是一个双关语，指的是编程语言是高级的，就像一个孤立、高耸、顶部平坦的小山一样。
- en: ^(2.)Available for free from The MIT Press at [https://mitpress.mit.edu/sites/default/files/sicp/index.html](https://mitpress.mit.edu/sites/default/files/sicp/index.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2.）可以从麻省理工学院出版社免费获取[https://mitpress.mit.edu/sites/default/files/sicp/index.html](https://mitpress.mit.edu/sites/default/files/sicp/index.html)。
