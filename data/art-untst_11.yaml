- en: 8 Maintainability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 可维护性
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Root causes of failing tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败测试的根本原因
- en: Common avoidable changes to test code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的可避免的测试代码更改
- en: Improving the maintainability of tests that aren’t currently failing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高当前未失败的测试的可维护性
- en: Tests can enable us to develop faster, unless they make us go slower due to
    all the changes needed. If we can avoid changing existing tests when we change
    production code, we can start to hope that our tests are helping rather than hurting
    our bottom line. In this chapter, we’ll focus on the maintainability of tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以使我们开发得更快，除非它们因为所有必要的更改而使我们放慢速度。如果我们能在更改生产代码时避免更改现有的测试，我们就可以开始希望我们的测试是在帮助而不是伤害我们的底线。在本章中，我们将重点关注测试的可维护性。
- en: Unmaintainable tests can ruin project schedules and are often set aside when
    the project is put on a more aggressive schedule. Developers will simply stop
    maintaining and fixing tests that take too long to change or that need to change
    often as the result of very minor production code changes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不可维护的测试会破坏项目进度，当项目被安排在一个更积极的进度表上时，它们通常会被搁置。开发者会简单地停止维护和修复那些更改时间过长或由于非常小的生产代码更改而需要经常更改的测试。
- en: 'If maintainability is a measure of how often we are forced to change tests,
    we’d like to minimize the number of times that happens. This forces us to ask
    these questions if we ever want to get down to the root causes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可维护性是衡量我们被迫更改测试的频率的指标，我们希望最小化这种情况发生的次数。这迫使我们提出这些问题，如果我们想深入了解根本原因的话：
- en: When do we notice that a test fails and therefore might require a change?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们何时注意到测试失败，因此可能需要更改？
- en: Why do tests fail?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么测试会失败？
- en: Which test failures force us to change the test?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些测试失败迫使我们更改测试？
- en: When do we choose to change a test even if we are not forced to?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们没有被迫改变测试时，我们选择何时改变测试？
- en: This chapter presents a series of practices related to maintainability that
    you can use when doing test reviews.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列与可维护性相关的实践，您可以在进行测试审查时使用。
- en: 8.1 Changes forced by failing tests
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 由失败测试引起的更改
- en: A failing test is usually the first sign of potential trouble for maintainability.
    Of course, we could have found a real bug in production code, but when that’s
    not the case, what other reasons do tests have to fail? I’ll refer to genuine
    failures as *true failures*, and failures that happen for reasons other than finding
    a bug in the underlying production code as *false failures*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个失败的测试通常是维护性潜在问题的第一个迹象。当然，我们可能在生产代码中找到了一个真正的错误，但如果没有这种情况，测试还有哪些其他原因会导致失败？我将真正的失败称为*真实失败*，将除在底层生产代码中找到错误之外的其他原因导致的失败称为*虚假失败*。
- en: 'If we wanted to measure test maintainability, we could start by measuring the
    number of false test failures, and the reason for each failure, over time. We
    already discussed one such reason in chapter 7: when a test contains a bug. Let’s
    now discuss other possible reasons for false failures.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要衡量测试的可维护性，我们可以从测量随着时间的推移中错误的测试失败次数以及每次失败的原因开始。我们在第7章中已经讨论了一个这样的原因：当一个测试包含一个错误时。现在让我们讨论其他可能导致错误失败的可能原因。
- en: 8.1.1 The test is not relevant or conflicts with another test
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 测试不再相关或与另一个测试冲突
- en: A conflict may arise when the production code introduces a new feature that’s
    in direct conflict with one or more existing tests. Instead of the test discovering
    a bug, it may discover conflicting or new requirements. There might also be a
    passing test that targets the new expectation for how the production code should
    work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产代码引入一个与一个或多个现有测试直接冲突的新功能时，可能会出现冲突。而不是测试发现一个错误，它可能会发现冲突或新的需求。也可能有一个通过测试，它针对生产代码应该如何工作的新期望。
- en: Either the existing failing test is no longer relevant, or the new requirement
    is wrong. Assuming that the requirement is correct, you can probably go ahead
    and delete the no-longer-relevant test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要么现有的失败测试不再相关，要么新的需求是错误的。假设需求是正确的，你可能会继续删除不再相关的测试。
- en: 'Note that there’s a common exception to the “remove the test” rule: when you’re
    working with *feature toggles*. We’ll touch on feature toggles in chapter 10 when
    we discuss testing strategies.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有一个常见的例外是“删除测试”规则：当你与*功能开关*一起工作时。当我们讨论测试策略时，在第10章中我们将涉及到功能开关。
- en: 8.1.2 Changes in the production code’s API
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 生产代码API的变化
- en: A test can fail if the production code under test changes so that a function
    or object being tested now needs to be used differently, even though it may still
    have the same functionality. Such false failures fall in the bucket of “let’s
    avoid this as much as possible.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被测试的生产代码发生变化，使得现在需要以不同的方式使用正在测试的函数或对象，即使它可能仍然具有相同的功能，测试可能会失败。这种错误失败属于“我们应尽可能避免这种情况”的范畴。
- en: 'Consider the `PasswordVerifier` class in listing 8.1, which requires two constructor
    parameters:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑列表8.1中的`PasswordVerifier`类，它需要两个构造函数参数：
- en: An array of `rules` (each is a function that takes an input and returns a Boolean)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`rules`数组（每个都是一个接收输入并返回布尔值的函数）
- en: An `ILogger` interface
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ILogger`接口
- en: Listing 8.1 A Password Verifier with two constructor parameters
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 具有两个构造函数参数的密码验证器
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We could write a couple of tests like the following.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一些像下面的测试。
- en: Listing 8.2 Tests without factory functions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 无工厂函数的测试
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Test using the code’s existing API
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用代码现有API进行测试
- en: If we look at these tests from a maintainability point of view, there are several
    potential changes we will likely need to make in the future.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从可维护性的角度来看这些测试，我们预计未来可能需要做出几个潜在的改变。
- en: Code usually lives for a long time
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通常会有很长的生命周期
- en: Consider that the code you’re writing will live in the codebase for at least
    4-6 years and sometimes a decade. Over that time, what is the likelihood that
    the design of `PasswordVerifier` will change? Even simple things, like the constructor
    accepting more parameters, or the parameter types changing, become more likely
    over a longer timeframe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你正在编写的代码将在代码库中至少存在4-6年，有时甚至十年。在这段时间里，`PasswordVerifier`的设计发生变化的概率有多大？即使是简单的事情，比如构造函数接受更多的参数，或者参数类型发生变化，在更长的时间内变得更有可能。
- en: 'Let’s list a few changes that could happen to our Password Verifier in the
    future:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出一些未来可能发生到我们的密码验证器上的更改：
- en: We may add or remove a parameter in the constructor for `PasswordVerifier`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会为`PasswordVerifier`的构造函数添加或删除参数。
- en: One of the parameters for `PasswordVerifier` may change to a different type.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PasswordVerifier`的一个参数可能改变为不同的类型。'
- en: The number of `ILogger` functions or their signatures may change over time.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILogger`函数的数量或它们的签名可能会随时间变化。'
- en: The usage pattern changes so we don’t need to instantiate a new `PasswordVerifier`,
    but just use the functions in it directly.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式发生了变化，所以我们不需要实例化一个新的`PasswordVerifier`，而是直接使用其中的函数。
- en: If any of these things happen, how many tests would we need to change? Right
    now we’d need to change all the tests that instantiate `PasswordVerifier`. Could
    we prevent the need for some of these changes?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生任何这些事情，我们需要更改多少测试？目前，我们需要更改所有实例化`PasswordVerifier`的测试。我们能否防止需要一些这些更改？
- en: Let’s pretend the future is here and our fears have come true—someone changed
    the production code’s API. Let’s say the constructor signature has changed to
    use `IComplicatedLogger` instead of `ILogger`, as follows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设未来已经到来，我们的担忧已经成真——有人改变了生产代码的API。让我们说构造函数签名已经更改，现在使用`IComplicatedLogger`而不是`ILogger`，如下所示。
- en: Listing 8.3 A breaking change in a constructor
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 构造函数中的破坏性更改
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As it stands, we would have to change any test that directly instantiates `PasswordVerifier`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照现状，我们可能需要更改任何直接实例化`PasswordVerifier`的测试。
- en: Factory functions decouple creation of object under test
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数解耦测试对象的创建
- en: A simple way to avoid this pain in the future is to decouple or abstract away
    the creation of the code under test so that the changes to the constructor only
    need to be dealt with in a centralized location. A function whose sole purpose
    is to create and preconfigure an instance of an object is usually called a *factory*
    function or method. A more advanced version of this (which we won’t cover here)
    is the Object Mother pattern.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 避免未来这种痛苦的一个简单方法是将测试代码的创建解耦或抽象出来，这样对构造函数的更改只需要在集中位置处理。一个唯一目的是创建和预配置对象实例的函数通常被称为*工厂*函数或方法。这种更高级的版本（我们在这里不会涉及）是Object
    Mother模式。
- en: Factory functions can help us mitigate this issue. The next two listings show
    how we could have initially written the tests before the signature change, and
    how we could easily adapt to the signature change in that case. In listing 8.4,
    the creation of `PasswordVerifier` has been extracted into its own centralized
    factory function. I’ve done the same for the `fakeLogger`—it’s now also created
    using its own separate factory function. If any of the changes we listed before
    happens in the future, we’ll only need to change our factory functions; the tests
    will usually not need to be touched.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数可以帮助我们减轻这个问题。接下来的两个列表显示了在签名更改之前我们如何最初编写测试，以及在这种情况下如何轻松适应签名更改。在列表8.4中，`PasswordVerifier`的创建已经被提取到它自己的集中化工厂函数中。我也为`fakeLogger`做了同样的事情——现在它也是通过它自己的单独工厂函数创建的。如果未来发生我们之前列出的任何更改，我们只需要更改我们的工厂函数；通常不需要触摸测试。
- en: Listing 8.4 Refactoring to factory functions
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 重构为工厂函数
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A centralized point for creating a fakeLogger
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建fakeLogger的集中点
- en: ❷ A centralized point for creating a PasswordVerifier
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建PasswordVerifier的集中点
- en: ❸ Using the factory function to create PasswordVerifier
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用工厂函数创建PasswordVerifier
- en: In the following listing, I’ve refactored the tests based on the signature change.
    Notice that the change doesn’t involve changing the tests, but only the factory
    functions. That’s the type of manageable change I can live with in a real project.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我根据签名更改重构了测试。请注意，这个更改并不涉及更改测试，而只是工厂函数。这就是我可以在实际项目中接受的那种可管理的更改。
- en: Listing 8.5 Refactoring factory methods to fit a new signature
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 重构工厂方法以适应新签名
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 8.1.3 Changes in other tests
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 其他测试中的更改
- en: A lack of test isolation is a huge cause of test blockage—I’ve seen this while
    consulting and working on unit tests. The basic concept you should keep in mind
    is that a test should always run in its own little world, isolated from other
    tests even if they verify the same functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 测试隔离不足是测试阻塞的一个主要原因——我在咨询和编写单元测试时见过这种情况。你应该记住的基本概念是，一个测试应该始终在自己的小世界中运行，即使它们验证相同的功能，也应该与其他测试隔离。
- en: The test that cried “fail”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 哭着“失败”的测试
- en: One project I was involved in had unit tests behaving strangely, and they got
    even stranger as time went on. A test would fail and then suddenly pass for a
    couple of days straight. A day later, it would fail, seemingly randomly, and other
    times it would pass even if code was changed to remove or change its behavior.
    It got to the point where developers would tell each other, “Ah, it’s OK. If it
    sometimes passes, that means it passes.”
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与的一个项目中，单元测试表现得很奇怪，随着时间的推移，它们变得更加奇怪。一个测试会失败，然后突然连续几天通过。一天后，它会随机失败，有时即使代码被更改以删除或改变其行为，它也会通过。到了开发者会告诉彼此，“哦，没关系。如果它有时通过，那就意味着它通过了。”的地步。
- en: Properly investigated, it turned out that the test was calling out a different
    (and flaky) test as part of its code, and when the other test failed, it would
    break the first test.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 经过适当调查，我们发现测试在代码中调用了一个不同的（且不可靠的）测试，当其他测试失败时，它会破坏第一个测试。
- en: It took us three days to untangle the mess, after spending a month trying various
    workarounds for the situation. When we finally had the test working correctly,
    we discovered that we had a bunch of real bugs in our code that we were ignoring
    because the test had its own bugs and issues. The story of the boy who cried wolf
    holds true even in development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了各种解决方案一个月后，我们花了三天时间理清了混乱，当我们最终使测试正常工作时，我们发现我们代码中有一堆我们因为测试有自身的错误和问题而忽略的真正错误。狼来了的故事即使在开发中也是成立的。
- en: When tests aren’t isolated well, they can step on each other’s toes, making
    you regret deciding to try unit testing and promising yourself never again. I’ve
    seen this happen. Developers don’t bother looking for problems in the tests, so
    when there’s a problem, it can take a lot of time to find out what’s wrong. The
    easiest symptom is what I call “constrained test order.”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试没有很好地隔离时，它们可能会互相干扰，让你后悔决定尝试单元测试并承诺自己再也不这样做。我见过这种情况发生。开发者懒得在测试中寻找问题，所以当有问题时，找出问题可能需要花费很多时间。最容易的症状就是我所说的“受限测试顺序”。
- en: Constrained test order
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 受限测试顺序
- en: A *constrained test order* happens when a test assumes that a previous test
    executed first, or did not execute first, because it relies on some shared state
    that is set up or reset by the other test. For example, if one test changes a
    shared variable in memory or some external resource like a database, and another
    test depends on that variable’s value after the first tests’ execution, we have
    a dependency between the tests based on order.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个测试假设先执行了之前的测试，或者没有先执行，因为它依赖于其他测试设置或重置的某些共享状态时，就会发生 *受限的测试顺序*。例如，如果一个测试更改了内存中的共享变量或某些外部资源（如数据库），而另一个测试在第一个测试执行后依赖于该变量的值，那么我们就有了基于顺序的测试之间的依赖关系。
- en: Couple that with the fact that most test runners don’t (and won’t, and maybe
    shouldn’t!) guarantee that tests will run in a specific order. This means that
    if you ran all your tests today, and all your tests a week later with a new version
    of the test runner, the tests might not run in the same order as before.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这样一个事实，即大多数测试运行器不会（也不会，也许不应该！）保证测试将按特定顺序运行。这意味着如果你今天运行了所有测试，一周后使用测试运行器的新版本再次运行所有测试，测试可能不会按之前的顺序运行。
- en: '![08-01](../Images/08-01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](../Images/08-01.png)'
- en: Figure 8.1 A shared `UserCache` instance
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 一个共享的 `UserCache` 实例
- en: To illustrate the problem, let’s look at a simple scenario. Figure 8.1 shows
    a `SpecialApp` object that uses a `UserCache` object. The user cache holds a single
    instance (a singleton) that is shared as a caching mechanism for the application,
    and, incidentally, also for the tests. Listing 8.6 shows the implementation of
    `SpecialApp`, the user cache, and the `IUserDetails` interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，让我们看看一个简单的场景。图 8.1 展示了一个使用 `UserCache` 对象的 `SpecialApp` 对象。用户缓存持有单个实例（一个单例），作为应用程序的缓存机制，顺便说一句，也是测试的缓存机制。列表
    8.6 展示了 `SpecialApp`、用户缓存和 `IUserDetails` 接口的实现。
- en: Listing 8.6 A shared user cache and associated interfaces
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 一个共享的用户缓存及其相关接口
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following listing shows the `SpecialApp` implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 `SpecialApp` 的实现。
- en: Listing 8.7 The `SpecialApp` implementation
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 `SpecialApp` 的实现
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a simplistic implementation for this example, so don’t worry about `SpecialApp`
    too much. Let’s look at the tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的示例实现，所以不必太担心 `SpecialApp`。让我们看看测试。
- en: Listing 8.8 Tests that need to run in a specific order
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 需要按特定顺序运行的测试
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Requires the user cache to be empty
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要用户缓存为空
- en: ❷ Adds a user to the cache
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将用户添加到缓存中
- en: ❸ Requires the cache to contain the user
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 需要缓存包含用户
- en: 'Notice that the first and third tests both rely on the second test. The first
    test requires that the second test has not executed yet, because it needs the
    user cache to be empty. On the other hand, the third test relies on the second
    test to fill up the cache with the expected user. If we run only the third test
    using Jest’s `test.only` keyword, the test would fail:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个和第三个测试都依赖于第二个测试。第一个测试要求第二个测试尚未执行，因为它需要用户缓存为空。另一方面，第三个测试依赖于第二个测试用预期的用户填充缓存。如果我们只使用
    Jest 的 `test.only` 关键字运行第三个测试，该测试将失败：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This antipattern usually happens when we try to reuse parts of tests without
    extracting helper functions. We end up expecting a different test to run first,
    saving us from doing some of the setup. This works, until it doesn’t.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式通常发生在我们尝试重用测试的一部分而不提取辅助函数时。我们最终期望不同的测试先运行，从而避免进行一些设置。这可以工作，直到它不行了。
- en: 'We can refactor this in a few steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分几个步骤进行重构：
- en: Extract a helper function for adding a user.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取一个用于添加用户的辅助函数。
- en: Reuse this function for multiple tests.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个测试中重用此函数。
- en: Reset the user cache between tests.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试之间重置用户缓存。
- en: The following listing shows how we could refactor the tests to avoid this problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们如何重构测试以避免这个问题。
- en: Listing 8.9 Refactoring tests to remove order dependence
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 重构测试以消除顺序依赖
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Extracted user-creation helper function
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提取的用户创建辅助函数
- en: ❷ Extracted factory function
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提取的工厂函数
- en: ❸ Resets user cache between tests
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在测试之间重置用户缓存
- en: ❹ New nested describe functions
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 新的嵌套 describe 函数
- en: ❺ Calls reusable helper functions
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用可重用的辅助函数
- en: 'There are several things going on here. First, we extracted two helper functions:
    a `makeSpecialApp` factory function and an `addDefaultUser` helper function that
    we can reuse. Next, we created a very important `beforeEach` function that resets
    the user cache before each test. Whenever I have a shared resource like that,
    I almost always have a `beforeEach` or `afterEach` function that resets it to
    its original condition before or after the test runs.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个事情在进行中。首先，我们提取了两个辅助函数：一个`makeSpecialApp`工厂函数和一个`addDefaultUser`辅助函数，我们可以重用它。接下来，我们创建了一个非常重要的`beforeEach`函数，在每个测试之前重置用户缓存。每当我有这样的共享资源时，我几乎总是有一个`beforeEach`或`afterEach`函数，在测试运行前后将其重置到原始状态。
- en: The first and the third tests now run in their own little nested `describe`
    structure. They also both use the `makeSpecialApp` factory function, and one of
    them is using `addDefaultUser` to make sure it does not require any other test
    to run first. The second test also runs in its own nested `describe` function
    and reuses the `addDefaultUser` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一个和第三个测试现在运行在自己的小嵌套`describe`结构中。它们也都使用了`makeSpecialApp`工厂函数，其中一个使用了`addDefaultUser`来确保它不需要先运行其他任何测试。第二个测试也运行在自己的嵌套`describe`函数中，并重用了`addDefaultUser`函数。
- en: 8.2 Refactoring to increase maintainability
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 重构以提高可维护性
- en: Up until now, I’ve discussed test failures that force us to make changes. Let’s
    now discuss changes that we *choose* to make, to make tests easier to maintain
    over time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我讨论了迫使我们必须做出更改的测试失败。现在让我们讨论我们*选择*做出的更改，以使测试随着时间的推移更容易维护。
- en: 8.2.1 Avoid testing private or protected methods
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 避免测试私有或受保护的函数
- en: This section applies more to object-oriented languages as well as TypeScript.
    Private or protected methods are usually private for a good reason in the developer’s
    mind. Sometimes it’s to hide implementation details, so that the implementation
    can change later without changing the observable behavior. It could also be for
    security-related or IP-related reasons (obfuscation, for example).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节更多地适用于面向对象的语言以及TypeScript。在开发者的心目中，私有或受保护的函数通常出于良好的原因而保持私有。有时是为了隐藏实现细节，这样实现可以在不改变可观察行为的情况下进行更改。也可能是出于安全相关或知识产权相关的原因（例如，混淆）。
- en: When you test a private method, you’re testing against a contract internal to
    the system. Internal contracts are dynamic, and they can change when you refactor
    the system. When they change, your test could fail because some internal work
    is being done differently, even though the overall functionality of the system
    remains the same. For testing purposes, the public contract (the observable behavior)
    is all you need to care about. Testing the functionality of private methods may
    lead to breaking tests, even though the observable behavior is correct.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你测试私有方法时，你是在测试系统内部的合同。内部合同是动态的，当你对系统进行重构时，它们可能会改变。当它们改变时，你的测试可能会失败，因为某些内部工作以不同的方式进行，尽管系统的整体功能保持不变。从测试的目的来看，公共合同（可观察的行为）是你需要关心的全部。测试私有方法的功能可能会导致测试中断，即使可观察的行为是正确的。
- en: 'Think of it this way: no private method exists in a vacuum. Somewhere down
    the line, something has to call it, or it will never get triggered. Usually there’s
    a public method that ends up invoking this private one, and if not, there’s always
    a public method up the chain of calls that gets invoked. This means that any private
    method is always part of a bigger unit of work, or use case in the system, that
    starts out with a public API and ends with one of the three end results: return
    value, state change, or third-party call (or all three).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想：没有私有方法存在于真空中。在某个地方，必须有人调用它，否则它永远不会被触发。通常有一个公共方法最终调用这个私有方法，如果没有，在调用链中总有一个公共方法被调用。这意味着任何私有方法总是系统中的更大工作单元或用例的一部分，它从公共API开始，以三个结果之一结束：返回值、状态更改或第三方调用（或三者兼有）。
- en: So if you see a private method, find the public use case in the system that
    will exercise it. If you test only the private method and it works, that doesn’t
    mean that the rest of the system is using this private method correctly or handles
    the results it provides correctly. You might have a system that works perfectly
    on the inside, but all that nice inside stuff is used incorrectly from the public
    APIs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你看到一个私有方法，找到系统中将使用它的公共用例。如果你只测试私有方法并且它工作正常，这并不意味着系统的其余部分正确地使用了这个私有方法或正确处理了它提供的结果。你可能有一个内部工作完美无缺的系统，但所有这些美好的内部东西都是从公共API中错误使用的。
- en: Sometimes, if a private method is worth testing, it might be worth making it
    public, static, or at least internal, and defining a public contract against any
    code that uses it. In some cases, the design may be cleaner if you put the method
    in a different class altogether. We’ll look at those approaches in a moment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果一个私有方法值得测试，那么将其公开、静态化或至少内部化，并定义一个公共契约，针对任何使用它的代码，可能是有价值的。在某些情况下，如果将方法放入不同的类中，设计可能会更简洁。我们稍后会探讨这些方法。
- en: Does this mean there should eventually be no private methods in the codebase?
    No. With test-driven design, you usually write tests against methods that are
    public, and those public methods are later refactored into calling smaller, private
    methods. All the while, the tests against the public methods continue to pass.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着代码库中最终不应该有私有方法？不。在使用测试驱动设计的情况下，你通常会对公开的方法编写测试，并且这些公开的方法随后会被重构为调用更小、更私有的方法。在此过程中，对公开方法的测试仍然会通过。
- en: Making methods public
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法公开
- en: Making a method public isn’t necessarily a bad thing. In a more functional world,
    it’s not even an issue. This practice may seem to go against the object-oriented
    principles many of us were raised on, but that’s not always the case.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法公开并不一定是坏事。在一个更功能化的世界中，这甚至不是一个问题。这种做法可能看起来与许多人都接受的面向对象原则相悖，但情况并不总是如此。
- en: Consider that wanting to test a method could mean that the method has a known
    behavior or contract against the calling code. By making it public, you’re making
    this official. By keeping the method private, you tell all the developers who
    come after you that they can change the implementation of the method without worrying
    about unknown code that uses it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到想要测试一个方法可能意味着该方法对调用代码有一个已知的行为或契约。通过将其公开，你使这成为官方的。通过保持方法私有，你告诉所有在你之后到来的开发者，他们可以更改方法的实现，而无需担心使用它的未知代码。
- en: Extracting methods to new classes or modules
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法提取到新的类或模块中
- en: If your method contains a lot of logic that can stand on its own, or it uses
    specialized state variables in the class or module that are relevant only to the
    method in question, it may be a good idea to extract the method into a new class
    or its own module with a specific role in the system. You can then test that class
    separately. Michael Feathers’ *Working Effectively with Legacy Code* (Pearson,
    2004) has some good examples of this technique, and *Clean Code* by Robert Martin
    (Pearson, 2008) can help you figure out when this is a good idea.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法包含大量可以独立存在的逻辑，或者它使用了与特定方法相关的特定状态变量，那么将方法提取到新的类或具有特定系统角色的模块中可能是个好主意。然后你可以单独测试这个类。Michael
    Feathers的《与遗留代码有效工作》（Pearson，2004）中有一些关于这种技术的良好示例，Robert Martin的《代码整洁之道》（Pearson，2008）可以帮助你确定何时这样做是有益的。
- en: Making stateless private methods public and static
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将无状态私有方法公开和静态化
- en: If your method is completely stateless, some people choose to refactor the method
    by making it static (in languages that support this feature). That makes it much
    more testable but also states that the method is a sort of utility method that
    has a known public contract specified by its name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法完全无状态，有些人会选择通过将其改为静态（在支持此特性的语言中）来重构该方法。这使得它更容易测试，但也表明该方法是一种具有已知公共契约的实用方法，该契约由其名称指定。
- en: 8.2.2 Keep tests DRY
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 保持测试DRY（不要重复自己）
- en: Duplication in your unit tests can hurt you, as a developer, just as much as,
    if not more than, duplication in production code. That’s because any change in
    a piece of code that has duplicates will force you to change all the duplicates
    as well. When you’re dealing with tests, there’s more risk of the developer just
    avoiding this trouble and deleting or ignoring tests instead of fixing them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中的重复可能会对你造成伤害，就像在生产代码中的重复一样，甚至可能更多。这是因为任何有重复的代码片段的更改都会迫使你更改所有重复的部分。当你处理测试时，开发者可能会避免这种麻烦，删除或忽略测试而不是修复它们的风险更大。
- en: The DRY (don’t repeat yourself) principle should be in effect in test code just
    as in production code. Duplicated code means there’s more code to change when
    one aspect you test against changes. Changing a constructor or changing the semantics
    of using a class can have a major effect on tests that have a lot of duplicated
    code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: DRY（不要重复自己）原则应该在测试代码中生效，就像在生产代码中一样。重复的代码意味着当你测试的一个方面发生变化时，有更多的代码需要更改。更改构造函数或更改类使用的语义可能会对有大量重复代码的测试产生重大影响。
- en: As we’ve seen in previous examples in this chapter, using helper functions can
    help to reduce duplication in tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面的示例中看到的那样，使用辅助函数可以帮助减少测试中的重复。
- en: warning Removing duplication can also go too far and hurt readability. We’ll
    talk about that in the next chapter, on readability.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：消除重复也可能做得太过分，从而损害可读性。我们将在下一章，关于可读性的章节中讨论这个问题。
- en: 8.2.3 Avoid setup methods
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 避免使用设置方法
- en: I’m not a fan of the `beforeEach` function (also called a *setup* function)
    that happens once before each test and is often used to remove duplication. I
    much prefer using helper functions. Setup functions are too easy to abuse. Developers
    tend to use them for things they weren’t meant for, and tests become less readable
    and less maintainable as a result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是“beforeEach”函数（也称为*设置*函数）的粉丝，这个函数在每个测试之前只发生一次，通常用于消除重复。我更倾向于使用辅助函数。设置函数很容易被滥用。开发者倾向于将它们用于它们本不应用于的事情，结果测试的可读性和可维护性会降低。
- en: 'Many developers abuse setup methods in several ways:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者以几种方式滥用设置方法：
- en: Initializing objects in the setup method that are used in only some tests in
    the file
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置方法中初始化仅用于文件中某些测试的对象
- en: Having setup code that’s lengthy and hard to understand
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有冗长且难以理解的设置代码
- en: Setting up mocks and fake objects within the setup method
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置方法内设置模拟和假对象
- en: 'Also, setup methods have limitations, which you can get around by using simple
    helper methods:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，设置方法也有局限性，你可以通过使用简单的辅助方法来克服这些局限性：
- en: Setup methods can only help when you need to initialize things.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方法只有在需要初始化事物时才能提供帮助。
- en: Setup methods aren’t always the best candidates for duplication removal. Removing
    duplication isn’t always about creating and initializing new instances of objects.
    Sometimes it’s about removing duplication in assertion logic or calling out code
    in a specific way.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方法并不总是消除重复的最佳候选者。消除重复并不总是关于创建和初始化对象的新实例。有时它关于消除断言逻辑中的重复或以特定方式调用代码。
- en: Setup methods can’t have parameters or return values.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方法不能有参数或返回值。
- en: Setup methods can’t be used as factory methods that return values. They’re run
    before the test executes, so they must be more generic in the way they work. Tests
    sometimes need to request specific things or call shared code with a parameter
    for the specific test (for example, retrieving an object and setting its property
    to a specific value).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方法不能用作返回值的工厂方法。它们在测试执行之前运行，因此它们的工作方式必须更通用。测试有时需要请求特定的事物或使用参数调用特定测试的共享代码（例如，检索一个对象并将其属性设置为特定值）。
- en: Setup methods should only contain code that applies to all the tests in the
    current test class, or the method will be harder to read and understand.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方法应仅包含适用于当前测试类中所有测试的代码，否则方法将更难以阅读和理解。
- en: I’ve almost entirely stopped using setup methods for the tests I write. Test
    code should be nice and clean, just like production code, but if your production
    code looks horrible, please don’t use that as a crutch to write unreadable tests.
    Use factory and helper methods, and make the world a better place for the generation
    of developers that will have to maintain your code in 5 or 10 years.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎完全停止使用设置方法来编写测试。测试代码应该既整洁又清晰，就像生产代码一样，但如果你的生产代码看起来很糟糕，请不要将其作为编写难以阅读的测试的借口。使用工厂和辅助方法，并为未来5年或10年将不得不维护你的代码的开发者创造一个更好的世界。
- en: Note We looked at an example of moving from using `beforeEach` to helper functions
    in section 8.2.3 (listing 8.9) and also in chapter 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们在8.2.3节（列表8.9）和第2章中查看了一个从使用`beforeEach`到辅助函数的示例。
- en: 8.2.4 Use parameterized tests to remove duplication
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 使用参数化测试来消除重复
- en: Another great option for replacing setup methods, if all your tests look the
    same, is to use parameterized tests. Different test frameworks in different languages
    support parameterized tests—if you’re using Jest, you can use the built-in `test.each`
    or `it.each` functions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有测试看起来都一样，另一个替换设置方法的绝佳选择是使用参数化测试。不同语言的测试框架支持不同的参数化测试——如果你使用Jest，你可以使用内置的`test.each`或`it.each`函数。
- en: Parameterization helps move the setup logic that would otherwise remain duplicated
    or would reside in the `beforeEach` block to the test’s arrange section. It also
    helps avoid duplication of the assertion logic, as shown in the following listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化有助于将原本可能重复或位于`beforeEach`块中的设置逻辑移动到测试的安排部分。它还有助于避免断言逻辑的重复，如下面的列表所示。
- en: Listing 8.10 Parameterized tests with Jest
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 使用Jest的参数化测试
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Duplicated setup and assertion logic
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重复的设置和断言逻辑
- en: ❷ Test data used for setup and assertion
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于设置和断言的测试数据
- en: ❸ Setup and assertion without duplication
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 无重复的设置和断言
- en: In the first `describe` block, we have two tests that repeat each other with
    different input values and expected outputs. In the second `describe` block, we’re
    using `test.each` to provide an array of arrays, where each subarray lists all
    the values needed for the test function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`describe`块中，我们有两次测试，它们使用不同的输入值和预期输出重复。在第二个`describe`块中，我们使用`test.each`提供一个数组数组，其中每个子数组列出测试函数所需的全部值。
- en: Parameterized tests can help reduce a lot of duplication between tests, but
    we should be careful to only use this technique in cases where we repeat the exact
    same scenario and only change the input and output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试可以帮助减少测试之间的许多重复，但我们应该小心只在重复完全相同的场景，并且只更改输入和输出的情况下使用这种技术。
- en: 8.3 Avoid overspecification
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 避免过度指定
- en: An overspecified test is one that contains assumptions about how a specific
    unit under test (production code) should implement its internal behavior, instead
    of only checking that the observable behavior (exit points) is correct.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过度指定的测试是包含关于特定单元（生产代码）应该如何实现其内部行为的假设的测试，而不是只检查可观察的行为（退出点）是否正确。
- en: 'Here are ways unit tests are often overspecified:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是单元测试通常过度指定的方法：
- en: A test asserts purely internal state in an object under test.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试断言在测试对象中纯粹的内状态。
- en: A test uses multiple mocks.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试使用多个模拟。
- en: A test uses stubs as mocks.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试使用存根作为模拟。
- en: A test assumes a specific order or exact string matches when that isn’t required.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试在不需要时假设特定的顺序或精确的字符串匹配。
- en: Let’s look at some examples of overspecified tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些过度指定测试的例子。
- en: 8.3.1 Internal behavior overspecification with mocks
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 使用模拟的内部行为过度指定
- en: A very common antipattern is to verify that an internal function in a class
    or module is called, instead of checking the exit point of the unit of work. Here’s
    a password verifier that calls an internal function, which the test shouldn’t
    care about.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的反模式是验证一个类或模块中的内部函数是否被调用，而不是检查工作单元的退出点。以下是一个密码验证器，它调用了一个内部函数，而测试不应该关心这一点。
- en: Listing 8.11 Production code that calls a protected function
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 调用受保护函数的生产代码
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Call to the internal function
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用内部函数
- en: ❷ Internal function
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 内部函数
- en: Notice that we’re calling the protected `findFailedRules` function to get a
    result from it, and then doing a calculation on the result.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们调用了受保护的`findFailedRules`函数来从它获取结果，然后对这个结果进行计算。
- en: Here’s our test.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的测试。
- en: Listing 8.12 An overspecified test verifying a call to a protected function
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 验证调用受保护函数的过度指定测试
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Mocking the internal function
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟内部函数
- en: ❷ Verifying the internal function call. Don’t do this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证内部函数调用。不要这样做。
- en: The antipattern here is that we’re proving something that isn’t an exit point.
    We’re checking that the code calls some internal function, but what does that
    really prove? We’re not checking that the calculation was correct on the result;
    we’re simply testing for the sake of testing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的反模式是我们证明了不是退出点的东西。我们检查代码是否调用了某个内部函数，但这实际上证明了什么呢？我们没有检查计算结果是否正确；我们只是在测试。
- en: If the function is returning a value, usually that’s a strong indication that
    we shouldn’t mock that function because the function call itself does not represent
    the exit point. The exit point is the value returned from the `verify()` function.
    We shouldn’t care whether the internal function even exists.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数正在返回一个值，通常这是一个强烈的迹象表明我们不应该模拟该函数，因为函数调用本身并不代表退出点。退出点是`verify()`函数返回的值。我们不应该关心内部函数是否存在。
- en: By verifying against a mock of a protected function that is not an exit point,
    we are coupling our test implementation to the internal implementation of the
    code under test, for no real benefit. When the internal calls change (and they
    will) we will also have to change all the tests associated with these calls, and
    that will not be a positive experience. You can read more about mocks and their
    relation to test fragility in chapter 5 of *Unit Testing Principles, Practices,
    and Patterns* by Vladimir Khorikov (Manning, 2020).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过验证一个受保护函数的模拟（该函数不是退出点），我们将测试实现耦合到被测试代码的内部实现中，这并没有带来真正的益处。当内部调用发生变化（它们会的）时，我们也必须更改所有与这些调用相关的测试，这不会是一个愉快的体验。你可以在
    Vladimir Khorikov 的《单元测试原则、实践和模式》（Manning, 2020）一书的第 5 章中了解更多关于模拟及其与测试脆弱性的关系。
- en: What should we do instead?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做什么呢？
- en: 'Look for the exit point. The real exit point depends on the type of test we
    wish to perform:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找退出点。真正的退出点取决于我们希望执行哪种类型的测试：
- en: '*Value-based test*—For a value-based test, which I would highly recommend you
    lean toward when possible, we look for a return value from the called function.
    In this case, the `verify` function returns a value, so it’s the perfect candidate
    for a value-based test: `pv4.verify("abc")`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于值的测试*—对于基于值的测试，我强烈建议你在可能的情况下倾向于这种测试，我们寻找被调用函数的返回值。在这种情况下，`verify` 函数返回一个值，因此它是基于值测试的完美候选：`pv4.verify("abc")`。'
- en: '*State-based test*—For a state-based test, we look for a sibling function (a
    function that exists at the same level of scope as the entry point) or a sibling
    property that is affected by calling the `verify()` function. For example, `firstname()`
    and `lastname()` could be considered sibling functions. That is where we should
    be asserting. In this codebase, nothing is affected by calling `verify()` that
    is visible at the same level, so it is not a good candidate for state-based testing.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于状态的测试*—对于基于状态的测试，我们寻找一个兄弟函数（一个与入口点处于相同作用域级别的函数）或一个受调用 `verify()` 函数影响的兄弟属性。例如，`firstname()`
    和 `lastname()` 可以被认为是兄弟函数。这就是我们应该进行断言的地方。在这个代码库中，没有东西在相同级别上被 `verify()` 调用所影响，因此它不是一个好的基于状态测试的候选。'
- en: '*Third-party test*—For a third-party test, we would have to use a mock, and
    that would require us to find out where the fire-and-forget location is inside
    the code. The `findFailedRules` function isn’t that, because it is actually delivering
    information back to our `verify()` function. In this case, there’s no real third-party
    dependency that we have to take over.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三方测试*—对于第三方测试，我们可能需要使用模拟，这将要求我们找出代码中“一次性”位置在哪里。`findFailedRules` 函数并不是这样的，因为它实际上是在向我们的
    `verify()` 函数返回信息。在这种情况下，我们没有真正的第三方依赖需要接管。'
- en: 8.3.2 Exact outputs and ordering overspecification
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 精确输出和顺序过度指定
- en: A common antipattern is when a test overspecifies the order and the structure
    of a collection of returned values. It’s often easier to specify the whole collection,
    along with each of its items, in the assertion, but with this approach, we implicitly
    take on the burden of fixing the test when any little detail of the collection
    changes. Instead of using a single huge assertion, we should separate different
    aspects of the verification into smaller, explicit asserts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的反模式是当测试过度指定了返回值集合的顺序和结构。通常在断言中指定整个集合及其每个项目更容易，但采用这种方法，我们隐式地承担了在集合的任何细节发生变化时修复测试的负担。而不是使用单个大的断言，我们应该将验证的不同方面分离成更小、更明确的断言。
- en: The following listing shows a `verify()` function that takes on multiple inputs
    and returns a list of result objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个 `verify()` 函数，它接受多个输入并返回一个结果对象列表。
- en: Listing 8.13 A verifier that returns a list of outputs
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 返回输出列表的验证器
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `verify()` function returns an array of `IResult` objects with an `input`
    and `result` in each. The following listing shows a test that makes an implicit
    check on both the ordering of the results and the structure of each result, as
    well as checking the value of the results.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `verify()` 函数返回一个包含 `IResult` 对象的数组，每个对象都有一个 `input` 和 `result`。以下列表显示了一个测试，它隐式检查了结果的顺序和结构，以及检查结果值。
- en: Listing 8.14 Overspecifying order and schema of the result
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 过度指定结果的顺序和模式
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ A single huge assert
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 单个大的断言
- en: 'How might this test change in the future? Here are quite a few reasons for
    it to change:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在未来可能会如何变化？这里有一些它可能需要变化的原因：
- en: When the length of the `results` array changes
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `results` 数组的长度发生变化时
- en: When each `result` object gains or removes a property (even if the test doesn’t
    care about those properties)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每个 `result` 对象增加或删除一个属性（即使测试不关心这些属性）
- en: When the order of the results changes (even if it might not be important for
    the current test)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当结果顺序发生变化时（即使它可能对当前测试不重要）
- en: If any of these changes happens in the future, but your test is just focused
    on checking the logic of the verifier and the structure of its output, there’s
    going to be a lot of pain involved in maintaining this test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来发生这些变化中的任何一项，但你的测试只是关注检查验证器的逻辑和其输出的结构，那么维护这个测试将会涉及很多痛苦。
- en: We can reduce some of that pain by verifying only the parts that matter to us.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过验证对我们来说重要的部分来减少一些这种痛苦。
- en: Listing 8.15 Ignoring the schema of the results
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 忽略结果的模式
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of providing the full expected output, we can simply assert on the values
    of specific properties in the output. However, we’re still stuck if the order
    of the results changes. If we don’t care about the order, we can simply check
    if the output contains a specific result, as follows.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是提供完整的预期输出，我们可以简单地断言输出中特定属性的值。然而，如果结果顺序发生变化，我们仍然会遇到麻烦。如果我们不关心顺序，我们可以简单地检查输出是否包含特定的结果，如下所示。
- en: Listing 8.16 Ignoring order and schema
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 忽略顺序和模式
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we are using `findResultFor()` to find the specific result for a given
    input. Now the order of the results can change, or extra values can be added,
    but our test will only fail if the calculation of the true or false results changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 `findResultFor()` 来找到给定输入的特定结果。现在结果的顺序可以改变，或添加额外的值，但我们的测试只有在计算真实或假结果发生变化时才会失败。
- en: Another common antipattern people tend to repeat is to assert against hardcoded
    strings in the unit’s return value or properties, when only a specific part of
    a string is necessary. Ask yourself, “Can I check if a string *contains* something
    rather than *equals* something?” Here’s a password verifier that gives us a message
    describing how many rules were broken during a verification.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个人们倾向于重复的常见反模式是在单元的返回值或属性中针对硬编码的字符串进行断言，而只需要字符串的特定部分。问问自己，“我能否检查字符串*包含*某些内容，而不是*等于*某些内容？”以下是一个密码验证器，它给我们一条消息，描述在验证过程中违反了多少规则。
- en: Listing 8.17 A verifier that returns a string message
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 返回字符串消息的验证器
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The following listing shows two tests that use `getMsg()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了两个使用 `getMsg()` 的测试。
- en: Listing 8.18 Overspecifying a string using equality
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 使用等式过度指定字符串
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Overly specific string expectation
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 过于具体的字符串期望
- en: ❷ A better way to assert against a string
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更好地断言字符串的方法
- en: The first test checks that the string exactly equals another string. This backfires
    often, because strings are a form of user interface. We tend to change them slightly
    and embellish them over time. For example, do we care that there is a period at
    the end of the string? Our test requires us to care, but the meat of the assert
    is the correct number being shown (especially since strings change in different
    computer languages or cultures, but numbers usually stay the same).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试检查字符串是否与另一个字符串完全相等。这通常适得其反，因为字符串是一种用户界面。我们倾向于随着时间的推移对其进行轻微的修改和装饰。例如，我们关心字符串末尾是否有句号吗？我们的测试要求我们关心，但断言的核心是显示正确的数字（特别是由于字符串在不同计算机语言或文化中会发生变化，但数字通常保持不变）。
- en: 'The second test simply looks for the “2 failed” string inside the message.
    This makes the test more future-proof: the string might change slightly, but the
    core message remains without forcing us to change the test.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试简单地查找消息中的“2 failed”字符串。这使得测试更具未来性：字符串可能略有变化，但核心信息保持不变，而不需要我们修改测试。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Tests grow and change with the system under test. If we don’t pay attention
    to maintainability, our tests may require so many changes from us that it might
    not be worth changing them. We may instead end up deleting them, and throwing
    away all the hard work that went into creating them. For tests to be useful in
    the long run, they should fail only for reasons we truly care about.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试会随着被测试的系统而增长和变化。如果我们不关注可维护性，我们的测试可能需要我们进行很多修改，这可能不值得修改它们。我们可能最终会删除它们，并丢弃所有投入创建它们的辛勤工作。为了使测试在长期内有用，它们应该只因为真正关心的原因而失败。
- en: A *true failure* is when a test fails because it finds a bug in production code.
    A *false failure* is when a test fails for any other reason.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*真正失败* 是指测试失败是因为它发现了生产代码中的错误。*假失败* 是指测试因其他任何原因而失败。'
- en: To estimate test maintainability, we can measure the number of false test failures
    and the reason for each failure, over time.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了估计测试的可维护性，我们可以随着时间的推移测量错误测试失败的数量和每次失败的原因。
- en: 'A test may falsely fail for multiple reasons: it conflicts with another test
    (in which case, you should just remove it); changes in the production code’s API
    (this can be mitigated by using factory and helper methods); changes in other
    tests (such tests should be decoupled from each other).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可能由于多种原因而错误地失败：它与另一个测试冲突（在这种情况下，你应该只是移除它）；生产代码API的变化（这可以通过使用工厂和辅助方法来缓解）；其他测试的变化（这些测试应该相互解耦）。
- en: Avoid testing private methods. Private methods are implementation details, and
    the resulting tests are going to be fragile. Tests should verify *observable behavior*—behavior
    that is relevant for the end user. Sometimes, the need to test a private method
    is a sign of a missing abstraction, which means the method should be made public
    or even be extracted into a separate class.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免测试私有方法。私有方法是实现细节，由此产生的测试将会很脆弱。测试应该验证*可观察的行为*——对最终用户相关的行为。有时，需要测试私有方法可能是一个缺少抽象的迹象，这意味着该方法应该公开，甚至可以提取到一个单独的类中。
- en: Keep tests DRY. Use helper methods to abstract nonessential details of arrange
    and assert sections. This will simplify your tests without coupling them to each
    other.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持测试DRY。使用辅助方法来抽象安排和断言部分的非必要细节。这将简化你的测试，而不会使它们相互耦合。
- en: Avoid setup methods such as the `beforeEach` function. Once again, use helper
    methods instead. Another option is to parameterize your tests and therefore move
    the content of the `beforeEach` block to the test’s arrange section.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用如`beforeEach`函数这样的设置方法。再次强调，使用辅助方法代替。另一个选择是参数化你的测试，并将`beforeEach`块的内容移动到测试的安排部分。
- en: Avoid overspecification. Examples of overspecification are asserting the private
    state of the code under test, asserting against calls on stubs, or assuming the
    specific order of elements in a result collection or exact string matches when
    that isn’t required.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度指定。过度指定的例子包括断言被测试代码的私有状态、对存根的调用断言，或者在没有要求的情况下假设结果集合中元素的具体顺序或精确字符串匹配。
