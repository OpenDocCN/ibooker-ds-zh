- en: '7  Views & Templates: Jade & EJS'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7  视图与模板：Jade 与 EJS
- en: In the previous chapters, we learned what Express is, how Express works, and
    how to use its routing feature. Starting in this chapter, we're going to stop
    learning about Express!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了 Express 是什么，Express 如何工作，以及如何使用它的路由功能。从本章开始，我们将停止学习 Express！
- en: '...well, okay, not exactly. We''ll still be using Express to power our applications,
    don''t worry. But as we''ve discussed throughout the book so far, Express is unopinionated
    and requires a lot of third-party accessories to make a full-fledged application.
    In this chapter and beyond, we''ll start really digging into some of these modules,
    learning how they work, and how they can make your applications lovely.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '...好吧，好吧，不是完全这样。我们仍然会使用 Express 来驱动我们的应用程序，不用担心。但正如我们在本书前面讨论的那样，Express 是无偏见的，并且需要大量的第三方配件来制作一个完整的应用程序。在本章以及之后，我们将真正深入一些这些模块，学习它们是如何工作的，以及它们如何让你的应用程序变得可爱。'
- en: In this chapter we will talk about views. Views are great. They give us a convenient
    way to dynamically generate content (usually HTML). We've seen a view engine before;
    EJS has helped us inject special variables into HTML. But while EJS gave us a
    conceptual understanding of views, we never really explored everything that Express
    (and the other view engines) had to offer. We'll learn the many ways to inject
    values into templates, see the features of EJS, Jade, and other Express-compatible
    view engines, and some subtleties in the world of views.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论视图。视图很棒。它们为我们提供了一个方便的方式来动态生成内容（通常是 HTML）。我们之前已经见过一个视图引擎；EJS 帮助我们将特殊变量注入到
    HTML 中。但尽管 EJS 给了我们视图的概念性理解，我们从未真正探索过 Express（以及其他视图引擎）所能提供的一切。我们将学习将值注入模板的多种方法，了解
    EJS、Jade 以及其他与 Express 兼容的视图引擎的功能，以及视图世界中的某些微妙之处。
- en: Let's get started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 7.1     Express's view features
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1     Express 的视图功能
- en: 'Before I begin, let me define a term I''ll be using a lot: view engine. When
    I say "view engine", I basically mean "module that does the actual rendering of
    views".'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始之前，让我定义一个我将大量使用的术语：视图引擎。当我提到“视图引擎”时，我基本上是指“执行视图实际渲染的模块”。
- en: Jade and EJS are view engines, and there are many others.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 和 EJS 是视图引擎，还有很多其他的。
- en: American singer-songwriter India.Arie has an excellent song called "Brown Skin".
    About brown skin she sings "I can't tell where yours begins, I can't tell where
    mine ends". Similarly, when I first started using Express views, I was confused
    where Express ended and the view engines began. Luckily, it's not too difficult!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 美国歌手兼词曲作者 India.Arie 有首名为 "Brown Skin" 的优秀歌曲。关于棕色皮肤，她唱道：“我分不清你的开始，也分不清我的结束”。同样，当我第一次开始使用
    Express 视图时，我很困惑 Express 和视图引擎的界限在哪里。幸运的是，这并不太难！
- en: Express is unopinionated about which view engine you use. As long as the view
    engine exposes an API that Express expects, you're good to go. Express offers
    a convenience function to help you render your views; let's take a look.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Express 对你使用的视图引擎没有意见。只要视图引擎暴露了 Express 期望的 API，你就可以开始了。Express 提供了一个便利函数来帮助你渲染视图；让我们看看。
- en: 7.1.1  A simple view rendering
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1  简单的视图渲染
- en: 'We''ve seen simple examples of how to render views before, but just in case,
    here''s an app that renders a simple EJS view:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了如何渲染视图的简单示例，但以防万一，这里有一个渲染简单 EJS 视图的示例应用：
- en: Listing 7.1 Simple view rendering example
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 简单视图渲染示例
- en: '`var express = require("express");  #A` `var path = require("path");  #A`  
    `var app = express();  #A`   `app.set("view engine", "ejs");  #B` `app.set("views",
    path.resolve(__dirname, "views"));  #C`   `app.get("/", function(req, res) { #D`
    `    res.render("index");  }); `  `app.listen(3000);  #E`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");  #A` `var path = require("path");  #A` `var
    app = express();  #A` `app.set("view engine", "ejs");  #B` `app.set("views", path.resolve(__dirname,
    "views"));  #C` `app.get("/", function(req, res) { #D` `    res.render("index"); 
    }); ` `app.listen(3000);  #E`'
- en: '#A First, we require what we need and create our application.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 首先，我们需要引入所需的模块并创建我们的应用程序。'
- en: '#B This tells Express that any file ending in ".ejs" should be rendered with
    whatever comes out of require("ejs"). This is a convention followed by some view
    engines; we''ll later see how to use view engines that don''t conform to this
    convention.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这告诉 Express，任何以 ".ejs" 结尾的文件都应该使用 require("ejs") 输出的内容进行渲染。一些视图引擎遵循这个约定；我们稍后会看到如何使用不遵循此约定的视图引擎。'
- en: '#C This tells Express where your views directory is. It happens to default
    to this, but I much prefer to be explicit. This also makes sure things work on
    Windows.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 这告诉 Express 你的视图目录在哪里。它默认是这样的，但我更喜欢明确指出。这也确保了在 Windows 上也能正常工作。'
- en: '#D When we visit the root, we''ll render a file called "index". This resolves
    to "views/index.ejs", which is then rendered with EJS.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 当我们访问根目录时，我们将渲染一个名为 "index" 的文件。这解析为 "views/index.ejs"，然后使用 EJS 进行渲染。'
- en: '#E This starts the server on port 3000!'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 在端口 3000 上启动服务器！'
- en: Once you've done an `npm install` of EJS (and Express, of course), this should
    work! When you visit the root, it'll find `views/index.ejs` and render it with
    EJS! 99% of the time, you'll do something like this; one view engine all the time.
    But things can get more complicated if you decide to mix things up.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了 EJS（以及当然 Express）的 `npm install`，这应该就能工作！当你访问根目录时，它会找到 `views/index.ejs`
    并使用 EJS 进行渲染！99% 的时间，你会做类似的事情；一直使用一个视图引擎。但如果决定混合使用，事情可能会变得更加复杂。
- en: 7.1.2  A complicated view rendering
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2  复杂的视图渲染
- en: 'Here''s a complex example of rendering a view from a response, using two different
    view engines: Jade and EJS. This should illustrate how crazy this can get:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从响应中渲染视图的复杂示例，使用了两种不同的视图引擎：Jade 和 EJS。这应该能说明这可能会变得多么疯狂：
- en: Listing 7.3 Complex rendering example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 复杂渲染示例
- en: '`var express = require("express");` `var path = require("path");` `var ejs
    = require("ejs");`   `var app = express();`   `app.locals.appName = "Song Lyrics";`
      `app.set("view engine", "jade");` `app.set("views", path.resolve(__dirname,
    "views"));` `app.engine("html", ejs.renderFile);`   `app.use(function(req, res,
    next) {` `  res.locals.userAgent = req.headers["user-agent"];` `  next();` `});`
      `app.get("/about", function(req, res) {` `  res.render("about", {` `    currentUser:
    "india-arie123"` `  });` `});`   `app.get("/contact", function(req, res) {` ` 
    res.render("contact.ejs");` `});`   `app.use(function(req, res) {` `  res.status(404);`
    `  res.render("404.html", {` `    urlAttempted: req.url` `  });` `});`  `app.listen(3000);`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var ejs
    = require("ejs");` `var app = express();` `app.locals.appName = "Song Lyrics";`
    `app.set("view engine", "jade");` `app.set("views", path.resolve(__dirname, "views"));`
    `app.engine("html", ejs.renderFile);` `app.use(function(req, res, next) {` ` 
    res.locals.userAgent = req.headers["user-agent"];` `  next();` `});` `app.get("/about",
    function(req, res) {` `  res.render("about", {` `    currentUser: "india-arie123"`
    `  });` `});` `app.get("/contact", function(req, res) {` `  res.render("contact.ejs");`
    `});` `app.use(function(req, res) {` `  res.status(404);` `  res.render("404.html",
    {` `    urlAttempted: req.url` `  });` `});` `app.listen(3000);`'
- en: 'Here''s what happens when you call `render` in these three cases. While it
    looks complicated at a high level, it''s just a number of straightforward steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在这三种情况下调用 `render` 时，会发生以下情况。虽然从高层次来看看起来很复杂，但实际上只是几个简单的步骤：
- en: 1.  Express builds up the context object every time you call render. These context
    objects will get passed to the view engines when it's time to render. These are
    effectively the variables available to views.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  每次调用 render 时，Express 都会构建上下文对象。当需要渲染时，这些上下文对象将被传递给视图引擎。这些实际上是视图可用的变量。
- en: It first adds all the properties from `app.locals`, an object available to every
    request. Then it adds all the properties in `res.locals`, overwriting anything
    added from `app.locals` if it was present. Finally, it adds the properties of
    the object passed to `render` (once again overwriting any previously-added properties).
    At the end of the day, if we visit `/about`, we'll create a context object with
    three properties: `appName`, `userAgent`, and `currentUser`. `/contact` will only
    have `appName` and `userAgent` in its context, while the 404 handler will have `appName`, `userAgent`,
    and `urlAttempted`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先添加来自 `app.locals` 的所有属性，这是一个对每个请求都可用的对象。然后它添加 `res.locals` 中的所有属性，如果存在，将覆盖来自
    `app.locals` 的任何添加。最后，它添加传递给 `render` 的对象的属性（再次覆盖之前添加的任何属性）。最终，如果我们访问 `/about`，我们将创建一个包含三个属性的上下文对象：`appName`、`userAgent`
    和 `currentUser`。`/contact` 将只有 `appName` 和 `userAgent` 在其上下文中，而 404 处理程序将具有 `appName`、`userAgent`
    和 `urlAttempted`。
- en: 2.  Next, we decide whether view caching is enabled. "View caching" might sound
    like Express caches the entire view rendering process, but it doesn't; it only
    caches the lookup of the view file and its assignment to the proper view engine.
    For example, it will cache the lookup of `views/my_view.ejs` and figure out that
    this view uses EJS, but it won't cache the actual render of the view. A bit misleading!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  接下来，我们决定是否启用视图缓存。"视图缓存"可能听起来像 Express 缓存整个视图渲染过程，但它并不这样做；它只缓存视图文件的查找并将其分配给适当的视图引擎。例如，它会缓存
    `views/my_view.ejs` 的查找，并确定这个视图使用 EJS，但它不会缓存视图的实际渲染。有点误导！
- en: It decides whether view caching is enabled in two ways, only one of which is
    documented.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它以两种方式决定是否启用视图缓存，其中只有一种是文档化的。
- en: 'The documented way: there''s an option that you can set on the app. If `app.enabled("view
    cache")` is truthy, Express will cache the lookup of the view. By default, this
    is disabled in development mode and enabled in production, but you can change
    it yourself with `app.enable("view cache")` or `app.disable("view cache")`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的方法：你可以在应用程序上设置一个选项。如果`app.enabled("view cache")`是布尔值，Express将缓存视图的查找。默认情况下，在开发模式下禁用此功能，在生产模式下启用，但你可以通过`app.enable("view
    cache")`或`app.disable("view cache")`来自定义更改。
- en: 'The undocumented way: if the context object generated in the previous step
    has a truthy property called `cache`, then caching will be enabled for that view.
    This overrides any application settings. This enables you to cache on a view-by-view
    basis, but I think it''s more important to know that it''s there so that you can
    avoid doing it unintentionally!'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 未记录的方法：如果前一步生成的上下文对象有一个名为`cache`的布尔属性，则将为该视图启用缓存。这会覆盖任何应用程序设置。这使你能够按视图逐个缓存，但我认为更重要的是知道它的存在，这样你就可以避免无意中这样做！
- en: 3.  Next, we have to look up where the view file resides and what view engine
    to use. In this case, we want to turn "about" into `/path/to/my/app/views/about.jade` +
    Jade and "contact.ejs" into `/path/to/my/app/views/contact.ejs`+ EJS. The 404
    handler should associate `404.html` with EJS by looking at our earlier call to `app.engine`.
    If we've already done this lookup before and view caching is enabled, we'll pull
    from the cache and skip to the final step. If not, we'll continue on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  接下来，我们必须查找视图文件所在的位置以及要使用哪个视图引擎。在这种情况下，我们希望将“about”转换为`/path/to/my/app/views/about.jade`
    + Jade，将“contact.ejs”转换为`/path/to/my/app/views/contact.ejs` + EJS。404处理程序应该通过查看我们之前对`app.engine`的调用，将`404.html`与EJS关联。如果我们之前已经执行过此查找并且启用了视图缓存，我们将从缓存中提取并跳到最后一步。如果没有，我们将继续执行。
- en: 4.  If you don't supply a file extension (like with "about"), Express appends
    the default you specify. In this case, "about" becomes "about.jade" but "contact.ejs"
    and "404.html" stay the same. If you don't supply an extension and don't supply
    a default view engine, Express will throw an error. Otherwise, it'll continue
    on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果你没有提供文件扩展名（例如，“about”），Express会附加你指定的默认值。在这种情况下，“about”变为“about.jade”，但“contact.ejs”和“404.html”保持不变。如果你没有提供扩展名且没有提供默认视图引擎，Express将抛出错误。否则，它将继续执行。
- en: 5.  Now that we definitely have a file extension, Express looks at the extension
    to determine which engine to use. If it matches any engine you've already specified,
    it'll use that. In this case, it'll match Jade for `about.jade` because it's the
    default. `contact.ejs` will try to `require("ejs")` based on the file extension.
    We explicitly assigned `404.html` to EJS's `renderFile` function, so it'll use
    that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  现在我们确实有一个文件扩展名，Express将查看扩展名以确定要使用哪个引擎。如果它与任何你已指定的引擎匹配，它将使用那个。在这种情况下，它将匹配Jade对`about.jade`，因为它默认如此。`contact.ejs`将根据文件扩展名尝试`require("ejs")`。我们明确地将`404.html`分配给EJS的`renderFile`函数，所以它将使用那个。
- en: 6.  Express looks the file up in your views directory. If it doesn't find the
    file, it throws an error, but it'll continue if it finds something.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  Express在视图目录中查找文件。如果没有找到文件，它将抛出错误，但如果找到了，它将继续执行。
- en: 7.  If view caching is enabled, we cache all this lookup logic for next time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  如果启用了视图缓存，我们将为下一次调用缓存所有这些查找逻辑。
- en: 8.  Finally, we render the view! This calls out to the view engine and is literally
    one line in Express's source code. This is where the view engine takes over and
    produces actual HTML (or whatever you'd like).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  最后，我们渲染视图！这会调用视图引擎，在Express的源代码中实际上只是一行。这就是视图引擎接管并生成实际HTML（或你想要的任何内容）的地方。
- en: This turns out to be a bit hairy, but the 99% case is "I pick one view engine
    and stick with it", so you're likely to be shielded from most of this complexity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点棘手，但99%的情况是“我选择一个视图引擎并坚持下去”，所以你很可能被大多数这种复杂性所屏蔽。
- en: Rendering non-HTML views
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染非HTML视图
- en: 'Express''s default content-type is HTML, so if you don''t do anything special,
    res.render will render your responses and send them to the client as HTML. Most
    of the time, I find this to be enough. But it doesn''t have to be this way! You
    can render plain text, XML, JSON, or whatever you want. Just change the content-type
    by changing the parameter to res.type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Express的默认内容类型是HTML，所以如果你不做任何特殊处理，res.render将渲染你的响应并将它们作为HTML发送到客户端。大多数时候，我发现这已经足够了。但不必非得这样！你可以渲染纯文本、XML、JSON或任何你想要的内容。只需通过更改参数res.type来更改内容类型：
- en: '`app.get("/", function(req, res) {` `  res.type("text");` `  res.render("myview",
    {` `    currentUser: "Gilligan"` `  });` `});`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/", function(req, res) {` `  res.type("text");` `  res.render("myview",
    {` `    currentUser: "Gilligan"` `  });` `});`'
- en: There are often better ways to render some of these things—`res.json`, for example,
    should be used instead of a view that renders JSON—but this option is totally
    available!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有一些更好的方法来渲染这些事物——例如，应该使用 `res.json` 而不是渲染 JSON 的视图——但这个选项完全可用！
- en: '7.1.3  Making all view engines compatible with Express: Consolidate.js'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3  使所有视图引擎与 Express 兼容：Consolidate.js
- en: We've talked about some view engines like EJS and Jade already, but there are
    plenty more that you might want to choose. You might've heard of Mustache, Handlebars,
    or Underscore.js's templating. You might also want to use a Node port of other
    templating languages like Jinja2 or HAML.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些视图引擎，如 EJS 和 Jade，但还有很多其他你可能想要选择的。你可能听说过 Mustache、Handlebars 或 Underscore.js
    的模板。你也可能想要使用其他模板语言的 Node.js 版本，如 Jinja2 或 HAML。
- en: Many of these view engines will "just work" with Express, like EJS and Jade.
    Others, however, don't have an Express-compatible API, and need to be wrapped
    in something Express can understand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些视图引擎将与 Express “直接工作”，如 EJS 和 Jade。然而，其他一些没有 Express 兼容的 API，需要被包裹在 Express
    可以理解的某些东西中。
- en: Enter Consolidate.js (at [https://github.com/tj/consolidate.js](https://github.com/visionmedia/consolidate.js)),
    a library that wraps a ton of view engines to be compatible with Express. It has
    support for the classics like EJS, Jade, Mustache, Handlebars, and Hogan. It supports
    a ton of others, too, in case you're using a more obscure/hipster view engine.
    You can see the whole list of supported engines on the project's page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 Consolidate.js（在 [https://github.com/tj/consolidate.js](https://github.com/visionmedia/consolidate.js)），这是一个封装了大量视图引擎以与
    Express 兼容的库。它支持经典如 EJS、Jade、Mustache、Handlebars 和 Hogan。它还支持许多其他引擎，以防你使用更不常见/另类视图引擎。你可以在项目的页面上查看支持的所有引擎列表。
- en: For example, let's say you're using Walrus, a JavaScript view engine that's
    not compatible with Express out of the box. We'll need to use Consolidate to make
    this compatible with Express.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在使用 Walrus，这是一个与 Express 默认不兼容的 JavaScript 视图引擎。我们需要使用 Consolidate 来使其与
    Express 兼容。
- en: After installing Walrus and Consolidate (with `npm install walrus consolidate`),
    you'll be able to use Walrus with Express!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Walrus 和 Consolidate（使用 `npm install walrus consolidate`）后，你将能够使用 Walrus
    与 Express 一起使用！
- en: Listing 7.4 Rendering with Walrus
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 使用 Walrus 渲染
- en: '`var express = require("express");` `var engines = require("consolidate");
    #A` `var path = require("path");` `var app = express();`   `app.set("view engine",
    "wal");  #B` `app.engine("wal", engines.walrus); #C` `app.set("views", path.resolve(__dirname,
    "views")); #D`   `app.get("/", function(req, res) {  #E` `   res.render("index");
    });`  `app.listen(3000);`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var engines = require("consolidate");
    #A` `var path = require("path");` `var app = express();` `app.set("view engine",
    "wal"); #B` `app.engine("wal", engines.walrus); #C` `app.set("views", path.resolve(__dirname,
    "views")); #D` `app.get("/", function(req, res) {` `   res.render("index"); });`
    `app.listen(3000);`'
- en: '#A First, we must require the Consolidate library. For readability, we place
    it in a variable called "engines".'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 首先，我们必须引入 Consolidate 库。为了可读性，我们将其放置在一个名为 "engines" 的变量中。'
- en: '#B Next, we specify .wal files as our default view file extension.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 接下来，我们指定 .wal 文件作为我们的默认视图文件扩展名。'
- en: '#C Here, we associate.wal files with the Walrus view engine.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 在这里，我们将 .wal 文件与 Walrus 视图引擎关联。'
- en: '#D As usual, we specify our views directory.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 如同往常，我们指定我们的视图目录。'
- en: '#E Finally, we render the view! This will render views/index.wal.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 最后，我们渲染视图！这将渲染 views/index.wal。'
- en: I recommend using Consolidate instead of trying to wrangle non-compatible view
    engines yourself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 Consolidate 而不是自己尝试处理不兼容的视图引擎。
- en: 7.2     Everything you need to know about EJS
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2     关于 EJS 的所有你需要知道的内容
- en: One of the simplest and most popular view engines out there is called EJS, for
    "Embedded JavaScript". It can do templating for simple strings, HTML, plain text—you
    name it—it lightly integrates itself with whatever tool you use. It works in the
    browser and Node.js. If you've ever used ERB from the Ruby world, EJS is very
    similar. In any case, it's pretty simple!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最简单且最受欢迎的视图引擎之一被称为 EJS，代表“嵌入式 JavaScript”。它可以对简单字符串、HTML、纯文本等进行模板化——你叫它什么，它就轻量级地与任何你使用的工具集成。它在浏览器和
    Node.js 中工作。如果你曾经使用过 Ruby 世界中的 ERB，EJS 非常相似。无论如何，它非常简单！
- en: THERE ARE TWO VERSIONS OF EJS OUT THERE There are actually two versions of EJS
    maintained by two different groups of people. They're similar, but not identical.
    The one we'll be using is by TJ Holowaychuck, the creator of Express. If you look
    for a package called "ejs" on npm, this is the one you'll find. But if you visit
    http://embeddedjs.com/, you'll find a very similar library claiming with the same
    name. A lot of the functionality is the same, but it's a different library last
    updated in 2009\. It doesn't work in Node, and it's even got some debatably-sexist
    sentences in its documentation; avoid it!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有 EJS 的两个版本 实际上，有两个不同的群体维护着两个版本的 EJS。它们很相似，但并不完全相同。我们将使用的是由 Express 的创建者 TJ
    Holowaychuck 维护的版本。如果你在 npm 上寻找名为 "ejs" 的包，这就是你将找到的版本。但如果你访问 http://embeddedjs.com/，你会找到一个非常相似的库，它也声称有相同的名字。许多功能都是相同的，但它是一个在
    2009 年最后更新的不同库。它不适用于 Node，甚至在它的文档中还有一些有争议的性别歧视性句子；请避免使用它！
- en: 7.2.1  The syntax of EJS
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 EJS 的语法
- en: EJS can be used for templating HTML, but it can be used for anything. Let's
    take a look at a short bit of EJS, and what that looks like when you render it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 可以用于 HTML 模板，但它可以用于任何东西。让我们看看一段简短的 EJS 代码，以及当你渲染它时它看起来像什么。
- en: Listing 7.5 An EJS template
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 一个 EJS 模板
- en: '`Hi <%= name %>!` `You were born in <%= birthyear %>, so that means you''re[CA]`
    `<%= (new Date()).getFullYear() - birthyear %> years old.` `<% if (career) { -%>`
    `  <%=: career | capitalize %> is a cool career!` `<% } else { -%>` `  Haven''t
    started a career yet? That''s cool.` `<% } -%>``Oh, let''s read your bio: <%-
    bio %> See you later!`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hi <%= name %>!` `You were born in <%= birthyear %>, so that means you''re[CA]`
    `<%= (new Date()).getFullYear() - birthyear %> years old.` `<% if (career) { -%>`
    `  <%=: career | capitalize %> is a cool career!` `<% } else { -%>` `  Haven''t
    started a career yet? That''s cool.` `<% } -%>``Oh, let''s read your bio: <%-
    bio %> See you later!`'
- en: If we passed the following context to EJS...
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将以下上下文传递给 EJS...
- en: Listing 7.6 An EJS context
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 一个 EJS 上下文
- en: '`{` `  name: "Tony Hawk",` `  birthyear: 1968,` `  career: "skateboarding",`
    `  bio: "<b>Tony Hawk</b> is the coolest skateboarder around."``}`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  name: "Tony Hawk",` `  birthyear: 1968,` `  career: "skateboarding",`
    `  bio: "<b>Tony Hawk</b> is the coolest skateboarder around."``}`'
- en: 'Then we''d get the following result (as of 2015, anyway):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们会得到以下结果（至少在 2015 年是这样的）：
- en: '`Hi Tony Hawk!` `You were born in 1968, so that means you''re 47 years old.`
    `Skateboarding is a cool career!``Oh, let''s read your bio: Tony Hawk is the coolest
    skateboarder around. See you later!`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hi Tony Hawk!` `You were born in 1968, so that means you''re 47 years old.`
    `Skateboarding is a cool career!``Oh, let''s read your bio: Tony Hawk is the coolest
    skateboarder around. See you later!`'
- en: 'This little example shows four major features of EJS: JavaScript that''s evaluated,
    escaped, and printed, JavaScript that''s evaluated but not printed, JavaScript
    that''s evaluate and printed (but not escaped for HTML), and filters.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小例子展示了 EJS 的四个主要功能：评估、转义和打印的 JavaScript，评估但不打印的 JavaScript，评估并打印（但不转义 HTML）的
    JavaScript，以及过滤器。
- en: You can print the results of JavaScript expressions in two ways, as we see. `<%
    expression %>` prints the result of the expression, while `<%= expression %>` prints
    the result of the expression and escapes any HTML entities that might be inside.
    In general, I'd recommend using the latter option when you can, because it's more
    secure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式打印 JavaScript 表达式的结果，正如我们所看到的。`<% expression %>` 打印表达式的结果，而 `<%= expression
    %>` 打印表达式的结果，并转义任何可能存在的 HTML 实体。一般来说，当你能使用时，我建议使用后者，因为它更安全。
- en: You can also run arbitrary JavaScript and keep it from being printed. This is
    useful for things like loops and conditionals, as we see in the above example.
    This is done with `<% expression %>`. As you can see, you can use brackets to
    group loops and conditionals across multiple lines. You can also avoid adding
    extraneous newlines with `<% expression -%>` (note the hyphen at the end).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以运行任意 JavaScript 并防止它被打印。这对于像循环和条件语句这样的东西很有用，正如我们在上面的例子中所看到的。这是通过 `<% expression
    %>` 来实现的。正如你所看到的，你可以使用括号来在多行中分组循环和条件语句。你还可以使用 `<% expression -%>` 来避免添加额外的换行（注意结尾的连字符）。
- en: Finally, appending a colon (`:`) to an output will allow filters to be applied.
    Filters take the output of an expression and filter it to change the output. In
    the above example, we use the capitalization filter, but there are plenty of others
    and you can define your own (as we'll see in just a moment!).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在输出后添加一个冒号（`:`）将允许应用过滤器。过滤器会过滤表达式的输出并改变输出。在上面的例子中，我们使用了大写字母过滤器，但还有很多其他的过滤器，你也可以定义自己的过滤器（正如我们马上就会看到的！）。
- en: NOTE If you want to play around with EJS, I made "Try EJS" (at https://evanhahn.github.io/try-EJS/),
    a simple browser app to play around with EJS in your browser. I'll admit it's
    not polished, but it's sufficient for just playing around with EJS in your browser
    and seeing the rendered output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想尝试 EJS，我制作了一个“尝试 EJS”的简单浏览器应用（在 https://evanhahn.github.io/try-EJS/），可以在浏览器中玩
    EJS。我承认它不够完善，但足以在浏览器中尝试 EJS 并查看渲染输出。
- en: INCLUDE-ING OTHER EJS TEMPLATES WITHIN YOUR OWN
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 EJS 模板中包含其他 EJS 模板
- en: EJS also lets you include other EJS templates, too. This is incredibly useful
    for a variety of reasons. You can add headers and footers to pages, split out
    common widgets, and more! If you find yourself writing the same code several times,
    it might be time to use EJS's include feature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 还允许您包含其他 EJS 模板。这非常有用，原因有很多。您可以为页面添加页眉和页脚，分离常见的 widget，等等！如果您发现自己多次编写相同的代码，可能就是时候使用
    EJS 的 include 功能了。
- en: Let's look at two examples.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个例子。
- en: First, let's imagine you have pages that all share the same header and footer.
    Rather than duplicate everything over and over again, you could create a header
    EJS file, a footer EJS file, and then your pages that go "between" the header
    and footer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们想象您有一些共享相同页眉和页脚的页面。而不是一遍又一遍地重复所有内容，您可以创建一个页眉 EJS 文件，一个页脚 EJS 文件，然后是位于页眉和页脚之间的页面。
- en: 'Here''s how a header file (saved at `header.ejs`) might look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个页眉文件（保存为 `header.ejs`）可能的样子：
- en: Listing 7.7 A header EJS file
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 标题 EJS 文件
- en: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `  <link rel="stylesheet"
    href="/the.css">` `  <title><%= appTitle %>/title>` `</head>` `<body>` `  <header>`
    `    <h1><%= appTitle %>``  </header>`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `  <link rel="stylesheet"
    href="/the.css">` `  <title><%= appTitle %>/title>` `</head>` `<body>` `  <header>`
    `    <h1><%= appTitle %>``  </header>`'
- en: 'Then, you''d define a footer in footer.ejs:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您会在 footer.ejs 中定义页脚：
- en: Listing 7.8 A footer EJS file
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 页脚 EJS 文件
- en: '`<footer>` `  All content copyright <%= new Date().getFullYear() %> <%= appName
    %>.` `</footer>` `</body>``</html>`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`<footer>` `  All content copyright <%= new Date().getFullYear() %> <%= appName
    %>.` `</footer>` `</body>``</html>`'
- en: Now that you've defined your header and footer, you can include it in sub-pages
    pretty easily!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了页眉和页脚，您可以在子页面上轻松地包含它们！
- en: Listing 7.9 Including a header and footer from EJS
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 从 EJS 包含页眉和页脚
- en: '`<% include header %>` `  <h1>Welcome to my page!</h1>` `  <p>This is a pretty
    cool page, I must say.</p>``<% include footer %>`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include header %>` `  <h1>欢迎来到我的页面！</h1>` `  <p>这是一个相当酷的页面，我必须说。</p>` `<%
    include footer %>`'
- en: We use include to, well, include other EJS files. Notice that we don't use `<%=
    ... %>` or `<%- ... %>`; everything is finally printed by EJS, not you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 include 来，嗯，包含其他 EJS 文件。请注意，我们不使用 `<%= ... %>` 或 `<%- ... %>`；最终所有内容都是由
    EJS 打印出来的，而不是你。
- en: 'We could also imagine ourselves using this to build a widget. For example,
    let''s say we had a widget that showed user profiles. Given an object called user,
    this template would spit out some HTML for that user. Here''s how `userwidget.ejs`might
    look:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以想象自己使用它来构建小部件。例如，假设我们有一个显示用户资料的 widget。给定一个名为 user 的对象，这个模板会为该用户输出一些 HTML。以下是
    `userwidget.ejs` 可能的样子：
- en: Listing 7.10 A user widget in userwidget.ejs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 用户小部件在 userwidget.ejs 中
- en: '`<div class="user-widget">` `  <img src="<%= user.profilePicture %>">` `  <div
    class="user-name"><%= user.name %></div>` `  <div class="user-bio"><%= user.bio
    %></div>``</div>`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div class="user-widget">` `  <img src="<%= user.profilePicture %>">` `  <div
    class="user-name"><%= user.name %></div>` `  <div class="user-bio"><%= user.bio
    %></div>``</div>`'
- en: Now we can use that template when rendering the current user...
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在渲染当前用户时使用该模板...
- en: Listing 7.11 Rendering a user widget for the current user
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 渲染当前用户的用户小部件
- en: '`<% user = currentUser %>` `<% include userwidget %>`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% user = currentUser %>` `<% include userwidget %>`'
- en: '...or when rendering a list of users.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '...或者当渲染用户列表时。'
- en: Listing 7.12 Rendering a user widget many times
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 多次渲染用户小部件
- en: '`<% userList.forEach(function(user) { %>` `  <% include userwidget %>``<% }
    %>`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% userList.forEach(function(user) { %>` `  <% include userwidget %>``<% }
    %>`'
- en: EJS's include is versatile; it can be used to create templates or to render
    sub-views many times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 的 include 功能非常灵活；它可以用来创建模板或多次渲染子视图。
- en: ADDING YOUR OWN FILTERS
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 添加您自己的过滤器
- en: There are 22 built-in filters, ranging from mathematic operations to array/string
    reversal to sorting. They're often enough for your needs, but sometimes you'll
    want to add your own.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有 22 个内置过滤器，从数学运算到数组/字符串反转到排序。它们通常足以满足您的需求，但有时您可能需要添加自己的。
- en: Assuming you've required EJS into a variable called `ejs`, you simply add a
    property to `ejs.filters`. If we're frequently summing arrays, we might find it
    useful to make our own custom "array summer" filter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经将 EJS 引入到一个名为 `ejs` 的变量中，你只需向 `ejs.filters` 添加一个属性即可。如果我们经常计算数组之和，我们可能会发现创建自己的自定义“数组求和”过滤器很有用。
- en: 'Here''s how we might add such a filter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们可能添加此类过滤器的示例：
- en: Listing 7.13 Add an EJS filter to sum an array
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 添加 EJS 过滤器以计算数组之和
- en: '`ejs.filters.sum = function(arr) {` `  var result = 0;` `  for (var i = 0;
    i < arr.length; i ++) {` `    result += arr[i];` `  }` `  return result;``};`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ejs.filters.sum = function(arr) {` `  var result = 0;` `  for (var i = 0;
    i < arr.length; i ++) {` `    result += arr[i];` `  }` `  return result;``};`'
- en: Now you can use it just like any other filter!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像使用任何其他过滤器一样使用它了！
- en: Listing 7.14 Using our new EJS sum filter
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 使用我们新的 EJS 求和过滤器
- en: '`<%=: myarray | sum %>`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`<%=: myarray | sum %>`'
- en: Pretty simple! There are lots of filters you could dream up—code them as you
    need them!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单！你可以想象出很多过滤器——按需编写它们！
- en: 7.3     Everything you need to know about Jade
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3  关于 Jade 你需要知道的一切
- en: View engines like Handlebars, Mustache, and EJS don't completely replace HTML—they
    augment it with some new features. This is really nice if you have designers,
    for example, who've already learned HTML and don't want to learn a whole new language.
    It's also useful for non-HTML-like templating solutions. If you're in this sort
    of situation, Jade is probably the wrong choice.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 视图引擎如 Handlebars、Mustache 和 EJS 并不完全取代 HTML——它们通过一些新特性来增强它。如果你有设计师，例如，他们已经学会了
    HTML 而不想学习一门全新的语言，这会非常不错。对于非 HTML 类的模板解决方案来说，这也很有用。如果你处于这种情况下，Jade 可能不是最佳选择。
- en: But Jade also promises some other features. It allows you to write far fewer
    lines of code and the lines you write are much prettier. Doctypes are easy; tags
    are nested by indentation, not close tags. It's got a number of EJS-style features
    built into the language, like conditionals and loops. It's more to learn, but
    more powerful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Jade 也承诺了一些其他特性。它允许你编写更少的代码行，而且你写的代码行看起来更漂亮。文档类型很容易；标签通过缩进来嵌套，而不是通过闭合标签。它内置了多个
    EJS 风格的特性，如条件和循环。学习起来更多，但功能更强大。
- en: 7.3.1  The syntax of Jade
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1  Jade 的语法
- en: Languages like HTML are nested. There's a root element (`<html>`) and then various
    sub-elements (like `<head>` and `<body>`), which each have their own sub-elements...and
    so on. HTML and XML choose to have an open (`<a>`) and a close (`</a>`) for each
    element.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 HTML 的语言是嵌套的。有一个根元素 (`<html>`)，然后是各种子元素（如 `<head>` 和 `<body>`），每个子元素都有自己的子元素……以此类推。HTML
    和 XML 选择为每个元素提供一个打开的 (`<a>`) 和一个关闭的 (`</a>`) 标签。
- en: 'Jade takes a different approach by using indentation and a different syntax
    for HTML. Here''s a very simple webpage that uses Jade:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 通过使用缩进和不同的 HTML 语法采取了不同的方法。以下是一个使用 Jade 的非常简单的网页示例：
- en: Listing 7.15 A simple Jade example
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 一个简单的 Jade 示例
- en: '`doctype html` `html(lang="en")  #A` `  head` `    title Hello world!` `  body`
    `    h1 This is a Jade example` `    #container   #B``      p Wow.`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctype html` `html(lang="en")  #A` `  head` `    title Hello world!` `  body`
    `    h1 This is a Jade example` `    #container   #B``      p Wow.`'
- en: '#A Adding attributes to elements looks like function calls. (They look a lot
    like keyworded method calls in Python, if you''re familiar with that!)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 将属性添加到元素看起来像函数调用。（如果你熟悉 Python 中的关键字方法调用，它们看起来非常像！）'
- en: '#B No element is specified, so this is a div.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 没有指定元素，所以这是一个 div。'
- en: 'This turns into the following HTML:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换为以下 HTML：
- en: Listing 7.16 Listing 7.15 rendered as HTML
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16 列表 7.15 渲染为 HTML
- en: '`<!DOCTYPE html>` `<html lang="en">` `  <head>` `    <title>Hello world!</title>`
    `  </head>` `  <body>` `    <h1>This is a Jade example</h1>` `    <div id="container">`
    `      <p>Wow.</p>` `    </div>` `  </body>``</html>`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html lang="en">` `  <head>` `    <title>Hello world!</title>`
    `  </head>` `  <body>` `    <h1>This is a Jade example</h1>` `    <div id="container">`
    `      <p>Wow.</p>` `    </div>` `  </body>``</html>`'
- en: You can play around with Jade on the project's homepage at [http://jade-lang.com/](http://jade-lang.com/)—try
    experimenting to see what happens!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目的首页上尝试 Jade [http://jade-lang.com/](http://jade-lang.com/)——尝试实验看看会发生什么！
- en: 7.3.2  Layouts in Jade
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2  Jade 中的布局
- en: Layouts are an important feature of any templating language. They allow you
    to include, in one form or another, other HTML. This allows you to define your
    header and footer once, and then include them on pages where you need them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是任何模板语言的一个重要特性。它们允许你以某种形式包含其他 HTML。这允许你一次性定义你的页眉和页脚，然后在需要它们的地方包含它们。
- en: A very common case is to define a layout file for your pages. That way, everything
    can have a consistent header and footer while allowing the content to change per
    page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的用例是为你的页面定义一个布局文件。这样，所有页面都可以有一个一致的页眉和页脚，同时允许内容按页面变化。
- en: First, we define the "master" layout. This is the Jade common to every page,
    like a header and footer. This master layout defines empty blocks that are filled
    in by any pages that use this master layout. Let's take a look at an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义 "master" 布局。这是每个页面都通用的 Jade，如页眉和页脚。这个主布局定义了空块，这些块将被使用此主布局的任何页面填充。让我们看看一个例子。
- en: First, let's define a simple layout file. This file will be shared by all of
    our pages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个简单的布局文件。这个文件将由我们所有的页面共享。
- en: Listing 7.15 A simple layout file for Jade
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 Jade 的简单布局文件
- en: '`doctype html` `html`   `  head` `     meta(charset="utf-8")` `     title Cute
    Animals website` `     link(rel="stylesheet" href="the.css")`   `     block header 
    #A`   `  body`   `     h1 Cute Animals website`  `     block body  #B`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctype html` `html`   `  head` `     meta(charset="utf-8")` `     title Cute
    Animals website` `     link(rel="stylesheet" href="the.css")`   `     block header 
    #A`   `  body`   `     h1 Cute Animals website`  `     block body  #B`'
- en: '#A In the parent layout file, we define a "header" block and "body" block.
    These will be used by anyone who extends this layout.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 在父布局文件中，我们定义了一个 "header" 块和 "body" 块。这些将被扩展此布局的任何人使用。'
- en: 'Notice how we''ve defined two blocks with block header and block body. These
    will get filled in by Jade files using this layout. Save that file into layout.jade.
    We can use these in "real" pages that use this layout, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何定义了两个带有 block header 和 block body 的块。这些将被使用此布局的 Jade 文件填充。将此文件保存到 layout.jade。我们可以在使用此布局的
    "真实" 页面中使用这些，如下所示：
- en: Listing 7.16 Using a Jade layout file
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16 使用 Jade 布局文件
- en: '`extends layout.jade` `block body``  p Welcome to my cute animals page!`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends layout.jade` `block body``  p Welcome to my cute animals page!`'
- en: 'That will render the following HTML:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染以下 HTML：
- en: Listing 7.17 The output of using a Jade layout
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17 使用 Jade 布局输出的结果
- en: '`<!DOCTYPE html>` `<html>` `  <head>` `    <meta charset="utf-8">` `    <title>Cute
    Animals website</title>` `    <link rel="stylesheet" href="the.css">` `  </head>`
    `  <body>` `    <h1>Cute Animals website</h1>` `    <p>Welcome to my cute animals
    page!</p>` `  </body>``</html>`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `  <head>` `    <meta charset="utf-8">` `    <title>Cute
    Animals website</title>` `    <link rel="stylesheet" href="the.css">` `  </head>`
    `  <body>` `    <h1>Cute Animals website</h1>` `    <p>Welcome to my cute animals
    page!</p>` `  </body>``</html>`'
- en: Notice that we simply put something in a block when we extend a layout and it's
    magically inserted! Also notice that we don't have to use a block just because
    it's defined -- we never touch the header block because we don't need to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们扩展布局时，我们只需在块中放入一些内容，它就会神奇地插入！也请注意，我们不需要使用块，即使它被定义了——我们从未触摸页眉块，因为我们不需要。
- en: If we wanted to, we could define another page that uses this layout very easily.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，可以非常容易地定义另一个使用此布局的页面。
- en: Listing 7.18 Using a Jade layout file again
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.18 再次使用 Jade 布局文件
- en: '`extends layout.jade` `block body` `  p This is another page using the layout.`
    `  img(src="cute_dog.jpg" alt="A cute dog!")``  p Isn''t that a cute dog!`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends layout.jade` `block body` `  p This is another page using the layout.`
    `  img(src="cute_dog.jpg" alt="A cute dog!")``  p Isn''t that a cute dog!`'
- en: Layouts let us separate out common components, which means we don't have to
    repeat the same code over and over again.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 布局让我们分离出常见的组件，这意味着我们不必一遍又一遍地重复相同的代码。
- en: 7.3.3  Mixins in Jade
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 在 Jade 中的混合
- en: Jade has another cool feature called mixins. Mixins are basically functions
    that you define in your Jade file to cut down on repetitive tasks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 有另一个酷炫的功能叫做混合。混合基本上是你定义在 Jade 文件中的函数，用于减少重复性任务。
- en: 'Let''s re-implement the users widget example from the EJS section. We''ll make
    a widget that''s given an object called user and returns an HTML widget for that
    user. Here''s we might do that:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新实现 EJS 部分的用户小部件示例。我们将创建一个接受一个名为 user 的对象的 widget，并返回该用户的 HTML widget。以下是我们可以这样做的方式：
- en: Listing 7.19 A user widget mixin
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.19 用户小部件混合
- en: '`mixin user-widget(user)` `  .user-widget` `    img(src=user.profilePicture)`
    `    .user-name= user.name` `    .user-bio= user.bio`   `//- Render the user widget
    for the current user` `+user-widget(currentUser)`   `//- Render the user widget
    for a bunch of users` `- each user in userList``  +user-widget(user)`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixin user-widget(user)` `  .user-widget` `    img(src=user.profilePicture)`
    `    .user-name= user.name` `    .user-bio= user.bio`   `//- Render the user widget
    for the current user` `+user-widget(currentUser)`   `//- Render the user widget
    for a bunch of users` `- each user in userList``  +user-widget(user)`'
- en: This would render the user widget for the `currentUser` and for every other
    user in the `userList`. No duplicated code for us!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染 `currentUser` 的用户小部件以及 `userList` 中其他每个用户的用户小部件。我们不需要重复的代码！
- en: That's all that we'll look at with Jade. For more about Jade's syntax, you can
    look at Jade's reference documentation at [http://jade-lang.com/reference/](http://jade-lang.com/reference/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们今天要讨论的 Jade。有关 Jade 语法更详细的内容，你可以查看 Jade 的参考文档，链接为 [http://jade-lang.com/reference/](http://jade-lang.com/reference/).
- en: 7.4     Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4    概述
- en: 'In this chapter, we''ve learned the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下内容：
- en: ·  Express's view system. We learned how to pass variables to views to dynamically
    generate HTML, and we've learned how the view engine works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: · Express 的视图系统。我们学习了如何将变量传递给视图以动态生成 HTML，以及我们学习了视图引擎是如何工作的。
- en: ·  The EJS templating language, to dynamically generate HTML with little bits
    of JavaScript.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: · EJS 模板语言，用一点 JavaScript 动态生成 HTML。
- en: ·  The Jade templating language, to reimagine HTML and dynamically generate
    it with a whole new language.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: · Jade 模板语言，用全新的语言重新构想 HTML 并动态生成它。
