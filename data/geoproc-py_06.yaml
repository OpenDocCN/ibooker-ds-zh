- en: Chapter 7\. Vector analysis with OGR
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章. 使用OGR进行矢量分析
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Determining if geometries share a spatial location
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断几何体是否共享空间位置
- en: Proximity relationships between geometries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何体之间的邻近关系
- en: Now you know how to access existing data and how to build your own geometries
    from scratch, but I see these as gateways to the more interesting task of spatial
    analysis. Without analysis capabilities, spatial data is only useful for making
    maps. Good cartography is essential for many things, but I imagine that even cartographers
    would get bored if new datasets weren’t continually created from various types
    of analyses. Plus, spatial analyses can answer countless questions relating to
    pretty much every discipline. In fact, you’re probably more likely to generate
    new data using the analysis functions described in this chapter than by creating
    geometries vertex by vertex as outlined previously in nauseating detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何访问现有数据以及如何从头开始构建自己的几何体，但我认为这些是通往更有趣的任务——空间分析的门户。没有分析能力，空间数据仅用于制作地图。优秀的制图对于许多事情都是必不可少的，但我想象即使制图员也会感到无聊，如果不断从各种分析中创建新的数据集。此外，空间分析可以回答与几乎所有学科相关的无数问题。事实上，你更有可能使用本章中描述的分析功能生成新的数据，而不是像之前那样逐个顶点地创建几何体。
- en: Spatial analysis with vector data comes down to looking at the spatial relationships
    between two or more geometries. Possible studies range from the extremely simple,
    such as the distance between two points, to much more complex algorithms such
    as network analyses. Have you ever wondered how certain mapping websites can provide
    you with various route options from point A to point B, and even provide travel
    times? That’s network analysis. One easy exercise that I sometimes find entertaining
    is comparing the distance I hiked with the straight-line distance between the
    starting and ending points, because these two distances can be significantly different
    in mountainous terrain. There probably isn’t much use for that particular example
    in my life, other than to satisfy my curiosity, but it’s important information
    for search-and-rescue teams who need to know actual distances. There are plenty
    of other important questions out there waiting to be answered using spatial analysis
    techniques.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矢量数据进行空间分析归结为观察两个或更多几何体之间的空间关系。可能的研究范围从极其简单的，例如两点之间的距离，到更复杂的算法，如网络分析。你是否曾经好奇某些地图网站是如何从点A到点B提供各种路线选项，甚至提供旅行时间？这就是网络分析。有时我发现一个简单的练习很有趣，那就是比较我所徒步的距离与起点和终点之间的直线距离，因为在这两种距离在山地地形中可能会有很大的差异。在我的生活中，这个特定的例子可能没有太大的用途，除了满足我的好奇心之外，但对于需要知道实际距离的搜救队伍来说，这是重要的信息。还有许多其他重要的问题等待使用空间分析技术来解答。
- en: For example, biologists can use the information downloaded from GPS collars
    to study how animals use various habitat types or their reactions to roads or
    other man-made features. Businesses use spatial data to help determine the best
    location for new stores or factories. Utility companies can use this type of data
    to select the best routes to install pipelines or electrical transmission lines,
    and mining companies use geographic information to determine areas that are likely
    rich in resources. If you’re reading this book, it’s likely that you have a specific
    type of analysis in mind, and it’s probably completely different from any of the
    examples mentioned. Spatial analyses are ubiquitous, and in fact, you use these
    sorts of analyses in your daily life when you choose where to live or what route
    to take to the office. OGR provides a good foundation for vector analysis, although
    it’s left to you to implement more-complicated algorithms that you may be interested
    in. This section will introduce you to the basic tools that make up this foundation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，生物学家可以使用从GPS项圈下载的信息来研究动物如何使用各种栖息地类型或它们对道路或其他人造特征的反应。企业使用空间数据来帮助确定新商店或工厂的最佳位置。公用事业公司可以使用此类数据来选择安装管道或输电线路的最佳路线，而采矿公司则使用地理信息来确定可能富含资源的地区。如果你正在阅读这本书，你很可能有特定的分析类型在心中，而且它可能完全不同于之前提到的任何例子。空间分析无处不在，实际上，你在选择居住地或选择上班路线时，每天都在使用这些类型的分析。OGR为矢量分析提供了一个良好的基础，尽管更复杂的算法留给了你自己去实现，这些算法可能对你来说很有趣。本节将介绍构成这个基础的基本工具。
- en: '7.1\. Overlay tools: what’s on top of what?'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 叠加工具：什么在什么之上？
- en: One basic question in geographic analysis is what features occur at the same
    place. Certain entities, such as countries, don’t occur in the same location,
    although they may share borders. Other types of areas, such as the home ranges
    of individual bears, can easily overlap, as can boundaries that aren’t necessarily
    related, such as wetlands and land ownership. Many types of queries are concerned
    with this overlap idea. For example, insurance companies want to know if a parcel
    of land is on a floodplain before they set a premium, or even decide to insure
    it at all. A business looking for land to build a factory on would want to know
    which lots for sale are within an appropriate municipal land use zone. If you’re
    making a map of Stockholm, you’ll want to know which roads, train tracks, and
    parks, among other things, are within city limits.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 地理分析中的一个基本问题是哪些特征出现在同一地点。某些实体，如国家，不会出现在同一位置，尽管它们可能共享边界。其他类型的区域，如个别熊的栖息地，可以轻易重叠，就像不一定相关的边界，如湿地和土地所有权。许多类型的查询都关注这种重叠概念。例如，保险公司想在设定保险费之前知道一块土地是否位于洪泛区，甚至决定是否要投保。一家寻找土地建造工厂的企业想知道哪些待售地块位于适当的市政土地利用区内。如果你正在制作斯德哥尔摩的地图，你将想知道哪些道路、铁路和公园等设施位于城市范围内。
- en: What sorts of overlap tools exist? Several test certain conditions, such as
    `Intersects`, which tells you if two geometries share any space in common. For
    example, in [figure 7.1](#ch07fig01), the line L2 intersects with the line L3
    and the polygon L3\. The polygons P2 and P4 also intersect. You can find out if
    two geometries touch edges, but don’t actually share any area, with `Touches`.
    This is also true for lines L2 and L3, but not L2 and P3, because they do more
    than touch. How about discovering if one geometry is contained completely within
    another? You can test that with either `Contains` or `Within`. Polygon P5 is within
    polygon P1, and P1 contains P5\. See [table 7.1](#ch07table01) for a list of the
    available operations, along with examples for each one from [figure 7.1](#ch07fig01).
    Note that while these functions work with polygons, they don’t work with linear
    rings. All functions return `True` or `False`. More information can be found in
    appendix C. (Appendixes C through E are available online on the Manning Publications
    website at [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python).)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存在哪些重叠工具？一些测试某些条件，例如`Intersects`，它告诉你两个几何形状是否共享任何共同的空间。例如，在[图7.1](#ch07fig01)中，线L2与线L3相交，并与多边形L3相交。多边形P2和P4也相交。你可以使用`Touches`找出两个几何形状是否触碰边缘，但实际上并不共享任何区域，这也是线L2和L3的情况，但不是L2和P3，因为它们不仅仅是触碰。那么，如何发现一个几何形状是否完全包含在另一个几何形状内呢？你可以使用`Contains`或`Within`来测试这一点。多边形P5包含在多边形P1内，P1包含P5。参见[表7.1](#ch07table01)以获取可用操作的列表，以及每个操作从[图7.1](#ch07fig01)中的示例。请注意，虽然这些函数适用于多边形，但它们不适用于线性环。所有函数都返回`True`或`False`。更多信息可以在附录C中找到。（附录C至E可在Manning
    Publications网站上在线获取，网址为[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)。）
- en: Figure 7.1\. Geometries used to get the results of overlay operations that are
    shown in [table 7.1](#ch07table01) and [figure 7.2](#ch07fig02).
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 用于获取[表7.1](#ch07table01)和[图7.2](#ch07fig02)中显示的叠加操作结果的几何形状。
- en: '![](07fig01_alt.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig01_alt.jpg)'
- en: Table 7.1\. Functions to test relationships between geometries. These all return
    `True` or `False`
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.1\. 测试几何形状之间关系的函数。这些函数都返回`True`或`False`
- en: '| Operation | Examples from [figure 7.1](#ch07fig01) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | [图7.1](#ch07fig01)中的示例 |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Intersects | Polygons P2 and P4 intersect. Line L3 and Point B intersect.
    Point A and Polygon P2 intersect. Lines L2 and L3 intersect. Line L2 and Polygon
    P3 intersect. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 相交 | 多边形P2和P4相交。线L3和点B相交。点A和多边形P2相交。线L2和线L3相交。线L2和多边形P3相交。 |'
- en: '| Touches | Polygon P2 and Point A touch. Polygon P5 and Point D do not touch.
    Lines L2 and L3 touch. Lines L1 and L3 do not touch. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 触碰 | 多边形P2和点A触碰。多边形P5和点D不触碰。线L2和线L3触碰。线L1和线L3不触碰。 |'
- en: '| Crosses | Lines L1 and L3 cross. Lines L2 and L3 do not cross. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 交叉 | 线L1和线L3交叉。线L2和线L3不相交。 |'
- en: '| Within | Line L1 is within Polygon P2. Line L3 is not within Polygon P2.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 包含 | 线L1包含在多边形P2内。线L3不包含在多边形P2内。 |'
- en: '| Contains | Polygon P1 contains Polygon P5. Polygon P2 does not contain Polygon
    P4. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 包含 | 多边形P1包含多边形P5。多边形P2不包含多边形P4。 |'
- en: '| Overlaps | Polygons P2 and P4 overlap. Polygons P1 and P5 do not overlap.
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 重叠 | 多边形P2和P4重叠。多边形P1和P5不重叠。 |'
- en: '| Disjoint | Polygon P1 and Line L1 are disjoint. Polygons P1 and P4 are disjoint.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 不相交 | 多边形 P1 和线 L1 不相交。多边形 P1 和 P4 不相交。 |'
- en: Several functions create new geometries based on the spatial relationships of
    existing geometries. For example, you can use `Intersection` to get a new geometry
    that represents only the area that two others have in common. In [figure 7.1](#ch07fig01),
    the intersection of L1 and L3 is a single point; the intersection of L2 and P3
    is a short segment from L2; and the intersection of P2 and P4 is shown in [figure
    7.2](#ch07fig02). You would probably use `Intersection` to create new datasets
    containing features only found within the Stockholm boundary when making the map
    mentioned earlier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 几个函数基于现有几何形状的空间关系创建新的几何形状。例如，您可以使用 `Intersection` 获取一个新几何形状，它仅表示两个其他几何形状共有的区域。在图
    7.1 中，L1 和 L3 的交集是一个单点；L2 和 P3 的交集是 L2 上的一个短段；P2 和 P4 的交集如图 7.2 所示。您可能会使用 `Intersection`
    创建新的数据集，其中只包含在之前提到的地图中找到的斯德哥尔摩边界内的特征。
- en: Figure 7.2\. The results of several overlay operations on the P2 and P4 geometries
    from [figure 7.1](#ch07fig01) are shown as hatched areas with dark outlines.
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 在图 7.1 中的 P2 和 P4 几何形状上进行的几个叠加操作的结果，以带有深色轮廓的阴影区域表示。
- en: '![](07fig02_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02_alt.jpg)'
- en: You can combine the areas of two existing geometries into one with `Union`,
    which may return a geometry collection if the input geometries are different types.
    You can treat a geometry collection kind of like a multigeometry, except that
    the parts don’t all need to be the same kind of geometry. For example, the union
    of L2 and P3 is a geometry collection containing a polygon and two lines, as shown
    in [figure 7.3](#ch07fig03). The section of L2 that intersects P3 no longer exists
    as a line, and instead the space it takes up is included in the polygon. The union
    of P2 and P4 is a single polygon, as shown in [figure 7.2](#ch07fig02). You might
    use this function if you were given a roads dataset in which the roads were broken
    up into segments based on changes in speed limits, which would be required for
    an analysis looking at travel time, but you want each road to be a single feature
    so it’s easier to use in a map.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Union` 将两个现有几何形状的面积合并成一个，如果输入的几何形状是不同类型，则可能返回一个几何集合。您可以将几何集合视为多几何形状，但各部分不需要都是同一种几何形状。例如，L2
    和 P3 的并集是一个包含一个多边形和两条线的几何集合，如图 7.3 所示。L2 与 P3 相交的部分不再作为线存在，而是其占据的空间包含在多边形中。P2
    和 P4 的并集是一个单一的多边形，如图 7.2 所示。如果您收到一个道路数据集，其中道路根据速度限制的变化被分割成段，这对于分析旅行时间可能是必需的，但您希望每条道路都是一个单独的特征，以便更容易在地图中使用，那么您可能会使用此功能。
- en: Figure 7.3\. The three parts of the geometry collection created by unioning
    L2 and P3 together.
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. 通过将 L2 和 P3 并联创建的几何集合的三个部分。
- en: '![](07fig03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig03.jpg)'
- en: It’s also possible to clip an intersection out of a geometry so that you’re
    left with the part of the geometry that doesn’t intersect the second geometry.
    Unlike `Intersection` and `Union`, the results from `Difference` depend on which
    geometry the function is called on and which is passed to it. This is also illustrated
    in [figure 7.2](#ch07fig02).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从几何形状中裁剪出交集，这样您就只剩下不与第二个几何形状相交的几何形状的部分。与 `Intersection` 和 `Union` 不同，`Difference`
    的结果取决于函数被调用在哪个几何形状上以及传递给它的哪个几何形状。这也在图 7.2 中得到了说明。
- en: There’s also `SymDifference`, which returns the union of two geometries with
    the intersection removed. If you were looking at the home ranges, or territories,
    of two different mountain lions, you might want to know the area that the first
    cat uses but the second doesn’t, or vice versa. You’d use `Difference` to get
    that information. You could use `SymDifference` to determine the area that was
    used by either lion, but not both. `Intersection` would give you the shared territory,
    and `Union` would provide the combined territories. Each type of information is
    likely useful to a cougar researcher, but each in a different way. In fact, it
    was a study similar to this, although on a threatened species of lizard and much
    more sophisticated than this simplified example, that got me hooked on GIS in
    the first place!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`SymDifference`，它返回两个几何图形的并集，并从中减去交集。如果你正在查看两只不同山狮的活动范围或领地，你可能想知道第一只猫使用的区域，而第二只猫没有使用，或者反之。你可以使用`Difference`来获取这些信息。你可以使用`SymDifference`来确定两只狮子都未使用的区域。`Intersection`会给你共享的领地，而`Union`会提供合并后的领地。每种类型的信息都可能对山狮研究者有用，但以不同的方式。事实上，正是类似这样的研究，尽管是在一种受威胁的蜥蜴物种上，而且比这个简化的例子要复杂得多，让我最初对GIS产生了兴趣！
- en: Let’s look at a concrete example. [Figure 7.4](#ch07fig04) might remind you
    of our discussion of wetlands within the boundaries of New Orleans back in [chapter
    3](kindle_split_011.html#ch03). You’re about to look at two different ways of
    using intersections to determine the percentage of New Orleans made up by wetlands.
    But first, it will be helpful to do a little interactive exercise with the data
    to visualize what’s happening. Open the water bodies shapefile for the United
    States, which contains features such as lakes, streams, canals, and marshes, and
    plot one specific feature that represents a marsh near New Orleans. This shapefile
    has approximately 27,000 features, so don’t try to plot the entire file unless
    you want to wait all day.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个具体的例子。[图7.4](#ch07fig04)可能会让你想起我们在[第3章](kindle_split_011.html#ch03)中讨论的新奥尔良边界内的湿地。你将看到两种不同的使用交集来确定新奥尔良湿地百分比的方法。但在那之前，进行一些与数据相关的互动练习来可视化所发生的情况将会有所帮助。打开包含湖泊、河流、运河和湿地等要素的美国水域形状文件，并绘制一个代表新奥尔良附近湿地的特定要素。这个形状文件大约有27,000个要素，所以除非你愿意等上一整天，否则不要尝试绘制整个文件。
- en: Figure 7.4\. A simple map of New Orleans showing the city boundary, water, and
    wetlands
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4。显示城市边界、水域和湿地的简单新奥尔良地图
- en: '![](07fig04_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig04_alt.jpg)'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should now see something similar to [figure 7.5](#ch07fig05), but without
    the city boundary. Add the New Orleans boundary to provide a little context:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到类似于[图7.5](#ch07fig05)的图像，但没有城市边界。添加新奥尔良的边界以提供一些背景信息：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 7.5\. The New Orleans city boundary is shown as a dashed line overlaid
    on a single, but large, marsh polygon from the United States water bodies dataset.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5。新奥尔良城市边界以虚线形式叠加在来自美国水域数据集的单个但较大的湿地多边形上。
- en: '![](07fig05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig05.jpg)'
- en: 'Now you have two polygons, one for New Orleans and one for a marsh that’s partly
    contained with the New Orleans boundary. Now intersect the two geometries:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个多边形，一个代表新奥尔良，另一个代表部分包含在新奥尔良边界内的湿地。现在将这两个几何图形相交：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can see from [figure 7.6](#ch07fig06) that the intersection geometry consists
    of the area that’s contained within both the city boundary and the marsh polygon.
    How can you use this to figure out how much of New Orleans is wetlands? Well,
    if you intersect the city boundary with all of the wetland polygons that it overlaps,
    then you’ll end up with a bunch of polygons that represent wetlands within the
    boundary. All you need to do then is sum up their areas and divide by the area
    of the New Orleans geometry. Let’s assume that anything in the water bodies dataset
    that’s not a lake is a wetland, and try this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图7.6](#ch07fig06)中可以看出，交集几何图形由同时包含在城市边界和湿地多边形内的区域组成。你如何利用这一点来计算新奥尔良有多少是湿地？嗯，如果你将城市边界与所有与之重叠的湿地多边形相交，那么你最终会得到代表边界内湿地的多个多边形。你只需要将它们的面积相加，然后除以新奥尔良几何图形的面积。假设水域数据集中除湖泊之外的所有内容都是湿地，并尝试这样做：
- en: '![](135fig01_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](135fig01_alt.jpg)'
- en: Figure 7.6\. The result of intersecting the New Orleans boundary with the marsh
    is shown in the hatched area.
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6。新奥尔良边界与湿地相交的结果显示在阴影区域内。
- en: '![](07fig06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig06.jpg)'
- en: The first thing you do is change the attribute filter on the water bodies so
    that lakes, specifically Lake Pontchartrain, are ignored. Then you use a spatial
    filter to toss out all of the features not in the vicinity of New Orleans, which
    gets rid of almost everything in the shapefile. This step isn’t technically necessary,
    but it speeds up processing time considerably because you get to ignore most of
    the dataset. Then you loop through the remaining water bodies, intersect each
    one with the New Orleans geometry, and add the intersection area to a running
    total. When done with the loop, all you needed to do was divide by the area of
    New Orleans to get your answer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要做的是更改水体上的属性过滤器，以便忽略湖泊，特别是庞查特雷恩湖。然后你使用空间过滤器去除所有不在新奥尔良附近的功能，这几乎去除了shapefile中的所有内容。这一步在技术上不是必需的，但它可以显著加快处理时间，因为你可以忽略大部分数据集。然后你遍历剩余的水体，将每个水体与新奥尔良几何体相交，并将相交区域加到累计总和中。当循环完成后，你所需要做的就是除以新奥尔良的面积，以得到你的答案。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Filtering out unneeded features, either with spatial or attribute filters, can
    significantly decrease your processing time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空间或属性过滤器过滤掉不需要的功能可以显著减少你的处理时间。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You have an easier way to do this, however, if you want to work with layers
    instead of individual geometries. In this case, OGR takes care of looping through
    the geometries in the layers for you. Let’s intersect the New Orleans boundary
    with the water layer to get the area in common between the two:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要使用图层而不是单独的几何体来工作，你有一个更简单的方法。在这种情况下，OGR会为你遍历图层中的几何体。让我们将新奥尔良边界与水层相交，以获取两个图层共有的区域：
- en: '![](135fig02_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](135fig02_alt.jpg)'
- en: As before, you limit the water bodies to the non-lakes, but you don’t perform
    a spatial filter because the layer intersection handles that. An empty layer is
    required for a layer intersection, however, so you do need the extra step of creating
    that. Because there’s no reason to save the layer, you use the memory driver to
    create the data source and layer. This driver doesn’t write anything out to disk,
    so it’s a good choice for temporary data. Once you have the empty layer, you pass
    it to the layer `Intersection` function, which populates it with the intersection
    of `nola_lyr` and `water_lyr`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你将水体限制为非湖泊，但你不执行空间过滤器，因为图层相交处理了这一点。然而，图层相交需要一个空图层，所以你需要额外的步骤来创建它。因为你没有理由保存图层，所以你使用内存驱动来创建数据源和图层。这个驱动器不会将任何内容写入磁盘，所以它是临时数据的良好选择。一旦你有了空图层，你将其传递给图层`Intersection`函数，该函数用`nola_lyr`和`water_lyr`的交集填充它。
- en: 'Once you have the intersected area, you can use a SQL statement to sum up the
    areas of all geometries in `temp_lyr`. Remember that `ExecuteSQL` returns a new
    layer object, so you need to get the first feature from it in order to access
    the results of the `SUM` function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了相交区域，你可以使用SQL语句来汇总`temp_lyr`中所有几何体的面积。记住，`ExecuteSQL`返回一个新的图层对象，所以你需要从中获取第一个特征来访问`SUM`函数的结果：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One more important detail is that functions that operate on entire layers instead
    of individual geometries preserve the attribute values from the input layers.
    This is handy if you still need the information about each feature. In this case
    you don’t need it, but think about the mountain lion home range example, but with
    even more cats. The researcher would almost definitely want to know which two
    cougars were sharing the same habitat, and a layer intersection would keep this
    information in the results, assuming it was in the original attribute tables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的细节是，那些在整图层上操作而不是在单独几何体上操作的函数会保留输入图层的属性值。如果你仍然需要每个功能的信息，这会很有用。在这种情况下你不需要它，但想想山狮活动范围示例，但假设有更多的猫。研究人员几乎肯定想知道哪两只美洲狮共享了相同的栖息地，而图层相交会保留这些信息，前提是它们在原始属性表中。
- en: '7.2\. Proximity tools: how far apart are things?'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2. 临近工具：事物之间有多远？
- en: Another common problem when analyzing geographic features is determining how
    far apart they are from one another. For example, many municipalities have regulations
    concerning the types of businesses allowed within a certain distance of a church
    or school, and proximity to a large customer base is another important factor
    when considering business locations. Or how about an ornithologist trying to determine
    how roads affect the nesting sites chosen by various species of birds? He would
    need to measure the distance between each nest and the closest roads as part of
    his study.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析地理特征时，另一个常见问题是确定它们彼此之间的距离。例如，许多市政当局都有关于在教堂或学校一定距离内允许经营的业务类型的法规，而接近大型客户群在考虑商业地点时也是一个重要因素。或者，一个试图确定道路如何影响各种鸟类选择筑巢地点的鸟类学家呢？他需要测量每个巢穴与最近道路之间的距离，作为他研究的一部分。
- en: Two proximity tools are included with OGR, one to measure distance between geometries
    and one to create buffer polygons. A buffer is a polygon that extends out a certain
    distance from the original geometry. [Figure 7.7](#ch07fig07) shows the yard geometries
    from [chapter 6](kindle_split_014.html#ch06) with buffers around them, although
    they’re not in their true yard configuration so that you can see the buffers better.
    You could use a buffer to visualize which businesses were within walking distance
    of your location, or to make sure that you didn’t build a pizza joint within a
    certain distance of an existing one. You could also buffer a stream geometry to
    get an idea of the riparian area surrounding it, or to show where cattle aren’t
    allowed to graze and risk damaging the ecosystem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: OGR包含两个邻近性工具，一个用于测量几何形状之间的距离，另一个用于创建缓冲多边形。缓冲区是从原始几何形状向外延伸一定距离的多边形。[图7.7](#ch07fig07)显示了[第6章](kindle_split_014.html#ch06)中的院子几何形状及其周围的缓冲区，尽管它们不是真正的院子配置，这样您可以更好地看到缓冲区。您可以使用缓冲区来可视化您所在位置附近哪些业务在步行范围内，或者确保您不会在现有业务一定距离内建造比萨饼店。您还可以对溪流几何形状进行缓冲，以了解其周围的河岸区域，或者显示牛不允许放牧以避免破坏生态系统的区域。
- en: Figure 7.7\. The geometries from the make-believe yard shown along with buffer
    geometries. Notice how the buffer for multigeometries becomes a single polygon
    if the individual buffers overlap.
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7. 从虚构的院子中展示的几何形状以及缓冲几何形状。注意，当单个缓冲区重叠时，多几何形状的缓冲区变成一个单边形。
- en: '![](07fig07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig07.jpg)'
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unprojected datasets (those using latitude and longitude) are fine for displaying
    data in many cases, but can be a poor choice when it comes to analysis. Think
    about how the longitudinal lines on a globe converge on the poles. One longitudinal
    degree at 40° latitude is shorter than one degree at the equator, which makes
    comparing distances at different latitudes extremely problematic. You’re much
    better off converting your data to a different coordinate system with a constant
    unit of measure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 未投影的数据集（使用纬度和经度）在许多情况下可以用于显示数据，但在分析时可能是一个较差的选择。想想地球仪上经线在两极汇聚的情况。在40°纬度上，一度经线比赤道上的短，这使得在不同纬度上比较距离变得极其困难。您最好将数据转换为具有恒定测量单位的不同坐标系。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As a buffering example, let’s figure out how many cities in the United States
    are within 10 miles of a volcano. We’ll use datasets that have an Albers projection
    so that the map units are meters instead of decimal degrees. We’ll also use this
    example to highlight a potential source of error when doing analyses like this.
    The first step in your analysis will be to buffer a volcano dataset by 16,000
    meters, which is roughly equivalent to 10 miles. Because there isn’t a buffer
    function on an entire layer, you’ll buffer each volcano point individually and
    add it to a temporary layer. Once that’s done, you can intersect the buffer layer
    with the cities layer to get the number of cities that fall within that 10-mile
    radius. All of this is shown in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为缓冲示例，让我们计算一下美国有多少城市在火山10英里范围内。我们将使用具有阿尔伯斯投影的数据库，这样地图单位就是米而不是十进制度。我们还将使用这个例子来强调在进行分析时可能出现的潜在错误来源。分析的第一步将是将火山数据集缓冲16,000米，这大约相当于10英里。由于整个图层上没有缓冲功能，您需要单独对每个火山点进行缓冲，并将其添加到临时图层中。完成这些后，您可以将缓冲图层与城市图层相交，以获取位于该10英里半径内的城市数量。所有这些都在下面的列表中展示。
- en: Listing 7.1\. A flawed method for determining the number of cities near volcanoes
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1. 确定火山附近城市数量的一个有缺陷的方法
- en: '![](137fig01_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](137fig01_alt.jpg)'
- en: From this you could conclude that that are 83 cities in the United States that
    are within 10 miles of a volcano. But for good measure, try doing the same thing
    with the slightly different method shown in [listing 7.2](#ch07ex02). This time
    you’ll add the buffers to a multipolygon instead of a temporary layer. A function
    called `UnionCascaded` efficiently unions all of the polygons in a multipolygon
    together; you’ll use this to create one polygon from all of the volcano buffers
    and then use the result as a spatial filter on the cities layer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结论中，你可以得出结论，美国有83个城市位于火山10英里范围内。但为了保险起见，尝试使用[列表7.2](#ch07ex02)中显示的略有不同的方法做同样的事情。这次你将把缓冲区添加到一个多边形而不是临时层中。一个名为`UnionCascaded`的函数可以有效地将多边形中的所有多边形合并在一起；你将使用这个函数从所有火山缓冲区创建一个多边形，然后将其作为空间过滤器应用于城市层。
- en: Listing 7.2\. A better method for determining the number of cities near volcanoes
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 确定火山附近城市数量的更好方法
- en: '![](138fig01_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](138fig01_alt.jpg)'
- en: Huh, somehow you lost five cities in the last few minutes, which is a little
    disconcerting. What happened? In the first example, a copy of a city is included
    in the output every time it falls within a volcano buffer. This means a city will
    be included more than once if it’s within 16,000 meters of multiple volcanoes.
    This happened with a few cities, which is why the count from the intersection
    method was wrong, and higher than from the spatial filter method. This is a good
    example of why you should always think through your methodology carefully, because
    the “obvious” solution might be incorrect and provide the wrong results.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，不知怎么的，在过去的几分钟里你失去了五个城市，这有点令人不安。发生了什么事？在第一个例子中，每当一个城市落在火山缓冲区中时，输出中都会包含该城市的副本。这意味着如果一个城市位于多个火山内16,000米范围内，它将被包含多次。一些城市就是这样发生的，这就是为什么交集方法得出的计数是错误的，并且高于空间过滤器方法。这是一个很好的例子，说明了为什么你应该始终仔细思考你的方法论，因为“显而易见”的解决方案可能是错误的，并给出错误的结果。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `UnionCascaded` when you need to union many geometries together. It will
    be much faster than joining them one by one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将许多几何形状合并在一起时，请使用`UnionCascaded`。它将比逐个连接它们快得多。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'We’ll look at one last example. Perhaps you want to know how far a particular
    city is from a certain volcano. The first thing you need to do is get the geometries
    for the city and volcano of interest:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将来看最后一个示例。也许你想知道某个城市与某个火山之间的距离。首先你需要做的是获取感兴趣的城市和火山的几何形状：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you have the geometries, you can use the `Distance` function to ask them
    how far apart they are from each other:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了几何形状，你可以使用`Distance`函数来询问它们之间的距离：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The city of Seattle is approximately 58 miles from Mount Rainier, which is considered
    an active volcano. Of course, you’d get a different answer if you used actual
    city boundaries instead of a point, but I doubt that the fine people of Seattle
    would appreciate the distinction if the mountain did erupt.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 西雅图市大约距离雷尼尔山58英里，雷尼尔山被认为是一座活跃的火山。当然，如果你使用实际的市界而不是一个点，你会得到不同的答案，但我怀疑如果山爆发了，西雅图的好人们不会欣赏这种区别。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**2.5D geometries**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.5D几何形状**'
- en: 'You may remember from the last chapter that geometries with z values are considered
    2.5D in OGR because the z values aren’t used when performing spatial operations.
    To illustrate this, let’s look at the distance between two points:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得上一章中，在OGR中，具有z值的几何形状被认为是2.5D，因为在执行空间操作时不会使用z值。为了说明这一点，让我们看看两点之间的距离：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That returns a distance of 4 units, as expected. Now try the same thing but
    with 2.5D points:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了预期的4个单位的距离。现在尝试用2.5D点做同样的事情：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That also returned a distance of 4, but taking the elevation values into account,
    the real distance is 5\. Clearly, the z values weren’t used in the calculation.
    How about an area example? This polygon is 10 units long on each side, so it should
    have an area of 100:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这也返回了4个单位的距离，但考虑到海拔值，实际距离是5个单位。显然，z值在计算中没有被使用。那么，我们来看一个面积示例？这个多边形的每一边长为10个单位，因此它应该有一个面积为100：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You got the expected result there, but try moving the right-most edge to a
    higher elevation so that the rectangle is in the 3D plane:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你在那里得到了预期的结果，但尝试将最右边的边缘移动到一个更高的海拔，这样矩形就会位于3D平面上：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This new rectangle also claims to have an area of 100 but in reality, the area
    is closer to 141.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的矩形也声称面积是100，但现实中面积更接近141。
- en: 'Overlay operations also ignore the elevation values. For example, if elevation
    were accounted for, `pt1_2d` would be contained in the 2D polygon but not in the
    2.5D one, which isn’t what we see:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 叠加操作也会忽略高程值。例如，如果考虑了高程，`pt1_2d` 将包含在二维多边形中，但不会包含在2.5D多边形中，而这并不是我们所看到的：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you know the basics of spatial analysis with vector data. You might not
    need to do anything more complicated than what you’ve seen here, but if you do,
    these tools are the building blocks with which to start.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了使用矢量数据进行空间分析的基本知识。你可能不需要做比这里更复杂的事情，但如果你需要，这些工具是开始的基础。
- en: '7.3\. Example: locating areas suitable for wind farms'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 示例：定位适合风力农场的区域
- en: Let’s do a simple analysis to look for suitable wind farm locations in Imperial
    County, California. The United States National Renewal Energy Laboratory provides
    a wind dataset that shows areas in the United States that are suitable for wind
    farms based on wind speed and abundance, and geographical factors such as terrain
    ([figure 7.8](#ch07fig08)). Areas are rated on a scale of 1 to 7, where anything
    3 and above is generally considered suitable. We’ll combine this with census data
    to locate areas with an appropriate wind rating and a population less than 0.5
    per square kilometer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个简单的分析，以寻找加利福尼亚州帝国县适合风力农场的位置。美国国家可再生能源实验室提供了一个风力数据集，该数据集显示了基于风速和丰富度以及地形等地理因素的美国哪些地区适合风力农场([图7.8](#ch07fig08))。区域按1到7的等级评分，其中3及以上通常被认为是合适的。我们将结合人口普查数据，以定位具有适当风力评分且人口密度小于每平方公里0.5人的区域。
- en: Figure 7.8\. Census and wind data for Imperial County, CA. The darker the shading,
    the better the wind conditions for a wind farm. The hatched area shows census
    tracts with a population density less than 0.5/km2.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8\. 加利福尼亚州帝国县的人口普查和风速数据。阴影越深，风力农场的风力条件越好。虚线区域显示人口密度小于0.5/km2的人口普查区域。
- en: '![](07fig08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![07fig08.jpg](07fig08.jpg)'
- en: 'The census dataset contains population per census tract, but doesn’t have a
    population density attribute. You can calculate that given the tract area and
    the population, however, so the first thing to do is add a field containing that
    information:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 人口普查数据集包含每个人口普查区域的居民人数，但没有人口密度属性。然而，你可以根据区域面积和人口来计算它，所以首先要做的是添加一个包含该信息的字段：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You open the census shapefile for editing and add a floating-point field. Then
    you loop through each row and calculate the population density. The map units
    for this dataset are meters, so the geometry’s area is square meters, but you
    convert that to square kilometers by dividing by 1,000,000\. You grab the tract
    population from the `HD01_S001` field and divide by the calculated area to get
    population per km².
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你打开人口普查形状文件进行编辑，并添加一个浮点字段。然后，你遍历每一行并计算人口密度。该数据集的地图单位是米，因此几何形状的面积是平方米，但你通过除以1,000,000将其转换为平方公里。你从`HD01_S001`字段中获取区域人口，并将其除以计算出的面积以获得每平方公里的人口数。
- en: Now get the geometry for Imperial County so that you can use it to spatially
    limit your analysis. You don’t need to keep the county data source open after
    cloning the geometry.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在获取帝国县的几何形状，以便你可以用它来对分析进行空间限制。在克隆几何形状后，你不需要保持县数据源打开。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But one problem exists, though. The county data uses coordinates that are latitude
    and longitude values, but the census and wind datasets use meters. You’ll learn
    how to work with different spatial reference systems like these in the next chapter,
    but for now please trust me that this bit of code will convert the county geometry
    to the correct coordinate system:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但存在一个问题。县数据使用的是纬度和经度坐标，而人口普查和风力数据集使用的是米。你将在下一章学习如何处理这些不同的空间参考系统，但在此期间，请相信我，这段代码会将县几何形状转换为正确的坐标系：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the geometry is converted, you use it to set a spatial filter on the census
    tract data so you’ll only be considering tracts in the correct part of the state.
    You also set an attribute filter to further limit the tracts to those with a low
    population density.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦几何形状被转换，你就可以用它来对人口普查区域数据设置空间过滤器，这样你只会考虑位于该州正确部分的人口普查区域。你还可以设置属性过滤器，进一步限制区域为那些人口密度低的区域。
- en: 'Now open the wind dataset and use an attribute filter to limit it to the areas
    with a rating of 3 or better:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开风力数据集，并使用属性过滤器将其限制为评分3或更好的区域：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It makes sense to create a data source to put the results in before starting
    any analysis, so let’s do that now. Create a new shapefile that uses the same
    spatial reference system as the wind data, and then add fields for the wind rating
    and the population density. You might as well use the layer’s definition to create
    an empty feature for inserting data later, too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何分析之前创建一个数据源来存放结果是有意义的，所以现在就让我们这么做。创建一个新的shapefile，使其使用与风速数据相同的空间参考系统，然后添加风速评级和人口密度的字段。你还可以使用图层定义来创建一个空的特征，以便稍后插入数据。
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You’re finally ready to look for possible wind farm locations. In the next listing,
    you’ll loop through the census tracts, intersect them with the suitable wind polygons,
    and put the results in your new shapefile.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你终于准备好寻找可能的风力发电场位置了。在下一个列表中，你将遍历人口普查区，将它们与合适的风力多边形相交，并将结果放入你的新shapefile中。
- en: Listing 7.3\. Intersecting census and wind data
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 人口普查和风速数据相交
- en: '![](142fig01_alt.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](142fig01_alt.jpg)'
- en: You have an extra step to get the results you want, however. Unfortunately,
    the census and county boundaries don’t line up exactly ([figure 7.9](#ch07fig09)),
    which means that a census tract that barely overlaps the county because of this
    data error will be used to select wind polygons even though you don’t need it.
    One way to deal with this is to intersect the census and county polygons so that
    you only use the part of the census polygon that falls within the county polygon
    (for example, the tiny sliver in [figure 7.9](#ch07fig09)). Once you’ve found
    this intersection, then you can use a spatial filter to select the wind polygons
    that it contains or overlaps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你有一个额外的步骤来得到你想要的结果。不幸的是，人口普查和县边界并不完全对齐([图7.9](#ch07fig09))，这意味着由于这个数据错误，几乎与县重叠的人口普查区将被用来选择风力多边形，尽管你不需要它。处理这个问题的一种方法是将人口普查和县多边形相交，这样你只使用位于县多边形内部的人口普查多边形部分（例如，[图7.9](#ch07fig09)中的小条带）。一旦找到这个交集，然后你可以使用空间过滤器来选择它包含或重叠的风力多边形。
- en: Figure 7.9\. The solid census tract boundary doesn’t line up perfectly with
    the dotted county boundary.
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9\. 粗实的人口普查区边界与虚线的县边界并不完全对齐。
- en: '![](07fig09.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig09.jpg)'
- en: After setting the spatial filter, you iterate through the selected wind polygons
    and intersect each of them with the census polygon. This throws out parts of a
    census tract that don’t get enough wind or suitable wind areas with too high of
    a population density. The attribute filter remains in effect, even with the spatial
    filter changes, so this is always limited to the suitable wind polygons. You add
    each of these intersection polygons to the new dataset, along with attributes
    for wind class and population density.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置空间过滤器后，你遍历选定的风力多边形，并将每个多边形与人口普查多边形相交。这会丢弃那些风力不足的部分人口普查区或人口密度过高的适宜风力区域。即使空间过滤器发生变化，属性过滤器仍然有效，所以这始终限于适宜的风力多边形。你将每个这些交集多边形以及风速类别和人口密度属性添加到新的数据集中。
- en: '[Figure 7.10](#ch07fig10) is zoomed in on part of the results. You’re close,
    but it would be nice to have large polygons instead of many small ones. This will
    lose the information about wind suitability class and population density, but
    at this point you know that all of your polygons are appropriate, anyway.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.10](#ch07fig10) 放大了部分结果。你很接近了，但有一个大多边形而不是许多小多边形会更好。这将失去关于风速适宜类别和人口密度的信息，但在这个阶段，你知道所有的多边形都是合适的，无论如何。'
- en: Figure 7.10\. Suitable wind farm locations according to our analysis. The darker
    the shading, the higher the wind rating.
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10\. 根据我们的分析，适合风力发电场的位置。阴影越深，风速评级越高。
- en: '![](07fig10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig10.jpg)'
- en: The fastest way to combine the little polygons into one large one is to use
    the `UnionCascaded` function, which requires that the polygons to be joined are
    all contained in a single multipolygon. It works correctly only if you add individual
    polygons to the multipolygon, however. If you add a multipolygon, then you’ll
    get incorrect results later, so you need to break up any multipolygons created
    by your earlier intersections and add each one individually. The following listing
    shows this process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将小多边形合并成一个大多边形最快的方法是使用`UnionCascaded`函数，该函数要求要连接的多边形都包含在一个单一的多边形中。只有当你将单个多边形添加到多边形中时，它才能正确工作。然而，如果你添加一个多边形，那么你稍后将会得到错误的结果，所以你需要将你之前创建的任何多边形分解，并单独添加每个多边形。以下列表显示了此过程。
- en: Listing 7.4\. Combining small polygons into large ones
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 将小多边形合并成大多边形
- en: '![](ch07ex04-0.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex04-0.jpg)'
- en: '![](ch07ex04-1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex04-1.jpg)'
- en: After you union all of the polygons together into one large multipolygon, you
    go through it and break it up into individual polygons that you add to the new
    shapefile. Small islands of land that aren’t big enough to hold a wind farm can
    be thrown out, so you only keep the polygons with an area of at least a square
    kilometer. The results are shown in [figure 7.11](#ch07fig11), and you can see
    that some of these little polygons that were off by themselves are now gone.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有多边形合并成一个大的多边形之后，你将遍历它们，将它们拆分成单独的多边形，并将它们添加到新的shapefile中。那些不足以容纳风力发电场的小岛屿可以被丢弃，因此你只保留面积至少为一平方公里的多边形。结果如图7.11所示，你可以看到一些原本独立的小多边形现在消失了。
- en: Figure 7.11\. The results from unioning the small polygons in [figure 7.10](#ch07fig10)
    together and throwing out the small island polygons
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11. 将[图7.10](#ch07fig10)中的小多边形合并在一起并丢弃小岛屿多边形的结果
- en: '![](07fig11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig11.jpg)'
- en: A dataset like this, with only large polygons, is probably easier to work with
    than one with many small polygons, as long as you don’t need the information that’s
    lost by joining them all together.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数据集，只有大多边形，可能比有多个小多边形的数据集更容易处理，只要你不需要合并它们所丢失的信息。
- en: '7.4\. Example: animal tracking data'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 示例：动物追踪数据
- en: The website [https://www.movebank.org/](https://www.movebank.org/) has a database
    of animal tracking data for studies all over the world. I downloaded GPS location
    data for Galapagos Albatrosses as a CSV file, but let’s convert it into a shapefile
    and then play with the data a bit. You can use the x and y coordinates from the
    location-long and location-lat columns to create a point and copy that and the
    individual-local-identifier and timestamp columns as attributes. The shapefile
    format doesn’t support true date/time fields, so you’ll keep the timestamp information
    as a string. The code for this is shown in the following listing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 网站[https://www.movebank.org/](https://www.movebank.org/)拥有全球各地动物追踪数据的数据库。我下载了加拉帕戈斯信天翁的GPS位置数据作为一个CSV文件，但让我们将其转换为shapefile，然后对数据进行一些操作。你可以使用位置-长和位置-宽列中的x和y坐标来创建一个点，并将该点以及个体-本地标识符和时间戳列作为属性复制。shapefile格式不支持真正的日期/时间字段，所以你将时间戳信息作为字符串保留。下面的列表显示了这段代码。
- en: Listing 7.5\. Create a shapefile from a .csv file
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5. 从.csv文件创建shapefile
- en: '![](ch07ex05-0.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex05-0.jpg)'
- en: '![](ch07ex05-1.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex05-1.jpg)'
- en: Unfortunately, if you plot this new shapefile or open it up in a GIS, you’ll
    see bad points over by Africa ([figure 7.12](#ch07fig12)). There must have been
    an error with the data collection for these points, so their latitude and longitude
    values are set to 0\. Let’s get rid of them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你绘制这个新的shapefile或者在一个GIS中打开它，你会在非洲附近看到一些坏点（[图7.12](#ch07fig12)）。这些点的数据收集肯定出现了错误，因此它们的纬度和经度值被设置为0。让我们将它们删除。
- en: Figure 7.12\. A few bad GPS locations by Africa instead of South America
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12. 非洲而不是南美洲的一些坏GPS位置
- en: '![](07fig12.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig12.jpg)'
- en: 'Because you know that the bad points have coordinates of (0, 0), you can set
    a spatial filter to select those points and then delete them one by one:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你知道坏点的坐标是(0, 0)，你可以设置一个空间过滤器来选择这些点，然后逐个删除它们：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Don’t forget to use `REPACK` to permanently delete the points and `RECOMPUTE
    EXTENT` to recalculate the shapefile’s spatial extent. Now all of the points are
    between the Galapagos Islands and South America, as shown in [figure 7.13](#ch07fig13).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用`REPACK`永久删除点，并使用`RECOMPUTE EXTENT`重新计算shapefile的空间范围。现在所有点都在加拉帕戈斯群岛和南美洲之间，如图7.13所示。
- en: Figure 7.13\. GPS locations for Galapagos Albatrosses
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.13. 加拉帕戈斯信天翁的GPS位置
- en: '![](07fig13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig13.jpg)'
- en: Now that the bad points are gone, you can think about doing some analysis. The
    first things I think of doing with GPS tracking data from animals are to see how
    far they move and to look at the area they use. Unfortunately, latitude/longitude
    data in degrees isn’t ideal for this, but that’s the coordinate system used by
    these points. Because you won’t learn how to work with spatial references and
    coordinate systems until the next chapter, let’s see how to convert between coordinate
    systems using the ogr2ogr command-line utility. Remember that you need to run
    this from a terminal window or command prompt, not from Python. You’ll also need
    to make sure that you’re in the same folder as the albatross_dd shapefile.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在坏点已经去除了，你可以考虑进行一些分析。我认为首先应该用动物GPS跟踪数据做的是看看它们移动了多远，以及它们使用的区域。不幸的是，以度为单位的地纬度/经度数据并不理想，但这是这些点使用的坐标系统。因为你将在下一章学习如何处理空间参考和坐标系统，所以让我们看看如何使用
    ogr2ogr 命令行工具在坐标系统之间进行转换。记住，你需要从终端窗口或命令提示符中运行此命令，而不是从 Python 中运行。你还需要确保你位于 albatross_dd
    形状文件所在的同一文件夹中。
- en: You’ll convert the coordinates to a system that uses meters rather than degrees
    as units of measure. Not only are meters easier to understand (most people probably
    can’t visualize half a degree very well), but they’re constant, unlike degrees
    that change with latitude. The system you’ll use is called Lambert Conformal Conic,
    and you’ll use a variation of it that’s specific for South America. The parts
    of this command after `-t_srs` and up to `+no_defs` are what define the coordinate
    system. The output will be a shapefile called albatross_lambert.shp.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将坐标转换为使用米而不是度作为度量单位的系统。米更容易理解（大多数人可能很难很好地想象半度），而且它们是恒定的，与随着纬度变化的度不同。你将使用的系统称为兰伯特等角圆锥投影，你将使用其针对南美洲的特定变体。在
    `-t_srs` 和 `+no_defs` 之间的这部分命令定义了坐标系统。输出将是一个名为 albatross_lambert.shp 的形状文件。
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now you’ve got a shapefile that uses meters, so let’s calculate the distance
    between each location. To do this, you need to select the points for an individual
    bird, so let’s write a function that will get unique values from an attribute
    column. You can use the function from the following listing to get `tag_id` values
    in later listings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个使用米的形状文件，让我们计算每个位置之间的距离。为此，你需要选择单个鸟的点，所以让我们编写一个函数，该函数将从一个属性列中获取唯一值。你可以使用以下列表中的函数在后续列表中获取
    `tag_id` 值。
- en: Listing 7.6\. Function to get unique values from an attribute column
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 从属性列获取唯一值的函数
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To calculate distances, you’ll iterate through the points for each bird in order
    and then calculate the distance between each location and the previous one, so
    you’ll need to keep track of the previous point as you loop. The points should
    be in the correct order in the original .csv file, which means they’re also in
    order in the shapefile you created, but you’ll add code to check, just in case.
    If it does find something out of order, it will bail so that you can correct the
    problem. The following listing shows the process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算距离，你需要按顺序遍历每只鸟的点，然后计算每个位置与上一个位置之间的距离，所以你需要在你循环时跟踪上一个点。点应该在原始 .csv 文件中按正确顺序排列，这意味着它们也在你创建的形状文件中按顺序排列，但你会添加代码来检查，以防万一。如果它发现顺序有误，它将退出，这样你就可以纠正问题。下面的列表显示了这个过程。
- en: Listing 7.7\. Calculating distance between adjacent points
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 计算相邻点之间的距离
- en: '![](147fig01_alt.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![147fig01_alt.jpg](147fig01_alt.jpg)'
- en: Before starting the loop, you save the timestamp and point geometry for the
    first location so that you can use it to calculate distance between it and the
    second feature. This increments the current feature, so the loop starts with the
    second feature instead of the first, and you calculate a distance between the
    first and second points in the first iteration. After saving the distance, you
    store the timestamp and geometry for the current feature in your “previous” variables,
    so that the next time through the loop you’ll have this information. If you hadn’t
    stored the current values, you’d always calculate the distance to the first point,
    because that’s the one originally stored in `previous_pt`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始循环之前，你保存了第一个位置的戳记和点几何形状，以便你可以用它来计算它与第二个特征之间的距离。这增加了当前特征的计数，因此循环从第二个特征而不是第一个特征开始，你在第一次迭代中计算第一和第二个点之间的距离。在保存距离后，你将当前特征的戳记和几何形状存储在你的“上一个”变量中，这样在下一次循环中你将拥有这些信息。如果你没有存储当前值，你将始终计算到第一个点的距离，因为那是最初存储在
    `previous_pt` 中的那个点。
- en: 'Now it’s an easy matter to get information about the distances. For example,
    you could use SQL to find out which bird had the longest distance between GPS
    fixes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易获取距离信息。例如，你可以使用SQL找出哪只鸟在GPS修正之间有最长的距离：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first few lines of output look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前几行看起来像这样：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What if later you want to know the maximum travel speed from one point to the
    next? You’ve got the distances, but you need to know the amount of time in between
    GPS readings to calculate speed. The fact that the timestamp field is a string,
    not a date/time, presents a small but easily surmountable problem. Fortunately,
    you can create Python datetime objects from a string as long as you can tell it
    how the string is formatted. The timestamps in your dataset look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后你想知道从一个点到下一个点的最大旅行速度怎么办？你有了距离，但你需要知道GPS读取之间的时间量来计算速度。时间戳字段是一个字符串，而不是日期/时间，这虽然是一个小问题，但很容易解决。幸运的是，只要你告诉它字符串的格式，你就可以从字符串创建Python
    datetime对象。你的数据集中的时间戳看起来像这样：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can create a format string that matches this using the information at [https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior](https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior),
    and then use the `strptime` function to convert the string to a datetime:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用[https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior](https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior)中的信息创建一个匹配的格式字符串，然后使用`strptime`函数将字符串转换为日期时间：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The following listing shows how to use this information to find the maximum
    travel speed between each location. This won’t be completely accurate because
    it’s probably rare that a bird has been flying the entire time between readings,
    but at least it’s a start.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用这些信息来找到每个位置之间的最大旅行速度。这不会完全准确，因为一只鸟在读取之间一直在飞行的可能性可能很小，但至少这是一个开始。
- en: Listing 7.8\. Find maximum speed from locations and elapsed time
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8. 从位置和经过时间找到最大速度
- en: '![](148fig01_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](148fig01_alt.jpg)'
- en: As with finding distance, you need to keep track of the previous point so that
    you can find the length of time between GPS fixes. After getting that information,
    you divide the distance by the number of hours between readings to get speed in
    meters per hour.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与寻找距离一样，你需要跟踪前一个点，以便找到GPS修正之间的时间长度。得到这些信息后，你将距离除以读取之间的小时数，以获得每小时的米数速度。
- en: Now let’s take a look at the areas used by each bird. Sophisticated methods
    are available for determining an animal’s home range, but we’ll use convex hull
    polygons because they’re simple and OGR has them built in. To do this, you need
    to put the points for each bird into a multipoint geometry that can then be used
    to create the convex hull polygons, as shown in the following listing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看每只鸟使用的区域。有复杂的方法可以确定动物的活动范围，但我们将使用凸包多边形，因为它们简单，并且OGR内置了这些功能。为此，你需要将每只鸟的点放入一个多点几何体中，然后可以使用它来创建凸包多边形，如下面的列表所示。
- en: Listing 7.9\. Create convex hull polygons for each bird
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9. 为每只鸟创建凸包多边形
- en: '![](ch07ex09-0.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex09-0.jpg)'
- en: '![](ch07ex09-1.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex09-1.jpg)'
- en: The results are shown in [figure 7.14](#ch07fig14), where the polygon for one
    bird is filled in and the rest are hollow. Maybe it’s me, but those big polygons
    don’t tell me a whole lot. I’d like to see the area each bird used around the
    islands and around the mainland, but without the middle of the ocean. In fact,
    comparing the area used between different visits to the archipelago or mainland
    might be interesting.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在[图7.14](#ch07fig14)中，其中一只鸟的多边形已填充，其余的都是空心的。也许是我自己的问题，但那些大多边形并没有告诉我太多。我想看到每只鸟在岛屿和大陆周围使用的区域，但不需要中间的海洋区域。实际上，比较不同访问群岛或大陆之间使用的区域可能很有趣。
- en: Figure 7.14\. The ranges for each bird. The polygon for the bird with ID 4264-84830852
    is filled in, but the rest are hollow.
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14. 每只鸟的范围。ID为4264-84830852的鸟的多边形已填充，但其余的都是空心的。
- en: '![](07fig14.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig14.jpg)'
- en: I can think of a few different ways to separate the points into different visits
    to the continent or islands, but we’ll only look at one of them. [Listing 7.10](#ch07ex10)
    does it by ignoring all locations that are more than 100 kilometers from land,
    and every time the birds cross an imaginary vertical line in the middle of the
    ocean, a new set of points is created so the two geographical areas are separated.
    In the interest of space, the code to create the new polygon shapefile itself
    is omitted and only the code to create the polygons is shown.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想到几种不同的方法来将点分离到大陆或岛屿的不同访问中，但我们只看其中一种。[列表 7.10](#ch07ex10) 通过忽略所有距离陆地超过 100
    公里的位置来实现，每次鸟类穿越海洋中间的想象中的垂直线时，就会创建一组新的点，从而将两个地理区域分开。为了节省空间，创建新的多边形形状文件的代码被省略了，只展示了创建多边形的代码。
- en: Listing 7.10\. Create convex hull polygons separated by geographic area
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 创建按地理区域分隔的凸包多边形
- en: '![](ch07ex10-0.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.10-0](ch07ex10-0.jpg)'
- en: '![](ch07ex10-1.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.10-1](ch07ex10-1.jpg)'
- en: In this example you need a land dataset so you can tell which points are within
    100 kilometers of land. After getting the land polygon, you buffer it by 100,000
    meters, which is the same as 100 km. When iterating through the points, the first
    thing you do is check to see if the point falls within the land buffer. If it
    doesn’t, then you move on to the next point without doing anything more. If a
    point is within the buffer, and therefore within 100 kilometers of land, you check
    to see which side of the imaginary line the point is on and set a location variable
    to keep track of whether the point is on the island or mainland. If the location
    has changed since the previous point you looked at, and you encounter at least
    three locations (the minimum required for a polygon), then you create a new convex
    hull polygon with the collected points. After checking the number of points and
    possibly creating a polygon, you create a new multipoint object to store the next
    set of points. If you hadn’t created a new multipoint, then your next convex hull
    would use all locations you’d saved so far, but you want to start over now that
    you’re in a different geographic area. When you finish iterating through the points
    for a specific animal, the points since the last location change still need to
    be turned into a polygon, so you’ve got another bit of code to take care of those
    last locations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你需要一个陆地数据集，以便你可以判断哪些点位于陆地 100 公里范围内。在获取陆地多边形后，你将其缓冲 100,000 米，这相当于 100
    公里。在遍历点时，你首先检查点是否位于陆地缓冲区内部。如果不是，那么你继续到下一个点而无需做任何事情。如果一个点位于缓冲区内部，因此位于陆地 100 公里范围内，你检查点位于想象中的线的哪一侧，并设置一个位置变量来跟踪点是在岛屿还是大陆上。如果位置自上次查看的点以来已改变，并且你遇到了至少三个位置（构成多边形所需的最小数量），那么你使用收集到的点创建一个新的凸包多边形。在检查点的数量并可能创建多边形后，你创建一个新的多点对象来存储下一组点。如果你还没有创建一个新的多点对象，那么你的下一个凸包将使用你迄今为止保存的所有位置，但现在你想要在一个不同的地理区域内重新开始。当你遍历特定动物的点完成时，自上次位置改变以来的点仍然需要转换为多边形，因此你需要一段代码来处理这些最后的点。
- en: The result for one bird is shown in [figure 7.15](#ch07fig15). This is the same
    animal whose range was shaded in [figure 7.14](#ch07fig14), so you can see the
    difference in the calculated ranges.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个鸟类的结果在[图 7.15](#ch07fig15)中展示。这是与[图 7.14](#ch07fig14)中阴影范围相同的动物，因此你可以看到计算范围之间的差异。
- en: Figure 7.15\. The area-specific ranges for bird 4264-84830852\. Compare this
    with the large polygon for the same animal shown in [figure 7.14](#ch07fig14).
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.15\. 鸟 4264-84830852 的特定区域范围。与[图 7.14](#ch07fig14)中显示的同一动物的较大多边形进行比较。
- en: '![](07fig15.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.15](07fig15.jpg)'
- en: I don’t know about you, but I’m curious how much of the same area is used by
    an individual on separate visits to the islands or the mainland—do they haunt
    the same locations or do they switch it up a bit? A simple way to get at this,
    which ignores the fact that some polygons might be created from a day’s worth
    of data as opposed to others with a week or two, might be to look at the ratio
    of common area to total area (if you’re an albatross biologist, please don’t cringe
    too much at my idea). [Figure 7.16](#ch07fig16) shows the difference between these
    two for one of the bird’s visits to the islands.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你们，但我很好奇同一个区域在个体对岛屿或大陆的单独访问中使用了多少——它们是否总是出现在相同的位置，或者它们会稍微改变一下？一个简单的方法，它忽略了某些多边形可能是由一天的数据创建，而其他多边形则是由一周或两周的数据创建的事实，可能是查看公共区域与总面积的比率（如果你是信天翁生物学家，请不要对我的想法过于皱眉）。[图7.16](#ch07fig16)显示了鸟类访问岛屿时这两个比率之间的差异。
- en: Figure 7.16\. The outlines show the areas used on four different visits to the
    islands by bird 1163-1163, and the shaded areas show the results of union and
    intersection operations on these polygons.
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.16\. 四个不同访问岛屿时，鸟类1163-1163使用的区域轮廓，阴影区域显示了这些多边形并集和交集操作的结果。
- en: '![](07fig16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig16.jpg)'
- en: Let’s look at how you’d calculate this ratio, and then we’ll leave the albatrosses
    alone. The following listing does it for the bird shown in [figure 7.16](#ch07fig16),
    but you could easily adapt the code to calculate this value for all of the birds.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何计算这个比率，然后我们将不再关注信天翁。以下列表展示了如何计算[图7.16](#ch07fig16)中所示鸟类的比率，但你也可以轻松地修改代码来计算所有鸟类的这个值。
- en: Listing 7.11\. Calculate percentage of total area used in all island visits
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.11\. 计算所有岛屿访问中使用的总面积百分比
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It looks like a quarter of this bird’s total range is used during each visit
    to the islands, but it’s clear from [figure 7.16](#ch07fig16) that this area is
    in the middle of the range. A next step might be to see how many points were used
    to create each polygon—maybe the larger polygons are bigger because they have
    more points and not because the bird changed its habits each time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这只鸟每次访问岛屿时使用了其总范围的四分之一，但从[图7.16](#ch07fig16)中可以看出，这个区域位于范围的中间。下一步可能就是看看创建每个多边形使用了多少点——也许较大的多边形更大是因为它们有更多的点，而不是因为鸟每次都改变了它的习惯。
- en: 7.5\. Summary
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 摘要
- en: Overlap tools tell you the spatial relationship of geometries to each other,
    such as whether or not they intersect in space.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠工具告诉你几何形状之间的空间关系，例如它们是否在空间中相交。
- en: Proximity tools are used to determine distances between geometries or create
    buffers around them.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临近工具用于确定几何形状之间的距离或围绕它们创建缓冲区。
- en: As with any type of analysis, it’s important to carefully consider your methodologies
    and assumptions when creating your workflow.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像任何类型的分析一样，在创建你的工作流程时，仔细考虑你的方法和假设是很重要的。
