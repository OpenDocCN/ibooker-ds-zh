- en: 3 Why function purity matters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 为什么函数纯净性很重要
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What makes a function pure or impure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使一个函数纯净或不纯净
- en: Why purity matters in concurrent scenarios
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在并发场景中纯净性很重要
- en: How purity relates to testability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯净性与可测试性的关系
- en: Reducing the impure footprint of your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码的不纯净痕迹
- en: 'The initial name for this chapter was “The irresistible appeal of purity.”
    But if it was so irresistible, we’d have more functional programmers, right? Functional
    programmers, you see, are suckers for *pure functions*: functions with no side
    effects. In this chapter, you’ll see what that means exactly and why pure functions
    have some very desirable properties.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这章最初的名称是“纯净的不可抗拒魅力。”但如果它真的如此不可抗拒，我们就会有更多的函数式程序员，对吧？你看，函数式程序员是**纯净函数**的忠实粉丝：没有副作用的功能。在本章中，你将看到这究竟意味着什么，以及为什么纯净函数具有一些非常令人向往的特性。
- en: Unfortunately, this fascination with pure functions is partly why FP as a discipline
    has become disconnected from the industry. As you’ll soon realize, there’s little
    purity in most real-world applications. And yet, purity is still relevant in the
    real world, as I hope to show in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种对纯净函数的迷恋部分原因是为什么函数式编程作为一门学科已经与行业脱节。很快你就会意识到，在大多数现实世界的应用中，几乎没有纯净性。然而，纯净性在现实世界中仍然相关，正如我希望在本章中展示的那样。
- en: We’ll start by looking at what makes a function pure (or impure), and then you’ll
    see how purity affects a program’s testability and even correctness, especially
    in concurrent scenarios. I hope that by the end of the chapter, you’ll find purity
    if not *irresistible* at least *definitely worth keeping in mind*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探讨什么使一个函数纯净（或不纯净）开始，然后你将看到纯净性如何影响程序的可测试性和甚至正确性，尤其是在并发场景中。我希望到本章结束时，你会发现纯净性如果不是**不可抗拒**，至少也是**绝对值得记住**的。
- en: 3.1 What is function purity?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 什么是函数纯净性？
- en: In chapter 2, you saw that mathematical functions are completely abstract entities.
    Although some programming functions are close representations of mathematical
    functions, this is often not the case. You often want a function to print something
    to the screen, to process a file, or to interact with another system. In short,
    you often want a function to *do* something, to have a *side effect*. Mathematical
    functions do nothing of the sort; they only return a value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，你看到数学函数是完全抽象的实体。尽管一些编程函数是数学函数的近似表示，但这通常并非如此。你经常希望一个函数在屏幕上打印某些内容，处理一个文件，或者与另一个系统交互。简而言之，你经常希望函数**做**一些事情，产生**副作用**。数学函数根本不做这样的事情；它们只返回一个值。
- en: 'There’s a second important difference: mathematical functions exist in a vacuum,
    so their results are determined strictly by their arguments. The programming constructs
    we use to represent functions, on the other hand, all have access to a *context*:
    an instance method has access to instance fields, a lambda has access to variables
    in the enclosing scope, and many functions have access to things that are completely
    outside the scope of the program, such as the system clock, a database, or a remote
    service, for instance.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的区别是：数学函数存在于真空中，因此它们的结果严格由它们的参数决定。我们用来表示函数的编程结构，另一方面，都可以访问一个**上下文**：一个实例方法可以访问实例字段，一个lambda可以访问封闭作用域中的变量，许多函数可以访问完全超出程序范围的事物，例如系统时钟、数据库或远程服务等。
- en: That this context exists, that its limits aren’t always clearly demarcated,
    and that it can consist of things that change outside of the program’s control
    means that the behavior of functions in programming is substantially more complex
    to analyze than functions in mathematics. This leads to a distinction between
    *pure* and *impure* functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种上下文的存在，其界限并不总是清晰界定，以及它可能包含程序控制之外变化的事物，意味着编程中函数的行为比数学中的函数更复杂，难以分析。这导致了**纯净**和**不纯净**函数之间的区别。
- en: 3.1.1 Purity and side effects
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 纯净性与副作用
- en: 'Pure functions closely resemble mathematical functions: they do nothing other
    than compute an output value based on their input values. Table 3.1 contrasts
    pure and impure functions.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 纯净函数与数学函数非常相似：它们除了根据输入值计算输出值之外，不做任何事情。表3.1对比了纯净和不纯净函数。
- en: Table 3.1 Requirements of pure functions
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 纯净函数的要求
- en: '| Pure functions | Impure functions |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 纯净函数 | 不纯净函数 |'
- en: '| Output depends entirely on the input arguments. | Factors other than input
    arguments can affect the output. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 输出完全取决于输入参数。 | 除了输入参数之外的其他因素可能影响输出。 |'
- en: '| Cause no side effects. | Can cause side effects. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 无副作用 | 可有副作用 |'
- en: 'To clarify this definition, we must define exactly what a side effect is. A
    function is said to have side effects if it does any of the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明这个定义，我们必须精确地定义什么是副作用。如果一个函数执行以下任何一项操作，那么它被认为是有副作用的：
- en: '*Mutates global state*—Global here means any state that’s visible outside of
    the function’s scope. For example, a private instance field is considered global
    because it’s visible from all methods within the class.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改全局状态*—这里的全局意味着任何在函数作用域之外可见的状态。例如，一个私有实例字段被认为是全局的，因为它可以从类中的所有方法中看到。'
- en: '*Mutates its input arguments*—Arguments passed by the caller are effectively
    a state that a function shares with its caller. If a function mutates one of its
    arguments, that’s a side effect that’s visible to the caller.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改其输入参数*—调用者传递的参数实际上是一种函数与其调用者共享的状态。如果一个函数修改了它的任何一个参数，那么这就是对调用者可见的副作用。'
- en: '*Throws exceptions*—You can reason about pure functions in isolation; however,
    if a function throws exceptions, then the outcome of calling it is context-dependent.
    Namely, it differs depending on whether the function is called in a `try`-`catch`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抛出异常*—你可以独立地推理纯函数；然而，如果一个函数抛出异常，那么调用它的结果取决于上下文。也就是说，它取决于函数是在`try`-`catch`块中调用。'
- en: '*Performs any I/O operation*—This includes any interaction between the program
    and the external world, including reading from or writing to the console, the
    filesystem, or a database, and interacting with any process outside the application’s
    boundary.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行任何I/O操作*—这包括程序与外部世界的任何交互，包括从控制台、文件系统或数据库中读取或写入，以及与应用程序边界之外的任何进程交互。'
- en: 'In summary, pure functions have no side effects, and their output is solely
    determined by their inputs. Note that both conditions must hold:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，纯函数没有副作用，它们的输出完全由它们的输入决定。请注意，这两个条件都必须满足：
- en: '*A function that has no side effects can still be impure.* Namely, a function
    that reads from global mutable state is likely to have an output that depends
    on factors other than its inputs.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有副作用的函数仍然可能是非纯的。* 也就是说，从全局可变状态读取的函数很可能会产生依赖于其输入之外因素的输出。'
- en: '*A function whose output depends entirely on its inputs can also be impure.*
    It could still have side effects such as updating global mutable state.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个输出完全取决于其输入的函数也可以是非纯的。* 它仍然可能具有副作用，例如更新全局可变状态。'
- en: The deterministic nature of pure functions (they always return the same output
    for the same input) has some interesting consequences. Pure functions are easy
    to test and to reason about.[¹](#pgfId-1110922)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的确定性特性（对于相同的输入总是返回相同的输出）有一些有趣的后果。纯函数易于测试和推理。[¹](#pgfId-1110922)
- en: 'Furthermore, the fact that outputs only depend on inputs means that the order
    of evaluation isn’t important. Whether you evaluate the result of a function now
    or later, the result does not change. This means that the parts of your program
    that consist entirely of pure functions can be optimized in a number of ways:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，输出仅取决于输入的事实意味着求值的顺序并不重要。无论你现在还是以后计算函数的结果，结果都不会改变。这意味着你的程序中完全由纯函数组成的部分可以通过多种方式优化：
- en: '*Parallelization*—Different threads carry out tasks in parallel.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行化*—不同的线程并行执行任务。'
- en: '*Lazy evaluation*—Only evaluates values as needed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*惰性求值*—仅在需要时计算值。'
- en: '*Memoization*—Caches the result of a function so that it’s only computed once.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记忆化*—缓存函数的结果，使其只计算一次。'
- en: On the other hand, using these techniques with impure functions can lead to
    rather nasty bugs. For these reasons, FP advocates that pure functions be preferred
    as far as possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用这些技术与非纯函数一起可能会导致相当棘手的错误。出于这些原因，函数式编程倡导者建议尽可能优先使用纯函数。
- en: 3.1.2 Strategies for managing side effects
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 管理副作用的方法
- en: OK, let’s aim to use pure functions whenever possible. But is it always possible?
    Is it ever possible? Well, if you look at the list of things considered as side
    effects, it’s a pretty mixed bag, so the strategies for managing side effects
    depend on the types of side effects in question.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尽可能使用纯函数。但是，这总是可能的吗？是否有可能？嗯，如果你看一下被认为是副作用的事项列表，它是一个相当混杂的集合，因此管理副作用的方法取决于所讨论的副作用类型。
- en: Mutating input arguments is the easiest of the lot. This side effect can always
    be avoided, and I’ll demonstrate this next. It’s also possible to always avoid
    throwing exceptions. We’ll look at error handling without throwing exceptions
    in chapters 8 and 14.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 修改输入参数是最容易的。这种副作用总是可以避免的，我将在下面演示这一点。总是避免抛出异常也是可能的。我们将在第8章和第14章中查看不抛出异常的错误处理。
- en: Writing programs (even stateful programs) without state mutation is also possible.
    You can write any program without ever mutating state.[²](#pgfId-1110938) This
    may be a surprising realization for an OO programmer and requires a real shift
    in thinking. In section 3.2, I’ll show you a simple example of how avoiding state
    mutation enables you to easily parallelize a function. In later chapters, you’ll
    learn various techniques to tackle more complex tasks without relying on state
    mutation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序（甚至是具有状态的程序）而不进行状态修改也是可能的。你可以编写任何程序而不必修改状态。[²](#pgfId-1110938)这对于一个面向对象程序员来说可能是一个令人惊讶的认识，需要真正的思维转变。在第3.2节中，我将向你展示一个简单的例子，说明避免状态修改如何使你能够轻松并行化一个函数。在后面的章节中，你将学习各种技术来处理更复杂的任务，而不依赖于状态修改。
- en: Finally, I’ll discuss how to manage I/O in section 3.3\. By learning these techniques,
    you’ll be able to isolate or avoid side effects and, thus, harness the benefits
    of pure functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将在第3.3节中讨论如何管理I/O。通过学习这些技术，你将能够隔离或避免副作用，从而利用纯函数的优势。
- en: 3.1.3 Avoid mutating arguments
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 避免修改参数
- en: 'You can view a function signature as a contract: the function receives some
    inputs and returns some output. When a function mutates its arguments, this muddies
    the waters because the caller relies on this side effect to happen, even though
    this is not declared in the function signature. For this reason, I’d argue that
    mutating arguments is a bad idea in *any* programming paradigm. Nonetheless, I’ve
    repeatedly stumbled on implementations that do something along these lines:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数签名视为一个合同：函数接收一些输入并返回一些输出。当函数修改其参数时，这会混淆水，因为调用者依赖于这个副作用发生，尽管这并没有在函数签名中声明。因此，我认为在*任何*编程范式中修改参数都是一个坏主意。尽管如此，我反复遇到一些实现，它们做的是类似的事情：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`RecomputeTotal` is meant to be called when the quantity of items in an order
    is modified. It recomputes the total value of the order and, *as a side effect*,
    adds the order lines whose quantities have changed to zero to the given `linesToDelete`
    list. This is represented in figure 3.1.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecomputeTotal`方法旨在在修改订单中项目数量时被调用。它重新计算订单的总价值，并且作为副作用，将数量变为零的订单行添加到给定的`linesToDelete`列表中。这如图3.1所示。'
- en: '![](Images/CH03_F01_Buonanno2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F01_Buonanno2.png)'
- en: Figure 3.1 `RecomputeTotal` mutates its input, and the caller depends on this
    side effect.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 `RecomputeTotal`修改了其输入，并且调用者依赖于这个副作用。
- en: 'The reason why this is such a terrible idea is that the behavior of the method
    is now tightly coupled with that of the caller: the caller relies on the method
    to perform its side effect, and the callee relies on the caller to initialize
    the list. As such, each method must be aware of the implementation details of
    the other, making it impossible to reason about the code in isolation.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以是一个糟糕的想法，是因为该方法的行为现在与调用者的行为紧密耦合：调用者依赖于该方法执行其副作用，而调用者依赖于调用者初始化列表。因此，每个方法都必须了解另一个方法的实现细节，这使得无法独立地推理代码。
- en: WARNING Another problem with methods that mutate their argument is that, if
    you were to change the type of the argument from a `class` to a `struct`, you’d
    get a radically different behavior because structs are copied when passed between
    functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：使用会修改其参数的方法存在另一个问题，如果你将参数的类型从`class`改为`struct`，你会得到截然不同的行为，因为当在函数间传递时，结构体会被复制。
- en: 'You can easily avoid this kind of side effect by returning all the computed
    information to the caller instead. It’s important to recognize that the method
    is effectively computing two pieces of data: the new total for the order and the
    list of lines that can be deleted. You can make this explicit by returning a tuple.
    The refactored code would be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将所有计算出的信息返回给调用者来轻松避免这种副作用。重要的是要认识到，该方法实际上正在计算两份数据：订单的新总计和可以删除的行列表。你可以通过返回一个元组来使这一点明确。重构后的代码如下：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 3.2 represents this refactored version and appears simplified. After
    all, now it’s just a normal function that takes some input and returns an output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2表示这个重构版本，看起来更简单。毕竟，现在它只是一个普通的函数，接受一些输入并返回输出。
- en: '![](Images/CH03_F02_Buonanno2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/CH03_F02_Buonanno2.png)'
- en: Figure 3.2 `RecomputeTotal` refactored to explicitly return all the information
    it computes
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 `RecomputeTotal`重构为显式返回其计算的所有信息
- en: Following this principle, you can always structure your code in such a way that
    functions never mutate their input arguments. In fact, it would be ideal to enforce
    this by always using immutable objects—objects that once created cannot be changed.
    We’ll discuss this in detail in chapter 11\.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 依据这个原则，你总是可以以这种方式构建你的代码，使得函数永远不会改变它们的输入参数。实际上，通过始终使用不可变对象——一旦创建就不能更改的对象——来强制执行这一点将是理想的。我们将在第11章中详细讨论这一点。
- en: 3.2 Enabling parallelization by avoiding state mutation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 通过避免状态突变来启用并行化
- en: 'In this section, I’ll show you a simple scenario that illustrates why pure
    functions can always be parallelized while impure functions can’t. Imagine you
    want to format a list of strings as a numbered list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示一个简单场景，说明为什么纯函数始终可以并行化，而不纯函数则不能。想象一下，你想将字符串列表格式化为编号列表：
- en: The casing should be standardized.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化大小写。
- en: Each item should be preceded with a counter.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目前应有一个计数器。
- en: 'To do this, you could define a `ListFormatter` class, with the following usage:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你可以定义一个`ListFormatter`类，以下是其用法：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following listing shows one possible implementation of `ListFormatter`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个可能的`ListFormatter`实现。
- en: Listing 3.1 A list formatter combining pure and impure functions
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 结合纯函数和不纯函数的列表格式化器
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A pure function
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 纯函数
- en: ❷ An impure function (it mutates global state).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 不纯函数（它会改变全局状态）。
- en: ❸ Pure and impure functions can be applied similarly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 纯函数和不纯函数可以类似地应用。
- en: 'There are a few things to point out with respect to purity:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于纯度，有几个要点需要注意：
- en: '`ToSentenceCase` *is pure (its output is strictly determined by the input).*
    Because its computation only depends on the input parameter, it can be made static
    without any problems.[³](#pgfId-1111032)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToSentenceCase`是纯函数（其输出严格由输入决定）。因为其计算只依赖于输入参数，所以可以无问题地将其定义为静态的。[³](#pgfId-1111032)'
- en: '`PrependCounter` *increments the counter, so it’s impure.* Because it depends
    on an instance member (the counter), you can’t make it static.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrependCounter`会增加计数器，所以它是不纯的。因为它依赖于实例成员（计数器），所以你不能将其定义为静态的。'
- en: '*In the* `Format` *method, you apply both functions to items in the list with*
    `Select`*, irrespective of purity.* This isn’t ideal, as you’ll soon learn. In
    fact, there should ideally be a rule that `Select` should only be used with pure
    functions.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Format`方法中，你使用`Select`将两个函数应用到列表中的项上，不考虑其纯度。这并不理想，正如你很快就会学到的。事实上，理想情况下应该有一个规则，即`Select`应该仅与纯函数一起使用。
- en: If the list you’re formatting is big enough, would it make sense to perform
    the string manipulations in parallel? Could the runtime decide to do this as an
    optimization? We’ll tackle these questions next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在格式化的列表足够大，并行执行字符串操作是否有意义？运行时是否会决定这样做以进行优化？我们将在下一节中解决这些问题。
- en: 3.2.1 Pure functions parallelize well
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 纯函数并行化良好
- en: Given a big enough set of data to process, it’s usually advantageous to process
    it in parallel, especially when the processing is CPU-intensive and the pieces
    of data can be processed independently. Pure functions parallelize well and are
    generally immune to the issues that make concurrency difficult. (For a refresher
    on concurrency and parallelism, see the sidebar on the “Meaning and types of concurrency”).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 给定足够大的数据集进行处理，通常并行处理是有利的，尤其是在处理是CPU密集型且数据片段可以独立处理时。纯函数可以很好地并行化，并且通常对使并发困难的问题免疫。（关于并发和并行性的复习，请参阅“并发和并行性的意义和类型”侧边栏）。
- en: 'I’ll illustrate this by trying to parallelize our list-formatting functions
    with `ListFormatter`. Compare these two expressions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过尝试使用`ListFormatter`并行化我们的列表格式化函数来阐述这一点。比较以下两个表达式：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first expression uses the `Select` method defined in `System.Linq.Enumerable`
    to apply the pure function `ToSentenceCase` to each element in the list. The second
    expression is similar, but it uses methods provided by Parallel LINQ (PLINQ).[⁴](#pgfId-1111049)
    `AsParallel` turns the list into a `ParallelQuery`. As a result, `Select` resolves
    to the implementation defined in `ParallelEnumerable`, which applies `ToSentenceCase`
    to each item in the list, but now in parallel.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式使用`System.Linq.Enumerable`中定义的`Select`方法将纯函数`ToSentenceCase`应用于列表中的每个元素。第二个表达式类似，但它使用Parallel
    LINQ (PLINQ)提供的方法。[⁴](#pgfId-1111049) `AsParallel`将列表转换为`ParallelQuery`。因此，`Select`解析为`ParallelEnumerable`中定义的实现，它将`ToSentenceCase`应用于列表中的每个项目，但现在是在并行执行的。
- en: The list is split into chunks, and several threads are fired to process each
    chunk. The results are then harvested into a single list when `ToList` is called.
    Figure 3.3 shows this process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表被分成块，然后启动几个线程来处理每个块。当调用`ToList`时，结果被收集到一个单独的列表中。图3.3展示了这个过程。
- en: '![](Images/CH03_F03_Buonanno2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F03_Buonanno2.png)'
- en: Figure 3.3 Parallel processing of data in a list
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 列表中的数据并行处理
- en: As you would expect, the two expressions yield the same results, but one does
    so sequentially and the other in parallel. This is nice. With just one call to
    `AsParallel`, you get parallelization *almost* for free.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，这两个表达式会产生相同的结果，但一个按顺序执行，另一个则并行执行。这很好。只需调用一次`AsParallel`，您就可以几乎免费地获得并行化。
- en: Why *almost* for free? Why do you have to explicitly instruct the program to
    parallelize the operation? Why can’t the runtime figure out that it’s a good idea
    to parallelize an operation just like it figures out when it’s a good time to
    run the garbage collector?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么几乎免费？为什么您必须明确指示程序并行化操作？为什么运行时不应该像确定垃圾回收的最佳时机一样，确定并行化操作是一个好主意？
- en: The answer is that the runtime doesn’t know enough about the function to make
    an informed decision on whether parallelization might change the program flow.
    Because of their properties, pure functions can always be applied in parallel,
    but the runtime doesn’t know whether the function being applied is pure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是运行时不了解函数的足够信息，无法做出是否并行化可能会改变程序流程的明智决定。由于它们的属性，纯函数始终可以并行应用，但运行时不了解正在应用的函数是否是纯函数。
- en: Meaning and types of concurrency
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的意义和类型
- en: '*Concurrency* is the general concept of having several things going on at the
    same time. More formally, concurrency is when a program initiates a task before
    another one has completed so that different tasks are executed in overlapping
    time windows. There are several scenarios in which concurrency can occur:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发*是同时进行几件事情的一般概念。更正式地说，并发是指程序在另一个任务完成之前启动一个任务，以便不同的任务在重叠的时间窗口内执行。在以下几种情况下可能会发生并发：'
- en: '*Asynchrony*—Your program performs *non-blocking* operations. For example,
    it can initiate a request for a remote resource via HTTP and then go on to do
    some other task while it waits to receive the response. It’s a bit like when you
    send an email and then go on with your life without waiting for a response.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步*——您的程序执行*非阻塞*操作。例如，它可以通过HTTP发起对远程资源的请求，然后在等待响应的同时继续执行其他任务。这有点像您发送电子邮件后继续生活而不等待回复。'
- en: '*Parallelism*—Your program leverages the hardware of multicore machines to
    execute tasks at the same time by breaking up work into tasks, each of which is
    executed on a separate core. It’s a bit like singing in the shower: you’re actually
    doing two things at exactly the same time.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行性*——您的程序通过将工作分解成任务，每个任务在单独的核心上执行，利用多核机器的硬件来同时执行任务。这有点像在淋浴时唱歌：您实际上同时做了两件事。'
- en: '*Multithreading*—A software implementation that allows different threads to
    execute concurrently. A multithreaded program appears to be doing several things
    at the same time even when it’s running on a single-core machine. This is a bit
    like chatting with different people through various IM windows, although you’re
    actually switching back and forth. The net result is that you’re having multiple
    conversations at the same time.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多线程*——一种软件实现，允许不同的线程并发执行。即使在一个单核机器上运行，多线程程序看起来也能同时做几件事情。这有点像通过各种即时通讯窗口与不同的人聊天，尽管您实际上是在来回切换。最终结果是您同时进行多个对话。'
- en: Doing several things at the same time can boost performance. It also means that
    the order of execution isn’t guaranteed, so concurrency can be the source of difficult
    problems, most notably when multiple tasks concurrently try to update some shared
    mutable state. (In later chapters, you’ll see how FP addresses this by avoiding
    a shared mutable state altogether.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同时做几件事情可以提高性能。这也意味着执行顺序没有保证，因此并发可能是困难的根源，尤其是在多个任务同时尝试更新某些共享可变状态时。（在后面的章节中，你将看到FP如何通过完全避免共享可变状态来解决这个问题。）
- en: 3.2.2 Parallelizing impure functions
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 并行化不纯函数
- en: 'You’ve seen that you could successfully apply the pure `ToSentenceCase` in
    parallel. Let’s see what happens if you naively apply the impure `PrependCounter`
    function in parallel:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到你可以成功地将纯函数`ToSentenceCase`并行化。让我们看看如果你天真地并行化不纯的`PrependCounter`函数会发生什么：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you now create a list with a million items and format it with the naively
    parallelized formatter, you’ll find that the last item in the list will be prepended
    not with 1,000,000, but with a smaller number. If you’ve downloaded the code samples,
    you can try it for yourself by running
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在创建一个包含一百万个项目的列表，并使用天真地并行化的格式化程序进行格式化，你会发现列表中的最后一个项目不是以1,000,000开头，而是以一个较小的数字开头。如果你已经下载了代码示例，你可以通过运行以下命令来亲自尝试：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output will end with something like
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将以类似以下内容结束
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because `PrependCounter` increments the `counter` variable, the parallel version
    will have multiple threads reading and updating the counter, as figure 3.4 shows.
    As is well known, `++` is not an atomic operation, and because there’s no locking
    in place, we’ll lose some of the updates and end up with an incorrect result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`PrependCounter`增加了`counter`变量，并行版本将会有多个线程读取和更新计数器，如图3.4所示。众所周知，`++`不是一个原子操作，因为没有锁定机制，我们将丢失一些更新，并最终得到一个错误的结果。
- en: '![](Images/CH03_F04_Buonanno2.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F04_Buonanno2.png)'
- en: Figure 3.4 When processing the list in parallel, multiple threads access the
    counter concurrently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 当并行处理列表时，多个线程并发访问计数器。
- en: This will sound familiar if you have some multithreading experience. Because
    multiple processes are reading and writing to the counter at the same time, some
    of the updates are lost. Of course, you could fix this by using a lock or the
    `Interlocked` class when incrementing the counter. But this would entail a performance
    hit, wiping out some of the gains made by parallelizing the computation. Furthermore,
    locking is an imperative construct that we’d rather avoid when coding functionally.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些多线程经验，这听起来可能很熟悉。因为多个进程同时读取和写入计数器，一些更新会丢失。当然，你可以在增加计数器时使用锁或`Interlocked`类来修复这个问题。但这样做会降低性能，抵消了并行计算带来的部分收益。此外，锁定是一个我们希望在函数式编程中避免的命令式构造。
- en: Let’s summarize. Unlike pure functions, whose application can be parallelized
    by default, impure functions don’t parallelize out of the box. And because parallel
    execution is nondeterministic, you may get some cases in which your result is
    correct and others in which it isn’t (not the sort of bug you’d like to face).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下。与默认可以并行化的纯函数不同，不纯函数不是直接可以并行化的。而且由于并行执行是非确定性的，你可能会遇到一些情况，其中你的结果是正确的，而另一些情况则不是（你不想遇到的错误类型）。
- en: Being aware of whether your functions are pure or not can help you understand
    these issues. Furthermore, if you develop with purity in mind, it’s easier to
    parallelize the execution if you decide to do so.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的函数是否是纯的可以帮助你理解这些问题。此外，如果你在开发时考虑到纯度，那么如果你决定并行化执行，这将更容易。
- en: 3.2.3 Avoiding state mutation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 避免状态突变
- en: One possible way to avoid the pitfalls of concurrent updates is to remove the
    problem at the source; don’t use shared states to begin with. How this can be
    done varies with each scenario, but I’ll show you a solution for the current scenario
    that enables us to format the list in parallel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 避免并发更新的潜在问题的一个可能方法是在源头上解决问题；一开始就不使用共享状态。如何做到这一点因场景而异，但我会向你展示一个解决方案，它使我们能够并行格式化列表。
- en: Let’s go back to the drawing board and see if there’s a sequential solution
    that doesn’t involve mutation. What if, instead of updating a running counter,
    you generate a list of all the counter values you need and then pair items from
    the given list with items from the list of counters? For the list of integers,
    you can use `Range`, a convenience method on `Enumerable`, as the following listing
    demonstrates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到起点，看看是否有一个不涉及修改的顺序解决方案。如果，不是更新一个运行计数器，而是生成所有需要的计数器值的列表，然后从给定的列表和计数器列表中配对项目，会怎样？对于整数列表，你可以使用
    `Enumerable` 上的便利方法 `Range`，如下所示。
- en: Listing 3.2 Generating a range of integers
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 生成整数范围
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The operation of pairing two parallel lists is common in FP. It’s called `Zip`.
    `Zip` takes two lists to pair up and a function to apply to each pair. The following
    listing shows an example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，对两个并行列表进行配对操作很常见。这被称为 `Zip`。`Zip` 接受两个列表进行配对，并应用到一个配对上的函数。以下列表显示了一个示例。
- en: Listing 3.3 Combining elements from parallel lists with `Zip`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 使用 `Zip` 结合并行列表中的元素
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can rewrite the list formatter using `Range` and `Zip` as the following
    listing shows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Range` 和 `Zip` 重新编写列表格式化程序，如下所示。
- en: Listing 3.4 List formatter refactored to use pure functions only
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 重构为仅使用纯函数的列表格式化程序
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here you use the list with `ToSentenceCase` applied to it as the left side
    of `Zip`. The right side is constructed with `Range`. The third argument to `Zip`
    is the pairing function: what to do with each pair of items. Because `Zip` can
    be used as an extension method, you can write the `Format` method using a more
    fluent syntax:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用应用了 `ToSentenceCase` 的列表作为 `Zip` 的左侧。右侧是用 `Range` 构建的。`Zip` 的第三个参数是配对函数：如何处理每一对项目。因为
    `Zip` 可以用作扩展方法，你可以使用更流畅的语法编写 `Format` 方法：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After this refactoring, `Format` is pure and can safely be made static. But
    what about making it parallel? That’s a piece of cake because PLINQ offers an
    implementation of `Zip` that works with parallel queries. The following listing
    provides a parallel implementation of the list formatter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重构之后，`Format` 是纯函数，可以安全地将其定义为静态。但使其并行化怎么样？这很简单，因为 PLINQ 提供了一个与并行查询一起工作的 `Zip`
    实现。以下列表提供了一个列表格式化的并行实现。
- en: Listing 3.5 A pure implementation that executes in parallel
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 一个并行执行的纯实现
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Uses `Range` exposed by `ParallelEnumerable`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `ParallelEnumerable` 暴露的 `Range`
- en: ❷ Turns the original data source into a parallel query
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将原始数据源转换为并行查询
- en: This is almost identical to the sequential version; there are only two differences.
    First, `AsParallel` is used to turn the given list into a `ParallelQuery` so that
    everything after that is done in parallel. Second, the change in `using static`
    has the effect that `Range` now refers to the implementation defined in `ParallelEnumerable`
    (this returns a `ParallelQuery`, which is what the parallel version of `Zip` expects).
    The rest is the same as the sequential version, and the parallel version of `Format`
    is still a pure function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与顺序版本相同；只有两个区别。首先，使用`AsParallel`将给定的列表转换为`ParallelQuery`，这样之后的所有操作都是并行执行的。其次，`using
    static`的变化使得`Range`现在指的是`ParallelEnumerable`中定义的实现（这返回一个`ParallelQuery`，这是`Zip`并行版本所期望的）。其余部分与顺序版本相同，`Format`的并行版本仍然是一个纯函数。
- en: In this scenario, it was possible to enable parallel execution by removing state
    updates altogether, but this isn’t always the case, nor is it always this easy.
    But the ideas you’ve seen so far put you in a better position when tackling issues
    related to parallelism and, more generally, concurrency.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过完全删除状态更新，可以启用并行执行，但这并不总是这种情况，也并不总是这么容易。但到目前为止你看到的想法让你在处理与并行性相关的问题时处于更好的位置，更普遍地说，是并发问题。
- en: The case for static methods
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法的理由
- en: When all variables required within a method are provided as input (or are statically
    available), you can define the method as static. This chapter contains several
    examples of refactoring instance methods to static methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法内部所需的所有变量都作为输入提供（或静态可用）时，你可以将方法定义为静态。本章包含将实例方法重构为静态方法的几个示例。
- en: 'You may feel uneasy about this, especially if (like me) you’ve seen programs
    become difficult to test and maintain because of the inordinate use of static
    classes. Static methods can cause problems if they do either of the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对此感到不安，尤其是如果你（像我一样）看到程序因为过度使用静态类而变得难以测试和维护。如果静态方法执行以下任一操作，它们可能会引起问题：
- en: '*Mutate static fields*—These are effectively the most global variables. They
    can be updated from any code that has visibility of the static class, causing
    coupling and unpredictable behavior.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改静态字段*—这些实际上是最全局的变量。它们可以从任何可以看到静态类的代码中更新，导致耦合和不可预测的行为。'
- en: '*Perform I/O*—In this case, it’s testability that’s jeopardized. If method
    `A` depends on the I/O behavior of static method `B`, it’s not possible to unit
    test `A`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行I/O*—在这种情况下，受威胁的是可测试性。如果方法`A`依赖于静态方法`B`的I/O行为，那么无法对`A`进行单元测试。'
- en: Note that both of these cases imply an impure function. On the other hand, when
    a function is pure, it can safely be marked as static. As a general guideline
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两种情况都意味着一个不纯的函数。另一方面，当一个函数是纯函数时，它可以安全地被标记为静态。作为一个一般准则
- en: Make pure functions static
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纯函数设为静态
- en: Avoid mutable static fields
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免可变静态字段
- en: Avoid directly calling static methods that perform I/O
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免直接调用执行I/O的静态方法
- en: As you code more functionally, more of your functions will be pure. This means
    more of your code will potentially be in static classes without causing any of
    the problems associated with the abuse of static classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你更多地以函数式的方式编码，你的更多函数将是纯函数。这意味着你的更多代码可能会在静态类中，而不会引起与滥用静态类相关的问题。
- en: 3.3 Purity and testability
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 纯度与可测试性
- en: In the previous section, you saw the relevance of purity in a concurrent scenario.
    Because the side effect had to do with state mutation, we could remove the mutation,
    and the resulting pure function could be run in parallel without problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了纯度在并发场景中的相关性。因为副作用与状态突变有关，我们可以移除突变，结果得到的纯函数可以无问题地并行运行。
- en: Now we’ll look at functions that perform I/O and how purity is relevant to unit
    testing. Unit tests have to be *repeatable* (if a test passes, it should do so
    irrespective of when it’s run, on what machine, whether there’s a connection,
    and so on). This is closely related to our requirement that pure functions be
    deterministic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨执行I/O操作的函数以及纯度与单元测试的相关性。单元测试必须是*可重复的*（如果测试通过，它应该在任何时间、任何机器、是否有连接等情况下都通过）。这与我们要求纯函数必须是确定性的要求密切相关。
- en: I’m aiming to leverage your knowledge of unit testing to help you understand
    the relevance of purity and also to dispel the notion that purity is only of a
    theoretical interest. Your manager may not care whether you write pure functions,
    but they’re probably keen on good test coverage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是利用你对单元测试的知识来帮助你理解纯度的相关性，并消除纯度只具有理论兴趣的观念。你的经理可能不在乎你是否编写纯函数，但他们可能非常关注良好的测试覆盖率。
- en: 3.3.1 Isolating I/O effects
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 隔离I/O效果
- en: 'Unlike mutation, you can’t avoid side effects related to I/O. Whereas mutation
    is an implementation detail, I/O is usually a requirement. Here are a few examples
    that help to clarify why functions that perform I/O can never be pure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与突变不同，你无法避免与I/O相关的副作用。虽然突变是实现细节，但I/O通常是必需的。以下是一些有助于阐明为什么执行I/O的函数永远不能是纯函数的例子：
- en: A function that takes a URL and returns the resource at that URL yields a different
    result any time the remote resource changes, or it may throw an error if the connection
    is unavailable.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受URL并返回该URL资源的函数，在远程资源发生变化时会产生不同的结果，或者如果连接不可用，可能会抛出错误。
- en: A function that takes a file path and contents to be written to a file can throw
    an error if the directory doesn’t exist or if the process hosting the program
    lacks write permissions.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受文件路径和要写入文件的内容的函数，如果目录不存在或程序所在进程没有写权限，可能会抛出错误。
- en: A function that returns the current time from the system clock returns a different
    result at any instant.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从系统时钟返回当前时间的函数在任何时刻都会返回不同的结果。
- en: As you can see, any dependency on the external world gets in the way of function
    purity because the state of the world affects the function’s return value. On
    the other hand, if your program is to do anything of use, there’s no escaping
    the fact that some I/O is required. Even a purely mathematical program that just
    performs a computation must perform some I/O to communicate its result. Some of
    your code will have to be impure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，任何对外部世界的依赖都会阻碍函数的纯度，因为世界状态会影响函数的返回值。另一方面，如果你的程序要做任何有用的东西，那么不可避免地需要一些I/O。即使是仅仅执行计算的纯数学程序，也必须执行一些I/O来传达其结果。你的某些代码将不得不是不纯的。
- en: 'How can you reap the benefits of purity while satisfying the requirement to
    perform I/O? You *isolate* the pure, computational parts of your programs from
    the I/O. In this way, you minimize the footprint of I/O and reap the benefits
    of purity for the pure part of the program. For example, consider the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在满足执行 I/O 的要求的同时，获得纯净性的好处？你 *隔离* 程序中纯净的计算部分与 I/O。这样，你最小化了 I/O 的足迹，并为程序的纯净部分获得了纯净性的好处。例如，考虑以下代码：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This trivial program mixes I/O with logic that could be captured in a pure
    function, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序将 I/O 与可以捕获在纯函数中的逻辑混合在一起，如下所示：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In some real-world programs, separating logic from I/O is relatively simple.
    For example, take a document format converter like Pandoc, which can be used to
    convert a file from, say, Markdown to PDF. When you execute Pandoc, it performs
    the steps shown in figure 3.5.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些现实世界的程序中，将逻辑与 I/O 分离相对简单。例如，以 Pandoc 这样的文档格式转换器为例，它可以用来将文件从 Markdown 转换为
    PDF。当你执行 Pandoc 时，它执行图 3.5 中显示的步骤。
- en: '![](Images/CH03_F05_Buonanno2.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F05_Buonanno2.png)'
- en: Figure 3.5 A program where I/O can easily be isolated. The core logic performing
    format conversion can be kept pure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 一个易于隔离 I/O 的程序。执行格式转换的核心逻辑可以保持纯净。
- en: The computational part of the program, which performs the format conversion,
    can be made entirely of pure functions. The impure functions that perform I/O
    can call the pure functions that perform the translation, but the functions that
    perform the translation can’t call any function that performs I/O, or they will
    also become impure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的计算部分，执行格式转换，可以完全由纯函数组成。执行 I/O 的不纯函数可以调用执行转换的纯函数，但执行转换的函数不能调用任何执行 I/O 的函数，否则它们也会变得不纯。
- en: Most Line of Business (LOB) applications have a more complex structure in terms
    of I/O, so isolating the purely computational parts of the program from I/O is
    quite a challenge. Next, I’ll introduce a business scenario we’ll use throughout
    the book, and we’ll see how we can test some validation that performs I/O.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数业务线 (LOB) 应用在 I/O 方面结构更为复杂，因此将程序的纯净计算部分与 I/O 分离是一个相当大的挑战。接下来，我将介绍本书中我们将使用的业务场景，我们将看到我们如何测试一些执行
    I/O 的验证。
- en: 3.3.2 A business validation scenario
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 一个业务验证场景
- en: Imagine you’re writing some code for an online banking application. Your client
    is the Bank of Codeland (BOC); the BOC’s customers can use a web or mobile device
    to make money transfers. Before booking a transfer, the server has to validate
    the request, as figure 3.6 shows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在为在线银行应用程序编写代码。你的客户端是 Codeland 银行 (BOC)；BOC 的客户可以使用网页或移动设备进行货币转账。在预订转账之前，服务器必须验证请求，如图
    3.6 所示。
- en: '![](Images/CH03_F06_Buonanno2.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F06_Buonanno2.png)'
- en: 'Figure 3.6 Business scenario: validating a transfer request'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 业务场景：验证转账请求
- en: Let’s assume that the user’s request to make a transfer is represented by a
    `MakeTransfer` command. A *command* is a simple data transfer object (DTO) that
    the client sends the server, encapsulating details about the action it wants to
    be performed. The following listing shows our call to `MakeTransfer`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户发起转账请求是通过一个 `MakeTransfer` 命令来表示的。一个 *命令* 是一个简单的数据传输对象 (DTO)，客户端将其发送给服务器，封装了它想要执行的操作的详细信息。以下列表显示了我们对
    `MakeTransfer` 的调用。
- en: Listing 3.6 A DTO representing a request to make a money transfer
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 代表发起货币转账请求的 DTO
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Identifies the sender’s account
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别发送者的账户
- en: ❷ Details about the beneficiary’s account
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 受益人账户的详细信息
- en: ❸ Details about the transfer
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 转账的详细信息
- en: ❹ We’ll use this for testing when you don’t need all the properties to be populated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当你不需要填充所有属性时，我们将使用这个来测试。
- en: The properties of a `MakeTransfer` are populated by deserializing the client’s
    request, except for the `Timestamp`, which needs to be set by the server. An initial
    `default` value is therefore declared. When unit testing, we’ll have to populate
    the object manually, so having a `Dummy` instance allows you to only populate
    the properties relevant to the test, as you’ll see in a moment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeTransfer` 的属性通过反序列化客户端的请求来填充，除了 `Timestamp`，它需要由服务器设置。因此，声明了一个初始的 `default`
    值。在单元测试时，我们必须手动填充对象，因此有一个 `Dummy` 实例允许你只填充与测试相关的属性，正如你将看到的。'
- en: 'Validation in this scenario can be quite complex. For the purposes of this
    explanation, we’ll only look at the following validation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中的验证可能相当复杂。为了解释的目的，我们只查看以下验证：
- en: The `Date` field, representing the date on which the transfer should be executed,
    should not be past.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示应执行转账的日期的字段 `Date` 不应该是过去的。
- en: The BIC code, a standard identifier for the beneficiary’s bank, should be valid.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受益人银行的标准化标识符 BIC 代码应该是有效的。
- en: 'We’ll start with an OO design. (In chapter 9, I show a more thoroughly functional
    approach to this scenario.) Following the single-responsibility principle, we’ll
    write one class for each particular validation. Let’s draft a simple interface
    that all these validator classes will implement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从面向对象设计开始。（在第 9 章中，我展示了针对此场景的更彻底的函数式方法。）遵循单一职责原则，我们将为每个特定的验证编写一个类。让我们草拟一个所有这些验证器类都将实现的简单接口：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have our domain-specific abstractions in place, let’s start with
    a basic implementation. The next listing shows how this is done.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了我们的领域特定抽象，让我们从基本实现开始。接下来的列表展示了这是如何完成的。
- en: Listing 3.7 Implementing validation rules
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 实现验证规则
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That was fairly easy. Is the logic in `BicFormatValidator` pure? Yes, because
    there are no side effects and the result of `IsValid` is deterministic. What about
    `DateNotPastValidator`? In this case, the result of `IsValid` depends on the current
    date, so clearly, the answer is no! What kind of side effect are we facing here?
    It’s I/O: `DateTime.UtcNow` queries the system clock, which is outside the context
    of the program.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。`BicFormatValidator` 中的逻辑是纯的？是的，因为没有副作用，`IsValid` 的结果是确定的。那么 `DateNotPastValidator`
    呢？在这种情况下，`IsValid` 的结果取决于当前日期，所以显然答案是：不是！我们面临什么样的副作用？是 I/O：`DateTime.UtcNow` 查询系统时钟，这超出了程序的上下文。
- en: 'Functions that perform I/O are difficult to test. For example, consider the
    following test:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 I/O 的函数很难测试。例如，考虑以下测试：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ `sut` stands for “structure under test.”
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `sut` 代表“待测试结构”。
- en: ❷ This date used to be in the future!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个日期曾经是未来的！
- en: This test creates a `MakeTransfer` command to make a transfer on 2021-03-12\.
    (If you’re unfamiliar with the `with` expression syntax used in the example, I’ll
    discuss this in section 11.3.) It then asserts that the command should pass the
    date-not-past validation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试创建了一个 `MakeTransfer` 命令，在 2021-03-12 进行转账。（如果你不熟悉示例中使用的 `with` 表达式语法，我将在第
    11.3 节中讨论这个问题。）然后断言该命令应该通过日期非过去的验证。
- en: The test passes as I’m writing this, but it will fail by the time you’re reading
    it, unless you’re running it on a machine where the clock is set before 2021-03-12\.
    Because the implementation relies on the system clock, the test is not repeatable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写这个测试时，它通过了，但当你阅读它时，它将失败，除非你在设置时钟早于 2021-03-12 的机器上运行它。因为实现依赖于系统时钟，所以这个测试是不可重复的。
- en: Let’s take a step back and see why testing pure functions is fundamentally easier
    than testing impure ones. Then, in section 3.4, we’ll come back to this example
    and see how we can bring `DateNotPastValidator` under test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看为什么测试纯函数比测试不纯函数基本更容易。然后，在第 3.4 节中，我们将回到这个例子，看看我们如何将 `DateNotPastValidator`
    纳入测试。
- en: 3.3.3 Why testing impure functions is hard
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 为什么测试不纯函数很难
- en: When you write unit tests, what are you testing? A unit, of course, but what’s
    a unit exactly? Whatever unit you’re testing is a function *or can be viewed as
    one*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写单元测试时，你在测试什么？当然是一个单元，但一个单元究竟是什么呢？无论你测试的是哪个单元，它都是一个函数*或者可以被视为一个函数*。
- en: 'Unit tests need to be isolated (no I/O) and repeatable (you always get the
    same result, given the same inputs). These properties are guaranteed when you
    use pure functions. When you’re testing a pure function, testing is easy: you
    just give it an input and verify that the output is as expected (as figure 3.7
    illustrated).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试需要是隔离的（无 I/O）和可重复的（给定相同的输入，你总是得到相同的结果）。当你使用纯函数时，这些属性是保证的。当你测试一个纯函数时，测试很容易：你只需给它一个输入，并验证输出是否符合预期（如图
    3.7 所示）。
- en: '![](Images/CH03_F07_Buonanno2.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F07_Buonanno2.png)'
- en: 'Figure 3.7 Testing a pure function is easy: you simply provide inputs and verify
    that the outputs are as expected.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 测试纯函数很容易：你只需提供输入并验证输出是否符合预期。
- en: If you use the standard Arrange Act Assert (AAA) pattern in your unit tests
    and the unit you’re testing is a pure function, then the arrange step consists
    of defining the input values, the act step is the function invocation, and the
    assert step consists of checking that the output is as expected.[⁵](#pgfId-1111313)
    If you do this for a representative set of input values, you can be confident
    that the function works as intended.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用标准的安排-行动-断言 (AAA) 模式进行单元测试，并且你正在测试的单元是一个纯函数，那么安排步骤包括定义输入值，行动步骤是函数调用，断言步骤包括检查输出是否符合预期。[⁵](#pgfId-1111313)
    如果你为代表性的一组输入值这样做，你可以确信函数按预期工作。
- en: 'If, on the other hand, the unit you’re testing is an *impure* function, its
    behavior depends not only on its inputs but, possibly, also on the state of the
    program (any mutable state that’s not local to the function under test) and the
    state of the world (anything outside the context of your program). Furthermore,
    the function’s side effects can lead to a new state of the program and the world:
    for example,'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在测试的单元是一个 *不纯* 函数，其行为不仅取决于其输入，还可能取决于程序的状态（任何不是被测试函数局部可变的可变状态）和世界的状态（任何超出程序上下文的内容）。此外，函数的副作用可能导致程序和世界的新状态：例如，
- en: The date validator depends on the state of the world, specifically the current
    time.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期验证器依赖于现实世界的状态，特别是当前时间。
- en: A `void`-returning method that sends an email has no explicit output to assert
    against, but it results in a new state of the world.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `void` 的方法发送电子邮件没有明确的输出可以断言，但它会导致世界的新状态。
- en: A method that sets a non-local variable results in a new state of the program.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置非局部变量的方法会导致程序的新状态。
- en: As a result, you could view an impure function as a pure function that takes
    as input its arguments, along with the current state of the program and the world,
    and returns its outputs, along with a new state of the program and the world.
    Figure 3.8 shows this process.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将不纯函数视为一个纯函数，它接受其参数、程序和世界的当前状态作为输入，并返回其输出，以及程序和世界的新状态。图 3.8 展示了这一过程。
- en: '![](Images/CH03_F08_Buonanno2.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F08_Buonanno2.png)'
- en: Figure 3.8 Testing an impure function. You need to set up and assert against
    more than just the function inputs and output.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 测试不纯函数。你需要设置和断言的不仅仅是函数的输入和输出。
- en: Another way to look at this is that an impure function has implicit inputs other
    than its arguments or implicit outputs other than its return value or both.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，不纯函数除了其参数之外还有隐式输入，或者除了其返回值之外还有隐式输出，或者两者都有。
- en: How does this affect testing? Well, in the case of an impure function, the arrange
    stage must not only provide the explicit inputs to the function under test, but
    must additionally set up a representation of the state of the program and the
    world. Similarly, the assert stage must not only check the result, but also that
    the expected changes have occurred in the state of the program and the world.
    This is summarized in table 3.2.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何影响测试？嗯，对于不纯函数，安排阶段不仅必须提供函数的显式输入，还必须设置程序和世界的状态表示。同样，断言阶段不仅必须检查结果，还必须检查预期的变化已发生在程序和世界的状态中。这总结在表
    3.2 中。
- en: Tanle 3.2 Unit testing from a functional perspective
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 从功能视角进行单元测试
- en: '| AAA pattern | Functional perspective |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| AAA 模式 | 功能视角 |'
- en: '| Arrange | Sets up the (explicit and implicit) inputs to the function under
    test |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 安排 | 设置被测试函数的（显式和隐式）输入 |'
- en: '| Act | Evaluates the function under test |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 行动 | 评估被测试函数 |'
- en: '| Assert | Verifies the correctness of the (explicit and implicit) output |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 断言 | 验证（显式和隐式）输出的正确性 |'
- en: 'Again, we should distinguish between different kinds of side effects with respect
    to testing:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们应该在测试方面区分不同类型的副作用：
- en: Setting the state of the program and checking that it’s updated makes for brittle
    tests and breaks encapsulation.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置程序状态并检查其更新会导致脆弱的测试并破坏封装性。
- en: The state of the world can be represented by using stubs that create an artificial
    world in which the test runs.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用存根来表示世界状态，这些存根创建一个测试运行的人工世界。
- en: It’s hard work, but the technique is well understood. We’ll look at this next.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项艰巨的工作，但技术已被充分理解。我们将在下一节探讨这一点。
- en: 3.4 Testing code that performs I/O
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 测试执行 I/O 的代码
- en: In this section, you’ll see how we can bring code that depends on I/O operations
    under test. I’ll show you different approaches to *dependency injection*, contrasting
    the mainstream OO approach with a more functional approach.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解我们如何将依赖于 I/O 操作的代码置于测试之下。我将向你展示不同的**依赖注入**方法，对比主流的面向对象方法与更函数式的方法。
- en: 'To demonstrate this, let’s go back to the impure validation in `DateNotPastValidator`
    and see how we can refactor the code to make it testable. Here’s a reminder of
    the code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们回到 `DateNotPastValidator` 中的不纯验证，看看我们如何重构代码以使其可测试。以下是对代码的提醒：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The problem is that because `DateTime.UtcNow` accesses the system clock, it’s
    not possible to write tests that are guaranteed to behave consistently.[⁶](#pgfId-1111372)
    Let’s see how we can address this.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，因为 `DateTime.UtcNow` 访问系统时钟，所以无法编写保证行为一致的测试。[⁶](#pgfId-1111372) 让我们看看我们如何解决这个问题。
- en: 3.4.1 Object-oriented dependency injection
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 面向对象的依赖注入
- en: The mainstream technique for testing code that depends on I/O operations is
    to abstract these operations in an interface and to use a deterministic implementation
    in the tests. If you’re already familiar with this approach, skip to section 3.4.2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 测试依赖于 I/O 操作的代码的主流技术是在接口中抽象这些操作，并在测试中使用确定性实现。如果你已经熟悉这种方法，请跳到 3.4.2 节。
- en: 'This *interface-based approach* to dependency injection is considered a best
    practice, but I’ve come to think of it as an anti-pattern. This is because of
    the amount of boilerplate it entails. It involves the following steps, which we’ll
    look at in greater detail in the following sections:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于**接口**的依赖注入方法被认为是最佳实践，但我已经认为它是一个反模式。这是因为它涉及大量的模板代码。它包括以下步骤，我们将在接下来的章节中更详细地探讨：
- en: Define an interface that abstracts the I/O operations performed by the code
    you want to bring under test and put the impure implementation in a class that
    implements that interface.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个接口，该接口抽象了你想要测试的代码执行的 I/O 操作，并将不纯实现放在实现该接口的类中。
- en: In the class under test, require the interface in the constructor, store it
    in a field, and consume it as needed.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试类中，构造函数中要求接口，将其存储在字段中，并按需使用它。
- en: Create and inject a stubbed implementation for the purposes of unit testing.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并注入一个用于单元测试的存根实现。
- en: Introduce some bootstrapping logic so that the impure implementation is provided
    at run time when the class under test is instantiated.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一些引导逻辑，以便在测试类实例化时在运行时提供不纯实现。
- en: Abstracting I/O with an interface
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口抽象 I/O
- en: 'Instead of calling `DateTime.UtcNow` directly, you abstract access to the system
    clock. That is, you define an interface and an implementation that performs the
    desired I/O like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接调用 `DateTime.UtcNow`，你抽象了对系统时钟的访问。也就是说，你定义了一个接口和一个执行所需 I/O 的实现，如下所示：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Encapsulates the impure behavior in an interface
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在接口中封装不纯行为
- en: ❷ Provides a default implementation
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供默认实现
- en: Consuming the interface
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 消费接口
- en: You then refactor the date validator to consume this interface instead of accessing
    the system clock directly. The validator’s behavior now *depends* on the interface
    of which an instance should be injected (usually in the constructor). The following
    listing shows how to do this.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将日期验证器重构为使用此接口而不是直接访问系统时钟。验证器的行为现在**取决于**应该注入的接口实例（通常在构造函数中）。以下列表显示了如何做到这一点。
- en: Listing 3.8 Refactoring a class to consume an interface
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 重构一个类以使用接口
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Injects the interface in the constructor
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在构造函数中注入接口
- en: ❷ Validation now depends on the interface.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证现在依赖于接口。
- en: 'Let’s look at the refactored `IsValid` method: is it a pure function? Well,
    the answer is, it *depends*! It depends, of course, on the implementation of `IDateTimeService`
    that’s injected:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看重构后的 `IsValid` 方法：它是一个纯函数吗？嗯，答案是，它**取决于**！当然，这取决于注入的 `IDateTimeService`
    的实现：
- en: When running normally, you’ll compose your objects so that you get the real
    *impure* implementation that checks the system clock.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当正常运行时，你会组合你的对象，以便得到检查系统时钟的真正**不纯**实现。
- en: When running unit tests, you’ll inject a fake *pure* implementation that does
    something predictable, such as always returning the same `DateTime`, enabling
    you to write tests that are repeatable.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行单元测试时，你会注入一个假的**纯**实现，该实现执行某些可预测的操作，例如总是返回相同的 `DateTime`，这样你就可以编写可重复的测试。
- en: Inject a stub when testing
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时注入存根
- en: The following listing shows how you can write tests using this approach.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用这种方法编写测试。
- en: Listing 3.9 Testing by injecting a predictable implementation
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 通过注入可预测的实现进行测试
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Provides a pure, fake implementation
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供一个纯的、假的实现
- en: ❷ Injects the fake
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注入假的
- en: That is, we create a stub, a *fake* implementation that, unlike the real one,
    has a deterministic result.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们创建了一个存根，一个*假的*实现，与真实实现不同，它有一个确定的结果。
- en: Setting up the dependencies
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 设置依赖项
- en: 'We’re still not done because we need to provide `DateNotPastValidator` with
    the `IDateTimeService` it depends on at run time. This can be done in a variety
    of ways, both manually and with the help of a framework, depending on the complexity
    of your program and your technologies of choice.[⁷](#pgfId-1111468) In an ASP.NET
    application, it may end up looking like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为我们需要在运行时为`DateNotPastValidator`提供它所依赖的`IDateTimeService`。这可以通过多种方式完成，无论是手动还是借助框架，具体取决于你程序的复杂性和选择的技术。[⁷](#pgfId-1111468)
    在一个ASP.NET应用程序中，它可能看起来像这样：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code registers the real, impure implementation `DefaultDateTimeService`,
    associating it with the `IDateTimeService` interface. As a result, when a `DateNotPastValidator`
    is required, ASP.NET sees that it needs an `IDateTimeService` in the constructor
    and provides it an instance of `DefaultDateTimeService`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码注册了真实的、不纯的实现`DefaultDateTimeService`，将其与`IDateTimeService`接口关联。因此，当需要`DateNotPastValidator`时，ASP.NET看到它需要在构造函数中需要一个`IDateTimeService`，并提供了一个`DefaultDateTimeService`的实例。
- en: Pitfalls of the interface-based approach
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 基于接口方法的陷阱
- en: Unit tests are so valuable that developers gladly put up with all this effort,
    even for something as simple as `DateTime.UtcNow`. One of the least desirable
    effects of using the interface-based approach systematically is the explosion
    in the number of interfaces because you must define an interface for every component
    that has an I/O element.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试非常有价值，以至于开发者愿意承受所有这些努力，即使是为了像`DateTime.UtcNow`这样简单的事情。使用基于接口的方法系统地使用的一个最不希望看到的效果是接口数量的激增，因为你必须为每个具有I/O元素的组件定义一个接口。
- en: Most applications are developed with an interface for every service, even when
    only one concrete implementation is envisaged. These are called *header interfaces*,
    and they’re not what interfaces were initially designed for (a common contract
    with several different implementations), but they’re used across the board. You
    end up with more files, more indirection, more assemblies, and code that’s difficult
    to navigate.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都是用每个服务的一个接口来开发的，即使只设想了一个具体的实现。这些被称为*头接口*，它们并不是接口最初设计的目的（与几个不同实现的一个通用合同），但它们被广泛使用。你最终会有更多的文件、更多的间接引用、更多的程序集，以及难以导航的代码。
- en: Avoiding trivial constructors
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 避免平凡的构造函数
- en: One of the issues of refactoring a class to consume an interface (shown in listing
    3.8) is the need to define a trivial constructor. All that this constructor does
    is store its input arguments in class fields. In a complex enough application,
    this creates a lot of boilerplate.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类重构为消费接口（如列表3.8所示）的一个问题是需要定义一个平凡的构造函数。这个构造函数所做的只是将输入参数存储在类字段中。在一个足够复杂的应用程序中，这会创建大量的样板代码。
- en: 'Many languages spare you such ceremony by having *primary constructors*. This
    feature is not available for classes, but since C# 9, you can use records instead.
    The code in listing 3.8 could be refactored as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言通过拥有*主构造函数*来节省这种仪式。这个特性对于类来说不可用，但自从C# 9以来，你可以使用记录。列表3.8中的代码可以重构如下：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The positional record syntax automatically generates a constructor into which
    you can inject the required `IDateTimeService` and a public property called `DateService`.
    If you feel that the generated property pollutes the class’s public API, you can
    explicitly specify that the property should be private. The preceding code shows
    how to do this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 位置记录语法自动生成一个构造函数，你可以将其注入所需的`IDateTimeService`和一个名为`DateService`的公共属性。如果你觉得生成的属性污染了类的公共API，你可以明确指定该属性应该是私有的。前面的代码展示了如何做到这一点。
- en: 3.4.2 Testability without so much boilerplate
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 减少样板代码的测试性
- en: I’ve discussed the pitfalls of the interface-based approach to dependency injection.
    In this subsection, I’ll show you some simpler alternatives. Namely, instead of
    consuming an interface, the code under test can consume a function or, sometimes,
    simply a value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经讨论了基于接口的依赖注入方法的陷阱。在本小节中，我将向你展示一些更简单的替代方案。具体来说，测试代码不是消费一个接口，而是消费一个函数，有时甚至只是一个值。
- en: Pushing the pure boundary outwards
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将纯净边界向外扩展
- en: Can we get rid of the whole problem and make everything pure? No, we’re required
    to check the current date. This is an operation with a nondeterministic result.
    But sometimes, we can push the boundaries of pure code. For instance, what if
    you rewrote the date validator as in the following listing?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否消除整个问题并使一切纯净？不，我们需要检查当前日期。这是一个具有非确定性结果的操作。但有时，我们可以扩展纯净代码的边界。例如，如果你像以下列表中那样重写日期验证器呢？
- en: Listing 3.10 Injecting a specific value, not an interface, making `IsValid`
    pure
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 注入一个特定的值，而不是接口，使`IsValid`纯净
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead of injecting an interface, exposing some method you can invoke, we
    inject a *value*. Now the implementation of `IsValid` is pure! You’ve effectively
    pushed the side effect of reading the current date outward to the code instantiating
    the validator. To set up the creation of this validator, you might use some code
    like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是注入一个接口，而是暴露一个可以调用的方法，而是注入一个*值*。现在`IsValid`的实现是纯净的！你实际上已经将读取当前日期的副作用推到了创建验证器的代码中。为了设置创建此验证器的设置，你可能需要使用一些像这样的代码：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Without going into detail, this code defines a function to be called whenever
    a `DateNotPastValidator` is required, and within this function, the current date
    creates the new instance. Note that this requires `DateNotPastValidator` to be
    transient; we have a new instance created when one is needed to validate an incoming
    request. This is a reasonable behavior in this case.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，此代码定义了一个函数，每当需要`DateNotPastValidator`时就会调用该函数，在这个函数内部，当前日期创建了一个新实例。请注意，这要求`DateNotPastValidator`是瞬时的；当需要验证传入的请求时，我们会创建一个新的实例。在这种情况下，这是一种合理的行为。
- en: Consuming a value rather than a method that performs I/O is an easy win, making
    more of your code pure and, thus, easily testable. This approach works well when
    your logic depends on, say, configurations that are stored in a file or environment-specific
    settings. But things are not always this easy, so let’s move on to a more general
    solution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 消费一个执行I/O的方法而不是一个值，这是一个简单的胜利，可以使你的代码更加纯净，从而更容易测试。当你的逻辑依赖于存储在文件中或特定环境设置中的配置时，这种方法效果很好。但事情并不总是这么简单，所以让我们继续探讨一个更通用的解决方案。
- en: Injecting functions as dependencies
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为依赖项注入
- en: Imagine that when a `MakeTransfer` request is received, a list of several validators,
    each enforcing a different rule, is created. If one validation fails, the request
    fails, and the subsequent validators will not be called.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当收到`MakeTransfer`请求时，会创建一个包含几个验证器的列表，每个验证器强制执行不同的规则。如果其中一个验证失败，请求就会失败，后续的验证器将不会被调用。
- en: 'Furthermore, imagine that querying the system clock is expensive (it isn’t,
    but most I/O operations are). You don’t want to do that every time the validator
    is created, but only when it’s actually used. You can achieve this by injecting
    a function, rather than a value, which the validator calls as needed:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设查询系统时钟是昂贵的（实际上并不昂贵，但大多数I/O操作都是）。你不想每次创建验证器时都这样做，而只想在实际使用时才这样做。你可以通过注入一个函数，而不是一个值，让验证器按需调用这个函数来实现这一点：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I’ve called the injected function `Clock`, because what’s a clock if not a
    function you can call to get the current time? The implementation of `IsValid`
    now performs no side effects *other than* those performed by `Clock`, so it can
    easily be tested by injecting a “broken clock”:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我把注入的函数叫做`Clock`，因为如果不是一个可以调用以获取当前时间的函数，那什么是时钟呢？`IsValid`的实现现在不执行除了`Clock`执行的任何副作用，因此可以很容易地通过注入一个“损坏的时钟”来测试：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On the other hand, when creating the validator, you’ll pass a function that
    actually queries the system clock, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在创建验证器时，你需要传递一个实际查询系统时钟的函数，如下所示：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that because the function that returns the current date is now called
    by the validator, it’s no longer required to have the validator be short-lived.
    You could use it as a singleton as I showed in the preceding snippet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为返回当前日期的函数现在是由验证器调用的，所以不再需要验证器是短暂的。你可以像前面代码片段中展示的那样将其用作单例。
- en: 'This solution ticks all the boxes: the validator can now be tested deterministically,
    no I/O will be performed unless required, and we don’t need to define any unnecessary
    interfaces or trivial classes. We’ll pursue this approach further in chapter 9\.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案满足了所有条件：验证器现在可以确定性测试，除非需要，否则不会执行任何I/O，我们也不需要定义任何不必要的接口或简单的类。我们将在第9章中进一步探讨这种方法。
- en: Injecting a delegate for more clarity
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注入一个代表以增加清晰度
- en: 'If you go down the route of injecting a function, you could consider going
    the extra mile. You can define a delegate rather than simply using a `Func`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择注入一个函数，你可以考虑走得更远。你可以定义一个委托而不是简单地使用 `Func`：
- en: '[PRE30]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code for testing remains identical; in the setup, you can potentially gain
    in clarity by just registering a `Clock`. Once that’s done, the framework knows
    to use that when the validator that requires a `Clock` is created:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码保持不变；在设置中，你可以在注册一个 `Clock` 的同时提高清晰度。一旦完成，框架就知道在创建需要 `Clock` 的验证器时使用它：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Parameterized unit tests
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化单元测试
- en: 'Regardless of what approach you use to bring `DateNotPastValidator` under test,
    you can use parameterized unit tests. Parameterized tests allow you to test your
    code with a variety of input values. They tend to be more functional because they
    make you think in terms of inputs and outputs. For example, the following shows
    how you can test that the date-not-past validation works in a variety of cases:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么方法来对 `DateNotPastValidator` 进行测试，你都可以使用参数化单元测试。参数化测试允许你使用各种输入值来测试你的代码。它们往往更具有功能性，因为它们让你从输入和输出的角度思考。例如，以下展示了如何测试日期非过去验证在各种情况下的工作情况：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code uses NUnit’s `TestCase` attribute to effectively run three tests:
    a transfer requested to take place today (relatively to a hard-coded date), yesterday,
    and tomorrow. The XUnit testing framework has the `Theory` and `InlineData` attributes
    that allow you to do the same thing, whereas in MSTest, it’s called `DataRow`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 NUnit 的 `TestCase` 属性有效地运行了三个测试：今天（相对于硬编码的日期）请求转账、昨天和明天。XUnit 测试框架有 `Theory`
    和 `InlineData` 属性，允许你做同样的事情，而在 MSTest 中，它被称为 `DataRow`。
- en: 'Parameterized tests have the advantage that you can test a variety of scenarios
    just by tweaking the parameter values. Should a client be able to request a transfer
    for a date that’s more than one year in the future? If not, you can add a test
    to verify this with a single line:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试的优势在于，你只需调整参数值就可以测试各种场景。客户是否能够请求一年以后的转账？如果不能，你可以添加一条测试来验证这一点，只需一行代码即可：
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that the test method now is itself a function: it maps the given parameter
    values to an output that NUnit can check. In fact, it’s a pure function, given
    that assertions (which throw exceptions) have been pushed out of the test method
    and are performed by the testing framework.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在的测试方法本身就是一个函数：它将给定的参数值映射到 NUnit 可以检查的输出。实际上，它是一个纯函数，因为断言（会抛出异常）已经被推离了测试方法，并由测试框架执行。
- en: A parameterized test is essentially just an adapter for the function under test.
    In this example, the test creates an artificial state of the world with a hard-coded
    present date. It then maps the test’s input parameter (the offset between the
    present date and the requested transfer date) to a suitably populated `MakeTransfer`
    object, which is given as input to the function under test.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试本质上只是对被测试函数的一个适配器。在这个例子中，测试创建了一个具有硬编码当前日期的人工世界状态。然后，它将测试的输入参数（当前日期与请求转账日期之间的偏移量）映射到一个适当填充的
    `MakeTransfer` 对象，该对象作为输入传递给被测试的函数。
- en: 3.5 Purity and the evolution of computing
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 纯度与计算的发展
- en: I hope that this chapter has made the concept of function purity less mysterious
    and has shown why extending the footprint of pure code is a worthwhile objective.
    This improves the maintainability, performance, and testability of your code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一章使函数纯度的概念不再神秘，并展示了为什么扩展纯代码的足迹是一个值得追求的目标。这提高了代码的可维护性、性能和可测试性。
- en: The evolution of software and hardware also has important consequences for how
    we think about purity. Our systems are increasingly distributed, so the I/O part
    of our programs is increasingly important. With microservices architectures becoming
    mainstream, our programs consist less of doing computation and more of delegating
    computation to other services, which they communicate with via I/O.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 软件和硬件的发展也对我们的纯度思考方式产生了重要影响。我们的系统越来越分布式，因此程序的 I/O 部分变得越来越重要。随着微服务架构的普及，我们的程序越来越少地涉及计算，更多地是将计算委托给其他服务，它们通过
    I/O 与这些服务进行通信。
- en: This increase in I/O requirements means purity is harder to achieve. But it
    also means increased requirements for asynchronous I/O. As you’ve seen, purity
    helps you deal with concurrent scenarios, which include dealing with asynchronous
    messages.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 I/O 需求的增加意味着纯度更难实现。但它也意味着对异步 I/O 的要求增加。正如你所看到的，纯度有助于你处理并发场景，包括处理异步消息。
- en: 'Hardware evolution is also important: CPUs aren’t getting faster at the same
    pace as before, so hardware manufacturers are moving toward combining multiple
    processors and cores. Parallelization is becoming the main road to computing speed,
    so there’s a need to write programs that can be parallelized well. Indeed, the
    move toward multicore machines is one of the main reasons for the renewed interest
    we’re currently seeing in FP.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件进化也很重要：CPU 的速度增长速度不如以前，因此硬件制造商正在转向结合多个处理器和核心。并行化正成为提高计算速度的主要途径，因此需要编写可以很好地并行化的程序。确实，向多核机器的转变是我们目前重新对函数式编程产生兴趣的主要原因之一。
- en: Exercises
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a console app that calculates a user’s Body Mass Index (BMI):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个控制台应用程序，计算用户的身体质量指数（BMI）：
- en: Prompt the user for their height in meters and weight in kilograms.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入他们的身高（以米为单位）和体重（以千克为单位）。
- en: Calculate the BMI as weight / height².
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算BMI为体重除以身高²。
- en: 'Output a message: underweight (BMI < 18.5), overweight (BMI >= 25), or healthy.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出一条消息：体重过轻（BMI < 18.5）、超重（BMI >= 25）或健康。
- en: Structure your code so that pure and impure parts are separate.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的代码结构化，使纯部分和不纯部分分离。
- en: Unit test the pure parts.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对纯部分进行单元测试。
- en: Unit test the overall workflow using the function-based approach to abstract
    away the reading from and writing to the console.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于函数的方法来抽象从控制台读取和写入的操作，对整体工作流程进行单元测试。
- en: Because most of this chapter was devoted to seeing the concept of purity in
    practice, I encourage you to investigate, applying the techniques we discussed
    to some code you’re presently working on. You can learn something new while getting
    paid for it!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因为本章的大部分内容都是关于在实践中看到纯度的概念，我鼓励你调查，将我们讨论的技术应用于你目前正在工作的代码中。你可以在赚钱的同时学到新东西！
- en: Find a place where you’re doing some non-trivial operation based on a list (search
    for `foreach`). See if the operation can be parallelized; if not, see if you can
    extract a pure part of the operation and parallelize that part.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个基于列表进行一些非平凡操作的地方（例如搜索`foreach`）。看看这个操作是否可以并行化；如果不能，看看是否可以提取操作的纯部分并并行化这部分。
- en: Search for uses of `DateTime.Now` or `DateTime.UtcNow` in your codebase. If
    that area isn’t under test, bring it under test using both the interface-based
    approach and the function-based approach described in this chapter.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码库中搜索 `DateTime.Now` 或 `DateTime.UtcNow` 的用法。如果该区域没有经过测试，请使用本章中描述的基于接口的方法和基于函数的方法将其纳入测试。
- en: Look for other areas of your code where you’re relying on an impure dependency
    that has no transitive dependencies. The obvious candidates are static classes
    such as `ConfigurationManager` or `Environment` that cross the application boundary.
    Try to apply the function-based testing pattern.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码的其他部分寻找你依赖于没有传递依赖的不纯依赖项的地方。明显的候选者是跨越应用程序边界的静态类，如`ConfigurationManager`或`Environment`。尝试应用基于函数的测试模式。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Compared to mathematical functions, programming functions are more difficult
    to reason about because their output may depend on variables other than their
    input arguments.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数学函数相比，编程函数更难推理，因为它们的输出可能取决于除了输入参数之外的变量。
- en: Side effects include state mutation, throwing exceptions, and I/O.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用包括状态突变、抛出异常和I/O。
- en: Functions without side effects are called *pure*. These functions do nothing
    other than return a value that depends solely on their input arguments.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有副作用的函数被称为 *纯函数*。这些函数除了返回一个仅取决于其输入参数的值之外，不做任何其他事情。
- en: Pure functions can be more readily optimized and tested than impure ones, and
    they can be used more reliably in concurrent scenarios. You should prefer pure
    functions whenever possible.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数比不纯函数更容易优化和测试，并且在并发场景中更可靠。在可能的情况下，你应该优先选择纯函数。
- en: Unlike other side effects, I/O can’t be avoided, but you can still isolate the
    parts of your application that perform I/O in order to reduce the footprint of
    impure code.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他副作用不同，I/O 无法避免，但你仍然可以隔离应用程序中执行 I/O 的部分，以减少不纯代码的影响。
- en: '* * *'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ More theoretically inclined authors show how you can reason about pure functions
    algebraically to prove the correctness of your program; see, for example, Graham
    Hutton’s *Programming in Haskell*, 2nd ed. Cambridge, UK: Cambridge University
    Press, 2016.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 一些更倾向于理论化的作者展示了如何可以通过代数推理纯函数来证明程序的正确性；例如，参见 Graham Hutton 的 *Programming in
    Haskell*，第 2 版，剑桥，英国：剑桥大学出版社，2016 年。
- en: ² I should point out that *completely* avoiding state mutation is not always
    easy and not always practical. But avoiding state mutation most of the time is,
    and this is something you should be aiming toward.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ² 我应该指出，*完全*避免状态变化并不总是容易的，也不总是实用的。但大多数时候避免状态变化是可行的，这是你应该努力实现的目标。
- en: ³ In many languages, you’d have functions like this as freestanding functions,
    but methods in C# need to be inside a class. It’s mostly a matter of taste where
    you put your static functions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 在许多语言中，你会有这样的独立函数，但在 C# 中，方法需要位于类内部。将静态函数放在哪里主要是一个品味问题。
- en: ⁴ PLINQ is an implementation of LINQ that works in parallel.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ PLINQ 是 LINQ 的并行实现。
- en: '⁵ AAA is a ubiquitous pattern for structuring the code in unit tests. According
    to this pattern, a test consists of three steps: *arrange* prepares any prerequisites,
    *act* performs the operation being tested, and *assert* runs assertions against
    the obtained result.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ AAA 是在单元测试中组织代码的通用模式。根据这个模式，一个测试由三个步骤组成：*arrange* 准备任何先决条件，*act* 执行被测试的操作，*assert*
    对获得的结果运行断言。
- en: ⁶ You could try writing a test that reads from the system clock when populating
    the input `MakeTransfer`. This may work in most cases, but there is a small window
    around midnight during which, when arranging the inputs for the test, the date
    is different than the date when `IsValid` is called. You’re not, in fact, guaranteed
    consistency after all. Furthermore, we need an approach that will work with any
    I/O operation, not just accessing the clock.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ 你可以尝试编写一个测试，在填充输入 `MakeTransfer` 时从系统时钟读取。这在大多数情况下可能有效，但在午夜前后有一个小的时间窗口，在这个时间窗口内，当安排测试的输入时，日期与调用
    `IsValid` 时的日期不同。实际上，你并不能保证始终一致。此外，我们需要一个可以与任何 I/O 操作一起工作的方法，而不仅仅是访问时钟。
- en: ⁷ Manually composing all classes in a complex application can become quite a
    chore. To mitigate this, some frameworks allow you to declare what implementations
    to use for any interface that’s required. These are called IoC containers, where
    IoC stands for *inversion of control*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 在复杂应用程序中手动组合所有类可能变得相当繁琐。为了减轻这种情况，一些框架允许你声明所需接口的实现。这些被称为 IoC 容器，其中 IoC 代表 *控制反转*。
