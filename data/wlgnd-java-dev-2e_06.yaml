- en: 4 Class files and bytecode
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 类文件和字节码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Class loading
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载
- en: Reflection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: The anatomy of class files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类文件的解剖结构
- en: JVM bytecode and why it matters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM字节码及其重要性
- en: One tried-and-true way to become a more well-grounded Java developer is to improve
    your understanding of how the platform works. Getting familiar with core features
    such as class loading and the nature of JVM bytecode can greatly help with this
    goal.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 成为一个更加扎实的Java开发者的一个经过验证的方法是提高你对平台工作原理的理解。熟悉核心功能，如类加载和JVM字节码的本质，将极大地帮助你实现这一目标。
- en: 'Consider the following scenarios that a senior Java developer might encounter:
    Imagine you have an application that makes heavy use of dependency injection (DI)
    techniques such as Spring, and it develops problems starting up and fails with
    a cryptic error message. If the problem is more than a simple configuration error,
    you may need to understand how the DI framework is implemented to track down the
    problem. This means understanding class loading.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一个资深Java开发者可能会遇到的情况：想象一下，你有一个大量使用依赖注入（DI）技术（如Spring）的应用程序，它在启动时出现问题，并带有难以理解的错误信息。如果问题不仅仅是简单的配置错误，你可能需要了解DI框架的实现方式，以便追踪问题。这意味着你需要理解类加载。
- en: Or suppose that a vendor you’re dealing with goes out of business. You’re left
    with a final drop of compiled code, no source code, and patchy documentation.
    How can you explore the compiled code and see what it contains?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 或者假设你正在与之合作的供应商倒闭了。你只剩下最后一点编译后的代码，没有源代码，文档也不完整。你如何探索编译后的代码，看看它包含什么？
- en: All but the simplest applications can fail with a `ClassNotFoundException` or
    `NoClassDefFoundError`, but many developers don’t know what these are, what the
    difference is between them, or even why they occur.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最简单的应用外，所有应用都可能因为`ClassNotFoundException`或`NoClassDefFoundError`而失败，但许多开发者并不了解这些错误，也不知道它们之间的区别，甚至不知道它们为什么会发生。
- en: This chapter focuses on the aspects of the platform that underlie these concerns.
    We’ll also discuss some more advanced features, but they are intended for those
    folks who like to dive deep and can be skipped if you’re in a hurry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍这些关注点背后的平台方面。我们还将讨论一些更高级的功能，但它们是为那些喜欢深入研究的人准备的，如果你时间紧迫，可以跳过这些内容。
- en: We’ll get started with an overview of class loading—the process by which the
    JVM locates and activates a new type for use in a running program. Central to
    that discussion are the `Class` objects that represent types in the JVM. Next,
    we’ll look at how these concepts build into the major language feature known as
    reflection (or Core Reflection).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从类加载的概述开始——这是JVM定位和激活新类型以便在运行程序中使用的过程。该讨论的核心是代表JVM中类型的`Class`对象。接下来，我们将探讨这些概念如何构建成称为反射（或核心反射）的主要语言功能。
- en: After that, we’ll discuss tools for examining and dissecting class files. We’ll
    use `javap`, which ships with the JDK, as our reference tool. Following this class
    file anatomy lesson, we’ll turn to bytecode. We’ll cover the major families of
    JVM opcodes and look at how the runtime operates at a low level.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将讨论用于检查和解剖类文件的工具。我们将使用与JDK一起提供的`javap`作为我们的参考工具。在完成类文件解剖课程之后，我们将转向字节码。我们将介绍JVM操作码的主要家族，并查看运行时在低级别是如何操作的。
- en: Let’s get started by discussing *class loading*—the process by which new classes
    are incorporated into a running JVM process. In this section, we will first discuss
    the basics of “classic” class loading, as it was done in Java 8 and earlier. Later
    in the chapter, we will talk about how the arrival of the modular JVM introduces
    some (small) changes to class loading.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论*类加载*开始——这是将新类纳入正在运行的JVM进程的过程。在本节中，我们将首先讨论“经典”类加载的基础，正如Java 8及之前版本所做的那样。在章节的后面部分，我们将讨论模块化JVM的出现如何对类加载带来一些（较小的）变化。
- en: 4.1 Class loading and class objects
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 类加载和类对象
- en: A .class file defines a type for the JVM, complete with fields, methods, inheritance
    information, annotations, and other metadata. The class file format is well-described
    by the standards, and any language that wants to run on the JVM must adhere to
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`.class`文件为JVM定义了一个类型，包括字段、方法、继承信息、注解和其他元数据。类文件格式由标准详细描述，任何希望在JVM上运行的语言都必须遵守它。'
- en: Note A class is the fundamental unit of program code that the Java platform
    will understand, accept, and execute.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类是Java平台将理解、接受和执行的程序代码的基本单元。
- en: From the perspective of a beginning Java developer, a lot of the class loading
    mechanism is hidden from view. The developer provides either an executable JAR
    file or the name of the main application class (which must be present on the classpath),
    and the JVM finds and executes the class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个初学 Java 开发者的角度来看，许多类加载机制是隐藏的。开发者提供可执行 JAR 文件或主应用程序类的名称（该名称必须存在于类路径上），然后 JVM
    找到并执行该类。
- en: Any application dependencies (e.g., libraries other than the JDK) must also
    be on the classpath, and the JVM finds and loads them as well. However, the Java
    specifications do not say whether this needs to be done at application startup
    or later, as needed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序依赖项（例如，除了 JDK 之外的库）也必须在类路径上，JVM 会找到并加载它们。然而，Java 规范没有说明这需要在应用程序启动时完成，还是根据需要稍后完成。
- en: Note The API that the Java class loading system presents to the user is fairly
    simple—a lot of the complexity is hidden on purpose, and we will discuss the developer-available
    API later in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Java 类加载系统向用户提供的 API 相对简单——很多复杂性都是故意隐藏的，我们将在本章后面讨论开发者可用的 API。
- en: 'Let’s start with a very simple example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This piece of code will load a class, `MyClass`, into the current execution
    state. From the JVM’s perspective, to achieve this a number of steps must be performed.
    First, a class file corresponding to the name `MyClass` must be found, and then
    the class it contains it must be resolved. These steps are performed in native
    code—in HotSpot, the native method is called `JVM_DefineClass()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将加载一个名为 `MyClass` 的类到当前执行状态中。从 JVM 的角度来看，为了实现这一点，必须执行一系列步骤。首先，必须找到与 `MyClass`
    名称对应的类文件，然后解析其中包含的类。这些步骤在本地代码中执行——在 HotSpot 中，本地方法被调用为 `JVM_DefineClass()`。
- en: The actual process, at a high level, is that the native code builds the JVM’s
    internal representation (which is called a *klass* and which is not a Java object—we
    will meet it properly in chapter 17). Then, provided the klass can be extracted
    from the class file successfully, the JVM constructs a Java “mirror” of the klass,
    which is passed back to Java code as a `Class` object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际过程在高层上，是本地代码构建 JVM 的内部表示（称为 *klass*，它不是 Java 对象——我们将在第 17 章中详细介绍）。然后，如果 klass
    能够成功从类文件中提取出来，JVM 将构建一个 Java “镜像”的 klass，并将其作为 `Class` 对象传递回 Java 代码。
- en: After this, the `Class` object representing the type is available to the running
    system, and new instances of it can be created. In the previous example, `clazz`
    ends up holding the `Class` object corresponding to the type `MyClass`. It cannot
    hold the klass, because a klass is a JVM-internal object and *not* a Java object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，代表类型的 `Class` 对象对运行系统可用，可以创建其新的实例。在先前的例子中，`clazz` 最终持有代表 `MyClass` 类型的 `Class`
    对象。它不能持有 klass，因为 klass 是 JVM 内部对象，*不是* Java 对象。
- en: Note The same process is used for the main application class, all of its dependencies,
    and any other classes that may be required after the program has started.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：相同的流程也用于主应用程序类、所有依赖项以及程序启动后可能需要的任何其他类。
- en: In this section, we’ll cover the steps from the JVM’s point of view in a bit
    more detail and provide an introduction to class loaders, which are the objects
    that control this entire process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地介绍 JVM 视角下的步骤，并介绍类加载器，它是控制整个过程的对象。
- en: 4.1.1 Loading and linking
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 加载和链接
- en: One way of looking at the JVM is that it is an execution container. In this
    view, the purpose of the JVM is to consume class files and execute the bytecode
    they contain. To achieve this, the JVM must retrieve the contents of the class
    file as a data stream of bytes, convert it to a useable form, and add it to the
    running state. This is essentially the process that we are describing here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个角度来看，JVM 可以被视为一个执行容器。在这个观点下，JVM 的目的是消费类文件并执行其中包含的字节码。为了实现这一点，JVM 必须以字节流的形式检索类文件的内容，将其转换为可用的形式，并将其添加到运行状态中。这正是我们在这里所描述的过程。
- en: This somewhat complex process can be divided in a number of ways, but we refer
    to it as *loading* and *linking*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对复杂的过程可以以多种方式划分，但我们将它称为 *加载* 和 *链接*。
- en: Note Our discussion of loading and linking refers to some details that are specific
    to the HotSpot code, but other implementations should do similar things.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们关于加载和链接的讨论涉及一些特定于 HotSpot 代码的细节，但其他实现应该做类似的事情。
- en: The first step is to acquire the data stream of bytes that constitute the class
    file. This process starts with a byte array that is often read in from a filesystem
    (but other alternatives are definitely possible).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取构成类文件的字节序列数据流。这个过程通常从一个从文件系统读取的字节数组开始（但其他替代方案肯定也是可能的）。
- en: Once we have the stream, it must be parsed to check that it contains a valid
    class file structure (this is sometimes called *format checking*). If so, then
    a candidate klass is created. During this phase, while the candidate klass is
    being filled in, some basic checks are performed (e.g., can the class being loaded
    actually access its declared superclass? Does it try to override any `final` methods?).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数据流，就必须解析它以检查它是否包含有效的类文件结构（这有时被称为*格式检查*）。如果是这样，那么就会创建一个候选klass。在这个阶段，当候选klass正在填充时，会执行一些基本检查（例如，正在加载的类实际上能否访问其声明的超类？它是否试图覆盖任何`final`方法？）。
- en: However, at the end of the loading process, the data structure corresponding
    to the class isn’t usable by other code yet, and, in particular, we don’t have
    a fully functional klass.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在加载过程结束时，对应于类的数据结构还不能被其他代码使用，特别是我们还没有一个完全功能的klass。
- en: 'To get there, the class must now be linked and then initialized before it can
    be used. Logically speaking, this step breaks down into three subphases: verification,
    preparation, and resolution. However, in a real implementation, the code might
    not be cleanly separated out, so if you are planning to read the source code,
    you should be aware that the description provided here is a high-level or conceptual
    description of the process and does not have a precise correlation to the actual
    implementing code.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达那里，类必须在被使用之前先进行链接和初始化。从逻辑上讲，这一步可以分为三个子阶段：验证、准备和解决。然而，在实际实现中，代码可能并没有被干净地分离出来，所以如果你打算阅读源代码，你应该意识到这里提供的描述是对过程的高层次或概念性描述，并不与实际实现代码有精确的对应关系。
- en: With this in mind, verification can be understood to be the phase that confirms
    that the class conforms to the requirements of the Java specifications and won’t
    cause runtime errors or other problems for the running system. This relationship
    between the phases of linking can be seen in figure 4.1.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，验证可以理解为确认类符合Java规范的要求，并且不会在运行时引起错误或其他问题的阶段。这种链接阶段的相互关系可以在图4.1中看到。
- en: '![](../Images/CH04_F01_Evans2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F01_Evans2.png)'
- en: Figure 4.1 Loading and linking (with subphases of linking)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 加载和链接（链接的子阶段）
- en: Let’s meet each phase in turn.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次了解每个阶段。
- en: Verification
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 验证
- en: Verification is quite a complex process, consisting of several independent concerns.
    For example, the JVM needs to check that symbolic information contained in the
    constant pool (discussed in detail in section 4.3.3) is self-consistent and obeys
    the basic behavior rules for constants.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是一个相当复杂的过程，由几个独立的部分组成。例如，JVM需要检查常量池中包含的符号信息（在4.3.3节中详细讨论）是否自洽，并遵守常量的基本行为规则。
- en: Another major concern, and probably the most complex part of verification, is
    checking the bytecode of methods. This involves ensuring that the bytecode is
    well-behaved and doesn’t try to circumvent the JVM’s environmental controls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要关注点，可能是验证中最复杂的一部分，是检查方法的字节码。这涉及到确保字节码表现良好，并且不会试图绕过JVM的环境控制。
- en: 'Some of the main checks that are performed follow:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的一些主要检查如下：
- en: Make sure bytecode doesn’t try to manipulate the stack in disallowed or evil
    ways.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保字节码不会尝试以不允许或邪恶的方式操作栈。
- en: Make sure every branch instruction (e.g., from an `if` or a loop) has a proper
    destination instruction.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个分支指令（例如，从`if`或循环）都有一个适当的跳转指令。
- en: Check methods are called with the right number of parameters of the correct
    static types.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保方法调用使用正确的静态类型和正确数量的参数。
- en: Check local variables are assigned only suitably typed values.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查局部变量是否只分配了适合其类型的值。
- en: Check each exception that can be thrown has a legal catch handler.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查每个可能抛出的异常都有一个合法的捕获处理器。
- en: These checks are done for several reasons, including performance. The checks
    enable the skipping of runtime checks, thus making the interpreted code run faster.
    Some of them can also simplify the compilation of bytecode into machine code at
    runtime (*just-in-time compilation*, which we’ll cover in chapter 6).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查是出于几个原因，包括性能。这些检查使得运行时检查可以跳过，从而使解释代码运行更快。其中一些还可以在运行时将字节码编译成机器码（即时编译，我们将在第6章中介绍）时简化编译过程。
- en: Preparation
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 准备
- en: Preparing the class involves allocating memory and getting static variables
    in the class ready to be initialized, but it doesn’t initialize variables or execute
    any JVM bytecode.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 准备类涉及分配内存并使类中的静态变量准备好初始化，但它不会初始化变量或执行任何JVM字节码。
- en: Resolution
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 解析
- en: Resolution is the part of linking where the JVM checks that the supertype of
    the class being linked (and any interfaces that it implements) are already linked,
    and if they are not, then they are linked before the linking of this class continues.
    This can lead to a recursive linking process for any new types that have not been
    seen before.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解析是链接的一部分，其中JVM检查正在链接的类的超类型（以及它实现的任何接口）是否已经链接，如果没有，则在继续链接此类之前进行链接。这可能导致任何以前未见过的新的类型出现递归链接过程。
- en: Note A key phrase that relates to this aspect of class loading is the *transitive
    closure* of types. Not only the types that a class inherits from directly but
    also all types that are indirectly referenced must be linked.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与类加载的这个方面相关的一个关键短语是类型的*传递闭包*。不仅包括类直接继承的类型，还包括所有间接引用的类型也必须链接。
- en: Once all additional types that need to be loaded have been located and resolved,
    the JVM can initialize the class it was originally asked to load.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到并解析了需要加载的所有附加类型，JVM就可以初始化它最初请求加载的类。
- en: Initialization
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化
- en: In this final phase, any static variables are initialized and any static initialization
    blocks are run. This is a significant point because it is only now that the JVM
    is finally running bytecode from the newly loaded class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终阶段，初始化任何静态变量，并运行任何静态初始化块。这是一个重要的点，因为只有现在JVM才最终从新加载的类中运行字节码。
- en: When this step completes, the class is fully loaded and ready to go. The class
    is available to the runtime and new instances of it can be created. Any further
    class loading operations that refer to this class will now see that it is loaded
    and available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一步完成时，类就完全加载并准备好使用。该类对运行时可用，并且可以创建其新实例。任何进一步引用此类的类加载操作现在将看到它已加载并可用。
- en: 4.1.2 Class objects
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 类对象
- en: The end result of the linking and loading process is a `Class` object, which
    represents the newly loaded and linked type. It’s now fully functional in the
    JVM, although for performance reasons, some aspects of the `Class` object are
    initialized only on demand.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 链接和加载过程的结果是一个`Class`对象，它代表新加载和链接的类型。现在它在JVM中完全功能化，尽管出于性能原因，`Class`对象的某些方面仅在需要时初始化。
- en: Note `Class` objects are regular Java objects. They live in the Java heap, just
    like any other object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`Class`对象是常规的Java对象。它们生活在Java堆中，就像任何其他对象一样。
- en: Your code can now go ahead and use the new type and create new instances. In
    addition, the `Class` object of a type provides a number of useful methods, such
    as `getSuperclass()`, which returns the `Class` object corresponding to the supertype.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在可以继续使用新类型并创建新实例。此外，类型的`Class`对象提供了一些有用的方法，例如`getSuperclass()`，它返回对应于超类型的`Class`对象。
- en: Class objects can be used with the Reflection API for indirect access to methods,
    fields, constructors, and so forth. A `Class` object has references to `Method`,
    `Field`, and various other objects that correspond to the members of the class.
    These objects can be used in the Reflection API to provide indirect access to
    the capabilities of the class, as we will see later in this chapter. You can see
    the high-level structure of this in figure 4.2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类对象可以使用反射API进行间接访问方法、字段、构造函数等。`Class`对象包含对`Method`、`Field`以及与类成员相对应的各种其他对象的引用。这些对象可以在反射API中使用，以提供对类功能的间接访问，正如我们将在本章后面看到的那样。您可以在图4.2中看到其高级结构。
- en: '![](../Images/CH04_F02_Evans2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Evans2.png)'
- en: Figure 4.2 `Class` object and `Method` references
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 `Class`对象和`Method`引用
- en: So far, we haven’t discussed exactly which part of the runtime is responsible
    for locating and linking the byte stream that will become the newly loaded class.
    This is handled by class loaders—subclasses of the abstract class `ClassLoader`,
    and they’re our next subject.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论运行时负责定位和链接将成为新加载类的字节流的哪个部分。这是由类加载器处理的——`ClassLoader`抽象类的子类，它们是我们接下来要讨论的主题。
- en: 4.2 Class loaders
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 类加载器
- en: Java is a fundamentally object-oriented system with a dynamic runtime. One aspect
    of this is that Java’s types are alive at runtime, and the type system of a running
    Java platform can be modified—in particular, by the addition of new types. The
    types that make up a Java program are open to extension by unknown types at runtime
    (unless they are `final` or one of the new `sealed` classes). The class-loading
    capability is exposed to the user. Class loaders are just Java classes that extend
    `ClassLoader`—they are themselves Java types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一个本质上面向对象的系统，具有动态运行时。其一个方面是Java的类型在运行时是活跃的，运行中的Java平台类型系统可以被修改——特别是通过添加新的类型。构成Java程序的类型在运行时可以由未知类型进行扩展（除非它们是`final`或新的`sealed`类）。类加载能力对用户是开放的。类加载器只是扩展`ClassLoader`的Java类——它们自身也是Java类型。
- en: Note In modern Java environments, all class loaders are modular. Loading classes
    is always done within the context of a module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在现代Java环境中，所有类加载器都是模块化的。加载类始终是在模块的上下文中完成的。
- en: The class `ClassLoader` has some native methods, including the loading and linking
    aspects that are responsible for low-level parsing of the class file, but user
    class loaders are not able to override this aspect of class loading. It is not
    possible to write a class loader using native code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassLoader`类有一些本地方法，包括负责对类文件进行低级解析的加载和链接方面，但用户类加载器无法覆盖类加载的这个方面。无法使用本地代码编写类加载器。'
- en: 'The platform ships with the following typical class loaders, which are used
    to do different jobs during the startup and normal operation of the platform:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 平台附带以下典型类加载器，它们在平台的启动和正常运行期间执行不同的任务：
- en: '`BootstrapClassLoader` (or *primordial* class loader)—This is instantiated
    very early in the process of starting up the JVM, so it’s usually best to think
    of it as being a part of the JVM itself. It’s typically used to get the absolute
    basic system loaded—essentially `java.base`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BootstrapClassLoader`（或*原初*类加载器）——这个类加载器在JVM启动过程中非常早就被实例化了，所以通常最好将其视为JVM本身的一部分。它通常用于加载绝对基本系统——本质上就是`java.base`。'
- en: '`PlatformClassLoader`—After the bare minimum system has been bootstrapped,
    then the platform class loader loads the rest of the platform modules that the
    application depends upon. This class loader is the primary interface to access
    any platform class, regardless of whether it was actually loaded by this loader
    or the bootstrap. It is an instance of an internal class.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlatformClassLoader`——在启动最基本系统之后，平台类加载器加载应用程序依赖的其他平台模块。这个类加载器是访问任何平台类的首选接口，无论它实际上是由这个加载器还是引导加载器加载的。它是一个内部类的实例。'
- en: '`AppClassLoader`—The application class loader—this is the most widely used
    class loader. It loads the application classes and does the majority of the work
    in most modern Java environments. In a modular JVM, the application class loader
    is no longer an instance of `URLClassLoader` (as it was in Java 8 and earlier)
    but, instead is an instance of an internal class.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppClassLoader`——应用程序类加载器——这是最广泛使用的类加载器。它加载应用程序类，并在大多数现代Java环境中执行大部分工作。在模块化JVM中，应用程序类加载器不再是`URLClassLoader`的实例（如Java
    8及之前版本），而是一个内部类的实例。'
- en: 'Let’s see these new class loaders in action, by adding some code to the top
    of the `main` method in `SiteCheck` from the `wgjd.sitecheck` module from chapter
    2:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向第2章中`wgjd.sitecheck`模块的`SiteCheck`类的`main`方法顶部添加一些代码，来看看这些新的类加载器是如何工作的：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We recompile it with the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方式重新编译它：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'and run it like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并按如下方式运行：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the use of the “starting module” syntax rather than an explicit starting
    class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用“起始模块”语法而不是显式的起始类。
- en: 'This produces the next output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The class loader for `Object` (which is in `java.base`) reports as `null`. This
    is a security feature—the bootstrap class loader does no verification and provides
    full security access to every class it loads. For that reason it does not make
    sense to have the class loader represented and available within the Java runtime—too
    much potential for bugs or abuse.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`类（位于`java.base`中）的类加载器报告为`null`。这是一个安全特性——引导类加载器不进行验证，并为它加载的每个类提供完全的安全访问。因此，在Java运行时中不表示和提供类加载器是没有意义的——这可能导致太多的错误或滥用。'
- en: 'In addition to their core role, class loaders are also often used to load resources
    (files that aren’t classes, such as images or config files) from JAR files or
    other locations on the classpath. This is often seen in a pattern that combines
    with try-with-resources to produce code like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们的核心角色外，类加载器还经常用于从JAR文件或其他类路径上的位置加载资源（不是类的文件，如图像或配置文件）。这通常在结合try-with-resources模式时看到，如下所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The class loaders provide this mechanism in a couple of different forms, returning
    either a `URL` or an `InputStream`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器以几种不同的形式提供这种机制，返回一个`URL`或一个`InputStream`。
- en: 4.2.1 Custom class loading
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 自定义类加载
- en: More complex environments will often have a number of additional *custom class
    loaders*—classes that subclass `java.lang.ClassLoader` (directly or indirectly).
    This is possible because the class loader class is not final, and developers are,
    in fact, encouraged to write their own class loaders specific to their individual
    needs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的环境通常会有许多额外的*自定义类加载器*——这些是继承自`java.lang.ClassLoader`（直接或间接）的类。这是可能的，因为类加载器类不是最终的，并且开发人员实际上被鼓励编写针对他们特定需求的自己的类加载器。
- en: Custom class loaders are represented as Java types, so they need to be loaded
    by a class loader, which is usually referred to as their *parent class loader*.
    This should not be confused with class inheritance and parent classes. Instead,
    class loaders are related by a form of *delegation*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类加载器以Java类型表示，因此需要由类加载器加载，这通常被称为它们的*父类加载器*。这不应与类继承和父类混淆。相反，类加载器通过一种*委托*形式相互关联。
- en: In figure 4.3, you can see the delegation hierarchy of class loaders and how
    the different loaders relate to each other. In some special cases, a custom class
    loader may have a different class loader as its parent, but the usual case is
    that it is the loading class loader.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.3中，您可以查看类加载器的委托层次结构以及不同的加载器是如何相互关联的。在某些特殊情况下，自定义类加载器可能具有不同的类加载器作为其父类加载器，但通常情况下，它是加载类加载器。
- en: '![](../Images/CH04_F03_Evans2.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F03_Evans2.png)'
- en: Figure 4.3 Classloader hierarchy
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 类加载器层次结构
- en: 'The key to the custom mechanism is found in the methods `loadClass()` and `findClass()`,
    which are defined on `ClassLoader`. The main entry point is `loadClass()` and
    a simplified form of the relevant code in `ClassLoader` follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义机制的关键在于`loadClass()`和`findClass()`方法，这些方法在`ClassLoader`上定义。主要入口点是`loadClass()`，下面是`ClassLoader`中相关代码的简化形式：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Essentially, the `loadClass()` mechanism looks to see whether the class is already
    loaded and then asks its parent class loader. If that class loading fails (note
    the try-catch surrounding the call to `parent.loadClass(name, false)`), then the
    loading process delegates to `findClass()`. The definition of `findClass()` in
    `java.lang .ClassLoader` is very simple—it just throws a `ClassNotFoundException`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`loadClass()`机制会检查类是否已经加载，然后询问其父类加载器。如果类加载失败（注意`parent.loadClass(name, false)`调用周围的try-catch），则加载过程委托给`findClass()`。`java.lang.ClassLoader`中`findClass()`的定义非常简单——它只是抛出一个`ClassNotFoundException`。
- en: At this point, let’s return to a question that we posed at the start of the
    chapter and explore some of the exception and error types that can be encountered
    during class loading.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们回到我们在本章开头提出的问题，并探讨在类加载过程中可能遇到的异常和错误类型。
- en: Class loading exceptions
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载异常
- en: 'The meaning of `ClassNotFoundException` is relatively simple: the class loader
    attempted to load the specified class but was unable to do so. That is, the class
    was unknown to the JVM at the point when loading was requested, and the JVM was
    unable to find it.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassNotFoundException`的含义相对简单：类加载器尝试加载指定的类，但无法完成。也就是说，在请求加载时，该类对JVM来说是未知的，并且JVM无法找到它。'
- en: 'Next up is `NoClassDefFoundError`. Note that this is an *error* rather than
    an exception. This error indicates that the JVM did know of the existence of the
    requested class but did not find a definition for it in its internal metadata.
    Let’s take a quick look at an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`NoClassDefFoundError`。请注意，这是一个*错误*而不是异常。这个错误表明JVM确实知道请求的类的存在，但在其内部元数据中找不到其定义。让我们快速看一下一个例子：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When this runs, we get some output like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，我们得到一些类似以下的输出：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This shows that the JVM tried to load the `BadInit` class but failed to do so.
    Nevertheless, the program caught the exception and tried to carry on. When the
    class was encountered for the second time, however, the JVM’s internal metadata
    table showed that the class had been seen but that a valid class was not loaded.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明JVM试图加载`BadInit`类，但未能成功。尽管如此，程序捕获了异常并尝试继续执行。然而，当第二次遇到该类时，JVM的内部元数据表显示该类已被识别，但没有加载有效的类。
- en: The JVM effectively implements *negative caching* on a failed class loading
    attempt—the loading is not retried, and instead an error (`NoClassDefFoundError`)
    is thrown.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JVM在失败类加载尝试上有效地实现了*负缓存*——不会重试加载，而是抛出一个错误（`NoClassDefFoundError`）。
- en: 'Another common error is `UnsupportedClassVersionError`, which is triggered
    when a class loading operation tries to load a class file that was compiled by
    a higher version of the Java source code compiler than the runtime supports. For
    example, consider a class compiled with Java 11 that we try to run on Java 8,
    shown next:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是`UnsupportedClassVersionError`，当类加载操作尝试加载由比运行时支持的Java源代码编译器更高版本的编译器编译的类文件时触发。例如，考虑一个用Java
    11编译的类，我们尝试在Java 8上运行，如下所示：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Java 11 format bytecode may have features in it that are not supported by
    the runtime, so it is not safe to continue to try to load it. Note that because
    this is a Java 8 runtime, it does not have modular entries in the stack trace.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11格式的字节码可能包含运行时不支持的特性，因此继续尝试加载它是不安全的。请注意，因为这是一个Java 8运行时，它没有在堆栈跟踪中具有模块入口。
- en: Finally, we should also mention `LinkageError`, which is the base class of a
    hierarchy containing `NoClassDefFoundError`, `VerifyError`, and `UnsatisfiedLinkError`,
    as well as several other possibilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应该提到`LinkageError`，它是包含`NoClassDefFoundError`、`VerifyError`、`UnsatisfiedLinkError`以及几个其他可能性的类层次结构的基类。
- en: A first custom class loader
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个自定义类加载器
- en: The simplest form of custom class loading is simply to subclass `ClassLoader`
    and override `findClass()`. This allows us to reuse the `loadClass()` logic that
    we discussed earlier and to reduce the complexity in our class loader.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类加载的最简单形式是简单地继承`ClassLoader`并重写`findClass()`方法。这允许我们重用之前讨论过的`loadClass()`逻辑，并简化我们的类加载器复杂性。
- en: 'Our first example is the `SadClassLoader`, shown in the next code sample. It
    doesn’t actually do anything, but it makes sure that you know that it was technically
    involved in the process and it wishes you well:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是`SadClassLoader`，如下一代码示例所示。它实际上并没有做什么，但它确保你知道它在技术上参与了该过程，并祝愿你一切顺利：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our example, we set up a very simple class loader and some code that uses
    it to try to load classes that may or may not already be loaded.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们设置了一个非常简单的类加载器以及一些使用它的代码来尝试加载可能已经或尚未加载的类。
- en: Note One common convention for custom class loaders is to provide a no-argument
    constructor that calls the superclass constructor and provides the loading class
    loader as an argument (to become the parent).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：自定义类加载器的一个常见约定是提供一个无参数的构造函数，该构造函数调用超类构造函数并将加载类加载器作为参数（成为父类加载器）。
- en: Many custom class loaders are not that much more complex than our example—they
    just override `findClass()` to provide the specific capability that is needed.
    This could include, for example, looking for the class over the network. In one
    memorable case, a custom class loader loaded classes by connecting to a database
    via JDBC and accessing an encrypted binary column to get the bytes that would
    be used. This was to satisfy an encryption-at-rest requirement for very sensitive
    code in a highly regulated environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自定义类加载器并不比我们的例子复杂多少——它们只是重写`findClass()`方法以提供所需的特定功能。例如，这可能包括通过网络查找类。在一个难忘的案例中，一个自定义类加载器通过连接数据库（使用JDBC）并访问加密的二进制列来获取将用于加载的字节来加载类。这是为了满足在高度监管环境中非常敏感代码的静态加密要求。
- en: It is possible to do more than just override `findClass()`, however. For example,
    `loadClass()` is not final and so can be overridden, and, in fact, some custom
    class loaders do override it precisely to change the general logic we met earlier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不仅仅可以重写`findClass()`。例如，`loadClass()`不是final的，因此可以被重写，实际上，一些自定义类加载器正是为了改变我们之前遇到的通用逻辑而重写它。
- en: Finally, we also have the method `defineClass()` that is defined on `ClassLoader`.
    This method is key to class loading because it is the user-accessible method that
    performs the “loading and linking” process that we described earlier in the chapter.
    It takes an array of bytes and turns them into a class object. This is the primary
    mechanism that is used to load new classes at runtime that are not present on
    the classpath.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有在`ClassLoader`上定义的`defineClass()`方法。这个方法是类加载的关键，因为它是一个用户可访问的方法，执行我们在本章中之前描述的“加载和链接”过程。它接受一个字节数组并将它们转换为类对象。这是在运行时加载不在类路径上的新类的主要机制。
- en: The call to `defineClass()` will work only if it is passed a buffer of bytes
    that are in the correct JVM class file format. If not, it will fail to load because
    either the loading or verification step will fail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当传递的字节缓冲区是正确的JVM类文件格式时，对`defineClass()`的调用才会成功。如果不是，它将失败加载，因为加载或验证步骤将失败。
- en: Note This method can be used for advanced techniques such as loading classes
    that are generated at runtime and that have no source code representation. This
    technique is how the lambda expressions mechanism works in Java. We will have
    more to say on this subject in chapter 17.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此方法可用于加载在运行时生成且没有源代码表示的类的高级技术。这种技术是Java中lambda表达式机制的工作方式。我们将在第17章中对此主题有更多讨论。
- en: 'The `defineClass()` method is both protected and final and is defined on `java.lang
    .ClassLoader`, so it can be accessed only by subclasses of `ClassLoader`. Custom
    class loaders, therefore, always have access to the basic functionality of `defineClass()`
    but cannot tamper with the verification or other low-level class loading logic.
    This last point is important: being unable to change the verification algorithm
    is a very useful safety feature—a poorly written custom class loader cannot compromise
    the basic platform security the JVM provides.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineClass()`方法既是受保护的也是final的，并且定义在`java.lang.ClassLoader`上，因此只能由`ClassLoader`的子类访问。因此，自定义类加载器始终可以访问`defineClass()`的基本功能，但不能干扰验证或其他低级类加载逻辑。这一点很重要：无法更改验证算法是一个非常有用的安全特性——一个编写不良的自定义类加载器无法危害JVM提供的基本平台安全。'
- en: In the case of the HotSpot virtual machine (which is by far the most common
    JVM implementation), `defineClass()` delegates to the native method `defineClass1()`,
    which does some basic checks and then calls a C function called `JVM_DefineClassWithSource()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在HotSpot虚拟机（这是最常用的JVM实现）的情况下，`defineClass()`委托给本地方法`defineClass1()`，它进行一些基本检查，然后调用一个名为`JVM_DefineClassWithSource()`的C函数。
- en: This function is an entry point into the JVM, and it provides access into the
    C code of HotSpot. HotSpot uses the C `SystemDictionary` to load the new class
    via the C++ method `ClassFileParser::parseClassFile()`. This code actually runs
    much of the linking process, in particular, the verification algorithm.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是进入JVM的入口点，它提供了访问HotSpot的C代码的权限。HotSpot使用C `SystemDictionary`通过C++方法`ClassFileParser::parseClassFile()`来加载新的类。这段代码实际上运行了大部分链接过程，特别是验证算法。
- en: Once class loading has completed, the bytecode of the methods is placed into
    HotSpot’s metadata objects that represent the methods (they are called *methodOops*).
    They are then available for the bytecode interpreter to use. This can be thought
    of as a method cache conceptually, although the bytecode is actually held by the
    methodOops for performance reasons.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类加载完成，方法的字节码就被放置在HotSpot的表示方法的元数据对象中（它们被称为*methodOops*）。然后它们可供字节码解释器使用。这可以被视为一个方法缓存的概念，尽管出于性能原因，字节码实际上是由methodOops持有的。
- en: We have already met the `SadClassloader`. Now let’s look at another couple of
    examples of custom class loaders, staring with a look at how class loading can
    be used to implement dependency injection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了`SadClassloader`。现在让我们看看几个自定义类加载器的例子，首先看看如何使用类加载来实现依赖注入。
- en: 'Example: A dependency injection framework'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：依赖注入框架
- en: 'We want to highlight the following two primary concepts that are highly relevant
    to DI:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调以下两个与DI高度相关的核心概念：
- en: Units of functionality within a system have dependencies and configuration information
    upon which they rely for proper functioning.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统内的功能单元有依赖项和配置信息，它们依赖于这些信息以实现正常功能。
- en: Many object systems have dependencies that are difficult or clumsy to express
    in code.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多对象系统都有难以或笨拙地在代码中表达依赖项。
- en: The picture you should have is of classes that contain behavior and configuration
    and dependencies that are external to the objects. This latter part is what is
    usually referred to as the *runtime wiring* of the objects. In this example, we’ll
    discuss how a hypothetical DI framework could use class loaders to implement runtime
    wiring.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该想象的是包含行为和配置的类以及外部于对象的依赖项。这部分通常被称为对象的*运行时连接*。在这个例子中，我们将讨论一个假设的DI框架如何使用类加载器来实现运行时连接。
- en: Note The approach we’ll take is like a simplified version of the original implementation
    of the Spring framework. However, modern production DI frameworks have significantly
    higher complexity. Our example is for demonstration purposes only.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将采取的方法类似于Spring框架原始实现的简化版本。然而，现代的生产级依赖注入（DI）框架具有显著更高的复杂性。我们的例子仅用于演示目的。
- en: 'Let’s start by looking at how we’d start an application under our imaginary
    DI framework, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何在我们假想的DI框架下启动应用程序开始看起，如下所示：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The class `DIMain` is the entry point class for the DI framework. It will read
    the config file, create the system of objects, and link them together (“wire them
    up”). Note that the class `DIMain` is not an application class—it comes from the
    framework and is completely general.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIMain`类是DI框架的入口点类。它将读取配置文件，创建对象系统，并将它们连接起来（“连接它们”）。请注意，`DIMain`类不是一个应用程序类——它来自框架，并且是完全通用的。'
- en: 'We can also see that the `CLASSPATH` for the application must contain three
    things: a) the JAR files for the DI framework, b) the application classes that
    are referred to in the config.xml file, and c) any other (non-DI) dependencies
    that the application has. Let’s look at an example config file, shown next:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，应用程序的`CLASSPATH`必须包含三样东西：a) DI框架的JAR文件，b) 在`config.xml`文件中引用的应用程序类，以及c)
    应用程序的其他（非DI）依赖项。让我们看看下一个示例配置文件，如下所示：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The DI framework uses the config file to determine which objects to construct.
    This example needs to make the `dao` and `service` beans, and the framework will
    need to call the constructors for each bean, with the specified arguments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DI框架使用配置文件来确定要构造哪些对象。这个例子需要创建`dao`和`service`豆类，并且框架将需要调用每个豆类的构造函数，并传递指定的参数。
- en: Class loading occurs in two separate phases. The first phase (which is handled
    by the application class loader) loads the class `DIMain` and any framework classes
    that it refers to. Then `DIMain` starts to run and receives the location of the
    config file as a parameter to `main()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载分为两个独立阶段。第一阶段（由应用程序类加载器处理）加载`DIMain`类及其引用的任何框架类。然后`DIMain`开始运行，并将配置文件的路径作为`main()`参数接收。
- en: At this point, the framework is up and running in the JVM, but the user classes
    specified in `config.xml` haven’t yet been touched. In fact, until `DIMain` examines
    the config file, the framework has no way of knowing what classes to load.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，框架已经在JVM中启动并运行，但`config.xml`中指定的用户类尚未被触及。事实上，直到`DIMain`检查配置文件，框架都没有办法知道要加载哪些类。
- en: To bring up the application configuration specified in `config.xml`, a second
    phase of class loading is required. In our example, this uses a custom class loader.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载`config.xml`中指定的应用程序配置，需要第二个阶段的类加载。在我们的例子中，这使用了一个自定义的类加载器。
- en: First, the `config.xml` file is checked for consistency and to make sure it’s
    error-free. Then, if all is well, the custom class loader tries to load the types
    from the `CLASSPATH`. If any of these fail, the whole process is aborted, causing
    a runtime error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查`config.xml`文件以确保其一致性并确保没有错误。然后，如果一切顺利，自定义类加载器尝试从`CLASSPATH`加载类型。如果其中任何一个失败，整个过程将被终止，导致运行时错误。
- en: If this succeeds, the DI framework can proceed to instantiate the required objects
    in the correct order (with their constructor parameters). Finally, if all of this
    completes correctly, the application context is up and can begin to run.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，DI框架可以按正确的顺序（使用它们的构造函数参数）实例化所需的对象。最后，如果所有这些操作都正确完成，应用程序上下文就绪并可以开始运行。
- en: It is worth reiterating that this example is hypothetical and illustrative.
    It would be entirely possible to build a simple DI framework that worked in the
    manner described here. However, the actual implementation of real DI systems is
    much more complicated in practice. Let’s move on to look at another example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重申的是，这个例子是假设性的和说明性的。完全有可能构建一个简单的DI框架，其工作方式如这里所描述。然而，实际实现真正的DI系统在实践中要复杂得多。让我们继续看看另一个例子。
- en: 'Example: An instrumenting class loader'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：一个用于监控的类加载器
- en: Consider a class loader that alters the bytecode of classes to add extra instrumentation
    information as they’re loaded. When test cases are run against the transformed
    code, the instrumentation code records which methods and code branches are actually
    tested by the test cases. From this, the developer can see how thorough the unit
    tests for a class are.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个在类加载时修改类字节码以添加额外监控信息的类加载器。当测试用例运行在转换后的代码上时，监控代码会记录测试用例实际测试了哪些方法和代码分支。从这些信息中，开发者可以了解一个类的单元测试是否全面。
- en: This approach was the basis of the EMMA testing coverage tool, which is still
    available from [http://emma.sourceforge.net/](http://emma.sourceforge.net/), although
    it is now rather outdated and has not been kept up-to-date for modern Java versions.
    Despite this, it’s quite common to encounter frameworks and other code that use
    specialized class loaders that transform the bytecode as it’s being loaded.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法曾是EMMA测试覆盖率工具的基础，该工具目前可以从[http://emma.sourceforge.net/](http://emma.sourceforge.net/)获取，尽管它现在相当过时，并且没有为现代Java版本更新。尽管如此，遇到使用专门类加载器转换加载时字节码的框架和其他代码是很常见的。
- en: Note The technique of modifying bytecode as it is loaded is also seen in the
    *java agent* approach, which is used for performance monitoring, observability,
    and other goals by tools such as New Relic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在加载时修改字节码的技术也见于*java agent*方法，该方法被New Relic等工具用于性能监控、可观察性和其他目标。
- en: 'We’ve briefly touched on a couple of use cases for custom class loading. Many
    other areas of the Java technology space are big users of class loaders and related
    techniques. Some of the best-known examples follow:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地讨论了自定义类加载的一些用例。Java技术领域的许多其他领域都是类加载和相关技术的重度使用者。以下是一些最著名的例子：
- en: Plugin architectures
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件架构
- en: Frameworks (whether vendor or homegrown)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架（无论是供应商的还是自建的）
- en: Class file retrieval from unusual locations (not filesystems or URLs)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从非传统位置（非文件系统或URL）检索类文件
- en: Java EE
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE
- en: Any circumstance where new, unknown code may need to be added after the JVM
    process has already started running
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JVM进程已经开始运行之后，可能需要添加新的、未知代码的任何情况
- en: Let’s move on to discuss how the module system affects class loading and modifies
    the classic picture that we’ve just explained.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论模块系统如何影响类加载并修改我们刚刚解释的经典图景。
- en: 4.2.2 Modules and class loading
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 模块和类加载
- en: The modules system is designed to operate at a different level from class loading,
    which is a relatively low-level mechanism within the platform. Modules are about
    large-scale dependencies between program units, and class loading is about the
    small scale. However, it is important to understand how the two mechanisms intersect
    and the changes to program startup that have been caused by the arrival of modules.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统旨在在类加载的不同级别上运行，而类加载是平台中相对低级的一种机制。模块涉及程序单元之间的大规模依赖关系，而类加载涉及小规模。然而，了解这两种机制如何交叉以及模块的引入对程序启动造成的改变是很重要的。
- en: Recall that when running on a modular JVM, to execute a program, the runtime
    will compute a module graph and try to satisfy it as a first step. This is referred
    to as *module resolution*, and it derives the transitive closure of the root module
    and its dependencies.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当在模块化JVM上运行时，为了执行程序，运行时会首先计算一个模块图，并尝试满足它。这被称为*模块解析*，它推导出根模块及其依赖项的传递闭包。
- en: During this process, additional checks are performed (e.g., no modules with
    duplicate names, no split packages). The existence of the module graph means that
    fewer runtime class-loading problems are expected, because missing JARs on the
    module path can now be detected before the process even starts fully.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，会执行额外的检查（例如，没有具有重复名称的模块，没有分割的包）。由于模块图的存在，预计运行时类加载问题会更少，因为现在可以在进程完全开始之前检测到模块路径上缺失的JAR文件。
- en: Beyond this, the modules system does not alter class loading much in most cases.
    There are some advanced possibilities (such as dynamically loading modular implementations
    of service provider interfaces by using reflection), but those are not likely
    to be encountered often by most developers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，模块系统在大多数情况下并不会对类加载产生太大影响。有一些高级的可能性（例如通过反射动态加载服务提供者接口的模块实现），但这些不太可能被大多数开发者经常遇到。
- en: 4.3 Examining class files
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 检查类文件
- en: Class files are binary blobs, so they aren’t easy to work with directly. But
    there are many circumstances in which you’ll find that investigating a class file
    is necessary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件是二进制块，因此它们不容易直接处理。但在许多情况下，你会发现调查类文件是必要的。
- en: Imagine that your application needs additional methods to be made public to
    allow better runtime monitoring (such as via JMX). The recompile and redeploy
    seems to complete fine, but when the management API is checked, the methods aren’t
    there. Additional rebuild and redeploy steps have no effect.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序需要额外的公共方法来允许更好的运行时监控（例如通过 JMX）。重新编译和重新部署似乎完成得很好，但当检查管理 API 时，方法并不在那里。额外的重建和重新部署步骤没有效果。
- en: To debug the deployment issue, you may need to check that `javac` has produced
    the class file that you think it has. Or you may need to investigate a class that
    you don’t have source for and where you suspect the documentation is incorrect.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试部署问题，你可能需要检查 `javac` 是否生成了你认为它应该生成的类文件。或者你可能需要调查一个你没有源代码的类，并且你怀疑文档是不正确的。
- en: For these and similar tasks, you must make use of tools to examine the contents
    of class files. Fortunately, the standard Oracle JVM ships with a tool called
    `javap`, which is very handy for peeking inside and disassembling class files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些和类似的任务，你必须使用工具来检查类文件的内容。幸运的是，标准的 Oracle JVM 随带一个名为 `javap` 的工具，它非常适合查看内部和反汇编类文件。
- en: We’ll start off by introducing `javap` and some of the basic switches it provides
    to examine aspects of class files. Then we’ll discuss some of the representations
    for method names and types that the JVM uses internally. We’ll move on to take
    a look at the constant pool—the JVM’s “box of useful things”—which plays an important
    role in understanding how bytecode works.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍 `javap` 以及它提供的一些基本开关，用于检查类文件的不同方面。然后我们将讨论 JVM 内部使用的一些方法名称和类型的表示形式。接下来，我们将查看常量池——JVM
    的“有用之物宝箱”——它在理解字节码的工作方式中起着重要作用。
- en: 4.3.1 Introducing javap
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 介绍 javap
- en: 'From seeing what methods a class declares to printing the bytecode, `javap`
    can be used for numerous useful tasks. Let’s examine the simplest form of `javap`
    usage, as applied to the class-loading example from earlier in the chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从查看一个类声明的方法到打印字节码，`javap` 可以用于许多有用的任务。让我们检查 `javap` 的最简单使用形式，这是应用在章节前面提到的类加载示例：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The inner class has been compiled out into a separate class, so we need to
    also look at that one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类已经被编译成单独的类，因此我们还需要查看这一点：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, `javap` shows the public, protected, and default access (package-protected)
    visibility methods. The `-p` switch also shows the private methods and fields.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`javap` 显示公共、受保护的和默认访问（包受保护）可见的方法。`-p` 开关也显示私有方法和字段。
- en: 4.3.2 Internal form for method signatures
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 方法签名的内部形式
- en: The JVM uses a slightly different form for method signatures internally than
    the human-readable form displayed by `javap`. As we delve deeper into the JVM,
    you’ll see these internal names more frequently. If you’re keen to keep going,
    you can jump ahead, but remember that this section’s here—you may need to refer
    to it from later sections and chapters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 在内部使用的方法签名形式与 `javap` 显示的供人类阅读的形式略有不同。随着我们更深入地了解 JVM，你将更频繁地看到这些内部名称。如果你热衷于继续前进，你可以跳过，但请记住，这一节在这里——你可能需要从后面的章节中参考它。
- en: In the compact form, type names are compressed. For example, `int` is represented
    by `I`. These compact forms are sometimes referred to as *type descriptors*. A
    complete list is provided in table 4.1 (and includes `void`, which is not a type
    but does appear in method signatures).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧凑形式中，类型名称被压缩。例如，`int` 被表示为 `I`。这些紧凑形式有时被称为 *类型描述符*。一个完整的列表在表 4.1 中提供（包括 `void`，它不是一个类型，但出现在方法签名中）。
- en: Table 4.1 Type descriptors
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 类型描述符
- en: '| Descriptor | Type |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 描述符 | 类型 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| B | Byte |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| B | Byte |'
- en: '| C | Char (a 16-bit Unicode character) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| C | Char（一个 16 位 Unicode 字符） |'
- en: '| D | Double |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| D | Double |'
- en: '| F | Float |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| F | Float |'
- en: '| I | Int |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| I | Int |'
- en: '| J | Long |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| J | 长整型 |'
- en: '| L<type name>; | Reference type (such as Ljava/lang/String; for a string)
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| L<类型名>; | 引用类型（例如，对于字符串，Ljava/lang/String;）|'
- en: '| S | Short |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| S | 短整型 |'
- en: '| V | Void |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| V | 无值 |'
- en: '| Z | Boolean |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Z | 布尔型 |'
- en: '| [ | Array-of |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| [ | 数组 |'
- en: In some cases, the type descriptor can be longer than the type name that appears
    in source code (e.g., `Ljava/lang/Object;` is longer than `Object`, but the type
    descriptors are always fully qualified so they can be directly resolved).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，类型描述符可能比源代码中出现的类型名称更长（例如，`Ljava/lang/Object;`比`Object`长，但类型描述符总是完全限定的，因此可以直接解析）。
- en: '`javap` provides a helpful switch, `-s`, which will output the type descriptors
    of signatures for you, so you don’t have to work them out using the table. You
    can use a slightly more advanced invocation of `javap` to show the signatures
    for some of the methods we looked at earlier, as shown next:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`javap`提供了一个有用的开关`-s`，它会为你输出签名类型描述符，这样你就不必使用表格来计算它们。你可以使用`javap`的一个稍微高级的调用，来显示我们之前查看的一些方法的签名，如下所示：'
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'and for the inner class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部类：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, each type in a method signature is represented by a type descriptor.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，方法签名中的每个类型都由一个类型描述符表示。
- en: In the next section, we’ll see another use of type descriptors. This is in a
    very important part of the class file—the constant pool.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到类型描述符的另一种用途。这是类文件中的一个非常重要的部分——常量池。
- en: 4.3.3 The constant pool
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 常量池
- en: The constant pool is an area that provides handy shortcuts to other (constant)
    elements of the class file. If you’ve studied languages like C or Perl, which
    make explicit use of symbol tables, you can think of the constant pool as being
    a somewhat similar JVM concept.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 常量池是一个提供便捷快捷方式访问类文件中其他（常量）元素的区域。如果你研究过像C或Perl这样的语言，它们明确使用了符号表，你可以将常量池视为与JVM概念有些相似。
- en: Let’s use a very simple example in the next listing to demonstrate the constant
    pool, so we don’t swamp ourselves with detail. The next listing shows a simple
    “playpen” or “scratchpad” class. This provides a way to quickly test out a Java
    syntax feature or library, by writing a small amount of code in `run()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个列表中使用一个非常简单的例子来演示常量池，这样我们就不至于被细节淹没。下一个列表显示了一个简单的“playpen”或“scratchpad”类。通过在`run()`中编写一小段代码，它可以快速测试Java语法特性或库。
- en: Listing 4.1 Sample playpen class
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 示例playpen类
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To see the information in the constant pool, you can use `javap -v`. This prints
    a lot of additional information—much more than just the constant pool—but let’s
    focus on the constant pool entries for the playpen, shown next:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看常量池中的信息，你可以使用`javap -v`。这将打印出大量的附加信息——远不止常量池本身——但让我们专注于下一个示例中的常量池条目：
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, constant pool entries are typed. They also refer to each other,
    so, for example, an entry of type `Class` will refer to an entry of type `Utf8`.
    A `Utf8` entry means a string, so the `Utf8` entry that a `Class` entry points
    out will be the name of the class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，常量池条目是分类型的。它们也相互引用，例如，类型为`Class`的条目将引用类型为`Utf8`的条目。`Utf8`条目意味着一个字符串，因此`Class`条目指向的`Utf8`条目将是类的名称。
- en: Table 4.2 shows the set of possibilities for entries in the constant pool. Entries
    from the constant pool are sometimes discussed with a `CONSTANT_` prefix, such
    as `CONSTANT _Class`. This is to make it clear that they are not Java types, in
    situations where they could be confused.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 展示了常量池条目的可能集合。常量池中的条目有时会使用`CONSTANT_`前缀进行讨论，例如`CONSTANT _Class`。这是为了在它们可能被混淆的情况下，明确指出它们不是Java类型。
- en: Table 4.2 Constant pool entries
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 常量池条目
- en: '| Name | Description |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Class` | A class constant. Points at the name of the class (as a `Utf8`
    entry). |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `Class` | 一个类常量。指向类的名称（作为一个`Utf8`条目）。|'
- en: '| `Fieldref` | Defines a field. Points at the `Class` and `NameAndType` of
    this field. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `Fieldref` | 定义一个字段。指向此字段的`Class`和`NameAndType`。|'
- en: '| `Methodref` | Defines a method. Points at the `Class` and `NameAndType` of
    this field. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `Methodref` | 定义一个方法。指向此字段的`Class`和`NameAndType`。|'
- en: '| `InterfaceMethodref` | Defines an interface method. Points at the `Class`
    and `NameAndType` of this field. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `InterfaceMethodref` | 定义一个接口方法。指向此字段的`Class`和`NameAndType`。|'
- en: '| `String` | A string constant. Points at the `Utf8` entry that holds the characters.
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 一个字符串常量。指向包含字符的`Utf8`条目。|'
- en: '| `Integer` | An integer constant (4 bytes). |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `Integer` | 一个整型常量（4字节）。|'
- en: '| `Float` | A floating-point constant (4 bytes). |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | 一个浮点常量（4字节）。|'
- en: '| `Long` | A long constant (8 bytes). |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `Long` | 一个长常量（8字节）。|'
- en: '| `Double` | A double-precision floating-point constant (8 bytes). |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `Double` | 一个双精度浮点常量（8字节）。|'
- en: '| `NameAndType` | Describes a name and type pair. The type points at the `Utf8`
    that holds the type descriptor for the type. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `NameAndType` | 描述一个名称和类型对。类型指向包含类型描述符的`Utf8`。|'
- en: '| `Utf8` | A stream of bytes representing `Utf8`-encoded characters. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `Utf8` | 表示`Utf8`编码字符的字节流。|'
- en: '| `InvokeDynamic` | Part of `invokedynamic` mechanism—see chapter 17. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `InvokeDynamic` | `invokedynamic`机制的一部分——见第17章。|'
- en: '| `MethodHandle` | Part of `invokedynamic` mechanism—see chapter 17. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `MethodHandle` | `invokedynamic`机制的一部分——见第17章。|'
- en: '| `MethodType` | Part of `invokedynamic` mechanism—see chapter 17. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `MethodType` | `invokedynamic`机制的一部分——见第17章。|'
- en: 'Using this table, you can look at an example constant resolution from the constant
    pool of the playpen. Consider the `Fieldref` at entry #10\. To resolve a field,
    you need a name, a type, and a class where it resides: #10 has the value #1.#11,
    which means constant #11 from class #1\. It’s easy to check that #1 is indeed
    a constant of type `Class`, and #11 is a `NameAndType`. #1 refers to the `ScratchImpl`
    Java class itself, and #11 refers to #5:#6—a variable called `inst` of type `ScratchImpl`.
    So, overall, #10 refers to the static variable inst in the `ScratchImpl` class
    itself (which you might have been able to guess from the output above).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个表格，你可以查看来自playpen常量池的一个示例常量解析。考虑第10个条目的`Fieldref`。要解析一个字段，你需要一个名称、一个类型以及它所在类的信息：第10个条目有值#1.#11，这意味着类#1中的常量#11。很容易检查#1确实是一个类型为`Class`的常量，而#11是一个`NameAndType`。#1指的是`ScratchImpl`
    Java类本身，而#11指的是#5:#6——一个类型为`ScratchImpl`的变量`inst`。因此，总的来说，#10指的是`ScratchImpl`类本身中的静态变量`inst`（你可能已经从上面的输出中猜到了）。
- en: In the verification step of class loading, there’s a step to check that the
    static information in the class file is consistent. The preceding example shows
    the kind of integrity check that the runtime will perform when loading a new class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在类加载的验证步骤中，有一个步骤来检查类文件中的静态信息是否一致。前面的例子显示了运行时在加载新类时将执行的那种完整性检查。
- en: We’ve discussed some of the basic anatomy of a class file. Let’s move on to
    the next topic, where we’ll delve into the world of bytecode. Understanding how
    source code is turned into bytecode will help you gain a better understanding
    of how your code will run. In turn, this will lead to more insights into the platform’s
    capabilities when we reach chapter 6 and beyond.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些类文件的基本结构。让我们继续下一个主题，我们将深入字节码的世界。了解源代码是如何转换为字节码的，将帮助你更好地理解你的代码将如何运行。反过来，这将导致当我们达到第6章及以后时，对平台功能的更多洞察。
- en: 4.4 Bytecode
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 字节码
- en: 'Bytecode has been a somewhat behind-the-scenes player in our discussion so
    far. Let’s start by reviewing what we’ve already learned about it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码在我们之前的讨论中一直是一个幕后玩家。让我们首先回顾一下我们已经学到的关于它的知识：
- en: Bytecode is an intermediate representation of a program, halfway between human
    readable source and machine code.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码是程序的中间表示，介于人类可读的源代码和机器码之间。
- en: Bytecode is produced by `javac` from Java source code files.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码由`javac`从Java源代码文件生成。
- en: Some high-level language features have been compiled away and don’t appear in
    bytecode. For example, Java’s looping constructs (`for`, `while`, and the like)
    are gone, turned into bytecode branch instructions.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些高级语言特性已经被编译掉了，不会出现在字节码中。例如，Java的循环结构（`for`、`while`等）已经消失，变成了字节码分支指令。
- en: Each opcode is represented by a single byte (hence the name *bytecode*).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作码由一个字节表示（因此得名*字节码*）。
- en: Bytecode is an abstract representation, not “machine code for an imaginary CPU.”
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码是一种抽象表示，不是“一个虚构CPU的机器码。”
- en: Bytecode can be further compiled to machine code, usually “just in time.”
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码可以进一步编译成机器码，通常是“即时”编译。
- en: When explaining bytecode, there can be a slight chicken-and-egg problem. To
    fully understand what’s going on, you need to understand both bytecode and the
    runtime environment that it executes in. This is a rather circular dependency,
    so to solve it, we’ll start by diving in and looking at a relatively simple example.
    Even if you don’t understand everything that’s in this example on the first pass,
    you can come back to it after you’ve read more about bytecode in the following
    sections.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释字节码时，可能会出现一个轻微的“鸡生蛋，蛋生鸡”的问题。要完全理解正在发生的事情，你需要理解字节码及其执行的运行时环境。这是一个相当循环的依赖关系，因此为了解决这个问题，我们将首先深入探讨，并查看一个相对简单的例子。即使你在第一次阅读这个例子时并不理解所有内容，你可以在阅读了后续章节中关于字节码的更多内容后回过头来再看。
- en: After the example, we’ll provide some context about the runtime environment,
    and then catalogue the JVM’s opcodes, including bytecodes for arithmetic, invocation,
    shortcut forms, and more. At the end, we’ll round off with another example, based
    on string concatenation. Let’s get started by looking at how you can examine bytecode
    from a .class file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例之后，我们将提供一些关于运行时环境的背景信息，然后列出 JVM 的操作码，包括算术、调用、快捷形式等。最后，我们将通过一个基于字符串连接的例子来结束。让我们先看看如何从
    `.class` 文件中检查字节码。
- en: 4.4.1 Disassembling a class
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 解析类
- en: Using `javap` with the `-c` switch, you can disassemble classes. In our example,
    we’ll use the `ScratchImpl` class we met earlier. The main focus will be to examine
    the bytecode that makes up methods. We’ll also use the `-p` switch so we can see
    bytecode from private methods.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 `-c` 选项的 `javap`，你可以解析类。在我们的例子中，我们将使用之前遇到的 `ScratchImpl` 类。主要关注点将是检查构成方法的字节码。我们还将使用
    `-p` 选项，这样我们就可以看到私有方法的字节码。
- en: 'Let’s work section by section—there’s a lot of information in each part of
    `javap`’s output, and it’s easy to become overwhelmed. First, the header. There’s
    nothing terribly unexpected or exciting in here, as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐节工作——`javap` 的输出中每个部分都有很多信息，很容易感到不知所措。首先，是标题。这里没有什么特别意外或令人兴奋的内容，如下所示：
- en: '[PRE19]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next is the static block. This is where variable initialization is placed,
    so this represents initializing `inst` to `null`. The keen-eyed reader might guess
    that `putstatic` could be a bytecode that puts a value in a static field:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是静态块。这是放置变量初始化的地方，因此这表示将 `inst` 初始化为 `null`。敏锐的读者可能会猜测 `putstatic` 可能是一个将值放入静态字段的字节码：
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The numbers in the preceding code represent the offset into the bytecode stream
    from the start of the method. So byte 1 is the `putstatic` opcode, and bytes 2
    and 3 represent a 16-bit index into the constant pool. In this case, the 16-bit
    index is the value 10, which means that the value (in this case, `null`) will
    be stored in the field indicated by constant pool entry #10\. Byte 4 from the
    start of the bytecode stream is the return opcode—the end of the block of code.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '上一段代码中的数字代表从方法开始到字节码流中的偏移量。所以字节 1 是 `putstatic` 操作码，字节 2 和 3 代表一个指向常量池的 16
    位索引。在这种情况下，16 位索引的值是 10，这意味着值（在这种情况下，`null`）将被存储在常量池条目 #10 指示的字段中。从字节码流开始处的字节
    4 是返回操作码——代码块的结束。'
- en: 'Next up is the constructor:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是构造函数：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that in Java, the void constructor will always implicitly call the
    superclass constructor. Here you can see this in the bytecode—it’s the `invokespecial`
    instruction. In general, any method call will be turned into one of the JVM’s
    five `invoke` instructions, which we’ll meet in section 4.4.7.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Java 中，void 构造函数将始终隐式调用超类构造函数。在这里，你可以从字节码中看到这一点——它是 `invokespecial` 指令。一般来说，任何方法调用都将转换为
    JVM 的五个 `invoke` 指令之一，我们将在 4.4.7 节中遇到。
- en: The constructor invocation requires a target, which is provided by the `aload_0`
    instruction. This loads a reference (an Address) and uses a shortcut form (which
    we’ll meet properly in section 4.4.9) to load the 0th local variable, which is
    just `this`, the current object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用需要一个目标，这个目标由 `aload_0` 指令提供。它加载一个引用（一个地址）并使用快捷形式（我们将在 4.4.9 节中详细了解）来加载
    0 号局部变量，即 `this`，当前对象。
- en: 'There’s basically no code in the `run()` method, because this is just a scratchpad
    class for testing out code. This method immediately returns to the caller and
    does not pass a value back (which is correct, because the method returns `void`):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法中基本上没有代码，因为这只是一个用于测试代码的临时类。此方法立即返回给调用者，并且不返回任何值（这是正确的，因为该方法返回 `void`）：'
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the main method, we initialize `inst` and do a bit of object creation. This
    demonstrates some very common basic bytecode patterns that we can learn to recognize:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中，我们初始化 `inst` 并进行一些对象创建。这展示了我们可以学会识别的一些非常常见的基本字节码模式：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This pattern of three bytecode instructions—`new`, `dup`, and `invokespecial`
    of a method called `<init>`—always represents the creation of a new instance.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种由三个字节码指令组成的模式——`new`、`dup` 和调用名为 `<init>` 的方法的 `invokespecial`——始终代表创建一个新的实例。
- en: The `new` opcode allocates memory for a new instance and places a reference
    to it on the top of the stack. The `dup` opcode duplicates the reference that’s
    on top of the stack (so now there are two copies). To finish fully creating the
    object, we need to call the body of the constructor. The `<init>` method contains
    the code for the constructor body, so we call that code block with `invokespecial`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 操作码为新实例分配内存，并将对该实例的引用放置在栈顶。`dup` 操作码复制栈顶的引用（因此现在有两个副本）。为了完全创建对象，我们需要调用构造函数的主体。`<init>`
    方法包含构造函数主体的代码，因此我们使用 `invokespecial` 调用该代码块。'
- en: When methods are called, the reference to the receiver object (if any) is consumed
    from the stack, along with any arguments to the method. This is why we need to
    perform a `dup` first—without it, the newly allocated object will have its only
    reference consumed by the `invoke` and will be inaccessible after this point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用方法时，接收器对象的引用（如果有）以及任何方法参数都会从栈中消耗掉。这就是为什么我们需要先执行 `dup` 的原因——如果没有它，新分配的对象的唯一引用将被
    `invoke` 消耗掉，并且在此之后将无法访问。
- en: 'Let’s look at the remaining bytecodes for the main method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看主方法剩余的字节码：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instruction 7 saves the address of the singleton instance that has been created.
    Instruction 10 puts it back on top of the stack, so that instruction 13 can call
    a method on it. This is done with the `invokevirtual` opcode, which carries out
    Java’s “standard” dispatch for instance methods.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 7 保存已创建的单例实例的地址。指令 10 将其放回栈顶，以便指令 13 可以调用其方法。这是通过 `invokevirtual` 操作码完成的，该操作码执行
    Java 的“标准”实例方法分派。
- en: Note In general, the bytecode produced by `javac` is a simple representation—it
    isn’t highly optimized. The overall strategy is that just-in-time (JIT) compilers
    do a lot of optimizing, so it helps if they have a relatively plain and simple
    starting point. The expression, “Bytecode should be dumb,” describes the general
    feeling of JVM implementers toward the bytecode produced from source languages.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一般来说，`javac` 生成的字节码是一种简单的表示——它并没有高度优化。总体策略是即时（JIT）编译器执行大量的优化，因此如果它们有一个相对简单和简单的起点，这会有所帮助。表达式“字节码应该是愚蠢的”描述了
    JVM 实现者对从源语言生成的字节码的一般感觉。
- en: The `invokevirtual` opcode includes checking for overrides of the method in
    the object’s inheritance hierarchy. You might notice that this is a bit odd, because
    private methods can’t be overridden. You might guess that the source code compiler
    could actually emit `invokespecial` instead of `invokevirtual` for private methods.
    In fact, this used to be the case and was changed only in recent versions of Java.
    For details, see the section on nestmates in chapter 17.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokevirtual` 操作码包括检查对象继承层次结构中方法的覆盖情况。你可能觉得这有点奇怪，因为私有方法不能被覆盖。你可能猜测源代码编译器实际上可以发出
    `invokespecial` 而不是 `invokevirtual` 用于私有方法。实际上，这曾经是情况，只是在最近的 Java 版本中才进行了更改。有关详细信息，请参阅第
    17 章关于嵌套成员的部分。'
- en: Let’s move on to discuss the runtime environment that bytecode needs. After
    that, we’ll introduce the tables that we’ll use to describe the major families
    of bytecode instructions—load/store, arithmetic, execution control, method invocation,
    and platform operations. Then we’ll discuss possible shortcut forms of opcodes,
    before moving on to another example.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论字节码所需的运行时环境。之后，我们将介绍我们将用来描述主要字节码指令家族的表格——加载/存储、算术、执行控制、方法调用和平台操作。然后我们将讨论操作码的可能快捷形式，然后再继续另一个示例。
- en: 4.4.2 The runtime environment
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 运行时环境
- en: Understanding the operation of the stack machine that the JVM uses is critical
    to understanding bytecode. One of the most obvious ways that the JVM doesn’t look
    like a hardware CPU (such as an x64 or ARM chip) is that the JVM doesn’t have
    processor registers and instead uses a stack for all calculations and operations.
    This is referred to as the *evaluation stack* (it’s officially called the *operand
    stack* in the VM specification, and we’ll use the two terms interchangeably).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 理解JVM使用的堆栈机的操作对于理解字节码至关重要。JVM不像硬件CPU（如x64或ARM芯片）的一个最明显的原因是，JVM没有处理器寄存器，而是使用堆栈进行所有计算和操作。这被称为*评估堆栈*（在VM规范中官方称为*操作数堆栈*，我们将交替使用这两个术语）。
- en: The evaluation stack is local to a method, and when a method is called, a fresh
    evaluation stack is created. Of course, the JVM also has a *call stack* for each
    Java thread that records which methods have been executed (and which forms the
    basis of stack traces in Java). It’s important to keep the distinction between
    the per-thread call stack and the per-method evaluation stack clear.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 评估堆栈是局部于方法的，当方法被调用时，会创建一个新的评估堆栈。当然，JVM为每个Java线程都有一个*调用堆栈*，用于记录哪些方法已被执行（这构成了Java中堆栈追踪的基础）。保持每个线程调用堆栈和每个方法评估堆栈之间的区别是很重要的。
- en: Figure 4.4 shows how the evaluation stack might be used to perform an addition
    operation on two int constants. We’re showing the equivalent JVM bytecode below
    each step—we’ll meet this bytecode later in the chapter, so don’t worry if it
    doesn’t make complete sense right now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4展示了如何使用评估堆栈对两个int常量执行加法操作。我们将在每个步骤下方显示等效的JVM字节码——我们将在本章后面遇到这个字节码，所以如果它现在看起来不完全合理，请不要担心。
- en: '![](../Images/CH04_F04_Evans2.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F04_Evans2.png)'
- en: Figure 4.4 Using a stack for numerical calculations
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 使用堆栈进行数值计算
- en: As we discussed earlier in this chapter, when a class is linked into the running
    environment, its bytecode will be checked, and a lot of that verification boils
    down to analyzing the pattern of types on the stack.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的，当一个类被链接到运行环境时，其字节码将被检查，其中很多验证都归结为分析堆栈上的类型模式。
- en: Note Manipulations of the values on the stack work only if the values on the
    stack have the correct types. Undefined or bad things could happen if, for example,
    we pushed a reference to an object onto the stack and then tried to treat it as
    an int and do arithmetic on it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：只有当堆栈上的值具有正确的类型时，对堆栈上值的操作才有效。如果，例如，我们将一个对象的引用压入堆栈，然后试图将其作为int处理并对其进行算术运算，可能会发生未定义或不良的事情。
- en: The verification phase of class loading performs extensive checks to ensure
    that methods in newly loaded classes don’t try to abuse the stack. This prevents
    a malformed (or deliberately evil) class from ever being accepted by the system
    and causing problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载的验证阶段执行广泛的检查，以确保新加载的类中的方法不会滥用堆栈。这防止了格式不正确（或故意邪恶）的类被系统接受并造成问题。
- en: 'As a method runs, it needs an area of memory to use as an evaluation stack,
    for computing new values. In addition, every running thread needs a call stack
    that records which methods are currently in flight (the stack that would be reported
    by a stack trace). These two stacks will interact in some cases. Consider this
    bit of code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法运行时，它需要一个内存区域作为评估堆栈，用于计算新值。此外，每个运行的线程都需要一个调用堆栈，用于记录当前正在执行的方法（堆栈追踪会报告的堆栈）。在某些情况下，这两个堆栈将相互作用。考虑以下这段代码：
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To evaluate this, the JVM puts `3` on the operand stack. Then it needs to call
    a method to calculate how many pets Ben has. To do this, it pushes the receiver
    object (the one the method is being called on—`petRecords`, in this example) onto
    the evaluation stack, followed by any call arguments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估这一点，JVM将`3`压入操作数堆栈。然后它需要调用一个方法来计算本有多少宠物。为此，它将接收对象（方法被调用的对象——在这个例子中是`petRecords`）压入评估堆栈，然后是任何调用参数。
- en: Then the `getNumberOfPets()` method is called using one of the `invoke` opcodes,
    which will cause control to transfer to the called method and the just-entered
    method to appear in the call stack. But, as the JVM enters the new method, it
    starts using a fresh operand stack, so the values already on the caller’s operand
    stack can’t possibly affect results calculated in the called method.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`invoke`操作码之一调用`getNumberOfPets()`方法，这将导致控制权转移到被调用的方法，并且刚刚进入的方法将出现在调用堆栈中。但是，当JVM进入新方法时，它开始使用一个新的操作数堆栈，因此调用者的操作数堆栈上的值不可能影响在调用方法中计算的结果。
- en: When `getNumberOfPets()` completes, the return value is placed onto the operand
    stack of the caller, as part of the process whereby `getNumberOfPets()` is removed
    from the call stack. Then the addition operation takes the two values and adds
    them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `getNumberOfPets()` 完成时，返回值会被放置在调用者的操作栈上，作为 `getNumberOfPets()` 从调用栈中移除的过程的一部分。然后加法操作将这两个值相加。
- en: Let’s now turn to examining bytecode. This is a large subject, with lots of
    special cases, so we’re going to present an overview of the main features rather
    than a complete treatment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向检查字节码。这是一个大主题，有很多特殊情况，所以我们将提供一个主要功能的概述，而不是完整的处理。
- en: 4.4.3 Introduction to opcodes
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 指令集介绍
- en: JVM bytecode consists of a sequence of operation codes (opcodes), possibly with
    some arguments following each instruction. Opcodes expect to find the stack in
    a given state and transform the stack, so that the arguments are removed and results
    placed there instead.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 字节码由一系列操作码（指令集），可能跟随着每个指令的一些参数组成。指令集期望在给定状态下找到栈，并转换栈，以便参数被移除，结果被放置在那里。
- en: Each opcode is denoted by a single-byte value, so at most 255 possible opcodes
    exist. Currently, only around 200 are used. This is too many for us to list exhaustively
    (but a complete list can be found at [http://mng.bz/aJaX](http://mng.bz/aJaX)).
    Fortunately, most opcodes fit into one of a number of basic families that provide
    similar functionality. We’ll discuss each family in turn, to help you get a feel
    for them. Some operations don’t fit cleanly into any of the families, but they
    tend to be encountered less often.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令集由一个单字节值表示，因此最多存在 255 个可能的指令集。目前，只有大约 200 个被使用。这太多了，我们无法一一列出（但完整列表可以在 [http://mng.bz/aJaX](http://mng.bz/aJaX)
    找到）。幸运的是，大多数指令集都适合于几个基本家族之一，这些家族提供了类似的功能。我们将依次讨论每个家族，以帮助您了解它们。有些操作不适合任何家族，但它们出现的频率较低。
- en: Note The JVM isn’t a purely object-oriented runtime environment. It has knowledge
    of primitive types. This shows up in some of the opcode families—some basic opcode
    types (such as `store` and `add`) are required to have a number of variations
    that differ, depending on the primitive type they’re acting upon.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：JVM 不是一个纯粹面向对象的运行时环境。它了解原始类型。这在一些指令集家族中有所体现——一些基本的指令集类型（如 `store` 和 `add`）需要根据它们作用的原始类型具有不同的变体。
- en: 'The opcode tables have the following four columns:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集表有以下四个列：
- en: '*Name*—This is a general name for the type of opcode. In many cases, several
    related opcodes do similar things.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名称*—这是指令集类型的一般名称。在许多情况下，几个相关的指令集会执行类似的功能。'
- en: '*Args*—The arguments that the opcode takes. Arguments that start with `i` are
    (unsigned) bytes that are used to form a lookup index in the constant pool or
    local variable table.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*—指令集所接受的参数。以 `i` 开头的参数是（无符号）字节，用于在常量池或局部变量表中形成查找索引。'
- en: 'Note To make longer indices, bytes are joined together, so that `i1,` `i2`
    means “make a 16-bit index out of these two bytes” via bit shifting and addition:
    `((i1` `<<` `8)` `+` `i2)`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了创建更长的索引，字节会被连接起来，所以 `i1,` `i2` 表示通过位移和加法“将这些两个字节组合成一个 16 位索引”：`((i1` `<<`
    `8)` `+` `i2)`
- en: If an arg is shown in brackets, it means that not all forms of the opcode will
    use it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个参数显示在括号中，这意味着并非所有指令集的形式都会使用它。
- en: '*Stack layout*—This shows the state of the stack before and after the opcode
    has executed. Elements in brackets indicate that not all forms of the opcode use
    them or that the elements are optional (such as for invocation opcodes).'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*栈布局*—这显示了指令集执行前后栈的状态。括号中的元素表示并非所有指令集的形式都会使用它们，或者这些元素是可选的（例如，对于调用指令集）。'
- en: '*Description*—What the opcode does.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*—指令集执行的操作。'
- en: Let’s look at an example of a row from table 4.3 by examining the entry for
    the `getfield` opcode. This is used to read a value from a field of an object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查 `getfield` 指令集的条目来查看表 4.3 中的一个示例行。这个指令集用于从对象字段中读取值。
- en: '| getfield | i1, i2 | [obj] -> [val] | Gets the field at the constant pool
    index specified from the object on top of the stack. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| getfield | i1, i2 | [obj] -> [val] | 从栈顶对象获取常量池中指定索引的字段。|'
- en: The first column gives the name of the opcode—`getfield`. The next column says
    that there are two arguments that follow the opcode in the bytecode stream. These
    arguments are put together to make a 16-bit value that is looked up in the constant
    pool to see which field is wanted (remember that constant pool indexes are always
    16-bit). The stack layout column shows that the reference to the object is replaced
    by the value of the field.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列给出了操作码的名称——`getfield`。下一列说明在字节码流中跟随操作码有两个参数。这些参数组合在一起形成一个16位的值，在常量池中查找以确定所需的字段（记住常量池索引总是16位）。栈布局列显示对象引用被字段的值所替换。
- en: This pattern of removing object instances as part of the operation is just a
    way to make bytecode compact, without lots of tedious cleanup and having to remember
    to remove object instances that you’re finished with.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作过程中作为一部分移除对象实例的模式，仅仅是为了使字节码更加紧凑，避免进行大量繁琐的清理工作，并记得移除已经处理完毕的对象实例。
- en: 4.4.4 Load and store opcodes
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 加载和存储操作码
- en: The family of load and store opcodes is concerned with loading values onto the
    stack or retrieving them. Table 4.3 shows the main operations in the load/store
    family.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和存储操作码系列关注于将值加载到栈上或从中检索。表4.3显示了加载/存储家族中的主要操作。
- en: Table 4.3 Load and store opcodes
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 加载和存储操作码
- en: '| Name | Args | Stack layout | Description |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 参数 | 栈布局 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| load | (i1) | [] -> [val] | Loads a value (primitive or reference) from a
    local variable onto the stack. Has shortcut forms and type-specific variants.
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| load | (i1) | [] -> [val] | 从局部变量加载一个值（原始类型或引用）到栈上。有快捷形式和类型特定的变体。 |'
- en: '| ldc | i1 | [] -> [val] | Loads a constant from the pool onto the stack. Has
    type-specific and wide variants. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| ldc | i1 | [] -> [val] | 从池中加载一个常量到栈上。有类型特定的和宽变体。 |'
- en: '| store | (i1) | [val] -> [] | Stores a value (primitive or reference) in a
    local variable, removing it from the stack in the process. Has shortcut forms
    and type-specific variants. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| store | (i1) | [val] -> [] | 将值（原始类型或引用）存储在局部变量中，在此过程中从栈中移除。有快捷形式和类型特定的变体。
    |'
- en: '| dup |  | [val] -> [val, val] | Duplicates the value on top of the stack.
    Has variant forms. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| dup |  | [val] -> [val, val] | 复制栈顶的值。有变体形式。 |'
- en: '| getfield | i1, i2 | [obj] -> [val] | Gets the field at the constant pool
    index specified from the object on top of the stack. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| getfield | i1, i2 | [obj] -> [val] | 从栈顶对象获取指定常量池索引的字段。 |'
- en: '| putfield | i1, i2 | [obj, val] -> [] | Puts the value into the object’s field
    at the specified constant pool index. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| putfield | i1, i2 | [obj, val] -> [] | 将值放入对象在指定常量池索引的字段中。 |'
- en: '| getstatic | i1, i2 | [] -> [val] | Gets the value of the static field at
    the constant pool index specified. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| getstatic | i1, i2 | [] -> [val] | 从指定的常量池索引获取静态字段的值。 |'
- en: '| putstatic | i1, i2 | [val] -> [] | Puts the value into the static field at
    the specified constant pool index. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| putstatic | i1, i2 | [val] -> [] | 将值放入指定常量池索引的静态字段中。 |'
- en: As we noted earlier, a number of different forms of the load and store instructions
    exist. For example, a `dload` opcode loads a double onto the stack from a local
    variable, and an `astore` opcode pops an object reference off the stack and into
    a local variable.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，存在多种形式的加载和存储指令。例如，`dload`操作码从局部变量将双精度值加载到栈上，而`astore`操作码从栈中弹出一个对象引用到局部变量中。
- en: 'Let’s do a quick example of `getfield` and `putfield`. This simple class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速举例说明`getfield`和`putfield`。这个简单的类：
- en: '[PRE26]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'will decompile the getter and setter as:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将反编译为getter和setter：
- en: '[PRE27]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: which shows how the stack is used to hold temporary variables before transferring
    them to heap storage.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了在将临时变量传输到堆存储之前，栈是如何用来存储它们的。
- en: 4.4.5 Arithmetic opcodes
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 算术操作码
- en: These opcodes perform arithmetic on the stack. They take arguments from the
    top of the stack and perform the required calculation on them. The arguments (which
    are always primitive types) must always match exactly, but the platform provides
    a wealth of opcodes to cast one primitive type to another. Table 4.4 shows the
    basic arithmetic operations.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作码在栈上执行算术运算。它们从栈顶获取参数，并对它们执行所需的计算。参数（总是原始类型）必须完全匹配，但平台提供了丰富的操作码来将一种原始类型转换为另一种类型。表4.4显示了基本的算术运算。
- en: Table 4.4 Arithmetic opcodes
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4 算术操作码
- en: '| Name | Args | Stack layout | Description |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 参数 | 栈布局 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| add |  | [val1, val2] -> [res] | Adds two values (which must be of the same
    primitive type) from the top of the stack and stores the result on the stack.
    Has shortcut forms and type-specific variants. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| add |  | [val1, val2] -> [res] | 将栈顶的两个值（必须是相同原始类型的值）相加，并将结果存储在栈上。具有快捷形式和特定类型的变体。
    |'
- en: '| sub |  | [val1, val2] -> [res] | Subtracts two values (of the same primitive
    type) from the top of the stack. Has shortcut forms and type-specific variants.
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| sub |  | [val1, val2] -> [res] | 从栈顶减去两个值（相同原始类型的值）。具有快捷形式和特定类型的变体。 |'
- en: '| div |  | [val1, val2] -> [res] | Divides two values (of the same primitive
    type) from the top of the stack. Has shortcut forms and type-specific variants.
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| div |  | [val1, val2] -> [res] | 将栈顶的两个值（相同原始类型的值）相除。具有快捷形式和特定类型的变体。 |'
- en: '| mul |  | [val1, val2] -> [res] | Multiplies two values (of the same primitive
    type) from top of the stack. Has shortcut forms and type-specific variants. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| mul |  | [val1, val2] -> [res] | 将栈顶的两个值（相同原始类型的值）相乘。具有快捷形式和特定类型的变体。 |'
- en: '| (cast) |  | [value] -> [res] | Casts a value from one primitive type to another.
    Has forms corresponding to each possible cast. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| (转换) |  | [value] -> [res] | 将值从一种原始类型转换为另一种类型。具有对应于每种可能转换的形式。 |'
- en: The cast opcodes have very short names, such as `i2d` for an `int` to `double`
    cast. In particular, the word *cast* doesn’t appear in the names, which is why
    it’s in parentheses in the table.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 转换操作码具有非常短的名字，例如 `i2d` 用于 `int` 到 `double` 的转换。特别是，单词 *cast* 不出现在名称中，这就是为什么它在表中用括号括起来的原因。
- en: 4.4.6 Execution flow control opcodes
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.6 执行流程控制操作码
- en: As mentioned earlier, the control constructs of high-level languages aren’t
    present in JVM bytecode. Instead, flow control is handled by a small number of
    primitives, which are shown in table 4.5.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，高级语言的控制结构不在 JVM 字节码中。相反，流程控制由少量原始操作处理，这些操作在表 4.5 中显示。
- en: Table 4.5 Execution control opcodes
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5 执行控制操作码
- en: '| Name | Args | Stack layout | Description |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 参数 | 栈布局 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| if | b1, b2 | [val1, val2] -> [] or [val1] -> [] | If the specific condition
    matches, jump to the specified branch offset. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| if | b1, b2 | [val1, val2] -> [] 或 [val1] -> [] | 如果特定条件匹配，则跳转到指定的分支偏移量。
    |'
- en: '| goto | b1, b2 | [] -> [] | Unconditionally jump to the branch offset. Has
    wide form. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| goto | b1, b2 | [] -> [] | 无条件跳转到分支偏移量。有宽形式。 |'
- en: '| tableswitch | {depends} | [index] -> [] | Used to implement switch. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| tableswitch | {depends} | [index] -> [] | 用于实现 switch。 |'
- en: '| lookupswitch | {depends} | [key] -> [] | Used to implement switch. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| lookupswitch | {depends} | [key] -> [] | 用于实现 switch。 |'
- en: Like the index bytes used to look up constants, the `b1, b2` args are used to
    construct a bytecode location within this method to jump to. They cannot be used
    to jump outside of the method—this is checked at class-loading time and would
    cause the class to fail verification.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于查找常量的索引字节类似，`b1, b2` 参数用于在此方法中构建一个字节码位置以跳转。它们不能用于跳转到方法外部——这在类加载时进行检查，会导致类验证失败。
- en: The family of `if` opcodes is a little larger than you might expect—it has more
    than 15 instructions to handle the various source code possibilities (e.g., numeric
    comparison, reference equality).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 操作码系列比你想象的要大一些——它有超过 15 条指令来处理各种源代码可能性（例如，数值比较、引用相等）。'
- en: Note The family of `if` opcodes also contains two deprecated instructions, `jsr`
    and `ret`, which are no longer produced by `javac` and are illegal in modern Java
    versions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`if` 操作码系列还包含两个已弃用的指令，`jsr` 和 `ret`，这些指令不再由 `javac` 生成，并且在现代 Java 版本中是非法的。
- en: A wide form of the `goto` instruction (`goto_w`) takes 4 bytes of arguments
    and constructs an offset, which can be larger than 64 KB. This isn’t often needed
    because it would only apply to very, very large methods (and such methods have
    other problems, such as being too large to be JIT compiled). There is also `ldc_w`,
    which can be used to address very large constant pools.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 指令的宽形式（`goto_w`）需要 4 个字节的参数并构建一个偏移量，该偏移量可以大于 64 KB。这并不常见，因为它只会应用于非常大非常大的方法（并且这样的方法有其他问题，例如太大而不能被
    JIT 编译）。还有 `ldc_w`，它可以用来引用非常大的常量池。'
- en: 4.4.7 Invocation opcodes
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.7 调用操作码
- en: The invocation opcodes comprise four opcodes for handling general method calling,
    plus the unusual `invokedynamic` opcode, which was added in Java 7\. We’ll discuss
    this special case in more detail in chapter 17\. The five method invocation opcodes
    are shown in table 4.6.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 调用操作码包括四个用于处理一般方法调用的操作码，以及不寻常的`invokedynamic`操作码，该操作码是在Java 7中添加的。我们将在第17章中更详细地讨论这个特殊情况。五个方法调用操作码如表4.6所示。
- en: Table 4.6 Invocation opcodes
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6 调用操作码
- en: '| Name | Args | Stack layout | Description |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 参数 | 堆栈布局 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| invokestatic | i1, i2 | [(val1, ...)] -> [] | Calls a static method. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| invokestatic | i1, i2 | [(val1, ...)] -> [] | 调用一个静态方法。|'
- en: '| invokevirtual | i1, i2 | [obj, (val1, ...)] -> [] | Calls a “normal” instance
    method. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| invokevirtual | i1, i2 | [obj, (val1, ...)] -> [] | 调用一个“正常”的实例方法。|'
- en: '| invokeinterface | i1, i2, count, 0 | [obj, (val1, ...)] -> [] | Calls an
    interface method. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 调用接口 | i1, i2, count, 0 | [obj, (val1, ...)] -> [] | 调用一个接口方法。|'
- en: '| invokespecial | i1, i2 | [obj, (val1, ...)] -> [] | Calls a “special” instance
    method, such as a constructor. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| invokespecial | i1, i2 | [obj, (val1, ...)] -> [] | 调用一个“特殊”的实例方法，例如构造函数。|'
- en: '| invokedynamic | i1, i2, 0, 0 | [val1, ...] -> [] | Dynamic invocation; see
    chapter 17. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| invokedynamic | i1, i2, 0, 0 | [val1, ...] -> [] | 动态调用；请参阅第17章。|'
- en: 'It’s easiest to see the difference between these opcodes with an extended example,
    shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个扩展的例子，我们可以最容易地看到这些操作码之间的区别，如下所示：
- en: '[PRE28]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s use `javap -c` to look at the bytecode for this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`javap -c`来查看这个的字节码：
- en: '[PRE29]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we discussed earlier, the Java method calls are actually turned into one
    of several possible `invoke*` bytecodes. Let’s take a closer look:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，Java方法调用实际上被转换成了几种可能的`invoke*`字节码之一。让我们更仔细地看看：
- en: '[PRE30]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The static call to `System.currentTimeMillis()` is turned into an `invokestatic`
    that appears at position 0 in the bytecode. This method takes no parameters, so
    nothing needs to be loaded onto the evaluation stack before the call is dispatched.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对`System.currentTimeMillis()`的静态调用被转换成了在字节码中位置为0的`invokestatic`。这个方法没有参数，因此在调用分发之前不需要将任何内容加载到评估堆栈上。
- en: Next, the two bytes `00 02` appear in the byte stream. These are combined into
    a 16-bit number that is used as an offset into the constant pool.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，字节流中出现了两个字节`00 02`。这些字节组合成一个16位数字，用作常量池的偏移量。
- en: The decompiler helpfully includes a comment that lets the user know which method
    offset `#2` corresponds to. In this case, as expected, it’s the method `System
    .currentTimeMillis()`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译器方便地包含了一条注释，告知用户方法偏移量`#2`对应的是哪个方法。在这个例子中，正如预期的那样，它是`System .currentTimeMillis()`方法。
- en: On return, the result of the call is placed on the stack, and at offset 3, we
    see the single, argument-less opcode `lstore_1` that saves this return value off
    into the local variable 1.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 返回时，调用结果被放置在堆栈上，在偏移量3处，我们看到单个无参数操作码`lstore_1`，它将这个返回值保存到局部变量1中。
- en: Human readers are, of course, able to see that the variable `time` is never
    used again. However, one of the design goals of `javac` is to represent the contents
    of the Java source code as faithfully as possible, whether or not it makes sense.
    Therefore, the return value of `System.currentTimeMillis()` is stored, even though
    it is not used after this point in the program.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，人类读者能够看到变量`time`从未再次被使用。然而，`javac`的设计目标之一是尽可能忠实地表示Java源代码的内容，无论其是否有意义。因此，`System.currentTimeMillis()`的返回值被存储，即使在此之后的程序中没有被使用。
- en: 'This is “dumb bytecode” in action: remember that from the point of view of
    the platform, the class file format is the input format to the compiler that really
    matters—the JIT compiler:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是“愚蠢的字节码”在起作用：记住，从平台的角度来看，类文件格式是真正重要的编译器的输入格式——即时编译器：
- en: '[PRE31]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Bytecodes 4 to 10 create a new `HashMap` instance, before instruction 11 saves
    a copy of it into a local variable. Next, instructions 12 to 16 set up the stack
    with the `HashMap` object and the arguments for the call to `put()`. The actual
    invocation of the `put()` method is performed by instructions 17 to 19.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码4到10创建了一个新的`HashMap`实例，在指令11将它的副本保存到局部变量中之前。接下来，指令12到16使用`HashMap`对象和调用`put()`的参数设置堆栈。实际的`put()`方法调用由指令17到19执行。
- en: The invoke opcode used this time is `invokevirtual` because the static type
    of the local variable was declared as `HashMap`—a class type. We will see what
    will happen if the local variable is declared as `Map` in a moment.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这次使用的调用操作码是`invokevirtual`，因为局部变量的静态类型被声明为`HashMap`——一个类类型。我们将在稍后看到如果局部变量被声明为`Map`会发生什么。
- en: An instance method call differs from a static method call because a static call
    does not have an instance on which the method is called (sometimes called the
    receiver object).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法调用与静态方法调用不同，因为静态调用没有方法被调用的实例（有时称为接收者对象）。
- en: Note In bytecode, an instance call must be set up by placing the receiver and
    any call arguments on the evaluation stack and then issuing the invoke instruction.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在字节码中，实例调用必须通过将接收者和任何调用参数放置在评估堆栈上，然后发出调用指令来设置。
- en: 'In this case, the return value from `put()` is not used, so instruction 20
    discards it, as shown here:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`put()` 的返回值没有被使用，所以指令 20 丢弃它，如下所示：
- en: '[PRE32]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The sequence of bytes from 21 to 25 seems rather odd at first glance. The `HashMap`
    instance that we created at 4 and saved to local variable 3 at instruction 11
    is now loaded back onto the stack, and a copy of the reference is saved to local
    variable 4\. This process removes it from the stack, so it must be reloaded (from
    variable 4) before use. This shuffling occurs because in the original Java code,
    we created an additional local variable (of type `Map` rather than `HashMap`),
    even though it always refers to the same object as the original variable. This
    is another example of the bytecode staying as close as possible to the original
    source code.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从 21 到 25 的字节序列一开始看起来相当奇怪。我们在指令 11 时创建并保存到局部变量 3 的 `HashMap` 实例现在被重新加载到堆栈上，并且其引用的副本被保存到局部变量
    4。这个过程将其从堆栈中移除，因此在使用之前必须重新加载（从变量 4）。这种重新排列发生是因为在原始的 Java 代码中，我们创建了一个额外的局部变量（类型为
    `Map` 而不是 `HashMap`），尽管它始终引用与原始变量相同的对象。这是字节码尽可能接近原始源代码的另一个例子。
- en: After the stack and variable shuffling, the values to be placed in the map are
    loaded at instructions 26 to 29\. With the stack prepared with receiver and arguments,
    the call to `put()` is dispatched at instruction 30\. This time, the opcode is
    `invokeinterface`, even though the exact same method is actually being called.
    This is because the Java local variable is of type `Map`—an interface type. Once
    again, the return value from `put()` is discarded, via the `pop` at instruction
    35.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈和变量重新排列之后，要在指令 26 到 29 之间加载要放入映射中的值。在堆栈准备好接收者和参数后，`put()` 的调用在指令 30 处分发。这次，指令是
    `invokeinterface`，尽管实际上正在调用的是完全相同的方法。这是因为 Java 本地变量是 `Map` 类型——一个接口类型。再次，`put()`
    的返回值通过指令 35 的 `pop` 被丢弃。
- en: As well as knowing which Java method invocations turn into which operations,
    you should notice a couple of other wrinkles about the invocation opcodes. First
    off is that `invokeinterface` has extra parameters. These are present for historical
    and backward compatibility reasons and aren’t used these days. The two extra zeros
    on `invokedynamic` are present for forward-compatibility reasons.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 除了知道哪些 Java 方法调用会转换为哪些操作外，你还应该注意关于调用指令的一些其他细节。首先，`invokeinterface` 有额外的参数。这些参数是出于历史和向后兼容性原因而存在的，并且现在不再使用。`invokedynamic`
    上的两个额外零是出于向前兼容性原因。
- en: The other important point is the distinction between a regular and a special
    instance method call. A regular call is *virtual*, which means that the exact
    method to be called is looked up at runtime using the standard Java rules of method
    overriding.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要点是常规和特殊实例方法调用的区别。常规调用是 *虚拟的*，这意味着确切要调用的方法是在运行时使用标准的 Java 覆盖规则查找的。
- en: However, a couple of special cases exist, including calls to a superclass method.
    In these cases, you don’t want the override rules to be triggered, so you need
    a different invocation opcode to allow for this case. This is why the opcode set
    needs an opcode for invocation of methods without the override mechanism—`invokespecial`—which
    instead indicates exactly which method will be called.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一些特殊情况，包括对超类方法的调用。在这些情况下，你不想触发覆盖规则，因此需要一个不同的调用指令来允许这种情况。这就是为什么指令集需要为没有覆盖机制的方法调用提供一个指令——`invokespecial`——它确切地指示将被调用的方法。
- en: 4.4.8 Platform operation opcodes
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.8 平台操作指令集
- en: The platform operation family of opcodes includes the new opcode, for allocating
    new object instances, and the thread-related opcodes, such as `monitorenter` and
    `monitorexit`. The details of this family can be seen in table 4.7.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集操作平台家族包括新的指令集，用于分配新的对象实例，以及与线程相关的指令集，例如 `monitorenter` 和 `monitorexit`。这个家族的详细信息可以在表
    4.7 中查看。
- en: Table 4.7 Platform opcodes
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.7 平台指令集
- en: '| Name | Args | Stack layout | Description |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 参数 | 堆栈布局 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| new | i1, i2 | [] -> [obj] | Allocates memory for a new object, of the type
    specified by the constant at the specified index. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| new | i1, i2 | [] -> [obj] | 为指定索引处常量指定的类型的新对象分配内存。|'
- en: '| monitorenter |  | [obj] -> [] | Locks an object. See chapter 5. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| monitorenter |  | [obj] -> [] | 锁定一个对象。参见第5章。|'
- en: '| monitorexit |  | [obj] -> [] | Unlocks an object. See chapter 5. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| monitorexit |  | [obj] -> [] | 解锁一个对象。参见第5章。|'
- en: The platform opcodes are used to control certain aspects of the object lifecycle,
    such as creating new objects and locking them. It’s important to notice that the
    new opcode allocates only storage. The high-level conception of object construction
    also includes running the code inside the constructor.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 平台操作码用于控制对象生命周期的某些方面，例如创建新对象和锁定它们。重要的是要注意，新操作码只分配存储空间。对对象构造的高级概念也包括在构造函数中运行代码。
- en: At the bytecode level, the constructor is turned into a method with a special
    name—`<init>`. This can’t be called from user Java code, but it can be called
    by bytecode. This leads to the distinctive bytecode pattern that directly corresponds
    to object creation—a `new` followed by a `dup` followed by an `invokespecial`
    to call the `<init>` method, as we saw earlier.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码级别，构造函数被转换为一个具有特殊名称的方法——`<init>`。这个方法不能从用户Java代码中调用，但可以从字节码中调用。这导致了与对象创建直接对应的独特字节码模式——一个`new`后面跟着一个`dup`，然后是一个`invokespecial`来调用`<init>`方法，正如我们之前看到的。
- en: The `monitorenter` and `monitorexit` bytecodes correspond to the start and end
    of a synchronized block.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitorenter`和`monitorexit`字节码对应于`synchronized`块的开始和结束。'
- en: 4.4.9 Shortcut opcode forms
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.9 简化操作码形式
- en: Many of the opcodes have shortcut forms to save a few bytes here and there.
    The general pattern is that certain local variables will be accessed much more
    frequently than others, so it makes sense to have a special opcode that means
    “do the general operation directly on the local variable” rather than having to
    specify the local variable as an argument. This gives rise to opcodes such as
    `aload_0` and `dstore_2` within the load/store family, which are 1 byte shorter
    than the equivalent byte sequences, `aload 00` or `dstore` `02`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作码都有简化的形式，以节省一些字节。一般模式是某些局部变量会被比其他变量更频繁地访问，因此有一个特殊的操作码表示“直接在局部变量上执行通用操作”是有意义的，而不是必须指定局部变量作为参数。这导致了在加载/存储家族中的操作码，如`aload_0`和`dstore_2`，它们比等效的字节序列`aload
    00`或`dstore 02`短1个字节。
- en: Note One byte saved may not sound like much, but it adds up over the entire
    class. Java’s original use case was applets, which were often downloaded over
    dial-up modems, at speeds of 28.8 *kilobits* per second. With that speed of bandwidth,
    it was important to save bytes wherever possible.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：节省的一个字节可能看起来不多，但整个类中加起来就很重要了。Java最初的使用案例是applet，它们通常通过拨号调制解调器下载，速度为每秒28.8
    *千比特*。在这种带宽速度下，尽可能节省字节是很重要的。
- en: To become a truly well-grounded Java developer, you should run `javap` against
    some of your own classes and learn to recognize common bytecode patterns. For
    now, with this brief introduction to bytecode under our belts, let’s move on to
    tackle our next subject—reflection.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个真正的经验丰富的Java开发者，你应该对你的某些自己的类运行`javap`，并学会识别常见的字节码模式。现在，带着对字节码的简要介绍，让我们继续解决我们的下一个主题——反射。
- en: 4.5 Reflection
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 反射
- en: One of the key techniques that a well-grounded Java developer should have at
    their command is *reflection*. This is an extremely powerful capability, but many
    developers struggle with it at first because it seems alien to the way that most
    Java developers think about code.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验丰富的Java开发者应该掌握的关键技术之一是*反射*。这是一个极其强大的功能，但许多开发者最初都会觉得它很陌生，因为它与大多数Java开发者对代码的看法不同。
- en: 'Reflection is the ability to query or *introspect* objects and discover (and
    use) their capabilities at runtime. It can be thought of as several different
    things, depending on context:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是查询或*内省*对象的能力，在运行时发现（并使用）它们的特性。它可以被视为在上下文中不同的几件事情：
- en: A programming language API
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种编程语言API
- en: A programming style or technique
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种编程风格或技术
- en: A runtime mechanism that enables the technique
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种启用该技术的运行时机制
- en: A property of the language type system
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言类型系统的一个属性
- en: Reflection in an object-oriented system is essentially the idea that the programming
    environment can represent the types and methods of the program as objects. This
    is possible only in languages that have a runtime that supports this, and it is
    a fundamentally dynamic aspect of a language.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象系统中，反射本质上是一种思想，即编程环境可以将程序的类型和方法表示为对象。这只有在具有支持此功能的运行时的语言中才可能，并且这是语言的一个基本动态特性。
- en: When using the reflective style of programming, it is possible to manipulate
    objects without using their static types at all. This seems like a step backward,
    but if we can work with objects without needing to know their static types, then
    it means that we can build libraries, frameworks, and tools that can work with
    *any* type—including types that did not even exist when our code was written.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反射式编程风格时，可以在完全不使用它们的静态类型的情况下操作对象。这似乎是一个倒退，但如果我们可以不依赖于它们的静态类型来处理对象，那么这意味着我们可以构建可以与
    *任何* 类型一起工作的库、框架和工具——包括在我们编写代码时甚至不存在的那种类型。
- en: When Java was a young language, reflection was one of the key technological
    innovations that it brought to the mainstream. Although other languages (notably
    Smalltalk) had introduced it much earlier, it was not a common part of many languages
    at the time Java was released.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 还是一个年轻的语言时，反射是它带给主流的几个关键技术创新之一。尽管其他语言（特别是 Smalltalk）早在很久以前就引入了它，但在 Java
    发布时，它并不是许多语言中常见的部分。
- en: 4.5.1 Introducing reflection
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 反射简介
- en: 'The abstract description of reflection can often seem confusing or hard to
    grasp. Let’s look at some simple examples in JShell to try to get a more concrete
    view of what reflection is:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的抽象描述常常显得令人困惑或难以理解。让我们通过 JShell 中的简单示例来尝试获得对反射更具体的概念：
- en: '[PRE33]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is our first glimpse of reflection—a class object for the type `Object`.
    In fact, the actual type of `clz` is `Class<Object>`, but when we obtain a class
    object from class loading or `getClass()`, we have to handle it using the unknown
    type, `?`, in the generics, as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对反射的第一瞥——`Object` 类型的类对象。实际上，`clz` 的实际类型是 `Class<Object>`，但当我们从类加载或 `getClass()`
    获取类对象时，我们必须使用泛型中的未知类型 `?` 来处理它，如下所示：
- en: '[PRE34]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is because reflection is a dynamic, runtime mechanism, and the true type
    `Class<Object>` is not known to the source code compiler. This process introduces
    irreducible extra complexity to working with reflection because we cannot rely
    on the Java type system to help us very much. On the other hand, this dynamic
    nature is the key point of reflection—if we don’t know what type something is
    at compile time and have to treat it in a very general way, we can exploit this
    flexibility to build an open, extensible system.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为反射是一个动态的运行时机制，真正的 `Class<Object>` 类型对源代码编译器来说是未知的。这个过程给使用反射的工作引入了不可减少的额外复杂性，因为我们不能依赖
    Java 类型系统来帮助我们很多。另一方面，这种动态性质是反射的关键点——如果我们不知道在编译时某个类型是什么，并且必须以非常通用的方式处理它，我们可以利用这种灵活性来构建一个开放、可扩展的系统。
- en: Note Reflection produces a fundamentally open system, and as we saw in chapter
    2, this can come into conflict with the more encapsulated systems that Java modules
    try to bring to the platform.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 注意反射产生了一个根本上是开放的系统，正如我们在第 2 章中看到的，这可能会与 Java 模块试图引入平台的更封装的系统发生冲突。
- en: 'Many familiar frameworks and developer tools rely heavily on reflection to
    achieve their capabilities, such as debuggers and code browsers. Plugin architectures,
    interactive environments, and REPLs also use reflection extensively. In fact,
    JShell itself could not be built in a language without a reflection subsystem.
    Let’s exploit this and use JShell to explore some of reflection’s key features,
    as shown next:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 许多熟悉的框架和开发工具严重依赖反射来实现其功能，例如调试器和代码浏览器。插件架构、交互式环境和 REPL 也广泛使用反射。事实上，如果没有反射子系统，JShell
    本身也无法构建。让我们利用这一点，使用 JShell 探索反射的一些关键特性，如下所示：
- en: '[PRE35]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we have an object that represents the class type of `Pet` that we can use
    to do other actions, such as creating a new instance, as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个代表 `Pet` 类型的对象，我们可以用它来进行其他操作，例如创建一个新的实例，如下所示：
- en: '[PRE36]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The problem we have is that `newInstance()` returns `Object`, which isn’t a
    very useful type. We could, of course, cast `o` back to `Pet`, but this requires
    us to know ahead of time what types we’re working with, which rather defeats the
    point of the dynamic nature of reflection. So let’s try something else:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的问题是`newInstance()`返回`Object`，这并不是一个非常有用的类型。我们当然可以将`o`回显式地转换为`Pet`，但这要求我们事先知道我们正在处理什么类型，这几乎抵消了反射动态特性的意义。所以让我们试试别的：
- en: '[PRE37]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we have an object that represents the method `feed()`, but it represents
    it as abstract metadata—it is not attached to any specific instance.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个代表`feed()`方法的对象，但它将其表示为抽象元数据——它没有附加到任何特定的实例上。
- en: The natural thing to do with an object that represents a method is to call it.
    The class `java.lang.reflect.Method` defines a method `invoke()` that has the
    effect of calling the method that the `Method` object represents.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代表方法的对象，自然的事情就是调用它。`java.lang.reflect.Method`类定义了一个`invoke()`方法，该方法的效果是调用`Method`对象代表的方法。
- en: Note When working in JShell, we avoid a lot of exception-handling code. When
    writing regular Java code that uses reflection, you will have to deal with the
    possible exception types in one way or another.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在JShell中工作，我们避免了大量的异常处理代码。当编写使用反射的常规Java代码时，你必须以某种方式处理可能的异常类型。
- en: 'For this call to succeed, we must provide the right number and types of arguments.
    This argument list must include the *receiver object* on which the method is being
    called reflectively (assuming the method is an instance method). In our simple
    example, this looks like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此调用成功，我们必须提供正确数量和类型的参数。此参数列表必须包括被反射调用的方法所在的*接收器对象*（假设该方法是一个实例方法）。在我们的简单示例中，它看起来是这样的：
- en: '[PRE38]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ The call returns null because the feed() method is actually void.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用返回null，因为feed()方法实际上是void。
- en: As well as the `Method` objects, reflection also provides for objects that represent
    other fundamental concepts within the Java type system and language, such as fields,
    annotations, and constructors. These classes are found in the `java.lang.reflect`
    package, and some of them (such as `Constructor`) are generic types.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Method`对象外，反射还提供了代表Java类型系统和语言中其他基本概念的对象，例如字段、注解和构造函数。这些类位于`java.lang.reflect`包中，其中一些类（如`Constructor`）是泛型类型。
- en: 'The reflection subsystem also had to be upgraded to deal with modules. Just
    as classes and methods can be treated reflectively, so there needs to be a reflective
    API for working with modules. The key class is, perhaps unsurprisingly, `java.lang.Module`,
    and we can access directly from a `Class` object as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 反射子系统也必须升级以处理模块。正如类和方法可以被反射处理一样，因此需要有一个用于处理模块的反射API。关键类可能是出人意料的是`java.lang.Module`，我们可以直接从一个`Class`对象访问它，如下所示：
- en: '[PRE39]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The descriptor of a module is of type `ModuleDescriptor` and provides a read-only
    view of the metadata about a module—basically equivalent to the contents of `module-info
    .class`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的描述符是`ModuleDescriptor`类型，它提供了对模块元数据的只读视图——基本上等同于`module-info .class`的内容。
- en: Dynamic capabilities, such as discovery of modules, are also possible in the
    new reflective API. This is achieved via interfaces such as `ModuleFinder`, but
    a detailed description of how to work reflectively with the modules system is
    outside the scope of this book—the interested reader should consult chapter 12
    of Nicolai Parlog’s book, *The Java Module System* (Manning, 2019), [http://mng.bz/gwGG](http://mng.bz/gwGG).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的反射API中，也支持动态功能，例如模块的发现。这是通过`ModuleFinder`等接口实现的，但如何详细地使用模块系统进行反射操作超出了本书的范围——感兴趣的读者应参考Nicolai
    Parlog的书籍第12章，*The Java Module System*（Manning，2019），[http://mng.bz/gwGG](http://mng.bz/gwGG)。
- en: 4.5.2 Combining class loading and reflection
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 结合类加载和反射
- en: Let’s look at an example that combines class loading and reflection. We won’t
    need a full class loader that obeys the usual `findClass()` and `loadClass()`
    protocols. Instead, we’ll just subclass `ClassLoader` to gain access to the protected
    `defineClass()` method.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个结合类加载和反射的例子。我们不需要遵循通常的`findClass()`和`loadClass()`协议的完整类加载器。相反，我们将仅通过子类化`ClassLoader`来访问受保护的`defineClass()`方法。
- en: 'The main method takes a list of filenames, and, if they’re a Java class, it
    uses reflection to access each method in turn and detect whether or not it’s a
    native method, as shown next:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法接受一个文件名列表，如果它们是Java类，它将使用反射依次访问每个方法并检测它是否是本地方法，如下所示：
- en: '[PRE40]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These types of examples can be fun to explore the dynamic nature of the Java
    platform and to learn how the Reflection API works. However, it’s important that
    a well-grounded Java developer be conscious of the limitations and occasional
    frustrations that can occur when working reflectively.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的例子可以很有趣，可以探索Java平台的动态性，并了解反射API是如何工作的。然而，一个扎实的Java开发者应该意识到，在反射工作时可能会遇到的限制和偶尔的挫败感。
- en: 4.5.3 Problems with reflection
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 反射的问题
- en: 'The Reflection API has been part of the Java platform since version 1.1 (1996),
    and in the 25 years since its arrival, a number of issues and weaknesses have
    come to light. Some of these inconveniences follow:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 反射API自Java平台1.1版本（1996年）以来就是其一部分，自从它出现以来，已经出现了一些问题和弱点。以下是一些不便之处：
- en: It’s a very old API with array types everywhere (it predates the Java Collections).
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个非常古老的API，到处都是数组类型（它早于Java集合）。
- en: Figuring out which method overload to call is painful.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定调用哪个方法重载是痛苦的。
- en: API has two different methods, `getMethod()` and `getDeclaredMethod()`, to access
    methods reflectively.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API提供了两种不同的方法，`getMethod()`和`getDeclaredMethod()`，用于反射访问方法。
- en: API provides the `setAccessible()` method, which can be used to ignore access
    control.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API提供了`setAccessible()`方法，可以用来忽略访问控制。
- en: Exception handling is complex for reflective calls—checked exceptions are elevated
    to runtime exceptions.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射调用中的异常处理很复杂——检查异常被提升为运行时异常。
- en: Boxing and unboxing is necessary to make reflective calls that pass or return
    primitives.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进行传递或返回原始类型的反射调用，需要装箱和拆箱。
- en: Primitive types require placeholder class objects, for example, `int.class`,
    which is actually of type `Class<Integer>`.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型需要占位符类对象，例如，`int.class`，它实际上是`Class<Integer>`类型。
- en: The `void` methods require the introduction of the `java.lang.Void` type.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`方法需要引入`java.lang.Void`类型。'
- en: As well as the various awkward corners in the API, Java Reflection has always
    suffered from poor performance for several reasons, including unfriendliness to
    the JVM’s JIT compiler.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 除了API中的各种尴尬角落，Java反射由于几个原因（包括对JVM的JIT编译器的友好性不足）一直遭受性能不佳的困扰。
- en: Note Solving the problem of reflective call performance was one of the major
    reasons for the addition of the Method Handles API, which we will meet in chapter
    17.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：解决反射调用性能问题是在第17章中将要介绍的Method Handles API添加的主要原因之一。
- en: 'There is one final problem with reflection, which is perhaps more of a philosophical
    problem (or antipattern): developers frequently encounter reflection as one of
    the first truly advanced techniques that they meet when leveling up in Java. As
    a result, it can become overused, or a *Golden Hammer* technique—used to implement
    systems that are excessively flexible or which display an internal mini-framework
    that is not really needed (sometimes called the *Inner Framework* antipattern).
    Such systems are often very configurable but at the expense of encoding the domain
    model into configuration rather than directly in the domain types.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 反射还有一个最终问题，这或许更是一个哲学问题（或反模式）：开发者们在Java进阶过程中，经常会遇到反射作为第一个真正高级的技术。因此，它可能会被过度使用，或者变成一种*金锤*技术——用于实现过度灵活的系统，或者显示一个实际上并不需要的内部迷你框架（有时称为*内部框架*反模式）。这样的系统通常非常可配置，但代价是将领域模型编码到配置中，而不是直接在领域类型中。
- en: Reflection is a great technique and one that the well-grounded Java developer
    should have in their toolbox, but it is not suitable for every situation, and
    most developers will need to use it only sparingly.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一项伟大的技术，一个扎实的Java开发者应该在他们的工具箱中拥有它，但它并不适合每种情况，大多数开发者可能只需要少量使用它。
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The class file format and class loading are central to the operation of the
    JVM. They’re essential for any language that wants to run on the VM.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类文件格式和类加载是JVM操作的核心。对于任何希望在VM上运行的语言来说，它们是必不可少的。
- en: The various phases of class loading enable both security and performance features
    at runtime.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载的各个阶段在运行时既提供了安全特性，也提供了性能特性。
- en: JVM bytecode is organized into families with related functionality.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM字节码被组织成具有相关功能的家庭。
- en: Using `javap` to disassemble class files can help you understand the lower level.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`javap`反汇编类文件可以帮助你理解底层。
- en: Reflection is a major feature and extremely powerful.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射是一个主要特性，非常强大。
