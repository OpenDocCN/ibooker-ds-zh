- en: 14 Fitting functions to data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 将函数拟合到数据中
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Measuring how closely a function models a data set
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量函数与数据集拟合的紧密程度
- en: Exploring spaces of functions determined by constants
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索由常数确定的函数空间
- en: Using gradient descent to optimize the quality of “fit”
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用梯度下降优化“拟合”质量
- en: Modeling data sets with different kinds of functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同类型的函数建模数据集
- en: The calculus techniques you learned in part 2 require well-behaved functions
    to be applicable. For a derivative to exist, a function needs to be sufficiently
    smooth, and to calculate an exact derivative or integral, you need a function
    to have a simple formula. For most real-world data, we aren’t so lucky. Due to
    randomness or measurement error, we rarely come across perfectly smooth functions
    in the wild. In this chapter, we cover how to take messy data and model it with
    a simple mathematical function−a task called *regression*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2部分中你学到的微积分技术需要适用性良好的函数。为了存在导数，函数需要足够平滑，并且为了计算精确的导数或积分，你需要一个具有简单公式的函数。对于大多数现实世界的数据，我们并不这么幸运。由于随机性或测量误差，我们在野外很少遇到完全平滑的函数。在本章中，我们介绍了如何将杂乱的数据用简单的数学函数进行建模−这是一个称为
    *回归* 的任务。
- en: I’ll walk you through an example on a real data set, consisting of 740 used
    cars listed for sale on the website CarGraph.com. These cars are all Toyota Priuses,
    and they all have mileage and sale price reported. Plotting this data on a scatter
    plot, figure 14.1 shows that we can see there’s a downward trend in price as mileage
    increases. This reflects that cars lose value as they are driven. Our goal is
    to come up with a simple function that describes how the price of a used Prius
    changes as its mileage increases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将带您通过一个真实数据集的例子，这个数据集包括在CarGraph.com网站上出售的740辆二手车的信息。这些车都是丰田普锐斯，并且都报告了行驶里程和销售价格。将这些数据绘制在散点图上，如图14.1所示，我们可以看到随着里程的增加，价格呈下降趋势。这反映了汽车在使用过程中会贬值。我们的目标是找到一个简单的函数来描述二手普锐斯价格随里程增加的变化。
- en: '![](../Images/CH14_F01_Orland.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F01_Orland.png)'
- en: Figure 14.1 A plot of price vs. mileage for used Toyota Priuses listed for sale
    on CarGraph.com
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 CarGraph.com上出售的二手丰田普锐斯的售价与里程的对比图
- en: We can’t draw a smooth function that passes through all of these points, and
    even if we could, it would be nonsensical. Many of these points are *outliers*
    and probably erroneous (for instance, the handful of nearly new cars that are
    selling for less than $5,000 in figure 14.1). And there are certainly other factors
    that affect the resale price of a used car. We shouldn’t expect mileage alone
    to put an exact value on the price.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法绘制一个穿过所有这些点的平滑函数，即使我们能够做到，那也是没有意义的。其中许多点是 *异常值*，可能存在错误（例如，图14.1中那些售价低于5000美元的几乎全新的汽车）。当然，还有其他因素会影响二手车的再销售价格。我们不应该期望仅凭里程就能准确评估价格。
- en: 'What we can do is find a function that approximates the trend of this data.
    Our function *p*(*x*) takes mileage *x* as an input and returns a typical price
    for a Prius with that given mileage. To do this, we need to make a *hypothesis*
    about what kind of function this will be. We can start with the simplest possible
    example: a linear function.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做的是找到一个函数来近似这些数据的变化趋势。我们的函数 *p*(*x*) 以里程 *x* 作为输入，并返回给定里程的普锐斯的典型价格。为了做到这一点，我们需要对这个函数的类型做出一个
    *假设*。我们可以从最简单的例子开始：一个线性函数。
- en: We looked at linear functions in many forms in chapter 7, but in this chapter,
    we’ll write these in the format *p*(*x*) = *ax* + *b*, where *x* is the mileage
    of a car, *p* is its price, and *a* and *b* are numbers that determine the shape
    of the function. With a choice of *a* and *b*, this function is an imaginary machine
    that takes the mileage of a Toyota Prius and predicts its price as shown in figure
    14.2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们以多种形式探讨了线性函数，但在这章中，我们将以 *p*(*x*) = *ax* + *b* 的格式来书写这些函数，其中 *x* 是汽车的行驶里程，*p*
    是其价格，而 *a* 和 *b* 是决定函数形状的数字。通过选择 *a* 和 *b*，这个函数就是一个想象中的机器，它根据丰田普锐斯的行驶里程预测其价格，如图14.2所示。
- en: '![](../Images/w_gifs_715.gif)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/w_gifs_715.gif)'
- en: Figure 14.2 A schematic of a linear function predicting price p from mileage
    x
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 从里程 x 预测价格 p 的线性函数示意图
- en: Remember, *a* is the slope of the line and *b* is its value at zero. With values
    like *a* = −0.05 and *b* = 20,000, the graph of the function becomes a line starting
    at a price of $20,000 and decreasing by $0.05 every time the mileage increases
    by one mile (figure 14.3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*a*是线的斜率，*b*是它在零点的值。对于像*a* = −0.05和*b* = 20,000这样的值，函数的图形变成了一条从20,000美元的价格开始，每增加一英里里程就减少0.05美元的线（图14.3）。
- en: '![](../Images/w_gifs_716.gif)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/w_gifs_716.gif)'
- en: Figure 14.3 Predicting the price of a Prius based on the mileage, using a function
    of the form *p*(*x*) = *ax* + *b* with *a* = −0.05 and *b* = 20,000
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 基于里程预测普锐斯的价格，使用形式为*p*(x) = *ax* + *b*的函数，其中*a* = −0.05和*b* = 20,000
- en: This choice of prediction function implies a new Prius is worth $20,000, and
    that it depreciates or loses value at a rate of $0.05 per mile. These values may
    or may not be correct; in fact, we have reason to believe they aren’t perfect
    because the graph of this line doesn’t come close to most of the data. The task
    of finding the values of *a* and *b* so that *p*(*x*) follows the trend of the
    data as well as possible is called *linear regression*. Once we find the best
    values, we can say *p*(*x*) is the *line of best fit*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种预测函数的选择意味着新普锐斯的价值为20,000美元，并且以每英里0.05美元的速度折旧或损失价值。这些值可能正确也可能不正确；事实上，我们有理由相信它们并不完美，因为这条线的图形与大多数数据相差甚远。找到*a*和*b*的值，使得*p*(x)尽可能好地遵循数据趋势的任务被称为线性回归。一旦我们找到最佳值，我们就可以说*p*(x)是最佳拟合线。
- en: If *p*(*x*) is going to come close to the real data, it seems reasonable that
    slope *a* should be negative so that the predicted price decreases as mileage
    increases. We won’t have to assume that, however, because we can implement an
    algorithm that figures this out directly from the raw data. This is why regression
    is a simple example of a machine learning algorithm; based on data alone, it infers
    a trend and can then make predictions about new data points.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*(x)要接近真实数据，那么斜率*a*应该是负的，这样随着里程的增加，预测的价格就会下降，这似乎是合理的。然而，我们不必假设这一点，因为我们可以直接从原始数据中实现一个算法来解决这个问题。这就是为什么回归是机器学习算法的一个简单例子；它仅基于数据，推断出趋势，然后对新数据点做出预测。
- en: The only real constraint we impose is that our algorithm looks for linear functions.
    A *linear function* assumes that the rate of depreciation is constant−that the
    loss in dollar value of the car in its first 1,000 miles is the same as the loss
    in value during 100,000 to 101,000 miles. Conventional wisdom says this is not
    the case, and in fact, that cars lose a good portion of their value the moment
    they are driven off the lot. Our goal will not be to find the perfect model, but
    to find a simple model that still performs well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们施加的唯一真正约束是，我们的算法寻找线性函数。线性函数假设折旧率是恒定的−即汽车在前1,000英里内的价值损失与在10万到10万1,000英里内的价值损失相同。传统智慧认为这不是事实，实际上，汽车一旦离开停车场就会损失很大一部分价值。我们的目标不是找到完美的模型，而是找到一个简单但仍然表现良好的模型。
- en: The first thing we need to do is be able to measure how well a given linear
    function, meaning a given choice of *a* and *b*, predicts the price of a Prius
    from its mileage. To do this, we write a function in Python, called a *cost function*,
    which takes a function *p*(*x*) as input and returns a number telling us how far
    it is from the raw data. For any pair of numbers *a* and *b*, we can then measure
    how well the function *p*(*x*) = *ax* + *b* fits the data set using the cost function.
    There’s one linear function for every pair (*a*, *b*), so we can think of our
    task as exploring the 2D space of such pairs and evaluating the linear function
    they imply.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是能够衡量一个给定的线性函数（即给定*a*和*b*的选择）如何预测普锐斯的价格。为此，我们编写一个Python函数，称为成本函数，它接受一个函数*p*(x)作为输入，并返回一个数字，告诉我们它距离原始数据有多远。对于任何一对数字*a*和*b*，我们都可以使用成本函数来衡量函数*p*(x)
    = *ax* + *b*如何拟合数据集。对于每一对(*a*, *b*)，都有一个线性函数，因此我们可以将我们的任务视为探索这种对对的2D空间，并评估它们所暗示的线性函数。
- en: Figure 14.4 shows that picking positive values of *a* and *b* yield a line,
    sloping upwards. If that were our price function, it would imply that a car gains
    value as it is driven, which is not likely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4显示，选择正的*a*和*b*值会产生一条向上倾斜的线。如果这是我们的价格函数，那么它将意味着汽车在行驶过程中会增值，这不太可能。
- en: '![](../Images/CH14_F04_Orland.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F04_Orland.png)'
- en: Figure 14.4 A pair of numbers (*a, b*) define a linear function that we can
    plot on a graph as a line. For positive values of a, the graph slopes upward.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 一对数字 (*a, b*) 定义了一个线性函数，我们可以在图上作为一条线来绘制。对于 a 的正值，图线向上倾斜。
- en: Our cost function compares a line like this to the actual data and returns a
    big number, indicating that the line is far away from the data. The closer the
    line gets to the data, the lower the cost and the better the fit.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的成本函数将此类线与实际数据进行比较，并返回一个大的数字，表示该线远离数据。线越接近数据，成本越低，拟合度越好。
- en: What we want are values of *a* and *b* that don’t just make the cost function
    small, but that make it the *exact* smallest function possible. The second major
    function we’ll write is called `linear_regression,` and it automatically finds
    these best values of *a* and *b*. This, in turn, tell us the line of best fit.
    To implement this, we build a function telling us the cost for any values of *a*
    and *b* and minimize it using the technique of gradient descent from chapter 12\.
    Let’s get started by implementing a cost function in Python to measure how well
    a function fits a data set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望的是 *a* 和 *b* 的值，不仅使成本函数变小，而且使其成为可能的最小函数。我们将编写的第二个主要函数称为 `linear_regression`，它自动找到这些最佳的
    *a* 和 *b* 值。这反过来又告诉我们最佳拟合线。为了实现这一点，我们构建一个函数，它告诉我们任何 *a* 和 *b* 值的成本，并使用第 12 章中提到的梯度下降技术来最小化它。让我们从在
    Python 中实现一个成本函数来衡量函数与数据集的拟合程度开始。
- en: 14.1 Measuring the quality of fit for a function
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 测量函数拟合质量
- en: We’ll write our cost function so that it can work on any data set, not just
    our collection of used cars. That allows us to test it out on simpler (made-up)
    data sets, so we can see how it works. With that in mind, the cost function is
    a Python function taking two inputs. One of these is the Python function *f*(*x*)
    that we want to test, and the second is the data set to test against, a collection
    of (*x*, *y*) pairs. For the used car example, our *f*(*x*) might be a linear
    function giving a cost in dollars for any mileage, and the (*x*, *y*) pairs are
    the actual values of mileage and price from the data set.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写我们的成本函数，使其能够适用于任何数据集，而不仅仅是我们的二手车集合。这允许我们在更简单（虚构的）数据集上测试它，这样我们就可以看到它是如何工作的。考虑到这一点，成本函数是一个接受两个输入的
    Python 函数。其中一个是我们要测试的 Python 函数 *f*(*x*)，另一个是要测试的数据集，即 (*x*, *y*) 对的集合。对于二手车示例，我们的
    *f*(*x*) 可能是一个线性函数，它为任何里程数提供美元成本，而 (*x*, *y*) 对是数据集中里程和价格的实际值。
- en: 'The output of the cost function is a single number, measuring how far the values
    of *f*(*x*) are from the correct *y* values. If *y* = *f*(*x*), for every *x*,
    the function is a perfect fit for the data, so the cost function returns zero.
    More realistically, the function won’t agree exactly with all the data points,
    and it will return some positive number. We’ll actually write two cost functions
    to compare them and give you a sense of how cost functions work:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 成本函数的输出是一个单一的数字，衡量 *f*(*x*) 的值与正确的 *y* 值之间的距离。如果 *y* = *f*(*x*)，对于每一个 *x*，函数是数据的完美拟合，因此成本函数返回零。更现实的情况是，函数不会与所有数据点完全一致，它将返回一些正数。我们实际上将编写两个成本函数来比较它们，并给你一个成本函数是如何工作的感觉：
- en: '`sum_error` −Adds the distance from *f*(*x*) to *y* for every (*x*, *y*) value
    in the data set'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum_error` − 将数据集中每个 (*x*, *y*) 值的 *f*(*x*) 到 *y* 的距离相加'
- en: '`sum_square_error` −Adds up the squares of these distances'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum_square_error` − 将这些距离的平方相加'
- en: The second of these is the cost function most commonly used in practice, and
    you’ll see why shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中第二个是实践中最常用的成本函数，你很快就会明白原因。
- en: 14.1.1 Measuring distance from a function
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 从函数测量距离
- en: In the source code for this book, you’ll find a made-up data set called `test_data`.
    It’s a Python list of (*x*, *y*) values, where the *x* values range from −1 to
    1\. I’ve intentionally chosen *y* values so that the points lie close to the line
    *f*(*x*) = 2*x*. Figure 14.5 shows a scatter plot of the `test_data` data set
    next to that line.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的源代码中，你可以找到一个名为 `test_data` 的虚构数据集。它是一个 (*x*, *y*) 值的 Python 列表，其中 *x* 值从
    -1 到 1。我故意选择了 *y* 值，使得点靠近线 *f*(*x*) = 2*x*。图 14.5 显示了 `test_data` 数据集的散点图，并显示在那条线旁边。
- en: '![](../Images/CH14_F05_Orland.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F05_Orland.png)'
- en: Figure 14.5 A set of randomly generated data that intentionally stays close
    to the line *f*(*x*) = 2x
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 一组故意靠近线 *f*(*x*) = 2x 的随机生成数据
- en: The fact that *f*(*x*) = 2*x* stays close to the data set means that for any
    *x* value in the data set, 2*x* is a pretty good guess for the corresponding *y*
    value. For instance, the point
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是 *f*(*x*) = 2*x* 与数据集保持接近，意味着对于数据集中的任何 *x* 值，2*x* 是对应 *y* 值的一个相当好的猜测。例如，这个点
- en: (*x*, *y*) = (0.2, 0.427)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*, *y*) = (0.2, 0.427)
- en: is an actual value from the data set. Given only the value *x* = 0.2, our *f*(*x*)
    = 2*x* would have predicted *y* = 0.4\. The absolute value of the difference |*f*(0.2)
    − 0.4| tells us the size of this error, which is about 0.027.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 是数据集中的实际值。仅给定 *x* = 0.2 的值，我们的 *f*(*x*) = 2*x* 会预测 *y* = 0.4。|*f*(0.2) − 0.4|
    的绝对值告诉我们这个误差的大小，大约是 0.027。
- en: An error value, which is the difference between the actual *y* value and the
    one predicted by the function *f*(*x*), can be pictured as the vertical distance
    from the actual (*x*, *y*) point to the graph of *f* . Figure 14.6 shows the error
    distances drawn as vertical lines.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 误差值，即实际 *y* 值与函数 *f*(*x*) 预测的值之间的差异，可以想象为实际 (*x*, *y*) 点到 *f* 图像的垂直距离。图 14.6
    显示了误差距离被绘制为垂直线。
- en: '![](../Images/CH14_F06_Orland.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F06_Orland.png)'
- en: Figure 14.6 The error values are the differences between the function *f*(*x*)
    and the actual y values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 误差值是函数 *f*(*x*) 和实际 y 值之间的差异。
- en: Some of these errors are smaller than others, but how can we quantify the quality
    of the fit? Let’s compare this to a picture of a function, *g*(*x*) = 1 − *x*,
    which is obviously a bad fit (figure 14.7).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些误差中有些比其他的小，但我们如何量化拟合的质量？让我们将此与函数 *g*(*x*) = 1 − *x* 的图像进行比较，它显然是一个不好的拟合（图
    14.7）。
- en: '![](../Images/CH14_F07_Orland.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F07_Orland.png)'
- en: Figure 14.7 Picturing a function with larger error values
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 展示了具有较大误差值的函数
- en: 'Our function, *g*(*x*) = 1 − *x*, happens to come close to one of the points,
    but the total of the errors is much larger. For that reason, we can write our
    first cost function by adding all of the errors. A larger sum of errors means
    a worse fit, while a lower value means a better fit. To implement this function,
    we simply iterate over the (*x*, *y*) pairs, take the absolute value of the difference
    between *f*(*x*) and *y*, and sum the results:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能，*g*(*x*) = 1 − *x*，恰好接近一个点，但误差总和要大得多。因此，我们可以通过添加所有误差来编写我们的第一个成本函数。误差总和越大，拟合越差，而值越低，拟合越好。要实现此功能，我们只需遍历
    (*x*, *y*) 对，取 *f*(*x*) 和 *y* 之间差异的绝对值，并求和结果：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To test this function, we can translate our *f*(*x*) and *g*(*x*) into code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个函数，我们可以将我们的 *f*(*x*) 和 *g*(*x*) 转换为代码：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As expected, the summed error for *f*(*x*) = 2*x* is lower than for *g*(*x*)
    = 1 − *x* :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，*f*(*x*) = 2*x* 的总误差低于 *g*(*x*) = 1 − *x*：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The exact values of these outputs don’t matter; what matters is the comparison
    between them. Because the sum of the error for *f*(*x*) is lower than for *g*(*x*),
    we can conclude that *f*(*x*) is a better fit for the given data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输出的确切值并不重要；重要的是它们之间的比较。因为 *f*(*x*) 的误差总和低于 *g*(*x*)，我们可以得出结论，*f*(*x*) 是给定数据的更好拟合。
- en: 14.1.2 Summing the squares of the errors
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 误差平方和
- en: The `sum_error` function might be the most obvious way to measure the distance
    from the line to the data, but in practice, we’ll use a cost function that sums
    up the *squares* of all the errors. There are a few good reasons for this. The
    simplest is because a squared distance function is smooth, so we can use derivatives
    to minimize it, while an absolute value function is not smooth, so we can’t take
    its derivative everywhere. Keep in mind the pictures of the graphs of functions
    |*x*| and *x*² (figure 14.8), both of which return bigger values when *x* is further
    from 0, but only the latter is smooth at *x* = 0 and has a derivative there.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_error` 函数可能是衡量数据点到直线距离的最明显方式，但在实践中，我们将使用一个求和所有误差平方的成本函数。这样做有几个很好的理由。最简单的是，平方距离函数是光滑的，因此我们可以使用导数来最小化它，而绝对值函数不是光滑的，所以我们不能在所有地方取其导数。记住函数
    |*x*| 和 *x*² 的图像（图 14.8），两者在 *x* 离 0 更远时都返回更大的值，但只有后者在 *x* = 0 处是光滑的，并且在该处有导数。'
- en: '![](../Images/CH14_F08_Orland.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F08_Orland.png)'
- en: Figure 14.8 The graph of *y* = |*x*| is not smooth at *x* = 0, but the graph
    of *y* = *x*² is.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 *y* = |*x*| 的图像在 *x* = 0 处不光滑，但 *y* = *x*² 的图像是光滑的。
- en: 'Given a test function *f*(*x*), we can look at every (*x*, *y*) pair and add
    the value of (*f*(*x*) − *y*)² to the cost. The `sum_squared_error` function does
    this, and its implementation doesn’t look much different than `sum_error`. We
    only need to square the error instead of taking its absolute value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个测试函数*f*(*x*)，我们可以查看每个(*x*, *y*)对，并将(*f*(*x*) − *y*)²的值添加到成本中。`sum_squared_error`函数就是这样做的，它的实现与`sum_error`没有太大区别。我们只需要平方误差而不是取其绝对值：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can also visualize this cost function. Instead of looking at the vertical
    distances between points and the graph of the function, we can think of those
    distances as edges of squares. The area of each square is the squared error for
    that data point, and the total area of all squares is the result of `sum_squared_error`.
    The total area of squares in figure 14.9 shows the sum of the squared error between
    `test_data` and *f*(*x*) = 2*x*. (Note that the squares don’t look like squares
    because the x- and y-axes have different scales!)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以可视化这个成本函数。我们不是通过观察点与函数图像之间的垂直距离来观察这些距离，我们可以将这些距离视为正方形的边缘。每个正方形的面积是该数据点的平方误差，所有正方形的总面积是`sum_squared_error`的结果。图14.9中正方形的总面积显示了`test_data`与*f*(*x*)
    = 2*x*之间的平方误差之和。（注意，由于x轴和y轴有不同的刻度，这些正方形看起来并不像正方形！）
- en: '![](../Images/CH14_F09_Orland.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F09_Orland.png)'
- en: Figure 14.9 Picturing the sum of the squared error between a function and a
    data set
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 展示函数与数据集之间平方误差之和的图像
- en: A *y* value, which is twice as far from the graph in figure 14.9, contributes
    to the sum squared error by a factor of four. One of the reasons to prefer this
    cost function is that it penalizes poor fits more aggressively. For *h*(*x*) =
    3*x*, you can see that the squares are quite a bit bigger (figure 14.10).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9中的*y*值，其距离图中的图形是图14.9的两倍，通过四倍的因子对平方误差总和做出贡献。选择这个成本函数的一个原因是它更严厉地惩罚不良拟合。对于*h*(*x*)
    = 3*x*，你可以看到正方形相当大（图14.10）。
- en: '![](../Images/CH14_F10_Orland.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F10_Orland.png)'
- en: Figure 14.10 Picturing the `sum_squared_error` for h(*x*) = 3*x* relative to
    the test data
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 相对于测试数据展示h(*x*) = 3*x*的`sum_squared_error`
- en: 'It’s not worth drawing the squared errors for *g*(*x*) = 1 − *x* because the
    squares are so big they fill almost the whole chart area and overlap each other
    significantly. You can see, though, that the difference in value of the `sum_squared_error`
    is even more drastic for *f*(*x*) and *g*(*x*) than for the difference in `sum_error`
    :'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*g*(*x*) = 1 − *x*，绘制平方误差是不值得的，因为正方形太大，几乎填满了整个图表区域，并且相互重叠很大。尽管如此，你可以看到，对于*f*(*x*)和*g*(*x*)，`sum_squared_error`的值差异甚至比`sum_error`的差异更剧烈：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The graph of *y* = *x*² in figure 14.8 is clearly smooth, and it turns out that
    if you move the line by varying the parameters *a* and *b* that define it, the
    cost function changes “smoothly” as well. For this reason, we’ll continue using
    the `sum_squared_error` cost function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8中的*y* = *x*²的图像非常平滑，而且如果你通过改变定义它的参数*a*和*b*来移动这条线，成本函数也会“平滑”地改变。因此，我们将继续使用`sum_squared_error`成本函数。
- en: 14.1.3 Calculating cost for car price functions
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 计算汽车价格函数的成本
- en: 'I’ll start by making an educated guess about how Priuses depreciate as they
    gain mileage. There are several different models of Toyota Priuses, but I would
    guess the average retail price is about $25,000\. To make the calculation simple,
    our first, naïve model assumes they stay on the road for 125,000 miles, after
    which they are worth exactly $0\. That means that the cars depreciate at an average
    rate of $0.20 per mile. That implies the price *p* of a Prius in terms of its
    mileage *x* is given by subtracting 0.2*x* dollars of depreciation from the starting
    price of $25,000, and this means *p*(*x*) is a linear function because it has
    the familiar form, *p*(*x*) = *ax* + *b*, with *a* = −0.2 and *b* = 25,000:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先对普锐斯随着行驶里程的增加而贬值的情况进行一个有根据的猜测。丰田普锐斯有多种不同的型号，但我猜测平均零售价格约为$25,000。为了简化计算，我们的第一个、直观的模型假设它们在行驶了125,000英里后仍保持在道路上，之后它们的市值正好为$0。这意味着汽车的平均折旧率为每英里$0.20。这意味着以里程*x*为条件的普锐斯价格*p*可以通过从起始价格$25,000中减去0.2*x*美元的折旧来计算，这意味着*p*(*x*)是一个线性函数，因为它具有熟悉的形式，*p*(*x*)
    = *ax* + *b*，其中*a* = −0.2和*b* = 25,000：
- en: '*p*(*x*) = −0.2*x* + 25,000'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*x*) = −0.2*x* + 25,000'
- en: Let’s see how this function looks on the graph by plotting it next to the CarGraph
    data (figure 14.11). You can find the data and the Python code to plot it in the
    source code for this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将其与CarGraph数据（图14.11）并排放置来查看这个函数在图上的样子。你可以在本章的源代码中找到这些数据和绘制它的Python代码。
- en: '![](../Images/CH14_F11_Orland.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F11_Orland.png)'
- en: Figure 14.11 The scatter plot of price and mileage for used Priuses with my
    hypothetical depreciation function
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 使用我假设的折旧函数的二手普锐斯价格与里程的散点图
- en: 'Clearly, many of the cars in the data set have made it past my guess of 125,000
    miles. That can mean that my guess of the depreciation rate was too high. Let’s
    try a depreciation rate of $0.10 per mile, implying a pricing function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，数据集中许多汽车已经超过了我对125,000英里的猜测。这意味着我对折旧率的猜测可能太高了。让我们尝试每英里0.10美元的折旧率，这意味着定价函数：
- en: '*p*(*x*) = −0.10*x* + 25,000'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*x*) = −0.10*x* + 25,000'
- en: This isn’t perfect either. We can see on the graph in figure 14.12 that this
    function overestimates the price of the majority of the cars.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是完美的。我们可以从图14.12中的图表中看到，这个函数高估了大多数汽车的价格。
- en: '![](../Images/CH14_F12_Orland.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F12_Orland.png)'
- en: Figure 14.12 Plotting a different function that assumes a depreciation of $0.10
    per mile
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 绘制一个假设每英里折旧$0.10的不同函数
- en: We can also experiment with the starting value, which we’ve assumed is $25,000\.
    Anecdotally, a car loses much of its value the moment it drives off the lot, so
    a price of $25,000 might be an overestimation for a used car with very few miles
    on it. If the car loses 10% of its value when it drives off the lot, a price of
    $22,500 at zero mileage might give us better results (figure 14.13).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实验起始值，我们假设它是$25,000。根据经验，一辆车一旦离开停车场就会失去很大一部分价值，所以对于行驶里程很少的二手车来说，$25,000可能是一个高估。如果一辆车在离开停车场时价值下降了10%，那么零里程时的$22,500可能给我们更好的结果（图14.13）。
- en: '![](../Images/CH14_F13_Orland.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F13_Orland.png)'
- en: Figure 14.13 Testing a starting value of $22,500 for used Toyota Priuses
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 测试二手丰田普锐斯的起始价值 $22,500
- en: 'We can spend a lot of time speculating about what the best linear function
    is to fit the data, but to see if our speculations are improving, we need to use
    a cost function. Using the `sum_squared_error` function, we can measure which
    of our educated guesses is the closest to the data. Here are three pricing functions
    translated to Python code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花很多时间猜测最适合数据的最佳线性函数，但要看看我们的猜测是否在改进，我们需要使用成本函数。使用`sum_squared_error`函数，我们可以衡量我们的有根据的猜测哪一个最接近数据。以下是三个定价函数转换为Python代码：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `sum_squared_error` function takes a function as well as a list of pairs
    of numbers representing the data. In this case, we want pairs of mileages and
    prices:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_squared_error`函数接受一个函数以及代表数据的数字对列表。在这种情况下，我们想要里程和价格的对：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the `sum_squared_error` function for each of the three pricing functions,
    we can compare their quality of fit to the data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sum_squared_error`函数对三个定价函数中的每一个进行计算，我们可以比较它们与数据的拟合质量：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These are some big values, roughly 88.7 billion, 34.7 billion, and 22.9 billion,
    respectively. Once again, the values don’t matter, only their relative sizes.
    Because the last one is the lowest, we can conclude that `p3` is the best of the
    three pricing functions. Given how unscientific I was when making up these functions,
    it seems likely I could keep guessing and find a linear function making the cost
    even lower. Rather than guessing and checking, we’ll look at how to explore the
    space of possible linear functions systematically.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些很大的数值，分别是大约8870亿、3470亿和2290亿。再次强调，数值本身并不重要，重要的是它们的相对大小。因为最后一个数值最低，我们可以得出结论，`p3`是三个定价函数中最好的。考虑到我在构造这些函数时是多么的不科学，我似乎可以继续猜测并找到一个使成本更低的线性函数。与其猜测和检查，我们将探讨如何系统地探索可能的线性函数空间。
- en: 14.1.4 Exercises
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 练习
- en: '| **Exercise 14.1**: Create a set of data points lying on a line and demonstrate
    that the `sum_error` and `sum_squared_error` cost functions both return exactly
    zero for the appropriate linear function.**Solution**: Here is a linear function
    and some points that lie on its graph:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习14.1**：创建一组位于直线上的数据点，并证明`sum_error`和`sum_squared_error`成本函数对于适当的线性函数都返回正好为零。**解答**：这是一个线性函数和一些位于其图形上的点：'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/CH14_F13_Orland_UN01.png)Both `sum_error(line,points)` and `sum_squared_error(line,points)`
    return zero because there is no distance from any of the points to the line. |'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/CH14_F13_Orland_UN01.png)Both `sum_error(line,points)` and `sum_squared_error(line,points)`返回零，因为没有任何一个点到直线的距离。|'
- en: '| **Exercise 14.2**: Calculate the value of the cost for the two linear functions,
    *x* + 0.5 and 2*x* − 1\. Which one produces a lower sum squared error relative
    to `test_data`, and what does that say about the quality of the fits?**Solution**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 14.2**：计算两个线性函数，*x* + 0.5 和 2*x* − 1 的成本值。哪一个相对于 `test_data` 产生更低的平方和误差，这说明了拟合质量如何？**解答**：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function *x* + 0.5 produces a lower value for `sum_squared_error`, so it
    is a better fit to the `test_data`. |
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *x* + 0.5 产生的 `sum_squared_error` 值更低，因此它更适合 `test_data`。|
- en: '| **Exercise 14.3**: Find a linear function `p4` that fits the data even better
    than `p1`, `p2`, or `p3`. Demonstrate that it is a better fit by showing the cost
    function is lower than for `p1`, `p2`, or `p3`.**Solution**: The best fit we found
    so far is `p3`, represented by *p*(*x*) = 22,500 − 0.1 · *x*. To get an even better
    fit, you can try tweaking the constants in this formula until the cost is reduced.
    One observation that you might make is that `p3` was a better fit because we reduced
    the *b* value from 25,000 to 22,500\. If we reduce it slightly further, the fit
    gets even better. If we define a new function `p4` with a *b* value of 20,000'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 14.3**：找到一个比 `p1`、`p2` 或 `p3` 更好的线性函数 `p4`。通过显示成本函数比 `p1`、`p2` 或 `p3`
    更低来证明它是更好的拟合。**解答**：我们迄今为止找到的最佳拟合是 `p3`，表示为 *p*(*x*) = 22,500 − 0.1 · *x*。为了得到更好的拟合，你可以尝试调整这个公式中的常数，直到成本降低。你可能观察到
    `p3` 是更好的拟合，因为我们把 *b* 值从 25,000 降低到 22,500。如果我们进一步降低它，拟合会更好。如果我们定义一个新的函数 `p4`，其
    *b* 值为 20,000'
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'it turns out the `sum_squared_error` is even lower:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明 `sum_squared_error` 甚至更低：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is lower than the values for any of the three previous functions, demonstrating
    that it is a better fit to the data. |
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这比前三个函数的值都要低，表明它更适合数据。|
- en: 14.2 Exploring spaces of functions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 探索函数空间
- en: We ended the last section by guessing some pricing functions of the form *p*(*x*)
    = *ax* + *b*, where *x* represents the mileage on a used Toyota Prius and *p*
    is a prediction of its price. By choosing different values of *a* and *b* and
    graphing the resulting function, *p*(*x*), we could tell which choices were better
    than others. The cost function gave us a way of measuring how close the functions
    came to the data, rather than eyeballing it. Our goal in this section is to systematize
    the process of trying different values of *a* and *b* to make the cost function
    as small as possible.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个部分通过猜测一些定价函数的形式 *p*(*x*) = *ax* + *b* 结束，其中 *x* 代表二手丰田普锐斯的里程数，而 *p* 是其价格的预测。通过选择不同的
    *a* 和 *b* 值并绘制结果函数 *p*(*x*)，我们可以判断哪些选择比其他选择更好。成本函数为我们提供了一种衡量函数接近数据程度的方法，而不是仅仅凭肉眼判断。本节的目标是系统地尝试不同的
    *a* 和 *b* 值，以使成本函数尽可能小。
- en: If you did the last exercise from section 14.1 and searched manually for a better
    fit, you might have noticed that part of the challenge is tuning *both* *a* and
    *b* simultaneously. If you remember from chapter 6, the collection of all functions
    like *p*(*x*) = *ax* + *b* form a 2D vector space. When you guess and check, you’re
    blindly picking points in various directions in this 2D space and hoping the cost
    function decreases.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了 14.1 节的最后一个练习并手动搜索更好的拟合，你可能已经注意到挑战的一部分是同时调整 *a* 和 *b*。如果你还记得第 6 章，所有像
    *p*(*x*) = *ax* + *b* 这样的函数构成一个 2D 向量空间。当你猜测和检查时，你在这个 2D 空间中盲目地选择各个方向上的点，并希望成本函数降低。
- en: In this section, we’ll try to understand the 2D space of possible linear functions
    by graphing the `sum_squared_error` cost function with respect to the parameters
    *a* and *b*, which define a linear function. Specifically, we can plot the cost
    as a function of the two parameters *a* and *b*, which define a choice of *p*(*x*)
    (figure 14.14).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过绘制关于参数 *a* 和 *b* 的 `sum_squared_error` 成本函数图来尝试理解可能的线性函数的 2D 空间。具体来说，我们可以绘制成本作为两个参数
    *a* 和 *b* 的函数，这两个参数定义了 *p*(*x*) 的选择（图 14.14）。
- en: The actual function we’ll plot takes two numbers, *a* and *b*, and returns one
    number, which is the cost of the function *p*(*x*) = *ax* + *b*. We call this
    function `coefficient_cost(a,b)` because the numbers *a* and *b* are *coefficients*.
    To plot such a function, we use a heatmap like we did in chapter 12.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要绘制的实际函数接受两个数字，*a* 和 *b*，并返回一个数字，即函数 *p*(*x*) = *ax* + *b* 的成本。我们称这个函数为 `coefficient_cost(a,b)`，因为数字
    *a* 和 *b* 是 *系数*。为了绘制这样的函数，我们使用类似于第 12 章中的热图。
- en: '![](../Images/CH14_F14_Orland.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F14_Orland.png)'
- en: Figure 14.14 A pair of numbers, (*a, b*), define a linear function. Comparing
    it to the fixed actual data produces the cost as a single number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 显示了一对数字 (*a, b*) 定义了一个线性函数。将其与固定实际数据比较，产生一个单一的成本数值。
- en: '![](../Images/CH14_F15_Orland.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F15_Orland.png)'
- en: Figure 14.15 Costs for various values of the slope a and the lines represented
    by each
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 不同斜率 *a* 值的线和对应的成本
- en: 'As a warm up, we can try to fit a function *f*(*x*) = *ax* to the `test_data`
    data set we used before. This is a simpler problem because `test_data` doesn’t
    have as many data points, and because we’ve only got one parameter to tune: *f*(*x*)
    = *ax* is a linear function with the value of *b* fixed at zero. The graph of
    a function of this form is a line through the origin and the coefficient *a* controls
    its slope. That means that there’s only one dimension to explore, and we can plot
    the value of the sum squared error versus the value of *a*, which is an ordinary
    function graph.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为热身，我们可以尝试将函数 *f*(*x*) = *ax* 拟合到之前使用的 `test_data` 数据集。这是一个更简单的问题，因为 `test_data`
    没有那么多数据点，而且我们只有一个参数需要调整：*f*(*x*) = *ax* 是一个线性函数，其 *b* 的值固定为零。这种形式函数的图表是通过原点的一条线，系数
    *a* 控制其斜率。这意味着只有一个维度需要探索，我们可以绘制平方和误差值与 *a* 值的普通函数图。
- en: 14.2.1 Picturing cost for lines through the origin
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 通过原点的线的成本图示
- en: 'Let’s use the same `test_data` data set as before and compute the `sum_squared
    _error` from functions of the form *f*(*x*) = *ax*. We can then write a function
    `test_data _coefficient_cost`, taking the parameter *a*(the slope) and returning
    the cost for *f*(*x*) = *ax*. To do this, we first create the function *f* from
    the value of the input *a* and then we can pass it and the test data into the
    `sum_squared_error` cost function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前相同的 `test_data` 数据集，并从形式为 *f*(*x*) = *ax* 的函数中计算 `sum_squared_error`。然后我们可以编写一个函数
    `test_data_coefficient_cost`，它接受参数 *a*（斜率）并返回 *f*(*x*) = *ax* 的成本。为此，我们首先从输入 *a*
    的值创建函数 *f*，然后我们可以将其和测试数据传递给 `sum_squared_error` 成本函数：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each value of this function corresponds to a choice of the slope, *a*, and,
    therefore, tells us the cost of a line we could plot alongside `test_data`. Figure
    14.15 shows a scatter plot of a few values of *a* and their corresponding lines.
    I’ve drawn attention to the slope of *a* = −1, which produces the highest cost
    and the line with the worst fit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的每个值对应于斜率 *a* 的一个选择，因此，它告诉我们可以绘制在 `test_data` 旁边的线的成本。图 14.15 展示了几个 *a*
    值及其对应线的散点图。我特别指出了斜率为 *a* = −1 的情况，这会产生最高的成本和最差的拟合线。
- en: The `test_data_coefficient_cost` function turns out to be a smooth function
    that we can plot over a range of *a* values. The graph in figure 14.16 shows us
    that the cost gets lower and lower until it hits a minimum around *a* = 2 and
    then it starts increasing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_data_coefficient_cost` 函数最终证明是一个平滑的函数，我们可以在一系列 *a* 值的范围内绘制它。图 14.16 显示，成本逐渐降低，直到在
    *a* ≈ 2 处达到最小值，然后开始增加。'
- en: '![](../Images/CH14_F16_Orland.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F16_Orland.png)'
- en: Figure 14.16 A graph of cost vs. the slope a, showing the quality of fit for
    different slope values
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16 成本与斜率 *a* 的图表，显示了不同斜率值的拟合质量
- en: The graph in figure 14.16 tells us the line through the origin producing the
    lowest cost and, therefore, the *best fit*, which has roughly a slope of 2 (we’ll
    find the exact value shortly). To find the best linear function fitting the used
    car data, let’s look at the cost over a space with one more dimension.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16 中的图表告诉我们，通过原点产生的成本最低的线，因此，是 *最佳拟合*，其斜率大约为 2（我们很快就会找到确切值）。为了找到最佳线性函数来拟合二手车数据，让我们看看在一个多一个维度的空间上的成本。
- en: 14.2.2 The space of all linear functions
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 所有线性函数的空间
- en: 'We’re looking for a function *p*(*x*) = *ax* + *b* that comes closest to predicting
    the price of a Prius based on its mileage as measured by the `sum_squared_error`
    function. To evaluate different choices of the coefficients *a* and *b*, we need
    to first write a function `coefficient_cost(a,b)` that gives the sum squared error
    for *p*(*x*) = *ax* + *b* relative to the car data. This looks like the `test_data_coefficient_cost`
    function, except there are two parameters and we use a different data set:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找一个函数 *p*(*x*) = *ax* + *b*，它通过 `sum_squared_error` 函数最接近地预测普锐斯的售价。为了评估系数
    *a* 和 *b* 的不同选择，我们首先需要编写一个函数 `coefficient_cost(a,b)`，它给出 *p*(*x*) = *ax* + *b*
    相对于汽车数据的平方和误差。这看起来像 `test_data_coefficient_cost` 函数，除了有两个参数，我们使用不同的数据集：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, there’s a 2D space of pairs of coefficients (*a*, *b*), any of which gives
    us a different candidate function *p*(*x*) to compare with the price data. Figure
    14.17 shows two points in the *a*, *b* plane and the corresponding lines on the
    graph.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个二维空间，包含系数对 (*a*, *b*) 的组合，其中任何一个都能给我们一个不同的候选函数 *p*(*x*) 来与价格数据进行比较。图14.17显示了
    *a*, *b* 平面上的两个点以及相应的图形上的线条。
- en: '![](../Images/CH14_F17_Orland.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F17_Orland.png)'
- en: Figure 14.17 Different pairs of numbers (*a, b*) correspond to different price
    functions
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 不同的 (*a, b*) 数字对对应不同的价格函数
- en: For every pair (*a*, *b*) and corresponding function *p*(*x*) = *ax* + *b*,
    we can compute the `sum_squared _error` function; that’s what the `coefficient_cost`
    function does for us in one step. This gives us a cost value for every point in
    the *a*, *b* plane that we can plot as a heat map (figure 14.18).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一对 (*a*, *b*) 和相应的函数 *p*(*x*) = *ax* + *b*，我们可以计算 `sum_squared_error` 函数；这正是
    `coefficient_cost` 函数为我们一步完成的事情。这为我们提供了 *a*, *b* 平面上每个点的成本值，我们可以将其绘制为热图（图14.18）。
- en: '![](../Images/CH14_F18_Orland.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F18_Orland.png)'
- en: Figure 14.18 Cost for the linear function as a heatmap over values of a and
    b
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 线性函数的成本作为 a 和 b 值的热图
- en: On this heatmap, you can see that when (*a*, *b*) are at their extremes, the
    cost function is high. The heatmap is darkest in the middle, but it’s not visually
    clear whether there’s a minimum value for the cost or exactly where it occurs.
    Fortunately, we have a method for finding where in the (*a*, *b*) plane the cost
    function is minimized−gradient descent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个热图中，你可以看到当 (*a*, *b*) 处于极端时，成本函数较高。热图在中间部分最暗，但视觉上并不清楚成本是否有最小值或确切的位置。幸运的是，我们有一种方法可以找到在
    (*a*, *b*) 平面上成本函数最小化的位置−梯度下降。
- en: 14.2.3 Exercises
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 练习
- en: '| **Exercise 14.4**: Find the exact formula for a line through the origin that
    passes through one point (3, 4). Do this by finding the function *f*(*x*) = *ax*,
    which minimizes the sum squared error relative to this one-point data set.**Solution**:
    There is one coefficient we need to find, which is *a*. The sum of squared error
    is the squared difference between *f*(3) = *a* · 3 and 4\. This is (3 *a* − 4)²,
    which expands to 9 *a*² − 24 *a* + 16\. We can think of this as a cost function
    in terms of *a*, that is, *c*(*a)* = 9 *a*² − 24 *a* + 16.The best value of *a*
    is the one that minimizes this cost. That value of *a* causes the derivative of
    the cost function to be zero. Using the derivative rules from chapter 10, we find
    *c*''(*a*) = 18 *a* − 24\. This is solved when *a* = 4/3, meaning our line of
    best fit is![](../Images/CH14_F18_Orland_EQ01.png)This clearly contains the origin
    and the point (4, 3). |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **练习14.4**：找到通过原点并通过一点 (3, 4) 的直线的确切公式。通过找到函数 *f*(*x*) = *ax*，该函数相对于这个一点数据集最小化平方误差。**解答**：我们需要找到一个系数，即
    *a*。平方误差之和是 *f*(3) = *a* · 3 和 4 之间的平方差。这是 (3 *a* − 4)²，展开为 9 *a*² − 24 *a* +
    16。我们可以将其视为关于 *a* 的成本函数，即 *c*(*a)* = 9 *a*² − 24 *a* + 16。*a* 的最佳值是使成本函数的导数为零的值。使用第10章中的导数规则，我们找到
    *c*''(*a*) = 18 *a* − 24。当 *a* = 4/3 时，这被解决，这意味着我们的最佳拟合线是![](../Images/CH14_F18_Orland_EQ01.png)。这显然包含原点和点
    (4, 3)。|'
- en: '| **Exercise 14.5**: Suppose we use a linear function to model the price of
    a sports car with respect to its mileage with coefficients (*a*, *b*) = (−0.4,
    80000). In English, what does that say about how the car depreciates over time?**Solution**:
    The value of *ax* + *b* when *x* = 0 is just *b* = 80,000\. That means that at
    a mileage of 0, we can expect the car to sell for $80,000\. The value *a* of −0.4
    means that the function value *ax* + *b* decreases at a rate of 0.4 units for
    every one unit increase in *x*. That means that the car’s value decreases, on
    average, by 40 cents for every one mile it is driven. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **练习14.5**：假设我们使用线性函数来模拟跑车与其里程数的关系，系数为 (*a*, *b*) = (−0.4, 80000)。用英语来说，这说明了汽车随时间贬值的情况？**解答**：当
    *x* = 0 时，*ax* + *b* 的值只是 *b* = 80,000。这意味着在里程数为0时，我们预计汽车可以卖80,000美元。*a* 的值为 −0.4
    表示，对于 *x* 的每增加一个单位，函数值 *ax* + *b* 会以0.4个单位的速率减少。这意味着汽车的价值平均每行驶一英里就会减少40美分。|'
- en: 14.3 Finding the line of best fit using gradient descent
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 使用梯度下降法找到最佳拟合线
- en: In chapter 12, we used the gradient descent algorithm to minimize a smooth function
    of the form *f*(*x*, *y*). In simpler terms, that meant finding the values of
    *x* and *y* that made the value of *f*(*x, y*) as small as possible. Because we
    have a `gradient_descent` function implemented, we can simply pass it a Python
    version of a function we want to minimize, and it automatically finds the inputs
    that minimize it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12章中，我们使用了梯度下降算法来最小化形式为 *f*(*x*, *y*) 的光滑函数。用更简单的话说，这意味着找到 *x* 和 *y* 的值，使得
    *f*(*x, y*) 的值尽可能小。因为我们已经实现了 `gradient_descent` 函数，所以我们可以简单地将我们想要最小化的函数的 Python
    版本传递给它，它将自动找到最小化它的输入。
- en: Now, we want to find the values of *a* and *b* that make the cost of *p*(*x*)
    = *ax* + *b* as small as possible, in other words, minimizing the Python function
    `coefficient _cost(a,b)`. When we plug `coefficient_cost` into our `gradient_descent`
    function, we get back the pair (*a*, *b*) such that *p*(*x*) = *ax* + *b* is the
    line of best fit. We can use the values of *a* and *b* that we find to plot the
    line *ax* + *b* and visually confirm that it’s a good fit to the data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要找到 *a* 和 *b* 的值，使得 *p*(*x*) = *ax* + *b* 的成本尽可能小，换句话说，最小化 Python 函数 `coefficient
    _cost(a,b)`。当我们把 `coefficient_cost` 插入到我们的 `gradient_descent` 函数中时，我们得到 (*a*,
    *b*) 这一对值，使得 *p*(*x*) = *ax* + *b* 是最佳拟合线。我们可以使用我们找到的 *a* 和 *b* 的值来绘制 *ax* + *b*
    的线，并直观地确认它很好地拟合了数据。
- en: 14.3.1 Rescaling the data
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 数据重缩放
- en: 'There’s one last tricky detail we need to deal with before applying gradient
    descent. The numbers we’ve been working with have drastically different sizes:
    the depreciation rates are between 0 and −1, the prices are in the tens of thousands,
    and the cost function returned results in the hundreds of billions. If we don’t
    specify otherwise, our derivative approximation is taken using a `dx` value of
    10^(−6). Because these numbers differ so greatly in magnitude, we can run into
    numerical errors if we try to run the gradient descent as is.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用梯度下降之前，我们还需要处理一个棘手的细节。我们一直在处理的数据有不同的规模：折旧率在 0 和 -1 之间，价格在数万之间，成本函数返回的结果在数千亿。如果我们不指定其他，我们的导数近似将使用
    10^(-6) 的 `dx` 值。因为这些数字的量级差异很大，如果我们尝试以这种方式运行梯度下降，我们可能会遇到数值错误。
- en: Note I won’t go into the details of the numerical issues that come up; my goal
    is to show you how to apply the math concepts, not to write robust numerical code.
    Instead, I’ll just show you how to get around this issue by reshaping the data
    we’re using.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我不会深入探讨出现的数值问题的细节；我的目标是向您展示如何应用数学概念，而不是编写健壮的数值代码。相反，我将只向您展示如何通过重塑我们使用的数据来解决这个问题。
- en: Based on our intuition about the data set, we can figure out some conservative
    bounds on the values of *a* and *b*, producing the line of best fit. The value
    *a* represents the depreciation, so the best value probably has a magnitude greater
    than 0.5 or 50 cents per mile. The *b* value represents the price of a Prius with
    zero miles on it and should be safely below $50,000.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对数据集的直觉，我们可以确定 *a* 和 *b* 的某些保守界限，从而产生最佳拟合线。*a* 的值代表折旧，所以最佳值可能大于 0.5 或每英里
    50 美分。*b* 的值代表零里程的普锐斯车的价格，应该安全地低于 50,000 美元。
- en: 'If we define new variables *c* and *d* by *a* = 0.5 · *c* and *b* = 50,000
    · *d*, then when *c* and *d* have a magnitude less than one, *a* and *b* should
    have a magnitude less than 0.5 and 50,000, respectively. For values of *a* and
    *b* smaller than these values, the cost function goes no higher than 10^(13).
    If we divide the cost function result by 10^(13) and express it in terms of *c*
    and *d*, we have a new version of the cost function whose inputs and outputs all
    have absolute value between zero and one:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过 *a* = 0.5 · *c* 和 *b* = 50,000 · *d* 定义新的变量 *c* 和 *d*，那么当 *c* 和 *d* 的大小小于
    1 时，*a* 和 *b* 应该分别小于 0.5 和 50,000。对于小于这些值的 *a* 和 *b* 的值，成本函数不会超过 10^(13)。如果我们把成本函数的结果除以
    10^(13) 并用 *c* 和 *d* 表示，我们就得到了一个新的成本函数版本，其输入和输出所有绝对值都在零和一之间：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we find the values of *c* and *d* that minimize this scaled cost function,
    we can find the *a* and *b* values minimizing the original function, using the
    facts that *a* = 0.5 · *c* and *b* = 50,000 · *d*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到最小化这个缩放成本函数的 *c* 和 *d* 的值，我们可以找到最小化原始函数的 *a* 和 *b* 的值，使用的事实是 *a* = 0.5
    · *c* 和 *b* = 50,000 · *d*。
- en: This is a somewhat back-of-the-envelope approach, and there are more scientific
    ways to scale data to make it more numerically mangeable, one of which we’ll see
    in chapter 15\. If you want to learn more, the usual process is called *feature
    scaling* in machine learning literature. For now, we’ve got what we need−a function
    we can plug into the gradient descent algorithm.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当简化的方法，还有更多科学的方法可以缩放数据，使其更易于数值处理，其中之一我们将在第15章中看到。如果您想了解更多，通常在机器学习文献中称为
    *特征缩放* 的过程。现在，我们已经得到了我们需要的−一个可以插入梯度下降算法的函数。
- en: 14.3.2 Finding and plotting the line of best fit
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 寻找和绘制最佳拟合线
- en: 'The function we’re going to optimize is `scaled_cost_function`, and we can
    expect the minimum to occur at a point (*c*, *d*), where |*c*| < 1 and |*d*| <
    1\. Because the optimal *c* and *d* are reasonably close to the origin, we can
    start the gradient descent at (0,0). The following code finds the minimum, although
    it may take a while to run, depending on what kind of machine you’re using:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要优化的函数是 `scaled_cost_function`，我们可以预期最小值出现在一个点 (*c*, *d*)，其中 |*c*| < 1 和
    |*d*| < 1。因为最优的 *c* 和 *d* 与原点相当接近，我们可以从 (0,0) 开始梯度下降。以下代码找到最小值，但具体运行时间取决于您使用的机器类型：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When it runs, it finds the following values for *c* and *d* :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，它会找到以下 *c* 和 *d* 的值：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To recover *a* and *b*, we need to multiply by the respective factors:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复 *a* 和 *b*，我们需要乘以相应的系数：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And, at last, we have our coefficients that we’ve been looking for! Rounding,
    we can say that the price function
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们找到了我们一直在寻找的系数！四舍五入后，我们可以说价格函数
- en: '*p*(*x*) = −0.0606 · *x* + 15,700'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*x*) = −0.0606 · *x* + 15,700'
- en: is the linear function that (approximately) minimizes the sum squared error
    over the whole data set of cars. It implies that the price of a Toyota Prius with
    zero miles on it is, on average, $15,700, and that Priuses depreciate at an average
    rate of just over 6 cents per mile. Figure 14.19 shows what the line looks like
    on a graph.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是（近似地）在整个汽车数据集上最小化平方误差的线性函数。它意味着一辆零里程的丰田普锐斯的价格平均为 15,700 美元，普锐斯的价格平均贬值率略超过每英里
    6 美分。图 14.19 显示了这条线在图上的样子。
- en: '![](../Images/CH14_F19_Orland.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH14_F19_Orland.png)'
- en: Figure 14.19 The line of best fit for the car price data
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19 汽车价格数据的最佳拟合线
- en: 'This looks at least as good as the other linear functions *p*[1](*x*), *p*[2](*x*),
    and *p*[3](*x*) that we tried, if not better. We can be sure that it’s a better
    fit to our data as measured by the cost function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来至少与其他我们尝试过的线性函数 *p*[1](*x*), *p*[2](*x*), 和 *p*[3](*x*) 一样好，如果不是更好。我们可以确信，根据成本函数衡量，它对我们的数据拟合得更好：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Having automatically found a line of best fit that minimizes the cost function,
    we can say that our algorithm “learned” how to value Priuses based on their mileage,
    and we achieved the main goal of this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 自动找到最佳拟合线，最小化成本函数后，我们可以说我们的算法“学会了”如何根据里程来评估普锐斯，我们实现了本章的主要目标。
- en: There are a number of ways to compute linear regression to get this line of
    best fit, including a number of optimized Python libraries. Regardless of the
    methodology, they should get you to the same linear function that minimizes the
    sum of the squared error. I picked this specific methodology using gradient descent,
    both because it is a great application of a number of concepts we covered in part
    1 and part 2, and also because it is highly generalizable. In the last section,
    I’ll show you one more application of gradient descent for regression, and we’ll
    make use of gradient descent and regression in the next two chapters as well.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以计算线性回归以获得最佳拟合线，包括许多优化的 Python 库。无论采用哪种方法，它们都应该得到相同的线性函数，该函数最小化平方误差之和。我选择使用梯度下降法来采用这种方法，这不仅是因为它是我们在第1部分和第2部分中覆盖的许多概念的出色应用，而且还因为它具有高度的可推广性。在最后一节中，我将向您展示梯度下降法在回归中的另一个应用，我们将在接下来的两个章节中也会使用梯度下降法和回归。
- en: 14.3.3 Exercises
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 练习
- en: '| **Exercise 14.6**: Use gradient descent to find the linear function that
    best fits the test data. Your resulting function should be close to 2*x* + 0,
    but not exactly, because the data was randomly generated around that line.**Solution**:
    First, we need to write a function that computes the cost of *f*(*x*) = *ax* +
    *b* relative to the test data in terms of the coefficients *a* and *b* :'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 14.6**: 使用梯度下降法找到最佳拟合测试数据的线性函数。您得到的结果函数应该接近 2*x* + 0，但不是完全一样，因为数据是围绕该线随机生成的。**解答**:
    首先，我们需要编写一个函数来计算 *f*(*x*) = *ax* + *b* 相对于测试数据中系数 *a* 和 *b* 的成本：'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The values of *a* and *b* that minimize this function give us the linear function
    of best fit. We expect *a* and *b* to be close to 2 and 0, respectively, so we
    can plot a heat map around those points to understand the function we’re minimizing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个函数最小化的 *a* 和 *b* 的值给我们提供了最佳拟合的线性函数。我们预计 *a* 和 *b* 分别接近 2 和 0，因此我们可以围绕这些点绘制一个热图来理解我们正在最小化的函数：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../Images/CH14_F19_Orland_UN02.png)The cost of *ax* + *b* relative to the
    test data as a function of *a* and *b* |'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH14_F19_Orland_UN02.png)相对于测试数据，*ax* + *b* 的成本作为 *a* 和 *b*
    的函数 |'
- en: '| It looks like there’s a minimum to this cost function in the vicinity of
    (*a*, *b*) = (2,0), as expected. Using gradient descent to minimize this function,
    we can find the exact values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '| 如预期，在 (*a*, *b*) = (2,0) 附近，这个成本函数似乎有一个最小值。使用梯度下降法最小化这个函数，我们可以找到确切的值：'
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means the line of best fit to the test data is approximately 2.10372 ·
    *x* + 0.00212. |
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最佳拟合线到测试数据的大致方程是 2.10372 · *x* + 0.00212。 |
- en: 14.4 Fitting a nonlinear function
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 拟合非线性函数
- en: In the work we’ve done so far, there was no step that *required* the price function
    *p*(*x*) to be linear. A linear function was a good choice because it was simple,
    but we can apply the same method with any function of one variable defined by
    two constants. As an example, let’s find the exponential function of best fit
    having the form *p*(*x*) = *qe^(rx)* and minimizing the sum of the squared error
    relative to the car data. In this equation, *e* is the special constant 2.71828 . . .,
    and we’ll find the values of *q* and *r* that give us the best fit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止所做的工作中，没有一步是 *需要* 价格函数 *p*(*x*) 为线性的。线性函数是一个好的选择，因为它简单，但我们可以用任何由两个常数定义的单变量函数应用相同的方法。作为一个例子，让我们找到形式为
    *p*(*x*) = *qe^(rx)* 的最佳拟合指数函数，并最小化相对于汽车数据的平方误差之和。在这个方程中，*e* 是特殊的常数 2.71828……，我们将找到
    *q* 和 *r* 的值，以给出最佳拟合。
- en: 14.4.1 Understanding the behavior of exponential functions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.1 理解指数函数的行为
- en: In case it’s been a while since you’ve worked with exponential functions, let’s
    do a quick review of how they work. You can recognize a function *f*(*x*) as exponential
    when the argument *x* is in an exponent. For instance, *f*(*x*) = 2*x* is an exponential
    function, while *f*(*x*) = *x*² is not. In fact, *f*(*x*) = 2*x* is one of the
    most familiar exponential functions. The value of 2*x* at each whole number of
    *x* is 2 multiplied by itself *x* times. Table 14.1 gives us some values of 2*x*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一段时间没有处理指数函数了，让我们快速回顾一下它们是如何工作的。你可以通过当自变量 *x* 在指数中时，识别一个函数 *f*(*x*) 为指数函数。例如，*f*(*x*)
    = 2*x* 是一个指数函数，而 *f*(*x*) = *x*² 则不是。实际上，*f*(*x*) = 2*x* 是最熟悉的指数函数之一。在 *x* 的每个整数处，2*x*
    的值是 2 乘以自身 *x* 次。表 14.1 给出了 2*x* 的一些值。
- en: Table 14.1 Values of the familiar exponential function 2x
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1 熟悉的指数函数 2x 的值
- en: '| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| 2x | 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 2x | 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 |'
- en: The number raised to the *x* power is called the *base*, so in the case of 2*x*,
    the base is 2\. If the base is greater than one, the function increases as *x*
    increases, but if it is less than one, it decreases as *x* increases. For instance,
    in (½)*x*, each whole number value is half the previous as shown in table 14.2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 被提升到 *x* 次方的数被称为底数，所以对于 2*x* 的情况，底数是 2。如果底数大于 1，当 *x* 增加时函数增加，但如果它小于 1，当 *x*
    增加时函数减少。例如，在 (½)*x* 中，每个整数值是前一个值的一半，如表 14.2 所示。
- en: Table 14.2 Values of the decreasing exponential function (½)x
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2 减少指数函数 (½)x 的值
- en: '| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| (½)*x* | 1 | 0.5 | 0.25 | 0.125 | ~0.06 | ~0.03 | ~0.015 | ~0.008 | ~0.004
    | ~0.002 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| (½)*x* | 1 | 0.5 | 0.25 | 0.125 | ~0.06 | ~0.03 | ~0.015 | ~0.008 | ~0.004
    | ~0.002 |'
- en: This is called an *exponential decay*, and it’s more like what we want for our
    car depreciation model. An exponential decay means that the value of the function
    decreases by the same ratio over every *x* interval of a fixed size. Once we have
    our model, it can tell us that a Prius loses half its value every 50,000 miles,
    implying that it’s worth is ¼ of its original price at 100,000 miles, and so on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为指数衰减，它更符合我们汽车折旧模型的需求。指数衰减意味着函数的值在固定大小的每个 *x* 间隔内按相同的比例减少。一旦我们有了模型，它就可以告诉我们，普锐斯每行驶
    50,000 英里就会损失一半的价值，这意味着在 100,000 英里时，它的价值是其原始价格的 ¼，依此类推。
- en: Intuitively, this could be a better way to model depreciation. Toyotas, which
    are reliable cars that last a long time, retain some value as long as they are
    driveable. Our linear model, by comparison, suggests that their value becomes
    negative after a long time (figure 14.20).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上看，这可能是一种更好的折旧建模方式。丰田车，作为可靠且耐用的汽车，只要能驾驶就会保留一些价值。相比之下，我们的线性模型表明，它们的值在长时间后会变成负数（图14.20）。
- en: '![](../Images/CH14_F20a_Orland.png)![](../Images/CH14_F20b_Orland.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F20a_Orland.png)![图片](../Images/CH14_F20b_Orland.png)'
- en: Figure 14.20 A linear model predicts negative values for Priuses, as compared
    with an exponential model that shows a positive value at any mileage.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20 线性模型预测普锐斯的值为负，而指数模型在任何里程数下都显示正值。
- en: The form of exponential function we can use is *p*(*x*) = *qe^(rx)* , where
    *e* = 2.71828 . . . is the fixed base, and *r* and *q* are the coefficients we
    can adjust. (It might seem arbitrary or even inconvenient to use the base *e*,
    but *ex* is the standard exponential function, so it’s worth getting used to.)
    In the case of exponential decay, the value of *r* is negative. Because *er*^(·0)
    = *e*⁰ = 1, we have *p*(*0*) = *qer*^(·0) = *q*, so *q* still models the price
    of the Prius with zero miles. The constant *r* decides the rate of depreciation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的指数函数形式是 *p*(*x*) = *qe^(rx)*，其中 *e* = 2.71828 . . . 是固定的底数，*r* 和 *q*
    是我们可以调整的系数。（使用底数 *e* 可能看起来是任意的，甚至不方便，但 *ex* 是标准的指数函数，所以值得习惯。）在指数衰减的情况下，*r* 的值是负的。因为
    *er*^(·0) = *e*⁰ = 1，我们有 *p*(*0*) = *qer*^(·0) = *q*，所以 *q* 仍然代表零里程的普锐斯价格。常数 *r*
    决定了折旧率。
- en: 14.4.2 Finding the exponential function of best fit
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.2 寻找最佳拟合的指数函数
- en: 'With the formula *p*(*x*) = *qe^(rx)* in mind, we can use our methodology from
    the previous sections to find the exponential function of best fit. The first
    step is to write a function that takes the coefficients *q* and *r* and returns
    the cost of the corresponding function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记公式 *p*(*x*) = *qe^(rx)*，我们可以使用前几节中的方法来找到最佳拟合的指数函数。第一步是编写一个函数，它接受系数 *q*
    和 *r* 并返回相应函数的成本：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Python’s exp function computes the exponential function ex.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Python 的 exp 函数计算指数函数 ex。
- en: The next thing we need to do is choose a reasonable range for the coefficients
    *q* and *r* , which set the starting price and the depreciation rate, respectively.
    For *q*, we expect it to be close to the value of *b* from our linear model because
    both *q* and *b* represent the price of the car with zero miles on it. I’ll use
    a range from $0 to $30,000 to be safe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是为系数 *q* 和 *r* 选择一个合理的范围，分别设置起始价格和折旧率。对于 *q*，我们期望它接近我们线性模型中 *b* 的值，因为
    *q* 和 *b* 都代表零里程的汽车价格。我将使用从 $0 到 $30,000 的范围以确保安全。
- en: The value of *r* , which controls the depreciation rate, is a bit trickier to
    understand and set limits on. The equation *p*(*x*) = *qe^(rx)* with a negative
    *r* value implies that every time *x* increases by −1/*r* units, the price decreases
    by a *factor* of *e*, meaning it is multiplied by 1/ *e* or about 0.36\. (I’ve
    added an exercise at the end of the section to help you convince yourself of this!)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 控制折旧率的 *r* 值理解起来有点复杂，并且需要设定限制。具有负 *r* 值的方程 *p*(*x*) = *qe^(rx)* 表明，每当 *x* 增加
    -1/*r* 单位时，价格就会以 *e* 的 *因子* 减少，这意味着它乘以 1/ *e* 或大约 0.36。（我在本节末尾添加了一个练习，帮助你确信这一点！）
- en: 'To be conservative, let’s say a car is reduced in price by a factor of 1/ *e*,
    or to 36% of its original value, after 10,000 miles at the earliest. That would
    give us *r* = 10^(−4). A smaller *r* value would mean a slower rate of depreciation.
    These benchmark magnitudes show us how to rescale the function, and if we divide
    by 10^(11), the cost values stay small as well. Here’s the implementation of the
    scaled cost function, and figure 14.21 shows a heat map of its output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保守起见，让我们假设一辆车在行驶了10,000英里后，价格降低到原始价值的1/ *e*，即36%。这将给我们 *r* = 10^(−4)。较小的 *r*
    值意味着更慢的折旧率。这些基准量级告诉我们如何重新缩放函数，如果我们除以 10^(11)，成本值也会保持较小。以下是缩放成本函数的实现，图14.21显示了其输出的热图：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/CH14_F21_Orland.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F21_Orland.png)'
- en: Figure 14.21 Cost as a function of the rescaled values of *q* and *r*, called
    *s* and *t*, respectively
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21 成本作为重新缩放后的 *q* 和 *r* 值的函数，分别称为 *s* 和 *t*。
- en: 'The dark region at the top of the heatmap in figure 14.21 shows that the lowest
    cost occurs at a small value of *t* and a value of *s* somewhere in the middle
    of the range 0 to 1\. We’re ready to plug the scaled cost function into the gradient
    descent algorithm. The outputs of the gradient descent function are the *s* and
    *t* values minimizing the cost function, and we can undo the scaling to get *q*
    and *r* :'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21中热力图顶部的深色区域表明，在*t*的小值和0到1范围内的某个值*s*处，成本最低。我们准备好将缩放的成本函数插入梯度下降算法中。梯度下降函数的输出是使成本函数最小化的*s*和*t*值，我们可以取消缩放以得到*q*和*r*：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This implies that the exponential function that best predicts the price of a
    Prius in terms of its mileage is approximately
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，从里程数来预测普锐斯价格的最佳指数函数大约是
- en: '*p*(*x*) = 18,700 · *e*^(−0.00000768) · *x*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*x*) = 18,700 · *e*^(−0.00000768) · *x*'
- en: Figure 14.22 shows the graph with the actual price data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22显示了实际价格数据的图表。
- en: '![](../Images/CH14_F22_Orland.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F22_Orland.png)'
- en: Figure 14.22 The exponential function of best fit for a Prius and its mileage
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22 普锐斯和其里程数的最佳拟合指数函数
- en: 'You could argue that this model is even better than our linear model because
    it produces a lower sum squared error, meaning it fits the data (slightly) better
    according to the cost function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以争辩说，这个模型甚至比我们的线性模型更好，因为它产生了更小的总和平方误差，这意味着根据成本函数，它（略微）更好地拟合了数据：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using a nonlinear function like an exponential function is just one of the many
    variations on this regression technique. We could use other nonlinear functions,
    functions defined by more than two constants or data fit in more than 2 dimensions.
    In the next two chapters, we’ll continue to use cost functions to measure the
    quality of fit for regression models and then use gradient descent to make the
    fit as good as possible.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像指数函数这样的非线性函数只是这种回归技术众多变化中的一种。我们可以使用其他非线性函数，例如定义超过两个常数的函数或数据拟合超过2维的函数。在接下来的两章中，我们将继续使用成本函数来衡量回归模型的质量，然后使用梯度下降法使拟合尽可能好。
- en: 14.4.3 Exercises
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.3 练习
- en: '| **Exercise 14.7**: Confirm by choosing a sample value of *r* that *e*^(−*rx*)
    decreases by a factor of *e* every time *x* increases by 1/*r* units.**Solution**:
    Let’s take *r* = 3, so our test function is *e*^(−3*x*). We want to confirm that
    this function decreases by a *factor* of *e* every time *x* increases by ⅓ units.
    Defining the function in Python as follows'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习14.7**：通过选择一个样本值*r*，确认当*x*增加1/*r*单位时，*e*^(−*rx*)的值会减少一个因子*e**。**解答**：让我们取*r*
    = 3，因此我们的测试函数是*e*^(−3*x*)。我们想要确认每次*x*增加1/3时，这个函数会减少一个*因子*。将函数在Python中定义为以下内容'
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'we can see that it starts at a value of 1 at *x* = 0 and decreases by a factor
    of *e* for every ⅓ we add to *x* :'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，它在*x* = 0时从1的值开始，并且每次*x*增加1/3时，都会减少一个因子*e*：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In each of these cases, adding ⅓ to the input of `test` yields the same result
    as dividing the previous result by *e*. |
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况中，将`test`的输入增加1/3得到的结果与将前一个结果除以*e*相同。|
- en: '| **Exercise 14.8**: According to the exponential function of best fit, what
    percentage of the value of a Prius is lost every 10,000 miles?**Solution**: The
    price function is *p*(*x*) = 18,700 · *e*^(−0.00000768) · *x*, where the value
    *q* = $18,700, which represents the initial price and not how fast the price is
    decreasing. We can focus on the term *erx* = *e*^(−0.00000768) · *x* and see how
    much it changes over 10,000 miles. For *x* = 0, the value of this expression is
    1, and for *x* = 10,000, the value is'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习14.8**：根据最佳拟合的指数函数，每行驶10,000英里，普锐斯的价值会损失多少百分比？**解答**：价格函数是*p*(*x*) =
    18,700 · *e*^(−0.00000768) · *x*，其中值*q* = $18,700代表初始价格，而不是价格下降的速度。我们可以关注*erx*
    = *e*^(−0.00000768) · *x*这一项，并查看它在10,000英里内的变化。对于*x* = 0，这个表达式的值是1，而对于*x* = 10,000，这个值是'
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This means that after 10,000 miles, the Prius is worth only 94.2% of its original
    price, a decrease of 5.8%. Given how the exponential function behaves, this will
    be the case over *any* 10,000-mile increase in the mileage. |
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在行驶了10,000英里之后，普锐斯的价值仅为原始价值的94.2%，下降了5.8%。鉴于指数函数的行为，这种情况将在*任何*10,000英里里程增加的情况下发生。|
- en: '| **Exercise 14.9**: Asserting that the retail price (the price at zero miles)
    is $25,000, what is the exponential function that best fits the data? In other
    words, fixing *q* = 25,000, what is the value of *r* yielding the best fit for
    *qe^(rx)* ?**Solution**: We can write a separate function that gives the cost
    of the exponential function in terms of the single unknown coefficient *r* :'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 14.9**：断言零售价格（零英里处的价格）为$25,000，什么是最适合数据的指数函数？换句话说，固定*q* = 25,000，什么值*r*能产生*q*·*e^(rx*)的最佳拟合？**解答**：我们可以编写一个单独的函数，该函数以单个未知系数*r*为条件给出指数函数的代价：'
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following plot confirms that there’s a value of *r* between −10^(−4) and
    0, which minimizes the cost function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表确认了存在一个介于−10^(−4)和0之间的*r*值，该值最小化了代价函数：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](../Images/CH14_F22_Orland_UN03.png)It looks like an approximate value of
    *r* = −10^(−5) minimizes the cost function. To automatically minimize this function,
    we need to write a one-dimensional version of the gradient descent or use another
    minimization algorithm. You can try that approach if you like, but because there’s
    only one parameter, we can simply guess and check to see that *r* = −1.12 · 10^(−5)
    is approximately the *r* value yielding the minimum cost. This implies the best
    fit function is *p*(*x*) = 25,000 · *e*^(−0.0000112) · *x*. Here’s the graph of
    the new exponential fit, plotted with the raw price data:![](../Images/CH14_F22_Orland_UN04.png)
    |'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像](../Images/CH14_F22_Orland_UN03.png)它看起来像*r* = −10^(−5)的近似值最小化了代价函数。为了自动最小化这个函数，我们需要编写梯度下降的一维版本或使用另一个最小化算法。如果你喜欢，可以尝试这种方法，但由于只有一个参数，我们可以简单地猜测并检查*r*
    = −1.12 · 10^(−5)是否是产生最小代价的*r*值。这表明最佳拟合函数是*p*(*x*) = 25,000 · *e*^(−0.0000112)
    · *x*。以下是新的指数拟合图，与原始价格数据一起绘制：![图像](../Images/CH14_F22_Orland_UN04.png) |'
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*Regression* is the process of finding a model to describe the relationship
    between various data sets. In this chapter, we use linear regression to approximate
    the price of a car from its mileage as a linear function.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*回归*是找到一个模型来描述各种数据集之间关系的过程。在本章中，我们使用线性回归来近似汽车的价格，将其里程作为线性函数。'
- en: For a set of many (*x*, *y*) data points, there is likely no line that passes
    through all of the points.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一组许多(*x*, *y*)数据点，可能没有一条线能穿过所有这些点。
- en: For a function *f*(*x*, *y*) modeling the data, you can measure how close it
    comes to the data by taking the distance between *f*(*x*) and *y* for the specified
    points (*x*, *y*).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个建模数据的函数*f*(*x*, *y*)，你可以通过计算指定点(*x*, *y*)处的*f*(*x*)和*y*之间的距离来衡量它接近数据的程度。
- en: A function measuring how well a model fits a data set is called a *cost function*.
    A commonly used cost function is the sum of squared distances from (*x*, *y*)
    points to the corresponding model value *f*(*x*). The function that best fits
    the data has the lowest cost function.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量一个模型如何适应数据集的函数被称为*代价函数*。一个常用的代价函数是从(*x*, *y*)点到相应模型值*f*(*x*)的距离平方和。最适合数据的函数具有最低的代价函数。
- en: Considering linear functions of the form *f*(*x*), every pair of coefficients
    (*a*, *b*) defines a unique linear function. There is a 2D space of such pairs
    and, therefore, a 2D space of lines to explore.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑形式为*f*(*x*)的线性函数，每一对系数(*a*, *b*)定义了一个唯一的线性函数。存在一个这样的系数对的二维空间，因此也存在一个二维空间来探索线条。
- en: Writing a function that takes a pair of coefficients (*a*, *b*) and computes
    the cost of *ax* + *b* gives a function taking a 2D point and returning a number.
    Minimizing this function gives the coefficients defining the line of best fit.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受一对系数(*a*, *b*)并计算*ax* + *b*的代价，得到一个函数，它接受一个二维点并返回一个数字。最小化这个函数给出了定义最佳拟合线的系数。
- en: Whereas a linear function *p*(*x*) increases or decreases by a constant amount
    for constant changes in *x*, an exponential function decreases or increases by
    a constant ratio for constant changes in *x*.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与线性函数*p*(*x*)在*x*的常数变化下增加或减少一个常数量不同，指数函数在*x*的常数变化下按一个常数比率增加或减少。
- en: To fit an exponential equation to data, you can follow the same procedure as
    for a linear equation; you need to find the pair (*q*, *r*) yielding an exponential
    function *qe^(rx)* minimizing the cost function.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将指数方程拟合到数据中，你可以遵循与线性方程相同的程序；你需要找到一对(*q*, *r*)，它产生一个指数函数*q*·*e^(rx*)，并使代价函数最小化。
