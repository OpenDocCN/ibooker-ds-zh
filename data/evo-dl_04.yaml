- en: 3 Introducing genetic algorithms with DEAP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用DEAP介绍遗传算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating genetic solvers using DEAP
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DEAP创建遗传求解器
- en: Applying GA to a complex design or placement problem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将GA应用于复杂的设计或放置问题
- en: Solving or estimating mathematically difficult problems with GA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GA解决或估计数学难题
- en: Determining which GA operators to employ when solving problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解决问题时确定要使用的GA算子
- en: Constructing complex gene structures for design and drawing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建复杂基因结构进行设计和绘图
- en: In the last chapter, we explored the origins of life simulation and how evolution
    and natural selection can be used for optimization. We learned how genetic algorithms,
    a subset of evolutionary computation, could extend these concepts further into
    an elegant practical method of optimized search.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了生命模拟的起源以及如何利用进化和自然选择进行优化。我们学习了遗传算法，作为进化计算的一个子集，如何将这些概念进一步扩展为一个优雅的实用搜索优化方法。
- en: In this chapter, we directly extend what we learned in the last chapter to tackle
    larger and more complex problems using genetic algorithms. As part of this journey,
    we employ an EC toolkit called Distributed Evolutionary Algorithms in Python (DEAP)
    to make our lives easier. Like frameworks such as Keras or PyTorch, DEAP provides
    several tools and operators to make coding easier.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们直接将上一章学到的知识扩展到使用遗传算法解决更大、更复杂的问题。作为这一旅程的一部分，我们采用了一个名为Python中的分布式进化算法（DEAP）的EC工具包，以使我们的工作更轻松。像Keras或PyTorch这样的框架一样，DEAP提供了几个工具和算子，使编码更容易。
- en: 3.1 Genetic algorithms in DEAP
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 DEAP中的遗传算法
- en: While we could continue writing all the GA code we need in straight Python,
    this book isn’t about building an EC framework. Instead, in this chapter, we use
    the well-established DEAP EC framework. As its name suggests, this framework helps
    us review various EC methods, including GA.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以继续用纯Python编写我们需要的所有GA代码，但这本书不是关于构建EC框架的。相反，在本章中，我们使用成熟的DEAP EC框架。正如其名所示，这个框架帮助我们回顾各种EC方法，包括GA。
- en: DEAP, released in 2009, is a comprehensive and simplified framework for working
    with EC algorithms in various forms. Throughout this book, it is our main tool
    for building EDL solutions. The framework provides tool abstractions, which allows
    it to be cross-compatible with various evolutionary algorithms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP，于2009年发布，是一个全面且简化的框架，用于以各种形式处理EC算法。在整个书中，它是我们构建EDL解决方案的主要工具。该框架提供工具抽象，使其能够与各种进化算法实现跨兼容。
- en: 3.1.1 One max with DEAP
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 使用DEAP实现一个最大值问题
- en: There is likely no better way to learn about DEAP than using it to solve a problem
    we already solved using straight Python and GA in the last chapter. This allows
    us to become familiar with the framework and toolbelt it uses. In the following
    exercise, we build a solver to the one max problem with DEAP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比使用它来解决我们在上一章中使用纯Python和GA解决的问题更好的方式来了解DEAP了。这使我们能够熟悉它所使用的框架和工具包。在接下来的练习中，我们使用DEAP构建一个求解一个最大值问题的求解器。
- en: Open EDL_3_1_OneMax_DEAP.ipynb in Colab and then run all the cells. Refer to
    the appendix if you need assistance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Colab中打开Open EDL_3_1_OneMax_DEAP.ipynb，然后运行所有单元格。如需帮助，请参阅附录。
- en: 'In the first cell, we install DEAP using the following shell command. The `!`
    prefix denotes this as a shell command, not Python code. We use `pip` to install
    DEAP, using the quiet option, --`quiet`, to suppress the noisy output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个单元格中，我们使用以下shell命令安装DEAP。`!`前缀表示这是一个shell命令，而不是Python代码。我们使用`pip`安装DEAP，使用静默选项`--quiet`来抑制嘈杂的输出：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Move past the imports and then look at the next code cell showing the DEAP module
    `creator` setting up the `fitness` criteria and `individual` classes. The creator
    takes as input the name and base class for the first two parameters. As the following
    listing shows, this creates the template used to define, first, the maximum `fitness`
    and, second, the `individual` based upon the `numpy.ndarray`, much like in the
    last example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过导入部分，然后查看下一个代码单元格，展示DEAP模块`creator`设置`fitness`标准和`individual`类。创建者接受前两个参数的名称和基类作为输入。如下所示，这创建了一个模板，用于首先定义最大`fitness`，然后基于`numpy.ndarray`定义`individual`，就像在上一例中一样。
- en: 'Listing 3.1 EDL_3_1_OneMax_DEAP.ipynb: The `creator`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 EDL_3_1_OneMax_DEAP.ipynb：`creator`
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates the max fitness class
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建最大适应度类
- en: ❷ Creates the individual class, based on ndarray
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 基于ndarray创建个体类
- en: In the next cell, we see a new module being used as the base to construct a
    `toolbox`. The `toolbox` is a container that holds the hyperparameters and options,
    like the genetic operators. In the code, a `toolbox` is constructed and then the
    basic `gene` type `attr_bool` is registered. Next, we register the `individual`
    based on the creator, using the `attr_bool` `gene` type and size of `n=100`. On
    the final line, the `population` is registered as a `list` filled with the type
    of `toolbox.individual`. The pattern here is to construct and register the templates
    for `gene` type, followed by `individual`, and then `population`, as shown in
    the following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个单元中，我们看到一个新的模块被用作构建 `toolbox` 的基础。`toolbox` 是一个容器，它包含超参数和选项，如遗传算子。在代码中，构建了一个
    `toolbox`，然后注册了基本的 `gene` 类型 `attr_bool`。接下来，我们根据创建者注册 `individual`，使用 `attr_bool`
    `gene` 类型和大小的 `n=100`。在最后一行，将 `population` 注册为一个 `list`，其中填充了 `toolbox.individual`
    的类型。这里的模式是构建并注册 `gene` 类型的模板，然后是 `individual`，最后是 `population`，如以下列表所示。
- en: 'Listing 3.2 EDL_3_1_OneMax_DEAP.ipynb: The `toolbox`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 EDL_3_1_OneMax_DEAP.ipynb：`toolbox`
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates the Toolbox from base
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从基础创建 Toolbox
- en: ❷ Defines the base gene values 0 or 1
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义基本基因值 0 或 1
- en: ❸ Registers an individual gene sequence of size n=100, using attr_bool as a
    gene template
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 attr_bool 作为基因模板注册大小为 n=100 的个体基因序列
- en: ❹ Registers a population of type list, using an existing individual
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注册一个类型为列表的种群，使用现有的个体
- en: Next, we move on to registering the genetic operators used to process each `generation`.
    We start with `evaluate` for evaluating `fitness` and populate that with a custom
    function, called `evalOneMax`. After that, we add the genetic operation for `crossover`,
    calling it `mate`, and employ another custom function called `cxTwoPointCopy`.
    The following line sets the `mutate` operator, this time using a predefined DEAP
    tools function called `mutFlipBit`. This, as before, flips the bit or logic of
    the `gene`. Finally, the `selection` operator is registered as `select` this time,
    using a prebuilt `selTournament` operator, which represents tournament `selection`.
    *Tournament* `selection` is a form of random pairing that compares `fitness` to
    `evaluate` and selects the next `generation`’s parents, as shown in the following
    listing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续注册用于处理每一代的遗传算子。我们首先使用 `evaluate` 来评估 `fitness`，并使用一个名为 `evalOneMax`
    的自定义函数来填充它。之后，我们添加了 `crossover` 的遗传操作，命名为 `mate`，并使用另一个名为 `cxTwoPointCopy` 的自定义函数。下一行设置了
    `mutate` 操作符，这次使用了一个预定义的 DEAP 工具函数 `mutFlipBit`。这，就像之前一样，翻转了 `gene` 的位或逻辑。最后，这次注册的
    `selection` 操作符是 `select`，使用了一个预构建的 `selTournament` 操作符，它代表了锦标赛 `selection`。*锦标赛*
    `selection` 是一种随机配对的形式，它比较 `fitness` 和 `evaluate`，并选择下一代的父母，如以下列表所示。
- en: 'Listing 3.3 EDL_3_1_OneMax_DEAP.ipynb: Genetic operators'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 EDL_3_1_OneMax_DEAP.ipynb：遗传算子
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Registers the function to evaluate fitness
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注册评估适应度的函数
- en: ❷ Registers the function to apply crossover
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注册应用交叉的函数
- en: ❸ Registers the function to apply mutation and rate
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注册应用突变和率的函数
- en: ❹ Registers the selection method
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注册选择方法
- en: In this exercise, we use two custom functions and two predefined functions for
    the genetic operators. If you scroll up, you can see the two custom functions
    `evalOneMax` and `cxTwoPointCopy`. The `evalOneMax` function is a single line
    of code returning the sum of the `genes`, as shown previously.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了两个自定义函数和两个预定义函数来处理遗传算子。如果你向上滚动，你可以看到两个自定义函数 `evalOneMax` 和 `cxTwoPointCopy`。`evalOneMax`
    函数是一行代码，返回 `genes` 的总和，如之前所示。
- en: We can scroll back down to the last cell to see how the evolution is run. First,
    we set the `random.seed` to a known value, which allows for consistent runs. Then
    we use the `toolbox` to create the `population`. Next, we create a `HallOfFame`
    object we can use to track the top number of performers. In this exercise, we
    are only interested in tracking the single top performer, and since the `individuals`
    are NumPy arrays, we need to override the `similar` or `matching` algorithm for
    sorting, as shown in the following listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以滚动到最后一行，看看如何运行进化。首先，我们设置 `random.seed` 为一个已知值，这允许运行一致性。然后我们使用 `toolbox`
    来创建 `population`。接下来，我们创建一个 `HallOfFame` 对象，我们可以用它来跟踪表现最好的数量。在这个练习中，我们只对跟踪单个最佳表现者感兴趣，因为
    `individuals` 是 NumPy 数组，我们需要覆盖排序的 `similar` 或 `matching` 算法，如以下列表所示。
- en: 'Listing 3.4 EDL_3_1_OneMax_DEAP.ipynb: Setting up evolution'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 EDL_3_1_OneMax_DEAP.ipynb：设置进化
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Sets the random see for consistency
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置随机种子以保持一致性
- en: ❷ Creates the population
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建种群
- en: ❸ Sets the number of top individuals to watch
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置要观察的顶级个体数量
- en: The next lines of code create a new `Statistics` object, `stat`, we can use
    to track the progress of the `population`’s `fitness`. We add the descriptive
    statistics using the `register` function passing in the corresponding NumPy function
    to evaluate the statistic, as shown in the following listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行创建了一个新的`Statistics`对象`stat`，我们可以用它来跟踪`种群`的`适应度`进度。我们使用`register`函数添加描述性统计，传递相应的NumPy函数来评估统计量，如下所示。
- en: 'Listing 3.5 DL_3_1_OneMax_DEAP.ipynb: Setting up evolution (cont.)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 DL_3_1_OneMax_DEAP.ipynb：设置进化（继续）
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates a statistics object to track individual fitness
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个用于跟踪个体适应度的统计对象
- en: ❷ Registers a statistics function name and implementation
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注册统计函数名称和实现
- en: Finally, the last line of code does the evolving using an out-of-the-box function
    called `eaSimple` from the `algorithms` module. This function takes as input the
    `pop`, `toolbox`, `halloffame`, and `stats` objects as well as sets hyperparameters
    for the probability of `crossover` (`cxpb`), `mutation` (`mutpb`), and the number
    of `generations` (`ngen`), as shown in the following listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一行代码使用`algorithms`模块中的`eaSimple`函数进行进化。这个函数接受`pop`、`toolbox`、`halloffame`和`stats`对象作为输入，并设置超参数，包括`交叉`的概率（`cxpb`）、`变异`的概率（`mutpb`）和`代数`的数量（`ngen`），如下所示。
- en: 'Listing 3.6 EDL_3_1_OneMax_DEAP.ipynb: Evolving'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 EDL_3_1_OneMax_DEAP.ipynb：进化
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the exercise runs, we see the statistics output showing the progress of evolution.
    Over 40 `generations` with a `population` of `300` this time, we should see the
    GA attain a maximum `fitness` of `100`. The reason for this assured success over
    the first example was the choice in operators.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 随着练习的进行，我们看到统计输出显示了进化的进度。这次有40多`代`，`种群`数量为`300`，我们应该看到GA达到`100`的最大`适应度`。这种确保成功的原因在于算子的选择。
- en: In the last scenario, almost everything was like the notebook we covered in
    the last section of chapter 2\. So why did this `population` perform so well?
    Is DEAP that much better? DEAP isn’t better, but it does provide a wide range
    of options for genetic operators and other settings. The key difference between
    the last notebook and the previous example was the use of tournament `selection`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，几乎所有内容都与我们在第2章最后部分讨论的笔记本相似。那么为什么这个`种群`的表现如此出色？DEAP是否真的那么好？DEAP并不比其他的好，但它确实为遗传算子和其他设置提供了广泛的选项。最后一个笔记本和前一个例子之间的关键区别是使用了`赛选`。
- en: Tournament `selection` works by randomly selecting competition pairs of `individuals`
    and then passing them through several tournaments, where the winner is the one
    with the better `fitness`. At the end of the tournament, the winners are selected
    to be the parents of the next `generation`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 赛选`选择`通过随机选择竞争的`个体`配对，然后通过几个赛选，胜者是具有更好`适应度`的个体。在赛选结束时，胜者被选为下一`代`的父代。
- en: DEAP provides a useful library of genetic operators we can easily swap with,
    like tournament `selection`, out of the box. We take a close look at the wide
    range of options in a later section after we tackle some substantial problems
    beyond the scope of one max.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP提供了一组有用的遗传算子库，我们可以轻松地替换，例如，开箱即用的`赛选`。在解决了一个最大值问题范围之外的一些实质性问题之后，我们将在下一节中仔细研究其广泛的选项。
- en: 3.1.2 Learning exercises
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 学习练习
- en: 'Use the following exercises to help improve your understanding of the concepts
    we’ve discussed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下练习来帮助提高你对所讨论概念的理解：
- en: Increase the number of `genes` in a sequence by modifying the `creator .Individual`
    `toolbox` function from listing 3.2\. Rerun the whole notebook to see the results.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改列表3.2中的`creator.Individual` `toolbox`函数来增加序列中的`基因`数量。重新运行整个笔记本以查看结果。
- en: Increase or decrease the size of the `population` in listing 3.4 and then rerun
    it to see the results.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加或减少列表3.4中的`种群`大小，然后重新运行以查看结果。
- en: Alter the `crossover` and `mutation` rates of the evolution in listing 3.6 and
    then rerun. What effect does this have on the evolution of the final solution?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表3.6中的`交叉`和`变异`率，然后重新运行。这会对最终解决方案的进化产生什么影响？
- en: Now that we have an understanding of the basics of DEAP, we can move on to solving
    more interesting examples in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了DEAP的基本知识，我们可以继续到下一节，解决更有趣的例子。
- en: 3.2 Solving the Queen’s Gambit
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 解决皇后棋
- en: Evolutionary and genetic algorithms have been shown to successfully tackle many
    complex problems of design and placement. These forms of AI and ML methods excel
    at these types of problems due, in part, to the controlled random element of search
    they employ. This often allows systems designed with EA or GA to innovate beyond
    our understanding.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 进化算法和遗传算法已被证明能够成功解决许多设计和布局的复杂问题。这些人工智能和机器学习方法之所以在这些类型的问题上表现出色，部分原因在于它们采用了受控的随机搜索元素。这通常使得使用EA或GA设计的系统能够超越我们的理解进行创新。
- en: 'In the next notebook, we look at a classic design and placement problem: the
    Queen’s Gambit. This problem uses typical chess or checkered style board of size
    *n*, with a classic chessboard having size 8, or 8 by 8\. The goal is to place
    *n* number of queen chess pieces on the board such that no piece may capture another
    without moving.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个笔记本中，我们来看一个经典的设计和布局问题：皇后弃兵。这个问题使用典型的棋盘或棋盘风格棋盘，大小为*n*，经典棋盘大小为8，或8x8。目标是放置*n*个皇后棋子，使得没有棋子可以捕获另一个棋子而不移动。
- en: Chess and the queen
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 象棋与皇后
- en: In chess, the queen piece is the most powerful and can move in any direction
    and distance. Typically, each player has only one queen, but there is a special
    rule that allows players to crown more queens anytime a pawn makes it to the opponent’s
    back row. The premise of the Queen’s Gambit is that players have crowned several
    queens. However, this scenario would likely never happen in a real game because
    players lose when their king piece is captured.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在象棋中，皇后棋子是最强大的，可以朝任何方向和距离移动。通常，每位玩家只有一个皇后，但有一条特殊规则允许玩家在兵到达对手的后排时随时加冕更多皇后。皇后弃兵的假设是玩家已经加冕了几个皇后。然而，这种情况在现实游戏中可能永远不会发生，因为当玩家的国王棋子被捕获时，玩家就会输掉比赛。
- en: Open the EDL_3_2_QueensGambit.ipynb and then run all the cells. If you need
    assistance opening the notebook, consult the appendix.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开EDL_3_2_QueensGambit.ipynb，然后运行所有单元格。如果您需要打开笔记本的帮助，请参阅附录。
- en: First, we want to look at the initial or random placement of the queens on a
    chessboard. Since the queen piece can move in any direction and at any distance,
    this hypothetical game is limited to a maximum number of queens equal to the size
    of the board. In this example, we use eight, and the block of code we look at
    in the following listing draws an initial placement of queens.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想看看在棋盘上放置皇后的初始或随机位置。由于皇后可以朝任何方向移动，并且可以移动任何距离，这个假设游戏的最大皇后数量等于棋盘的大小。在这个例子中，我们使用八个，以下列表中我们查看的代码块绘制了皇后的初始放置。
- en: 'Listing 3.7 EDL_3_2_QueensGambit.ipynb: Plotting the board'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 EDL_3_2_QueensGambit.ipynb：绘制棋盘
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Sets up chessboard NumPy array 0s and 1s
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置棋盘NumPy数组0s和1s
- en: ❷ Sets the size of the figure
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置图形的大小
- en: ❸ Plots the base chessboard grid using a binary color map
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用二进制颜色图绘制基础象棋棋盘网格
- en: ❹ Randomly places queens on the board
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 随机在棋盘上放置皇后
- en: ❺ Plots the piece on the board as text
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在棋盘上以文本形式绘制棋子
- en: Figure 3.1 shows the rendered board and a reminder of how the queen piece can
    move. Notice that the selected piece can immediately capture several other pieces.
    Remember the goal of this problem is to place the pieces such that no single piece
    may capture another.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1显示了渲染的棋盘和皇后棋子如何移动的提醒。注意，选定的棋子可以立即捕获几个其他棋子。记住，这个问题的目标是放置棋子，使得没有单个棋子可以捕获另一个棋子。
- en: '![](../Images/CH03_F01_Lanham.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_Lanham.png)'
- en: Figure 3.1 A random placement of queens on a chessboard
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 棋盘上的随机皇后放置
- en: Again, much of the code in this notebook is like previous exercises. Next, we
    focus on how to fill the `toolbox`, as shown in listing 3.8\. Notice that for
    this exercise, we use two new `toolbox` functions for `crossover` and `mutation`.
    We cover more examples of these `toolbox` genetic operators you can use at the
    end of the chapter. Another great resource for understanding these operators is
    the DEAP documentation at [https://deap.readthedocs.io/en/master/api/tools.html](https://deap.readthedocs.io/en/master/api/tools.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个笔记本中的大部分代码与之前的练习类似。接下来，我们将关注如何填充`toolbox`，如列表3.8所示。请注意，对于这个练习，我们使用了两个新的`toolbox`函数用于`交叉`和`变异`。我们将在本章末尾提供更多这些`toolbox`遗传操作员的示例。了解这些操作员的另一个优秀资源是DEAP文档[https://deap.readthedocs.io/en/master/api/tools.html](https://deap.readthedocs.io/en/master/api/tools.html)。
- en: 'Listing 3.8 EDL_3_2_QueensGambit.ipynb: Filling the `toolbox`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 EDL_3_2_QueensGambit.ipynb：填充`toolbox`
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Sets the number of queens and board/ individual size
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置皇后的数量和棋盘/个体大小
- en: ❷ Adds a customer fitness function evalNQueens
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加客户适应度函数evalNQueens
- en: ❸ Uses a toolbox function for mating/crossover
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用工具箱函数进行交配/交叉
- en: ❹ Uses a toolbox function for applying mutation
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用工具箱函数应用变异
- en: ❺ Uses a tournament selection of selection
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用锦标赛选择进行选择
- en: The queen’s `fitness` `evaluate` function `evalNQueens` evaluates an `individual`’s
    `fitness` by taking a shortcut, and instead of running through every iteration
    of placement, the function assumes only a single queen can be placed on a row
    or column. Therefore, we just need to evaluate whether the queens are placed diagonally
    from one another, which simplifies the `fitness` function to the code in the following
    listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 皇后的`适应度` `评估`函数`evalNQueens`通过捷径评估个体的`适应度`，而不是运行放置的每个迭代，该函数假设只有一位皇后可以放置在一行或一列上。因此，我们只需要评估皇后是否对角放置，这简化了`适应度`函数到以下列表中的代码。
- en: 'Listing 3.9 EDL_3_2_QueensGambit.ipynb: Evaluating the `fitness`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 EDL_3_2_QueensGambit.ipynb：评估`适应度`
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Loops through the board and evaluates diagonal placements
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历棋盘并评估对角放置
- en: ❷ Loops over placements and sums nonconflicts
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对放置进行循环并计算非冲突总和
- en: ❸ Returns the sum of nonconflicts
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回非冲突的总和
- en: Following the `fitness` `evaluation` function, there is another function called
    `eaSimple`, which is just a copy of the standard `alogirthms.eaSimple` function
    from DEAP. This function is virtually identical to the one we used in the last
    exercise; however, it has much of the noisy logging removed, which allows us to
    custom output the top-performing `individual` as well as test for early stopping.
    Notice the test of the `individual`’s `fitness` against a maximum `fitness` in
    the following listing. This allows the evolution to stop early if the maximum
    `fitness` has been reached.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`适应度` `评估`函数之后，还有一个名为`eaSimple`的函数，这个函数只是DEAP中标准`alogirthms.eaSimple`函数的一个副本。这个函数与我们上次练习中使用的是几乎相同的；然而，它移除了大部分的噪声日志，这使得我们可以自定义输出表现最佳的`个体`，以及测试早期停止。注意以下列表中`个体`的`适应度`与最大`适应度`的测试。这允许在达到最大`适应度`时提前停止进化。
- en: 'Listing 3.10 EDL_3_2_QueensGambit.ipynb: The evolution function'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 EDL_3_2_QueensGambit.ipynb：进化函数
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Loops through the individuals and pairs to fitness with zip
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过个体和配对进行循环以与zip匹配适应度
- en: ❷ Tests whether the individual’s fitness has reached or exceeded max
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试个体的适应度是否达到或超过最大值
- en: ❸ If max fitness is reached, prints solved and sets the exit flag
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果达到最大适应度，则打印已解决并设置退出标志
- en: At the end of the notebook, you can see how the `population` is evolved. We
    first create the `population` and a `HallOfFame` container for the top performer.
    After that, we register the various statistics and then, finally, call the `eaSimple`
    function to evolve the `population`. In the following listing, notice the use
    of the `max = number_of_queens` as an input to control early stopping or when
    an `individual` has reached maximum `fitness`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本的末尾，你可以看到种群是如何进化的。我们首先创建`种群`和用于最佳表现者的`名人堂`容器。然后，我们注册各种统计数据，最后调用`eaSimple`函数以进化种群。在以下列表中，注意使用`max
    = number_of_queens`作为输入来控制早期停止或当`个体`达到最大`适应度`时。
- en: 'Listing 3.11 EDL_3_2_QueensGambit.ipynb: Evolution'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 EDL_3_2_QueensGambit.ipynb：进化
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Creates the population and hall of fame for the best
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建最佳表现者的种群和名人堂
- en: ❷ Registers the statistics functions for monitoring the population
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注册用于监控种群的统计数据函数
- en: ❸ Calls the evolution function to evolve the population
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用进化函数以进化种群
- en: Finally, we review the output of the evolution and see how well the algorithm
    evolved a solution. Figure 3.2 shows the solution for the given `seed` parameter
    we set earlier. You can see from the output that the evolution was able to stop
    early—67 `generations`—to create a viable solution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾进化的输出，看看算法如何进化出一个解决方案。图3.2显示了之前设置的给定`种子`参数的解决方案。你可以从输出中看到，进化能够提前停止——67
    `代`——以创建一个可行的解决方案。
- en: '![](../Images/CH03_F02_Lanham.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F02_Lanham.png)'
- en: Figure 3.2 Solution to the Queen’s Gambit
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 皇后棋的解决方案
- en: Feel free to revisit the solution and confirm that each of the queens is unable
    to capture one another on your own. You can even go back and increase the `board_size`
    or `number_of_queens` to a larger value, like 16 or more. This likely requires
    you to also increase the `population` size and the number of evolution `generations`.
    I recommend trying this now to gain some more experience working with GA.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随意回顾解决方案，并确认每个皇后都无法捕获彼此。你甚至可以回到增加`棋盘大小`或`皇后数量`到更大的值，如16或更多。这可能需要你同时增加`种群`大小和进化的`代数`数量。我建议你现在尝试一下，以获得更多使用GA的经验。
- en: 3.2.1 Learning exercises
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 学习练习
- en: 'Improve your knowledge by exploring these fun exercises:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索这些有趣的练习来提高你的知识：
- en: Change the `population` size to be evolved in listing 3.11 and then rerun. What
    effect does a larger `population` have on the evolution?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表3.11中的`种群`大小进行进化，然后重新运行。更大的`种群`对进化有什么影响？
- en: Alter the `crossover` and `mutation` rates in listing 3.11 and then rerun. Can
    you solve the solution in fewer `generations`?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表3.11中的`交叉`和`变异`率，然后重新运行。你能在更少的`代数`内解决问题吗？
- en: Increase or decrease the `selection` tournament size in listing 3.8 and then
    rerun. What effect does the tournament size have on the evolution?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表3.8中增加或减少`选择`锦标赛的大小，然后重新运行。锦标赛的大小对进化有什么影响？
- en: The Queen’s Gambit is a fun problem to look at; we continue looking at other
    classic problems solved with EC in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 女王棋局是一个有趣的问题来观察；我们将在下一节继续探讨其他用EC解决的经典问题。
- en: 3.3 Helping a traveling salesman
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 帮助旅行商人
- en: EA and GA have also been successful in optimizing difficult-to-solve mathematical
    problems, like the classic traveling salesman problem. You see, in the old days
    before the internet, the salesman would need to physically travel the country
    to sell their wares. The concept of this problem is to solve the route a salesman
    would need to take to never revisit the same location twice, while optimizing
    the length of their journey.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: EA和GA在优化难以解决的数学问题方面也取得了成功，例如经典的旅行商问题。你看，在互联网出现之前的日子里，商人需要亲自穿越国家来销售他们的商品。这个问题的概念是解决商人需要采取的路线，以确保他们不会两次访问同一地点，同时优化他们的行程长度。
- en: Figure 3.3 shows an example of the traveling salesman problem (TSP) depicted
    on a map grid of 100 units by 100 units. In the figure, the salesman has optimized
    their route, so they can visit each city just once and then return home at the
    end of the trip.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3展示了在100单位×100单位的地图网格上描述的旅行商问题（TSP）的示例。在图中，商人已经优化了他们的路线，因此他们可以只访问每个城市一次，并在旅行的最后返回家中。
- en: The TSP is considered an NP-hard problem in mathematics, which means it is not
    computationally solvable in linear time. Instead, the computational power to solve
    such a problem increases exponentially with the number of locations. In figure
    3.3, the salesman has 22 `destinations`, including `home`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: TSP在数学上被认为是一个NP-hard问题，这意味着它不能在线性时间内计算解决。相反，解决此类问题的计算能力随着地点数量的增加而呈指数增长。在图3.3中，商人有22个`目的地`，包括`家`。
- en: '![](../Images/CH03_F03_Lanham.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F03_Lanham.png)'
- en: Figure 3.3 Solution to the TSP visualized
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 TSP解决方案的可视化
- en: NP problems in computation and math
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和数学中的NP问题
- en: In mathematics and computation, algorithms are classified by their difficulty
    according to the amount of time or computational power required to solve them.
    We classify such problems as NP, where N stands for the number of elements needed
    to solve for and P is the time required to solve the problem. Problems are classified
    as NP easy if they can be solved in linear time—that is, N × P increases at a
    linear rate. Conversely, NP-hard problems are defined such that they cannot be
    solved in linear time and, instead, require exponential time. NP-hard solutions
    are defined with N2 × P or higher exponential, such that as the number of elements
    increases, the complexity of the problem increases exponentially.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学和计算中，算法根据解决它们所需的时间或计算能力来分类其难度。我们将此类问题分类为NP，其中N代表解决所需元素的数量，P是解决问题所需的时间。如果问题可以在线性时间内解决，则将其分类为NP
    easy——即N × P以线性速率增加。相反，NP-hard问题定义为不能在线性时间内解决，而是需要指数时间。NP-hard解决方案定义为N2 × P或更高指数，这样随着元素数量的增加，问题的复杂性呈指数增长。
- en: Since the TSP problem is NP-hard, we have yet to find a mathematical solution
    that can solve the problem in linear time. Instead, many methods developed to
    solve the TSP are estimation methods that borrow from shortcuts in process and
    optimization. Such fine-tuned methods have been shown to work successfully over
    thousands of points.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TSP问题是NP难的，我们还没有找到可以在线性时间内解决问题的数学解。相反，许多为解决TSP而开发的方法都是估计方法，它们借鉴了过程和优化的捷径。这些经过精心调整的方法已经在数千个点中成功应用。
- en: Using big O notation, we can express the TSP problem as O(n²2^n) for calculating
    the maximum time to calculate an answer. We get this for each new `destination`
    point; we need to recalculate the corresponding subpoints for each `destination`.
    In comparison, calculating 22 `destinations` would require a maximum of 2 billion
    calculations, while 23 `destinations` would require 4.5 billion calculations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大O符号，我们可以将TSP问题表示为O(n²2^n)来计算得到答案的最大计算时间。对于每个新的`目的地`点，我们都需要重新计算相应的子点。相比之下，计算22个`目的地`需要最多20亿次的计算，而23个`目的地`则需要45亿次的计算。
- en: To put this amount of computation into perspective for 22 points, consider that
    if each calculation required 1 millisecond or 1/1000^(th) of a second to complete,
    then 2 billion calculations would take 23 days to complete. That number would
    grow exponentially with each additional `destination`, making typical programming
    solutions not practical. Instead, methods like EA/GA provide alternatives for
    finding solutions to such complex problems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将22个点的计算量放在一个可比较的视角中，假设每个计算需要1毫秒或1/1000秒来完成，那么20亿次的计算将需要23天来完成。随着每个额外`目的地`的增加，这个数字将以指数级增长，使得典型的编程解决方案变得不切实际。相反，EA/GA等方法为解决这类复杂问题提供了替代方案。
- en: 3.3.1 Building the TSP solver
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 构建TSP求解器
- en: In the next notebook, we use DEAP to construct a solution to solve the class
    of open-ended TSP problems. A closed form of the TSP is where the salesman is
    constrained to a certain driving distance or length. That means in the problem,
    the salesman may travel any distance to travel to all `destinations`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个笔记本中，我们使用DEAP构建一个解决方案来解决开放端TSP问题类。TSP的封闭形式是指旅行商被限制在一定的驾驶距离或长度。这意味着在问题中，旅行商可以旅行任何距离到达所有`目的地`。
- en: Open the EDL_3_3_TSP.ipynb notebook in Colab and then run all the cells. If
    you need assistance, refer to the appendix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Colab中打开EDL_3_3_TSP.ipynb笔记本，然后运行所有单元格。如果您需要帮助，请参阅附录。
- en: We start by looking at the initialization and visualization of a random salesman
    path. The first thing we define is the base `map` of `destination` points that
    will hold all the locations for the traveling salesman’s route. Next, we draw
    the `map destinations` using the `plt.scatter` function by passing in the `0`
    and `1` values from the map. After that, we grab the current plot using `plt.gca()`
    and add limits to the plot bounds, so we can clearly visualize the entire `map`
    of `destinations`, as shown in the following listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看随机旅行商路径的初始化和可视化。我们首先定义的是包含旅行商路线所有位置的基`地图`。接下来，我们使用`plt.scatter`函数通过传递地图中的`0`和`1`值来绘制`地图目的地`。之后，我们使用`plt.gca()`获取当前图表并添加绘图边界限制，以便我们可以清楚地可视化整个`目的地`地图，如下所示。
- en: 'Listing 3.12 EDL_3_3_TSP.ipynb: Setting up the `map`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 EDL_3_3_TSP.ipynb：设置`地图`
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Sets the size and resolution of the figure
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置图形的大小和分辨率
- en: ❷ Defines a random NumPy array of points with size = destinations
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个大小为`目的地`的随机NumPy数组
- en: ❸ Plots the points on the map
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在地图上绘制点
- en: ❹ Sets the plot’s limits
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 设置绘图限制
- en: When we apply GA, each `individual` in the `population` will represent a list
    of indexes on the `destination` `map`. That list also represents the `gene` sequence
    of the `individual`, where each index is a `gene`. Since our map represents a
    random set of points, we can assume starting `individuals` just visit each of
    those points in order. Doing that allows us to construct a simple path from an
    `individual`, using the code in the following listing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用GA时，`种群`中的每个`个体`将代表一个在`目的地``地图`上的索引列表。这个列表也代表了`个体`的`基因`序列，其中每个索引是一个`基因`。由于我们的地图代表了一组随机的点，我们可以假设起始`个体`只是按顺序访问这些点。这样做允许我们使用以下列表中的代码从`个体`构建一个简单的路径。
- en: 'Listing 3.13 EDL_3_3_TSP.ipynb: Creating a `path`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 EDL_3_3_TSP.ipynb：创建`路径`
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Enumerates the points on the map
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列出地图上的点
- en: ❷ Appends each destination to path
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个目的地添加到路径中
- en: ❸ Creates a new path based on the map
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 基于地图创建新的路径
- en: Next, we want a way to visualize this path, so we can see what the route is
    and will be as the evolution progresses. The `draw_path` function operates by
    passing in the path constructed from the last step. Inside the function, the code
    loops through the indexes in the path and connects the points using the `plt.arrow`
    function passing in the point pairs, as shown in the following listing. After
    looping through the indexes in the path list, we draw a final path to the starting
    point. Figure 3.4 shows the output of calling the `draw_path` function with the
    starting path we constructed in the last step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望有一种方法来可视化这条路径，以便我们可以看到随着进化的进行，路线将是什么样子。`draw_path`函数通过传递从上一步构建的路径来操作。在函数内部，代码遍历路径中的索引，并使用`plt.arrow`函数通过点对连接点，如下面的列表所示。遍历路径列表中的索引后，我们绘制一条指向起点的最终路径。图3.4显示了使用我们在上一步构建的起始路径调用`draw_path`函数的输出。
- en: '![](../Images/CH03_F04_Lanham.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F04_Lanham.png)'
- en: Figure 3.4 Visualizing the starting random path
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4可视化起始随机路径
- en: 'Listing 3.14 EDL_3_3_TSP.ipynb: Visualizing the Path'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 EDL_3_3_TSP.ipynb：可视化路径
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Plots the base map destinations
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制基础地图目的地
- en: ❷ Draws arrows from point to point
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从一点绘制到另一点的箭头
- en: ❸ Plots an arrow back to the start
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 绘制一个指向起点的箭头
- en: ❹ Draws the entire path
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 绘制整个路径
- en: Just below the `draw_path` function, we can see the `evaluate_path` function
    used to determine the `fitness` of each path. This function in the following listing
    loops through the point indexes in the path and calculates the L1, or Euclidean,
    distance. It then sums up all these distances into the total path length, which
    also corresponds to the `individual`’s `fitness`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw_path`函数下方，我们可以看到`evaluate_path`函数用于确定每个路径的`fitness`。在下面的列表中，这个函数遍历路径中的点索引，并计算L1或欧几里得距离。然后，将这些距离加起来得到总路径长度，这也对应于`individual`的`fitness`。
- en: 'Listing 3.15 EDL_3_3_TSP.ipynb: Evaluating the path'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 EDL_3_3_TSP.ipynb：评估路径
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Loops through point indexes in the path
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历路径中的点索引
- en: ❷ Calculates the L1 distance between points
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算点之间的L1距离
- en: ❸ Returns the distance as a set
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回距离作为集合
- en: From here, we pass the other familiar code and look at the `toolbox` setup as
    well as how to construct the `individuals`. In this example, we construct a `chromosome`
    with indices equal to the number of `destinations` to hold the indexes in the
    `destination` `map`, as shown in the following listing. Each `individual` in this
    exercise represents a path of indexes on the `destination map`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们传递其他熟悉的代码，并查看`toolbox`的设置以及如何构建`individuals`。在这个例子中，我们构建一个`chromosome`，其索引等于`destinations`的数量，以存储`destination`
    `map`中的索引，如下面的列表所示。在这个练习中，每个`individual`代表`destination` `map`上的索引路径。
- en: 'Listing 3.16 EDL_3_3_TSP.ipynb: Filling the `toolbox`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.16 EDL_3_3_TSP.ipynb：填充`toolbox`
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Creates a gene type called indices of the length of destinations
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个长度等于目的地的基因型索引
- en: ❷ Creates an individual using the indices gene type
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用索引基因型创建一个个体
- en: ❸ Creates the population list to hold individuals
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个包含个体的种群列表
- en: Jump down to the bottom cell to review the code that performs the evolution.
    Again, this code is like the previous exercise, except this time we don’t provide
    an early stopping parameter. That is because calculating the minimum path distance
    would be as or more expensive than the algorithm we are using to calculate the
    distance. Instead, we can use the evolutions output to confirm the evolution has
    reached a solution, as shown in the following listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到最底部的单元格，查看执行进化的代码。再次强调，这段代码与之前的练习类似，只是这次我们没有提供早期停止参数。这是因为计算最小路径距离的成本可能与我们所使用的计算距离的算法一样高，甚至更高。相反，我们可以使用进化的输出来确认进化已经达到解决方案，如下面的列表所示。
- en: 'Listing 3.17 EDL_3_3_TSP.ipynb: Evolution'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.17 EDL_3_3_TSP.ipynb：进化
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Calls the evolution function with hardcoded hyperparameters
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用硬编码的超参数调用进化函数
- en: Figure 3.5 shows the solution to a 22-point `destination` problem. A simple
    way to evaluate whether a solution is correct is to notice that all the connected
    points don’t cross over each other and, essentially, form a loop, as shown in
    the figure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5显示了22个点的`目的地`问题的解决方案。评估解决方案是否正确的一个简单方法是通过注意所有连接的点不会交叉，并且本质上形成一个循环，如图所示。
- en: '![](../Images/CH03_F05_Lanham.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F05_Lanham.png)'
- en: Figure 3.5 Solving the TSP with 22 destinations in 52 `generations`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5使用22个目的地在52`代`中解决TSP问题
- en: In most cases, with a `destination` count of 22, this exercise should complete
    in under 200 `generations`. Even though we set the seed for the `random.seed`,
    we can still get diverse variations in the `destination` `map` as well as the
    final solution path. If you find the notebook is unable to solve the problem in
    under 200 `generations`, either reduce the number of `destination` points or increase
    the number of `generations`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当`目的地`数量为22时，这个练习应该在200`代`内完成。尽管我们设置了`random.seed`的种子，但我们仍然可以在`目的地``地图`以及最终的解决方案路径中获得多样化的变化。如果你发现笔记本在200代内无法解决问题，要么减少`目的地`点的数量，要么增加`代数`的数量。
- en: Try going back and increasing the number of `destinations` by 1 to 23 or up
    to 25 and then run the exercise again. Keep in mind that each additional point
    is an exponential increase in complexity, but in some cases, it is just as readily
    solvable. See if you can increase the number of `destinations` beyond 25 to find
    a solution. If you do, keep in mind that you also likely need to increase the
    number of `generations` and/or `population`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`目的地`的数量增加1到23或最多25，然后再次运行练习。记住，每增加一个点都会在复杂性上呈指数级增长，但在某些情况下，它同样容易解决。看看你是否能将`目的地`的数量增加到25以上以找到解决方案。如果你做到了，记住你可能还需要增加`代数`和/或`种群`的数量。
- en: 3.3.2 Learning exercises
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 学习练习
- en: 'Use these exercises to explore the concepts in the notebook further:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些练习来进一步探索笔记本中的概念：
- en: Increase or decrease the number of `destinations` the salesman needs to visit
    and then rerun after each change. What is the maximum number of `destinations`
    you can create a solution for?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加或减少销售员需要访问的`目的地`数量，然后每次更改后重新运行。你能创建多少个`目的地`的解决方案？
- en: Tweak the `population`, `crossover`, and `mutation` rate and then rerun the
    notebook.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`种群`、`交叉`和`变异`率，然后重新运行笔记本。
- en: Alter the type or parameters of the `selection` function used for the evolution.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变用于进化的`选择`函数的类型或参数。
- en: Now, with a couple of fun and interesting examples out of the way, we can dig
    into more details about selecting various genetic operators in the next section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几个有趣且引人入胜的例子已经介绍完毕，我们可以在下一节中更深入地探讨选择各种遗传操作符的细节。
- en: 3.4 Selecting genetic operators for improved evolution
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 选择遗传操作符以改进进化
- en: Evolutionary computation, not unlike other AI or ML disciplines, provides a
    wide variety of hyperparameters and options for tuning to problems. EA and GA
    are certainly no different and, as we have already seen, provide various hyperparameters
    and genetic operator options. In this section, we explore and attempt to understand
    more about these options.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 进化计算，与其他人工智能或机器学习学科一样，提供了广泛的超参数和选项来调整以适应问题。EA和GA当然也不例外，正如我们之前所看到的，它们提供了各种超参数和遗传操作符选项。在本节中，我们将探讨并尝试更深入地了解这些选项。
- en: DEAP provides several genetic operator options that, under the Evolutionary
    Tools documentation, can, in many cases, be easily swapped out. Other operators
    may require special circumstances with the `gene` or `individual` type, like the
    `mutShuffleIndexes` operator we used in the last two exercises; others may be
    custom-made according to your requirements and discretion, making the possibilities
    endless.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP提供了几种遗传操作符选项，根据进化工具文档，在许多情况下可以轻松替换。其他操作符可能需要特殊的`基因`或`个体`类型环境，例如我们在最后两个练习中使用的`mutShuffleIndexes`操作符；其他操作符可能根据你的需求和判断定制制作，使可能性无限。
- en: 'Tip DEAP has an excellent documentation resource that provides more details
    about the genetic operators we look at in this section and beyond. Documentation
    on evolutionary tools and genetic operators can be found on the following web
    page: [https://deap.readthedocs.io/en/master/api/tools.html](https://deap.readthedocs.io/en/master/api/tools.html).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：DEAP有一个优秀的文档资源，提供了关于本节及以后我们探讨的遗传操作符的更多详细信息。关于进化工具和遗传操作符的文档可以在以下网页上找到：[https://deap.readthedocs.io/en/master/api/tools.html](https://deap.readthedocs.io/en/master/api/tools.html)。
- en: Of course, applying the right genetic operator to your evolver requires knowledge
    of what and how these tools do what they do. In the next exercise, we review a
    few of the most common operators and see how they modify the evolution of the
    target `population`. We use a simplified version of the TSP we explored in the
    last section to view the results of swapping out various genetic operators.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将正确的遗传算子应用于你的进化器需要了解这些工具做什么以及如何做。在下一个练习中，我们将回顾一些最常见的算子，并看看它们如何修改目标种群（population）的进化。我们使用上一节中探索的简化版
    TSP 来查看替换各种遗传算子的结果。
- en: Open the EDL_3_4_TSP_Operators.ipynb in Colab and then run all the cells. Refer
    to the appendix if you need assistance. This exercise borrows most of its code
    from the previous exercise and annotates it with some additional visualizations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Colab 中打开 EDL_3_4_TSP_Operators.ipynb 并运行所有单元格。如有需要，请参考附录。这个练习借鉴了上一个练习的大部分代码，并添加了一些额外的可视化注释。
- en: This notebook heavily uses Colab forms to provide a UI to modify the various
    options and hyperparameters. Jump down to the cell titled Selecting the Genetic
    Operators, shown in figure 3.6.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个笔记本大量使用 Colab 表单来提供用户界面，以修改各种选项和超参数。跳转到标题为“选择遗传算子”的单元格，如图 3.6 所示。
- en: '![](../Images/CH03_F06_Lanham.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F06_Lanham.png)'
- en: Figure 3.6 The Google Colab forms interface to select genetic operators
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 Google Colab 表单界面用于选择遗传算子
- en: 'Let’s start by testing variations to the `selection` genetic operators. This
    notebook provides several options for the type of `selection` operator we can
    choose and test for `crossover` and `selection`. Swapping out the `mutation` operator
    isn’t an option, since we are using a specialized form of `mutation` that swaps
    indices. Choose one of the `selection` operators, and then from the menu, select
    Runtime > Run After to apply the changes and rerun the remaining cells in the
    notebook. The following list shows each of the operators and a brief description
    of the operation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试 `selection` 遗传算子的变体开始。这个笔记本提供了我们可以选择和测试的 `selection` 算子类型选项，以及用于交叉和选择的选项。由于我们使用的是交换索引的特殊变异形式，因此无法更换变异算子。选择一个
    `selection` 算子，然后从菜单中选择运行 > 运行后，以应用更改并重新运行笔记本中的剩余单元格。以下列表显示了每个算子及其简要操作描述：
- en: '*Tournament*—This operator selects by running tournament `selection` for *n*
    number of repetitions. Initial tournaments are selected randomly, and winners
    move to the next tournament. This operator works well, optimizing the best `individuals`
    while maintaining some amount of diversity.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*锦标赛*—此算子通过进行 *n* 次重复的锦标赛选择来选择。初始锦标赛是随机选择的，获胜者进入下一轮锦标赛。此算子效果良好，在保持一定多样性的同时优化最佳个体。'
- en: '*Random*—This operator selects by randomly picking parents from the `population`.
    This is a good operator to employ if you find the `population` becomes specialized
    quickly or appears to get stuck at a local maximum/minimum. For problems like
    the TSP, this operator may be effective, depending on the chosen `crossover` and
    `mutation` operator.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机*—此算子通过随机从种群中挑选父母来选择。如果你发现种群很快专业化或似乎陷入局部最大值/最小值，这是一个很好的算子。对于像 TSP 这样的问题，这个算子可能有效，具体取决于选择的交叉和变异算子。'
- en: '*Best* —This operator selects the best performers to use as parents. As seen
    in our first example, using elite `selection` or best `selection` works well to
    quickly find solutions, but it is much less effective long-term. This is because
    the `population` does not remain diverse enough to overcome sticking points.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳* —此算子选择表现最佳的个体作为父母。正如我们在第一个例子中看到的那样，使用精英选择或最佳选择可以快速找到解决方案，但长期效果较差。这是因为种群没有足够多的多样性来克服停滞点。'
- en: '*Worst*—The opposite of the best operator, this operator selects the worst
    performers for parents. The benefit of using the worst as parents is the ability
    to entirely avoid specialization. This, in turn, works well when you find `populations`
    specialized and get stuck in incorrect solutions.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最差*—与最佳算子的相反，此算子选择表现最差的个体作为父母。使用最差个体作为父母的优点是可以完全避免专业化。当你发现种群专业化并且陷入错误解决方案时，这一点尤其有效。'
- en: '*NSGA2*—This operator is based on the paper “A Fast Elitist Non-dominated Sorting
    Genetic Algorithm for Multi-objective Optimization: NSGA-II” by Deb et al. (2002,
    Springer). It is an algorithm/operator that works well to maintain `fitness` optimization
    but still retains `population` diversity long-term. Using this algorithm results
    in the `population` tending to stay within a normal distribution. That makes this
    method useful for longer evolving problems.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NSGA2*——此操作符基于Deb等人于2002年（Springer）发表的论文“A Fast Elitist Non-dominated Sorting
    Genetic Algorithm for Multi-objective Optimization: NSGA-II”。它是一个既能够很好地维护`fitness`优化，又能在长期内保持`population`多样性的算法/操作符。使用此算法会导致`population`倾向于保持在正态分布内。这使得这种方法对于需要长期进化的问题很有用。'
- en: '*SPEA2* —This operator originates from the paper “SPEA 2: Improving the Strength
    Pareto Evolutionary Algorithm” by Zitzler et al. (2001, ETH Zurich, Computer Engineering
    and Networks Laboratory). It attempts to maintain a Pareto front distribution
    of the `population` with a peak near the max/min `fitness`, resulting in an almost-U
    shape distribution. This is a good operator for problems requiring long-term evolution,
    since it maintains a balanced diversity, which avoids sticking points.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SPEA2*——此操作符起源于Zitzler等人于2001年（ETH Zurich，计算机工程和网络实验室）发表的论文“SPEA 2: Improving
    the Strength Pareto Evolutionary Algorithm”。它试图在最大/最小`fitness`附近保持`population`的Pareto前沿分布，从而形成一个几乎U形的分布。这是一个适用于需要长期进化的问题的良好操作符，因为它保持平衡的多样性，避免了停滞点。'
- en: Be sure to set the `population` to `1000` and the number of `generations` to
    `15` to see the full effect of the `selection` operator. As you go through each
    of the `selection` operators, pay particular attention to the output generated
    from the last cell doing the evolution. The histogram output shown for various
    `selection` operators is depicted in figure 3.7\. Notice how the tournament `selection`
    operator forms a Pareto distribution of `fitness`, while other methods tend to
    diversify the `fitness`. Remember that more diversity benefits longer evolution
    and generally adapts better around sticking points. However, at the same time,
    more diversity requires a higher number of `generations` to evolve an optimum
    `fitness`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将`population`设置为`1000`，并将`generations`的数量设置为`15`，以便看到`selection`操作符的完整效果。在遍历每个`selection`操作符时，请特别注意最后进行进化的单元格生成的输出。图3.7展示了各种`selection`操作符的直方图输出。注意，锦标赛`selection`操作符形成了一个`fitness`的Pareto分布，而其他方法则倾向于多样化`fitness`。记住，更多的多样性有利于更长时间的进化，并且通常能更好地适应关键点。然而，与此同时，更多的多样性需要更多的`generations`来进化出最佳的`fitness`。
- en: '![](../Images/CH03_F07_Lanham.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F07_Lanham.png)'
- en: Figure 3.7 A comparison of `selection` operators on population diversity
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 `selection`操作符对种群多样性的比较
- en: 'Feel free to explore the various selection operators, and be sure to change
    the number of `destinations` and `generations` as well as the size of the `populations`.
    Take note of what effects larger and smaller `populations` have on `selection`.
    When you are done exploring `selection`, we can move on to change the `crossover`
    operator, as shown in figure 3.7\. There are several types of `crossover` operators
    that can provide more efficient solution finding. When applying `crossover`, the
    resulting offspring often performs less effectively due to mismatching or misaligned
    sequences. `Genes` do not need to be aligned in sequences in all cases, but in
    this exercise, they do. The following is a list of the `crossover` operators used
    in this sample notebook and how they affect evolution:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随意探索各种选择操作符，并确保更改`destinations`和`generations`的数量以及`populations`的大小。注意较大和较小的`populations`对`selection`的影响。当你完成对`selection`的探索后，我们可以继续更改如图3.7所示的`crossover`操作符。有几种类型的`crossover`操作符可以提供更有效的解决方案。在应用`crossover`时，由于不匹配或序列错位，产生的后代往往表现不佳。在某些情况下，`genes`不需要在序列中对齐，但在这个练习中，它们需要。以下是在这个示例笔记本中使用的`crossover`操作符列表以及它们对进化的影响：
- en: '*Partially matched*—This method works by matching sequences of indices type
    `genes` and performing a `crossover` on sequences—it may not work well or as expected
    for other `gene` types. By preserving index sequences, this `crossover` operation
    is better at preserving the best parts of offspring, whereas other operators may
    disrupt the path or important evolved sequences.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分匹配*——这种方法通过匹配索引类型`genes`的序列并在这序列上执行`crossover`操作来实现。对于其他`gene`类型，它可能工作得不好或不符合预期。通过保留索引序列，这种`crossover`操作更好地保留了后代中最好的部分，而其他操作符可能会破坏路径或重要的进化序列。'
- en: '*Uniform partially matched*—This method is like the partially matched operator
    but differs in that it attempts to maintain a balanced and uniform trade of sequences
    between parents’ `crossover`. The benefit of this method is a stronger adherence
    to persevering sequences over the long term, but it may make initial evolution
    difficult.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*均匀部分匹配*—这种方法类似于部分匹配操作符，但不同之处在于它试图在父母的“交叉”之间保持平衡和均匀的序列交换。这种方法的好处是长期坚持序列的更强一致性，但它可能使初始进化变得困难。'
- en: '*Ordered*—This `crossover` operator performs an ordered swap of index sequences.
    Doing so preserves the order but allows the sequence to be essentially rotated.
    This is a good operator to use for `populations` that may get stuck evolving sequence
    operations, like the TSP.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有序*—这个“交叉”操作符执行有序的索引序列交换。这样做可以保持顺序，但允许序列基本上旋转。这是一个很好的操作符，用于可能陷入进化序列操作（如TSP）的“种群”。'
- en: '*One point/two point*—Much like the first `crossover` operator earlier in this
    chapter, a one-point `crossover` selects a point at which to split the parent’s
    `gene` sequences together. Extending this concept, the two-point `crossover` performs
    the same operation but uses two points to slice the `gene` sequences. These are
    good general methods but are not options when working with indexed sequences,
    like the TSP.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一点/两点*—与本章前面提到的第一个“交叉”操作符类似，一点“交叉”选择一个点来分割父母的“基因”序列。扩展这个概念，两点“交叉”执行相同的操作，但使用两个点来切割“基因”序列。这些是很好的通用方法，但在处理像TSP这样的索引序列时并不是选项。'
- en: To understand the effects of changing `crossover`, we need to introduce a new
    type of plot called a *genealogy plot*, as shown in figure 3.8\. In the figure,
    each circle represents a `generation`, and if that `generation` spawns a good
    offspring, then an arrow will be connected to the next `generation`. The genealogy
    plot is useful for confirming that your `crossover` operation is spawning viable,
    fit offspring. A good plot shows the flow from less fit to more fit offspring.
    Essentially, the more arrows and connections, the better; this indicates progress
    of the evolutionary process, where each arrow from one node to another represents
    a connected step, or *subspecies* in evolutionary nomenclature. Genealogy plots
    showing fewer connections, or no connections at all, indicate your `crossover`
    is not producing viable offspring. Isolated points on this plot indicate random
    offspring that may have had good `fitness` but produced no viable offspring.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解改变“交叉”的影响，我们需要引入一种新的图表类型，称为“家谱图”，如图3.8所示。在图中，每个圆圈代表一代，如果这一代产生了好的后代，那么就会有一条箭头连接到下一代。家谱图有助于确认你的“交叉”操作是否产生了有活力的、适应良好的后代。一个好的图表显示了从不太适应到更适应的后代的流动。基本上，箭头和连接越多，越好；这表明进化过程的进展，其中从一个节点到另一个节点的每个箭头代表一个连接步骤，或进化命名法中的“亚种”。显示较少连接或根本没有连接的家谱图表明你的“交叉”没有产生有活力的后代。这个图上的孤立点表示可能具有良好“适应性”但未产生有活力后代的随机后代。
- en: '![](../Images/CH03_F08_Lanham.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F08_Lanham.png)'
- en: Figure 3.8 A genealogy plot showing `individuals` evolving using `crossover`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 展示使用“交叉”进化的个体家谱图
- en: Increase the number of `destinations` to `10`, and reduce the `population` and
    `generations` to `5`. Generating a genealogy plot while evolving is very expensive
    and difficult to read for large `populations`, so this notebook limits rendering
    those plots to `populations` under `10`. After you have done that, change the
    various `crossover` operators and then rerun the entire notebook with Run > Run
    All from the menu.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将“目的地”数量增加到`10`，并将“种群”和“代数”减少到`5`。在进化过程中生成家谱图非常昂贵且难以阅读，所以这个笔记本限制渲染那些图只针对`10`以下的“种群”。你完成这个操作后，更改各种“交叉”操作符，然后从菜单中选择运行
    > 运行全部来重新运行整个笔记本。
- en: Figure 3.9 shows an example of the genealogy plots for the three different `crossover`
    operations this notebook supports. You can see in the figure that, apparently,
    the best `crossover` operation for this example is the partially matched option.
    As you can see in the figure, the first operator is able to successfully generate
    more fit offspring, whereas the uniform partially matched operator can produce
    viable offspring but with a less significant increase in `fitness`. To see the
    differences more clearly, be sure to run the notebook and visualize them yourself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9展示了该笔记本支持的三个不同`交叉`操作的谱系图示例。从图中可以看出，对于这个例子来说，部分匹配选项似乎是最佳的`交叉`操作。如图所示，第一个算子能够成功生成更适应的后代，而均匀部分匹配算子可以产生可行的后代，但`适应度`的增加并不显著。为了更清楚地看到差异，请确保运行笔记本并自行可视化。
- en: '![](../Images/CH03_F09_Lanham.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F09_Lanham.png)'
- en: Figure 3.9 A comparison of genealogy plots of `crossover` operations
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 `交叉`操作的谱系图比较
- en: After completing this exercise, you should now have a sense of the differences
    between using the various genetic operators for `crossover` and `selection`. In
    future chapters, we look at various implementations of `mutation` operators when
    we get to applying EDL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你现在应该对使用各种遗传算子进行`交叉`和`选择`之间的差异有所了解。在未来的章节中，我们将探讨在应用EDL时`变异`算子的各种实现。
- en: 3.4.1 Learning exercises
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 学习练习
- en: 'Review the notebook by performing the following exercises:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下练习回顾笔记本：
- en: Alter the `selection` or `crossover` operators from the Colab form in figure
    3.6\. Try each of the operators to see which works best for this problem.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图3.6中的Colab表单中的`选择`或`交叉`算子进行更改。尝试每个算子，看看哪个最适合这个问题。
- en: See what effect altering the operators and hyperparameters (`population`, `crossover`,
    and `mutation` rate) has on the genealogy.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看改变算子和超参数（`种群`、`交叉`和`变异`率）对基因谱系有什么影响。
- en: Revisit notebook EDL_3_2_QueensGambit.ipynb and change the `selection` or `crossover`
    operator to see what effect this has on evolution.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾笔记本EDL_3_2_QueensGambit.ipynb，并更改`选择`或`交叉`算子，看看这会对进化产生什么影响。
- en: Building on the previous examples, we now look at another entertaining example
    in the final section of this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子基础上，我们现在来看本章最后部分的一个有趣例子。
- en: 3.5 Painting with the EvoLisa
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 使用EvoLisa绘画
- en: In 2008, Roger Johansson demonstrated the use of genetic algorithms to paint
    the Mona Lisa using a set of polygons. Figure 3.10 showcases the excellent results
    of that experiment during later stages of evolution. From the collection of images,
    you can see those results took almost a million `generations` to evolve.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年，罗杰·约翰逊展示了使用遗传算法通过一系列多边形绘制蒙娜丽莎的过程。图3.10展示了该实验在进化后期阶段的优秀结果。从这些图像集合中，你可以看到这些结果几乎需要一百万个`代`才能进化完成。
- en: '![](../Images/CH03_F10_Lanham.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F10_Lanham.png)'
- en: Figure 3.10 Example of EvoLisa output from Roger Johansson’s blog ([https://rogerjohansson.blog/](https://rogerjohansson.blog/2008/12/16/evolisa-optimizations-and-improved-quality/))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10展示了罗杰·约翰逊博客中的EvoLisa输出示例（[https://rogerjohansson.blog/](https://rogerjohansson.blog/2008/12/16/evolisa-optimizations-and-improved-quality/））
- en: EvoLisa is an example of a form of generative modeling, where the goal of the
    algorithm is to model or replicate the output of some process. In recent years,
    GM has exploded, with the inception of generative deep learning (GDL) in the generative
    adversarial networks (GANs). Starting in chapter 8, we take a closer look at GM
    and GDL with GANs and how those techniques can be improved upon with EDL.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: EvoLisa是一种生成建模的形式，算法的目标是模拟或复制某些过程的输出。近年来，生成模型（GM）随着生成深度学习（GDL）在生成对抗网络（GANs）中的出现而爆炸式增长。从第8章开始，我们将更深入地探讨GM和GDL与GANs，以及如何通过EDL改进这些技术。
- en: DEAP makes replicating the EvoLisa project quite easy, but it does require us
    to think of our simple `gene` sequences in a more complex and structured manner.
    Where previously, a `gene` was a single element in a list, we now need to think
    of a `gene` as a subset or group of elements in a list. Each of these subgroups
    of elements or `genes` defines one drawing polygon, with an `individual` having
    multiple `genes` of polygons used to draw on a canvas.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP使得复制EvoLisa项目变得相当容易，但它确实要求我们以更复杂和结构化的方式思考我们的简单`基因`序列。以前，一个`基因`是列表中的一个单一元素，我们现在需要将`基因`视为列表中元素的一个子集或一组。这些元素子组或`基因`中的每一个定义了一个绘图多边形，一个`个体`拥有多个用于在画布上绘制的多边形`基因`。
- en: 'Let’s get started on the next project: building the EvoLisa with DEAP and GA.
    As you can see from figure 3.10, getting good results could take a substantial
    amount of time. While we may not want to replicate those results, reviewing the
    process of creating complex `genes` is beneficial for later chapters and other
    projects you may work on.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始下一个项目：使用 DEAP 和 GA 构建 EvoLisa。如图 3.10 所示，获得良好的结果可能需要相当多的时间。虽然我们可能不想复制那些结果，但回顾创建复杂
    `基因` 的过程对后续章节和其他你可能工作的项目是有益的。
- en: Open EDL_3_5_EvoLisa.ipynb in your browser, and let’s begin. Consult the appendix
    if you need further assistance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 EDL_3_5_EvoLisa.ipynb，让我们开始。如需进一步帮助，请参阅附录。
- en: The first thing we need to understand is how a sequence of numbers can be converted
    to a `gene` that represents a drawing polygon or brush. Figure 3.11 outlines how
    we extract a set of attributes from a sequence and convert that into a drawing
    brush, where the first six elements represent three points on our simple polygon.
    After that, the next three denote color, and finally, the last element represents
    the alpha, or transparency. By introducing transparency, we allow each brush to
    overlay others, producing more complex features.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要理解的是，如何将数字序列转换为表示绘图多边形或笔刷的 `基因`。图 3.11 概述了如何从序列中提取一组属性并将其转换为绘图笔刷，其中前六个元素代表简单多边形的三个点。之后，接下来的三个表示颜色，最后，最后一个元素代表
    alpha，或透明度。通过引入透明度，我们允许每个笔刷叠加在其他笔刷之上，产生更复杂的功能。
- en: '![](../Images/CH03_F11_Lanham.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F11_Lanham.png)'
- en: Figure 3.11 Extracting a `gene` from a sequence of attributes
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 从属性序列中提取 `基因`
- en: In our previous scenarios, each attribute in a genetic sequence represented
    a single `gene`. Now, a subset of attributes comprises a single `gene` that represents
    a drawing brush. The following code listing takes a sequence of attributes (`genes`)
    and splits them by the `gene` length. This example is built to use a polygon as
    a drawing brush, but extra commented code demonstrates using other brushes, like
    a circle or rectangle.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的场景中，遗传序列中的每个属性代表一个单独的 `基因`。现在，属性的一个子集代表一个 `基因`，该 `基因` 表示一个绘图笔刷。以下代码列表接受一个属性序列（`基因`）并将它们按
    `基因` 长度分割。此示例构建为使用多边形作为绘图笔刷，但额外的注释代码演示了使用其他笔刷，如圆形或矩形。
- en: 'Listing 3.18 EDL_3_5_EvoList.ipynb: Extracting genes'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 EDL_3_5_EvoList.ipynb：提取基因
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Extracts and yields a single gene from a sequence of attributes
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从属性序列中提取并产生单个基因
- en: In the same code block, we can see the render code that draws each of the `genes`.
    This is complex code, which we break into two listings. The first listing shows
    the construction of the drawing canvas and the extraction of the `genes` to loop
    through.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的代码块中，我们可以看到绘制每个 `基因` 的渲染代码。这是一段复杂的代码，我们将其分为两个列表。第一个列表展示了绘制画布的构建和从 `基因` 中提取以循环的内容。
- en: 'Listing 3.19 EDL_3_5_EvoList.ipynb: Rendering genes'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 EDL_3_5_EvoList.ipynb：渲染基因
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Converts an individual to a NumPy array if list
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果是列表，将个体转换为 NumPy 数组
- en: ❷ Creates a canvas based on image size and adds a third dimension for colors
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据图像大小创建画布并添加一个颜色维度
- en: ❸ Not used for polyline brush
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 不用于多边形笔刷
- en: ❹ Uses the extract_genes generator to load genes
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 extract_genes 生成器加载基因
- en: ❺ Loops through the genes
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 遍历基因
- en: Listing 3.20 shows how each brush is defined from extracting the relevant `gene`
    attributes, where the first six values represent the three points or coordinates
    of the polygon to draw using the `cv2.fillPoly` function. Then, the extracted
    alpha is used to blend the brush (`overlay`) onto the canvas using the `cv2.addWeighted`
    function. Finally, after all the `gene` brushes have been drawn, the function
    returns the final canvas to be evaluated.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 展示了如何从提取的相关 `基因` 属性中定义每个笔刷，其中前六个值代表使用 `cv2.fillPoly` 函数绘制的多边形的三个点或坐标。然后，提取的
    alpha 用于使用 `cv2.addWeighted` 函数将笔刷（叠加）混合到画布上。最后，在绘制了所有 `基因` 笔刷之后，函数返回要评估的最终画布。
- en: 'Listing 3.20 EDL_3_5_EvoList.ipynb: Rendering `genes`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 EDL_3_5_EvoList.ipynb：渲染 `基因`
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Copies the base image and NumPy array
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 复制基础图像和 NumPy 数组
- en: ❷ Extracts and scales values to int for drawing
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从值中提取并缩放为整数以进行绘制
- en: ❸ Extracts color from the next points
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从下一个点提取颜色
- en: ❹ Draws the polygon
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 绘制多边形
- en: ❺ Extracts alpha
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 提取 alpha
- en: ❻ Combines the overlay with the canvas using alpha transparency
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用 alpha 透明度将叠加与画布合并
- en: ❼ Wraps it all in error handling, just in case
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 包裹在错误处理中，以防万一
- en: Figure 3.12 shows the result of a random `individual` being rendered using the
    `render_individual` function. You can generate this image by running all the notebook
    code via Runtime > Run All in the menu. Go ahead and do that now, as this notebook
    takes a substantial time to run completely.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12展示了使用`render_individual`函数渲染的随机`个体`的结果。您可以通过在菜单中选择“运行”>“运行所有”来运行所有笔记本代码以生成此图像。现在就去做吧，因为这个笔记本需要相当长的时间才能完全运行。
- en: '![](../Images/CH03_F12_Lanham.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F12_Lanham.png)'
- en: Figure 3.12 Target image and rendered image from a random `individual`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12目标图像和从随机`个体`渲染的图像
- en: For this demonstration, we use a classic image of the *Mona Lisa*. However,
    if you go to the top of the notebook, you can see other options to load various
    other images, from a stop sign to pictures of a celebrity, like Dwayne “the Rock”
    Johnson. If you want to use a different image, select from the Colab forms dropdown
    provided and then rerun the notebook.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们使用一幅经典的*蒙娜丽莎*画像。然而，如果您滚动到笔记本的顶部，您可以看到其他选项来加载各种其他图像，从停车标志到名人照片，比如道恩·强森（Dwayne
    “the Rock” Johnson）。如果您想使用不同的图像，请从提供的Colab表单下拉菜单中选择，然后重新运行笔记本。
- en: We can evaluate the `fitness` of the function using a simple pixel-wise comparison
    of color values from one NumPy array to another, using mean-squared error. The
    function in the following listing calculates the MSE between the rendered image
    and original image and then this error is returned as the `individual`’s `fitness`
    score. Keep in mind that the goal of EvoLisa is to minimize this error.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的像素级颜色值比较，从一个NumPy数组到另一个数组，使用均方误差来评估函数的`fitness`。以下列表中的函数计算渲染图像和原始图像之间的MSE，然后这个误差作为`individual`的`fitness`分数返回。请记住，EvoLisa的目标是最小化这个误差。
- en: 'Listing 3.21 EDL_3_5_EvoList.ipynb: The `fitness` and `evaluate` functions'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.21 EDL_3_5_EvoList.ipynb：`fitness`和`evaluate`函数
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Calculates MSE error from the render compared to the target
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从渲染结果与目标之间的比较计算MSE误差
- en: ❷ Renders the image
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 渲染图像
- en: ❸ Prints a point for each evaluation, a simple progress bar
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每次评估打印一个点，一个简单的进度条
- en: ❹ Returns MSE as the individual fitness
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回MSE作为个体的适应度
- en: The last parts we need to look at are the setup of the genetic operators, as
    shown in listing 3.22\. There are only a few new things going on here. We define
    a uniform function for generating float attributes from a uniform distribution
    defined by a lower and upper bound. This function is registers an `attr_float`
    operator and is used in the registration of the `creator.Individual` operator.
    Finally, we can see how the `evaluate` function is registered as the `evaluate`
    operator.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的最后部分是遗传算子的设置，如列表3.22所示。这里只有一些新的内容。我们定义了一个均匀函数，用于从定义的下限和上限的均匀分布中生成浮点属性。这个函数注册了一个`attr_float`算子，并在`creator.Individual`算子的注册中使用。最后，我们可以看到`evaluate`函数是如何注册为`evaluate`算子的。
- en: 'Listing 3.22 EDL_3_5_EvoList.ipynb: Setting up GA operators'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.22 EDL_3_5_EvoList.ipynb：设置GA算子
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ A uniform function generates individual
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 均匀函数生成个体
- en: ❷ Registers an attr_float operator for individual creating
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为个体创建注册attr_float算子
- en: ❸ Registers an individual created with attr_float operator
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用attr_float算子注册创建的个体
- en: ❹ Registers evaluate function
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注册`evaluate`函数
- en: Figure 3.13 shows the results of running this example for around 5,000 `generations`
    using a rectangle brush and the polyline brush. The code to implement a circle
    or rectangle brush is commented out but shown as an option for interested readers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13展示了使用矩形笔刷和多段线笔刷运行此示例大约5,000`代`的结果。实现圆形或矩形笔刷的代码已被注释，但作为对感兴趣读者的一个选项展示。
- en: '![](../Images/CH03_F13_Lanham.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F13_Lanham.png)'
- en: Figure 3.13 Example output of EvoLisa using different brush formats (rectangle
    and polyfill)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13使用不同笔刷格式（矩形和多边形填充）的EvoLisa示例输出
- en: Be sure to go back and use the Colab forms options provided in this example
    to alter the settings and then rerun the EvoLisa. Are you able to improve on how
    quickly EvoLisa can replicate an image? Be sure to also try adjusting the number
    of polygons (brushes/`genes`) EvoLisa is using.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要回到这个例子中提供的Colab表单选项，更改设置，然后重新运行EvoLisa。您能否提高EvoLisa复制图像的速度？请确保还尝试调整EvoLisa使用的多边形数量（笔刷/`基因`）。
- en: EvoLisa was a great demonstration of generative modeling with genetic algorithms
    just over a decade ago. Since that time, the advent of GDL has demonstrated far
    superior results using GANs. However, the EvoLisa demonstrates how we can encode
    and evolve sets of `genes` or instructions, which can define a much more complex
    process. While the applications appear similar, the underlying mechanism of the
    EvoLisa demonstrates a different form of optimization.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: EvoLisa是十多年前使用遗传算法进行生成建模的一个很好的演示。从那时起，GDL的出现已经使用GANs展示了远超预期的结果。然而，EvoLisa展示了我们如何编码和进化一系列`基因`或指令，这可以定义一个更复杂的过程。虽然应用看起来相似，但EvoLisa的底层机制展示了不同形式的优化。
- en: 3.5.1 Learning exercises
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 学习练习
- en: 'Complete the following exercises to build on the concepts discussed in this
    section:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习，以巩固本节讨论的概念：
- en: Switch to different images to see how well the evolution can copy the original.
    You may even want to add your own images.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到不同的图像，看看进化如何很好地复制原始图像。您甚至可能想添加自己的图像。
- en: Increase or decrease the number of `genes` and polygons used to render the image
    and then see what effect this has.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加或减少用于渲染图像的`基因`和多边形的数量，然后看看这有什么影响。
- en: Alter the `mutation`, `crossover`, and `population` to see what effect they
    have on evolution. Can you reduce the number of `generations` to a better facsimile
    of the selected image?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`变异`、`交叉`和`种群`，看看它们对进化有什么影响。您能否将`代数`的数量减少到所选图像的更好复制品？
- en: Try to produce the best facsimile you can. Feel free to contact the author to
    show your impressive results.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能地制作出最好的复制品。如有需要，请随时联系作者展示您令人印象深刻的结果。
- en: After reading this chapter, we now know the basics of evolutionary computation
    and the inner workings of genetic algorithms.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，我们现在了解了进化计算的基本原理以及遗传算法的内部工作原理。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Distributed Evolutionary Algorithms in Python (DEAP) is an excellent tool that
    incorporate a variety of evolutionary algorithms, including genetic methods. Genetic
    algorithm hyperparameters of `population` size, number of `generations`, `crossover`
    rate, and `mutation` rate can be adjusted to fit individual solutions. DEAP can
    be quickly configured and set up to tackle a variety of problems using basic building
    blocks:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的分布式进化算法（DEAP）是一个优秀的工具，它集成了各种进化算法，包括遗传方法。`种群`大小、`代数`数量、`交叉`率和`变异`率的遗传算法超参数可以根据个别解决方案进行调整。DEAP可以快速配置和设置，以使用基本构建块解决各种问题：
- en: '*The creator*—This holds the definition of the individual.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建者*—这包含个体的定义。'
- en: '*The toolbox*—This defines a set of helper functions and a place to define
    the genetic operators and operations.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工具箱*—这定义了一组辅助函数以及定义遗传算子和操作的位置。'
- en: '*The hall of fame*—This tracks the top successful individuals.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名人堂*—这跟踪最成功的个体。'
- en: '*Statistics*—These track basic metrics that can be used to evaluate the success
    of a `population`.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统计数据*—这些跟踪基本指标，可用于评估`种群`的成功率。'
- en: '*Historical objects*—These provide the ability to track custom or other external
    operations.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*历史对象*—这些提供跟踪自定义或其他外部操作的能力。'
- en: The Queen’s Gambit is a simulated chess problem that can be solved using genetic
    algorithms with DEAP.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《后翼弃兵》是一个模拟的棋局问题，可以使用DEAP中的遗传算法来解决。
- en: The traveling salesman problem, a classic complex path organization problem,
    can be solved using genetic algorithms with DEAP.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行商问题，一个经典的复杂路径组织问题，可以使用DEAP中的遗传算法来解决。
- en: Visualizing the `population` diversity of `fitness` using a histogram can identify
    evolutionary `populations` that may stagnate.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直方图可视化`种群`的`适应度`多样性可以识别可能停滞的进化`种群`。
- en: Genealogy plots can be read to determine how well the `crossover` operation
    is working during evolution. They provide insight into the evaluation and performance
    of various `selection` genetic operators on `population` evolution. The effectiveness
    of how well a particular `crossover` operation is performing can be evaluated
    with the use of a genealogy plot.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过家谱图可以了解在进化过程中`交叉`操作的效果如何。它们提供了对各种`选择`遗传算子对`种群`进化的评估和性能的洞察。可以使用家谱图评估特定`交叉`操作执行得有多好。
- en: An individual’s simulated genetic code can represent a process or order of operations.
    They can even implement a complex genetic structure to represent an order of complex
    operations for replicating or copying images.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个个体的模拟遗传密码可以代表一个过程或操作顺序。他们甚至可以实施一个复杂的遗传结构来表示复制或复制图像的复杂操作顺序。
