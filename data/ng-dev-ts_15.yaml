- en: Appendix A. An overview of ECMAScript
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A. ECMAScript 概述
- en: ECMAScript is a standard for scripting languages. ECMAScript syntax is implemented
    in several languages, the most popular implementation being JavaScript. The first
    edition of the ECMAScript specification was released in 1997, and the sixth edition
    was finalized in 2015\. This edition is known as ES6 or ES2015\. Lots of new features
    were introduced in ES6 compared to its predecessor ES5, and most of the syntax
    covered in this appendix is about the ES6 syntax. ES7 was finalized in 2016, and
    ES8 in 2017\. ES7 and ES8 didn’t introduce many new syntax elements, but we’ll
    cover the async/await syntax from ES8 at the end of this appendix.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 是一种脚本语言的规范。ECMAScript 语法被应用于多种语言中，其中最流行的实现是 JavaScript。ECMAScript
    规范的第一版于 1997 年发布，第六版于 2015 年最终确定。这一版被称为 ES6 或 ES2015。与它的前身 ES5 相比，ES6 引入了大量新特性，附录中涵盖的大部分语法都是关于
    ES6 语法的。ES7 于 2016 年最终确定，ES8 于 2017 年确定。ES7 和 ES8 并没有引入很多新的语法元素，但附录的末尾我们将介绍 ES8
    的 async/await 语法。
- en: At the time of writing, most web browsers fully support the ES6 specification,
    which introduced the most significant syntax additions. You can visit the ECMAScript
    compatibility site at [http://mng.bz/ao59](http://mng.bz/ao59) to see the current
    state of ES6 support. Even if the users of your app have older browsers, you can
    develop in ES6/7/8 today and use transpilers like Traceur, Babel, or TypeScript
    to turn code that uses the latest syntax into its ES5 version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，大多数网络浏览器完全支持引入了最显著语法添加的 ES6 规范。您可以通过访问 ECMAScript 兼容性网站 [http://mng.bz/ao59](http://mng.bz/ao59)
    来查看 ES6 支持的当前状态。即使您的应用程序的用户使用的是较旧的浏览器，您今天也可以在 ES6/7/8 中进行开发，并使用 Traceur、Babel
    或 TypeScript 等转换器将使用最新语法的代码转换为 ES5 版本。
- en: We assume you’re familiar with the ES5 syntax and APIs, and we’ll cover only
    selected new features introduced in the newer editions of ECMAScript. In this
    appendix, we’ll often compare the code snippets in ES5 with their ES6 equivalents,
    but ES6 doesn’t deprecate any old syntax, so you’ll be able to safely run legacy
    ES5 code in future web browsers or standalone JavaScript engines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您熟悉 ES5 语法和 API，我们将仅涵盖 ECMAScript 新版本中引入的一些新特性。在本附录中，我们经常将 ES5 中的代码片段与它们的
    ES6 等价物进行比较，但 ES6 并没有废弃任何旧语法，因此您可以在未来的网络浏览器或独立的 JavaScript 引擎中安全地运行遗留的 ES5 代码。
- en: A.1\. How to run the code samples
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1. 如何运行代码示例
- en: The code samples for this appendix come as JavaScript files with the .js extension.
    Typically, the code samples produce some output on the console, so you need to
    open the browser console to see the output. You can create a simple HTML file
    and include a particular .js file there using the `<script>` tag.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的代码示例以 .js 扩展名的 JavaScript 文件形式提供。通常，这些代码示例会在控制台产生一些输出，因此您需要打开浏览器控制台来查看输出。您可以创建一个简单的
    HTML 文件，并使用 `<script>` 标签在其中包含特定的 .js 文件。
- en: The other option is to use CodePen (see [https://codepen.io](https://codepen.io)).
    This site allows you to quickly write, test, and share apps that use HTML, CSS,
    and JavaScript. To save you some typing, we’ll provide CodePen links to most of
    the code samples so you can just follow the link, see the selected code sample
    in action, and modify it if you choose to do so. If a code sample produces output
    on the console, just click Console at the bottom of the CodePen window to see
    it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用 CodePen（请参阅 [https://codepen.io](https://codepen.io)）。该网站允许您快速编写、测试和分享使用
    HTML、CSS 和 JavaScript 的应用程序。为了节省您的输入，我们将提供大多数代码示例的 CodePen 链接，您可以只需点击链接，查看所选代码示例的实际效果，并根据需要对其进行修改。如果代码示例在控制台产生输出，只需点击
    CodePen 窗口底部的“控制台”即可查看。
- en: Let’s review some of the relatively new features of ECMAScript as they’re implemented
    in JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 ECMAScript 在 JavaScript 中实现的一些相对较新的特性。
- en: A.2\. Scope of variables and this
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2. 变量和 this 的作用域
- en: The scoping mechanism in ES5 is rather confusing. Regardless of where we declare
    a variable with the `var` keyword, the declaration is moved to the top of the
    execution context (for example, a function). This is called *hoisting* (see more
    on hoisting at [http://mng.bz/3x9w](http://mng.bz/3x9w)). The use of the `this`
    keyword is also not as straightforward as it is in languages like Java or C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ES5 中的作用域机制相当复杂。无论我们使用 `var` 关键字在哪里声明变量，声明都会被移动到执行上下文（例如，一个函数）的顶部。这被称为 *提升*（有关提升的更多信息，请参阅
    [http://mng.bz/3x9w](http://mng.bz/3x9w)）。`this` 关键字的用法也不像 Java 或 C# 等语言那样直接。
- en: ES6 eliminates this hoisting confusion (discussed in the next section) by introducing
    the `let` keyword, and the `this` confusion is cured by using arrow functions.
    Let’s look closer at the hoisting and `this` problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 通过引入 `let` 关键字消除了这种提升混淆（将在下一节讨论），并通过使用箭头函数解决了 `this` 混淆问题。让我们更仔细地看看提升和 `this`
    问题。
- en: A.2.1\. Hoisting of variable declarations
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.1\. 变量声明的提升
- en: 'In JavaScript, all variable declarations that use the `var` keyword are moved
    to the top of the execution context even if a variable is declared inside the
    code block. Look at the following simple example that declares the variable `i`
    inside the `for` loop but uses it outside as well:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，所有使用 `var` 关键字的变量声明都会被移动到执行上下文的顶部，即使变量是在代码块内部声明的。看看以下简单示例，它将变量
    `i` 声明在 `for` 循环内部，但也在外部使用：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running this code will print `i=10`. The variable `i` is still available outside
    the loop, even though it seems like it was meant to be used only inside the loop.
    JavaScript automatically hoists the variable declaration to the top.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将打印 `i=10`。变量 `i` 即使看起来似乎只应在循环内部使用，但在循环外部仍然可用。JavaScript 会自动将变量声明提升到顶部。
- en: In the preceding example, hoisting didn’t cause any harm, because there was
    only one variable named `i`. If two variables with the same name are declared
    inside and outside the function, however, this may result in confusing behavior.
    Consider [listing A.1](#app01ex01), which declares the variable `customer` on
    the global scope. A bit later, we’ll introduce another `customer` variable in
    the local scope, but for now let’s keep it commented out.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，提升没有造成任何损害，因为只有一个名为 `i` 的变量。然而，如果在函数内部和外部声明了具有相同名称的两个变量，这可能会导致令人困惑的行为。考虑[列表
    A.1](#app01ex01)，它在全局作用域中声明了变量 `customer`。稍后，我们将在局部作用域中引入另一个 `customer` 变量，但现在让我们将其注释掉。
- en: Listing A.1\. Hoisting a variable declaration
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.1\. 变量声明的提升
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The global variable `customer` is visible inside and outside the function,
    and running this code will print the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `customer` 在函数内部和外部都是可见的，运行此代码将打印以下内容：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Uncomment the `if` statement that declares and initializes the `customer` variable
    inside the curly braces. Now we have two variables with the same name—one on the
    global scope and another on the function scope. The console output is different
    now:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释在花括号内声明和初始化 `customer` 变量的 `if` 语句。现在我们有两个具有相同名称的变量——一个在全局作用域中，另一个在函数作用域中。控制台输出现在不同了：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The reason is that in ES5, variable declarations are hoisted to the top of
    the scope (the expression within the topmost parentheses), but variable initializations
    with values aren’t. When a variable is created, its initial value is `undefined`.
    The declaration of the second undefined `customer` variable was hoisted to the
    top of the expression, and `console.log()` printed the value of the variable declared
    inside the function, which has shadowed the value of the global variable `customer`.^([[1](#app01fn1)])
    Function declarations are hoisted as well, so we can invoke a function before
    it’s declared:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，在 ES5 中，变量声明被提升到作用域的顶部（最顶层括号内的表达式），但带有值的变量初始化则不会。当创建变量时，其初始值是 `undefined`。第二个未定义的
    `customer` 变量的声明被提升到表达式的顶部，`console.log()` 打印了函数内部声明的变量值，这覆盖了全局变量 `customer` 的值。^([[1](#app01fn1)])
    函数声明也会提升，因此我们可以在声明之前调用函数：
- en: ¹
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it on CodePen: [http://mng.bz/cK9y](http://mng.bz/cK9y).'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/cK9y](http://mng.bz/cK9y)。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the other hand, function expressions are considered variable initializations,
    so they aren’t hoisted. The following code snippet will produce `undefined` for
    the `doSomething` variable:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数表达式被视为变量初始化，因此不会提升。以下代码片段将为 `doSomething` 变量产生 `undefined`：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s see how ES6 can help us with scoping.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 ES6 如何帮助我们处理作用域问题。
- en: A.2.2\. Block scoping with let and const
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.2\. 使用 let 和 const 的块级作用域
- en: Declaring variables with the ES6 `let` keyword instead of `var` allows variables
    to have block scoping. The next listing shows an example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 的 `let` 关键字而不是 `var` 声明变量，允许变量具有块级作用域。下一个列表显示了一个示例。
- en: Listing A.2\. Variables with block scoping
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.2\. 块级作用域的变量
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now two `customer` variables have different scopes and values, and this program
    will print the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个 `customer` 变量具有不同的作用域和值，并且此程序将打印以下内容：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To put it simply, if we’re developing a new application, we don’t use `var`.
    We use `let` instead. The `let` keyword allows us to assign and reassign a value
    to a variable as many times as we want. The only exception to this rule is a `for`
    loop. Using `let` to declare a loop variable may cause performance issues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，如果我们正在开发一个新应用程序，我们不使用 `var`。我们使用 `let`。`let` 关键字允许我们多次将值分配给变量。唯一例外的是 `for`
    循环。使用 `let` 声明循环变量可能会导致性能问题。
- en: If we want to declare a variable that doesn’t change its value after its initialization,
    we declare it with the `const` keyword for constants. Constants also support block
    scope.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要声明一个初始化后其值不会改变的变量，我们使用 `const` 关键字来声明常量。常量也支持块作用域。
- en: The only difference between `let` and `const` is that the latter won’t allow
    the assigned value to be changed. The best practice is to start declaring variables
    with `const`; if we see that this value needs to change, we replace `const` with
    `let`. [Listing A.2](#app01ex02) should use `const` instead of `let`, because
    we never reassigned the values for both `customer` variables.^([[2](#app01fn2)])
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 和 `const` 之间的唯一区别是后者不允许更改分配的值。最佳实践是使用 `const` 开始声明变量；如果我们看到这个值需要改变，我们就将
    `const` 替换为 `let`。[列表 A.2](#app01ex02) 应该使用 `const` 而不是 `let`，因为我们从未重新分配过两个 `customer`
    变量的值.^([[2](#app01fn2)])'
- en: ²
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it on CodePen: [http://mng.bz/fkJd](http://mng.bz/fkJd)'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/fkJd](http://mng.bz/fkJd)
- en: A.3\. Template literals
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3\. 模板字面量
- en: ES6 introduces a new syntax for working with string literals, which can contain
    embedded expressions. This feature is known as *string interpolation*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了一种新的字符串字面量语法，它可以包含嵌入的表达式。这个特性被称为 *字符串插值*。
- en: 'In ES5 we’d use concatenation to create a string that contains string literals
    combined with the values of variables:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，我们会使用连接来创建一个包含字符串字面量和变量值的字符串：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In ES6, template literals are surrounded with backtick symbols, and we can
    embed expressions right inside a literal by placing them between the curly braces,
    prefixed with a dollar sign. In the next code snippet, the value of the variable
    `customerName` is embedded in the string literal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，模板字面量由反引号包围，我们可以在字面量中嵌入表达式，只需将它们放在大括号之间，并以前面加上美元符号即可。在下一个代码片段中，变量 `customerName`
    的值被嵌入到字符串字面量中：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output of this code is shown here:^([[3](#app01fn3)])
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下所示：^([[3](#app01fn3)])
- en: ³
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See it in CodePen at [http://mng.bz/Ey30](http://mng.bz/Ey30)
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/Ey30](http://mng.bz/Ey30)
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we embed the value of the variable `customerName`
    into the template literal, and then embed the value returned by the `getCustomer()`
    function. We can use any valid JavaScript expression between the curly braces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将变量 `customerName` 的值嵌入到模板字面量中，然后嵌入 `getCustomer()` 函数返回的值。我们可以在大括号之间放置任何有效的
    JavaScript 表达式，以嵌入任何有效的 JavaScript 表达式。
- en: A.3.1\. Multiline strings
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.1\. 多行字符串
- en: 'Strings can span multiple lines in our code. Using backticks, we can write
    multiline strings without the need to concatenate them or use the backslash character:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，字符串可以跨越多行。使用反引号，我们可以编写多行字符串，而无需将它们连接或使用反斜杠字符：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The resulting string will treat all spaces as part of the string, so the output
    will look like this:^([[4](#app01fn4)])
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串将把所有空格视为字符串的一部分，因此输出将看起来像这样：^([[4](#app01fn4)])
- en: ⁴
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/1SSP](http://mng.bz/1SSP).'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/1SSP](http://mng.bz/1SSP)。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A.4\. Optional parameters and default values
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4\. 可选参数和默认值
- en: 'In ES6, we can specify default values for function parameters (arguments) that
    will be used if no value is provided during function invocation. Say we’re writing
    a function to calculate tax, that takes two arguments: the annual income and the
    state where the person lives. If the state value isn’t provided, we want to use
    Florida as a default.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，我们可以为函数参数（参数）指定默认值，如果函数调用时没有提供值，则将使用这些默认值。比如说，我们正在编写一个计算税款的函数，它接受两个参数：年收入和居住州。如果未提供州值，我们希望使用佛罗里达州作为默认值。
- en: 'In ES5, we’d need to start the function body by checking whether the state
    value was provided; otherwise, we’d use Florida:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，我们需要在函数体开始时检查是否提供了状态值；如果没有提供，则使用佛罗里达州：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s what this code prints:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In ES6, we can specify the default value right in the function signature:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，我们可以直接在函数签名中指定默认值：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output looks similar:^([[5](#app01fn5)])
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来类似：^([[5](#app01fn5)])
- en: ⁵
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/U51z](http://mng.bz/U51z).'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/U51z](http://mng.bz/U51z)。
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Rather than providing a hardcoded value for an optional parameter, we can invoke
    a function that returns one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为可选参数提供一个硬编码的值，我们可以调用一个返回一个值的函数：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just keep in mind that the `getDefaultState()` function will be invoked each
    time we invoke `calcTaxES6()`, which may have performance consequences. This new
    syntax for optional parameters means we write less code and the code is easier
    to understand.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，每次我们调用`calcTaxES6()`时，都会调用`getDefaultState()`函数，这可能会产生性能影响。这种可选参数的新语法意味着我们编写的代码更少，代码也更容易理解。
- en: A.5\. Arrow function expressions, this, and that
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5\. 箭头函数表达式、this和that
- en: ES6 introduced arrow function expressions, which provide a shorter notation
    for anonymous functions and add lexical scope for the `this` variable. In some
    other programming languages (such as C# and Java) a similar syntax is called *lambda
    expressions*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了箭头函数表达式，它为匿名函数提供了一种更短的表示法，并为`this`变量添加了词法作用域。在某些其他编程语言（如C#和Java）中，类似的语法被称为*lambda表达式*。
- en: 'The syntax of arrow function expressions consists of arguments, the fat-arrow
    sign (`=>`), and the function body. If the function body is just one expression,
    we don’t even need curly braces. If a single-expression function returns a value,
    there’s no need to write the `return` statement—the result is returned implicitly:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数表达式的语法由参数、粗箭头符号（`=>`）和函数体组成。如果函数体只有一个表达式，我们甚至不需要大括号。如果单表达式函数返回一个值，则不需要编写`return`语句——结果会隐式返回：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The body of a multiline arrow function expression should be enclosed in curly
    braces and use the explicit `return` statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 多行箭头函数表达式的主体应该用大括号括起来，并使用显式的`return`语句：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If an arrow function doesn’t have any arguments, use empty parentheses:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果箭头函数没有任何参数，则使用空括号：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the function has just one argument, parentheses aren’t mandatory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数只有一个参数，则括号不是必需的：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the following code snippet, we pass arrow function expressions as arguments
    to an array’s `reduce()` method to calculate a sum, and `filter()` to print even
    numbers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将箭头函数表达式作为参数传递给数组的`reduce()`方法来计算总和，以及`filter()`来打印偶数：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that you’re familiar with the syntax of arrow functions, let’s see how they
    streamline working with the `this` object reference.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了箭头函数的语法，让我们看看它们如何简化与`this`对象引用的工作。
- en: In ES5, figuring out which object is referred to by the `this` keyword isn’t
    always a simple task. Search online for “JavaScript this and that,” and you’ll
    find multiple posts where people complain about `this` pointing to the “wrong”
    object. The `this` reference can have different values depending on how the function
    is invoked and whether strict mode was used (see the documentation for strict
    mode on the Mozilla Developer Network at [http://mng.bz/VNVL](http://mng.bz/VNVL)).
    We’ll illustrate the problem first, and then we’ll show you the solution offered
    by ES6.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，确定`this`关键字所引用的对象并不总是简单的事情。在网上搜索“JavaScript this and that”，你会找到多个帖子，人们抱怨`this`指向“错误”的对象。`this`引用的值可能因函数的调用方式和是否使用了严格模式而不同（请参阅Mozilla开发者网络上的严格模式文档[http://mng.bz/VNVL](http://mng.bz/VNVL)）。我们将首先说明这个问题，然后展示ES6提供的解决方案。
- en: Consider the code in the following listing that invokes the anonymous function
    every second. The function prints randomly generated prices for the stock symbol
    provided to the `StockQuoteGenerator ()` constructor function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码列表，它每秒调用一次匿名函数。该函数打印提供给`StockQuoteGenerator()`构造函数的股票符号的随机生成价格。
- en: Listing A.3\. `this` and `that`
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.3\. `this`和`that`
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The line that’s commented out in [listing A.3](#app01ex03) illustrates the wrong
    way of using `this` when a value is needed in the anonymous function that seemingly
    has the same `this` reference but doesn’t. If we hadn’t saved the value of `this`
    in `that`, and used `this.symbol` inside the anonymous function, it would print
    `undefined` instead of `IBM`. You’ll see the same behavior not only if a function
    is invoked inside `setInterval ()`, but if a function is invoked in any callback.
    Inside the callback, `this` would point at the global object, which is not the
    same as `this` defined by the `StockQuoteGenerator()` constructor function.^([[6](#app01fn6)])
    The other solution for ensuring that a function runs in a particular `this` object
    is to use the JavaScript `call()`, `apply()`, or `bind()` functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表A.3](#app01ex03)中注释掉的行展示了在匿名函数中需要值时，使用`this`的错误方式。如果我们没有在`that`中保存`this`的值，并在匿名函数中使用`this.symbol`，它将打印`undefined`而不是`IBM`。你会在函数在`setInterval
    ()`内部调用时看到这种行为，同样，如果函数在任何回调中调用，也会出现这种行为。在回调内部，`this`将指向全局对象，这与`StockQuoteGenerator()`构造函数定义的`this`不同.^([[6](#app01fn6)])
    确保函数在特定`this`对象中运行的另一种解决方案是使用JavaScript的`call()`、`apply()`或`bind()`函数。
- en: ⁶
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/cK70](http://mng.bz/cK70).'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen上查看：[http://mng.bz/cK70](http://mng.bz/cK70)。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re not familiar with the `this` problem in JavaScript, check out Richard
    Bovell’s article, “Understand JavaScript’s ‘this’ with Clarity, and Master It”
    at [http://mng.bz/ZQfz](http://mng.bz/ZQfz).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉JavaScript中的`this`问题，请查看Richard Bovell的文章，“清晰理解JavaScript的‘this’，并掌握它”在[http://mng.bz/ZQfz](http://mng.bz/ZQfz)。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing illustrates an arrow function solution that eliminates
    the need to store `this` in `that`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了消除在`that`中存储`this`的需要的箭头函数解决方案。
- en: Listing A.4\. Fat-arrow function
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.4\. 粗箭头函数
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Listing A.4](#app01ex04) will properly resolve the `this` reference. An arrow
    function that’s given as an argument to `setInterval ()` uses the `this` value
    of the enclosing context, so it will recognize `IBM` as the value of `this.symbol`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表A.4](#app01ex04)将正确解决`this`引用。作为`setInterval ()`参数传递的箭头函数使用封装上下文的`this`值，因此它将识别`IBM`为`this.symbol`的值。'
- en: A.6\. The rest operator
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.6\. 剩余操作符
- en: In ES5, writing a function with a variable number of parameters required using
    a special `arguments` object. This object is *similar* to an array, and it contains
    values corresponding to the arguments passed to a function. The implicit `arguments`
    variable could be treated as a local variable in any function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，编写具有可变数量参数的函数需要使用特殊的`arguments`对象。此对象类似于数组，并包含与传递给函数的参数相对应的值。隐式的`arguments`变量可以在任何函数中作为局部变量处理。
- en: The rest operator represents a variable number of arguments in a function, and
    it has to be the last one in the argument list. If the name of the function argument
    starts with the three dots, the function will get the rest of the arguments in
    an array. The ES6 rest operator is represented by three dots (...).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余操作符表示函数中的可变数量参数，并且它必须是参数列表中的最后一个。如果函数参数的名称以三个点开头，函数将获取剩余的参数作为一个数组。ES6的剩余操作符用三个点（...）表示。
- en: 'For example, we can pass multiple customers to a function using a single variable
    name with a rest operator:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用单个变量名和剩余操作符将多个客户传递给一个函数：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside this function, we can handle the `customers` data the same way we’d handle
    any array. Imagine that we need to write a function to calculate taxes that must
    be invoked with the first argument, `income`, followed by any number of arguments
    representing the names of the customers. [Listing A.5](#app01ex05) shows how we
    could process a variable number of arguments using first ES5 and then ES6 syntax.
    The `calcTaxES5()` function uses the object named `arguments`, and the `calcTaxES6()`
    function uses the ES6 rest operator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们可以像处理任何数组一样处理`customers`数据。想象一下，我们需要编写一个计算税款的函数，该函数必须使用第一个参数`income`调用，然后是任何数量的表示客户名称的参数。[列表A.5](#app01ex05)展示了如何使用ES5和ES6语法处理可变数量的参数。`calcTaxES5()`函数使用名为`arguments`的对象，而`calcTaxES6()`函数使用ES6剩余操作符。
- en: Listing A.5\. Rest operator
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.5\. 剩余操作符
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both functions, `calcTaxES5()` and `calcTaxES6()`, produce the same results:^([[7](#app01fn7)])
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数，`calcTaxES5()`和`calcTaxES6()`，产生相同的结果:^([[7](#app01fn7)])
- en: ⁷
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it on CodePen: [http://mng.bz/I2zq](http://mng.bz/I2zq).'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen上查看：[http://mng.bz/I2zq](http://mng.bz/I2zq)。
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There’s a difference in handling customers, though. Because the `arguments`
    object isn’t a real array, we had to create an array in the ES5 version by using
    the `slice()` and `call()` methods to extract the names of customers starting
    from the second element in `arguments`. The ES6 version doesn’t require us to
    use these tricks because the rest operator gives us a regular array of customers.
    Using the rest arguments made the code simpler and more readable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在处理客户方面存在差异。因为 `arguments` 对象不是一个真正的数组，所以在 ES5 版本中，我们必须使用 `slice()` 和 `call()`
    方法创建一个数组，以提取从 `arguments` 的第二个元素开始的客户名称。ES6 版本不需要我们使用这些技巧，因为剩余运算符给我们一个客户的常规数组。使用剩余参数使代码更简单、更易读。
- en: A.7\. The spread operator
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.7\. 扩展运算符
- en: 'The ES6 spread operator is also represented by three dots (...), like the rest
    operator, but whereas the rest operator can turn a variable number of parameters
    into an array, the spread operator can do the opposite: turn an array into a list
    of values or function parameters.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 扩展运算符也用三个点（...）表示，就像剩余运算符一样，但与剩余运算符可以将可变数量的参数转换为数组不同，扩展运算符可以执行相反的操作：将数组转换为值或函数参数的列表。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you see three dots on the right side of the equals sign, it’s a spread operator.
    Three dots on the left of the equals sign represent the rest operator.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到等号右侧有三个点，那就是扩展运算符。等号左侧的三个点表示剩余运算符。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Say we have two arrays and we need to add the elements of the second array
    to the end of the first one. With the spread operator, it’s one line of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个数组，我们需要将第二个数组的元素添加到第一个数组的末尾。使用扩展运算符，这只需要一行代码：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, the spread operator extracts each element of `myArray` and adds to the
    new array (here, the square brackets mean “create a new array”). We can also create
    a copy of an array as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，扩展运算符提取 `myArray` 的每个元素并将其添加到新数组中（这里，方括号表示“创建一个新数组”）。我们也可以按照以下方式创建数组的副本：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finding a maximum value in the array is also easy with the spread operator:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展运算符在数组中找到最大值也很简单：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In some cases, we want to clone an object. For example, suppose we have an object
    that stores the state of our app and want to create a new object when one of the
    state properties changes. We don’t want to mutate the original object but want
    to clone it with modification of one or more properties. One way to implement
    immutable objects is by using the `Object.assign()` function. The following listing
    creates a clone of the object first and then creates another clone, changing the
    `lastName` at the same time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们想要克隆一个对象。例如，假设我们有一个存储我们应用状态的对象，并且当状态属性之一发生变化时，我们想要创建一个新的对象。我们不想修改原始对象，但想通过修改一个或多个属性来克隆它。实现不可变对象的一种方法是通过使用
    `Object.assign()` 函数。以下列表首先创建对象的克隆，然后创建另一个克隆，同时更改 `lastName`。
- en: Listing A.6\. Cloning with `assign()`
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.6\. 使用 `assign()` 进行克隆
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The spread operator offers a more concise syntax for achieving the same goals,
    as you can see in the following listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下列表所示，扩展运算符提供了更简洁的语法来实现相同的目标。
- en: Listing A.7\. Cloning with `spread`
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.7\. 使用 `spread` 进行克隆
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our `myObject` has two properties: `name` and `lastName`. The line that clones
    `myObject` with modification of the `lastName` will still work even if we or someone
    else adds more properties to `myObject`.^([[8](#app01fn8)])'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `myObject` 有两个属性：`name` 和 `lastName`。即使我们或其他人向 `myObject` 添加更多属性，克隆 `myObject`
    并修改 `lastName` 的那行代码仍然会正常工作。^([[8](#app01fn8)])
- en: ⁸
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/X2pL](http://mng.bz/X2pL).'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/X2pL](http://mng.bz/X2pL)。
- en: In [chapter 15](kindle_split_024.xhtml#ch15), we show you how to work with immutable
    state objects. There, we use the spread operator to clone the state object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 15 章](kindle_split_024.xhtml#ch15) 中，我们向您展示了如何处理不可变状态对象。在那里，我们使用扩展运算符来克隆状态对象。
- en: A.8\. Generator functions
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.8\. 生成器函数
- en: When a browser executes a JavaScript function, it runs without interrupting
    its own flow to the end. But the execution of a *generator function* can be paused
    and resumed multiple times. A generator function can yield control to the calling
    script, which runs on the same thread.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器执行 JavaScript 函数时，它会连续运行，不会打断自己的流程。但生成器函数的执行可以被暂停和恢复多次。生成器函数可以将控制权交回调用脚本，该脚本在同一个线程上运行。
- en: 'As soon as the code in a generator function reaches the `yield` keyword, it
    gets suspended, and the calling script can resume the function’s execution by
    calling `next ()` on the generator. To turn a regular function into a generator,
    we need to place an asterisk between the `function` keyword and the function name.
    Here’s an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成器函数中的代码达到`yield`关键字，它就会被挂起，调用脚本可以通过在生成器上调用`next()`来恢复函数的执行。要将普通函数转换为生成器，我们需要在`function`关键字和函数名之间放置一个星号。以下是一个示例：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we invoke this function, it doesn’t immediately execute the function code
    but returns a special `Generator` object, which serves as an iterator. The following
    line won’t print anything:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，它不会立即执行函数代码，而是返回一个特殊的`Generator`对象，该对象作为迭代器。以下行不会打印任何内容：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To start executing the body of the function, we need to call the `next()` method
    on the generator:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始执行函数的主体，我们需要在生成器上调用`next()`方法：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After the preceding line, the `doSomething()` function will print “Started processing”
    and will be suspended because of the `yield` operator. Calling `next()` again
    will print “Resumed processing.”
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行之后，`doSomething()`函数将打印“Started processing”并由于`yield`运算符而暂停。再次调用`next()`将打印“Resumed
    processing。”
- en: Generator functions are useful when we need to write a function to produce a
    stream of data, but we want to control *when* to handle the next stream value.
    Imagine that we need a function to retrieve and produce stock prices for a specified
    stock symbol (such as IBM). If a stock price falls below a specified value (the
    limit price), we want to purchase this stock.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要编写一个函数来生成一系列数据，但又想控制何时处理下一个流值时，生成器函数非常有用。想象一下，我们需要一个函数来检索并生成指定股票符号（如IBM）的股票价格。如果股票价格低于指定的值（限制价格），我们想购买这只股票。
- en: The generator function in the next listing, `getStockPrice()`, emulates this
    scenario by generating random prices with `Math.random()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的生成器函数`getStockPrice()`通过使用`Math.random()`生成随机价格来模拟这种场景。
- en: Listing A.8\. `getStockPrice()`
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.8\. `getStockPrice()`
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If there’s a value after `yield`, it’s returned to the caller, but the function
    isn’t completed yet. Even though the `getStockPrice()` function has an infinite
    loop, it will yield (return) the price only if the script that invoked `getStockPrice()`
    calls `next()` on this generator, as in the following listing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`yield`之后有值，它会被返回给调用者，但函数还没有完成。即使`getStockPrice()`函数有一个无限循环，它也只有在调用`getStockPrice()`的脚本在生成器上调用`next()`时才会产生（返回）价格，如下面的列表所示。
- en: Listing A.9\. Invoking `getStockPrice ()`
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.9\. 调用`getStockPrice ()`
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Creates the Generator object but doesn’t execute the body of the getStockPrice()
    function**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建了生成器对象，但没有执行getStockPrice()函数的主体**'
- en: '***2* Sets the limit price to 15 and the initial price to 100 dollars**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将限制价格设置为15美元，初始价格设置为100美元**'
- en: '***3* Keeps requesting stock prices until they fall below 15 dollars**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 持续请求股票价格，直到它们低于15美元**'
- en: '***4* Requests the next price and prints it to the console**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 请求下一个价格并将其打印到控制台**'
- en: '***5* If the price falls below 15 dollars, the loop is over and the program
    prints a message about buying the stock and its price.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果价格低于15美元，循环结束，程序将打印一条关于购买股票及其价格的消息。**'
- en: 'Running [listing A.9](#app01ex09) will print something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[列表A.9](#app01ex09)将打印出类似以下内容：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the order of the messages. When we call the `next()` method on the `priceGenerator`,
    the execution of the suspended `getStockPrice()` method resumes at the line below
    `yield`, which prints `"resuming for IBM"`. Even though the control flow went
    outside the function and then came back, `getStockPrice()` remembers that the
    value of `symbol` was `IBM`. When the `yield` operator returns control to the
    outside script, it creates a snapshot of the stack so it can remember all the
    values of the local variables. When execution of the generator function is resumed,
    these values haven’t been lost.^([[9](#app01fn9)])
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意消息的顺序。当我们对`priceGenerator`调用`next()`方法时，暂停的`getStockPrice()`方法的执行会从`yield`下面的行恢复，打印出`"resuming
    for IBM"`。尽管控制流已经离开了函数，然后又回来，`getStockPrice()`仍然记得`symbol`的值是`IBM`。当`yield`运算符将控制权返回给外部脚本时，它会创建一个堆栈快照，以便记住所有局部变量的值。当生成器函数恢复执行时，这些值还没有丢失.^([[9](#app01fn9)])
- en: ⁹
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it on CodePen: [http://mng.bz/4d40](http://mng.bz/4d40).'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen上查看：[http://mng.bz/4d40](http://mng.bz/4d40).
- en: With generators, you can separate the implementation of certain operations (such
    as getting a price quote) and the consumption of the data produced by these operations.
    The consumer of the data lazily evaluates the results and decides if requesting
    more data is necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器，你可以将某些操作的实现（如获取价格报价）与这些操作产生的数据的消费分离。数据的消费者会懒加载评估结果，并决定是否需要请求更多数据。
- en: A.9\. Destructuring
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.9\. 解构
- en: Creating instances of objects means constructing them in memory. The term *destructuring*
    means taking objects apart. In ES5, we could deconstruct any object or a collection
    by writing a function to do it. ES6 introduces the destructuring assignment syntax
    that allows us to extract data from an object’s properties or an array in a simple
    expression by specifying a *matching pattern*. It’s easier to explain by example,
    which we’ll do next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象的实例意味着在内存中构建它们。术语 *解构* 指的是将对象拆分。在 ES5 中，我们可以通过编写一个函数来解构任何对象或集合。ES6 引入了解构赋值语法，允许我们通过指定一个
    *匹配模式*，以简单的表达式从对象的属性或数组中提取数据。通过示例更容易解释，我们将在下面进行演示。
- en: A.9.1\. Destructuring objects
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.9.1\. 对象解构
- en: 'Let’s say that a `getStock()` function returns a `Stock` object that has the
    attributes `symbol` and `price`. In ES5, if we wanted to assign the values of
    these attributes to separate variables, we’d need to create a variable to store
    the `Stock` object first, and then write two statements assigning the object attributes
    to corresponding variables:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个 `getStock()` 函数返回一个具有 `symbol` 和 `price` 属性的 `Stock` 对象。在 ES5 中，如果我们想要将这些属性的值分配给单独的变量，我们需要首先创建一个变量来存储
    `Stock` 对象，然后编写两个语句将对象属性分配给相应的变量：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Starting in ES6, we just need to write a matching pattern on the left and assign
    the `Stock` object to it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ES6 开始，我们只需要在左侧写一个匹配模式，并将 `Stock` 对象分配给它：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It’s a little unusual to see curly braces on the left of the equals sign, but
    this is part of the syntax of a matching expression. When we see curly braces
    on the left side, we think of them as a block of code and not the object literal.
    The following listing demonstrates getting the `Stock` object from the `getStock()`
    function and destructuring it into two variables.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号左侧看到花括号有点不寻常，但这匹配表达式的语法的一部分。当我们看到左侧的花括号时，我们会认为它们是一个代码块，而不是对象字面量。以下列表演示了从
    `getStock()` 函数获取 `Stock` 对象并将其解构为两个变量的过程。
- en: Listing A.10\. Destructuring an object
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.10\. 对象解构
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running that script will print the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该脚本将打印以下内容：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In other words, we bind a set of data (object properties, in this case) to a
    set of variables (`symbol` and `price`) in one assignment expression. Even if
    the `Stock` object had more than two properties, the preceding destructuring expression
    would still work because `symbol` and `price` would have matched the pattern.
    The matching expression lists only the variables for the object attributes we’re
    interested in.^([[10](#app01fn10)])
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在一个赋值表达式中将一组数据（在这种情况下是对象属性）绑定到一组变量（`symbol` 和 `price`）。即使 `Stock` 对象有超过两个属性，前面的解构表达式仍然有效，因为
    `symbol` 和 `price` 会匹配模式。匹配表达式只列出我们感兴趣的属性变量。^([[10](#app01fn10)])
- en: ^(10)
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See in CodePen: [http://mng.bz/CI47](http://mng.bz/CI47).'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/CI47](http://mng.bz/CI47)。
- en: '[Listing A.10](#app01ex10) works because the names of the variables are the
    same as the names of the `Stock` attributes. Let’s change `symbol` to `sym`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 A.10](#app01ex10) 之所以有效，是因为变量的名称与 `Stock` 属性的名称相同。让我们将 `symbol` 改为 `sym`：'
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we’ll get an error “symbol is not defined” because JavaScript doesn’t know
    that the object’s `symbol` attribute should be assigned to the variable `sym`.
    This is an example of a wrong matching pattern. If we really want to map the variable
    named `sym` to the `symbol` attribute, we introduce an alias name for `symbol`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们会得到一个错误“symbol 未定义”，因为 JavaScript 不知道对象的 `symbol` 属性应该分配给变量 `sym`。这是一个错误匹配模式的例子。如果我们真的想将名为
    `sym` 的变量映射到 `symbol` 属性，我们可以为 `symbol` 引入一个别名：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we provide more variables on the left than the number of attributes the
    object has, the extra variables will get the value `undefined`. If we add a `stockExchange`
    variable on the left, it will be initialized with `undefined`, because there’s
    no such attribute in the object returned by `getStock()`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在左侧提供比对象属性数量更多的变量，额外的变量将获得 `undefined` 的值。如果我们添加一个 `stockExchange` 变量在左侧，它将被初始化为
    `undefined`，因为 `getStock()` 返回的对象中没有这样的属性：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we apply the preceding destructuring assignment to the same `Stock` object,
    the console output will look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的解构赋值应用到同一个 `Stock` 对象上，控制台输出将如下所示：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we want the `stockExchange` variable to have a default value, such as `"NASDAQ"`,
    we could rewrite the destructuring expression like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 `stockExchange` 变量有一个默认值，例如 `"NASDAQ"`，我们可以将解构表达式重写如下：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can also destructure nested objects. [Listing A.11](#app01ex11) creates a
    nested object that represents Microsoft stock and passes it to the `printStockInfo()`
    function, which pulls the stock symbol and name of the stock exchange from this
    object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以解构嵌套对象。[列表 A.11](#app01ex11) 创建了一个表示微软股票的嵌套对象，并将其传递给 `printStockInfo()`
    函数，该函数从这个对象中提取股票符号和证券交易所的名称。
- en: Listing A.11\. Destructuring a nested object
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.11\. 解构嵌套对象
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* The nested object**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 嵌套对象**'
- en: '***2* Destructures a nested object to get the name of the stock exchange**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 解构嵌套对象以获取证券交易所的名称**'
- en: Running the preceding script will print the following:^([[11](#app01fn11)])
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本将打印以下内容：^([[11](#app01fn11)])
- en: ^(11)
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/Xauq](http://mng.bz/Xauq).'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/Xauq](http://mng.bz/Xauq)。
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Say we’re writing a function to handle a browser DOM event. In the HTML part,
    we invoke this function, passing the event object as an argument. The event object
    has multiple properties, but our handler function only needs the `target` property
    to identify the component that dispatched this event. The destructuring syntax
    makes it easy:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个处理浏览器 DOM 事件的函数。在 HTML 部分，我们调用此函数，并将事件对象作为参数传递。事件对象有多个属性，但我们的处理函数只需要
    `target` 属性来识别触发此事件的组件。解构语法使这变得很容易：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note the destructuring syntax `{target}` in the function argument.^([[12](#app01fn12)])
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数参数中的解构语法 `{target}`.^([[12](#app01fn12)])
- en: ^(12)
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it on CodePen: [http://mng.bz/Dj24](http://mng.bz/Dj24).'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 上查看：[http://mng.bz/Dj24](http://mng.bz/Dj24)。
- en: A.9.2\. Destructuring arrays
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.9.2\. 解构数组
- en: 'Array destructuring works much like object destructuring, but instead of curly
    brackets, we need to use square ones. Whereas in destructuring objects we need
    to specify variables that match object properties, with arrays, we specify variables
    that match arrays’ indexes. The following code extracts the values of two array
    elements into two variables:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构与对象解构的工作方式非常相似，但我们需要使用方括号而不是花括号。在解构对象时，我们需要指定与对象属性匹配的变量，而在数组中，我们指定与数组索引匹配的变量。以下代码将两个数组元素的值提取到两个变量中：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output will look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we wanted to extract the second element of this array, the matching pattern
    would look like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想提取这个数组的第二个元素，匹配的模式将如下所示：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If a function returns an array, the destructuring syntax turns it into a function
    with a multiple-value return, as shown in the `getCustomers()` function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回一个数组，解构语法将其转换为具有多个返回值的函数，如 `getCustomers()` 函数所示：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let’s combine array destructuring with rest parameters. Let’s say we have
    an array of multiple customers, but we want to process only the first two. The
    following code snippet shows how to do it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将数组解构与剩余参数结合起来。假设我们有一个包含多个客户的数组，但我们只想处理前两个。下面的代码片段展示了如何做到这一点：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here’s the console output produced by that code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该代码产生的控制台输出：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'On a similar note, we can pass the matching pattern with a rest parameter to
    a function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，我们可以将匹配模式与剩余参数一起传递给函数：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output will be the same:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将相同：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To summarize, the benefit of destructuring is that we can write less code when
    we need to initialize some variables with data that’s located in object properties
    or arrays.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，解构的优势在于，当我们需要用位于对象属性或数组中的数据初始化一些变量时，我们可以编写更少的代码。
- en: A.10\. Iterating with forEach(), for-in, and for-of
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.10\. 使用 forEach()、for-in 和 for-of 迭代
- en: We can loop through a collection of objects using different JavaScript keywords
    and APIs. In this section, we’ll show you how to use the `for-of` loop. We’ll
    compare it with `for-in` loops and the `forEach()` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的 JavaScript 关键字和 API 来遍历对象集合。在本节中，我们将向您展示如何使用 `for-of` 循环。我们将将其与 `for-in`
    循环和 `forEach()` 函数进行比较。
- en: A.10.1\. Using the forEach() method
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.10.1\. 使用 forEach() 方法
- en: 'Consider the following code, which iterates through an array of four numbers.
    This array also has an additional `description` property, which is ignored by
    `forEach()`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它遍历一个包含四个数字的数组。这个数组还有一个额外的 `description` 属性，它被 `forEach()` 忽略：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output of the script looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出如下所示：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `forEach()` method takes a function as an argument and properly prints four
    numbers from the array, ignoring the `description` property. Another limitation
    of `forEach()` is that it doesn’t allow us to break the loop prematurely. We’d
    need to use the `every()` method instead of `forEach()` or come up with some other
    hack to do that. Let’s see how the `for-in` loop can help.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()`方法接受一个函数作为参数，并正确地打印出数组中的四个数字，忽略`description`属性。`forEach()`的另一个限制是它不允许我们提前退出循环。我们需要使用`every()`方法代替`forEach()`，或者想出其他方法来实现这一点。让我们看看`for-in`循环如何帮助。'
- en: A.10.2\. Using the for-in loop
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.10.2\. 使用for-in循环
- en: 'The `for-in` loop iterates over the *property names* of objects and data collections.
    In JavaScript, any object is a collection of key-value pairs, where a *key* is
    a property name and a *value* is the property value. The array has five properties:
    four for the numbers, and `description`. Let’s iterate through the properties
    of this array:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环遍历对象和数据集合的*属性名*。在JavaScript中，任何对象都是键值对的集合，其中*键*是属性名，*值*是属性值。数组有五个属性：四个用于数字，一个用于`description`。让我们遍历这个数组的属性：'
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of the preceding code looks like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running this code through a debugger shows that each of these properties is
    a `string`. To see the actual values of the properties, print the array elements
    using the `numbersArray[n]` notation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调试器运行此代码显示，这些属性都是`string`类型。要查看属性的值，请使用`numbersArray[n]`表示法打印数组元素：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now the output looks like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出看起来像这样：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, the `for-in` loop iterated through all the properties, not only
    the data, which may not be what you need. Let’s try the new `for-of` syntax.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`for-in`循环遍历了所有属性，而不仅仅是数据，这可能不是您需要的。让我们尝试新的`for-of`语法。
- en: A.10.3\. Using for-of
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.10.3\. 使用for-of
- en: 'ES6 introduced the `for-of` loop, which allows us to iterate over data regardless
    of what other properties the data collection has. We can break out of this loop
    if need be by using the `break` keyword:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了`for-of`循环，允许我们遍历数据，而不管数据集合具有哪些其他属性。如果需要，我们可以使用`break`关键字跳出这个循环：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This script produces the following output:^([[13](#app01fn13)])
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本产生以下输出：^([[13](#app01fn13)])
- en: ^(13)
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/53DO](http://mng.bz/53DO).'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/53DO](http://mng.bz/53DO)。
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `for-of` loop works with any iterable object, including `Array`, `Map`,
    `Set`, and others. Strings are iterable as well. The following code prints the
    content of the string `"John"`, one character at a time:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-of`循环可以与任何可迭代对象一起工作，包括`Array`、`Map`、`Set`以及其他。字符串也是可迭代的。以下代码逐个字符打印字符串`"John"`的内容：'
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: A.11\. Classes and inheritance
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.11\. 类和继承
- en: Although ES5 supports object-oriented programming and inheritance, with ES6
    classes, the code is easier to read and write.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ES5支持面向对象编程和继承，但使用ES6类，代码更易于阅读和编写。
- en: 'In ES5, objects can be created either from scratch or by inheriting from other
    objects. By default, all JavaScript objects are inherited from `Object`. This
    object inheritance is implemented via a special property called `prototype`, which
    points at this object’s ancestor. This is called *prototypal inheritance*. For
    example, to create an `NJTax` object that inherits from the object `Tax`, we can
    write something like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，对象可以从头创建，也可以从其他对象继承。默认情况下，所有JavaScript对象都是从`Object`继承的。这种对象继承是通过一个称为`prototype`的特殊属性实现的，它指向这个对象的祖先。这被称为*原型继承*。例如，要创建一个从对象`Tax`继承的`NJTax`对象，我们可以编写如下内容：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Inherits NJTax from Tax**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 从Tax继承NJTax'
- en: 'ES6 introduced the keywords `class` and `extends` to bring the syntax in line
    with other object-oriented languages such as Java and C#. The ES6 equivalent of
    the preceding code is shown next:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了`class`和`extends`关键字，使语法与其他面向对象的语言（如Java和C#）保持一致。以下代码展示了上述代码的ES6等效版本：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `Tax` class is an ancestor or *superclass*, and `NJTax` is a descendant
    or *subclass*. We can also say that the `NJTax` class has the “is-a” relation
    with the class `Tax`. In other words, `NJTax` is a `Tax`. You can implement additional
    functionality in `NJTax`, but `NJTax` still “is a” or “is a kind of” `Tax`. Similarly,
    if we create an `Employee` class that inherits from `Person`, we can say that
    `Employee` is a `Person`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tax`类是一个祖先或*超类*，而`NJTax`是一个后代或*子类*。我们也可以说`NJTax`类与`Tax`类有“是”的关系。换句话说，`NJTax`是`Tax`。您可以在`NJTax`中实现额外的功能，但`NJTax`仍然是“是”或“是一种”`Tax`。同样，如果我们创建一个从`Person`继承的`Employee`类，我们可以说`Employee`是`Person`。'
- en: 'We can create one or more instances of the objects like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个或多个对象实例，如下所示：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* First instance of the Tax object**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Tax对象的第一个实例**'
- en: '***2* Second instance of the Tax object**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Tax对象的第二个实例**'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Class declarations aren’t hoisted. You need to declare the class first and then
    work with it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明不会提升。您需要先声明类，然后再使用它。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Each of these objects will have properties and methods that exist in the `Tax`
    class, but they will have different *state*; for example, the first instance could
    be created for a customer with an annual income of $50,000, and the second for
    a customer who earns $75,000\. Each instance would share the same copy of the
    methods declared in the `Tax` class, so there’s no duplication of code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象中的每一个都将具有存在于`Tax`类中的属性和方法，但它们将具有不同的*状态*；例如，第一个实例可能为年收入为50,000美元的客户创建，第二个为年收入为75,000美元的客户创建。每个实例都会共享在`Tax`类中声明的相同方法副本，因此没有代码重复。
- en: 'In ES5, we can also avoid code duplication by declaring methods, not inside
    the objects, but on their prototypes:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，我们也可以通过在对象原型上声明方法而不是在对象内部声明方法来避免代码重复：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'JavaScript remains a language with prototypal inheritance, but ES6 allows us
    to write more elegant code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript仍然是一种具有原型继承的语言，但ES6允许我们编写更优雅的代码：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Class member variables aren’t supported**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**类成员变量不受支持**'
- en: 'The ES6 syntax doesn’t allow you to declare class member variables, as you
    can in Java, C#, or TypeScript. The following syntax is *not* supported:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ES6语法不允许您声明类成员变量，就像在Java、C#或TypeScript中那样。以下语法*不支持*：
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A.11.1\. Constructors
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.11.1\. 构造函数
- en: 'During instantiation, classes execute the code placed in special methods called
    *constructors*. In languages like Java and C#, the name of the constructor must
    be the same as the name of the class; but in ES6, we specify the class’s constructor
    by using the `constructor` keyword:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化过程中，类会执行放置在特殊方法中的代码，这些方法称为*构造函数*。在Java和C#等语言中，构造函数的名称必须与类的名称相同；但在ES6中，我们通过使用`constructor`关键字来指定类的构造函数：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A constructor is a special method that’s executed only once: when the object
    is created. The `Tax` class doesn’t declare a separate class-level `income` variable,
    but creates it dynamically on the `this` object, initializing `this.income` with
    the values of the constructor argument. The `this` variable points at the instance
    of the current object.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个特殊的方法，它只执行一次：当对象被创建时。`Tax`类没有声明单独的类级`income`变量，而是在`this`对象上动态创建它，用构造函数参数的值初始化`this.income`。`this`变量指向当前对象的实例。
- en: 'The next example shows how we can create an instance of an `NJTax` subclass,
    providing the income of `50,000` to its constructor:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了我们如何创建`NJTax`子类的一个实例，向其构造函数提供`50,000`的收入：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output of this code snippet is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段的输出如下：
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Because the `NJTax` subclass doesn’t define its own constructor, the one from
    the `Tax` superclass is automatically invoked during the instantiation of `NJTax`.
    This wouldn’t be the case if a subclass defined its own constructor. You’ll see
    such an example in the next section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`NJTax`子类没有定义自己的构造函数，所以在`NJTax`实例化时，会自动调用`Tax`超类的构造函数。如果子类定义了自己的构造函数，则不会发生这种情况。您将在下一节中看到这样的示例。
- en: A.11.2\. The super keyword and the super function
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.11.2\. `super`关键字和`super`函数
- en: The `super()` function allows a subclass (descendant) to invoke a constructor
    from a superclass (ancestor). The `super` keyword is used to call a method defined
    in a superclass. [Listing A.12](#app01ex12) illustrates both `super()` and `super`.
    The `Tax` class has a `calculateFederalTax()` method, and its `NJTax` subclass
    adds the `calculateStateTax()` method. Both of these classes have their own versions
    of the `calcMinTax()` method.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()` 函数允许子类（后代）从超类（祖先）调用构造函数。`super` 关键字用于调用在超类中定义的方法。[列表 A.12](#app01ex12)
    说明了 `super()` 和 `super` 的用法。`Tax` 类有一个 `calculateFederalTax()` 方法，而它的 `NJTax`
    子类添加了 `calculateStateTax()` 方法。这两个类都有自己的 `calcMinTax()` 方法版本。'
- en: Listing A.12\. `super()` and `super`
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.12\. `super()` 和 `super`
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Running this code produces the following output:^([[14](#app01fn14)])
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出^([14](#app01fn14)))
- en: ^(14)
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([14](#app01fn14))
- en: ''
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/6e9S](http://mng.bz/6e9S).'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/6e9S](http://mng.bz/6e9S)。
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `NJTax` class has its own explicitly defined constructor with two arguments,
    `income` and `stateTaxPercent`, which we provide while instantiating `NJTax`.
    To make sure the constructor of `Tax` is invoked (it sets the `income` attribute
    on the object), we explicitly call it from the subclass’s constructor: `super(income)`.
    Without this line, running [listing A.12](#app01ex12) would report an error; we
    must call the constructor of a superclass from the derived constructor by calling
    the function `super()`.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`NJTax` 类有一个显式定义的构造函数，带有两个参数，`income` 和 `stateTaxPercent`，我们在实例化 `NJTax` 时提供这些参数。为了确保
    `Tax` 的构造函数被调用（它设置了对象的 `income` 属性），我们从子类的构造函数中显式调用它：`super(income)`。如果没有这一行，运行
    [列表 A.12](#app01ex12) 将会报告错误；我们必须通过调用函数 `super()` 从派生构造函数中调用超类的构造函数。'
- en: The other way of invoking code in superclasses is by using the `super` keyword.
    Both `Tax` and `NJTax` have the `calcMinTax()` methods. The one in the `Tax` superclass
    calculates the base minimum amount according to federal tax laws, whereas the
    subclass’s version of this method uses the base value and adjusts it. Both methods
    have the same signature, so we have a case for *method overriding*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 调用超类中代码的另一种方式是使用 `super` 关键字。`Tax` 和 `NJTax` 都有 `calcMinTax()` 方法。`Tax` 超类中的方法根据联邦税法计算基本最低金额，而子类版本的此方法使用基本值并对其进行调整。这两个方法具有相同的签名，因此我们有一个
    *方法重写* 的例子。
- en: By calling `super.calcMinTax()`, we ensure that the base federal tax is taken
    into account for calculating state tax. If we didn’t call `super.calcMinTax()`,
    the subclass’s version of the `calcMinTax()` method would apply. Method overriding
    is often used to replace the functionality of the method in the superclass without
    changing its code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `super.calcMinTax()`，我们确保在计算州税时考虑了基本联邦税。如果我们没有调用 `super.calcMinTax()`，子类的
    `calcMinTax()` 方法版本将适用。方法重写通常用于在不更改其代码的情况下替换超类中方法的函数。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A warning about classes and inheritance**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于类和继承的警告**'
- en: ES6 classes are just syntactic sugar that increases code readability. Under
    the hood, JavaScript still uses prototypal inheritance, which allows you to replace
    the ancestor dynamically at runtime, whereas a class can have only one ancestor.
    Try to avoid creating deep inheritance hierarchies, because they reduce the flexibility
    of your code and complicate refactoring if it’s needed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 类仅是提高代码可读性的语法糖。在底层，JavaScript 仍然使用原型继承，这允许你在运行时动态地替换祖先，而一个类只能有一个祖先。尽量避免创建深层继承层次，因为它们会降低代码的灵活性，并在需要时使重构变得复杂。
- en: Although using the `super` keyword lets you invoke code in the ancestor, you
    should try to avoid using it to avoid tight coupling between the descendant and
    ancestor objects. The less the descendant knows about its ancestor, the better.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `super` 关键字可以让你调用祖先中的代码，但你应该尽量避免使用它，以避免后代和祖先对象之间的紧密耦合。后代对祖先了解得越少，越好。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A.11.3\. Static variables
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.11.3\. 静态变量
- en: If we need a class property that’s shared by multiple class instances, we need
    to create it outside of the class declaration. In [listing A.13](#app01ex13),
    the static variable `counter` is visible from both instances of the object `A`
    by invoking the `printCounter()` method. But if we try to access the variable
    `counter` on the instance level, it’ll be undefined.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个由多个类实例共享的类属性，我们需要在类声明之外创建它。在 [列表 A.13](#app01ex13) 中，静态变量 `counter`
    通过调用 `printCounter()` 方法可以从对象 `A` 的两个实例中访问。但如果我们尝试在实例级别访问变量 `counter`，它将是未定义的。
- en: Listing A.13\. Sharing a class property
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.13\. 共享类属性
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: That code produces this output:^([[15](#app01fn15)])
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码产生以下输出：^[[15](#app01fn15)])
- en: ^(15)
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(15)]
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/lCXD](http://mng.bz/lCXD).'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/lCXD](http://mng.bz/lCXD)。
- en: '[PRE80]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: A.11.4\. Getters, setters, and method definitions
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.11.4. 访问器、设置器和方法定义
- en: 'The syntax for the object’s getter and setter methods isn’t new in ES6, but
    let’s review it before going on to the new syntax for defining methods. Setters
    and getters bind functions to object properties. Consider the declaration and
    the use of the object literal `Tax`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的获取器和设置器方法的语法在 ES6 中并不新，但在介绍定义新语法的语法之前，让我们先回顾一下。设置器和获取器将函数绑定到对象属性。考虑对象字面量
    `Tax` 的声明和使用：
- en: '[PRE81]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you assign and retrieve the value of `income` using dot notation,
    as if it were a declared property of the `Tax` object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您使用点符号分配和检索 `income` 的值，就像它是 `Tax` 对象的一个已声明的属性一样。
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In ES5, we’d need to use the `function` keyword, such as `calculateTax = function(){...}`.
    With ES6, we can skip the `function` keyword in any method definition:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，我们需要使用 `function` 关键字，例如 `calculateTax = function(){...}`。在 ES6 中，我们可以在任何方法定义中省略
    `function` 关键字：
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The output of that code comes next:^([[16](#app01fn16)])
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码的输出如下：^[[16](#app01fn16)])
- en: ^(16)
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(16)]
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/5729](http://mng.bz/5729).'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 CodePen 中查看：[http://mng.bz/5729](http://mng.bz/5729)。
- en: '[PRE83]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Getters and setters offer a convenient syntax for working with properties. For
    example, if we decide to add some validation code to the `income` getter, the
    scripts using the `Tax.income` notation won’t need to be changed. The bad part
    is that ES6 doesn’t support private variables in classes, so nothing stops programmers
    from accessing the variable used in a getter or setter (such as `taxableIncome`)
    directly. We’ll talk about hiding (encapsulating) variables in [section A.13](#app01lev1sec13).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器为处理属性提供了一个方便的语法。例如，如果我们决定在 `income` 获取器中添加一些验证代码，使用 `Tax.income` 语句的脚本就不需要更改。坏处是
    ES6 不支持类中的私有变量，因此没有任何东西阻止程序员直接访问在获取器或设置器中使用的变量（例如 `taxableIncome`）。我们将在[第 A.13
    节](#app01lev1sec13)中讨论隐藏（封装）变量。
- en: A.12\. Asynchronous processing
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.12. 异步处理
- en: To arrange asynchronous processing in previous implementations of ECMAScript,
    we had to use *callbacks*, functions that are given as arguments to another function
    for invocation. Callbacks can be called synchronously or asynchronously.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 的先前实现中安排异步处理时，我们必须使用 *回调*，即作为另一个函数参数传递的函数。回调可以同步或异步调用。
- en: Earlier, we passed a callback to the `forEach()` method for synchronous invocation.
    In making AJAX requests to the server, we pass a callback function to be invoked
    asynchronously when the result arrives from the server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们向 `forEach()` 方法传递了一个回调函数以进行同步调用。在向服务器发送 AJAX 请求时，我们传递一个回调函数，当从服务器收到结果时异步调用该函数。
- en: A.12.1\. A callback hell
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.12.1. 回调地狱
- en: Let’s consider an example of getting data about some ordered products from the
    server. It starts with an asynchronous call to the server to get the information
    about the customers, and then for each customer we’ll need to make another call
    to get the orders. For each order, we need to get products, and the final call
    will get the product details.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个从服务器获取有关一些已订购产品的数据的例子。它从一个异步调用开始，以获取客户信息，然后对于每个客户，我们需要再次调用以获取订单。对于每个订单，我们需要获取产品，最后的调用将获取产品详情。
- en: In asynchronous processing, we don’t know when each of these operations will
    complete, so we need to write callback functions that are invoked when the previous
    one is complete. Let’s use the `setTimeout()` function to emulate delays, as if
    each operation requires one second to complete. [Figure A.1](#app01fig01) shows
    what this code may look like.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步处理中，我们不知道这些操作中的每一个何时完成，因此我们需要编写回调函数，在先前的操作完成后调用。让我们使用 `setTimeout()` 函数来模拟延迟，就像每个操作需要一秒钟来完成。[图
    A.1](#app01fig01) 展示了这段代码可能的样子。
- en: Figure A.1\. Callback hell or pyramid of doom
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.1. 回调地狱或死亡金字塔
- en: '![](Images/afig01_alt.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/afig01_alt.jpg)'
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using callbacks is considered an anti-pattern, also known as Pyramid of Doom,
    as seen in [figure A.1](#app01fig01) on the left. In our code sample we had four
    callbacks, and this level of nesting makes the code hard to read. In real-world
    apps, the pyramid may quickly grow, making the code very hard to read and debug.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调被认为是一种反模式，也称为死亡金字塔，如左边的[图 A.1](#app01fig01) 所示。在我们的代码示例中，我们有四个回调，这种嵌套级别使得代码难以阅读。在实际应用中，金字塔可能会迅速增长，使得代码非常难以阅读和调试。
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Running the code in [figure A.1](#app01fig01) will print the following messages
    with one-second delays:^([[17](#app01fn17)])
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图A.1](#app01fig01)中运行代码将每隔一秒打印以下消息：^([17](#app01fn17))。
- en: ^(17)
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([17](#app01fn17))
- en: ''
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/DAX5](http://mng.bz/DAX5).'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/DAX5](http://mng.bz/DAX5)。
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: A.12.2\. ES6 promises
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.12.2\. ES6承诺
- en: When you press the button on your coffee machine, you don’t get a cup of coffee
    that very second. You get a promise that you’ll get a cup of coffee sometime later.
    If you didn’t forget to provide the water and the ground coffee, the promise will
    be *resolved*, and you can enjoy the coffee in a minute or so. If your coffee
    machine is out of water or coffee, the promise will be *rejected*. The entire
    process is asynchronous, and you can do other things while your coffee is being
    brewed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下咖啡机上的按钮时，你不会立即得到一杯咖啡。你得到一个承诺，你将在稍后得到一杯咖啡。如果你没有忘记提供水和磨碎的咖啡，这个承诺将被*解决*，你可以在大约一分钟后享用咖啡。如果你的咖啡机没有水或咖啡，这个承诺将被*拒绝*。整个过程是异步的，你可以在咖啡被煮制的同时做其他事情。
- en: 'JavaScript promises allow us to avoid nested calls and make the async code
    more readable. The `Promise` object represents an eventual completion or failure
    of an async operation. After the `Promise` object is created, it waits and listens
    for the result of an asynchronous operation and lets us know if it succeeded or
    failed so we can proceed with the next steps accordingly. The `Promise` object
    represents the future result of an operation, and it can be in one of these states:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript承诺允许我们避免嵌套调用，并使异步代码更易于阅读。`Promise`对象代表异步操作的最终完成或失败。在创建`Promise`对象之后，它将等待并监听异步操作的结果，并通知我们操作是成功还是失败，以便我们可以相应地继续下一步。`Promise`对象代表操作的将来结果，它可以处于以下状态之一：
- en: '***Fulfilled*—** The operation successfully completed.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Fulfilled*—** 操作成功完成。'
- en: '***Rejected*—** The operation failed and returned an error.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Rejected*—** 操作失败并返回错误。'
- en: '***Pending*—** The operation is in progress, neither fulfilled nor rejected.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Pending*—** 操作正在进行中，既未完成也未拒绝。'
- en: 'We can instantiate a `Promise` object by providing two functions to its constructor:
    the function to call if the operation is fulfilled, and the function to call if
    the operation is rejected. Consider a script with a `getCustomers()` function,
    shown in the following listing.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向其构造函数提供两个函数来实例化一个`Promise`对象：一个是在操作成功时调用的函数，另一个是在操作失败时调用的函数。考虑一个包含`getCustomers()`函数的脚本，如下所示。
- en: Listing A.14\. Using a promise
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.14\. 使用承诺
- en: '[PRE85]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Gets the customer**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取客户**'
- en: '***2* Invoked if an error occurs**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 发生错误时调用**'
- en: '***3* Invoked when the promise is fulfilled**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当承诺得到满足时调用**'
- en: '***4* Invoked if the promise is rejected**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当承诺被拒绝时调用**'
- en: The `getCustomers()` function returns a `Promise` object, which is instantiated
    with a function that has `resolve` and `reject` as the constructor’s arguments.
    In the code, we invoke `resolve()` if we receive the customer information. For
    simplicity, `setTimeout()` emulates an asynchronous call that lasts one second.
    We also hardcode the `success` flag to be `true`. In a real-world scenario, we
    could make a request with the `XMLHttpRequest` object and invoke `resolve()` if
    the result was successfully retrieved or `reject()` if an error occurred.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCustomers()`函数返回一个`Promise`对象，该对象使用具有`resolve`和`reject`作为构造函数参数的函数进行实例化。在代码中，如果我们收到客户信息，我们将调用`resolve()`。为了简单起见，`setTimeout()`模拟了一个持续一秒的异步调用。我们还硬编码了`success`标志为`true`。在现实世界的场景中，我们可以使用`XMLHttpRequest`对象发出请求，如果结果成功检索，则调用`resolve()`，如果发生错误，则调用`reject()`。'
- en: 'At the bottom of [listing A.14](#app01ex14), we attach `then()` and `catch()`
    methods to the `Promise()` instance. Only one of these two will be invoked. When
    we call `resolve ("John Smith")` from inside the function, it results in the invocation
    of the `then()` that received `"John Smith"` as its argument. If we changed the
    value of `success` to `false`, the `catch()` method would be called with the argument
    containing `"Can''t get customers"`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表A.14](#app01ex14)的底部，我们将`then()`和`catch()`方法附加到`Promise()`实例上。这两个方法中只有一个会被调用。当我们从函数内部调用`resolve("John
    Smith")`时，它会导致接收`"John Smith"`作为其参数的`then()`被调用。如果我们将`success`的值改为`false`，`catch()`方法将被调用，其参数包含`"Can't
    get customers"`：
- en: '[PRE86]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note that the message `"Invoked getCustomers. Waiting for results"` is printed
    before `"John Smith"`. This proves that the `getCustomers()` function worked asynchronously.^([[18](#app01fn18)])
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在打印`"John Smith"`之前，会打印消息`"Invoked getCustomers. Waiting for results"`。这证明了`getCustomers()`函数是异步工作的.^([[18](#app01fn18)])
- en: ^(18)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/5rf3](http://mng.bz/5rf3).'
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/5rf3](http://mng.bz/5rf3).
- en: Each promise represents one asynchronous operation, and we can chain them to
    guarantee a particular order of execution. Let’s add a `getOrders()` function
    in the following listing that can find the orders for a provided customer, and
    chain `getOrders()` with `getCustomers()`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 每个promise代表一个异步操作，我们可以将它们连接起来以确保特定的执行顺序。让我们在下面的列表中添加一个`getOrders()`函数，它可以找到提供的客户的订单，并将`getOrders()`与`getCustomers()`连接起来。
- en: Listing A.15\. Chaining promises
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.15\. 连接promise
- en: '[PRE87]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* Invoked when the customer is successfully obtained**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当成功获取客户时调用**'
- en: '***2* Invoked when the order for a customer is successful**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当客户的订单成功时调用**'
- en: '***3* Chains with getOrders()**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 与getOrders()连接**'
- en: '***4* Handles errors**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理错误**'
- en: This code not only declares and chains two functions but also demonstrates how
    we can print intermediate results on the console. The output of [listing A.15](#app01ex15)
    follows (note that the customer returned from `getCustomers()` was properly passed
    to `getOrders()`):^([[19](#app01fn19)])
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不仅声明并连接了两个函数，还展示了我们如何在控制台打印中间结果。列表A.15的输出如下（注意，从`getCustomers()`返回的客户被正确地传递给了`getOrders()`）:^([[19](#app01fn19)])
- en: ^(19)
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19)
- en: ''
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/6z5k](http://mng.bz/6z5k).'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/6z5k](http://mng.bz/6z5k).
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We can chain multiple function calls using `then()` and have just one error-handling
    script for all chained invocations. If an error occurs, it will be propagated
    through the entire chain of `then`s until it finds an error handler. No `then`s
    will be invoked after the error.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`then()`链式调用多个函数调用，并为所有链式调用只有一个错误处理脚本。如果发生错误，它将通过整个`then`链传播，直到找到一个错误处理器。错误发生后，不会调用任何`then`。
- en: 'Changing the value of the `success` variable to `false` in [listing A.15](#app01ex15)
    will result in printing the message `"Can''t get customers"`, and the `getOrders()`
    method won’t be called. If we remove these console prints, the code that retrieves
    customers and orders looks clean and is easy to understand:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表A.15](#app01ex15)中的`success`变量的值更改为`false`将导致打印消息`"Can't get customers"`，并且`getOrders()`方法不会被调用。如果我们移除这些控制台打印，检索客户和订单的代码看起来干净且易于理解：
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Adding more `then`s doesn’t make this code less readable (compare it with the
    pyramid of doom shown in [figure A.1](#app01fig01)).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多的`then`不会使这段代码的可读性降低（将其与图A.1中显示的“灾难金字塔”进行比较）。
- en: A.12.3\. Resolving several promises at once
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.12.3\. 同时解析多个promise
- en: Another case to consider is asynchronous functions that don’t depend on each
    other. Say we need to invoke two functions in no particular order, but we need
    to perform some action only after both of them are complete. The `Promise` object
    has an `all()` method that takes an iterable collection of promises and executes
    (resolves) all of them. Because the `all()` method returns a `Promise` object,
    we can add `then()` or `catch()` (or both) to the result.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的案例是相互之间不依赖的异步函数。比如说，我们需要以任意顺序调用两个函数，但只有在它们都完成之后，我们才需要执行某些操作。`Promise`对象有一个`all()`方法，它接受一个promise的可迭代集合，并执行（解析）所有这些promise。因为`all()`方法返回一个`Promise`对象，所以我们可以将`then()`或`catch()`（或两者）添加到结果中。
- en: 'Imagine a web portal that needs to make several asynchronous calls to get the
    weather, stock market news, and traffic information. If we want to display the
    portal page only after all of these calls have completed, `Promise.all()` is what
    we need:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个需要执行多个异步调用来获取天气、股市新闻和交通信息的网络门户。如果我们想在所有这些调用完成之后才显示门户页面，`Promise.all()`就是我们所需要的：
- en: '[PRE90]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Keep in mind that `Promise.all()` resolves only after all of the promises resolve.
    If one of them rejects, the control goes to the `catch()` handler.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`Promise.all()`只有在所有promise都解析后才会解析。如果其中一个拒绝，控制权将转到`catch()`处理器。
- en: Compared to callback functions, promises make our code more linear and easier
    to read, and they represent multiple states of an application. On the negative
    side, promises can’t be canceled. Imagine an impatient user who clicks a button
    several times to get some data from the server. Each click creates a promise and
    initiates an HTTP request. There’s no way to keep only the last request and cancel
    the uncompleted ones.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调函数相比，promises 使我们的代码更加线性且易于阅读，并且它们代表了应用程序的多个状态。在负面方面，promises 不能被取消。想象一个没有耐心的用户多次点击按钮以从服务器获取一些数据。每次点击都会创建一个
    promise 并发起一个 HTTP 请求。没有方法可以只保留最后一个请求并取消未完成的请求。
- en: The next step in the evolution of a `Promise` object is an `Observable` object,
    which should be introduced in future ECMAScript specifications; in [chapter 5](kindle_split_014.xhtml#ch05),
    we explain how to use it today.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象进化的下一步是 `Observable` 对象，这将在未来的 ECMAScript 规范中介绍；在 [第 5 章](kindle_split_014.xhtml#ch05)
    中，我们解释了如何今天使用它。'
- en: The JavaScript code with promises is easier to read, but if you look at the
    `then()` function carefully, you’ll see that you still have to provide a callback
    function that will be called sometime later. The keywords `async` and `await`
    are the next step in the evolution of the JavaScript syntax for asynchronous programming.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 promises 的 JavaScript 代码更容易阅读，但如果仔细查看 `then()` 函数，你会看到你仍然需要提供一个稍后将被调用的回调函数。关键字
    `async` 和 `await` 是 JavaScript 异步编程语法的下一进化步骤。
- en: A.12.4\. async and await
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.12.4\. async 和 await
- en: 'The keywords `async` and `await` were introduced in ES8 (a.k.a. ES2017). They
    allow us to treat functions returning promises as if they’re synchronous. The
    next line of code is executed only when the previous one completes. It’s important
    to note that the waiting for the asynchronous code to complete happens in the
    background and doesn’t block the execution of other parts of the program:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `async` 和 `await` 是在 ES8（也称为 ES2017）中引入的。它们允许我们将返回 promises 的函数当作同步函数来处理。下一行代码只有在上一行代码完成后才会执行。重要的是要注意，等待异步代码完成是在后台发生的，并且不会阻塞程序其他部分的执行：
- en: '`async` is a keyword that marks a function that returns a promise.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 是一个关键字，用于标记返回 promise 的函数。'
- en: '`await` is a keyword that we place right before the invocation of the `async`
    function. This instructs the JavaScript engine to not proceed to the next line
    until the asynchronous function either returns the result or throws an error.
    The JavaScript engine will internally wrap the expression on the right of the
    `await` keyword into a promise and the rest of the method into a `then()` callback.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await` 是一个关键字，我们将其放置在 `async` 函数调用之前。这指示 JavaScript 引擎在异步函数返回结果或抛出错误之前，不要继续执行下一行。JavaScript
    引擎将 `await` 关键字右侧的表达式内部包装成一个 promise，并将方法的其他部分包装成一个 `then()` 回调函数。'
- en: To illustrate the use of `async` and `await` keywords, the following listing
    reuses the functions `getCustomers()` and `getOrders()` that use promises inside
    to emulate asynchronous processing.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `async` 和 `await` 关键字的使用，以下列表重用了 `getCustomers()` 和 `getOrders()` 函数，这些函数内部使用
    promises 来模拟异步处理。
- en: Listing A.16\. Declaring two functions that use promises
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.16\. 声明使用 promises 的两个函数
- en: '[PRE91]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We want to chain these function calls, but this time we won’t be using the `then()`
    calls as we did with promises. We’ll create a new function, `getCustomersOrders()`,
    that internally invokes `getCustomers()`, and when it completes, `getOrders()`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要链式调用这些函数调用，但这次我们不会像处理 promises 那样使用 `then()` 调用。我们将创建一个新的函数 `getCustomersOrders()`，它内部调用
    `getCustomers()`，并在完成时调用 `getOrders()`。
- en: We’ll use the `await` keyword in the lines where we invoke `getCustomers()`
    and `getOrders()` so the code will wait for each of these functions to complete
    before continuing execution. We’ll mark the `getCustomersOrders()` function with
    the `async` keyword because it’ll use `await` inside. The following listing declares
    and invokes the function `getCustomersOrders()`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在调用 `getCustomers()` 和 `getOrders()` 的行中使用 `await` 关键字，这样代码将在继续执行之前等待每个函数完成。我们将使用
    `async` 关键字标记 `getCustomersOrders()` 函数，因为它将在内部使用 `await`。以下列表声明并调用了函数 `getCustomersOrders()`。
- en: Listing A.17\. Declaring and invoking an `async` function
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.17\. 声明和调用 `async` 函数
- en: '[PRE92]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Declares the function with the async keyword**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 `async` 关键字声明函数**'
- en: '***2* Invokes the asynchronous function getCustomers() with await so the code
    below won’t be executed until the function completes**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 `await` 调用异步函数 `getCustomers()`，这样下面的代码在函数完成之前不会执行**'
- en: '***3* Invokes the asynchronous function getOrders() with await so the code
    below won’t be executed until the function completes**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用await调用异步函数getOrders()，因此下面的代码将在函数完成之前不会执行**'
- en: '***4* Handles errors**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理错误**'
- en: '***5* This code runs outside of the async function.**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 此代码在异步函数外部运行。**'
- en: As you see, this code looks as if it’s synchronous. It has no callbacks and
    is executed line by line. Error processing is done in a standard way using the
    `try`/`catch` block.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，此代码看起来像是同步的。它没有回调，并且逐行执行。错误处理使用标准的`try`/`catch`块进行。
- en: 'Running this code will produce the following output:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE93]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that the message about the last line of code is printed before the name
    of the customer and the order number. Even though these values are retrieved asynchronously
    a bit later, the execution of this small app wasn’t blocked, and the script reached
    the last line before the async functions `getCustomers()` and `getOrders()` finished
    their execution.^([[20](#app01fn20)])
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到关于代码最后一行的消息是在客户名称和订单号之前打印的。尽管这些值稍后异步检索，但这个小应用程序的执行没有被阻塞，脚本在异步函数`getCustomers()`和`getOrders()`完成执行之前已经到达了最后一行.^([[20](#app01fn20)])
- en: ^(20)
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(20)
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See it in CodePen: [http://mng.bz/pSV8](http://mng.bz/pSV8).'
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在CodePen中查看：[http://mng.bz/pSV8](http://mng.bz/pSV8)。
- en: A.13\. ES6 modules
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.13\. ES6模块
- en: In any programming language, splitting code into modules helps organize the
    application into logical and possibly reusable units. Modularized applications
    allow programming tasks to be split between software developers more efficiently.
    Developers get to decide which API should be exposed by the module for external
    use and which should be used internally.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，将代码拆分为模块有助于将应用程序组织成逻辑上可能可重用的单元。模块化应用程序允许软件开发者更有效地将编程任务分配给多个开发者。开发者可以决定哪些API应该由模块对外暴露，哪些应该内部使用。
- en: 'ES5 doesn’t have language constructs for creating modules, so we have to resort
    to one of these options:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ES5没有用于创建模块的语言结构，因此我们必须求助于以下选项之一：
- en: Manually implement a module design pattern as an immediately initialized function.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动实现一个模块设计模式作为立即初始化的函数。
- en: Use third-party implementations of the AMD ([http://mng.bz/JKVc](http://mng.bz/JKVc))
    or CommonJS ([http://mng.bz/7Lld](http://mng.bz/7Lld)) standard.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AMD ([http://mng.bz/JKVc](http://mng.bz/JKVc)) 或 CommonJS ([http://mng.bz/7Lld](http://mng.bz/7Lld))
    标准的第三方实现。
- en: CommonJS was created for modularizing JavaScript applications that run outside
    the web browser (such as those written in Node.js and deployed under Google’s
    V8 engine). AMD is primarily used for applications that run in a web browser.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS是为了模块化在浏览器外运行的JavaScript应用程序（如Node.js中编写的那些，在Google的V8引擎下部署）而创建的。AMD主要用于在浏览器中运行的应用程序。
- en: You should split your app into modules to make your code more maintainable.
    Besides that, you should minimize the amount of JavaScript code loaded to the
    client on app startup. Imagine a typical online store. Do you need to load the
    code for processing payments when users open the application’s home page? What
    if they never click the Place Order button? It would be nice to modularize the
    application so the code is loaded on an as-needed basis. RequireJS is probably
    the most popular third-party library that implements the AMD standard; it lets
    you define dependencies between modules and load them on the browser on demand.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将你的应用程序拆分为模块，以使你的代码更易于维护。除此之外，你还应该最小化在应用程序启动时加载到客户端的JavaScript代码量。想象一下典型的在线商店。当用户打开应用程序的主页时，你需要加载处理支付的代码吗？如果他们从未点击“下订单”按钮呢？将应用程序模块化以便按需加载代码会很好。RequireJS可能是实现AMD标准的最受欢迎的第三方库；它允许你定义模块之间的依赖关系，并在浏览器中按需加载它们。
- en: Starting with ES6, modules have become part of the language, which means developers
    will stop using third-party libraries to implement various standards. A script
    becomes a module if it uses `import` and/or `export` keywords.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES6开始，模块已经成为语言的一部分，这意味着开发者将停止使用第三方库来实现各种标准。如果一个脚本使用了`import`和/或`export`关键字，它就成为一个模块。
- en: '|  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ES6 modules allow you to avoid polluting the global scope and restrict the visibility
    of the script and its members (classes, functions, variables, and constants) to
    those modules that import them.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块允许你避免污染全局作用域，并限制脚本及其成员（类、函数、变量和常量）的可见性，仅限于那些导入它们的模块。
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**ES6 modules and global scope**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES6模块和全局作用域**'
- en: 'Say we have a multifile project, and one of the files has the following content:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个多文件项目，其中一个文件包含以下内容：
- en: '[PRE94]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Because we didn’t export anything from this file, it’s not an ES6 module, and
    the instance of the `Person` class would be created in the global scope. If you
    already have another script in the same project that also declares the `Person`
    class, the Type-Script compiler will give you an error in the preceding code stating
    that you’re trying to declare a duplicate of what already exists.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有从这个文件导出任何内容，它不是一个 ES6 模块，`Person` 类的实例将在全局作用域中创建。如果你在同一项目中已经有另一个脚本也声明了
    `Person` 类，TypeScript 编译器将在前面的代码中给出错误，指出你正在尝试声明一个已存在的重复项。
- en: 'Adding the `export` statement to the preceding code changes the situation,
    and this script becomes a module:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中添加 `export` 语句会改变情况，并且这个脚本变成了一个模块：
- en: '[PRE95]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now objects of type `Person` won’t be created on the global scope, and their
    scope will be limited to only those scripts (other ES6 modules) that import `Person`.
    In [chapters 1](kindle_split_010.xhtml#ch01) and [2](kindle_split_011.xhtml#ch02),
    we introduce Angular modules that (in contrast to ES6 modules) serve as registries
    of Angular artifacts that belong together.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Person` 类型的对象不会在全局作用域中创建，它们的作用域将仅限于那些导入 `Person` 的脚本（其他 ES6 模块）。在第 [1](kindle_split_010.xhtml#ch01)
    和 [2](kindle_split_011.xhtml#ch02) 章中，我们介绍了 Angular 模块，这些模块（与 ES6 模块相反）作为属于一起的
    Angular 艺术品的注册表。
- en: '|  |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A.13.1\. import and export
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.13.1\. 导入和导出
- en: A *module* is just a JavaScript file that implements certain functionality and
    exports (or imports) a public API so other JavaScript programs can use it. There’s
    no special keyword to declare that the code in a particular file is a module.
    Just by using the keywords `import` and `export`, you turn a script into an ES6
    module.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *模块* 只是一个实现特定功能并导出（或导入）公共 API 的 JavaScript 文件，以便其他 JavaScript 程序可以使用它。没有特殊的关键字来声明特定文件中的代码是一个模块。只需使用
    `import` 和 `export` 关键字，你就可以将一个脚本转换为 ES6 模块。
- en: The `import` keyword enables one script to declare that it needs to use exported
    members from another script. Similarly, the `export` keyword lets you declare
    variables, functions, and classes that the module should be exposed to other scripts.
    Using the `export` keyword, you can make selected APIs available to other modules.
    A module’s functions, variables, and classes that aren’t explicitly exported remain
    private to the module.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 关键字使一个脚本能够声明它需要使用另一个脚本导出的成员。同样，`export` 关键字让你声明模块应该暴露给其他脚本的变量、函数和类。使用
    `export` 关键字，你可以使选定的 API 对其他模块可用。未明确导出的模块的函数、变量和类仍然是模块的私有成员。'
- en: 'ES6 offers two types of `export` usage: named and default. With named exports,
    you can use the `export` keyword in front of multiple members of the module (such
    as classes, functions, and variables). The code in the following file (tax.js)
    exports the `taxCode` variable and the functions `calcTaxes()` and `fileTaxes()`,
    but the `doSomethingElse()` function remains hidden to external scripts:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了两种 `export` 使用类型：命名和默认。使用命名导出，你可以在模块的多个成员（如类、函数和变量）之前使用 `export` 关键字。以下文件（tax.js）中的代码导出了
    `taxCode` 变量和 `calcTaxes()`、`fileTaxes()` 函数，但 `doSomethingElse()` 函数对外部脚本来说是隐藏的：
- en: '[PRE96]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When a script imports named, exported module members, their names must be placed
    in curly braces. The main.js file illustrates this:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个脚本导入命名的导出模块成员时，它们的名称必须放在大括号中。`main.js` 文件说明了这一点：
- en: '[PRE97]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, `tax` refers to the filename of the module, minus the file extension.
    The curly braces represent destructuring. The module from tax.js exports three
    members, but we’re interested in importing only `taxCode` and `calcTaxes`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tax` 指的是模块的文件名，减去文件扩展名。大括号表示解构。从 tax.js 导出的模块导出了三个成员，但我们只对导入 `taxCode`
    和 `calcTaxes` 感兴趣。
- en: 'One of the exported module members can be marked as `default`, which means
    this is an anonymous export, and another module can give it any name in its `import`
    statement. The my_module.js file that exports a function may look like this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将导出的模块成员之一标记为 `default`，这意味着这是一个匿名导出，另一个模块可以在其 `import` 语句中给它任何名称。导出函数的 my_module.js
    文件可能看起来像这样：
- en: '[PRE98]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* No semicolon**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无分号**'
- en: 'The main.js file imports both named and default exports while assigning the
    name `coolFunction` to the default one:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js` 文件在分配默认名称 `coolFunction` 给默认导出时同时导入了命名和默认导出：'
- en: '[PRE99]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Note that you don’t use curly braces around `coolFunction` (default export)
    but you do around `taxCode` (named export). A script that imports a class, variable,
    or function that was exported with the `default` keyword can give them new names
    without using any special keywords:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要在 `coolFunction`（默认导出）周围使用花括号，但需要在 `taxCode`（命名导出）周围使用。一个导入使用 `default`
    关键字导出的类、变量或函数的脚本可以给它们新的名称，而无需使用任何特殊的关键字：
- en: '[PRE100]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'But to give an alias name to a named export, we need to write something like
    this:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 但要给命名导出起别名，我们需要写点像这样：
- en: '[PRE101]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '`import` module statements don’t result in copying the exported code. Imports
    serve as references. A script that imports modules or members can’t modify them,
    and if the values in imported modules change, the new values are immediately reflected
    in all places where they were imported. We use the import statement in each chapter
    of this book, so you’ll have a chance to get a good feeling for how to use ES6
    modules.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 模块语句不会导致导出代码的复制。导入作为引用。一个导入模块或成员的脚本不能修改它们，如果导入模块中的值发生变化，新的值会立即反映在它们被导入的所有地方。我们在本书的每一章中都使用了导入语句，这样你就有机会很好地了解如何使用
    ES6 模块。'
- en: '|  |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don’t use default exports in Angular apps because you’ll get errors during ahead-of-time
    (AoT) compilation.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用中不要使用默认导出，因为在编译时（AoT）你将会遇到错误。
- en: '|  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '|  |'
